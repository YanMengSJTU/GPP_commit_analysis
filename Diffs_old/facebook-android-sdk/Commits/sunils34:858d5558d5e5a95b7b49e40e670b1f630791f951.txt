diff --git a/.gitignore b/.gitignore
index afd03db53..56fe04416 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,18 +2,14 @@
 *.DS_Store
 *.class
 *java#
-*.classpath
-*.project
 *.settings
-facebook/local.properties
-facebook/bin/
-facebook/gen/
-examples/Hackbook/bin/
-examples/Hackbook/gen/
-examples/Hackbook/local.properties
-examples/stream/bin/
-examples/simple/bin/
-examples/stream/gen/
-examples/simple/gen/
-tests/bin
-tests/gen
+local.properties
+.arc/
+bin/
+gen/
+out/
+facebook/doc/
+facebook/lint.xml
+facebook/tests/lint.xml
+facebook/tests/assets/config.json
+.idea/workspace.xml
diff --git a/.idea/.name b/.idea/.name
new file mode 100644
index 000000000..20f69a2ae
--- /dev/null
+++ b/.idea/.name
@@ -0,0 +1 @@
+android-sdk
\ No newline at end of file
diff --git a/.idea/ant.xml b/.idea/ant.xml
new file mode 100644
index 000000000..2581ca3fe
--- /dev/null
+++ b/.idea/ant.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="AntConfiguration">
+    <defaultAnt bundledAnt="true" />
+  </component>
+</project>
+
diff --git a/.idea/codeStyleSettings.xml b/.idea/codeStyleSettings.xml
new file mode 100644
index 000000000..3bf548318
--- /dev/null
+++ b/.idea/codeStyleSettings.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectCodeStyleSettingsManager">
+    <option name="PER_PROJECT_SETTINGS">
+      <value>
+        <XML>
+          <option name="XML_LEGACY_SETTINGS_IMPORTED" value="true" />
+        </XML>
+        <codeStyleSettings language="JAVA">
+          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="CALL_PARAMETERS_WRAP" value="1" />
+          <option name="METHOD_PARAMETERS_WRAP" value="1" />
+          <option name="METHOD_CALL_CHAIN_WRAP" value="1" />
+        </codeStyleSettings>
+      </value>
+    </option>
+    <option name="USE_PER_PROJECT_SETTINGS" value="true" />
+  </component>
+</project>
+
diff --git a/.idea/compiler.xml b/.idea/compiler.xml
new file mode 100644
index 000000000..b5ac196ca
--- /dev/null
+++ b/.idea/compiler.xml
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="CompilerConfiguration">
+    <option name="DEFAULT_COMPILER" value="Javac" />
+    <excludeFromCompile>
+      <directory url="file://$PROJECT_DIR$/facebook/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/JustLoginSample/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/JustRequestSample/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/examples/Hackbook/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/facebook/TestApp/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/facebook/tests/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/testtest/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/SessionLoginSample/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/FriendPickerSample/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/PlacePickerSample/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/BooleanOGSample/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/ProfilePictureSample/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/Scrumptious/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/SwitchUserSample/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/HelloFacebookSample/gen" includeSubdirectories="true" />
+    </excludeFromCompile>
+    <resourceExtensions />
+    <wildcardResourcePatterns>
+      <entry name="?*.properties" />
+      <entry name="?*.xml" />
+      <entry name="?*.gif" />
+      <entry name="?*.png" />
+      <entry name="?*.jpeg" />
+      <entry name="?*.jpg" />
+      <entry name="?*.html" />
+      <entry name="?*.dtd" />
+      <entry name="?*.tld" />
+      <entry name="?*.ftl" />
+    </wildcardResourcePatterns>
+    <annotationProcessing enabled="false" useClasspath="true" />
+  </component>
+</project>
+
diff --git a/.idea/copyright/profiles_settings.xml b/.idea/copyright/profiles_settings.xml
new file mode 100644
index 000000000..3572571ad
--- /dev/null
+++ b/.idea/copyright/profiles_settings.xml
@@ -0,0 +1,5 @@
+<component name="CopyrightManager">
+  <settings default="">
+    <module2copyright />
+  </settings>
+</component>
\ No newline at end of file
diff --git a/.idea/encodings.xml b/.idea/encodings.xml
new file mode 100644
index 000000000..e206d70d8
--- /dev/null
+++ b/.idea/encodings.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Encoding" useUTFGuessing="true" native2AsciiForPropertiesFiles="false" />
+</project>
+
diff --git a/.idea/libraries/android_support_v4.xml b/.idea/libraries/android_support_v4.xml
new file mode 100644
index 000000000..7abf0b359
--- /dev/null
+++ b/.idea/libraries/android_support_v4.xml
@@ -0,0 +1,19 @@
+<component name="libraryTable">
+  <library name="android-support-v4">
+    <CLASSES>
+      <root url="jar://$PROJECT_DIR$/libs/android-support-v4.jar!/" />
+    </CLASSES>
+    <JAVADOC />
+    <SOURCES>
+      <root url="file://$PROJECT_DIR$/../android-sdk-macosx/extras/android/support/v4/src/eclair" />
+      <root url="file://$PROJECT_DIR$/../android-sdk-macosx/extras/android/support/v4/src/froyo" />
+      <root url="file://$PROJECT_DIR$/../android-sdk-macosx/extras/android/support/v4/src/gingerbread" />
+      <root url="file://$PROJECT_DIR$/../android-sdk-macosx/extras/android/support/v4/src/honeycomb" />
+      <root url="file://$PROJECT_DIR$/../android-sdk-macosx/extras/android/support/v4/src/honeycomb_mr2" />
+      <root url="file://$PROJECT_DIR$/../android-sdk-macosx/extras/android/support/v4/src/ics" />
+      <root url="file://$PROJECT_DIR$/../android-sdk-macosx/extras/android/support/v4/src/ics-mr1" />
+      <root url="file://$PROJECT_DIR$/../android-sdk-macosx/extras/android/support/v4/src/java" />
+      <root url="file://$PROJECT_DIR$/../android-sdk-macosx/extras/android/support/v4/src/jellybean" />
+    </SOURCES>
+  </library>
+</component>
\ No newline at end of file
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
index 000000000..95a5c34d4
--- /dev/null
+++ b/.idea/misc.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="EntryPointsManager">
+    <entry_points version="2.0" />
+  </component>
+  <component name="JavadocGenerationManager">
+    <option name="OUTPUT_DIRECTORY" value="$USER_HOME$/tmp/javadoc.out" />
+    <option name="OPTION_SCOPE" value="protected" />
+    <option name="OPTION_HIERARCHY" value="true" />
+    <option name="OPTION_NAVIGATOR" value="true" />
+    <option name="OPTION_INDEX" value="true" />
+    <option name="OPTION_SEPARATE_INDEX" value="true" />
+    <option name="OPTION_DOCUMENT_TAG_USE" value="false" />
+    <option name="OPTION_DOCUMENT_TAG_AUTHOR" value="false" />
+    <option name="OPTION_DOCUMENT_TAG_VERSION" value="false" />
+    <option name="OPTION_DOCUMENT_TAG_DEPRECATED" value="true" />
+    <option name="OPTION_DEPRECATED_LIST" value="true" />
+    <option name="OTHER_OPTIONS" />
+    <option name="HEAP_SIZE" />
+    <option name="LOCALE" />
+    <option name="OPEN_IN_BROWSER" value="true" />
+    <option name="OPTION_INCLUDE_LIBS" value="false" />
+  </component>
+  <component name="ProjectResources">
+    <default-html-doctype>http://www.w3.org/1999/xhtml</default-html-doctype>
+  </component>
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_6" assert-keyword="true" jdk-15="true" project-jdk-name="Android 2.2 Platform" project-jdk-type="Android SDK">
+    <output url="file://$PROJECT_DIR$/out" />
+  </component>
+</project>
+
diff --git a/.idea/modules.xml b/.idea/modules.xml
new file mode 100644
index 000000000..c9eb2bbdd
--- /dev/null
+++ b/.idea/modules.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/samples/BooleanOGSample/BooleanOGSample.iml" filepath="$PROJECT_DIR$/samples/BooleanOGSample/BooleanOGSample.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/FriendPickerSample/FriendPickerSample.iml" filepath="$PROJECT_DIR$/samples/FriendPickerSample/FriendPickerSample.iml" />
+      <module fileurl="file://$PROJECT_DIR$/examples/Hackbook/Hackbook.iml" filepath="$PROJECT_DIR$/examples/Hackbook/Hackbook.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/HelloFacebookSample/HelloFacebookSample.iml" filepath="$PROJECT_DIR$/samples/HelloFacebookSample/HelloFacebookSample.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/JustRequestSample/JustRequestSample.iml" filepath="$PROJECT_DIR$/samples/JustRequestSample/JustRequestSample.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/PlacePickerSample/PlacePickerSample.iml" filepath="$PROJECT_DIR$/samples/PlacePickerSample/PlacePickerSample.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/ProfilePictureSample/ProfilePictureSample.iml" filepath="$PROJECT_DIR$/samples/ProfilePictureSample/ProfilePictureSample.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/Scrumptious/Scrumptious.iml" filepath="$PROJECT_DIR$/samples/Scrumptious/Scrumptious.iml" />
+      <module fileurl="file://$PROJECT_DIR$/facebook/TestApp/SdkTestApp.iml" filepath="$PROJECT_DIR$/facebook/TestApp/SdkTestApp.iml" />
+      <module fileurl="file://$PROJECT_DIR$/facebook/tests/SdkTests.iml" filepath="$PROJECT_DIR$/facebook/tests/SdkTests.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/SessionLoginSample/SessionLoginSample.iml" filepath="$PROJECT_DIR$/samples/SessionLoginSample/SessionLoginSample.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/SwitchUserSample/SwitchUserSample.iml" filepath="$PROJECT_DIR$/samples/SwitchUserSample/SwitchUserSample.iml" />
+      <module fileurl="file://$PROJECT_DIR$/facebook/android-sdk.iml" filepath="$PROJECT_DIR$/facebook/android-sdk.iml" />
+    </modules>
+  </component>
+</project>
+
diff --git a/.idea/runConfigurations/SdkTests.xml b/.idea/runConfigurations/SdkTests.xml
new file mode 100644
index 000000000..def33dc66
--- /dev/null
+++ b/.idea/runConfigurations/SdkTests.xml
@@ -0,0 +1,23 @@
+<component name="ProjectRunConfigurationManager">
+  <configuration default="false" name="SdkTests" type="AndroidTestRunConfigurationType" factoryName="Android Tests">
+    <module name="SdkTests" />
+    <option name="TESTING_TYPE" value="0" />
+    <option name="INSTRUMENTATION_RUNNER_CLASS" value="" />
+    <option name="METHOD_NAME" value="" />
+    <option name="CLASS_NAME" value="" />
+    <option name="PACKAGE_NAME" value="" />
+    <option name="TARGET_SELECTION_MODE" value="EMULATOR" />
+    <option name="PREFERRED_AVD" value="and4.0.3x86" />
+    <option name="COMMAND_LINE" value="" />
+    <option name="WIPE_USER_DATA" value="false" />
+    <option name="DISABLE_BOOT_ANIMATION" value="false" />
+    <option name="NETWORK_SPEED" value="full" />
+    <option name="NETWORK_LATENCY" value="none" />
+    <option name="CLEAR_LOGCAT" value="false" />
+    <RunnerSettings RunnerId="AndroidDebugRunner" />
+    <RunnerSettings RunnerId="Run" />
+    <ConfigurationWrapper RunnerId="AndroidDebugRunner" />
+    <ConfigurationWrapper RunnerId="Run" />
+    <method />
+  </configuration>
+</component>
\ No newline at end of file
diff --git a/.idea/scopes/scope_settings.xml b/.idea/scopes/scope_settings.xml
new file mode 100644
index 000000000..922003b84
--- /dev/null
+++ b/.idea/scopes/scope_settings.xml
@@ -0,0 +1,5 @@
+<component name="DependencyValidationManager">
+  <state>
+    <option name="SKIP_IMPORT_STATEMENTS" value="false" />
+  </state>
+</component>
\ No newline at end of file
diff --git a/.idea/uiDesigner.xml b/.idea/uiDesigner.xml
new file mode 100644
index 000000000..3b0002030
--- /dev/null
+++ b/.idea/uiDesigner.xml
@@ -0,0 +1,125 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Palette2">
+    <group name="Swing">
+      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />
+      </item>
+      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />
+      </item>
+      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.png" removable="false" auto-create-binding="false" can-attach-label="true">
+        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />
+        <initial-values>
+          <property name="text" value="Button" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="RadioButton" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="CheckBox" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="Label" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
+          <preferred-size width="200" height="200" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
+          <preferred-size width="200" height="200" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />
+      </item>
+      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">
+          <preferred-size width="-1" height="20" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />
+      </item>
+      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />
+      </item>
+    </group>
+  </component>
+</project>
+
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
index 000000000..9d32e507a
--- /dev/null
+++ b/.idea/vcs.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="" vcs="" />
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+  </component>
+</project>
+
diff --git a/CONTRIBUTING.mdown b/CONTRIBUTING.mdown
new file mode 100644
index 000000000..ec5ea367e
--- /dev/null
+++ b/CONTRIBUTING.mdown
@@ -0,0 +1,15 @@
+Facebook welcomes contributions to our SDKs.
+
+All contributors must sign a CLA (contributor license agreement) here:
+
+  https://developers.facebook.com/opensource/cla
+
+To contribute on behalf of your employer, sign the company CLA
+To contribute on behalf of yourself, sign the individual CLA
+
+All contributions:
+
+1/ MUST be be licensed using the Apache License, Version 2.0  
+2/ authors MAY retain copyright by adding their copyright notice to the appropriate flies 
+
+More information on the Apache License can be found here: http://www.apache.org/foundation/license-faq.html
diff --git a/LICENSE.txt b/LICENSE.txt
new file mode 100644
index 000000000..261eeb9e9
--- /dev/null
+++ b/LICENSE.txt
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/NOTICE.txt b/NOTICE.txt
new file mode 100644
index 000000000..8a7b5c546
--- /dev/null
+++ b/NOTICE.txt
@@ -0,0 +1,61 @@
+THE FOLLOWING SETS FORTH ATTRIBUTION NOTICES FOR THIRD PARTY SOFTWARE THAT MAY BE CONTAINED IN PORTIONS OF THE FACEBOOK PRODUCT.
+
+-----
+
+The following software may be included in this product: Android. This software contains the following license and notice below:
+
+Apache License
+Version 2.0, January 2004
+http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+1. Definitions.
+
+"License" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.
+
+"Licensor" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.
+
+"Legal Entity" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, "control" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.
+
+"You" (or "Your") shall mean an individual or Legal Entity exercising permissions granted by this License.
+
+"Source" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.
+
+"Object" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.
+
+"Work" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).
+
+"Derivative Works" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.
+
+"Contribution" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, "submitted" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as "Not a Contribution."
+
+"Contributor" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.
+
+2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.
+
+3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.
+
+4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:
+
+(a) You must give any other recipients of the Work or Derivative Works a copy of this License; and
+
+(b) You must cause any modified files to carry prominent notices stating that You changed the files; and
+
+(c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and
+
+(d) If the Work includes a "NOTICE" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.
+
+You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.
+
+5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.
+
+6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.
+
+7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.
+
+8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.
+
+9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.
+
+END OF TERMS AND CONDITIONS
diff --git a/README.md b/README.md
deleted file mode 100644
index 3a9fc9cd5..000000000
--- a/README.md
+++ /dev/null
@@ -1,33 +0,0 @@
-This open source Java library allows you to integrate Facebook into your Android application. Except as otherwise noted, the Facebook Android SDK is licensed under the Apache License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0.html)
-
-Getting Started
-===============
-
-See our [Android SDK Getting Started Guide](https://developers.facebook.com/docs/mobile/android/build/)
-
-Sample Applications
-===============
-
-This library includes three sample applications to guide you in development.
-
-* __simple__: A bare-bones app that demonstrates authorization, making API calls, and invoking a dialog.
-
-* __stream__: This slightly beefier application lets you view your news feed.
-
-* __Hackbook__: This includes Single Sign On implementation (SSO), sample API calls, and advanced features like Get new Permissions, Run sample FQL Query and Graph API Explorer. Check out [Hackbook for Android](https://developers.facebook.com/docs/mobile/android/hackbook/)
-
-Developer Terms
-===============
-* By enabling Facebook integrations, including through this SDK, you can share information with Facebook, including information about people’s use of your app. Facebook will use information received in accordance with our Data Use Policy [https://www.facebook.com/about/privacy/], including to provide you with insights about the effectiveness of your ads and the use of your app.  These integrations also enable us and our partners to serve ads on and off Facebook.
-
-* You may limit your sharing of information with us by updating the Insights control in the developer tool [https://developers.facebook.com/apps/YOUR_APP_ID/advanced].
-
-* If you use a Facebook integration, including to share information with us, you agree and confirm that you have provided appropriate and sufficiently prominent notice to and obtained the appropriate consent from your users regarding such collection, use, and disclosure (including, at a minimum, through your privacy policy). You further agree that you will not share information with us about children under the age of 13.
-
-* You agree to comply with all applicable laws and regulations and also agree to our Terms <https://www.facebook.com/policies/>, including our Platform Policies <https://developers.facebook.com/policy/>.and Advertising Guidelines, as applicable <https://www.facebook.com/ad_guidelines.php>.
-
-Report Issues/Bugs
-===============
-[Bugs](https://developers.facebook.com/bugs)
-
-[Questions](http://facebook.stackoverflow.com/questions/tagged/android)
diff --git a/README.mdown b/README.mdown
new file mode 100644
index 000000000..7e4bb9b02
--- /dev/null
+++ b/README.mdown
@@ -0,0 +1,32 @@
+Facebook SDK for Android
+========================
+
+This open-source library allows you to integrate Facebook into your Android app.
+
+Learn more about about the provided samples, documentation, integrating the SDK into your app, accessing source code, and more at https://developers.facebook.com/android-beta
+
+TRY IT OUT
+
+1. Test your install; build and run the project at facebook-android-sdk-3.0.b/samples/HelloFacebookSample (To avoid test signing issues, run this on a device that does not have Facebook for Android installed, or debug the signed sample binaries provided in facebook-android-sdk-3.0.b/bin)
+
+2. Check-out the tutorials available online at https://developers.facebook.com/docs/getting-started/facebook-sdk-for-android/3.0/
+
+3. Start coding! Visit https://developers.facebook.com/android-beta for tutorials and reference documentation.
+
+LICENSE
+
+Except as otherwise noted, the Facebook SDK for Android is licensed under the Apache License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0.html).
+
+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the specific language governing permissions and limitations under the License.
+
+DEVELOPER TERMS
+
+- By enabling Facebook integrations, including through this SDK, you can share information with Facebook, including information about people’s use of your app. Facebook will use information received in accordance with our Data Use Policy (https://www.facebook.com/about/privacy/), including to provide you with insights about the effectiveness of your ads and the use of your app.  These integrations also enable us and our partners to serve ads on and off Facebook.
+
+- You may limit your sharing of information with us by updating the Insights control in the developer tool (https://developers.facebook.com/apps/<app_id>/advanced).
+
+- If you use a Facebook integration, including to share information with us, you agree and confirm that you have provided appropriate and sufficiently prominent notice to and obtained the appropriate consent from your users regarding such collection, use, and disclosure (including, at a minimum, through your privacy policy). You further agree that you will not share information with us about children under the age of 13.
+
+- You agree to comply with all applicable laws and regulations and also agree to our Terms (https://www.facebook.com/policies/), including our Platform Policies (https://developers.facebook.com/policy/) and Advertising Guidelines, as applicable (https://www.facebook.com/ad_guidelines.php).
+
+By using the Facebook SDK for Android you agree to these terms.
diff --git a/examples/simple/AndroidManifest.xml b/examples/simple/AndroidManifest.xml
deleted file mode 100644
index f647de1aa..000000000
--- a/examples/simple/AndroidManifest.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-	package="com.facebook.android" 
-	android:versionCode="1"
-	android:versionName="1.0">
-	<application android:icon="@drawable/icon" 
-	    android:label="@string/app_name"
-		android:debuggable="true">
-		<activity android:name=".Example" 
-		    android:label="@string/app_name"
-		    android:configChanges="keyboardHidden">
-			<intent-filter>
-				<action android:name="android.intent.action.MAIN" />
-				<category android:name="android.intent.category.LAUNCHER" />
-			</intent-filter>
-		</activity>
-	</application>
-	<uses-permission android:name="android.permission.INTERNET"></uses-permission>
-	<uses-sdk android:minSdkVersion="3"/>
-</manifest> 
\ No newline at end of file
diff --git a/examples/simple/default.properties b/examples/simple/default.properties
deleted file mode 100644
index 0f4dfe443..000000000
--- a/examples/simple/default.properties
+++ /dev/null
@@ -1,14 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-# 
-# This file must be checked in Version Control Systems.
-# 
-# To customize properties used by the Ant build system use,
-# "build.properties", and override values to adapt the script to your
-# project structure.
-
-# Indicates whether an apk should be generated for each density.
-split.density=false
-android.library.reference.1=../../facebook/
-# Project target.
-target=android-3
diff --git a/examples/simple/res/drawable/login.png b/examples/simple/res/drawable/login.png
deleted file mode 100644
index 95c8dc156..000000000
Binary files a/examples/simple/res/drawable/login.png and /dev/null differ
diff --git a/examples/simple/res/drawable/login_button.xml b/examples/simple/res/drawable/login_button.xml
deleted file mode 100644
index 73dc6c3ab..000000000
--- a/examples/simple/res/drawable/login_button.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<selector xmlns:android="http://schemas.android.com/apk/res/android">
-	<item android:state_pressed="true" android:drawable="@drawable/login_down" />
-	<item android:drawable="@drawable/login" /> <!-- default -->
-</selector>
\ No newline at end of file
diff --git a/examples/simple/res/drawable/login_down.png b/examples/simple/res/drawable/login_down.png
deleted file mode 100644
index 10d216b3f..000000000
Binary files a/examples/simple/res/drawable/login_down.png and /dev/null differ
diff --git a/examples/simple/res/drawable/logout.png b/examples/simple/res/drawable/logout.png
deleted file mode 100644
index 290272aa0..000000000
Binary files a/examples/simple/res/drawable/logout.png and /dev/null differ
diff --git a/examples/simple/res/drawable/logout_button.xml b/examples/simple/res/drawable/logout_button.xml
deleted file mode 100644
index 58f57656b..000000000
--- a/examples/simple/res/drawable/logout_button.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<selector xmlns:android="http://schemas.android.com/apk/res/android">
-    <item android:state_pressed="true" android:drawable="@drawable/logout_down" />
-    <item android:drawable="@drawable/logout" /> <!-- default -->
-</selector>
\ No newline at end of file
diff --git a/examples/simple/res/drawable/logout_down.png b/examples/simple/res/drawable/logout_down.png
deleted file mode 100644
index 1ab14b9dc..000000000
Binary files a/examples/simple/res/drawable/logout_down.png and /dev/null differ
diff --git a/examples/simple/res/layout/main.xml b/examples/simple/res/layout/main.xml
deleted file mode 100644
index b73286a71..000000000
--- a/examples/simple/res/layout/main.xml
+++ /dev/null
@@ -1,65 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-	android:orientation="vertical" android:layout_width="fill_parent"
-	android:layout_height="fill_parent" android:background="@drawable/white"
-	android:gravity="center_horizontal">
-
-    <com.facebook.android.LoginButton
-        android:id="@+id/login"
-        android:src="@drawable/login_button"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content" 
-        android:layout_margin="30dp"
-        />
-
-	<TextView android:id="@+id/txt" 
-        android:text="@string/hello"
-        android:textColor="@drawable/black"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-		/>
-		
-	<Button android:id="@+id/uploadButton"
-        android:text="@string/upload"
-        android:visibility="invisible"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content" 
-        android:paddingRight="20dp" 
-        android:paddingLeft="20dp"
-        android:layout_margin="20dp" 
-        />
-        
-	<Button android:id="@+id/requestButton"
-        android:text="@string/request"
-        android:visibility="invisible"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content" 
-        android:paddingRight="20dp" 
-        android:paddingLeft="20dp"
-        android:layout_margin="20dp" 
-        />
-
-
-	<Button android:id="@+id/postButton" 
-        android:text="@string/post"
-        android:visibility="invisible"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content" 
-        android:paddingRight="20dp" 
-        android:paddingLeft="20dp"
-        android:layout_margin="20dp" 
-		/>
-		
-    <Button android:id="@+id/deletePostButton" 
-        android:text="@string/delete"
-        android:visibility="invisible"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content" 
-        android:paddingRight="20dp" 
-        android:paddingLeft="20dp"
-        android:layout_margin="20dp" 
-        />
-
-
-
-</LinearLayout>
\ No newline at end of file
diff --git a/examples/simple/res/values/colors.xml b/examples/simple/res/values/colors.xml
deleted file mode 100644
index 2aa7e8e36..000000000
--- a/examples/simple/res/values/colors.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <drawable name="white">#ffffff</drawable>
-    <drawable name="black">#000000</drawable>
-</resources>
\ No newline at end of file
diff --git a/examples/simple/res/values/strings.xml b/examples/simple/res/values/strings.xml
deleted file mode 100644
index ced6f8b47..000000000
--- a/examples/simple/res/values/strings.xml
+++ /dev/null
@@ -1,10 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <string name="app_name">Facebook SDK Example</string>
-    <string name="request">Request!</string>
-    <string name="hello">Hello World!</string>
-    <string name="upload">Upload Photo</string><string name="post">Wall Post!</string>
-    <string name="delete">Delete Post</string>
-
-
-</resources>
diff --git a/examples/simple/src/com/facebook/android/BaseDialogListener.java b/examples/simple/src/com/facebook/android/BaseDialogListener.java
deleted file mode 100644
index 6b4b9453d..000000000
--- a/examples/simple/src/com/facebook/android/BaseDialogListener.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package com.facebook.android;
-
-import com.facebook.android.Facebook.DialogListener;
-
-/**
- * Skeleton base class for RequestListeners, providing default error 
- * handling. Applications should handle these error conditions.
- *
- */
-public abstract class BaseDialogListener implements DialogListener {
-
-    public void onFacebookError(FacebookError e) {
-        e.printStackTrace();
-    }
-
-    public void onError(DialogError e) {
-        e.printStackTrace();        
-    }
-
-    public void onCancel() {        
-    }
-    
-}
diff --git a/examples/simple/src/com/facebook/android/BaseRequestListener.java b/examples/simple/src/com/facebook/android/BaseRequestListener.java
deleted file mode 100644
index bd0f80f99..000000000
--- a/examples/simple/src/com/facebook/android/BaseRequestListener.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package com.facebook.android;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.net.MalformedURLException;
-
-import android.util.Log;
-
-import com.facebook.android.AsyncFacebookRunner.RequestListener;
-
-/**
- * Skeleton base class for RequestListeners, providing default error 
- * handling. Applications should handle these error conditions.
- *
- */
-public abstract class BaseRequestListener implements RequestListener {
-
-    public void onFacebookError(FacebookError e, final Object state) {
-        Log.e("Facebook", e.getMessage());
-        e.printStackTrace();
-    }
-
-    public void onFileNotFoundException(FileNotFoundException e,
-                                        final Object state) {
-        Log.e("Facebook", e.getMessage());
-        e.printStackTrace();
-    }
-
-    public void onIOException(IOException e, final Object state) {
-        Log.e("Facebook", e.getMessage());
-        e.printStackTrace();
-    }
-
-    public void onMalformedURLException(MalformedURLException e,
-                                        final Object state) {
-        Log.e("Facebook", e.getMessage());
-        e.printStackTrace();
-    }
-    
-}
diff --git a/examples/simple/src/com/facebook/android/Example.java b/examples/simple/src/com/facebook/android/Example.java
deleted file mode 100644
index 54db7d58e..000000000
--- a/examples/simple/src/com/facebook/android/Example.java
+++ /dev/null
@@ -1,281 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.MalformedURLException;
-import java.net.URL;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.widget.Button;
-import android.widget.TextView;
-
-import com.facebook.android.SessionEvents.AuthListener;
-import com.facebook.android.SessionEvents.LogoutListener;
-
-
-public class Example extends Activity {
-
-    // Your Facebook Application ID must be set before running this example
-    // See http://www.facebook.com/developers/createapp.php
-    public static final String APP_ID = "175729095772478";
-
-    private LoginButton mLoginButton;
-    private TextView mText;
-    private Button mRequestButton;
-    private Button mPostButton;
-    private Button mDeleteButton;
-    private Button mUploadButton;
-
-    private Facebook mFacebook;
-    private AsyncFacebookRunner mAsyncRunner;
-
-    /** Called when the activity is first created. */
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        if (APP_ID == null) {
-            Util.showAlert(this, "Warning", "Facebook Applicaton ID must be " +
-                    "specified before running this example: see Example.java");
-        }
-
-        setContentView(R.layout.main);
-        mLoginButton = (LoginButton) findViewById(R.id.login);
-        mText = (TextView) Example.this.findViewById(R.id.txt);
-        mRequestButton = (Button) findViewById(R.id.requestButton);
-        mPostButton = (Button) findViewById(R.id.postButton);
-        mDeleteButton = (Button) findViewById(R.id.deletePostButton);
-        mUploadButton = (Button) findViewById(R.id.uploadButton);
-
-       	mFacebook = new Facebook(APP_ID);
-       	mAsyncRunner = new AsyncFacebookRunner(mFacebook);
-
-        SessionStore.restore(mFacebook, this);
-        SessionEvents.addAuthListener(new SampleAuthListener());
-        SessionEvents.addLogoutListener(new SampleLogoutListener());
-        mLoginButton.init(this, mFacebook);
-
-        mRequestButton.setOnClickListener(new OnClickListener() {
-            public void onClick(View v) {
-            	mAsyncRunner.request("me", new SampleRequestListener());
-            }
-        });
-        mRequestButton.setVisibility(mFacebook.isSessionValid() ?
-                View.VISIBLE :
-                View.INVISIBLE);
-
-        mUploadButton.setOnClickListener(new OnClickListener() {
-            public void onClick(View v) {
-                Bundle params = new Bundle();
-                params.putString("method", "photos.upload");
-
-                URL uploadFileUrl = null;
-                try {
-                    uploadFileUrl = new URL(
-                        "http://www.facebook.com/images/devsite/iphone_connect_btn.jpg");
-                } catch (MalformedURLException e) {
-                	e.printStackTrace();
-                }
-                try {
-                    HttpURLConnection conn= (HttpURLConnection)uploadFileUrl.openConnection();
-                    conn.setDoInput(true);
-                    conn.connect();
-                    int length = conn.getContentLength();
-
-                    byte[] imgData =new byte[length];
-                    InputStream is = conn.getInputStream();
-                    is.read(imgData);
-                    params.putByteArray("picture", imgData);
-
-                } catch  (IOException e) {
-                    e.printStackTrace();
-                }
-
-                mAsyncRunner.request(null, params, "POST",
-                        new SampleUploadListener(), null);
-            }
-        });
-        mUploadButton.setVisibility(mFacebook.isSessionValid() ?
-                View.VISIBLE :
-                View.INVISIBLE);
-
-        mPostButton.setOnClickListener(new OnClickListener() {
-            public void onClick(View v) {
-                mFacebook.dialog(Example.this, "feed",
-                        new SampleDialogListener());
-            }
-        });
-        mPostButton.setVisibility(mFacebook.isSessionValid() ?
-                View.VISIBLE :
-                View.INVISIBLE);
-    }
-
-    @Override
-    protected void onActivityResult(int requestCode, int resultCode,
-                                    Intent data) {
-        mFacebook.authorizeCallback(requestCode, resultCode, data);
-    }
-
-    public class SampleAuthListener implements AuthListener {
-
-        public void onAuthSucceed() {
-            mText.setText("You have logged in! ");
-            mRequestButton.setVisibility(View.VISIBLE);
-            mUploadButton.setVisibility(View.VISIBLE);
-            mPostButton.setVisibility(View.VISIBLE);
-        }
-
-        public void onAuthFail(String error) {
-            mText.setText("Login Failed: " + error);
-        }
-    }
-
-    public class SampleLogoutListener implements LogoutListener {
-        public void onLogoutBegin() {
-            mText.setText("Logging out...");
-        }
-
-        public void onLogoutFinish() {
-            mText.setText("You have logged out! ");
-            mRequestButton.setVisibility(View.INVISIBLE);
-            mUploadButton.setVisibility(View.INVISIBLE);
-            mPostButton.setVisibility(View.INVISIBLE);
-        }
-    }
-
-    public class SampleRequestListener extends BaseRequestListener {
-
-        public void onComplete(final String response, final Object state) {
-            try {
-                // process the response here: executed in background thread
-                Log.d("Facebook-Example", "Response: " + response.toString());
-                JSONObject json = Util.parseJson(response);
-                final String name = json.getString("name");
-
-                // then post the processed result back to the UI thread
-                // if we do not do this, an runtime exception will be generated
-                // e.g. "CalledFromWrongThreadException: Only the original
-                // thread that created a view hierarchy can touch its views."
-                Example.this.runOnUiThread(new Runnable() {
-                    public void run() {
-                        mText.setText("Hello there, " + name + "!");
-                    }
-                });
-            } catch (JSONException e) {
-                Log.w("Facebook-Example", "JSON Error in response");
-            } catch (FacebookError e) {
-                Log.w("Facebook-Example", "Facebook Error: " + e.getMessage());
-            }
-        }
-    }
-
-    public class SampleUploadListener extends BaseRequestListener {
-
-        public void onComplete(final String response, final Object state) {
-            try {
-                // process the response here: (executed in background thread)
-                Log.d("Facebook-Example", "Response: " + response.toString());
-                JSONObject json = Util.parseJson(response);
-                final String src = json.getString("src");
-
-                // then post the processed result back to the UI thread
-                // if we do not do this, an runtime exception will be generated
-                // e.g. "CalledFromWrongThreadException: Only the original
-                // thread that created a view hierarchy can touch its views."
-                Example.this.runOnUiThread(new Runnable() {
-                    public void run() {
-                        mText.setText("Hello there, photo has been uploaded at \n" + src);
-                    }
-                });
-            } catch (JSONException e) {
-                Log.w("Facebook-Example", "JSON Error in response");
-            } catch (FacebookError e) {
-                Log.w("Facebook-Example", "Facebook Error: " + e.getMessage());
-            }
-        }
-    }
-    public class WallPostRequestListener extends BaseRequestListener {
-
-        public void onComplete(final String response, final Object state) {
-            Log.d("Facebook-Example", "Got response: " + response);
-            String message = "<empty>";
-            try {
-                JSONObject json = Util.parseJson(response);
-                message = json.getString("message");
-            } catch (JSONException e) {
-                Log.w("Facebook-Example", "JSON Error in response");
-            } catch (FacebookError e) {
-                Log.w("Facebook-Example", "Facebook Error: " + e.getMessage());
-            }
-            final String text = "Your Wall Post: " + message;
-            Example.this.runOnUiThread(new Runnable() {
-                public void run() {
-                    mText.setText(text);
-                }
-            });
-        }
-    }
-
-    public class WallPostDeleteListener extends BaseRequestListener {
-
-        public void onComplete(final String response, final Object state) {
-            if (response.equals("true")) {
-                Log.d("Facebook-Example", "Successfully deleted wall post");
-                Example.this.runOnUiThread(new Runnable() {
-                    public void run() {
-                        mDeleteButton.setVisibility(View.INVISIBLE);
-                        mText.setText("Deleted Wall Post");
-                    }
-                });
-            } else {
-                Log.d("Facebook-Example", "Could not delete wall post");
-            }
-        }
-    }
-
-    public class SampleDialogListener extends BaseDialogListener {
-
-        public void onComplete(Bundle values) {
-            final String postId = values.getString("post_id");
-            if (postId != null) {
-                Log.d("Facebook-Example", "Dialog Success! post_id=" + postId);
-                mAsyncRunner.request(postId, new WallPostRequestListener());
-                mDeleteButton.setOnClickListener(new OnClickListener() {
-                    public void onClick(View v) {
-                        mAsyncRunner.request(postId, new Bundle(), "DELETE",
-                                new WallPostDeleteListener(), null);
-                    }
-                });
-                mDeleteButton.setVisibility(View.VISIBLE);
-            } else {
-                Log.d("Facebook-Example", "No wall post made");
-            }
-        }
-    }
-
-}
diff --git a/examples/simple/src/com/facebook/android/LoginButton.java b/examples/simple/src/com/facebook/android/LoginButton.java
deleted file mode 100644
index bd758f413..000000000
--- a/examples/simple/src/com/facebook/android/LoginButton.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android;
-
-import com.facebook.android.BaseRequestListener;
-import com.facebook.android.SessionEvents.AuthListener;
-import com.facebook.android.SessionEvents.LogoutListener;
-import com.facebook.android.Facebook.DialogListener;
-
-import android.app.Activity;
-import android.content.Context;
-import android.graphics.Color;
-import android.os.Bundle;
-import android.os.Handler;
-import android.util.AttributeSet;
-import android.view.View;
-import android.widget.ImageButton;
-
-public class LoginButton extends ImageButton {
-    
-    private Facebook mFb;
-    private Handler mHandler;
-    private SessionListener mSessionListener = new SessionListener();
-    private String[] mPermissions;
-    private Activity mActivity;
-    
-    public LoginButton(Context context) {
-        super(context);
-    }
-    
-    public LoginButton(Context context, AttributeSet attrs) {
-        super(context, attrs);
-    }
-    
-    public LoginButton(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-    }
-    
-    public void init(final Activity activity, final Facebook fb) {
-    	init(activity, fb, new String[] {});
-    }
-    
-    public void init(final Activity activity, final Facebook fb,
-                     final String[] permissions) {
-        mActivity = activity;
-        mFb = fb;
-        mPermissions = permissions;
-        mHandler = new Handler();
-        
-        setBackgroundColor(Color.TRANSPARENT);
-        setAdjustViewBounds(true);
-        setImageResource(fb.isSessionValid() ?
-                         R.drawable.logout_button : 
-                         R.drawable.login_button);
-        drawableStateChanged();
-        
-        SessionEvents.addAuthListener(mSessionListener);
-        SessionEvents.addLogoutListener(mSessionListener);
-        setOnClickListener(new ButtonOnClickListener());
-    }
-    
-    private final class ButtonOnClickListener implements OnClickListener {
-        
-        public void onClick(View arg0) {
-            if (mFb.isSessionValid()) {
-                SessionEvents.onLogoutBegin();
-                AsyncFacebookRunner asyncRunner = new AsyncFacebookRunner(mFb);
-                asyncRunner.logout(getContext(), new LogoutRequestListener());
-            } else {
-                mFb.authorize(mActivity, mPermissions,
-                              new LoginDialogListener());
-            }
-        }
-    }
-
-    private final class LoginDialogListener implements DialogListener {
-        public void onComplete(Bundle values) {
-            SessionEvents.onLoginSuccess();
-        }
-
-        public void onFacebookError(FacebookError error) {
-            SessionEvents.onLoginError(error.getMessage());
-        }
-        
-        public void onError(DialogError error) {
-            SessionEvents.onLoginError(error.getMessage());
-        }
-
-        public void onCancel() {
-            SessionEvents.onLoginError("Action Canceled");
-        }
-    }
-    
-    private class LogoutRequestListener extends BaseRequestListener {
-        public void onComplete(String response, final Object state) {
-            // callback should be run in the original thread, 
-            // not the background thread
-            mHandler.post(new Runnable() {
-                public void run() {
-                    SessionEvents.onLogoutFinish();
-                }
-            });
-        }
-    }
-    
-    private class SessionListener implements AuthListener, LogoutListener {
-        
-        public void onAuthSucceed() {
-            setImageResource(R.drawable.logout_button);
-            SessionStore.save(mFb, getContext());
-        }
-
-        public void onAuthFail(String error) {
-        }
-        
-        public void onLogoutBegin() {           
-        }
-        
-        public void onLogoutFinish() {
-            SessionStore.clear(getContext());
-            setImageResource(R.drawable.login_button);
-        }
-    }
-    
-}
diff --git a/examples/simple/src/com/facebook/android/SessionEvents.java b/examples/simple/src/com/facebook/android/SessionEvents.java
deleted file mode 100644
index 1351f88e1..000000000
--- a/examples/simple/src/com/facebook/android/SessionEvents.java
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android;
-
-import java.util.LinkedList;
-
-public class SessionEvents {
-
-    private static LinkedList<AuthListener> mAuthListeners = 
-        new LinkedList<AuthListener>();
-    private static LinkedList<LogoutListener> mLogoutListeners = 
-        new LinkedList<LogoutListener>();
-
-    /**
-     * Associate the given listener with this Facebook object. The listener's
-     * callback interface will be invoked when authentication events occur.
-     * 
-     * @param listener
-     *            The callback object for notifying the application when auth
-     *            events happen.
-     */
-    public static void addAuthListener(AuthListener listener) {
-        mAuthListeners.add(listener);
-    }
-
-    /**
-     * Remove the given listener from the list of those that will be notified
-     * when authentication events occur.
-     * 
-     * @param listener
-     *            The callback object for notifying the application when auth
-     *            events happen.
-     */
-    public static void removeAuthListener(AuthListener listener) {
-        mAuthListeners.remove(listener);
-    }
-
-    /**
-     * Associate the given listener with this Facebook object. The listener's
-     * callback interface will be invoked when logout occurs.
-     * 
-     * @param listener
-     *            The callback object for notifying the application when log out
-     *            starts and finishes.
-     */
-    public static void addLogoutListener(LogoutListener listener) {
-        mLogoutListeners.add(listener);
-    }
-
-    /**
-     * Remove the given listener from the list of those that will be notified
-     * when logout occurs.
-     * 
-     * @param listener
-     *            The callback object for notifying the application when log out
-     *            starts and finishes.
-     */
-    public static void removeLogoutListener(LogoutListener listener) {
-        mLogoutListeners.remove(listener);
-    }
-    
-    public static void onLoginSuccess() {
-        for (AuthListener listener : mAuthListeners) {
-            listener.onAuthSucceed();
-        }
-    }
-    
-    public static void onLoginError(String error) {
-        for (AuthListener listener : mAuthListeners) {
-            listener.onAuthFail(error);
-        }
-    }
-    
-    public static void onLogoutBegin() {
-        for (LogoutListener l : mLogoutListeners) {
-            l.onLogoutBegin();
-        }
-    }
-    
-    public static void onLogoutFinish() {
-        for (LogoutListener l : mLogoutListeners) {
-            l.onLogoutFinish();
-        }   
-    }
-    
-    /**
-     * Callback interface for authorization events.
-     *
-     */
-    public static interface AuthListener {
-
-        /**
-         * Called when a auth flow completes successfully and a valid OAuth 
-         * Token was received.
-         * 
-         * Executed by the thread that initiated the authentication.
-         * 
-         * API requests can now be made.
-         */
-        public void onAuthSucceed();
-
-        /**
-         * Called when a login completes unsuccessfully with an error. 
-         *  
-         * Executed by the thread that initiated the authentication.
-         */
-        public void onAuthFail(String error);
-    }
-    
-    /**
-     * Callback interface for logout events.
-     *
-     */ 
-    public static interface LogoutListener {
-        /**
-         * Called when logout begins, before session is invalidated.  
-         * Last chance to make an API call.  
-         * 
-         * Executed by the thread that initiated the logout.
-         */
-        public void onLogoutBegin();
-
-        /**
-         * Called when the session information has been cleared.
-         * UI should be updated to reflect logged-out state.
-         * 
-         * Executed by the thread that initiated the logout.
-         */
-        public void onLogoutFinish();
-    }
-    
-}
diff --git a/examples/simple/src/com/facebook/android/SessionStore.java b/examples/simple/src/com/facebook/android/SessionStore.java
deleted file mode 100644
index d65df66b9..000000000
--- a/examples/simple/src/com/facebook/android/SessionStore.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android;
-
-import com.facebook.android.Facebook;
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.content.SharedPreferences.Editor;
-
-public class SessionStore {
-    
-    private static final String TOKEN = "access_token";
-    private static final String EXPIRES = "expires_in";
-    private static final String KEY = "facebook-session";
-    
-    public static boolean save(Facebook session, Context context) {
-        Editor editor =
-            context.getSharedPreferences(KEY, Context.MODE_PRIVATE).edit();
-        editor.putString(TOKEN, session.getAccessToken());
-        editor.putLong(EXPIRES, session.getAccessExpires());
-        return editor.commit();
-    }
-
-    public static boolean restore(Facebook session, Context context) {
-        SharedPreferences savedSession =
-            context.getSharedPreferences(KEY, Context.MODE_PRIVATE);
-        session.setAccessToken(savedSession.getString(TOKEN, null));
-        session.setAccessExpires(savedSession.getLong(EXPIRES, 0));
-        return session.isSessionValid();
-    }
-
-    public static void clear(Context context) {
-        Editor editor = 
-            context.getSharedPreferences(KEY, Context.MODE_PRIVATE).edit();
-        editor.clear();
-        editor.commit();
-    }
-    
-}
diff --git a/examples/stream/AndroidManifest.xml b/examples/stream/AndroidManifest.xml
deleted file mode 100644
index 0f2493301..000000000
--- a/examples/stream/AndroidManifest.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-      android:versionCode="1"
-      android:versionName="1.0" package="com.facebook.stream">
-    <application android:icon="@drawable/icon" android:label="@string/app_name">
-        <activity android:name=".App"
-                  android:label="@string/app_name"
-                  android:screenOrientation="portrait"
-                  android:configChanges="keyboardHidden|orientation">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
-
-	<uses-permission android:name="android.permission.INTERNET" />
-	<uses-sdk android:minSdkVersion="3" />
-</manifest> 
\ No newline at end of file
diff --git a/examples/stream/assets/like_icon.png b/examples/stream/assets/like_icon.png
deleted file mode 100644
index 79ea76ec5..000000000
Binary files a/examples/stream/assets/like_icon.png and /dev/null differ
diff --git a/examples/stream/assets/login.css b/examples/stream/assets/login.css
deleted file mode 100644
index d1e3f2fc2..000000000
--- a/examples/stream/assets/login.css
+++ /dev/null
@@ -1,14 +0,0 @@
-#main {
-  width: 200px;
-  margin: 50% auto 0 auto;
-  text-align: center;
-}
-
-#welcome {
-  margin-bottom: 10px;
-}
-
-#login_button {
-  width: 91px;
-  margin: auto;
-}
\ No newline at end of file
diff --git a/examples/stream/assets/login.html b/examples/stream/assets/login.html
deleted file mode 100644
index 35e536994..000000000
--- a/examples/stream/assets/login.html
+++ /dev/null
@@ -1,13 +0,0 @@
-<html>
-<head>
-  <link rel="stylesheet" href="file:///android_asset/login.css" type="text/css"/>
-</head>
-<body>
-  <div id="main">
-    <div id="welcome">Welcome to Stream</div>
-    <div id="login_button">
-      <a onclick="app.login()"><img src="file:///android_asset/login_button.png" width="90" height="31"/></a>
-    </div>
-  </div>
-</body>
-</html>
\ No newline at end of file
diff --git a/examples/stream/assets/login_button.png b/examples/stream/assets/login_button.png
deleted file mode 100644
index 77bc30c27..000000000
Binary files a/examples/stream/assets/login_button.png and /dev/null differ
diff --git a/examples/stream/assets/stream.css b/examples/stream/assets/stream.css
deleted file mode 100644
index cb0d676f0..000000000
--- a/examples/stream/assets/stream.css
+++ /dev/null
@@ -1,118 +0,0 @@
-a {
-  color: #00f;
-}
-
-a:visited {
-  color: #00f;
-}
-
-.hidden {
-  display: none;
-}
-
-.clear {
-  clear: both
-}
-
-#header {
-  float: right;
-}
-
-input {
-  width: 80%;
-  height: 28px;
-  border: #666 solid 1px;
-  margin: 1px 3px 0 0;
-  float: left;
-}
-
-#status_box {
-  margin: 5px 0;
-}
-
-#status_input {
-  color: #666;
-  float: left;
-}
-
-.profile_pic_container {
-  float: left;
-  margin: 0 5px;
-}
-
-.profile_pic {
-  width: 30px;
-  height: 30px;
-}
-
-.attachment {
-  margin-top: 3px;
-}
-
-.title {
-  margin-bottom: 3px;
-}
-
-.caption {
-  margin-bottom: 3px;
-  color: #666;
-}
-
-.description {
-  color: #666;  
-} 
-
-.picture {
-  float: left;
-  margin-right: 5px;
-}
-
-.post {
-  padding: 10px 0;
-  border-bottom: #ccc solid 1px;
-}
-
-.action_links {
-  margin: 5px 0;
-}
-
-.action_link {
-  margin-right: 5px;
-  float: left;
-}
-
-
-.comment {
-  padding: 5px 0;
-  margin-bottom: 2px;
-  background-color: #eee;
-  min-height: 30px;
-}
-
-.comments {
-  margin-top: 5px;
-}
-
-.comment_box {
-  display: none;
-}
-
-.timestamp {
-  color: #666;
-}
-
-.like_icon {
-  float: left;
-  top: 3px;
-  position: relative;
-  margin-right: 5px;
-}
-
-.like_icon img {
-  width: 16px;
-  height: 14px;
-}
-
-.num_likes {
-  padding-left: 5px;
-}
\ No newline at end of file
diff --git a/examples/stream/assets/stream.js b/examples/stream/assets/stream.js
deleted file mode 100644
index 23c4809f4..000000000
--- a/examples/stream/assets/stream.js
+++ /dev/null
@@ -1,88 +0,0 @@
-function $(id) {
-  return document.getElementById(id);
-}
-
-function show(id) {
-  $(id).style.display = "block";
-}
-
-function hide(id) {
-  $(id).style.display = "none";
-}
-
-function onStatusBoxFocus(elt) {
-  elt.value = '';
-  elt.style.color = "#000";
-  show('status_submit');
-}
-
-function updateStatus() {
-  var message = $('status_input').value;
-  if (message == "") {
-    return;
-  }
-  $('status_input').disabled = true;
-  $('status_submit').disabled = true;
-  app.updateStatus(message);
-}
-
-function onStatusUpdated(html) {
-  $('status_input').disabled = false;
-  $('status_submit').disabled = false;
-  $('posts').innerHTML = html + $('posts').innerHTML;
-}
-
-function like(post_id) {
-  doLike(post_id, true);
- 
-}
-
-function unlike(post_id) {
-  doLike(post_id, false);
-}
-
-function doLike(post_id, val) {
-  var ids = getLikeLinkIds(post_id, val);
-  $(ids[0]).disabled = true;
-  app.like(post_id, val);
-}
-
-// called when the api request has succeeded
-function onLike(post_id, val) {
-  var ids = getLikeLinkIds(post_id, val);
-  $(ids[0]).disabled = false;
-  hide(ids[0]);
-  show(ids[1]);
-}
-
-function getLikeLinkIds(post_id, val) {
-  if (val) {
-    var prefix1 = 'like';
-    var prefix2 = 'unlike';
-  } else {
-    var prefix1 = 'unlike';
-    var prefix2 = 'like';
-  }
-  return [prefix1 + post_id, prefix2 + post_id];
-}
-  
-
-function comment(post_id) {
-  show("comment_box" + post_id);
-  $("comment_box_input" + post_id).focus();
-}
-
-function postComment(post_id) {
-  var message = $("comment_box_input" + post_id).value;
-  if (message == "") {
-    return;
-  }
-  $("comment_box" + post_id).disabled = true;
-  app.postComment(post_id, message);
-}
-
-function onComment(post_id, html) {
-  $("comments" + post_id).innerHTML += html;
-  $("comment_box" + post_id).disabled = false;
-  $("comment_box_input" + post_id).value = "";
-}
\ No newline at end of file
diff --git a/examples/stream/default.properties b/examples/stream/default.properties
deleted file mode 100644
index 0f4dfe443..000000000
--- a/examples/stream/default.properties
+++ /dev/null
@@ -1,14 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-# 
-# This file must be checked in Version Control Systems.
-# 
-# To customize properties used by the Ant build system use,
-# "build.properties", and override values to adapt the script to your
-# project structure.
-
-# Indicates whether an apk should be generated for each density.
-split.density=false
-android.library.reference.1=../../facebook/
-# Project target.
-target=android-3
diff --git a/examples/stream/res/drawable-mdpi/icon.png b/examples/stream/res/drawable-mdpi/icon.png
deleted file mode 100644
index a07c69fa5..000000000
Binary files a/examples/stream/res/drawable-mdpi/icon.png and /dev/null differ
diff --git a/examples/stream/res/values/strings.xml b/examples/stream/res/values/strings.xml
deleted file mode 100644
index a33b88605..000000000
--- a/examples/stream/res/values/strings.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <string name="app_name">stream</string>
-</resources>
\ No newline at end of file
diff --git a/examples/stream/src/com/facebook/stream/App.java b/examples/stream/src/com/facebook/stream/App.java
deleted file mode 100644
index 4efca7aa6..000000000
--- a/examples/stream/src/com/facebook/stream/App.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import android.app.Activity;
-import android.app.AlertDialog.Builder;
-import android.content.Intent;
-import android.os.Bundle;
-import com.facebook.android.Facebook;
-
-/**
- * This class implements the application's main Activity.
- * 
- * @author yariv
- */
-public class App extends Activity {
-
-    // This is a demo application ID just to get this demo up and running
-    // If you modify this to work for your own app, you must use your
-    // own Facebook Application ID.
-    // See http://www.facebook.com/developers/createapp.php
-    public static final String FB_APP_ID = "126642314059639";
-
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        if (FB_APP_ID == null) {
-            Builder alertBuilder = new Builder(this);
-            alertBuilder.setTitle("Warning");
-            alertBuilder.setMessage("A Facebook Applicaton ID must be " +
-                    "specified before running this example: see App.java");
-            alertBuilder.create().show();
-        }
-        
-        // Initialize the dispatcher
-        Dispatcher dispatcher = new Dispatcher(this);
-        dispatcher.addHandler("login", LoginHandler.class);
-        dispatcher.addHandler("stream", StreamHandler.class);
-        dispatcher.addHandler("logout", LogoutHandler.class);
-
-        // If a session already exists, render the stream page
-        // immediately. Otherwise, render the login page.
-        Session session = Session.restore(this);
-        if (session != null) {
-            dispatcher.runHandler("stream");
-        } else {
-            dispatcher.runHandler("login");
-        }
-    }
-
-    protected void onActivityResult(int requestCode, int resultCode,
-                                    Intent data) {
-        Facebook fb = Session.wakeupForAuthCallback();
-        fb.authorizeCallback(requestCode, resultCode, data);
-    }
-}
diff --git a/examples/stream/src/com/facebook/stream/AsyncRequestListener.java b/examples/stream/src/com/facebook/stream/AsyncRequestListener.java
deleted file mode 100644
index 94d5eb4f4..000000000
--- a/examples/stream/src/com/facebook/stream/AsyncRequestListener.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.net.MalformedURLException;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import android.util.Log;
-
-import com.facebook.android.FacebookError;
-import com.facebook.android.Util;
-import com.facebook.android.AsyncFacebookRunner.RequestListener;
-
-abstract class AsyncRequestListener implements RequestListener {
-
-    public void onComplete(String response, final Object state) {
-        try {
-            JSONObject obj = Util.parseJson(response);
-            onComplete(obj, state);
-        } catch (JSONException e) {
-            e.printStackTrace();
-            Log.e("facebook-stream", "JSON Error:" + e.getMessage());
-        } catch (FacebookError e) {
-            Log.e("facebook-stream", "Facebook Error:" + e.getMessage());
-        }
-
-    }
-
-    public abstract void onComplete(JSONObject obj, final Object state);
-
-    public void onFacebookError(FacebookError e, final Object state) {
-        Log.e("stream", "Facebook Error:" + e.getMessage());
-    }
-
-    public void onFileNotFoundException(FileNotFoundException e,
-                                        final Object state) {
-        Log.e("stream", "Resource not found:" + e.getMessage());      
-    }
-
-    public void onIOException(IOException e, final Object state) {
-        Log.e("stream", "Network Error:" + e.getMessage());      
-    }
-
-    public void onMalformedURLException(MalformedURLException e,
-                                        final Object state) {
-        Log.e("stream", "Invalid URL:" + e.getMessage());            
-    }
-
-}
\ No newline at end of file
diff --git a/examples/stream/src/com/facebook/stream/Dispatcher.java b/examples/stream/src/com/facebook/stream/Dispatcher.java
deleted file mode 100644
index 462734079..000000000
--- a/examples/stream/src/com/facebook/stream/Dispatcher.java
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import java.util.HashMap;
-
-import android.app.Activity;
-import android.webkit.WebView;
-import android.webkit.WebViewClient;
-import android.widget.LinearLayout;
-import android.widget.LinearLayout.LayoutParams;
-
-/**
- * Handles the rendering of the WebView instance and the
- * mapping of app:// urls to their appropriate Handlers.  
- * 
- * @author yariv
- */
-public class Dispatcher {
-
-    // The WebView instance
-    private WebView webView;
-
-    // The app's main Activity
-    private Activity activity;
-
-    // Contains the webView object
-    LinearLayout layout;
-
-    // Has the webView been rendered?
-    boolean isWebViewShown;
-
-    // Holds mappings between handler names to their classes
-    // (e.g. "login" -> LoginHandler.class)
-    HashMap<String, Class> handlers;
-
-    public Dispatcher(Activity activity) {
-        this.activity = activity;
-        handlers = new HashMap<String, Class>();
-        layout = new LinearLayout(activity);
-        activity.addContentView(
-                layout, new LayoutParams(
-                        LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));
-        isWebViewShown = false;
-        showWebView();
-    }
-
-    /**
-     * Adds a handler name to handler class mapping. This should be called
-     * for each handler when the application starts up.
-     * 
-     * @param name
-     * @param clazz
-     */
-    public void addHandler(String name, Class clazz) {
-        this.handlers.put(name, clazz);
-    }
-
-    /**
-     * Executes the handler associated with the given name. For example,
-     * dispatcher.runHandler("login") would render the Login page in the
-     * WebView instance.
-     * 
-     * @param name
-     */
-    public void runHandler(String name) {
-        Class clazz = handlers.get(name);
-        if (clazz != null) {
-            try {
-                Handler handler = (Handler)clazz.newInstance();
-                handler.setDispatcher(this);
-                handler.go();
-            } catch (IllegalAccessException e) {
-                e.printStackTrace();
-            } catch (InstantiationException e) {
-                e.printStackTrace();
-            }
-        }
-    }
-
-    /**
-     * Show the app's WebView instance.
-     */
-    public void showWebView() {
-        if (isWebViewShown) {
-            return;
-        }
-        webView = new WebView(activity);
-        webView.setWebViewClient(new AppWebViewClient());
-        webView.getSettings().setJavaScriptEnabled(true);
-        layout.addView(webView,
-                new LayoutParams(
-                        LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));
-        isWebViewShown = true;
-    }
-
-    /**
-     * Hide the app's WebView instance. This should be called if the
-     * WebView instance is visible and the app wants to open another
-     * WebView instance (e.g. for a Facebook dialog). Android doesn't
-     * seem to be able to handle more than one WebView instance per
-     * application.
-     */
-    public void hideWebView() {
-        layout.removeView(webView);
-        isWebViewShown = false;
-    }
-
-    /**
-     * Returns true if the WebView instance is visible.
-     */
-    public boolean isWebViewShown() {
-        return isWebViewShown;
-    }
-
-    /**
-     * Loads the html string into the WebView instance.
-     * 
-     * @param html
-     */
-    public void loadData(String html) {
-        webView.loadDataWithBaseURL(
-                "http://nada", html, "text/html", "utf8", "");
-    }
-
-    /**
-     * Loads a file from the assets directory into the
-     * WebView instance.
-     * 
-     * @param file
-     */
-    public void loadFile(String file) {
-        webView.loadUrl(getAbsoluteUrl(file));
-    }
-
-    /**
-     * Returns the absolute URL for a local file.
-     * 
-     * @param file
-     */
-    public static String getAbsoluteUrl(String file) {
-        return "file:///android_asset/" + file;
-    }
-
-    /**
-     * Returns the Dispatcher's WebView instance.
-     */
-    public WebView getWebView() {
-        return webView;
-    }
-
-    /**
-     * Returns the Dispatcher's Activity
-     */
-    public Activity getActivity() {
-        return activity;
-    }
-
-
-    /**
-     * Enables the mapping of app:// urls to Handlers.
-     * 
-     * @author yariv
-     */
-    private class AppWebViewClient extends WebViewClient {
-
-        @Override
-        public boolean shouldOverrideUrlLoading(WebView view, String url) {
-            if (url.startsWith("app://")) {
-                String handlerName = url.substring(6);
-                runHandler(handlerName);
-                return true;	
-            }
-            return false;
-        }        
-    }
-
-}
diff --git a/examples/stream/src/com/facebook/stream/FileIO.java b/examples/stream/src/com/facebook/stream/FileIO.java
deleted file mode 100644
index 8ea21b80c..000000000
--- a/examples/stream/src/com/facebook/stream/FileIO.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import java.io.BufferedReader;
-import java.io.BufferedWriter;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.InputStreamReader;
-
-import android.app.Activity;
-
-/**
- * Helpers for doing basic file IO.
- * 
- * @author yariv
- *
- */
-public class FileIO {
-
-    /**
-     * Write the data to the file indicate by fileName. The file is created
-     * if it doesn't exist.
-     * 
-     * @param activity
-     * @param data
-     * @param fileName
-     * @throws IOException
-     */
-    public static void write(
-            Activity activity, String data, String fileName)
-            throws IOException {
-        FileOutputStream fo = activity.openFileOutput(fileName, 0);
-        BufferedWriter bf = new BufferedWriter(new FileWriter(fo.getFD()));
-        bf.write(data);
-        bf.flush();
-        bf.close();
-    }
-
-    /**
-     * Read the contents of the file indicated by fileName
-     * 
-     * @param activity
-     * @param fileName
-     * @return the contents
-     * @throws IOException
-     */
-    public static String read(Activity activity, String fileName) 
-            throws IOException {
-        FileInputStream is = activity.openFileInput(fileName);
-        BufferedReader br = new BufferedReader(new InputStreamReader(is));
-        StringBuilder sb = new StringBuilder();
-        while (br.ready()) {
-            String line = br.readLine();
-            sb.append(line);
-        }
-        String data = sb.toString();
-        return data;
-    }
-}
diff --git a/examples/stream/src/com/facebook/stream/Handler.java b/examples/stream/src/com/facebook/stream/Handler.java
deleted file mode 100644
index 1c682c653..000000000
--- a/examples/stream/src/com/facebook/stream/Handler.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import android.app.Activity;
-import android.webkit.WebView;
-
-/**
- * An abstract superclass for handlers. Handlers are similar to
- * controllers in traditional web apps. Each page has a handler
- * that is responsible for rendering the page.
- * 
- * @author yariv
- */
-public abstract class Handler {
-
-    // The app's dispatcher.
-    protected Dispatcher dispatcher;
-
-    /**
-     * The dispatcher calls this method when the Handler
-     * is expected to render its page.
-     */
-    public abstract void go();
-
-    /**
-     * A setter for the dispatcher.
-     * 
-     * @param dispatcher
-     */
-    public void setDispatcher(Dispatcher dispatcher) {
-        this.dispatcher = dispatcher;
-    }
-
-    /**
-     * Returns the dispatcher.
-     */
-    public Dispatcher getDispatcher() {
-        return dispatcher;
-    }
-
-
-    /**
-     * Returns the dispatcher's WebView
-     */
-    public WebView getWebView() {
-        return dispatcher.getWebView();
-    }
-
-    /**
-     * Returns the dispatcher's Activity
-     */
-    public Activity getActivity() {
-        return dispatcher.getActivity();
-    }
-}
diff --git a/examples/stream/src/com/facebook/stream/LoginHandler.java b/examples/stream/src/com/facebook/stream/LoginHandler.java
deleted file mode 100644
index 0e2ef34ae..000000000
--- a/examples/stream/src/com/facebook/stream/LoginHandler.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import org.json.JSONObject;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.util.Log;
-
-import com.facebook.android.AsyncFacebookRunner;
-import com.facebook.android.DialogError;
-import com.facebook.android.Facebook;
-import com.facebook.android.FacebookError;
-import com.facebook.android.Facebook.DialogListener;
-
-/**
- * A handler for the login page.
- * 
- * @author yariv
- */
-public class LoginHandler extends Handler {
-
-    // The permissions that the app should request from the user
-    // when the user authorizes the app.
-    private static String[] PERMISSIONS = 
-        new String[] { "offline_access", "read_stream", "publish_stream" };
-
-    /**
-     * Render the Login page.
-     */
-    public void go() {
-        dispatcher.getWebView().addJavascriptInterface(
-                new JsHandler(), "app");
-        dispatcher.loadFile("login.html");
-    }
-
-    /**
-     * Contains functions that are exported to the Javascript context
-     * in Login.html
-     * 
-     * @author yariv
-     */
-    private class JsHandler {
-
-        /**
-         * Opens the Facebook login dialog.
-         */
-        public void login() {
-            final Activity activity = LoginHandler.this.getActivity();
-            activity.runOnUiThread(new Runnable() {
-                public void run() {
-                    // We need to temporarily remove the app's WebView
-                    // instance because Android apparently doesn't support
-                    // multiple WebView instances in the same app.
-                    dispatcher.hideWebView();
-                    final Facebook fb = new Facebook(App.FB_APP_ID);
-                    Session.waitForAuthCallback(fb);
-                    fb.authorize(getActivity(), PERMISSIONS,
-                                 new AppLoginListener(fb));
-                }
-            });
-        }
-
-        private class AppLoginListener implements DialogListener {
-
-            private Facebook fb;
-
-            public AppLoginListener(Facebook fb) {
-                this.fb = fb;
-            }
-
-            public void onCancel() {
-                Log.d("app", "login canceled");
-            }
-
-            public void onComplete(Bundle values) {
-                /**
-                 * We request the user's info so we can cache it locally and
-                 * use it to render the new html snippets
-                 * when the user updates her status or comments on a post. 
-                 */
-                new AsyncFacebookRunner(fb).request("/me", 
-                        new AsyncRequestListener() {
-                    public void onComplete(JSONObject obj, final Object state) {
-                        // save the session data
-                        String uid = obj.optString("id");
-                        String name = obj.optString("name");
-                        new Session(fb, uid, name).save(getActivity());
-
-                        // render the Stream page in the UI thread
-                        getActivity().runOnUiThread(new Runnable() {
-                            public void run() {
-                                dispatcher.showWebView();
-                                dispatcher.runHandler("stream");
-                            }
-                        });
-                    }
-                }, null);
-            }
-
-            public void onError(DialogError e) {
-                Log.d("app", "dialog error: " + e);               
-            }
-
-            public void onFacebookError(FacebookError e) {
-                Log.d("app", "facebook error: " + e);
-            }
-        }
-    }
-
-}
diff --git a/examples/stream/src/com/facebook/stream/LogoutHandler.java b/examples/stream/src/com/facebook/stream/LogoutHandler.java
deleted file mode 100644
index dc3f94ef7..000000000
--- a/examples/stream/src/com/facebook/stream/LogoutHandler.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.net.MalformedURLException;
-
-import android.util.Log;
-
-import com.facebook.android.AsyncFacebookRunner;
-import com.facebook.android.Facebook;
-import com.facebook.android.FacebookError;
-import com.facebook.android.AsyncFacebookRunner.RequestListener;
-
-/**
- * A handler for the logout link. This handler doesn't render
- * its own page. After logging out it redirects the user
- * to the login handler.
- * 
- * @author yariv
- */
-public class LogoutHandler extends Handler {
-
-    /**
-     * Called by the dispatcher when the user clicks 'logout'.
-     */
-    public void go() {
-        Facebook fb = Session.restore(getActivity()).getFb();
-
-        // clear the local session data
-        Session.clearSavedSession(getActivity());
-        new AsyncFacebookRunner(fb).logout(getActivity(), 
-                new RequestListener() {
-
-            public void onComplete(String response, final Object state) {
-                dispatcher.runHandler("login");
-            }
-
-            public void onFileNotFoundException(FileNotFoundException error,
-                                                final Object state) {
-                Log.e("app", error.toString());
-                dispatcher.runHandler("login");
-            }
-
-            public void onIOException(IOException error, final Object state) {
-                Log.e("app", error.toString());
-                dispatcher.runHandler("login");            
-            }
-
-            public void onMalformedURLException(MalformedURLException error,
-                                                final Object state) {
-                Log.e("app", error.toString());
-                dispatcher.runHandler("login");
-            }
-
-            public void onFacebookError(FacebookError error,
-                                        final Object state) {
-                Log.e("app", error.toString());
-                dispatcher.runHandler("login");
-            }
-        });
-    }
-}
diff --git a/examples/stream/src/com/facebook/stream/Session.java b/examples/stream/src/com/facebook/stream/Session.java
deleted file mode 100644
index f1af9ae74..000000000
--- a/examples/stream/src/com/facebook/stream/Session.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.content.SharedPreferences.Editor;
-
-import com.facebook.android.Facebook;
-
-/**
- * A utility class for storing and retrieving Facebook session data.
- * 
- * @author yariv
- */
-public class Session {
-
-    private static final String TOKEN = "access_token";
-    private static final String EXPIRES = "expires_in";
-    private static final String KEY = "facebook-session";
-    private static final String UID = "uid";
-    private static final String NAME = "name";
-    private static final String APP_ID = "app_id";
-
-    private static Session singleton;
-    private static Facebook fbLoggingIn;
-
-    // The Facebook object
-    private Facebook fb;
-
-    // The user id of the logged in user
-    private String uid;
-
-    // The user name of the logged in user
-    private String name;
-
-    /**
-     * Constructor
-     * 
-     * @param fb
-     * @param uid
-     * @param name
-     */
-    public Session(Facebook fb, String uid, String name) {
-        this.fb = fb;
-        this.uid = uid;
-        this.name = name;
-    }
-
-    /**
-     * Returns the Facebook object
-     */
-    public Facebook getFb() {
-        return fb;
-    }
-
-    /**
-     * Returns the session user's id
-     */
-    public String getUid() {
-        return uid;
-    }
-
-    /**
-     * Returns the session user's name 
-     */
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * Stores the session data on disk.
-     * 
-     * @param context
-     * @return
-     */
-    public boolean save(Context context) {
-
-        Editor editor =
-            context.getSharedPreferences(KEY, Context.MODE_PRIVATE).edit();
-        editor.putString(TOKEN, fb.getAccessToken());
-        editor.putLong(EXPIRES, fb.getAccessExpires());
-        editor.putString(UID, uid);
-        editor.putString(NAME, name);
-        editor.putString(APP_ID, fb.getAppId());
-        if (editor.commit()) {
-            singleton = this;
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Loads the session data from disk.
-     * 
-     * @param context
-     * @return
-     */
-    public static Session restore(Context context) {
-        if (singleton != null) {
-            if (singleton.getFb().isSessionValid()) {
-                return singleton;
-            } else {
-                return null;
-            }
-        }
-
-        SharedPreferences prefs =
-            context.getSharedPreferences(KEY, Context.MODE_PRIVATE);
-        
-        String appId = prefs.getString(APP_ID, null);
-        
-        if (appId == null) {
-        	return null;
-        }
-        
-        Facebook fb = new Facebook(appId);
-        fb.setAccessToken(prefs.getString(TOKEN, null));
-        fb.setAccessExpires(prefs.getLong(EXPIRES, 0));
-        String uid = prefs.getString(UID, null);
-        String name = prefs.getString(NAME, null);
-        if (!fb.isSessionValid() || uid == null || name == null) {
-            return null;
-        }
-
-        Session session = new Session(fb, uid, name);
-        singleton = session;
-        return session;
-    }
-
-    /**
-     * Clears the saved session data.
-     * 
-     * @param context
-     */
-    public static void clearSavedSession(Context context) {
-        Editor editor = 
-            context.getSharedPreferences(KEY, Context.MODE_PRIVATE).edit();
-        editor.clear();
-        editor.commit();
-        singleton = null;
-    }
-
-    /**
-     * Freezes a Facebook object while it's waiting for an auth callback.
-     */
-    public static void waitForAuthCallback(Facebook fb) {
-        fbLoggingIn = fb;
-    }
-
-    /**
-     * Returns a Facebook object that's been waiting for an auth callback.
-     */
-    public static Facebook wakeupForAuthCallback() {
-        Facebook fb = fbLoggingIn;
-        fbLoggingIn = null;
-        return fb;
-    }
-
-}
diff --git a/examples/stream/src/com/facebook/stream/StreamHandler.java b/examples/stream/src/com/facebook/stream/StreamHandler.java
deleted file mode 100644
index b97c84f78..000000000
--- a/examples/stream/src/com/facebook/stream/StreamHandler.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.net.MalformedURLException;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import android.util.Log;
-
-import com.facebook.android.AsyncFacebookRunner;
-import com.facebook.android.Facebook;
-import com.facebook.android.FacebookError;
-import com.facebook.android.Util;
-import com.facebook.android.AsyncFacebookRunner.RequestListener;
-
-/**
- * A handler for the stream page. It's responsible for
- * fetching the stream data from the API and storing it
- * in a local file based cache. It uses the helper class
- * StreamRenderer to render the stream.
- *  
- * @author yariv
- */
-public class StreamHandler extends Handler {
-
-    private static final String CACHE_FILE = "cache.txt";
-
-    /**
-     * Called by the dispatcher to render the stream page.
-     */
-    public void go() {
-        dispatcher.getWebView().addJavascriptInterface(
-                new StreamJsHandler(this), "app");
-
-        // first try to load the cached data
-        try {
-            String cached = FileIO.read(getActivity(), CACHE_FILE);
-            if (cached != null) {
-                JSONObject obj = new JSONObject(cached);
-                dispatcher.loadData(StreamRenderer.render(obj));
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
-        } catch (JSONException e) {
-            e.printStackTrace();
-        }
-
-        Facebook fb = Session.restore(getActivity()).getFb();
-        new AsyncFacebookRunner(fb).request("me/home", 
-                new StreamRequestListener());
-    }
-
-    public class StreamRequestListener implements RequestListener {
-
-        public void onComplete(String response, final Object state) {
-            try {
-                JSONObject obj = Util.parseJson(response);
-                // try to cache the result
-                try {
-                    FileIO.write(getActivity(), response, CACHE_FILE);
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-
-                // Convert the result into an HTML string and then load it
-                // into the WebView in the UI thread.
-                final String html = StreamRenderer.render(obj);
-                getActivity().runOnUiThread(new Runnable() {
-                    public void run() {
-                        dispatcher.loadData(html);
-                    }
-                });
-
-            } catch (JSONException e) {
-                Log.e("stream", "JSON Error:" + e.getMessage());
-            } catch (FacebookError e) {
-                Log.e("stream", "Facebook Error:" + e.getMessage());
-            }
-        }
-
-        public void onFacebookError(FacebookError e, final Object state) {
-            Log.e("stream", "Facebook Error:" + e.getMessage());
-        }
-
-        public void onFileNotFoundException(FileNotFoundException e,
-                                            final Object state) {
-            Log.e("stream", "Resource not found:" + e.getMessage());      
-        }
-
-        public void onIOException(IOException e, final Object state) {
-            Log.e("stream", "Network Error:" + e.getMessage());      
-        }
-
-        public void onMalformedURLException(MalformedURLException e,
-                                            final Object state) {
-            Log.e("stream", "Invalid URL:" + e.getMessage());            
-        }
-
-    }
-}
diff --git a/examples/stream/src/com/facebook/stream/StreamJsHandler.java b/examples/stream/src/com/facebook/stream/StreamJsHandler.java
deleted file mode 100644
index a1f633edf..000000000
--- a/examples/stream/src/com/facebook/stream/StreamJsHandler.java
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import java.text.SimpleDateFormat;
-import java.util.Date;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import android.os.Bundle;
-import com.facebook.android.AsyncFacebookRunner;
-import com.facebook.android.Facebook;
-
-/**
- * Implements functions that can be called from Javascript in the
- * stream page.
- * 
- * @author yariv
- */
-class StreamJsHandler {
-
-    // The handler for the Stream page
-    private final StreamHandler streamHandler;
-
-    /**
-     * @param streamHandler
-     */
-    StreamJsHandler(StreamHandler streamHandler) {
-        this.streamHandler = streamHandler;
-    }
-
-    /**
-     * Returns the Facebook object.
-     */
-    private AsyncFacebookRunner getFb() {
-        Facebook fb = Session.restore(streamHandler.getActivity()).getFb();
-        return new AsyncFacebookRunner(fb);
-    }
-
-    /**
-     * Update the status and render the resulting status at the
-     * top of the stream.
-     *  
-     * @param message
-     */
-    public void updateStatus(final String message) {
-        AsyncFacebookRunner fb = getFb();
-        Bundle params = new Bundle();
-        params.putString("message", message);
-        fb.request("me/feed", params, "POST", new AsyncRequestListener() {
-
-            public void onComplete(JSONObject obj, final Object state) {
-                String html;
-                try {
-                    html = renderStatus(obj, message);
-                    html = html.replace("'", "\\\'");
-                    callJs("onStatusUpdated('" + html + "');");
-                } catch (JSONException e) {
-                    // TODO Auto-generated catch block
-                    e.printStackTrace();
-                }
-            }
-        }, null);
-    }
-
-    /**
-     * Renders the html for the new status.
-     * 
-     * @param response
-     * @param message
-     * @return
-     * @throws JSONException
-     */
-    private String renderStatus(JSONObject response, String message)
-            throws JSONException {
-
-        String postId = response.getString("id");
-        JSONObject post = new JSONObject();
-        post.put("id", postId);
-        post.put("message", message);
-
-        JSONObject from = createAuthorObj();
-        post.put("from", from);
-
-        JSONArray actions = new JSONArray();
-        JSONObject like = new JSONObject();
-        like.put("name", "Like");
-        actions.put(like);
-
-        JSONObject comment = new JSONObject();
-        comment.put("name", "Comment");
-        actions.put(comment);
-
-        post.put("actions", actions);
-
-        SimpleDateFormat format = StreamRenderer.getDateFormat();
-        String timestamp = format.format(new Date());
-        post.put("created_time", timestamp);
-
-        String html = StreamRenderer.renderSinglePost(post);
-        return html;
-    }
-
-    /**
-     * Like or unlike a post
-     * 
-     * @param post_id
-     * @param val if the action should be a like (true) or an unlike (false)
-     */
-    public void like(final String post_id, final boolean val) {
-        Bundle params = new Bundle();
-        if (!val) {
-            params.putString("method", "delete");
-        }
-        getFb().request(post_id + "/likes", new Bundle(), "POST",
-                new AsyncRequestListener() {
-
-            public void onComplete(JSONObject response, final Object state) {
-                callJs("javascript:onLike('" + post_id + "'," + val + ")");
-            }
-        }, null);
-    }
-
-
-    public void postComment(final String post_id, final String message) {
-        Bundle params = new Bundle();
-        params.putString("message", message);
-
-        getFb().request(post_id + "/comments", params, "POST",
-                new AsyncRequestListener() {
-
-            public void onComplete(JSONObject response, final Object state) {
-
-                try {
-                    String html = renderComment(response, message);
-                    html = html.replace("'", "\\'");
-                    callJs("onComment('" + post_id + "','" + html + "');");
-                } catch (JSONException e) {
-                    e.printStackTrace();
-                }
-
-            }
-        }, null);
-    }
-
-    /**
-     * Renders the html string for a new comment.
-     * 
-     * @param response
-     * @param message
-     * @return
-     * @throws JSONException
-     */
-    private String renderComment(JSONObject response, String message)
-            throws JSONException {
-
-        JSONObject comment = new JSONObject();
-        String commentId = response.getString("id");
-        comment.put("id", commentId);
-        comment.put("from", createAuthorObj());
-        comment.put("message", message);
-
-        String html = StreamRenderer.renderSingleComment(comment);
-        return html;
-    }
-
-    /**
-     * Executes javascript code inside WebKit.
-     * 
-     * @param js
-     */
-    private void callJs(String js) {
-        streamHandler.getWebView().loadUrl("javascript:" + js);
-    }
-
-    /**
-     * Creates a JSONObject for the post or comment author.
-     *  
-     * @return
-     * @throws JSONException
-     */
-    private JSONObject createAuthorObj() throws JSONException {
-        Session session = Session.restore(streamHandler.getActivity());
-        JSONObject from = new JSONObject();
-        from.put("id", session.getUid());
-        from.put("name", session.getName());
-        return from;
-    }
-}
\ No newline at end of file
diff --git a/examples/stream/src/com/facebook/stream/StreamRenderer.java b/examples/stream/src/com/facebook/stream/StreamRenderer.java
deleted file mode 100644
index b7a470416..000000000
--- a/examples/stream/src/com/facebook/stream/StreamRenderer.java
+++ /dev/null
@@ -1,538 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import java.text.ParsePosition;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.HashSet;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import android.util.Log;
-
-/**
- * Contains logic for converting a JSONObject obtained from
- * querying /me/home to a HTML string that can be rendered
- * in WebKit.
- * 
- * @author yariv
- */
-class StreamRenderer {
-
-    private StringBuilder sb;
-
-    /**
-     * The main function for rendering the stream JSONObject.
-     * 
-     * @param data
-     * @return
-     */
-    public static String render(JSONObject data) {
-        StreamRenderer renderer = new StreamRenderer();
-        return renderer.doRender(data);
-    }
-
-    /**
-     * Renders the HTML for a single post.
-     * 
-     * @param post
-     * @return
-     * @throws JSONException
-     */
-    public static String renderSinglePost(JSONObject post)
-            throws JSONException {
-
-        StreamRenderer renderer = new StreamRenderer();
-        renderer.renderPost(post);
-        return renderer.getResult();
-    }
-
-    /**
-     * Renders the HTML for a single comment.
-     * 
-     * @param comment
-     * @return
-     */
-    public static String renderSingleComment(JSONObject comment) {
-        StreamRenderer renderer = new StreamRenderer();
-        renderer.renderComment(comment);
-        return renderer.getResult();
-    }
-
-
-    private StreamRenderer() {
-        this.sb = new StringBuilder();
-    }
-
-    /**
-     * Returns a SimpleDateFormat object we use for
-     * parsing and rendering timestamps.
-     * 
-     * @return
-     */
-    public static SimpleDateFormat getDateFormat() {
-        return new SimpleDateFormat("yyyy-MM-dd'T'hh:mm:ssZ");
-    }
-
-    /**
-     * Returns the result html.
-     * 
-     * @return
-     */
-    private String getResult() {
-        return sb.toString();
-    }
-
-    private String doRender(JSONObject data) {
-
-        try {
-            JSONArray posts = data.getJSONArray("data");
-            String[] chunks = {
-                "<html><head>",
-                "<link rel=\"stylesheet\" " +
-                "href=\"file:///android_asset/stream.css\" type=\"text/css\">",
-                "<script src=\"file:///android_asset/stream.js\"></script>",
-                "</head>",
-                "<body>",
-                "<div id=\"header\">"
-            };
-            append(chunks);
-            renderLink("app://logout", "logout");
-
-            renderStatusBox();
-
-            append("<div id=\"posts\">");
-            for (int i = 0; i < posts.length(); i++) {
-                renderPost(posts.getJSONObject(i));
-            }
-            append("</div></body></html>");
-            return getResult();
-        } catch (JSONException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-            return "";
-        }
-    }
-
-    /**
-     * Renders the "what's on your mind?" box and the Share button.
-     */
-    private void renderStatusBox() {
-        String[] chunks = new String[] {
-            "</div><div class=\"clear\"></div>",
-            "<div id=\"status_box\">",
-            "<input id=\"status_input\" value=\" What's on your mind?\"",
-            " onfocus=\"onStatusBoxFocus(this);\"/>",
-            "<button id=\"status_submit\" class=\"hidden\" " +
-            "onclick=\"updateStatus();\">Share</button>",
-            "<div class=\"clear\"></div>",
-            "</div>"
-        };
-        append(chunks);
-    }
-
-    /**
-     * Renders a single post
-     * 
-     * @param post
-     * @throws JSONException
-     */
-    private void renderPost(JSONObject post) throws JSONException {
-        append("<div class=\"post\">");
-        renderFrom(post);
-        renderTo(post);
-        renderMessage(post);
-        renderAttachment(post);
-        renderActionLinks(post);
-        renderLikes(post);
-        renderComments(post);
-        renderCommentBox(post);
-        append("</div>");
-    }
-
-
-    /**
-     * Renders the author's name
-     * 
-     * @param post
-     * @throws JSONException
-     */
-    private void renderFrom(JSONObject post) throws JSONException {
-        JSONObject from = post.getJSONObject("from");
-        String fromName = from.getString("name");
-        String fromId = from.getString("id");
-        renderAuthor(fromId, fromName);
-    }
-
-    /**
-     * If it's a wall post on a friend's fall, renders
-     * the recipient's name preceded by a '>'.
-     * 
-     * @param post
-     * @throws JSONException
-     */
-    private void renderTo(JSONObject post) throws JSONException {
-        JSONObject to = post.optJSONObject("to");
-        if (to != null) {
-            JSONObject toData = to.getJSONArray("data").getJSONObject(0);
-            String toName = toData.getString("name");
-            String toId = toData.getString("id");
-            append(" > ");
-            renderProfileLink(toId, toName);
-        }
-    }
-
-    /**
-     * Renders a link to a user.
-     * 
-     * @param id
-     * @param name
-     */
-    private void renderProfileLink(String id, String name) {
-        renderLink(getProfileUrl(id), name);
-    }
-
-    private String getProfileUrl(String id) {
-        return "http://touch.facebook.com/#/profile.php?id=" + id;
-    }
-
-    /**
-     * Renders the author pic and name.
-     * 
-     * @param id
-     * @param name
-     */
-    private void renderAuthor(String id, String name) {
-        String[] chunks = {
-            "<div class=\"profile_pic_container\">",
-            "<a href=\"", getProfileUrl(id),
-            "\"><img class=\"profile_pic\" src=\"http://graph.facebook.com/",
-            id, "/picture\"/></a>",
-            "</div>"
-        };
-        append(chunks);
-        renderProfileLink(id, name);
-    }
-
-    /**
-     * Renders the post message.
-     * 
-     * @param post
-     */
-    private void renderMessage(JSONObject post) {
-        String message = post.optString("message");
-        String[] chunks = {
-            "&nbsp;<span class=\"msg\">", message, "</span>",
-            "<div class=\"clear\"></div>"
-        };
-        append(chunks);
-    }
-
-    /**
-     * Renders the attachment.
-     * 
-     * @param post
-     */
-    private void renderAttachment(JSONObject post) {
-        String name = post.optString("name");
-        String link = post.optString("link");
-        String picture = post.optString("picture");
-        String source = post.optString("source"); // for videos
-        String caption = post.optString("caption");
-        String description = post.optString("description");
-
-        String[] fields = new String[] {
-                name, link, picture, source, caption, description
-        };
-        boolean hasAttachment = false;
-        for (String field : fields) {
-            if (field.length() != 0) {
-                hasAttachment = true;
-                break;
-            }
-        }
-
-        if (!hasAttachment) {
-            return;
-        }
-
-        append("<div class=\"attachment\">");
-        if (name != "") {
-            append("<div class=\"title\">");
-            if (link != null) {
-                renderLink(link, name);
-            } else {
-                append(name);
-            }
-            append("</div>");
-        }
-        if (caption != "") {
-            append("<div class=\"caption\">" + caption + "</div>");
-        }
-
-        if (picture != "") {
-            append("<div class=\"picture\">");
-            String img = "<img src=\"" + picture + "\"/>";
-            if (link != "") {
-                renderLink(link, img);
-            } else {
-                append(img);
-            }
-            append("</div>");
-        }
-
-        if (description != "") {
-            append("<div class=\"description\">" + description + "</div>");
-        }
-        append("<div class=\"clear\"></div></div>");
-    }
-
-    /**
-     * Renders an anchor tag
-     *  
-     * @param href
-     * @param text
-     */
-    private void renderLink(String href, String text) {
-        append(new String[] {
-            "<a href=\"",
-            href,
-            "\">",
-            text,
-            "</a>"
-        });
-    }
-
-    /**
-     * Renders the posts' action links.
-     * 
-     * @param post
-     */
-    private void renderActionLinks(JSONObject post) {
-        HashSet<String> actions = getActions(post);
-        append("<div class=\"action_links\">");
-        append("<div class=\"action_link\">");
-        renderTimeStamp(post);
-        append("</div>");
-        String post_id = post.optString("id");
-        if (actions.contains("Comment")) {
-            renderActionLink(post_id, "Comment", "comment");
-        }
-        boolean canLike = actions.contains("Like");
-        renderActionLink(post_id, "Like", "like", canLike);
-        renderActionLink(post_id, "Unlike", "unlike", !canLike);
-
-        append("<div class=\"clear\"></div></div>");
-    }
-
-    /**
-     * Renders a single visible action link.
-     *  
-     * @param post_id
-     * @param title
-     * @param func
-     */
-    private void renderActionLink(String post_id, String title, String func) { 
-        renderActionLink(post_id, title, func, true);
-    }
-
-    /**
-     * Renders an action link with optional visibility.
-     * 
-     * @param post_id
-     * @param title
-     * @param func
-     * @param visible
-     */
-    private void renderActionLink(String post_id, String title, String func, 
-            boolean visible) {
-        String extraClass = visible ? "" : "hidden";
-        String[] chunks = new String[] {
-            "<div id=\"", func, post_id, "\" class=\"action_link ", 
-            extraClass, "\">", "<a href=\"#\" onclick=\"",func, "('",
-            post_id, "'); return false;\">", title, "</a></div>"
-        };
-        append(chunks);
-    }
-
-    /**
-     * Renders the post's timestamp.
-     * 
-     * @param post
-     */
-    private void renderTimeStamp(JSONObject post) {
-        String dateStr = post.optString("created_time");
-        SimpleDateFormat formatter = getDateFormat();
-        ParsePosition pos = new ParsePosition(0);
-        long then  = formatter.parse(dateStr, pos).getTime();
-        long now = new Date().getTime();
-
-        long seconds = (now - then)/1000;
-        long minutes = seconds/60;
-        long hours = minutes/60;
-        long days = hours/24;
-
-        String friendly = null;
-        long num = 0;
-        if (days > 0) {
-            num = days;
-            friendly = days + " day";
-        } else if (hours > 0) {
-            num = hours;
-            friendly = hours + " hour";
-        } else if (minutes > 0) {
-            num = minutes;
-            friendly = minutes + " minute";
-        } else {
-            num = seconds;
-            friendly = seconds + " second";
-        }
-        if (num > 1) {
-            friendly += "s";
-        }
-        String[] chunks = new String[] {
-            "<div class=\"timestamp\">",
-            friendly,
-            " ago",
-            "</div>"
-        };
-        append(chunks);
-    }
-
-    /**
-     * Returns the available actions for the post.
-     * 
-     * @param post
-     * @return
-     */
-    private HashSet<String> getActions(JSONObject post) {
-        HashSet<String> actionsSet = new HashSet<String>();
-        JSONArray actions = post.optJSONArray("actions");
-        if (actions != null) {
-            for (int j = 0; j < actions.length(); j++) {
-                JSONObject action = actions.optJSONObject(j);
-                String actionName = action.optString("name");
-                actionsSet.add(actionName);
-            }
-        }
-        return actionsSet;
-    }
-
-    /**
-     * Renders the 'x people like this' text,
-     * 
-     * @param post
-     */
-    private void renderLikes(JSONObject post) {
-        int numLikes = post.optInt("likes", 0);
-        if (numLikes > 0) {
-            String desc = numLikes == 1 ?
-                "person likes this" :
-                "people like this";
-            String[] chunks = new String[] {
-                "<div class=\"like_icon\">",
-                "<img src=\"file:///android_asset/like_icon.png\"/>",
-                "</div>",
-                "<div class=\"num_likes\">",
-                new Integer(numLikes).toString(),
-                " ",
-                desc,
-                "</div>"
-            };
-            append(chunks);
-        }
-    }
-
-    /**
-     * Renders the post's comments.
-     * 
-     * @param post
-     * @throws JSONException
-     */
-    private void renderComments(JSONObject post) throws JSONException {
-        append("<div class=\"comments\" id=\"comments" + post.optString("id")
-                + "\">");
-        JSONObject comments = post.optJSONObject("comments");
-        if (comments != null) {
-            JSONArray data = comments.optJSONArray("data");
-            if (data != null) {
-                for (int j = 0; j < data.length(); j++) {
-                    JSONObject comment = data.getJSONObject(j);
-                    renderComment(comment);
-                }
-            }
-        }
-        append("</div>");
-    }
-
-    /**
-     * Renders an individual comment.
-     * 
-     * @param comment
-     */
-    private void renderComment(JSONObject comment) {
-        JSONObject from = comment.optJSONObject("from");
-        if (from == null) {
-            Log.w("StreamRenderer",
-                    "Comment missing from field: " + comment.toString());
-        } else {
-            String authorId = from.optString("id");
-            String authorName = from.optString("name");
-            renderAuthor(authorId, authorName);
-        }
-        String message = comment.optString("message");
-        append("<div class=\"comment\">");
-        String[] chunks = {
-            "&nbsp;",
-            message,
-            "</div>"
-        };	
-        append(chunks);
-    }
-
-
-    /**
-     * Renders the new comment input box.
-     * 
-     * @param post
-     */
-    private void renderCommentBox(JSONObject post) {
-        String id = post.optString("id");
-        String[] chunks = new String[] {
-            "<div class=\"comment_box\" id=\"comment_box", id, "\">",
-            "<input id=\"comment_box_input", id, "\"/>",
-            "<button onclick=\"postComment('", id , "');\">Post</button>",
-            "<div class=\"clear\"></div>",
-            "</div>"
-        };
-        append(chunks);
-    }
-
-
-    private void append(String str) {
-        sb.append(str);
-    }
-
-    private void append(String[] chunks) {
-        for (String chunk : chunks) {
-            sb.append(chunk);
-        }
-    }
-}
\ No newline at end of file
diff --git a/facebook/.classpath b/facebook/.classpath
new file mode 100644
index 000000000..c5c5afd01
--- /dev/null
+++ b/facebook/.classpath
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="lib" path="libs/android-support-v4.jar"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/facebook/.project b/facebook/.project
new file mode 100644
index 000000000..d0551a112
--- /dev/null
+++ b/facebook/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>FacebookSDK</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/facebook/AndroidManifest.xml b/facebook/AndroidManifest.xml
index e6940f838..daf6c8b4a 100644
--- a/facebook/AndroidManifest.xml
+++ b/facebook/AndroidManifest.xml
@@ -18,4 +18,5 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
       package="com.facebook.android">
     <application/>
+    <uses-sdk android:minSdkVersion="8" />
 </manifest>
diff --git a/facebook/TestApp/AndroidManifest.xml b/facebook/TestApp/AndroidManifest.xml
new file mode 100644
index 000000000..cccc2923d
--- /dev/null
+++ b/facebook/TestApp/AndroidManifest.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+      package="com.facebook.sdk"
+      android:versionCode="1"
+      android:versionName="1.0">
+    <application android:label="@string/app_name" android:icon="@drawable/ic_launcher">
+        <activity android:name="StatusActivity"
+                  android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+</manifest>
diff --git a/facebook/TestApp/SdkTestApp.eml b/facebook/TestApp/SdkTestApp.eml
new file mode 100644
index 000000000..4104d1ffc
--- /dev/null
+++ b/facebook/TestApp/SdkTestApp.eml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<component>
+	<exclude-output/>
+	<contentEntry url="file://$MODULE_DIR$"/>
+</component>
diff --git a/facebook/TestApp/SdkTestApp.iml b/facebook/TestApp/SdkTestApp.iml
new file mode 100644
index 000000000..f75bae6df
--- /dev/null
+++ b/facebook/TestApp/SdkTestApp.iml
@@ -0,0 +1,52 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="EclipseModuleManager">
+    <conelement value="com.android.ide.eclipse.adt.LIBRARIES" />
+    <src_description expected_position="0">
+      <src_folder value="file://$MODULE_DIR$/src" expected_position="0" />
+      <src_folder value="file://$MODULE_DIR$/gen" expected_position="1" />
+    </src_description>
+  </component>
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="true" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/bin/classes" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+  </component>
+</module>
+
diff --git a/facebook/TestApp/ant.properties b/facebook/TestApp/ant.properties
new file mode 100644
index 000000000..b0971e891
--- /dev/null
+++ b/facebook/TestApp/ant.properties
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff --git a/facebook/TestApp/build.xml b/facebook/TestApp/build.xml
new file mode 100644
index 000000000..ea49a3fca
--- /dev/null
+++ b/facebook/TestApp/build.xml
@@ -0,0 +1,83 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="FacebookSdk" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties" />
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties" />
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties" />
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through an env var"
+            unless="sdk.dir"
+    />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true" />
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml" />
+
+</project>
diff --git a/examples/Hackbook/proguard-project.txt b/facebook/TestApp/proguard-project.txt
similarity index 100%
rename from examples/Hackbook/proguard-project.txt
rename to facebook/TestApp/proguard-project.txt
diff --git a/facebook/TestApp/project.properties b/facebook/TestApp/project.properties
new file mode 100644
index 000000000..b0620672e
--- /dev/null
+++ b/facebook/TestApp/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+
diff --git a/examples/stream/res/drawable-hdpi/icon.png b/facebook/TestApp/res/drawable-hdpi/ic_launcher.png
similarity index 100%
rename from examples/stream/res/drawable-hdpi/icon.png
rename to facebook/TestApp/res/drawable-hdpi/ic_launcher.png
diff --git a/examples/stream/res/drawable-ldpi/icon.png b/facebook/TestApp/res/drawable-ldpi/ic_launcher.png
similarity index 100%
rename from examples/stream/res/drawable-ldpi/icon.png
rename to facebook/TestApp/res/drawable-ldpi/ic_launcher.png
diff --git a/examples/simple/res/drawable/icon.png b/facebook/TestApp/res/drawable-mdpi/ic_launcher.png
similarity index 100%
rename from examples/simple/res/drawable/icon.png
rename to facebook/TestApp/res/drawable-mdpi/ic_launcher.png
diff --git a/facebook/TestApp/res/layout/main.xml b/facebook/TestApp/res/layout/main.xml
new file mode 100644
index 000000000..db98bc8c4
--- /dev/null
+++ b/facebook/TestApp/res/layout/main.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    >
+<TextView
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:text="SDK Unit Tests"
+    />
+</LinearLayout>
+
diff --git a/facebook/TestApp/res/values/strings.xml b/facebook/TestApp/res/values/strings.xml
new file mode 100644
index 000000000..c29c37b9a
--- /dev/null
+++ b/facebook/TestApp/res/values/strings.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">StatusActivity</string>
+</resources>
diff --git a/facebook/TestApp/src/com/facebook/sdk/StatusActivity.java b/facebook/TestApp/src/com/facebook/sdk/StatusActivity.java
new file mode 100644
index 000000000..6448b64a9
--- /dev/null
+++ b/facebook/TestApp/src/com/facebook/sdk/StatusActivity.java
@@ -0,0 +1,15 @@
+package com.facebook.sdk;
+
+import android.app.Activity;
+import android.os.Bundle;
+
+public class StatusActivity extends Activity
+{
+    /** Called when the activity is first created. */
+    @Override
+    public void onCreate(Bundle savedInstanceState)
+    {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+    }
+}
diff --git a/facebook/android-sdk.eml b/facebook/android-sdk.eml
new file mode 100644
index 000000000..4104d1ffc
--- /dev/null
+++ b/facebook/android-sdk.eml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<component>
+	<exclude-output/>
+	<contentEntry url="file://$MODULE_DIR$"/>
+</component>
diff --git a/facebook/android-sdk.iml b/facebook/android-sdk.iml
new file mode 100644
index 000000000..641785433
--- /dev/null
+++ b/facebook/android-sdk.iml
@@ -0,0 +1,54 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="EclipseModuleManager">
+    <conelement value="com.android.ide.eclipse.adt.LIBRARIES" />
+    <src_description expected_position="0">
+      <src_folder value="file://$MODULE_DIR$/src" expected_position="0" />
+      <src_folder value="file://$MODULE_DIR$/gen" expected_position="1" />
+    </src_description>
+  </component>
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="true" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/bin/classes" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/res" isTestSource="false" />
+    </content>
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/facebook/ant.properties b/facebook/ant.properties
new file mode 100644
index 000000000..deea2247d
--- /dev/null
+++ b/facebook/ant.properties
@@ -0,0 +1 @@
+jar.libs.dir=../lib
\ No newline at end of file
diff --git a/facebook/libs b/facebook/libs
new file mode 120000
index 000000000..d4bda9b46
--- /dev/null
+++ b/facebook/libs
@@ -0,0 +1 @@
+../libs
\ No newline at end of file
diff --git a/facebook/project.properties b/facebook/project.properties
index b2ed0b007..cd0ca122a 100644
--- a/facebook/project.properties
+++ b/facebook/project.properties
@@ -12,4 +12,4 @@
 
 android.library=true
 # Project target.
-target=android-16
+target=android-8
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_grey_focused.9.png b/facebook/res/drawable-hdpi/com_facebook_button_grey_focused.9.png
new file mode 100644
index 000000000..2e6f66dbc
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_button_grey_focused.9.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_grey_normal.9.png b/facebook/res/drawable-hdpi/com_facebook_button_grey_normal.9.png
new file mode 100644
index 000000000..6098f0b0e
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_button_grey_normal.9.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_grey_pressed.9.png b/facebook/res/drawable-hdpi/com_facebook_button_grey_pressed.9.png
new file mode 100644
index 000000000..23b9757d1
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_button_grey_pressed.9.png differ
diff --git a/facebook/res/drawable-hdpi/close.png b/facebook/res/drawable-hdpi/com_facebook_close.png
similarity index 51%
rename from facebook/res/drawable-hdpi/close.png
rename to facebook/res/drawable-hdpi/com_facebook_close.png
index d44c33575..d925cb7b2 100644
Binary files a/facebook/res/drawable-hdpi/close.png and b/facebook/res/drawable-hdpi/com_facebook_close.png differ
diff --git a/facebook/res/drawable-hdpi/facebook_icon.png b/facebook/res/drawable-hdpi/com_facebook_icon.png
similarity index 100%
rename from facebook/res/drawable-hdpi/facebook_icon.png
rename to facebook/res/drawable-hdpi/com_facebook_icon.png
diff --git a/facebook/res/drawable-hdpi/com_facebook_loginbutton_blue_focused.png b/facebook/res/drawable-hdpi/com_facebook_loginbutton_blue_focused.png
new file mode 100644
index 000000000..7badb08d7
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_loginbutton_blue_focused.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_loginbutton_blue_normal.png b/facebook/res/drawable-hdpi/com_facebook_loginbutton_blue_normal.png
new file mode 100644
index 000000000..7f71a8a6d
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_loginbutton_blue_normal.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_loginbutton_blue_pressed.png b/facebook/res/drawable-hdpi/com_facebook_loginbutton_blue_pressed.png
new file mode 100644
index 000000000..7badb08d7
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_loginbutton_blue_pressed.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_logo.png b/facebook/res/drawable-hdpi/com_facebook_logo.png
new file mode 100644
index 000000000..26ab7945f
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_logo.png differ
diff --git a/facebook/res/drawable-ldpi/close.png b/facebook/res/drawable-ldpi/com_facebook_close.png
similarity index 100%
rename from facebook/res/drawable-ldpi/close.png
rename to facebook/res/drawable-ldpi/com_facebook_close.png
diff --git a/facebook/res/drawable-ldpi/facebook_icon.png b/facebook/res/drawable-ldpi/com_facebook_icon.png
similarity index 100%
rename from facebook/res/drawable-ldpi/facebook_icon.png
rename to facebook/res/drawable-ldpi/com_facebook_icon.png
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_grey_focused.9.png b/facebook/res/drawable-xhdpi/com_facebook_button_grey_focused.9.png
new file mode 100644
index 000000000..bfd883f92
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_button_grey_focused.9.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_grey_normal.9.png b/facebook/res/drawable-xhdpi/com_facebook_button_grey_normal.9.png
new file mode 100644
index 000000000..aa9895432
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_button_grey_normal.9.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_grey_pressed.9.png b/facebook/res/drawable-xhdpi/com_facebook_button_grey_pressed.9.png
new file mode 100644
index 000000000..92f2ad12a
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_button_grey_pressed.9.png differ
diff --git a/facebook/res/drawable-xhdpi/close.png b/facebook/res/drawable-xhdpi/com_facebook_close.png
old mode 100644
new mode 100755
similarity index 100%
rename from facebook/res/drawable-xhdpi/close.png
rename to facebook/res/drawable-xhdpi/com_facebook_close.png
diff --git a/facebook/res/drawable-xhdpi/com_facebook_loginbutton_blue_focused.png b/facebook/res/drawable-xhdpi/com_facebook_loginbutton_blue_focused.png
new file mode 100644
index 000000000..93882b64b
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_loginbutton_blue_focused.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_loginbutton_blue_normal.png b/facebook/res/drawable-xhdpi/com_facebook_loginbutton_blue_normal.png
new file mode 100644
index 000000000..911feeee9
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_loginbutton_blue_normal.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_loginbutton_blue_pressed.png b/facebook/res/drawable-xhdpi/com_facebook_loginbutton_blue_pressed.png
new file mode 100644
index 000000000..93882b64b
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_loginbutton_blue_pressed.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_logo.png b/facebook/res/drawable-xhdpi/com_facebook_logo.png
new file mode 100644
index 000000000..24d7fc56b
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_logo.png differ
diff --git a/facebook/res/drawable/com_facebook_button_check.xml b/facebook/res/drawable/com_facebook_button_check.xml
new file mode 100644
index 000000000..49079dca4
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_button_check.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+  <item android:state_checked="true" android:drawable="@drawable/com_facebook_button_check_on" />
+  <item android:drawable="@drawable/com_facebook_button_check_off" />
+</selector>
diff --git a/facebook/res/drawable/com_facebook_button_check_off.png b/facebook/res/drawable/com_facebook_button_check_off.png
new file mode 100644
index 000000000..e9737df5c
Binary files /dev/null and b/facebook/res/drawable/com_facebook_button_check_off.png differ
diff --git a/facebook/res/drawable/com_facebook_button_check_on.png b/facebook/res/drawable/com_facebook_button_check_on.png
new file mode 100644
index 000000000..d793151e6
Binary files /dev/null and b/facebook/res/drawable/com_facebook_button_check_on.png differ
diff --git a/facebook/res/drawable/com_facebook_button_grey_focused.9.png b/facebook/res/drawable/com_facebook_button_grey_focused.9.png
new file mode 100644
index 000000000..56f603571
Binary files /dev/null and b/facebook/res/drawable/com_facebook_button_grey_focused.9.png differ
diff --git a/facebook/res/drawable/com_facebook_button_grey_normal.9.png b/facebook/res/drawable/com_facebook_button_grey_normal.9.png
new file mode 100644
index 000000000..dff3b7d73
Binary files /dev/null and b/facebook/res/drawable/com_facebook_button_grey_normal.9.png differ
diff --git a/facebook/res/drawable/com_facebook_button_grey_pressed.9.png b/facebook/res/drawable/com_facebook_button_grey_pressed.9.png
new file mode 100644
index 000000000..46648efcd
Binary files /dev/null and b/facebook/res/drawable/com_facebook_button_grey_pressed.9.png differ
diff --git a/facebook/res/drawable/close.png b/facebook/res/drawable/com_facebook_close.png
old mode 100644
new mode 100755
similarity index 60%
rename from facebook/res/drawable/close.png
rename to facebook/res/drawable/com_facebook_close.png
index ed8b374b1..ad0147460
Binary files a/facebook/res/drawable/close.png and b/facebook/res/drawable/com_facebook_close.png differ
diff --git a/facebook/res/drawable/facebook_icon.png b/facebook/res/drawable/com_facebook_icon.png
similarity index 100%
rename from facebook/res/drawable/facebook_icon.png
rename to facebook/res/drawable/com_facebook_icon.png
diff --git a/facebook/res/drawable/com_facebook_list_divider.9.png b/facebook/res/drawable/com_facebook_list_divider.9.png
new file mode 100644
index 000000000..7d4c46c47
Binary files /dev/null and b/facebook/res/drawable/com_facebook_list_divider.9.png differ
diff --git a/facebook/res/drawable/com_facebook_list_section_header_background.9.png b/facebook/res/drawable/com_facebook_list_section_header_background.9.png
new file mode 100644
index 000000000..1763c4a64
Binary files /dev/null and b/facebook/res/drawable/com_facebook_list_section_header_background.9.png differ
diff --git a/facebook/res/drawable/com_facebook_loginbutton_blue.xml b/facebook/res/drawable/com_facebook_loginbutton_blue.xml
new file mode 100644
index 000000000..6de365058
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_loginbutton_blue.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android" >
+    <item android:state_pressed="true" 
+          android:drawable="@drawable/com_facebook_loginbutton_blue_pressed" />
+    <item android:state_focused="true" 
+          android:drawable="@drawable/com_facebook_loginbutton_blue_focused" />
+    <item android:drawable="@drawable/com_facebook_loginbutton_blue_normal" />
+</selector>
diff --git a/facebook/res/drawable/com_facebook_loginbutton_blue_focused.png b/facebook/res/drawable/com_facebook_loginbutton_blue_focused.png
new file mode 100644
index 000000000..218b6e5d1
Binary files /dev/null and b/facebook/res/drawable/com_facebook_loginbutton_blue_focused.png differ
diff --git a/facebook/res/drawable/com_facebook_loginbutton_blue_normal.png b/facebook/res/drawable/com_facebook_loginbutton_blue_normal.png
new file mode 100644
index 000000000..121741085
Binary files /dev/null and b/facebook/res/drawable/com_facebook_loginbutton_blue_normal.png differ
diff --git a/facebook/res/drawable/com_facebook_loginbutton_blue_pressed.png b/facebook/res/drawable/com_facebook_loginbutton_blue_pressed.png
new file mode 100644
index 000000000..218b6e5d1
Binary files /dev/null and b/facebook/res/drawable/com_facebook_loginbutton_blue_pressed.png differ
diff --git a/facebook/res/drawable/com_facebook_loginbutton_silver.xml b/facebook/res/drawable/com_facebook_loginbutton_silver.xml
new file mode 100644
index 000000000..88e32ebce
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_loginbutton_silver.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android" >
+    <item android:state_pressed="true" 
+          android:drawable="@drawable/com_facebook_button_grey_pressed" />
+    <item android:state_focused="true" 
+          android:drawable="@drawable/com_facebook_button_grey_focused" />
+    <item android:drawable="@drawable/com_facebook_button_grey_normal" />
+</selector>
diff --git a/facebook/res/drawable/com_facebook_loginfragment_background_gradient.xml b/facebook/res/drawable/com_facebook_loginfragment_background_gradient.xml
new file mode 100644
index 000000000..11a7a445f
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_loginfragment_background_gradient.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle">
+    <gradient
+      android:startColor="#5774B5"
+      android:endColor="#2C4988"
+      android:gradientRadius="495"
+      android:type="radial"/>
+</shape>    
diff --git a/facebook/res/drawable/com_facebook_logo.png b/facebook/res/drawable/com_facebook_logo.png
new file mode 100644
index 000000000..785acf9ea
Binary files /dev/null and b/facebook/res/drawable/com_facebook_logo.png differ
diff --git a/facebook/res/drawable/com_facebook_picker_item_background.xml b/facebook/res/drawable/com_facebook_picker_item_background.xml
new file mode 100644
index 000000000..420d3da28
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_picker_item_background.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <!-- Even though these two point to the same resource, have two states so the drawable will invalidate itself when coming out of pressed state. -->
+    <item android:state_focused="true"  android:state_enabled="false" android:state_pressed="true" android:drawable="@drawable/com_facebook_picker_list_selector_disabled" />
+    <item android:state_focused="true"  android:state_enabled="false"                              android:drawable="@drawable/com_facebook_picker_list_selector_disabled" />
+    <item android:state_focused="true"                                android:state_pressed="true" android:drawable="@drawable/com_facebook_picker_list_selector_background_transition" />
+    <item android:state_focused="false"                               android:state_pressed="true" android:drawable="@drawable/com_facebook_picker_list_selector_background_transition" />
+    <item android:state_focused="true"                                                             android:drawable="@drawable/com_facebook_picker_list_focused" />
+    <item                                                                                          android:drawable="@android:color/transparent" />
+</selector>
diff --git a/facebook/res/drawable/com_facebook_picker_list_focused.9.png b/facebook/res/drawable/com_facebook_picker_list_focused.9.png
new file mode 100644
index 000000000..7c0599e3a
Binary files /dev/null and b/facebook/res/drawable/com_facebook_picker_list_focused.9.png differ
diff --git a/facebook/res/drawable/com_facebook_picker_list_longpressed.9.png b/facebook/res/drawable/com_facebook_picker_list_longpressed.9.png
new file mode 100644
index 000000000..3bf8e0362
Binary files /dev/null and b/facebook/res/drawable/com_facebook_picker_list_longpressed.9.png differ
diff --git a/facebook/res/drawable/com_facebook_picker_list_pressed.9.png b/facebook/res/drawable/com_facebook_picker_list_pressed.9.png
new file mode 100644
index 000000000..6e77525d2
Binary files /dev/null and b/facebook/res/drawable/com_facebook_picker_list_pressed.9.png differ
diff --git a/facebook/res/drawable/com_facebook_picker_list_selector.xml b/facebook/res/drawable/com_facebook_picker_list_selector.xml
new file mode 100644
index 000000000..a943a5165
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_picker_list_selector.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <item android:state_window_focused="false" android:drawable="@android:color/transparent" />
+
+    <item android:state_focused="true"  android:state_enabled="false" android:state_pressed="true" android:drawable="@drawable/com_facebook_picker_list_selector_disabled" />
+    <item android:state_focused="true"  android:state_enabled="false"                              android:drawable="@drawable/com_facebook_picker_list_selector_disabled" />
+    <item android:state_focused="true"                                android:state_pressed="true" android:drawable="@drawable/com_facebook_picker_list_selector_background_transition" />
+    <item android:state_focused="false"                               android:state_pressed="true" android:drawable="@drawable/com_facebook_picker_list_selector_background_transition" />
+    <item android:state_focused="true"                                                             android:drawable="@drawable/com_facebook_picker_list_focused" />
+
+</selector>
diff --git a/facebook/res/drawable/com_facebook_picker_list_selector_background_transition.xml b/facebook/res/drawable/com_facebook_picker_list_selector_background_transition.xml
new file mode 100644
index 000000000..0e4aa8eb8
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_picker_list_selector_background_transition.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2010 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<transition xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:drawable="@drawable/com_facebook_picker_list_pressed"  />
+    <item android:drawable="@drawable/com_facebook_picker_list_longpressed"  />
+</transition>
diff --git a/facebook/res/drawable/com_facebook_picker_list_selector_disabled.9.png b/facebook/res/drawable/com_facebook_picker_list_selector_disabled.9.png
new file mode 100644
index 000000000..42cb6463e
Binary files /dev/null and b/facebook/res/drawable/com_facebook_picker_list_selector_disabled.9.png differ
diff --git a/facebook/res/drawable/com_facebook_picker_top_button.xml b/facebook/res/drawable/com_facebook_picker_top_button.xml
new file mode 100644
index 000000000..c1cf56359
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_picker_top_button.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android">
+    <gradient
+            android:startColor="#3f5b96"
+            android:endColor="#2d4984"
+            android:angle="270"/>
+</shape>
\ No newline at end of file
diff --git a/facebook/res/drawable/com_facebook_place_default_icon.png b/facebook/res/drawable/com_facebook_place_default_icon.png
new file mode 100644
index 000000000..97ec3e608
Binary files /dev/null and b/facebook/res/drawable/com_facebook_place_default_icon.png differ
diff --git a/facebook/res/drawable/com_facebook_profile_default_icon.png b/facebook/res/drawable/com_facebook_profile_default_icon.png
new file mode 100644
index 000000000..15864ccdb
Binary files /dev/null and b/facebook/res/drawable/com_facebook_profile_default_icon.png differ
diff --git a/facebook/res/drawable/com_facebook_profile_picture_blank_portrait.png b/facebook/res/drawable/com_facebook_profile_picture_blank_portrait.png
new file mode 100755
index 000000000..1ea13d41a
Binary files /dev/null and b/facebook/res/drawable/com_facebook_profile_picture_blank_portrait.png differ
diff --git a/facebook/res/drawable/com_facebook_profile_picture_blank_square.png b/facebook/res/drawable/com_facebook_profile_picture_blank_square.png
new file mode 100755
index 000000000..bf10aebff
Binary files /dev/null and b/facebook/res/drawable/com_facebook_profile_picture_blank_square.png differ
diff --git a/facebook/res/drawable/com_facebook_top_background.xml b/facebook/res/drawable/com_facebook_top_background.xml
new file mode 100644
index 000000000..9da6daaaf
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_top_background.xml
@@ -0,0 +1,6 @@
+<shape xmlns:android="http://schemas.android.com/apk/res/android">
+  <gradient
+      android:startColor="#FF5975b0"
+      android:endColor="#FF47639e"
+      android:angle="270"/>
+</shape>
diff --git a/facebook/res/drawable/com_facebook_top_button.xml b/facebook/res/drawable/com_facebook_top_button.xml
new file mode 100644
index 000000000..5e9474da6
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_top_button.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_pressed="true"
+          android:drawable="@drawable/com_facebook_picker_top_button" />
+    <item android:state_focused="true"
+          android:drawable="@drawable/com_facebook_picker_top_button" />
+    <item android:state_selected="true"
+          android:drawable="@drawable/com_facebook_picker_top_button" />
+    <item
+            android:drawable="@drawable/com_facebook_top_background" />
+</selector>
diff --git a/facebook/res/layout/com_facebook_friendpickerfragment.xml b/facebook/res/layout/com_facebook_friendpickerfragment.xml
new file mode 100644
index 000000000..97efbf059
--- /dev/null
+++ b/facebook/res/layout/com_facebook_friendpickerfragment.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+              android:background="#FFFFFF">
+
+    <include layout="@layout/com_facebook_picker_title_bar_stub"/>
+
+    <ListView
+            android:id="@+id/com_facebook_picker_list_view"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:divider="@drawable/com_facebook_list_divider"
+            android:fastScrollEnabled="true"
+            android:scrollbars="vertical"
+            android:listSelector="@drawable/com_facebook_picker_list_selector"
+            android:cacheColorHint="#FFFFFF"
+            />
+
+    <ProgressBar android:indeterminate="true"
+                 android:layout_width="wrap_content"
+                 android:layout_height="wrap_content"
+                 android:id="@+id/com_facebook_picker_activity_circle"
+                 style="@android:style/Widget.ProgressBar"
+                 android:layout_centerInParent="true"
+                 android:visibility="invisible"
+            />
+</RelativeLayout>
diff --git a/facebook/res/layout/com_facebook_loginfragment.xml b/facebook/res/layout/com_facebook_loginfragment.xml
new file mode 100644
index 000000000..97702f0b7
--- /dev/null
+++ b/facebook/res/layout/com_facebook_loginfragment.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:loginView="http://schemas.android.com/apk/res-auto"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:background="@drawable/com_facebook_loginfragment_background_gradient" >
+    <LinearLayout
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent"
+        android:orientation="vertical">
+
+        <ImageView
+            android:id="@+id/com_facebook_loginfragment_logo_image"
+            android:layout_width="193dp"
+            android:layout_height="44dp"
+            android:layout_gravity="center_horizontal"
+            android:src="@drawable/com_facebook_logo"
+            android:layout_marginTop="35dp"
+            android:contentDescription="@string/com_facebook_logo_content_description"/>
+
+        <TextView
+            android:id="@+id/com_facebook_loginfragment_profile_name"
+            android:layout_width="fill_parent"
+            android:layout_height="100dp"
+            android:lines="1"
+            android:textSize="16sp"
+            android:textStyle="bold"
+            android:layout_marginTop="35dp"
+            android:gravity="center"/>
+    
+        <com.facebook.LoginButton
+            android:id="@+id/com_facebook_loginfragment_login_button"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:layout_marginTop="35dp"
+            android:layout_marginBottom="35dp"
+            loginView:login_text="@string/com_facebook_loginfragment_log_in_button"
+            style="@style/com_facebook_loginview_silver_style" />
+    
+    </LinearLayout>
+</ScrollView>
\ No newline at end of file
diff --git a/facebook/res/layout/com_facebook_picker_activity_circle_row.xml b/facebook/res/layout/com_facebook_picker_activity_circle_row.xml
new file mode 100644
index 000000000..eb72bf0a5
--- /dev/null
+++ b/facebook/res/layout/com_facebook_picker_activity_circle_row.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        android:layout_height="50dip"
+        android:layout_width="fill_parent"
+        >
+    <ProgressBar android:indeterminate="true"
+                 android:layout_width="wrap_content"
+                 android:layout_height="50dip"
+                 android:id="@+id/com_facebook_picker_row_activity_circle"
+                 style="@android:style/Widget.ProgressBar.Small"
+                 android:layout_centerInParent="true"
+                 android:visibility="visible"
+                 android:indeterminateOnly="true"
+            />
+</RelativeLayout>
diff --git a/facebook/res/layout/com_facebook_picker_checkbox.xml b/facebook/res/layout/com_facebook_picker_checkbox.xml
new file mode 100644
index 000000000..a8fe8f405
--- /dev/null
+++ b/facebook/res/layout/com_facebook_picker_checkbox.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<CheckBox
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/com_facebook_picker_checkbox"
+    android:layout_width="23dip"
+    android:layout_height="23dip"
+    android:focusable="false"
+    android:clickable="false"
+    android:button="@drawable/com_facebook_button_check" />
diff --git a/facebook/res/layout/com_facebook_picker_image.xml b/facebook/res/layout/com_facebook_picker_image.xml
new file mode 100644
index 000000000..34206449c
--- /dev/null
+++ b/facebook/res/layout/com_facebook_picker_image.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ImageView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/com_facebook_picker_image"
+    android:layout_width="50dip"
+    android:layout_height="50dip"
+    android:layout_gravity="center_vertical"
+    android:src="@drawable/com_facebook_profile_default_icon" />
diff --git a/facebook/res/layout/com_facebook_picker_list_row.xml b/facebook/res/layout/com_facebook_picker_list_row.xml
new file mode 100644
index 000000000..896704292
--- /dev/null
+++ b/facebook/res/layout/com_facebook_picker_list_row.xml
@@ -0,0 +1,32 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        android:layout_height="wrap_content"
+        android:layout_width="fill_parent"
+        >
+    <ViewStub
+            android:id="@+id/com_facebook_picker_profile_pic_stub"
+            android:inflatedId="@+id/com_facebook_picker_image"
+            android:layout="@layout/com_facebook_picker_image"
+            android:layout_width="50dip"
+            android:layout_height="50dip" />
+    <TextView
+            android:id="@+id/com_facebook_picker_title"
+            android:layout_width="100dip"
+            android:layout_height="50dip"
+            android:layout_weight="1.0"
+            android:paddingLeft="5dip"
+            android:textStyle="bold"
+            android:textColor="#000000"
+            android:singleLine="true"
+            android:ellipsize="end"
+            android:textSize="18sp"
+            android:gravity="left|center_vertical"/>
+    <ViewStub
+            android:id="@+id/com_facebook_picker_checkbox_stub"
+            android:inflatedId="@+id/com_facebook_picker_checkbox"
+            android:layout="@layout/com_facebook_picker_checkbox"
+            android:layout_width="23dip"
+            android:layout_height="23dip"
+            android:layout_marginRight="10dip"/>
+</LinearLayout>
diff --git a/facebook/res/layout/com_facebook_picker_list_section_header.xml b/facebook/res/layout/com_facebook_picker_list_section_header.xml
new file mode 100644
index 000000000..77530bf01
--- /dev/null
+++ b/facebook/res/layout/com_facebook_picker_list_section_header.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<TextView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/com_facebook_picker_list_section_header"
+    android:layout_width="fill_parent"
+    android:layout_height="wrap_content"
+    android:textStyle="bold"
+    android:background="@drawable/com_facebook_list_section_header_background"
+    android:orientation="horizontal"
+    android:gravity="left|center_vertical"
+    android:textColor="#68768a"
+    android:textSize="17sp"
+    android:paddingLeft="8dip"
+    android:paddingBottom="0px"
+    android:shadowDx="1"
+    android:shadowDy="1"
+    android:shadowRadius="1"
+    android:shadowColor="#BFFFFFFF" />
diff --git a/facebook/res/layout/com_facebook_picker_search_box.xml b/facebook/res/layout/com_facebook_picker_search_box.xml
new file mode 100644
index 000000000..ce5e8dd90
--- /dev/null
+++ b/facebook/res/layout/com_facebook_picker_search_box.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<EditText xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="wrap_content"
+              android:layout_height="fill_parent">
+</EditText>
\ No newline at end of file
diff --git a/facebook/res/layout/com_facebook_picker_title_bar.xml b/facebook/res/layout/com_facebook_picker_title_bar.xml
new file mode 100644
index 000000000..55ba5e0c4
--- /dev/null
+++ b/facebook/res/layout/com_facebook_picker_title_bar.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+                android:id="@+id/com_facebook_picker_top_bar"
+                android:layout_width="fill_parent"
+                android:layout_height="48dp"
+                android:background="@drawable/com_facebook_top_background"
+                android:gravity="right">
+    <Button
+            android:id="@+id/com_facebook_picker_done_button"
+            android:layout_width="wrap_content"
+            android:minWidth="55dp"
+            android:layout_height="48dp"
+            android:background="@drawable/com_facebook_top_button"
+            android:paddingLeft="5dip"
+            android:paddingRight="5dip"
+            android:textColor="#ffffff"
+            android:textSize="14sp"
+            android:shadowColor="#66000000"
+            android:shadowDx="1"
+            android:shadowDy="1"
+            android:shadowRadius="1"
+            android:layout_alignParentRight="true"
+            />
+    <LinearLayout
+            android:id="@+id/com_facebook_picker_divider"
+            android:layout_width="1dp"
+            android:layout_height="fill_parent"
+            android:background="#40000000"
+            android:layout_alignLeft="@id/com_facebook_picker_done_button"/>
+    <TextView
+            android:id="@+id/com_facebook_picker_title"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:textSize="22sp"
+            android:textColor="#FFFFFF"
+            android:gravity="left|center_vertical"
+            android:ellipsize="end"
+            android:singleLine="true"
+            android:scaleType="center"
+            android:shadowColor="#66000000"
+            android:shadowDx="1"
+            android:shadowDy="1"
+            android:shadowRadius="1"
+            android:layout_marginLeft="10dip"
+            android:layout_marginRight="10dip"
+            android:layout_toLeftOf="@id/com_facebook_picker_divider"/>
+</RelativeLayout>
diff --git a/facebook/res/layout/com_facebook_picker_title_bar_stub.xml b/facebook/res/layout/com_facebook_picker_title_bar_stub.xml
new file mode 100644
index 000000000..524f7c6e5
--- /dev/null
+++ b/facebook/res/layout/com_facebook_picker_title_bar_stub.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<merge xmlns:android="http://schemas.android.com/apk/res/android">
+    <ViewStub android:id="@+id/com_facebook_picker_title_bar_stub"
+              android:inflatedId="@+id/com_facebook_picker_title_bar"
+              android:layout="@layout/com_facebook_picker_title_bar"
+              android:layout_height="48dip"
+              android:layout_width="fill_parent"/>
+
+</merge>
\ No newline at end of file
diff --git a/facebook/res/layout/com_facebook_placepickerfragment.xml b/facebook/res/layout/com_facebook_placepickerfragment.xml
new file mode 100644
index 000000000..5ce0423fd
--- /dev/null
+++ b/facebook/res/layout/com_facebook_placepickerfragment.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+              android:background="#FFFFFF">
+
+    <include layout="@layout/com_facebook_picker_title_bar_stub"/>
+
+    <ViewStub android:id="@+id/com_facebook_placepickerfragment_search_box_stub"
+              android:inflatedId="@+id/search_box"
+              android:layout="@layout/com_facebook_picker_search_box"
+              android:layout_height="wrap_content"
+              android:layout_width="fill_parent"/>
+
+    <ListView
+            android:id="@+id/com_facebook_picker_list_view"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:layout_alignParentTop="true"
+            android:divider="@drawable/com_facebook_list_divider"
+            android:fastScrollEnabled="true"
+            android:scrollbars="vertical"
+            android:listSelector="@drawable/com_facebook_picker_list_selector"
+            android:cacheColorHint="#FFFFFF"
+            />
+
+    <ProgressBar android:indeterminate="true"
+                 android:layout_width="wrap_content"
+                 android:layout_height="wrap_content"
+                 android:id="@+id/com_facebook_picker_activity_circle"
+                 style="@android:style/Widget.ProgressBar"
+                 android:layout_centerInParent="true"
+                 android:visibility="invisible"
+            />
+</RelativeLayout>
diff --git a/facebook/res/layout/com_facebook_placepickerfragment_list_row.xml b/facebook/res/layout/com_facebook_placepickerfragment_list_row.xml
new file mode 100644
index 000000000..e1aac9281
--- /dev/null
+++ b/facebook/res/layout/com_facebook_placepickerfragment_list_row.xml
@@ -0,0 +1,54 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        android:layout_height="wrap_content"
+        android:layout_width="fill_parent">
+    <ViewStub
+            android:id="@+id/com_facebook_picker_profile_pic_stub"
+            android:inflatedId="@+id/com_facebook_picker_image"
+            android:layout="@layout/com_facebook_picker_image"
+            android:layout_width="50dip"
+            android:layout_height="50dip" />
+    <LinearLayout
+            android:orientation="vertical"
+            android:focusable="false"
+            android:layout_width="0dip"
+            android:layout_height="wrap_content"
+            android:layout_marginRight="16dp"
+            android:layout_gravity="center_vertical"
+            android:layout_weight="1">
+        <TextView
+                android:id="@+id/com_facebook_picker_title"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:layout_weight="1.0"
+                android:paddingLeft="5dip"
+                android:ellipsize="end"
+                android:singleLine="true"
+                android:typeface="sans"
+                android:textColor="#000000"
+                android:lines="1"
+                android:textSize="16sp"
+                android:gravity="left|center_vertical"/>
+        <TextView
+                android:id="@+id/picker_subtitle"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:layout_weight="1.0"
+                android:paddingLeft="5dip"
+                android:ellipsize="end"
+                android:singleLine="true"
+                android:textColor="#666666"
+                android:lines="1"
+                android:typeface="sans"
+                android:textSize="12sp"
+                android:gravity="left|center_vertical"/>
+    </LinearLayout>
+    <!--ViewStub
+            android:id="@+id/checkbox_stub"
+            android:inflatedId="@+id/picker_checkbox"
+            android:layout="@layout/checkbox_layout"
+            android:layout_width="23dip"
+            android:layout_height="23dip"
+            android:layout_marginRight="10dip"/-->
+</LinearLayout>
diff --git a/facebook/res/values-es/strings.xml b/facebook/res/values-es/strings.xml
new file mode 100644
index 000000000..fbcef142c
--- /dev/null
+++ b/facebook/res/values-es/strings.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="com_facebook_loginview_log_out_button">Cerrar Sesión</string>
+    <string name="com_facebook_loginview_log_in_button">Iniciar Sesión</string>
+    <string name="com_facebook_loginview_logged_in_as">Sesión iniciada como: %1$s</string>
+    <string name="com_facebook_loginview_logged_in_using_facebook">Sesión iniciada con Facebook</string>
+    <string name="com_facebook_loginview_log_out_action">Cerrar sesión</string>
+    <string name="com_facebook_loginview_cancel_action">Cancelar</string>
+    <string name="com_facebook_logo_content_description">Logo de Facebook</string>
+    <string name="com_facebook_loginfragment_log_in_button">Iniciar Sesión&#8230;</string>
+    <string name="com_facebook_loginfragment_logged_in">Sesión iniciada</string>
+    <string name="com_facebook_loginfragment_not_logged_in">No has iniciado sesión</string>
+    <string name="com_facebook_placepicker_subtitle_format">%1$s • %2$,d estuvieron aquí</string>
+    <string name="com_facebook_placepicker_subtitle_catetory_only_format">%1$s</string>
+    <string name="com_facebook_placepicker_subtitle_were_here_only_format">es:%1$,d estuvieron aquí</string>
+</resources>
diff --git a/facebook/res/values-he/strings.xml b/facebook/res/values-he/strings.xml
new file mode 100644
index 000000000..b6135754e
--- /dev/null
+++ b/facebook/res/values-he/strings.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="com_facebook_loginview_log_out_button">התנתק</string>
+    <string name="com_facebook_loginview_log_in_button">התחבר</string>
+    <string name="com_facebook_loginview_logged_in_as">מחובר בשם: %1$s</string>
+    <string name="com_facebook_loginview_logged_in_using_facebook">מחובר באמצעות פייסבוק</string>
+    <string name="com_facebook_loginview_log_out_action">התנתק</string>
+    <string name="com_facebook_loginview_cancel_action">בטל</string>
+    <string name="com_facebook_logo_content_description">Facebook Logo</string>
+    <string name="com_facebook_loginfragment_log_in_button">התחבר&#8230;</string>
+    <string name="com_facebook_loginfragment_logged_in">מחובר</string>
+    <string name="com_facebook_loginfragment_not_logged_in">לא מחובר</string>
+    <string name="com_facebook_placepicker_subtitle_format">%1$s • %2$,d היו פה</string>
+    <string name="com_facebook_placepicker_subtitle_catetory_only_format">%1$s</string>
+    <string name="com_facebook_placepicker_subtitle_were_here_only_format">%1$,d היו פה</string>
+</resources>
diff --git a/facebook/res/values-iw/strings.xml b/facebook/res/values-iw/strings.xml
new file mode 100644
index 000000000..b6135754e
--- /dev/null
+++ b/facebook/res/values-iw/strings.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="com_facebook_loginview_log_out_button">התנתק</string>
+    <string name="com_facebook_loginview_log_in_button">התחבר</string>
+    <string name="com_facebook_loginview_logged_in_as">מחובר בשם: %1$s</string>
+    <string name="com_facebook_loginview_logged_in_using_facebook">מחובר באמצעות פייסבוק</string>
+    <string name="com_facebook_loginview_log_out_action">התנתק</string>
+    <string name="com_facebook_loginview_cancel_action">בטל</string>
+    <string name="com_facebook_logo_content_description">Facebook Logo</string>
+    <string name="com_facebook_loginfragment_log_in_button">התחבר&#8230;</string>
+    <string name="com_facebook_loginfragment_logged_in">מחובר</string>
+    <string name="com_facebook_loginfragment_not_logged_in">לא מחובר</string>
+    <string name="com_facebook_placepicker_subtitle_format">%1$s • %2$,d היו פה</string>
+    <string name="com_facebook_placepicker_subtitle_catetory_only_format">%1$s</string>
+    <string name="com_facebook_placepicker_subtitle_were_here_only_format">%1$,d היו פה</string>
+</resources>
diff --git a/facebook/res/values/attrs.xml b/facebook/res/values/attrs.xml
new file mode 100644
index 000000000..8b497b70b
--- /dev/null
+++ b/facebook/res/values/attrs.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <declare-styleable name="com_facebook_picker_fragment">
+        <attr name="show_pictures" format="boolean"/>
+        <attr name="extra_fields" format="string"/>
+        <attr name="show_title_bar" format="boolean" />
+        <attr name="title_text" format="string" />
+        <attr name="done_button_text" format="string" />
+        <attr name="title_bar_background" format="reference" />
+        <attr name="done_button_background" format="reference" />
+    </declare-styleable>
+    <declare-styleable name="com_facebook_friend_picker_fragment">
+        <attr name="multi_select" format="boolean"/>
+    </declare-styleable>
+    <declare-styleable name="com_facebook_place_picker_fragment">
+        <attr name="radius_in_meters" format="integer"/>
+        <attr name="results_limit" format="integer"/>
+        <attr name="search_text" format="string"/>
+        <attr name="show_search_box" format="boolean" />
+    </declare-styleable>
+    <declare-styleable name="com_facebook_login_view">
+        <attr name="confirm_logout" format="boolean"/>
+        <attr name="fetch_user_info" format="boolean"/>
+        <attr name="login_text" format="string"/>
+        <attr name="logout_text" format="string"/>
+    </declare-styleable>
+    <declare-styleable name="com_facebook_profile_picture_view">
+        <attr name="preset_size">
+            <!-- Keep in sync with constants in ProfilePictureView -->
+            <enum name="small" value="-2" />
+            <enum name="normal" value="-3" />
+            <enum name="large" value="-4" />
+        </attr>
+    </declare-styleable>
+</resources>
diff --git a/facebook/res/values/strings.xml b/facebook/res/values/strings.xml
new file mode 100644
index 000000000..bfce323e5
--- /dev/null
+++ b/facebook/res/values/strings.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="com_facebook_dialogloginactivity_ok_button">OK</string>
+    <string name="com_facebook_loginview_log_out_button">Log Out</string>
+    <string name="com_facebook_loginview_log_in_button">Log In</string>
+    <string name="com_facebook_loginview_logged_in_as">Logged in as: %1$s</string>
+    <string name="com_facebook_loginview_logged_in_using_facebook">Logged in using Facebook</string>
+    <string name="com_facebook_loginview_log_out_action">Log Out</string>
+    <string name="com_facebook_loginview_cancel_action">Cancel</string>
+    <string name="com_facebook_logo_content_description">Facebook Logo</string>
+    <string name="com_facebook_loginfragment_log_in_button">Log In&#8230;</string>
+    <string name="com_facebook_loginfragment_logged_in">Logged In</string>
+    <string name="com_facebook_loginfragment_not_logged_in">Not Logged In</string>
+    <string name="com_facebook_placepicker_subtitle_format">%1$s • %2$,d were here</string>
+    <string name="com_facebook_placepicker_subtitle_catetory_only_format">%1$s</string>
+    <string name="com_facebook_placepicker_subtitle_were_here_only_format">%1$,d were here</string>
+    <string name="com_facebook_picker_done_button_text">Done</string>
+    <string name="com_facebook_choose_friends">Choose Friends</string>
+    <string name="com_facebook_nearby">Nearby</string>
+</resources>
diff --git a/facebook/res/values/styles.xml b/facebook/res/values/styles.xml
new file mode 100644
index 000000000..04e22cbc1
--- /dev/null
+++ b/facebook/res/values/styles.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android">
+    <color name="com_facebook_blue">#3B5998</color>
+    
+    <color name="com_facebook_loginfragment_connected_text_color">#FFFFFF</color>
+    <color name="com_facebook_loginfragment_connected_shadow_color">#000000</color>
+    <color name="com_facebook_loginfragment_not_connected_text_color">#A6AED7</color>
+    <dimen name="com_facebook_loginfragment_profile_picture_width">64dp</dimen>
+    <dimen name="com_facebook_loginfragment_profile_picture_height">64dp</dimen>
+    
+    <dimen name="com_facebook_loginview_padding_left">42dp</dimen>
+    <dimen name="com_facebook_loginview_padding_right">0dp</dimen>
+    <dimen name="com_facebook_loginview_padding_top">0dp</dimen>
+    <dimen name="com_facebook_loginview_padding_bottom">0dp</dimen>
+    <dimen name="com_facebook_loginview_width">205dp</dimen>
+    <dimen name="com_facebook_loginview_height">44dp</dimen>
+    <color name="com_facebook_loginview_text_color">#FFFFFF</color>
+    <dimen name="com_facebook_loginview_text_size">16.0sp</dimen>
+
+    <dimen name="com_facebook_profilepictureview_preset_size_small">50dp</dimen>
+    <dimen name="com_facebook_profilepictureview_preset_size_normal">100dp</dimen>
+    <dimen name="com_facebook_profilepictureview_preset_size_large">180dp</dimen>
+
+    <style name="com_facebook_loginview_default_style" parent="@android:style/Widget.Button">
+        <item name="android:width">@dimen/com_facebook_loginview_width</item>
+        <item name="android:height">@dimen/com_facebook_loginview_height</item>
+        <item name="android:background">@drawable/com_facebook_loginbutton_blue</item>
+        <item name="android:textColor">@color/com_facebook_loginview_text_color</item>
+        <item name="android:textSize">@dimen/com_facebook_loginview_text_size</item>
+        <item name="android:paddingLeft">@dimen/com_facebook_loginview_padding_left</item>
+        <item name="android:gravity">center</item>
+    </style>
+    
+    <style name="com_facebook_loginview_silver_style" parent="@android:style/Widget.Button">
+        <item name="android:width">205dp</item>
+        <item name="android:height">44dp</item>
+        <item name="android:background">@drawable/com_facebook_loginbutton_silver</item>
+        <item name="android:textSize">18sp</item>
+        <item name="android:textStyle">bold</item>
+        <item name="android:textColor">#4B5164</item>
+        <item name="android:gravity">center</item>
+    </style>
+</resources>
diff --git a/facebook/src/com/facebook/AccessToken.java b/facebook/src/com/facebook/AccessToken.java
new file mode 100644
index 000000000..b24241cf9
--- /dev/null
+++ b/facebook/src/com/facebook/AccessToken.java
@@ -0,0 +1,234 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.annotation.SuppressLint;
+import android.content.Intent;
+import android.os.Bundle;
+
+import java.io.InvalidObjectException;
+import java.io.ObjectInputStream;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+
+final class AccessToken implements Serializable {
+    private static final long serialVersionUID = 1L;
+    static final String ACCESS_TOKEN_KEY = "access_token";
+    static final String EXPIRES_IN_KEY = "expires_in";
+    private static final Date MIN_DATE = new Date(Long.MIN_VALUE);
+    private static final Date MAX_DATE = new Date(Long.MAX_VALUE);
+
+    private final Date expires;
+    private final List<String> permissions;
+    private final String token;
+    private final boolean isSSO;
+    private final Date lastRefresh;
+
+    AccessToken(String token, Date expires, List<String> permissions, boolean isSSO, Date lastRefresh) {
+        this.expires = expires;
+        this.permissions = permissions;
+        this.token = token;
+        this.isSSO = isSSO;
+        this.lastRefresh = lastRefresh;
+    }
+
+    String getToken() {
+        return this.token;
+    }
+
+    Date getExpires() {
+        return this.expires;
+    }
+
+    List<String> getPermissions() {
+        return this.permissions;
+    }
+
+    boolean getIsSSO() {
+        return this.isSSO;
+    }
+
+    Date getLastRefresh() {
+        return this.lastRefresh;
+    }
+
+    static AccessToken createEmptyToken(List<String> permissions) {
+        return new AccessToken("", MIN_DATE, permissions, false, MIN_DATE);
+    }
+
+    static AccessToken createFromString(String token, List<String> permissions) {
+        return new AccessToken(token, MAX_DATE, permissions, false, new Date());
+    }
+
+    static AccessToken createFromDialog(List<String> requestedPermissions, Bundle bundle) {
+        return createNew(requestedPermissions, bundle, false, new Date());
+    }
+
+    static AccessToken createFromSSO(List<String> requestedPermissions, Intent data) {
+        return createNew(requestedPermissions, data.getExtras(), true, new Date());
+    }
+
+    @SuppressLint("FieldGetter")
+    static AccessToken createForRefresh(AccessToken current, Bundle bundle) {
+        // isSSO is set true since only SSO tokens support refresh. Token refresh returns the expiration date in
+        // seconds from the epoch rather than seconds from now.
+
+        return createNew(current.getPermissions(), bundle, true, new Date(0));
+    }
+
+    private static AccessToken createNew(List<String> requestedPermissions, Bundle bundle, boolean isSSO,
+            Date expirationBase) {
+        String token = bundle.getString(ACCESS_TOKEN_KEY);
+        Date expires = getExpiresInDate(bundle, expirationBase);
+
+        if (Utility.isNullOrEmpty(token) || (expires == null)) {
+            return null;
+        }
+
+        return new AccessToken(token, expires, requestedPermissions, isSSO, new Date());
+    }
+
+    static AccessToken createFromCache(Bundle bundle) {
+        // Copy the list so we can guarantee immutable
+        List<String> originalPermissions = bundle.getStringArrayList(TokenCache.PERMISSIONS_KEY);
+        List<String> permissions;
+        if (originalPermissions == null) {
+            permissions = Collections.emptyList();
+        } else {
+            permissions = Collections.unmodifiableList(new ArrayList<String>(originalPermissions));
+        }
+
+        return new AccessToken(bundle.getString(TokenCache.TOKEN_KEY), TokenCache.getDate(bundle,
+                TokenCache.EXPIRATION_DATE_KEY), permissions, bundle.getBoolean(TokenCache.IS_SSO_KEY),
+                TokenCache.getDate(bundle, TokenCache.LAST_REFRESH_DATE_KEY));
+    }
+
+    Bundle toCacheBundle() {
+        Bundle bundle = new Bundle();
+
+        bundle.putString(TokenCache.TOKEN_KEY, this.token);
+        TokenCache.putDate(bundle, TokenCache.EXPIRATION_DATE_KEY, expires);
+        bundle.putStringArrayList(TokenCache.PERMISSIONS_KEY, new ArrayList<String>(permissions));
+        bundle.putBoolean(TokenCache.IS_SSO_KEY, isSSO);
+        TokenCache.putDate(bundle, TokenCache.LAST_REFRESH_DATE_KEY, lastRefresh);
+
+        return bundle;
+    }
+
+    boolean isInvalid() {
+        return Utility.isNullOrEmpty(this.token) || new Date().after(this.expires);
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+
+        builder.append("{AccessToken");
+        builder.append(" token:").append(tokenToString());
+        appendPermissions(builder);
+        builder.append("}");
+
+        return builder.toString();
+    }
+
+    private String tokenToString() {
+        if (this.token == null) {
+            return "null";
+        } else if (Settings.isLoggingBehaviorEnabled(LoggingBehaviors.INCLUDE_ACCESS_TOKENS)) {
+            return this.token;
+        } else {
+            return "ACCESS_TOKEN_REMOVED";
+        }
+    }
+
+    private void appendPermissions(StringBuilder builder) {
+        builder.append(" permissions:");
+        if (this.permissions == null) {
+            builder.append("null");
+        } else {
+            builder.append("[");
+            for (int i = 0; i < this.permissions.size(); i++) {
+                if (i > 0) {
+                    builder.append(", ");
+                }
+                builder.append(this.permissions.get(i));
+            }
+        }
+    }
+
+    private static class SerializationProxyV1 implements Serializable {
+        private static final long serialVersionUID = -2488473066578201069L;
+        private final Date expires;
+        private final List<String> permissions;
+        private final String token;
+        private final boolean isSSO;
+        private final Date lastRefresh;
+
+        private SerializationProxyV1(String token, Date expires,
+                List<String> permissions, boolean isSSO, Date lastRefresh) {
+            this.expires = expires;
+            this.permissions = permissions;
+            this.token = token;
+            this.isSSO = isSSO;
+            this.lastRefresh = lastRefresh;
+        }
+
+        private Object readResolve() {
+            return new AccessToken(token, expires, permissions, isSSO, lastRefresh);
+        }
+    }
+
+    private Object writeReplace() {
+        return new SerializationProxyV1(token, expires, permissions, isSSO, lastRefresh);
+    }
+
+    // have a readObject that throws to prevent spoofing
+    private void readObject(ObjectInputStream stream) throws InvalidObjectException {
+        throw new InvalidObjectException("Cannot readObject, serialization proxy required");
+    }
+
+
+    private static Date getExpiresInDate(Bundle bundle, Date expirationBase) {
+        if (bundle == null) {
+            return null;
+        }
+
+        long secondsFromBase = Long.MIN_VALUE;
+
+        Object secondsObject = bundle.get(EXPIRES_IN_KEY);
+        if (secondsObject instanceof Long) {
+            secondsFromBase = (Long)secondsObject;
+        } else if (secondsObject instanceof String) {
+            try {
+                secondsFromBase = Long.parseLong((String)secondsObject);
+            } catch (NumberFormatException e) {
+                return null;
+            }
+        } else {
+            return null;
+        }
+
+        if (secondsFromBase == 0) {
+            return new Date(Long.MAX_VALUE);
+        } else {
+            return new Date(expirationBase.getTime() + (secondsFromBase * 1000L));
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookActivity.java b/facebook/src/com/facebook/FacebookActivity.java
new file mode 100644
index 000000000..fcc8d7cbe
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookActivity.java
@@ -0,0 +1,328 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+
+import java.util.Date;
+import java.util.List;
+
+/**
+ * <p>Basic implementation of an Activity that uses a Session to perform 
+ * Single Sign On (SSO).</p>
+ * 
+ * <p>Numerous Activity lifecycle methods are overridden in this class
+ * to manage session information. If you override Activity lifecycle methods,
+ * be sure to call the appropriate {@code super} method.
+ * 
+ * <p>The methods in this class are not thread-safe</p>
+ */
+public class FacebookActivity extends FragmentActivity {
+
+    private static final String SESSION_IS_ACTIVE_KEY = "com.facebook.sdk.FacebookActivity.sessionIsActiveKey";
+
+    private SessionTracker sessionTracker;
+
+    /**
+     * Initializes the state in FacebookActivity. This method will try to restore the Session
+     * if one was saved. If the restored Session object was the active Session, it will also set
+     * the restored Session as the active Session (unless there's currently an active Session
+     * already set).
+     */
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        Session.StatusCallback callback = new DefaultSessionStatusCallback();
+        sessionTracker = new SessionTracker(this, callback);
+        if (savedInstanceState != null) {
+            Session session = Session.restoreSession(this, null, callback, savedInstanceState);
+            if (session != null) {
+                if (savedInstanceState.getBoolean(SESSION_IS_ACTIVE_KEY)) {
+                    if (Session.getActiveSession() == null) {
+                        Session.setActiveSession(session);
+                    }
+                } else {
+                    sessionTracker.setSession(session);
+                }
+            }
+        }
+    }
+
+    /**
+     * Called when the activity that was launched exits. This method manages session
+     * information when a session is opened. If this method is overridden in subclasses,
+     * be sure to call {@code super.onActivityResult(...)} first.
+     */
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        sessionTracker.getSession().onActivityResult(this, requestCode, resultCode, data);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        sessionTracker.stopTracking();
+    }
+
+    /**
+     * This method will save the session state so that it can be restored during
+     * onCreate.
+     */
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        Session currentSession = sessionTracker.getSession();
+        Session.saveSession(currentSession, outState);
+        outState.putBoolean(SESSION_IS_ACTIVE_KEY, sessionTracker.isTrackingActiveSession());
+    }
+
+    // METHOD TO BE OVERRIDDEN
+    
+    /**
+     * Called when the session state changes. Override this method to take action
+     * on session state changes.
+     * 
+     * @param state the new Session state
+     * @param exception any exceptions that occurred during the state change
+     */
+    protected void onSessionStateChange(SessionState state, Exception exception) {
+    }
+
+    /** 
+     * Use the supplied Session object instead of the active Session.
+     * 
+     * @param newSession the Session object to use
+     */
+    protected void setSession(Session newSession) {
+        sessionTracker.setSession(newSession);
+    }
+
+    // ACCESSORS (CANNOT BE OVERRIDDEN)
+
+    /**
+     * Gets the current session for this Activity
+     *
+     * @return the current session, or null if one has not been set.
+     */
+    protected final Session getSession() {
+        return sessionTracker.getSession();
+    }
+
+    /**
+     * Determines whether the current session is open.
+     * 
+     * @return true if the current session is open
+     */
+    protected final boolean isSessionOpen() {
+        return sessionTracker.getOpenSession() != null;
+    }
+    
+    /**
+     * Gets the current state of the session or null if no session has been created.
+     * 
+     * @return the current state of the session
+     */
+    protected final SessionState getSessionState() {
+        Session currentSession = sessionTracker.getSession();
+        return (currentSession != null) ? currentSession.getState() : null;
+    }
+    
+    /**
+     * Gets the access token associated with the current session or null if no 
+     * session has been created.
+     * 
+     * @return the access token
+     */
+    protected final String getAccessToken() {
+        Session currentSession = sessionTracker.getOpenSession();
+        return (currentSession != null) ? currentSession.getAccessToken() : null;
+    }
+
+    /**
+     * Gets the date at which the current session will expire or null if no session 
+     * has been created.
+     * 
+     * @return the date at which the current session will expire
+     */
+    protected final Date getExpirationDate() {
+        Session currentSession = sessionTracker.getOpenSession();
+        return (currentSession != null) ? currentSession.getExpirationDate() : null;
+    }
+    
+    /**
+     * Closes the current session.
+     */
+    protected final void closeSession() {
+        Session currentSession = sessionTracker.getOpenSession();
+        if (currentSession != null) {
+            currentSession.close();
+        }
+    }
+    
+    /**
+     * Closes the current session as well as clearing the token cache.
+     */
+    protected final void closeSessionAndClearTokenInformation() {
+        Session currentSession = sessionTracker.getOpenSession();
+        if (currentSession != null) {
+            currentSession.closeAndClearTokenInformation();
+        }
+    }
+    
+    /**
+     * Gets the permissions associated with the current session or null if no session 
+     * has been created.
+     * 
+     * @return the permissions associated with the current session
+     */
+    protected final List<String> getSessionPermissions() {
+        Session currentSession = sessionTracker.getSession();
+        return (currentSession != null) ? currentSession.getPermissions() : null;
+    }
+
+    /**
+     * Opens a new session. This method will use the application id from
+     * the associated meta-data value and an empty list of permissions.
+     * <p>
+     * If no session exists for this Activity, or if the current session has been closed,
+     * this will create a new Session object and set it as the active session. If a session
+     * exists for this Activity but is not yet open, this will try to open the session.
+     * If a session is already open for this Activity, this does nothing.
+     * </p>
+     */
+    protected final void openSession() {
+        openSessionForRead(null, null);
+    }
+    
+    /**
+     * Opens a new session with read permissions. If either applicationID or permissions
+     * is null, this method will default to using the values from the associated
+     * meta-data value and an empty list respectively.
+     * <p>
+     * If no session exists for this Activity, or if the current session has been closed,
+     * this will create a new Session object and set it as the active session. If a session
+     * exists for this Activity but is not yet open, this will try to open the session.
+     * If a session is already open for this Activity, this does nothing.
+     * </p>
+     *
+     * @param applicationId the applicationID, can be null
+     * @param permissions the permissions list, can be null
+     */
+    protected final void openSessionForRead(String applicationId, List<String> permissions) {
+        openSessionForRead(applicationId, permissions, SessionLoginBehavior.SSO_WITH_FALLBACK,
+                Session.DEFAULT_AUTHORIZE_ACTIVITY_CODE);
+    }
+    
+    /**
+     * Opens a new session with read permissions. If either applicationID or permissions
+     * is null, this method will default to using the values from the associated
+     * meta-data value and an empty list respectively.
+     * <p>
+     * If no session exists for this Activity, or if the current session has been closed,
+     * this will create a new Session object and set it as the active session. If a session
+     * exists for this Activity but is not yet open, this will try to open the session.
+     * If a session is already open for this Activity, this does nothing.
+     * </p>
+     *
+     * @param applicationId the applicationID, can be null
+     * @param permissions the permissions list, can be null
+     * @param behavior the login behavior to use with the session
+     * @param activityCode the activity code to use for the SSO activity
+     */
+    protected final void openSessionForRead(String applicationId, List<String> permissions,
+            SessionLoginBehavior behavior, int activityCode) {
+        openSession(applicationId, permissions, behavior, activityCode, Session.AuthorizationType.READ);
+    }
+
+    /**
+     * Opens a new session with publish permissions. If the applicationID is null,
+     * this method will default to using the value from the associated
+     * meta-data value. The permissions list cannot be null.
+     * <p>
+     * If no session exists for this Activity, or if the current session has been closed,
+     * this will create a new Session object and set it as the active session. If a session
+     * exists for this Activity but is not yet open, this will try to open the session.
+     * If a session is already open for this Activity, this does nothing.
+     * </p>
+     *
+     * @param applicationId the applicationID, can be null
+     * @param permissions the permissions list, cannot be null
+     */
+    protected final void openSessionForPublish(String applicationId, List<String> permissions) {
+        openSessionForPublish(applicationId, permissions, SessionLoginBehavior.SSO_WITH_FALLBACK,
+                Session.DEFAULT_AUTHORIZE_ACTIVITY_CODE);
+    }
+
+    /**
+     * Opens a new session with publish permissions. If the applicationID is null,
+     * this method will default to using the value from the associated
+     * meta-data value. The permissions list cannot be null.
+     * <p>
+     * If no session exists for this Activity, or if the current session has been closed,
+     * this will create a new Session object and set it as the active session. If a session
+     * exists for this Activity but is not yet open, this will try to open the session.
+     * If a session is already open for this Activity, this does nothing.
+     * </p>
+     *
+     * @param applicationId the applicationID, can be null
+     * @param permissions the permissions list, cannot be null
+     * @param behavior the login behavior to use with the session
+     * @param activityCode the activity code to use for the SSO activity
+     */
+    protected final void openSessionForPublish(String applicationId, List<String> permissions,
+            SessionLoginBehavior behavior, int activityCode) {
+        openSession(applicationId, permissions, behavior, activityCode, Session.AuthorizationType.PUBLISH);
+    }
+
+    private void openSession(String applicationId, List<String> permissions,
+            SessionLoginBehavior behavior, int activityCode, Session.AuthorizationType authType) {
+        Session currentSession = sessionTracker.getSession();
+        if (currentSession == null || currentSession.getState().isClosed()) {
+            Session session = new Session.Builder(this).setApplicationId(applicationId).build();
+            Session.setActiveSession(session);
+            currentSession = session;
+        }
+        if (!currentSession.isOpened()) {
+            Session.OpenRequest openRequest = new Session.OpenRequest(this).
+                    setPermissions(permissions).
+                    setLoginBehavior(behavior).
+                    setRequestCode(activityCode);
+            if (Session.AuthorizationType.PUBLISH.equals(authType)) {
+                currentSession.openForPublish(openRequest);
+            } else {
+                currentSession.openForRead(openRequest);
+            }
+        }
+    }
+
+    /**
+     * The default callback implementation for the session.
+     */
+    private class DefaultSessionStatusCallback implements Session.StatusCallback {
+
+        @Override
+        public void call(Session session, 
+                         SessionState state,
+                         Exception exception) {
+            FacebookActivity.this.onSessionStateChange(state, exception);
+        }
+        
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookAuthorizationException.java b/facebook/src/com/facebook/FacebookAuthorizationException.java
new file mode 100644
index 000000000..01f7876c6
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookAuthorizationException.java
@@ -0,0 +1,65 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * An Exception indicating that a Session failed to open or reauthorize.
+ */
+public class FacebookAuthorizationException extends FacebookException {
+    static final long serialVersionUID = 1;
+
+    /**
+     * Constructs a FacebookAuthorizationException with no additional
+     * information.
+     */
+    public FacebookAuthorizationException() {
+        super();
+    }
+
+    /**
+     * Constructs a FacebookAuthorizationException with a message.
+     * 
+     * @param message
+     *            A String to be returned from getMessage.
+     */
+    public FacebookAuthorizationException(String message) {
+        super(message);
+    }
+
+    /**
+     * Constructs a FacebookAuthorizationException with a message and inner
+     * error.
+     * 
+     * @param message
+     *            A String to be returned from getMessage.
+     * @param throwable
+     *            A Throwable to be returned from getCause.
+     */
+    public FacebookAuthorizationException(String message, Throwable throwable) {
+        super(message, throwable);
+    }
+
+    /**
+     * Constructs a FacebookAuthorizationException with an inner error.
+     * 
+     * @param throwable
+     *            A Throwable to be returned from getCause.
+     */
+    public FacebookAuthorizationException(Throwable throwable) {
+        super(throwable);
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookException.java b/facebook/src/com/facebook/FacebookException.java
new file mode 100644
index 000000000..83f3112c2
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookException.java
@@ -0,0 +1,63 @@
+/**
+ * Copyright 2010 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Represents an error condition specific to the Facebook SDK for Android.
+ */
+public class FacebookException extends RuntimeException {
+    static final long serialVersionUID = 1;
+
+    /**
+     * Constructs a new FacebookException.
+     */
+    public FacebookException() {
+        super();
+    }
+
+    /**
+     * Constructs a new FacebookException.
+     * 
+     * @param message
+     *            the detail message of this exception
+     */
+    public FacebookException(String message) {
+        super(message);
+    }
+
+    /**
+     * Constructs a new FacebookException.
+     * 
+     * @param message
+     *            the detail message of this exception
+     * @param throwable
+     *            the cause of this exception
+     */
+    public FacebookException(String message, Throwable throwable) {
+        super(message, throwable);
+    }
+
+    /**
+     * Constructs a new FacebookException.
+     * 
+     * @param throwable
+     *            the cause of this exception
+     */
+    public FacebookException(Throwable throwable) {
+        super(throwable);
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookFragment.java b/facebook/src/com/facebook/FacebookFragment.java
new file mode 100644
index 000000000..d75aa625c
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookFragment.java
@@ -0,0 +1,266 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+
+import java.util.Date;
+import java.util.List;
+
+/**
+ * <p>Basic implementation of a Fragment that uses a Session to perform 
+ * Single Sign On (SSO). This class is package private, and is not intended
+ * to be consumed by external applications.</p>
+ * 
+ * <p>The method {@link android.support.v4.app.Fragment#onActivityResult} is
+ * used to manage the session information, so if you override it in a subclass, 
+ * be sure to call {@code super.onActivityResult}.</p>
+ * 
+ * <p>The methods in this class are not thread-safe.</p>
+ */
+class FacebookFragment extends Fragment {
+
+    private SessionTracker sessionTracker;
+
+    @Override
+    public void onActivityCreated(Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+        sessionTracker = new SessionTracker(getActivity(), new DefaultSessionStatusCallback());
+    }
+    
+    /**
+     * Called when the activity that was launched exits. This method manages session
+     * information when a session is opened. If this method is overridden in subclasses,
+     * be sure to call {@code super.onActivityResult(...)} first.
+     */
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        sessionTracker.getSession().onActivityResult(this.getActivity(), requestCode, resultCode, data);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        sessionTracker.stopTracking();
+    }
+
+    /**
+     * Use the supplied Session object instead of the active Session.
+     *
+     * @param newSession the Session object to use
+     */
+    public void setSession(Session newSession) {
+        sessionTracker.setSession(newSession);
+    }
+
+    // METHOD TO BE OVERRIDDEN
+    
+    /**
+     * Called when the session state changes. Override this method to take action
+     * on session state changes.
+     * 
+     * @param state the new state
+     * @param exception any exceptions that occurred during the state change
+     */
+    protected void onSessionStateChange(SessionState state, Exception exception) {
+    }
+
+    // ACCESSORS (CANNOT BE OVERRIDDEN)
+    
+    /**
+     * Gets the current Session.
+     * 
+     * @return the current Session object.
+     */
+    protected final Session getSession() {
+        return sessionTracker.getSession();
+    }
+
+    /**
+     * Determines whether the current session is open.
+     * 
+     * @return true if the current session is open
+     */
+    protected final boolean isSessionOpen() {
+        return sessionTracker.getOpenSession() != null;
+    }
+    
+    /**
+     * Gets the current state of the session or null if no session has been created.
+     * 
+     * @return the current state of the session
+     */
+    protected final SessionState getSessionState() {
+        Session currentSession = sessionTracker.getSession();
+        return (currentSession != null) ? currentSession.getState() : null;
+    }
+    
+    /**
+     * Gets the access token associated with the current session or null if no 
+     * session has been created.
+     * 
+     * @return the access token
+     */
+    protected final String getAccessToken() {
+        Session currentSession = sessionTracker.getOpenSession();
+        return (currentSession != null) ? currentSession.getAccessToken() : null;
+    }
+
+    /**
+     * Gets the date at which the current session will expire or null if no session 
+     * has been created.
+     * 
+     * @return the date at which the current session will expire
+     */
+    protected final Date getExpirationDate() {
+        Session currentSession = sessionTracker.getOpenSession();
+        return (currentSession != null) ? currentSession.getExpirationDate() : null;
+    }
+    
+    /**
+     * Closes the current session.
+     */
+    protected final void closeSession() {
+        Session currentSession = sessionTracker.getOpenSession();
+        if (currentSession != null) {
+            currentSession.close();
+        }
+    }
+    
+    /**
+     * Closes the current session as well as clearing the token cache.
+     */
+    protected final void closeSessionAndClearTokenInformation() {
+        Session currentSession = sessionTracker.getOpenSession();
+        if (currentSession != null) {
+            currentSession.closeAndClearTokenInformation();
+        }
+    }
+    
+    /**
+     * Gets the permissions associated with the current session or null if no session 
+     * has been created.
+     * 
+     * @return the permissions associated with the current session
+     */
+    protected final List<String> getSessionPermissions() {
+        Session currentSession = sessionTracker.getSession();
+        return (currentSession != null) ? currentSession.getPermissions() : null;
+    }
+
+    /**
+     * Opens a new session. This method will use the application id from
+     * the associated meta-data value and an empty list of permissions.
+     */
+    protected final void openSession() {
+        openSessionForRead(null, null);
+    }
+
+    /**
+     * Opens a new session with read permissions. If either applicationID or permissions
+     * is null, this method will default to using the values from the associated
+     * meta-data value and an empty list respectively.
+     *
+     * @param applicationId the applicationID, can be null
+     * @param permissions the permissions list, can be null
+     */
+    protected final void openSessionForRead(String applicationId, List<String> permissions) {
+        openSessionForRead(applicationId, permissions, SessionLoginBehavior.SSO_WITH_FALLBACK,
+                Session.DEFAULT_AUTHORIZE_ACTIVITY_CODE);
+    }
+
+    /**
+     * Opens a new session with read permissions. If either applicationID or permissions
+     * is null, this method will default to using the values from the associated
+     * meta-data value and an empty list respectively.
+     *
+     * @param applicationId the applicationID, can be null
+     * @param permissions the permissions list, can be null
+     * @param behavior the login behavior to use with the session
+     * @param activityCode the activity code to use for the SSO activity
+     */
+    protected final void openSessionForRead(String applicationId, List<String> permissions,
+            SessionLoginBehavior behavior, int activityCode) {
+        openSession(applicationId, permissions, behavior, activityCode, Session.AuthorizationType.READ);
+    }
+
+    /**
+     * Opens a new session with publish permissions. If either applicationID is null,
+     * this method will default to using the value from the associated
+     * meta-data value. The permissions list cannot be null.
+     *
+     * @param applicationId the applicationID, can be null
+     * @param permissions the permissions list, cannot be null
+     */
+    protected final void openSessionForPublish(String applicationId, List<String> permissions) {
+        openSessionForPublish(applicationId, permissions, SessionLoginBehavior.SSO_WITH_FALLBACK,
+                Session.DEFAULT_AUTHORIZE_ACTIVITY_CODE);
+    }
+
+    /**
+     * Opens a new session with publish permissions. If either applicationID is null,
+     * this method will default to using the value from the associated
+     * meta-data value. The permissions list cannot be null.
+     *
+     * @param applicationId the applicationID, can be null
+     * @param permissions the permissions list, cannot be null
+     * @param behavior the login behavior to use with the session
+     * @param activityCode the activity code to use for the SSO activity
+     */
+    protected final void openSessionForPublish(String applicationId, List<String> permissions,
+            SessionLoginBehavior behavior, int activityCode) {
+        openSession(applicationId, permissions, behavior, activityCode, Session.AuthorizationType.PUBLISH);
+    }
+
+    private void openSession(String applicationId, List<String> permissions,
+            SessionLoginBehavior behavior, int activityCode, Session.AuthorizationType authType) {
+        Session currentSession = sessionTracker.getSession();
+        if (currentSession == null || currentSession.getState().isClosed()) {
+            Session session = new Session.Builder(getActivity()).setApplicationId(applicationId).build();
+            Session.setActiveSession(session);
+            currentSession = session;
+        }
+        if (!currentSession.isOpened()) {
+            Session.OpenRequest openRequest = new Session.OpenRequest(this).
+                    setPermissions(permissions).
+                    setLoginBehavior(behavior).
+                    setRequestCode(activityCode);
+            if (Session.AuthorizationType.PUBLISH.equals(authType)) {
+                currentSession.openForPublish(openRequest);
+            } else {
+                currentSession.openForRead(openRequest);
+            }
+        }
+    }
+
+    /**
+     * The default callback implementation for the session.
+     */
+    private class DefaultSessionStatusCallback implements Session.StatusCallback {
+
+        @Override
+        public void call(Session session, 
+                         SessionState state,
+                         Exception exception) {
+            FacebookFragment.this.onSessionStateChange(state, exception);
+        }
+        
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookGraphObjectException.java b/facebook/src/com/facebook/FacebookGraphObjectException.java
new file mode 100644
index 000000000..6e0932ab5
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookGraphObjectException.java
@@ -0,0 +1,47 @@
+package com.facebook;
+
+/**
+ * Represents an error specific to the {@link GraphObject GraphObject} class.
+ */
+public class FacebookGraphObjectException extends FacebookException {
+    static final long serialVersionUID = 1;
+
+    /**
+     * Constructs a new FacebookGraphObjectException.
+     */
+    public FacebookGraphObjectException() {
+        super();
+    }
+
+    /**
+     * Constructs a new FacebookGraphObjectException.
+     * 
+     * @param message
+     *            the detail message of this exception
+     */
+    public FacebookGraphObjectException(String message) {
+        super(message);
+    }
+
+    /**
+     * Constructs a new FacebookGraphObjectException.
+     * 
+     * @param message
+     *            the detail message of this exception
+     * @param throwable
+     *            the cause of this exception
+     */
+    public FacebookGraphObjectException(String message, Throwable throwable) {
+        super(message, throwable);
+    }
+
+    /**
+     * Constructs a new FacebookGraphObjectException.
+     * 
+     * @param throwable
+     *            the cause of this exception
+     */
+    public FacebookGraphObjectException(Throwable throwable) {
+        super(throwable);
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookOperationCanceledException.java b/facebook/src/com/facebook/FacebookOperationCanceledException.java
new file mode 100644
index 000000000..f45589532
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookOperationCanceledException.java
@@ -0,0 +1,43 @@
+package com.facebook;
+
+/**
+ * An Exception indicating that an operation was canceled before it completed.
+ */
+public class FacebookOperationCanceledException extends FacebookException {
+    static final long serialVersionUID = 1;
+
+    /**
+     * Constructs a FacebookOperationCanceledException with no additional information.
+     */
+    public FacebookOperationCanceledException() {
+        super();
+    }
+
+    /**
+     * Constructs a FacebookOperationCanceledException with a message.
+     *
+     * @param message A String to be returned from getMessage.
+     */
+    public FacebookOperationCanceledException(String message) {
+        super(message);
+    }
+
+    /**
+     * Constructs a FacebookOperationCanceledException with a message and inner error.
+     *
+     * @param message   A String to be returned from getMessage.
+     * @param throwable A Throwable to be returned from getCause.
+     */
+    public FacebookOperationCanceledException(String message, Throwable throwable) {
+        super(message, throwable);
+    }
+
+    /**
+     * Constructs a FacebookOperationCanceledException with an inner error.
+     *
+     * @param throwable A Throwable to be returned from getCause.
+     */
+    public FacebookOperationCanceledException(Throwable throwable) {
+        super(throwable);
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookSdkVersion.java b/facebook/src/com/facebook/FacebookSdkVersion.java
new file mode 100644
index 000000000..172d0d660
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookSdkVersion.java
@@ -0,0 +1,32 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Specifies sdk-version-specific data.
+ */
+public final class FacebookSdkVersion {
+    /**
+     * The build version string of this SDK.
+     */
+    public static final String BUILD = "3.0.1.b";
+
+    /**
+     * The migration bundle string with which this version of the SDK was tested.
+     */
+    public static final String MIGRATION_BUNDLE = "fbsdk:20120913";
+}
diff --git a/facebook/src/com/facebook/FacebookServiceErrorException.java b/facebook/src/com/facebook/FacebookServiceErrorException.java
new file mode 100644
index 000000000..87d6e719a
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookServiceErrorException.java
@@ -0,0 +1,107 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import org.json.JSONObject;
+
+/**
+ * Represents an error returned from the Facebook service in response to a request.
+ */
+public class FacebookServiceErrorException extends FacebookException {
+    /**
+     * Indicates no error code was returned by Facebook.
+     */
+    public static final int UNKNOWN_ERROR_CODE = -1;
+
+    private final int httpResponseCode;
+    private final int facebookErrorCode;
+    private final String facebookErrorType;
+    private final JSONObject responseBody;
+
+    static final long serialVersionUID = 1;
+
+    /**
+     * Constructs a new FacebookServiceErrorException.
+     * 
+     * @param responseCode the HTTP response code returned by Facebook
+     */
+    public FacebookServiceErrorException(int responseCode) {
+        this(responseCode, UNKNOWN_ERROR_CODE, null, null, null);
+    }
+
+    /**
+     * Constructs a new FacebookServiceErrorException.
+     * 
+     * @param responseCode the HTTP response code returned by Facebook
+     * @param facebookErrorCode the error code returned by Facebook
+     * @param facebookErrorType the error type returned by Facebook
+     * @param message the error message returned by Facebook
+     * @param responseBody the complete error response returned by Facebook.
+     */
+    public FacebookServiceErrorException(int responseCode, int facebookErrorCode, String facebookErrorType,
+            String message, JSONObject responseBody) {
+        super(message);
+        this.httpResponseCode = responseCode;
+        this.facebookErrorCode = facebookErrorCode;
+        this.facebookErrorType = facebookErrorType;
+        this.responseBody = responseBody;
+    }
+
+    /**
+     * Returns the HTTP response code returned by Facebook.
+     * @return the HTTP response code returned by Facebook
+     */
+    public final int getHttpResponseCode() {
+        return this.httpResponseCode;
+    }
+
+    /**
+     * Returns the error code returned by Facebook.
+     * @return the error code returned by Facebook
+     */
+    public final int getFacebookErrorCode() {
+        return this.facebookErrorCode;
+    }
+
+    /**
+     * Returns the error type returned by Facebook.
+     * @return the error type returned by Facebook
+     */
+    public final String getFacebookErrorType() {
+        return this.facebookErrorType;
+    }
+
+    /**
+     * Returns the complete error response returned by Facebook.
+     * @return the complete error resposne returned by Facebook
+     */
+    public final JSONObject getResponseBody() {
+        return this.responseBody;
+    }
+
+    /**
+     * Returns a debugging string.
+     */
+    @Override
+    public final String toString() {
+        return new StringBuilder().append("{FacebookServiceErrorException: ").append("httpResponseCode: ")
+                .append(this.httpResponseCode).append(", facebookErrorCode: ").append(this.facebookErrorCode)
+                .append(", facebookErrorType: ").append(this.facebookErrorType).append(", message: ")
+                .append(this.getMessage()).append("}").toString();
+    }
+
+}
diff --git a/facebook/src/com/facebook/FileLruCache.java b/facebook/src/com/facebook/FileLruCache.java
new file mode 100644
index 000000000..8cc2459eb
--- /dev/null
+++ b/facebook/src/com/facebook/FileLruCache.java
@@ -0,0 +1,524 @@
+/**
+ * Copyright 2010 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.Context;
+import android.util.Log;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.json.JSONTokener;
+
+import java.io.*;
+import java.security.InvalidParameterException;
+import java.util.Date;
+import java.util.PriorityQueue;
+import java.util.concurrent.atomic.AtomicLong;
+
+final class FileLruCache {
+    static final String TAG = FileLruCache.class.getSimpleName();
+    private static final String HEADER_CACHEKEY_KEY = "key";
+    private static final String HEADER_CACHE_CONTENT_TAG_KEY = "tag";
+
+    private static final AtomicLong bufferIndex = new AtomicLong();
+
+    private final String tag;
+    private final Limits limits;
+    private final File directory;
+
+    // The value of tag should be a final String that works as a directory name.
+    FileLruCache(Context context, String tag, Limits limits) {
+        this.tag = tag;
+        this.limits = limits;
+        this.directory = new File(context.getCacheDir(), tag);
+
+        // Ensure the cache dir exists
+        this.directory.mkdirs();
+
+        // Remove any stale partially-written files from a previous run
+        BufferFile.deleteAll(this.directory);
+    }
+
+    void clear() throws IOException {
+        for (File file : this.directory.listFiles()) {
+            file.delete();
+        }
+    }
+
+    InputStream get(String key) throws IOException {
+        return get(key, null);
+    }
+
+    InputStream get(String key, String contentTag) throws IOException {
+        File file = new File(this.directory, Utility.md5hash(key));
+
+        FileInputStream input = null;
+        try {
+            input = new FileInputStream(file);
+        } catch (IOException e) {
+            return null;
+        }
+
+        BufferedInputStream buffered = new BufferedInputStream(input, Utility.DEFAULT_STREAM_BUFFER_SIZE);
+        boolean success = false;
+
+        try {
+            JSONObject header = StreamHeader.readHeader(buffered);
+            if (header == null) {
+                return null;
+            }
+
+            String foundKey = header.optString(HEADER_CACHEKEY_KEY);
+            if ((foundKey == null) || !foundKey.equals(key)) {
+                return null;
+            }
+
+            String headerContentTag = header.optString(HEADER_CACHE_CONTENT_TAG_KEY, null);
+            if (headerContentTag != contentTag) {
+                return null;
+            }
+
+            long accessTime = new Date().getTime();
+            Logger.log(LoggingBehaviors.CACHE, TAG, "Setting lastModified to " + Long.valueOf(accessTime) + " for "
+                    + file.getName());
+            file.setLastModified(accessTime);
+
+            success = true;
+            return buffered;
+        } finally {
+            if (!success) {
+                buffered.close();
+            }
+        }
+    }
+
+    OutputStream openPutStream(final String key) throws IOException {
+        return openPutStream(key, null);
+    }
+
+    OutputStream openPutStream(final String key, String contentTag) throws IOException {
+        final File buffer = BufferFile.newFile(this.directory);
+        buffer.delete();
+        if (!buffer.createNewFile()) {
+            throw new IOException("Could not create file at " + buffer.getAbsolutePath());
+        }
+
+        FileOutputStream file = null;
+        try {
+            file = new FileOutputStream(buffer);
+        } catch (FileNotFoundException e) {
+            Logger.log(LoggingBehaviors.CACHE, Log.WARN, TAG, "Error creating buffer output stream: " + e);
+            throw new IOException(e.getMessage());
+        }
+
+        StreamCloseCallback renameToTargetCallback = new StreamCloseCallback() {
+            @Override
+            public void onClose() {
+                final File target = new File(directory, Utility.md5hash(key));
+                if (!buffer.renameTo(target)) {
+                    buffer.delete();
+                }
+                trim();
+            }
+        };
+
+        CloseCallbackOutputStream cleanup = new CloseCallbackOutputStream(file, renameToTargetCallback);
+        BufferedOutputStream buffered = new BufferedOutputStream(cleanup, Utility.DEFAULT_STREAM_BUFFER_SIZE);
+        boolean success = false;
+
+        try {
+            // Prefix the stream with the actual key, since there could be collisions
+            JSONObject header = new JSONObject();
+            header.put(HEADER_CACHEKEY_KEY, key);
+            if (!Utility.isNullOrEmpty(contentTag)) {
+                header.put(HEADER_CACHE_CONTENT_TAG_KEY, contentTag);
+            }
+
+            StreamHeader.writeHeader(buffered, header);
+
+            success = true;
+            return buffered;
+        } catch (JSONException e) {
+            // JSON is an implementation detail of the cache, so don't let JSON exceptions out.
+            Logger.log(LoggingBehaviors.CACHE, Log.WARN, TAG, "Error creating JSON header for cache file: " + e);
+            throw new IOException(e.getMessage());
+        } finally {
+            if (!success) {
+                buffered.close();
+            }
+        }
+    }
+
+    // Opens an output stream for the key, and creates an input stream wrapper to copy
+    // the contents of input into the new output stream.  The effect is to store a
+    // copy of input, and associate that data with key.
+    InputStream interceptAndPut(String key, InputStream input) throws IOException {
+        OutputStream output = openPutStream(key);
+        return new CopyingInputStream(input, output);
+    }
+
+    long sizeInBytes() {
+        File[] files = this.directory.listFiles();
+        long total = 0;
+        for (File file : files) {
+            total += file.length();
+        }
+        return total;
+    }
+
+    public synchronized String toString() {
+        return "{FileLruCache:" + " tag:" + this.tag + " file:" + this.directory.getName() + "}";
+    }
+
+    private void trim() {
+        Logger.log(LoggingBehaviors.CACHE, TAG, "trim started");
+        PriorityQueue<ModifiedFile> heap = new PriorityQueue<ModifiedFile>();
+        long size = 0;
+        long count = 0;
+        for (File file : this.directory.listFiles(BufferFile.excludeBufferFiles())) {
+            ModifiedFile modified = new ModifiedFile(file);
+            heap.add(modified);
+            Logger.log(LoggingBehaviors.CACHE, TAG, "  trim considering time=" + Long.valueOf(modified.getModified())
+                    + " name=" + modified.getFile().getName());
+
+            size += file.length();
+            count++;
+        }
+
+        while ((size > limits.getByteCount()) || (count > limits.getFileCount())) {
+            File file = heap.remove().getFile();
+            Logger.log(LoggingBehaviors.CACHE, TAG, "  trim removing " + file.getName());
+            size -= file.length();
+            count--;
+            file.delete();
+        }
+    }
+
+    private static class BufferFile {
+        private static final String FILE_NAME_PREFIX = "buffer";
+        private static final FilenameFilter filterExcludeBufferFiles = new FilenameFilter() {
+            @Override
+            public boolean accept(File dir, String filename) {
+                return !filename.startsWith(FILE_NAME_PREFIX);
+            }
+        };
+        private static final FilenameFilter filterExcludeNonBufferFiles = new FilenameFilter() {
+            @Override
+            public boolean accept(File dir, String filename) {
+                return filename.startsWith(FILE_NAME_PREFIX);
+            }
+        };
+
+        static void deleteAll(final File root) {
+            for (File file : root.listFiles(excludeNonBufferFiles())) {
+                file.delete();
+            }
+        }
+
+        static FilenameFilter excludeBufferFiles() {
+            return filterExcludeBufferFiles;
+        }
+
+        static FilenameFilter excludeNonBufferFiles() {
+            return filterExcludeNonBufferFiles;
+        }
+
+        static File newFile(final File root) {
+            String name = FILE_NAME_PREFIX + Long.valueOf(bufferIndex.incrementAndGet()).toString();
+            return new File(root, name);
+        }
+    }
+
+    // Treats the first part of a stream as a header, reads/writes it as a JSON blob, and
+    // leaves the stream positioned exactly after the header.
+    //
+    // The format is as follows:
+    //     byte: meaning
+    // ---------------------------------
+    //        0: version number
+    //      1-3: big-endian JSON header blob size
+    // 4-size+4: UTF-8 JSON header blob
+    //      ...: stream data
+    private static final class StreamHeader {
+        private static final int HEADER_VERSION = 0;
+
+        static void writeHeader(OutputStream stream, JSONObject header) throws IOException {
+            String headerString = header.toString();
+            byte[] headerBytes = headerString.getBytes();
+
+            // Write version number and big-endian header size
+            stream.write(HEADER_VERSION);
+            stream.write((headerBytes.length >> 16) & 0xff);
+            stream.write((headerBytes.length >> 8) & 0xff);
+            stream.write((headerBytes.length >> 0) & 0xff);
+
+            stream.write(headerBytes);
+        }
+
+        static JSONObject readHeader(InputStream stream) throws IOException {
+            int version = stream.read();
+            if (version != HEADER_VERSION) {
+                return null;
+            }
+
+            int headerSize = 0;
+            for (int i = 0; i < 3; i++) {
+                int b = stream.read();
+                if (b == -1) {
+                    Logger.log(LoggingBehaviors.CACHE, TAG,
+                            "readHeader: stream.read returned -1 while reading header size");
+                    return null;
+                }
+                headerSize <<= 8;
+                headerSize += b & 0xff;
+            }
+
+            byte[] headerBytes = new byte[headerSize];
+            int count = 0;
+            while (count < headerBytes.length) {
+                int readCount = stream.read(headerBytes, count, headerBytes.length - count);
+                if (readCount < 1) {
+                    Logger.log(LoggingBehaviors.CACHE, TAG,
+                            "readHeader: stream.read stopped at " + Integer.valueOf(count) + " when expected "
+                                    + headerBytes.length);
+                    return null;
+                }
+                count += readCount;
+            }
+
+            String headerString = new String(headerBytes);
+            JSONObject header = null;
+            JSONTokener tokener = new JSONTokener(headerString);
+            try {
+                Object parsed = tokener.nextValue();
+                if (!(parsed instanceof JSONObject)) {
+                    Logger.log(LoggingBehaviors.CACHE, TAG, "readHeader: expected JSONObject, got " + parsed.getClass().getCanonicalName());
+                    return null;
+                }
+                header = (JSONObject) parsed;
+            } catch (JSONException e) {
+                throw new IOException(e.getMessage());
+            }
+
+            return header;
+        }
+    }
+
+    private static class CloseCallbackOutputStream extends OutputStream {
+        final OutputStream innerStream;
+        final StreamCloseCallback callback;
+
+        CloseCallbackOutputStream(OutputStream innerStream, StreamCloseCallback callback) {
+            this.innerStream = innerStream;
+            this.callback = callback;
+        }
+
+        @Override
+        public void close() throws IOException {
+            try {
+                this.innerStream.close();
+            } finally {
+                this.callback.onClose();
+            }
+        }
+
+        @Override
+        public void flush() throws IOException {
+            this.innerStream.flush();
+        }
+
+        @Override
+        public void write(byte[] buffer, int offset, int count) throws IOException {
+            this.innerStream.write(buffer, offset, count);
+        }
+
+        @Override
+        public void write(byte[] buffer) throws IOException {
+            this.innerStream.write(buffer);
+        }
+
+        @Override
+        public void write(int oneByte) throws IOException {
+            this.innerStream.write(oneByte);
+        }
+    }
+
+    private static final class CopyingInputStream extends InputStream {
+        final InputStream input;
+        final OutputStream output;
+
+        CopyingInputStream(final InputStream input, final OutputStream output) {
+            this.input = input;
+            this.output = output;
+        }
+
+        @Override
+        public int available() throws IOException {
+            return input.available();
+        }
+
+        @Override
+        public void close() throws IOException {
+            // According to http://www.cs.cornell.edu/andru/javaspec/11.doc.html:
+            //  "If a finally clause is executed because of abrupt completion of a try block and the finally clause
+            //   itself completes abruptly, then the reason for the abrupt completion of the try block is discarded
+            //   and the new reason for abrupt completion is propagated from there."
+            //
+            // Android does appear to behave like this.
+            try {
+                this.input.close();
+            } finally {
+                this.output.close();
+            }
+        }
+
+        @Override
+        public void mark(int readlimit) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean markSupported() {
+            return false;
+        }
+
+        @Override
+        public int read(byte[] buffer) throws IOException {
+            int count = input.read(buffer);
+            if (count > 0) {
+                output.write(buffer, 0, count);
+            }
+            return count;
+        }
+
+        @Override
+        public int read() throws IOException {
+            int b = input.read();
+            if (b >= 0) {
+                output.write(b);
+            }
+            return b;
+        }
+
+        @Override
+        public int read(byte[] buffer, int offset, int length) throws IOException {
+            int count = input.read(buffer, offset, length);
+            if (count > 0) {
+                output.write(buffer, offset, count);
+            }
+            return count;
+        }
+
+        @Override
+        public synchronized void reset() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public long skip(long byteCount) throws IOException {
+            byte[] buffer = new byte[1024];
+            long total = 0;
+            while (total < byteCount) {
+                int count = read(buffer, 0, (int)Math.min(byteCount - total, buffer.length));
+                if (count < 0) {
+                    return total;
+                }
+                total += count;
+            }
+            return total;
+        }
+    }
+
+    static final class Limits {
+        private int byteCount;
+        private int fileCount;
+
+        Limits() {
+            // A Samsung Galaxy Nexus can create 1k files in half a second.  By the time
+            // it gets to 5k files it takes 5 seconds.  10k files took 15 seconds.  This
+            // continues to slow down as files are added.  This assumes all files are in
+            // a single directory.
+            //
+            // Following a git-like strategy where we partition MD5-named files based on
+            // the first 2 characters is slower across the board.
+            this.fileCount = 1024;
+            this.byteCount = 1024 * 1024;
+        }
+
+        int getByteCount() {
+            return byteCount;
+        }
+
+        int getFileCount() {
+            return fileCount;
+        }
+
+        void setByteCount(int n) {
+            if (n < 0) {
+                throw new InvalidParameterException("Cache byte-count limit must be >= 0");
+            }
+            byteCount = n;
+        }
+
+        void setFileCount(int n) {
+            if (n < 0) {
+                throw new InvalidParameterException("Cache file count limit must be >= 0");
+            }
+            fileCount = n;
+        }
+    }
+
+    // Caches the result of lastModified during sort/heap operations
+    private final static class ModifiedFile implements Comparable<ModifiedFile> {
+        private final File file;
+        private final long modified;
+
+        ModifiedFile(File file) {
+            this.file = file;
+            this.modified = file.lastModified();
+        }
+
+        File getFile() {
+            return file;
+        }
+
+        long getModified() {
+            return modified;
+        }
+
+        @Override
+        public int compareTo(ModifiedFile another) {
+            if (getModified() < another.getModified()) {
+                return -1;
+            } else if (getModified() > another.getModified()) {
+                return 1;
+            } else {
+                return getFile().compareTo(another.getFile());
+            }
+        }
+
+        @Override
+        public boolean equals(Object another) {
+            return
+                    (another instanceof ModifiedFile) &&
+                    (compareTo((ModifiedFile)another) == 0);
+        }
+    }
+
+    private interface StreamCloseCallback {
+        void onClose();
+    }
+}
diff --git a/facebook/src/com/facebook/FriendPickerFragment.java b/facebook/src/com/facebook/FriendPickerFragment.java
new file mode 100644
index 000000000..bbc290f9b
--- /dev/null
+++ b/facebook/src/com/facebook/FriendPickerFragment.java
@@ -0,0 +1,252 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.annotation.SuppressLint;
+import android.app.Activity;
+import android.content.res.TypedArray;
+import android.os.Bundle;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import com.facebook.android.R;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * Provides a Fragment that displays a list of a user's friends and allows one or more of the
+ * friends to be selected.
+ */
+public class FriendPickerFragment extends GraphObjectListFragment<GraphUser> {
+    /**
+     * The key for a String parameter in the fragment's Intent bundle to indicate what user's
+     * friends should be shown. The default is to display the currently authenticated user's friends.
+     */
+    public static final String USER_ID_BUNDLE_KEY = "com.facebook.FriendPickerFragment.UserId";
+    /**
+     * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
+     * picker should allow more than one friend to be selected or not.
+     */
+    public static final String MULTI_SELECT_BUNDLE_KEY = "com.facebook.FriendPickerFragment.MultiSelect";
+
+    private static final String ID = "id";
+    private static final String NAME = "name";
+
+    private String userId;
+
+    private boolean multiSelect = true;
+
+    /**
+     * Default constructor. Creates a Fragment with all default properties.
+     */
+    public FriendPickerFragment() {
+        this(null);
+    }
+
+    /**
+     * Constructor.
+     * @param args  a Bundle that optionally contains one or more values containing additional
+     *              configuration information for the Fragment.
+     */
+    @SuppressLint("ValidFragment")
+    public FriendPickerFragment(Bundle args) {
+        super(GraphUser.class, R.layout.com_facebook_friendpickerfragment, args);
+        setFriendPickerSettingsFromBundle(args);
+    }
+
+    /**
+     * Gets the ID of the user whose friends should be displayed. If null, the default is to
+     * show the currently authenticated user's friends.
+     * @return the user ID, or null
+     */
+    public String getUserId() {
+        return userId;
+    }
+
+    /**
+     * Sets the ID of the user whose friends should be displayed. If null, the default is to
+     * show the currently authenticated user's friends.
+     * @param userId     the user ID, or null
+     */
+    public void setUserId(String userId) {
+        this.userId = userId;
+    }
+
+    /**
+     * Gets whether the user can select multiple friends, or only one friend.
+     * @return true if the user can select multiple friends, false if only one friend
+     */
+    public boolean getMultiSelect() {
+        return multiSelect;
+    }
+
+    /**
+     * Sets whether the user can select multiple friends, or only one friend.
+     * @param multiSelect    true if the user can select multiple friends, false if only one friend
+     */
+    public void setMultiSelect(boolean multiSelect) {
+        if (this.multiSelect != multiSelect) {
+            this.multiSelect = multiSelect;
+            setSelectionStrategy(createSelectionStrategy());
+        }
+    }
+
+    /**
+     * Gets the currently-selected list of users.
+     * @return the currently-selected list of users
+     */
+    public List<GraphUser> getSelection() {
+        return getSelectedGraphObjects();
+    }
+
+    @Override
+    public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
+        super.onInflate(activity, attrs, savedInstanceState);
+        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.com_facebook_friend_picker_fragment);
+
+        setMultiSelect(a.getBoolean(R.styleable.com_facebook_friend_picker_fragment_multi_select, multiSelect));
+
+        a.recycle();
+    }
+
+    public void setSettingsFromBundle(Bundle inState) {
+        super.setSettingsFromBundle(inState);
+        setFriendPickerSettingsFromBundle(inState);
+    }
+
+    void saveSettingsToBundle(Bundle outState) {
+        super.saveSettingsToBundle(outState);
+
+        outState.putString(USER_ID_BUNDLE_KEY, userId);
+        outState.putBoolean(MULTI_SELECT_BUNDLE_KEY, multiSelect);
+    }
+
+    @Override
+    GraphObjectListFragmentAdapter<GraphUser> createAdapter() {
+        GraphObjectListFragmentAdapter<GraphUser> adapter = new GraphObjectListFragmentAdapter<GraphUser>(
+                this.getActivity()) {
+
+            @Override
+            protected int getGraphObjectRowLayoutId(GraphUser graphObject) {
+                return R.layout.com_facebook_picker_list_row;
+            }
+
+            @Override
+            protected int getDefaultPicture() {
+                return R.drawable.com_facebook_profile_default_icon;
+            }
+
+        };
+        adapter.setShowCheckbox(true);
+        adapter.setShowPicture(getShowPictures());
+        adapter.setSortFields(Arrays.asList(new String[]{NAME}));
+        adapter.setGroupByField(NAME);
+
+        return adapter;
+    }
+
+    @Override
+    LoadingStrategy createLoadingStrategy() {
+        return new ImmediateLoadingStrategy();
+    }
+
+    @Override
+    SelectionStrategy createSelectionStrategy() {
+        return multiSelect ? new MultiSelectionStrategy() : new SingleSelectionStrategy();
+    }
+
+    @Override
+    Request getRequestForLoadData(Session session) {
+        if (adapter == null) {
+            throw new FacebookException("Can't issue requests until Fragment has been created.");
+        }
+
+        String userToFetch = (userId != null) ? userId : "me";
+        return createRequest(userToFetch, extraFields, session);
+    }
+
+    @Override
+    String getDefaultTitleText() {
+        return getString(R.string.com_facebook_choose_friends);
+    }
+
+    private Request createRequest(String userID, Set<String> extraFields, Session session) {
+        Request request = Request.newGraphPathRequest(session, userID + "/friends", null);
+
+        String pictureField = adapter.getPictureFieldSpecifier();
+        Set<String> fields = new HashSet<String>(extraFields);
+        String[] requiredFields = new String[]{
+                ID,
+                NAME,
+                pictureField
+        };
+        fields.addAll(Arrays.asList(requiredFields));
+
+        Bundle parameters = request.getParameters();
+        parameters.putString("fields", TextUtils.join(",", fields));
+        request.setParameters(parameters);
+
+        return request;
+    }
+
+    private void setFriendPickerSettingsFromBundle(Bundle inState) {
+        // We do this in a separate non-overridable method so it is safe to call from the constructor.
+        if (inState != null) {
+            if (inState.containsKey(USER_ID_BUNDLE_KEY)) {
+                setUserId(inState.getString(USER_ID_BUNDLE_KEY));
+            }
+            setMultiSelect(inState.getBoolean(MULTI_SELECT_BUNDLE_KEY, multiSelect));
+        }
+    }
+
+    private class ImmediateLoadingStrategy extends LoadingStrategy {
+        @Override
+        protected void onLoadFinished(GraphObjectPagingLoader<GraphUser> loader,
+                SimpleGraphObjectCursor<GraphUser> data) {
+            super.onLoadFinished(loader, data);
+
+            // We could be called in this state if we are clearing data or if we are being re-attached
+            // in the middle of a query.
+            if (data == null || loader.isLoading()) {
+                return;
+            }
+
+            if (data.areMoreObjectsAvailable()) {
+                // We got results, but more are available.
+                followNextLink();
+            } else {
+                // We finished loading results.
+                hideActivityCircle();
+
+                // If this was from the cache, schedule a delayed refresh query (unless we got no results
+                // at all, in which case refresh immediately.
+                if (data.isFromCache()) {
+                    loader.refreshOriginalRequest(data.getCount() == 0 ? CACHED_RESULT_REFRESH_DELAY : 0);
+                }
+            }
+        }
+
+        private void followNextLink() {
+            // This may look redundant, but this causes the circle to be alpha-dimmed if we have results.
+            displayActivityCircle();
+
+            loader.followNextLink();
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/GraphLocation.java b/facebook/src/com/facebook/GraphLocation.java
new file mode 100644
index 000000000..93dbcef63
--- /dev/null
+++ b/facebook/src/com/facebook/GraphLocation.java
@@ -0,0 +1,130 @@
+/**
+ * Copyright 2010 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Provides a strongly-typed representation of a Location as defined by the Graph API.
+ *
+ * Note that this interface is intended to be used with GraphObjectWrapper
+ * and not implemented directly.
+ */
+public interface GraphLocation extends GraphObject {
+    /**
+     * Returns the street component of the location.
+     * 
+     * @return the street component of the location, or null
+     */
+    public String getStreet();
+
+    /**
+     * Sets the street component of the location.
+     * 
+     * @param street
+     *            the street component of the location, or null
+     */
+    public void setStreet(String street);
+
+    /**
+     * Gets the city component of the location.
+     * 
+     * @return the city component of the location
+     */
+    public String getCity();
+
+    /**
+     * Sets the city component of the location.
+     * 
+     * @param city
+     *            the city component of the location
+     */
+    public void setCity(String city);
+
+    /**
+     * Returns the state component of the location.
+     * 
+     * @return the state component of the location
+     */
+    public String getState();
+
+    /**
+     * Sets the state component of the location.
+     * 
+     * @param state
+     *            the state component of the location
+     */
+    public void setState(String state);
+
+    /**
+     * Returns the country component of the location.
+     * 
+     * @return the country component of the location
+     */
+    public String getCountry();
+
+    /**
+     * Sets the country component of the location
+     * 
+     * @param country
+     *            the country component of the location
+     */
+    public void setCountry(String country);
+
+    /**
+     * Returns the postal code component of the location.
+     * 
+     * @return the postal code component of the location
+     */
+    public String getZip();
+
+    /**
+     * Sets the postal code component of the location.
+     * 
+     * @param zip
+     *            the postal code component of the location
+     */
+    public void setZip(String zip);
+
+    /**
+     * Returns the latitude component of the location.
+     * 
+     * @return the latitude component of the location
+     */
+    public double getLatitude();
+
+    /**
+     * Sets the latitude component of the location.
+     * 
+     * @param latitude
+     *            the latitude component of the location
+     */
+    public void setLatitude(double latitude);
+
+    /**
+     * Returns the longitude component of the location.
+     * 
+     * @return the longitude component of the location
+     */
+    public double getLongitude();
+
+    /**
+     * Sets the longitude component of the location.
+     * 
+     * @param longitude
+     *            the longitude component of the location
+     */
+    public void setLongitude(double longitude);
+}
diff --git a/facebook/src/com/facebook/GraphMultiResult.java b/facebook/src/com/facebook/GraphMultiResult.java
new file mode 100644
index 000000000..0332f6648
--- /dev/null
+++ b/facebook/src/com/facebook/GraphMultiResult.java
@@ -0,0 +1,32 @@
+/**
+ * Copyright 2010 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Defines a GraphObject that represents the result of a query that returns multiple GraphObjects
+ * nested under a "data" property.
+ *
+ * Note that this interface is intended to be used with GraphObjectWrapper
+ * and not implemented directly.
+ */
+public interface GraphMultiResult extends GraphObject {
+    /**
+     * Provides access to the GraphObjects that make up the result set.
+     * @return a list of GraphObjects
+     */
+    public GraphObjectList<GraphObject> getData();
+}
diff --git a/facebook/src/com/facebook/GraphObject.java b/facebook/src/com/facebook/GraphObject.java
new file mode 100644
index 000000000..8597c10cf
--- /dev/null
+++ b/facebook/src/com/facebook/GraphObject.java
@@ -0,0 +1,75 @@
+/**
+ * Copyright 2010 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import org.json.JSONObject;
+
+import java.util.Map;
+
+/**
+ * GraphObject is the primary interface used by the Facebook SDK for Android to represent objects in the Facebook
+ * Social Graph and the Facebook Open Graph (OG). It is the base interface for all typed access to graph objects
+ * in the SDK. No concrete classes implement GraphObject or its derived interfaces. Rather, they are implemented as
+ * proxies (see the {@link GraphObjectWrapper GraphObjectWrapper} class) that provide strongly-typed property
+ * getters and setters to access the underlying data. Since the primary use case for graph objects is sending and
+ * receiving them over the wire to/from Facebook services, they are represented as JSONObjects. No validation is done
+ * that a graph object is actually of a specific type -- any graph object can be treated as any GraphObject-derived
+ * interface, and the presence or absence of specific properties determines its suitability for use as that
+ * particular type of object.
+ * <br/>
+ */
+public interface GraphObject {
+    /**
+     * Returns a new proxy that treats this graph object as a different GraphObject-derived type.
+     * @param graphObjectClass the type of GraphObject to return
+     * @return a new instance of the GraphObject-derived-type that references the same underlying data
+     */
+    public <T extends GraphObject> T cast(Class<T> graphObjectClass);
+
+    /**
+     * Returns a Java Collections map of names and properties.  Modifying the returned map modifies the
+     * inner JSON representation.
+     * @return a Java Collections map representing the GraphObject state
+     */
+    public Map<String, Object> asMap();
+
+    /**
+     * Gets the underlying JSONObject representation of this graph object.
+     * @return the underlying JSONObject representation of this graph object
+     */
+    public JSONObject getInnerJSONObject();
+
+    /**
+     * Gets a property of the GraphObject
+     * @param propertyName the name of the property to get
+     * @return the value of the named property
+     */
+    public Object getProperty(String propertyName);
+
+    /**
+     * Sets a property of the GraphObject
+     * @param propertyName the name of the property to set
+     * @param propertyValue the value of the named property to set
+     */
+    public void setProperty(String propertyName, Object propertyValue);
+
+    /**
+     * Removes a property of the GraphObject
+     * @param propertyName the name of the property to remove
+     */
+    public void removeProperty(String propertyName);
+}
diff --git a/facebook/src/com/facebook/GraphObjectAdapter.java b/facebook/src/com/facebook/GraphObjectAdapter.java
new file mode 100644
index 000000000..ddef18c90
--- /dev/null
+++ b/facebook/src/com/facebook/GraphObjectAdapter.java
@@ -0,0 +1,785 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.os.Handler;
+import android.os.Looper;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewStub;
+import android.widget.*;
+import com.facebook.android.R;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.text.Collator;
+import java.util.*;
+
+class GraphObjectAdapter<T extends GraphObject> extends BaseAdapter implements SectionIndexer {
+    private static final PrioritizedWorkQueue downloadWorkQueue = new PrioritizedWorkQueue();
+
+    private final int DISPLAY_SECTIONS_THRESHOLD = 1;
+    private final int HEADER_VIEW_TYPE = 0;
+    private final int GRAPH_OBJECT_VIEW_TYPE = 1;
+    private final int ACTIVITY_CIRCLE_VIEW_TYPE = 2;
+
+    private final String ID = "id";
+    private final String NAME = "name";
+    private final String PICTURE = "picture";
+
+    private final LayoutInflater inflater;
+    private List<String> sectionKeys = new ArrayList<String>();
+    private Map<String, ArrayList<T>> graphObjectsBySection = new HashMap<String, ArrayList<T>>();
+    private Map<String, T> graphObjectsById = new HashMap<String, T>();
+    private boolean displaySections;
+    private List<String> sortFields;
+    private String groupByField;
+    private PictureDownloader pictureDownloader;
+    private boolean showPicture;
+    private boolean showCheckbox;
+    private Filter<T> filter;
+    private DataNeededListener dataNeededListener;
+    private GraphObjectCursor<T> cursor;
+
+    public interface DataNeededListener {
+        public void onDataNeeded();
+    }
+
+    public static class SectionAndItem<T extends GraphObject> {
+        public String sectionKey;
+        public T graphObject;
+
+        public enum Type {
+            GRAPH_OBJECT,
+            SECTION_HEADER,
+            ACTIVITY_CIRCLE
+        }
+
+        public SectionAndItem(String sectionKey, T graphObject) {
+            this.sectionKey = sectionKey;
+            this.graphObject = graphObject;
+        }
+
+        public Type getType() {
+            if (sectionKey == null) {
+                return Type.ACTIVITY_CIRCLE;
+            } else if (graphObject == null) {
+                return Type.SECTION_HEADER;
+            } else {
+                return Type.GRAPH_OBJECT;
+            }
+        }
+    }
+
+    interface Filter<T> {
+        boolean includeItem(T graphObject);
+    }
+
+    public GraphObjectAdapter(Context context) {
+        this.inflater = LayoutInflater.from(context);
+    }
+
+    public List<String> getSortFields() {
+        return sortFields;
+    }
+
+    public void setSortFields(List<String> sortFields) {
+        this.sortFields = sortFields;
+    }
+
+    public String getGroupByField() {
+        return groupByField;
+    }
+
+    public void setGroupByField(String groupByField) {
+        this.groupByField = groupByField;
+    }
+
+    public boolean getShowPicture() {
+        return showPicture;
+    }
+
+    public void setShowPicture(boolean showPicture) {
+        this.showPicture = showPicture;
+    }
+
+    public boolean getShowCheckbox() {
+        return showCheckbox;
+    }
+
+    public void setShowCheckbox(boolean showCheckbox) {
+        this.showCheckbox = showCheckbox;
+    }
+
+    public DataNeededListener getDataNeededListener() {
+        return dataNeededListener;
+    }
+
+    public void setDataNeededListener(DataNeededListener dataNeededListener) {
+        this.dataNeededListener = dataNeededListener;
+    }
+
+    public GraphObjectCursor<T> getCursor() {
+        return cursor;
+    }
+
+    public boolean changeCursor(GraphObjectCursor<T> cursor) {
+        if (this.cursor == cursor) {
+            return false;
+        }
+        if (this.cursor != null) {
+            this.cursor.close();
+        }
+        this.cursor = cursor;
+
+        rebuildAndNotify();
+        return true;
+    }
+
+    public void rebuildAndNotify() {
+        rebuildSections();
+        notifyDataSetChanged();
+    }
+
+    public void cancelPendingDownloads() {
+        PictureDownloader downloader = pictureDownloader;
+        if (downloader != null) {
+            downloader.cancelAllDownloads();
+        }
+    }
+
+    public void prioritizeViewRange(int start, int count) {
+        PictureDownloader downloader = pictureDownloader;
+        if (downloader != null) {
+            downloader.prioritizeViewRange(start, count);
+        }
+    }
+
+    protected String getSectionKeyOfGraphObject(T graphObject) {
+        String result = null;
+
+        if (groupByField != null) {
+            result = (String) graphObject.getProperty(groupByField);
+            if (result != null && result.length() > 0) {
+                result = result.substring(0, 1).toUpperCase();
+            }
+        }
+
+        return (result != null) ? result : "";
+    }
+
+    protected CharSequence getTitleOfGraphObject(T graphObject) {
+        return (String) graphObject.getProperty(NAME);
+    }
+
+    protected CharSequence getSubTitleOfGraphObject(T graphObject) {
+        return null;
+    }
+
+    protected URL getPictureUrlOfGraphObject(T graphObject) {
+        String url = null;
+        Object o = graphObject.getProperty(PICTURE);
+        if (o instanceof String) {
+            url = (String) o;
+        } else if (o instanceof JSONObject) {
+            ItemPicture itemPicture = GraphObjectWrapper.createGraphObject((JSONObject) o).cast(ItemPicture.class);
+            ItemPictureData data = itemPicture.getData();
+            if (data != null) {
+                url = data.getUrl();
+            }
+        }
+
+        if (url != null) {
+            try {
+                return new URL(url);
+            } catch (MalformedURLException e) {
+            }
+        }
+        return null;
+    }
+
+    protected View getSectionHeaderView(String sectionHeader, View convertView, ViewGroup parent) {
+        TextView result = (TextView) convertView;
+
+        if (result == null) {
+            result = (TextView) inflater.inflate(R.layout.com_facebook_picker_list_section_header, null);
+        }
+
+        result.setText(sectionHeader);
+
+        return result;
+    }
+
+    protected View getGraphObjectView(T graphObject, View convertView, ViewGroup parent) {
+        View result = (View) convertView;
+
+        if (result == null) {
+            result = createGraphObjectView(graphObject, convertView);
+        }
+
+        populateGraphObjectView(result, graphObject);
+        return result;
+    }
+
+    private View getActivityCircleView(View convertView, ViewGroup parent) {
+        View result = (View) convertView;
+
+        if (result == null) {
+            result = (View) inflater.inflate(R.layout.com_facebook_picker_activity_circle_row, null);
+        }
+        ProgressBar activityCircle = (ProgressBar) result.findViewById(R.id.com_facebook_picker_row_activity_circle);
+        activityCircle.setVisibility(View.VISIBLE);
+
+        return result;
+    }
+
+    protected int getGraphObjectRowLayoutId(T graphObject) {
+        return R.layout.com_facebook_picker_list_row;
+    }
+
+    protected int getDefaultPicture() {
+        return R.drawable.com_facebook_profile_default_icon;
+    }
+
+    protected View createGraphObjectView(T graphObject, View convertView) {
+        View result = inflater.inflate(getGraphObjectRowLayoutId(graphObject), null);
+
+        ViewStub checkboxStub = (ViewStub) result.findViewById(R.id.com_facebook_picker_checkbox_stub);
+        if (checkboxStub != null) {
+            if (!getShowCheckbox()) {
+                checkboxStub.setVisibility(View.GONE);
+            } else {
+                CheckBox checkBox = (CheckBox) checkboxStub.inflate();
+                updateCheckboxState(checkBox, false);
+            }
+        }
+
+        ViewStub profilePicStub = (ViewStub) result.findViewById(R.id.com_facebook_picker_profile_pic_stub);
+        if (!getShowPicture()) {
+            profilePicStub.setVisibility(View.GONE);
+        } else {
+            ImageView imageView = (ImageView) profilePicStub.inflate();
+            imageView.setVisibility(View.VISIBLE);
+        }
+
+        return result;
+    }
+
+    protected void populateGraphObjectView(View view, T graphObject) {
+        String id = getIdOfGraphObject(graphObject);
+        view.setTag(id);
+
+        CharSequence title = getTitleOfGraphObject(graphObject);
+        TextView titleView = (TextView) view.findViewById(R.id.com_facebook_picker_title);
+        if (titleView != null) {
+            titleView.setText(title, TextView.BufferType.SPANNABLE);
+        }
+
+        CharSequence subtitle = getSubTitleOfGraphObject(graphObject);
+        TextView subtitleView = (TextView) view.findViewById(R.id.picker_subtitle);
+        if (subtitleView != null) {
+            if (subtitle != null) {
+                subtitleView.setText(subtitle, TextView.BufferType.SPANNABLE);
+                subtitleView.setVisibility(View.VISIBLE);
+            } else {
+                subtitleView.setVisibility(View.GONE);
+            }
+        }
+
+        if (getShowCheckbox()) {
+            CheckBox checkBox = (CheckBox) view.findViewById(R.id.com_facebook_picker_checkbox);
+            updateCheckboxState(checkBox, isGraphObjectSelected(id));
+        }
+
+        if (getShowPicture()) {
+            URL pictureURL = getPictureUrlOfGraphObject(graphObject);
+
+            if (pictureURL != null) {
+                ImageView profilePic = (ImageView) view.findViewById(R.id.com_facebook_picker_image);
+                getPictureDownloader().download(id, pictureURL, profilePic);
+            }
+        }
+    }
+
+    /**
+     * @throws FacebookException if the GraphObject doesn't have an ID.
+     */
+    String getIdOfGraphObject(T graphObject) {
+        if (graphObject.asMap().containsKey(ID)) {
+            Object obj = graphObject.getProperty(ID);
+            if (obj instanceof String) {
+                return (String) obj;
+            }
+        }
+        throw new FacebookException("Received an object without an ID.");
+    }
+
+    boolean filterIncludesItem(T graphObject) {
+        return filter == null || filter.includeItem(graphObject);
+    }
+
+    Filter<T> getFilter() {
+        return filter;
+    }
+
+    void setFilter(Filter<T> filter) {
+        this.filter = filter;
+    }
+
+    boolean isGraphObjectSelected(String graphObjectId) {
+        return false;
+    }
+
+    void updateCheckboxState(CheckBox checkBox, boolean graphObjectSelected) {
+        // Default is no-op
+    }
+
+    String getPictureFieldSpecifier() {
+        // How big is our image?
+        View view = createGraphObjectView(null, null);
+        ImageView picture = (ImageView) view.findViewById(R.id.com_facebook_picker_image);
+        if (picture == null) {
+            return null;
+        }
+
+        // Note: these dimensions are in pixels, not dips
+        ViewGroup.LayoutParams layoutParams = picture.getLayoutParams();
+        return String.format("picture.height(%d).width(%d)", layoutParams.height, layoutParams.width);
+    }
+
+
+    private boolean shouldShowActivityCircleCell() {
+        // We show the "more data" activity circle cell if we have a listener to request more data,
+        // we are expecting more data, and we have some data already (i.e., not on a fresh query).
+        return (cursor != null) && cursor.areMoreObjectsAvailable() && (dataNeededListener != null) && !isEmpty();
+    }
+
+    private PictureDownloader getPictureDownloader() {
+        if (pictureDownloader == null) {
+            pictureDownloader = new PictureDownloader();
+        }
+
+        return pictureDownloader;
+    }
+
+    private void rebuildSections() {
+        sectionKeys = new ArrayList<String>();
+        graphObjectsBySection = new HashMap<String, ArrayList<T>>();
+        graphObjectsById = new HashMap<String, T>();
+        displaySections = false;
+
+        if (cursor == null || cursor.getCount() == 0) {
+            return;
+        }
+
+        int objectsAdded = 0;
+        cursor.moveToFirst();
+        do {
+            T graphObject = cursor.getGraphObject();
+
+            if (!filterIncludesItem(graphObject)) {
+                continue;
+            }
+
+            objectsAdded++;
+
+            String sectionKeyOfItem = getSectionKeyOfGraphObject(graphObject);
+            if (!graphObjectsBySection.containsKey(sectionKeyOfItem)) {
+                sectionKeys.add(sectionKeyOfItem);
+                graphObjectsBySection.put(sectionKeyOfItem, new ArrayList<T>());
+            }
+            List<T> section = graphObjectsBySection.get(sectionKeyOfItem);
+            section.add(graphObject);
+
+            graphObjectsById.put(getIdOfGraphObject(graphObject), graphObject);
+        } while (cursor.moveToNext());
+
+        if (sortFields != null) {
+            final Collator collator = Collator.getInstance();
+            for (List<T> section : graphObjectsBySection.values()) {
+                Collections.sort(section, new Comparator<GraphObject>() {
+                    @Override
+                    public int compare(GraphObject a, GraphObject b) {
+                        return Utility.compareGraphObjects(a, b, sortFields, collator);
+                    }
+                });
+            }
+        }
+
+        Collections.sort(sectionKeys, Collator.getInstance());
+
+        displaySections = sectionKeys.size() > 1 && objectsAdded > DISPLAY_SECTIONS_THRESHOLD;
+    }
+
+    SectionAndItem<T> getSectionAndItem(int position) {
+        if (sectionKeys.size() == 0) {
+            return null;
+        }
+        String sectionKey = null;
+        T graphObject = null;
+
+        if (!displaySections) {
+            sectionKey = sectionKeys.get(0);
+            List<T> section = graphObjectsBySection.get(sectionKey);
+            if (position >= 0 && position < section.size()) {
+                graphObject = graphObjectsBySection.get(sectionKey).get(position);
+            } else {
+                // We are off the end; we must be adding an activity circle to indicate more data is coming.
+                assert dataNeededListener != null && cursor.areMoreObjectsAvailable();
+                // We return null for both to indicate this.
+                return new SectionAndItem<T>(null, null);
+            }
+        } else {
+            // Count through the sections; the "0" position in each section is the header. We decrement
+            // position each time we skip forward a certain number of elements, including the header.
+            for (String key : sectionKeys) {
+                // Decrement if we skip over the header
+                if (position-- == 0) {
+                    sectionKey = key;
+                    break;
+                }
+
+                List<T> section = graphObjectsBySection.get(key);
+                if (position < section.size()) {
+                    // The position is somewhere in this section. Get the corresponding graph object.
+                    sectionKey = key;
+                    graphObject = section.get(position);
+                    break;
+                }
+                // Decrement by as many items as we skipped over
+                position -= section.size();
+            }
+        }
+        if (sectionKey != null) {
+            // Note: graphObject will be null if this represents a section header.
+            return new SectionAndItem<T>(sectionKey, graphObject);
+        } else {
+            throw new IndexOutOfBoundsException("position");
+        }
+    }
+
+    int getPosition(String sectionKey, T graphObject) {
+        int position = 0;
+        boolean found = false;
+
+        // First find the section key and increment position one for each header we will render;
+        // increment by the size of each section prior to the one we want.
+        for (String key : sectionKeys) {
+            if (displaySections) {
+                position++;
+            }
+            if (key.equals(sectionKey)) {
+                found = true;
+                break;
+            } else {
+                position += graphObjectsBySection.get(key).size();
+            }
+        }
+
+        if (!found) {
+            return -1;
+        } else if (graphObject == null) {
+            // null represents the header for a section; we counted this header in position earlier,
+            // so subtract it back out.
+            return position - (displaySections ? 1 : 0);
+        }
+
+        // Now find index of this item within that section.
+        for (T t : graphObjectsBySection.get(sectionKey)) {
+            if (GraphObjectWrapper.hasSameId(t, graphObject)) {
+                return position;
+            }
+            position++;
+        }
+        return -1;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        // We'll never populate sectionKeys unless we have at least one object.
+        return sectionKeys.size() == 0;
+    }
+
+    @Override
+    public int getCount() {
+        if (sectionKeys.size() == 0) {
+            return 0;
+        }
+
+        // If we are not displaying sections, we don't display a header; otherwise, we have one header per item in
+        // addition to the actual items.
+        int count = (displaySections) ? sectionKeys.size() : 0;
+        for (List<T> section : graphObjectsBySection.values()) {
+            count += section.size();
+        }
+
+        // If we should show a cell with an activity circle indicating more data is coming, add it to the count.
+        if (shouldShowActivityCircleCell()) {
+            ++count;
+        }
+
+        return count;
+    }
+
+    @Override
+    public boolean areAllItemsEnabled() {
+        return displaySections;
+    }
+
+    @Override
+    public boolean hasStableIds() {
+        return true;
+    }
+
+    @Override
+    public boolean isEnabled(int position) {
+        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
+        return sectionAndItem.getType() == SectionAndItem.Type.GRAPH_OBJECT;
+    }
+
+    @Override
+    public Object getItem(int position) {
+        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
+        return (sectionAndItem.getType() == SectionAndItem.Type.GRAPH_OBJECT) ? sectionAndItem.graphObject : null;
+    }
+
+    @Override
+    public long getItemId(int position) {
+        // We assume IDs that can be converted to longs. If this is not the case for certain types of
+        // GraphObjects, subclasses should override this to return, e.g., position, and override hasStableIds
+        // to return false.
+        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
+        if (sectionAndItem != null && sectionAndItem.graphObject != null) {
+            String id = getIdOfGraphObject(sectionAndItem.graphObject);
+            if (id != null) {
+                return Long.parseLong(id);
+            }
+        }
+        return 0;
+    }
+
+    @Override
+    public int getViewTypeCount() {
+        return 3;
+    }
+
+    @Override
+    public int getItemViewType(int position) {
+        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
+        switch (sectionAndItem.getType()) {
+            case SECTION_HEADER:
+                return HEADER_VIEW_TYPE;
+            case GRAPH_OBJECT:
+                return GRAPH_OBJECT_VIEW_TYPE;
+            case ACTIVITY_CIRCLE:
+                return ACTIVITY_CIRCLE_VIEW_TYPE;
+            default:
+                throw new FacebookException("Unexpected type of section and item.");
+        }
+    }
+
+    @Override
+    public View getView(int position, View convertView, ViewGroup parent) {
+        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
+
+        switch (sectionAndItem.getType()) {
+            case SECTION_HEADER:
+                return getSectionHeaderView(sectionAndItem.sectionKey, convertView, parent);
+            case GRAPH_OBJECT:
+                return getGraphObjectView(sectionAndItem.graphObject, convertView, parent);
+            case ACTIVITY_CIRCLE:
+                // If we get a request for this view, it means we need more data.
+                assert cursor.areMoreObjectsAvailable() && (dataNeededListener != null);
+                dataNeededListener.onDataNeeded();
+                return getActivityCircleView(convertView, parent);
+            default:
+                throw new FacebookException("Unexpected type of section and item.");
+        }
+    }
+
+    @Override
+    public Object[] getSections() {
+        if (displaySections) {
+            return sectionKeys.toArray();
+        } else {
+            return new Object[0];
+        }
+    }
+
+    @Override
+    public int getPositionForSection(int section) {
+        if (displaySections) {
+            section = Math.max(0, Math.min(section, sectionKeys.size() - 1));
+            if (section < sectionKeys.size()) {
+                return getPosition(sectionKeys.get(section), null);
+            }
+        }
+        return 0;
+    }
+
+    @Override
+    public int getSectionForPosition(int position) {
+        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
+        if (sectionAndItem != null &&
+            sectionAndItem.getType() != SectionAndItem.Type.ACTIVITY_CIRCLE) {
+            return Math.max(0, Math.min(sectionKeys.indexOf(sectionAndItem.sectionKey), sectionKeys.size() - 1));
+        }
+        return 0;
+    }
+
+    public List<T> getGraphObjectsById(Collection<String> ids) {
+        Set<String> idSet = new HashSet<String>();
+        idSet.addAll(ids);
+
+        ArrayList<T> result = new ArrayList<T>(idSet.size());
+        for (String id : idSet) {
+            T graphObject = graphObjectsById.get(id);
+            if (graphObject != null) {
+                result.add(graphObject);
+            }
+        }
+
+        return result;
+    }
+
+    private class PictureDownloader {
+        private final Map<String, PictureDownload> pendingDownloads = new HashMap<String, PictureDownload>();
+        private final Handler handler = new Handler();
+
+        void download(String id, URL pictureURL, ImageView imageView) {
+            validateIsUIThread(true);
+
+            if (pictureURL != null && !pictureURL.equals(imageView.getTag())) {
+                imageView.setTag(id);
+
+                PictureDownload download = new PictureDownload(id, pictureURL, imageView);
+
+                imageView.setImageResource(getDefaultPicture());
+                start(download);
+            }
+        }
+
+        void cancelAllDownloads() {
+            validateIsUIThread(true);
+
+            for (PictureDownload download : pendingDownloads.values()) {
+                download.workItem.cancel();
+            }
+
+            pendingDownloads.clear();
+        }
+
+        void prioritizeViewRange(int start, int count) {
+            validateIsUIThread(true);
+
+            downloadWorkQueue.backgroundAll();
+            for (int i = start; i < (start + count); i++) {
+                SectionAndItem<T> sectionAndItem = getSectionAndItem(i);
+                if (sectionAndItem.graphObject != null) {
+                    String id = getIdOfGraphObject(sectionAndItem.graphObject);
+                    PictureDownload download = pendingDownloads.get(id);
+                    if (download != null) {
+                        download.workItem.setPriority(PrioritizedWorkQueue.PRIORITY_ACTIVE);
+                    }
+                }
+            }
+        }
+
+        private void start(final PictureDownload download) {
+            validateIsUIThread(true);
+
+            if (pendingDownloads.containsKey(download.graphObjectId)) {
+                PictureDownload inProgress = pendingDownloads.get(download.graphObjectId);
+                inProgress.imageView = download.imageView;
+            } else {
+                pendingDownloads.put(download.graphObjectId, download);
+                download.workItem = downloadWorkQueue.addActiveWorkItem(new Runnable() {
+                    @Override
+                    public void run() {
+                        getStream(download);
+                    }
+                });
+            }
+        }
+
+        private void getStream(final PictureDownload download) {
+            validateIsUIThread(false);
+
+            InputStream stream = null;
+            try {
+                stream = ImageResponseCache.getImageStream(download.pictureURL, download.context);
+                final Bitmap bitmap = (stream != null) ? BitmapFactory.decodeStream(stream) : null;
+
+                handler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        updateView(download, bitmap);
+                    }
+                });
+            } catch (IOException e) {
+            } finally {
+                Utility.closeQuietly(stream);
+            }
+        }
+
+        private void updateView(final PictureDownload download, final Bitmap bitmap) {
+            validateIsUIThread(true);
+
+            pendingDownloads.remove(download.graphObjectId);
+            if (download.graphObjectId.equals(download.imageView.getTag())) {
+                download.imageView.setImageBitmap(bitmap);
+                download.imageView.setTag(download.pictureURL);
+            }
+        }
+
+        void validateIsUIThread(boolean uiThreadExpected) {
+            assert uiThreadExpected == (handler.getLooper() == Looper.myLooper());
+        }
+    }
+
+    private class PictureDownload {
+        public final String graphObjectId;
+        public final URL pictureURL;
+        public final Context context;
+        public ImageView imageView;
+        public PrioritizedWorkQueue.WorkItem workItem;
+
+        public PictureDownload(String graphObjectId, URL pictureURL, ImageView imageView) {
+            this.graphObjectId = graphObjectId;
+            this.pictureURL = pictureURL;
+            this.imageView = imageView;
+            context = imageView.getContext().getApplicationContext();
+        }
+    }
+
+    // Graph object type to navigate the JSON that sometimes comes back instead of a URL string
+    private interface ItemPicture extends GraphObject {
+        ItemPictureData getData();
+    }
+
+    // Graph object type to navigate the JSON that sometimes comes back instead of a URL string
+    private interface ItemPictureData extends GraphObject {
+        String getUrl();
+    }
+}
diff --git a/facebook/src/com/facebook/GraphObjectCursor.java b/facebook/src/com/facebook/GraphObjectCursor.java
new file mode 100644
index 000000000..eccc3d4bd
--- /dev/null
+++ b/facebook/src/com/facebook/GraphObjectCursor.java
@@ -0,0 +1,37 @@
+package com.facebook;
+
+interface GraphObjectCursor<T extends GraphObject> {
+    boolean isFromCache();
+
+    boolean areMoreObjectsAvailable();
+
+    int getCount();
+
+    int getPosition();
+
+    boolean move(int offset);
+
+    boolean moveToPosition(int position);
+
+    boolean moveToFirst();
+
+    boolean moveToLast();
+
+    boolean moveToNext();
+
+    boolean moveToPrevious();
+
+    boolean isFirst();
+
+    boolean isLast();
+
+    boolean isBeforeFirst();
+
+    boolean isAfterLast();
+
+    T getGraphObject();
+
+    void close();
+
+    boolean isClosed();
+}
diff --git a/facebook/src/com/facebook/GraphObjectList.java b/facebook/src/com/facebook/GraphObjectList.java
new file mode 100644
index 000000000..34e9dc231
--- /dev/null
+++ b/facebook/src/com/facebook/GraphObjectList.java
@@ -0,0 +1,47 @@
+/**
+ * Copyright 2010 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import org.json.JSONArray;
+
+import java.util.List;
+
+/**
+ * GraphObjectList is the primary representation of a collection of graph objects in the Facebook SDK for Android.
+ * It is not implemented by any concrete classes, but rather by a proxy (see the {@link GraphObjectWrapper GraphObjectWrapper}
+ * class). A GraphObjectList can actually contain elements of any type, not just graph objects, but its principal
+ * use in the SDK is to contain types derived from GraphObject.
+ * <br/>
+ *
+ * @param <T> the type of elements in the list
+ */
+public interface GraphObjectList<T> extends List<T> {
+    // cast method is only supported if T extends GraphObject
+    /**
+     * If T is derived from GraphObject, returns a new GraphObjectList exposing the same underlying data as a new
+     * GraphObject-derived type.
+     * @param graphObjectClass the GraphObject-derived type to return a list of
+     * @return a list representing the same underlying data, exposed as the new GraphObject-derived type
+     * @throws FacebookGraphObjectException if T does not derive from GraphObject
+     */
+    public <U extends GraphObject> GraphObjectList<U> castToListOf(Class<U> graphObjectClass);
+    /**
+     * Gets the underlying JSONArray representation of the data.
+     * @return the underlying JSONArray representation of the data
+     */
+    public JSONArray getInnerJSONArray();
+}
diff --git a/facebook/src/com/facebook/GraphObjectListFragment.java b/facebook/src/com/facebook/GraphObjectListFragment.java
new file mode 100644
index 000000000..4b3e2eacb
--- /dev/null
+++ b/facebook/src/com/facebook/GraphObjectListFragment.java
@@ -0,0 +1,778 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.drawable.Drawable;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.LoaderManager;
+import android.support.v4.content.Loader;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewStub;
+import android.widget.*;
+import com.facebook.android.R;
+
+import java.util.*;
+
+abstract class GraphObjectListFragment<T extends GraphObject> extends Fragment
+        implements PickerFragment<T>, LoaderManager.LoaderCallbacks<SimpleGraphObjectCursor<T>> {
+    private static final String SELECTION_BUNDLE_KEY = "com.facebook.android.GraphObjectListFragment.Selection";
+
+    private final int layout;
+    private OnErrorListener onErrorListener;
+    private OnDataChangedListener onDataChangedListener;
+    private OnSelectionChangedListener onSelectionChangedListener;
+    private OnDoneButtonClickedListener onDoneButtonClickedListener;
+    private GraphObjectFilter<T> filter;
+    private boolean showPictures = true;
+    private boolean showTitleBar = true;
+    private ListView listView;
+    HashSet<String> extraFields = new HashSet<String>();
+    GraphObjectAdapter<T> adapter;
+    private final Class<T> graphObjectClass;
+    private LoadingStrategy loadingStrategy;
+    private SelectionStrategy selectionStrategy;
+    private ProgressBar activityCircle;
+    private SessionTracker sessionTracker;
+    private String titleText;
+    private String doneButtonText;
+    private TextView titleTextView;
+    private Button doneButton;
+    private Drawable titleBarBackground;
+    private Drawable doneButtonBackground;
+
+    GraphObjectListFragment(Class<T> graphObjectClass, int layout, Bundle args) {
+        this.graphObjectClass = graphObjectClass;
+        this.layout = layout;
+
+        setGraphObjectListFragmentSettingsFromBundle(args);
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        adapter = createAdapter();
+        adapter.setFilter(new GraphObjectAdapter.Filter<T>() {
+            @Override
+            public boolean includeItem(T graphObject) {
+                return filterIncludesItem(graphObject);
+            }
+        });
+    }
+
+    @Override
+    public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
+        super.onInflate(activity, attrs, savedInstanceState);
+        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.com_facebook_picker_fragment);
+
+        setShowPictures(a.getBoolean(R.styleable.com_facebook_picker_fragment_show_pictures, showPictures));
+        String extraFieldsString = a.getString(R.styleable.com_facebook_picker_fragment_extra_fields);
+        if (extraFieldsString != null) {
+            String[] strings = extraFieldsString.split(",");
+            setExtraFields(Arrays.asList(strings));
+        }
+
+        showTitleBar = a.getBoolean(R.styleable.com_facebook_picker_fragment_show_title_bar, showTitleBar);
+        titleText = a.getString(R.styleable.com_facebook_picker_fragment_title_text);
+        doneButtonText = a.getString(R.styleable.com_facebook_picker_fragment_done_button_text);
+        titleBarBackground = a.getDrawable(R.styleable.com_facebook_picker_fragment_title_bar_background);
+        doneButtonBackground = a.getDrawable(R.styleable.com_facebook_picker_fragment_done_button_background);
+
+        a.recycle();
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        ViewGroup view = (ViewGroup) inflater.inflate(layout, container, false);
+
+        listView = (ListView) view.findViewById(R.id.com_facebook_picker_list_view);
+        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+            @Override
+            public void onItemClick(AdapterView<?> parent, View v, int position, long id) {
+                onListItemClick((ListView) parent, v, position);
+            }
+        });
+        listView.setOnLongClickListener(new View.OnLongClickListener() {
+            @Override
+            public boolean onLongClick(View v) {
+                // We don't actually do anything differently on long-clicks, but setting the listener
+                // enables the selector transition that we have for visual consistency with the
+                // Facebook app's pickers.
+                return false;
+            }
+        });
+        listView.setOnScrollListener(onScrollListener);
+        listView.setAdapter(adapter);
+
+        activityCircle = (ProgressBar) view.findViewById(R.id.com_facebook_picker_activity_circle);
+
+        return view;
+    }
+
+    @Override
+    public void onActivityCreated(final Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+
+        sessionTracker = new SessionTracker(getActivity(), new Session.StatusCallback() {
+            @Override
+            public void call(Session session, SessionState state, Exception exception) {
+                if (!session.isOpened()) {
+                    // When a session is closed, we want to clear out our data so it is not visible to subsequent users
+                    clearResults();
+                }
+            }
+        });
+
+        setSettingsFromBundle(savedInstanceState);
+
+        loadingStrategy = createLoadingStrategy();
+        loadingStrategy.attach(adapter);
+
+        selectionStrategy = createSelectionStrategy();
+        selectionStrategy.readSelectionFromBundle(savedInstanceState, SELECTION_BUNDLE_KEY);
+
+        // Should we display a title bar? (We need to do this after we've retrieved our bundle settings.)
+        if (showTitleBar) {
+            inflateTitleBar((ViewGroup) getView());
+        }
+    }
+
+    @Override
+    public void onDetach() {
+        super.onDetach();
+
+        listView.setOnScrollListener(null);
+        listView.setAdapter(null);
+
+        loadingStrategy.detach();
+        sessionTracker.stopTracking();
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        saveSettingsToBundle(outState);
+        selectionStrategy.saveSelectionToBundle(outState, SELECTION_BUNDLE_KEY);
+    }
+
+    @Override
+    public void setArguments(Bundle args) {
+        super.setArguments(args);
+        setSettingsFromBundle(args);
+    }
+
+    @Override
+    public OnDataChangedListener getOnDataChangedListener() {
+        return onDataChangedListener;
+    }
+
+    @Override
+    public void setOnDataChangedListener(OnDataChangedListener onDataChangedListener) {
+        this.onDataChangedListener = onDataChangedListener;
+    }
+
+    @Override
+    public OnSelectionChangedListener getOnSelectionChangedListener() {
+        return onSelectionChangedListener;
+    }
+
+    @Override
+    public void setOnSelectionChangedListener(
+            OnSelectionChangedListener onSelectionChangedListener) {
+        this.onSelectionChangedListener = onSelectionChangedListener;
+    }
+
+    @Override
+    public OnDoneButtonClickedListener getOnDoneButtonClickedListener() {
+        return onDoneButtonClickedListener;
+    }
+
+    @Override
+    public void setOnDoneButtonClickedListener(OnDoneButtonClickedListener onDoneButtonClickedListener) {
+        this.onDoneButtonClickedListener = onDoneButtonClickedListener;
+    }
+
+    @Override
+    public OnErrorListener getOnErrorListener() {
+        return onErrorListener;
+    }
+
+    @Override
+    public void setOnErrorListener(OnErrorListener onErrorListener) {
+        this.onErrorListener = onErrorListener;
+    }
+
+    @Override
+    public GraphObjectFilter<T> getFilter() {
+        return filter;
+    }
+
+    @Override
+    public void setFilter(GraphObjectFilter<T> filter) {
+        this.filter = filter;
+    }
+
+    @Override
+    public Session getSession() {
+        return sessionTracker.getSession();
+    }
+
+    @Override
+    public void setSession(Session session) {
+        sessionTracker.setSession(session);
+    }
+
+    @Override
+    public boolean getShowPictures() {
+        return showPictures;
+    }
+
+    @Override
+    public void setShowPictures(boolean showPictures) {
+        this.showPictures = showPictures;
+    }
+
+    public Set<String> getExtraFields() {
+        return new HashSet<String>(extraFields);
+    }
+
+    public void setExtraFields(Collection<String> fields) {
+        extraFields = new HashSet<String>();
+        if (fields != null) {
+            extraFields.addAll(fields);
+        }
+    }
+
+    @Override
+    public void loadData(boolean forceReload) {
+        if (!forceReload && !adapter.isEmpty()) {
+            return;
+        }
+
+        loadDataSkippingRoundTripIfCached();
+    }
+
+    @Override
+    public void setSettingsFromBundle(Bundle inState) {
+        setGraphObjectListFragmentSettingsFromBundle(inState);
+    }
+
+    @Override
+    public GraphObjectPagingLoader<T> onCreateLoader(int id, Bundle args) {
+        // This is called when a new Loader needs to be created.  This
+        // sample only has one Loader with no arguments, so it is simple.
+        return new GraphObjectPagingLoader<T>(getActivity(), graphObjectClass);
+    }
+
+    @Override
+    public void onLoaderReset(Loader<SimpleGraphObjectCursor<T>> loader) {
+        adapter.changeCursor(null);
+    }
+
+    @Override
+    public void onLoadFinished(Loader<SimpleGraphObjectCursor<T>> loader, SimpleGraphObjectCursor<T> data) {
+        adapter.changeCursor(data);
+    }
+
+    boolean filterIncludesItem(T graphObject) {
+        if (filter != null) {
+            return filter.includeItem(graphObject);
+        }
+        return true;
+    }
+
+    List<T> getSelectedGraphObjects() {
+        return adapter.getGraphObjectsById(selectionStrategy.getSelectedIds());
+    }
+
+    void saveSettingsToBundle(Bundle outState) {
+        outState.putBoolean(SHOW_PICTURES_BUNDLE_KEY, showPictures);
+        if (!extraFields.isEmpty()) {
+            outState.putString(EXTRA_FIELDS_BUNDLE_KEY, TextUtils.join(",", extraFields));
+        }
+        outState.putBoolean(SHOW_TITLE_BAR_BUNDLE_KEY, showTitleBar);
+        outState.putString(TITLE_TEXT_BUNDLE_KEY, titleText);
+        outState.putString(DONE_BUTTON_TEXT_BUNDLE_KEY, doneButtonText);
+    }
+
+    abstract Request getRequestForLoadData(Session session);
+
+    abstract GraphObjectListFragmentAdapter<T> createAdapter();
+
+    abstract LoadingStrategy createLoadingStrategy();
+
+    abstract SelectionStrategy createSelectionStrategy();
+
+    void onLoadingData() {
+    }
+
+    String getDefaultTitleText() {
+        return null;
+    }
+
+    String getDefaultDoneButtonText() {
+        return getString(R.string.com_facebook_picker_done_button_text);
+    }
+
+    void displayActivityCircle() {
+        if (activityCircle != null) {
+            layoutActivityCircle();
+            activityCircle.setVisibility(View.VISIBLE);
+        }
+    }
+
+    void layoutActivityCircle() {
+        // If we've got no data, make the activity circle full-opacity. Otherwise we'll dim it to avoid
+        //  cluttering the UI.
+        float alpha = (!adapter.isEmpty()) ? .25f : 1.0f;
+        Utility.setAlpha(activityCircle, alpha);
+    }
+
+    void hideActivityCircle() {
+        if (activityCircle != null) {
+            // We use an animation to dim the activity circle; need to clear this or it will remain visible.
+            activityCircle.clearAnimation();
+            activityCircle.setVisibility(View.INVISIBLE);
+        }
+    }
+
+    void setSelectionStrategy(SelectionStrategy selectionStrategy) {
+        if (selectionStrategy != this.selectionStrategy) {
+            this.selectionStrategy = selectionStrategy;
+            if (adapter != null) {
+                // Adapter should cause a re-render.
+                adapter.notifyDataSetChanged();
+            }
+        }
+    }
+
+    private void setGraphObjectListFragmentSettingsFromBundle(Bundle inState) {
+        // We do this in a separate non-overridable method so it is safe to call from the constructor.
+        if (inState != null) {
+            showPictures = inState.getBoolean(SHOW_PICTURES_BUNDLE_KEY, showPictures);
+            String extraFieldsString = inState.getString(EXTRA_FIELDS_BUNDLE_KEY);
+            if (extraFieldsString != null) {
+                String[] strings = extraFieldsString.split(",");
+                setExtraFields(Arrays.asList(strings));
+            }
+            showTitleBar = inState.getBoolean(SHOW_TITLE_BAR_BUNDLE_KEY, showTitleBar);
+            String titleTextString = inState.getString(TITLE_TEXT_BUNDLE_KEY);
+            if (titleTextString != null) {
+                titleText = titleTextString;
+                if (titleTextView != null) {
+                    titleTextView.setText(titleText);
+                }
+            }
+            String doneButtonTextString = inState.getString(DONE_BUTTON_TEXT_BUNDLE_KEY);
+            if (doneButtonTextString != null) {
+                doneButtonText = doneButtonTextString;
+                if (doneButton != null) {
+                    doneButton.setText(doneButtonText);
+                }
+            }
+        }
+    }
+
+    private void inflateTitleBar(ViewGroup view) {
+        ViewStub stub = (ViewStub) view.findViewById(R.id.com_facebook_picker_title_bar_stub);
+        if (stub != null) {
+            View titleBar = stub.inflate();
+
+            final RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
+                    RelativeLayout.LayoutParams.FILL_PARENT,
+                    RelativeLayout.LayoutParams.FILL_PARENT);
+            layoutParams.addRule(RelativeLayout.BELOW, R.id.com_facebook_picker_title_bar);
+            listView.setLayoutParams(layoutParams);
+
+            if (titleBarBackground != null) {
+                titleBar.setBackgroundDrawable(titleBarBackground);
+            }
+
+            doneButton = (Button) view.findViewById(R.id.com_facebook_picker_done_button);
+            if (doneButton != null) {
+                doneButton.setOnClickListener(new View.OnClickListener() {
+                    @Override
+                    public void onClick(View v) {
+                        if (onDoneButtonClickedListener != null) {
+                            onDoneButtonClickedListener.onDoneButtonClicked();
+                        }
+                    }
+                });
+
+                if (doneButtonText == null) {
+                    doneButtonText = getDefaultDoneButtonText();
+                }
+                if (doneButtonText != null) {
+                    doneButton.setText(doneButtonText);
+                }
+
+                if (doneButtonBackground != null) {
+                    doneButton.setBackgroundDrawable(doneButtonBackground);
+                }
+            }
+
+            titleTextView = (TextView) view.findViewById(R.id.com_facebook_picker_title);
+            if (titleTextView != null) {
+                if (titleText == null) {
+                    titleText = getDefaultTitleText();
+                }
+                if (titleText != null) {
+                    titleTextView.setText(titleText);
+                }
+            }
+        }
+    }
+
+    private void onListItemClick(ListView listView, View v, int position) {
+        @SuppressWarnings("unchecked")
+        T graphObject = (T) listView.getItemAtPosition(position);
+        String id = adapter.getIdOfGraphObject(graphObject);
+        selectionStrategy.toggleSelection(id);
+        adapter.notifyDataSetChanged();
+
+        if (onSelectionChangedListener != null) {
+            onSelectionChangedListener.onSelectionChanged();
+        }
+    }
+
+    private void loadDataSkippingRoundTripIfCached() {
+        clearResults();
+
+        Request request = getRequestForLoadData(getSession());
+        if (request != null) {
+            onLoadingData();
+            loadingStrategy.startLoading(request);
+        }
+    }
+
+    private void clearResults() {
+        if (adapter != null) {
+            boolean wasSelection = !selectionStrategy.isEmpty();
+            boolean wasData = !adapter.isEmpty();
+
+            loadingStrategy.clearResults();
+            selectionStrategy.clear();
+            adapter.notifyDataSetChanged();
+
+            // Tell anyone who cares the data and selection has changed, if they have.
+            if (wasData && onDataChangedListener != null) {
+                onDataChangedListener.onDataChanged();
+            }
+            if (wasSelection && onSelectionChangedListener != null) {
+                onSelectionChangedListener.onSelectionChanged();
+            }
+        }
+    }
+
+    void updateAdapter(SimpleGraphObjectCursor<T> data) {
+        if (adapter != null) {
+            // As we fetch additional results and add them to the table, we do not
+            // want the items displayed jumping around seemingly at random, frustrating the user's
+            // attempts at scrolling, etc. Since results may be added anywhere in
+            // the table, we choose to try to keep the first visible row in a fixed
+            // position (from the user's perspective). We try to keep it positioned at
+            // the same offset from the top of the screen so adding new items seems
+            // smoother, as opposed to having it "snap" to a multiple of row height
+
+            // We use the second row, to give context above and below it and avoid
+            // cases where the first row is only barely visible, thus providing little context.
+            // The exception is where the very first row is visible, in which case we use that.
+            View view = listView.getChildAt(1);
+            int anchorPosition = listView.getFirstVisiblePosition();
+            if (anchorPosition > 0) {
+                anchorPosition++;
+            }
+            GraphObjectAdapter.SectionAndItem<T> anchorItem = adapter.getSectionAndItem(anchorPosition);
+            final int top = (view != null &&
+                    anchorItem.getType() != GraphObjectAdapter.SectionAndItem.Type.ACTIVITY_CIRCLE) ?
+                    view.getTop() : 0;
+
+            // Now actually add the results.
+            boolean dataChanged = adapter.changeCursor(data);
+
+            if (view != null && anchorItem != null) {
+                // Put the item back in the same spot it was.
+                final int newPositionOfItem = adapter.getPosition(anchorItem.sectionKey, anchorItem.graphObject);
+                if (newPositionOfItem != -1) {
+                    listView.setSelectionFromTop(newPositionOfItem, top);
+                }
+            }
+
+            if (dataChanged && onDataChangedListener != null) {
+                onDataChangedListener.onDataChanged();
+            }
+        }
+    }
+
+    private void reprioritizeDownloads() {
+        int firstVisibleItem = listView.getFirstVisiblePosition();
+        int lastVisibleItem = listView.getLastVisiblePosition();
+
+        if (lastVisibleItem >= 0) {
+            int visibleItemCount = lastVisibleItem + 1 - firstVisibleItem;
+            adapter.prioritizeViewRange(firstVisibleItem, visibleItemCount);
+        }
+    }
+
+    private ListView.OnScrollListener onScrollListener = new ListView.OnScrollListener() {
+        @Override
+        public void onScrollStateChanged(AbsListView view, int scrollState) {
+            if (scrollState == ListView.OnScrollListener.SCROLL_STATE_IDLE) {
+                reprioritizeDownloads();
+            }
+        }
+
+        @Override
+        public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
+        }
+    };
+
+    abstract class LoadingStrategy {
+        protected final static int CACHED_RESULT_REFRESH_DELAY = 2 * 1000;
+
+        protected GraphObjectPagingLoader<T> loader;
+        protected GraphObjectAdapter<T> adapter;
+
+        public void attach(GraphObjectAdapter<T> adapter) {
+            loader = (GraphObjectPagingLoader<T>) getLoaderManager().initLoader(0, null,
+                    new LoaderManager.LoaderCallbacks<SimpleGraphObjectCursor<T>>() {
+                        @Override
+                        public Loader<SimpleGraphObjectCursor<T>> onCreateLoader(int id, Bundle args) {
+                            return LoadingStrategy.this.onCreateLoader();
+                        }
+
+                        @Override
+                        public void onLoadFinished(Loader<SimpleGraphObjectCursor<T>> loader,
+                                SimpleGraphObjectCursor<T> data) {
+                            if (loader != LoadingStrategy.this.loader) {
+                                throw new FacebookException("Received callback for unknown loader.");
+                            }
+                            LoadingStrategy.this.onLoadFinished((GraphObjectPagingLoader<T>) loader, data);
+                        }
+
+                        @Override
+                        public void onLoaderReset(Loader<SimpleGraphObjectCursor<T>> loader) {
+                            if (loader != LoadingStrategy.this.loader) {
+                                throw new FacebookException("Received callback for unknown loader.");
+                            }
+                            LoadingStrategy.this.onLoadReset((GraphObjectPagingLoader<T>) loader);
+                        }
+                    });
+
+            loader.setOnErrorListener(new GraphObjectPagingLoader.OnErrorListener() {
+                @Override
+                public void onError(FacebookException error, GraphObjectPagingLoader<?> loader) {
+                    hideActivityCircle();
+                    if (onErrorListener != null) {
+                        onErrorListener.onError(error);
+                    }
+                }
+            });
+
+            this.adapter = adapter;
+            // Tell the adapter about any data we might already have.
+            this.adapter.changeCursor(loader.getCursor());
+        }
+
+        public void detach() {
+            adapter.setDataNeededListener(null);
+            loader.setOnErrorListener(null);
+
+            loader = null;
+            adapter = null;
+        }
+
+        public void clearResults() {
+            if (loader != null) {
+                loader.clearResults();
+            }
+        }
+
+        public void startLoading(Request request) {
+            if (loader != null) {
+                loader.startLoading(request, true);
+            }
+        }
+
+        protected GraphObjectPagingLoader<T> onCreateLoader() {
+            return new GraphObjectPagingLoader<T>(getActivity(), graphObjectClass);
+        }
+
+        protected void onLoadReset(GraphObjectPagingLoader<T> loader) {
+            adapter.changeCursor(null);
+        }
+
+        protected void onLoadFinished(GraphObjectPagingLoader<T> loader, SimpleGraphObjectCursor<T> data) {
+            updateAdapter(data);
+        }
+    }
+
+    abstract class SelectionStrategy {
+        abstract boolean isSelected(String id);
+
+        abstract void toggleSelection(String id);
+
+        abstract Collection<String> getSelectedIds();
+
+        abstract void clear();
+
+        abstract boolean isEmpty();
+
+        abstract boolean shouldShowCheckBoxIfUnselected();
+
+        abstract void saveSelectionToBundle(Bundle outBundle, String key);
+
+        abstract void readSelectionFromBundle(Bundle inBundle, String key);
+    }
+
+    class SingleSelectionStrategy extends SelectionStrategy {
+        private String selectedId;
+
+        public Collection<String> getSelectedIds() {
+            return Arrays.asList(new String[]{selectedId});
+        }
+
+        @Override
+        boolean isSelected(String id) {
+            return selectedId != null && id != null && selectedId.equals(id);
+        }
+
+        @Override
+        void toggleSelection(String id) {
+            if (selectedId != null && selectedId.equals(id)) {
+                selectedId = null;
+            } else {
+                selectedId = id;
+            }
+        }
+
+        @Override
+        void saveSelectionToBundle(Bundle outBundle, String key) {
+            if (!TextUtils.isEmpty(selectedId)) {
+                outBundle.putString(key, selectedId);
+            }
+        }
+
+        @Override
+        void readSelectionFromBundle(Bundle inBundle, String key) {
+            if (inBundle != null) {
+                selectedId = inBundle.getString(key);
+            }
+        }
+
+        @Override
+        public void clear() {
+            selectedId = null;
+        }
+
+        @Override
+        boolean isEmpty() {
+            return selectedId == null;
+        }
+
+        @Override
+        boolean shouldShowCheckBoxIfUnselected() {
+            return false;
+        }
+    }
+
+    class MultiSelectionStrategy extends SelectionStrategy {
+        private Set<String> selectedIds = new HashSet<String>();
+
+        public Collection<String> getSelectedIds() {
+            return selectedIds;
+        }
+
+        @Override
+        boolean isSelected(String id) {
+            return id != null && selectedIds.contains(id);
+        }
+
+        @Override
+        void toggleSelection(String id) {
+            if (id != null) {
+                if (selectedIds.contains(id)) {
+                    selectedIds.remove(id);
+                } else {
+                    selectedIds.add(id);
+                }
+            }
+        }
+
+        @Override
+        void saveSelectionToBundle(Bundle outBundle, String key) {
+            if (!selectedIds.isEmpty()) {
+                String ids = TextUtils.join(",", selectedIds);
+                outBundle.putString(key, ids);
+            }
+        }
+
+        @Override
+        void readSelectionFromBundle(Bundle inBundle, String key) {
+            if (inBundle != null) {
+                String ids = inBundle.getString(key);
+                if (ids != null) {
+                    String[] splitIds = TextUtils.split(ids, ",");
+                    selectedIds.clear();
+                    Collections.addAll(selectedIds, splitIds);
+                }
+            }
+        }
+
+        @Override
+        public void clear() {
+            selectedIds.clear();
+        }
+
+        @Override
+        boolean isEmpty() {
+            return selectedIds.isEmpty();
+        }
+
+        @Override
+        boolean shouldShowCheckBoxIfUnselected() {
+            return true;
+        }
+    }
+
+    abstract class GraphObjectListFragmentAdapter<U extends GraphObject> extends GraphObjectAdapter<T> {
+        public GraphObjectListFragmentAdapter(Context context) {
+            super(context);
+        }
+
+        @Override
+        boolean isGraphObjectSelected(String graphObjectId) {
+            return selectionStrategy.isSelected(graphObjectId);
+        }
+
+        @Override
+        void updateCheckboxState(CheckBox checkBox, boolean graphObjectSelected) {
+            checkBox.setChecked(graphObjectSelected);
+            checkBox.setVisibility(selectionStrategy.shouldShowCheckBoxIfUnselected() ?
+                    View.VISIBLE : View.GONE);
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/GraphObjectPagingLoader.java b/facebook/src/com/facebook/GraphObjectPagingLoader.java
new file mode 100644
index 000000000..1c7cd0a2b
--- /dev/null
+++ b/facebook/src/com/facebook/GraphObjectPagingLoader.java
@@ -0,0 +1,250 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.Context;
+import android.os.Handler;
+import android.support.v4.content.Loader;
+
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+
+class GraphObjectPagingLoader<T extends GraphObject> extends Loader<SimpleGraphObjectCursor<T>> {
+    private final Class<T> graphObjectClass;
+    private boolean skipRoundtripIfCached;
+    private Request originalRequest;
+    private Request currentRequest;
+    private String nextLink;
+    private OnErrorListener onErrorListener;
+    private SimpleGraphObjectCursor<T> cursor;
+    private boolean appendResults = false;
+    private boolean loading = false;
+
+    public interface OnErrorListener {
+        public void onError(FacebookException error, GraphObjectPagingLoader<?> loader);
+    }
+
+    public GraphObjectPagingLoader(Context context, Class<T> graphObjectClass) {
+        super(context);
+
+        this.graphObjectClass = graphObjectClass;
+    }
+
+    public OnErrorListener getOnErrorListener() {
+        return onErrorListener;
+    }
+
+    public void setOnErrorListener(OnErrorListener listener) {
+        this.onErrorListener = listener;
+    }
+
+    public SimpleGraphObjectCursor<T> getCursor() {
+        return cursor;
+    }
+
+    public void clearResults() {
+        nextLink = null;
+        originalRequest = null;
+        currentRequest = null;
+
+        deliverResult(null);
+    }
+
+    public boolean isLoading() {
+        return loading;
+    }
+
+    public void startLoading(Request request, boolean skipRoundtripIfCached) {
+        originalRequest = request;
+        startLoading(request, skipRoundtripIfCached, 0);
+    }
+
+    public void refreshOriginalRequest(long afterDelay) {
+        if (originalRequest == null) {
+            throw new FacebookException(
+                    "refreshOriginalRequest may not be called until after startLoading has been called.");
+        }
+        startLoading(originalRequest, false, afterDelay);
+    }
+
+    public void followNextLink() {
+        if (nextLink != null) {
+            appendResults = true;
+            currentRequest = Request.newGraphPathRequest(originalRequest.getSession(), null, new Request.Callback() {
+                @Override
+                public void onCompleted(Response response) {
+                    requestCompleted(response);
+                }
+            });
+
+            // We rely on the "next" link returned to us being in the right format to return the results we expect.
+            HttpURLConnection connection = null;
+            try {
+                connection = Request.createConnection(new URL(nextLink));
+            } catch (IOException e) {
+                if (onErrorListener != null) {
+                    onErrorListener.onError(new FacebookException(e), this);
+                }
+                return;
+            }
+
+            loading = true;
+            RequestBatch batch = putRequestIntoBatch(currentRequest, skipRoundtripIfCached);
+            batch.setCacheKey(nextLink.toString());
+            Request.executeConnectionAsync(connection, batch);
+        }
+    }
+
+    @Override
+    public void deliverResult(SimpleGraphObjectCursor<T> cursor) {
+        SimpleGraphObjectCursor<T> oldCursor = this.cursor;
+        this.cursor = cursor;
+
+        if (isStarted()) {
+            super.deliverResult(cursor);
+
+            if (oldCursor != null && oldCursor != cursor && !oldCursor.isClosed()) {
+                oldCursor.close();
+            }
+        }
+    }
+
+    @Override
+    protected void onStartLoading() {
+        super.onStartLoading();
+
+        if (cursor != null) {
+            deliverResult(cursor);
+        }
+    }
+
+    private void startLoading(Request request, boolean skipRoundtripIfCached, long afterDelay) {
+        this.skipRoundtripIfCached = skipRoundtripIfCached;
+        appendResults = false;
+        nextLink = null;
+        currentRequest = request;
+        currentRequest.setCallback(new Request.Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                requestCompleted(response);
+            }
+        });
+
+        // We are considered loading even if we have a delay.
+        loading = true;
+
+        final RequestBatch batch = putRequestIntoBatch(request, skipRoundtripIfCached);
+        Runnable r = new Runnable() {
+            @Override
+            public void run() {
+                Request.executeBatchAsync(batch);
+            }
+        };
+        if (afterDelay == 0) {
+            r.run();
+        } else {
+            Handler handler = new Handler();
+            handler.postDelayed(r, afterDelay);
+        }
+    }
+
+    private RequestBatch putRequestIntoBatch(Request request, boolean skipRoundtripIfCached) {
+        // We just use the request URL as the cache key.
+        RequestBatch batch = new RequestBatch(request);
+        try {
+            batch.setCacheKey(request.getUrlForSingleRequest().toString());
+        } catch (MalformedURLException e) {
+            throw new FacebookException(e);
+        }
+        batch.setForceRoundTrip(!skipRoundtripIfCached);
+        return batch;
+    }
+
+    private void requestCompleted(Response response) {
+        Request request = response.getRequest();
+        if (request != currentRequest) {
+            return;
+        }
+
+        loading = false;
+        currentRequest = null;
+
+        FacebookException error = response.getError();
+        PagedResults result = response.getGraphObjectAs(PagedResults.class);
+        if (result == null && error == null) {
+            error = new FacebookException("GraphObjectPagingLoader received neither a result nor an error.");
+        }
+
+        if (error != null) {
+            nextLink = null;
+
+            if (onErrorListener != null) {
+                onErrorListener.onError(error, this);
+            }
+        } else {
+            boolean fromCache = response.getIsFromCache();
+            addResults(result, fromCache);
+            // Once we get any set of results NOT from the cache, stop trying to get any future ones
+            // from it.
+            if (!fromCache) {
+                skipRoundtripIfCached = false;
+            }
+        }
+    }
+
+    private void addResults(PagedResults result, boolean fromCache) {
+        SimpleGraphObjectCursor<T> cursorToModify = (cursor == null || !appendResults) ? new SimpleGraphObjectCursor<T>() :
+                new SimpleGraphObjectCursor<T>(cursor);
+
+        GraphObjectList<T> data = result.getData().castToListOf(graphObjectClass);
+        boolean haveData = data.size() > 0;
+
+        if (haveData) {
+            PagingInfo paging = result.getPaging();
+            if (nextLink != null && nextLink.equals(paging.getNext())) {
+                // We got the same "next" link as we just tried to retrieve. This could happen if cached
+                // data is invalid. All we can do in this case is pretend we have finished.
+                haveData = false;
+            } else {
+                nextLink = paging.getNext();
+
+                cursorToModify.addGraphObjects(data, fromCache);
+                cursorToModify.setMoreObjectsAvailable(true);
+            }
+        }
+        if (!haveData) {
+            cursorToModify.setMoreObjectsAvailable(false);
+            cursorToModify.setFromCache(fromCache);
+
+            nextLink = null;
+        }
+
+        deliverResult(cursorToModify);
+    }
+
+    interface PagingInfo extends GraphObject {
+        String getNext();
+    }
+
+    interface PagedResults extends GraphObject {
+        GraphObjectList<GraphObject> getData();
+
+        PagingInfo getPaging();
+    }
+}
diff --git a/facebook/src/com/facebook/GraphObjectWrapper.java b/facebook/src/com/facebook/GraphObjectWrapper.java
new file mode 100644
index 000000000..7656c363b
--- /dev/null
+++ b/facebook/src/com/facebook/GraphObjectWrapper.java
@@ -0,0 +1,661 @@
+/**
+ * Copyright 2010 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.lang.reflect.*;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.*;
+
+/**
+ * Creates proxies that implement GraphObject, GraphObjectList, and their derived types. These proxies allow access
+ * to underlying collections and name/value property bags via strongly-typed property getters and setters.
+ * <p/>
+ * This supports get/set properties that use primitive types, JSON types, Date, other GraphObject types, Iterable,
+ * Collection, List, and GraphObjectList.
+ */
+public final class GraphObjectWrapper {
+    private static final HashSet<Class<?>> verifiedGraphObjectClasses = new HashSet<Class<?>>();
+    private static final SimpleDateFormat[] dateFormats = new SimpleDateFormat[] {
+            new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.US),
+            new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.US), new SimpleDateFormat("yyyy-MM-dd", Locale.US), };
+
+    // No objects of this type should exist.
+    private GraphObjectWrapper() {
+    }
+
+    /**
+     * Creates a GraphObject proxy that provides typed access to the data in an underlying JSONObject.
+     * @param json the JSONObject containing the data to be exposed
+     * @return a GraphObject that represents the underlying data
+     *
+     * @throws FacebookException
+     *            If the passed in Class is not a valid GraphObject interface
+     */
+    public static GraphObject createGraphObject(JSONObject json) {
+        return createGraphObject(json, GraphObject.class);
+    }
+
+    /**
+     * Creates a GraphObject-derived proxy that provides typed access to the data in an underlying JSONObject.
+     * @param json the JSONObject containing the data to be exposed
+     * @param graphObjectClass the GraphObject-derived type to return
+     * @return a graphObjectClass that represents the underlying data
+     *
+     * @throws FacebookException
+     *            If the passed in Class is not a valid GraphObject interface
+     */
+    public static <T extends GraphObject> T createGraphObject(JSONObject json, Class<T> graphObjectClass) {
+        return createGraphObjectProxy(graphObjectClass, json);
+    }
+
+    /**
+     * Creates a GraphObject proxy that initially contains no data.
+     * @return a GraphObject with no data
+     *
+     * @throws FacebookException
+     *            If the passed in Class is not a valid GraphObject interface
+     */
+    public static GraphObject createGraphObject() {
+        return createGraphObject(GraphObject.class);
+    }
+
+    /**
+     * Creates a GraphObject-derived proxy that initially contains no data.
+     * @param graphObjectClass the GraphObject-derived type to return
+     * @return a graphObjectClass with no data
+     *
+     * @throws FacebookException
+     *            If the passed in Class is not a valid GraphObject interface
+     */
+    public static <T extends GraphObject> T createGraphObject(Class<T> graphObjectClass) {
+        return createGraphObjectProxy(graphObjectClass, new JSONObject());
+    }
+
+    /**
+     * Determines if two GraphObjects represent the same underlying graph object, based on their IDs.
+     * @param a a graph object
+     * @param b another graph object
+     * @return true if both graph objects have an ID and it is the same ID, false otherwise
+     */
+    public static boolean hasSameId(GraphObject a, GraphObject b) {
+        if (a == null || b == null || !a.asMap().containsKey("id") || !b.asMap().containsKey("id")) {
+            return false;
+        }
+        if (a.equals(b)) {
+            return true;
+        }
+        Object idA = a.getProperty("id");
+        Object idB = b.getProperty("id");
+        if (idA == null || idB == null || !(idA instanceof String) || !(idB instanceof String)) {
+            return false;
+        }
+        return idA.equals(idB);
+    }
+
+    static <T> GraphObjectList<T> wrapArray(JSONArray array, Class<T> objectClass) {
+        return new GraphObjectListImpl<T>(array, objectClass);
+    }
+
+    static <T> GraphObjectList<T> createArray(Class<T> objectClass) {
+        return wrapArray(new JSONArray(), objectClass);
+    }
+
+    private static <T extends GraphObject> T createGraphObjectProxy(Class<T> graphObjectClass, JSONObject state) {
+        verifyCanProxyClass(graphObjectClass);
+
+        Class<?>[] interfaces = new Class[] { graphObjectClass };
+        GraphObjectProxy graphObjectProxy = new GraphObjectProxy(state, graphObjectClass);
+
+        @SuppressWarnings("unchecked")
+        T graphObject = (T) Proxy.newProxyInstance(GraphObject.class.getClassLoader(), interfaces, graphObjectProxy);
+
+        return graphObject;
+    }
+
+    private static Map<String, Object> createGraphObjectProxyForMap(JSONObject state) {
+        Class<?>[] interfaces = new Class[]{Map.class};
+        GraphObjectProxy graphObjectProxy = new GraphObjectProxy(state, Map.class);
+
+        @SuppressWarnings("unchecked")
+        Map<String, Object> graphObject = (Map<String, Object>) Proxy
+                .newProxyInstance(GraphObject.class.getClassLoader(), interfaces, graphObjectProxy);
+
+        return graphObject;
+    }
+
+    private static synchronized <T extends GraphObject> boolean hasClassBeenVerified(Class<T> graphObjectClass) {
+        return verifiedGraphObjectClasses.contains(graphObjectClass);
+    }
+
+    private static synchronized <T extends GraphObject> void recordClassHasBeenVerified(Class<T> graphObjectClass) {
+        verifiedGraphObjectClasses.add(graphObjectClass);
+    }
+
+    private static <T extends GraphObject> void verifyCanProxyClass(Class<T> graphObjectClass) {
+        if (hasClassBeenVerified(graphObjectClass)) {
+            return;
+        }
+
+        if (!graphObjectClass.isInterface()) {
+            throw new FacebookGraphObjectException("GraphObjectWrapper can only wrap interfaces, not class: "
+                    + graphObjectClass.getName());
+        }
+
+        Method[] methods = graphObjectClass.getMethods();
+        for (Method method : methods) {
+            String methodName = method.getName();
+            int parameterCount = method.getParameterTypes().length;
+            Class<?> returnType = method.getReturnType();
+            boolean hasPropertyNameOverride = method.isAnnotationPresent(PropertyName.class);
+
+            if (method.getDeclaringClass().isAssignableFrom(GraphObject.class)) {
+                // Don't worry about any methods from GraphObject or one of its base classes.
+                continue;
+            } else if (parameterCount == 1 && returnType == Void.TYPE) {
+                if (hasPropertyNameOverride) {
+                    // If a property override is present, it MUST be valid. We don't fallback
+                    // to using the method name
+                    if (!Utility.isNullOrEmpty(method.getAnnotation(PropertyName.class).value())) {
+                        continue;
+                    }
+                } else if (methodName.startsWith("set") && methodName.length() > 3) {
+                    // Looks like a valid setter
+                    continue;
+                }
+            } else if (parameterCount == 0 && returnType != Void.TYPE) {
+                if (hasPropertyNameOverride) {
+                    // If a property override is present, it MUST be valid. We don't fallback
+                    // to using the method name
+                    if (!Utility.isNullOrEmpty(method.getAnnotation(PropertyName.class).value())) {
+                        continue;
+                    }
+                } else if (methodName.startsWith("get") && methodName.length() > 3) {
+                    // Looks like a valid getter
+                    continue;
+                }
+            }
+
+            throw new FacebookGraphObjectException("GraphObjectWrapper can't proxy method: " + method.toString());
+        }
+
+        recordClassHasBeenVerified(graphObjectClass);
+    }
+
+    // If expectedType is a generic type, expectedTypeAsParameterizedType must be provided in order to determine
+    // generic parameter types.
+    static <U> U coerceValueToExpectedType(Object value, Class<U> expectedType,
+            ParameterizedType expectedTypeAsParameterizedType) {
+        if (value == null) {
+            return null;
+        }
+
+        Class<?> valueType = value.getClass();
+        if (expectedType.isAssignableFrom(valueType)) {
+            @SuppressWarnings("unchecked")
+            U result = (U) value;
+            return result;
+        }
+
+        if (expectedType.isPrimitive()) {
+            // If the result is a primitive, let the runtime succeed or fail at unboxing it.
+            @SuppressWarnings("unchecked")
+            U result = (U) value;
+            return result;
+        }
+
+        if (GraphObject.class.isAssignableFrom(expectedType)) {
+            @SuppressWarnings("unchecked")
+            Class<? extends GraphObject> graphObjectClass = (Class<? extends GraphObject>) expectedType;
+
+            // We need a GraphObject, but we don't have one.
+            if (JSONObject.class.isAssignableFrom(valueType)) {
+                // We can wrap a JSONObject as a GraphObject.
+                @SuppressWarnings("unchecked")
+                U result = (U) createGraphObjectProxy(graphObjectClass, (JSONObject) value);
+                return result;
+            } else if (GraphObject.class.isAssignableFrom(valueType)) {
+                // We can cast a GraphObject-derived class to another GraphObject-derived class.
+                @SuppressWarnings("unchecked")
+                U result = (U) ((GraphObject) value).cast(graphObjectClass);
+                return result;
+            } else {
+                throw new FacebookGraphObjectException("Can't create GraphObject from " + valueType.getName());
+            }
+        } else if (Iterable.class.equals(expectedType) || Collection.class.equals(expectedType)
+                || List.class.equals(expectedType) || GraphObjectList.class.equals(expectedType)) {
+            if (expectedTypeAsParameterizedType == null) {
+                throw new FacebookGraphObjectException("can't infer generic type of: " + expectedType.toString());
+            }
+
+            Type[] actualTypeArguments = expectedTypeAsParameterizedType.getActualTypeArguments();
+
+            if (actualTypeArguments == null || actualTypeArguments.length != 1
+                    || !(actualTypeArguments[0] instanceof Class<?>)) {
+                throw new FacebookGraphObjectException(
+                        "Expect collection properties to be of a type with exactly one generic parameter.");
+            }
+            Class<?> collectionGenericArgument = (Class<?>) actualTypeArguments[0];
+
+            if (JSONArray.class.isAssignableFrom(valueType)) {
+                JSONArray jsonArray = (JSONArray) value;
+                @SuppressWarnings("unchecked")
+                U result = (U) wrapArray(jsonArray, collectionGenericArgument);
+                return result;
+            } else {
+                throw new FacebookGraphObjectException("Can't create Collection from " + valueType.getName());
+            }
+        } else if (String.class.equals(expectedType)) {
+            if (Number.class.isAssignableFrom(valueType)) {
+                @SuppressWarnings("unchecked")
+                U result = (U) String.format("%d", value);
+                return result;
+            }
+        } else if (Date.class.equals(expectedType)) {
+            if (String.class.isAssignableFrom(valueType)) {
+                for (SimpleDateFormat format : dateFormats) {
+                    try {
+                        Date date = format.parse((String) value);
+                        if (date != null) {
+                            @SuppressWarnings("unchecked")
+                            U result = (U) date;
+                            return result;
+                        }
+                    } catch (ParseException e) {
+                        // Keep going.
+                    }
+                }
+            }
+        }
+        throw new FacebookGraphObjectException("Can't convert type" + valueType.getName() + " to "
+                + expectedType.getName());
+    }
+
+    private static Object getUnderlyingJSONObject(Object obj) {
+        Class<?> objClass = obj.getClass();
+        if (GraphObject.class.isAssignableFrom(objClass)) {
+            GraphObject graphObject = (GraphObject) obj;
+            return graphObject.getInnerJSONObject();
+        } else if (GraphObjectList.class.isAssignableFrom(objClass)) {
+            GraphObjectList<?> graphObjectList = (GraphObjectList<?>) obj;
+            return graphObjectList.getInnerJSONArray();
+        }
+        return obj;
+    }
+
+    private abstract static class ProxyBase<STATE> implements InvocationHandler {
+        // Pre-loaded Method objects for the methods in java.lang.Object
+        private static final String EQUALS_METHOD = "equals";
+        private static final String TOSTRING_METHOD = "toString";
+
+        protected final STATE state;
+
+        protected ProxyBase(STATE state) {
+            this.state = state;
+        }
+
+        // Declared to return Object just to simplify implementation of proxy helpers.
+        protected final Object throwUnexpectedMethodSignature(Method method) {
+            throw new FacebookGraphObjectException(getClass().getName() + " got an unexpected method signature: "
+                    + method.toString());
+        }
+
+        protected final Object proxyObjectMethods(Object proxy, Method method, Object[] args) throws Throwable {
+            String methodName = method.getName();
+            if (methodName.equals(EQUALS_METHOD)) {
+                Object other = args[0];
+
+                if (other == null) {
+                    return false;
+                }
+
+                InvocationHandler handler = Proxy.getInvocationHandler(other);
+                if (!(handler instanceof GraphObjectProxy)) {
+                    return false;
+                }
+                GraphObjectProxy otherProxy = (GraphObjectProxy) handler;
+                return this.state.equals(otherProxy.state);
+            } else if (methodName.equals(TOSTRING_METHOD)) {
+                return toString();
+            }
+
+            // For others, just defer to the implementation object.
+            return method.invoke(this.state, args);
+        }
+
+    }
+
+    private final static class GraphObjectProxy extends ProxyBase<JSONObject> {
+        private static final String CLEAR_METHOD = "clear";
+        private static final String CONTAINSKEY_METHOD = "containsKey";
+        private static final String CONTAINSVALUE_METHOD = "containsValue";
+        private static final String ENTRYSET_METHOD = "entrySet";
+        private static final String GET_METHOD = "get";
+        private static final String ISEMPTY_METHOD = "isEmpty";
+        private static final String KEYSET_METHOD = "keySet";
+        private static final String PUT_METHOD = "put";
+        private static final String PUTALL_METHOD = "putAll";
+        private static final String REMOVE_METHOD = "remove";
+        private static final String SIZE_METHOD = "size";
+        private static final String VALUES_METHOD = "values";
+        private static final String CAST_METHOD = "cast";
+        private static final String CASTTOMAP_METHOD = "asMap";
+        private static final String GETPROPERTY_METHOD = "getProperty";
+        private static final String SETPROPERTY_METHOD = "setProperty";
+        private static final String REMOVEPROPERTY_METHOD = "removeProperty";
+        private static final String GETINNERJSONOBJECT_METHOD = "getInnerJSONObject";
+
+        private final Class<?> graphObjectClass;
+
+        public GraphObjectProxy(JSONObject state, Class<?> graphObjectClass) {
+            super(state);
+            this.graphObjectClass = graphObjectClass;
+        }
+
+        @Override
+        public String toString() {
+            return String.format("GraphObject{graphObjectClass=%s, state=%s}", graphObjectClass.getSimpleName(), state);
+        }
+
+        @Override
+        public final Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+            Class<?> declaringClass = method.getDeclaringClass();
+
+            if (declaringClass == Object.class) {
+                return proxyObjectMethods(proxy, method, args);
+            } else if (declaringClass == Map.class) {
+                return proxyMapMethods(method, args);
+            } else if (declaringClass == GraphObject.class) {
+                return proxyGraphObjectMethods(proxy, method, args);
+            } else if (GraphObject.class.isAssignableFrom(declaringClass)) {
+                return proxyGraphObjectGettersAndSetters(method, args);
+            }
+
+            return throwUnexpectedMethodSignature(method);
+        }
+
+        private final Object proxyMapMethods(Method method, Object[] args) {
+            String methodName = method.getName();
+            if (methodName.equals(CLEAR_METHOD)) {
+                Utility.jsonObjectClear(this.state);
+                return null;
+            } else if (methodName.equals(CONTAINSKEY_METHOD)) {
+                return this.state.has((String) args[0]);
+            } else if (methodName.equals(CONTAINSVALUE_METHOD)) {
+                return Utility.jsonObjectContainsValue(this.state, args[0]);
+            } else if (methodName.equals(ENTRYSET_METHOD)) {
+                return Utility.jsonObjectEntrySet(this.state);
+            } else if (methodName.equals(GET_METHOD)) {
+                return this.state.opt((String) args[0]);
+            } else if (methodName.equals(ISEMPTY_METHOD)) {
+                return this.state.length() == 0;
+            } else if (methodName.equals(KEYSET_METHOD)) {
+                return Utility.jsonObjectKeySet(this.state);
+            } else if (methodName.equals(PUT_METHOD)) {
+                return setJSONProperty(args);
+            } else if (methodName.equals(PUTALL_METHOD)) {
+                Map<String, Object> map = null;
+                if (args[0] instanceof Map) {
+                    @SuppressWarnings("unchecked")
+                    Map<String, Object> castMap = (Map<String, Object>) args[0];
+                    map = castMap;
+                } else if (args[0] instanceof GraphObject) {
+                    map = ((GraphObject) args[0]).asMap();
+                }
+                Utility.jsonObjectPutAll(this.state, map);
+                return null;
+            } else if (methodName.equals(REMOVE_METHOD)) {
+                this.state.remove((String) args[0]);
+                return null;
+            } else if (methodName.equals(SIZE_METHOD)) {
+                return this.state.length();
+            } else if (methodName.equals(VALUES_METHOD)) {
+                return Utility.jsonObjectValues(this.state);
+            }
+
+            return throwUnexpectedMethodSignature(method);
+        }
+
+        private final Object proxyGraphObjectMethods(Object proxy, Method method, Object[] args) {
+            String methodName = method.getName();
+            if (methodName.equals(CAST_METHOD)) {
+                @SuppressWarnings("unchecked")
+                Class<? extends GraphObject> graphObjectClass = (Class<? extends GraphObject>) args[0];
+
+                if (graphObjectClass != null &&
+                        graphObjectClass.isAssignableFrom(this.graphObjectClass)) {
+                    return proxy;
+                }
+                return GraphObjectWrapper.createGraphObjectProxy(graphObjectClass, this.state);
+            } else if (methodName.equals(GETINNERJSONOBJECT_METHOD)) {
+                InvocationHandler handler = Proxy.getInvocationHandler(proxy);
+                GraphObjectProxy otherProxy = (GraphObjectProxy) handler;
+                return otherProxy.state;
+            } else if (methodName.equals(CASTTOMAP_METHOD)) {
+                return GraphObjectWrapper.createGraphObjectProxyForMap(this.state);
+            } else if (methodName.equals(GETPROPERTY_METHOD)) {
+                return state.opt((String) args[0]);
+            } else if (methodName.equals(SETPROPERTY_METHOD)) {
+                return setJSONProperty(args);
+            } else if (methodName.equals(REMOVEPROPERTY_METHOD)) {
+                this.state.remove((String) args[0]);
+                return null;
+            }
+
+            return throwUnexpectedMethodSignature(method);
+        }
+
+        private final Object proxyGraphObjectGettersAndSetters(Method method, Object[] args) throws JSONException {
+            String methodName = method.getName();
+            int parameterCount = method.getParameterTypes().length;
+            PropertyName propertyNameOverride = method.getAnnotation(PropertyName.class);
+
+            String key = propertyNameOverride != null ? propertyNameOverride.value() :
+                    Utility.convertCamelCaseToLowercaseWithUnderscores(methodName.substring(3));
+
+            // If it's a get or a set on a GraphObject-derived class, we can handle it.
+            if (parameterCount == 0) {
+                // Has to be a getter. ASSUMPTION: The GraphObject-derived class has been verified
+                Object value = this.state.opt(key);
+
+                Class<?> expectedType = method.getReturnType();
+
+                Type genericReturnType = method.getGenericReturnType();
+                ParameterizedType parameterizedReturnType = null;
+                if (genericReturnType instanceof ParameterizedType) {
+                    parameterizedReturnType = (ParameterizedType) genericReturnType;
+                }
+
+                value = coerceValueToExpectedType(value, expectedType, parameterizedReturnType);
+
+                return value;
+            } else if (parameterCount == 1) {
+                // Has to be a setter. ASSUMPTION: The GraphObject-derived class has been verified
+                Object value = args[0];
+                // If this is a wrapped object, store the underlying JSONObject instead, in order to serialize
+                // correctly.
+                if (GraphObject.class.isAssignableFrom(value.getClass())) {
+                    value = ((GraphObject) value).getInnerJSONObject();
+                } else if (GraphObjectList.class.isAssignableFrom(value.getClass())) {
+                    value = ((GraphObjectList<?>) value).getInnerJSONArray();
+                } else if (Iterable.class.isAssignableFrom(value.getClass())) {
+                    JSONArray jsonArray = new JSONArray();
+                    Iterable<?> iterable = (Iterable<?>) value;
+                    for (Object o : iterable ) {
+                        if (GraphObject.class.isAssignableFrom(o.getClass())) {
+                            jsonArray.put(((GraphObject)o).getInnerJSONObject());
+                        } else {
+                            jsonArray.put(o);
+                        }
+                    }
+                    value = jsonArray;
+                }
+                this.state.putOpt(key, value);
+                return null;
+            }
+
+            return throwUnexpectedMethodSignature(method);
+        }
+
+        private Object setJSONProperty(Object[] args) {
+            String name = (String) args[0];
+            Object property = args[1];
+            Object value = getUnderlyingJSONObject(property);
+            try {
+                state.putOpt(name, value);
+            } catch (JSONException e) {
+                throw new IllegalArgumentException(e);
+            }
+            return null;
+        }
+    }
+
+    private final static class GraphObjectListImpl<T> extends AbstractList<T> implements GraphObjectList<T> {
+        private final JSONArray state;
+        private final Class<?> itemType;
+
+        public GraphObjectListImpl(JSONArray state, Class<?> itemType) {
+            Validate.notNull(state, "state");
+            Validate.notNull(itemType, "itemType");
+
+            this.state = state;
+            this.itemType = itemType;
+        }
+
+        @Override
+        public String toString() {
+            return String.format("GraphObjectList{itemType=%s, state=%s}", itemType.getSimpleName(), state);
+        }
+
+        @Override
+        public void add(int location, T object) {
+            // We only support adding at the end of the list, due to JSONArray restrictions.
+            if (location < 0) {
+                throw new IndexOutOfBoundsException();
+            } else if (location < size()) {
+                throw new UnsupportedOperationException("Only adding items at the end of the list is supported.");
+            }
+
+            put(location, object);
+        }
+
+        @Override
+        public T set(int location, T object) {
+            checkIndex(location);
+
+            T result = get(location);
+            put(location, object);
+            return result;
+        }
+
+        @Override
+        public int hashCode() {
+            return state.hashCode();
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj)
+                return true;
+            if (getClass() != obj.getClass()) {
+                return false;
+            }
+            @SuppressWarnings("unchecked")
+            GraphObjectListImpl<T> other = (GraphObjectListImpl<T>) obj;
+            return state.equals(other.state);
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public T get(int location) {
+            checkIndex(location);
+
+            Object value = state.opt(location);
+
+            // Class<?> expectedType = method.getReturnType();
+            // Type genericType = method.getGenericReturnType();
+            T result = (T) coerceValueToExpectedType(value, itemType, null);
+
+            return result;
+        }
+
+        @Override
+        public int size() {
+            return state.length();
+        }
+
+        @Override
+        public final <U extends GraphObject> GraphObjectList<U> castToListOf(Class<U> graphObjectClass) {
+            if (GraphObject.class.isAssignableFrom(itemType)) {
+                if (graphObjectClass.isAssignableFrom(itemType)) {
+                    @SuppressWarnings("unchecked")
+                    GraphObjectList<U> result = (GraphObjectList<U>)this;
+                    return result;
+                }
+
+                return wrapArray(state, graphObjectClass);
+            } else {
+                throw new FacebookGraphObjectException("Can't cast GraphObjectCollection of non-GraphObject type "
+                        + itemType);
+            }
+        }
+
+        @Override
+        public final JSONArray getInnerJSONArray() {
+            return state;
+        }
+
+        @Override
+        public void clear() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            throw new UnsupportedOperationException();
+        }
+
+        private void checkIndex(int index) {
+            if (index < 0 || index >= state.length()) {
+                throw new IndexOutOfBoundsException();
+            }
+        }
+
+        private void put(int index, T obj) {
+            Object underlyingObject = getUnderlyingJSONObject(obj);
+            try {
+                state.put(index, underlyingObject);
+            } catch (JSONException e) {
+                throw new IllegalArgumentException(e);
+            }
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/GraphPlace.java b/facebook/src/com/facebook/GraphPlace.java
new file mode 100644
index 000000000..14aa43640
--- /dev/null
+++ b/facebook/src/com/facebook/GraphPlace.java
@@ -0,0 +1,69 @@
+/**
+ * Copyright 2010 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Provides a strongly-typed representation of a Place as defined by the Graph API.
+ *
+ * Note that this interface is intended to be used with GraphObjectWrapper
+ * and not implemented directly.
+ */
+public interface GraphPlace extends GraphObject {
+    /**
+     * Returns the ID of the place.
+     * @return the ID of the place
+     */
+    public String getId();
+    /**
+     * Sets the ID of the place.
+     * @param id the ID of the place
+     */
+    public void setId(String id);
+
+    /**
+     * Returns the name of the place.
+     * @return the name of the place
+     */
+    public String getName();
+    /**
+     * Sets the name of the place.
+     * @param name the name of the place
+     */
+    public void setName(String name);
+
+    /**
+     * Returns the category of the place.
+     * @return the category of the place
+     */
+    public String getCategory();
+    /**
+     * Sets the category of the place.
+     * @param category the category of the place
+     */
+    public void setCategory(String category);
+
+    /**
+     * Returns the location of the place.
+     * @return the location of the place
+     */
+    public GraphLocation getLocation();
+    /**
+     * Sets the location of the place.
+     * @param location the location of the place
+     */
+    public void setLocation(GraphLocation location);
+}
diff --git a/facebook/src/com/facebook/GraphUser.java b/facebook/src/com/facebook/GraphUser.java
new file mode 100644
index 000000000..6b6eec6b7
--- /dev/null
+++ b/facebook/src/com/facebook/GraphUser.java
@@ -0,0 +1,124 @@
+/**
+ * Copyright 2010 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Provides a strongly-typed representation of a User as defined by the Graph API.
+ *
+ * Note that this interface is intended to be used with GraphObjectWrapper
+ * and not implemented directly.
+ */
+public interface GraphUser extends GraphObject {
+    /**
+     * Returns the ID of the user.
+     * @return the ID of the user
+     */
+    public String getId();
+    /**
+     * Sets the ID of the user.
+     * @param id the ID of the user
+     */
+    public void setId(String id);
+
+    /**
+     * Returns the name of the user.
+     * @return the name of the user
+     */
+    public String getName();
+    /**
+     * Sets the name of the user.
+     * @param name the name of the user
+     */
+    public void setName(String name);
+
+    /**
+     * Returns the first name of the user.
+     * @return the first name of the user
+     */
+    public String getFirstName();
+    /**
+     * Sets the first name of the user.
+     * @param firstName the first name of the user
+     */
+    public void setFirstName(String firstName);
+
+    /**
+     * Returns the middle name of the user.
+     * @return the middle name of the user
+     */
+    public String getMiddleName();
+    /**
+     * Sets the middle name of the user.
+     * @param middleName the middle name of the user
+     */
+    public void setMiddleName(String middleName);
+
+    /**
+     * Returns the last name of the user.
+     * @return the last name of the user
+     */
+    public String getLastName();
+    /**
+     * Sets the last name of the user.
+     * @param lastName the last name of the user
+     */
+    public void setLastName(String lastName);
+
+    /**
+     * Returns the Facebook URL of the user.
+     * @return the Facebook URL of the user
+     */
+    public String getLink();
+    /**
+     * Sets the Facebook URL of the user.
+     * @param link the Facebook URL of the user
+     */
+    public void setLink(String link);
+
+    /**
+     * Returns the Facebook username of the user.
+     * @return the Facebook username of the user
+     */
+    public String getUsername();
+    /**
+     * Sets the Facebook username of the user.
+     * @param username the Facebook username of the user
+     */
+    public void setUsername(String username);
+
+    /**
+     * Returns the birthday of the user.
+     * @return the birthday of the user
+     */
+    public String getBirthday();
+    /**
+     * Sets the birthday of the user.
+     * @param birthday the birthday of the user
+     */
+    public void setBirthday(String birthday);
+
+    /**
+     * Returns the current city of the user.
+     * @return the current city of the user
+     */
+    public GraphLocation getLocation();
+    /**
+     * Sets the current city of the user.
+     * @param location the current city of the user
+     */
+    public void setLocation(GraphLocation location);
+}
diff --git a/facebook/src/com/facebook/HttpMethod.java b/facebook/src/com/facebook/HttpMethod.java
new file mode 100644
index 000000000..83936b091
--- /dev/null
+++ b/facebook/src/com/facebook/HttpMethod.java
@@ -0,0 +1,37 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Enumeration of HTTP methods supported by Request
+ */
+public enum HttpMethod {
+    /**
+     * Use HTTP method "GET" for the request
+     */
+    GET,
+
+    /**
+     * Use HTTP method "POST" for the request
+     */
+    POST,
+
+    /**
+     * Use HTTP method "DELETE" for the request
+     */
+    DELETE,
+}
diff --git a/facebook/src/com/facebook/ImageDownloader.java b/facebook/src/com/facebook/ImageDownloader.java
new file mode 100644
index 000000000..42d7f1b49
--- /dev/null
+++ b/facebook/src/com/facebook/ImageDownloader.java
@@ -0,0 +1,75 @@
+package com.facebook;
+
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.os.AsyncTask;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.EnumSet;
+
+class ImageDownloader {
+
+    /**
+     * Downloads the image specified in the passed in request.
+     * If a callback is specified, it is guaranteed to be invoked on the calling thread.
+     * @param request Request to process
+     */
+    static void downloadAsync(ImageRequest request) {
+        ImageDownloadTask downloadTask = new ImageDownloadTask();
+        downloadTask.execute(request);
+    }
+
+    private static class ImageDownloadTask extends AsyncTask<ImageRequest, Void, ImageResponse> {
+        @Override
+        protected ImageResponse doInBackground(ImageRequest... requests) {
+            Bitmap bitmap = null;
+            Exception error = null;
+            ImageRequest request = requests[0];
+            boolean isCachedRedirect = false;
+
+            if (!request.isCancelled()) {
+                URL url = request.getImageUrl();
+                InputStream stream = null;
+                try {
+                    if (request.isCachedRedirectAllowed()) {
+                        stream = ImageResponseCache.getCachedImageStream(
+                                url,
+                                request.getContext(),
+                                EnumSet.of(ImageResponseCache.Options.FOLLOW_REDIRECTS));
+                        isCachedRedirect = stream != null;
+                    }
+
+                    if (!isCachedRedirect) {
+                        stream = ImageResponseCache.getImageStream(
+                                url,
+                                request.getContext(),
+                                ImageResponseCache.Options.NONE);
+                    }
+
+                    if (stream != null) {
+                        bitmap = BitmapFactory.decodeStream(stream);
+                    }
+                } catch (IOException e) {
+                    error = e;
+                } finally {
+                    Utility.closeQuietly(stream);
+                }
+            }
+
+            return new ImageResponse(request, error, isCachedRedirect, bitmap);
+        }
+
+        @Override
+        protected void onPostExecute(ImageResponse response) {
+            super.onPostExecute(response);
+
+            ImageRequest request = response.getRequest();
+            ImageRequest.Callback callback = request.getCallback();
+            if (!request.isCancelled() && callback != null) {
+                callback.onCompleted(response);
+            }
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/ImageRequest.java b/facebook/src/com/facebook/ImageRequest.java
new file mode 100644
index 000000000..3b68b5f2e
--- /dev/null
+++ b/facebook/src/com/facebook/ImageRequest.java
@@ -0,0 +1,101 @@
+package com.facebook;
+
+import android.content.Context;
+import android.net.Uri;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+
+class ImageRequest {
+
+    interface Callback {
+        void onCompleted(ImageResponse response);
+    }
+
+    static final int UNSPECIFIED_DIMENSION = 0;
+
+    private static final String PROFILEPIC_URL_FORMAT =
+            "https://graph.facebook.com/%s/picture";
+    private static final String HEIGHT_PARAM = "height";
+    private static final String WIDTH_PARAM = "width";
+    private static final String MIGRATION_PARAM = "migration_overrides";
+    private static final String MIGRATION_VALUE = "{october_2012:true}";
+
+    private Context context;
+    private URL imageUrl;
+    private Callback callback;
+    private boolean isCancelled;
+    private boolean allowCachedRedirects;
+
+    static ImageRequest createProfilePictureImageRequest(
+            Context context,
+            String userId,
+            int width,
+            int height,
+            boolean allowCachedImage,
+            Callback callback)
+        throws MalformedURLException {
+
+        Validate.notNullOrEmpty(userId, "userId");
+
+        width = Math.max(width, UNSPECIFIED_DIMENSION);
+        height = Math.max(height, UNSPECIFIED_DIMENSION);
+
+        if (width == UNSPECIFIED_DIMENSION && height == UNSPECIFIED_DIMENSION) {
+            throw new IllegalArgumentException("Either width or height must be greater than 0");
+        }
+
+        Uri.Builder builder = new Uri.Builder().encodedPath(String.format(PROFILEPIC_URL_FORMAT, userId));
+
+        if (height != UNSPECIFIED_DIMENSION) {
+            builder.appendQueryParameter(HEIGHT_PARAM, String.valueOf(height));
+        }
+
+        if (width != UNSPECIFIED_DIMENSION) {
+            builder.appendQueryParameter(WIDTH_PARAM, String.valueOf(width));
+        }
+
+        builder.appendQueryParameter(MIGRATION_PARAM, MIGRATION_VALUE);
+
+        return new ImageRequest(context, new URL(builder.toString()), allowCachedImage, callback);
+    }
+
+    ImageRequest(Context context, URL imageUrl, boolean allowCachedRedirects, Callback callback) {
+        Validate.notNull(imageUrl, "imageUrl");
+        this.context = context;
+        this.imageUrl = imageUrl;
+        this.callback = callback;
+        this.allowCachedRedirects = allowCachedRedirects;
+    }
+
+    Context getContext() {
+        return context;
+    }
+
+    URL getImageUrl() {
+        return imageUrl;
+    }
+
+    Callback getCallback() {
+        return callback;
+    }
+
+    /**
+     * Will prevent the registered callback from firing.
+     * This method is only reliable when called from the UI thread. If you cancel a request
+     * from a non-UI thread, the registered callback may be invoked. For multi-threaded
+     * scenarios, it is best to check whether the ImageRequest has been cancelled in the
+     * callback.
+     */
+    void cancel() {
+        isCancelled = true;
+    }
+
+    boolean isCancelled() {
+        return isCancelled;
+    }
+
+    boolean isCachedRedirectAllowed() {
+        return allowCachedRedirects;
+    }
+}
diff --git a/facebook/src/com/facebook/ImageResponse.java b/facebook/src/com/facebook/ImageResponse.java
new file mode 100644
index 000000000..040455837
--- /dev/null
+++ b/facebook/src/com/facebook/ImageResponse.java
@@ -0,0 +1,34 @@
+package com.facebook;
+
+import android.graphics.Bitmap;
+
+class ImageResponse {
+
+    private ImageRequest request;
+    private Exception error;
+    private boolean isCachedRedirect;
+    private Bitmap bitmap;
+
+    ImageResponse(ImageRequest request, Exception error, boolean isCachedRedirect, Bitmap bitmap) {
+        this.request = request;
+        this.error = error;
+        this.bitmap = bitmap;
+        this.isCachedRedirect = isCachedRedirect;
+    }
+
+    ImageRequest getRequest() {
+        return request;
+    }
+
+    Exception getError() {
+        return error;
+    }
+
+    Bitmap getBitmap() {
+        return bitmap;
+    }
+
+    boolean isCachedRedirect() {
+        return isCachedRedirect;
+    }
+}
diff --git a/facebook/src/com/facebook/ImageResponseCache.java b/facebook/src/com/facebook/ImageResponseCache.java
new file mode 100644
index 000000000..252f622a1
--- /dev/null
+++ b/facebook/src/com/facebook/ImageResponseCache.java
@@ -0,0 +1,230 @@
+/**
+ * Copyright 2010 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.Context;
+import android.util.Log;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.EnumSet;
+
+class ImageResponseCache {
+    static final String TAG = ImageResponseCache.class.getSimpleName();
+    private static final String REDIRECT_CONTENT_TAG = TAG + "_Redirect";
+
+    private volatile static FileLruCache imageCache;
+
+    static InputStream getCachedImageStream(URL url, Context context) {
+        return getCachedImageStream(url, context, Options.NONE);
+    }
+
+    // Get stream from cache, or return null if the image is not cached.
+    // Does not throw if there was an error.
+    static InputStream getCachedImageStream(URL url, Context context, EnumSet<Options> options) {
+        InputStream imageStream = null;
+        if (url != null) {
+            if (options.contains(Options.FOLLOW_REDIRECTS)) {
+                url = getRedirectedURL(context, url.toString());
+            }
+
+            if (isCDNURL(url)) {
+                try {
+                    FileLruCache cache = getCache(context);
+                    imageStream = cache.get(url.toString());
+                } catch (IOException e) {
+                    Logger.log(LoggingBehaviors.CACHE, Log.WARN, TAG, e.toString());
+                }
+            }
+        }
+
+        return imageStream;
+    }
+
+    synchronized static FileLruCache getCache(Context context) throws IOException{
+        if (imageCache == null) {
+            imageCache = new FileLruCache(context.getApplicationContext(), TAG, new FileLruCache.Limits());
+        }
+        return imageCache;
+    }
+
+    static InputStream getImageStream(URL url, Context context) throws IOException {
+        return getImageStream(
+                url,
+                context,
+                EnumSet.of(Options.FOLLOW_REDIRECTS, Options.RETURN_STREAM_ON_HTTP_ERROR));
+    }
+
+    // Get stream from cache if present, otherwise get from web.
+    // If not cached and the uri points to a CDN, store the result in cache.
+    static InputStream getImageStream(URL url, Context context, EnumSet<Options> options) throws IOException {
+        Validate.notNull(url, "url");
+        Validate.notNull(context, "context");
+
+        InputStream stream = null;
+        boolean performRequest = true;
+        while (performRequest) {
+            performRequest = false;
+            // See if the url has been cached
+            stream = getCachedImageStream(url, context);
+            if (stream != null) {
+                break;
+            }
+
+            // Since it isn't cached, make the network call
+            HttpURLConnection connection = (HttpURLConnection)url.openConnection();
+            connection.setInstanceFollowRedirects(options.contains(Options.FOLLOW_REDIRECTS));
+
+            switch (connection.getResponseCode()) {
+                case HttpURLConnection.HTTP_MOVED_PERM:
+                case HttpURLConnection.HTTP_MOVED_TEMP:
+                    // redirect. So we need to perform further requests
+                    String redirectLocation = connection.getHeaderField("location");
+                    if (!Utility.isNullOrEmpty(redirectLocation)) {
+                        cacheImageRedirect(context, url, redirectLocation);
+                        url = new URL(redirectLocation);
+                        performRequest = true;
+                    }
+                    break;
+
+                case HttpURLConnection.HTTP_OK:
+                    // image should be available
+                    stream = cacheImageFromStream(
+                            context,
+                            url,
+                            new BufferedHttpInputStream(connection.getInputStream(), connection));
+                    break;
+
+                default:
+                    if (options.contains(Options.RETURN_STREAM_ON_HTTP_ERROR)) {
+                        // If response is not HTTP_OK, return error stream
+                        stream = new BufferedHttpInputStream(connection.getErrorStream(), connection);
+                    }
+                    break;
+            }
+        }
+
+        return stream;
+    }
+
+    private static InputStream cacheImageFromStream(Context context, URL url, InputStream stream) {
+        if (isCDNURL(url)) {
+            try {
+                FileLruCache cache = getCache(context);
+
+                // Wrap stream with a caching stream
+                stream = cache.interceptAndPut(url.toString(), stream);
+            } catch (IOException e) {
+                // Caching is best effort
+            }
+        }
+        return stream;
+    }
+
+    private static void cacheImageRedirect(Context context, URL fromUrl, String toUrl) {
+        OutputStream redirectStream = null;
+        try {
+            FileLruCache cache = getCache(context);
+            redirectStream = cache.openPutStream(fromUrl.toString(), REDIRECT_CONTENT_TAG);
+            redirectStream.write(toUrl.getBytes());
+        } catch (IOException e) {
+            // Caching is best effort
+        } finally {
+            Utility.closeQuietly(redirectStream);
+        }
+    }
+
+    private static URL getRedirectedURL(Context context, String url) {
+        URL finalUrl = null;
+        InputStreamReader reader = null;
+        try {
+            InputStream stream;
+            FileLruCache cache = getCache(context);
+            boolean redirectExists = false;
+            while ((stream = cache.get(url, REDIRECT_CONTENT_TAG)) != null) {
+                redirectExists = true;
+
+                // Get the redirected url
+                reader = new InputStreamReader(stream);
+                char[] buffer = new char[128];
+                int bufferLength;
+                StringBuilder urlBuilder = new StringBuilder();
+                while ((bufferLength = reader.read(buffer, 0, buffer.length)) > 0) {
+                    urlBuilder.append(buffer, 0, bufferLength);
+                }
+                Utility.closeQuietly(reader);
+
+                // Iterate to the next url in the redirection
+                url = urlBuilder.toString();
+            }
+
+            if (redirectExists) {
+                finalUrl = new URL(url);
+            }
+        } catch (MalformedURLException e) {
+            // caching is best effort, so ignore the exception
+        } catch (IOException ioe) {
+        } finally {
+            Utility.closeQuietly(reader);
+        }
+
+        return finalUrl;
+    }
+
+    private static boolean isCDNURL(URL url) {
+        if (url != null) {
+            String uriHost = url.getHost();
+
+            if (uriHost.endsWith("fbcdn.net")) {
+                return true;
+            }
+
+            if (uriHost.startsWith("fbcdn") && uriHost.endsWith("akamaihd.net")) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private static class BufferedHttpInputStream extends BufferedInputStream {
+        HttpURLConnection connection;
+        BufferedHttpInputStream(InputStream stream, HttpURLConnection connection) {
+            super(stream, Utility.DEFAULT_STREAM_BUFFER_SIZE);
+            this.connection = connection;
+        }
+
+        @Override
+        public void close() throws IOException {
+            super.close();
+            Utility.disconnectQuietly(connection);
+        }
+    }
+
+    enum Options {
+        FOLLOW_REDIRECTS,
+        RETURN_STREAM_ON_HTTP_ERROR;
+        public static final EnumSet<Options> NONE = EnumSet.noneOf(Options.class);
+    }
+}
+
diff --git a/facebook/src/com/facebook/Logger.java b/facebook/src/com/facebook/Logger.java
new file mode 100644
index 000000000..2aff1caf0
--- /dev/null
+++ b/facebook/src/com/facebook/Logger.java
@@ -0,0 +1,130 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.util.Log;
+
+import java.util.HashMap;
+import java.util.Map;
+
+class Logger {
+    private static final HashMap<String, String> stringsToReplace = new HashMap<String, String>();
+
+    private final LoggingBehaviors behavior;
+    private final String tag;
+    private StringBuilder contents;
+    private int priority = Log.DEBUG;
+
+    // Note that the mapping of replaced strings is never emptied, so it should be used only for things that
+    // are not expected to be too numerous, such as access tokens.
+    public synchronized static void registerStringToReplace(String original, String replace) {
+        stringsToReplace.put(original, replace);
+    }
+
+    public synchronized static void registerAccessToken(String accessToken) {
+        if (Settings.isLoggingBehaviorEnabled(LoggingBehaviors.INCLUDE_ACCESS_TOKENS) == false) {
+            registerStringToReplace(accessToken, "ACCESS_TOKEN_REMOVED");
+        }
+    }
+
+    public static void log(LoggingBehaviors behavior, String tag, String string) {
+        log(behavior, Log.DEBUG, tag, string);
+    }
+
+    public static void log(LoggingBehaviors behavior, String tag, String format, Object... args) {
+        if (Settings.isLoggingBehaviorEnabled(behavior)) {
+            String string = String.format(format, args);
+            log(behavior, Log.DEBUG, tag, string);
+        }
+    }
+
+    public static void log(LoggingBehaviors behavior, int priority, String tag, String string) {
+        if (Settings.isLoggingBehaviorEnabled(behavior)) {
+            string = replaceStrings(string);
+            if (tag.startsWith(Settings.LOG_TAG_BASE) == false) {
+                tag = Settings.LOG_TAG_BASE + tag;
+            }
+            Log.println(priority, tag, string);
+        }
+    }
+
+    private synchronized static String replaceStrings(String string) {
+        for (Map.Entry<String, String> entry : stringsToReplace.entrySet()) {
+            string = string.replace(entry.getKey(), entry.getValue());
+        }
+        return string;
+    }
+
+    public Logger(LoggingBehaviors behavior, String tag) {
+        Validate.notNullOrEmpty(tag, "tag");
+
+        this.behavior = behavior;
+        this.tag = Settings.LOG_TAG_BASE + tag;
+        this.contents = new StringBuilder();
+    }
+
+    public int getPriority() {
+        return priority;
+    }
+
+    public void setPriority(int value) {
+        Validate.oneOf(value, "value", Log.ASSERT, Log.DEBUG, Log.ERROR, Log.INFO, Log.VERBOSE, Log.WARN);
+
+        priority = value;
+    }
+
+    public String getContents() {
+        return replaceStrings(contents.toString());
+    }
+
+    // Writes the accumulated contents, then clears contents to start again.
+    public void log() {
+        logString(contents.toString());
+        contents = new StringBuilder();
+    }
+
+    // Immediately logs a string, ignoring any accumulated contents, which are left unchanged.
+    public void logString(String string) {
+        log(behavior, priority, tag, string);
+    }
+
+    public void append(StringBuilder stringBuilder) {
+        if (shouldLog()) {
+            contents.append(stringBuilder);
+        }
+    }
+
+    public void append(String string) {
+        if (shouldLog()) {
+            contents.append(string);
+        }
+    }
+
+    public void append(String format, Object... args) {
+        if (shouldLog()) {
+            contents.append(String.format(format, args));
+        }
+    }
+
+    public void appendKeyValue(String key, Object value) {
+        append("  %s:\t%s\n", key, value);
+    }
+
+    private boolean shouldLog() {
+        return Settings.isLoggingBehaviorEnabled(behavior);
+    }
+}
diff --git a/facebook/src/com/facebook/LoggingBehaviors.java b/facebook/src/com/facebook/LoggingBehaviors.java
new file mode 100644
index 000000000..9b8eda90c
--- /dev/null
+++ b/facebook/src/com/facebook/LoggingBehaviors.java
@@ -0,0 +1,41 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Specifies different categories of logging messages that can be generated.
+ *
+ * @see Settings#addLoggingBehavior(LoggingBehaviors)
+ */
+public enum LoggingBehaviors {
+    /**
+     * Indicates that HTTP requests and a summary of responses should be logged.
+     */
+    REQUESTS,
+    /**
+     * Indicates that access tokens should be logged as part of the request logging; normally they are not.
+     */
+    INCLUDE_ACCESS_TOKENS,
+    /**
+     * Indicates that the entire raw HTTP response for each request should be logged.
+     */
+    INCLUDE_RAW_RESPONSES,
+    /**
+     * Indicates that cache operations should be logged.
+     */
+    CACHE
+}
diff --git a/facebook/src/com/facebook/LoginActivity.java b/facebook/src/com/facebook/LoginActivity.java
new file mode 100644
index 000000000..5b17da788
--- /dev/null
+++ b/facebook/src/com/facebook/LoginActivity.java
@@ -0,0 +1,127 @@
+package com.facebook;
+
+import android.Manifest;
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.net.Uri;
+import android.os.Bundle;
+import android.webkit.CookieSyncManager;
+import com.facebook.android.*;
+
+/**
+ * This class addresses the issue of a potential window leak during
+ * dialog authorization if the Activity containing the dialog is destroyed
+ * (e.g. if the user rotates the device).
+ * <p/>
+ * Add this activity to your AndroidManifest.xml to ensure proper handling
+ * of dialog authorization.
+ */
+public class LoginActivity extends Activity {
+    private Dialog loginDialog;
+    private Dialog errorDialog;
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        int permissionCheck = checkCallingOrSelfPermission(Manifest.permission.INTERNET);
+        if (permissionCheck != PackageManager.PERMISSION_GRANTED) {
+            AlertDialog.Builder builder = new AlertDialog.Builder(this);
+            builder.setTitle("AndroidManifest Error")
+                   .setMessage("WebView login requires INTERNET permission")
+                   .setCancelable(true)
+                   .setPositiveButton(R.string.com_facebook_dialogloginactivity_ok_button,
+                           new DialogInterface.OnClickListener() {
+                               @Override
+                               public void onClick(DialogInterface dialogInterface, int i) {
+                                   finish();
+                               }
+                           })
+                   .setOnCancelListener(new DialogInterface.OnCancelListener() {
+                       @Override
+                       public void onCancel(DialogInterface dialogInterface) {
+                           finish();
+                       }
+                   });
+            errorDialog = builder.create();
+            errorDialog.show();
+            setResult(Activity.RESULT_CANCELED);
+            return;
+        }
+
+        Bundle parameters = new Bundle();
+        String permissions = getIntent().getStringExtra("scope");
+        if (!Utility.isNullOrEmpty(permissions)) {
+            parameters.putString(ServerProtocol.DIALOG_PARAM_SCOPE, permissions);
+        }
+
+        // The call to clear cookies will create the first instance of CookieSyncManager if necessary
+        Utility.clearFacebookCookies(this);
+
+        Facebook.DialogListener listener = new Facebook.DialogListener() {
+            public void onComplete(Bundle bundle) {
+                // Ensure any cookies set by the dialog are saved
+                CookieSyncManager.getInstance().sync();
+                setResultAndFinish(Activity.RESULT_OK, bundle);
+            }
+
+            public void onError(DialogError error) {
+                Bundle bundle = null;
+                if (error != null) {
+                    bundle = new Bundle();
+                    bundle.putInt(Session.WEB_VIEW_ERROR_CODE_KEY, error.getErrorCode());
+                    bundle.putString(Session.WEB_VIEW_FAILING_URL_KEY, error.getFailingUrl());
+                    bundle.putString("error", error.getMessage());
+                }
+                setResultAndFinish(Activity.RESULT_OK, bundle);
+            }
+
+            public void onFacebookError(FacebookError error) {
+                Bundle bundle = null;
+                if (error != null && error.getMessage() != null) {
+                    bundle = new Bundle();
+                    bundle.putString("error", error.getMessage());
+                }
+                setResultAndFinish(Activity.RESULT_OK, bundle);
+            }
+
+            public void onCancel() {
+                setResultAndFinish(Activity.RESULT_CANCELED, null);
+            }
+
+            private void setResultAndFinish(int resultCode, Bundle bundle) {
+                if (bundle != null) {
+                    Intent intent = new Intent();
+                    intent.putExtras(bundle);
+                    setResult(resultCode, intent);
+                } else {
+                    setResult(resultCode);
+                }
+                finish();
+            }
+        };
+
+        parameters.putString(ServerProtocol.DIALOG_PARAM_DISPLAY, "touch");
+        parameters.putString(ServerProtocol.DIALOG_PARAM_REDIRECT_URI, "fbconnect://success");
+        parameters.putString(ServerProtocol.DIALOG_PARAM_TYPE, "user_agent");
+        parameters.putString(ServerProtocol.DIALOG_PARAM_CLIENT_ID, getIntent().getStringExtra("client_id"));
+
+        Uri uri = Utility.buildUri(ServerProtocol.DIALOG_AUTHORITY, ServerProtocol.DIALOG_OAUTH_PATH, parameters);
+        loginDialog = new FbDialog(this, uri.toString(), listener);
+        loginDialog.show();
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        if (errorDialog != null && errorDialog.isShowing()) {
+            errorDialog.dismiss();
+        }
+        if (loginDialog != null && loginDialog.isShowing()) {
+            loginDialog.dismiss();
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/LoginButton.java b/facebook/src/com/facebook/LoginButton.java
new file mode 100644
index 000000000..0b9b85430
--- /dev/null
+++ b/facebook/src/com/facebook/LoginButton.java
@@ -0,0 +1,524 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.facebook;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.res.TypedArray;
+import android.support.v4.app.Fragment;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.view.View;
+import android.widget.Button;
+import com.facebook.android.R;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A Log In/Log Out button that maintains session state and logs
+ * in/out for the app.
+ * <p/>
+ * This control will create and use the active session upon construction
+ * if it has the available data (if the app ID is specified in the manifest).
+ * It will also open the active session if it does not require user interaction
+ * (i.e. if the session is in the {@link SessionState#CREATED_TOKEN_LOADED} state.
+ * Developers can override the use of the active session by calling
+ * the {@link #setSession(Session)} method.
+ */
+public class LoginButton extends Button {
+
+    private static final String TAG = LoginButton.class.getName();
+    private List<String> permissions = Collections.<String>emptyList();
+    private Session.AuthorizationType authorizationType = null;
+    private String applicationId = null;
+    private SessionTracker sessionTracker;
+    private GraphUser user = null;
+    private Session userInfoSession = null; // the Session used to fetch the current user info
+    private boolean confirmLogout;
+    private boolean fetchUserInfo;
+    private String loginText;
+    private String logoutText;
+    private UserInfoChangedCallback userInfoChangedCallback;
+    private Fragment parentFragment;
+    private OnErrorListener onErrorListener;
+
+    /**
+     * Specifies a callback interface that will be called when the button's notion of the current
+     * user changes (if the fetch_user_info attribute is true for this control).
+     */
+    public interface UserInfoChangedCallback {
+        /**
+         * Called when the current user changes.
+         * @param user  the current user, or null if there is no user
+         */
+        void onUserInfoFetched(GraphUser user);
+    }
+
+    /**
+     * Callback interface that will be called when a network or other error is encountered
+     * while logging in.
+     */
+    public interface OnErrorListener {
+        /**
+         * Called when a network or other error is encountered.
+         * @param error     a FacebookException representing the error that was encountered.
+         */
+        void onError(FacebookException error);
+    }
+
+    /**
+     * Create the LoginButton.
+     * 
+     * @see View#View(Context)
+     */
+    public LoginButton(Context context) {
+        super(context);
+        initializeActiveSessionWithCachedToken(context);
+        // since onFinishInflate won't be called, we need to finish initialization ourselves
+        finishInit();
+    }
+    
+    /**
+     * Create the LoginButton by inflating from XML
+     * 
+     * @see View#View(Context, AttributeSet)
+     */
+    public LoginButton(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        if (attrs.getStyleAttribute() == 0) {
+            // apparently there's no method of setting a default style in xml,
+            // so in case the users do not explicitly specify a style, we need 
+            // to use sensible defaults.
+            this.setBackgroundResource(R.drawable.com_facebook_loginbutton_blue);
+            this.setTextColor(getResources().getColor(R.color.com_facebook_loginview_text_color));
+            this.setTextSize(TypedValue.COMPLEX_UNIT_PX, getResources().getDimension(R.dimen.com_facebook_loginview_text_size));
+            this.setPadding(getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_left),
+                            getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_top),
+                            getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_right),
+                            getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_bottom));
+            this.setWidth(getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_width));
+            this.setHeight(getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_height));
+            this.setGravity(Gravity.CENTER);
+        }
+        parseAttributes(attrs);
+        initializeActiveSessionWithCachedToken(context);
+    }
+
+    /**
+     * Create the LoginButton by inflating from XML and applying a style.
+     * 
+     * @see View#View(Context, AttributeSet, int)
+     */
+    public LoginButton(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        parseAttributes(attrs);
+        initializeActiveSessionWithCachedToken(context);
+    }
+
+    /**
+     * Sets an OnErrorListener for this instance of LoginButton to call into when
+     * certain exceptions occur.
+     *
+     * @param onErrorListener The listener object to set
+     */
+    public void setOnErrorListener(OnErrorListener onErrorListener) {
+        this.onErrorListener = onErrorListener;
+    }
+
+    /**
+     * Returns the current OnErrorListener for this instance of LoginButton.
+     *
+     * @return The OnErrorListener
+     */
+    public OnErrorListener getOnErrorListener() {
+        return onErrorListener;
+    }
+    
+    /**
+     * Set the permissions to use when the session is opened. The permissions here
+     * can only be read permissions. If any publish permissions are included, the login
+     * attempt by the user will fail. The LoginButton can only be associated with either
+     * read permissions or publish permissions, but not both. Calling both
+     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
+     * will result in an exception being thrown unless clearPermissions is called in between.
+     * <p/>
+     * This method is only meaningful if called before the session is open. If this is called
+     * after the session is opened, and the list of permissions passed in is not a subset
+     * of the permissions granted during the authorization, it will log an error.
+     * <p/>
+     * Since the session can be automatically opened when the LoginButton is constructed,
+     * it's important to always pass in a consistent set of permissions to this method, or
+     * manage the setting of permissions outside of the LoginButton class altogether
+     * (by managing the session explicitly).
+     * 
+     * @param permissions the read permissions to use
+     *
+     * @throws UnsupportedOperationException if setPublishPermissions has been called
+     */
+    public void setReadPermissions(List<String> permissions) {
+        if (Session.AuthorizationType.PUBLISH.equals(authorizationType)) {
+            throw new UnsupportedOperationException(
+                    "Cannot call setReadPermissions after setPublishPermissions has been called.");
+        }
+        if (validatePermissions(permissions, Session.AuthorizationType.READ)) {
+            this.permissions = permissions;
+            authorizationType = Session.AuthorizationType.READ;
+        }
+    }
+
+    /**
+     * Set the permissions to use when the session is opened. The permissions here
+     * should only be publish permissions. If any read permissions are included, the login
+     * attempt by the user may fail. The LoginButton can only be associated with either
+     * read permissions or publish permissions, but not both. Calling both
+     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
+     * will result in an exception being thrown unless clearPermissions is called in between.
+     * <p/>
+     * This method is only meaningful if called before the session is open. If this is called
+     * after the session is opened, and the list of permissions passed in is not a subset
+     * of the permissions granted during the authorization, it will log an error.
+     * <p/>
+     * Since the session can be automatically opened when the LoginButton is constructed,
+     * it's important to always pass in a consistent set of permissions to this method, or
+     * manage the setting of permissions outside of the LoginButton class altogether
+     * (by managing the session explicitly).
+     *
+     * @param permissions the read permissions to use
+     *
+     * @throws UnsupportedOperationException if setReadPermissions has been called
+     * @throws IllegalArgumentException if permissions is null or empty
+     */
+    public void setPublishPermissions(List<String> permissions) {
+        if (Session.AuthorizationType.READ.equals(authorizationType)) {
+            throw new UnsupportedOperationException(
+                    "Cannot call setPublishPermissions after setReadPermissions has been called.");
+        }
+        if (validatePermissions(permissions, Session.AuthorizationType.PUBLISH)) {
+            this.permissions = permissions;
+            authorizationType = Session.AuthorizationType.PUBLISH;
+        }
+    }
+
+    private boolean validatePermissions(List<String> permissions, Session.AuthorizationType authType) {
+        if (Session.AuthorizationType.PUBLISH.equals(authType)) {
+            if (Utility.isNullOrEmpty(permissions)) {
+                throw new IllegalArgumentException("Permissions for publish actions cannot be null or empty.");
+            }
+        }
+        Session openSession = sessionTracker.getOpenSession();
+        if (openSession != null) {
+            if (!Utility.isSubset(permissions, openSession.getPermissions())) {
+                Log.e(TAG, "Cannot set additional permissions when session is already open.");
+                return false;
+            }
+        }
+        return true;
+    }
+    /**
+     * Clears the permissions currently associated with this LoginButton.
+     */
+    public void clearPermissions() {
+        permissions = null;
+        authorizationType = null;
+    }
+
+    /**
+     * Set the application ID to be used to open the session.
+     * 
+     * @param applicationId the application ID to use
+     */
+    public void setApplicationId(String applicationId) {
+        this.applicationId = applicationId;
+    }
+
+    /**
+     * Gets the callback interface that will be called when the current user changes.
+     * @return the callback interface
+     */
+    public UserInfoChangedCallback getUserInfoChangedCallback() {
+        return userInfoChangedCallback;
+    }
+
+    /**
+     * Sets the callback interface that will be called when the current user changes.
+     *
+     * @param userInfoChangedCallback   the callback interface
+     */
+    public void setUserInfoChangedCallback(UserInfoChangedCallback userInfoChangedCallback) {
+        this.userInfoChangedCallback = userInfoChangedCallback;
+    }
+
+    /**
+     * Provides an implementation for {@link Activity#onActivityResult
+     * onActivityResult} that updates the Session based on information returned
+     * during the authorization flow. The Activity containing this view
+     * should forward the resulting onActivityResult call here to
+     * update the Session state based on the contents of the resultCode and
+     * data.
+     * 
+     * @param requestCode
+     *            The requestCode parameter from the forwarded call. When this
+     *            onActivityResult occurs as part of facebook authorization
+     *            flow, this value is the activityCode passed to open or
+     *            authorize.
+     * @param resultCode
+     *            An int containing the resultCode parameter from the forwarded
+     *            call.
+     * @param data
+     *            The Intent passed as the data parameter from the forwarded
+     *            call.
+     * @return A boolean indicating whether the requestCode matched a pending
+     *         authorization request for this Session.
+     * @see Session#onActivityResult(Activity, int, int, Intent)
+     */
+    public boolean onActivityResult(int requestCode, int resultCode, Intent data) {
+        Session session = sessionTracker.getSession();
+        if (session != null) {
+            return session.onActivityResult((Activity)getContext(), requestCode,
+                    resultCode, data);
+        } else {
+            return false;
+        }
+    }
+    
+    /**
+     * Set the Session object to use instead of the active Session. Since a Session
+     * cannot be reused, if the user logs out from this Session, and tries to
+     * log in again, a new Active Session will be used instead.
+     * <p/>
+     * If the passed in session is currently opened, this method will also attempt to
+     * load some user information for display (if needed).
+     * 
+     * @param newSession the Session object to use
+     * @throws FacebookException if errors occur during the loading of user information
+     */
+    public void setSession(Session newSession) {
+        sessionTracker.setSession(newSession);
+        fetchUserInfo();
+        setButtonText();
+    }
+
+    @Override
+    public void onFinishInflate() {
+        super.onFinishInflate();
+        finishInit();
+    }
+
+    private void finishInit() {
+        sessionTracker = new SessionTracker(getContext(), new LoginButtonCallback(), null, false);
+        setOnClickListener(new LoginClickListener());
+        setButtonText();
+        fetchUserInfo();
+    }
+
+    /**
+     * Sets the fragment that contains this control. This allows the LoginButton to be
+     * embedded inside a Fragment, and will allow the fragment to receive the
+     * {@link Fragment#onActivityResult(int, int, android.content.Intent) onActivityResult}
+     * call rather than the Activity.
+     *
+     * @param fragment the fragment that contains this control
+     */
+    public void setFragment(Fragment fragment) {
+        parentFragment = fragment;
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        if (!sessionTracker.isTracking()) {
+            sessionTracker.startTracking();
+            fetchUserInfo();
+            setButtonText();
+        }
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        sessionTracker.stopTracking();
+    }
+
+    // For testing purposes only
+    List<String> getPermissions() {
+        return permissions;
+    }
+
+    private void parseAttributes(AttributeSet attrs) {
+        TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.com_facebook_login_view);
+        confirmLogout = a.getBoolean(R.styleable.com_facebook_login_view_confirm_logout, true);
+        fetchUserInfo = a.getBoolean(R.styleable.com_facebook_login_view_fetch_user_info, true);
+        loginText = a.getString(R.styleable.com_facebook_login_view_login_text);
+        logoutText = a.getString(R.styleable.com_facebook_login_view_logout_text);
+        a.recycle();
+
+    }
+   
+    private void setButtonText() {
+        if (sessionTracker.getOpenSession() != null) {
+            setText((logoutText != null) ? logoutText :
+                getResources().getString(R.string.com_facebook_loginview_log_out_button));
+        } else {
+            setText((loginText != null) ? loginText : 
+                getResources().getString(R.string.com_facebook_loginview_log_in_button));
+        }
+    }
+
+    private boolean initializeActiveSessionWithCachedToken(Context context) {
+        if (context == null) {
+            return false;
+        }
+
+        Session session = Session.getActiveSession();
+        if (session != null) {
+            return session.isOpened();
+        }
+
+        String applicationId = Session.getMetadataApplicationId(context);
+        if (applicationId == null) {
+            return false;
+        }
+
+        session = new Session(context);
+        if (session.getState() != SessionState.CREATED_TOKEN_LOADED) {
+            return false;
+        }
+
+        Session.setActiveSession(session);
+        session.open();
+        return true;
+    }
+
+    private void fetchUserInfo() {
+        if (fetchUserInfo) {
+            final Session currentSession = sessionTracker.getOpenSession();
+            if (currentSession != null) {
+                if (currentSession != userInfoSession) {
+                    Request request = Request.newMeRequest(currentSession, new Request.GraphUserCallback() {
+                        @Override
+                        public void onCompleted(GraphUser me,  Response response) {
+                            if (currentSession == sessionTracker.getOpenSession()) {
+                                user = me;
+                                if (userInfoChangedCallback != null) {
+                                    userInfoChangedCallback.onUserInfoFetched(user);
+                                }
+                            }
+                            if (response.getError() != null) {
+                                handleError(response.getError());
+                            }
+                        }
+                    });
+                    Request.executeBatchAsync(request);
+                    userInfoSession = currentSession;
+                }
+            } else {
+                user = null;
+                if (userInfoChangedCallback != null) {
+                    userInfoChangedCallback.onUserInfoFetched(user);
+                }
+            }
+        }
+    }
+
+    private class LoginClickListener implements OnClickListener {
+
+        @Override
+        public void onClick(View v) {
+            Context context = getContext();
+            final Session openSession = sessionTracker.getOpenSession();
+            if (openSession != null) {
+                // If the Session is currently open, it must mean we need to log out
+                if (confirmLogout) {
+                    // Create a confirmation dialog
+                    String logout = getResources().getString(R.string.com_facebook_loginview_log_out_action);
+                    String cancel = getResources().getString(R.string.com_facebook_loginview_cancel_action);
+                    String message;
+                    if (user != null && user.getName() != null) {
+                        message = String.format(getResources().getString(R.string.com_facebook_loginview_logged_in_as), user.getName());
+                    } else {
+                        message = getResources().getString(R.string.com_facebook_loginview_logged_in_using_facebook);
+                    }
+                    AlertDialog.Builder builder = new AlertDialog.Builder(context);
+                    builder.setMessage(message)
+                           .setCancelable(true)
+                           .setPositiveButton(logout, new DialogInterface.OnClickListener() {
+                               public void onClick(DialogInterface dialog, int which) {
+                                   openSession.closeAndClearTokenInformation();
+                               }
+                           })
+                           .setNegativeButton(cancel, null);
+                    builder.create().show();
+                } else {
+                    openSession.closeAndClearTokenInformation();
+                }
+            } else {
+                Session currentSession = sessionTracker.getSession();
+                if (currentSession == null || currentSession.getState().isClosed()) {
+                    sessionTracker.setSession(null);
+                    Session session = new Session.Builder(context).setApplicationId(applicationId).build();
+                    Session.setActiveSession(session);
+                    currentSession = session;
+                }
+                if (!currentSession.isOpened()) {
+                    Session.OpenRequest openRequest = null;
+                    if (parentFragment != null) {
+                        openRequest = new Session.OpenRequest(parentFragment);
+                    } else if (context instanceof Activity) {
+                        openRequest = new Session.OpenRequest((Activity)context);
+                    }
+
+                    if (openRequest != null) {
+                        openRequest.setPermissions(permissions);
+
+                        if (Session.AuthorizationType.PUBLISH.equals(authorizationType)) {
+                            currentSession.openForPublish(openRequest);
+                        } else {
+                            currentSession.openForRead(openRequest);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private class LoginButtonCallback implements Session.StatusCallback {
+        @Override
+        public void call(Session session, SessionState state,
+                         Exception exception) {
+            fetchUserInfo();
+            setButtonText();
+            if (exception != null) {
+                handleError(exception);
+            }
+        }
+    };
+
+    void handleError(Exception exception) {
+        if (onErrorListener != null) {
+            if (exception instanceof FacebookException) {
+                onErrorListener.onError((FacebookException)exception);
+            } else {
+                onErrorListener.onError(new FacebookException(exception));
+            }
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/LoginFragment.java b/facebook/src/com/facebook/LoginFragment.java
new file mode 100644
index 000000000..5342a458b
--- /dev/null
+++ b/facebook/src/com/facebook/LoginFragment.java
@@ -0,0 +1,323 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.facebook;
+
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.text.TextUtils;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.TextView;
+import com.facebook.android.R;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.List;
+import java.util.concurrent.RejectedExecutionException;
+
+/**
+ * A Fragment that displays a Login/Logout button as well as the user's
+ * profile picture and name when logged in.
+ * <p/>
+ * This Fragment will create and use the active session upon construction
+ * if it has the available data (if the app ID is specified in the manifest).
+ * It will also open the active session if it does not require user interaction
+ * (i.e. if the session is in the {@link SessionState#CREATED_TOKEN_LOADED} state.
+ * Developers can override the use of the active session by calling
+ * the {@link #setSession(Session)} method.
+ */
+public class LoginFragment extends FacebookFragment {
+
+    private static final String NAME = "name";
+    private static final String ID = "id";
+    private static final String PICTURE = "picture";
+    private static final String FIELDS = "fields";
+    
+    private static final String PICTURE_URL = "https://graph.facebook.com/%s/picture?width=%d&height=%d";
+    
+    private static final String REQUEST_FIELDS = TextUtils.join(",", new String[] {ID, NAME, PICTURE});
+
+    private LoginButton loginButton;
+    private TextView connectedStateLabel;
+    private GraphUser user;
+    private Session userInfoSession; // the Session used to fetch the current user info
+    private Drawable userProfilePic;
+    private String userProfilePicID;
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        View view = inflater.inflate(R.layout.com_facebook_loginfragment, container, false);
+        loginButton = (LoginButton) view.findViewById(R.id.com_facebook_loginfragment_login_button);
+        loginButton.setFragment(this);
+        connectedStateLabel = (TextView) view.findViewById(R.id.com_facebook_loginfragment_profile_name);
+        
+        // if no background is set for some reason, then default to Facebook blue
+        if (view.getBackground() == null) {
+            view.setBackgroundColor(getResources().getColor(R.color.com_facebook_blue));
+        } else {
+            view.getBackground().setDither(true);
+        }
+        return view;
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setRetainInstance(true);
+    }
+
+    /**
+     * @throws FacebookException if errors occur during the loading of user information
+     */
+    @Override
+    public void onResume() {
+        super.onResume();
+        fetchUserInfo();
+        updateUI();
+    }
+
+    /**
+     * Set the Session object to use instead of the active Session. Since a Session
+     * cannot be reused, if the user logs out from this Session, and tries to
+     * log in again, a new Active Session will be used instead.
+     * <p/>
+     * If the passed in session is currently opened, this method will also attempt to
+     * load some user information for display (if needed).
+     *
+     * @param newSession the Session object to use
+     * @throws FacebookException if errors occur during the loading of user information
+     */
+    @Override
+    public void setSession(Session newSession) {
+        super.setSession(newSession);
+        loginButton.setSession(newSession);
+        fetchUserInfo();
+        updateUI();
+    }
+
+    /**
+     * Set the permissions to use when the session is opened. The permissions here
+     * can only be read permissions. If any publish permissions are included, the login
+     * attempt by the user will fail. The LoginButton can only be associated with either
+     * read permissions or publish permissions, but not both. Calling both
+     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
+     * will result in an exception being thrown unless clearPermissions is called in between.
+     * <p/>
+     * This method is only meaningful if called before the session is open. If this is called
+     * after the session is opened, and the list of permissions passed in is not a subset
+     * of the permissions granted during the authorization, it will log an error.
+     * <p/>
+     * Since the session can be automatically opened when the LoginFragment is constructed,
+     * it's important to always pass in a consistent set of permissions to this method, or
+     * manage the setting of permissions outside of the LoginButton class altogether
+     * (by managing the session explicitly).
+     *
+     * @param permissions the read permissions to use
+     *
+     * @throws UnsupportedOperationException if setPublishPermissions has been called
+     */
+    public void setReadPermissions(List<String> permissions) {
+        loginButton.setReadPermissions(permissions);
+    }
+
+    /**
+     * Set the permissions to use when the session is opened. The permissions here
+     * should only be publish permissions. If any read permissions are included, the login
+     * attempt by the user may fail. The LoginButton can only be associated with either
+     * read permissions or publish permissions, but not both. Calling both
+     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
+     * will result in an exception being thrown unless clearPermissions is called in between.
+     * <p/>
+     * This method is only meaningful if called before the session is open. If this is called
+     * after the session is opened, and the list of permissions passed in is not a subset
+     * of the permissions granted during the authorization, it will log an error.
+     * <p/>
+     * Since the session can be automatically opened when the LoginButton is constructed,
+     * it's important to always pass in a consistent set of permissions to this method, or
+     * manage the setting of permissions outside of the LoginButton class altogether
+     * (by managing the session explicitly).
+     *
+     * @param permissions the read permissions to use
+     *
+     * @throws UnsupportedOperationException if setReadPermissions has been called
+     * @throws IllegalArgumentException if permissions is null or empty
+     */
+    public void setPublishPermissions(List<String> permissions) {
+        loginButton.setPublishPermissions(permissions);
+    }
+
+    /**
+     * Clears the permissions currently associated with this LoginButton.
+     */
+    public void clearPermissions() {
+        loginButton.clearPermissions();
+    }
+
+    /**
+     * Sets an OnErrorListener for this instance of LoginFragment to call into when
+     * certain exceptions occur.
+     *
+     * @param onErrorListener The listener object to set
+     */
+    public void setOnErrorListener(LoginButton.OnErrorListener onErrorListener) {
+        loginButton.setOnErrorListener(onErrorListener);
+    }
+
+    /**
+     * Returns the current OnErrorListener for this instance of LoginFragment.
+     *
+     * @return The OnErrorListener
+     */
+    public LoginButton.OnErrorListener getOnErrorListener() {
+        return loginButton.getOnErrorListener();
+    }
+
+    @Override
+    protected void onSessionStateChange(SessionState state, Exception exception) {
+        fetchUserInfo();
+        updateUI();
+    }
+    
+    private void fetchUserInfo() {
+        final Session currentSession = getSession();
+        if (currentSession != null && currentSession.isOpened()) {
+            if (currentSession != userInfoSession) {
+                Request request = Request.newMeRequest(currentSession, new Request.GraphUserCallback() {
+                    @Override
+                    public void onCompleted(GraphUser me, Response response) {
+                        if (currentSession == getSession()) {
+                            user = me;
+                            updateUI();
+                        }
+                        if (response.getError() != null) {
+                            loginButton.handleError(response.getError());
+                        }
+                    }
+                });
+                Bundle parameters = new Bundle();
+                parameters.putString(FIELDS, REQUEST_FIELDS);
+                request.setParameters(parameters);
+                Request.executeBatchAsync(request);
+                userInfoSession = currentSession;
+            }
+        } else {
+            user = null;
+        }
+    }
+    
+    private void updateUI() {
+        if (!isAdded()) {
+            return;
+        }
+        if (isSessionOpen()) {
+            connectedStateLabel.setTextColor(getResources().getColor(R.color.com_facebook_loginfragment_connected_text_color));
+            connectedStateLabel.setShadowLayer(1f, 0f, -1f,
+                    getResources().getColor(R.color.com_facebook_loginfragment_connected_shadow_color));
+            
+            if (user != null) {
+                URL pictureURL = getPictureUrlOfUser();
+                // Do we already have the right picture? If so, leave it alone.
+                if (pictureURL != null && !pictureURL.equals(connectedStateLabel.getTag())) {
+                    if (user.getId().equals(userProfilePicID)) {
+                        connectedStateLabel.setCompoundDrawables(null, userProfilePic, null, null);
+                        connectedStateLabel.setTag(pictureURL);
+                    } else {
+                        try {
+                            ProfilePictureDownloadTask task = new ProfilePictureDownloadTask(user.getId());
+                            task.execute(pictureURL);
+                        } catch (RejectedExecutionException exception) {
+                        }
+                    }
+                }
+                connectedStateLabel.setText(user.getName());
+            } else {
+                connectedStateLabel.setText(getResources().getString(R.string.com_facebook_loginfragment_logged_in));
+                Drawable noProfilePic = getResources().getDrawable(R.drawable.com_facebook_profile_default_icon);
+                noProfilePic.setBounds(0, 0, 
+                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginfragment_profile_picture_width),
+                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginfragment_profile_picture_height));
+                connectedStateLabel.setCompoundDrawables(null, noProfilePic, null, null);
+            }
+        } else {
+            int textColor = getResources().getColor(R.color.com_facebook_loginfragment_not_connected_text_color);
+            connectedStateLabel.setTextColor(textColor);
+            connectedStateLabel.setShadowLayer(0f, 0f, 0f, textColor);
+            connectedStateLabel.setText(getResources().getString(R.string.com_facebook_loginfragment_not_logged_in));
+            connectedStateLabel.setCompoundDrawables(null, null, null, null);
+            connectedStateLabel.setTag(null);
+        }
+    }
+
+    private URL getPictureUrlOfUser() {
+        try {
+            return new URL(String.format(PICTURE_URL, user.getId(), 
+                    getResources().getDimensionPixelSize(R.dimen.com_facebook_loginfragment_profile_picture_width),
+                    getResources().getDimensionPixelSize(R.dimen.com_facebook_loginfragment_profile_picture_height)));
+        } catch (MalformedURLException e) {
+        }
+        return null;
+    }
+
+    private class ProfilePictureDownloadTask extends AsyncTask<URL, Void, Bitmap> {
+        private URL tag;
+        private String id;
+
+        public ProfilePictureDownloadTask(String id) {
+            this.id = id;
+        }
+        
+        @Override
+        protected Bitmap doInBackground(URL... params) {
+            URLConnection connection = null;
+            InputStream stream = null;
+            try {
+                tag = params[0];
+                connection = tag.openConnection();
+                stream = connection.getInputStream();
+                Bitmap bitmap = BitmapFactory.decodeStream(stream);
+                return bitmap;
+            } catch (IOException e) {
+            } finally {
+                Utility.closeQuietly(stream);
+                Utility.disconnectQuietly(connection);
+            }
+            return null;
+        }
+
+        @Override
+        protected void onPostExecute(Bitmap bitmap) {
+            super.onPostExecute(bitmap);
+            if (LoginFragment.this.isVisible()) {
+                BitmapDrawable drawable = new BitmapDrawable(LoginFragment.this.getResources(), bitmap);
+                drawable.setBounds(0, 0,
+                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginfragment_profile_picture_width),
+                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginfragment_profile_picture_height));
+                userProfilePic = drawable;
+                userProfilePicID = id;
+                connectedStateLabel.setCompoundDrawables(null, drawable, null, null);
+                connectedStateLabel.setTag(tag);
+            }
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/NativeProtocol.java b/facebook/src/com/facebook/NativeProtocol.java
new file mode 100644
index 000000000..ab6627f5a
--- /dev/null
+++ b/facebook/src/com/facebook/NativeProtocol.java
@@ -0,0 +1,44 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+final class NativeProtocol {
+    static final String KATANA_PACKAGE = "com.facebook.katana";
+    static final String KATANA_PROXY_AUTH_ACTIVITY = "com.facebook.katana.ProxyAuth";
+    static final String KATANA_TOKEN_REFRESH_ACTIVITY = "com.facebook.katana.platform.TokenRefreshService";
+    static final String KATANA_SIGNATURE =
+            "30820268308201d102044a9c4610300d06092a864886f70d0101040500307a310"
+                    + "b3009060355040613025553310b30090603550408130243413112301006035504"
+                    + "07130950616c6f20416c746f31183016060355040a130f46616365626f6f6b204"
+                    + "d6f62696c653111300f060355040b130846616365626f6f6b311d301b06035504"
+                    + "03131446616365626f6f6b20436f72706f726174696f6e3020170d30393038333"
+                    + "13231353231365a180f32303530303932353231353231365a307a310b30090603"
+                    + "55040613025553310b30090603550408130243413112301006035504071309506"
+                    + "16c6f20416c746f31183016060355040a130f46616365626f6f6b204d6f62696c"
+                    + "653111300f060355040b130846616365626f6f6b311d301b06035504031314466"
+                    + "16365626f6f6b20436f72706f726174696f6e30819f300d06092a864886f70d01"
+                    + "0101050003818d0030818902818100c207d51df8eb8c97d93ba0c8c1002c928fa"
+                    + "b00dc1b42fca5e66e99cc3023ed2d214d822bc59e8e35ddcf5f44c7ae8ade50d7"
+                    + "e0c434f500e6c131f4a2834f987fc46406115de2018ebbb0d5a3c261bd97581cc"
+                    + "fef76afc7135a6d59e8855ecd7eacc8f8737e794c60a761c536b72b11fac8e603"
+                    + "f5da1a2d54aa103b8a13c0dbc10203010001300d06092a864886f70d010104050"
+                    + "0038181005ee9be8bcbb250648d3b741290a82a1c9dc2e76a0af2f2228f1d9f9c"
+                    + "4007529c446a70175c5a900d5141812866db46be6559e2141616483998211f4a6"
+                    + "73149fb2232a10d247663b26a9031e15f84bc1c74d141ff98a02d76f85b2c8ab2"
+                    + "571b6469b232d8e768a7f7ca04f7abe4a775615916c07940656b58717457b42bd"
+                    + "928a2";
+}
diff --git a/facebook/src/com/facebook/OpenGraphAction.java b/facebook/src/com/facebook/OpenGraphAction.java
new file mode 100644
index 000000000..4a55bd66c
--- /dev/null
+++ b/facebook/src/com/facebook/OpenGraphAction.java
@@ -0,0 +1,213 @@
+/**
+ * Copyright 2010 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import org.json.JSONObject;
+
+import java.util.Date;
+import java.util.List;
+
+/**
+ * Provides a strongly-typed representation of an Open Graph Action.
+ * For more documentation of OG Actions, see: https://developers.facebook.com/docs/opengraph/actions/
+ *
+ * Note that this interface is intended to be used with GraphObjectWrapper
+ * and not implemented directly.
+ */
+public interface OpenGraphAction extends GraphObject {
+    /**
+     * Gets the ID of the action.
+     * @return the ID
+     */
+    public String getId();
+
+    /**
+     * Sets the ID of the action.
+     * @param id the ID
+     */
+    public void setId(String id);
+
+    /**
+     * Gets the start time of the action.
+     * @return the start time
+     */
+    public Date getStartTime();
+
+    /**
+     * Sets the start time of the action.
+     * @param startTime the start time
+     */
+    public void setStartTime(Date startTime);
+
+    /**
+     * Gets the end time of the action.
+     * @return the end time
+     */
+    public Date getEndTime();
+
+    /**
+     * Sets the end time of the action.
+     * @param endTime the end time
+     */
+    public void setEndTime(Date endTime);
+
+    /**
+     * Gets the time the action was published, if any.
+     * @return the publish time
+     */
+    public Date getPublishTime();
+
+    /**
+     * Sets the time the action was published.
+     * @param publishTime the publish time
+     */
+    public void setPublishTime(Date publishTime);
+
+    /**
+     * Gets the time the action was created.
+     * @return the creation time
+     */
+    public Date getCreatedTime();
+
+    /**
+     * Sets the time the action was created.
+     * @param createdTime the creation time
+     */
+    public void setCreatedTime(Date createdTime);
+
+    /**
+     * Gets the time the action expires at.
+     * @return the expiration time
+     */
+    public Date getExpiresTime();
+
+    /**
+     * Sets the time the action expires at.
+     * @param expiresTime the expiration time
+     */
+    public void setExpiresTime(Date expiresTime);
+
+    /**
+     * Gets the unique string which will be passed to the OG Action owner's website
+     * when a user clicks through this action on Facebook.
+     * @return the ref string
+     */
+    public String getRef();
+
+    /**
+     * Sets the unique string which will be passed to the OG Action owner's website
+     * when a user clicks through this action on Facebook.
+     * @param ref the ref string
+     */
+    public void setRef(String ref);
+
+    /**
+     * Gets the message assoicated with the action.
+     * @return the message
+     */
+    public String getMessage();
+
+    /**
+     * Sets the message associated with the action.
+     * @param message the message
+     */
+    public void setMessage(String message);
+
+    /**
+     * Gets the place where the action took place.
+     * @return the place
+     */
+    public GraphPlace getPlace();
+
+    /**
+     * Sets the place where the action took place.
+     * @param place the place
+     */
+    public void setPlace(GraphPlace place);
+
+    /**
+     * Gets the list of profiles that were tagged in the action.
+     * @return the profiles that were tagged in the action
+     */
+    public List<GraphObject> getTags();
+
+    /**
+     * Sets the list of profiles that were tagged in the action.
+     * @param tags the profiles that were tagged in the action
+     */
+    public void setTags(List<? extends GraphObject> tags);
+
+    /**
+     * Gets the images that were associated with the action.
+     * @return the images
+     */
+    public List<JSONObject> getImage();
+
+    /**
+     * Sets the images that were associated with the action.
+     * @param image the images
+     */
+    public void setImage(List<JSONObject> image);
+
+    /**
+     * Gets the from-user associated with the action.
+     * @return the user
+     */
+    public GraphUser getFrom();
+
+    /**
+     * Sets the from-user associated with the action.
+     * @param from the from-user
+     */
+    public void setFrom(GraphUser from);
+
+    /**
+     * Gets the 'likes' that have been performed on this action.
+     * @return the likes
+     */
+    public JSONObject getLikes();
+
+    /**
+     * Sets the 'likes' that have been performed on this action.
+     * @param likes the likes
+     */
+    public void setLikes(JSONObject likes);
+
+    /**
+     * Gets the application that created this action.
+     * @return the application
+     */
+    public GraphObject getApplication();
+
+    /**
+     * Sets the application that created this action.
+     * @param application the application
+     */
+    public void setApplication(GraphObject application);
+
+    /**
+     * Gets the comments that have been made on this action.
+     * @return the comments
+     */
+    public JSONObject getComments();
+
+    /**
+     * Sets the comments that have been made on this action.
+     * @param comments the comments
+     */
+    public void setComments(JSONObject comments);
+}
diff --git a/facebook/src/com/facebook/PickerFragment.java b/facebook/src/com/facebook/PickerFragment.java
new file mode 100644
index 000000000..9eb911c70
--- /dev/null
+++ b/facebook/src/com/facebook/PickerFragment.java
@@ -0,0 +1,244 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.os.Bundle;
+
+import java.util.Collection;
+import java.util.Set;
+
+/**
+ * Provides functionality common to SDK UI elements that allow the user to pick one or more
+ * graph objects (e.g., places, friends) from a list of possibilities. The UI is exposed as a
+ * Fragment to allow to it to be included in an Activity along with other Fragments. The Fragments
+ * can be configured by passing parameters as part of their Intent bundle, or (for certain
+ * properties) by specifying attributes in their XML layout files.
+ * <br/>
+ * PickerFragments support callbacks that will be called in the event of an error, when the
+ * underlying data has been changed, or when the set of selected graph objects changes.
+ */
+public interface PickerFragment<T extends GraphObject> {
+    /**
+     * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
+     * picker should show pictures (if available) for the graph objects.
+     */
+    static final String SHOW_PICTURES_BUNDLE_KEY = "com.facebook.PickerFragment.ShowPictures";
+    /**
+     * The key for a String parameter in the fragment's Intent bundle to indicate which extra fields
+     * beyond the default fields should be retrieved for any graph objects in the results.
+     */
+    static final String EXTRA_FIELDS_BUNDLE_KEY = "com.facebook.PickerFragment.ExtraFields";
+    /**
+     * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
+     * picker should display a title bar with a Done button.
+     */
+    static final String SHOW_TITLE_BAR_BUNDLE_KEY = "com.facebook.PickerFragment.ShowTitleBar";
+    /**
+     * The key for a String parameter in the fragment's Intent bundle to indicate the text to
+     * display in the title bar.
+     */
+    static final String TITLE_TEXT_BUNDLE_KEY = "com.facebook.PickerFragment.TitleText";
+    /**
+     * The key for a String parameter in the fragment's Intent bundle to indicate the text to
+     * display in the Done btuton.
+     */
+    static final String DONE_BUTTON_TEXT_BUNDLE_KEY = "com.facebook.PickerFragment.DoneButtonText";
+
+    /**
+     * Gets the current OnDataChangedListener for this fragment, which will be called whenever
+     * the underlying data being displaying in the picker has changed.
+     * @return the OnDataChangedListener, or null if there is none
+     */
+    OnDataChangedListener getOnDataChangedListener();
+
+    /**
+     * Sets the current OnDataChangedListener for this fragment, which will be called whenever
+     * the underlying data being displaying in the picker has changed.
+     * @param onDataChangedListener     the OnDataChangedListener, or null if there is none
+     */
+    void setOnDataChangedListener(OnDataChangedListener onDataChangedListener);
+
+    /**
+     * Gets the current OnSelectionChangedListener for this fragment, which will be called
+     * whenever the user selects or unselects a graph object in the list.
+     * @return the OnSelectionChangedListener, or null if there is none
+     */
+    OnSelectionChangedListener getOnSelectionChangedListener();
+
+    /**
+     * Sets the current OnSelectionChangedListener for this fragment, which will be called
+     * whenever the user selects or unselects a graph object in the list.
+     * @param onSelectionChangedListener     the OnSelectionChangedListener, or null if there is none
+     */
+    void setOnSelectionChangedListener(
+            OnSelectionChangedListener onSelectionChangedListener);
+
+    /**
+     * Gets the current OnDoneButtonClickedListener for this fragment, which will be called
+     * when the user clicks the Done button.
+     * @return the OnDoneButtonClickedListener, or null if there is none
+     */
+    OnDoneButtonClickedListener getOnDoneButtonClickedListener();
+
+    /**
+     * Sets the current OnDoneButtonClickedListener for this fragment, which will be called
+     * when the user clicks the Done button. This will only be possible if the title bar is
+     * being shown in this fragment.
+     * @param onDoneButtonClickedListener     the OnDoneButtonClickedListener, or null if there is none
+     */
+    void setOnDoneButtonClickedListener(OnDoneButtonClickedListener onDoneButtonClickedListener);
+
+    /**
+     * Gets the current OnErrorListener for this fragment, which will be called in the event
+     * of network or other errors encountered while populating the graph objects in the list.
+     * @return the OnErrorListener, or null if there is none
+     */
+    OnErrorListener getOnErrorListener();
+
+    /**
+     * Sets the current OnErrorListener for this fragment, which will be called in the event
+     * of network or other errors encountered while populating the graph objects in the list.
+     * @param onErrorListener    the OnErrorListener, or null if there is none
+     */
+    void setOnErrorListener(OnErrorListener onErrorListener);
+
+    /**
+     * Gets the current filter for this fragment, which will be called for each graph object
+     * returned from the service to determine if it should be displayed in the list.
+     * If no filter is specified, all retrieved graph objects will be displayed.
+     * @return the GraphObjectFilter, or null if there is none
+     */
+    GraphObjectFilter<T> getFilter();
+
+    /**
+     * Sets the current filter for this fragment, which will be called for each graph object
+     * returned from the service to determine if it should be displayed in the list.
+     * If no filter is specified, all retrieved graph objects will be displayed.
+     * @param filter     the GraphObjectFilter, or null if there is none
+     */
+    void setFilter(GraphObjectFilter<T> filter);
+
+    /**
+     * Gets the Session to use for any Facebook requests this fragment will make.
+     * @return the Session that will be used for any Facebook requests, or null if there is none
+     */
+    Session getSession();
+
+    /**
+     * Sets the Session to use for any Facebook requests this fragment will make. If the
+     * parameter is null, the fragment will use the current active session, if any.
+     * @param session   the Session to use for Facebook requests, or null to use the active session
+     */
+    void setSession(Session session);
+
+    /**
+     * Gets whether to display pictures, if available, for displayed graph objects.
+     * @return true if pictures should be displayed, false if not
+     */
+    boolean getShowPictures();
+
+    /**
+     * Gets whether to display pictures, if available, for displayed graph objects.
+     * @param showPictures   true if pictures should be displayed, false if not
+     */
+    void setShowPictures(boolean showPictures);
+
+    /**
+     * Gets the extra fields to request for the retrieved graph objects.
+     * @return the extra fields to request
+     */
+    Set<String> getExtraFields();
+
+    /**
+     * Sets the extra fields to request for the retrieved graph objects.
+     * @param fields     the extra fields to request
+     */
+    void setExtraFields(Collection<String> fields);
+
+    /**
+     * Causes the picker to load data from the service and display it to the user.
+     * @param forceReload if true, data will be loaded even if there is already data being displayed;
+     *                    if false, data will not be re-loaded if it is already displayed
+     */
+    void loadData(boolean forceReload);
+
+    /**
+     * Updates the properties of the PickerFragment based on the contents of the supplied Bundle;
+     * calling Activities may use this to pass additional configuration information to the
+     * PickerFragment beyond what is specified in its XML layout.
+     * @param inState   a Bundle containing keys corresponding to properties of the PickerFragment
+     */
+    void setSettingsFromBundle(Bundle inState);
+
+    /**
+     * Callback interface that will be called when a network or other error is encountered
+     * while retrieving graph objects.
+     */
+    interface OnErrorListener {
+        /**
+         * Called when a network or other error is encountered.
+         * @param error     a FacebookException representing the error that was encountered.
+         */
+        void onError(FacebookException error);
+    }
+
+    /**
+     * Callback interface that will be called when the underlying data being displayed in the
+     * picker has been updated.
+     */
+    interface OnDataChangedListener {
+        /**
+         * Called when the set of data being displayed in the picker has changed.
+         */
+        void onDataChanged();
+    }
+
+    /**
+     * Callback interface that will be called when the user selects or unselects graph objects
+     * in the picker.
+     */
+    interface OnSelectionChangedListener {
+        /**
+         * Called when the user selects or unselects graph objects in the picker.
+         */
+        void onSelectionChanged();
+    }
+
+    /**
+     * Callback interface that will be called when the user clicks the Done button on the
+     * title bar.
+     */
+    interface OnDoneButtonClickedListener {
+        /**
+         * Called when the user clicks the Done button.
+         */
+        void onDoneButtonClicked();
+    }
+
+    /**
+     * Callback interface that will be called to determine if a graph object should be displayed.
+     * @param <T>
+     */
+    interface GraphObjectFilter<T> {
+        /**
+         * Called to determine if a graph object should be displayed.
+         * @param graphObject       the graph object
+         * @return true to display the graph object, false to hide it
+         */
+        boolean includeItem(T graphObject);
+    }
+}
diff --git a/facebook/src/com/facebook/PlacePickerFragment.java b/facebook/src/com/facebook/PlacePickerFragment.java
new file mode 100644
index 000000000..331dc4821
--- /dev/null
+++ b/facebook/src/com/facebook/PlacePickerFragment.java
@@ -0,0 +1,488 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.app.Activity;
+import android.content.res.TypedArray;
+import android.location.Location;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.text.Editable;
+import android.text.TextUtils;
+import android.text.TextWatcher;
+import android.util.AttributeSet;
+import android.view.ViewGroup;
+import android.view.ViewStub;
+import android.widget.EditText;
+import android.widget.ListView;
+import android.widget.RelativeLayout;
+import com.facebook.android.R;
+
+import java.util.*;
+
+public class PlacePickerFragment extends GraphObjectListFragment<GraphPlace> {
+    /**
+     * The key for an int parameter in the fragment's Intent bundle to indicate the radius in meters around
+     * the center point to search. The default is 1000 meters.
+     */
+    public static final String RADIUS_IN_METERS_BUNDLE_KEY = "com.facebook.PlacePickerFragment.RadiusInMeters";
+    /**
+     * The key for an int parameter in the fragment's Intent bundle to indicate what how many results to
+     * return at a time. The default is 100 results.
+     */
+    public static final String RESULTS_LIMIT_BUNDLE_KEY = "com.facebook.PlacePickerFragment.ResultsLimit";
+    /**
+     * The key for a String parameter in the fragment's Intent bundle to indicate what search text should
+     * be sent to the service. The default is to have no search text.
+     */
+    public static final String SEARCH_TEXT_BUNDLE_KEY = "com.facebook.PlacePickerFragment.SearchText";
+    /**
+     * The key for a Location parameter in the fragment's Intent bundle to indicate what geographical
+     * location should be the center of the search.
+     */
+    public static final String LOCATION_BUNDLE_KEY = "com.facebook.PlacePickerFragment.Location";
+    /**
+     * The key for a boolean parameter in the fragment's Intent bundle to indicate that the fragment
+     * should display a search box and automatically update the search text as it changes.
+     */
+    public static final String SHOW_SEARCH_BOX_BUNDLE_KEY = "com.facebook.PlacePickerFragment.ShowSearchBox";
+
+    /**
+     * The default radius around the center point to search.
+     */
+    public static final int DEFAULT_RADIUS_IN_METERS = 1000;
+    /**
+     * The default number of results to retrieve.
+     */
+    public static final int DEFAULT_RESULTS_LIMIT = 100;
+
+    private static final int searchTextTimerDelayInMilliseconds = 2 * 1000;
+
+    private static final String ID = "id";
+    private static final String NAME = "name";
+    private static final String LOCATION = "location";
+    private static final String CATEGORY = "category";
+    private static final String WERE_HERE_COUNT = "were_here_count";
+    private static final String TAG = "PlacePickerFragment";
+
+    private Location location;
+    private int radiusInMeters = DEFAULT_RADIUS_IN_METERS;
+    private int resultsLimit = DEFAULT_RESULTS_LIMIT;
+    private String searchText;
+    private Timer searchTextTimer;
+    private boolean hasSearchTextChangedSinceLastQuery;
+    private boolean showSearchBox = true;
+    private EditText searchBox;
+
+    /**
+     * Default constructor. Creates a Fragment with all default properties.
+     */
+    public PlacePickerFragment() {
+        this(null);
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param args a Bundle that optionally contains one or more values containing additional
+     *             configuration information for the Fragment.
+     */
+    public PlacePickerFragment(Bundle args) {
+        super(GraphPlace.class, R.layout.com_facebook_placepickerfragment, args);
+        setPlacePickerSettingsFromBundle(args);
+    }
+
+    /**
+     * Gets the location to search around. Either the location or the search text (or both) must be specified.
+     *
+     * @return the Location to search around
+     */
+    public Location getLocation() {
+        return location;
+    }
+
+    /**
+     * Sets the location to search around. Either the location or the search text (or both) must be specified.
+     *
+     * @param location the Location to search around
+     */
+    public void setLocation(Location location) {
+        this.location = location;
+    }
+
+    /**
+     * Gets the radius in meters around the location to search.
+     *
+     * @return the radius in meters
+     */
+    public int getRadiusInMeters() {
+        return radiusInMeters;
+    }
+
+    /**
+     * Sets the radius in meters around the location to search.
+     *
+     * @param radiusInMeters the radius in meters
+     */
+    public void setRadiusInMeters(int radiusInMeters) {
+        this.radiusInMeters = radiusInMeters;
+    }
+
+    /**
+     * Gets the number of results to retrieve.
+     *
+     * @return the number of results to retrieve
+     */
+    public int getResultsLimit() {
+        return resultsLimit;
+    }
+
+    /**
+     * Sets the number of results to retrieve.
+     *
+     * @param resultsLimit the number of results to retrieve
+     */
+    public void setResultsLimit(int resultsLimit) {
+        this.resultsLimit = resultsLimit;
+    }
+
+    /**
+     * Gets the search text (e.g., category, name) to search for. Either the location or the search
+     * text (or both) must be specified.
+     *
+     * @return the search text
+     */
+    public String getSearchText() {
+        return searchText;
+    }
+
+    /**
+     * Sets the search text (e.g., category, name) to search for. Either the location or the search
+     * text (or both) must be specified.
+     *
+     * @param searchText the search text
+     */
+    public void setSearchText(String searchText) {
+        if (TextUtils.isEmpty(searchText)) {
+            searchText = null;
+        }
+        this.searchText = searchText;
+    }
+
+    /**
+     * Sets the search text and reloads the data in the control. This is used to provide search-box
+     * functionality where the user may be typing or editing text rapidly. It uses a timer to avoid repeated
+     * requerying, preferring to wait until the user pauses typing to refresh the data.
+     *
+     * @param searchText                 the search text
+     * @param forceReloadEventIfSameText if true, will reload even if the search text has not changed; if false,
+     *                                   identical search text will not force a reload
+     */
+    public void setSearchTextAndReload(String searchText, boolean forceReloadEventIfSameText) {
+        if (!forceReloadEventIfSameText && Utility.stringsEqualOrEmpty(this.searchText, searchText)) {
+            return;
+        }
+
+        setSearchText(searchText);
+
+        // If search text is being set in response to user input, it is wasteful to send a new request
+        // with every keystroke. Send a request the first time the search text is set, then set up a 2-second timer
+        // and send whatever changes the user has made since then. (If nothing has changed
+        // in 2 seconds, we reset so the next change will cause an immediate re-query.)
+        hasSearchTextChangedSinceLastQuery = true;
+        if (searchTextTimer == null) {
+            searchTextTimer = createSearchTextTimer();
+        }
+    }
+
+    /**
+     * Gets the currently-selected place.
+     *
+     * @return the currently-selected place, or null if there is none
+     */
+    public GraphPlace getSelection() {
+        Collection<GraphPlace> selection = getSelectedGraphObjects();
+        return (selection != null && selection.size() > 0) ? selection.iterator().next() : null;
+    }
+
+    public void setSettingsFromBundle(Bundle inState) {
+        super.setSettingsFromBundle(inState);
+        setPlacePickerSettingsFromBundle(inState);
+    }
+
+    @Override
+    public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
+        super.onInflate(activity, attrs, savedInstanceState);
+        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.com_facebook_place_picker_fragment);
+
+        setRadiusInMeters(a.getInt(R.styleable.com_facebook_place_picker_fragment_radius_in_meters, radiusInMeters));
+        setResultsLimit(a.getInt(R.styleable.com_facebook_place_picker_fragment_results_limit, resultsLimit));
+        if (a.hasValue(R.styleable.com_facebook_place_picker_fragment_results_limit)) {
+            setSearchText(a.getString(R.styleable.com_facebook_place_picker_fragment_search_text));
+        }
+        showSearchBox = a.getBoolean(R.styleable.com_facebook_place_picker_fragment_show_search_box, showSearchBox);
+
+        a.recycle();
+    }
+
+    @Override
+    public void onActivityCreated(final Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+
+        ViewGroup view = (ViewGroup) getView();
+        if (showSearchBox) {
+            ViewStub stub = (ViewStub) view.findViewById(R.id.com_facebook_placepickerfragment_search_box_stub);
+            if (stub != null) {
+                searchBox = (EditText) stub.inflate();
+
+                // Put the list under the search box
+                RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
+                        RelativeLayout.LayoutParams.FILL_PARENT,
+                        RelativeLayout.LayoutParams.FILL_PARENT);
+                layoutParams.addRule(RelativeLayout.BELOW, R.id.search_box);
+
+                ListView listView = (ListView) view.findViewById(R.id.com_facebook_picker_list_view);
+                listView.setLayoutParams(layoutParams);
+
+                // If we need to, put the search box under the title bar.
+                if (view.findViewById(R.id.com_facebook_picker_title_bar) != null) {
+                    layoutParams = new RelativeLayout.LayoutParams(
+                            RelativeLayout.LayoutParams.FILL_PARENT,
+                            RelativeLayout.LayoutParams.WRAP_CONTENT);
+                    layoutParams.addRule(RelativeLayout.BELOW, R.id.com_facebook_picker_title_bar);
+
+                    searchBox.setLayoutParams(layoutParams);
+                }
+
+                searchBox.addTextChangedListener(new SearchTextWatcher());
+            }
+        }
+    }
+
+    void saveSettingsToBundle(Bundle outState) {
+        super.saveSettingsToBundle(outState);
+
+        outState.putInt(RADIUS_IN_METERS_BUNDLE_KEY, radiusInMeters);
+        outState.putInt(RESULTS_LIMIT_BUNDLE_KEY, resultsLimit);
+        outState.putString(SEARCH_TEXT_BUNDLE_KEY, searchText);
+        outState.putParcelable(LOCATION_BUNDLE_KEY, location);
+        outState.putBoolean(SHOW_SEARCH_BOX_BUNDLE_KEY, showSearchBox);
+    }
+
+    @Override
+    void onLoadingData() {
+        hasSearchTextChangedSinceLastQuery = false;
+    }
+
+    @Override
+    Request getRequestForLoadData(Session session) {
+        return createRequest(location, radiusInMeters, resultsLimit, searchText, extraFields, session);
+    }
+
+    @Override
+    String getDefaultTitleText() {
+        return getString(R.string.com_facebook_nearby);
+    }
+
+    @Override
+    GraphObjectListFragmentAdapter<GraphPlace> createAdapter() {
+        GraphObjectListFragmentAdapter<GraphPlace> adapter = new GraphObjectListFragmentAdapter<GraphPlace>(
+                this.getActivity()) {
+            @Override
+            protected CharSequence getSubTitleOfGraphObject(GraphPlace graphObject) {
+                String category = graphObject.getCategory();
+                Integer wereHereCount = (Integer) graphObject.getProperty(WERE_HERE_COUNT);
+
+                String result = null;
+                if (category != null && wereHereCount != null) {
+                    result = getString(R.string.com_facebook_placepicker_subtitle_format, category, wereHereCount);
+                } else if (category == null && wereHereCount != null) {
+                    result = getString(R.string.com_facebook_placepicker_subtitle_were_here_only_format, wereHereCount);
+                } else if (category != null && wereHereCount == null) {
+                    result = getString(R.string.com_facebook_placepicker_subtitle_catetory_only_format, category);
+                }
+                return result;
+            }
+
+            @Override
+            protected int getGraphObjectRowLayoutId(GraphPlace graphObject) {
+                return R.layout.com_facebook_placepickerfragment_list_row;
+            }
+
+            @Override
+            protected int getDefaultPicture() {
+                return R.drawable.com_facebook_place_default_icon;
+            }
+
+        };
+        adapter.setShowCheckbox(false);
+        adapter.setShowPicture(getShowPictures());
+        return adapter;
+    }
+
+    @Override
+    LoadingStrategy createLoadingStrategy() {
+        return new AsNeededLoadingStrategy();
+    }
+
+    @Override
+    SelectionStrategy createSelectionStrategy() {
+        return new SingleSelectionStrategy();
+    }
+
+    private Request createRequest(Location location, int radiusInMeters, int resultsLimit, String searchText,
+            Set<String> extraFields,
+            Session session) {
+        Request request = Request.newPlacesSearchRequest(session, location, radiusInMeters, resultsLimit, searchText,
+                null);
+
+        String pictureField = adapter.getPictureFieldSpecifier();
+        Set<String> fields = new HashSet<String>(extraFields);
+        String[] requiredFields = new String[]{
+                ID,
+                NAME,
+                LOCATION,
+                CATEGORY,
+                WERE_HERE_COUNT,
+                pictureField
+        };
+        fields.addAll(Arrays.asList(requiredFields));
+
+        Bundle parameters = request.getParameters();
+        parameters.putString("fields", TextUtils.join(",", fields));
+        request.setParameters(parameters);
+
+        return request;
+    }
+
+    private void setPlacePickerSettingsFromBundle(Bundle inState) {
+        // We do this in a separate non-overridable method so it is safe to call from the constructor.
+        if (inState != null) {
+            setRadiusInMeters(inState.getInt(RADIUS_IN_METERS_BUNDLE_KEY, radiusInMeters));
+            setResultsLimit(inState.getInt(RESULTS_LIMIT_BUNDLE_KEY, resultsLimit));
+            if (inState.containsKey(SEARCH_TEXT_BUNDLE_KEY)) {
+                setSearchText(inState.getString(SEARCH_TEXT_BUNDLE_KEY));
+            }
+            if (inState.containsKey(LOCATION_BUNDLE_KEY)) {
+                Location location = inState.getParcelable(LOCATION_BUNDLE_KEY);
+                setLocation(location);
+            }
+            showSearchBox = inState.getBoolean(SHOW_SEARCH_BOX_BUNDLE_KEY, showSearchBox);
+        }
+    }
+
+    private Timer createSearchTextTimer() {
+        Timer timer = new Timer();
+        timer.schedule(new TimerTask() {
+            @Override
+            public void run() {
+                onSearchTextTimerTriggered();
+            }
+        }, 0, searchTextTimerDelayInMilliseconds);
+
+        return timer;
+    }
+
+    private void onSearchTextTimerTriggered() {
+        if (hasSearchTextChangedSinceLastQuery) {
+            Handler handler = new Handler(Looper.getMainLooper());
+            handler.post(new Runnable() {
+                @Override
+                public void run() {
+                    FacebookException error = null;
+                    try {
+                        loadData(true);
+                    } catch (FacebookException fe) {
+                        error = fe;
+                    } catch (Exception e) {
+                        error = new FacebookException(e);
+                    } finally {
+                        if (error != null) {
+                            OnErrorListener onErrorListener = getOnErrorListener();
+                            if (onErrorListener != null) {
+                                onErrorListener.onError(error);
+                            } else {
+                                Logger.log(LoggingBehaviors.REQUESTS, TAG, "Error loading data : %s", error);
+                            }
+                        }
+                    }
+                }
+            });
+        } else {
+            // Nothing has changed in 2 seconds. Invalidate and forget about this timer.
+            // Next time the user types, we will fire a query immediately again.
+            searchTextTimer.cancel();
+            searchTextTimer = null;
+        }
+    }
+
+    private class AsNeededLoadingStrategy extends LoadingStrategy {
+        @Override
+        public void attach(GraphObjectAdapter<GraphPlace> adapter) {
+            super.attach(adapter);
+
+            this.adapter.setDataNeededListener(new GraphObjectAdapter.DataNeededListener() {
+                @Override
+                public void onDataNeeded() {
+                    // Do nothing if we are currently loading data . We will get notified again when that load finishes if the adapter still
+                    // needs more data. Otherwise, follow the next link.
+                    if (!loader.isLoading()) {
+                        loader.followNextLink();
+                    }
+                }
+            });
+        }
+
+        @Override
+        protected void onLoadFinished(GraphObjectPagingLoader<GraphPlace> loader,
+                SimpleGraphObjectCursor<GraphPlace> data) {
+            super.onLoadFinished(loader, data);
+
+            // We could be called in this state if we are clearing data or if we are being re-attached
+            // in the middle of a query.
+            if (data == null || loader.isLoading()) {
+                return;
+            }
+
+            hideActivityCircle();
+
+            if (data.isFromCache()) {
+                // Only the first page can be cached, since all subsequent pages will be round-tripped. Force
+                // a refresh of the first page before we allow paging to begin. If the first page produced
+                // no data, launch the refresh immediately, otherwise schedule it for later.
+                loader.refreshOriginalRequest(data.areMoreObjectsAvailable() ? CACHED_RESULT_REFRESH_DELAY : 0);
+            }
+        }
+    }
+
+    private class SearchTextWatcher implements TextWatcher {
+
+        @Override
+        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+        }
+
+        @Override
+        public void onTextChanged(CharSequence s, int start, int before, int count) {
+            setSearchTextAndReload(s.toString(), false);
+        }
+
+        @Override
+        public void afterTextChanged(Editable s) {
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/PrioritizedWorkQueue.java b/facebook/src/com/facebook/PrioritizedWorkQueue.java
new file mode 100644
index 000000000..d67bc3f7c
--- /dev/null
+++ b/facebook/src/com/facebook/PrioritizedWorkQueue.java
@@ -0,0 +1,264 @@
+package com.facebook;
+
+import java.util.concurrent.Executor;
+
+class PrioritizedWorkQueue {
+    public static final int PRIORITY_RUNNING = -1;
+    public static final int PRIORITY_ACTIVE = 0;
+    public static final int PRIORITY_BACKGROUND = 1;
+    private static final int PRIORITY_COUNT = 2;
+    private static final int DEFAULT_MAX_CONCURRENT = 8;
+
+    private final WorkNode[] queues = new WorkNode[PRIORITY_COUNT];
+    private final int maxConcurrent;
+    private final Executor executor;
+
+    private WorkNode runningItems = null;
+    private int runningCount = 0;
+
+    PrioritizedWorkQueue() {
+        this(DEFAULT_MAX_CONCURRENT, Settings.getExecutor());
+    }
+
+    PrioritizedWorkQueue(int maxConcurrent, Executor executor) {
+        this.maxConcurrent = maxConcurrent;
+        this.executor = executor;
+    }
+
+    WorkItem addActiveWorkItem(Runnable callback) {
+        WorkNode node = new WorkNode(callback);
+        synchronized (queues) {
+            queues[node.priority] = node.addToList(queues[node.priority]);
+        }
+
+        startItem();
+        return node;
+    }
+
+    void backgroundAll() {
+        setPriorityOnAll(PRIORITY_BACKGROUND);
+    }
+
+    void validate() {
+        synchronized (queues) {
+            // Verify that priority on items agrees with the priority of the queue they are in
+            for (int priority = 0; priority < PRIORITY_COUNT; priority++) {
+                if (queues[priority] != null) {
+                    WorkNode walk = queues[priority];
+                    do {
+                        walk.verify(priority);
+                        walk = walk.getNext();
+                    } while (walk != queues[priority]);
+                }
+            }
+
+            // Verify that all running items know they are running, and counts match
+            int count = 0;
+
+            if (runningItems != null) {
+                WorkNode walk = runningItems;
+                do {
+                    walk.verify(PRIORITY_RUNNING);
+                    count++;
+                    walk = walk.getNext();
+                } while (walk != runningItems);
+            }
+
+            assert runningCount == count;
+        }
+    }
+
+    private void startItem() {
+        finishItemAndStartNew(null);
+    }
+
+    private void finishItemAndStartNew(WorkNode finished) {
+        WorkNode ready = null;
+
+        synchronized (queues) {
+            if (finished != null) {
+                runningItems = finished.removeFromList(runningItems);
+                runningCount--;
+            }
+
+            if (runningCount < maxConcurrent) {
+                ready = extractNextReadyItem();
+
+                if (ready != null) {
+                    ready.setPriorityRunning();
+                    runningItems = ready.addToList(runningItems);
+                    runningCount++;
+                }
+            }
+        }
+
+        if (ready != null) {
+            execute(ready);
+        }
+    }
+
+    private void execute(final WorkNode node) {
+        executor.execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    node.getCallback().run();
+                } finally {
+                    finishItemAndStartNew(node);
+                }
+            }
+        });
+    }
+
+    private WorkNode extractNextReadyItem() {
+        for (int priority = 0; priority < PRIORITY_COUNT; priority++) {
+            WorkNode ready = queues[priority];
+            if (ready != null) {
+                queues[priority] = ready.removeFromList(queues[priority]);
+                return ready;
+            }
+        }
+
+        return null;
+    }
+
+    private void setPriorityOnAll(int priority) {
+        synchronized (queues) {
+            for (int i = 0; i < PRIORITY_COUNT; i++) {
+                if (i != priority) {
+                    WorkNode move = queues[i];
+                    if (move != null) {
+                        do {
+                            move.priority = priority;
+                            move = move.getNext();
+                        } while (move != queues[i]);
+
+                        queues[i] = null;
+                        queues[priority] = move.spliceLists(queues[priority]);
+                    }
+                }
+            }
+        }
+    }
+
+    private class WorkNode implements WorkItem {
+        private final Runnable callback;
+        private int priority;
+        private WorkNode next;
+        private WorkNode prev;
+
+        WorkNode(Runnable callback) {
+            this.callback = callback;
+            this.priority = PRIORITY_ACTIVE;
+        }
+
+        @Override
+        public boolean cancel() {
+            synchronized (queues) {
+                if ((priority != PRIORITY_RUNNING) && (next != null)) {
+                    queues[priority] = removeFromList(queues[priority]);
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        @Override
+        public void setPriority(int newPriority) {
+            assert priority >= 0;
+            assert priority < PRIORITY_COUNT;
+
+            synchronized (queues) {
+                if (priority != PRIORITY_RUNNING) {
+                    if (next != null) {
+                        queues[priority] = removeFromList(queues[priority]);
+                    }
+                    priority = newPriority;
+                    queues[priority] = addToList(queues[priority]);
+                }
+            }
+        }
+
+        @Override
+        public int getPriority() {
+            return priority;
+        }
+
+        void setPriorityRunning() {
+            synchronized (queues) {
+                priority = PRIORITY_RUNNING;
+            }
+        }
+
+        Runnable getCallback() {
+            return callback;
+        }
+
+        WorkNode getNext() {
+            return next;
+        }
+
+        WorkNode addToList(WorkNode list) {
+            assert next == null;
+            assert prev == null;
+
+            if (list == null) {
+                list = next = prev = this;
+            } else {
+                next = list;
+                prev = list.prev;
+                next.prev = prev.next = this;
+            }
+
+            return list;
+        }
+
+        WorkNode removeFromList(WorkNode list) {
+            assert next != null;
+            assert prev != null;
+
+            if (list == this) {
+                if (next == this) {
+                    list = null;
+                } else {
+                    list = next;
+                }
+            }
+
+            next.prev = prev;
+            prev.next = next;
+            next = prev = null;
+
+            return list;
+        }
+
+        WorkNode spliceLists(WorkNode list) {
+            if (list == null) {
+                list = this;
+            } else {
+                WorkNode listPrev = list.prev;
+
+                list.prev = prev;
+                prev.next = list;
+
+                listPrev.next = this;
+                prev = listPrev;
+            }
+
+            return list;
+        }
+
+        void verify(int expectedPriority) {
+            assert priority == expectedPriority;
+            assert prev.next == this;
+            assert next.prev == this;
+        }
+    }
+
+    interface WorkItem {
+        boolean cancel();
+        int getPriority();
+        void setPriority(int priority);
+    }
+}
diff --git a/facebook/src/com/facebook/ProfilePictureView.java b/facebook/src/com/facebook/ProfilePictureView.java
new file mode 100644
index 000000000..d514eddd8
--- /dev/null
+++ b/facebook/src/com/facebook/ProfilePictureView.java
@@ -0,0 +1,494 @@
+/**
+ * Copyright 2010 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Bitmap;
+import android.os.Bundle;
+import android.os.Parcelable;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import com.facebook.android.R;
+
+import java.net.MalformedURLException;
+
+/**
+ * View that displays the profile photo of a supplied user ID, while conforming
+ * to user specified dimensions.
+ */
+public class ProfilePictureView extends FrameLayout {
+
+    /**
+     * Callback interface that will be called when a network or other error is encountered
+     * while retrieving profile pictures.
+     */
+    public interface OnErrorListener {
+        /**
+         * Called when a network or other error is encountered.
+         * @param error     a FacebookException representing the error that was encountered.
+         */
+        void onError(FacebookException error);
+    }
+
+    /**
+     * Tag used when logging calls are made by ProfilePictureView
+     */
+    public static final String TAG = ProfilePictureView.class.getSimpleName();
+
+    /**
+     * Indicates that the specific size of the View will be set via layout params.
+     * ProfilePictureView will default to NORMAL X NORMAL, if the layout params set on
+     * this instance do not have a fixed size.
+     * Used in calls to setPresetSize() and getPresetSize().
+     * Corresponds with the preset_size Xml attribute that can be set on ProfilePictureView.
+     */
+    public static final int CUSTOM = -1;
+
+    /**
+     * Indicates that the profile image should fit in a SMALL X SMALL space, regardless
+     * of whether the cropped or un-cropped version is chosen.
+     * Used in calls to setPresetSize() and getPresetSize().
+     * Corresponds with the preset_size Xml attribute that can be set on ProfilePictureView.
+     */
+    public static final int SMALL = -2;
+
+    /**
+     * Indicates that the profile image should fit in a NORMAL X NORMAL space, regardless
+     * of whether the cropped or un-cropped version is chosen.
+     * Used in calls to setPresetSize() and getPresetSize().
+     * Corresponds with the preset_size Xml attribute that can be set on ProfilePictureView.
+     */
+    public static final int NORMAL = -3;
+
+    /**
+     * Indicates that the profile image should fit in a LARGE X LARGE space, regardless
+     * of whether the cropped or un-cropped version is chosen.
+     * Used in calls to setPresetSize() and getPresetSize().
+     * Corresponds with the preset_size Xml attribute that can be set on ProfilePictureView.
+     */
+    public static final int LARGE = -4;
+
+    private static final int MIN_SIZE = 1;
+    private static final String SUPER_STATE_KEY = "ProfilePictureView_superState";
+    private static final String USER_ID_KEY = "ProfilePictureView_userId";
+    private static final String PRESET_SIZE_KEY = "ProfilePictureView_presetSize";
+    private static final String IS_CROPPED_KEY = "ProfilePictureView_isCropped";
+    private static final String BITMAP_KEY = "ProfilePictureView_bitmap";
+    private static final String BITMAP_WIDTH_KEY = "ProfilePictureView_width";
+    private static final String BITMAP_HEIGHT_KEY = "ProfilePictureView_height";
+    private static final String PENDING_REFRESH_KEY = "ProfilePictureView_refresh";
+
+    private String userId;
+    private int queryHeight = ImageRequest.UNSPECIFIED_DIMENSION;
+    private int queryWidth = ImageRequest.UNSPECIFIED_DIMENSION;
+    private boolean isCropped;
+    private Bitmap imageContents;
+    private ImageView image;
+    private int presetSizeType = CUSTOM;
+    private ImageRequest lastRequest;
+    private OnErrorListener onErrorListener;
+
+    /**
+     * Constructor
+     *
+     * @param context Context for this View
+     */
+    public ProfilePictureView(Context context) {
+        super(context);
+        initialize(context);
+    }
+
+    /**
+     * Constructor
+     *
+     * @param context Context for this View
+     * @param attrs   AttributeSet for this View.
+     *                The attribute 'preset_size' is processed here
+     */
+    public ProfilePictureView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        initialize(context);
+        parseAttributes(attrs);
+    }
+
+    /**
+     * Constructor
+     *
+     * @param context  Context for this View
+     * @param attrs    AttributeSet for this View.
+     *                 The attribute 'preset_size' is processed here
+     * @param defStyle Default style for this View
+     */
+    public ProfilePictureView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        initialize(context);
+        parseAttributes(attrs);
+    }
+
+    /**
+     * Gets the current preset size type
+     *
+     * @return The current preset size type, if set; CUSTOM if not
+     */
+    public final int getPresetSize() {
+        return presetSizeType;
+    }
+
+    /**
+     * Apply a preset size to this profile photo
+     *
+     * @param sizeType The size type to apply: SMALL, NORMAL or LARGE
+     */
+    public final void setPresetSize(int sizeType) {
+        switch (sizeType) {
+            case SMALL:
+            case NORMAL:
+            case LARGE:
+            case CUSTOM:
+                this.presetSizeType = sizeType;
+                break;
+
+            default:
+                throw new IllegalArgumentException("Must use a predefined preset size");
+        }
+
+        requestLayout();
+    }
+
+    /**
+     * Indicates whether the cropped version of the profile photo has been chosen
+     *
+     * @return True if the cropped version is chosen, false if not.
+     */
+    public final boolean isCropped() {
+        return isCropped;
+    }
+
+    /**
+     * Sets the profile photo to be the cropped version, or the original version
+     *
+     * @param showCroppedVersion True to select the cropped version
+     *                           False to select the standard version
+     */
+    public final void setCropped(boolean showCroppedVersion) {
+        isCropped = showCroppedVersion;
+        // No need to force the refresh since we will catch the change in required dimensions
+        refreshImage(false);
+    }
+
+    /**
+     * Returns the user Id for the current profile photo
+     *
+     * @return The user Id
+     */
+    public final String getUserId() {
+        return userId;
+    }
+
+    /**
+     * Sets the user Id for this profile photo
+     *
+     * @param userId The userId
+     *               NULL/Empty String will show the blank profile photo
+     */
+    public final void setUserId(String userId) {
+        boolean force = Utility.isNullOrEmpty(this.userId) || !this.userId.equalsIgnoreCase(userId);
+        this.userId = userId;
+
+        refreshImage(force);
+    }
+
+    /**
+     * Returns the current OnErrorListener for this instance of ProfilePictureView
+     *
+     * @return The OnErrorListener
+     */
+    public final OnErrorListener getOnErrorListener() {
+        return onErrorListener;
+    }
+
+    /**
+     * Sets an OnErrorListener for this instance of ProfilePictureView to call into when
+     * certain exceptions occur.
+     *
+     * @param onErrorListener The listener object to set
+     */
+    public final void setOnErrorListener(OnErrorListener onErrorListener) {
+        this.onErrorListener = onErrorListener;
+    }
+
+    /**
+     * Overriding onMeasure to handle the case where WRAP_CONTENT might be
+     * specified in the layout. Since we don't know the dimensions of the profile
+     * photo, we need to handle this case specifically.
+     * <p/>
+     * The approach is to default to a NORMAL sized amount of space in the case that
+     * a preset size is not specified. This logic is applied to both width and height
+     */
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        ViewGroup.LayoutParams params = getLayoutParams();
+        boolean customMeasure = false;
+        int newHeight = MeasureSpec.getSize(heightMeasureSpec);
+        int newWidth = MeasureSpec.getSize(widthMeasureSpec);
+        if (MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY &&
+                params.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
+            newHeight = getPresetSizeInPixels(true); // Default to a preset size
+            heightMeasureSpec = MeasureSpec.makeMeasureSpec(newHeight, MeasureSpec.EXACTLY);
+            customMeasure = true;
+        }
+
+        if (MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY &&
+                params.width == ViewGroup.LayoutParams.WRAP_CONTENT) {
+            newWidth = getPresetSizeInPixels(true); // Default to a preset size
+            widthMeasureSpec = MeasureSpec.makeMeasureSpec(newWidth, MeasureSpec.EXACTLY);
+            customMeasure = true;
+        }
+
+        if (customMeasure) {
+            // Since we are providing custom dimensions, we need to handle the measure
+            // phase from here
+            setMeasuredDimension(newWidth, newHeight);
+            measureChildren(widthMeasureSpec, heightMeasureSpec);
+        } else {
+            // Rely on FrameLayout to do the right thing
+            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+        }
+    }
+
+    /**
+     * In addition to calling super.Layout(), we also attempt to get a new image that
+     * is properly size for the layout dimensions
+     */
+    @Override
+    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+        super.onLayout(changed, left, top, right, bottom);
+
+        // See if the image needs redrawing
+        refreshImage(false);
+    }
+
+    /**
+     * Some of the current state is returned as a Bundle to allow quick restoration
+     * of the ProfilePictureView object in scenarios like orientation changes.
+     * @return
+     */
+    @Override
+    protected Parcelable onSaveInstanceState() {
+        Parcelable superState = super.onSaveInstanceState();
+        Bundle instanceState = new Bundle();
+        instanceState.putParcelable(SUPER_STATE_KEY, superState);
+        instanceState.putString(USER_ID_KEY, userId);
+        instanceState.putInt(PRESET_SIZE_KEY, presetSizeType);
+        instanceState.putBoolean(IS_CROPPED_KEY, isCropped);
+        instanceState.putParcelable(BITMAP_KEY, imageContents);
+        instanceState.putInt(BITMAP_WIDTH_KEY, queryWidth);
+        instanceState.putInt(BITMAP_HEIGHT_KEY, queryHeight);
+        instanceState.putBoolean(PENDING_REFRESH_KEY, lastRequest != null);
+
+        return instanceState;
+    }
+
+    /**
+     * If the passed in state is a Bundle, an attempt is made to restore from it.
+     * @param state
+     */
+    @Override
+    protected void onRestoreInstanceState(Parcelable state) {
+        if (state.getClass() != Bundle.class) {
+            super.onRestoreInstanceState(state);
+        } else {
+            Bundle instanceState = (Bundle)state;
+            super.onRestoreInstanceState(instanceState.getParcelable(SUPER_STATE_KEY));
+
+            userId = instanceState.getString(USER_ID_KEY);
+            presetSizeType = instanceState.getInt(PRESET_SIZE_KEY);
+            isCropped = instanceState.getBoolean(IS_CROPPED_KEY);
+            imageContents = (Bitmap)instanceState.getParcelable(BITMAP_KEY);
+            queryWidth = instanceState.getInt(BITMAP_WIDTH_KEY);
+            queryHeight = instanceState.getInt(BITMAP_HEIGHT_KEY);
+
+            if (image != null && imageContents != null) {
+                image.setImageBitmap(imageContents);
+            }
+
+            if (instanceState.getBoolean(PENDING_REFRESH_KEY)) {
+                refreshImage(true);
+            }
+        }
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+
+        // Null out lastRequest. This way, when the response is returned, we can ascertain
+        // that the view is detached and hence should not attempt to update its contents.
+        lastRequest = null;
+    }
+
+    private void initialize(Context context) {
+        // We only want our ImageView in here. Nothing else is permitted
+        removeAllViews();
+
+        image = new ImageView(context);
+
+        LayoutParams imageLayout = new LayoutParams(
+                LayoutParams.MATCH_PARENT,
+                LayoutParams.MATCH_PARENT);
+
+        image.setLayoutParams(imageLayout);
+
+        // We want to prevent up-scaling the image, but still have it fit within
+        // the layout bounds as best as possible.
+        image.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
+        addView(image);
+    }
+
+    private void parseAttributes(AttributeSet attrs) {
+        TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.com_facebook_profile_picture_view);
+        setPresetSize(a.getInt(R.styleable.com_facebook_profile_picture_view_preset_size, CUSTOM));
+        a.recycle();
+    }
+
+    private void refreshImage(boolean force) {
+        boolean changed = updateImageQueryParameters();
+        if (Utility.isNullOrEmpty(userId) ||
+                ((queryWidth == ImageRequest.UNSPECIFIED_DIMENSION) &&
+                        (queryHeight == ImageRequest.UNSPECIFIED_DIMENSION))) {
+            int blankImage = isCropped() ?
+                    R.drawable.com_facebook_profile_picture_blank_square :
+                    R.drawable.com_facebook_profile_picture_blank_portrait;
+
+            image.setImageDrawable(getResources().getDrawable(blankImage));
+        } else if (changed || force) {
+            sendImageRequest(true);
+        }
+    }
+
+    private void sendImageRequest(boolean allowCachedResponse) {
+        try {
+            ImageRequest request = ImageRequest.createProfilePictureImageRequest(
+                    getContext(),
+                    userId,
+                    queryWidth,
+                    queryHeight,
+                    allowCachedResponse,
+                    new ImageRequest.Callback() {
+                        @Override
+                        public void onCompleted(ImageResponse response) {
+                            processResponse(response);
+                        }
+                    });
+
+            ImageDownloader.downloadAsync(request);
+
+            if (lastRequest != null) {
+                lastRequest.cancel();
+            }
+            lastRequest = request;
+        } catch (MalformedURLException e) {
+            Logger.log(LoggingBehaviors.REQUESTS, Log.ERROR, TAG, e.toString());
+        }
+    }
+
+    private void processResponse(ImageResponse response) {
+        // First check if the response is for the right request. We may have:
+        // 1. Sent a new request, thus super-ceding this one.
+        // 2. Detached this view, in which case the response should be discarded.
+        if (response.getRequest() == lastRequest) {
+            lastRequest = null;
+            imageContents = response.getBitmap();
+            Exception error = response.getError();
+            if (error != null) {
+                OnErrorListener listener = onErrorListener;
+                if (listener != null) {
+                    listener.onError(new FacebookException(
+                            "Error in downloading profile picture for userId: " + getUserId(), error));
+                } else {
+                    Logger.log(LoggingBehaviors.REQUESTS, Log.ERROR, TAG, error.toString());
+                }
+            } else if (imageContents != null) {
+                image.setImageBitmap(imageContents);
+
+                if (response.isCachedRedirect()) {
+                    sendImageRequest(false);
+                }
+            }
+        }
+    }
+
+    private boolean updateImageQueryParameters() {
+        int newHeightPx = getHeight();
+        int newWidthPx = getWidth();
+        if (newWidthPx < MIN_SIZE || newHeightPx < MIN_SIZE) {
+            // Not enough space laid out for this View yet. Or something else is awry.
+            return false;
+        }
+
+        int presetSize = getPresetSizeInPixels(false);
+        if (presetSize != ImageRequest.UNSPECIFIED_DIMENSION) {
+            newWidthPx = presetSize;
+            newHeightPx = presetSize;
+        }
+
+        // The cropped version is square
+        // If full version is desired, then only one dimension is required.
+        if (newWidthPx <= newHeightPx) {
+            newHeightPx = isCropped() ? newWidthPx : ImageRequest.UNSPECIFIED_DIMENSION;
+        } else {
+            newWidthPx = isCropped() ? newHeightPx : ImageRequest.UNSPECIFIED_DIMENSION;
+        }
+
+        boolean changed = (newWidthPx != queryWidth) || (newHeightPx != queryHeight);
+
+        queryWidth = newWidthPx;
+        queryHeight = newHeightPx;
+
+        return changed;
+    }
+
+    private int getPresetSizeInPixels(boolean forcePreset) {
+        int dimensionId = 0;
+        switch (presetSizeType) {
+            case SMALL:
+                dimensionId = R.dimen.com_facebook_profilepictureview_preset_size_small;
+                break;
+            case NORMAL:
+                dimensionId = R.dimen.com_facebook_profilepictureview_preset_size_normal;
+                break;
+            case LARGE:
+                dimensionId = R.dimen.com_facebook_profilepictureview_preset_size_large;
+                break;
+            case CUSTOM:
+                if (!forcePreset) {
+                    return ImageRequest.UNSPECIFIED_DIMENSION;
+                } else {
+                    dimensionId = R.dimen.com_facebook_profilepictureview_preset_size_normal;
+                    break;
+                }
+            default:
+                return ImageRequest.UNSPECIFIED_DIMENSION;
+        }
+
+        return getResources().getDimensionPixelSize(dimensionId);
+    }
+}
diff --git a/facebook/src/com/facebook/PropertyName.java b/facebook/src/com/facebook/PropertyName.java
new file mode 100644
index 000000000..6613d1096
--- /dev/null
+++ b/facebook/src/com/facebook/PropertyName.java
@@ -0,0 +1,18 @@
+package com.facebook;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * Use this annotation on getters and setters in an interface that derives from
+ * GraphObject, if you wish to override the default property name that is inferred
+ * from the name of the method.
+ *
+ * If this annotation is specified on a method, it must contain a non-empty String
+ * value that represents the name of the property that the method is a getter or setter
+ * for.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+public @interface PropertyName {
+    String value();
+}
\ No newline at end of file
diff --git a/facebook/src/com/facebook/Request.java b/facebook/src/com/facebook/Request.java
new file mode 100644
index 000000000..166790ca0
--- /dev/null
+++ b/facebook/src/com/facebook/Request.java
@@ -0,0 +1,1739 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.graphics.Bitmap;
+import android.location.Location;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.ParcelFileDescriptor;
+import android.text.TextUtils;
+import android.util.Pair;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.*;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLEncoder;
+import java.text.SimpleDateFormat;
+import java.util.*;
+import java.util.Map.Entry;
+
+/**
+ * A single request to be sent to the Facebook Platform through either the <a
+ * href="https://developers.facebook.com/docs/reference/api/">Graph API</a> or <a
+ * href="https://developers.facebook.com/docs/reference/rest/">REST API</a>. The Request class provides functionality
+ * relating to serializing and deserializing requests and responses, making calls in batches (with a single round-trip
+ * to the service) and making calls asynchronously.
+ * 
+ * The particular service endpoint that a request targets is determined by either a graph path (see the
+ * {@link #setGraphPath(String) setGraphPath} method) or a REST method name (see the {@link #setRestMethod(String)
+ * setRestMethod} method); a single request may not target both.
+ * 
+ * A Request can be executed either anonymously or representing an authenticated user. In the former case, no Session
+ * needs to be specified, while in the latter, a Session that is in an opened state must be provided. If requests are
+ * executed in a batch, a Facebook application ID must be associated with the batch, either by supplying a Session for
+ * at least one of the requests in the batch (the first one found in the batch will be used) or by calling the
+ * {@link #setDefaultBatchApplicationId(String) setDefaultBatchApplicationId} method.
+ * 
+ * After completion of a request, its Session, if any, will be checked to determine if its Facebook access token needs
+ * to be extended; if so, a request to extend it will be issued in the background.
+ */
+public class Request {
+    /**
+     * The maximum number of requests that can be submitted in a single batch. This limit is enforced on the service
+     * side by the Facebook platform, not by the Request class.
+     */
+    public static final int MAXIMUM_BATCH_SIZE = 50;
+
+    private static final String ME = "me";
+    private static final String MY_FRIENDS = "me/friends";
+    private static final String MY_PHOTOS = "me/photos";
+    private static final String SEARCH = "search";
+    private static final String MY_FEED = "me/feed";
+
+    private static final String USER_AGENT_BASE = "FBAndroidSDK";
+    private static final String USER_AGENT_HEADER = "User-Agent";
+    private static final String CONTENT_TYPE_HEADER = "Content-Type";
+
+    // Parameter names/values
+    private static final String PICTURE_PARAM = "picture";
+    private static final String FORMAT_PARAM = "format";
+    private static final String FORMAT_JSON = "json";
+    private static final String SDK_PARAM = "sdk";
+    private static final String SDK_ANDROID = "android";
+    private static final String ACCESS_TOKEN_PARAM = "access_token";
+    private static final String BATCH_ENTRY_NAME_PARAM = "name";
+    private static final String BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM = "omit_response_on_success";
+    private static final String BATCH_ENTRY_DEPENDS_ON_PARAM = "depends_on";
+    private static final String BATCH_APP_ID_PARAM = "batch_app_id";
+    private static final String BATCH_RELATIVE_URL_PARAM = "relative_url";
+    private static final String BATCH_BODY_PARAM = "body";
+    private static final String BATCH_METHOD_PARAM = "method";
+    private static final String BATCH_PARAM = "batch";
+    private static final String ATTACHMENT_FILENAME_PREFIX = "file";
+    private static final String ATTACHED_FILES_PARAM = "attached_files";
+    private static final String MIGRATION_BUNDLE_PARAM = "migration_bundle";
+
+    private static final String MIME_BOUNDARY = "3i2ndDfv2rTHiSisAbouNdArYfORhtTPEefj3q2f";
+    private static final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.US);
+
+    private static String defaultBatchApplicationId;
+
+    private Session session;
+    private HttpMethod httpMethod;
+    private String graphPath;
+    private GraphObject graphObject;
+    private String restMethod;
+    private String batchEntryName;
+    private String batchEntryDependsOn;
+    private boolean batchEntryOmitResultOnSuccess = true;
+    private Bundle parameters;
+    private Callback callback;
+
+    /**
+     * Constructs a request without a session, graph path, or any other parameters.
+     */
+    public Request() {
+        this(null, null, null, null, null);
+    }
+
+    /**
+     * Constructs a request with a Session to retrieve a particular graph path. A Session need not be provided, in which
+     * case the request is sent without an access token and thus is not executed in the context of any particular user.
+     * Only certain graph requests can be expected to succeed in this case. If a Session is provided, it must be in an
+     * opened state or the request will fail.
+     * 
+     * @param session
+     *            the Session to use, or null
+     * @param graphPath
+     *            the graph path to retrieve
+     */
+    public Request(Session session, String graphPath) {
+        this(session, graphPath, null, null, null);
+    }
+
+    /**
+     * Constructs a request with a specific Session, graph path, parameters, and HTTP method. A Session need not be
+     * provided, in which case the request is sent without an access token and thus is not executed in the context of
+     * any particular user. Only certain graph requests can be expected to succeed in this case. If a Session is
+     * provided, it must be in an opened state or the request will fail.
+     * 
+     * Depending on the httpMethod parameter, the object at the graph path may be retrieved, created, or deleted.
+     * 
+     * @param session
+     *            the Session to use, or null
+     * @param graphPath
+     *            the graph path to retrieve, create, or delete
+     * @param parameters
+     *            additional parameters to pass along with the Graph API request; parameters must be Strings, Numbers,
+     *            Bitmaps, Dates, or Byte arrays.
+     * @param httpMethod
+     *            the {@link HttpMethod} to use for the request, or null for default (HttpMethod.GET)
+     */
+    public Request(Session session, String graphPath, Bundle parameters, HttpMethod httpMethod) {
+        this(session, graphPath, parameters, httpMethod, null);
+    }
+
+    /**
+     * Constructs a request with a specific Session, graph path, parameters, and HTTP method. A Session need not be
+     * provided, in which case the request is sent without an access token and thus is not executed in the context of
+     * any particular user. Only certain graph requests can be expected to succeed in this case. If a Session is
+     * provided, it must be in an opened state or the request will fail.
+     * 
+     * Depending on the httpMethod parameter, the object at the graph path may be retrieved, created, or deleted.
+     * 
+     * @param session
+     *            the Session to use, or null
+     * @param graphPath
+     *            the graph path to retrieve, create, or delete
+     * @param parameters
+     *            additional parameters to pass along with the Graph API request; parameters must be Strings, Numbers,
+     *            Bitmaps, Dates, or Byte arrays.
+     * @param httpMethod
+     *            the {@link HttpMethod} to use for the request, or null for default (HttpMethod.GET)
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     */
+    public Request(Session session, String graphPath, Bundle parameters, HttpMethod httpMethod, Callback callback) {
+        this.session = session;
+        this.graphPath = graphPath;
+        this.callback = callback;
+
+        setHttpMethod(httpMethod);
+
+        if (parameters != null) {
+            this.parameters = new Bundle(parameters);
+        } else {
+            this.parameters = new Bundle();
+        }
+
+        if (!this.parameters.containsKey(MIGRATION_BUNDLE_PARAM)) {
+            this.parameters.putString(MIGRATION_BUNDLE_PARAM, FacebookSdkVersion.MIGRATION_BUNDLE);
+        }
+    }
+
+    /**
+     * Creates a new Request configured to post a GraphObject to a particular graph path, to either create or update the
+     * object at that path.
+     * 
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param graphPath
+     *            the graph path to retrieve, create, or delete
+     * @param graphObject
+     *            the GraphObject to create or update
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newPostRequest(Session session, String graphPath, GraphObject graphObject, Callback callback) {
+        Request request = new Request(session, graphPath, null, HttpMethod.POST , callback);
+        request.setGraphObject(graphObject);
+        return request;
+    }
+
+    /**
+     * Creates a new Request configured to make a call to the Facebook REST API.
+     * 
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param restMethod
+     *            the method in the Facebook REST API to execute
+     * @param parameters
+     *            additional parameters to pass along with the Graph API request; parameters must be Strings, Numbers,
+     *            Bitmaps, Dates, or Byte arrays.
+     * @param httpMethod
+     *            the HTTP method to use for the request; must be one of GET, POST, or DELETE
+     * @return a Request that is ready to execute
+     */
+    public static Request newRestRequest(Session session, String restMethod, Bundle parameters, HttpMethod httpMethod) {
+        Request request = new Request(session, null, parameters, httpMethod);
+        request.setRestMethod(restMethod);
+        return request;
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a user's own profile.
+     * 
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newMeRequest(Session session, final GraphUserCallback callback) {
+        Callback wrapper = new Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                if (callback != null) {
+                    callback.onCompleted(response.getGraphObjectAs(GraphUser.class), response);
+                }
+            }
+        };
+        return new Request(session, ME, null, null, wrapper);
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a user's friend list.
+     * 
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newMyFriendsRequest(Session session, final GraphUserListCallback callback) {
+        Callback wrapper = new Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                if (callback != null) {
+                    callback.onCompleted(typedListFromResponse(response, GraphUser.class), response);
+                }
+            }
+        };
+        return new Request(session, MY_FRIENDS, null, null, wrapper);
+    }
+
+    /**
+     * Creates a new Request configured to upload a photo to the user's default photo album.
+     * 
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param image
+     *            the image to upload
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newUploadPhotoRequest(Session session, Bitmap image, Callback callback) {
+        Bundle parameters = new Bundle(1);
+        parameters.putParcelable(PICTURE_PARAM, image);
+
+        return new Request(session, MY_PHOTOS, parameters, HttpMethod.POST, callback);
+    }
+
+    /**
+     * Creates a new Request configured to upload a photo to the user's default photo album. The photo
+     * will be read from the specified stream.
+     *
+     * @param session  the Session to use, or null; if non-null, the session must be in an opened state
+     * @param file     the file containing the photo to upload
+     * @param callback a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newUploadPhotoRequest(Session session, File file,
+            Callback callback) throws FileNotFoundException {
+        ParcelFileDescriptor descriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
+        Bundle parameters = new Bundle(1);
+        parameters.putParcelable(PICTURE_PARAM, descriptor);
+
+        return new Request(session, MY_PHOTOS, parameters, HttpMethod.POST, callback);
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a particular graph path.
+     * 
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param graphPath
+     *            the graph path to retrieve
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newGraphPathRequest(Session session, String graphPath, Callback callback) {
+        return new Request(session, graphPath, null, null, callback);
+    }
+
+    /**
+     * Creates a new Request that is configured to perform a search for places near a specified location via the Graph
+     * API.
+     * 
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param location
+     *            the location around which to search; only the latitude and longitude components of the location are
+     *            meaningful
+     * @param radiusInMeters
+     *            the radius around the location to search, specified in meters
+     * @param resultsLimit
+     *            the maximum number of results to return
+     * @param searchText
+     *            optional text to search for as part of the name or type of an object
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     *
+     * @throws FacebookException If neither location nor searchText is specified
+     */
+    public static Request newPlacesSearchRequest(Session session, Location location, int radiusInMeters,
+            int resultsLimit, String searchText, final GraphPlaceListCallback callback) {
+        if (location == null && Utility.isNullOrEmpty(searchText)) {
+            throw new FacebookException("Either location or searchText must be specified.");
+        }
+
+        Bundle parameters = new Bundle(5);
+        parameters.putString("type", "place");
+        parameters.putString("limit", String.format("%d", resultsLimit));
+        parameters.putString("distance", String.format("%d", radiusInMeters));
+        parameters.putString("center",
+                String.format(Locale.US, "%f,%f", location.getLatitude(), location.getLongitude()));
+        if (!Utility.isNullOrEmpty(searchText)) {
+            parameters.putString("q", searchText);
+        }
+
+        Callback wrapper = new Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                if (callback != null) {
+                    callback.onCompleted(typedListFromResponse(response, GraphPlace.class), response);
+                }
+            }
+        };
+
+        return new Request(session, SEARCH, parameters, HttpMethod.GET, wrapper);
+    }
+
+    /**
+     * Creates a new Request configured to post a status update to a user's feed.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param message
+     *            the text of the status update
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newStatusUpdateRequest(Session session, String message, Callback callback) {
+        Bundle parameters = new Bundle();
+        parameters.putString("message", message);
+
+        return new Request(session, MY_FEED, parameters, HttpMethod.POST, callback);
+    }
+
+    /**
+     * Returns the GraphObject, if any, associated with this request.
+     * 
+     * @return the GraphObject associated with this requeset, or null if there is none
+     */
+    public final GraphObject getGraphObject() {
+        return this.graphObject;
+    }
+
+    /**
+     * Sets the GraphObject associated with this request. This is meaningful only for POST requests.
+     * 
+     * @param graphObject
+     *            the GraphObject to upload along with this request
+     */
+    public final void setGraphObject(GraphObject graphObject) {
+        this.graphObject = graphObject;
+    }
+
+    /**
+     * Returns the graph path of this request, if any.
+     * 
+     * @return the graph path of this request, or null if there is none
+     */
+    public final String getGraphPath() {
+        return this.graphPath;
+    }
+
+    /**
+     * Sets the graph path of this request. A graph path may not be set if a REST method has been specified.
+     * 
+     * @param graphPath
+     *            the graph path for this request
+     */
+    public final void setGraphPath(String graphPath) {
+        this.graphPath = graphPath;
+    }
+
+    /**
+     * Returns the {@link HttpMethod} to use for this request.
+     * 
+     * @return the HttpMethod
+     */
+    public final HttpMethod getHttpMethod() {
+        return this.httpMethod;
+    }
+
+    /**
+     * Sets the {@link HttpMethod} to use for this request.
+     * 
+     * @param httpMethod
+     *            the HttpMethod, or null for the default (HttpMethod.GET).
+     */
+    public final void setHttpMethod(HttpMethod httpMethod) {
+        this.httpMethod = (httpMethod != null) ? httpMethod : HttpMethod.GET;
+    }
+
+    /**
+     * Returns the parameters for this request.
+     * 
+     * @return the parameters
+     */
+    public final Bundle getParameters() {
+        return this.parameters;
+    }
+
+    /**
+     * Sets the parameters for this request.
+     * 
+     * @param parameters
+     *            the parameters
+     */
+    public final void setParameters(Bundle parameters) {
+        this.parameters = parameters;
+    }
+
+    /**
+     * Returns the REST method to call for this request.
+     * 
+     * @return the REST method
+     */
+    public final String getRestMethod() {
+        return this.restMethod;
+    }
+
+    /**
+     * Sets the REST method to call for this request. A REST method may not be set if a graph path has been specified.
+     * 
+     * @param restMethod
+     *            the REST method to call
+     */
+    public final void setRestMethod(String restMethod) {
+        this.restMethod = restMethod;
+    }
+
+    /**
+     * Returns the Session associated with this request.
+     * 
+     * @return the Session associated with this request, or null if none has been specified
+     */
+    public final Session getSession() {
+        return this.session;
+    }
+
+    /**
+     * Sets the Session to use for this request. The Session does not need to be opened at the time it is specified, but
+     * it must be opened by the time the request is executed.
+     * 
+     * @param session
+     *            the Session to use for this request
+     */
+    public final void setSession(Session session) {
+        this.session = session;
+    }
+
+    /**
+     * Returns the name of this request's entry in a batched request.
+     * 
+     * @return the name of this request's batch entry, or null if none has been specified
+     */
+    public final String getBatchEntryName() {
+        return this.batchEntryName;
+    }
+
+    /**
+     * Sets the name of this request's entry in a batched request. This value is only used if this request is submitted
+     * as part of a batched request. It can be used to specified dependencies between requests. See <a
+     * href="https://developers.facebook.com/docs/reference/api/batch/">Batch Requests</a> in the Graph API
+     * documentation for more details.
+     * 
+     * @param batchEntryName
+     *            the name of this request's entry in a batched request, which must be unique within a particular batch
+     *            of requests
+     */
+    public final void setBatchEntryName(String batchEntryName) {
+        this.batchEntryName = batchEntryName;
+    }
+
+    /**
+     * Returns the name of the request that this request entry explicitly depends on in a batched request.
+     *
+     * @return the name of this request's dependency, or null if none has been specified
+     */
+    public final String getBatchEntryDependsOn() {
+        return this.batchEntryDependsOn;
+    }
+
+    /**
+     * Sets the name of the request entry that this request explicitly depends on in a batched request. This value is
+     * only used if this request is submitted as part of a batched request. It can be used to specified dependencies
+     * between requests. See <a href="https://developers.facebook.com/docs/reference/api/batch/">Batch Requests</a> in
+     * the Graph API documentation for more details.
+     *
+     * @param batchEntryDependsOn
+     *            the name of the request entry that this entry depends on in a batched request
+     */
+    public final void setBatchEntryDependsOn(String batchEntryDependsOn) {
+        this.batchEntryDependsOn = batchEntryDependsOn;
+    }
+
+
+    /**
+     * Returns whether or not this batch entry will return a response if it is successful. Only applies if another
+     * request entry in the batch specifies this entry as a dependency.
+     *
+     * @return the name of this request's dependency, or null if none has been specified
+     */
+    public final boolean getBatchEntryOmitResultOnSuccess() {
+        return this.batchEntryOmitResultOnSuccess;
+    }
+
+    /**
+     * Sets whether or not this batch entry will return a response if it is successful. Only applies if another
+     * request entry in the batch specifies this entry as a dependency. See
+     * <a href="https://developers.facebook.com/docs/reference/api/batch/">Batch Requests</a> in the Graph API
+     * documentation for more details.
+     *
+     * @param batchEntryOmitResultOnSuccess
+     *            the name of the request entry that this entry depends on in a batched request
+     */
+    public final void setBatchEntryOmitResultOnSuccess(boolean batchEntryOmitResultOnSuccess) {
+        this.batchEntryOmitResultOnSuccess = batchEntryOmitResultOnSuccess;
+    }
+
+    /**
+     * Gets the default Facebook application ID that will be used to submit batched requests if none of those requests
+     * specifies a Session. Batched requests require an application ID, so either at least one request in a batch must
+     * specify a Session or the application ID must be specified explicitly.
+     * 
+     * @return the Facebook application ID to use for batched requests if none can be determined
+     */
+    public static final String getDefaultBatchApplicationId() {
+        return Request.defaultBatchApplicationId;
+    }
+
+    /**
+     * Sets the default application ID that will be used to submit batched requests if none of those requests specifies
+     * a Session. Batched requests require an application ID, so either at least one request in a batch must specify a
+     * Session or the application ID must be specified explicitly.
+     * 
+     * @param applicationId
+     *            the Facebook application ID to use for batched requests if none can be determined
+     */
+    public static final void setDefaultBatchApplicationId(String applicationId) {
+        Request.defaultBatchApplicationId = applicationId;
+    }
+
+    /**
+     * Returns the callback which will be called when the request finishes.
+     * 
+     * @return the callback
+     */
+    public final Callback getCallback() {
+        return callback;
+    }
+
+    /**
+     * Sets the callback which will be called when the request finishes.
+     * 
+     * @param callback
+     *            the callback
+     */
+    public final void setCallback(Callback callback) {
+        this.callback = callback;
+    }
+
+    /**
+     * Starts a new Request configured to post a GraphObject to a particular graph path, to either create or update the
+     * object at that path.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param graphPath
+     *            the graph path to retrieve, create, or delete
+     * @param graphObject
+     *            the GraphObject to create or update
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executePostRequestAsync(Session session, String graphPath, GraphObject graphObject,
+            Callback callback) {
+        return newPostRequest(session, graphPath,graphObject, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to make a call to the Facebook REST API.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param restMethod
+     *            the method in the Facebook REST API to execute
+     * @param parameters
+     *            additional parameters to pass along with the Graph API request; parameters must be Strings, Numbers,
+     *            Bitmaps, Dates, or Byte arrays.
+     * @param httpMethod
+     *            the HTTP method to use for the request; must be one of GET, POST, or DELETE
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeRestRequestAsync(Session session, String restMethod, Bundle parameters,
+            HttpMethod httpMethod) {
+        return newRestRequest(session, restMethod, parameters, httpMethod).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a user's own profile.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeMeRequestAsync(Session session, GraphUserCallback callback) {
+        return newMeRequest(session, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a user's friend list.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeMyFriendsRequestAsync(Session session, GraphUserListCallback callback) {
+        return newMyFriendsRequest(session, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to upload a photo to the user's default photo album.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param image
+     *            the image to upload
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeUploadPhotoRequestAsync(Session session, Bitmap image, Callback callback) {
+        return newUploadPhotoRequest(session, image, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to upload a photo to the user's default photo album. The photo
+     * will be read from the specified stream.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session  the Session to use, or null; if non-null, the session must be in an opened state
+     * @param file     the file containing the photo to upload
+     * @param callback a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeUploadPhotoRequestAsync(Session session, File file,
+            Callback callback) throws FileNotFoundException {
+        return newUploadPhotoRequest(session, file, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a particular graph path.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param graphPath
+     *            the graph path to retrieve
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeGraphPathRequestAsync(Session session, String graphPath, Callback callback) {
+        return newGraphPathRequest(session, graphPath, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request that is configured to perform a search for places near a specified location via the Graph
+     * API.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param location
+     *            the location around which to search; only the latitude and longitude components of the location are
+     *            meaningful
+     * @param radiusInMeters
+     *            the radius around the location to search, specified in meters
+     * @param resultsLimit
+     *            the maximum number of results to return
+     * @param searchText
+     *            optional text to search for as part of the name or type of an object
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     *
+     * @throws FacebookException If neither location nor searchText is specified
+     */
+    public static RequestAsyncTask executePlacesSearchRequestAsync(Session session, Location location, int radiusInMeters,
+            int resultsLimit, String searchText, GraphPlaceListCallback callback) {
+        return newPlacesSearchRequest(session, location, radiusInMeters, resultsLimit, searchText, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to post a status update to a user's feed.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param message
+     *            the text of the status update
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeStatusUpdateRequestAsync(Session session, String message, Callback callback) {
+        return newStatusUpdateRequest(session, message, callback).executeAsync();
+    }
+
+    /**
+     * Executes this request and returns the response.
+     * <p/>
+     * This should only be called if you have transitioned off the UI thread.
+     *
+     * @return the Response object representing the results of the request
+     *
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     * @throws IllegalArgumentException
+     */
+    public final Response executeAndWait() {
+        return Request.executeAndWait(this);
+    }
+
+    /**
+     * Executes this request and returns the response.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @return a RequestAsyncTask that is executing the request
+     *
+     * @throws IllegalArgumentException
+     */
+    public final RequestAsyncTask executeAsync() {
+        return Request.executeBatchAsync(this);
+    }
+
+    /**
+     * Serializes one or more requests but does not execute them. The resulting HttpURLConnection can be executed
+     * explicitly by the caller.
+     * 
+     * @param requests
+     *            one or more Requests to serialize
+     * @return an HttpURLConnection which is ready to execute
+     *
+     * @throws FacebookException
+     *            If any of the requests in the batch are badly constructed or if there are problems
+     *            contacting the service
+     * @throws IllegalArgumentException if the passed in array is zero-length
+     * @throws NullPointerException if the passed in array or any of its contents are null
+     */
+    public static HttpURLConnection toHttpConnection(Request... requests) {
+        return toHttpConnection(Arrays.asList(requests));
+    }
+
+    /**
+     * Serializes one or more requests but does not execute them. The resulting HttpURLConnection can be executed
+     * explicitly by the caller.
+     *
+     * @param requests
+     *            one or more Requests to serialize
+     * @return an HttpURLConnection which is ready to execute
+     *
+     * @throws FacebookException
+     *            If any of the requests in the batch are badly constructed or if there are problems
+     *            contacting the service
+     * @throws IllegalArgumentException if the passed in collection is empty
+     * @throws NullPointerException if the passed in collection or any of its contents are null
+     */
+    public static HttpURLConnection toHttpConnection(Collection<Request> requests) {
+        Validate.notEmptyAndContainsNoNulls(requests, "requests");
+
+        return toHttpConnection(new RequestBatch(requests));
+    }
+
+
+    /**
+     * Serializes one or more requests but does not execute them. The resulting HttpURLConnection can be executed
+     * explicitly by the caller.
+     *
+     * @param requests
+     *            a RequestBatch to serialize
+     * @return an HttpURLConnection which is ready to execute
+     *
+     * @throws FacebookException
+     *            If any of the requests in the batch are badly constructed or if there are problems
+     *            contacting the service
+     * @throws IllegalArgumentException
+     */
+    public static HttpURLConnection toHttpConnection(RequestBatch requests) {
+
+        for (Request request : requests) {
+            request.validate();
+        }
+
+        URL url = null;
+        try {
+            if (requests.size() == 1) {
+                // Single request case.
+                Request request = requests.get(0);
+                url = request.getUrlForSingleRequest();
+            } else {
+                // Batch case -- URL is just the graph API base, individual request URLs are serialized
+                // as relative_url parameters within each batch entry.
+                url = new URL(ServerProtocol.GRAPH_URL);
+            }
+        } catch (MalformedURLException e) {
+            throw new FacebookException("could not construct URL for request", e);
+        }
+
+        HttpURLConnection connection;
+        try {
+            connection = createConnection(url);
+
+            serializeToUrlConnection(requests, connection);
+        } catch (IOException e) {
+            throw new FacebookException("could not construct request body", e);
+        } catch (JSONException e) {
+            throw new FacebookException("could not construct request body", e);
+        }
+
+        return connection;
+    }
+
+    /**
+     * Executes a single request on the current thread and returns the response.
+     * <p/>
+     * This should only be used if you have transitioned off the UI thread.
+     * 
+     * @param request
+     *            the Request to execute
+     * 
+     * @return the Response object representing the results of the request
+     *
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     */
+    public static Response executeAndWait(Request request) {
+        List<Response> responses = executeBatchAndWait(request);
+
+        if (responses == null || responses.size() != 1) {
+            throw new FacebookException("invalid state: expected a single response");
+        }
+
+        return responses.get(0);
+    }
+
+    /**
+     * Executes requests on the current thread as a single batch and returns the responses.
+     * <p/>
+     * This should only be used if you have transitioned off the UI thread.
+     *
+     * @param requests
+     *            the Requests to execute
+     * 
+     * @return a list of Response objects representing the results of the requests; responses are returned in the same
+     *         order as the requests were specified.
+     *
+     * @throws NullPointerException
+     *            In case of a null request
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     */
+    public static List<Response> executeBatchAndWait(Request... requests) {
+        Validate.notNull(requests, "requests");
+
+        return executeBatchAndWait(Arrays.asList(requests));
+    }
+
+    /**
+     * Executes requests as a single batch on the current thread and returns the responses.
+     * <p/>
+     * This should only be used if you have transitioned off the UI thread.
+     *
+     * @param requests
+     *            the Requests to execute
+     *
+     * @return a list of Response objects representing the results of the requests; responses are returned in the same
+     *         order as the requests were specified.
+     *
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     */
+    public static List<Response> executeBatchAndWait(Collection<Request> requests) {
+        return executeBatchAndWait(new RequestBatch(requests));
+    }
+
+    /**
+     * Executes requests on the current thread as a single batch and returns the responses.
+     * <p/>
+     * This should only be used if you have transitioned off the UI thread.
+     *
+     * @param requests
+     *            the batch of Requests to execute
+     *
+     * @return a list of Response objects representing the results of the requests; responses are returned in the same
+     *         order as the requests were specified.
+     *
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     * @throws IllegalArgumentException if the passed in RequestBatch is empty
+     * @throws NullPointerException if the passed in RequestBatch or any of its contents are null
+     */
+    public static List<Response> executeBatchAndWait(RequestBatch requests) {
+        Validate.notEmptyAndContainsNoNulls(requests, "requests");
+
+        HttpURLConnection connection = null;
+        try {
+            connection = toHttpConnection(requests);
+        } catch (Exception ex) {
+            List<Response> responses = Response.constructErrorResponses(requests.getRequests(), null, new FacebookException(ex));
+            runCallbacks(requests, responses);
+            return responses;
+        }
+
+        List<Response> responses = executeConnectionAndWait(connection, requests);
+        return responses;
+    }
+
+    /**
+     * Executes requests as a single batch asynchronously. This function will return immediately, and the requests will
+     * be processed on a separate thread. In order to process results of a request, or determine whether a request
+     * succeeded or failed, a callback must be specified (see the {@link #setCallback(Callback) setCallback} method).
+     * <p/>
+     * This should only be called from the UI thread.
+     * 
+     * @param requests
+     *            the Requests to execute
+     * @return a RequestAsyncTask that is executing the request
+     *
+     * @throws NullPointerException
+     *            If a null request is passed in
+     */
+    public static RequestAsyncTask executeBatchAsync(Request... requests) {
+        Validate.notNull(requests, "requests");
+
+        return executeBatchAsync(Arrays.asList(requests));
+    }
+
+    /**
+     * Executes requests as a single batch asynchronously. This function will return immediately, and the requests will
+     * be processed on a separate thread. In order to process results of a request, or determine whether a request
+     * succeeded or failed, a callback must be specified (see the {@link #setCallback(Callback) setCallback} method).
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param requests
+     *            the Requests to execute
+     * @return a RequestAsyncTask that is executing the request
+     *
+     * @throws IllegalArgumentException if the passed in collection is empty
+     * @throws NullPointerException if the passed in collection or any of its contents are null
+     */
+    public static RequestAsyncTask executeBatchAsync(Collection<Request> requests) {
+        return executeBatchAsync(new RequestBatch(requests));
+    }
+
+    /**
+     * Executes requests as a single batch asynchronously. This function will return immediately, and the requests will
+     * be processed on a separate thread. In order to process results of a request, or determine whether a request
+     * succeeded or failed, a callback must be specified (see the {@link #setCallback(Callback) setCallback} method).
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param requests
+     *            the RequestBatch to execute
+     * @return a RequestAsyncTask that is executing the request
+     *
+     * @throws IllegalArgumentException if the passed in RequestBatch is empty
+     * @throws NullPointerException if the passed in RequestBatch or any of its contents are null
+     */
+    public static RequestAsyncTask executeBatchAsync(RequestBatch requests) {
+        Validate.notEmptyAndContainsNoNulls(requests, "requests");
+
+        RequestAsyncTask asyncTask = new RequestAsyncTask(requests);
+        asyncTask.execute();
+        return asyncTask;
+    }
+
+    /**
+     * Executes requests that have already been serialized into an HttpURLConnection. No validation is done that the
+     * contents of the connection actually reflect the serialized requests, so it is the caller's responsibility to
+     * ensure that it will correctly generate the desired responses.
+     * <p/>
+     * This should only be called if you have transitioned off the UI thread.
+     *
+     * @param connection
+     *            the HttpURLConnection that the requests were serialized into
+     * @param requests
+     *            the requests represented by the HttpURLConnection
+     * @return a list of Responses corresponding to the requests
+     *
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     */
+    public static List<Response> executeConnectionAndWait(HttpURLConnection connection, Collection<Request> requests) {
+        return executeConnectionAndWait(connection, new RequestBatch(requests));
+    }
+
+    /**
+     * Executes requests that have already been serialized into an HttpURLConnection. No validation is done that the
+     * contents of the connection actually reflect the serialized requests, so it is the caller's responsibility to
+     * ensure that it will correctly generate the desired responses.
+     * <p/>
+     * This should only be called if you have transitioned off the UI thread.
+     *
+     * @param connection
+     *            the HttpURLConnection that the requests were serialized into
+     * @param requests
+     *            the RequestBatch represented by the HttpURLConnection
+     * @return a list of Responses corresponding to the requests
+     *
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     */
+    public static List<Response> executeConnectionAndWait(HttpURLConnection connection, RequestBatch requests) {
+        List<Response> responses = Response.fromHttpConnection(connection, requests);
+
+        Utility.disconnectQuietly(connection);
+
+        int numRequests = requests.size();
+        if (numRequests != responses.size()) {
+            throw new FacebookException(String.format("Received %d responses while expecting %d", responses.size(),
+                    numRequests));
+        }
+
+        runCallbacks(requests, responses);
+
+        // See if any of these sessions needs its token to be extended. We do this after issuing the request so as to
+        // reduce network contention.
+        HashSet<Session> sessions = new HashSet<Session>();
+        for (Request request : requests) {
+            if (request.session != null) {
+                sessions.add(request.session);
+            }
+        }
+        for (Session session : sessions) {
+            session.extendAccessTokenIfNeeded();
+        }
+
+        return responses;
+    }
+
+    /**
+     * Asynchronously executes requests that have already been serialized into an HttpURLConnection. No validation is
+     * done that the contents of the connection actually reflect the serialized requests, so it is the caller's
+     * responsibility to ensure that it will correctly generate the desired responses. This function will return
+     * immediately, and the requests will be processed on a separate thread. In order to process results of a request,
+     * or determine whether a request succeeded or failed, a callback must be specified (see the
+     * {@link #setCallback(Callback) setCallback} method).
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param connection
+     *            the HttpURLConnection that the requests were serialized into
+     * @param requests
+     *            the requests represented by the HttpURLConnection
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeConnectionAsync(HttpURLConnection connection, RequestBatch requests) {
+        return executeConnectionAsync(null, connection, requests);
+    }
+
+    /**
+     * Asynchronously executes requests that have already been serialized into an HttpURLConnection. No validation is
+     * done that the contents of the connection actually reflect the serialized requests, so it is the caller's
+     * responsibility to ensure that it will correctly generate the desired responses. This function will return
+     * immediately, and the requests will be processed on a separate thread. In order to process results of a request,
+     * or determine whether a request succeeded or failed, a callback must be specified (see the
+     * {@link #setCallback(Callback) setCallback} method)
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param callbackHandler
+     *            a Handler that will be used to post calls to the callback for each request; if null, a Handler will be
+     *            instantiated on the calling thread
+     * @param connection
+     *            the HttpURLConnection that the requests were serialized into
+     * @param requests
+     *            the requests represented by the HttpURLConnection
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeConnectionAsync(Handler callbackHandler, HttpURLConnection connection,
+            RequestBatch requests) {
+        RequestAsyncTask asyncTask = new RequestAsyncTask(connection, requests);
+        requests.setCallbackHandler(callbackHandler);
+        asyncTask.execute();
+        return asyncTask;
+    }
+
+    /**
+     * Returns a string representation of this Request, useful for debugging.
+     * 
+     * @return the debugging information
+     */
+    @Override
+    public String toString() {
+        return new StringBuilder().append("{Request: ").append(" session: ").append(session).append(", graphPath: ")
+                .append(graphPath).append(", graphObject: ").append(graphObject).append(", restMethod: ")
+                .append(restMethod).append(", httpMethod: ").append(httpMethod).append(", parameters: ")
+                .append(parameters).append("}").toString();
+    }
+
+    private static void runCallbacks(RequestBatch requests, List<Response> responses) {
+        int numRequests = requests.size();
+
+        // Compile the list of callbacks to call and then run them either on this thread or via the Handler we received
+        final ArrayList<Pair<Callback, Response>> callbacks = new ArrayList<Pair<Callback, Response>>();
+        for (int i = 0; i < numRequests; ++i) {
+            Request request = requests.get(i);
+            if (request.callback != null) {
+                callbacks.add(new Pair<Callback, Response>(request.callback, responses.get(i)));
+            }
+        }
+
+        if (callbacks.size() > 0) {
+            Runnable runnable = new Runnable() {
+                public void run() {
+                    for (Pair<Callback, Response> pair : callbacks) {
+                        pair.first.onCompleted(pair.second);
+                    }
+                }
+            };
+
+            Handler callbackHandler = requests.getCallbackHandler();
+            if (callbackHandler == null) {
+                // Run on this thread.
+                runnable.run();
+            } else {
+                // Post to the handler.
+                callbackHandler.post(runnable);
+            }
+        }
+    }
+
+    static HttpURLConnection createConnection(URL url) throws IOException {
+        HttpURLConnection connection;
+        connection = (HttpURLConnection) url.openConnection();
+
+        connection.setRequestProperty(USER_AGENT_HEADER, getUserAgent());
+        connection.setRequestProperty(CONTENT_TYPE_HEADER, getMimeContentType());
+
+        connection.setChunkedStreamingMode(0);
+        return connection;
+    }
+
+
+    private void addCommonParameters() {
+        if (this.session != null && !this.parameters.containsKey(ACCESS_TOKEN_PARAM)) {
+            String accessToken = this.session.getAccessToken();
+            Logger.registerAccessToken(accessToken);
+            this.parameters.putString(ACCESS_TOKEN_PARAM, accessToken);
+        }
+        this.parameters.putString(SDK_PARAM, SDK_ANDROID);
+        this.parameters.putString(FORMAT_PARAM, FORMAT_JSON);
+    }
+
+    private String appendParametersToBaseUrl(String baseUrl) {
+        Uri.Builder uriBuilder = new Uri.Builder().encodedPath(baseUrl);
+
+        Set<String> keys = this.parameters.keySet();
+        for (String key : keys) {
+            Object value = this.parameters.get(key);
+
+            if (!(value instanceof String)) {
+                if (httpMethod == HttpMethod.GET) {
+                    throw new IllegalArgumentException("Cannot use GET to upload a file.");
+                }
+
+                // Skip non-strings. We add them later as attachments.
+                continue;
+            }
+            uriBuilder.appendQueryParameter(key, value.toString());
+        }
+
+        return uriBuilder.toString();
+    }
+
+    final String getUrlStringForBatchedRequest() throws MalformedURLException {
+        String baseUrl = null;
+        if (this.restMethod != null) {
+            baseUrl = ServerProtocol.BATCHED_REST_METHOD_URL_BASE + this.restMethod;
+        } else {
+            baseUrl = this.graphPath;
+        }
+
+        addCommonParameters();
+        // We don't convert to a URL because it may only be part of a URL.
+        return appendParametersToBaseUrl(baseUrl);
+    }
+
+    final URL getUrlForSingleRequest() throws MalformedURLException {
+        String baseUrl = null;
+        if (this.restMethod != null) {
+            baseUrl = ServerProtocol.REST_URL_BASE + this.restMethod;
+        } else {
+            baseUrl = ServerProtocol.GRAPH_URL_BASE + this.graphPath;
+        }
+
+        addCommonParameters();
+        return new URL(appendParametersToBaseUrl(baseUrl));
+    }
+
+    private void serializeToBatch(JSONArray batch, Bundle attachments) throws JSONException, IOException {
+        JSONObject batchEntry = new JSONObject();
+
+        if (this.batchEntryName != null) {
+            batchEntry.put(BATCH_ENTRY_NAME_PARAM, this.batchEntryName);
+            batchEntry.put(BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM, this.batchEntryOmitResultOnSuccess);
+        }
+        if (this.batchEntryDependsOn != null) {
+            batchEntry.put(BATCH_ENTRY_DEPENDS_ON_PARAM, this.batchEntryDependsOn);
+        }
+
+        String relativeURL = getUrlStringForBatchedRequest();
+        batchEntry.put(BATCH_RELATIVE_URL_PARAM, relativeURL);
+        batchEntry.put(BATCH_METHOD_PARAM, httpMethod);
+        if (this.session != null) {
+            String accessToken = this.session.getAccessToken();
+            Logger.registerAccessToken(accessToken);
+        }
+
+        // Find all of our attachments. Remember their names and put them in the attachment map.
+        ArrayList<String> attachmentNames = new ArrayList<String>();
+        Set<String> keys = this.parameters.keySet();
+        for (String key : keys) {
+            Object value = this.parameters.get(key);
+            if (Serializer.isSupportedAttachmentType(value)) {
+                // Make the name unique across this entire batch.
+                String name = String.format("%s%d", ATTACHMENT_FILENAME_PREFIX, attachments.size());
+                attachmentNames.add(name);
+                Utility.putObjectInBundle(attachments, name, value);
+            }
+        }
+
+        if (!attachmentNames.isEmpty()) {
+            String attachmentNamesString = TextUtils.join(",", attachmentNames);
+            batchEntry.put(ATTACHED_FILES_PARAM, attachmentNamesString);
+        }
+
+        if (this.graphObject != null) {
+            // Serialize the graph object into the "body" parameter.
+            final ArrayList<String> keysAndValues = new ArrayList<String>();
+            processGraphObject(this.graphObject, relativeURL, new KeyValueSerializer() {
+                @Override
+                public void writeString(String key, String value) throws IOException {
+                    keysAndValues.add(String.format("%s=%s", key, URLEncoder.encode(value, "UTF-8")));
+                }
+            });
+            String bodyValue = TextUtils.join("&", keysAndValues);
+            batchEntry.put(BATCH_BODY_PARAM, bodyValue);
+        }
+
+        batch.put(batchEntry);
+    }
+
+    private void validate() {
+        if (graphPath != null && restMethod != null) {
+            throw new IllegalArgumentException("Only one of a graph path or REST method may be specified per request.");
+        }
+    }
+
+    final static void serializeToUrlConnection(RequestBatch requests, HttpURLConnection connection)
+    throws IOException, JSONException {
+        Logger logger = new Logger(LoggingBehaviors.REQUESTS, "Request");
+
+        int numRequests = requests.size();
+
+        HttpMethod connectionHttpMethod = (numRequests == 1) ? requests.get(0).httpMethod : HttpMethod.POST;
+        connection.setRequestMethod(connectionHttpMethod.name());
+
+        URL url = connection.getURL();
+        logger.append("Request:\n");
+        logger.appendKeyValue("Id", requests.getId());
+        logger.appendKeyValue("URL", url);
+        logger.appendKeyValue("Method", connection.getRequestMethod());
+        logger.appendKeyValue("User-Agent", connection.getRequestProperty("User-Agent"));
+        logger.appendKeyValue("Content-Type", connection.getRequestProperty("Content-Type"));
+
+        connection.setConnectTimeout(requests.getTimeout());
+        connection.setReadTimeout(requests.getTimeout());
+
+        // If we have a single non-POST request, don't try to serialize anything or HttpURLConnection will
+        // turn it into a POST.
+        boolean isPost = (connectionHttpMethod == HttpMethod.POST);
+        if (!isPost) {
+            logger.log();
+            return;
+        }
+
+        connection.setDoOutput(true);
+
+        BufferedOutputStream outputStream = new BufferedOutputStream(connection.getOutputStream());
+        try {
+            Serializer serializer = new Serializer(outputStream, logger);
+
+            if (numRequests == 1) {
+                Request request = requests.get(0);
+
+                logger.append("  Parameters:\n");
+                serializeParameters(request.parameters, serializer);
+
+                logger.append("  Attachments:\n");
+                serializeAttachments(request.parameters, serializer);
+
+                if (request.graphObject != null) {
+                    processGraphObject(request.graphObject, url.getPath(), serializer);
+                }
+            } else {
+                String batchAppID = getBatchAppId(requests);
+                if (Utility.isNullOrEmpty(batchAppID)) {
+                    throw new FacebookException("At least one request in a batch must have an open Session, or a "
+                            + "default app ID must be specified.");
+                }
+
+                serializer.writeString(BATCH_APP_ID_PARAM, batchAppID);
+
+                // We write out all the requests as JSON, remembering which file attachments they have, then
+                // write out the attachments.
+                Bundle attachments = new Bundle();
+                serializeRequestsAsJSON(serializer, requests, attachments);
+
+                logger.append("  Attachments:\n");
+                serializeAttachments(attachments, serializer);
+            }
+        } finally {
+            outputStream.close();
+        }
+
+        logger.log();
+    }
+
+    private static void processGraphObject(GraphObject graphObject, String path, KeyValueSerializer serializer)
+            throws IOException {
+        // In general, graph objects are passed by reference (ID/URL). But if this is an OG Action,
+        // we need to pass the entire values of the contents of the 'image' property, as they
+        // contain important metadata beyond just a URL. We don't have a 100% foolproof way of knowing
+        // if we are posting an OG Action, given that batched requests can have parameter substitution,
+        // but passing the OG Action type as a substituted parameter is unlikely.
+        // It looks like an OG Action if it's posted to me/namespace:action[?other=stuff].
+        boolean isOGAction = false;
+        if (path.startsWith("me/") || path.startsWith("/me/")) {
+            int colonLocation = path.indexOf(":");
+            int questionMarkLocation = path.indexOf("?");
+            isOGAction = colonLocation > 3 && (questionMarkLocation == -1 || colonLocation < questionMarkLocation);
+        }
+
+        Set<Entry<String, Object>> entries = graphObject.asMap().entrySet();
+        for (Entry<String, Object> entry : entries) {
+            boolean passByValue = isOGAction && entry.getKey().equalsIgnoreCase("image");
+            processGraphObjectProperty(entry.getKey(), entry.getValue(), serializer, passByValue);
+        }
+    }
+
+    private static void processGraphObjectProperty(String key, Object value, KeyValueSerializer serializer,
+            boolean passByValue) throws IOException {
+        Class<?> valueClass = value.getClass();
+        if (GraphObject.class.isAssignableFrom(valueClass)) {
+            value = ((GraphObject) value).getInnerJSONObject();
+            valueClass = value.getClass();
+        } else if (GraphObjectList.class.isAssignableFrom(valueClass)) {
+            value = ((GraphObjectList<?>) value).getInnerJSONArray();
+            valueClass = value.getClass();
+        }
+
+        if (JSONObject.class.isAssignableFrom(valueClass)) {
+            JSONObject jsonObject = (JSONObject) value;
+            if (passByValue) {
+                // We need to pass all properties of this object in key[propertyName] format.
+                @SuppressWarnings("unchecked")
+                Iterator<String> keys = jsonObject.keys();
+                while (keys.hasNext()) {
+                    String propertyName = keys.next();
+                    String subKey = String.format("%s[%s]", key, propertyName);
+                    processGraphObjectProperty(subKey, jsonObject.opt(propertyName), serializer, passByValue);
+                }
+            } else {
+                // Normal case is passing objects by reference, so just pass the ID or URL, if any, as the value
+                // for "key"
+                if (jsonObject.has("id")) {
+                    processGraphObjectProperty(key, jsonObject.optString("id"), serializer, passByValue);
+                } else if (jsonObject.has("url")) {
+                    processGraphObjectProperty(key, jsonObject.optString("url"), serializer, passByValue);
+                }
+            }
+        } else if (JSONArray.class.isAssignableFrom(valueClass)) {
+            JSONArray jsonArray = (JSONArray) value;
+            int length = jsonArray.length();
+            for (int i = 0; i < length; ++i) {
+                String subKey = String.format("%s[%d]", key, i);
+                processGraphObjectProperty(subKey, jsonArray.opt(i), serializer, passByValue);
+            }
+        } else if (String.class.isAssignableFrom(valueClass) ||
+                Number.class.isAssignableFrom(valueClass) ||
+                Boolean.class.isAssignableFrom(valueClass)) {
+            serializer.writeString(key, value.toString());
+        } else if (Date.class.isAssignableFrom(valueClass)) {
+            Date date = (Date) value;
+            // The "Events Timezone" platform migration affects what date/time formats Facebook accepts and returns.
+            // Apps created after 8/1/12 (or apps that have explicitly enabled the migration) should send/receive
+            // dates in ISO-8601 format. Pre-migration apps can send as Unix timestamps. Since the future is ISO-8601,
+            // that is what we support here. Apps that need pre-migration behavior can explicitly send these as
+            // integer timestamps rather than Dates.
+            serializer.writeString(key, iso8601DateFormat.format(date));
+        }
+    }
+
+    private static void serializeParameters(Bundle bundle, Serializer serializer) throws IOException {
+        Set<String> keys = bundle.keySet();
+
+        for (String key : keys) {
+            Object value = bundle.get(key);
+            if (Serializer.isSupportedParameterType(value)) {
+                serializer.writeObject(key, value);
+            }
+        }
+    }
+
+    private static void serializeAttachments(Bundle bundle, Serializer serializer) throws IOException {
+        Set<String> keys = bundle.keySet();
+
+        for (String key : keys) {
+            Object value = bundle.get(key);
+            if (Serializer.isSupportedAttachmentType(value)) {
+                serializer.writeObject(key, value);
+            }
+        }
+    }
+
+    private static void serializeRequestsAsJSON(Serializer serializer, Collection<Request> requests, Bundle attachments)
+            throws JSONException, IOException {
+        JSONArray batch = new JSONArray();
+        for (Request request : requests) {
+            request.serializeToBatch(batch, attachments);
+        }
+
+        String batchAsString = batch.toString();
+        serializer.writeString(BATCH_PARAM, batchAsString);
+    }
+
+    private static String getMimeContentType() {
+        return String.format("multipart/form-data; boundary=%s", MIME_BOUNDARY);
+    }
+
+    private static volatile String userAgent;
+
+    private static String getUserAgent() {
+        if (userAgent == null) {
+            userAgent = String.format("%s.%s", USER_AGENT_BASE, FacebookSdkVersion.BUILD);
+        }
+
+        return userAgent;
+    }
+
+    private static String getBatchAppId(Collection<Request> requests) {
+        for (Request request : requests) {
+            Session session = request.session;
+            if (session != null) {
+                return session.getApplicationId();
+            }
+        }
+        return Request.defaultBatchApplicationId;
+    }
+
+    private static <T extends GraphObject> List<T> typedListFromResponse(Response response, Class<T> clazz) {
+        GraphMultiResult multiResult = response.getGraphObjectAs(GraphMultiResult.class);
+        if (multiResult == null) {
+            return null;
+        }
+
+        GraphObjectList<GraphObject> data = multiResult.getData();
+        if (data == null) {
+            return null;
+        }
+
+        return data.castToListOf(clazz);
+    }
+
+    private interface KeyValueSerializer {
+        void writeString(String key, String value) throws IOException;
+    }
+
+    private static class Serializer implements KeyValueSerializer {
+        private final BufferedOutputStream outputStream;
+        private final Logger logger;
+        private boolean firstWrite = true;
+
+        public Serializer(BufferedOutputStream outputStream, Logger logger) {
+            this.outputStream = outputStream;
+            this.logger = logger;
+        }
+
+        public void writeObject(String key, Object value) throws IOException {
+            if (value instanceof String) {
+                writeString(key, (String) value);
+            } else if (value instanceof Bitmap) {
+                writeBitmap(key, (Bitmap) value);
+            } else if (value instanceof byte[]) {
+                writeBytes(key, (byte[]) value);
+            } else if (value instanceof ParcelFileDescriptor) {
+                writeFile(key, (ParcelFileDescriptor) value);
+            } else {
+                throw new IllegalArgumentException("value is not a supported type: String, Bitmap, byte[]");
+            }
+        }
+
+        public void writeString(String key, String value) throws IOException {
+            writeContentDisposition(key, null, null);
+            writeLine("%s", value);
+            writeRecordBoundary();
+            if (logger != null) {
+                logger.appendKeyValue("    " + key, value);
+            }
+        }
+
+        public void writeBitmap(String key, Bitmap bitmap) throws IOException {
+            writeContentDisposition(key, key, "image/png");
+            // Note: quality parameter is ignored for PNG
+            bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream);
+            writeLine("");
+            writeRecordBoundary();
+            logger.appendKeyValue("    " + key, "<Image>");
+        }
+
+        public void writeBytes(String key, byte[] bytes) throws IOException {
+            writeContentDisposition(key, key, "content/unknown");
+            this.outputStream.write(bytes);
+            writeLine("");
+            writeRecordBoundary();
+            logger.appendKeyValue("    " + key, String.format("<Data: %d>", bytes.length));
+        }
+
+        public void writeFile(String key, ParcelFileDescriptor descriptor) throws IOException {
+            writeContentDisposition(key, key, "content/unknown");
+
+            ParcelFileDescriptor.AutoCloseInputStream inputStream = null;
+            BufferedInputStream bufferedInputStream = null;
+            int totalBytes = 0;
+            try {
+                inputStream = new ParcelFileDescriptor.AutoCloseInputStream(descriptor);
+                bufferedInputStream = new BufferedInputStream(inputStream);
+
+                byte[] buffer = new byte[8192];
+                int bytesRead;
+                while ((bytesRead = bufferedInputStream.read(buffer)) != -1) {
+                    this.outputStream.write(buffer, 0, bytesRead);
+                    totalBytes += bytesRead;
+                }
+            } finally {
+                if (bufferedInputStream != null) {
+                    bufferedInputStream.close();
+                }
+                if (inputStream != null) {
+                    inputStream.close();
+                }
+            }
+            writeLine("");
+            writeRecordBoundary();
+            logger.appendKeyValue("    " + key, String.format("<Data: %d>", totalBytes));
+        }
+
+        public void writeRecordBoundary() throws IOException {
+            writeLine("--%s", MIME_BOUNDARY);
+        }
+
+        public void writeContentDisposition(String name, String filename, String contentType) throws IOException {
+            write("Content-Disposition: form-data; name=\"%s\"", name);
+            if (filename != null) {
+                write("; filename=\"%s\"", filename);
+            }
+            writeLine(""); // newline after Content-Disposition
+            if (contentType != null) {
+                writeLine("%s: %s", CONTENT_TYPE_HEADER, contentType);
+            }
+            writeLine(""); // blank line before content
+        }
+
+        public void write(String format, Object... args) throws IOException {
+            if (firstWrite) {
+                // Prepend all of our output with a boundary string.
+                this.outputStream.write("--".getBytes());
+                this.outputStream.write(MIME_BOUNDARY.getBytes());
+                this.outputStream.write("\r\n".getBytes());
+                firstWrite = false;
+            }
+            this.outputStream.write(String.format(format, args).getBytes());
+        }
+
+        public void writeLine(String format, Object... args) throws IOException {
+            write(format, args);
+            write("\r\n");
+        }
+
+        public static boolean isSupportedAttachmentType(Object value) {
+            return value instanceof Bitmap || value instanceof byte[] || value instanceof ParcelFileDescriptor;
+        }
+
+        public static boolean isSupportedParameterType(Object value) {
+            return value instanceof String;
+        }
+
+    }
+
+    /**
+     * Specifies the interface that consumers of the Request class can implement in order to be notified when a
+     * particular request completes, either successfully or with an error.
+     */
+    public interface Callback {
+        /**
+         * The method that will be called when a request completes.
+         * 
+         * @param response
+         *            the Response of this request, which may include error information if the request was unsuccessful
+         */
+        void onCompleted(Response response);
+    }
+
+    /**
+     * Specifies the interface that consumers of
+     * {@link Request#executeMeRequestAsync(Session, com.facebook.Request.GraphUserCallback)}
+     * can use to be notified when the request completes, either successfully or with an error.
+     */
+    public interface GraphUserCallback {
+        /**
+         * The method that will be called when the request completes.
+         *
+         * @param user     the GraphObject representing the returned user, or null
+         * @param response the Response of this request, which may include error information if the request was unsuccessful
+         */
+        void onCompleted(GraphUser user, Response response);
+    }
+
+    /**
+     * Specifies the interface that consumers of
+     * {@link Request#executeMyFriendsRequestAsync(Session, com.facebook.Request.GraphUserListCallback)}
+     * can use to be notified when the request completes, either successfully or with an error.
+     */
+    public interface GraphUserListCallback {
+        /**
+         * The method that will be called when the request completes.
+         *
+         * @param users    the list of GraphObjects representing the returned friends, or null
+         * @param response the Response of this request, which may include error information if the request was unsuccessful
+         */
+        void onCompleted(List<GraphUser> users, Response response);
+    }
+
+    /**
+     * Specifies the interface that consumers of
+     * {@link Request#executePlacesSearchRequestAsync(Session, android.location.Location, int, int, String, com.facebook.Request.GraphPlaceListCallback)}
+     * can use to be notified when the request completes, either successfully or with an error.
+     */
+    public interface GraphPlaceListCallback {
+        /**
+         * The method that will be called when the request completes.
+         *
+         * @param places   the list of GraphObjects representing the returned places, or null
+         * @param response the Response of this request, which may include error information if the request was unsuccessful
+         */
+        void onCompleted(List<GraphPlace> places, Response response);
+    }
+}
diff --git a/facebook/src/com/facebook/RequestAsyncTask.java b/facebook/src/com/facebook/RequestAsyncTask.java
new file mode 100644
index 000000000..66bdec673
--- /dev/null
+++ b/facebook/src/com/facebook/RequestAsyncTask.java
@@ -0,0 +1,153 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.annotation.TargetApi;
+import android.os.AsyncTask;
+import android.os.Handler;
+import android.util.Log;
+
+import java.net.HttpURLConnection;
+import java.util.Collection;
+import java.util.List;
+
+/**
+ * Defines an AsyncTask suitable for executing a Request in the background. May be subclassed
+ * by applications having unique threading model needs.
+ */
+@TargetApi(3)
+public class RequestAsyncTask extends AsyncTask<Void, Void, List<Response>> {
+    private static final String TAG = RequestAsyncTask.class.getCanonicalName();
+
+    private final HttpURLConnection connection;
+    private final RequestBatch requests;
+
+    private Exception exception;
+
+    /**
+     * Constructor. Serialization of the requests will be done in the background, so any serialization-
+     * related errors will be returned via the Response.getError() method.
+     *
+     * @param requests the requests to execute
+     */
+    public RequestAsyncTask(Request... requests) {
+        this(null, new RequestBatch(requests));
+    }
+
+    /**
+     * Constructor. Serialization of the requests will be done in the background, so any serialization-
+     * related errors will be returned via the Response.getError() method.
+     *
+     * @param requests the requests to execute
+     */
+    public RequestAsyncTask(Collection<Request> requests) {
+        this(null, new RequestBatch(requests));
+    }
+
+    /**
+     * Constructor. Serialization of the requests will be done in the background, so any serialization-
+     * related errors will be returned via the Response.getError() method.
+     *
+     * @param requests the requests to execute
+     */
+    public RequestAsyncTask(RequestBatch requests) {
+        this(null, requests);
+    }
+
+    /**
+     * Constructor that allows specification of an HTTP connection to use for executing
+     * the requests. No validation is done that the contents of the connection actually
+     * reflect the serialized requests, so it is the caller's responsibility to ensure
+     * that it will correctly generate the desired responses.
+     *
+     * @param connection the HTTP connection to use to execute the requests
+     * @param requests   the requests to execute
+     */
+    public RequestAsyncTask(HttpURLConnection connection, Request... requests) {
+        this(connection, new RequestBatch(requests));
+    }
+
+    /**
+     * Constructor that allows specification of an HTTP connection to use for executing
+     * the requests. No validation is done that the contents of the connection actually
+     * reflect the serialized requests, so it is the caller's responsibility to ensure
+     * that it will correctly generate the desired responses.
+     *
+     * @param connection the HTTP connection to use to execute the requests
+     * @param requests   the requests to execute
+     */
+    public RequestAsyncTask(HttpURLConnection connection, Collection<Request> requests) {
+        this(connection, new RequestBatch(requests));
+    }
+
+    /**
+     * Constructor that allows specification of an HTTP connection to use for executing
+     * the requests. No validation is done that the contents of the connection actually
+     * reflect the serialized requests, so it is the caller's responsibility to ensure
+     * that it will correctly generate the desired responses.
+     *
+     * @param connection the HTTP connection to use to execute the requests
+     * @param requests   the requests to execute
+     */
+    public RequestAsyncTask(HttpURLConnection connection, RequestBatch requests) {
+        this.requests = requests;
+        this.connection = connection;
+    }
+
+    protected final Exception getException() {
+        return exception;
+    }
+
+    @Override
+    public String toString() {
+        return new StringBuilder().append("{RequestAsyncTask: ").append(" connection: ").append(connection)
+                .append(", requests: ").append(requests).append("}").toString();
+    }
+
+    @Override
+    protected void onPreExecute() {
+        super.onPreExecute();
+
+        if (requests.getCallbackHandler() == null) {
+            // We want any callbacks to go to a handler on this thread unless a handler has already been specified.
+            requests.setCallbackHandler(new Handler());
+        }
+    }
+
+    @Override
+    protected void onPostExecute(List<Response> result) {
+        super.onPostExecute(result);
+
+        if (exception != null) {
+            Log.d(TAG, String.format("onPostExecute: exception encountered during request: ", exception.getMessage()));
+        }
+    }
+
+    @Override
+    protected List<Response> doInBackground(Void... params) {
+        try {
+            if (connection == null) {
+                return Request.executeBatchAndWait(requests);
+            } else {
+                return Request.executeConnectionAndWait(connection, requests);
+            }
+        } catch (Exception e) {
+            exception = e;
+            return null;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/RequestBatch.java b/facebook/src/com/facebook/RequestBatch.java
new file mode 100644
index 000000000..59ce5a043
--- /dev/null
+++ b/facebook/src/com/facebook/RequestBatch.java
@@ -0,0 +1,194 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.os.Handler;
+
+import java.util.AbstractList;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * RequestBatch contains a list of Request objects that can be sent to facebook in a single round-trip.
+ */
+public class RequestBatch extends AbstractList<Request> {
+    private static AtomicInteger idGenerator = new AtomicInteger();
+
+    private String cacheKey;
+    private Handler callbackHandler;
+    private boolean forceRoundTrip;
+    private ArrayList<Request> requests = new ArrayList<Request>();
+    private int timeoutInMilliseconds = 0;
+    private final String id = Integer.valueOf(idGenerator.incrementAndGet()).toString();
+
+    /**
+     * Constructor. Creates an empty batch.
+     */
+    public RequestBatch() {
+        this.requests = new ArrayList<Request>();
+    }
+
+    /**
+     * Constructor.
+     * @param requests the requests to add to the batch
+     */
+    public RequestBatch(Collection<Request> requests) {
+        this.requests = new ArrayList<Request>(requests);
+    }
+
+    /**
+     * Constructor.
+     * @param requests the requests to add to the batch
+     */
+    public RequestBatch(Request... requests) {
+        this.requests = Utility.arrayList(requests);
+    }
+
+    /**
+     * Constructor.
+     * @param requests the requests to add to the batch
+     */
+    public RequestBatch(RequestBatch requests) {
+        this.requests = new ArrayList<Request>(requests);
+        this.cacheKey = requests.cacheKey;
+        this.callbackHandler = requests.callbackHandler;
+        this.forceRoundTrip = requests.forceRoundTrip;
+        this.timeoutInMilliseconds = requests.timeoutInMilliseconds;
+    }
+
+    /**
+     * Gets the timeout to wait for responses from the server before a timeout error occurs.
+     * @return the timeout, in milliseconds; 0 (the default) means do not timeout
+     */
+    public int getTimeout() {
+        return timeoutInMilliseconds;
+    }
+
+    /**
+     * Sets the timeout to wait for responses from the server before a timeout error occurs.
+     * @param timeoutInMilliseconds the timeout, in milliseconds; 0 means do not timeout
+     */
+    public void setTimeout(int timeoutInMilliseconds) {
+        if (timeoutInMilliseconds < 0) {
+            throw new IllegalArgumentException("Argument timeoutInMilliseconds must be >= 0.");
+        }
+        this.timeoutInMilliseconds = timeoutInMilliseconds;
+    }
+
+    @Override
+    public final boolean add(Request request) {
+        return requests.add(request);
+    }
+
+    @Override
+    public final void add(int location, Request request) {
+        requests.add(location, request);
+    }
+
+    @Override
+    public final void clear() {
+        requests.clear();
+    }
+
+    @Override
+    public final Request get(int i) {
+        return requests.get(i);
+    }
+
+    @Override
+    public final Request remove(int location) {
+        return requests.remove(location);
+    }
+
+    @Override
+    public final Request set(int location, Request request) {
+        return requests.set(location, request);
+    }
+
+    @Override
+    public final int size() {
+        return requests.size();
+    }
+
+    final String getId() {
+        return id;
+    }
+
+    final String getCacheKey() {
+        return cacheKey;
+    }
+
+    final void setCacheKey(String cacheKey) {
+        this.cacheKey = cacheKey;
+    }
+
+    final boolean getForceRoundTrip() {
+        return forceRoundTrip;
+    }
+
+    final void setForceRoundTrip(boolean forceRoundTrip) {
+        this.forceRoundTrip = forceRoundTrip;
+    }
+
+    final Handler getCallbackHandler() {
+        return callbackHandler;
+    }
+
+    final void setCallbackHandler(Handler callbackHandler) {
+        this.callbackHandler = callbackHandler;
+    }
+
+    final ArrayList<Request> getRequests() {
+        return requests;
+    }
+
+    /**
+     * Executes this batch on the current thread and returns the responses.
+     * <p/>
+     * This should only be used if you have transitioned off the UI thread.
+     *
+     * @return a list of Response objects representing the results of the requests; responses are returned in the same
+     *         order as the requests were specified.
+     *
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     * @throws IllegalArgumentException if the passed in RequestBatch is empty
+     * @throws NullPointerException if the passed in RequestBatch or any of its contents are null
+     */
+    public final List<Response> executeAndWait() {
+        return Request.executeBatchAndWait(this);
+    }
+
+    /**
+     * Executes this batch asynchronously. This function will return immediately, and the batch will
+     * be processed on a separate thread. In order to process results of a request, or determine
+     * whether a request succeeded or failed, a callback must be specified (see
+     * {@link Request#setCallback(com.facebook.Request.Callback)})
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @return a RequestAsyncTask that is executing the request
+     *
+     * @throws IllegalArgumentException if this batch is empty
+     * @throws NullPointerException if any of the contents of this batch are null
+     */
+    public final RequestAsyncTask executeAsync() {
+        return Request.executeBatchAsync(this);
+    }
+}
diff --git a/facebook/src/com/facebook/Response.java b/facebook/src/com/facebook/Response.java
new file mode 100644
index 000000000..d36b3027f
--- /dev/null
+++ b/facebook/src/com/facebook/Response.java
@@ -0,0 +1,415 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.Context;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.json.JSONTokener;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Encapsulates the response, successful or otherwise, of a call to the Facebook platform.
+ */
+public class Response {
+    private final HttpURLConnection connection;
+    private final GraphObject graphObject;
+    private final GraphObjectList<GraphObject> graphObjectList;
+    private final boolean isFromCache;
+    private final FacebookException error;
+    private final Request request;
+
+    /**
+     * Property name of non-JSON results in the GraphObject. Certain calls to Facebook result in a non-JSON response
+     * (e.g., the string literal "true" or "false"). To present a consistent way of accessing results, these are
+     * represented as a GraphObject with a single string property with this name.
+     */
+    public static final String NON_JSON_RESPONSE_PROPERTY = "FACEBOOK_NON_JSON_RESULT";
+
+    private static final int INVALID_SESSION_FACEBOOK_ERROR_CODE = 190;
+
+    private static final String CODE_KEY = "code";
+    private static final String BODY_KEY = "body";
+    private static final String ERROR_KEY = "error";
+    private static final String ERROR_TYPE_FIELD_KEY = "type";
+    private static final String ERROR_CODE_FIELD_KEY = "code";
+    private static final String ERROR_MESSAGE_FIELD_KEY = "message";
+    private static final String ERROR_CODE_KEY = "error_code";
+    private static final String ERROR_MSG_KEY = "error_msg";
+    private static final String ERROR_REASON_KEY = "error_reason";
+
+    private static final String RESPONSE_LOG_TAG = "Response";
+
+    private static final String RESPONSE_CACHE_TAG = "ResponseCache";
+    private static FileLruCache responseCache;
+
+    private Response(Request request, HttpURLConnection connection, GraphObject graphObject,
+            GraphObjectList<GraphObject> graphObjects, boolean isFromCache) {
+        if (graphObject != null && graphObjects != null) {
+            throw new FacebookException("Expected either a graphObject or multiple graphObjects, but not both.");
+        }
+
+        this.request = request;
+        this.connection = connection;
+        this.graphObject = graphObject;
+        this.graphObjectList = graphObjects;
+        this.isFromCache = isFromCache;
+        this.error = null;
+    }
+
+    private Response(Request request, HttpURLConnection connection, FacebookException error) {
+        this.request = request;
+        this.connection = connection;
+        this.graphObject = null;
+        this.graphObjectList = null;
+        this.isFromCache = false;
+        this.error = error;
+    }
+
+    /**
+     * Returns the error returned for this request, if any.
+     * 
+     * @return the error encountered, or null if the request succeeded
+     */
+    public final FacebookException getError() {
+        return error;
+    }
+
+    /**
+     * The single graph object returned for this request, if any.
+     * 
+     * @return the graph object returned, or null if none was returned (or if the result was a list)
+     */
+    public final GraphObject getGraphObject() {
+        return graphObject;
+    }
+
+    /**
+     * The single graph object returned for this request, if any, cast into a particular type of GraphObject.
+     * 
+     * @param graphObjectClass
+     *            the GraphObject-derived interface to cast the graph object into
+     * @return the graph object returned, or null if none was returned (or if the result was a list)
+     *
+     * @throws FacebookException
+     *            If the passed in Class is not a valid GraphObject interface
+     */
+    public final <T extends GraphObject> T getGraphObjectAs(Class<T> graphObjectClass) {
+        if (graphObject == null) {
+            return null;
+        }
+        if (graphObjectClass == null) {
+            throw new NullPointerException("Must pass in a valid interface that extends GraphObject");
+        }
+        return graphObject.cast(graphObjectClass);
+    }
+
+    /**
+     * The list of graph objects returned for this request, if any.
+     * 
+     * @return the list of graph objects returned, or null if none was returned (or if the result was not a list)
+     */
+    public final GraphObjectList<GraphObject> getGraphObjectList() {
+        return graphObjectList;
+    }
+
+    /**
+     * The list of graph objects returned for this request, if any, cast into a particular type of GraphObject.
+     * 
+     * @param graphObjectClass
+     *            the GraphObject-derived interface to cast the graph objects into
+     * @return the list of graph objects returned, or null if none was returned (or if the result was not a list)
+     *
+     * @throws FacebookException
+     *            If the passed in Class is not a valid GraphObject interface
+     */
+    public final <T extends GraphObject> GraphObjectList<T> getGraphObjectListAs(Class<T> graphObjectClass) {
+        if (graphObjectList == null) {
+            return null;
+        }
+        return graphObjectList.castToListOf(graphObjectClass);
+    }
+
+    /**
+     * Returns the HttpURLConnection that this response was generated from. If the response was retrieved
+     * from the cache, this will be null.
+     * 
+     * @return the connection, or null
+     */
+    public final HttpURLConnection getConnection() {
+        return connection;
+    }
+
+    /**
+     * Returns the request that this response is for.
+     * @return the request that this response is for
+     */
+    public Request getRequest() {
+        return request;
+    }
+
+    /**
+     * Provides a debugging string for this response.
+     */
+    @Override
+    public String toString() {
+        String responseCode;
+        try {
+            responseCode = String.format("%d", (connection != null) ? connection.getResponseCode() : 200);
+        } catch (IOException e) {
+            responseCode = "unknown";
+        }
+
+        return new StringBuilder().append("{Response: ").append(" responseCode: ").append(responseCode)
+                .append(", graphObject: ").append(graphObject).append(", error: ").append(error)
+                .append(", isFromCache:" ).append(isFromCache).append("}")
+                .toString();
+    }
+
+    final boolean getIsFromCache() {
+        return isFromCache;
+    }
+
+    static FileLruCache getResponseCache() {
+        if (responseCache == null) {
+            Context applicationContext = Session.getStaticContext();
+            if (applicationContext != null) {
+                responseCache = new FileLruCache(applicationContext, RESPONSE_CACHE_TAG, new FileLruCache.Limits());
+            }
+        }
+
+        return responseCache;
+    }
+
+    @SuppressWarnings("resource")
+    static List<Response> fromHttpConnection(HttpURLConnection connection, RequestBatch requests) {
+        InputStream stream = null;
+
+        // Try loading from cache.  If that fails, load from the network.
+        FileLruCache cache = getResponseCache();
+        String cacheKey = requests.getCacheKey();
+        if (!requests.getForceRoundTrip() && (cache != null) && (cacheKey != null)) {
+            try {
+                stream = cache.get(cacheKey);
+                if (stream != null) {
+                    return createResponsesFromStream(stream, null, requests, true);
+                }
+            } catch (FacebookException exception) { // retry via roundtrip below
+            } catch (JSONException exception) {
+            } catch (IOException exception) {
+            } finally {
+                Utility.closeQuietly(stream);
+            }
+        }
+
+        // Load from the network, and cache the result if not an error.
+        try {
+            if (connection.getResponseCode() >= 400) {
+                stream = connection.getErrorStream();
+            } else {
+                stream = connection.getInputStream();
+                if ((cache != null) && (cacheKey != null) && (stream != null)) {
+                    InputStream interceptStream = cache.interceptAndPut(cacheKey, stream);
+                    if (interceptStream != null) {
+                        stream = interceptStream;
+                    }
+                }
+            }
+
+            return createResponsesFromStream(stream, connection, requests, false);
+        } catch (FacebookException facebookException) {
+            Logger.log(LoggingBehaviors.REQUESTS, RESPONSE_LOG_TAG, "Response <Error>: %s", facebookException);
+            return constructErrorResponses(requests, connection, facebookException);
+        } catch (JSONException exception) {
+            Logger.log(LoggingBehaviors.REQUESTS, RESPONSE_LOG_TAG, "Response <Error>: %s", exception);
+            return constructErrorResponses(requests, connection, new FacebookException(exception));
+        } catch (IOException exception) {
+            Logger.log(LoggingBehaviors.REQUESTS, RESPONSE_LOG_TAG, "Response <Error>: %s", exception);
+            return constructErrorResponses(requests, connection, new FacebookException(exception));
+        } finally {
+            Utility.closeQuietly(stream);
+        }
+    }
+
+    static List<Response> createResponsesFromStream(InputStream stream, HttpURLConnection connection,
+            RequestBatch requests, boolean isFromCache) throws FacebookException, JSONException, IOException {
+
+        String responseString = Utility.readStreamToString(stream);
+        Logger.log(LoggingBehaviors.INCLUDE_RAW_RESPONSES, RESPONSE_LOG_TAG,
+                "Response (raw)\n  Size: %d\n  Response:\n%s\n", responseString.length(),
+                responseString);
+
+        JSONTokener tokener = new JSONTokener(responseString);
+        Object resultObject = tokener.nextValue();
+
+        List<Response> responses = createResponsesFromObject(connection, requests, resultObject, isFromCache);
+        Logger.log(LoggingBehaviors.REQUESTS, RESPONSE_LOG_TAG, "Response\n  Id: %s\n  Size: %d\n  Responses:\n%s\n",
+                requests.getId(), responseString.length(), responses);
+
+        return responses;
+    }
+
+    private static List<Response> createResponsesFromObject(HttpURLConnection connection, List<Request> requests,
+            Object object, boolean isFromCache) throws FacebookException, JSONException {
+        assert (connection != null) || isFromCache;
+
+        int numRequests = requests.size();
+        List<Response> responses = new ArrayList<Response>(numRequests);
+
+        if (numRequests == 1) {
+            Request request = requests.get(0);
+            try {
+                // Single request case -- the entire response is the result, wrap it as "body" so we can handle it
+                // the same as we do in the batched case. We get the response code from the actual HTTP response,
+                // as opposed to the batched case where it is returned as a "code" element.
+                JSONObject jsonObject = new JSONObject();
+                jsonObject.put(BODY_KEY, object);
+                int responseCode = (connection != null) ? connection.getResponseCode() : 200;
+                jsonObject.put(CODE_KEY, responseCode);
+
+                JSONArray jsonArray = new JSONArray();
+                jsonArray.put(jsonObject);
+
+                // Pretend we got an array of 1 back.
+                object = jsonArray;
+            } catch (JSONException e) {
+                responses.add(new Response(request, connection, new FacebookException(e)));
+            } catch (IOException e) {
+                responses.add(new Response(request, connection, new FacebookException(e)));
+            }
+        }
+
+        if (!(object instanceof JSONArray) || ((JSONArray) object).length() != numRequests) {
+            FacebookException exception = new FacebookException("TODO unexpected number of results");
+            throw exception;
+        }
+
+        JSONArray jsonArray = (JSONArray) object;
+
+        for (int i = 0; i < jsonArray.length(); ++i) {
+            Request request = requests.get(i);
+            try {
+                Object obj = jsonArray.get(i);
+                responses.add(createResponseFromObject(request, connection, obj, isFromCache));
+            } catch (JSONException e) {
+                responses.add(new Response(request, connection, new FacebookException(e)));
+            } catch (FacebookException e) {
+                responses.add(new Response(request, connection, e));
+            }
+        }
+
+        return responses;
+    }
+
+    private static Response createResponseFromObject(Request request, HttpURLConnection connection, Object object, boolean isFromCache) throws JSONException {
+        if (object instanceof JSONObject) {
+            JSONObject jsonObject = (JSONObject) object;
+
+            FacebookServiceErrorException exception = checkResponseAndCreateException(jsonObject);
+            if (exception != null) {
+                if (exception.getFacebookErrorCode() == INVALID_SESSION_FACEBOOK_ERROR_CODE) {
+                    Session session = request.getSession();
+                    if (session != null) {
+                        session.closeAndClearTokenInformation();
+                    }
+                }
+                throw exception;
+            }
+
+            Object body = Utility.getStringPropertyAsJSON(jsonObject, BODY_KEY, NON_JSON_RESPONSE_PROPERTY);
+
+            GraphObject graphObject = null;
+            GraphObjectList<GraphObject> graphObjectList = null;
+            if (body instanceof JSONObject) {
+                graphObject = GraphObjectWrapper.createGraphObject((JSONObject) body);
+            } else if (body instanceof JSONArray) {
+                graphObjectList = GraphObjectWrapper.wrapArray((JSONArray) body, GraphObject.class);
+            }
+            return new Response(request, connection, graphObject, graphObjectList, isFromCache);
+        } else if (object == JSONObject.NULL) {
+            return new Response(request, connection, null, null, isFromCache);
+        } else {
+            throw new FacebookException("Got unexpected object type in response, class: "
+                    + object.getClass().getSimpleName());
+        }
+    }
+
+    private static FacebookServiceErrorException checkResponseAndCreateException(JSONObject jsonObject) {
+        try {
+            if (jsonObject.has(CODE_KEY)) {
+                int responseCode = jsonObject.getInt(CODE_KEY);
+                Object body = Utility.getStringPropertyAsJSON(jsonObject, BODY_KEY, NON_JSON_RESPONSE_PROPERTY);
+
+                if (body != null && body instanceof JSONObject) {
+                    JSONObject jsonBody = (JSONObject) body;
+                    // Does this response represent an error from the service? We might get either an "error"
+                    // with several sub-properties, or else one or more top-level fields containing error info.
+                    String errorType = null;
+                    String errorMessage = null;
+                    int errorCode = -1;
+
+                    boolean hasError = false;
+                    if (jsonBody.has(ERROR_KEY)) {
+                        // We assume the error object is correctly formatted.
+                        JSONObject error = (JSONObject) Utility.getStringPropertyAsJSON(jsonBody, ERROR_KEY, null);
+
+                        errorType = error.optString(ERROR_TYPE_FIELD_KEY, null);
+                        errorMessage = error.optString(ERROR_MESSAGE_FIELD_KEY, null);
+                        errorCode = error.optInt(ERROR_CODE_FIELD_KEY, -1);
+                        hasError = true;
+                    } else if (jsonBody.has(ERROR_CODE_KEY) || jsonBody.has(ERROR_MSG_KEY)
+                            || jsonBody.has(ERROR_REASON_KEY)) {
+                        errorType = jsonBody.optString(ERROR_REASON_KEY, null);
+                        errorMessage = jsonBody.optString(ERROR_MSG_KEY, null);
+                        errorCode = jsonBody.optInt(ERROR_CODE_KEY, -1);
+                        hasError = true;
+                    }
+
+                    if (hasError) {
+                        return new FacebookServiceErrorException(responseCode, errorCode, errorType, errorMessage,
+                                jsonBody);
+                    }
+                }
+
+                // If we didn't get error details, but we did get a failure response code, report it.
+                if (responseCode < 200 || responseCode >= 300) {
+                    return new FacebookServiceErrorException(responseCode);
+                }
+            }
+        } catch (JSONException e) {
+        }
+
+        return null;
+    }
+
+    static List<Response> constructErrorResponses(List<Request> requests, HttpURLConnection connection,
+            FacebookException error) {
+        int count = requests.size();
+        List<Response> responses = new ArrayList<Response>(count);
+        for (int i = 0; i < count; ++i) {
+            Response response = new Response(requests.get(i), connection, error);
+            responses.add(response);
+        }
+        return responses;
+    }
+}
diff --git a/facebook/src/com/facebook/ServerProtocol.java b/facebook/src/com/facebook/ServerProtocol.java
new file mode 100644
index 000000000..619729e47
--- /dev/null
+++ b/facebook/src/com/facebook/ServerProtocol.java
@@ -0,0 +1,41 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import java.util.Collection;
+
+final class ServerProtocol {
+    static final String FACEBOOK_COM = "facebook.com";
+    static final String DIALOG_AUTHORITY = "m." + FACEBOOK_COM;
+    static final String DIALOG_OAUTH_PATH = "dialog/oauth";
+    static final String DIALOG_PARAM_SCOPE = "scope";
+    static final String DIALOG_PARAM_CLIENT_ID = "client_id";
+    static final String DIALOG_PARAM_DISPLAY = "display";
+    static final String DIALOG_PARAM_REDIRECT_URI = "redirect_uri";
+    static final String DIALOG_PARAM_TYPE = "type";
+
+    // URL components
+    static final String GRAPH_URL = "https://graph." + FACEBOOK_COM;
+    static final String GRAPH_URL_BASE = "https://graph." + FACEBOOK_COM + "/";
+    static final String REST_URL_BASE = "https://api." + FACEBOOK_COM + "/method/";
+    static final String BATCHED_REST_METHOD_URL_BASE = "method/";
+
+    static final Collection<String> errorsProxyAuthDisabled =
+            Utility.unmodifiableCollection("service_disabled", "AndroidAuthKillSwitchException");
+    static final Collection<String> errorsUserCanceled =
+            Utility.unmodifiableCollection("access_denied", "OAuthAccessDeniedException");
+}
diff --git a/facebook/src/com/facebook/Session.java b/facebook/src/com/facebook/Session.java
new file mode 100644
index 000000000..939c6e5ce
--- /dev/null
+++ b/facebook/src/com/facebook/Session.java
@@ -0,0 +1,1987 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.Manifest;
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.*;
+import android.content.pm.*;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.net.Uri;
+import android.os.*;
+import android.support.v4.app.Fragment;
+import android.support.v4.content.LocalBroadcastManager;
+import android.text.TextUtils;
+import android.util.Log;
+import android.webkit.CookieSyncManager;
+import com.facebook.android.DialogError;
+import com.facebook.android.Facebook.DialogListener;
+import com.facebook.android.FacebookError;
+import com.facebook.android.FbDialog;
+import com.facebook.android.Util;
+
+import java.io.*;
+import java.lang.ref.WeakReference;
+import java.util.*;
+
+/**
+ * <p>
+ * Session is used to authenticate a user and manage the user's session with
+ * Facebook.
+ * </p>
+ * <p>
+ * Sessions must be opened before they can be used to make a Request. When a
+ * Session is created, it attempts to initialize itself from a TokenCache.
+ * Closing the session can optionally clear this cache.  The Session lifecycle
+ * uses {@link SessionState SessionState} to indicate its state.
+ * </p>
+ * <p>
+ * Instances of Session provide state change notification via a callback
+ * interface, {@link Session.StatusCallback StatusCallback}.
+ * </p>
+ */
+public class Session implements Serializable {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * The logging tag used by Session.
+     */
+    public static final String TAG = Session.class.getCanonicalName();
+
+    /**
+     * The default activity code used for authorization.
+     * 
+     * @see #openForRead(OpenRequest)
+     *      open
+     */
+    public static final int DEFAULT_AUTHORIZE_ACTIVITY_CODE = 0xface;
+
+    /**
+     * If Session authorization fails and provides a web view error code, the
+     * web view error code is stored in the Bundle returned from
+     * {@link #getAuthorizationBundle getAuthorizationBundle} under this key.
+     */
+    public static final String WEB_VIEW_ERROR_CODE_KEY = "com.facebook.sdk.WebViewErrorCode";
+
+    /**
+     * If Session authorization fails and provides a failing url, the failing
+     * url is stored in the Bundle returned from {@link #getAuthorizationBundle
+     * getAuthorizationBundle} under this key.
+     */
+    public static final String WEB_VIEW_FAILING_URL_KEY = "com.facebook.sdk.FailingUrl";
+
+    /**
+     * The action used to indicate that the active session has been set. This should
+     * be used as an action in an IntentFilter and BroadcastReceiver registered with
+     * the {@link android.support.v4.content.LocalBroadcastManager}.
+     */
+    public static final String ACTION_ACTIVE_SESSION_SET = "com.facebook.sdk.ACTIVE_SESSION_SET";
+
+    /**
+     * The action used to indicate that the active session has been set to null. This should
+     * be used as an action in an IntentFilter and BroadcastReceiver registered with
+     * the {@link android.support.v4.content.LocalBroadcastManager}.
+     */
+    public static final String ACTION_ACTIVE_SESSION_UNSET = "com.facebook.sdk.ACTIVE_SESSION_UNSET";
+
+    /**
+     * The action used to indicate that the active session has been opened. This should
+     * be used as an action in an IntentFilter and BroadcastReceiver registered with
+     * the {@link android.support.v4.content.LocalBroadcastManager}.
+     */
+    public static final String ACTION_ACTIVE_SESSION_OPENED = "com.facebook.sdk.ACTIVE_SESSION_OPENED";
+
+    /**
+     * The action used to indicate that the active session has been closed. This should
+     * be used as an action in an IntentFilter and BroadcastReceiver registered with
+     * the {@link android.support.v4.content.LocalBroadcastManager}.
+     */
+    public static final String ACTION_ACTIVE_SESSION_CLOSED = "com.facebook.sdk.ACTIVE_SESSION_CLOSED";
+    
+    /**
+     * Session takes application id as a constructor parameter. If this is null,
+     * Session will attempt to load the application id from
+     * application/meta-data using this String as the key.
+     */
+    public static final String APPLICATION_ID_PROPERTY = "com.facebook.sdk.ApplicationId";
+
+    private static Object staticLock = new Object();
+    private static Session activeSession;
+    private static volatile Context staticContext;
+
+    // Token extension constants
+    private static final int TOKEN_EXTEND_THRESHOLD_SECONDS = 24 * 60 * 60; // 1
+                                                                            // day
+    private static final int TOKEN_EXTEND_RETRY_SECONDS = 60 * 60; // 1 hour
+
+    private static final String SESSION_BUNDLE_SAVE_KEY = "com.facebook.sdk.Session.saveSessionKey";
+    private static final String AUTH_BUNDLE_SAVE_KEY = "com.facebook.sdk.Session.authBundleKey";
+    private static final String PUBLISH_PERMISSION_PREFIX = "publish";
+    private static final String MANAGE_PERMISSION_PREFIX = "manage";
+    @SuppressWarnings("serial")
+    private static final Set<String> OTHER_PUBLISH_PERMISSIONS = new HashSet<String>() {{
+        add("ads_management");
+        add("create_event");
+        add("rsvp_event");
+    }};
+
+    private String applicationId;
+    private SessionState state;
+    private AccessToken tokenInfo;
+    private Date lastAttemptedTokenExtendDate = new Date(0);
+    private boolean shouldAutoPublish = true;
+
+    private AuthorizationRequest pendingRequest;
+
+    // The following are not serialized with the Session object
+    private volatile Bundle authorizationBundle;
+    private List<StatusCallback> callbacks;
+    private Handler handler;
+    private AutoPublishAsyncTask autoPublishAsyncTask;
+    // This is the object that synchronizes access to state and tokenInfo
+    private Object lock = new Object();
+    private TokenCache tokenCache;
+    private volatile TokenRefreshRequest currentTokenRefreshRequest;
+
+    /**
+     * Serialization proxy for the Session class. This is version 1 of
+     * serialization. Future serializations may differ in format. This
+     * class should not be modified. If serializations formats change,
+     * create a new class SerializationProxyVx.
+     */
+    private static class SerializationProxyV1 implements Serializable {
+        private static final long serialVersionUID = 7663436173185080063L;
+        private final String applicationId;
+        private final SessionState state;
+        private final AccessToken tokenInfo;
+        private final Date lastAttemptedTokenExtendDate;
+        private final boolean shouldAutoPublish;
+        private final AuthorizationRequest pendingRequest;
+
+        SerializationProxyV1(String applicationId, SessionState state,
+                AccessToken tokenInfo, Date lastAttemptedTokenExtendDate,
+                boolean shouldAutoPublish, AuthorizationRequest pendingRequest) {
+            this.applicationId = applicationId;
+            this.state = state;
+            this.tokenInfo = tokenInfo;
+            this.lastAttemptedTokenExtendDate = lastAttemptedTokenExtendDate;
+            this.shouldAutoPublish = shouldAutoPublish;
+            this.pendingRequest = pendingRequest;
+        }
+
+        private Object readResolve() {
+            return new Session(applicationId, state, tokenInfo,
+                    lastAttemptedTokenExtendDate, shouldAutoPublish, pendingRequest);
+        }
+    }
+
+    /**
+     * Used by version 1 of the serialization proxy, do not modify.
+     */
+    private Session(String applicationId, SessionState state,
+            AccessToken tokenInfo, Date lastAttemptedTokenExtendDate,
+            boolean shouldAutoPublish, AuthorizationRequest pendingRequest) {
+        this.applicationId = applicationId;
+        this.state = state;
+        this.tokenInfo = tokenInfo;
+        this.lastAttemptedTokenExtendDate = lastAttemptedTokenExtendDate;
+        this.shouldAutoPublish = shouldAutoPublish;
+        this.pendingRequest = pendingRequest;
+        lock = new Object();
+        handler = new Handler(Looper.getMainLooper());
+        currentTokenRefreshRequest = null;
+        tokenCache = null;
+        callbacks = new ArrayList<StatusCallback>();
+    }
+
+    /**
+     * Initializes a new Session with the specified context.
+     * 
+     * @param currentContext
+     *            The Activity or Service creating this Session.
+     */
+    public Session(Context currentContext) {
+        this(currentContext, null, null, true);
+    }
+
+    Session(Context context, String applicationId, TokenCache tokenCache, boolean shouldAutoPublish) {
+        // if the application ID passed in is null, try to get it from the
+        // meta-data in the manifest.
+        if ((context != null) && (applicationId == null)) {
+            applicationId = getMetadataApplicationId(context);
+        }
+
+        Validate.notNull(applicationId, "applicationId");
+
+        initializeStaticContext(context);
+
+        if (tokenCache == null) {
+            tokenCache = new SharedPreferencesTokenCache(staticContext);
+        }
+
+        this.applicationId = applicationId;
+        this.tokenCache = tokenCache;
+        this.state = SessionState.CREATED;
+        this.pendingRequest = null;
+        this.callbacks = new ArrayList<StatusCallback>();
+        this.handler = new Handler(Looper.getMainLooper());
+        this.shouldAutoPublish = shouldAutoPublish;
+
+        Bundle tokenState = tokenCache.load();
+        if (TokenCache.hasTokenInformation(tokenState)) {
+            Date cachedExpirationDate = TokenCache.getDate(tokenState, TokenCache.EXPIRATION_DATE_KEY);
+            Date now = new Date();
+
+            if ((cachedExpirationDate == null) || cachedExpirationDate.before(now)) {
+                // If expired or we require new permissions, clear out the
+                // current token cache.
+                tokenCache.clear();
+                this.tokenInfo = AccessToken.createEmptyToken(Collections.<String>emptyList());
+            } else {
+                // Otherwise we have a valid token, so use it.
+                this.tokenInfo = AccessToken.createFromCache(tokenState);
+                this.state = SessionState.CREATED_TOKEN_LOADED;
+            }
+        } else {
+            this.tokenInfo = AccessToken.createEmptyToken(Collections.<String>emptyList());
+        }
+    }
+
+    /**
+     * Returns a Bundle containing data that was returned from facebook during
+     * authorization.
+     * 
+     * @return a Bundle containing data that was returned from facebook during
+     *         authorization.
+     */
+    public final Bundle getAuthorizationBundle() {
+        synchronized (this.lock) {
+            return this.authorizationBundle;
+        }
+    }
+
+    /**
+     * Returns a boolean indicating whether the session is opened.
+     * 
+     * @return a boolean indicating whether the session is opened.
+     */
+    public final boolean isOpened() {
+        synchronized (this.lock) {
+            return this.state.isOpened();
+        }
+    }
+
+    public final boolean isClosed() {
+        synchronized (this.lock) {
+            return this.state.isClosed();
+        }
+    }
+
+    /**
+     * Returns the current state of the Session.
+     * See {@link SessionState} for details.
+     * 
+     * @return the current state of the Session.
+     */
+    public final SessionState getState() {
+        synchronized (this.lock) {
+            return this.state;
+        }
+    }
+
+    /**
+     * Returns the application id associated with this Session.
+     * 
+     * @return the application id associated with this Session.
+     */
+    public final String getApplicationId() {
+        return this.applicationId;
+    }
+
+    /**
+     * Returns the access token String.
+     * 
+     * @return the access token String.
+     */
+    public final String getAccessToken() {
+        synchronized (this.lock) {
+            return this.tokenInfo.getToken();
+        }
+    }
+
+    /**
+     * <p>
+     * Returns the Date at which the current token will expire.
+     * </p>
+     * <p>
+     * Note that Session automatically attempts to extend the lifetime of Tokens
+     * as needed when facebook requests are made.
+     * </p>
+     * 
+     * @return the Date at which the current token will expire.
+     */
+    public final Date getExpirationDate() {
+        synchronized (this.lock) {
+            return this.tokenInfo.getExpires();
+        }
+    }
+
+    /**
+     * <p>
+     * Returns the list of permissions associated with the session.
+     * </p>
+     * <p>
+     * If there is a valid token, this represents the permissions granted by
+     * that token. This can change during calls to
+     * {@link #reauthorizeForRead(com.facebook.Session.ReauthorizeRequest)}
+     * or {@link #reauthorizeForPublish(com.facebook.Session.ReauthorizeRequest)}.
+     * </p>
+     * 
+     * @return the list of permissions associated with the session.
+     */
+    public final List<String> getPermissions() {
+        synchronized (this.lock) {
+            return this.tokenInfo.getPermissions();
+        }
+    }
+
+    /**
+     * <p>
+     * Logs a user in to Facebook.
+     * </p>
+     * <p>
+     * A session may not be used with {@link Request Request} and other classes
+     * in the SDK until it is open. If, prior to calling open, the session is in
+     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
+     * state, and the requested permissions are a subset of the previously authorized
+     * permissions, then the Session becomes usable immediately with no user interaction.
+     * </p>
+     * <p>
+     * The permissions associated with the openRequest passed to this method must
+     * be read permissions only (or null/empty). It is not allowed to pass publish
+     * permissions to this method and will result in an exception being thrown.
+     * </p>
+     * <p>
+     * Any open method must be called at most once, and cannot be called after the
+     * Session is closed. Calling the method at an invalid time will result in
+     * UnsuportedOperationException.
+     * </p>
+     *
+     * @param openRequest
+     *         the open request, can be null only if the Session is in the
+     *         {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED} state
+     *
+     * @throws FacebookException
+     *         if any publish permissions are requested
+     */
+    public final void openForRead(OpenRequest openRequest) {
+        open(openRequest, AuthorizationType.READ);
+    }
+
+    /**
+     * <p>
+     * Logs a user in to Facebook.
+     * </p>
+     * <p>
+     * A session may not be used with {@link Request Request} and other classes
+     * in the SDK until it is open. If, prior to calling open, the session is in
+     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
+     * state, and the requested permissions are a subset of the previously authorized
+     * permissions, then the Session becomes usable immediately with no user interaction.
+     * </p>
+     * <p>
+     * The permissions associated with the openRequest passed to this method must
+     * be publish permissions only and must be non-empty. Any read permissions
+     * will result in a warning, and may fail during server-side authorization.
+     * </p>
+     * <p>
+     * Any open method must be called at most once, and cannot be called after the
+     * Session is closed. Calling the method at an invalid time will result in
+     * UnsuportedOperationException.
+     * </p>
+     *
+     * @param openRequest
+     *         the open request, can be null only if the Session is in the
+     *         {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED} state
+     *
+     * @throws FacebookException
+     *         if the passed in request is null or has no permissions set.
+     */
+    public final void openForPublish(OpenRequest openRequest) {
+        open(openRequest, AuthorizationType.PUBLISH);
+    }
+
+    /**
+     * <p>
+     * Logs a user in to Facebook.
+     * </p>
+     * <p>
+     * A session may not be used with {@link Request Request} and other classes
+     * in the SDK until it is open. If, prior to calling open, the session is in
+     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
+     * state, then the Session becomes usable immediately with no user interaction.
+     * Otherwise, this will open the Session with basic permissions.
+     * </p>
+     * <p>
+     * Any open method must be called at most once, and cannot be called after the
+     * Session is closed. Calling the method at an invalid time will result in
+     * UnsuportedOperationException.
+     * </p>
+     *
+     * @param activity
+     *         the Activity used to open the Session
+     */
+    public final void openForRead(Activity activity) {
+        openForRead(new OpenRequest(activity));
+    }
+
+    /**
+     * <p>
+     * Logs a user in to Facebook.
+     * </p>
+     * <p>
+     * A session may not be used with {@link Request Request} and other classes
+     * in the SDK until it is open. If, prior to calling open, the session is in
+     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
+     * state, then the Session becomes usable immediately with no user interaction.
+     * Otherwise, this will open the Session with basic permissions.
+     * </p>
+     * <p>
+     * Any open method must be called at most once, and cannot be called after the
+     * Session is closed. Calling the method at an invalid time will result in
+     * UnsuportedOperationException.
+     * </p>
+     *
+     * @param fragment
+     *         the Fragment used to open the Session
+     */
+    public final void openForRead(Fragment fragment) {
+        openForRead(new OpenRequest(fragment));
+    }
+
+    /**
+     * <p>
+     * Logs a user in to Facebook.
+     * </p>
+     * <p>
+     * This method should only be called if the session is in
+     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
+     * state.
+     * </p>
+     * <p>
+     * Any open method must be called at most once, and cannot be called after the
+     * Session is closed. Calling the method at an invalid time will result in
+     * UnsuportedOperationException.
+     * </p>
+     *
+     * @throws UnsupportedOperationException
+     *          If the session is in an invalid state.
+     */
+    public final void open() {
+        if (state.equals(SessionState.CREATED_TOKEN_LOADED)) {
+            openForRead((OpenRequest) null);
+        } else {
+            throw new UnsupportedOperationException(String.format(
+                    "Cannot call open without an OpenRequest when the state is %s",
+                    state.toString()));
+        }
+    }
+
+    /**
+     * <p>
+     * Reauthorizes the Session, with additional read permissions.
+     * </p>
+     * <p>
+     * If successful, this will update the set of permissions on this session to
+     * match the newPermissions. If this fails, the Session remains unchanged.
+     * </p>
+     * <p>
+     * The permissions associated with the reauthorizeRequest passed to this method must
+     * be read permissions only (or null/empty). It is not allowed to pass publish
+     * permissions to this method and will result in an exception being thrown.
+     * </p>
+     *
+     * @param reauthorizeRequest the reauthorization request
+     */
+    public final void reauthorizeForRead(ReauthorizeRequest reauthorizeRequest) {
+        reauthorize(reauthorizeRequest, AuthorizationType.READ);
+    }
+
+    /**
+     * <p>
+     * Reauthorizes the Session, with additional publish permissions.
+     * </p>
+     * <p>
+     * If successful, this will update the set of permissions on this session to
+     * match the newPermissions. If this fails, the Session remains unchanged.
+     * </p>
+     * <p>
+     * The permissions associated with the reauthorizeRequest passed to this method must
+     * be publish permissions only and must be non-empty. Any read permissions
+     * will result in a warning, and may fail during server-side authorization.
+     * </p>
+     *
+     * @param reauthorizeRequest the reauthorization request
+     */
+    public final void reauthorizeForPublish(ReauthorizeRequest reauthorizeRequest) {
+        reauthorize(reauthorizeRequest, AuthorizationType.PUBLISH);
+    }
+
+    /**
+     * Provides an implementation for {@link Activity#onActivityResult
+     * onActivityResult} that updates the Session based on information returned
+     * during the authorization flow. The Activity that calls open or
+     * reauthorize should forward the resulting onActivityResult call here to
+     * update the Session state based on the contents of the resultCode and
+     * data.
+     * 
+     * @param currentActivity
+     *            The Activity that is forwarding the onActivityResult call.
+     * @param requestCode
+     *            The requestCode parameter from the forwarded call. When this
+     *            onActivityResult occurs as part of facebook authorization
+     *            flow, this value is the activityCode passed to open or
+     *            authorize.
+     * @param resultCode
+     *            An int containing the resultCode parameter from the forwarded
+     *            call.
+     * @param data
+     *            The Intent passed as the data parameter from the forwarded
+     *            call.
+     * @return A boolean indicating whether the requestCode matched a pending
+     *         authorization request for this Session.
+     */
+    public final boolean onActivityResult(Activity currentActivity, int requestCode, int resultCode, Intent data) {
+        Validate.notNull(currentActivity, "currentActivity");
+
+        initializeStaticContext(currentActivity);
+
+        AuthorizationRequest currentRequest = null;
+        AuthorizationRequest retryRequest = null;
+        AccessToken newToken = null;
+        Exception exception = null;
+
+        synchronized (lock) {
+            if (pendingRequest == null || (requestCode != pendingRequest.getRequestCode())) {
+                return false;
+            } else {
+                currentRequest = pendingRequest;
+            }
+        }
+
+        this.authorizationBundle = null;
+
+        if (resultCode == Activity.RESULT_CANCELED) {
+            if (data == null) {
+                // User pressed the 'back' button
+                exception = new FacebookOperationCanceledException("Log in was canceled by the user");
+            } else {
+                this.authorizationBundle = data.getExtras();
+                exception = new FacebookAuthorizationException(this.authorizationBundle.getString("error"));
+            }
+        } else if (resultCode == Activity.RESULT_OK) {
+            Validate.notNull(data, "data");
+
+            this.authorizationBundle = data.getExtras();
+            String error = this.authorizationBundle.getString("error");
+            if (error == null) {
+                error = this.authorizationBundle.getString("error_type");
+            }
+            if (error != null) {
+                if (ServerProtocol.errorsProxyAuthDisabled.contains(error)) {
+                    retryRequest = currentRequest.setLoginBehavior(SessionLoginBehavior.SUPPRESS_SSO);
+                } else if (ServerProtocol.errorsUserCanceled.contains(error)) {
+                    exception = new FacebookOperationCanceledException("User canceled log in.");
+                } else {
+                    String description = this.authorizationBundle.getString("error_description");
+                    if (description != null) {
+                        error = error + ": " + description;
+                    }
+                    exception = new FacebookAuthorizationException(error);
+                }
+            } else {
+                newToken = AccessToken.createFromSSO(currentRequest.permissions, data);
+            }
+        }
+
+        if (retryRequest != null) {
+            synchronized (lock) {
+                if (pendingRequest == currentRequest) {
+                    pendingRequest = retryRequest;
+                } else {
+                    retryRequest = null;
+                }
+            }
+            authorize(retryRequest);
+        } else {
+            finishAuth(newToken, exception);
+        }
+
+        return true;
+    }
+
+    /**
+     * Closes the local in-memory Session object, but does not clear the
+     * persisted token cache.
+     */
+    @SuppressWarnings("incomplete-switch")
+    public final void close() {
+        synchronized (this.lock) {
+            final SessionState oldState = this.state;
+
+            switch (this.state) {
+            case CREATED:
+            case OPENING:
+                this.state = SessionState.CLOSED_LOGIN_FAILED;
+                postStateChange(oldState, this.state, new FacebookException(
+                        "Log in attempt aborted."));
+                break;
+
+            case CREATED_TOKEN_LOADED:
+            case OPENED:
+            case OPENED_TOKEN_UPDATED:
+                this.state = SessionState.CLOSED;
+                postStateChange(oldState, this.state, null);
+                break;
+            }
+        }
+    }
+
+    /**
+     * Closes the local in-memory Session object and clears any persisted token
+     * cache related to the Session.
+     */
+    public final void closeAndClearTokenInformation() {
+        if (this.tokenCache != null) {
+            this.tokenCache.clear();
+        }
+        Utility.clearFacebookCookies(staticContext);
+        close();
+    }
+
+    @Override
+    public final String toString() {
+        return new StringBuilder().append("{Session").append(" state:").append(this.state).append(", token:")
+                .append((this.tokenInfo == null) ? "null" : this.tokenInfo).append(", appId:")
+                .append((this.applicationId == null) ? "null" : this.applicationId).append("}").toString();
+    }
+
+    /**
+     * <p>
+     * Do not use this method.
+     * </p>
+     * <p>
+     * Refreshes the token based on information obtained from the Facebook
+     * class. This is exposed to enable the com.facebook.android.Facebook class
+     * to refresh the token in its underlying Session. Normally Session
+     * automatically updates its token. This is only provided for backwards
+     * compatibility and may be removed in a future release.
+     * </p>
+     * 
+     * @param bundle
+     *            Opaque Bundle of data from the Facebook class.
+     */
+    public void internalRefreshToken(Bundle bundle) {
+        synchronized (this.lock) {
+            final SessionState oldState = this.state;
+
+            switch (this.state) {
+            case OPENED:
+                this.state = SessionState.OPENED_TOKEN_UPDATED;
+                postStateChange(oldState, this.state, null);
+                break;
+            case OPENED_TOKEN_UPDATED:
+                break;
+            default:
+                // Silently ignore attempts to refresh token if we are not open
+                Log.d(TAG, "refreshToken ignored in state " + this.state);
+                return;
+            }
+            this.tokenInfo = AccessToken.createForRefresh(this.tokenInfo, bundle);
+            if (this.tokenCache != null) {
+                this.tokenCache.save(this.tokenInfo.toCacheBundle());
+            }
+        }
+    }
+
+    private Object writeReplace() {
+        return new SerializationProxyV1(applicationId, state, tokenInfo,
+                lastAttemptedTokenExtendDate, shouldAutoPublish, pendingRequest);
+    }
+
+    // have a readObject that throws to prevent spoofing
+    private void readObject(ObjectInputStream stream) throws InvalidObjectException {
+        throw new InvalidObjectException("Cannot readObject, serialization proxy required");
+    }
+
+    /**
+     * Save the Session object into the supplied Bundle.
+     *
+     * @param session the Session to save
+     * @param bundle the Bundle to save the Session to
+     */
+    public static final void saveSession(Session session, Bundle bundle) {
+        if (bundle != null && session != null) {
+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+            try {
+                new ObjectOutputStream(outputStream).writeObject(session);
+            } catch (IOException e) {
+                throw new FacebookException("Unable to save session.", e);
+            }
+            bundle.putByteArray(SESSION_BUNDLE_SAVE_KEY, outputStream.toByteArray());
+            bundle.putBundle(AUTH_BUNDLE_SAVE_KEY, session.authorizationBundle);
+        }
+    }
+
+    /**
+     * Restores the saved session from a Bundle, if any. Returns the restored Session or
+     * null if it could not be restored.
+     *
+     * @param context
+     *            the Activity or Service creating the Session, must not be null
+     * @param cache
+     *            the TokenCache to use to load and store the token. If this is
+     *            null, a default token cache that stores data in
+     *            SharedPreferences will be used
+     * @param callback
+     *            the callback to notify for Session state changes, can be null
+     * @param bundle
+     *            the bundle to restore the Session from
+     * @return the restored Session, or null
+     */
+    public static final Session restoreSession(
+            Context context, TokenCache cache, StatusCallback callback, Bundle bundle) {
+        if (bundle == null) {
+            return null;
+        }
+        byte[] data = bundle.getByteArray(SESSION_BUNDLE_SAVE_KEY);
+        if (data != null) {
+            ByteArrayInputStream is = new ByteArrayInputStream(data);
+            try {
+                Session session = (Session) (new ObjectInputStream(is)).readObject();
+                initializeStaticContext(context);
+                if (cache != null) {
+                    session.tokenCache = cache;
+                } else {
+                    session.tokenCache = new SharedPreferencesTokenCache(context);
+                }
+                if (callback != null) {
+                    session.addCallback(callback);
+                }
+                session.authorizationBundle =  bundle.getBundle(AUTH_BUNDLE_SAVE_KEY);
+                return session;
+            } catch (ClassNotFoundException e) {
+                Log.w(TAG, "Unable to restore session", e);
+            } catch (IOException e) {
+                Log.w(TAG, "Unable to restore session.", e);
+            }
+        }
+        return null;
+    }
+
+
+    /**
+     * Returns the current active Session, or null if there is none.
+     * 
+     * @return the current active Session, or null if there is none.
+     */
+    public static final Session getActiveSession() {
+        synchronized (Session.staticLock) {
+            return Session.activeSession;
+        }
+    }
+
+    /**
+     * <p>
+     * Sets the current active Session.
+     * </p>
+     * <p>
+     * The active Session is used implicitly by predefined Request factory
+     * methods as well as optionally by UI controls in the sdk.
+     * </p>
+     * <p>
+     * It is legal to set this to null, or to a Session that is not yet open.
+     * </p>
+     * 
+     * @param session
+     *            A Session to use as the active Session, or null to indicate
+     *            that there is no active Session.
+     */
+    public static final void setActiveSession(Session session) {
+        synchronized (Session.staticLock) {
+            if (session != Session.activeSession) {
+                Session oldSession = Session.activeSession;
+
+                if (oldSession != null) {
+                    oldSession.close();
+                }
+
+                Session.activeSession = session;
+
+                if (oldSession != null) {
+                    postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_UNSET);
+                }
+
+                if (session != null) {
+                    postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_SET);
+
+                    if (session.isOpened()) {
+                        postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Create a new Session, and if a token cache is available, open the
+     * Session and make it active without any user interaction.
+     *
+     * @param context
+     *         The Context creating this session
+     * @return The new session or null if one could not be created
+     */
+    public static Session openActiveSession(Context context) {
+        return openActiveSession(context, false, null);
+    }
+
+    /**
+     * If allowLoginUI is true, this will create a new Session, make it active, and
+     * open it. If the default token cache is not available, then this will request
+     * basic permissions. If the default token cache is available and cached tokens
+     * are loaded, this will use the cached token and associated permissions.
+     * <p/>
+     * If allowedLoginUI is false, this will only create the active session and open
+     * it if it requires no user interaction (i.e. the token cache is available and
+     * there are cached tokens).
+     *
+     * @param activity
+     *            The Activity that is opening the new Session.
+     * @param allowLoginUI
+     *            if false, only sets the active session and opens it if it
+     *            does not require user interaction
+     * @return The new Session or null if one could not be created
+     */
+    public static Session openActiveSession(Activity activity, boolean allowLoginUI) {
+        return openActiveSession(activity, allowLoginUI, (StatusCallback) null);
+    }
+
+    /**
+     * If allowLoginUI is true, this will create a new Session, make it active, and
+     * open it. If the default token cache is not available, then this will request
+     * basic permissions. If the default token cache is available and cached tokens
+     * are loaded, this will use the cached token and associated permissions.
+     * <p/>
+     * If allowedLoginUI is false, this will only create the active session and open
+     * it if it requires no user interaction (i.e. the token cache is available and
+     * there are cached tokens).
+     * 
+     * @param activity
+     *            The Activity that is opening the new Session.
+     * @param allowLoginUI
+     *            if false, only sets the active session and opens it if it
+     *            does not require user interaction
+     * @param callback
+     *            The {@link StatusCallback SessionStatusCallback} to
+     *            notify regarding Session state changes.
+     * @return The new Session or null if one could not be created
+     */
+    public static Session openActiveSession(Activity activity, boolean allowLoginUI,
+            StatusCallback callback) {
+        return openActiveSession(activity, allowLoginUI, new OpenRequest(activity).setCallback(callback));
+    }
+
+    /**
+     * If allowLoginUI is true, this will create a new Session, make it active, and
+     * open it. If the default token cache is not available, then this will request
+     * basic permissions. If the default token cache is available and cached tokens
+     * are loaded, this will use the cached token and associated permissions.
+     * <p/>
+     * If allowedLoginUI is false, this will only create the active session and open
+     * it if it requires no user interaction (i.e. the token cache is available and
+     * there are cached tokens).
+     *
+     * @param context
+     *            The Activity or Service creating this Session
+     * @param fragment
+     *            The Fragment that is opening the new Session.
+     * @param allowLoginUI
+     *            if false, only sets the active session and opens it if it
+     *            does not require user interaction
+     * @return The new Session or null if one could not be created
+     */
+    public static Session openActiveSession(Context context, Fragment fragment, boolean allowLoginUI) {
+        return openActiveSession(context, fragment, allowLoginUI, null);
+    }
+
+    /**
+     * If allowLoginUI is true, this will create a new Session, make it active, and
+     * open it. If the default token cache is not available, then this will request
+     * basic permissions. If the default token cache is available and cached tokens
+     * are loaded, this will use the cached token and associated permissions.
+     * <p/>
+     * If allowedLoginUI is false, this will only create the active session and open
+     * it if it requires no user interaction (i.e. the token cache is available and
+     * there are cached tokens).
+     *
+     * @param context
+     *            The Activity or Service creating this Session
+     * @param fragment
+     *            The Fragment that is opening the new Session.
+     * @param allowLoginUI
+     *            if false, only sets the active session and opens it if it
+     *            does not require user interaction
+     * @param callback
+     *            The {@link StatusCallback SessionStatusCallback} to
+     *            notify regarding Session state changes.
+     * @return The new Session or null if one could not be created
+     */
+    public static Session openActiveSession(Context context, Fragment fragment,
+            boolean allowLoginUI, StatusCallback callback) {
+        return openActiveSession(context, allowLoginUI, new OpenRequest(fragment).setCallback(callback));
+    }
+
+    private static Session openActiveSession(Context context, boolean allowLoginUI, OpenRequest openRequest) {
+        Session session = new Builder(context).build();
+        if (SessionState.CREATED_TOKEN_LOADED.equals(session.getState()) || allowLoginUI) {
+            setActiveSession(session);
+            if (openRequest != null) {
+                session.openForRead(openRequest);
+            } else {
+                session.open();
+            }
+            return session;
+        }
+        return null;
+    }
+
+    static Context getStaticContext() {
+        return staticContext;
+    }
+
+    static void initializeStaticContext(Context currentContext) {
+        if ((currentContext != null) && (staticContext == null)) {
+            Context applicationContext = currentContext.getApplicationContext();
+            staticContext = (applicationContext != null) ? applicationContext : currentContext;
+        }
+    }
+
+    void authorize(AuthorizationRequest request) {
+        boolean started = false;
+
+        autoPublishAsync();
+
+        if (!started && request.allowKatana()) {
+            started = tryKatanaProxyAuth(request);
+        }
+        if (!started && request.allowWebView()) {
+            started = tryDialogAuth(request);
+        }
+
+        if (!started) {
+            synchronized (this.lock) {
+                final SessionState oldState = this.state;
+
+                switch (this.state) {
+                    case CLOSED:
+                    case CLOSED_LOGIN_FAILED:
+                        return;
+
+                    default:
+                        this.state = SessionState.CLOSED_LOGIN_FAILED;
+                        postStateChange(oldState, this.state, new FacebookException("Log in attempt failed."));
+                }
+            }
+        }
+    }
+
+    public final void addCallback(StatusCallback callback) {
+        synchronized(callbacks) {
+            if (callback != null && !callbacks.contains(callback)) {
+                callbacks.add(callback);
+            }
+        }
+    }
+
+    public final void removeCallback(StatusCallback callback) {
+        synchronized(callbacks) {
+            callbacks.remove(callback);
+        }
+    }
+
+    private void open(OpenRequest openRequest, AuthorizationType authType) {
+        validatePermissions(openRequest, authType);
+        validateLoginBehavior(openRequest);
+        SessionState newState;
+        synchronized (this.lock) {
+            if (pendingRequest != null) {
+                throw new UnsupportedOperationException(
+                        "Session: an attempt was made to open a session that has a pending request.");
+            }
+            final SessionState oldState = this.state;
+
+            switch (this.state) {
+                case CREATED:
+                    this.state = newState = SessionState.OPENING;
+                    if (openRequest == null) {
+                        throw new IllegalArgumentException("openRequest cannot be null when opening a new Session");
+                    }
+                    pendingRequest = openRequest;
+                    break;
+                case CREATED_TOKEN_LOADED:
+                    if (openRequest != null && !Utility.isNullOrEmpty(openRequest.getPermissions())) {
+                        if (!Utility.isSubset(openRequest.getPermissions(), getPermissions())) {
+                            pendingRequest = openRequest;
+                        }
+                    }
+                    if (pendingRequest == null) {
+                        this.state = newState = SessionState.OPENED;
+                    } else {
+                        this.state = newState = SessionState.OPENING;
+                    }
+                    break;
+                default:
+                    throw new UnsupportedOperationException(
+                            "Session: an attempt was made to open an already opened session.");
+            }
+            if (openRequest != null) {
+                addCallback(openRequest.getCallback());
+            }
+            this.postStateChange(oldState, newState, null);
+        }
+
+        if (newState == SessionState.OPENING) {
+            authorize(openRequest);
+        }
+    }
+
+    private void reauthorize(ReauthorizeRequest reauthorizeRequest, AuthorizationType authType) {
+        validatePermissions(reauthorizeRequest, authType);
+        validateLoginBehavior(reauthorizeRequest);
+        if (reauthorizeRequest != null) {
+            synchronized (this.lock) {
+                if (pendingRequest != null) {
+                    throw new UnsupportedOperationException(
+                            "Session: an attempt was made to reauthorize a session that has a pending request.");
+                }
+                switch (this.state) {
+                    case OPENED:
+                    case OPENED_TOKEN_UPDATED:
+                        pendingRequest = reauthorizeRequest;
+                        break;
+                    default:
+                        throw new UnsupportedOperationException(
+                                "Session: an attempt was made to reauthorize a session that is not currently open.");
+                }
+            }
+
+            authorize(reauthorizeRequest);
+        }
+    }
+
+    private void validateLoginBehavior(AuthorizationRequest request) {
+        if (request != null && !request.suppressLoginActivityVerification &&
+                (SessionLoginBehavior.SSO_WITH_FALLBACK.equals(request.getLoginBehavior()) ||
+                 SessionLoginBehavior.SUPPRESS_SSO.equals(request.getLoginBehavior()))) {
+            Intent intent = new Intent();
+            intent.setClass(getStaticContext(), LoginActivity.class);
+            if (!resolveIntent(intent, false)) {
+                throw new FacebookException(String.format(
+                        "Cannot use SessionLoginBehavior %s when %s is not declared as an activity in AndroidManifest.xml",
+                        request.getLoginBehavior(), LoginActivity.class.getName()));
+            }
+        }
+    }
+
+    private void validatePermissions(AuthorizationRequest request, AuthorizationType authType) {
+        if (request == null || Utility.isNullOrEmpty(request.getPermissions())) {
+            if (AuthorizationType.PUBLISH.equals(authType)) {
+                throw new FacebookException("Cannot request publish authorization with no permissions.");
+            }
+            return; // nothing to check
+        }
+        for (String permission : request.getPermissions()) {
+            if (isPublishPermission(permission)) {
+                if (AuthorizationType.READ.equals(authType)) {
+                    throw new FacebookException(
+                            String.format(
+                                    "Cannot pass a publish permission (%s) to a request for read authorization",
+                                    permission));
+                }
+            } else {
+                if (AuthorizationType.PUBLISH.equals(authType)) {
+                    Log.w(TAG,
+                            String.format(
+                                    "Should not pass a read permission (%s) to a request for publish authorization",
+                                    permission));
+                }
+            }
+        }
+    }
+
+    private boolean isPublishPermission(String permission) {
+        return permission != null &&
+                (permission.startsWith(PUBLISH_PERMISSION_PREFIX) ||
+                        permission.startsWith(MANAGE_PERMISSION_PREFIX) ||
+                        OTHER_PUBLISH_PERMISSIONS.contains(permission));
+
+    }
+
+    private boolean tryActivityAuth(Intent intent, AuthorizationRequest request, boolean validateSignature) {
+        intent.putExtra("client_id", this.applicationId);
+
+        if (!Utility.isNullOrEmpty(request.getPermissions())) {
+            intent.putExtra("scope", TextUtils.join(",", request.getPermissions()));
+        }
+
+        if (!resolveIntent(intent, validateSignature)) {
+            return false;
+        }
+
+        try {
+            request.getStartActivityDelegate().startActivityForResult(intent, request.getRequestCode());
+        } catch (ActivityNotFoundException e) {
+            return false;
+        }
+        return true;
+    }
+
+    private boolean resolveIntent(Intent intent, boolean validateSignature) {
+        ResolveInfo resolveInfo = getStaticContext().getPackageManager().resolveActivity(intent, 0);
+        if ((resolveInfo == null) ||
+                (validateSignature && !validateFacebookAppSignature(resolveInfo.activityInfo.packageName))) {
+            return false;
+        }
+        return true;
+    }
+
+    private boolean tryDialogAuth(final AuthorizationRequest request) {
+        Intent intent = new Intent();
+
+        intent.setClass(getStaticContext(), LoginActivity.class);
+        if (tryActivityAuth(intent, request, false)) {
+            return true;
+        }
+
+        Log.w(TAG,
+                String.format("Please add %s as an activity to your AndroidManifest.xml",
+                        LoginActivity.class.getName()));
+
+        int permissionCheck = getStaticContext().checkCallingOrSelfPermission(Manifest.permission.INTERNET);
+        Activity activityContext = request.getStartActivityDelegate().getActivityContext();
+        if (permissionCheck != PackageManager.PERMISSION_GRANTED) {
+            AlertDialog.Builder builder = new AlertDialog.Builder(activityContext);
+            builder.setTitle("AndroidManifest Error");
+            builder.setMessage("WebView login requires INTERNET permission");
+            builder.create().show();
+            return false;
+        }
+
+        Bundle parameters = new Bundle();
+        if (!Utility.isNullOrEmpty(request.getPermissions())) {
+            String scope = TextUtils.join(",", request.getPermissions());
+            parameters.putString(ServerProtocol.DIALOG_PARAM_SCOPE, scope);
+        }
+
+        // The call to clear cookies will create the first instance of CookieSyncManager if necessary
+        Utility.clearFacebookCookies(getStaticContext());
+
+        DialogListener listener = new DialogListener() {
+            public void onComplete(Bundle bundle) {
+                // Ensure any cookies set by the dialog are saved
+                CookieSyncManager.getInstance().sync();
+                AccessToken newToken = AccessToken.createFromDialog(request.getPermissions(), bundle);
+                Session.this.authorizationBundle = bundle;
+                Session.this.finishAuth(newToken, null);
+            }
+
+            public void onError(DialogError error) {
+                Bundle bundle = new Bundle();
+                bundle.putInt(WEB_VIEW_ERROR_CODE_KEY, error.getErrorCode());
+                bundle.putString(WEB_VIEW_FAILING_URL_KEY, error.getFailingUrl());
+                Session.this.authorizationBundle = bundle;
+
+                Exception exception = new FacebookAuthorizationException(error.getMessage());
+                Session.this.finishAuth(null, exception);
+            }
+
+            public void onFacebookError(FacebookError error) {
+                Exception exception = new FacebookAuthorizationException(error.getMessage());
+                Session.this.finishAuth(null, exception);
+            }
+
+            public void onCancel() {
+                Exception exception = new FacebookOperationCanceledException("User canceled log in.");
+                Session.this.finishAuth(null, exception);
+            }
+        };
+
+        parameters.putString(ServerProtocol.DIALOG_PARAM_DISPLAY, "touch");
+        parameters.putString(ServerProtocol.DIALOG_PARAM_REDIRECT_URI, "fbconnect://success");
+        parameters.putString(ServerProtocol.DIALOG_PARAM_TYPE, "user_agent");
+        parameters.putString(ServerProtocol.DIALOG_PARAM_CLIENT_ID, this.applicationId);
+
+        Uri uri = Utility.buildUri(ServerProtocol.DIALOG_AUTHORITY, ServerProtocol.DIALOG_OAUTH_PATH, parameters);
+        new FbDialog(activityContext, uri.toString(), listener).show();
+
+        return true;
+    }
+
+    private boolean tryKatanaProxyAuth(AuthorizationRequest request) {
+        Intent intent = new Intent();
+
+        intent.setClassName(NativeProtocol.KATANA_PACKAGE, NativeProtocol.KATANA_PROXY_AUTH_ACTIVITY);
+        return tryActivityAuth(intent, request, true);
+    }
+
+    private boolean validateFacebookAppSignature(String packageName) {
+        PackageInfo packageInfo = null;
+        try {
+            packageInfo = staticContext.getPackageManager().getPackageInfo(packageName,
+                    PackageManager.GET_SIGNATURES);
+        } catch (NameNotFoundException e) {
+            return false;
+        }
+
+        for (Signature signature : packageInfo.signatures) {
+            if (signature.toCharsString().equals(NativeProtocol.KATANA_SIGNATURE)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @SuppressWarnings("incomplete-switch")
+    void finishAuth(AccessToken newToken, Exception exception) {
+        // If the token we came up with is expired/invalid, then auth failed.
+        if ((newToken != null) && newToken.isInvalid()) {
+            newToken = null;
+            exception = new FacebookException("Invalid access token.");
+        }
+
+        // Update the cache if we have a new token.
+        if ((newToken != null) && (this.tokenCache != null)) {
+            this.tokenCache.save(newToken.toCacheBundle());
+        }
+
+        synchronized (this.lock) {
+            final SessionState oldState = this.state;
+
+            switch (this.state) {
+            case OPENING:
+            case OPENED:
+            case OPENED_TOKEN_UPDATED:
+                if (newToken != null) {
+                    this.tokenInfo = newToken;
+                    this.state = (oldState == SessionState.OPENING) ? SessionState.OPENED
+                            : SessionState.OPENED_TOKEN_UPDATED;
+                } else if (exception != null) {
+                    this.state = (oldState == SessionState.OPENING) ? SessionState.CLOSED_LOGIN_FAILED
+                            : oldState;
+                }
+                postStateChange(oldState, this.state, exception);
+                break;
+            }
+            pendingRequest = null;
+        }
+    }
+
+    void postStateChange(final SessionState oldState, final SessionState newState, final Exception exception) {
+        synchronized(callbacks) {
+            // Need to schedule the callbacks inside the same queue to preserve ordering.
+            // Otherwise these callbacks could have been added to the queue before the SessionTracker
+            // gets the ACTIVE_SESSION_SET action.
+            Runnable runCallbacks = new Runnable() {
+                public void run() {
+                    for (final StatusCallback callback : callbacks) {
+                        Runnable closure = new Runnable() {
+                            public void run() {
+                                // This can be called inside a synchronized block.
+                                callback.call(Session.this, newState, exception);
+                            }
+                        };
+        
+                        runWithHandlerOrExecutor(handler, closure);
+                    }
+                }
+            };
+            runWithHandlerOrExecutor(handler, runCallbacks);
+        }
+
+        if (this == Session.activeSession) {
+            if (oldState.isOpened() != newState.isOpened()) {
+                if (newState.isOpened()) {
+                    postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
+                } else {
+                    postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_CLOSED);
+                }
+            }
+        }
+    }
+
+    static void postActiveSessionAction(String action) {
+        final Intent intent = new Intent(action);
+
+        LocalBroadcastManager.getInstance(getStaticContext()).sendBroadcast(intent);
+    }
+
+    private static void runWithHandlerOrExecutor(Handler handler, Runnable runnable) {
+        if (handler != null) {
+            handler.post(runnable);
+        } else {
+            Settings.getExecutor().execute(runnable);
+        }
+    }
+
+    void extendAccessTokenIfNeeded() {
+        if (shouldExtendAccessToken()) {
+            extendAccessToken();
+        }
+    }
+
+    void extendAccessToken() {
+        TokenRefreshRequest newTokenRefreshRequest = null;
+        synchronized (this.lock) {
+            if (currentTokenRefreshRequest == null) {
+                newTokenRefreshRequest = new TokenRefreshRequest();
+                currentTokenRefreshRequest = newTokenRefreshRequest;
+            }
+        }
+
+        if (newTokenRefreshRequest != null) {
+            newTokenRefreshRequest.bind();
+        }
+    }
+
+    boolean shouldExtendAccessToken() {
+        if (currentTokenRefreshRequest != null) {
+            return false;
+        }
+
+        boolean result = false;
+
+        Date now = new Date();
+
+        if (state.isOpened() && tokenInfo.getIsSSO()
+                && now.getTime() - lastAttemptedTokenExtendDate.getTime() > TOKEN_EXTEND_RETRY_SECONDS * 1000
+                && now.getTime() - tokenInfo.getLastRefresh().getTime() > TOKEN_EXTEND_THRESHOLD_SECONDS * 1000) {
+            result = true;
+        }
+
+        return result;
+    }
+
+    AccessToken getTokenInfo() {
+        return tokenInfo;
+    }
+
+    void setTokenInfo(AccessToken tokenInfo) {
+        this.tokenInfo = tokenInfo;
+    }
+
+    Date getLastAttemptedTokenExtendDate() {
+        return lastAttemptedTokenExtendDate;
+    }
+
+    void setLastAttemptedTokenExtendDate(Date lastAttemptedTokenExtendDate) {
+        this.lastAttemptedTokenExtendDate = lastAttemptedTokenExtendDate;
+    }
+
+    void setCurrentTokenRefreshRequest(TokenRefreshRequest request) {
+        this.currentTokenRefreshRequest = request;
+    }
+
+    static String getMetadataApplicationId(Context context) {
+        try {
+            ApplicationInfo ai = context.getPackageManager().getApplicationInfo(
+                    context.getPackageName(), PackageManager.GET_META_DATA);
+            if (ai.metaData != null) {
+                return ai.metaData.getString(APPLICATION_ID_PROPERTY);
+            }
+        } catch (NameNotFoundException e) {
+            // if we can't find it in the manifest, just return null
+        }
+
+        return null;
+    }
+
+    class TokenRefreshRequest implements ServiceConnection {
+
+        final Messenger messageReceiver = new Messenger(
+                new TokenRefreshRequestHandler(Session.this, this));
+
+        Messenger messageSender = null;
+
+        public void bind() {
+            Intent intent = new Intent();
+            intent.setClassName(NativeProtocol.KATANA_PACKAGE, NativeProtocol.KATANA_TOKEN_REFRESH_ACTIVITY);
+
+            ResolveInfo resolveInfo = staticContext.getPackageManager().resolveService(intent, 0);
+            if (resolveInfo != null && validateFacebookAppSignature(resolveInfo.serviceInfo.packageName)
+                    && staticContext.bindService(intent, new TokenRefreshRequest(), Context.BIND_AUTO_CREATE)) {
+                setLastAttemptedTokenExtendDate(new Date());
+            } else {
+                cleanup();
+            }
+        }
+
+        @Override
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            messageSender = new Messenger(service);
+            refreshToken();
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName arg) {
+            cleanup();
+
+            // We returned an error so there's no point in
+            // keeping the binding open.
+            staticContext.unbindService(TokenRefreshRequest.this);
+        }
+
+        private void cleanup() {
+            if (currentTokenRefreshRequest == this) {
+                currentTokenRefreshRequest = null;
+            }
+        }
+
+        private void refreshToken() {
+            Bundle requestData = new Bundle();
+            requestData.putString(AccessToken.ACCESS_TOKEN_KEY, getTokenInfo().getToken());
+
+            Message request = Message.obtain();
+            request.setData(requestData);
+            request.replyTo = messageReceiver;
+
+            try {
+                messageSender.send(request);
+            } catch (RemoteException e) {
+                cleanup();
+            }
+        }
+        
+    }
+
+    // Creating a static Handler class to reduce the possibility of a memory leak.
+    // Handler objects for the same thread all share a common Looper object, which they post messages
+    // to and read from. As messages contain target Handler, as long as there are messages with target
+    // handler in the message queue, the handler cannot be garbage collected. If handler is not static,
+    // the instance of the containing class also cannot be garbage collected even if it is destroyed.
+    static class TokenRefreshRequestHandler extends Handler {
+
+        private WeakReference<Session> sessionWeakReference;
+        private WeakReference<TokenRefreshRequest> refreshRequestWeakReference;
+
+        TokenRefreshRequestHandler(Session session, TokenRefreshRequest refreshRequest) {
+            super(Looper.getMainLooper());
+            sessionWeakReference = new WeakReference<Session>(session);
+            refreshRequestWeakReference = new WeakReference<TokenRefreshRequest>(refreshRequest);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            String token = msg.getData().getString(AccessToken.ACCESS_TOKEN_KEY);
+            Session session = sessionWeakReference.get();
+
+            if (session != null && token != null) {
+                session.internalRefreshToken(msg.getData());
+            }
+
+            TokenRefreshRequest request = refreshRequestWeakReference.get();
+            if (request != null) {
+                // The refreshToken function should be called rarely,
+                // so there is no point in keeping the binding open.
+                staticContext.unbindService(request);
+                request.cleanup();
+            }
+        }
+    }
+
+    /**
+     * Provides asynchronous notification of Session state changes.
+     * 
+     * @see Session#open open
+     */
+    public interface StatusCallback {
+        public void call(Session session, SessionState state, Exception exception);
+    }
+    
+    @Override
+    public int hashCode() {
+        return 0;
+    }
+    
+    @Override
+    public boolean equals(Object otherObj) {
+        if (!(otherObj instanceof Session)) {
+            return false;
+        }
+        Session other = (Session) otherObj;
+        
+        return areEqual(other.applicationId, applicationId) &&
+                areEqual(other.authorizationBundle, authorizationBundle) &&
+                areEqual(other.state, state) &&
+                areEqual(other.getExpirationDate(), getExpirationDate());
+    }
+    
+    private static boolean areEqual(Object a, Object b) {
+        if (a == null) {
+            return b == null;
+        } else {
+            return a.equals(b);
+        }
+    }
+
+    /**
+     * Builder class used to create a Session.
+     */
+    public static final class Builder {
+        private final Context context;
+        private String applicationId;
+        private TokenCache tokenCache;
+        private boolean shouldAutoPublishInstall = true;
+
+        /**
+         * Constructs a new Builder associated with the context.
+         *
+         * @param context the Activity or Service starting the Session
+         */
+        public Builder(Context context) {
+            this.context = context;
+        }
+
+        /**
+         * Sets the application id for the Session.
+         *
+         * @param applicationId the application id
+         * @return the Builder instance
+         */
+        public Builder setApplicationId(final String applicationId) {
+            this.applicationId = applicationId;
+            return this;
+        }
+
+        /**
+         * Sets the TokenCache for the Session.
+         *
+         * @param tokenCache the token cache to use
+         * @return the Builder instance
+         */
+        public Builder setTokenCache(final TokenCache tokenCache) {
+            this.tokenCache = tokenCache;
+            return this;
+        }
+
+        public Builder setShouldAutoPublishInstall(boolean shouldAutoPublishInstall) {
+            this.shouldAutoPublishInstall = shouldAutoPublishInstall;
+            return this;
+        }
+
+        /**
+         * Build the Session.
+         *
+         * @return a new Session
+         */
+        public Session build() {
+            return new Session(context, applicationId, tokenCache, shouldAutoPublishInstall);
+        }
+    }
+
+    private interface StartActivityDelegate {
+        public void startActivityForResult(Intent intent, int requestCode);
+
+        public Activity getActivityContext();
+    }
+
+    enum AuthorizationType {
+        READ,
+        PUBLISH
+    }
+
+    private void autoPublishAsync() {
+        AutoPublishAsyncTask asyncTask = null;
+        synchronized (this) {
+            if (autoPublishAsyncTask == null && shouldAutoPublish) {
+                // copy the application id to guarantee thread safety against our container.
+                String applicationId = Session.this.applicationId;
+
+                // skip publish if we don't have an application id.
+                if (applicationId != null) {
+                    asyncTask = autoPublishAsyncTask = new AutoPublishAsyncTask(applicationId, staticContext);
+                }
+            }
+        }
+
+        if (asyncTask != null) {
+            asyncTask.execute();
+        }
+    }
+
+    /**
+     * Async implementation to allow auto publishing to not block the ui thread.
+     */
+    private class AutoPublishAsyncTask extends AsyncTask<Void, Void, Void> {
+        private final String mApplicationId;
+        private final Context mApplicationContext;
+
+        public AutoPublishAsyncTask(String applicationId, Context context) {
+            mApplicationId = applicationId;
+            mApplicationContext = context.getApplicationContext();
+        }
+
+        @Override
+        protected Void doInBackground(Void... voids) {
+            try {
+                Settings.publishInstallAndWait(mApplicationContext, mApplicationId);
+            } catch (Exception e) {
+                Util.logd("Facebook-publish", e.getMessage());
+            }
+            return null;
+        }
+
+        @Override
+        protected void onPostExecute(Void result) {
+            // always clear out the publisher to allow other invocations.
+            synchronized (Session.this) {
+                autoPublishAsyncTask = null;
+            }
+        }
+    }
+
+    public static class AuthorizationRequest implements Serializable {
+
+        private static final long serialVersionUID = 1L;
+
+        private final StartActivityDelegate startActivityDelegate;
+        private SessionLoginBehavior loginBehavior = SessionLoginBehavior.SSO_WITH_FALLBACK;
+        private int requestCode = DEFAULT_AUTHORIZE_ACTIVITY_CODE;
+        private StatusCallback statusCallback;
+        private boolean suppressLoginActivityVerification = false;
+        private List<String> permissions = Collections.emptyList();
+
+        AuthorizationRequest(final Activity activity) {
+            startActivityDelegate = new StartActivityDelegate() {
+                @Override
+                public void startActivityForResult(Intent intent, int requestCode) {
+                    activity.startActivityForResult(intent, requestCode);
+                }
+
+                @Override
+                public Activity getActivityContext() {
+                    return activity;
+                }
+            };
+        }
+
+        AuthorizationRequest(final Fragment fragment) {
+            startActivityDelegate = new StartActivityDelegate() {
+                @Override
+                public void startActivityForResult(Intent intent, int requestCode) {
+                    fragment.startActivityForResult(intent, requestCode);
+                }
+
+                @Override
+                public Activity getActivityContext() {
+                    return fragment.getActivity();
+                }
+            };
+        }
+
+        /**
+         * Constructor to be used for V1 serialization only, DO NOT CHANGE.
+         */
+        private AuthorizationRequest(SessionLoginBehavior loginBehavior, int requestCode,
+                List<String> permissions, boolean suppressLoginActivityVerification) {
+            startActivityDelegate = new StartActivityDelegate() {
+                @Override
+                public void startActivityForResult(Intent intent, int requestCode) {
+                    throw new UnsupportedOperationException(
+                            "Cannot create an AuthorizationRequest without a valid Activity or Fragment");
+                }
+
+                @Override
+                public Activity getActivityContext() {
+                    throw new UnsupportedOperationException(
+                            "Cannot create an AuthorizationRequest without a valid Activity or Fragment");
+                }
+            };
+            this.loginBehavior = loginBehavior;
+            this.requestCode = requestCode;
+            this.permissions = permissions;
+            this.suppressLoginActivityVerification = suppressLoginActivityVerification;
+        }
+
+        /**
+         * Used for backwards compatibility with Facebook.java only, DO NOT USE.
+         *
+         * @param suppressVerification
+         */
+        public void suppressLoginActivityVerification(boolean suppressVerification) {
+            suppressLoginActivityVerification = suppressVerification;
+        }
+
+        AuthorizationRequest setCallback(StatusCallback statusCallback) {
+            this.statusCallback = statusCallback;
+            return this;
+        }
+
+        StatusCallback getCallback() {
+            return statusCallback;
+        }
+
+        AuthorizationRequest setLoginBehavior(SessionLoginBehavior loginBehavior) {
+            if (loginBehavior != null) {
+                this.loginBehavior = loginBehavior;
+            }
+            return this;
+        }
+
+        SessionLoginBehavior getLoginBehavior() {
+            return loginBehavior;
+        }
+
+        AuthorizationRequest setRequestCode(int requestCode) {
+            if (requestCode >= 0) {
+                this.requestCode = requestCode;
+            }
+            return this;
+        }
+
+        int getRequestCode() {
+            return requestCode;
+        }
+
+        AuthorizationRequest setPermissions(List<String> permissions) {
+            if (permissions != null) {
+                this.permissions = permissions;
+            }
+            return this;
+        }
+
+        List<String> getPermissions() {
+            return permissions;
+        }
+
+        StartActivityDelegate getStartActivityDelegate() {
+            return startActivityDelegate;
+        }
+
+        boolean allowKatana() {
+            switch (loginBehavior) {
+                case SSO_ONLY: return true;
+                case SUPPRESS_SSO: return false;
+                default: return true;
+            }
+        }
+
+        boolean allowWebView() {
+            switch (loginBehavior) {
+                case SSO_ONLY: return false;
+                case SUPPRESS_SSO: return true;
+                default: return true;
+            }
+        }
+
+        // package private so subclasses can use it
+        Object writeReplace() {
+            return new AuthRequestSerializationProxyV1(loginBehavior, requestCode, permissions,
+                    suppressLoginActivityVerification);
+        }
+
+        // have a readObject that throws to prevent spoofing
+        // package private so subclasses can use it
+        void readObject(ObjectInputStream stream) throws InvalidObjectException {
+            throw new InvalidObjectException("Cannot readObject, serialization proxy required");
+        }
+
+        private static class AuthRequestSerializationProxyV1 implements Serializable {
+            private static final long serialVersionUID = -8748347685113614927L;
+            private final SessionLoginBehavior loginBehavior;
+            private final int requestCode;
+            private boolean suppressLoginActivityVerification;
+            private final List<String> permissions;
+
+            private AuthRequestSerializationProxyV1(SessionLoginBehavior loginBehavior,
+                    int requestCode, List<String> permissions, boolean suppressVerification) {
+                this.loginBehavior = loginBehavior;
+                this.requestCode = requestCode;
+                this.permissions = permissions;
+                this.suppressLoginActivityVerification = suppressVerification;
+            }
+
+            private Object readResolve() {
+                return new AuthorizationRequest(loginBehavior, requestCode, permissions,
+                        suppressLoginActivityVerification);
+            }
+        }
+    }
+
+    /**
+     * A request used to open a Session.
+     */
+    public static final class OpenRequest extends AuthorizationRequest {
+        private static final long serialVersionUID = 1L;
+
+        /**
+         * Constructs an OpenRequest.
+         *
+         * @param activity the Activity to use to open the Session
+         */
+        public OpenRequest(Activity activity) {
+            super(activity);
+        }
+
+        /**
+         * Constructs an OpenRequest.
+         *
+         * @param fragment the Fragment to use to open the Session
+         */
+        public OpenRequest(Fragment fragment) {
+            super(fragment);
+        }
+
+        /**
+         * Sets the StatusCallback for the OpenRequest.
+         *
+         * @param statusCallback
+         *            The {@link StatusCallback SessionStatusCallback} to
+         *            notify regarding Session state changes.
+         * @return the OpenRequest object to allow for chaining
+         */
+        public final OpenRequest setCallback(StatusCallback statusCallback) {
+            super.setCallback(statusCallback);
+            return this;
+        }
+
+        /**
+         * Sets the login behavior for the OpenRequest.
+         *
+         * @param loginBehavior
+         *            The {@link SessionLoginBehavior SessionLoginBehavior} that
+         *            specifies what behaviors should be attempted during
+         *            authorization.
+         * @return the OpenRequest object to allow for chaining
+         */
+        public final OpenRequest setLoginBehavior(SessionLoginBehavior loginBehavior) {
+            super.setLoginBehavior(loginBehavior);
+            return this;
+        }
+
+        /**
+         * Sets the request code for the OpenRequest.
+         *
+         * @param requestCode
+         *            An integer that identifies this request. This integer will be used
+         *            as the request code in {@link Activity#onActivityResult
+         *            onActivityResult}. This integer should be >= 0. If a value < 0 is
+         *            passed in, then a default value will be used.
+         * @return the OpenRequest object to allow for chaining
+         */
+        public final OpenRequest setRequestCode(int requestCode) {
+            super.setRequestCode(requestCode);
+            return this;
+        }
+
+        /**
+         * Sets the permissions for the OpenRequest.
+         *
+         * @param permissions
+         *            A List&lt;String&gt; representing the permissions to request
+         *            during the authentication flow. A null or empty List
+         *            represents basic permissions.
+         * @return the OpenRequest object to allow for chaining
+         */
+        public final OpenRequest setPermissions(List<String> permissions) {
+            super.setPermissions(permissions);
+            return this;
+        }
+    }
+
+    /**
+     * A request to be used to reauthorize a Session.
+     */
+    public static final class ReauthorizeRequest extends AuthorizationRequest {
+        private static final long serialVersionUID = 1L;
+
+        /**
+         * Constructs a ReauthorizeRequest.
+         *
+         * @param activity the Activity used to reauthorize
+         * @param permissions additional permissions to request
+         */
+        public ReauthorizeRequest(Activity activity, List<String> permissions) {
+            super(activity);
+            setPermissions(permissions);
+        }
+
+        /**
+         * Constructs a ReauthorizeRequest.
+         *
+         * @param fragment the Fragment used to reauthorize
+         * @param permissions additional permissions to request
+         */
+        public ReauthorizeRequest(Fragment fragment, List<String> permissions) {
+            super(fragment);
+            setPermissions(permissions);
+        }
+
+        /**
+         * Sets the StatusCallback for the ReauthorizeRequest.
+         *
+         * @param statusCallback
+         *            The {@link StatusCallback SessionStatusCallback} to
+         *            notify regarding Session state changes.
+         * @return the ReauthorizeRequest object to allow for chaining
+         */
+        public final ReauthorizeRequest setCallback(StatusCallback statusCallback) {
+            super.setCallback(statusCallback);
+            return this;
+        }
+
+        /**
+         * Sets the login behavior for the ReauthorizeRequest.
+         *
+         * @param loginBehavior
+         *            The {@link SessionLoginBehavior SessionLoginBehavior} that
+         *            specifies what behaviors should be attempted during
+         *            authorization.
+         * @return the ReauthorizeRequest object to allow for chaining
+         */
+        public final ReauthorizeRequest setLoginBehavior(SessionLoginBehavior loginBehavior) {
+            super.setLoginBehavior(loginBehavior);
+            return this;
+        }
+
+        /**
+         * Sets the request code for the ReauthorizeRequest.
+         *
+         * @param requestCode
+         *            An integer that identifies this request. This integer will be used
+         *            as the request code in {@link Activity#onActivityResult
+         *            onActivityResult}. This integer should be >= 0. If a value < 0 is
+         *            passed in, then a default value will be used.
+         * @return the ReauthorizeRequest object to allow for chaining
+         */
+        public final ReauthorizeRequest setRequestCode(int requestCode) {
+            super.setRequestCode(requestCode);
+            return this;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/SessionLoginBehavior.java b/facebook/src/com/facebook/SessionLoginBehavior.java
new file mode 100644
index 000000000..68d3ffabe
--- /dev/null
+++ b/facebook/src/com/facebook/SessionLoginBehavior.java
@@ -0,0 +1,43 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Specifies the behaviors to try during
+ * {@link Session#openForRead(com.facebook.Session.OpenRequest) openForRead},
+ * {@link Session#openForPublish(com.facebook.Session.OpenRequest) openForPublish},
+ * {@link Session#reauthorizeForRead(com.facebook.Session.ReauthorizeRequest) reauthorizeForRead}, or
+ * {@link Session#reauthorizeForPublish(com.facebook.Session.ReauthorizeRequest) reauthorizeForPublish}.
+ */
+public enum SessionLoginBehavior {
+    /**
+     * Specifies that Session should attempt Single Sign On (SSO), and if that
+     * does not work fall back to dialog auth. This is the default behavior.
+     */
+    SSO_WITH_FALLBACK,
+
+    /**
+     * Specifies that Session should only attempt SSO. If SSO fails, then the
+     * open or reauthorize call fails.
+     */
+    SSO_ONLY,
+
+    /**
+     * Specifies that SSO should not be attempted, and to only use dialog auth.
+     */
+    SUPPRESS_SSO;
+}
diff --git a/facebook/src/com/facebook/SessionState.java b/facebook/src/com/facebook/SessionState.java
new file mode 100644
index 000000000..8fb8de2fb
--- /dev/null
+++ b/facebook/src/com/facebook/SessionState.java
@@ -0,0 +1,117 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * <p>
+ * Identifies the state of a Session.
+ * </p>
+ * <p>
+ * Session objects implement a state machine that controls their lifecycle. This
+ * enum represents the states of the state machine.
+ * </p>
+ */
+public enum SessionState {
+    /**
+     * Indicates that the Session has not yet been opened and has no cached
+     * token. Opening a Session in this state will involve user interaction.
+     */
+    CREATED(Category.CREATED_CATEGORY),
+
+    /**
+     * <p>
+     * Indicates that the Session has not yet been opened and has a cached
+     * token. Opening a Session in this state will not involve user interaction.
+     * </p>
+     * <p>
+     * If you are using Session from an Android Service, you must provide a
+     * TokenCache implementation that contains a valid token to the Session
+     * constructor. The resulting Session will be created in this state, and you
+     * can then safely call open, passing null for the Activity.
+     * </p>
+     */
+    CREATED_TOKEN_LOADED(Category.CREATED_CATEGORY),
+
+    /**
+     * Indicates that the Session is in the process of opening.
+     */
+    OPENING(Category.CREATED_CATEGORY),
+
+    /**
+     * Indicates that the Session is opened. In this state, the Session may be
+     * used with a {@link Request}.
+     */
+    OPENED(Category.OPENED_CATEGORY),
+
+    /**
+     * <p>
+     * Indicates that the Session is opened and that the token has changed. In
+     * this state, the Session may be used with {@link Request}.
+     * </p>
+     * <p>
+     * Every time the token is updated, {@link Session.StatusCallback
+     * StatusCallback} is called with this value.
+     * </p>
+     */
+    OPENED_TOKEN_UPDATED(Category.OPENED_CATEGORY),
+
+    /**
+     * Indicates that the Session is closed, and that it was not closed
+     * normally. Typically this means that the open call failed, and the
+     * Exception parameter to {@link Session.StatusCallback StatusCallback} will
+     * be non-null.
+     */
+    CLOSED_LOGIN_FAILED(Category.CLOSED_CATEGORY),
+
+    /**
+     * Indicates that the Session was closed normally.
+     */
+    CLOSED(Category.CLOSED_CATEGORY);
+
+    private final Category category;
+
+    SessionState(Category category) {
+        this.category = category;
+    }
+
+    /**
+     * Returns a boolean indicating whether the state represents a successfully
+     * opened state in which the Session can be used with a {@link Request}.
+     * 
+     * @return a boolean indicating whether the state represents a successfully
+     *         opened state in which the Session can be used with a
+     *         {@link Request}.
+     */
+    public boolean isOpened() {
+        return this.category == Category.OPENED_CATEGORY;
+    }
+
+    /**
+     * Returns a boolean indicating whether the state represents a closed
+     * Session that can no longer be used with a {@link Request}.
+     * 
+     * @return a boolean indicating whether the state represents a closed
+     * Session that can no longer be used with a {@link Request}.
+     */
+    public boolean isClosed() {
+        return this.category == Category.CLOSED_CATEGORY;
+    }
+
+    private enum Category {
+        CREATED_CATEGORY, OPENED_CATEGORY, CLOSED_CATEGORY
+    }
+}
diff --git a/facebook/src/com/facebook/SessionTracker.java b/facebook/src/com/facebook/SessionTracker.java
new file mode 100644
index 000000000..d22898644
--- /dev/null
+++ b/facebook/src/com/facebook/SessionTracker.java
@@ -0,0 +1,236 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.support.v4.content.LocalBroadcastManager;
+
+/**
+ * A Session tracker that tracks either the active Session or the
+ * passed in Session object. This class is not thread safe.
+ */
+class SessionTracker {
+
+    private Session session;
+    private final Session.StatusCallback callback;
+    private final BroadcastReceiver receiver;
+    private final LocalBroadcastManager broadcastManager;
+    private boolean isTracking = false;
+
+    /**
+     * Constructs a SessionTracker to track the active Session object.
+     * 
+     * @param context the context object.
+     * @param callback the callback to use whenever the active Session's 
+     *                 state changes
+     */
+    SessionTracker(Context context, Session.StatusCallback callback) {
+        this(context, callback, null);
+    }
+    
+    /**
+     * Constructs a SessionTracker to track the Session object passed in.
+     * If the Session is null, then it will track the active Session instead.
+     * 
+     * @param context the context object.
+     * @param callback the callback to use whenever the Session's state changes
+     * @param session the Session object to track
+     */
+    SessionTracker(Context context, Session.StatusCallback callback, Session session) {
+        this(context, callback, session, true);
+    }
+    
+    /**
+     * Constructs a SessionTracker to track the Session object passed in.
+     * If the Session is null, then it will track the active Session instead.
+     * 
+     * @param context the context object.
+     * @param callback the callback to use whenever the Session's state changes
+     * @param session the Session object to track
+     * @param startTracking whether to start tracking the Session right away
+     */
+    SessionTracker(Context context, Session.StatusCallback callback, Session session, boolean startTracking) {
+        this.callback = new CallbackWrapper(callback);
+        this.session = session;
+        this.receiver = new ActiveSessionBroadcastReceiver();
+        this.broadcastManager = LocalBroadcastManager.getInstance(context);
+
+        if (startTracking) {
+            startTracking();
+        }
+    }
+
+    /**
+     * Returns the current Session that's being tracked.
+     * 
+     * @return the current Session associated with this tracker
+     */
+    Session getSession() {
+        return (session == null) ? Session.getActiveSession() : session;
+    }
+
+    /**
+     * Returns the current Session that's being tracked if it's open, 
+     * otherwise returns null.
+     * 
+     * @return the current Session if it's open, otherwise returns null
+     */
+    Session getOpenSession() {
+        Session openSession = getSession();
+        if (openSession != null && openSession.isOpened()) {
+            return openSession;
+        }
+        return null;
+    }
+
+    /**
+     * Set the Session object to track.
+     * 
+     * @param newSession the new Session object to track
+     */
+    void setSession(Session newSession) {
+        if (newSession == null) {
+            if (session != null) {
+                // We're current tracking a Session. Remove the callback
+                // and start tracking the active Session.
+                session.removeCallback(callback);
+                session = null;
+                addBroadcastReceiver();
+                if (getSession() != null) {
+                    getSession().addCallback(callback);
+                }
+            }
+        } else {
+            if (session == null) {
+                // We're currently tracking the active Session, but will be
+                // switching to tracking a different Session object.
+                Session activeSession = Session.getActiveSession();
+                if (activeSession != null) {
+                    activeSession.removeCallback(callback);
+                }
+                broadcastManager.unregisterReceiver(receiver);
+            } else {
+                // We're currently tracking a Session, but are now switching 
+                // to a new Session, so we remove the callback from the old 
+                // Session, and add it to the new one.
+                session.removeCallback(callback);
+            }
+            session = newSession;
+            session.addCallback(callback);
+        }
+    }
+
+    /**
+     * Start tracking the Session (either active or the one given). 
+     */
+    void startTracking() {
+        if (isTracking) {
+            return;
+        }
+        if (this.session == null) {
+            addBroadcastReceiver();
+        }        
+        // if the session is not null, then add the callback to it right away
+        if (getSession() != null) {
+            getSession().addCallback(callback);
+        }
+        isTracking = true;
+    }
+
+    /**
+     * Stop tracking the Session and remove any callbacks attached
+     * to those sessions.
+     */
+    void stopTracking() {
+        if (!isTracking) {
+            return;
+        }
+        Session session = getSession();
+        if (session != null) {
+            session.removeCallback(callback);
+        }
+        broadcastManager.unregisterReceiver(receiver);
+        isTracking = false;
+    }
+    
+    /**
+     * Returns whether it's currently tracking the Session.
+     * 
+     * @return true if currently tracking the Session
+     */
+    boolean isTracking() {
+        return isTracking;
+    }
+
+    /**
+     * Returns whether it's currently tracking the active Session.
+     *
+     * @return true if the currently tracked session is the active Session.
+     */
+    boolean isTrackingActiveSession() {
+        return session == null;
+    }
+    
+    private void addBroadcastReceiver() {
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Session.ACTION_ACTIVE_SESSION_SET);
+        filter.addAction(Session.ACTION_ACTIVE_SESSION_UNSET);
+        
+        // Add a broadcast receiver to listen to when the active Session
+        // is set or unset, and add/remove our callback as appropriate    
+        broadcastManager.registerReceiver(receiver, filter);
+    }
+
+    /**
+     * The BroadcastReceiver implementation that either adds or removes the callback
+     * from the active Session object as it's SET or UNSET.
+     */
+    private class ActiveSessionBroadcastReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (Session.ACTION_ACTIVE_SESSION_SET.equals(intent.getAction())) {
+                Session session = Session.getActiveSession();
+                if (session != null) {
+                    session.addCallback(SessionTracker.this.callback);
+                }
+            }
+        }
+    }
+
+    private class CallbackWrapper implements Session.StatusCallback {
+
+        private final Session.StatusCallback wrapped;
+        public CallbackWrapper(Session.StatusCallback wrapped) {
+            this.wrapped = wrapped;
+        }
+
+        @Override
+        public void call(Session session, SessionState state, Exception exception) {
+            if (wrapped != null && isTracking()) {
+                wrapped.call(session, state, exception);
+            }
+            // if we're not tracking the Active Session, and the current session
+            // is closed, then start tracking the Active Session.
+            if (session == SessionTracker.this.session && state.isClosed()) {
+                setSession(null);
+            }
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/Settings.java b/facebook/src/com/facebook/Settings.java
new file mode 100644
index 000000000..fc601575f
--- /dev/null
+++ b/facebook/src/com/facebook/Settings.java
@@ -0,0 +1,283 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import com.facebook.android.Util;
+import org.json.JSONException;
+
+import java.lang.reflect.Field;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Allows some customization of sdk behavior.
+ */
+public final class Settings {
+    static final String LOG_TAG_BASE = "FacebookSDK.";
+    private static final HashSet<LoggingBehaviors> loggingBehaviors = new HashSet<LoggingBehaviors>();
+    private static volatile Executor executor;
+    private static final int DEFAULT_CORE_POOL_SIZE = 5;
+    private static final int DEFAULT_MAXIMUM_POOL_SIZE = 128;
+    private static final int DEFAULT_KEEP_ALIVE = 1;
+    private static final Object LOCK = new Object();
+
+    private static final Uri ATTRIBUTION_ID_CONTENT_URI =
+            Uri.parse("content://com.facebook.katana.provider.AttributionIdProvider");
+    private static final String ATTRIBUTION_ID_COLUMN_NAME = "aid";
+
+    private static final String ATTRIBUTION_PREFERENCES = "com.facebook.sdk.attributionTracking";
+    private static final String PUBLISH_ACTIVITY_PATH = "%s/activities";
+    private static final String MOBILE_INSTALL_EVENT = "MOBILE_APP_INSTALL";
+    private static final String SUPPORTS_ATTRIBUTION = "supports_attribution";
+    private static final String APPLICATION_FIELDS = "fields";
+    private static final String ANALYTICS_EVENT = "event";
+    private static final String ATTRIBUTION_KEY = "attribution";
+
+    private static final BlockingQueue<Runnable> DEFAULT_WORK_QUEUE = new LinkedBlockingQueue<Runnable>(10);
+
+    private static final ThreadFactory DEFAULT_THREAD_FACTORY = new ThreadFactory() {
+        private final AtomicInteger counter = new AtomicInteger(0);
+
+        public Thread newThread(Runnable runnable) {
+            return new Thread(runnable, "FacebookSdk #" + counter.incrementAndGet());
+        }
+    };
+
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Returns the types of extended logging that are currently enabled.
+     *
+     * @return a set containing enabled logging behaviors
+     */
+    public static final Set<LoggingBehaviors> getLoggingBehaviors() {
+        synchronized (loggingBehaviors) {
+            return Collections.unmodifiableSet(new HashSet<LoggingBehaviors>(loggingBehaviors));
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Enables a particular extended logging in the sdk.
+     *
+     * @param behavior
+     *          The LoggingBehavior to enable
+     */
+    public static final void addLoggingBehavior(LoggingBehaviors behavior) {
+        synchronized (loggingBehaviors) {
+            loggingBehaviors.add(behavior);
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Disables a particular extended logging behavior in the sdk.
+     *
+     * @param behavior
+     *          The LoggingBehavior to disable
+     */
+    public static final void removeLoggingBehavior(LoggingBehaviors behavior) {
+        synchronized (loggingBehaviors) {
+            loggingBehaviors.remove(behavior);
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Disables all extended logging behaviors.
+     */
+    public static final void clearLoggingBehaviors() {
+        synchronized (loggingBehaviors) {
+            loggingBehaviors.clear();
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Checks if a particular extended logging behavior is enabled.
+     *
+     * @param behavior
+     *          The LoggingBehavior to check
+     * @return whether behavior is enabled
+     */
+    public static final boolean isLoggingBehaviorEnabled(LoggingBehaviors behavior) {
+        synchronized (loggingBehaviors) {
+            return loggingBehaviors.contains(behavior);
+        }
+    }
+
+    /**
+     * Returns the Executor used by the SDK for non-AsyncTask background work.
+     *
+     * By default this uses AsyncTask Executor via reflection if the API level is high enough.
+     * Otherwise this creates a new Executor with defaults similar to those used in AsyncTask.
+     *
+     * @return an Executor used by the SDK.  This will never be null.
+     */
+    public static Executor getExecutor() {
+        synchronized (LOCK) {
+            if (Settings.executor == null) {
+                Executor executor = getAsyncTaskExecutor();
+                if (executor == null) {
+                    executor = new ThreadPoolExecutor(DEFAULT_CORE_POOL_SIZE, DEFAULT_MAXIMUM_POOL_SIZE,
+                            DEFAULT_KEEP_ALIVE, TimeUnit.SECONDS, DEFAULT_WORK_QUEUE, DEFAULT_THREAD_FACTORY);
+                }
+                Settings.executor = executor;
+            }
+        }
+        return Settings.executor;
+    }
+
+    /**
+     * Sets the Executor used by the SDK for non-AsyncTask background work.
+     *
+     * @param executor
+     *          the Executor to use; must not be null.
+     */
+    public static void setExecutor(Executor executor) {
+        Validate.notNull(executor, "executor");
+        synchronized (LOCK) {
+            Settings.executor = executor;
+        }
+    }
+
+    private static Executor getAsyncTaskExecutor() {
+        Field executorField = null;
+        try {
+            executorField = AsyncTask.class.getField("THREAD_POOL_EXECUTOR");
+        } catch (NoSuchFieldException e) {
+            return null;
+        }
+
+        if (executorField == null) {
+            return null;
+        }
+
+        Object executorObject = null;
+        try {
+            executorObject = executorField.get(null);
+        } catch (IllegalAccessException e) {
+            return null;
+        }
+
+        if (executorObject == null) {
+            return null;
+        }
+
+        if (!(executorObject instanceof Executor)) {
+            return null;
+        }
+
+        return (Executor) executorObject;
+    }
+
+    public static void publishInstallAsync(final Context context, final String applicationId) {
+        // grab the application context ahead of time, since we will return to the caller immediately.
+        final Context applicationContext = context.getApplicationContext();
+        Settings.getExecutor().execute(new Runnable() {
+            @Override
+            public void run() {
+                Settings.publishInstallAndWait(applicationContext, applicationId);
+            }
+        });
+    }
+
+    /**
+     * Manually publish install attribution to the facebook graph.  Internally handles tracking repeat calls to prevent
+     * multiple installs being published to the graph.
+     * @param context
+     * @return returns false on error.  Applications should retry until true is returned.  Safe to call again after
+     * true is returned.
+     */
+    public static boolean publishInstallAndWait(final Context context, final String applicationId) {
+        try {
+            if (applicationId == null) {
+                return false;
+            }
+            String attributionId = Settings.getAttributionId(context.getContentResolver());
+            SharedPreferences preferences = context.getSharedPreferences(ATTRIBUTION_PREFERENCES, Context.MODE_PRIVATE);
+            String pingKey = applicationId+"ping";
+            long lastPing = preferences.getLong(pingKey, 0);
+            if (lastPing == 0 && attributionId != null) {
+                Bundle supportsAttributionParams = new Bundle();
+                supportsAttributionParams.putString(APPLICATION_FIELDS, SUPPORTS_ATTRIBUTION);
+                Request pingRequest = Request.newGraphPathRequest(null, applicationId, null);
+                pingRequest.setParameters(supportsAttributionParams);
+
+                GraphObject supportResponse = pingRequest.executeAndWait().getGraphObject();
+                Object doesSupportAttribution = supportResponse.getProperty(SUPPORTS_ATTRIBUTION);
+
+                if (!(doesSupportAttribution instanceof Boolean)) {
+                    throw new JSONException(String.format(
+                            "%s contains %s instead of a Boolean", SUPPORTS_ATTRIBUTION, doesSupportAttribution));
+                }
+
+                if ((Boolean)doesSupportAttribution) {
+                    GraphObject publishParams = GraphObjectWrapper.createGraphObject();
+                    publishParams.setProperty(ANALYTICS_EVENT, MOBILE_INSTALL_EVENT);
+                    publishParams.setProperty(ATTRIBUTION_KEY, attributionId);
+
+                    String publishUrl = String.format(PUBLISH_ACTIVITY_PATH, applicationId);
+
+                    Request publishRequest = Request.newPostRequest(null, publishUrl, publishParams, null);
+                    publishRequest.executeAndWait();
+
+                    // denote success since no error threw from the post.
+                    SharedPreferences.Editor editor = preferences.edit();
+                    editor.putLong(pingKey, System.currentTimeMillis());
+                    editor.commit();
+                }
+            }
+            return true;
+        } catch (Exception e) {
+            // if there was an error, fall through to the failure case.
+            Util.logd("Facebook-publish", e.getMessage());
+        }
+        return false;
+    }
+
+    public static String getAttributionId(ContentResolver contentResolver) {
+        String [] projection = {ATTRIBUTION_ID_COLUMN_NAME};
+        Cursor c = contentResolver.query(ATTRIBUTION_ID_CONTENT_URI, projection, null, null, null);
+        if (c == null || !c.moveToFirst()) {
+            return null;
+        }
+        String attributionId = c.getString(c.getColumnIndex(ATTRIBUTION_ID_COLUMN_NAME));
+        c.close();
+        return attributionId;
+    }
+}
diff --git a/facebook/src/com/facebook/SharedPreferencesTokenCache.java b/facebook/src/com/facebook/SharedPreferencesTokenCache.java
new file mode 100644
index 000000000..86b638f2e
--- /dev/null
+++ b/facebook/src/com/facebook/SharedPreferencesTokenCache.java
@@ -0,0 +1,382 @@
+/**
+ * Copyright 2010 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+import android.util.Log;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+/*
+ * <p>
+ * An implementation of {@link TokenCache TokenCache} that uses Android SharedPreferences
+ * to persist information.
+ * </p>
+ * <p>
+ * The data to be cached is passed in via a Bundle. Only non-null key-value-pairs where
+ * the value is one of the following types (or an array of the same) are persisted:
+ * boolean, byte, int, long, float, double, char. In addition, String and List<String>
+ * are also supported.
+ * </p>
+ */
+public class SharedPreferencesTokenCache extends TokenCache {
+
+    private static final String DEFAULT_CACHE_KEY = "com.facebook.SharedPreferencesTokenCache.DEFAULT_KEY";
+    private static final String TAG = SharedPreferencesTokenCache.class.getSimpleName();
+
+    private static final String JSON_VALUE_TYPE = "valueType";
+    private static final String JSON_VALUE = "value";
+
+    private static final String TYPE_BOOLEAN = "bool";
+    private static final String TYPE_BOOLEAN_ARRAY = "bool[]";
+    private static final String TYPE_BYTE = "byte";
+    private static final String TYPE_BYTE_ARRAY = "byte[]";
+    private static final String TYPE_SHORT = "short";
+    private static final String TYPE_SHORT_ARRAY = "short[]";
+    private static final String TYPE_INTEGER = "int";
+    private static final String TYPE_INTEGER_ARRAY = "int[]";
+    private static final String TYPE_LONG = "long";
+    private static final String TYPE_LONG_ARRAY = "long[]";
+    private static final String TYPE_FLOAT = "float";
+    private static final String TYPE_FLOAT_ARRAY = "float[]";
+    private static final String TYPE_DOUBLE = "double";
+    private static final String TYPE_DOUBLE_ARRAY = "double[]";
+    private static final String TYPE_CHAR = "char";
+    private static final String TYPE_CHAR_ARRAY = "char[]";
+    private static final String TYPE_STRING = "string";
+    private static final String TYPE_STRING_LIST = "stringList";
+
+    private String cacheKey;
+    private SharedPreferences cache;
+
+    /**
+     * Creates a default {@link SharedPreferencesTokenCache SharedPreferencesTokenCache}
+     * instance that provides access to a single set of token information.
+     *
+     * @param context
+     *              The Context object to use to get the SharedPreferences object.
+     *
+     * @throws NullPointerException if the passed in Context is null
+     */
+    public SharedPreferencesTokenCache(Context context) {
+        this(context, null);
+    }
+
+    /**
+     * Creates a {@link SharedPreferencesTokenCache SharedPreferencesTokenCache} instance
+     * that is distinct for the passed in cacheKey.
+     *
+     * @param context
+     *              The Context object to use to get the SharedPreferences object.
+     *
+     * @param cacheKey
+     *              Identifies a distinct set of token information.
+     *
+     * @throws NullPointerException if the passed in Context is null
+     */
+    public SharedPreferencesTokenCache(Context context, String cacheKey) {
+        Validate.notNull(context, "context");
+
+        this.cacheKey = Utility.isNullOrEmpty(cacheKey) ? DEFAULT_CACHE_KEY : cacheKey;
+
+        // If the application context is available, use that. However, if it isn't
+        // available (possibly because of a context that was created manually), use
+        // the passed in context directly.
+        Context applicationContext = context.getApplicationContext();
+        context = applicationContext != null ? applicationContext : context;
+
+        this.cache = context.getSharedPreferences(
+                this.cacheKey,
+                Context.MODE_PRIVATE);
+    }
+
+    /**
+     * Returns a Bundle that contains the information stored in this cache
+     *
+     * @return A Bundle with the information contained in this cache
+     */
+    public Bundle load() {
+        Bundle settings = new Bundle();
+
+        Map<String, ?> allCachedEntries = cache.getAll();
+
+        for (String key : allCachedEntries.keySet()) {
+            try {
+                deserializeKey(key, settings);
+            } catch (JSONException e) {
+                // Error in the cache. So consider it corrupted and return null
+                Logger.log(LoggingBehaviors.CACHE, Log.WARN, TAG, "Error reading cached value for key: '" + key + "' -- " + e);
+                return null;
+            }
+        }
+
+        return settings;
+    }
+
+    /**
+     * Persists all supported data types present in the passed in Bundle, to the
+     * cache
+     *
+     * @param bundle
+     *          The Bundle containing information to be cached
+     */
+    public void save(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+
+        SharedPreferences.Editor editor = cache.edit();
+
+        for (String key : bundle.keySet()) {
+            try {
+                serializeKey(key, bundle, editor);
+            } catch (JSONException e) {
+                // Error in the bundle. Don't store a partial cache.
+                Logger.log(LoggingBehaviors.CACHE, Log.WARN, TAG, "Error processing value for key: '" + key + "' -- " + e);
+
+                // Bypass the commit and just return. This cancels the entire edit transaction
+                return;
+            }
+        }
+
+        boolean successfulCommit = editor.commit();
+        if (!successfulCommit) {
+            Logger.log(LoggingBehaviors.CACHE, Log.WARN, TAG, "SharedPreferences.Editor.commit() was not successful");
+        }
+    }
+
+    /**
+     * Clears out all token information stored in this cache.
+     */
+    public void clear() {
+        cache.edit().clear().commit();
+    }
+
+    private void serializeKey(String key, Bundle bundle, SharedPreferences.Editor editor)
+        throws JSONException {
+        Object value = bundle.get(key);
+        if (value == null) {
+            // Cannot serialize null values.
+            return;
+        }
+
+        String supportedType = null;
+        JSONArray jsonArray = null;
+        JSONObject json = new JSONObject();
+
+        if (value instanceof Byte) {
+            supportedType = TYPE_BYTE;
+            json.put(JSON_VALUE, ((Byte)value).intValue());
+        } else if (value instanceof Short) {
+            supportedType = TYPE_SHORT;
+            json.put(JSON_VALUE, ((Short)value).intValue());
+        } else if (value instanceof Integer) {
+            supportedType = TYPE_INTEGER;
+            json.put(JSON_VALUE, ((Integer)value).intValue());
+        } else if (value instanceof Long) {
+            supportedType = TYPE_LONG;
+            json.put(JSON_VALUE, ((Long)value).longValue());
+        } else if (value instanceof Float) {
+            supportedType = TYPE_FLOAT;
+            json.put(JSON_VALUE, ((Float)value).doubleValue());
+        } else if (value instanceof Double) {
+            supportedType = TYPE_DOUBLE;
+            json.put(JSON_VALUE, ((Double)value).doubleValue());
+        } else if (value instanceof Boolean) {
+            supportedType = TYPE_BOOLEAN;
+            json.put(JSON_VALUE, ((Boolean)value).booleanValue());
+        } else if (value instanceof Character) {
+            supportedType = TYPE_CHAR;
+            json.put(JSON_VALUE, value.toString());
+        } else if (value instanceof String) {
+            supportedType = TYPE_STRING;
+            json.put(JSON_VALUE, (String)value);
+        } else {
+            // Optimistically create a JSONArray. If not an array type, we can null
+            // it out later
+            jsonArray = new JSONArray();
+            if (value instanceof byte[]) {
+                supportedType = TYPE_BYTE_ARRAY;
+                for (byte v : (byte[])value) {
+                    jsonArray.put((int)v);
+                }
+            } else if (value instanceof short[]) {
+                supportedType = TYPE_SHORT_ARRAY;
+                for (short v : (short[])value) {
+                    jsonArray.put((int)v);
+                }
+            } else if (value instanceof int[]) {
+                supportedType = TYPE_INTEGER_ARRAY;
+                for (int v : (int[])value) {
+                    jsonArray.put(v);
+                }
+            } else if (value instanceof long[]) {
+                supportedType = TYPE_LONG_ARRAY;
+                for (long v : (long[])value) {
+                    jsonArray.put(v);
+                }
+            } else if (value instanceof float[]) {
+                supportedType = TYPE_FLOAT_ARRAY;
+                for (float v : (float[])value) {
+                    jsonArray.put((double)v);
+                }
+            } else if (value instanceof double[]) {
+                supportedType = TYPE_DOUBLE_ARRAY;
+                for (double v : (double[])value) {
+                    jsonArray.put(v);
+                }
+            } else if (value instanceof boolean[]) {
+                supportedType = TYPE_BOOLEAN_ARRAY;
+                for (boolean v : (boolean[])value) {
+                    jsonArray.put(v);
+                }
+            } else if (value instanceof char[]) {
+                supportedType = TYPE_CHAR_ARRAY;
+                for (char v : (char[])value) {
+                    jsonArray.put(String.valueOf(v));
+                }
+            } else if (value instanceof List<?>) {
+                supportedType = TYPE_STRING_LIST;
+                @SuppressWarnings("unchecked")
+                List<String> stringList = (List<String>)value;
+                for (String v : stringList) {
+                    jsonArray.put((v == null) ? JSONObject.NULL : v);
+                }
+            } else {
+                // Unsupported type. Clear out the array as a precaution even though
+                // it is redundant with the null supportedType.
+                jsonArray = null;
+            }
+        }
+
+        if (supportedType != null) {
+            json.put(JSON_VALUE_TYPE, supportedType);
+            if (jsonArray != null) {
+                // If we have an array, it has already been converted to JSON. So use
+                // that instead.
+                json.putOpt(JSON_VALUE, jsonArray);
+            }
+
+            String jsonString = json.toString();
+            editor.putString(key, jsonString);
+        }
+    }
+
+    private void deserializeKey(String key, Bundle bundle)
+            throws JSONException {
+        String jsonString = cache.getString(key, "{}");
+        JSONObject json = new JSONObject(jsonString);
+
+        String valueType = json.getString(JSON_VALUE_TYPE);
+
+        if (valueType.equals(TYPE_BOOLEAN)) {
+            bundle.putBoolean(key, json.getBoolean(JSON_VALUE));
+        } else if (valueType.equals(TYPE_BOOLEAN_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            boolean[] array = new boolean[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = jsonArray.getBoolean(i);
+            }
+            bundle.putBooleanArray(key, array);
+        } else if (valueType.equals(TYPE_BYTE)) {
+            bundle.putByte(key, (byte)json.getInt(JSON_VALUE));
+        } else if (valueType.equals(TYPE_BYTE_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            byte[] array = new byte[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = (byte)jsonArray.getInt(i);
+            }
+            bundle.putByteArray(key, array);
+        } else if (valueType.equals(TYPE_SHORT)) {
+            bundle.putShort(key, (short)json.getInt(JSON_VALUE));
+        } else if (valueType.equals(TYPE_SHORT_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            short[] array = new short[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = (short)jsonArray.getInt(i);
+            }
+            bundle.putShortArray(key, array);
+        } else if (valueType.equals(TYPE_INTEGER)) {
+            bundle.putInt(key, json.getInt(JSON_VALUE));
+        } else if (valueType.equals(TYPE_INTEGER_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            int[] array = new int[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = jsonArray.getInt(i);
+            }
+            bundle.putIntArray(key, array);
+        } else if (valueType.equals(TYPE_LONG)) {
+            bundle.putLong(key, json.getLong(JSON_VALUE));
+        } else if (valueType.equals(TYPE_LONG_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            long[] array = new long[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = jsonArray.getLong(i);
+            }
+            bundle.putLongArray(key, array);
+        } else if (valueType.equals(TYPE_FLOAT)) {
+            bundle.putFloat(key, (float)json.getDouble(JSON_VALUE));
+        } else if (valueType.equals(TYPE_FLOAT_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            float[] array = new float[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = (float)jsonArray.getDouble(i);
+            }
+            bundle.putFloatArray(key, array);
+        } else if (valueType.equals(TYPE_DOUBLE)) {
+            bundle.putDouble(key, json.getDouble(JSON_VALUE));
+        } else if (valueType.equals(TYPE_DOUBLE_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            double[] array = new double[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = jsonArray.getDouble(i);
+            }
+            bundle.putDoubleArray(key, array);
+        } else if (valueType.equals(TYPE_CHAR)) {
+            String charString = json.getString(JSON_VALUE);
+            if (charString != null && charString.length() == 1) {
+                bundle.putChar(key, charString.charAt(0));
+            }
+        } else if (valueType.equals(TYPE_CHAR_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            char[] array = new char[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                String charString = jsonArray.getString(i);
+                if (charString != null && charString.length() == 1) {
+                    array[i] = charString.charAt(0);
+                }
+            }
+            bundle.putCharArray(key, array);
+        } else if (valueType.equals(TYPE_STRING)) {
+            bundle.putString(key, json.getString(JSON_VALUE));
+        } else if (valueType.equals(TYPE_STRING_LIST)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            int numStrings = jsonArray.length();
+            ArrayList<String> stringList = new ArrayList<String>(numStrings);
+            for (int i = 0; i < numStrings; i++) {
+                Object jsonStringValue = jsonArray.get(i);
+                stringList.add(i, jsonStringValue == JSONObject.NULL ? null : (String)jsonStringValue);
+            }
+            bundle.putStringArrayList(key, stringList);
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/SimpleGraphObjectCursor.java b/facebook/src/com/facebook/SimpleGraphObjectCursor.java
new file mode 100644
index 000000000..f8385ccf8
--- /dev/null
+++ b/facebook/src/com/facebook/SimpleGraphObjectCursor.java
@@ -0,0 +1,145 @@
+package com.facebook;
+
+import android.database.CursorIndexOutOfBoundsException;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+class SimpleGraphObjectCursor<T extends GraphObject> implements GraphObjectCursor<T> {
+    private int pos = -1;
+    private boolean closed = false;
+    private ArrayList<T> graphObjects = new ArrayList<T>();
+    private boolean moreObjectsAvailable = false;
+    private boolean fromCache = false;
+
+    SimpleGraphObjectCursor() {
+    }
+
+    SimpleGraphObjectCursor(SimpleGraphObjectCursor<T> other) {
+        pos = other.pos;
+        closed = other.closed;
+        graphObjects = new ArrayList<T>();
+        graphObjects.addAll(other.graphObjects);
+        fromCache = other.fromCache;
+
+        // We do not copy observers.
+    }
+
+    public void addGraphObjects(Collection<T> graphObjects, boolean fromCache) {
+        this.graphObjects.addAll(graphObjects);
+        // We consider this cached if ANY results were from the cache.
+        this.fromCache |= fromCache;
+    }
+
+    public boolean isFromCache() {
+        return fromCache;
+    }
+
+    public void setFromCache(boolean fromCache) {
+        this.fromCache = fromCache;
+    }
+
+    public boolean areMoreObjectsAvailable() {
+        return moreObjectsAvailable;
+    }
+
+    public void setMoreObjectsAvailable(boolean moreObjectsAvailable) {
+        this.moreObjectsAvailable = moreObjectsAvailable;
+    }
+
+    @Override
+    public int getCount() {
+        return graphObjects.size();
+    }
+
+    @Override
+    public int getPosition() {
+        return pos;
+    }
+
+    @Override
+    public boolean move(int offset) {
+        return moveToPosition(pos + offset);
+    }
+
+    @Override
+    public boolean moveToPosition(int position) {
+        final int count = getCount();
+        if (position >= count) {
+            pos = count;
+            return false;
+        }
+
+        if (position < 0) {
+            pos = -1;
+            return false;
+        }
+
+        pos = position;
+        return true;
+    }
+
+    @Override
+    public boolean moveToFirst() {
+        return moveToPosition(0);
+    }
+
+    @Override
+    public boolean moveToLast() {
+        return moveToPosition(getCount() - 1);
+    }
+
+    @Override
+    public boolean moveToNext() {
+        return moveToPosition(pos + 1);
+    }
+
+    @Override
+    public boolean moveToPrevious() {
+        return moveToPosition(pos - 1);
+    }
+
+    @Override
+    public boolean isFirst() {
+        return (pos == 0) && (getCount() != 0);
+    }
+
+    @Override
+    public boolean isLast() {
+        final int count = getCount();
+        return (pos == (count - 1)) && (count != 0);
+    }
+
+    @Override
+    public boolean isBeforeFirst() {
+        return (getCount() == 0) || (pos == -1);
+    }
+
+    @Override
+    public boolean isAfterLast() {
+        final int count = getCount();
+        return (count == 0) || (pos == count);
+    }
+
+    @Override
+    public T getGraphObject() {
+        if (pos < 0) {
+            throw new CursorIndexOutOfBoundsException("Before first object.");
+        }
+        if (pos >= graphObjects.size()) {
+            throw new CursorIndexOutOfBoundsException("After last object.");
+        }
+        return graphObjects.get(pos);
+    }
+
+    @Override
+    public void close() {
+        closed = true;
+    }
+
+    @Override
+    public boolean isClosed() {
+        return closed;
+    }
+
+}
diff --git a/facebook/src/com/facebook/TokenCache.java b/facebook/src/com/facebook/TokenCache.java
new file mode 100644
index 000000000..44fe3bd90
--- /dev/null
+++ b/facebook/src/com/facebook/TokenCache.java
@@ -0,0 +1,378 @@
+/**
+ * Copyright 2010 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.os.Bundle;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+/**
+ * <p>
+ * A base class for implementations of a {@link Session Session} token cache.
+ * </p>
+ * <p>
+ * The Session constructor optionally takes a TokenCache, from which it will
+ * attempt to load a cached token during construction. Also, whenever the
+ * Session updates its token, it will also save the token and associated state
+ * to the TokenCache.
+ * </p>
+ * <p>
+ * This is the only mechanism supported for an Android service to use Session.
+ * The service can create a custom TokenCache that returns the Session provided
+ * by an Activity through which the user logged in to Facebook.
+ * </p>
+ */
+public abstract class TokenCache {
+    /**
+     * The key used by Session to store the token value in the Bundle during
+     * load and save.
+     */
+    public static final String TOKEN_KEY = "com.facebook.TokenCache.Token";
+
+    /**
+     * The key used by Session to store the expiration date value in the Bundle
+     * during load and save.
+     */
+    public static final String EXPIRATION_DATE_KEY = "com.facebook.TokenCache.ExpirationDate";
+
+    /**
+     * The key used by Session to store the last refresh date value in the
+     * Bundle during load and save.
+     */
+    public static final String LAST_REFRESH_DATE_KEY = "com.facebook.TokenCache.LastRefreshDate";
+
+    /**
+     * The key used by Session to store the user's id value in the Bundle during
+     * load and save.
+     */
+    public static final String USER_FBID_KEY = "com.facebook.TokenCache.UserFBID";
+
+    /**
+     * The key used by Session to store a boolean indicating whether the token
+     * was SSO in the Bundle during load and save.
+     */
+    public static final String IS_SSO_KEY = "com.facebook.TokenCache.IsSSO";
+
+    /**
+     * The key used by Session to store the list of permissions granted by the
+     * token in the Bundle during load and save.
+     */
+    public static final String PERMISSIONS_KEY = "com.facebook.TokenCache.Permissions";
+
+    private static final long INVALID_BUNDLE_MILLISECONDS = Long.MIN_VALUE;
+
+    /**
+     * Called during Session construction to get the token state. Typically this
+     * is loaded from a persistent store that was previously initialized via
+     * save.  The caller may choose to keep a reference to the returned Bundle
+     * indefinitely.  Therefore the TokenCache should not store the returned Bundle
+     * and should return a new Bundle on every call to this method.
+     *
+     * @return A Bundle that represents the token state that was loaded.
+     */
+    public abstract Bundle load();
+
+    /**
+     * Called when a Session updates its token. This is passed a Bundle of
+     * values that should be stored durably for the purpose of being returned
+     * from a later call to load.  Some implementations may choose to store
+     * bundle beyond the scope of this call, so the caller should keep no
+     * references to the bundle to ensure that it is not modified later.
+     * 
+     * @param bundle
+     *            A Bundle that represents the token state to be saved.
+     */
+    public abstract void save(Bundle bundle);
+
+    /**
+     * Called when a Session learns its token is no longer valid or during a
+     * call to {@link Session#closeAndClearTokenInformation
+     * closeAndClearTokenInformation} to clear the durable state associated with
+     * the token.
+     */
+    public abstract void clear();
+
+    /**
+     * Returns a boolean indicating whether a Bundle contains properties that
+     * could be a valid saved token.
+     * 
+     * @param bundle
+     *            A Bundle to check for token information.
+     * @return a boolean indicating whether a Bundle contains properties that
+     *         could be a valid saved token.
+     */
+    public static boolean hasTokenInformation(Bundle bundle) {
+        if (bundle == null) {
+            return false;
+        }
+
+        String token = bundle.getString(TOKEN_KEY);
+        if ((token == null) || (token.length() == 0)) {
+            return false;
+        }
+
+        long expiresMilliseconds = bundle.getLong(EXPIRATION_DATE_KEY, 0L);
+        if (expiresMilliseconds == 0L) {
+            return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * Gets the cached token value from a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the token value was stored.
+     * @return the cached token value, or null.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static String getToken(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return bundle.getString(TOKEN_KEY);
+    }
+
+    /**
+     * Puts the token value into a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the token value should be stored.
+     * @param value
+     *            The String representing the token value, or null.
+     *
+     * @throws NullPointerException if the passed in Bundle or token value are null
+     */
+    public static void putToken(Bundle bundle, String value) {
+        Validate.notNull(bundle, "bundle");
+        Validate.notNull(value, "value");
+        bundle.putString(TOKEN_KEY, value);
+    }
+
+    /**
+     * Gets the cached expiration date from a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the expiration date was stored.
+     * @return the cached expiration date, or null.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static Date getExpirationDate(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return getDate(bundle, EXPIRATION_DATE_KEY);
+    }
+
+    /**
+     * Puts the expiration date into a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the expiration date should be stored.
+     * @param value
+     *            The Date representing the expiration date.
+     *
+     * @throws NullPointerException if the passed in Bundle or date value are null
+     */
+    public static void putExpirationDate(Bundle bundle, Date value) {
+        Validate.notNull(bundle, "bundle");
+        Validate.notNull(value, "value");
+        putDate(bundle, EXPIRATION_DATE_KEY, value);
+    }
+
+    /**
+     * Gets the cached expiration date from a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the expiration date was stored.
+     * @return the long representing the cached expiration date in milliseconds
+     *         since the epoch, or 0.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static long getExpirationMilliseconds(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return bundle.getLong(EXPIRATION_DATE_KEY);
+    }
+
+    /**
+     * Puts the expiration date into a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the expiration date should be stored.
+     * @param value
+     *            The long representing the expiration date in milliseconds
+     *            since the epoch.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static void putExpirationMilliseconds(Bundle bundle, long value) {
+        Validate.notNull(bundle, "bundle");
+        bundle.putLong(EXPIRATION_DATE_KEY, value);
+    }
+
+    /**
+     * Gets the cached list of permissions from a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the list of permissions was stored.
+     * @return the cached list of permissions.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static List<String> getPermissions(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return bundle.getStringArrayList(PERMISSIONS_KEY);
+    }
+
+    /**
+     * Puts the list of permissions into a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the list of permissions should be stored.
+     * @param value
+     *            The List&lt;String&gt; representing the list of permissions,
+     *            or null.
+     *
+     * @throws NullPointerException if the passed in Bundle or permissions list are null
+     */
+    public static void putPermissions(Bundle bundle, List<String> value) {
+        Validate.notNull(bundle, "bundle");
+        Validate.notNull(value, "value");
+
+        ArrayList<String> arrayList;
+        if (value instanceof ArrayList<?>) {
+            arrayList = (ArrayList<String>) value;
+        } else {
+            arrayList = new ArrayList<String>(value);
+        }
+        bundle.putStringArrayList(PERMISSIONS_KEY, arrayList);
+    }
+
+    /**
+     * Gets the cached boolean indicating whether the token came from SSO from a
+     * Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the boolean indicating whether the token
+     *            came from SSO was stored.
+     * @return the cached boolean indicating whether the token came from SSO, or
+     *         null.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static boolean getIsSSO(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return bundle.getBoolean(IS_SSO_KEY);
+    }
+
+    /**
+     * Puts the boolean indicating whether the token came from SSO into a
+     * Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the boolean indicating whether the token
+     *            came from SSO should be stored.
+     * @param value
+     *            The boolean indicating whether the token came from SSO, or
+     *            null.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static void putIsSSO(Bundle bundle, boolean value) {
+        Validate.notNull(bundle, "bundle");
+        bundle.putBoolean(IS_SSO_KEY, value);
+    }
+
+    /**
+     * Gets the cached last refresh date from a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the last refresh date was stored.
+     * @return the cached last refresh Date, or null.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static Date getLastRefreshDate(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return getDate(bundle, LAST_REFRESH_DATE_KEY);
+    }
+
+    /**
+     * Puts the last refresh date into a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the last refresh date should be stored.
+     * @param value
+     *            The Date representing the last refresh date, or null.
+     *
+     * @throws NullPointerException if the passed in Bundle or date value are null
+     */
+    public static void putLastRefreshDate(Bundle bundle, Date value) {
+        Validate.notNull(bundle, "bundle");
+        Validate.notNull(value, "value");
+        putDate(bundle, LAST_REFRESH_DATE_KEY, value);
+    }
+
+    /**
+     * Gets the cached last refresh date from a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the last refresh date was stored.
+     * @return the cached last refresh date in milliseconds since the epoch.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static long getLastRefreshMilliseconds(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return bundle.getLong(LAST_REFRESH_DATE_KEY);
+    }
+
+    /**
+     * Puts the last refresh date into a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the last refresh date should be stored.
+     * @param value
+     *            The long representing the last refresh date in milliseconds
+     *            since the epoch.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static void putLastRefreshMilliseconds(Bundle bundle, long value) {
+        Validate.notNull(bundle, "bundle");
+        bundle.putLong(LAST_REFRESH_DATE_KEY, value);
+    }
+
+    static Date getDate(Bundle bundle, String key) {
+        if (bundle == null) {
+            return null;
+        }
+
+        long n = bundle.getLong(key, INVALID_BUNDLE_MILLISECONDS);
+        if (n == INVALID_BUNDLE_MILLISECONDS) {
+            return null;
+        }
+
+        return new Date(n);
+    }
+
+    static void putDate(Bundle bundle, String key, Date date) {
+        bundle.putLong(key, date.getTime());
+    }
+}
diff --git a/facebook/src/com/facebook/Utility.java b/facebook/src/com/facebook/Utility.java
new file mode 100644
index 000000000..c5583ae45
--- /dev/null
+++ b/facebook/src/com/facebook/Utility.java
@@ -0,0 +1,398 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Parcelable;
+import android.text.TextUtils;
+import android.view.View;
+import android.view.animation.AlphaAnimation;
+import android.webkit.CookieManager;
+import android.webkit.CookieSyncManager;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.json.JSONTokener;
+
+import java.io.*;
+import java.net.HttpURLConnection;
+import java.net.URLConnection;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.text.Collator;
+import java.util.*;
+import java.util.Map.Entry;
+
+final class Utility {
+    static final String LOG_TAG = "FacebookSDK";
+    private static final String HASH_ALGORITHM_MD5 = "MD5";
+    private static final String URL_SCHEME = "http";
+
+    // This is the default used by the buffer streams, but they trace a warning if you do not specify.
+    static final int DEFAULT_STREAM_BUFFER_SIZE = 8192;
+
+    // Returns true iff all items in subset are in superset, treating null and
+    // empty collections as
+    // the same.
+    static <T> boolean isSubset(Collection<T> subset, Collection<T> superset) {
+        if ((superset == null) || (superset.size() == 0)) {
+            return ((subset == null) || (subset.size() == 0));
+        }
+
+        HashSet<T> hash = new HashSet<T>(superset);
+        for (T t : subset) {
+            if (!hash.contains(t)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    static <T> boolean isNullOrEmpty(Collection<T> c) {
+        return (c == null) || (c.size() == 0);
+    }
+
+    static boolean isNullOrEmpty(String s) {
+        return (s == null) || (s.length() == 0);
+    }
+
+    static <T> Collection<T> unmodifiableCollection(T... ts) {
+        return Collections.unmodifiableCollection(Arrays.asList(ts));
+    }
+
+    static <T> ArrayList<T> arrayList(T... ts) {
+        ArrayList<T> arrayList = new ArrayList<T>(ts.length);
+        for (T t : ts) {
+            arrayList.add(t);
+        }
+        return arrayList;
+    }
+
+    static String md5hash(String key) {
+        MessageDigest hash = null;
+        try {
+            hash = MessageDigest.getInstance(HASH_ALGORITHM_MD5);
+        } catch (NoSuchAlgorithmException e) {
+            return null;
+        }
+
+        hash.update(key.getBytes());
+        byte[] digest = hash.digest();
+        StringBuilder builder = new StringBuilder();
+        for (int b : digest) {
+            builder.append(Integer.toHexString((b >> 4) & 0xf));
+            builder.append(Integer.toHexString((b >> 0) & 0xf));
+        }
+        return builder.toString();
+    }
+
+    static Uri buildUri(String authority, String path, Bundle parameters) {
+        Uri.Builder builder = new Uri.Builder();
+        builder.scheme(URL_SCHEME);
+        builder.authority(authority);
+        builder.path(path);
+        for (String key : parameters.keySet()) {
+            Object parameter = parameters.get(key);
+            if (parameter instanceof String) {
+                builder.appendQueryParameter(key, (String) parameter);
+            }
+        }
+        return builder.build();
+    }
+
+    static void putObjectInBundle(Bundle bundle, String key, Object value) {
+        if (value instanceof String) {
+            bundle.putString(key, (String) value);
+        } else if (value instanceof Parcelable) {
+            bundle.putParcelable(key, (Parcelable) value);
+        } else if (value instanceof byte[]) {
+            bundle.putByteArray(key, (byte[]) value);
+        } else {
+            throw new FacebookException("attempted to add unsupported type to Bundle");
+        }
+    }
+
+    static void closeQuietly(Closeable closeable) {
+        try {
+            if (closeable != null) {
+                closeable.close();
+            }
+        } catch (IOException ioe) {
+            // ignore
+        }
+    }
+
+    static void disconnectQuietly(HttpURLConnection connection) {
+        if (connection != null) {
+            connection.disconnect();
+        }
+    }
+
+    static void disconnectQuietly(URLConnection connection) {
+        if (connection instanceof HttpURLConnection) {
+            ((HttpURLConnection)connection).disconnect();
+        }
+    }
+
+    static String convertCamelCaseToLowercaseWithUnderscores(String string) {
+        string = string.replaceAll("([a-z])([A-Z])", "$1_$2");
+        return string.toLowerCase();
+    }
+
+    static void jsonObjectClear(JSONObject jsonObject) {
+        @SuppressWarnings("unchecked")
+        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
+        while (keys.hasNext()) {
+            keys.next();
+            keys.remove();
+        }
+    }
+
+    static boolean jsonObjectContainsValue(JSONObject jsonObject, Object value) {
+        @SuppressWarnings("unchecked")
+        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
+        while (keys.hasNext()) {
+            Object thisValue = jsonObject.opt(keys.next());
+            if (thisValue != null && thisValue.equals(value)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private final static class JSONObjectEntry implements Entry<String, Object> {
+        private final String key;
+        private final Object value;
+
+        JSONObjectEntry(String key, Object value) {
+            this.key = key;
+            this.value = value;
+        }
+
+        @SuppressLint("FieldGetter")
+        @Override
+        public String getKey() {
+            return this.key;
+        }
+
+        @Override
+        public Object getValue() {
+            return this.value;
+        }
+
+        @Override
+        public Object setValue(Object object) {
+            throw new UnsupportedOperationException("JSONObjectEntry is immutable");
+        }
+
+    }
+
+    static Set<Entry<String, Object>> jsonObjectEntrySet(JSONObject jsonObject) {
+        HashSet<Entry<String, Object>> result = new HashSet<Entry<String, Object>>();
+
+        @SuppressWarnings("unchecked")
+        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
+        while (keys.hasNext()) {
+            String key = keys.next();
+            Object value = jsonObject.opt(key);
+            result.add(new JSONObjectEntry(key, value));
+        }
+
+        return result;
+    }
+
+    static Set<String> jsonObjectKeySet(JSONObject jsonObject) {
+        HashSet<String> result = new HashSet<String>();
+
+        @SuppressWarnings("unchecked")
+        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
+        while (keys.hasNext()) {
+            result.add(keys.next());
+        }
+
+        return result;
+    }
+
+    static void jsonObjectPutAll(JSONObject jsonObject, Map<String, Object> map) {
+        Set<Entry<String, Object>> entrySet = map.entrySet();
+        for (Entry<String, Object> entry : entrySet) {
+            try {
+                jsonObject.putOpt(entry.getKey(), entry.getValue());
+            } catch (JSONException e) {
+                throw new IllegalArgumentException(e);
+            }
+        }
+    }
+
+    static Collection<Object> jsonObjectValues(JSONObject jsonObject) {
+        ArrayList<Object> result = new ArrayList<Object>();
+
+        @SuppressWarnings("unchecked")
+        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
+        while (keys.hasNext()) {
+            result.add(jsonObject.opt(keys.next()));
+        }
+
+        return result;
+    }
+
+    static Map<String, Object> convertJSONObjectToHashMap(JSONObject jsonObject) {
+        HashMap<String, Object> map = new HashMap<String, Object>();
+        JSONArray keys = jsonObject.names();
+        for (int i = 0; i < keys.length(); ++i) {
+            String key;
+            try {
+                key = keys.getString(i);
+                Object value = jsonObject.get(key);
+                if (value instanceof JSONObject) {
+                    value = convertJSONObjectToHashMap((JSONObject) value);
+                }
+                map.put(key, value);
+            } catch (JSONException e) {
+            }
+        }
+        return map;
+    }
+
+    // Returns either a JSONObject or JSONArray representation of the 'key' property of 'jsonObject'.
+    static Object getStringPropertyAsJSON(JSONObject jsonObject, String key, String nonJSONPropertyKey)
+            throws JSONException {
+        Object value = jsonObject.opt(key);
+        if (value != null && value instanceof String) {
+            JSONTokener tokener = new JSONTokener((String) value);
+            value = tokener.nextValue();
+        }
+
+        if (value != null && !(value instanceof JSONObject || value instanceof JSONArray)) {
+            if (nonJSONPropertyKey != null) {
+                // Facebook sometimes gives us back a non-JSON value such as
+                // literal "true" or "false" as a result.
+                // If we got something like that, we present it to the caller as
+                // a GraphObject with a single
+                // property. We only do this if the caller wants that behavior.
+                jsonObject = new JSONObject();
+                jsonObject.putOpt(nonJSONPropertyKey, value);
+                return jsonObject;
+            } else {
+                throw new FacebookException("Got an unexpected non-JSON object.");
+            }
+        }
+
+        return value;
+
+    }
+
+    static String readStreamToString(InputStream inputStream) throws IOException {
+        BufferedInputStream bufferedInputStream = null;
+        InputStreamReader reader = null;
+        try {
+            bufferedInputStream = new BufferedInputStream(inputStream);
+            reader = new InputStreamReader(bufferedInputStream);
+            StringBuilder stringBuilder = new StringBuilder();
+
+            final int bufferSize = 1024 * 2;
+            char[] buffer = new char[bufferSize];
+            int n = 0;
+            while ((n = reader.read(buffer)) != -1) {
+                stringBuilder.append(buffer, 0, n);
+            }
+
+            return stringBuilder.toString();
+        } finally {
+            closeQuietly(bufferedInputStream);
+            closeQuietly(reader);
+        }
+    }
+
+    static int compareGraphObjects(GraphObject a, GraphObject b, Collection<String> sortFields,
+            Collator collator) {
+        for (String sortField : sortFields) {
+            String sa = (String) a.getProperty(sortField);
+            String sb = (String) b.getProperty(sortField);
+
+            if (sa != null && sb != null) {
+                int result = collator.compare(sa, sb);
+                if (result != 0) {
+                    return result;
+                }
+            } else if (!(sa == null && sb == null)) {
+                return (sa == null) ? -1 : 1;
+            }
+        }
+        return 0;
+    }
+
+    static void setAlpha(View view, float alpha) {
+        // Set the alpha appropriately (setAlpha is API >= 11, this technique works on all API levels).
+        AlphaAnimation alphaAnimation = new AlphaAnimation(alpha, alpha);
+        alphaAnimation.setDuration(0);
+        alphaAnimation.setFillAfter(true);
+        view.startAnimation(alphaAnimation);
+    }
+
+    static boolean stringsEqualOrEmpty(String a, String b) {
+        boolean aEmpty = TextUtils.isEmpty(a);
+        boolean bEmpty = TextUtils.isEmpty(b);
+
+        if (aEmpty && bEmpty) {
+            // Both null or empty, they match.
+            return true;
+        }
+        if (!aEmpty && !bEmpty) {
+            // Both non-empty, check equality.
+            return a.equals(b);
+        }
+        // One empty, one non-empty, can't match.
+        return false;
+    }
+
+    private static void clearCookiesForDomain(Context context, String domain) {
+        // This is to work around a bug where CookieManager may fail to instantiate if CookieSyncManager
+        // has never been created.
+        CookieSyncManager syncManager = CookieSyncManager.createInstance(context);
+        syncManager.sync();
+
+        CookieManager cookieManager = CookieManager.getInstance();
+
+        String cookies = cookieManager.getCookie(domain);
+        if (cookies == null) {
+            return;
+        }
+
+        String[] splitCookies = cookies.split(";");
+        for (String cookie : splitCookies) {
+            String[] cookieParts = cookie.split("=");
+            if (cookieParts.length > 0) {
+                String newCookie = cookieParts[0].trim() + "=;expires=Sat, 1 Jan 2000 00:00:01 UTC;";
+                cookieManager.setCookie(domain, newCookie);
+            }
+        }
+        cookieManager.removeExpiredCookie();
+    }
+
+    public static void clearFacebookCookies(Context context) {
+        // setCookie acts differently when trying to expire cookies between builds of Android that are using
+        // Chromium HTTP stack and those that are not. Using both of these domains to ensure it works on both.
+        clearCookiesForDomain(context, "facebook.com");
+        clearCookiesForDomain(context, ".facebook.com");
+        clearCookiesForDomain(context, "https://facebook.com");
+        clearCookiesForDomain(context, "https://.facebook.com");
+    }
+}
diff --git a/facebook/src/com/facebook/Validate.java b/facebook/src/com/facebook/Validate.java
new file mode 100644
index 000000000..63bc8eb55
--- /dev/null
+++ b/facebook/src/com/facebook/Validate.java
@@ -0,0 +1,52 @@
+package com.facebook;
+
+import java.util.Collection;
+
+final class Validate {
+    static void notNull(Object arg, String name) {
+        if (arg == null) {
+            throw new NullPointerException("Argument " + name + " cannot be null");
+        }
+    }
+
+    static <T> void notEmpty(Collection<T> container, String name) {
+        if (container.isEmpty()) {
+            throw new IllegalArgumentException("Container '" + name + "' cannot be empty");
+        }
+    }
+
+    static <T> void containsNoNulls(Collection<T> container, String name) {
+        Validate.notNull(container, name);
+        for (T item : container) {
+            if (item == null) {
+                throw new NullPointerException("Container '" + name + "' cannot contain null values");
+            }
+        }
+    }
+
+    static <T> void notEmptyAndContainsNoNulls(Collection<T> container, String name) {
+        Validate.containsNoNulls(container, name);
+        Validate.notEmpty(container, name);
+    }
+
+    static void notNullOrEmpty(String arg, String name) {
+        if (Utility.isNullOrEmpty(arg)) {
+            throw new IllegalArgumentException("Argument " + name + " cannot be null or empty");
+        }
+    }
+
+    static void oneOf(Object arg, String name, Object... values) {
+        for (Object value : values) {
+            if (value != null) {
+                if (value.equals(arg)) {
+                    return;
+                }
+            } else {
+                if (arg == null) {
+                    return;
+                }
+            }
+        }
+        throw new IllegalArgumentException("Argument " + name + " was not one of the allowed values");
+    }
+}
diff --git a/facebook/src/com/facebook/android/AsyncFacebookRunner.java b/facebook/src/com/facebook/android/AsyncFacebookRunner.java
index be3870a1a..eb9754f60 100644
--- a/facebook/src/com/facebook/android/AsyncFacebookRunner.java
+++ b/facebook/src/com/facebook/android/AsyncFacebookRunner.java
@@ -16,13 +16,13 @@
 
 package com.facebook.android;
 
+import android.content.Context;
+import android.os.Bundle;
+
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.net.MalformedURLException;
 
-import android.content.Context;
-import android.os.Bundle;
-
 /**
  * A sample implementation of asynchronous API requests. This class provides
  * the ability to execute API methods and have the call return immediately,
@@ -57,10 +57,12 @@ public AsyncFacebookRunner(Facebook fb) {
      * memory, clearing the browser cookies, and calling auth.expireSession
      * through the API. The application will be notified when logout is
      * complete via the callback interface.
-     *
+     * <p/>
      * Note that this method is asynchronous and the callback will be invoked
      * in a background thread; operations that affect the UI will need to be
      * posted to the UI thread or an appropriate handler.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Session} for more info.
      *
      * @param context
      *            The Android context in which the logout should be called: it
@@ -74,13 +76,14 @@ public AsyncFacebookRunner(Facebook fb) {
      *            returns to the callback. This has no effect on the request
      *            itself.
      */
+    @Deprecated
     public void logout(final Context context,
                        final RequestListener listener,
                        final Object state) {
         new Thread() {
             @Override public void run() {
                 try {
-                    String response = fb.logout(context);
+                    String response = fb.logoutImpl(context);
                     if (response.length() == 0 || response.equals("false")){
                         listener.onFacebookError(new FacebookError(
                                 "auth.expireSession failed"), state);
@@ -98,6 +101,7 @@ public void logout(final Context context,
         }.start();
     }
 
+    @Deprecated
     public void logout(final Context context, final RequestListener listener) {
         logout(context, listener, /* state */ null);
     }
@@ -106,19 +110,21 @@ public void logout(final Context context, final RequestListener listener) {
      * Make a request to Facebook's old (pre-graph) API with the given
      * parameters. One of the parameter keys must be "method" and its value
      * should be a valid REST server API method.
-     *
+     * <p/>
      * See http://developers.facebook.com/docs/reference/rest/
-     *
+     * <p/>
      * Note that this method is asynchronous and the callback will be invoked
      * in a background thread; operations that affect the UI will need to be
      * posted to the UI thread or an appropriate handler.
-     *
+     * <p/>
      * Example:
      * <code>
      *  Bundle parameters = new Bundle();
      *  parameters.putString("method", "auth.expireSession", new Listener());
      *  String response = request(parameters);
      * </code>
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
      *
      * @param parameters
      *            Key-value pairs of parameters to the request. Refer to the
@@ -131,24 +137,28 @@ public void logout(final Context context, final RequestListener listener) {
      *            returns to the callback. This has no effect on the request
      *            itself.
      */
+    @Deprecated
     public void request(Bundle parameters,
                         RequestListener listener,
                         final Object state) {
         request(null, parameters, "GET", listener, state);
     }
 
+    @Deprecated
     public void request(Bundle parameters, RequestListener listener) {
         request(null, parameters, "GET", listener, /* state */ null);
     }
 
     /**
      * Make a request to the Facebook Graph API without any parameters.
-     *
+     * <p/>
      * See http://developers.facebook.com/docs/api
-     *
+     * <p/>
      * Note that this method is asynchronous and the callback will be invoked
      * in a background thread; operations that affect the UI will need to be
      * posted to the UI thread or an appropriate handler.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
      *
      * @param graphPath
      *            Path to resource in the Facebook graph, e.g., to fetch data
@@ -162,12 +172,14 @@ public void request(Bundle parameters, RequestListener listener) {
      *            returns to the callback. This has no effect on the request
      *            itself.
      */
+    @Deprecated
     public void request(String graphPath,
                         RequestListener listener,
                         final Object state) {
         request(graphPath, new Bundle(), "GET", listener, state);
     }
 
+    @Deprecated
     public void request(String graphPath, RequestListener listener) {
         request(graphPath, new Bundle(), "GET", listener, /* state */ null);
     }
@@ -175,12 +187,14 @@ public void request(String graphPath, RequestListener listener) {
     /**
      * Make a request to the Facebook Graph API with the given string parameters
      * using an HTTP GET (default method).
-     *
+     * <p/>
      * See http://developers.facebook.com/docs/api
-     *
+     * <p/>
      * Note that this method is asynchronous and the callback will be invoked
      * in a background thread; operations that affect the UI will need to be
      * posted to the UI thread or an appropriate handler.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
      *
      * @param graphPath
      *            Path to resource in the Facebook graph, e.g., to fetch data
@@ -199,6 +213,7 @@ public void request(String graphPath, RequestListener listener) {
      *            returns to the callback. This has no effect on the request
      *            itself.
      */
+    @Deprecated
     public void request(String graphPath,
                         Bundle parameters,
                         RequestListener listener,
@@ -206,6 +221,7 @@ public void request(String graphPath,
         request(graphPath, parameters, "GET", listener, state);
     }
 
+    @Deprecated
     public void request(String graphPath,
                         Bundle parameters,
                         RequestListener listener) {
@@ -216,12 +232,14 @@ public void request(String graphPath,
      * Make a request to the Facebook Graph API with the given HTTP method and
      * string parameters. Note that binary data parameters (e.g. pictures) are
      * not yet supported by this helper function.
-     *
+     * <p/>
      * See http://developers.facebook.com/docs/api
-     *
+     * <p/>
      * Note that this method is asynchronous and the callback will be invoked
      * in a background thread; operations that affect the UI will need to be
      * posted to the UI thread or an appropriate handler.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
      *
      * @param graphPath
      *            Path to resource in the Facebook graph, e.g., to fetch data
@@ -242,6 +260,7 @@ public void request(String graphPath,
      *            returns to the callback. This has no effect on the request
      *            itself.
      */
+    @Deprecated
     public void request(final String graphPath,
                         final Bundle parameters,
                         final String httpMethod,
@@ -250,7 +269,7 @@ public void request(final String graphPath,
         new Thread() {
             @Override public void run() {
                 try {
-                    String resp = fb.request(graphPath, parameters, httpMethod);
+                    String resp = fb.requestImpl(graphPath, parameters, httpMethod);
                     listener.onComplete(resp, state);
                 } catch (FileNotFoundException e) {
                     listener.onFileNotFoundException(e, state);
@@ -265,11 +284,14 @@ public void request(final String graphPath,
 
     /**
      * Callback interface for API requests.
-     *
+     * <p/>
      * Each method includes a 'state' parameter that identifies the calling
      * request. It will be set to the value passed when originally calling the
      * request method, or null if none was passed.
+     * <p/>
+     * This interface is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
      */
+    @Deprecated
     public static interface RequestListener {
 
         /**
diff --git a/facebook/src/com/facebook/android/DialogError.java b/facebook/src/com/facebook/android/DialogError.java
index 51d06c9a1..cdb1a883e 100644
--- a/facebook/src/com/facebook/android/DialogError.java
+++ b/facebook/src/com/facebook/android/DialogError.java
@@ -40,11 +40,11 @@ public DialogError(String message, int errorCode, String failingUrl) {
         mFailingUrl = failingUrl;
     }
 
-    int getErrorCode() {
+    public int getErrorCode() {
         return mErrorCode;
     }
 
-    String getFailingUrl() {
+    public String getFailingUrl() {
         return mFailingUrl;
     }
 
diff --git a/facebook/src/com/facebook/android/Facebook.java b/facebook/src/com/facebook/android/Facebook.java
index 173f34205..b1d9a0624 100644
--- a/facebook/src/com/facebook/android/Facebook.java
+++ b/facebook/src/com/facebook/android/Facebook.java
@@ -16,47 +16,37 @@
 
 package com.facebook.android;
 
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.net.MalformedURLException;
-
 import android.Manifest;
 import android.app.Activity;
-import android.content.ActivityNotFoundException;
-import android.content.ComponentName;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.ServiceConnection;
-import android.content.SharedPreferences;
+import android.content.*;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
 import android.content.pm.ResolveInfo;
 import android.content.pm.Signature;
-import android.database.Cursor;
 import android.net.Uri;
-import android.os.AsyncTask;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.IBinder;
-import android.os.Message;
-import android.os.Messenger;
-import android.os.RemoteException;
-import android.text.TextUtils;
-import android.webkit.CookieSyncManager;
-import org.json.JSONException;
-import org.json.JSONObject;
+import android.os.*;
+import com.facebook.*;
+import com.facebook.Session.StatusCallback;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.lang.ref.WeakReference;
+import java.net.MalformedURLException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
 
 /**
- * Main Facebook object for interacting with the Facebook developer API.
- * Provides methods to log in and log out a user, make requests using the REST
- * and Graph APIs, and start user interface interactions with the API (such as
- * pop-ups promoting for credentials, permissions, stream posts, etc.)
- *
- * @author  Jim Brusstar (jimbru@facebook.com),
- *          Yariv Sadan (yariv@facebook.com),
- *          Luke Shepard (lshepard@facebook.com)
+ * NOTE:  New code should not use this class for anything other than dialog
+ * functionality.  This class is maintained for backwards compatibility and
+ * because not all dialogs are supported natively yet.  However, we do not
+ * intend to add new features to this class, and new code should target
+ * Session, Request, and native controls instead.
+ * <p/>
+ * The getSession/setSession methods enable incrementally moving some code
+ * to use newer APIs while the rest of the application continues to function
+ * against this API.
  */
 public class Facebook {
 
@@ -71,14 +61,6 @@
         Uri.parse("content://com.facebook.katana.provider.AttributionIdProvider");
     public static final String ATTRIBUTION_ID_COLUMN_NAME = "aid";
 
-    private static final String ATTRIBUTION_PREFERENCES = "com.facebook.sdk.attributionTracking";
-    private static final String PUBLISH_ACTIVITY_PATH = "%s/activities";
-    private static final String MOBILE_INSTALL_EVENT = "MOBILE_APP_INSTALL";
-    private static final String SUPPORTS_ATTRIBUTION = "supports_attribution";
-    private static final String APPLICATION_FIELDS = "fields";
-    private static final String ANALYTICS_EVENT = "event";
-    private static final String ATTRIBUTION_KEY = "attribution";
-
     public static final int FORCE_DIALOG_AUTH = -1;
 
     private static final String LOGIN = "oauth";
@@ -87,78 +69,84 @@
     private static final int DEFAULT_AUTH_ACTIVITY_CODE = 32665;
 
     // Facebook server endpoints: may be modified in a subclass for testing
-    protected static String DIALOG_BASE_URL =
-        "https://m.facebook.com/dialog/";
-    protected static String GRAPH_BASE_URL =
-        "https://graph.facebook.com/";
-    protected static String RESTSERVER_URL =
-        "https://api.facebook.com/restserver.php";
-
-    private String mAccessToken = null;
-    private long mLastAccessUpdate = 0;
-    private long mAccessExpires = 0;
+    protected static String DIALOG_BASE_URL = "https://m.facebook.com/dialog/";
+    protected static String GRAPH_BASE_URL = "https://graph.facebook.com/";
+    protected static String RESTSERVER_URL = "https://api.facebook.com/restserver.php";
+
+    private final Object lock = new Object();
+
+    private String accessToken = null;
+    private long accessExpiresMillisecondsAfterEpoch = 0;
+    private long lastAccessUpdateMillisecondsAfterEpoch = 0;
     private String mAppId;
 
-    private Activity mAuthActivity;
-    private String[] mAuthPermissions;
-    private int mAuthActivityCode;
-    private DialogListener mAuthDialogListener;
-    
+    private Activity pendingAuthorizationActivity;
+    private String[] pendingAuthorizationPermissions;
+    private Session pendingOpeningSession;
+
+    private volatile Session session; // must synchronize this.sync to write
+    private boolean sessionInvalidated; // must synchronize this.sync to access
+    private SetterTokenCache tokenCache;
+    private volatile Session userSetSession;
+
     // If the last time we extended the access token was more than 24 hours ago
     // we try to refresh the access token again.
     final private long REFRESH_TOKEN_BARRIER = 24L * 60L * 60L * 1000L;
 
     private boolean shouldAutoPublishInstall = true;
-    private AutoPublishAsyncTask mAutoPublishAsyncTask = null;
 
     /**
      * Constructor for Facebook object.
-     *
+     * 
      * @param appId
-     *          Your Facebook application ID. Found at
-     *          www.facebook.com/developers/apps.php.
+     *            Your Facebook application ID. Found at
+     *            www.facebook.com/developers/apps.php.
      */
     public Facebook(String appId) {
         if (appId == null) {
-            throw new IllegalArgumentException(
-                    "You must specify your application ID when instantiating " +
-                    "a Facebook object. See README for details.");
+            throw new IllegalArgumentException("You must specify your application ID when instantiating "
+                    + "a Facebook object. See README for details.");
         }
         mAppId = appId;
     }
 
     /**
      * Default authorize method. Grants only basic permissions.
-     *
+     * <p/>
      * See authorize() below for @params.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
      */
+    @Deprecated
     public void authorize(Activity activity, final DialogListener listener) {
-        authorize(activity, new String[] {}, DEFAULT_AUTH_ACTIVITY_CODE,
+        authorize(activity, new String[]{}, DEFAULT_AUTH_ACTIVITY_CODE, SessionLoginBehavior.SSO_WITH_FALLBACK,
                 listener);
     }
 
     /**
      * Authorize method that grants custom permissions.
-     *
+     * <p/>
      * See authorize() below for @params.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
      */
-    public void authorize(Activity activity, String[] permissions,
-            final DialogListener listener) {
-        authorize(activity, permissions, DEFAULT_AUTH_ACTIVITY_CODE, listener);
+    @Deprecated
+    public void authorize(Activity activity, String[] permissions, final DialogListener listener) {
+        authorize(activity, permissions, DEFAULT_AUTH_ACTIVITY_CODE, SessionLoginBehavior.SSO_WITH_FALLBACK, listener);
     }
 
     /**
      * Full authorize method.
-     *
+     * <p/>
      * Starts either an Activity or a dialog which prompts the user to log in to
      * Facebook and grant the requested permissions to the given application.
-     *
+     * <p/>
      * This method will, when possible, use Facebook's single sign-on for
      * Android to obtain an access token. This involves proxying a call through
      * the Facebook for Android stand-alone application, which will handle the
      * authentication flow, and return an OAuth access token for making API
      * calls.
-     *
+     * <p/>
      * Because this process will not be available for all users, if single
      * sign-on is not possible, this method will automatically fall back to the
      * OAuth 2.0 User-Agent flow. In this flow, the user credentials are handled
@@ -166,30 +154,30 @@ public void authorize(Activity activity, String[] permissions,
      * such, the dialog makes a network request and renders HTML content rather
      * than a native UI. The access token is retrieved from a redirect to a
      * special URL that the WebView handles.
-     *
+     * <p/>
      * Note that User credentials could be handled natively using the OAuth 2.0
      * Username and Password Flow, but this is not supported by this SDK.
-     *
+     * <p/>
      * See http://developers.facebook.com/docs/authentication/ and
      * http://wiki.oauth.net/OAuth-2 for more details.
-     *
+     * <p/>
      * Note that this method is asynchronous and the callback will be invoked in
      * the original calling thread (not in a background thread).
-     *
+     * <p/>
      * Also note that requests may be made to the API without calling authorize
      * first, in which case only public information is returned.
-     *
+     * <p/>
      * IMPORTANT: Note that single sign-on authentication will not function
      * correctly if you do not include a call to the authorizeCallback() method
      * in your onActivityResult() function! Please see below for more
      * information. single sign-on may be disabled by passing FORCE_DIALOG_AUTH
      * as the activityCode parameter in your call to authorize().
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
      *
      * @param activity
      *            The Android activity in which we want to display the
      *            authorization dialog.
-     * @param applicationId
-     *            The Facebook application identifier e.g. "350685531728"
      * @param permissions
      *            A list of permissions required for this application: e.g.
      *            "read_stream", "publish_stream", "offline_access", etc. see
@@ -205,136 +193,190 @@ public void authorize(Activity activity, String[] permissions,
      *            parameter. Otherwise just omit this parameter and Facebook
      *            will use a suitable default. See
      *            http://developer.android.com/reference/android/
-     *              app/Activity.html for more information.
+     *            app/Activity.html for more information.
      * @param listener
      *            Callback interface for notifying the calling application when
      *            the authentication dialog has completed, failed, or been
      *            canceled.
      */
-    public void authorize(Activity activity, String[] permissions,
-            int activityCode, final DialogListener listener) {
-
-        boolean singleSignOnStarted = false;
-
-        mAuthDialogListener = listener;
+    @Deprecated
+    public void authorize(Activity activity, String[] permissions, int activityCode, final DialogListener listener) {
+        SessionLoginBehavior behavior = (activityCode >= 0) ? SessionLoginBehavior.SSO_WITH_FALLBACK
+                : SessionLoginBehavior.SUPPRESS_SSO;
 
-        // fire off an auto-attribution publish if appropriate.
-        autoPublishAsync(activity.getApplicationContext());
-
-        // Prefer single sign-on, where available.
-        if (activityCode >= 0) {
-            singleSignOnStarted = startSingleSignOn(activity, mAppId,
-                    permissions, activityCode);
-        }
-        // Otherwise fall back to traditional dialog.
-        if (!singleSignOnStarted) {
-            startDialogAuth(activity, permissions);
-        }
+        authorize(activity, permissions, activityCode, behavior, listener);
     }
 
     /**
-     * Internal method to handle single sign-on backend for authorize().
-     *
+     * Full authorize method.
+     * 
+     * Starts either an Activity or a dialog which prompts the user to log in to
+     * Facebook and grant the requested permissions to the given application.
+     * 
+     * This method will, when possible, use Facebook's single sign-on for
+     * Android to obtain an access token. This involves proxying a call through
+     * the Facebook for Android stand-alone application, which will handle the
+     * authentication flow, and return an OAuth access token for making API
+     * calls.
+     * 
+     * Because this process will not be available for all users, if single
+     * sign-on is not possible, this method will automatically fall back to the
+     * OAuth 2.0 User-Agent flow. In this flow, the user credentials are handled
+     * by Facebook in an embedded WebView, not by the client application. As
+     * such, the dialog makes a network request and renders HTML content rather
+     * than a native UI. The access token is retrieved from a redirect to a
+     * special URL that the WebView handles.
+     * 
+     * Note that User credentials could be handled natively using the OAuth 2.0
+     * Username and Password Flow, but this is not supported by this SDK.
+     * 
+     * See http://developers.facebook.com/docs/authentication/ and
+     * http://wiki.oauth.net/OAuth-2 for more details.
+     * 
+     * Note that this method is asynchronous and the callback will be invoked in
+     * the original calling thread (not in a background thread).
+     * 
+     * Also note that requests may be made to the API without calling authorize
+     * first, in which case only public information is returned.
+     * 
+     * IMPORTANT: Note that single sign-on authentication will not function
+     * correctly if you do not include a call to the authorizeCallback() method
+     * in your onActivityResult() function! Please see below for more
+     * information. single sign-on may be disabled by passing FORCE_DIALOG_AUTH
+     * as the activityCode parameter in your call to authorize().
+     * 
      * @param activity
-     *            The Android Activity that will parent the ProxyAuth Activity.
-     * @param applicationId
-     *            The Facebook application identifier.
+     *            The Android activity in which we want to display the
+     *            authorization dialog.
      * @param permissions
-     *            A list of permissions required for this application. If you do
-     *            not require any permissions, pass an empty String array.
+     *            A list of permissions required for this application: e.g.
+     *            "read_stream", "publish_stream", "offline_access", etc. see
+     *            http://developers.facebook.com/docs/authentication/permissions
+     *            This parameter should not be null -- if you do not require any
+     *            permissions, then pass in an empty String array.
      * @param activityCode
-     *            Activity code to uniquely identify the result Intent in the
-     *            callback.
+     *            Single sign-on requires an activity result to be called back
+     *            to the client application -- if you are waiting on other
+     *            activities to return data, pass a custom activity code here to
+     *            avoid collisions. If you would like to force the use of legacy
+     *            dialog-based authorization, pass FORCE_DIALOG_AUTH for this
+     *            parameter. Otherwise just omit this parameter and Facebook
+     *            will use a suitable default. See
+     *            http://developer.android.com/reference/android/
+     *            app/Activity.html for more information.
+     * @param behavior
+     *            The {@link SessionLoginBehavior SessionLoginBehavior} that
+     *            specifies what behaviors should be attempted during
+     *            authorization.
+     * @param listener
+     *            Callback interface for notifying the calling application when
+     *            the authentication dialog has completed, failed, or been
+     *            canceled.
      */
-    private boolean startSingleSignOn(Activity activity, String applicationId,
-            String[] permissions, int activityCode) {
-        boolean didSucceed = true;
-        Intent intent = new Intent();
+    private void authorize(Activity activity, String[] permissions, int activityCode,
+                          SessionLoginBehavior behavior, final DialogListener listener) {
+        checkUserSession("authorize");
+        pendingOpeningSession = new Session.Builder(activity).
+                setApplicationId(mAppId).
+                setTokenCache(getTokenCache()).
+                setShouldAutoPublishInstall(getShouldAutoPublishInstall()).
+                build();
+        pendingAuthorizationActivity = activity;
+        pendingAuthorizationPermissions = (permissions != null) ? permissions : new String[0];
+
+        StatusCallback callback = new StatusCallback() {
+            @Override
+            public void call(Session callbackSession, SessionState state, Exception exception) {
+                // Invoke user-callback.
+                onSessionCallback(callbackSession, state, exception, listener);
+            }
+        };
+
+        Session.OpenRequest openRequest = new Session.OpenRequest(activity).
+                setCallback(callback).
+                setLoginBehavior(behavior).
+                setRequestCode(activityCode).
+                setPermissions(Arrays.asList(permissions));
+        openSession(pendingOpeningSession, openRequest, pendingAuthorizationPermissions.length > 0);
+    }
 
-        intent.setClassName("com.facebook.katana",
-                "com.facebook.katana.ProxyAuth");
-        intent.putExtra("client_id", applicationId);
-        if (permissions.length > 0) {
-            intent.putExtra("scope", TextUtils.join(",", permissions));
+    private void openSession(Session session, Session.OpenRequest openRequest, boolean isPublish) {
+        openRequest.suppressLoginActivityVerification(true);
+        if (isPublish) {
+            session.openForPublish(openRequest);
+        } else {
+            session.openForRead(openRequest);
         }
+    }
 
-        // Verify that the application whose package name is
-        // com.facebook.katana.ProxyAuth
-        // has the expected FB app signature.
-        if (!validateActivityIntent(activity, intent)) {
-            return false;
-        }
+    private void onSessionCallback(Session callbackSession, SessionState state, Exception exception,
+            DialogListener listener) {
+        Bundle extras = callbackSession.getAuthorizationBundle();
 
-        mAuthActivity = activity;
-        mAuthPermissions = permissions;
-        mAuthActivityCode = activityCode;
-        try {
-            activity.startActivityForResult(intent, activityCode);
-        } catch (ActivityNotFoundException e) {
-            didSucceed = false;
-        }
+        if (state == SessionState.OPENED) {
+            Session sessionToClose = null;
 
-        return didSucceed;
-    }
+            synchronized (Facebook.this.lock) {
+                if (callbackSession != Facebook.this.session) {
+                    sessionToClose = Facebook.this.session;
+                    Facebook.this.session = callbackSession;
+                    Facebook.this.sessionInvalidated = false;
+                }
+            }
 
-    /**
-     * Helper to validate an activity intent by resolving and checking the
-     * provider's package signature.
-     *
-     * @param context
-     * @param intent
-     * @return true if the service intent resolution happens successfully and the
-     * 	signatures match.
-     */
-    private boolean validateActivityIntent(Context context, Intent intent) {
-        ResolveInfo resolveInfo =
-            context.getPackageManager().resolveActivity(intent, 0);
-        if (resolveInfo == null) {
-            return false;
-        }
+            if (sessionToClose != null) {
+                sessionToClose.close();
+            }
 
-        return validateAppSignatureForPackage(
-            context,
-            resolveInfo.activityInfo.packageName);
+            listener.onComplete(extras);
+        } else if (exception != null) {
+            if (exception instanceof FacebookOperationCanceledException) {
+                listener.onCancel();
+            } else if ((exception instanceof FacebookAuthorizationException) && (extras != null)
+                    && extras.containsKey(Session.WEB_VIEW_ERROR_CODE_KEY)
+                    && extras.containsKey(Session.WEB_VIEW_FAILING_URL_KEY)) {
+                DialogError error = new DialogError(exception.getMessage(),
+                        extras.getInt(Session.WEB_VIEW_ERROR_CODE_KEY),
+                        extras.getString(Session.WEB_VIEW_FAILING_URL_KEY));
+                listener.onError(error);
+            } else {
+                FacebookError error = new FacebookError(exception.getMessage());
+                listener.onFacebookError(error);
+            }
+        }
     }
 
-
     /**
      * Helper to validate a service intent by resolving and checking the
      * provider's package signature.
-     *
+     * 
      * @param context
      * @param intent
-     * @return true if the service intent resolution happens successfully and the
-     * 	signatures match.
+     * @return true if the service intent resolution happens successfully and
+     *         the signatures match.
      */
     private boolean validateServiceIntent(Context context, Intent intent) {
-        ResolveInfo resolveInfo =
-            context.getPackageManager().resolveService(intent, 0);
+        ResolveInfo resolveInfo = context.getPackageManager().resolveService(intent, 0);
         if (resolveInfo == null) {
             return false;
         }
 
-        return validateAppSignatureForPackage(
-            context,
-            resolveInfo.serviceInfo.packageName);
+        return validateAppSignatureForPackage(context, resolveInfo.serviceInfo.packageName);
     }
 
     /**
      * Query the signature for the application that would be invoked by the
      * given intent and verify that it matches the FB application's signature.
-     *
+     * 
      * @param context
      * @param packageName
      * @return true if the app's signature matches the expected signature.
      */
-    private boolean validateAppSignatureForPackage(Context context,
-        String packageName) {
+    private boolean validateAppSignatureForPackage(Context context, String packageName) {
 
         PackageInfo packageInfo;
         try {
-            packageInfo = context.getPackageManager().getPackageInfo(
-                    packageName, PackageManager.GET_SIGNATURES);
+            packageInfo = context.getPackageManager().getPackageInfo(packageName, PackageManager.GET_SIGNATURES);
         } catch (NameNotFoundException e) {
             return false;
         }
@@ -348,138 +390,30 @@ private boolean validateAppSignatureForPackage(Context context,
     }
 
     /**
-     * Internal method to handle dialog-based authentication backend for
-     * authorize().
-     *
-     * @param activity
-     *            The Android Activity that will parent the auth dialog.
-     * @param applicationId
-     *            The Facebook application identifier.
-     * @param permissions
-     *            A list of permissions required for this application. If you do
-     *            not require any permissions, pass an empty String array.
-     */
-	private void startDialogAuth(Activity activity, String[] permissions) {
-        Bundle params = new Bundle();
-        if (permissions.length > 0) {
-            params.putString("scope", TextUtils.join(",", permissions));
-        }
-        CookieSyncManager.createInstance(activity);
-        dialog(activity, LOGIN, params, new DialogListener() {
-
-            public void onComplete(Bundle values) {
-                // ensure any cookies set by the dialog are saved
-                CookieSyncManager.getInstance().sync();
-                setAccessToken(values.getString(TOKEN));
-                setAccessExpiresIn(values.getString(EXPIRES));
-                if (isSessionValid()) {
-                    Util.logd("Facebook-authorize", "Login Success! access_token="
-                            + getAccessToken() + " expires="
-                            + getAccessExpires());
-                    mAuthDialogListener.onComplete(values);
-                } else {
-                    mAuthDialogListener.onFacebookError(new FacebookError(
-                                    "Failed to receive access token."));
-                }
-            }
-
-            public void onError(DialogError error) {
-                Util.logd("Facebook-authorize", "Login failed: " + error);
-                mAuthDialogListener.onError(error);
-            }
-
-            public void onFacebookError(FacebookError error) {
-                Util.logd("Facebook-authorize", "Login failed: " + error);
-                mAuthDialogListener.onFacebookError(error);
-            }
-
-            public void onCancel() {
-                Util.logd("Facebook-authorize", "Login canceled");
-                mAuthDialogListener.onCancel();
-            }
-        });
-    }
-
-    /**
-     * IMPORTANT: This method must be invoked at the top of the calling
+     * IMPORTANT: If you are using the deprecated authorize() method,
+     * this method must be invoked at the top of the calling
      * activity's onActivityResult() function or Facebook authentication will
      * not function properly!
-     *
+     * <p/>
      * If your calling activity does not currently implement onActivityResult(),
      * you must implement it and include a call to this method if you intend to
      * use the authorize() method in this SDK.
-     *
+     * <p/>
      * For more information, see
      * http://developer.android.com/reference/android/app/
-     *   Activity.html#onActivityResult(int, int, android.content.Intent)
+     * Activity.html#onActivityResult(int, int, android.content.Intent)
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
      */
+    @Deprecated
     public void authorizeCallback(int requestCode, int resultCode, Intent data) {
-        if (requestCode == mAuthActivityCode) {
-
-            // Successfully redirected.
-            if (resultCode == Activity.RESULT_OK) {
-
-                // Check OAuth 2.0/2.10 error code.
-                String error = data.getStringExtra("error");
-                if (error == null) {
-                    error = data.getStringExtra("error_type");
-                }
-
-                // A Facebook error occurred.
-                if (error != null) {
-                    if (error.equals(SINGLE_SIGN_ON_DISABLED)
-                            || error.equals("AndroidAuthKillSwitchException")) {
-                        Util.logd("Facebook-authorize", "Hosted auth currently "
-                            + "disabled. Retrying dialog auth...");
-                        startDialogAuth(mAuthActivity, mAuthPermissions);
-                    } else if (error.equals("access_denied")
-                            || error.equals("OAuthAccessDeniedException")) {
-                        Util.logd("Facebook-authorize", "Login canceled by user.");
-                        mAuthDialogListener.onCancel();
-                    } else {
-                        String description = data.getStringExtra("error_description");
-                        if (description != null) {
-                            error = error + ":" + description;
-                        }
-                        Util.logd("Facebook-authorize", "Login failed: " + error);
-                        mAuthDialogListener.onFacebookError(
-                          new FacebookError(error));
-                    }
-
-                // No errors.
-                } else {
-                    setAccessToken(data.getStringExtra(TOKEN));
-                    setAccessExpiresIn(data.getStringExtra(EXPIRES));
-                    if (isSessionValid()) {
-                        Util.logd("Facebook-authorize",
-                                "Login Success! access_token="
-                                        + getAccessToken() + " expires="
-                                        + getAccessExpires());
-                        mAuthDialogListener.onComplete(data.getExtras());
-                    } else {
-                        mAuthDialogListener.onFacebookError(new FacebookError(
-                                        "Failed to receive access token."));
-                    }
-                }
-
-            // An error occurred before we could be redirected.
-            } else if (resultCode == Activity.RESULT_CANCELED) {
-
-                // An Android error occured.
-                if (data != null) {
-                    Util.logd("Facebook-authorize",
-                            "Login failed: " + data.getStringExtra("error"));
-                    mAuthDialogListener.onError(
-                            new DialogError(
-                                    data.getStringExtra("error"),
-                                    data.getIntExtra("error_code", -1),
-                                    data.getStringExtra("failing_url")));
-
-                // User pressed the 'back' button.
-                } else {
-                    Util.logd("Facebook-authorize", "Login canceled by user.");
-                    mAuthDialogListener.onCancel();
-                }
+        checkUserSession("authorizeCallback");
+        Session pending = this.pendingOpeningSession;
+        if (pending != null) {
+            if (pending.onActivityResult(this.pendingAuthorizationActivity, requestCode, resultCode, data)) {
+                this.pendingOpeningSession = null;
+                this.pendingAuthorizationActivity = null;
+                this.pendingAuthorizationPermissions = null;
             }
         }
     }
@@ -492,7 +426,9 @@ public void authorizeCallback(int requestCode, int resultCode, Intent data) {
      * will automatically replace the old token with a new one. Note that this
      * method is asynchronous and the callback will be invoked in the original
      * calling thread (not in a background thread).
-     * 
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
+     *
      * @param context
      *            The Android Context that will be used to bind to the Facebook
      *            RefreshToken Service
@@ -503,11 +439,12 @@ public void authorizeCallback(int requestCode, int resultCode, Intent data) {
      *            Bundle under Facebook.ACCESS_TOKEN key.
      * @return true if the binding to the RefreshToken Service was created
      */
+    @Deprecated
     public boolean extendAccessToken(Context context, ServiceListener serviceListener) {
+        checkUserSession("extendAccessToken");
         Intent intent = new Intent();
 
-        intent.setClassName("com.facebook.katana",
-                "com.facebook.katana.platform.TokenRefreshService");
+        intent.setClassName("com.facebook.katana", "com.facebook.katana.platform.TokenRefreshService");
 
         // Verify that the application whose package name is
         // com.facebook.katana
@@ -516,82 +453,57 @@ public boolean extendAccessToken(Context context, ServiceListener serviceListene
             return false;
         }
 
-        return context.bindService(intent,
-                new TokenRefreshServiceConnection(context, serviceListener),
+        return context.bindService(intent, new TokenRefreshServiceConnection(context, serviceListener),
                 Context.BIND_AUTO_CREATE);
     }
-    
+
     /**
-    * Calls extendAccessToken if shouldExtendAccessToken returns true.
-    * 
-    * @return the same value as extendAccessToken if the the token requires
-    *           refreshing, true otherwise
-    */
+     * Calls extendAccessToken if shouldExtendAccessToken returns true.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
+     *
+     * @return the same value as extendAccessToken if the the token requires
+     *         refreshing, true otherwise
+     */
+    @Deprecated
     public boolean extendAccessTokenIfNeeded(Context context, ServiceListener serviceListener) {
+        checkUserSession("extendAccessTokenIfNeeded");
         if (shouldExtendAccessToken()) {
             return extendAccessToken(context, serviceListener);
         }
         return true;
     }
-    
+
     /**
-     * Check if the access token requires refreshing. 
-     * 
-     * @return true if the last time a new token was obtained was over 24 hours ago.
+     * Check if the access token requires refreshing.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
+     *
+     * @return true if the last time a new token was obtained was over 24 hours
+     *         ago.
      */
+    @Deprecated
     public boolean shouldExtendAccessToken() {
-        return isSessionValid() &&
-                (System.currentTimeMillis() - mLastAccessUpdate >= REFRESH_TOKEN_BARRIER);
+        checkUserSession("shouldExtendAccessToken");
+        return isSessionValid()
+                && (System.currentTimeMillis() - lastAccessUpdateMillisecondsAfterEpoch >= REFRESH_TOKEN_BARRIER);
     }
-    
+
     /**
      * Handles connection to the token refresh service (this service is a part
      * of Facebook App).
      */
     private class TokenRefreshServiceConnection implements ServiceConnection {
 
-        final Messenger messageReceiver = new Messenger(new Handler() {
-            @Override
-            public void handleMessage(Message msg) {
-                String token = msg.getData().getString(TOKEN);
-                long expiresAt = msg.getData().getLong(EXPIRES) * 1000L;
-
-                // To avoid confusion we should return the expiration time in
-                // the same format as the getAccessExpires() function - that
-                // is in milliseconds.
-                Bundle resultBundle = (Bundle) msg.getData().clone();
-                resultBundle.putLong(EXPIRES, expiresAt);
-
-                if (token != null) {
-                    setAccessToken(token);
-                    setAccessExpires(expiresAt);
-                    if (serviceListener != null) {
-                        serviceListener.onComplete(resultBundle);
-                    }
-                } else if (serviceListener != null) { // extract errors only if client wants them
-                    String error = msg.getData().getString("error");
-                    if (msg.getData().containsKey("error_code")) {
-                        int errorCode = msg.getData().getInt("error_code");
-                        serviceListener.onFacebookError(new FacebookError(error, null, errorCode));
-                    } else {
-                        serviceListener.onError(new Error(error != null ? error
-                                : "Unknown service error"));
-                    }
-                }
-
-                // The refreshToken function should be called rarely,
-                // so there is no point in keeping the binding open.
-                applicationsContext.unbindService(TokenRefreshServiceConnection.this);
-            }
-        });
+        final Messenger messageReceiver = new Messenger(
+                new TokenRefreshConnectionHandler(Facebook.this, this));
 
         final ServiceListener serviceListener;
         final Context applicationsContext;
 
         Messenger messageSender = null;
 
-        public TokenRefreshServiceConnection(Context applicationsContext,
-                ServiceListener serviceListener) {
+        public TokenRefreshServiceConnection(Context applicationsContext, ServiceListener serviceListener) {
             this.applicationsContext = applicationsContext;
             this.serviceListener = serviceListener;
         }
@@ -612,7 +524,7 @@ public void onServiceDisconnected(ComponentName arg) {
 
         private void refreshToken() {
             Bundle requestData = new Bundle();
-            requestData.putString(TOKEN, mAccessToken);
+            requestData.putString(TOKEN, accessToken);
 
             Message request = Message.obtain();
             request.setData(requestData);
@@ -624,15 +536,84 @@ private void refreshToken() {
                 serviceListener.onError(new Error("Service connection error"));
             }
         }
-    };    
-    
+    }
+
+    // Creating a static Handler class to reduce the possibility of a memory leak.
+    // Handler objects for the same thread all share a common Looper object, which they post messages
+    // to and read from. As messages contain target Handler, as long as there are messages with target
+    // handler in the message queue, the handler cannot be garbage collected. If handler is not static,
+    // the instance of the containing class also cannot be garbage collected even if it is destroyed.
+    private static class TokenRefreshConnectionHandler extends Handler {
+        WeakReference<Facebook> facebookWeakReference;
+        WeakReference<TokenRefreshServiceConnection> connectionWeakReference;
+
+        TokenRefreshConnectionHandler(Facebook facebook, TokenRefreshServiceConnection connection) {
+            super();
+            facebookWeakReference = new WeakReference<Facebook>(facebook);
+            connectionWeakReference = new WeakReference<TokenRefreshServiceConnection>(connection);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            Facebook facebook = facebookWeakReference.get();
+            TokenRefreshServiceConnection connection = connectionWeakReference.get();
+            if (facebook == null || connection == null) {
+                return;
+            }
+
+            String token = msg.getData().getString(TOKEN);
+            // Legacy functions in Facebook class (and ServiceListener implementors) expect expires_in in
+            // milliseconds from epoch
+            long expiresAtMsecFromEpoch = msg.getData().getLong(EXPIRES) * 1000L;
+
+            if (token != null) {
+                facebook.setAccessToken(token);
+                facebook.setAccessExpires(expiresAtMsecFromEpoch);
+
+                Session refreshSession = facebook.session;
+                if (refreshSession != null) {
+                    // Session.internalRefreshToken expects the original bundle with expires_in in seconds from
+                    // epoch.
+                    refreshSession.internalRefreshToken(msg.getData());
+                }
+
+                if (connection.serviceListener != null) {
+                    // To avoid confusion we should return the expiration time in
+                    // the same format as the getAccessExpires() function - that
+                    // is in milliseconds.
+                    Bundle resultBundle = (Bundle) msg.getData().clone();
+                    resultBundle.putLong(EXPIRES, expiresAtMsecFromEpoch);
+
+                    connection.serviceListener.onComplete(resultBundle);
+                }
+            } else if (connection.serviceListener != null) { // extract errors only if
+                // client wants them
+                String error = msg.getData().getString("error");
+                if (msg.getData().containsKey("error_code")) {
+                    int errorCode = msg.getData().getInt("error_code");
+                    connection.serviceListener.onFacebookError(new FacebookError(error, null, errorCode));
+                } else {
+                    connection.serviceListener.onError(new Error(error != null ? error : "Unknown service error"));
+                }
+            }
+
+            if (connection != null) {
+                // The refreshToken function should be called rarely,
+                // so there is no point in keeping the binding open.
+                connection.applicationsContext.unbindService(connection);
+            }
+        }
+    }
+
     /**
      * Invalidate the current user session by removing the access token in
      * memory, clearing the browser cookie, and calling auth.expireSession
      * through the API.
-     *
+     * <p/>
      * Note that this method blocks waiting for a network response, so do not
      * call it in a UI thread.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
      *
      * @param context
      *            The Android context in which the logout should be called: it
@@ -641,16 +622,36 @@ private void refreshToken() {
      * @throws IOException
      * @throws MalformedURLException
      * @return JSON string representation of the auth.expireSession response
-     *            ("true" if successful)
+     *         ("true" if successful)
      */
-    public String logout(Context context)
-            throws MalformedURLException, IOException {
-        Util.clearCookies(context);
+    @Deprecated
+    public String logout(Context context) throws MalformedURLException, IOException {
+        return logoutImpl(context);
+    }
+
+    String logoutImpl(Context context) throws MalformedURLException, IOException  {
+        checkUserSession("logout");
         Bundle b = new Bundle();
         b.putString("method", "auth.expireSession");
         String response = request(b);
-        setAccessToken(null);
-        setAccessExpires(0);
+
+        long currentTimeMillis = System.currentTimeMillis();
+        Session sessionToClose = null;
+
+        synchronized (this.lock) {
+            sessionToClose = session;
+
+            session = null;
+            accessToken = null;
+            accessExpiresMillisecondsAfterEpoch = 0;
+            lastAccessUpdateMillisecondsAfterEpoch = currentTimeMillis;
+            sessionInvalidated = false;
+        }
+
+        if (sessionToClose != null) {
+            sessionToClose.closeAndClearTokenInformation();
+        }
+
         return response;
     }
 
@@ -658,47 +659,50 @@ public String logout(Context context)
      * Make a request to Facebook's old (pre-graph) API with the given
      * parameters. One of the parameter keys must be "method" and its value
      * should be a valid REST server API method.
-     *
+     * <p/>
      * See http://developers.facebook.com/docs/reference/rest/
-     *
+     * <p/>
      * Note that this method blocks waiting for a network response, so do not
      * call it in a UI thread.
-     *
-     * Example:
-     * <code>
+     * <p/>
+     * Example: <code>
      *  Bundle parameters = new Bundle();
      *  parameters.putString("method", "auth.expireSession");
      *  String response = request(parameters);
      * </code>
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Request} for more info.
      *
      * @param parameters
      *            Key-value pairs of parameters to the request. Refer to the
      *            documentation: one of the parameters must be "method".
      * @throws IOException
-     *            if a network error occurs
+     *             if a network error occurs
      * @throws MalformedURLException
-     *            if accessing an invalid endpoint
+     *             if accessing an invalid endpoint
      * @throws IllegalArgumentException
-     *            if one of the parameters is not "method"
+     *             if one of the parameters is not "method"
      * @return JSON string representation of the response
      */
-    public String request(Bundle parameters)
-            throws MalformedURLException, IOException {
+    @Deprecated
+    public String request(Bundle parameters) throws MalformedURLException, IOException {
         if (!parameters.containsKey("method")) {
             throw new IllegalArgumentException("API method must be specified. "
                     + "(parameters must contain key \"method\" and value). See"
                     + " http://developers.facebook.com/docs/reference/rest/");
         }
-        return request(null, parameters, "GET");
+        return requestImpl(null, parameters, "GET");
     }
 
     /**
      * Make a request to the Facebook Graph API without any parameters.
-     *
+     * <p/>
      * See http://developers.facebook.com/docs/api
-     *
+     * <p/>
      * Note that this method blocks waiting for a network response, so do not
      * call it in a UI thread.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Request} for more info.
      *
      * @param graphPath
      *            Path to resource in the Facebook graph, e.g., to fetch data
@@ -708,19 +712,21 @@ public String request(Bundle parameters)
      * @throws MalformedURLException
      * @return JSON string representation of the response
      */
-    public String request(String graphPath)
-            throws MalformedURLException, IOException {
-        return request(graphPath, new Bundle(), "GET");
+    @Deprecated
+    public String request(String graphPath) throws MalformedURLException, IOException {
+        return requestImpl(graphPath, new Bundle(), "GET");
     }
 
     /**
      * Make a request to the Facebook Graph API with the given string parameters
      * using an HTTP GET (default method).
-     *
+     * <p/>
      * See http://developers.facebook.com/docs/api
-     *
+     * <p/>
      * Note that this method blocks waiting for a network response, so do not
      * call it in a UI thread.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Request} for more info.
      *
      * @param graphPath
      *            Path to resource in the Facebook graph, e.g., to fetch data
@@ -735,20 +741,22 @@ public String request(String graphPath)
      * @throws MalformedURLException
      * @return JSON string representation of the response
      */
-    public String request(String graphPath, Bundle parameters)
-            throws MalformedURLException, IOException {
-        return request(graphPath, parameters, "GET");
+    @Deprecated
+    public String request(String graphPath, Bundle parameters) throws MalformedURLException, IOException {
+        return requestImpl(graphPath, parameters, "GET");
     }
 
     /**
      * Synchronously make a request to the Facebook Graph API with the given
-     * HTTP method and string parameters. Note that binary data parameters
-     * (e.g. pictures) are not yet supported by this helper function.
-     *
+     * HTTP method and string parameters. Note that binary data parameters (e.g.
+     * pictures) are not yet supported by this helper function.
+     * <p/>
      * See http://developers.facebook.com/docs/api
-     *
+     * <p/>
      * Note that this method blocks waiting for a network response, so do not
      * call it in a UI thread.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Request} for more info.
      *
      * @param graphPath
      *            Path to resource in the Facebook graph, e.g., to fetch data
@@ -765,23 +773,29 @@ public String request(String graphPath, Bundle parameters)
      * @throws MalformedURLException
      * @return JSON string representation of the response
      */
-    public String request(String graphPath, Bundle params, String httpMethod)
-            throws FileNotFoundException, MalformedURLException, IOException {
+    @Deprecated
+    public String request(String graphPath, Bundle params, String httpMethod) throws FileNotFoundException,
+            MalformedURLException, IOException {
+        return requestImpl(graphPath, params, httpMethod);
+    }
+
+    // Internal call to avoid deprecated warnings.
+    String requestImpl(String graphPath, Bundle params, String httpMethod) throws FileNotFoundException,
+            MalformedURLException, IOException {
         params.putString("format", "json");
         if (isSessionValid()) {
             params.putString(TOKEN, getAccessToken());
         }
-        String url = (graphPath != null) ? GRAPH_BASE_URL + graphPath
-                                         : RESTSERVER_URL;
+        String url = (graphPath != null) ? GRAPH_BASE_URL + graphPath : RESTSERVER_URL;
         return Util.openUrl(url, httpMethod, params);
     }
 
     /**
      * Generate a UI dialog for the request action in the given Android context.
-     *
+     * <p/>
      * Note that this method is asynchronous and the callback will be invoked in
      * the original calling thread (not in a background thread).
-     *
+     * 
      * @param context
      *            The Android context in which we will generate this dialog.
      * @param action
@@ -791,18 +805,17 @@ public String request(String graphPath, Bundle params, String httpMethod)
      *            Callback interface to notify the application when the dialog
      *            has completed.
      */
-    public void dialog(Context context, String action,
-            DialogListener listener) {
+    public void dialog(Context context, String action, DialogListener listener) {
         dialog(context, action, new Bundle(), listener);
     }
 
     /**
      * Generate a UI dialog for the request action in the given Android context
      * with the provided parameters.
-     *
+     * <p/>
      * Note that this method is asynchronous and the callback will be invoked in
      * the original calling thread (not in a background thread).
-     *
+     * 
      * @param context
      *            The Android context in which we will generate this dialog.
      * @param action
@@ -813,8 +826,7 @@ public void dialog(Context context, String action,
      *            Callback interface to notify the application when the dialog
      *            has completed.
      */
-    public void dialog(Context context, String action, Bundle parameters,
-            final DialogListener listener) {
+    public void dialog(Context context, String action, Bundle parameters, final DialogListener listener) {
 
         String endpoint = DIALOG_BASE_URL + action;
         parameters.putString("display", "touch");
@@ -831,22 +843,118 @@ public void dialog(Context context, String action, Bundle parameters,
             parameters.putString(TOKEN, getAccessToken());
         }
         String url = endpoint + "?" + Util.encodeUrl(parameters);
-        if (context.checkCallingOrSelfPermission(Manifest.permission.INTERNET)
-                != PackageManager.PERMISSION_GRANTED) {
-            Util.showAlert(context, "Error",
-                    "Application requires permission to access the Internet");
+        if (context.checkCallingOrSelfPermission(Manifest.permission.INTERNET) != PackageManager.PERMISSION_GRANTED) {
+            Util.showAlert(context, "Error", "Application requires permission to access the Internet");
         } else {
             new FbDialog(context, url, listener).show();
         }
     }
 
     /**
+     * Returns whether the current access token is valid
+     *
      * @return boolean - whether this object has an non-expired session token
      */
     public boolean isSessionValid() {
-        return (getAccessToken() != null) &&
-                ((getAccessExpires() == 0) ||
-                        (System.currentTimeMillis() < getAccessExpires()));
+        return (getAccessToken() != null)
+                && ((getAccessExpires() == 0) || (System.currentTimeMillis() < getAccessExpires()));
+    }
+
+    /**
+     * Allows the user to set a Session for the Facebook class to use.
+     * If a Session is set here, then one should not use the authorize, logout,
+     * or extendAccessToken methods which alter the Session object since that may
+     * result in undefined behavior. Using those methods after setting the
+     * session here will result in exceptions being thrown.
+     *
+     * @param session the Session object to use, cannot be null
+     */
+    public void setSession(Session session) {
+        if (session == null) {
+            throw new IllegalArgumentException("session cannot be null");
+        }
+        synchronized (this.lock) {
+            this.userSetSession = session;
+        }
+    }
+
+    private void checkUserSession(String methodName) {
+        if (userSetSession != null) {
+            throw new UnsupportedOperationException(
+                    String.format("Cannot call %s after setSession has been called.", methodName));
+        }
+    }
+
+    /**
+     * Get the underlying Session object to use with 3.0 api.
+     * 
+     * @return Session - underlying session
+     */
+    public final Session getSession() {
+        while (true) {
+            String cachedToken = null;
+            Session oldSession = null;
+
+            synchronized (this.lock) {
+                if (userSetSession != null) {
+                    return userSetSession;
+                }
+                if ((session != null) || !sessionInvalidated) {
+                    return session;
+                }
+
+                cachedToken = accessToken;
+                oldSession = session;
+            }
+
+            if (cachedToken == null) {
+                return null;
+            }
+
+            // At this point we do not have a valid session, but mAccessToken is
+            // non-null.
+            // So we can try building a session based on that.
+            List<String> permissions;
+            if (oldSession != null) {
+                permissions = oldSession.getPermissions();
+            } else if (pendingAuthorizationPermissions != null) {
+                permissions = Arrays.asList(pendingAuthorizationPermissions);
+            } else {
+                permissions = Collections.<String>emptyList();
+            }
+
+            Session newSession = new Session.Builder(pendingAuthorizationActivity).
+                    setApplicationId(mAppId).
+                    setTokenCache(getTokenCache()).
+                    build();
+            if (newSession.getState() != SessionState.CREATED_TOKEN_LOADED) {
+                return null;
+            }
+            Session.OpenRequest openRequest =
+                    new Session.OpenRequest(pendingAuthorizationActivity).setPermissions(permissions);
+            openSession(newSession, openRequest, !permissions.isEmpty());
+
+            Session invalidatedSession = null;
+            Session returnSession = null;
+
+            synchronized (this.lock) {
+                if (sessionInvalidated || (session == null)) {
+                    invalidatedSession = session;
+                    returnSession = session = newSession;
+                    sessionInvalidated = false;
+                }
+            }
+
+            if (invalidatedSession != null) {
+                invalidatedSession.close();
+            }
+
+            if (returnSession != null) {
+                return returnSession;
+            }
+            // Else token state changed between the synchronized blocks, so
+            // retry..
+        }
     }
 
     /**
@@ -856,7 +964,12 @@ public boolean isSessionValid() {
      * @return String - access token
      */
     public String getAccessToken() {
-        return mAccessToken;
+        Session s = getSession();
+        if (s != null) {
+            return s.getAccessToken();
+        } else {
+            return null;
+        }
     }
 
     /**
@@ -866,7 +979,12 @@ public String getAccessToken() {
      * @return long - session expiration time
      */
     public long getAccessExpires() {
-        return mAccessExpires;
+        Session s = getSession();
+        if (s != null) {
+            return s.getExpirationDate().getTime();
+        } else {
+            return accessExpiresMillisecondsAfterEpoch;
+        }
     }
 
     /**
@@ -876,99 +994,206 @@ public long getAccessExpires() {
      * @return long - timestamp of the last token update.
      */
     public long getLastAccessUpdate() {
-        return mLastAccessUpdate;
+        return lastAccessUpdateMillisecondsAfterEpoch;
     }
 
     /**
      * Restore the token, expiration time, and last update time from cached values.
      * These should be values obtained from getAccessToken(), getAccessExpires, and
      * getLastAccessUpdate() respectively.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
      *
      * @param accessToken - access token
      * @param accessExpires - access token expiration time
      * @param lastAccessUpdate - timestamp of the last token update
      */
+    @Deprecated
     public void setTokenFromCache(String accessToken, long accessExpires, long lastAccessUpdate) {
-        mAccessToken = accessToken;
-        mAccessExpires = accessExpires;
-        mLastAccessUpdate = lastAccessUpdate;
+        checkUserSession("setTokenFromCache");
+        synchronized (this.lock) {
+            this.accessToken = accessToken;
+            accessExpiresMillisecondsAfterEpoch = accessExpires;
+            lastAccessUpdateMillisecondsAfterEpoch = lastAccessUpdate;
+        }
     }
 
     /**
      * Set the OAuth 2.0 access token for API access.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
      *
-     * @param token - access token
+     * @param token
+     *            - access token
      */
+    @Deprecated
     public void setAccessToken(String token) {
-        mAccessToken = token;
-        mLastAccessUpdate = System.currentTimeMillis();
+        checkUserSession("setAccessToken");
+        synchronized (this.lock) {
+            accessToken = token;
+            lastAccessUpdateMillisecondsAfterEpoch = System.currentTimeMillis();
+            sessionInvalidated = true;
+        }
     }
 
     /**
      * Set the current session's expiration time (in milliseconds since Unix
      * epoch), or 0 if the session doesn't expire.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
      *
-     * @param time - timestamp in milliseconds
+     * @param timestampInMsec
+     *            - timestamp in milliseconds
      */
-    public void setAccessExpires(long time) {
-        mAccessExpires = time;
+    @Deprecated
+    public void setAccessExpires(long timestampInMsec) {
+        checkUserSession("setAccessExpires");
+        synchronized (this.lock) {
+            accessExpiresMillisecondsAfterEpoch = timestampInMsec;
+            lastAccessUpdateMillisecondsAfterEpoch = System.currentTimeMillis();
+            sessionInvalidated = true;
+        }
     }
 
     /**
      * Set the current session's duration (in seconds since Unix epoch), or "0"
      * if session doesn't expire.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
      *
-     * @param expiresIn
+     * @param expiresInSecsFromNow
      *            - duration in seconds (or 0 if the session doesn't expire)
      */
-    public void setAccessExpiresIn(String expiresIn) {
-        if (expiresIn != null) {
-            long expires = expiresIn.equals("0")
-                    ? 0
-                    : System.currentTimeMillis() + Long.parseLong(expiresIn) * 1000L;
+    @Deprecated
+    public void setAccessExpiresIn(String expiresInSecsFromNow) {
+        checkUserSession("setAccessExpiresIn");
+        if (expiresInSecsFromNow != null) {
+            long expires = expiresInSecsFromNow.equals("0") ? 0 : System.currentTimeMillis()
+                    + Long.parseLong(expiresInSecsFromNow) * 1000L;
             setAccessExpires(expires);
         }
     }
 
+    /**
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
+     *
+     * @return the String representing application ID
+     */
+    @Deprecated
     public String getAppId() {
         return mAppId;
     }
 
+    /**
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
+     *
+     * @param appId the String representing the application ID
+     */
+    @Deprecated
     public void setAppId(String appId) {
-        mAppId = appId;
+        checkUserSession("setAppId");
+        synchronized (this.lock) {
+            mAppId = appId;
+            sessionInvalidated = true;
+        }
+    }
+
+    private TokenCache getTokenCache() {
+        // Intentionally not volatile/synchronized--it is okay if we race to
+        // create more than one of these.
+        if (tokenCache == null) {
+            tokenCache = new SetterTokenCache();
+        }
+        return tokenCache;
+    }
+
+    private static String[] stringArray(List<String> list) {
+        String[] array = new String[list.size()];
+
+        if (list != null) {
+            for (int i = 0; i < array.length; i++) {
+                array[i] = list.get(i);
+            }
+        }
+
+        return array;
+    }
+
+    private static List<String> stringList(String[] array) {
+        if (array != null) {
+            return Arrays.asList(array);
+        } else {
+            return Collections.emptyList();
+        }
+    }
+
+    private class SetterTokenCache extends TokenCache {
+
+        @Override
+        public Bundle load() {
+            Bundle bundle = new Bundle();
+
+            if (accessToken != null) {
+                TokenCache.putToken(bundle, accessToken);
+                TokenCache.putExpirationMilliseconds(bundle, accessExpiresMillisecondsAfterEpoch);
+                TokenCache.putPermissions(bundle, stringList(pendingAuthorizationPermissions));
+                TokenCache.putIsSSO(bundle, false);
+                TokenCache.putLastRefreshMilliseconds(bundle, lastAccessUpdateMillisecondsAfterEpoch);
+            }
+
+            return bundle;
+        }
+
+        @Override
+        public void save(Bundle bundle) {
+            accessToken = TokenCache.getToken(bundle);
+            accessExpiresMillisecondsAfterEpoch = TokenCache.getExpirationMilliseconds(bundle);
+            pendingAuthorizationPermissions = stringArray(TokenCache.getPermissions(bundle));
+            lastAccessUpdateMillisecondsAfterEpoch = TokenCache.getLastRefreshMilliseconds(bundle);
+        }
+
+        @Override
+        public void clear() {
+            accessToken = null;
+        }
     }
 
     /**
      * Get Attribution ID for app install conversion tracking.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Settings} for more info.
+     *
      * @param contentResolver
      * @return Attribution ID that will be used for conversion tracking. It will be null only if
      *         the user has not installed or logged in to the Facebook app.
      */
+    @Deprecated
     public static String getAttributionId(ContentResolver contentResolver) {
-        String [] projection = {ATTRIBUTION_ID_COLUMN_NAME};
-        Cursor c = contentResolver.query(ATTRIBUTION_ID_CONTENT_URI, projection, null, null, null);
-        if (c == null || !c.moveToFirst()) {
-            return null;
-        }
-        String attributionId = c.getString(c.getColumnIndex(ATTRIBUTION_ID_COLUMN_NAME));
-
-        return attributionId;
+        return Settings.getAttributionId(contentResolver);
     }
 
     /**
      * Get the auto install publish setting.  If true, an install event will be published during authorize(), unless
      * it has occurred previously or the app does not have install attribution enabled on the application's developer
      * config page.
-     * @return
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Settings} for more info.
+     *
+     * @return a Boolean indicating whether installation of the app should be auto-published.
      */
+    @Deprecated
     public boolean getShouldAutoPublishInstall() {
         return shouldAutoPublishInstall;
     }
 
     /**
      * Sets whether auto publishing of installs will occur.
-     * @param value
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Settings} for more info.
+     *
+     * @param value a Boolean indicating whether installation of the app should be auto-published.
      */
+    @Deprecated
     public void setShouldAutoPublishInstall(boolean value) {
         shouldAutoPublishInstall = value;
     }
@@ -976,128 +1201,31 @@ public void setShouldAutoPublishInstall(boolean value) {
     /**
      * Manually publish install attribution to the facebook graph.  Internally handles tracking repeat calls to prevent
      * multiple installs being published to the graph.
-     * @param context
-     * @return returns false on error.  Applications should retry until true is returned.  Safe to call again after
-     * true is returned.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Settings} for more info.
+     *
+     * @param context the current Android context
+     * @return Always false.  Earlier versions of the API returned true if it was no longer necessary to call.
+     * Apps should ignore this value, but for compatibility we will return false to ensure repeat calls (and the
+     * underlying code will prevent duplicate network traffic).
      */
+    @Deprecated
     public boolean publishInstall(final Context context) {
-        try {
-            // copy the application id to guarantee thread safety..
-            String applicationId = mAppId;
-            if (applicationId != null) {
-                publishInstall(this, applicationId, context);
-                return true;
-            }
-        } catch (Exception e) {
-            // if there was an error, fall through to the failure case.
-            Util.logd("Facebook-publish", e.getMessage());
-        }
+        Settings.publishInstallAsync(context, mAppId);
         return false;
     }
 
-    /**
-     * This function does the heavy lifting of publishing an install.
-     * @param fb
-     * @param applicationId
-     * @param context
-     * @throws Exception
-     */
-    private static void publishInstall(final Facebook fb, final String applicationId, final Context context)
-            throws JSONException, FacebookError, MalformedURLException, IOException {
-
-        String attributionId = Facebook.getAttributionId(context.getContentResolver());
-        SharedPreferences preferences = context.getSharedPreferences(ATTRIBUTION_PREFERENCES, Context.MODE_PRIVATE);
-        String pingKey = applicationId+"ping";
-        long lastPing = preferences.getLong(pingKey, 0);
-        if (lastPing == 0 && attributionId != null) {
-            Bundle supportsAttributionParams = new Bundle();
-            supportsAttributionParams.putString(APPLICATION_FIELDS, SUPPORTS_ATTRIBUTION);
-            JSONObject supportResponse = Util.parseJson(fb.request(applicationId, supportsAttributionParams));
-            Object doesSupportAttribution = (Boolean)supportResponse.get(SUPPORTS_ATTRIBUTION);
-
-            if (!(doesSupportAttribution instanceof Boolean)) {
-                throw new JSONException(String.format(
-                    "%s contains %s instead of a Boolean", SUPPORTS_ATTRIBUTION, doesSupportAttribution));
-            }
-
-            if ((Boolean)doesSupportAttribution) {
-                Bundle publishParams = new Bundle();
-                publishParams.putString(ANALYTICS_EVENT, MOBILE_INSTALL_EVENT);
-                publishParams.putString(ATTRIBUTION_KEY, attributionId);
-
-                String publishUrl = String.format(PUBLISH_ACTIVITY_PATH, applicationId);
-
-                fb.request(publishUrl, publishParams, "POST");
-
-                // denote success since no error threw from the post.
-                SharedPreferences.Editor editor = preferences.edit();
-                editor.putLong(pingKey, System.currentTimeMillis());
-                editor.commit();
-            }
-        }
-    }
-
-    void autoPublishAsync(final Context context) {
-        AutoPublishAsyncTask asyncTask = null;
-        synchronized (this) {
-            if (mAutoPublishAsyncTask == null && getShouldAutoPublishInstall()) {
-                // copy the application id to guarantee thread safety against our container.
-                String applicationId = Facebook.this.mAppId;
-
-                // skip publish if we don't have an application id.
-                if (applicationId != null) {
-                    asyncTask = mAutoPublishAsyncTask = new AutoPublishAsyncTask(applicationId, context);
-                }
-            }
-        }
-
-        if (asyncTask != null) {
-            asyncTask.execute();
-        }
-    }
-
-    /**
-     * Async implementation to allow auto publishing to not block the ui thread.
-     */
-    private class AutoPublishAsyncTask extends AsyncTask<Void, Void, Void> {
-        private final String mApplicationId;
-        private final Context mApplicationContext;
-
-        public AutoPublishAsyncTask(String applicationId, Context context) {
-            mApplicationId = applicationId;
-            mApplicationContext = context.getApplicationContext();
-        }
-
-        @Override
-        protected Void doInBackground(Void... voids) {
-            try {
-                Facebook.publishInstall(Facebook.this, mApplicationId, mApplicationContext);
-            } catch (Exception e) {
-                Util.logd("Facebook-publish", e.getMessage());
-            }
-            return null;
-        }
-
-        @Override
-        protected void onPostExecute(Void result) {
-            // always clear out the publisher to allow other invocations.
-            synchronized (Facebook.this) {
-                mAutoPublishAsyncTask = null;
-            }
-        }
-    }
-
     /**
      * Callback interface for dialog requests.
-     *
+     * 
      */
     public static interface DialogListener {
 
         /**
          * Called when a dialog completes.
-         *
+         * 
          * Executed by the thread that initiated the dialog.
-         *
+         * 
          * @param values
          *            Key-value string pairs extracted from the response.
          */
@@ -1105,30 +1233,30 @@ protected void onPostExecute(Void result) {
 
         /**
          * Called when a Facebook responds to a dialog with an error.
-         *
+         * 
          * Executed by the thread that initiated the dialog.
-         *
+         * 
          */
         public void onFacebookError(FacebookError e);
 
         /**
          * Called when a dialog has an error.
-         *
+         * 
          * Executed by the thread that initiated the dialog.
-         *
+         * 
          */
         public void onError(DialogError e);
 
         /**
          * Called when a dialog is canceled by the user.
-         *
+         * 
          * Executed by the thread that initiated the dialog.
-         *
+         * 
          */
         public void onCancel();
 
     }
-    
+
     /**
      * Callback interface for service requests.
      */
diff --git a/facebook/src/com/facebook/android/FbDialog.java b/facebook/src/com/facebook/android/FbDialog.java
index 9622f816d..e556365b8 100644
--- a/facebook/src/com/facebook/android/FbDialog.java
+++ b/facebook/src/com/facebook/android/FbDialog.java
@@ -16,26 +16,27 @@
 
 package com.facebook.android;
 
+import android.annotation.SuppressLint;
 import android.app.Dialog;
 import android.app.ProgressDialog;
 import android.content.Context;
+import android.content.DialogInterface;
 import android.content.Intent;
 import android.graphics.Bitmap;
 import android.graphics.Color;
 import android.graphics.drawable.Drawable;
 import android.net.Uri;
+import android.net.http.SslError;
 import android.os.Bundle;
-import android.util.Log;
 import android.view.View;
-import android.view.ViewGroup;
 import android.view.ViewGroup.LayoutParams;
 import android.view.Window;
+import android.webkit.SslErrorHandler;
 import android.webkit.WebView;
 import android.webkit.WebViewClient;
 import android.widget.FrameLayout;
 import android.widget.ImageView;
 import android.widget.LinearLayout;
-
 import com.facebook.android.Facebook.DialogListener;
 
 public class FbDialog extends Dialog {
@@ -44,8 +45,8 @@
     static final float[] DIMENSIONS_DIFF_LANDSCAPE = {20, 60};
     static final float[] DIMENSIONS_DIFF_PORTRAIT = {40, 60};
     static final FrameLayout.LayoutParams FILL =
-        new FrameLayout.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,
-                         ViewGroup.LayoutParams.FILL_PARENT);
+        new FrameLayout.LayoutParams(LayoutParams.MATCH_PARENT,
+                         LayoutParams.MATCH_PARENT);
     static final int MARGIN = 4;
     static final int PADDING = 2;
     static final String DISPLAY_STRING = "touch";
@@ -61,15 +62,41 @@
     public FbDialog(Context context, String url, DialogListener listener) {
         super(context, android.R.style.Theme_Translucent_NoTitleBar);
         mUrl = url;
-        mListener = listener;
+        mListener = new SingleDispatchDialogListener(listener);
+    }
+
+    @Override
+    public void dismiss() {
+        if (mWebView != null) {
+            mWebView.stopLoading();
+        }
+        if (mSpinner.isShowing()) {
+            mSpinner.dismiss();
+        }
+        super.dismiss();
     }
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
+
+        setOnCancelListener(new OnCancelListener() {
+            @Override
+            public void onCancel(DialogInterface dialogInterface) {
+                mListener.onCancel();
+            }
+        });
+
         mSpinner = new ProgressDialog(getContext());
         mSpinner.requestWindowFeature(Window.FEATURE_NO_TITLE);
         mSpinner.setMessage("Loading...");
+        mSpinner.setOnCancelListener(new OnCancelListener() {
+            @Override
+            public void onCancel(DialogInterface dialogInterface) {
+                mListener.onCancel();
+                FbDialog.this.dismiss();
+            }
+        });
         
         requestWindowFeature(Window.FEATURE_NO_TITLE);
         mContent = new FrameLayout(getContext());
@@ -90,7 +117,7 @@ protected void onCreate(Bundle savedInstanceState) {
          * add mContent to the Dialog view
          */
         mContent.addView(mCrossImage, new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));
-        addContentView(mContent, new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));
+        addContentView(mContent, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
     }
     
     private void createCrossImage() {
@@ -103,7 +130,7 @@ public void onClick(View v) {
                 FbDialog.this.dismiss();
             }
         });
-        Drawable crossDrawable = getContext().getResources().getDrawable(R.drawable.close);
+        Drawable crossDrawable = getContext().getResources().getDrawable(R.drawable.com_facebook_close);
         mCrossImage.setImageDrawable(crossDrawable);
         /* 'x' should not be visible while webview is loading
          * make it visible only after webview has fully loaded
@@ -111,6 +138,7 @@ public void onClick(View v) {
         mCrossImage.setVisibility(View.INVISIBLE);
     }
 
+    @SuppressLint("SetJavaScriptEnabled") 
     private void setUpWebView(int margin) {
         LinearLayout webViewContainer = new LinearLayout(getContext());
         mWebView = new WebView(getContext());
@@ -174,6 +202,15 @@ public void onReceivedError(WebView view, int errorCode,
             FbDialog.this.dismiss();
         }
 
+        @Override
+        public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {
+            super.onReceivedSslError(view, handler, error);
+
+            mListener.onError(new DialogError(null, ERROR_FAILED_SSL_HANDSHAKE, null));
+            handler.cancel();
+            FbDialog.this.dismiss();
+        }
+
         @Override
         public void onPageStarted(WebView view, String url, Bitmap favicon) {
             Util.logd("Facebook-WebView", "Webview loading URL: " + url);
@@ -194,4 +231,56 @@ public void onPageFinished(WebView view, String url) {
             mCrossImage.setVisibility(View.VISIBLE);
         }
     }
+
+    /**
+     * Ensure that only one listener method is called per dialog. This class is not thread
+     * safe and assumes that all onXXX calls will be made in the same thread (preferably the
+     * main thread). It is package private for testing purposes.
+     */
+    static class SingleDispatchDialogListener implements DialogListener {
+
+        private final DialogListener wrapped;
+        private boolean allowDispatch;
+
+        public SingleDispatchDialogListener(DialogListener listener) {
+            wrapped = listener;
+            allowDispatch = true;
+        }
+
+        @Override
+        public void onComplete(Bundle values) {
+            if (checkAndSetDispatch(false)) {
+                wrapped.onComplete(values);
+            }
+        }
+
+        @Override
+        public void onFacebookError(FacebookError e) {
+            if (checkAndSetDispatch(false)) {
+                wrapped.onFacebookError(e);
+            }
+        }
+
+        @Override
+        public void onError(DialogError e) {
+            if (checkAndSetDispatch(false)) {
+                wrapped.onError(e);
+            }
+        }
+
+        @Override
+        public void onCancel() {
+            if (checkAndSetDispatch(false)) {
+                wrapped.onCancel();
+            }
+        }
+
+        private boolean checkAndSetDispatch(boolean finalValue) {
+            if (wrapped != null && allowDispatch) {
+                allowDispatch = finalValue;
+                return true;
+            }
+            return false;
+        }
+    }
 }
diff --git a/facebook/src/com/facebook/android/Util.java b/facebook/src/com/facebook/android/Util.java
index 52cf4d87b..52dda1232 100644
--- a/facebook/src/com/facebook/android/Util.java
+++ b/facebook/src/com/facebook/android/Util.java
@@ -16,28 +16,15 @@
 
 package com.facebook.android;
 
-import java.io.BufferedOutputStream;
-import java.io.BufferedReader;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.net.HttpURLConnection;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.net.URLDecoder;
-import java.net.URLEncoder;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
 import android.app.AlertDialog.Builder;
 import android.content.Context;
 import android.os.Bundle;
 import android.util.Log;
-import android.webkit.CookieManager;
-import android.webkit.CookieSyncManager;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.*;
+import java.net.*;
 
 /**
  * Utility class supporting the Facebook Object.
@@ -53,6 +40,8 @@
      */
     private static boolean ENABLE_LOG = false;
 
+    private final static String UTF8 = "UTF-8";
+
     /**
      * Generate the multi-part post body providing the parameters and boundary
      * string
@@ -105,9 +94,16 @@ public static Bundle decodeUrl(String s) {
             String array[] = s.split("&");
             for (String parameter : array) {
                 String v[] = parameter.split("=");
-                if (v.length == 2) {
-                    params.putString(URLDecoder.decode(v[0]),
-                                     URLDecoder.decode(v[1]));
+
+                try {
+                    if (v.length == 2) {
+                        params.putString(URLDecoder.decode(v[0], UTF8),
+                                         URLDecoder.decode(v[1], UTF8));
+                    } else if (v.length == 1) {
+                        params.putString(URLDecoder.decode(v[0], UTF8), "");
+                    }
+                } catch (UnsupportedEncodingException e) {
+                    // shouldn't happen
                 }
             }
         }
@@ -230,19 +226,6 @@ private static String read(InputStream in) throws IOException {
         return sb.toString();
     }
 
-    public static void clearCookies(Context context) {
-        // Edge case: an illegal state exception is thrown if an instance of
-        // CookieSyncManager has not be created.  CookieSyncManager is normally
-        // created by a WebKit view, but this might happen if you start the
-        // app, restore saved state, and click logout before running a UI
-        // dialog in a WebView -- in which case the app crashes
-        @SuppressWarnings("unused")
-        CookieSyncManager cookieSyncMngr =
-            CookieSyncManager.createInstance(context);
-        CookieManager cookieManager = CookieManager.getInstance();
-        cookieManager.removeAllCookie();
-    }
-
     /**
      * Parse a server response into a JSON Object. This is a basic
      * implementation using org.json.JSONObject representation. More
diff --git a/facebook/tests/.classpath b/facebook/tests/.classpath
new file mode 100644
index 000000000..a4763d1ee
--- /dev/null
+++ b/facebook/tests/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/facebook/tests/.project b/facebook/tests/.project
new file mode 100644
index 000000000..82993b5a8
--- /dev/null
+++ b/facebook/tests/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SDKTests</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/facebook/tests/AndroidManifest.xml b/facebook/tests/AndroidManifest.xml
new file mode 100644
index 000000000..a93331391
--- /dev/null
+++ b/facebook/tests/AndroidManifest.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- package name must be unique so suffix with "tests" so package loader doesn't ignore us -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.facebook.sdk.tests"
+          android:versionCode="1"
+          android:versionName="1.0">
+    <uses-permission android:name="android.permission.INTERNET"></uses-permission>
+    <uses-sdk android:minSdkVersion="7" android:targetSdkVersion="7"/>
+    <!-- We add an application tag here just so that we can indicate that
+         this package needs to link against the android.test library,
+         which is needed when building test cases. -->
+    <application>
+        <uses-library android:name="android.test.runner"/>
+        <activity android:name="com.facebook.FacebookTestCase$FacebookTestActivity"/>
+        <activity android:name="com.facebook.FriendPickerFragmentTests$TestActivity"/>
+        <activity android:name="com.facebook.PlacePickerFragmentTests$TestActivity"/>
+        <activity android:name="com.facebook.GraphObjectPagingLoaderTests$TestActivity"/>
+        <activity android:name="com.facebook.LoginActivity" />
+        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
+    </application>
+    <!--
+    This declares that this application uses the instrumentation test runner targeting
+    the package of com.facebook.sdk.  To run the tests use the command:
+    "adb shell am instrument -w com.facebook.sdk.tests/android.test.InstrumentationTestRunner"
+    -->
+    <instrumentation android:name="android.test.InstrumentationTestRunner"
+                     android:targetPackage="com.facebook.sdk.tests"
+                     android:label="Tests for com.facebook.sdk.tests"/>
+</manifest>
diff --git a/facebook/tests/SdkTests.eml b/facebook/tests/SdkTests.eml
new file mode 100644
index 000000000..3bbc2f8d5
--- /dev/null
+++ b/facebook/tests/SdkTests.eml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<component>
+	<exclude-output/>
+	<contentEntry url="file://$MODULE_DIR$"/>
+	<module name="SdkTestApp" scope="PROVIDED"/>
+</component>
diff --git a/facebook/tests/SdkTests.iml b/facebook/tests/SdkTests.iml
new file mode 100644
index 000000000..9843b7e24
--- /dev/null
+++ b/facebook/tests/SdkTests.iml
@@ -0,0 +1,56 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="EclipseModuleManager">
+    <conelement value="com.android.ide.eclipse.adt.LIBRARIES" />
+    <src_description expected_position="1">
+      <src_folder value="file://$MODULE_DIR$/src" expected_position="1" />
+      <src_folder value="file://$MODULE_DIR$/gen" expected_position="2" />
+    </src_description>
+  </component>
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="true" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/bin/classes" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/assets" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" exported="" />
+    <orderEntry type="module" module-name="SdkTestApp" scope="PROVIDED" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/facebook/tests/ant.properties b/facebook/tests/ant.properties
new file mode 100644
index 000000000..928de2ff9
--- /dev/null
+++ b/facebook/tests/ant.properties
@@ -0,0 +1,20 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
+# Removed based on advice at code.google.com/p/android/issues/detail?id=21108#c2
+# and the comment that follows.
+# tested.project.dir=../TestApp
diff --git a/facebook/tests/build.xml b/facebook/tests/build.xml
new file mode 100644
index 000000000..34c89faa8
--- /dev/null
+++ b/facebook/tests/build.xml
@@ -0,0 +1,101 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="FacebookSdkTests" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties" />
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties" />
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties" />
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through an env var"
+            unless="sdk.dir"
+    />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true" />
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml" />
+
+    <!-- SDK Tools r15 workaround -->
+    <property name="tested.manifest.package" value="com.facebook.sdk.tests" />
+
+    <!-- This seems to have no effect.  The value remains android.test.AndroidTestRunner -->
+    <!-- <property name="test.runner" value="android.test.InstrumentationTestRunner" /> -->
+
+    <target name="run-tests">
+      <echo>Running tests...</echo>
+      <exec executable="${adb}" failonerror="true">
+        <arg line="${adb.device.arg}" />
+        <arg value="shell" />
+        <arg value="am" />
+        <arg value="instrument" />
+        <arg value="-w" />
+        <!-- was <arg value="${tested.manifest.package}/${test.runner}" /> -->
+        <arg value="${tested.manifest.package}/android.test.InstrumentationTestRunner" />
+      </exec>
+    </target>
+</project>
diff --git a/facebook/tests/proguard-project.txt b/facebook/tests/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/facebook/tests/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/facebook/tests/project.properties b/facebook/tests/project.properties
new file mode 100644
index 000000000..705d57d8d
--- /dev/null
+++ b/facebook/tests/project.properties
@@ -0,0 +1,16 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+test.runner=android.test.AndroidTestRunner
+android.library.reference.1=../../facebook
diff --git a/facebook/tests/res/layout/friend_picker_test_layout_1.xml b/facebook/tests/res/layout/friend_picker_test_layout_1.xml
new file mode 100644
index 000000000..31fedd78a
--- /dev/null
+++ b/facebook/tests/res/layout/friend_picker_test_layout_1.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              xmlns:app="http://schemas.android.com/apk/res-auto"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent">
+
+    <fragment
+            android:id="@+id/friend_picker_fragment"
+            android:name="com.facebook.FriendPickerFragment"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            app:show_pictures="false"
+            app:multi_select="false"
+            app:extra_fields="middle_name,link"
+            />
+</LinearLayout>
\ No newline at end of file
diff --git a/facebook/tests/res/layout/place_picker_test_layout_1.xml b/facebook/tests/res/layout/place_picker_test_layout_1.xml
new file mode 100644
index 000000000..51ba709fc
--- /dev/null
+++ b/facebook/tests/res/layout/place_picker_test_layout_1.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              xmlns:app="http://schemas.android.com/apk/res-auto"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent">
+
+    <fragment
+            android:id="@+id/place_picker_fragment"
+            android:name="com.facebook.PlacePickerFragment"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            app:show_pictures="false"
+            app:radius_in_meters="75"
+            app:results_limit="5"
+            app:search_text="coffee"
+            app:extra_fields="checkins,general_info"
+            />
+</LinearLayout>
\ No newline at end of file
diff --git a/facebook/tests/res/values/strings.xml b/facebook/tests/res/values/strings.xml
new file mode 100644
index 000000000..6d33d2b96
--- /dev/null
+++ b/facebook/tests/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+    <string name="app_id">1234567890</string>
+</resources>
\ No newline at end of file
diff --git a/facebook/tests/src/com/facebook/AccessTokenTests.java b/facebook/tests/src/com/facebook/AccessTokenTests.java
new file mode 100644
index 000000000..18ee7cbfd
--- /dev/null
+++ b/facebook/tests/src/com/facebook/AccessTokenTests.java
@@ -0,0 +1,249 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+
+public final class AccessTokenTests extends AndroidTestCase {
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testEmptyToken() {
+        List<String> permissions = list();
+        AccessToken token = AccessToken.createEmptyToken(permissions);
+        assertSamePermissions(permissions, token);
+        assertEquals("", token.getToken());
+        assertTrue(token.isInvalid());
+        assertTrue(token.getExpires().before(new Date()));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testEmptyTokenWithPermissions() {
+        List<String> permissions = list("stream_publish");
+        AccessToken token = AccessToken.createEmptyToken(permissions);
+        assertSamePermissions(permissions, token);
+        assertEquals("", token.getToken());
+        assertTrue(token.isInvalid());
+        assertTrue(token.getExpires().before(new Date()));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testFromDialog() {
+        List<String> permissions = list("stream_publish", "go_outside_and_play");
+        String token = "AnImaginaryTokenValue";
+
+        Bundle bundle = new Bundle();
+        bundle.putString("access_token", token);
+        bundle.putString("expires_in", "60");
+
+        AccessToken accessToken = AccessToken.createFromDialog(permissions, bundle);
+        assertSamePermissions(permissions, accessToken);
+        assertEquals(token, accessToken.getToken());
+        assertFalse(accessToken.getIsSSO());
+        assertTrue(!accessToken.isInvalid());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testFromSSOWithExpiresString() {
+        List<String> permissions = list("stream_publish", "go_outside_and_play");
+        String token = "AnImaginaryTokenValue";
+
+        Intent intent = new Intent();
+        intent.putExtra("access_token", token);
+        intent.putExtra("expires_in", "60");
+        intent.putExtra("extra_extra", "Something unrelated");
+
+        AccessToken accessToken = AccessToken.createFromSSO(permissions, intent);
+        assertSamePermissions(permissions, accessToken);
+        assertEquals(token, accessToken.getToken());
+        assertTrue(accessToken.getIsSSO());
+        assertTrue(!accessToken.isInvalid());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testFromSSOWithExpiresLong() {
+        List<String> permissions = list("stream_publish", "go_outside_and_play");
+        String token = "AnImaginaryTokenValue";
+
+        Intent intent = new Intent();
+        intent.putExtra("access_token", token);
+        intent.putExtra("expires_in", 60L);
+        intent.putExtra("extra_extra", "Something unrelated");
+
+        AccessToken accessToken = AccessToken.createFromSSO(permissions, intent);
+        assertSamePermissions(permissions, accessToken);
+        assertEquals(token, accessToken.getToken());
+        assertTrue(accessToken.getIsSSO());
+        assertTrue(!accessToken.isInvalid());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCacheRoundtrip() {
+        ArrayList<String> permissions = list("stream_publish", "go_outside_and_play");
+        String token = "AnImaginaryTokenValue";
+        Date later = nowPlusSeconds(60);
+        Date earlier = nowPlusSeconds(-60);
+
+        Bundle bundle = new Bundle();
+        TokenCache.putToken(bundle, token);
+        TokenCache.putExpirationDate(bundle, later);
+        TokenCache.putIsSSO(bundle, true);
+        TokenCache.putLastRefreshDate(bundle, earlier);
+        TokenCache.putPermissions(bundle, permissions);
+
+        AccessToken accessToken = AccessToken.createFromCache(bundle);
+        assertSamePermissions(permissions, accessToken);
+        assertEquals(token, accessToken.getToken());
+        assertTrue(accessToken.getIsSSO());
+        assertTrue(!accessToken.isInvalid());
+
+        Bundle cache = accessToken.toCacheBundle();
+        assertEqualContents(bundle, cache);
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testCachePutGet() {
+        Bundle bundle = new Bundle();
+
+        for (String token : new String[] { "", "A completely random token value" }) {
+            TokenCache.putToken(bundle, token);
+            assertEquals(token, TokenCache.getToken(bundle));
+        }
+
+        for (Date date : new Date[] { new Date(42), new Date() }) {
+            TokenCache.putExpirationDate(bundle, date);
+            assertEquals(date, TokenCache.getExpirationDate(bundle));
+
+            TokenCache.putLastRefreshDate(bundle, date);
+            assertEquals(date, TokenCache.getLastRefreshDate(bundle));
+        }
+
+        for (long milliseconds : new long[] { 0, -1, System.currentTimeMillis() }) {
+            TokenCache.putExpirationMilliseconds(bundle, milliseconds);
+            assertEquals(milliseconds, TokenCache.getExpirationMilliseconds(bundle));
+
+            TokenCache.putLastRefreshMilliseconds(bundle, milliseconds);
+            assertEquals(milliseconds, TokenCache.getLastRefreshMilliseconds(bundle));
+        }
+
+        for (boolean isSSO : new boolean[] { true, false }) {
+            TokenCache.putIsSSO(bundle, isSSO);
+            assertEquals(isSSO, TokenCache.getIsSSO(bundle));
+        }
+
+        List<String> normalList = Arrays.asList("", "Another completely random token value");
+        List<String> emptyList = Arrays.asList();
+        ArrayList<String> normalArrayList = new ArrayList<String>(normalList);
+        ArrayList<String> emptyArrayList = new ArrayList<String>();
+        @SuppressWarnings("unchecked")
+        List<List<String>> permissionLists = Arrays
+                .asList(normalList, emptyList, normalArrayList, emptyArrayList);
+        for (List<String> list : permissionLists) {
+            TokenCache.putPermissions(bundle, list);
+            assertSamePermissions(list, TokenCache.getPermissions(bundle));
+        }
+        normalArrayList.add(null);
+    }
+    
+    @SmallTest
+    public void testBasicSerialization() throws IOException {
+        AccessToken accessToken = AccessToken.createFromString("a token",
+                Arrays.asList("permission_1", "permission_2"));
+        AccessToken res = TestUtils.serializeAndUnserialize(accessToken);
+        
+        // if one field got serialized most likely all other non transient fields
+        // got serialized correctly.
+        assertEquals(accessToken.getPermissions(), res.getPermissions());
+        assertEquals(accessToken.getToken(), res.getToken());
+    }
+
+    private ArrayList<String> list(String... ss) {
+        ArrayList<String> result = new ArrayList<String>();
+
+        for (String s : ss) {
+            result.add(s);
+        }
+
+        return result;
+    }
+
+    private static Date nowPlusSeconds(long offset) {
+        return new Date(new Date().getTime() + (offset * 1000L));
+    }
+
+    private static void assertSamePermissions(List<String> expected, AccessToken actual) {
+        if (expected == null) {
+            assertEquals(null, actual.getPermissions());
+        } else {
+            for (String p : expected) {
+                assertTrue(actual.getPermissions().contains(p));
+            }
+            for (String p : actual.getPermissions()) {
+                assertTrue(expected.contains(p));
+            }
+        }
+    }
+
+    private static void assertSamePermissions(List<String> expected, List<String> actual) {
+        if (expected == null) {
+            assertEquals(null, actual);
+        } else {
+            for (String p : expected) {
+                assertTrue(actual.contains(p));
+            }
+            for (String p : actual) {
+                assertTrue(expected.contains(p));
+            }
+        }
+    }
+
+    private static void assertEqualContents(Bundle a, Bundle b) {
+        for (String key : a.keySet()) {
+            if (!b.containsKey(key)) {
+                fail("bundle does not include key " + key);
+            }
+            assertEquals(a.get(key), b.get(key));
+        }
+        for (String key : b.keySet()) {
+            if (!a.containsKey(key)) {
+                fail("bundle does not include key " + key);
+            }
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/AsyncRequestTests.java b/facebook/tests/src/com/facebook/AsyncRequestTests.java
new file mode 100644
index 000000000..4fec540b6
--- /dev/null
+++ b/facebook/tests/src/com/facebook/AsyncRequestTests.java
@@ -0,0 +1,308 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.facebook;
+
+import android.graphics.Bitmap;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+
+import java.net.HttpURLConnection;
+import java.util.Arrays;
+import java.util.List;
+
+public class AsyncRequestTests extends FacebookTestCase {
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanLaunchAsyncRequestFromUiThread() {
+        Request request = Request.newPostRequest(null, "me/feeds", null, null);
+        try {
+            TestRequestAsyncTask task = createAsyncTaskOnUiThread(request);
+            assertNotNull(task);
+        } catch (Throwable throwable) {
+            assertNull(throwable);
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testExecuteWithNullRequestsThrows() throws Exception {
+        try {
+            TestRequestAsyncTask task = new TestRequestAsyncTask((Request[]) null);
+
+            task.executeOnBlockerThread();
+
+            waitAndAssertSuccessOrRethrow(1);
+
+            fail("expected NullPointerException");
+        } catch (NullPointerException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testExecuteBatchWithZeroRequestsThrows() throws Exception {
+        try {
+            TestRequestAsyncTask task = new TestRequestAsyncTask(new Request[] {});
+
+            task.executeOnBlockerThread();
+
+            waitAndAssertSuccessOrRethrow(1);
+
+            fail("expected IllegalArgumentException");
+        } catch (IllegalArgumentException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testExecuteBatchWithNullRequestThrows() throws Exception {
+        try {
+            TestRequestAsyncTask task = new TestRequestAsyncTask(new Request[] { null });
+
+            task.executeOnBlockerThread();
+
+            waitAndAssertSuccessOrRethrow(1);
+
+            fail("expected NullPointerException");
+        } catch (NullPointerException exception) {
+        }
+
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecuteSingleGet() {
+        Request request = new Request(null, "TourEiffel", null, null, new ExpectSuccessCallback() {
+            @Override
+            protected void performAsserts(Response response) {
+                assertNotNull(response);
+                GraphPlace graphPlace = response.getGraphObjectAs(GraphPlace.class);
+                assertEquals("Paris", graphPlace.getLocation().getCity());
+            }
+        });
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(request);
+
+        task.executeOnBlockerThread();
+
+        // Wait on 2 signals: request and task will both signal.
+        waitAndAssertSuccess(2);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecuteSingleGetUsingHttpURLConnection() {
+        Request request = new Request(null, "TourEiffel", null, null, new ExpectSuccessCallback() {
+            @Override
+            protected void performAsserts(Response response) {
+                assertNotNull(response);
+                GraphPlace graphPlace = response.getGraphObjectAs(GraphPlace.class);
+                assertEquals("Paris", graphPlace.getLocation().getCity());
+            }
+        });
+        HttpURLConnection connection = Request.toHttpConnection(request);
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(connection, Arrays.asList(new Request[] { request }));
+
+        task.executeOnBlockerThread();
+
+        // Wait on 2 signals: request and task will both signal.
+        waitAndAssertSuccess(2);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecuteSingleGetFailureCase() {
+        Request request = new Request(null, "-1", null, null, new ExpectFailureCallback());
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(request);
+
+        task.executeOnBlockerThread();
+
+        // Wait on 2 signals: request and task will both signal.
+        waitAndAssertSuccess(2);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testBatchWithoutAppIDIsError() throws Throwable {
+        Request request1 = new Request(null, "TourEiffel", null, null, new ExpectFailureCallback());
+        Request request2 = new Request(null, "SpaceNeedle", null, null, new ExpectFailureCallback());
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(request1, request2);
+
+        task.executeOnBlockerThread();
+
+        // Wait on 3 signals: request1, request2, and task will all signal.
+        waitAndAssertSuccessOrRethrow(3);
+    }
+
+    @LargeTest
+    public void testMixedSuccessAndFailure() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        final int NUM_REQUESTS = 8;
+        Request[] requests = new Request[NUM_REQUESTS];
+        for (int i = 0; i < NUM_REQUESTS; ++i) {
+            boolean shouldSucceed = (i % 2) == 1;
+            if (shouldSucceed) {
+                requests[i] = new Request(session, "me", null, null, new ExpectSuccessCallback());
+            } else {
+                requests[i] = new Request(session, "-1", null, null, new ExpectFailureCallback());
+            }
+        }
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(requests);
+
+        task.executeOnBlockerThread();
+
+        // Note: plus 1, because the overall async task signals as well.
+        waitAndAssertSuccess(NUM_REQUESTS + 1);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testStaticExecuteMeAsync() {
+        final TestSession session = openTestSessionWithSharedUser();
+
+        class MeCallback extends ExpectSuccessCallback implements Request.GraphUserCallback {
+            @Override
+            public void onCompleted(GraphUser me, Response response) {
+                assertNotNull(me);
+                assertEquals(session.getTestUserId(), me.getId());
+                RequestTests.validateMeResponse(session, response);
+                onCompleted(response);
+            }
+        }
+
+        runOnBlockerThread(new Runnable() {
+            @Override
+            public void run() {
+                Request.executeMeRequestAsync(session, new MeCallback());
+            }
+        }, false);
+        waitAndAssertSuccess(1);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testStaticExecuteMyFriendsAsync() {
+        final TestSession session = openTestSessionWithSharedUser();
+
+        class FriendsCallback extends ExpectSuccessCallback implements Request.GraphUserListCallback {
+            @Override
+            public void onCompleted(List<GraphUser> friends, Response response) {
+                assertNotNull(friends);
+                RequestTests.validateMyFriendsResponse(session, response);
+                onCompleted(response);
+            }
+        }
+
+        runOnBlockerThread(new Runnable() {
+            @Override
+            public void run() {
+                Request.executeMyFriendsRequestAsync(session, new FriendsCallback());
+            }
+        }, false);
+        waitAndAssertSuccess(1);
+    }
+
+    @LargeTest
+    public void testBatchUploadPhoto() {
+        TestSession session = openTestSessionWithSharedUserAndPermissions(null, "user_photos");
+
+        final int image1Size = 120;
+        final int image2Size = 150;
+
+        Bitmap bitmap1 = createTestBitmap(image1Size);
+        Bitmap bitmap2 = createTestBitmap(image2Size);
+
+        Request uploadRequest1 = Request.newUploadPhotoRequest(session, bitmap1, null);
+        uploadRequest1.setBatchEntryName("uploadRequest1");
+        Request uploadRequest2 = Request.newUploadPhotoRequest(session, bitmap2, null);
+        uploadRequest2.setBatchEntryName("uploadRequest2");
+        Request getRequest1 = new Request(session, "{result=uploadRequest1:$.id}", null, null,
+                new ExpectSuccessCallback() {
+                    @Override
+                    protected void performAsserts(Response response) {
+                        assertNotNull(response);
+                        GraphObject retrievedPhoto = response.getGraphObject();
+                        assertNotNull(retrievedPhoto);
+                        assertEquals(image1Size, retrievedPhoto.getProperty("width"));
+                    }
+                });
+        Request getRequest2 = new Request(session, "{result=uploadRequest2:$.id}", null, null,
+                new ExpectSuccessCallback() {
+                    @Override
+                    protected void performAsserts(Response response) {
+                        assertNotNull(response);
+                        GraphObject retrievedPhoto = response.getGraphObject();
+                        assertNotNull(retrievedPhoto);
+                        assertEquals(image2Size, retrievedPhoto.getProperty("width"));
+                    }
+                });
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(uploadRequest1, uploadRequest2, getRequest1, getRequest2);
+        task.executeOnBlockerThread();
+
+        // Wait on 3 signals: getRequest1, getRequest2, and task will all signal.
+        waitAndAssertSuccess(3);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testShortTimeoutCausesFailure() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request request = new Request(session, "me/likes", null, null, new ExpectFailureCallback());
+
+        RequestBatch requestBatch = new RequestBatch(request);
+
+        // 1 millisecond timeout should be too short for response from server.
+        requestBatch.setTimeout(1);
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(requestBatch);
+        task.executeOnBlockerThread();
+
+        // Note: plus 1, because the overall async task signals as well.
+        waitAndAssertSuccess(2);
+    }
+
+    @LargeTest
+    public void testLongTimeoutAllowsSuccess() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request request = new Request(session, "me", null, null, new ExpectSuccessCallback());
+
+        RequestBatch requestBatch = new RequestBatch(request);
+
+        // 10 second timeout should be long enough for successful response from server.
+        requestBatch.setTimeout(10000);
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(requestBatch);
+        task.executeOnBlockerThread();
+
+        // Note: plus 1, because the overall async task signals as well.
+        waitAndAssertSuccess(2);
+    }
+}
diff --git a/facebook/tests/src/com/facebook/BatchRequestTests.java b/facebook/tests/src/com/facebook/BatchRequestTests.java
new file mode 100644
index 000000000..a6c67c49b
--- /dev/null
+++ b/facebook/tests/src/com/facebook/BatchRequestTests.java
@@ -0,0 +1,467 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.facebook;
+
+import android.graphics.Bitmap;
+import android.os.Handler;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+public class BatchRequestTests extends FacebookTestCase {
+    protected void setUp() throws Exception {
+        super.setUp();
+
+        // Tests that need this set should explicitly set it.
+        Request.setDefaultBatchApplicationId(null);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreateEmptyRequestBatch() {
+        RequestBatch batch = new RequestBatch();
+
+        Request meRequest = Request.newMeRequest(null, null);
+        assertEquals(0, batch.size());
+        batch.add(meRequest);
+        assertEquals(1, batch.size());
+        assertEquals(meRequest, batch.get(0));
+
+        String key = "The Key";
+        assertNull(batch.getCacheKey());
+        batch.setCacheKey(key);
+        assertEquals(key, batch.getCacheKey());
+
+        TestBlocker blocker = getTestBlocker();
+        Handler handler = blocker.getHandler();
+        assertNull(batch.getCallbackHandler());
+        batch.setCallbackHandler(handler);
+        assertNotNull(batch.getCallbackHandler());
+
+        assertTrue(!batch.getForceRoundTrip());
+        batch.setForceRoundTrip(true);
+        assertTrue(batch.getForceRoundTrip());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreateNonemptyRequestBatch() {
+        Request meRequest = Request.newMeRequest(null, null);
+
+        RequestBatch batch = new RequestBatch(new Request[] { meRequest, meRequest });
+        assertEquals(2, batch.size());
+        assertEquals(meRequest, batch.get(0));
+        assertEquals(meRequest, batch.get(1));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testBatchWithoutAppIDIsError() {
+        Request request1 = new Request(null, "TourEiffel", null, null, new ExpectFailureCallback());
+        Request request2 = new Request(null, "SpaceNeedle", null, null, new ExpectFailureCallback());
+        Request.executeBatchAndWait(request1, request2);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecuteBatchedGets() throws IOException {
+        setBatchApplicationIdForTestApp();
+
+        Request request1 = new Request(null, "TourEiffel");
+        Request request2 = new Request(null, "SpaceNeedle");
+
+        List<Response> responses = Request.executeBatchAndWait(request1, request2);
+        assertEquals(2, responses.size());
+        assertTrue(responses.get(0).getError() == null);
+        assertTrue(responses.get(1).getError() == null);
+
+        GraphPlace eiffelTower = responses.get(0).getGraphObjectAs(GraphPlace.class);
+        GraphPlace spaceNeedle = responses.get(1).getGraphObjectAs(GraphPlace.class);
+        assertTrue(eiffelTower != null);
+        assertTrue(spaceNeedle != null);
+
+        assertEquals("Paris", eiffelTower.getLocation().getCity());
+        assertEquals("Seattle", spaceNeedle.getLocation().getCity());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testFacebookErrorResponsesCreateErrors() {
+        setBatchApplicationIdForTestApp();
+
+        Request request1 = new Request(null, "somestringthatshouldneverbeavalidfobjectid");
+        Request request2 = new Request(null, "someotherstringthatshouldneverbeavalidfobjectid");
+        List<Response> responses = Request.executeBatchAndWait(request1, request2);
+
+        assertEquals(2, responses.size());
+        assertTrue(responses.get(0).getError() != null);
+        assertTrue(responses.get(1).getError() != null);
+
+        FacebookException exception1 = responses.get(0).getError();
+        assertTrue(exception1 instanceof FacebookServiceErrorException);
+        FacebookServiceErrorException serviceException1 = (FacebookServiceErrorException) exception1;
+        assertTrue(serviceException1.getFacebookErrorType() != null);
+        assertTrue(serviceException1.getFacebookErrorCode() != FacebookServiceErrorException.UNKNOWN_ERROR_CODE);
+    }
+
+    @LargeTest
+    public void testBatchPostStatusUpdate() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        GraphObject statusUpdate1 = createStatusUpdate();
+        GraphObject statusUpdate2 = createStatusUpdate();
+
+        Request postRequest1 = Request.newPostRequest(session, "me/feed", statusUpdate1, null);
+        postRequest1.setBatchEntryName("postRequest1");
+        Request postRequest2 = Request.newPostRequest(session, "me/feed", statusUpdate2, null);
+        postRequest2.setBatchEntryName("postRequest2");
+        Request getRequest1 = new Request(session, "{result=postRequest1:$.id}");
+        Request getRequest2 = new Request(session, "{result=postRequest2:$.id}");
+
+        List<Response> responses = Request.executeBatchAndWait(postRequest1, postRequest2, getRequest1, getRequest2);
+        assertNotNull(responses);
+        assertEquals(4, responses.size());
+        assertNoErrors(responses);
+
+        GraphObject retrievedStatusUpdate1 = responses.get(2).getGraphObject();
+        GraphObject retrievedStatusUpdate2 = responses.get(3).getGraphObject();
+        assertNotNull(retrievedStatusUpdate1);
+        assertNotNull(retrievedStatusUpdate2);
+
+        assertEquals(statusUpdate1.getProperty("message"), retrievedStatusUpdate1.getProperty("message"));
+        assertEquals(statusUpdate2.getProperty("message"), retrievedStatusUpdate2.getProperty("message"));
+    }
+
+    @LargeTest
+    public void testTwoDifferentAccessTokens() {
+        TestSession session1 = openTestSessionWithSharedUser();
+        TestSession session2 = openTestSessionWithSharedUser(SECOND_TEST_USER_TAG);
+
+        Request request1 = Request.newMeRequest(session1, null);
+        Request request2 = Request.newMeRequest(session2, null);
+
+        List<Response> responses = Request.executeBatchAndWait(request1, request2);
+        assertNotNull(responses);
+        assertEquals(2, responses.size());
+
+        GraphUser user1 = responses.get(0).getGraphObjectAs(GraphUser.class);
+        GraphUser user2 = responses.get(1).getGraphObjectAs(GraphUser.class);
+
+        assertNotNull(user1);
+        assertNotNull(user2);
+
+        assertFalse(user1.getId().equals(user2.getId()));
+        assertEquals(session1.getTestUserId(), user1.getId());
+        assertEquals(session2.getTestUserId(), user2.getId());
+    }
+
+    @LargeTest
+    public void testBatchWithValidSessionAndNoSession() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request request1 = new Request(session, "me");
+        Request request2 = new Request(null, "zuck");
+
+        List<Response> responses = Request.executeBatchAndWait(request1, request2);
+        assertNotNull(responses);
+        assertEquals(2, responses.size());
+
+        GraphUser user1 = responses.get(0).getGraphObjectAs(GraphUser.class);
+        GraphUser user2 = responses.get(1).getGraphObjectAs(GraphUser.class);
+
+        assertNotNull(user1);
+        assertNotNull(user2);
+
+        assertFalse(user1.getId().equals(user2.getId()));
+        assertEquals(session.getTestUserId(), user1.getId());
+        assertEquals("4", user2.getId());
+    }
+
+    @LargeTest
+    public void testBatchWithNoSessionAndValidSession() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request request1 = new Request(null, "zuck");
+        Request request2 = new Request(session, "me");
+
+        List<Response> responses = Request.executeBatchAndWait(request1, request2);
+        assertNotNull(responses);
+        assertEquals(2, responses.size());
+
+        GraphUser user1 = responses.get(0).getGraphObjectAs(GraphUser.class);
+        GraphUser user2 = responses.get(1).getGraphObjectAs(GraphUser.class);
+
+        assertNotNull(user1);
+        assertNotNull(user2);
+
+        assertFalse(user1.getId().equals(user2.getId()));
+        assertEquals("4", user1.getId());
+        assertEquals(session.getTestUserId(), user2.getId());
+    }
+
+    @LargeTest
+    public void testBatchWithTwoSessionlessRequestsAndDefaultAppID() {
+        TestSession session = getTestSessionWithSharedUser(null);
+        String appId = session.getApplicationId();
+        Request.setDefaultBatchApplicationId(appId);
+
+        Request request1 = new Request(null, "zuck");
+        Request request2 = new Request(null, "zuck");
+
+        List<Response> responses = Request.executeBatchAndWait(request1, request2);
+        assertNotNull(responses);
+        assertEquals(2, responses.size());
+
+        GraphUser user1 = responses.get(0).getGraphObjectAs(GraphUser.class);
+        GraphUser user2 = responses.get(1).getGraphObjectAs(GraphUser.class);
+
+        assertNotNull(user1);
+        assertNotNull(user2);
+
+        assertEquals("4", user1.getId());
+        assertEquals("4", user2.getId());
+    }
+
+    @LargeTest
+    public void testMixedSuccessAndFailure() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        final int NUM_REQUESTS = 8;
+        Request[] requests = new Request[NUM_REQUESTS];
+        for (int i = 0; i < NUM_REQUESTS; ++i) {
+            boolean shouldSucceed = (i % 2) == 1;
+            requests[i] = new Request(session, shouldSucceed ? "me" : "-1");
+        }
+
+        List<Response> responses = Request.executeBatchAndWait(requests);
+        assertNotNull(responses);
+        assertEquals(NUM_REQUESTS, responses.size());
+
+        for (int i = 0; i < NUM_REQUESTS; ++i) {
+            boolean shouldSucceed = (i % 2) == 1;
+
+            Response response = responses.get(i);
+            assertNotNull(response);
+            if (shouldSucceed) {
+                assertNull(response.getError());
+                assertNotNull(response.getGraphObject());
+            } else {
+                assertNotNull(response.getError());
+                assertNull(response.getGraphObject());
+            }
+        }
+    }
+
+    @LargeTest
+    public void testBatchUploadPhoto() {
+        TestSession session = openTestSessionWithSharedUserAndPermissions(null, "user_photos");
+
+        final int image1Size = 120;
+        final int image2Size = 150;
+
+        Bitmap bitmap1 = createTestBitmap(image1Size);
+        Bitmap bitmap2 = createTestBitmap(image2Size);
+
+        Request uploadRequest1 = Request.newUploadPhotoRequest(session, bitmap1, null);
+        uploadRequest1.setBatchEntryName("uploadRequest1");
+        Request uploadRequest2 = Request.newUploadPhotoRequest(session, bitmap2, null);
+        uploadRequest2.setBatchEntryName("uploadRequest2");
+        Request getRequest1 = new Request(session, "{result=uploadRequest1:$.id}");
+        Request getRequest2 = new Request(session, "{result=uploadRequest2:$.id}");
+
+        List<Response> responses = Request.executeBatchAndWait(uploadRequest1, uploadRequest2, getRequest1, getRequest2);
+        assertNotNull(responses);
+        assertEquals(4, responses.size());
+        assertNoErrors(responses);
+
+        GraphObject retrievedPhoto1 = responses.get(2).getGraphObject();
+        GraphObject retrievedPhoto2 = responses.get(3).getGraphObject();
+        assertNotNull(retrievedPhoto1);
+        assertNotNull(retrievedPhoto2);
+
+        assertEquals(image1Size, retrievedPhoto1.getProperty("width"));
+        assertEquals(image2Size, retrievedPhoto2.getProperty("width"));
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCallbacksAreCalled() {
+        setBatchApplicationIdForTestApp();
+
+        ArrayList<Request> requests = new ArrayList<Request>();
+        final ArrayList<Boolean> calledBack = new ArrayList<Boolean>();
+
+        final int NUM_REQUESTS = 4;
+        for (int i = 0; i < NUM_REQUESTS; ++i) {
+            Request request = new Request(null, "4");
+
+            request.setCallback(new Request.Callback() {
+                @Override
+                public void onCompleted(Response response) {
+                    calledBack.add(true);
+                }
+            });
+
+            requests.add(request);
+        }
+
+        List<Response> responses = Request.executeBatchAndWait(requests);
+        assertNotNull(responses);
+        assertTrue(calledBack.size() == NUM_REQUESTS);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCacheMyFriendsRequest() throws IOException {
+        Response.getResponseCache().clear();
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request request = Request.newMyFriendsRequest(session, null);
+
+        RequestBatch batch = new RequestBatch(request);
+        batch.setCacheKey("MyFriends");
+
+        // Running the request with empty cache should hit the server.
+        List<Response> responses = Request.executeBatchAndWait(batch);
+        assertNotNull(responses);
+        assertEquals(1, responses.size());
+
+        Response response = responses.get(0);
+        assertNotNull(response);
+        assertNull(response.getError());
+        assertTrue(!response.getIsFromCache());
+
+        // Running again should hit the cache.
+        responses = Request.executeBatchAndWait(batch);
+        assertNotNull(responses);
+        assertEquals(1, responses.size());
+
+        response = responses.get(0);
+        assertNotNull(response);
+        assertNull(response.getError());
+        assertTrue(response.getIsFromCache());
+
+        // Forcing roundtrip should hit the server again.
+        batch.setForceRoundTrip(true);
+        responses = Request.executeBatchAndWait(batch);
+        assertNotNull(responses);
+        assertEquals(1, responses.size());
+
+        response = responses.get(0);
+        assertNotNull(response);
+        assertNull(response.getError());
+        assertTrue(!response.getIsFromCache());
+
+        Response.getResponseCache().clear();
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCacheMeAndMyFriendsRequest() throws IOException {
+        Response.getResponseCache().clear();
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request requestMe = Request.newMeRequest(session, null);
+        Request requestMyFriends = Request.newMyFriendsRequest(session, null);
+
+        RequestBatch batch = new RequestBatch(new Request[] { requestMyFriends, requestMe });
+        batch.setCacheKey("MyFriends");
+
+        // Running the request with empty cache should hit the server.
+        List<Response> responses = Request.executeBatchAndWait(batch);
+        assertNotNull(responses);
+        assertEquals(2, responses.size());
+
+        for (Response response : responses) {
+            assertNotNull(response);
+            assertNull(response.getError());
+            assertTrue(!response.getIsFromCache());
+        }
+
+        // Running again should hit the cache.
+        responses = Request.executeBatchAndWait(batch);
+        assertNotNull(responses);
+        assertEquals(2, responses.size());
+
+        for (Response response : responses) {
+            assertNotNull(response);
+            assertNull(response.getError());
+            assertTrue(response.getIsFromCache());
+        }
+
+        // Forcing roundtrip should hit the server again.
+        batch.setForceRoundTrip(true);
+        responses = Request.executeBatchAndWait(batch);
+        assertNotNull(responses);
+        assertEquals(2, responses.size());
+
+        for (Response response : responses) {
+            assertNotNull(response);
+            assertNull(response.getError());
+            assertTrue(!response.getIsFromCache());
+        }
+
+        Response.getResponseCache().clear();
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExplicitDependencyDefaultsToOmitFirstResponse() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request requestMe = Request.newMeRequest(session, null);
+        requestMe.setBatchEntryName("me_request");
+
+        Request requestMyFriends = Request.newMyFriendsRequest(session, null);
+        requestMyFriends.setBatchEntryDependsOn("me_request");
+
+        List<Response> responses = Request.executeBatchAndWait(requestMe, requestMyFriends);
+
+        Response meResponse = responses.get(0);
+        Response myFriendsResponse = responses.get(1);
+
+        assertNull(meResponse.getGraphObject());
+        assertNotNull(myFriendsResponse.getGraphObject());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExplicitDependencyCanIncludeFirstResponse() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request requestMe = Request.newMeRequest(session, null);
+        requestMe.setBatchEntryName("me_request");
+        requestMe.setBatchEntryOmitResultOnSuccess(false);
+
+        Request requestMyFriends = Request.newMyFriendsRequest(session, null);
+        requestMyFriends.setBatchEntryDependsOn("me_request");
+
+        List<Response> responses = Request.executeBatchAndWait(requestMe, requestMyFriends);
+
+        Response meResponse = responses.get(0);
+        Response myFriendsResponse = responses.get(1);
+
+        assertNotNull(meResponse.getGraphObject());
+        assertNotNull(myFriendsResponse.getGraphObject());
+    }
+}
diff --git a/facebook/tests/src/com/facebook/FacebookActivityTestCase.java b/facebook/tests/src/com/facebook/FacebookActivityTestCase.java
new file mode 100644
index 000000000..eba3175b1
--- /dev/null
+++ b/facebook/tests/src/com/facebook/FacebookActivityTestCase.java
@@ -0,0 +1,601 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.app.Activity;
+import android.content.res.AssetManager;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.os.Bundle;
+import android.os.ConditionVariable;
+import android.os.Handler;
+import android.test.ActivityInstrumentationTestCase2;
+import android.util.Log;
+import junit.framework.AssertionFailedError;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.json.JSONTokener;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+public class FacebookActivityTestCase<T extends Activity> extends ActivityInstrumentationTestCase2<T> {
+    private static final String TAG = FacebookActivityTestCase.class.getSimpleName();
+
+    private static String applicationId;
+    private static String applicationSecret;
+
+    public final static String SECOND_TEST_USER_TAG = "Second";
+    public final static String THIRD_TEST_USER_TAG = "Third";
+
+    private TestBlocker testBlocker;
+
+    protected synchronized TestBlocker getTestBlocker() {
+        if (testBlocker == null) {
+            testBlocker = TestBlocker.createTestBlocker();
+        }
+        return testBlocker;
+    }
+
+    public FacebookActivityTestCase(Class<T> activityClass) {
+        super("", activityClass);
+    }
+
+    // Returns an un-opened TestSession
+    protected TestSession getTestSessionWithSharedUser() {
+        return getTestSessionWithSharedUser(null);
+    }
+
+    // Returns an un-opened TestSession
+    protected TestSession getTestSessionWithSharedUser(String sessionUniqueUserTag) {
+        return getTestSessionWithSharedUserAndPermissions(sessionUniqueUserTag, (String[]) null);
+    }
+
+    protected TestSession getTestSessionWithSharedUserAndPermissions(String sessionUniqueUserTag,
+            String... permissions) {
+        List<String> permissionsList = (permissions != null) ? Arrays.asList(permissions) : null;
+        return TestSession.createSessionWithSharedUser(getActivity(), permissionsList, sessionUniqueUserTag);
+    }
+
+    // Returns an un-opened TestSession
+    protected TestSession getTestSessionWithPrivateUser(TestBlocker testBlocker) {
+        return TestSession.createSessionWithPrivateUser(getActivity(), null);
+    }
+
+    protected TestSession openTestSessionWithSharedUser(final TestBlocker blocker) {
+        return openTestSessionWithSharedUser(blocker, null);
+    }
+
+    protected TestSession openTestSessionWithSharedUser(final TestBlocker blocker, String sessionUniqueUserTag) {
+        TestSession session = getTestSessionWithSharedUser();
+        openSession(getActivity(), session, blocker);
+        return session;
+    }
+
+    protected TestSession openTestSessionWithSharedUser() {
+        return openTestSessionWithSharedUser((String) null);
+    }
+
+    protected TestSession openTestSessionWithSharedUser(String sessionUniqueUserTag) {
+        return openTestSessionWithSharedUserAndPermissions(sessionUniqueUserTag, (String[]) null);
+    }
+
+    protected TestSession openTestSessionWithSharedUserAndPermissions(String sessionUniqueUserTag,
+            String... permissions) {
+        final TestBlocker blocker = getTestBlocker();
+        TestSession session = getTestSessionWithSharedUserAndPermissions(sessionUniqueUserTag, permissions);
+        openSession(getActivity(), session, blocker);
+        return session;
+    }
+
+    // Turns exceptions from the TestBlocker into JUnit assertions
+    protected void waitAndAssertSuccess(TestBlocker testBlocker, int numSignals) {
+        try {
+            testBlocker.waitForSignalsAndAssertSuccess(numSignals);
+        } catch (AssertionFailedError e) {
+            throw e;
+        } catch (Exception e) {
+            fail("Got exception: " + e.getMessage());
+        }
+    }
+
+    protected void waitAndAssertSuccess(int numSignals) {
+        waitAndAssertSuccess(getTestBlocker(), numSignals);
+    }
+
+    protected void waitAndAssertSuccessOrRethrow(int numSignals) throws Exception {
+        getTestBlocker().waitForSignalsAndAssertSuccess(numSignals);
+    }
+
+    protected void runAndBlockOnUiThread(final int expectedSignals, final Runnable runnable) throws Throwable {
+        final TestBlocker blocker = getTestBlocker();
+        runTestOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                runnable.run();
+                blocker.signal();
+            }
+        });
+        // We wait for the operation to complete; wait for as many other signals as we expect.
+        blocker.waitForSignals(1 + expectedSignals);
+        // Wait for the UI thread to become idle so any UI updates the runnable triggered have a chance
+        // to finish before we return.
+        getInstrumentation().waitForIdleSync();
+    }
+
+    protected synchronized void readApplicationIdAndSecret() {
+        synchronized (FacebookTestCase.class) {
+            if (applicationId != null && applicationSecret != null) {
+                return;
+            }
+
+            AssetManager assets = getInstrumentation().getContext().getResources().getAssets();
+            InputStream stream = null;
+            final String errorMessage = "could not read applicationId and applicationSecret from config.json; ensure "
+                    + "you have run 'configure_unit_tests.sh'. Error: ";
+            try {
+                stream = assets.open("config.json");
+                String string = Utility.readStreamToString(stream);
+
+                JSONTokener tokener = new JSONTokener(string);
+                Object obj = tokener.nextValue();
+                if (!(obj instanceof JSONObject)) {
+                    fail(errorMessage + "could not deserialize a JSONObject");
+                }
+                JSONObject jsonObject = (JSONObject) obj;
+
+                applicationId = jsonObject.optString("applicationId");
+                applicationSecret = jsonObject.optString("applicationSecret");
+
+                if (Utility.isNullOrEmpty(applicationId) || Utility.isNullOrEmpty(applicationSecret)) {
+                    fail(errorMessage + "one or both config values are missing");
+                }
+
+                String machineUniqueUserTag = jsonObject.optString("machineUniqueUserTag");
+
+                TestSession.setTestApplicationId(applicationId);
+                TestSession.setTestApplicationSecret(applicationSecret);
+                TestSession.setMachineUniqueUserTag(machineUniqueUserTag);
+            } catch (IOException e) {
+                fail(errorMessage + e.toString());
+            } catch (JSONException e) {
+                fail(errorMessage + e.toString());
+            } finally {
+                if (stream != null) {
+                    try {
+                        stream.close();
+                    } catch (IOException e) {
+                        fail(errorMessage + e.toString());
+                    }
+                }
+            }
+        }
+    }
+
+    protected void openSession(Activity activity, TestSession session) {
+        final TestBlocker blocker = getTestBlocker();
+        openSession(activity, session, blocker);
+    }
+
+    protected void openSession(Activity activity, TestSession session, final TestBlocker blocker) {
+        Session.OpenRequest openRequest = new Session.OpenRequest(activity).
+                setCallback(new Session.StatusCallback() {
+                    boolean signaled = false;
+
+                    @Override
+                    public void call(Session session, SessionState state, Exception exception) {
+                        if (exception != null) {
+                            Log.w(TAG,
+                                    "openSession: received an error opening session: " + exception.toString());
+                        }
+                        assertTrue(exception == null);
+                        // Only signal once, or we might screw up the count on the blocker.
+                        if (!signaled) {
+                            blocker.signal();
+                            signaled = true;
+                        }
+                    }
+                });
+
+        session.openForRead(openRequest);
+        waitAndAssertSuccess(blocker, 1);
+    }
+
+    protected void setUp() throws Exception {
+        super.setUp();
+
+        // Make sure we have read application ID and secret.
+        readApplicationIdAndSecret();
+
+        // These are useful for debugging unit test failures.
+        Settings.addLoggingBehavior(LoggingBehaviors.REQUESTS);
+        Settings.addLoggingBehavior(LoggingBehaviors.INCLUDE_ACCESS_TOKENS);
+
+        // We want the UI thread to be in StrictMode to catch any violations.
+        turnOnStrictModeForUiThread();
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+
+        if (testBlocker != null) {
+            testBlocker.quit();
+        }
+    }
+
+    interface GraphObjectPostResult extends GraphObject {
+        String getId();
+    }
+
+    protected GraphObject getAndAssert(Session session, String id) {
+        Request request = new Request(session, id);
+        Response response = request.executeAndWait();
+        assertNotNull(response);
+
+        Exception exception = response.getError();
+        assertNull(exception);
+
+        GraphObject result = response.getGraphObject();
+        assertNotNull(result);
+
+        return result;
+    }
+
+    protected GraphObject postGetAndAssert(Session session, String path, GraphObject graphObject) {
+        Request request = Request.newPostRequest(session, path, graphObject, null);
+        Response response = request.executeAndWait();
+        assertNotNull(response);
+
+        Exception exception = response.getError();
+        assertNull(exception);
+
+        GraphObjectPostResult result = response.getGraphObjectAs(GraphObjectPostResult.class);
+        assertNotNull(result);
+        assertNotNull(result.getId());
+
+        return getAndAssert(session, result.getId());
+    }
+
+    protected void setBatchApplicationIdForTestApp() {
+        String appId = TestSession.getTestApplicationId();
+        Request.setDefaultBatchApplicationId(appId);
+    }
+
+    protected <U extends GraphObject> U batchCreateAndGet(Session session, String graphPath, GraphObject graphObject,
+            String fields, Class<U> resultClass) {
+        Request create = Request.newPostRequest(session, graphPath, graphObject, new ExpectSuccessCallback());
+        create.setBatchEntryName("create");
+        Request get = Request.newGraphPathRequest(session, "{result=create:$.id}", new ExpectSuccessCallback());
+        if (fields != null) {
+            Bundle parameters = new Bundle();
+            parameters.putString("fields", fields);
+            get.setParameters(parameters);
+        }
+
+        return batchPostAndGet(create, get, resultClass);
+    }
+
+    protected <U extends GraphObject> U batchUpdateAndGet(Session session, String graphPath, GraphObject graphObject,
+            String fields, Class<U> resultClass) {
+        Request update = Request.newPostRequest(session, graphPath, graphObject, new ExpectSuccessCallback());
+        Request get = Request.newGraphPathRequest(session, graphPath, new ExpectSuccessCallback());
+        if (fields != null) {
+            Bundle parameters = new Bundle();
+            parameters.putString("fields", fields);
+            get.setParameters(parameters);
+        }
+
+        return batchPostAndGet(update, get, resultClass);
+    }
+
+    protected <U extends GraphObject> U batchPostAndGet(Request post, Request get, Class<U> resultClass) {
+        List<Response> responses = Request.executeBatchAndWait(post, get);
+        assertEquals(2, responses.size());
+
+        U resultGraphObject = responses.get(1).getGraphObjectAs(resultClass);
+        assertNotNull(resultGraphObject);
+        return resultGraphObject;
+    }
+
+    protected GraphObject createStatusUpdate() {
+        GraphObject statusUpdate = GraphObjectWrapper.createGraphObject();
+        String message = String.format(
+                "Check out my awesome new status update posted at: %s. Some chars for you: +\"[]:,", new Date());
+        statusUpdate.setProperty("message", message);
+        return statusUpdate;
+    }
+
+    protected Bitmap createTestBitmap(int size) {
+        Bitmap image = Bitmap.createBitmap(size, size, Bitmap.Config.RGB_565);
+        image.eraseColor(Color.BLUE);
+        return image;
+    }
+
+    protected void issueFriendRequest(TestSession session, String targetUserId) {
+        String graphPath = "me/friends/" + targetUserId;
+        Request request = Request.newPostRequest(session, graphPath, null, null);
+        Response response = request.executeAndWait();
+        // We will get a 400 error if the users are already friends.
+        FacebookException error = response.getError();
+        assertTrue(error == null ||
+                (error instanceof FacebookServiceErrorException && ((FacebookServiceErrorException) error)
+                        .getHttpResponseCode() == 400));
+    }
+
+    protected void makeTestUsersFriends(TestSession session1, TestSession session2) {
+        issueFriendRequest(session1, session2.getTestUserId());
+        issueFriendRequest(session2, session1.getTestUserId());
+    }
+
+    protected void assertNoErrors(List<Response> responses) {
+        for (int i = 0; i < responses.size(); ++i) {
+            Response response = responses.get(i);
+            assertNotNull(response);
+            assertNull(response.getError());
+        }
+    }
+
+    protected void runOnBlockerThread(final Runnable runnable, boolean waitForCompletion) {
+        Runnable runnableToPost = runnable;
+        final ConditionVariable condition = waitForCompletion ? new ConditionVariable(!waitForCompletion) : null;
+
+        if (waitForCompletion) {
+            runnableToPost = new Runnable() {
+                @Override
+                public void run() {
+                    runnable.run();
+                    condition.open();
+                }
+            };
+        }
+
+        TestBlocker blocker = getTestBlocker();
+        Handler handler = blocker.getHandler();
+        handler.post(runnableToPost);
+
+        if (waitForCompletion) {
+            boolean success = condition.block(10000);
+            assertTrue(success);
+        }
+    }
+
+    protected void closeBlockerAndAssertSuccess() {
+        TestBlocker blocker = getTestBlocker();
+        testBlocker = null;
+
+        blocker.quit();
+
+        boolean joined = false;
+        while (!joined) {
+            try {
+                blocker.join();
+                joined = true;
+            } catch (InterruptedException e) {
+            }
+        }
+
+        try {
+            blocker.assertSuccess();
+        } catch (Exception e) {
+            fail(e.toString());
+        }
+    }
+
+    protected TestRequestAsyncTask createAsyncTaskOnUiThread(final Request... requests) throws Throwable {
+        final ArrayList<TestRequestAsyncTask> result = new ArrayList<TestRequestAsyncTask>();
+        runTestOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                result.add(new TestRequestAsyncTask(requests));
+            }
+        });
+        return result.isEmpty() ? null : result.get(0);
+    }
+
+
+    /*
+     * Classes and helpers related to asynchronous requests.
+     */
+
+    // A subclass of RequestAsyncTask that knows how to interact with TestBlocker to ensure that tests can wait
+    // on and assert success of async tasks.
+    protected class TestRequestAsyncTask extends RequestAsyncTask {
+        private final TestBlocker blocker = FacebookActivityTestCase.this.getTestBlocker();
+
+        public TestRequestAsyncTask(Request... requests) {
+            super(requests);
+        }
+
+        public TestRequestAsyncTask(List<Request> requests) {
+            super(requests);
+        }
+
+        public TestRequestAsyncTask(RequestBatch requests) {
+            super(requests);
+        }
+
+        public TestRequestAsyncTask(HttpURLConnection connection, Request... requests) {
+            super(connection, requests);
+        }
+
+        public TestRequestAsyncTask(HttpURLConnection connection, List<Request> requests) {
+            super(connection, requests);
+        }
+
+        public TestRequestAsyncTask(HttpURLConnection connection, RequestBatch requests) {
+            super(connection, requests);
+        }
+
+        public final TestBlocker getBlocker() {
+            return blocker;
+        }
+
+        public final Exception getThrowable() {
+            return getException();
+        }
+
+        protected void onPostExecute(List<Response> result) {
+            try {
+                super.onPostExecute(result);
+
+                if (getException() != null) {
+                    blocker.setException(getException());
+                }
+            } finally {
+                Log.d("TestRequestAsyncTask", "signaling blocker");
+                blocker.signal();
+            }
+        }
+
+        // In order to be able to block and accumulate exceptions, we want to ensure the async task is really
+        // being started on the blocker's thread, rather than the test's thread. Use this instead of calling
+        // execute directly in unit tests.
+        public void executeOnBlockerThread() {
+            ensureAsyncTaskLoaded();
+
+            Runnable runnable = new Runnable() {
+                public void run() {
+                    execute();
+                }
+            };
+            Handler handler = new Handler(blocker.getLooper());
+            handler.post(runnable);
+        }
+
+        private void ensureAsyncTaskLoaded() {
+            // Work around this issue on earlier frameworks: http://stackoverflow.com/a/7818839/782044
+            try {
+                runAndBlockOnUiThread(0, new Runnable() {
+                    @Override
+                    public void run() {
+                        try {
+                            Class.forName("android.os.AsyncTask");
+                        } catch (ClassNotFoundException e) {
+                        }
+                    }
+                });
+            } catch (Throwable throwable) {
+            }
+        }
+    }
+
+    // Provides an implementation of Request.Callback that will assert either success (no error) or failure (error)
+    // of a request, and allow derived classes to perform additional asserts.
+    protected class TestCallback implements Request.Callback {
+        private final TestBlocker blocker;
+        private final boolean expectSuccess;
+
+        public TestCallback(TestBlocker blocker, boolean expectSuccess) {
+            this.blocker = blocker;
+            this.expectSuccess = expectSuccess;
+        }
+
+        public TestCallback(boolean expectSuccess) {
+            this(FacebookActivityTestCase.this.getTestBlocker(), expectSuccess);
+        }
+
+        @Override
+        public void onCompleted(Response response) {
+            try {
+                // We expect to be called on the right thread.
+                if (Thread.currentThread() != blocker) {
+                    throw new FacebookException("Invalid thread " + Thread.currentThread().getId()
+                            + "; expected to be called on thread " + blocker.getId());
+                }
+
+                // We expect either success or failure.
+                if (expectSuccess && response.getError() != null) {
+                    throw response.getError();
+                } else if (!expectSuccess && response.getError() == null) {
+                    throw new FacebookException("Expected failure case, received no error");
+                }
+
+                // Some tests may want more fine-grained control and assert additional conditions.
+                performAsserts(response);
+            } catch (Exception e) {
+                blocker.setException(e);
+            } finally {
+                // Tell anyone waiting on us that this callback was called.
+                blocker.signal();
+            }
+        }
+
+        protected void performAsserts(Response response) {
+        }
+    }
+
+    // A callback that will assert if the request resulted in an error.
+    protected class ExpectSuccessCallback extends TestCallback {
+        public ExpectSuccessCallback() {
+            super(true);
+        }
+    }
+
+    // A callback that will assert if the request did NOT result in an error.
+    protected class ExpectFailureCallback extends TestCallback {
+        public ExpectFailureCallback() {
+            super(false);
+        }
+    }
+
+    private AtomicBoolean strictModeOnForUiThread = new AtomicBoolean();
+    protected void turnOnStrictModeForUiThread() {
+        // We only ever need to do this once. If the boolean is true, we know that the next runnable
+        // posted to the UI thread will have strict mode on.
+        if (strictModeOnForUiThread.get() == false) {
+            try {
+                runTestOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        // Double-check whether we really need to still do this on the UI thread.
+                        if (strictModeOnForUiThread.compareAndSet(false, true)) {
+                            turnOnStrictModeForThisThread();
+                        }
+                    }
+                });
+            } catch (Throwable throwable) {
+            }
+        }
+    }
+
+    protected void turnOnStrictModeForThisThread() {
+        // We use reflection, because Instrumentation will complain about any references to StrictMode in API versions < 9
+        // when attempting to run the unit tests. No particular effort has been made to make this efficient, since we
+        // expect to call it just once.
+        try {
+            ClassLoader loader = Thread.currentThread().getContextClassLoader();
+            Class<?> strictModeClass = Class.forName("android.os.StrictMode", true, loader);
+            Class<?> threadPolicyClass = Class.forName("android.os.StrictMode$ThreadPolicy", true, loader);
+            Class<?> threadPolicyBuilderClass = Class.forName("android.os.StrictMode$ThreadPolicy$Builder", true,
+                    loader);
+
+            Object threadPolicyBuilder = threadPolicyBuilderClass.getConstructor().newInstance();
+            threadPolicyBuilder = threadPolicyBuilderClass.getMethod("detectAll").invoke(threadPolicyBuilder);
+            threadPolicyBuilder = threadPolicyBuilderClass.getMethod("penaltyDeath").invoke(threadPolicyBuilder);
+
+            Object threadPolicy = threadPolicyBuilderClass.getMethod("build").invoke(threadPolicyBuilder);
+            strictModeClass.getMethod("setThreadPolicy", threadPolicyClass).invoke(strictModeClass, threadPolicy);
+        } catch (Exception ex) {
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/FacebookTestCase.java b/facebook/tests/src/com/facebook/FacebookTestCase.java
new file mode 100644
index 000000000..9900de8a3
--- /dev/null
+++ b/facebook/tests/src/com/facebook/FacebookTestCase.java
@@ -0,0 +1,31 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.app.Activity;
+
+public class FacebookTestCase extends FacebookActivityTestCase<FacebookTestCase.FacebookTestActivity> {
+    public FacebookTestCase() {
+        super(FacebookTestCase.FacebookTestActivity.class);
+        Settings.addLoggingBehavior(LoggingBehaviors.REQUESTS);
+        Settings.addLoggingBehavior(LoggingBehaviors.INCLUDE_RAW_RESPONSES);
+    }
+
+    public static class FacebookTestActivity extends Activity {
+    }
+}
+
diff --git a/facebook/tests/src/com/facebook/FileLruCacheTests.java b/facebook/tests/src/com/facebook/FileLruCacheTests.java
new file mode 100644
index 000000000..90ccb2e59
--- /dev/null
+++ b/facebook/tests/src/com/facebook/FileLruCacheTests.java
@@ -0,0 +1,359 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.Random;
+
+public final class FileLruCacheTests extends AndroidTestCase {
+    private static final Random random = new Random();
+
+    @SmallTest @MediumTest @LargeTest
+    public void testCacheOutputStream() throws IOException {
+        int dataSize = 1024;
+        byte[] data = generateBytes(dataSize);
+        String key = "a";
+
+        // Limit to 2x to allow for extra header data
+        FileLruCache cache = new FileLruCache(getContext(), "testCacheOutputStream", limitCacheSize(2*dataSize));
+
+        put(cache, key, data);
+        checkValue(cache, key, data);
+        cache.clear();
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testCacheInputStream() throws IOException {
+        int dataSize = 1024;
+        byte[] data = generateBytes(dataSize);
+        String key = "a";
+        InputStream stream = new ByteArrayInputStream(data);
+
+        // Limit to 2x to allow for extra header data
+        FileLruCache cache = new FileLruCache(getContext(), "testCacheInputStream", limitCacheSize(2*dataSize));
+        cache.clear();
+
+        InputStream wrapped = cache.interceptAndPut(key, stream);
+        consumeAndClose(wrapped);
+        checkValue(cache, key, data);
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testCacheClear() throws IOException {
+        int dataSize = 1024;
+        byte[] data = generateBytes(dataSize);
+        String key = "a";
+
+        // Limit to 2x to allow for extra header data
+        FileLruCache cache = new FileLruCache(getContext(), "testCacheClear", limitCacheSize(2*dataSize));
+        cache.clear();
+
+        put(cache, key, data);
+        checkValue(cache, key, data);
+
+        cache.clear();
+        assertEquals(false, hasValue(cache, key));
+        assertEquals(0, cache.sizeInBytes());
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testSizeInBytes() throws IOException {
+        int count = 17;
+        int dataSize = 53;
+        int cacheSize = count * dataSize;
+        byte[] data = generateBytes(dataSize);
+
+        // Limit to 2x to allow for extra header data
+        FileLruCache cache = new FileLruCache(getContext(), "testSizeInBytes", limitCacheSize(2*cacheSize));
+        cache.clear();
+
+        for (int i = 0; i < count; i++) {
+            put(cache, i, data);
+
+            // The size reported by sizeInBytes includes a version/size token as well
+            // as a JSON blob that records the name.  Verify that the cache size is larger
+            // than the data content but not more than twice as large.  This guarantees
+            // that sizeInBytes is doing at least approximately the right thing.
+            int totalDataSize = (i + 1) * dataSize;
+            assertTrue(cache.sizeInBytes() > totalDataSize);
+            assertTrue(cache.sizeInBytes() < 2 * totalDataSize);
+        }
+        for (int i = 0; i < count; i++) {
+            String key = Integer.valueOf(i).toString();
+            checkValue(cache, key, data);
+        }
+    }
+
+    @MediumTest @LargeTest
+    public void testCacheSizeLimit() throws IOException {
+        int count = 64;
+        int dataSize = 32;
+        int cacheSize = count * dataSize / 2;
+        byte[] data = generateBytes(dataSize);
+
+        // Here we do not set the limit to 2x to make sure we hit the limit well before we have
+        // added all the data.
+        FileLruCache cache = new FileLruCache(getContext(), "testCacheSizeLimit", limitCacheSize(cacheSize));
+        cache.clear();
+
+        for (int i = 0; i < count; i++) {
+            put(cache, i, data);
+
+            // See comment in testSizeInBytes for why this is not an exact calculation.
+            //
+            // This changes verification such that the final cache size lands somewhere
+            // between half and full quota.
+            int totalDataSize = (i + 1) * dataSize;
+            assertTrue(cache.sizeInBytes() > Math.min(totalDataSize, cacheSize/2));
+            assertTrue(cache.sizeInBytes() < Math.min(2 * totalDataSize, cacheSize));
+        }
+
+        // Verify that some keys exist and others do not
+        boolean hasValueExists = false;
+        boolean hasNoValueExists = false;
+
+        for (int i = 0; i < count; i++) {
+            String key = Integer.valueOf(i).toString();
+            if (hasValue(cache, key)) {
+                hasValueExists = true;
+                checkValue(cache, key, data);
+            } else {
+                hasNoValueExists = true;
+            }
+        }
+
+        assertEquals(true, hasValueExists);
+        assertEquals(true, hasNoValueExists);
+    }
+
+    @MediumTest @LargeTest
+    public void testCacheCountLimit() throws IOException {
+        int count = 64;
+        int dataSize = 32;
+        int cacheCount = count / 2;
+        byte[] data = generateBytes(dataSize);
+
+        // Here we only limit by count, and we allow half of the entries.
+        FileLruCache cache = new FileLruCache(getContext(), "testCacheCountLimit", limitCacheCount(cacheCount));
+        cache.clear();
+
+        for (int i = 0; i < count; i++) {
+            put(cache, i, data);
+        }
+
+        // Verify that some keys exist and others do not
+        boolean hasValueExists = false;
+        boolean hasNoValueExists = false;
+
+        for (int i = 0; i < count; i++) {
+            if (hasValue(cache, i)) {
+                hasValueExists = true;
+                checkValue(cache, i, data);
+            } else {
+                hasNoValueExists = true;
+            }
+        }
+
+        assertEquals(true, hasValueExists);
+        assertEquals(true, hasNoValueExists);
+    }
+
+    @LargeTest
+    public void testCacheLru() throws IOException, InterruptedException {
+        int keepCount = 10;
+        int otherCount = 5;
+        int dataSize = 64;
+        byte[] data = generateBytes(dataSize);
+
+        // Limit by count, and allow all the keep keys plus one other.
+        FileLruCache cache = new FileLruCache(getContext(), "testCacheLru", limitCacheCount(keepCount + 1));
+        cache.clear();
+
+        for (int i = 0; i < keepCount; i++) {
+            put(cache, i, data);
+        }
+
+        // Make sure operations are separated by enough time that the file timestamps are all different.
+        // On the test device, it looks like lastModified has 1-second resolution, so we have to wait at
+        // least a second to guarantee that updated timestamps will come later.
+        Thread.sleep(1000);
+        for (int i = 0; i < otherCount; i++) {
+            put(cache, keepCount + i, data);
+            Thread.sleep(1000);
+
+            // By verifying all the keep keys, they should be LRU and survive while the others do not.
+            for (int keepIndex = 0; keepIndex < keepCount; keepIndex++) {
+                checkValue(cache, keepIndex, data);
+            }
+            Thread.sleep(1000);
+        }
+
+        // All but the last other key should have been pushed out
+        for (int i = 0; i < (otherCount - 1); i++) {
+            String key = Integer.valueOf(keepCount + i).toString();
+            assertEquals(false, hasValue(cache, key));
+        }
+    }
+
+    @LargeTest
+    public void testConcurrentWritesToSameKey() throws IOException, InterruptedException {
+        final int count = 5;
+        final int dataSize = 81;
+        final int threadCount = 31;
+        final int iterationCount = 10;
+        final byte[] data = generateBytes(dataSize);
+
+        final FileLruCache cache = new FileLruCache(
+                getContext(), "testConcurrentWritesToSameKey", limitCacheCount(count+1));
+        cache.clear();
+
+        Runnable run = new Runnable() {
+            @Override
+            public void run() {
+                for (int iterations = 0; iterations < iterationCount; iterations++) {
+                    for (int i = 0; i < count; i++) {
+                        put(cache, i, data);
+                    }
+                }
+            }
+        };
+
+        // Create a bunch of threads to write a set of keys repeatedly
+        Thread[] threads = new Thread[threadCount];
+        for (int i = 0; i < threads.length; i++) {
+            threads[i] = new Thread(run);
+        }
+
+        for (Thread thread : threads) {
+            thread.start();
+        }
+
+        for (Thread thread : threads) {
+            thread.join(10 * 1000, 0);
+        }
+
+        // Verify that the file state ended up consistent in the end
+        for (int i = 0; i < count; i++) {
+            checkValue(cache, i, data);
+        }
+    }
+
+    byte[] generateBytes(int n) {
+        byte[] bytes = new byte[n];
+        random.nextBytes(bytes);
+        return bytes;
+    }
+
+    FileLruCache.Limits limitCacheSize(int n) {
+        FileLruCache.Limits limits = new FileLruCache.Limits();
+        limits.setByteCount(n);
+        return limits;
+    }
+
+    FileLruCache.Limits limitCacheCount(int n) {
+        FileLruCache.Limits limits = new FileLruCache.Limits();
+        limits.setFileCount(n);
+        return limits;
+    }
+
+    void put(FileLruCache cache, int i, byte[] data) {
+        put(cache, Integer.valueOf(i).toString(), data);
+    }
+
+    void put(FileLruCache cache, String key, byte[] data) {
+        try {
+            OutputStream stream = cache.openPutStream(key);
+            assertNotNull(stream);
+
+            stream.write(data);
+            stream.close();
+        } catch (IOException e) {
+            // Fail test and print Exception
+            assertNull(e);
+        }
+    }
+
+    void checkValue(FileLruCache cache, int i, byte[] expected) {
+        checkValue(cache, Integer.valueOf(i).toString(), expected);
+    }
+
+    void checkValue(FileLruCache cache, String key, byte[] expected) {
+        try {
+            InputStream stream = cache.get(key);
+            assertNotNull(stream);
+
+            checkInputStream(expected, stream);
+            stream.close();
+        } catch (IOException e) {
+            // Fail test and print Exception
+            assertNull(e);
+        }
+    }
+
+    boolean hasValue(FileLruCache cache, int i) {
+        return hasValue(cache, Integer.valueOf(i).toString());
+    }
+
+    boolean hasValue(FileLruCache cache, String key) {
+        InputStream stream = null;
+
+        try {
+            stream = cache.get(key);
+        } catch (IOException e) {
+            // Fail test and print Exception
+            assertNull(e);
+        }
+
+        return stream != null;
+    }
+
+    void checkInputStream(byte[] expected, InputStream actual) {
+        try {
+            for (int i = 0; i < expected.length; i++) {
+                int b = actual.read();
+                assertEquals(((int)expected[i]) & 0xff, b);
+            }
+
+            int eof = actual.read();
+            assertEquals(-1, eof);
+        } catch (IOException e) {
+            // Fail test and print Exception
+            assertNull(e);
+        }
+    }
+
+    void consumeAndClose(InputStream stream) {
+        try {
+            byte[] buffer = new byte[1024];
+            while (stream.read(buffer) > -1) {
+                // these bytes intentionally ignored
+            }
+            stream.close();
+        } catch (IOException e) {
+            // Fail test and print Exception
+            assertNull(e);
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/FragmentTestCase.java b/facebook/tests/src/com/facebook/FragmentTestCase.java
new file mode 100644
index 000000000..db974969a
--- /dev/null
+++ b/facebook/tests/src/com/facebook/FragmentTestCase.java
@@ -0,0 +1,81 @@
+package com.facebook;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+import android.widget.LinearLayout;
+
+public class FragmentTestCase<T extends FragmentTestCase.TestFragmentActivity<?>> extends FacebookActivityTestCase<T> {
+    public FragmentTestCase(Class<T> activityClass) {
+        super(activityClass);
+    }
+
+    protected T getTestActivity() {
+        return (T) getActivity();
+    }
+
+    public static class TestFragmentActivity<T extends Fragment> extends FragmentActivity {
+        public static final int FRAGMENT_ID = 0xFACE;
+
+        private Class<T> fragmentClass;
+        private int fragmentId;
+
+        protected TestFragmentActivity(Class<T> fragmentClass) {
+            this.fragmentClass = fragmentClass;
+        }
+
+        @Override
+        protected void onCreate(Bundle savedInstanceState) {
+            super.onCreate(savedInstanceState);
+            if (getAutoCreateUI()) {
+                setContentToFragment(null);
+            }
+        }
+
+        protected boolean getAutoCreateUI() {
+            return true;
+        }
+
+        void setContentToFragment(T fragment) {
+            if (fragment == null) {
+                fragment = createFragment();
+            }
+
+            LinearLayout layout = new LinearLayout(this);
+            layout.setOrientation(LinearLayout.VERTICAL);
+            layout.setLayoutParams(new LinearLayout.LayoutParams(LinearLayout.LayoutParams.FILL_PARENT,
+                    LinearLayout.LayoutParams.FILL_PARENT));
+            layout.setId(FRAGMENT_ID);
+
+            getSupportFragmentManager().beginTransaction()
+                    .add(FRAGMENT_ID, fragment)
+                    .commit();
+
+            fragmentId = FRAGMENT_ID;
+
+            setContentView(layout);
+        }
+
+        void setContentToLayout(int i, int fragmentId) {
+            this.fragmentId = fragmentId;
+            setContentView(i);
+        }
+
+        T createFragment() {
+            try {
+                return fragmentClass.newInstance();
+            } catch (IllegalAccessException e) {
+                fail("could not create fragment");
+            } catch (InstantiationException e) {
+                fail("could not create fragment");
+            }
+            return null;
+        }
+
+        T getFragment() {
+            @SuppressWarnings("unchecked")
+            T fragment = (T) getSupportFragmentManager().findFragmentById(fragmentId);
+            return fragment;
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/FriendPickerFragmentTests.java b/facebook/tests/src/com/facebook/FriendPickerFragmentTests.java
new file mode 100644
index 000000000..5141857e8
--- /dev/null
+++ b/facebook/tests/src/com/facebook/FriendPickerFragmentTests.java
@@ -0,0 +1,173 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.os.Bundle;
+import android.test.TouchUtils;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.view.View;
+import android.widget.CheckBox;
+import android.widget.ListView;
+import com.facebook.sdk.tests.R;
+
+import java.util.Arrays;
+import java.util.Collection;
+
+public class FriendPickerFragmentTests extends FragmentTestCase<FriendPickerFragmentTests.TestActivity> {
+    public FriendPickerFragmentTests() {
+        super(TestActivity.class);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCanSetParametersProgrammatically() throws Throwable {
+        TestActivity activity = getActivity();
+        assertNotNull(activity);
+
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                Bundle bundle = new Bundle();
+                // We deliberately set these to non-defaults to ensure they are set correctly.
+                bundle.putString(FriendPickerFragment.USER_ID_BUNDLE_KEY, "4");
+                bundle.putBoolean(FriendPickerFragment.MULTI_SELECT_BUNDLE_KEY, false);
+                bundle.putBoolean(FriendPickerFragment.SHOW_PICTURES_BUNDLE_KEY, false);
+                bundle.putString(FriendPickerFragment.EXTRA_FIELDS_BUNDLE_KEY, "middle_name,link");
+                FriendPickerFragment fragment = new FriendPickerFragment(bundle);
+                getActivity().setContentToFragment(fragment);
+            }
+        });
+
+        // We don't just test the fragment we created directly above, because we want it to go through the
+        // activity lifecycle and ensure the settings are still correct.
+        final FriendPickerFragment fragment = activity.getFragment();
+        assertNotNull(fragment);
+
+        assertEquals("4", fragment.getUserId());
+        assertEquals(false, fragment.getMultiSelect());
+        assertEquals(false, fragment.getShowPictures());
+        Collection<String> extraFields = fragment.getExtraFields();
+        assertTrue(extraFields.contains("middle_name"));
+        assertTrue(extraFields.contains("link"));
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCanSetParametersViaLayout() throws Throwable {
+        TestActivity activity = getActivity();
+        assertNotNull(activity);
+
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                getActivity().setContentToLayout(R.layout.friend_picker_test_layout_1, R.id.friend_picker_fragment);
+            }
+        });
+
+        final FriendPickerFragment fragment = activity.getFragment();
+        assertNotNull(fragment);
+
+        assertEquals(false, fragment.getShowPictures());
+        assertEquals(false, fragment.getMultiSelect());
+        Collection<String> extraFields = fragment.getExtraFields();
+        assertTrue(extraFields.contains("middle_name"));
+        assertTrue(extraFields.contains("link"));
+        // It doesn't make sense to specify user id via layout, so we don't support it.
+    }
+
+    @LargeTest
+    public void testFriendsLoad() throws Throwable {
+        TestActivity activity = getActivity();
+        assertNotNull(activity);
+
+        // We don't auto-create any UI, so do it now. Needs to run on the UI thread.
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                getActivity().setContentToFragment(null);
+            }
+        });
+
+        final FriendPickerFragment fragment = activity.getFragment();
+        assertNotNull(fragment);
+
+        // Ensure our test user has at least one friend.
+        final TestSession session1 = openTestSessionWithSharedUser();
+        TestSession session2 = openTestSessionWithSharedUser(SECOND_TEST_USER_TAG);
+        makeTestUsersFriends(session1, session2);
+
+        // Trigger a data load (on the UI thread).
+        final TestBlocker blocker = getTestBlocker();
+        // We expect to get called twice -- once with results, once to indicate we are done paging.
+        runAndBlockOnUiThread(2, new Runnable() {
+            @Override
+            public void run() {
+                fragment.setSession(session1);
+                fragment.setOnDataChangedListener(new PickerFragment.OnDataChangedListener() {
+                    @Override
+                    public void onDataChanged() {
+                        blocker.signal();
+                    }
+                });
+                fragment.setExtraFields(Arrays.asList("first_name"));
+                fragment.loadData(true);
+            }
+        });
+
+        // We should have at least one item in the list by now.
+        ListView listView = (ListView) fragment.getView().findViewById(R.id.com_facebook_picker_list_view);
+        assertNotNull(listView);
+        View firstChild = listView.getChildAt(0);
+        assertNotNull(firstChild);
+
+        // Assert our state before we touch anything.
+        CheckBox checkBox = (CheckBox)listView.findViewById(R.id.com_facebook_picker_checkbox);
+        assertNotNull(checkBox);
+        assertFalse(checkBox.isChecked());
+        assertEquals(0, fragment.getSelection().size());
+
+        // Click on the first item in the list view.
+        TouchUtils.clickView(this, firstChild);
+
+        // We should have a selection (it might not be the user we made a friend up above, if the
+        // test user has more than one friend).
+        assertEquals(1, fragment.getSelection().size());
+
+        // We should have gotten the extra field we wanted.
+        assertNotNull(fragment.getSelection().iterator().next().getFirstName());
+
+        // And the checkbox should be checked.
+        assertTrue(checkBox.isChecked());
+
+        // Touch the item again. We should go back to no selection.
+        TouchUtils.clickView(this, firstChild);
+        assertEquals(0, fragment.getSelection().size());
+        assertFalse(checkBox.isChecked());
+    }
+
+    public static class TestActivity extends FragmentTestCase.TestFragmentActivity<FriendPickerFragment> {
+        public TestActivity() {
+            super(FriendPickerFragment.class);
+        }
+
+        @Override
+        protected boolean getAutoCreateUI() {
+            return false;
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/GraphObjectPagingLoaderTests.java b/facebook/tests/src/com/facebook/GraphObjectPagingLoaderTests.java
new file mode 100644
index 000000000..dce2f1d06
--- /dev/null
+++ b/facebook/tests/src/com/facebook/GraphObjectPagingLoaderTests.java
@@ -0,0 +1,160 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.location.Location;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.LoaderManager;
+import android.support.v4.content.Loader;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+
+public class GraphObjectPagingLoaderTests extends FragmentTestCase<GraphObjectPagingLoaderTests.TestActivity> {
+    public GraphObjectPagingLoaderTests() {
+        super(TestActivity.class);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testLoaderLoadsAndFollowsNextLinks() throws Exception {
+        CountingCallback callback = new CountingCallback();
+        final GraphObjectPagingLoader<GraphPlace> loader = (GraphObjectPagingLoader<GraphPlace>)
+                getActivity().getSupportLoaderManager().initLoader(0, null, callback);
+
+        TestSession session = openTestSessionWithSharedUser();
+
+        Location location = new Location("");
+        location.setLatitude(47.6204);
+        location.setLongitude(-122.3491);
+
+        final Request request = Request.newPlacesSearchRequest(session, location, 1000, 5, null, null);
+
+        // Need to run this on blocker thread so callbacks are made there.
+        runOnBlockerThread(new Runnable() {
+            @Override
+            public void run() {
+                loader.startLoading(request, false);
+            }
+        }, false);
+
+        getTestBlocker().waitForSignals(1);
+        assertEquals(1, callback.onLoadFinishedCount);
+        assertEquals(0, callback.onErrorCount);
+        assertEquals(0, callback.onLoadResetCount);
+        // We might not get back the exact number we requested because of privacy or other rules on
+        // the service side.
+        assertNotNull(callback.results);
+        assertTrue(callback.results.getCount() > 0);
+
+        runOnBlockerThread(new Runnable() {
+            @Override
+            public void run() {
+                loader.followNextLink();
+            }
+        }, false);
+        getTestBlocker().waitForSignals(1);
+        assertEquals(2, callback.onLoadFinishedCount);
+        assertEquals(0, callback.onErrorCount);
+        assertEquals(0, callback.onLoadResetCount);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testLoaderFinishesImmediatelyOnNoResults() throws Exception {
+        CountingCallback callback = new CountingCallback();
+        final GraphObjectPagingLoader<GraphPlace> loader = (GraphObjectPagingLoader<GraphPlace>)
+                getActivity().getSupportLoaderManager().initLoader(0, null, callback);
+
+        TestSession session = openTestSessionWithSharedUser();
+
+        // Unlikely to ever be a Place here.
+        Location location = new Location("");
+        location.setLatitude(-1.0);
+        location.setLongitude(-1.0);
+
+        final Request request = Request.newPlacesSearchRequest(session, location, 10, 5, null, null);
+
+        // Need to run this on blocker thread so callbacks are made there.
+        runOnBlockerThread(new Runnable() {
+            @Override
+            public void run() {
+                loader.startLoading(request, false);
+            }
+        }, false);
+
+        getTestBlocker().waitForSignals(1);
+        assertEquals(1, callback.onLoadFinishedCount);
+        assertEquals(0, callback.onErrorCount);
+        assertEquals(0, callback.onLoadResetCount);
+        assertNotNull(callback.results);
+        assertEquals(0, callback.results.getCount());
+    }
+
+    private class CountingCallback implements
+            GraphObjectPagingLoader.OnErrorListener, LoaderManager.LoaderCallbacks<SimpleGraphObjectCursor<GraphPlace>> {
+        public int onLoadFinishedCount;
+        public int onLoadResetCount;
+        public int onErrorCount;
+        public SimpleGraphObjectCursor<GraphPlace> results;
+
+        private TestBlocker testBlocker = getTestBlocker();
+
+        @Override
+        public void onError(FacebookException error, GraphObjectPagingLoader<?> loader) {
+            ++onErrorCount;
+            testBlocker.signal();
+        }
+
+        @Override
+        public Loader<SimpleGraphObjectCursor<GraphPlace>> onCreateLoader(int id, Bundle args) {
+            GraphObjectPagingLoader<GraphPlace> loader = new GraphObjectPagingLoader<GraphPlace>(getActivity(),
+                    GraphPlace.class);
+            loader.setOnErrorListener(this);
+            return loader;
+        }
+
+        @Override
+        public void onLoadFinished(Loader<SimpleGraphObjectCursor<GraphPlace>> loader,
+                SimpleGraphObjectCursor<GraphPlace> data) {
+            results = data;
+            ++onLoadFinishedCount;
+            testBlocker.signal();
+        }
+
+        @Override
+        public void onLoaderReset(Loader<SimpleGraphObjectCursor<GraphPlace>> loader) {
+            ++onLoadResetCount;
+            testBlocker.signal();
+        }
+    }
+
+    public static class DummyFragment extends Fragment  {
+    }
+
+    public static class TestActivity extends FragmentTestCase.TestFragmentActivity<DummyFragment> {
+        public TestActivity() {
+            super(DummyFragment.class);
+        }
+
+        @Override
+        protected boolean getAutoCreateUI() {
+            return false;
+        }
+    }
+
+}
diff --git a/facebook/tests/src/com/facebook/GraphObjectWrapperTests.java b/facebook/tests/src/com/facebook/GraphObjectWrapperTests.java
new file mode 100644
index 000000000..a6196a349
--- /dev/null
+++ b/facebook/tests/src/com/facebook/GraphObjectWrapperTests.java
@@ -0,0 +1,1106 @@
+/**
+ * Copyright 2010 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+import junit.framework.Assert;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.*;
+import java.util.Map.Entry;
+
+public final class GraphObjectWrapperTests extends AndroidTestCase {
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreateEmptyGraphObject() {
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject();
+        assertTrue(graphObject != null);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanTreatAsMap() {
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject();
+
+        graphObject.setProperty("hello", "world");
+        assertEquals("world", (String) graphObject.asMap().get("hello"));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanTreatAsGraphPlace() {
+        GraphPlace graphPlace = GraphObjectWrapper.createGraphObject(GraphPlace.class);
+
+        graphPlace.setName("hello");
+        assertEquals("hello", graphPlace.getName());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanTreatAsGraphUser() {
+        GraphUser graphUser = GraphObjectWrapper.createGraphObject(GraphUser.class);
+
+        graphUser.setFirstName("Michael");
+        assertEquals("Michael", graphUser.getFirstName());
+        assertEquals("Michael", graphUser.getProperty("first_name"));
+        assertEquals("Michael", graphUser.asMap().get("first_name"));
+
+        graphUser.setProperty("last_name", "Scott");
+        assertEquals("Scott", graphUser.getProperty("last_name"));
+        assertEquals("Scott", graphUser.getLastName());
+        assertEquals("Scott", graphUser.asMap().get("last_name"));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanCastBetweenGraphObjectTypes() {
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject();
+
+        graphObject.setProperty("first_name", "Mickey");
+
+        GraphUser graphUser = graphObject.cast(GraphUser.class);
+        assertTrue(graphUser != null);
+        // Should see the name we set earlier as a GraphObject.
+        assertEquals("Mickey", graphUser.getFirstName());
+
+        // Changes to GraphUser should be reflected in GraphObject version.
+        graphUser.setLastName("Mouse");
+        assertEquals("Mouse", graphObject.getProperty("last_name"));
+    }
+
+    interface Base extends GraphObject {
+    }
+
+    interface Derived extends Base {
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCastingToSameTypeGivesSameObject() {
+        Base base = GraphObjectWrapper.createGraphObject(Base.class);
+
+        Base cast = base.cast(Base.class);
+
+        assertTrue(base == cast);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCastingToBaseTypeGivesSameObject() {
+        Derived derived = GraphObjectWrapper.createGraphObject(Derived.class);
+
+        Base cast = derived.cast(Base.class);
+        assertTrue(derived == cast);
+
+        cast = cast.cast(Derived.class);
+        assertTrue(derived == cast);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanSetComplexTypes() {
+        GraphLocation graphLocation = GraphObjectWrapper.createGraphObject(GraphLocation.class);
+        graphLocation.setCity("Seattle");
+
+        GraphPlace graphPlace = GraphObjectWrapper.createGraphObject(GraphPlace.class);
+        graphPlace.setLocation(graphLocation);
+
+        assertEquals(graphLocation, graphPlace.getLocation());
+        assertEquals("Seattle", graphPlace.getLocation().getCity());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanConvertFromJSON() throws JSONException {
+        JSONObject jsonLocation = new JSONObject();
+        jsonLocation.put("city", "Paris");
+        jsonLocation.put("country", "France");
+
+        JSONObject jsonPlace = new JSONObject();
+        jsonPlace.put("location", jsonLocation);
+        jsonPlace.put("name", "Eiffel Tower");
+
+        GraphPlace graphPlace = GraphObjectWrapper.createGraphObject(jsonPlace, GraphPlace.class);
+        GraphLocation graphLocation = graphPlace.getLocation();
+        assertEquals("Paris", graphLocation.getCity());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanConvertFromGraphObject() throws JSONException {
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject();
+        graphObject.setProperty("city", "Paris");
+        graphObject.setProperty("country", "France");
+
+        JSONObject jsonPlace = new JSONObject();
+        jsonPlace.put("location", graphObject);
+        jsonPlace.put("name", "Eiffel Tower");
+
+        GraphPlace graphPlace = GraphObjectWrapper.createGraphObject(jsonPlace, GraphPlace.class);
+        GraphLocation graphLocation = graphPlace.getLocation();
+        assertEquals("Paris", graphLocation.getCity());
+    }
+
+    private abstract class GraphObjectClass implements GraphObject {
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapNonInterface() {
+        try {
+            GraphObjectWrapper.createGraphObject(GraphObjectClass.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface BadNoParameterMethodNameGraphObject extends GraphObject {
+        Object floppityFlee();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadZeroParameterMethodName() {
+        try {
+            GraphObjectWrapper.createGraphObject(BadNoParameterMethodNameGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface BadSingleParameterMethodNameGraphObject extends GraphObject {
+        void floppityFlee(Object obj);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadSingleParameterMethodName() {
+        try {
+            GraphObjectWrapper.createGraphObject(BadSingleParameterMethodNameGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface BadGetterNameGraphObject extends GraphObject {
+        void get();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadGetterName() {
+        try {
+            GraphObjectWrapper.createGraphObject(BadGetterNameGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface BadGetterParamsGraphObject extends GraphObject {
+        Object getFoo(Object obj);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadGetterParams() {
+        try {
+            GraphObjectWrapper.createGraphObject(BadGetterParamsGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface BadGetterReturnTypeGraphObject extends GraphObject {
+        void getFoo();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadGetterReturnType() {
+        try {
+            GraphObjectWrapper.createGraphObject(BadGetterReturnTypeGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface BadSetterNameGraphObject extends GraphObject {
+        void set();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadSetterName() {
+        try {
+            GraphObjectWrapper.createGraphObject(BadSetterNameGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface BadSetterParamsGraphObject extends GraphObject {
+        void setFoo();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadSetterParams() {
+        try {
+            GraphObjectWrapper.createGraphObject(BadSetterParamsGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface BadSetterReturnTypeGraphObject extends GraphObject {
+        Object setFoo(Object obj);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadSetterReturnType() {
+        try {
+            GraphObjectWrapper.createGraphObject(BadSetterReturnTypeGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface BadBaseInterfaceGraphObject extends BadSetterReturnTypeGraphObject {
+        void setBar(Object obj);
+
+        Object getBar();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadBaseInterface() {
+        try {
+            GraphObjectWrapper.createGraphObject(BadBaseInterfaceGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface GoodPropertyOverrideInterfaceGraphObject extends GraphObject {
+        void setDefaultName(String s);
+
+        // No annotation to ensure that the right property is being set.
+        String getAnotherDefaultName();
+
+        @PropertyName("another_default_name")
+        void putSomething(String s);
+
+        @PropertyName("default_name")
+        String retrieveSomething();
+
+        @PropertyName("MixedCase")
+        void setMixedCase(String s);
+
+        @PropertyName("MixedCase")
+        String getMixedCase();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanOverrideGraphPropertyNames() {
+        GoodPropertyOverrideInterfaceGraphObject graphObject =
+                GraphObjectWrapper.createGraphObject(GoodPropertyOverrideInterfaceGraphObject.class);
+
+        String testValue = "flu-blah";
+        graphObject.setDefaultName(testValue);
+        Assert.assertEquals(testValue, graphObject.retrieveSomething());
+
+        testValue = testValue + "1";
+        graphObject.putSomething(testValue);
+        Assert.assertEquals(testValue, graphObject.getAnotherDefaultName());
+
+        testValue = testValue + "2";
+        graphObject.setMixedCase(testValue);
+        Assert.assertEquals(testValue, graphObject.getMixedCase());
+    }
+
+    private interface BadPropertyOverrideInterfaceGraphObject extends GraphObject {
+        @PropertyName("")
+        void setMissingProperty(Object value);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadPropertyNameOverrides() {
+        try {
+            GraphObjectWrapper.createGraphObject(BadPropertyOverrideInterfaceGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testObjectEquals() {
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject();
+        graphObject.setProperty("aKey", "aValue");
+
+        assertTrue(graphObject.equals(graphObject));
+
+        GraphPlace graphPlace = graphObject.cast(GraphPlace.class);
+        assertTrue(graphObject.equals(graphPlace));
+        assertTrue(graphPlace.equals(graphObject));
+
+        GraphObject aDifferentGraphObject = GraphObjectWrapper.createGraphObject();
+        aDifferentGraphObject.setProperty("aKey", "aDifferentValue");
+        assertFalse(graphObject.equals(aDifferentGraphObject));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testGetProperty() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        assertEquals("world", graphObject.getProperty("hello"));
+        assertTrue(graphObject.getProperty("fred") == null);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testSetProperty() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+
+        graphObject.setProperty("hello", "world");
+        graphObject.setProperty("don't imagine", "purple elephants");
+
+        assertEquals("world", jsonObject.getString("hello"));
+        assertEquals("purple elephants", jsonObject.getString("don't imagine"));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testRemoveProperty() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("whirled", "peas");
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+
+        graphObject.setProperty("hello", "world");
+        graphObject.setProperty("don't imagine", "purple elephants");
+
+        assertEquals("world", jsonObject.getString("hello"));
+        assertEquals("purple elephants", jsonObject.getString("don't imagine"));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapClear() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+
+        assertEquals(1, jsonObject.length());
+
+        graphObject.asMap().clear();
+
+        assertEquals(0, jsonObject.length());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapContainsKey() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+
+        assertTrue(graphObject.asMap().containsKey("hello"));
+        assertFalse(graphObject.asMap().containsKey("hocus"));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapContainsValue() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+
+        assertTrue(graphObject.asMap().containsValue("world"));
+        assertFalse(graphObject.asMap().containsValue("pocus"));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapEntrySet() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+
+        Set<Entry<String, Object>> entrySet = graphObject.asMap().entrySet();
+        assertEquals(2, entrySet.size());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapGet() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        assertEquals("world", graphObject.asMap().get("hello"));
+        assertTrue(graphObject.getProperty("fred") == null);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapGetReturnsNullForMissingProperty() throws JSONException {
+        GraphUser graphUser = GraphObjectWrapper.createGraphObject(GraphUser.class);
+        assertNull(graphUser.getBirthday());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapIsEmpty() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        assertTrue(graphObject.asMap().isEmpty());
+
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+        assertFalse(graphObject.asMap().isEmpty());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapKeySet() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+
+        Set<String> keySet = graphObject.asMap().keySet();
+        assertEquals(2, keySet.size());
+        assertTrue(keySet.contains("hello"));
+        assertTrue(keySet.contains("hocus"));
+        assertFalse(keySet.contains("world"));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapPut() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        graphObject.setProperty("hello", "world");
+        graphObject.setProperty("hocus", "pocus");
+
+        assertEquals("pocus", jsonObject.get("hocus"));
+        assertEquals(2, jsonObject.length());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapPutOfWrapperPutsJSONObject() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        graphObject.setProperty("hello", "world");
+        graphObject.setProperty("hocus", "pocus");
+
+        GraphObject parentObject = GraphObjectWrapper.createGraphObject();
+        parentObject.setProperty("key", graphObject);
+
+        JSONObject jsonParent = parentObject.getInnerJSONObject();
+        Object obj = jsonParent.opt("key");
+
+        assertNotNull(obj);
+        assertEquals(jsonObject, obj);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapPutOfWrapperPutsJSONArray() throws JSONException {
+        JSONArray jsonArray = new JSONArray();
+
+        GraphObjectList<String> graphObjectList = GraphObjectWrapper.wrapArray(jsonArray, String.class);
+        graphObjectList.add("hello");
+        graphObjectList.add("world");
+
+        GraphObject parentObject = GraphObjectWrapper.createGraphObject();
+        parentObject.setProperty("key", graphObjectList);
+
+        JSONObject jsonParent = parentObject.getInnerJSONObject();
+        Object obj = jsonParent.opt("key");
+
+        assertNotNull(obj);
+        assertEquals(jsonArray, obj);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapPutAll() throws JSONException {
+        HashMap<String, Object> map = new HashMap<String, Object>();
+        map.put("hello", "world");
+        map.put("hocus", "pocus");
+
+        JSONObject jsonObject = new JSONObject();
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+
+        graphObject.asMap().putAll(map);
+        assertEquals("pocus", jsonObject.get("hocus"));
+        assertEquals(2, jsonObject.length());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapRemove() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        graphObject.removeProperty("hello");
+
+        assertEquals(1, jsonObject.length());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapSize() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+
+        assertEquals(2, graphObject.asMap().size());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapValues() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+
+        Collection<Object> values = graphObject.asMap().values();
+
+        assertEquals(2, values.size());
+        assertTrue(values.contains("world"));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testGetInnerJSONObject() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+
+        assertEquals(jsonObject, graphObject.getInnerJSONObject());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testSettingGraphObjectProxyStoresJSONObject() throws JSONException {
+        GraphPlace graphPlace = GraphObjectWrapper.createGraphObject(GraphPlace.class);
+        GraphLocation graphLocation = GraphObjectWrapper.createGraphObject(GraphLocation.class);
+
+        graphPlace.setLocation(graphLocation);
+
+        assertEquals(graphLocation.getInnerJSONObject(), graphPlace.getInnerJSONObject().get("location"));
+
+    }
+
+    private interface DateGraphObject extends GraphObject {
+        Date getDate1();
+
+        Date getDate2();
+
+        Date getDate3();
+
+        Date getDate4();
+        void setDate4(Date date);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testGetStringsAsDates() {
+        DateGraphObject dates = GraphObjectWrapper.createGraphObject(DateGraphObject.class);
+        dates.setProperty("date1", "2012-07-04");
+        dates.setProperty("date2", "2012-07-04T19:30:50");
+        dates.setProperty("date3", "2012-07-04T19:20:40-0400");
+
+        // Dates without a time zone should be assumed to be in the current timezone.
+        Calendar cal = new GregorianCalendar();
+        cal.set(Calendar.MILLISECOND, 0);
+
+        cal.set(2012, 6, 4, 0, 0, 0);
+        Date expectedDate1 = cal.getTime();
+        Date date1 = dates.getDate1();
+        assertEquals(expectedDate1, date1);
+
+        cal.set(2012, 6, 4, 19, 30, 50);
+        Date expectedDate2 = cal.getTime();
+        Date date2 = dates.getDate2();
+        assertEquals(expectedDate2, date2);
+
+        // Dates with an explicit time zone should take that timezone into account.
+        cal = new GregorianCalendar(TimeZone.getTimeZone("GMT"));
+        cal.set(Calendar.MILLISECOND, 0);
+        cal.set(2012, 6, 4, 23, 20, 40);
+
+        Date expectedDate3 = cal.getTime();
+        Date date3 = dates.getDate3();
+        assertEquals(expectedDate3, date3);
+
+        cal.set(2012, 9, 28, 9, 53, 0);
+        Date expectedDate4 = cal.getTime();
+        dates.setDate4(expectedDate4);
+        Date date4 = dates.getDate4();
+        assertEquals(expectedDate4, date4);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionAdd() throws JSONException {
+        JSONArray array = new JSONArray();
+
+        Collection<Integer> collection = GraphObjectWrapper.wrapArray(array, Integer.class);
+        collection.add(5);
+
+        assertTrue(array.length() == 1);
+        assertTrue(array.optInt(0) == 5);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionAddAll() throws JSONException {
+        JSONArray array = new JSONArray();
+
+        Collection<Integer> collectionToAdd = Arrays.asList(5, -1);
+
+        Collection<Integer> collection = GraphObjectWrapper.wrapArray(array, Integer.class);
+        collection.addAll(collectionToAdd);
+
+        assertTrue(array.length() == 2);
+        assertTrue(array.optInt(0) == 5);
+        assertTrue(array.optInt(1) == -1);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionContains() throws JSONException {
+        JSONArray array = new JSONArray();
+        array.put(5);
+
+        Collection<Integer> collection = GraphObjectWrapper.wrapArray(array, Integer.class);
+        assertTrue(collection.contains(5));
+        assertFalse(collection.contains(6));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionContainsAll() throws JSONException {
+        JSONArray array = new JSONArray();
+        array.put(5);
+        array.put(-1);
+
+        Collection<Integer> collection = GraphObjectWrapper.wrapArray(array, Integer.class);
+        assertTrue(collection.containsAll(Arrays.asList(5)));
+        assertTrue(collection.containsAll(Arrays.asList(5, -1)));
+        assertFalse(collection.containsAll(Arrays.asList(5, -1, 2)));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionIsEmpty() throws JSONException {
+        JSONArray array = new JSONArray();
+
+        Collection<Integer> collection = GraphObjectWrapper.wrapArray(array, Integer.class);
+        assertTrue(collection.isEmpty());
+
+        array.put(5);
+        assertFalse(collection.isEmpty());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionIterator() throws JSONException {
+        JSONArray array = new JSONArray();
+        array.put(5);
+        array.put(-1);
+
+        Collection<Integer> collection = GraphObjectWrapper.wrapArray(array, Integer.class);
+        Iterator<Integer> iter = collection.iterator();
+        assertTrue(iter.hasNext());
+        assertTrue(iter.next() == 5);
+        assertTrue(iter.hasNext());
+        assertTrue(iter.next() == -1);
+        assertFalse(iter.hasNext());
+
+        for (Integer i : collection) {
+            assertNotSame(0, i);
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionIteratorOfGraphObject() throws JSONException {
+        Collection<GraphLocation> collection = GraphObjectWrapper.createArray(GraphLocation.class);
+
+        GraphLocation seattle = GraphObjectWrapper.createGraphObject(GraphLocation.class);
+        seattle.setCity("Seattle");
+        collection.add(seattle);
+        GraphLocation paris = GraphObjectWrapper.createGraphObject(GraphLocation.class);
+        paris.setCity("Paris");
+        collection.add(paris);
+
+        Iterator<GraphLocation> iter = collection.iterator();
+        assertTrue(iter.hasNext());
+        assertEquals(seattle, iter.next());
+        assertTrue(iter.hasNext());
+        assertEquals(paris, iter.next());
+        assertFalse(iter.hasNext());
+
+        for (GraphLocation location : collection) {
+            assertTrue(location != null);
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionSize() throws JSONException {
+        JSONArray array = new JSONArray();
+
+        Collection<Integer> collection = GraphObjectWrapper.wrapArray(array, Integer.class);
+        assertEquals(0, collection.size());
+
+        array.put(5);
+        assertEquals(1, collection.size());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionClearThrows() throws JSONException {
+        try {
+            Collection<Integer> collection = GraphObjectWrapper.createArray(Integer.class);
+            collection.clear();
+            fail("Expected exception");
+        } catch (UnsupportedOperationException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionRemoveThrows() throws JSONException {
+        try {
+            Collection<Integer> collection = GraphObjectWrapper.createArray(Integer.class);
+            collection.remove(5);
+            fail("Expected exception");
+        } catch (UnsupportedOperationException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionRemoveAllThrows() throws JSONException {
+        try {
+            Collection<Integer> collection = GraphObjectWrapper.createArray(Integer.class);
+            collection.removeAll(Arrays.asList());
+            fail("Expected exception");
+        } catch (UnsupportedOperationException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionRetainAllThrows() throws JSONException {
+        try {
+            Collection<Integer> collection = GraphObjectWrapper.createArray(Integer.class);
+            collection.retainAll(Arrays.asList());
+            fail("Expected exception");
+        } catch (UnsupportedOperationException exception) {
+        }
+    }
+
+    private interface Locations extends GraphObject {
+        Collection<GraphLocation> getLocations();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testObjectWrapsJSONCollection() throws JSONException {
+        JSONObject jsonLocation = new JSONObject();
+        jsonLocation.put("city", "Seattle");
+
+        JSONArray jsonArray = new JSONArray();
+        jsonArray.put(jsonLocation);
+
+        JSONObject jsonLocations = new JSONObject();
+        jsonLocations.put("locations", jsonArray);
+
+        Locations locations = GraphObjectWrapper.createGraphObject(jsonLocations, Locations.class);
+        Collection<GraphLocation> locationsGraphObjectCollection = locations.getLocations();
+        assertTrue(locationsGraphObjectCollection != null);
+
+        GraphLocation graphLocation = locationsGraphObjectCollection.iterator().next();
+        assertTrue(graphLocation != null);
+        assertEquals("Seattle", graphLocation.getCity());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testObjectWrapsIterable() throws JSONException {
+        GraphUser user = GraphObjectWrapper.createGraphObject(GraphUser.class);
+        user.setFirstName("Foo");
+        user.setLastName("Bar");
+
+        List<GraphUser> users = new ArrayList<GraphUser>();
+        users.add(user);
+
+        OpenGraphAction action = GraphObjectWrapper.createGraphObject(OpenGraphAction.class);
+        action.setTags(users);
+
+        String json = action.getInnerJSONObject().toString();
+
+        assertTrue("JSON string should contain last_name", json.contains("last_name"));
+
+        Object tags = action.getInnerJSONObject().get("tags");
+        assertNotNull("tags should not be null", tags);
+        assertTrue("tags should be JSONArray", tags instanceof JSONArray);
+
+        List<GraphObject> retrievedUsers = action.getTags();
+        assertEquals("Size should be 1", 1, retrievedUsers.size());
+        GraphUser retrievedUser = retrievedUsers.get(0).cast(GraphUser.class);
+        assertEquals("First name should be Foo", "Foo", retrievedUser.getFirstName());
+        assertEquals("Last name should be Bar", "Bar", retrievedUser.getLastName());
+
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionWrapsJSONObject() throws JSONException {
+        JSONObject jsonLocation = new JSONObject();
+        jsonLocation.put("city", "Seattle");
+
+        JSONArray jsonArray = new JSONArray();
+        jsonArray.put(jsonLocation);
+        Collection<GraphLocation> locationsGraphObjectCollection = GraphObjectWrapper.wrapArray(jsonArray,
+                GraphLocation.class);
+        assertTrue(locationsGraphObjectCollection != null);
+
+        GraphLocation graphLocation = locationsGraphObjectCollection.iterator().next();
+        assertTrue(graphLocation != null);
+        assertEquals("Seattle", graphLocation.getCity());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCannotCastCollectionOfNonGraphObjects() throws JSONException {
+        try {
+            GraphObjectList<Integer> collection = GraphObjectWrapper.createArray(Integer.class);
+            collection.castToListOf(GraphLocation.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanCastCollectionOfGraphObjects() throws JSONException {
+        JSONObject jsonSeattle = new JSONObject();
+        jsonSeattle.put("city", "Seattle");
+
+        JSONArray jsonArray = new JSONArray();
+        jsonArray.put(jsonSeattle);
+
+        GraphObjectList<GraphObject> collection = GraphObjectWrapper.wrapArray(jsonArray, GraphObject.class);
+
+        GraphObjectList<GraphLocation> locationCollection = collection.castToListOf(GraphLocation.class);
+        assertTrue(locationCollection != null);
+
+        GraphLocation seattle = locationCollection.iterator().next();
+        assertTrue(seattle != null);
+        assertEquals("Seattle", seattle.getCity());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCastingCollectionToSameTypeGivesSameObject() {
+        GraphObjectList<Base> base = GraphObjectWrapper.createArray(Base.class);
+
+        GraphObjectList<Base> cast = base.castToListOf(Base.class);
+
+        assertTrue(base == cast);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCastingCollectionToBaseTypeGivesSameObject() {
+        GraphObjectList<Derived> derived = GraphObjectWrapper.createArray(Derived.class);
+
+        GraphObjectList<Base> cast = derived.castToListOf(Base.class);
+
+        assertTrue((GraphObjectList<?>)derived == (GraphObjectList<?>)cast);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanGetInnerJSONArray() throws JSONException {
+        JSONArray jsonArray = new JSONArray();
+
+        GraphObjectList<GraphObject> collection = GraphObjectWrapper.wrapArray(jsonArray, GraphObject.class);
+
+        assertEquals(jsonArray, collection.getInnerJSONArray());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanGetRandomAccess() throws JSONException {
+        JSONArray jsonArray = new JSONArray();
+        jsonArray.put("Seattle");
+        jsonArray.put("Menlo Park");
+
+        GraphObjectList<String> collection = GraphObjectWrapper.wrapArray(jsonArray, String.class);
+
+        assertEquals("Menlo Park", collection.get(1));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanSetRandomAccess() throws JSONException {
+        JSONArray jsonArray = new JSONArray();
+
+        GraphObjectList<String> collection = GraphObjectWrapper.wrapArray(jsonArray, String.class);
+
+        collection.add("Seattle");
+        collection.add("Menlo Park");
+
+        collection.set(1, "Ann Arbor");
+        assertEquals("Ann Arbor", collection.get(1));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionPutOfWrapperPutsJSONObject() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        graphObject.setProperty("hello", "world");
+        graphObject.setProperty("hocus", "pocus");
+
+        GraphObjectList<GraphObject> parentList = GraphObjectWrapper.createArray(GraphObject.class);
+        parentList.add(graphObject);
+
+        JSONArray jsonArray = parentList.getInnerJSONArray();
+
+        Object obj = jsonArray.opt(0);
+
+        assertNotNull(obj);
+        assertEquals(jsonObject, obj);
+
+        parentList.set(0, graphObject);
+
+        obj = jsonArray.opt(0);
+
+        assertNotNull(obj);
+        assertEquals(jsonObject, obj);
+    }
+}
diff --git a/facebook/tests/src/com/facebook/GraphRequestTests.java b/facebook/tests/src/com/facebook/GraphRequestTests.java
new file mode 100644
index 000000000..a00a11239
--- /dev/null
+++ b/facebook/tests/src/com/facebook/GraphRequestTests.java
@@ -0,0 +1,88 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.facebook;
+
+import android.test.suitebuilder.annotation.LargeTest;
+
+import java.util.Date;
+
+// These tests relate to serialization/de-serialization of graph objects in a variety of scenarios, rather than
+// to the underlying request/batch plumbing.
+public class GraphRequestTests extends FacebookTestCase {
+
+    @LargeTest
+    public void testCommentRoundTrip() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        GraphObject status = createStatusUpdate();
+        GraphObject createdStatus = batchCreateAndGet(session, "me/feed", status, null, GraphObject.class);
+        String statusID = (String) createdStatus.getProperty("id");
+
+        GraphObject comment = GraphObjectWrapper.createGraphObject();
+        final String commentMessage = "It truly is a wonderful status update.";
+        comment.setProperty("message", commentMessage);
+
+        GraphObject createdComment1 = batchCreateAndGet(session, statusID + "/comments", comment, null,
+                GraphObject.class);
+        assertNotNull(createdComment1);
+
+        String comment1ID = (String) createdComment1.getProperty("id");
+        String comment1Message = (String) createdComment1.getProperty("message");
+        assertNotNull(comment1ID);
+        assertNotNull(comment1Message);
+        assertEquals(commentMessage, comment1Message);
+
+        // Try posting the same comment to the same status update. We need to clear its ID first.
+        createdComment1.removeProperty("id");
+        GraphObject createdComment2 = batchCreateAndGet(session, statusID + "/comments", createdComment1, null,
+                GraphObject.class);
+        assertNotNull(createdComment2);
+
+        String comment2ID = (String) createdComment2.getProperty("id");
+        String comment2Message = (String) createdComment2.getProperty("message");
+        assertNotNull(comment2ID);
+        assertFalse(comment1ID.equals(comment2ID));
+        assertNotNull(comment2Message);
+        assertEquals(commentMessage, comment2Message);
+    }
+
+    @LargeTest
+    public void testEventRoundTrip() {
+        TestSession session = openTestSessionWithSharedUserAndPermissions(null, "create_event");
+
+        GraphObject event = GraphObjectWrapper.createGraphObject();
+        // Android emulators tend to not have the right date/time. To avoid issues with posting events in the past
+        // or too far in the future, we use a constant year. This test will break in 2030, angering our robot overlords.
+        Date startTime = new Date(130, 2, 17, 12, 34, 56);
+        event.setProperty("name", "My awesome St. Patrick's Day party on " + startTime.toString());
+        final String eventDescription = "This is a great event. You should all come.";
+        event.setProperty("description", eventDescription);
+        Date endTime = new Date(startTime.getTime() + 3600 * 1000);
+        event.setProperty("start_time", startTime);
+        event.setProperty("end_time", endTime);
+        event.setProperty("location", "My house");
+
+        GraphObject event1 = batchCreateAndGet(session, "me/events", event, null, GraphObject.class);
+        assertNotNull(event1);
+        assertEquals(eventDescription, event1.getProperty("description"));
+
+        event1.removeProperty("id");
+        GraphObject event2 = batchCreateAndGet(session, "me/events", event1, null, GraphObject.class);
+        assertNotNull(event2);
+        assertEquals(eventDescription, event2.getProperty("description"));
+    }
+
+}
diff --git a/facebook/tests/src/com/facebook/ImageResponseCacheTests.java b/facebook/tests/src/com/facebook/ImageResponseCacheTests.java
new file mode 100644
index 000000000..c18cd31cb
--- /dev/null
+++ b/facebook/tests/src/com/facebook/ImageResponseCacheTests.java
@@ -0,0 +1,101 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+public final class ImageResponseCacheTests extends AndroidTestCase {
+
+    @MediumTest @LargeTest
+    public void testImageCaching() throws IOException {
+        // In unit test, since we need verify first access the image is not in cache
+        // we need clear the cache first
+        ImageResponseCache.getCache(safeGetContext()).clear();
+        String imgUrl = "http://sphotos-b.xx.fbcdn.net/hphotos-snc7/300716_163831917043403_1106723719_n.jpg";
+        
+        Bitmap bmp1 = readImage(imgUrl, false);
+        Bitmap bmp2 = readImage(imgUrl, true);
+        compareImages(bmp1, bmp2);
+    }
+    
+    @MediumTest @LargeTest
+    public void testImageNotCaching() throws IOException {
+        
+        String imgUrl = "http://graph.facebook.com/ryanseacrest/picture?type=large";
+        
+        Bitmap bmp1 = readImage(imgUrl, false);
+        Bitmap bmp2 = readImage(imgUrl, false);
+        compareImages(bmp1, bmp2);
+    }
+
+    private Bitmap readImage(String uri, boolean expectedFromCache) {
+        Bitmap bmp = null;
+        InputStream istream = null;
+        try
+        {
+            URL url = new URL(uri);
+            // Check if the cache contains value for this url
+            boolean isInCache = (ImageResponseCache.getCache(safeGetContext()).get(url.toString()) != null);
+            assertTrue(isInCache == expectedFromCache);
+            // Read the image
+            istream = ImageResponseCache.getImageStream(url, safeGetContext());
+            assertTrue(istream != null);
+            bmp = BitmapFactory.decodeStream(istream);
+            assertTrue(bmp != null);
+        } catch (Exception e) {
+             assertNull(e);
+        } finally {
+            Utility.closeQuietly(istream);
+        }
+        return bmp;
+    }
+    
+    private static void compareImages(Bitmap bmp1, Bitmap bmp2) {
+        assertTrue(bmp1.getHeight() == bmp2.getHeight());
+        assertTrue(bmp1.getWidth() == bmp1.getWidth());
+        ByteBuffer buffer1 = ByteBuffer.allocate(bmp1.getHeight() * bmp1.getRowBytes());
+        bmp1.copyPixelsToBuffer(buffer1);
+
+        ByteBuffer buffer2 = ByteBuffer.allocate(bmp2.getHeight() * bmp2.getRowBytes());
+        bmp2.copyPixelsToBuffer(buffer2);
+
+        assertTrue(Arrays.equals(buffer1.array(), buffer2.array()));
+    }
+
+    private Context safeGetContext() {
+        for (;;) {
+            if ((getContext() != null) && (getContext().getApplicationContext() != null)) {
+                return getContext();
+            }
+            try {
+                Thread.sleep(25);
+            } catch (InterruptedException e) {
+            }
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/LoginButtonTest.java b/facebook/tests/src/com/facebook/LoginButtonTest.java
new file mode 100644
index 000000000..2fdeb6023
--- /dev/null
+++ b/facebook/tests/src/com/facebook/LoginButtonTest.java
@@ -0,0 +1,242 @@
+package com.facebook;
+
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+public class LoginButtonTest extends SessionTestsBase {
+
+    static final int STRAY_CALLBACK_WAIT_MILLISECONDS = 50;
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testLoginButton() {
+        SessionTestsBase.MockTokenCache cache = new SessionTestsBase.MockTokenCache(null, 0);
+        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
+        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder = new SessionTestsBase.SessionStatusCallbackRecorder();
+        AccessToken openToken = AccessToken.createFromString("A token of thanks", new ArrayList<String>());
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        final LoginButton button = new LoginButton(getActivity());
+        button.setSession(session);
+        session.addAuthorizeResult(openToken);
+        session.addCallback(statusRecorder);
+
+        button.performClick();
+
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testLoginFail() {
+        SessionTestsBase.MockTokenCache cache = new SessionTestsBase.MockTokenCache(null, 0);
+        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
+        final Exception openException = new Exception("Open failed!");
+        final AtomicBoolean clicked = new AtomicBoolean(false);
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        final LoginButton button = new LoginButton(getActivity());
+        LoginButton.OnErrorListener listener = new LoginButton.OnErrorListener() {
+            @Override
+            public void onError(FacebookException exception) {
+                synchronized (this) {
+                    assertEquals(exception.getCause().getMessage(), openException.getMessage());
+                    clicked.set(true);
+                    this.notifyAll();
+                }
+            }
+        };
+        button.setOnErrorListener(listener);
+        button.setSession(session);
+        session.addAuthorizeResult(openException);
+
+        button.onAttachedToWindow();
+        button.performClick();
+
+        try {
+            synchronized (listener) {
+                listener.wait(DEFAULT_TIMEOUT_MILLISECONDS);
+            }
+        } catch (InterruptedException e) {
+            fail("Interrupted during open");
+        }
+
+        if (!clicked.get()) {
+            fail("Did not get exception");
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanAddReadPermissions() {
+        SessionTestsBase.MockTokenCache cache = new SessionTestsBase.MockTokenCache(null, 0);
+        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
+        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder = new SessionTestsBase.SessionStatusCallbackRecorder();
+        AccessToken openToken = AccessToken.createFromString("A token of thanks", new ArrayList<String>());
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        final LoginButton button = new LoginButton(getActivity());
+        button.setSession(session);
+        button.setReadPermissions(Arrays.asList(new String[] {"read_permission", "read_another"}));
+        session.addAuthorizeResult(openToken);
+        session.addCallback(statusRecorder);
+
+        button.performClick();
+
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanAddPublishPermissions() {
+        SessionTestsBase.MockTokenCache cache = new SessionTestsBase.MockTokenCache(null, 0);
+        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
+        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder =
+                new SessionTestsBase.SessionStatusCallbackRecorder();
+        AccessToken openToken = AccessToken.createFromString("A token of thanks", new ArrayList<String>());
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        final LoginButton button = new LoginButton(getActivity());
+        button.setSession(session);
+        button.setPublishPermissions(Arrays.asList(new String[] {"publish_permission", "publish_another"}));
+        session.addAuthorizeResult(openToken);
+        session.addCallback(statusRecorder);
+
+        button.performClick();
+
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantAddReadThenPublishPermissions() {
+        final LoginButton button = new LoginButton(getActivity());
+        button.setReadPermissions(Arrays.asList(new String[] {"read_permission", "read_another"}));
+        try {
+            button.setPublishPermissions(Arrays.asList(new String[] {"read_permission", "read_a_third"}));
+            fail("Should not be able to reach here");
+        } catch (Exception e) {
+            assertTrue(e instanceof UnsupportedOperationException);
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantAddPublishThenReadPermissions() {
+        final LoginButton button = new LoginButton(getActivity());
+        button.setPublishPermissions(Arrays.asList(new String[] {"publish_permission", "publish_another"}));
+        try {
+            button.setReadPermissions(Arrays.asList(new String[] {"publish_permission", "publish_a_third"}));
+            fail("Should not be able to reach here");
+        } catch (Exception e) {
+            assertTrue(e instanceof UnsupportedOperationException);
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanAddReadThenPublishPermissionsWithClear() {
+        final LoginButton button = new LoginButton(getActivity());
+        button.setReadPermissions(Arrays.asList(new String[] {"read_permission", "read_another"}));
+        button.clearPermissions();
+        button.setPublishPermissions(Arrays.asList(new String[] {"publish_permission", "publish_another"}));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantAddMorePermissionsToOpenSession() {
+        SessionTestsBase.MockTokenCache cache = new SessionTestsBase.MockTokenCache(null, 0);
+        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
+        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder =
+                new SessionTestsBase.SessionStatusCallbackRecorder();
+        AccessToken openToken = AccessToken.createFromString("A token of thanks",
+                Arrays.asList(new String[] {"read_permission", "read_another"}));
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        final LoginButton button = new LoginButton(getActivity());
+        button.setSession(session);        session.addAuthorizeResult(openToken);
+        session.addCallback(statusRecorder);
+
+        button.performClick();
+
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        // this should be fine
+        button.setReadPermissions(Arrays.asList(new String[] {"read_permission", "read_another"}));
+
+        button.setReadPermissions(Arrays.asList(new String[] {"read_permission", "read_a_third"}));
+        List<String> permissions = button.getPermissions();
+        assertTrue(permissions.contains("read_permission"));
+        assertTrue(permissions.contains("read_another"));
+        assertFalse(permissions.contains("read_a_third"));
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+}
diff --git a/facebook/tests/src/com/facebook/PlacePickerFragmentTests.java b/facebook/tests/src/com/facebook/PlacePickerFragmentTests.java
new file mode 100644
index 000000000..160bcc59c
--- /dev/null
+++ b/facebook/tests/src/com/facebook/PlacePickerFragmentTests.java
@@ -0,0 +1,278 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.location.Location;
+import android.os.Bundle;
+import android.test.TouchUtils;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.view.View;
+import android.widget.ListView;
+import com.facebook.sdk.tests.R;
+
+import java.util.Collection;
+
+public class PlacePickerFragmentTests extends FragmentTestCase<PlacePickerFragmentTests.TestActivity> {
+    public PlacePickerFragmentTests() {
+        super(TestActivity.class);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCanSetParametersProgrammatically() throws Throwable {
+        TestActivity activity = getActivity();
+        assertNotNull(activity);
+
+        final Location location = new Location("");
+        location.setLatitude(47.6204);
+        location.setLongitude(-122.3491);
+
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                Bundle bundle = new Bundle();
+                // We deliberately set these to non-defaults to ensure they are set correctly.
+                bundle.putBoolean(PlacePickerFragment.SHOW_PICTURES_BUNDLE_KEY, false);
+                bundle.putInt(PlacePickerFragment.RADIUS_IN_METERS_BUNDLE_KEY, 75);
+                bundle.putInt(PlacePickerFragment.RESULTS_LIMIT_BUNDLE_KEY, 5);
+                bundle.putString(PlacePickerFragment.SEARCH_TEXT_BUNDLE_KEY, "coffee");
+                bundle.putParcelable(PlacePickerFragment.LOCATION_BUNDLE_KEY, location);
+                bundle.putString(FriendPickerFragment.EXTRA_FIELDS_BUNDLE_KEY, "checkins,general_info");
+
+                PlacePickerFragment fragment = new PlacePickerFragment(bundle);
+                getActivity().setContentToFragment(fragment);
+            }
+        });
+
+        // We don't just test the fragment we created directly above, because we want it to go through the
+        // activity lifecycle and ensure the settings are still correct.
+        final PlacePickerFragment fragment = activity.getFragment();
+        assertNotNull(fragment);
+
+        assertEquals(false, fragment.getShowPictures());
+        assertEquals(75, fragment.getRadiusInMeters());
+        assertEquals(5, fragment.getResultsLimit());
+        assertEquals("coffee", fragment.getSearchText());
+        assertEquals(location, fragment.getLocation());
+        Collection<String> extraFields = fragment.getExtraFields();
+        assertTrue(extraFields.contains("checkins"));
+        assertTrue(extraFields.contains("general_info"));
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCanSetParametersViaLayout() throws Throwable {
+        TestActivity activity = getActivity();
+        assertNotNull(activity);
+
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                getActivity().setContentToLayout(R.layout.place_picker_test_layout_1, R.id.place_picker_fragment);
+            }
+        });
+
+        final PlacePickerFragment fragment = activity.getFragment();
+        assertNotNull(fragment);
+
+        assertEquals(false, fragment.getShowPictures());
+        assertEquals(75, fragment.getRadiusInMeters());
+        assertEquals(5, fragment.getResultsLimit());
+        assertEquals("coffee", fragment.getSearchText());
+        Collection<String> extraFields = fragment.getExtraFields();
+        assertTrue(extraFields.contains("checkins"));
+        assertTrue(extraFields.contains("general_info"));
+        // It doesn't make sense to specify location via layout, so we don't support it.
+    }
+
+    @LargeTest
+    public void testPlacesLoad() throws Throwable {
+        TestActivity activity = getActivity();
+        assertNotNull(activity);
+
+        // We don't auto-create any UI, so do it now. Needs to run on the UI thread.
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                getActivity().setContentToFragment(null);
+            }
+        });
+        getInstrumentation().waitForIdleSync();
+
+        final PlacePickerFragment fragment = activity.getFragment();
+        assertNotNull(fragment);
+
+        final TestSession session = openTestSessionWithSharedUser();
+
+        // Trigger a data load (on the UI thread).
+        final TestBlocker blocker = getTestBlocker();
+        runAndBlockOnUiThread(1, new Runnable() {
+            @Override
+            public void run() {
+                fragment.setSession(session);
+
+                Location location = new Location("");
+                location.setLatitude(47.6204);
+                location.setLongitude(-122.3491);
+                fragment.setLocation(location);
+
+                fragment.setOnDataChangedListener(new PickerFragment.OnDataChangedListener() {
+                    @Override
+                    public void onDataChanged() {
+                        blocker.signal();
+                    }
+                });
+                fragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
+                    @Override
+                    public void onError(FacebookException error) {
+                        fail("Got unexpected error: " + error.toString());
+                    }
+                });
+                fragment.loadData(true);
+            }
+        });
+
+        // We should have at least one item in the list by now.
+        ListView listView = (ListView) fragment.getView().findViewById(R.id.com_facebook_picker_list_view);
+        assertNotNull(listView);
+        View firstChild = listView.getChildAt(0);
+        assertNotNull(firstChild);
+
+        // Assert our state before we touch anything.
+        assertNull(fragment.getSelection());
+
+        // Click on the first item in the list view.
+        TouchUtils.clickView(this, firstChild);
+
+        // We should have a selection.
+        assertNotNull(fragment.getSelection());
+
+        // Touch the item again. We should go back to no selection.
+        TouchUtils.clickView(this, firstChild);
+        assertNull(fragment.getSelection());
+    }
+
+    @LargeTest
+    public void testClearsResultsWhenSessionClosed() throws Throwable {
+        TestActivity activity = getActivity();
+        assertNotNull(activity);
+
+        // We don't auto-create any UI, so do it now. Needs to run on the UI thread.
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                getActivity().setContentToFragment(null);
+            }
+        });
+        getInstrumentation().waitForIdleSync();
+
+        final PlacePickerFragment fragment = activity.getFragment();
+        assertNotNull(fragment);
+
+        final TestSession session = openTestSessionWithSharedUser();
+
+        // Trigger a data load (on the UI thread).
+        // We use multiple test blockers to keep the counts from getting confused if other events
+        // cause our listeners to fire.
+        final TestBlocker blocker1 = TestBlocker.createTestBlocker();
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                fragment.setSession(session);
+
+                Location location = new Location("");
+                location.setLatitude(47.6204);
+                location.setLongitude(-122.3491);
+                fragment.setLocation(location);
+
+                fragment.setOnDataChangedListener(new PickerFragment.OnDataChangedListener() {
+                    @Override
+                    public void onDataChanged() {
+                        blocker1.signal();
+                    }
+                });
+                fragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
+                    @Override
+                    public void onError(FacebookException error) {
+                        fail("Got unexpected error: " + error.getMessage());
+                    }
+                });
+                fragment.loadData(true);
+            }
+        });
+        blocker1.waitForSignals(1);
+
+        // We should have at least one item in the list by now.
+        ListView listView = (ListView) fragment.getView().findViewById(R.id.com_facebook_picker_list_view);
+        assertNotNull(listView);
+
+        Thread.sleep(500);
+
+        int lastPosition = listView.getLastVisiblePosition();
+        assertTrue(lastPosition > -1);
+
+        View firstChild = listView.getChildAt(0);
+        assertNotNull(firstChild);
+
+        // Assert our state before we touch anything.
+        assertNull(fragment.getSelection());
+
+        // Click on the first item in the list view.
+        TouchUtils.clickView(this, firstChild);
+
+        // We should have a selection.
+        assertNotNull(fragment.getSelection());
+
+        // To validate the behavior, we need to wait until the session state notifications have been processed.
+        // We run this on the UI thread but don't wait on the blocker until we've closed the session.
+        final TestBlocker blocker2 = TestBlocker.createTestBlocker();
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                session.addCallback(new Session.StatusCallback() {
+                    @Override
+                    public void call(Session session, SessionState state, Exception exception) {
+                        blocker2.signal();
+                    }
+                });
+            }
+        });
+        session.close();
+        // Wait for the notification and for any UI activity to stop.
+        blocker2.waitForSignals(1);
+        getInstrumentation().waitForIdleSync();
+
+        Thread.sleep(500);
+        // The list and the selection should have been cleared.
+        lastPosition = listView.getLastVisiblePosition();
+        assertTrue(lastPosition == -1);
+        assertNull(fragment.getSelection());
+    }
+
+    public static class TestActivity extends FragmentTestCase.TestFragmentActivity<PlacePickerFragment> {
+        public TestActivity() {
+            super(PlacePickerFragment.class);
+        }
+
+        @Override
+        protected boolean getAutoCreateUI() {
+            return false;
+        }
+    }
+
+}
diff --git a/facebook/tests/src/com/facebook/PrioritizedWorkQueueTests.java b/facebook/tests/src/com/facebook/PrioritizedWorkQueueTests.java
new file mode 100644
index 000000000..f39149082
--- /dev/null
+++ b/facebook/tests/src/com/facebook/PrioritizedWorkQueueTests.java
@@ -0,0 +1,341 @@
+package com.facebook;
+
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+
+import java.security.SecureRandom;
+import java.util.ArrayList;
+import java.util.concurrent.Executor;
+
+public class PrioritizedWorkQueueTests extends FacebookTestCase {
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testEmptyValidate() {
+        PrioritizedWorkQueue manager = new PrioritizedWorkQueue();
+        manager.validate();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testRunSomething() {
+        CountingRunnable run = new CountingRunnable();
+        assertEquals(0, run.getRunCount());
+
+        ScriptableExecutor executor = new ScriptableExecutor();
+        assertEquals(0, executor.getPendingCount());
+
+        PrioritizedWorkQueue manager = new PrioritizedWorkQueue(1, executor);
+
+        addActiveWorkItem(manager, run);
+        assertEquals(1, executor.getPendingCount());
+        assertEquals(0, run.getRunCount());
+
+        executeNext(manager, executor);
+        assertEquals(0, executor.getPendingCount());
+        assertEquals(1, run.getRunCount());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testRunSequence() {
+        final int workTotal = 100;
+
+        CountingRunnable run = new CountingRunnable();
+        ScriptableExecutor executor = new ScriptableExecutor();
+        PrioritizedWorkQueue manager = new PrioritizedWorkQueue(1, executor);
+
+        for (int i = 0; i < workTotal; i++) {
+            addActiveWorkItem(manager, run);
+            assertEquals(1, executor.getPendingCount());
+        }
+
+        for (int i = 0; i < workTotal; i++) {
+            assertEquals(1, executor.getPendingCount());
+            assertEquals(i, run.getRunCount());
+            executeNext(manager, executor);
+        }
+        assertEquals(0, executor.getPendingCount());
+        assertEquals(workTotal, run.getRunCount());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testRunParallel() {
+        final int workTotal = 100;
+
+        CountingRunnable run = new CountingRunnable();
+        ScriptableExecutor executor = new ScriptableExecutor();
+        PrioritizedWorkQueue manager = new PrioritizedWorkQueue(workTotal, executor);
+
+        for (int i = 0; i < workTotal; i++) {
+            assertEquals(i, executor.getPendingCount());
+            addActiveWorkItem(manager, run);
+        }
+
+        for (int i = 0; i < workTotal; i++) {
+            assertEquals(workTotal - i, executor.getPendingCount());
+            assertEquals(i, run.getRunCount());
+            executeNext(manager, executor);
+        }
+        assertEquals(0, executor.getPendingCount());
+        assertEquals(workTotal, run.getRunCount());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testSimpleCancel() {
+        CountingRunnable run = new CountingRunnable();
+        ScriptableExecutor executor = new ScriptableExecutor();
+        PrioritizedWorkQueue manager = new PrioritizedWorkQueue(1, executor);
+
+        addActiveWorkItem(manager, run);
+        PrioritizedWorkQueue.WorkItem work1 = addActiveWorkItem(manager, run);
+        cancelWork(manager, work1);
+
+        assertEquals(1, executor.getPendingCount());
+        executeNext(manager, executor);
+        assertEquals(0, executor.getPendingCount());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testPriority() {
+        final int firstCount = 8;
+        final int highCount = 17;
+
+        ArrayList<PrioritizedWorkQueue.WorkItem> highWorkItems = new ArrayList<PrioritizedWorkQueue.WorkItem>();
+        CountingRunnable highRun = new CountingRunnable();
+        CountingRunnable firstRun = new CountingRunnable();
+        CountingRunnable lowRun = new CountingRunnable();
+        ScriptableExecutor executor = new ScriptableExecutor();
+        PrioritizedWorkQueue manager = new PrioritizedWorkQueue(firstCount, executor);
+
+        for (int i = 0; i < firstCount; i++) {
+            addActiveWorkItem(manager, firstRun);
+        }
+
+        int lowCount = 0;
+        for (int h = 0; h < highCount; h++) {
+            highWorkItems.add(addActiveWorkItem(manager, highRun));
+            for (int l = 0; l < h; l++) {
+                addActiveWorkItem(manager, lowRun);
+                lowCount++;
+            }
+        }
+
+        assertEquals(firstCount, executor.getPendingCount());
+        backgroundAll(manager);
+        for (PrioritizedWorkQueue.WorkItem highItem : highWorkItems) {
+            int priority = setPriority(manager, highItem, PrioritizedWorkQueue.PRIORITY_ACTIVE);
+            assertEquals(priority, PrioritizedWorkQueue.PRIORITY_ACTIVE);
+        }
+
+        for (int i = 0; i < firstCount; i++) {
+            assertEquals(i, firstRun.getRunCount());
+            executeNext(manager, executor);
+        }
+
+        for (int i = 0; i < highCount; i++) {
+            assertEquals(i, highRun.getRunCount());
+            executeNext(manager, executor);
+        }
+
+        for (int i = 0; i < lowCount; i++) {
+            assertEquals(i, lowRun.getRunCount());
+            executeNext(manager, executor);
+        }
+
+        assertEquals(firstCount, firstRun.getRunCount());
+        assertEquals(highCount, highRun.getRunCount());
+        assertEquals(lowCount, lowRun.getRunCount());
+    }
+
+    // Test cancelling running work item, completed work item
+
+    @LargeTest
+    public void testThreadStress() {
+        PrioritizedWorkQueue manager = new PrioritizedWorkQueue();
+        ArrayList<StressRunnable> runnables = new ArrayList<StressRunnable>();
+        final int threadCount = 20;
+
+        for (int i = 0; i < threadCount; i++) {
+            runnables.add(new StressRunnable(manager, 20));
+        }
+
+        for (int i = 0; i < threadCount; i++) {
+            manager.addActiveWorkItem(runnables.get(i));
+        }
+
+        for (int i = 0; i < threadCount; i++) {
+            runnables.get(i).waitForDone();
+        }
+    }
+
+    private PrioritizedWorkQueue.WorkItem addActiveWorkItem(PrioritizedWorkQueue manager, Runnable runnable) {
+        manager.validate();
+        PrioritizedWorkQueue.WorkItem workItem = manager.addActiveWorkItem(runnable);
+        manager.validate();
+        return workItem;
+    }
+
+    private void executeNext(PrioritizedWorkQueue manager, ScriptableExecutor executor) {
+        manager.validate();
+        executor.runNext();
+        manager.validate();
+    }
+
+    private void cancelWork(PrioritizedWorkQueue manager, PrioritizedWorkQueue.WorkItem workItem) {
+        manager.validate();
+        workItem.cancel();
+        manager.validate();
+    }
+
+    private int setPriority(PrioritizedWorkQueue manager, PrioritizedWorkQueue.WorkItem workItem, int priority) {
+        manager.validate();
+        workItem.setPriority(priority);
+        manager.validate();
+        return workItem.getPriority();
+    }
+
+    private void backgroundAll(PrioritizedWorkQueue manager) {
+        manager.validate();
+        manager.backgroundAll();
+        manager.validate();
+    }
+
+    static class StressRunnable implements Runnable {
+        static ArrayList<PrioritizedWorkQueue.WorkItem> tracked = new ArrayList<PrioritizedWorkQueue.WorkItem>();
+
+        final PrioritizedWorkQueue manager;
+        final SecureRandom random = new SecureRandom();
+        final int iterationCount;
+        int iterationIndex = 0;
+        boolean isDone = false;
+
+        StressRunnable(PrioritizedWorkQueue manager, int iterationCount) {
+            this.manager = manager;
+            this.iterationCount = iterationCount;
+        }
+
+        @Override
+        public void run() {
+            // Each iteration runs a random action against the PrioritizedWorkQueue.
+            if (iterationIndex++ < iterationCount) {
+                final int sleepWeight = 80;
+                final int backgroundWeight = 10;
+                final int trackThisWeight = 3;
+                final int prioritizeTrackedWeight = 3;
+                final int validateWeight = 2;
+                int weight = 0;
+                final int n = random.nextInt(sleepWeight + backgroundWeight + trackThisWeight + prioritizeTrackedWeight + validateWeight);
+                PrioritizedWorkQueue.WorkItem workItem = manager.addActiveWorkItem(this);
+
+                if (n < (weight += sleepWeight)) {
+                    // Sleep
+                    try {
+                        Thread.sleep(n/4);
+                    } catch (InterruptedException e) {
+                    }
+                } else if (n < (weight += backgroundWeight)) {
+                    // Move this work item to be background
+                    workItem.setPriority(PrioritizedWorkQueue.PRIORITY_BACKGROUND);
+                } else if (n < (weight += trackThisWeight)) {
+                    // Track this work item to activate later
+                    synchronized (tracked) {
+                        tracked.add(workItem);
+                    }
+                } else if (n < (weight += prioritizeTrackedWeight)) {
+                    // Background all pending items, prioritize tracked items, and clear tracked list
+                    ArrayList<PrioritizedWorkQueue.WorkItem> items = new ArrayList<PrioritizedWorkQueue.WorkItem>();
+
+                    synchronized (tracked) {
+                        items.addAll(tracked);
+                        tracked.clear();
+                    }
+
+                    manager.backgroundAll();
+                    for (PrioritizedWorkQueue.WorkItem item : items) {
+                        item.setPriority(PrioritizedWorkQueue.PRIORITY_ACTIVE);
+                    }
+                } else {
+                    // Validate
+                    manager.validate();
+                }
+            } else {
+                // Also have all threads validate once they are done.
+                manager.validate();
+                synchronized (this) {
+                    isDone = true;
+                    this.notifyAll();
+                }
+            }
+        }
+
+        void waitForDone() {
+            synchronized (this) {
+                while (!isDone) {
+                    try {
+                        this.wait();
+                    } catch (InterruptedException e) {
+                    }
+                }
+            }
+        }
+    }
+
+    class ScriptableExecutor implements Executor {
+        private final ArrayList<Runnable> runnables = new ArrayList<Runnable>();
+
+        int getPendingCount() {
+            return runnables.size();
+        }
+
+        void runNext() {
+            assertTrue(runnables.size() > 0);
+            runnables.get(0).run();
+            runnables.remove(0);
+        }
+
+        void runLast() {
+            assertTrue(runnables.size() > 0);
+            int index = runnables.size() - 1;
+            runnables.get(index).run();
+            runnables.remove(index);
+        }
+
+        @Override
+        public void execute(Runnable runnable) {
+            synchronized (this) {
+                runnables.add(runnable);
+            }
+        }
+    }
+
+    class CountingRunnable implements Runnable {
+        volatile int runCount = 0;
+
+        int getRunCount() {
+            return runCount;
+        }
+
+        @Override
+        public void run() {
+            synchronized (this) {
+                runCount++;
+            }
+
+            try {
+                Thread.sleep(1);
+            } catch (InterruptedException e) {
+            }
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/RequestTests.java b/facebook/tests/src/com/facebook/RequestTests.java
new file mode 100644
index 000000000..f016ffe6c
--- /dev/null
+++ b/facebook/tests/src/com/facebook/RequestTests.java
@@ -0,0 +1,528 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.facebook;
+
+import android.graphics.Bitmap;
+import android.location.Location;
+import android.net.Uri;
+import android.os.Bundle;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class RequestTests extends FacebookTestCase {
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreateRequest() {
+        Request request = new Request();
+        assertTrue(request != null);
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreatePostRequest() {
+        GraphObject graphObject = GraphObjectWrapper.createGraphObject();
+        Request request = Request.newPostRequest(null, "me/statuses", graphObject, null);
+        assertTrue(request != null);
+        assertEquals(HttpMethod.POST, request.getHttpMethod());
+        assertEquals("me/statuses", request.getGraphPath());
+        assertEquals(graphObject, request.getGraphObject());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreateMeRequest() {
+        Request request = Request.newMeRequest(null, null);
+        assertTrue(request != null);
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+        assertEquals("me", request.getGraphPath());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreateMyFriendsRequest() {
+        Request request = Request.newMyFriendsRequest(null, null);
+        assertTrue(request != null);
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+        assertEquals("me/friends", request.getGraphPath());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreateUploadPhotoRequest() {
+        Bitmap image = Bitmap.createBitmap(128, 128, Bitmap.Config.ALPHA_8);
+
+        Request request = Request.newUploadPhotoRequest(null, image, null);
+        assertTrue(request != null);
+
+        Bundle parameters = request.getParameters();
+        assertTrue(parameters != null);
+
+        assertTrue(parameters.containsKey("picture"));
+        assertEquals(image, parameters.getParcelable("picture"));
+        assertEquals("me/photos", request.getGraphPath());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreatePlacesSearchRequest() {
+        Location location = new Location("");
+        location.setLatitude(47.6204);
+        location.setLongitude(-122.3491);
+
+        Request request = Request.newPlacesSearchRequest(null, location, 1000, 50, null, null);
+
+        assertTrue(request != null);
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+        assertEquals("search", request.getGraphPath());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreatePlacesSearchRequestRequiresLocationOrSearchText() {
+        try {
+            Request request = Request.newPlacesSearchRequest(null, null, 1000, 50, null, null);
+
+            assertTrue(request != null);
+            assertEquals(HttpMethod.GET, request.getHttpMethod());
+            assertEquals("search", request.getGraphPath());
+
+            fail("expected exception");
+        } catch (FacebookException exception) {
+            // Success
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreatePlacesSearchRequestRequiresLocation() {
+        try {
+            Request.newPlacesSearchRequest(null, null, 1000, 50, null, null);
+            fail("expected NullPointerException");
+        } catch (FacebookException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testSetHttpMethodToNilGivesDefault() {
+        Request request = new Request();
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+
+        request.setHttpMethod(null);
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testExecuteBatchWithNullRequestsThrows() {
+        try {
+            Request.executeBatchAndWait((Request[]) null);
+            fail("expected NullPointerException");
+        } catch (NullPointerException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testExecuteBatchWithZeroRequestsThrows() {
+        try {
+            Request.executeBatchAndWait(new Request[]{});
+            fail("expected IllegalArgumentException");
+        } catch (IllegalArgumentException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testExecuteBatchWithNullRequestThrows() {
+        try {
+            Request.executeBatchAndWait(new Request[]{null});
+            fail("expected NullPointerException");
+        } catch (NullPointerException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testToHttpConnectionWithNullRequestsThrows() {
+        try {
+            Request.toHttpConnection((Request[]) null);
+            fail("expected NullPointerException");
+        } catch (NullPointerException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testToHttpConnectionWithZeroRequestsThrows() {
+        try {
+            Request.toHttpConnection(new Request[]{});
+            fail("expected IllegalArgumentException");
+        } catch (IllegalArgumentException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testToHttpConnectionWithNullRequestThrows() {
+        try {
+            Request.toHttpConnection(new Request[]{null});
+            fail("expected NullPointerException");
+        } catch (NullPointerException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testSingleGetToHttpRequest() throws Exception {
+        Request requestMe = new Request(null, "TourEiffel");
+        HttpURLConnection connection = Request.toHttpConnection(requestMe);
+
+        assertTrue(connection != null);
+
+        assertEquals("GET", connection.getRequestMethod());
+        assertEquals("/TourEiffel", connection.getURL().getPath());
+
+        assertTrue(connection.getRequestProperty("User-Agent").startsWith("FBAndroidSDK"));
+
+        Uri uri = Uri.parse(connection.getURL().toString());
+        assertEquals("android", uri.getQueryParameter("sdk"));
+        assertEquals("json", uri.getQueryParameter("format"));
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecuteSingleGet() {
+        Request request = new Request(null, "TourEiffel");
+        Response response = request.executeAndWait();
+
+        assertTrue(response != null);
+        assertTrue(response.getError() == null);
+        assertTrue(response.getGraphObject() != null);
+
+        GraphPlace graphPlace = response.getGraphObjectAs(GraphPlace.class);
+        assertEquals("Paris", graphPlace.getLocation().getCity());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecuteSingleGetUsingHttpURLConnection() throws IOException {
+        Request request = new Request(null, "TourEiffel");
+        HttpURLConnection connection = Request.toHttpConnection(request);
+
+        List<Response> responses = Request.executeConnectionAndWait(connection, Arrays.asList(new Request[]{request}));
+        assertNotNull(responses);
+        assertEquals(1, responses.size());
+
+        Response response = responses.get(0);
+
+        assertTrue(response != null);
+        assertTrue(response.getError() == null);
+        assertTrue(response.getGraphObject() != null);
+
+        GraphPlace graphPlace = response.getGraphObjectAs(GraphPlace.class);
+        assertEquals("Paris", graphPlace.getLocation().getCity());
+
+        // Make sure calling code can still access HTTP headers and call disconnect themselves.
+        int code = connection.getResponseCode();
+        assertEquals(200, code);
+        assertTrue(connection.getHeaderFields().keySet().contains("Content-Length"));
+        connection.disconnect();
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testFacebookErrorResponseCreatesError() {
+        Request request = new Request(null, "somestringthatshouldneverbeavalidfobjectid");
+        Response response = request.executeAndWait();
+
+        assertTrue(response != null);
+
+        FacebookException exception = response.getError();
+        assertTrue(exception != null);
+
+        assertTrue(exception instanceof FacebookServiceErrorException);
+        FacebookServiceErrorException serviceException = (FacebookServiceErrorException) exception;
+        assertTrue(serviceException.getFacebookErrorType() != null);
+        assertTrue(serviceException.getFacebookErrorCode() != FacebookServiceErrorException.UNKNOWN_ERROR_CODE);
+        assertTrue(serviceException.getResponseBody() != null);
+    }
+
+    @LargeTest
+    public void testFacebookSuccessResponseWithErrorCodeCreatesError() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request request = Request.newRestRequest(session, "auth.extendSSOAccessToken", null, null);
+        assertNotNull(request);
+
+        // Because TestSession access tokens were not created via SSO, we expect to get an error from the service,
+        // but with a 200 (success) code.
+        Response response = request.executeAndWait();
+
+        assertTrue(response != null);
+
+        FacebookException exception = response.getError();
+        assertTrue(exception != null);
+
+        assertTrue(exception instanceof FacebookServiceErrorException);
+        FacebookServiceErrorException serviceException = (FacebookServiceErrorException) exception;
+        assertTrue(serviceException.getFacebookErrorCode() != FacebookServiceErrorException.UNKNOWN_ERROR_CODE);
+        assertTrue(serviceException.getResponseBody() != null);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testRequestWithUnopenedSessionFails() {
+        TestSession session = getTestSessionWithSharedUser(null);
+        Request request = new Request(session, "me");
+        Response response = request.executeAndWait();
+
+        FacebookException exception = response.getError();
+        assertNotNull(exception);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecuteRequestMe() {
+        TestSession session = openTestSessionWithSharedUser();
+        Request request = Request.newMeRequest(session, null);
+        Response response = request.executeAndWait();
+
+        validateMeResponse(session, response);
+    }
+
+    static void validateMeResponse(TestSession session, Response response) {
+        FacebookException exception = response.getError();
+        assertNull(exception);
+
+        GraphUser me = response.getGraphObjectAs(GraphUser.class);
+        assertNotNull(me);
+        assertEquals(session.getTestUserId(), me.getId());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecuteMyFriendsRequest() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request request = Request.newMyFriendsRequest(session, null);
+        Response response = request.executeAndWait();
+
+        validateMyFriendsResponse(session, response);
+    }
+
+    static void validateMyFriendsResponse(TestSession session, Response response) {
+        assertNotNull(response);
+
+        assertNull(response.getError());
+
+        GraphMultiResult graphResult = response.getGraphObjectAs(GraphMultiResult.class);
+        assertNotNull(graphResult);
+
+        List<GraphObject> results = graphResult.getData();
+        assertNotNull(results);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecutePlaceRequest() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Location location = new Location("");
+        location.setLatitude(47.6204);
+        location.setLongitude(-122.3491);
+
+        Request request = Request.newPlacesSearchRequest(session, location, 5, 5, null, null);
+        Response response = request.executeAndWait();
+        assertNotNull(response);
+
+        assertNull(response.getError());
+
+        GraphMultiResult graphResult = response.getGraphObjectAs(GraphMultiResult.class);
+        assertNotNull(graphResult);
+
+        List<GraphObject> results = graphResult.getData();
+        assertNotNull(results);
+    }
+
+    @LargeTest
+    public void testExecuteUploadPhoto() {
+        TestSession session = openTestSessionWithSharedUser();
+        Bitmap image = createTestBitmap(128);
+
+        Request request = Request.newUploadPhotoRequest(session, image, null);
+        Response response = request.executeAndWait();
+        assertNotNull(response);
+
+        Exception exception = response.getError();
+        assertNull(exception);
+
+        GraphObject result = response.getGraphObject();
+        assertNotNull(result);
+    }
+
+    @LargeTest
+    public void testExecuteUploadPhotoViaFile() throws IOException {
+        File outputFile = null;
+        FileOutputStream outStream = null;
+
+        try {
+            TestSession session = openTestSessionWithSharedUser();
+            Bitmap image = createTestBitmap(128);
+
+            File outputDir = getActivity().getCacheDir(); // context being the Activity pointer
+            outputFile = File.createTempFile("prefix", "extension", outputDir);
+
+            outStream = new FileOutputStream(outputFile);
+            image.compress(Bitmap.CompressFormat.PNG, 100, outStream);
+            outStream.close();
+            outStream = null;
+
+            Request request = Request.newUploadPhotoRequest(session, outputFile, null);
+            Response response = request.executeAndWait();
+            assertNotNull(response);
+
+            Exception exception = response.getError();
+            assertNull(exception);
+
+            GraphObject result = response.getGraphObject();
+            assertNotNull(result);
+        } finally {
+            if (outStream != null) {
+                outStream.close();;
+            }
+            if (outputFile != null) {
+                outputFile.delete();
+            }
+        }
+    }
+
+    @LargeTest
+    public void testPostStatusUpdate() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        GraphObject statusUpdate = createStatusUpdate();
+
+        GraphObject retrievedStatusUpdate = postGetAndAssert(session, "me/feed", statusUpdate);
+
+        assertEquals(statusUpdate.getProperty("message"), retrievedStatusUpdate.getProperty("message"));
+    }
+
+    @LargeTest
+    public void testRestMethodGetUser() {
+        TestSession session = openTestSessionWithSharedUser();
+        String testUserId = session.getTestUserId();
+
+        Bundle parameters = new Bundle();
+        parameters.putString("uids", testUserId);
+        parameters.putString("fields", "uid,name");
+
+        Request request = Request.newRestRequest(session, "users.getInfo", parameters, null);
+        Response response = request.executeAndWait();
+        assertNotNull(response);
+
+        GraphObjectList<GraphObject> graphObjects = response.getGraphObjectList();
+        assertNotNull(graphObjects);
+        assertEquals(1, graphObjects.size());
+
+        GraphObject user = graphObjects.get(0);
+        assertNotNull(user);
+        assertEquals(testUserId, user.getProperty("uid").toString());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCallbackIsCalled() {
+        Request request = new Request(null, "4");
+
+        final ArrayList<Boolean> calledBack = new ArrayList<Boolean>();
+        request.setCallback(new Request.Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                calledBack.add(true);
+            }
+        });
+
+        Response response = request.executeAndWait();
+        assertNotNull(response);
+        assertTrue(calledBack.size() == 1);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testBatchTimeoutIsApplied() {
+        Request request = new Request(null, "me");
+        RequestBatch batch = new RequestBatch(request);
+
+        // We assume 1 ms is short enough to fail
+        batch.setTimeout(1);
+
+        List<Response> responses = Request.executeBatchAndWait(batch);
+        assertNotNull(responses);
+        assertTrue(responses.size() == 1);
+        Response response = responses.get(0);
+        assertNotNull(response);
+        assertNotNull(response.getError());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testBatchTimeoutCantBeNegative() {
+        try {
+            RequestBatch batch = new RequestBatch();
+            batch.setTimeout(-1);
+            fail();
+        } catch (IllegalArgumentException ex) {
+        }
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCantSetBothGraphPathAndRestMethod() {
+        Request request = new Request();
+        request.setGraphPath("me");
+        request.setRestMethod("amethod");
+        request.setCallback(new ExpectFailureCallback());
+        request.executeAndWait();
+    }
+}
diff --git a/facebook/tests/src/com/facebook/SessionTests.java b/facebook/tests/src/com/facebook/SessionTests.java
new file mode 100644
index 000000000..53b864ac9
--- /dev/null
+++ b/facebook/tests/src/com/facebook/SessionTests.java
@@ -0,0 +1,615 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.IntentFilter;
+import android.support.v4.content.LocalBroadcastManager;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+
+public class SessionTests extends SessionTestsBase {
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testFailNullArguments() {
+        try {
+            new Session(null);
+
+            // Should not get here
+            assertFalse(true);
+        } catch (NullPointerException e) {
+            // got expected exception
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testActiveSessionChangeRegistration() {
+        final WaitForBroadcastReceiver receiver0 = new WaitForBroadcastReceiver();
+        final WaitForBroadcastReceiver receiver1 = new WaitForBroadcastReceiver();
+        final WaitForBroadcastReceiver receiver2 = new WaitForBroadcastReceiver();
+        final LocalBroadcastManager broadcastManager = LocalBroadcastManager.getInstance(getActivity());
+
+        try {
+            // Register these on the blocker thread so they will send
+            // notifications there as well. The notifications need to be on a
+            // different thread than the progress.
+            Runnable initialize0 = new Runnable() {
+                @Override
+                public void run() {
+                    broadcastManager.registerReceiver(receiver0, getActiveSessionAllFilter());
+
+                    broadcastManager.registerReceiver(receiver1,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_SET));
+                    broadcastManager.registerReceiver(receiver1,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
+                    broadcastManager.registerReceiver(receiver1,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_CLOSED));
+
+                    broadcastManager.registerReceiver(receiver2,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
+                    broadcastManager.registerReceiver(receiver2,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_CLOSED));
+                }
+            };
+            runOnBlockerThread(initialize0, true);
+
+            // Verify all actions show up where they are expected
+            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver1, receiver2);
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
+            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver1, receiver2);
+
+            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver1, receiver2);
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_CLOSED);
+            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver1, receiver2);
+
+            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver1);
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_SET);
+            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver1);
+
+            receiver0.incrementExpectCount();
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_UNSET);
+            receiver0.waitForExpectedCalls();
+
+            // Remove receiver1 and verify actions continue to show up where
+            // expected
+            broadcastManager.unregisterReceiver(receiver1);
+
+            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver2);
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
+            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver2);
+
+            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver2);
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_CLOSED);
+            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver2);
+
+            receiver0.incrementExpectCount();
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_SET);
+            receiver0.waitForExpectedCalls();
+
+            receiver0.incrementExpectCount();
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_UNSET);
+            receiver0.waitForExpectedCalls();
+
+            // Remove receiver0 and register receiver1 multiple times for one
+            // action
+            broadcastManager.unregisterReceiver(receiver0);
+
+            Runnable initialize1 = new Runnable() {
+                @Override
+                public void run() {
+                    broadcastManager.registerReceiver(receiver1,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
+                    broadcastManager.registerReceiver(receiver1,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
+                    broadcastManager.registerReceiver(receiver1,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
+                }
+            };
+            runOnBlockerThread(initialize1, true);
+
+            receiver1.incrementExpectCount(3);
+            receiver2.incrementExpectCount();
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
+            receiver1.waitForExpectedCalls();
+            receiver2.waitForExpectedCalls();
+
+            receiver2.incrementExpectCount();
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_CLOSED);
+            receiver2.waitForExpectedCalls();
+
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_SET);
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_UNSET);
+
+            closeBlockerAndAssertSuccess();
+        } finally {
+            broadcastManager.unregisterReceiver(receiver0);
+            broadcastManager.unregisterReceiver(receiver1);
+            broadcastManager.unregisterReceiver(receiver2);
+            Session.setActiveSession(null);
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testSetActiveSession() {
+        Session.setActiveSession(null);
+
+        final WaitForBroadcastReceiver receiverOpened = new WaitForBroadcastReceiver();
+        final WaitForBroadcastReceiver receiverClosed = new WaitForBroadcastReceiver();
+        final WaitForBroadcastReceiver receiverSet = new WaitForBroadcastReceiver();
+        final WaitForBroadcastReceiver receiverUnset = new WaitForBroadcastReceiver();
+        final LocalBroadcastManager broadcastManager = LocalBroadcastManager.getInstance(getActivity());
+        
+        try {
+            Runnable initializeOnBlockerThread = new Runnable() {
+                @Override
+                public void run() {
+                    broadcastManager.registerReceiver(receiverOpened,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
+                    broadcastManager.registerReceiver(receiverClosed,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_CLOSED));
+                    broadcastManager.registerReceiver(receiverSet,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_SET));
+                    broadcastManager.registerReceiver(receiverUnset,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_UNSET));
+                }
+            };
+            runOnBlockerThread(initializeOnBlockerThread, true);
+
+            // null -> null should not fire events
+            assertEquals(null, Session.getActiveSession());
+            Session.setActiveSession(null);
+            assertEquals(null, Session.getActiveSession());
+
+            Session session0 = new Session.Builder(getActivity()).
+                    setApplicationId("FakeAppId").
+                    setTokenCache(new MockTokenCache()).
+                    build();
+            assertEquals(SessionState.CREATED_TOKEN_LOADED, session0.getState());
+
+            // For unopened session, we should only see the Set event.
+            receiverSet.incrementExpectCount();
+            Session.setActiveSession(session0);
+            assertEquals(session0, Session.getActiveSession());
+            receiverSet.waitForExpectedCalls();
+
+            // When we open it, then we should see the Opened event.
+            receiverOpened.incrementExpectCount();
+            session0.open();
+            receiverOpened.waitForExpectedCalls();
+
+            // Setting to itself should not fire events
+            Session.setActiveSession(session0);
+            assertEquals(session0, Session.getActiveSession());
+
+            // Setting from one opened session to another should deliver a full
+            // cycle of events
+            WaitForBroadcastReceiver.incrementExpectCounts(receiverClosed, receiverUnset, receiverSet, receiverOpened);
+            Session session1 = new Session.Builder(getActivity()).
+                    setApplicationId("FakeAppId").
+                    setTokenCache(new MockTokenCache()).
+                    build();
+            assertEquals(SessionState.CREATED_TOKEN_LOADED, session1.getState());
+            session1.open();
+            assertEquals(SessionState.OPENED, session1.getState());
+            Session.setActiveSession(session1);
+            WaitForBroadcastReceiver.waitForExpectedCalls(receiverClosed, receiverUnset, receiverSet, receiverOpened);
+            assertEquals(SessionState.CLOSED, session0.getState());
+            assertEquals(session1, Session.getActiveSession());
+
+            closeBlockerAndAssertSuccess();
+        } finally {
+            broadcastManager.unregisterReceiver(receiverOpened);
+            broadcastManager.unregisterReceiver(receiverClosed);
+            broadcastManager.unregisterReceiver(receiverSet);
+            broadcastManager.unregisterReceiver(receiverUnset);
+            Session.setActiveSession(null);
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenSuccess() {
+        ArrayList<String> permissions = new ArrayList<String>();
+        MockTokenCache cache = new MockTokenCache(null, 0);
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+        AccessToken openToken = AccessToken.createFromString("A token of thanks", permissions);
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        session.addAuthorizeResult(openToken);
+        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        verifySessionHasToken(session, openToken);
+
+        // Verify we get a close callback.
+        session.close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Verify we saved the token to cache.
+        assertTrue(cache.getSavedState() != null);
+        assertEquals(openToken.getToken(), TokenCache.getToken(cache.getSavedState()));
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+     @MediumTest
+     @LargeTest
+     public void testOpenForPublishSuccess() {
+        ArrayList<String> permissions = new ArrayList<String>();
+        MockTokenCache cache = new MockTokenCache(null, 0);
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+        AccessToken openToken = AccessToken.createFromString("A token of thanks", permissions);
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        session.addAuthorizeResult(openToken);
+        session.openForPublish(new Session.OpenRequest(getActivity()).setCallback(statusRecorder).
+                setPermissions(Arrays.asList(new String[] {
+                        "publish_something",
+                        "manage_something",
+                        "ads_management",
+                        "create_event",
+                        "rsvp_event"
+                })));
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        verifySessionHasToken(session, openToken);
+
+        // Verify we get a close callback.
+        session.close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Verify we saved the token to cache.
+        assertTrue(cache.getSavedState() != null);
+        assertEquals(openToken.getToken(), TokenCache.getToken(cache.getSavedState()));
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenForPublishSuccessWithReadPermissions() {
+        ArrayList<String> permissions = new ArrayList<String>();
+        MockTokenCache cache = new MockTokenCache(null, 0);
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+        AccessToken openToken = AccessToken.createFromString("A token of thanks", permissions);
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        session.addAuthorizeResult(openToken);
+        session.openForPublish(new Session.OpenRequest(getActivity()).setCallback(statusRecorder).
+                setPermissions(Arrays.asList(new String[] {
+                        "publish_something",
+                        "manage_something",
+                        "ads_management",
+                        "create_event",
+                        "rsvp_event",
+                        "read_something"
+                })));
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        verifySessionHasToken(session, openToken);
+
+        // Verify we get a close callback.
+        session.close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Verify we saved the token to cache.
+        assertTrue(cache.getSavedState() != null);
+        assertEquals(openToken.getToken(), TokenCache.getToken(cache.getSavedState()));
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenFromTokenCache() {
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        String token = "A token less unique than most";
+        MockTokenCache cache = new MockTokenCache(token, DEFAULT_TIMEOUT_MILLISECONDS);
+        ScriptedSession session = createScriptedSessionOnBlockerThread("app-id", cache);
+
+        // Verify state when we have a token in cache.
+        assertEquals(SessionState.CREATED_TOKEN_LOADED, session.getState());
+
+        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
+
+        // Verify we open with no authorize call.
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        // Verify no token information is saved.
+        assertTrue(cache.getSavedState() == null);
+
+        // Verify we get a close callback.
+        session.close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenActiveFromEmptyTokenCache() {
+        assertNull(Session.openActiveSession(getActivity(), false));
+    }
+
+
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenFailure() {
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        MockTokenCache cache = new MockTokenCache(null, 0);
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+        Exception openException = new Exception();
+
+        session.addAuthorizeResult(openException);
+        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+
+        // Verify we get the expected exception and no saved state.
+        statusRecorder.waitForCall(session, SessionState.CLOSED_LOGIN_FAILED, openException);
+        assertTrue(cache.getSavedState() == null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenForReadFailure() {
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        MockTokenCache cache = new MockTokenCache(null, 0);
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+
+        try {
+            session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder).
+                    setPermissions(Arrays.asList(new String[] {"publish_something"})));
+            fail("should not reach here without an exception");
+        } catch (FacebookException e) {
+            assertTrue(e.getMessage().contains("Cannot pass a publish permission"));
+        } finally {
+            stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+            statusRecorder.close();
+        }
+    }
+
+
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testReauthorizeSuccess() {
+        ArrayList<String> permissions = new ArrayList<String>();
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        MockTokenCache cache = new MockTokenCache(null, 0);
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+
+        // Session.open
+        final AccessToken openToken = AccessToken.createFromString("Allows playing outside", permissions);
+        permissions.add("play_outside");
+
+        session.addAuthorizeResult(openToken);
+        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        verifySessionHasToken(session, openToken);
+        assertTrue(cache.getSavedState() != null);
+        assertEquals(openToken.getToken(), TokenCache.getToken(cache.getSavedState()));
+
+        // Successful Session.reauthorize with new permissions
+        final AccessToken reauthorizeToken = AccessToken.createFromString(
+                "Allows playing outside and eating ice cream", permissions);
+        permissions.add("eat_ice_cream");
+
+        session.addAuthorizeResult(reauthorizeToken);
+        session.reauthorizeForRead(new Session.ReauthorizeRequest(getActivity(), permissions));
+        statusRecorder.waitForCall(session, SessionState.OPENED_TOKEN_UPDATED, null);
+
+        verifySessionHasToken(session, reauthorizeToken);
+        assertTrue(cache.getSavedState() != null);
+        assertEquals(reauthorizeToken.getToken(), TokenCache.getToken(cache.getSavedState()));
+
+        // Failing reauthorization with new permissions
+        final Exception reauthorizeException = new Exception("Don't run with scissors");
+        permissions.add("run_with_scissors");
+
+        session.addAuthorizeResult(reauthorizeException);
+        session.reauthorizeForRead(new Session.ReauthorizeRequest(getActivity(), permissions));
+        statusRecorder.waitForCall(session, SessionState.OPENED_TOKEN_UPDATED, reauthorizeException);
+
+        // Verify we do not overwrite cache if reauthorize fails
+        assertTrue(cache.getSavedState() != null);
+        assertEquals(reauthorizeToken.getToken(), TokenCache.getToken(cache.getSavedState()));
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorders.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testReauthorizeForPublishSuccess() {
+        ArrayList<String> permissions = new ArrayList<String>();
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        MockTokenCache cache = new MockTokenCache(null, 0);
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+
+        // Session.open
+        final AccessToken openToken = AccessToken.createFromString("Allows playing outside", permissions);
+        permissions.add("play_outside");
+
+        session.addAuthorizeResult(openToken);
+        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        verifySessionHasToken(session, openToken);
+        assertTrue(cache.getSavedState() != null);
+        assertEquals(openToken.getToken(), TokenCache.getToken(cache.getSavedState()));
+
+        // Successful Session.reauthorize with new permissions
+        final AccessToken reauthorizeToken = AccessToken.createFromString(
+                "Allows playing outside and publish eating ice cream", permissions);
+        permissions.add("publish_eat_ice_cream");
+
+        session.addAuthorizeResult(reauthorizeToken);
+        session.reauthorizeForPublish(new Session.ReauthorizeRequest(getActivity(), permissions));
+        statusRecorder.waitForCall(session, SessionState.OPENED_TOKEN_UPDATED, null);
+
+        verifySessionHasToken(session, reauthorizeToken);
+        assertTrue(cache.getSavedState() != null);
+        assertEquals(reauthorizeToken.getToken(), TokenCache.getToken(cache.getSavedState()));
+
+        // Failing reauthorization with publish permissions on a read request
+        permissions.add("publish_run_with_scissors");
+
+        try {
+            session.reauthorizeForRead(new Session.ReauthorizeRequest(getActivity(), permissions));
+            fail("Should not reach here without an exception");
+        } catch (FacebookException e) {
+            assertTrue(e.getMessage().contains("Cannot pass a publish permission"));
+        } finally {
+            stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+            statusRecorder.close();
+        }
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testSessionWillExtendTokenIfNeeded() {
+        TestSession session = openTestSessionWithSharedUser();
+        session.forceExtendAccessToken(true);
+
+        Request request = Request.newMeRequest(session, null);
+        request.executeAndWait();
+
+        assertTrue(session.getWasAskedToExtendAccessToken());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testSessionWillNotExtendTokenIfCurrentlyAttempting() {
+        TestSession session = openTestSessionWithSharedUser();
+        session.forceExtendAccessToken(true);
+        session.fakeTokenRefreshAttempt();
+
+        Request request = Request.newMeRequest(session, null);
+        request.executeAndWait();
+        assertFalse(session.getWasAskedToExtendAccessToken());
+    }
+
+    
+    @LargeTest
+    public void testBasicSerialization() throws IOException, ClassNotFoundException {
+        // Try to test the happy path, that there are no unserializable fields
+        // in the session.
+        Session session0 = new Session.Builder(getActivity()).setApplicationId("fakeID").
+                setShouldAutoPublishInstall(false).build();
+        Session session1 = TestUtils.serializeAndUnserialize(session0);
+        
+        // do some basic assertions
+        assertNotNull(session0.getAccessToken());
+        assertEquals(session0, session1);
+
+        Session.AuthorizationRequest authRequest0 =
+                new Session.OpenRequest(getActivity()).
+                        setRequestCode(123).
+                        setLoginBehavior(SessionLoginBehavior.SSO_ONLY);
+        Session.AuthorizationRequest authRequest1 = TestUtils.serializeAndUnserialize(authRequest0);
+
+        assertEquals(authRequest0.getLoginBehavior(), authRequest1.getLoginBehavior());
+        assertEquals(authRequest0.getRequestCode(), authRequest1.getRequestCode());
+    }
+    
+    static IntentFilter getActiveSessionFilter(String... actions) {
+        IntentFilter filter = new IntentFilter();
+
+        for (String action : actions) {
+            filter.addAction(action);
+        }
+
+        return filter;
+    }
+
+    static IntentFilter getActiveSessionAllFilter() {
+        return getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_CLOSED, Session.ACTION_ACTIVE_SESSION_OPENED,
+                Session.ACTION_ACTIVE_SESSION_SET, Session.ACTION_ACTIVE_SESSION_UNSET);
+    }
+
+    private void verifySessionHasToken(Session session, AccessToken token) {
+        assertEquals(token.getToken(), session.getAccessToken());
+        assertEquals(token.getExpires(), session.getExpirationDate());
+        assertEquals(token.getPermissions(), session.getPermissions());
+    }
+}
diff --git a/facebook/tests/src/com/facebook/SessionTestsBase.java b/facebook/tests/src/com/facebook/SessionTestsBase.java
new file mode 100644
index 000000000..d6b0d970a
--- /dev/null
+++ b/facebook/tests/src/com/facebook/SessionTestsBase.java
@@ -0,0 +1,263 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.os.ConditionVariable;
+import android.os.Looper;
+
+import java.util.LinkedList;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+
+public class SessionTestsBase extends FacebookTestCase {
+    static final int DEFAULT_TIMEOUT_MILLISECONDS = 10 * 1000;
+    static final int SIMULATED_WORKING_MILLISECONDS = 20;
+    static final int STRAY_CALLBACK_WAIT_MILLISECONDS = 50;
+    
+    ScriptedSession createScriptedSessionOnBlockerThread(TokenCache cache) {
+        return createScriptedSessionOnBlockerThread("SomeApplicationId", cache);
+    }
+
+    ScriptedSession createScriptedSessionOnBlockerThread(final String applicationId,
+            final TokenCache cache) {
+        class MutableState {
+            ScriptedSession session;
+        }
+        ;
+        final MutableState mutable = new MutableState();
+
+        runOnBlockerThread(new Runnable() {
+            @Override
+            public void run() {
+                mutable.session = new ScriptedSession(getActivity(), applicationId, cache);
+            }
+        }, true);
+
+        return mutable.session;
+    }
+
+    static void stall(int stallMsec) {
+        try {
+            Thread.sleep(stallMsec);
+        } catch (InterruptedException e) {
+            fail("InterruptedException while stalling");
+        }
+    }
+
+    static class ScriptedSession extends Session {
+        private static final long serialVersionUID = 1L;
+        private final LinkedList<AuthorizeResult> pendingAuthorizations = new LinkedList<AuthorizeResult>();
+
+        ScriptedSession(Context currentContext, String applicationId, TokenCache tokenCache) {
+            super(currentContext, applicationId, tokenCache, false);
+        }
+
+        public void addAuthorizeResult(AccessToken token) {
+            pendingAuthorizations.add(new AuthorizeResult(token));
+        }
+
+        public void addAuthorizeResult(Exception exception) {
+            pendingAuthorizations.add(new AuthorizeResult(exception));
+        }
+
+        // Overrides authorize to return the next AuthorizeResult we added.
+        @Override
+        void authorize(final AuthorizationRequest request) {
+            Settings.getExecutor().execute(new Runnable() {
+                @Override
+                public void run() {
+                    stall(SIMULATED_WORKING_MILLISECONDS);
+                    AuthorizeResult result = pendingAuthorizations.poll();
+
+                    if (result == null) {
+                        fail("Missing call to addScriptedAuthorization");
+                    }
+
+                    finishAuth(result.token, result.exception);
+                }
+            });
+        }
+
+        private static class AuthorizeResult {
+            final AccessToken token;
+            final Exception exception;
+
+            private AuthorizeResult(AccessToken token, Exception exception) {
+                this.token = token;
+                this.exception = exception;
+            }
+
+            AuthorizeResult(AccessToken token) {
+                this(token, null);
+            }
+
+            AuthorizeResult(Exception exception) {
+                this(null, exception);
+            }
+        }
+    }
+
+    static class SessionStatusCallbackRecorder implements Session.StatusCallback {
+        private final BlockingQueue<Call> calls = new LinkedBlockingQueue<Call>();
+        volatile boolean isClosed = false;
+
+        void waitForCall(Session session, SessionState state, Exception exception) {
+            Call call = null;
+
+            try {
+                call = calls.poll(DEFAULT_TIMEOUT_MILLISECONDS, TimeUnit.MILLISECONDS);
+                if (call == null) {
+                    fail("Did not get a status callback within timeout.");
+                }
+            } catch (InterruptedException e) {
+                fail("InterruptedException while waiting for status callback: " + e);
+            }
+
+            assertEquals(session, call.session);
+            assertEquals(state, call.state);
+            assertEquals(exception, call.exception);
+        }
+
+        void close() {
+            isClosed = true;
+            assertEquals(0, calls.size());
+        }
+
+        @Override
+        public void call(Session session, SessionState state, Exception exception) {
+            Call call = new Call(session, state, exception);
+            if (!calls.offer(call)) {
+                fail("Test Error: Blocking queue ran out of capacity");
+            }
+            if (isClosed) {
+                fail("Reauthorize callback called after closed");
+            }
+            assertEquals("Callback should run on main UI thread", Thread.currentThread(), 
+                    Looper.getMainLooper().getThread());
+        }
+
+        private static class Call {
+            final Session session;
+            final SessionState state;
+            final Exception exception;
+
+            Call(Session session, SessionState state, Exception exception) {
+                this.session = session;
+                this.state = state;
+                this.exception = exception;
+            }
+        }
+
+    }
+
+    static class MockTokenCache extends TokenCache {
+        private final String token;
+        private final long expires_in;
+        private Bundle saved;
+
+        MockTokenCache() {
+            this("FakeToken", DEFAULT_TIMEOUT_MILLISECONDS);
+        }
+
+        MockTokenCache(String token, long expires_in) {
+            this.token = token;
+            this.expires_in = expires_in;
+            this.saved = null;
+        }
+
+        Bundle getSavedState() {
+            return saved;
+        }
+
+        @Override
+        public Bundle load() {
+            Bundle bundle = null;
+
+            if (token != null) {
+                bundle = new Bundle();
+
+                TokenCache.putToken(bundle, token);
+                TokenCache.putExpirationMilliseconds(bundle, System.currentTimeMillis() + expires_in);
+            }
+
+            return bundle;
+        }
+
+        @Override
+        public void save(Bundle bundle) {
+            this.saved = bundle;
+        }
+
+        @Override
+        public void clear() {
+            this.saved = null;
+        }
+    }
+
+    static class WaitForBroadcastReceiver extends BroadcastReceiver {
+        static int idGenerator = 0;
+        final int id = idGenerator++;
+
+        ConditionVariable condition = new ConditionVariable(true);
+        int expectCount;
+        int actualCount;
+
+        public void incrementExpectCount() {
+            incrementExpectCount(1);
+        }
+
+        public void incrementExpectCount(int n) {
+            expectCount += n;
+            if (actualCount < expectCount) {
+                condition.close();
+            }
+        }
+
+        public void waitForExpectedCalls() {
+            if (!condition.block(DEFAULT_TIMEOUT_MILLISECONDS)) {
+                assertTrue(false);
+            }
+        }
+
+        public static void incrementExpectCounts(WaitForBroadcastReceiver... receivers) {
+            for (WaitForBroadcastReceiver receiver : receivers) {
+                receiver.incrementExpectCount();
+            }
+        }
+
+        public static void waitForExpectedCalls(WaitForBroadcastReceiver... receivers) {
+            for (WaitForBroadcastReceiver receiver : receivers) {
+                receiver.waitForExpectedCalls();
+            }
+        }
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (++actualCount == expectCount) {
+                condition.open();
+            }
+            assertTrue(actualCount <= expectCount);
+            assertEquals("BroadcastReceiver should receive on main UI thread",
+                    Thread.currentThread(), Looper.getMainLooper().getThread());
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/SessionTrackerTests.java b/facebook/tests/src/com/facebook/SessionTrackerTests.java
new file mode 100644
index 000000000..561e617cd
--- /dev/null
+++ b/facebook/tests/src/com/facebook/SessionTrackerTests.java
@@ -0,0 +1,189 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+
+import java.util.Collections;
+
+public class SessionTrackerTests extends SessionTestsBase {
+
+    private static final String TOKEN_STR = "A token of thanks";
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    // Tests the SessionDelegate while tracking the active session
+    public void testDelegateWithActiveSession() throws Exception {
+        Session.setActiveSession(null);
+        final SessionStatusCallbackRecorder statusRecorder = 
+                new SessionStatusCallbackRecorder();
+        final MockTokenCache cache = new MockTokenCache(null, 0);
+        final ScriptedSession session = 
+                createScriptedSessionOnBlockerThread(cache);
+
+        final AccessToken openToken = AccessToken.createFromString(TOKEN_STR, 
+                Collections.<String>emptyList());
+        session.addAuthorizeResult(openToken);
+
+        final SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder);
+        Session.setActiveSession(session); 
+        
+        session.openForRead(getActivity());
+        
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+        assertNotNull("Session should be open", tracker.getOpenSession());
+        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
+        tracker.getOpenSession().close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+        
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        tracker.stopTracking();
+        statusRecorder.close();
+    }
+    
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    // Tests the SessionDelegate while tracking a passed in session from the constructor
+    public void testDelegateWithSessionInConstructor() throws Exception {
+        final SessionStatusCallbackRecorder statusRecorder = 
+                new SessionStatusCallbackRecorder();
+        final MockTokenCache cache = new MockTokenCache(null, 0);
+        final ScriptedSession session = 
+                createScriptedSessionOnBlockerThread(cache);
+
+        final AccessToken openToken = AccessToken.createFromString(TOKEN_STR, 
+                Collections.<String>emptyList());
+        session.addAuthorizeResult(openToken);
+
+        SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder, session);
+        
+        session.openForRead(getActivity());
+        
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+        assertNotNull("Session should be open", tracker.getOpenSession());
+        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
+        tracker.getOpenSession().close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+        
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        tracker.stopTracking();
+        statusRecorder.close();
+    }
+    
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    // Tests the SessionDelegate while tracking the active session and then a new session
+    public void testDelegateWithActiveSessionThenNewSession() throws Exception {
+        Session.setActiveSession(null);
+        final SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        final MockTokenCache cache = new MockTokenCache(null, 0);
+        final ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+
+        final AccessToken openToken = AccessToken.createFromString(TOKEN_STR, 
+                Collections.<String>emptyList());
+        session.addAuthorizeResult(openToken);
+
+        SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder);
+        Session.setActiveSession(session); 
+        
+        session.openForRead(getActivity());
+        
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+        assertNotNull("Session should be open", tracker.getOpenSession());
+        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
+        tracker.getOpenSession().close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+        
+        final ScriptedSession newSession = createScriptedSessionOnBlockerThread(cache);
+        newSession.addAuthorizeResult(openToken);
+        
+        tracker.setSession(newSession);
+        assertNull("Session should not be open", tracker.getOpenSession());
+        newSession.openForRead(getActivity());
+        
+        statusRecorder.waitForCall(newSession, SessionState.OPENING, null);
+        statusRecorder.waitForCall(newSession, SessionState.OPENED, null);
+        assertNotNull("Session should be open", tracker.getOpenSession());
+        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
+        tracker.getOpenSession().close();
+        statusRecorder.waitForCall(newSession, SessionState.CLOSED, null);
+        
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        tracker.stopTracking();
+        statusRecorder.close();
+    }
+    
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    // Tests the SessionDelegate while tracking a new session and then an active session
+    public void testDelegateWithSessionThenActiveSession() throws Exception {
+        Session.setActiveSession(null);
+        final SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        final MockTokenCache cache = new MockTokenCache(null, 0);
+        final ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+
+        final AccessToken openToken = AccessToken.createFromString(TOKEN_STR, 
+                Collections.<String>emptyList());
+        session.addAuthorizeResult(openToken);
+
+        final SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder, session);
+        
+        session.openForRead(getActivity());
+        
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+        assertNotNull("Session should be open", tracker.getOpenSession());
+        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
+        tracker.getOpenSession().close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+        
+        final ScriptedSession newSession = createScriptedSessionOnBlockerThread(cache);
+        newSession.addAuthorizeResult(openToken);
+        
+        // need to run on the blocker thread so that when we register the 
+        // BroadcastReceivers, the handler gets run on the right thread
+        runOnBlockerThread(new Runnable() {
+            public void run() {
+                tracker.setSession(null);
+                Session.setActiveSession(newSession);
+            }
+        }, true);
+        
+        assertNull("Session should not be open", tracker.getOpenSession());
+        newSession.openForRead(getActivity());
+        
+        statusRecorder.waitForCall(newSession, SessionState.OPENING, null);
+        statusRecorder.waitForCall(newSession, SessionState.OPENED, null);
+        assertNotNull("Session should be open", tracker.getOpenSession());
+        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
+        tracker.getOpenSession().close();
+        statusRecorder.waitForCall(newSession, SessionState.CLOSED, null);
+        
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        tracker.stopTracking();
+        statusRecorder.close();
+    }
+}
diff --git a/facebook/tests/src/com/facebook/SettingsTests.java b/facebook/tests/src/com/facebook/SettingsTests.java
new file mode 100644
index 000000000..114c047d7
--- /dev/null
+++ b/facebook/tests/src/com/facebook/SettingsTests.java
@@ -0,0 +1,58 @@
+package com.facebook;
+
+import android.os.ConditionVariable;
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+
+import java.util.concurrent.Executor;
+
+public final class SettingsTests extends AndroidTestCase {
+
+    @SmallTest @MediumTest @LargeTest
+    public void testGetExecutor() {
+        final ConditionVariable condition = new ConditionVariable();
+
+        Settings.getExecutor().execute(new Runnable() {
+            @Override
+            public void run() {
+                condition.open();
+            }
+        });
+
+        boolean success = condition.block(5000);
+        assertTrue(success);
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testSetExecutor() {
+        final ConditionVariable condition = new ConditionVariable();
+
+        final Runnable runnable = new Runnable() {
+            @Override
+            public void run() { }
+        };
+
+        final Executor executor = new Executor() {
+            @Override
+            public void execute(Runnable command) {
+                assertEquals(runnable, command);
+                command.run();
+
+                condition.open();
+            }
+        };
+
+        Executor original = Settings.getExecutor();
+        try {
+            Settings.setExecutor(executor);
+            Settings.getExecutor().execute(runnable);
+
+            boolean success = condition.block(5000);
+            assertTrue(success);
+        } finally {
+            Settings.setExecutor(original);
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/SharedPreferencesTokenCacheTests.java b/facebook/tests/src/com/facebook/SharedPreferencesTokenCacheTests.java
new file mode 100644
index 000000000..8309f7baf
--- /dev/null
+++ b/facebook/tests/src/com/facebook/SharedPreferencesTokenCacheTests.java
@@ -0,0 +1,296 @@
+package com.facebook;
+
+import android.os.Bundle;
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+import junit.framework.Assert;
+
+import java.lang.reflect.Array;
+import java.util.*;
+
+
+public final class SharedPreferencesTokenCacheTests extends AndroidTestCase {
+
+    private static final String BOOLEAN_KEY = "booleanKey";
+    private static final String BOOLEAN_ARRAY_KEY = "booleanArrayKey";
+    private static final String BYTE_KEY = "byteKey";
+    private static final String BYTE_ARRAY_KEY = "byteArrayKey";
+    private static final String SHORT_KEY = "shortKey";
+    private static final String SHORT_ARRAY_KEY = "shortArrayKey";
+    private static final String INT_KEY = "intKey";
+    private static final String INT_ARRAY_KEY = "intArrayKey";
+    private static final String LONG_KEY = "longKey";
+    private static final String LONG_ARRAY_KEY = "longArrayKey";
+    private static final String FLOAT_ARRAY_KEY = "floatKey";
+    private static final String FLOAT_KEY = "floatArrayKey";
+    private static final String DOUBLE_KEY = "doubleKey";
+    private static final String DOUBLE_ARRAY_KEY = "doubleArrayKey";
+    private static final String CHAR_KEY = "charKey";
+    private static final String CHAR_ARRAY_KEY = "charArrayKey";
+    private static final String STRING_KEY = "stringKey";
+    private static final String STRING_LIST_KEY = "stringListKey";
+
+    private static Random random = new Random((new Date()).getTime());
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testAllTypes() {
+        Bundle originalBundle = new Bundle();
+
+        putBoolean(BOOLEAN_KEY, originalBundle);
+        putBooleanArray(BOOLEAN_ARRAY_KEY, originalBundle);
+        putByte(BYTE_KEY, originalBundle);
+        putByteArray(BYTE_ARRAY_KEY, originalBundle);
+        putShort(SHORT_KEY, originalBundle);
+        putShortArray(SHORT_ARRAY_KEY, originalBundle);
+        putInt(INT_KEY, originalBundle);
+        putIntArray(INT_ARRAY_KEY, originalBundle);
+        putLong(LONG_KEY, originalBundle);
+        putLongArray(LONG_ARRAY_KEY, originalBundle);
+        putFloat(FLOAT_KEY, originalBundle);
+        putFloatArray(FLOAT_ARRAY_KEY, originalBundle);
+        putDouble(DOUBLE_KEY, originalBundle);
+        putDoubleArray(DOUBLE_ARRAY_KEY, originalBundle);
+        putChar(CHAR_KEY, originalBundle);
+        putCharArray(CHAR_ARRAY_KEY, originalBundle);
+        putString(STRING_KEY, originalBundle);
+        putStringList(STRING_LIST_KEY, originalBundle);
+
+        ensureApplicationContext();
+
+        SharedPreferencesTokenCache cache = new SharedPreferencesTokenCache(getContext());
+        cache.save(originalBundle);
+
+        SharedPreferencesTokenCache cache2 = new SharedPreferencesTokenCache(getContext());
+        Bundle cachedBundle = cache2.load();
+
+        Assert.assertEquals(originalBundle.getBoolean(BOOLEAN_KEY), cachedBundle.getBoolean(BOOLEAN_KEY));
+        assertArrayEquals(originalBundle.getBooleanArray(BOOLEAN_ARRAY_KEY), cachedBundle.getBooleanArray(BOOLEAN_ARRAY_KEY));
+        Assert.assertEquals(originalBundle.getByte(BYTE_KEY), cachedBundle.getByte(BYTE_KEY));
+        assertArrayEquals(originalBundle.getByteArray(BYTE_ARRAY_KEY), cachedBundle.getByteArray(BYTE_ARRAY_KEY));
+        Assert.assertEquals(originalBundle.getShort(SHORT_KEY), cachedBundle.getShort(SHORT_KEY));
+        assertArrayEquals(originalBundle.getShortArray(SHORT_ARRAY_KEY), cachedBundle.getShortArray(SHORT_ARRAY_KEY));
+        Assert.assertEquals(originalBundle.getInt(INT_KEY), cachedBundle.getInt(INT_KEY));
+        assertArrayEquals(originalBundle.getIntArray(INT_ARRAY_KEY), cachedBundle.getIntArray(INT_ARRAY_KEY));
+        Assert.assertEquals(originalBundle.getLong(LONG_KEY), cachedBundle.getLong(LONG_KEY));
+        assertArrayEquals(originalBundle.getLongArray(LONG_ARRAY_KEY), cachedBundle.getLongArray(LONG_ARRAY_KEY));
+        Assert.assertEquals(originalBundle.getFloat(FLOAT_KEY), cachedBundle.getFloat(FLOAT_KEY));
+        assertArrayEquals(originalBundle.getFloatArray(FLOAT_ARRAY_KEY), cachedBundle.getFloatArray(FLOAT_ARRAY_KEY));
+        Assert.assertEquals(originalBundle.getDouble(DOUBLE_KEY), cachedBundle.getDouble(DOUBLE_KEY));
+        assertArrayEquals(originalBundle.getDoubleArray(DOUBLE_ARRAY_KEY), cachedBundle.getDoubleArray(DOUBLE_ARRAY_KEY));
+        Assert.assertEquals(originalBundle.getChar(CHAR_KEY), cachedBundle.getChar(CHAR_KEY));
+        assertArrayEquals(originalBundle.getCharArray(CHAR_ARRAY_KEY), cachedBundle.getCharArray(CHAR_ARRAY_KEY));
+        Assert.assertEquals(originalBundle.getString(STRING_KEY), cachedBundle.getString(STRING_KEY));
+        assertListEquals(originalBundle.getStringArrayList(STRING_LIST_KEY), cachedBundle.getStringArrayList(
+                STRING_LIST_KEY));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMultipleCaches() {
+        Bundle bundle1 = new Bundle(), bundle2 = new Bundle();
+
+        bundle1.putInt(INT_KEY, 10);
+        bundle1.putString(STRING_KEY, "ABC");
+        bundle2.putInt(INT_KEY, 100);
+        bundle2.putString(STRING_KEY, "xyz");
+
+        ensureApplicationContext();
+
+        SharedPreferencesTokenCache cache1 = new SharedPreferencesTokenCache(getContext());
+        SharedPreferencesTokenCache cache2 = new SharedPreferencesTokenCache(getContext(), "CustomCache");
+
+        cache1.save(bundle1);
+        cache2.save(bundle2);
+
+        // Get new references to make sure we are getting persisted data.
+        // Reverse the cache references for fun.
+        cache1 = new SharedPreferencesTokenCache(getContext(), "CustomCache");
+        cache2 = new SharedPreferencesTokenCache(getContext());
+
+        Bundle newBundle1 = cache1.load(), newBundle2 = cache2.load();
+
+        Assert.assertEquals(bundle2.getInt(INT_KEY), newBundle1.getInt(INT_KEY));
+        Assert.assertEquals(bundle2.getString(STRING_KEY), newBundle1.getString(STRING_KEY));
+        Assert.assertEquals(bundle1.getInt(INT_KEY), newBundle2.getInt(INT_KEY));
+        Assert.assertEquals(bundle1.getString(STRING_KEY), newBundle2.getString(STRING_KEY));
+    }
+
+    private static void assertArrayEquals(Object a1, Object a2) {
+        Assert.assertNotNull(a1);
+        Assert.assertNotNull(a2);
+        Assert.assertEquals(a1.getClass(), a2.getClass());
+        Assert.assertTrue("Not an array", a1.getClass().isArray());
+
+        int length = Array.getLength(a1);
+        Assert.assertEquals(length, Array.getLength(a2));
+        for (int i = 0; i < length; i++) {
+            Object a1Value = Array.get(a1, i);
+            Object a2Value = Array.get(a2, i);
+
+            Assert.assertEquals(a1Value, a2Value);
+        }
+    }
+
+    private static void assertListEquals(List<?> l1, List<?> l2) {
+        Assert.assertNotNull(l1);
+        Assert.assertNotNull(l2);
+
+        Iterator<?> i1 = l1.iterator(), i2 = l2.iterator();
+        while (i1.hasNext() && i2.hasNext()) {
+            Assert.assertEquals(i1.next(), i2.next());
+        }
+
+        Assert.assertTrue("Lists not of the same length", !i1.hasNext());
+        Assert.assertTrue("Lists not of the same length", !i2.hasNext());
+    }
+
+    private static void putInt(String key, Bundle bundle) {
+        bundle.putInt(key, random.nextInt());
+    }
+
+    private static void putIntArray(String key, Bundle bundle) {
+        int length = random.nextInt(50);
+        int[] array = new int[length];
+        for (int i = 0; i < length; i++) {
+            array[i] = random.nextInt();
+        }
+        bundle.putIntArray(key, array);
+    }
+
+    private static void putShort(String key, Bundle bundle) {
+        bundle.putShort(key, (short)random.nextInt());
+    }
+
+    private static void putShortArray(String key, Bundle bundle) {
+        int length = random.nextInt(50);
+        short[] array = new short[length];
+        for (int i = 0; i < length; i++) {
+            array[i] = (short)random.nextInt();
+        }
+        bundle.putShortArray(key, array);
+    }
+
+    private static void putByte(String key, Bundle bundle) {
+        bundle.putByte(key, (byte)random.nextInt());
+    }
+
+    private static void putByteArray(String key, Bundle bundle) {
+        int length = random.nextInt(50);
+        byte[] array = new byte[length];
+        random.nextBytes(array);
+        bundle.putByteArray(key, array);
+    }
+
+    private static void putBoolean(String key, Bundle bundle) {
+        bundle.putBoolean(key, random.nextBoolean());
+    }
+
+    private static void putBooleanArray(String key, Bundle bundle) {
+        int length = random.nextInt(50);
+        boolean[] array = new boolean[length];
+        for (int i = 0; i < length; i++) {
+            array[i] = random.nextBoolean();
+        }
+        bundle.putBooleanArray(key, array);
+    }
+
+    private static void putLong(String key, Bundle bundle) {
+        bundle.putLong(key, random.nextLong());
+    }
+
+    private static void putLongArray(String key, Bundle bundle) {
+        int length = random.nextInt(50);
+        long[] array = new long[length];
+        for (int i = 0; i < length; i++) {
+            array[i] = random.nextLong();
+        }
+        bundle.putLongArray(key, array);
+    }
+
+    private static void putFloat(String key, Bundle bundle) {
+        bundle.putFloat(key, random.nextFloat());
+    }
+
+    private static void putFloatArray(String key, Bundle bundle) {
+        int length = random.nextInt(50);
+        float[] array = new float[length];
+        for (int i = 0; i < length; i++) {
+            array[i] = random.nextFloat();
+        }
+        bundle.putFloatArray(key, array);
+    }
+
+    private static void putDouble(String key, Bundle bundle) {
+        bundle.putDouble(key, random.nextDouble());
+    }
+
+    private static void putDoubleArray(String key, Bundle bundle) {
+        int length = random.nextInt(50);
+        double[] array = new double[length];
+        for (int i = 0; i < length; i++) {
+            array[i] = random.nextDouble();
+        }
+        bundle.putDoubleArray(key, array);
+    }
+
+    private static void putChar(String key, Bundle bundle) {
+        bundle.putChar(key, getChar());
+    }
+
+    private static void putCharArray(String key, Bundle bundle) {
+        bundle.putCharArray(key, getCharArray());
+    }
+
+    private static void putString(String key, Bundle bundle) {
+        bundle.putString(key, new String(getCharArray()));
+    }
+
+    private static void putStringList(String key, Bundle bundle) {
+        int length = random.nextInt(50);
+        ArrayList<String> stringList = new ArrayList<String>(length);
+        while (0 < length--) {
+            if (length == 0) {
+                stringList.add(null);
+            } else {
+                stringList.add(new String(getCharArray()));
+            }
+        }
+
+        bundle.putStringArrayList(key, stringList);
+    }
+
+    private static char[] getCharArray() {
+        int length = random.nextInt(50);
+        char[] array = new char[length];
+        for (int i = 0; i < length; i++) {
+            array[i] = getChar();
+        }
+
+        return array;
+    }
+
+    private static char getChar() {
+        return (char)random.nextInt(255);
+    }
+
+    private void ensureApplicationContext() {
+        // Since the test case is not running on the UI thread, the applicationContext might
+        // not be ready (i.e. it might be null). Wait for a bit to resolve this.
+        long waitedFor = 0;
+        try {
+            // Don't hold up execution for too long.
+            while (getContext().getApplicationContext() == null && waitedFor <= 2000) {
+                Thread.sleep(50);
+                waitedFor += 50;
+            }
+        }
+        catch (InterruptedException e) {
+        }
+    }
+
+}
diff --git a/facebook/tests/src/com/facebook/TestBlocker.java b/facebook/tests/src/com/facebook/TestBlocker.java
new file mode 100644
index 000000000..cfeb5ac54
--- /dev/null
+++ b/facebook/tests/src/com/facebook/TestBlocker.java
@@ -0,0 +1,115 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.os.Handler;
+import android.os.HandlerThread;
+
+public class TestBlocker extends HandlerThread {
+    private Exception exception;
+    public int signals;
+    private volatile Handler handler;
+
+    private TestBlocker() {
+        super("TestBlocker");
+    }
+
+    public synchronized static TestBlocker createTestBlocker() {
+        TestBlocker blocker = new TestBlocker();
+        blocker.start();
+
+        // Wait until we have a Looper and Handler.
+        synchronized (blocker) {
+            while (blocker.handler == null) {
+                try {
+                    blocker.wait();
+                } catch (InterruptedException e) {
+                }
+            }
+        }
+
+        return blocker;
+    }
+
+    @Override
+    public void run() {
+        try {
+            super.run();
+        } catch (Exception e) {
+            setException(e);
+        }
+        synchronized (this) {
+            notifyAll();
+        }
+    }
+
+    public Handler getHandler() {
+        return handler;
+    }
+
+    public void assertSuccess() throws Exception {
+        Exception e = getException();
+        if (e != null) {
+            throw e;
+        }
+    }
+
+    public synchronized void signal() {
+        ++signals;
+        notifyAll();
+    }
+
+    public void waitForSignals(int numSignals) throws Exception {
+        // Make sure we aren't sitting on an unhandled exception before we even start, because that means our
+        // thread isn't around anymore.
+        assertSuccess();
+
+        setException(null);
+
+        synchronized (this) {
+            while (getException() == null && signals < numSignals) {
+                try {
+                    wait();
+                } catch (InterruptedException e) {
+                }
+            }
+            signals = 0;
+        }
+    }
+
+    public void waitForSignalsAndAssertSuccess(int numSignals) throws Exception {
+        waitForSignals(numSignals);
+        assertSuccess();
+    }
+
+    public synchronized Exception getException() {
+        return exception;
+    }
+
+    public synchronized void setException(Exception e) {
+        exception = e;
+        notifyAll();
+    }
+
+    @Override
+    protected void onLooperPrepared() {
+        synchronized (this) {
+            handler = new Handler(getLooper());
+            notifyAll();
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/TestSession.java b/facebook/tests/src/com/facebook/TestSession.java
new file mode 100644
index 000000000..ecf717363
--- /dev/null
+++ b/facebook/tests/src/com/facebook/TestSession.java
@@ -0,0 +1,418 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.text.TextUtils;
+import android.util.Log;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.*;
+
+public class TestSession extends Session {
+    private static final long serialVersionUID = 1L;
+
+    private enum Mode {
+        PRIVATE, SHARED
+    }
+
+    private static final String LOG_TAG = Settings.LOG_TAG_BASE + "TestSession";
+
+    private static Map<String, TestAccount> appTestAccounts;
+    private static String testApplicationSecret;
+    private static String testApplicationId;
+    private static String machineUniqueUserTag;
+
+    private final String sessionUniqueUserTag;
+    private final List<String> requestedPermissions;
+    private final Mode mode;
+    private String testAccountId;
+
+    private boolean wasAskedToExtendAccessToken;
+
+    protected TestSession(Activity activity, List<String> permissions, TokenCache tokenCache,
+            String machineUniqueUserTag, String sessionUniqueUserTag, Mode mode) {
+        super(activity, TestSession.testApplicationId, tokenCache, false);
+
+        Validate.notNull(permissions, "permissions");
+
+        // Validate these as if they were arguments even though they are statics.
+        Validate.notNullOrEmpty(testApplicationId, "testApplicationId");
+        Validate.notNullOrEmpty(testApplicationSecret, "testApplicationSecret");
+
+        this.sessionUniqueUserTag = sessionUniqueUserTag;
+        this.mode = mode;
+        this.requestedPermissions = permissions;
+    }
+
+    public static TestSession createSessionWithPrivateUser(Activity activity, List<String> permissions) {
+        return createTestSession(activity, permissions, Mode.PRIVATE, null);
+    }
+
+    public static TestSession createSessionWithSharedUser(Activity activity, List<String> permissions) {
+        return createSessionWithSharedUser(activity, permissions, null);
+    }
+
+    public static TestSession createSessionWithSharedUser(Activity activity, List<String> permissions,
+            String sessionUniqueUserTag) {
+        return createTestSession(activity, permissions, Mode.SHARED, sessionUniqueUserTag);
+    }
+
+    public static final String getAppAccessToken() {
+        return testApplicationId + "|" + testApplicationSecret;
+    }
+
+    public static synchronized String getTestApplicationId() {
+        return testApplicationId;
+    }
+
+    public static synchronized void setTestApplicationId(String value) {
+        if (testApplicationId != null && !testApplicationId.equals(value)) {
+            throw new FacebookException("Can't have more than one test application ID");
+        }
+        testApplicationId = value;
+    }
+
+    public static synchronized String getTestApplicationSecret() {
+        return testApplicationSecret;
+    }
+
+    public static synchronized void setTestApplicationSecret(String value) {
+        if (testApplicationSecret != null && !testApplicationSecret.equals(value)) {
+            throw new FacebookException("Can't have more than one test application secret");
+        }
+        testApplicationSecret = value;
+    }
+
+    public static synchronized String getMachineUniqueUserTag() {
+        return machineUniqueUserTag;
+    }
+
+    public static synchronized void setMachineUniqueUserTag(String value) {
+        if (machineUniqueUserTag != null && !machineUniqueUserTag.equals(value)) {
+            throw new FacebookException("Can't have more than one machine-unique user tag");
+        }
+        machineUniqueUserTag = value;
+    }
+
+    private static synchronized TestSession createTestSession(Activity activity, List<String> permissions, Mode mode,
+            String sessionUniqueUserTag) {
+        if (Utility.isNullOrEmpty(testApplicationId) || Utility.isNullOrEmpty(testApplicationSecret)) {
+            throw new FacebookException("Must provide app ID and secret");
+        }
+
+        if (Utility.isNullOrEmpty(permissions)) {
+            permissions = Arrays.asList("email", "publish_actions");
+        }
+
+        return new TestSession(activity, permissions, new TestTokenCache(), machineUniqueUserTag, sessionUniqueUserTag,
+                mode);
+    }
+
+    private static synchronized void retrieveTestAccountsForAppIfNeeded() {
+        if (appTestAccounts != null) {
+            return;
+        }
+
+        appTestAccounts = new HashMap<String, TestAccount>();
+
+        // The data we need is split across two different FQL tables. We construct two queries, submit them
+        // together (the second one refers to the first one), then cross-reference the results.
+
+        // Get the test accounts for this app.
+        String testAccountQuery = String.format("SELECT id,access_token FROM test_account WHERE app_id = %s",
+                testApplicationId);
+        // Get the user names for those accounts.
+        String userQuery = "SELECT uid,name FROM user WHERE uid IN (SELECT id FROM #test_accounts)";
+
+        Bundle parameters = new Bundle();
+
+        // Build a JSON string that contains our queries and pass it as the 'q' parameter of the query.
+        JSONObject multiquery;
+        try {
+            multiquery = new JSONObject();
+            multiquery.put("test_accounts", testAccountQuery);
+            multiquery.put("users", userQuery);
+        } catch (JSONException exception) {
+            throw new FacebookException(exception);
+        }
+        parameters.putString("q", multiquery.toString());
+
+        // We need to authenticate as this app.
+        parameters.putString("access_token", getAppAccessToken());
+
+        Request request = new Request(null, "fql", parameters, null);
+        Response response = request.executeAndWait();
+
+        if (response.getError() != null) {
+            throw response.getError();
+        }
+
+        FqlResponse fqlResponse = response.getGraphObjectAs(FqlResponse.class);
+
+        GraphObjectList<FqlResult> fqlResults = fqlResponse.getData();
+        if (fqlResults == null || fqlResults.size() != 2) {
+            throw new FacebookException("Unexpected number of results from FQL query");
+        }
+
+        // We get back two sets of results. The first is from the test_accounts query, the second from the users query.
+        Collection<TestAccount> testAccounts = fqlResults.get(0).getFqlResultSet().castToListOf(TestAccount.class);
+        Collection<UserAccount> userAccounts = fqlResults.get(1).getFqlResultSet().castToListOf(UserAccount.class);
+
+        // Use both sets of results to populate our static array of accounts.
+        populateTestAccounts(testAccounts, userAccounts);
+
+        return;
+    }
+
+    private static synchronized void populateTestAccounts(Collection<TestAccount> testAccounts,
+            Collection<UserAccount> userAccounts) {
+        // We get different sets of data from each of these queries. We want to combine them into a single data
+        // structure. We have added a Name property to the TestAccount interface, even though we don't really get
+        // a name back from the service from that query. We stick the Name from the corresponding UserAccount in it.
+        for (TestAccount testAccount : testAccounts) {
+            storeTestAccount(testAccount);
+        }
+
+        for (UserAccount userAccount : userAccounts) {
+            TestAccount testAccount = appTestAccounts.get(userAccount.getUid());
+            if (testAccount != null) {
+                testAccount.setName(userAccount.getName());
+            }
+        }
+    }
+
+    private static synchronized void storeTestAccount(TestAccount testAccount) {
+        appTestAccounts.put(testAccount.getId(), testAccount);
+    }
+
+    private static synchronized TestAccount findTestAccountMatchingIdentifier(String identifier) {
+        retrieveTestAccountsForAppIfNeeded();
+
+        for (TestAccount testAccount : appTestAccounts.values()) {
+            if (testAccount.getName().contains(identifier)) {
+                return testAccount;
+            }
+        }
+        return null;
+    }
+
+    public final String getTestUserId() {
+        return testAccountId;
+    }
+
+    @Override
+    void authorize(AuthorizationRequest request) {
+        if (mode == Mode.PRIVATE) {
+            createTestAccountAndFinishAuth();
+        } else {
+            findOrCreateSharedTestAccount();
+        }
+    }
+
+    @Override
+    void postStateChange(final SessionState oldState, final SessionState newState, final Exception error) {
+        // Make sure this doesn't get overwritten.
+        String id = testAccountId;
+
+        super.postStateChange(oldState, newState, error);
+
+        if (newState.isClosed() && id != null && mode == Mode.PRIVATE) {
+            deleteTestAccount(id, getAppAccessToken());
+        }
+    }
+
+    public boolean getWasAskedToExtendAccessToken() {
+        return wasAskedToExtendAccessToken;
+    }
+
+    public void forceExtendAccessToken(boolean forceExtendAccessToken) {
+        AccessToken currentToken = getTokenInfo();
+        setTokenInfo(
+                new AccessToken(currentToken.getToken(), new Date(), currentToken.getPermissions(), true, new Date(0)));
+        setLastAttemptedTokenExtendDate(new Date(0));
+    }
+
+    @Override
+    boolean shouldExtendAccessToken() {
+        boolean result = super.shouldExtendAccessToken();
+        wasAskedToExtendAccessToken = false;
+        return result;
+    }
+
+    @Override
+    void extendAccessToken() {
+        wasAskedToExtendAccessToken = true;
+        super.extendAccessToken();
+    }
+
+    void fakeTokenRefreshAttempt() {
+        setCurrentTokenRefreshRequest(new TokenRefreshRequest());
+    }
+
+    private void findOrCreateSharedTestAccount() {
+        TestAccount testAccount = findTestAccountMatchingIdentifier(getSharedTestAccountIdentifier());
+        if (testAccount != null) {
+            finishAuthWithTestAccount(testAccount);
+        } else {
+            createTestAccountAndFinishAuth();
+        }
+    }
+
+    private void finishAuthWithTestAccount(TestAccount testAccount) {
+        testAccountId = testAccount.getId();
+
+        AccessToken accessToken = AccessToken.createFromString(testAccount.getAccessToken(), requestedPermissions);
+        finishAuth(accessToken, null);
+    }
+
+    private TestAccount createTestAccountAndFinishAuth() {
+        Bundle parameters = new Bundle();
+        parameters.putString("installed", "true");
+        parameters.putString("permissions", getPermissionsString());
+        parameters.putString("access_token", getAppAccessToken());
+
+        // If we're in shared mode, we want to rename this user to encode its permissions, so we can find it later
+        // in another shared session. If we're in private mode, don't bother renaming it since we're just going to
+        // delete it at the end of the session.
+        if (mode == Mode.SHARED) {
+            parameters.putString("name", String.format("Shared %s Testuser", getSharedTestAccountIdentifier()));
+        }
+
+        String graphPath = String.format("%s/accounts/test-users", testApplicationId);
+        Request createUserRequest = new Request(null, graphPath, parameters, HttpMethod.POST);
+        Response response = createUserRequest.executeAndWait();
+
+        FacebookException error = response.getError();
+        TestAccount testAccount = response.getGraphObjectAs(TestAccount.class);
+        if (error != null) {
+            finishAuth(null, error);
+            return null;
+        } else {
+            assert testAccount != null;
+
+            // If we are in shared mode, store this new account in the dictionary so we can re-use it later.
+            if (mode == Mode.SHARED) {
+                // Remember the new name we gave it, since we didn't get it back in the results of the create request.
+                testAccount.setName(parameters.getString("name"));
+                storeTestAccount(testAccount);
+            }
+
+            finishAuthWithTestAccount(testAccount);
+
+            return testAccount;
+        }
+    }
+
+    private void deleteTestAccount(String testAccountId, String appAccessToken) {
+        Bundle parameters = new Bundle();
+        parameters.putString("access_token", appAccessToken);
+
+        Request request = new Request(null, testAccountId, parameters, HttpMethod.DELETE);
+        Response response = request.executeAndWait();
+
+        Exception error = response.getError();
+        GraphObject graphObject = response.getGraphObject();
+        if (error != null) {
+            Log.w(LOG_TAG, String.format("Could not delete test account %s: %s", testAccountId, error.toString()));
+        } else if (graphObject.getProperty(Response.NON_JSON_RESPONSE_PROPERTY) == (Boolean) false) {
+            Log.w(LOG_TAG, String.format("Could not delete test account %s: unknown reason", testAccountId));
+        }
+    }
+
+    private String getPermissionsString() {
+        return TextUtils.join(",", requestedPermissions);
+    }
+
+    private String getSharedTestAccountIdentifier() {
+        // We use long even though hashes are ints to avoid sign issues.
+        long permissionsHash = getPermissionsString().hashCode() & 0xffffffffL;
+        long machineTagHash = (machineUniqueUserTag != null) ? machineUniqueUserTag.hashCode() & 0xffffffffL : 0;
+        long sessionTagHash = (sessionUniqueUserTag != null) ? sessionUniqueUserTag.hashCode() & 0xffffffffL : 0;
+
+        long combinedHash = permissionsHash ^ machineTagHash ^ sessionTagHash;
+        return validNameStringFromInteger(combinedHash);
+    }
+
+    private String validNameStringFromInteger(long i) {
+        String s = Long.toString(i);
+        StringBuilder result = new StringBuilder("Perm");
+
+        // We know each character is a digit. Convert it into a letter 'a'-'j'. Avoid repeated characters
+        //  that might make Facebook reject the name by converting every other repeated character into one
+        //  10 higher ('k'-'t').
+        char lastChar = 0;
+        for (char c : s.toCharArray()) {
+            if (c == lastChar) {
+                c += 10;
+            }
+            result.append((char) (c + 'a' - '0'));
+            lastChar = c;
+        }
+
+        return result.toString();
+    }
+
+    private interface TestAccount extends GraphObject {
+        String getId();
+
+        String getAccessToken();
+
+        // Note: We don't actually get Name from our FQL query. We fill it in by correlating with UserAccounts.
+        String getName();
+
+        void setName(String name);
+    }
+
+    private interface UserAccount extends GraphObject {
+        String getUid();
+
+        String getName();
+
+        void setName(String name);
+    }
+
+    private interface FqlResult extends GraphObject {
+        GraphObjectList<GraphObject> getFqlResultSet();
+
+    }
+
+    private interface FqlResponse extends GraphObject {
+        GraphObjectList<FqlResult> getData();
+    }
+
+    private static final class TestTokenCache extends TokenCache {
+        private Bundle bundle;
+
+        @Override
+        public Bundle load() {
+            return bundle;
+        }
+
+        @Override
+        public void save(Bundle value) {
+            bundle = value;
+        }
+
+        @Override
+        public void clear() {
+            bundle = null;
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/TestSessionTests.java b/facebook/tests/src/com/facebook/TestSessionTests.java
new file mode 100644
index 000000000..4c466d4d0
--- /dev/null
+++ b/facebook/tests/src/com/facebook/TestSessionTests.java
@@ -0,0 +1,163 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.os.Bundle;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+import org.json.JSONArray;
+
+// Because TestSession is the component under test here, be careful in calling methods on FacebookTestCase that
+// assume TestSession works correctly.
+public class TestSessionTests extends FacebookTestCase {
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanCreateWithPrivateUser() {
+        TestSession session = TestSession.createSessionWithPrivateUser(getActivity(), null);
+        assertTrue(session != null);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanCreateWithSharedUser() {
+        TestSession session = TestSession.createSessionWithSharedUser(getActivity(), null);
+        assertTrue(session != null);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCanOpenWithSharedUser() throws Throwable {
+        final TestBlocker blocker = getTestBlocker();
+        TestSession session = getTestSessionWithSharedUser();
+
+        Session.OpenRequest openRequest = new Session.OpenRequest(getActivity()).
+                setCallback(
+                        new Session.StatusCallback() {
+                            @Override
+                            public void call(Session session, SessionState state, Exception exception) {
+                                assertTrue(exception == null);
+                                blocker.signal();
+                            }
+                        });
+        session.openForRead(openRequest);
+
+        waitAndAssertSuccess(blocker, 1);
+
+        assertTrue(session.getState().isOpened());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testSharedUserDoesntCreateUnnecessaryUsers() throws Throwable {
+        TestSession session = getTestSessionWithSharedUser();
+        openSession(getActivity(), session);
+
+        // Note that this test is somewhat brittle in that the count of test users could change for
+        // external reasons while the test is running. For that reason it may not be appropriate for an
+        // automated test suite, and could be run only when testing changes to TestSession.
+        int startingUserCount = countTestUsers();
+
+        session = getTestSessionWithSharedUser();
+        openSession(getActivity(), session);
+
+        int endingUserCount = countTestUsers();
+
+        assertSame(startingUserCount, endingUserCount);
+    }
+
+    // This test is currently unreliable, I believe due to timing/replication issues that cause the
+    // counts to occasionally be off. Taking out of test runs for now until a more robust test can be added.
+    @LargeTest
+    public void failing_testPrivateUserIsDeletedOnSessionClose() throws Throwable {
+        final TestBlocker blocker = getTestBlocker();
+
+        // See comment above regarding test user count.
+        int startingUserCount = countTestUsers();
+
+        TestSession session = getTestSessionWithPrivateUser(blocker);
+        openSession(getActivity(), session);
+
+        int sessionOpenUserCount = countTestUsers();
+
+        assertSame(startingUserCount + 1, sessionOpenUserCount);
+
+        session.close();
+
+        int endingUserCount = countTestUsers();
+
+        assertSame(startingUserCount, endingUserCount);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCannotChangeTestApplicationIdOnceSet() {
+        try {
+            TestSession.setTestApplicationId("hello");
+            TestSession.setTestApplicationId("world");
+            fail("expected exception");
+        } catch (FacebookException e) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCannotChangeTestApplicationSecretOnceSet() {
+        try {
+            TestSession.setTestApplicationSecret("hello");
+            TestSession.setTestApplicationSecret("world");
+            fail("expected exception");
+        } catch (FacebookException e) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCannotChangeMachineUniqueUserTagOnceSet() {
+        try {
+            TestSession.setMachineUniqueUserTag("hello");
+            TestSession.setMachineUniqueUserTag("world");
+            fail("expected exception");
+        } catch (FacebookException e) {
+        }
+    }
+
+    private int countTestUsers() {
+        TestSession session = getTestSessionWithSharedUser(null);
+
+        String appAccessToken = TestSession.getAppAccessToken();
+        assertNotNull(appAccessToken);
+        String applicationId = session.getApplicationId();
+        assertNotNull(applicationId);
+
+        String fqlQuery = String.format("SELECT id FROM test_account WHERE app_id = %s", applicationId);
+        Bundle parameters = new Bundle();
+        parameters.putString("q", fqlQuery);
+        parameters.putString("access_token", appAccessToken);
+
+        Request request = new Request(null, "fql", parameters, null);
+        Response response = request.executeAndWait();
+
+        JSONArray data = (JSONArray) response.getGraphObject().getProperty("data");
+        return data.length();
+    }
+}
diff --git a/facebook/tests/src/com/facebook/TestUtils.java b/facebook/tests/src/com/facebook/TestUtils.java
new file mode 100644
index 000000000..49bd6fc8b
--- /dev/null
+++ b/facebook/tests/src/com/facebook/TestUtils.java
@@ -0,0 +1,38 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import java.io.*;
+
+public class TestUtils {
+    public static <T extends Serializable> T serializeAndUnserialize(T t) {
+        try {
+            ByteArrayOutputStream os = new ByteArrayOutputStream();
+            new ObjectOutputStream(os).writeObject(t);
+            ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
+
+            @SuppressWarnings("unchecked")
+            T ret = (T) (new ObjectInputStream(is)).readObject();
+
+            return ret;
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        } catch (ClassNotFoundException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/UtilityTests.java b/facebook/tests/src/com/facebook/UtilityTests.java
new file mode 100644
index 000000000..b2e97c10a
--- /dev/null
+++ b/facebook/tests/src/com/facebook/UtilityTests.java
@@ -0,0 +1,109 @@
+/**
+ * Copyright 2010 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map.Entry;
+import java.util.Set;
+
+public final class UtilityTests extends AndroidTestCase {
+
+    @SmallTest @MediumTest @LargeTest
+    public void testCamelCaseToLowercase() {
+        assertEquals("hello_world", Utility.convertCamelCaseToLowercaseWithUnderscores("HelloWorld"));
+        assertEquals("hello_world", Utility.convertCamelCaseToLowercaseWithUnderscores("helloWorld"));
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testJsonObjectClear() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        Utility.jsonObjectClear(jsonObject);
+        assertEquals(0, jsonObject.length());
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testJsonObjectContainsValue() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        assertTrue(Utility.jsonObjectContainsValue(jsonObject, "pocus"));
+        assertFalse(Utility.jsonObjectContainsValue(jsonObject, "Fred"));
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testJsonObjectEntrySet() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        Set<Entry<String, Object>> entrySet = Utility.jsonObjectEntrySet(jsonObject);
+        assertEquals(2, entrySet.size());
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testJsonObjectKeySet() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        Set<String> keySet = Utility.jsonObjectKeySet(jsonObject);
+        assertEquals(2, keySet.size());
+        assertTrue(keySet.contains("hello"));
+        assertFalse(keySet.contains("world"));
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testJsonObjectPutAll() throws JSONException {
+        HashMap<String, Object> map = new HashMap<String, Object>();
+        map.put("hello", "world");
+        map.put("hocus", "pocus");
+
+        JSONObject jsonObject = new JSONObject();
+        Utility.jsonObjectPutAll(jsonObject, map);
+
+        assertEquals("pocus", jsonObject.get("hocus"));
+        assertEquals(2, jsonObject.length());
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testJsonObjectValues() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        Collection<Object> values = Utility.jsonObjectValues(jsonObject);
+
+        assertEquals(2, values.size());
+        assertTrue(values.contains("world"));
+    }
+}
diff --git a/facebook/tests/src/com/facebook/ValidateTests.java b/facebook/tests/src/com/facebook/ValidateTests.java
new file mode 100644
index 000000000..751c3a1a2
--- /dev/null
+++ b/facebook/tests/src/com/facebook/ValidateTests.java
@@ -0,0 +1,88 @@
+package com.facebook;
+
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.SmallTest;
+
+import java.util.Arrays;
+
+public class ValidateTests extends AndroidTestCase {
+    
+    @SmallTest
+    public void testNotNullOnNonNull() {
+        Validate.notNull("A string", "name");
+    }
+
+    @SmallTest
+    public void testNotNullOnNull() {
+        try {
+            Validate.notNull(null, "name");
+            fail("expected exception");
+        } catch (Exception e) {
+        }
+    }
+
+    @SmallTest
+    public void testNotEmptyOnNonEmpty() {
+        Validate.notEmpty(Arrays.asList(new String[] { "hi" }), "name");
+    }
+
+    @SmallTest
+    public void testNotEmptylOnEmpty() {
+        try {
+            Validate.notEmpty(Arrays.asList(new String[] {}), "name");
+            fail("expected exception");
+        } catch (Exception e) {
+        }
+    }
+
+    @SmallTest
+    public void testNotNullOrEmptyOnNonEmpty() {
+        Validate.notNullOrEmpty("hi", "name");
+    }
+
+    @SmallTest
+    public void testNotNullOrEmptyOnEmpty() {
+        try {
+            Validate.notNullOrEmpty("", "name");
+            fail("expected exception");
+        } catch (Exception e) {
+        }
+    }
+
+    @SmallTest
+    public void testNotNullOrEmptyOnNull() {
+        try {
+            Validate.notNullOrEmpty(null, "name");
+            fail("expected exception");
+        } catch (Exception e) {
+        }
+    }
+
+    @SmallTest
+    public void testOneOfOnValid() {
+        Validate.oneOf("hi", "name", "hi", "there");
+    }
+
+    @SmallTest
+    public void testOneOfOnInvalid() {
+        try {
+            Validate.oneOf("hit", "name", "hi", "there");
+            fail("expected exception");
+        } catch (Exception e) {
+        }
+    }
+
+    @SmallTest
+    public void testOneOfOnValidNull() {
+        Validate.oneOf(null, "name", "hi", "there", null);
+    }
+
+    @SmallTest
+    public void testOneOfOnInvalidNull() {
+        try {
+            Validate.oneOf(null, "name", "hi", "there");
+            fail("expected exception");
+        } catch (Exception e) {
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/android/FbDialogTests.java b/facebook/tests/src/com/facebook/android/FbDialogTests.java
new file mode 100644
index 000000000..e3854c483
--- /dev/null
+++ b/facebook/tests/src/com/facebook/android/FbDialogTests.java
@@ -0,0 +1,45 @@
+package com.facebook.android;
+
+import android.os.Bundle;
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+
+public class FbDialogTests extends AndroidTestCase {
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testDialogListener() {
+        Facebook.DialogListener testListener = new Facebook.DialogListener() {
+            @Override
+            public void onComplete(Bundle values) {
+                assertNotNull("Got a bundle", values);
+            }
+
+            @Override
+            public void onFacebookError(FacebookError e) {
+                fail("Should not reach this method");
+            }
+
+            @Override
+            public void onError(DialogError e) {
+                fail("Should not reach this method");
+            }
+
+            @Override
+            public void onCancel() {
+                fail("Should not reach this method");
+            }
+        };
+
+        Facebook.DialogListener singleDispatchListener =
+                new FbDialog.SingleDispatchDialogListener(testListener);
+
+        singleDispatchListener.onComplete(new Bundle());
+        singleDispatchListener.onFacebookError(null);
+        singleDispatchListener.onError(null);
+        singleDispatchListener.onCancel();
+    }
+}
diff --git a/libs/android-support-v4.jar b/libs/android-support-v4.jar
new file mode 100644
index 000000000..feaf44f80
Binary files /dev/null and b/libs/android-support-v4.jar differ
diff --git a/samples/BooleanOGSample/.classpath b/samples/BooleanOGSample/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/BooleanOGSample/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/BooleanOGSample/.project b/samples/BooleanOGSample/.project
new file mode 100644
index 000000000..cd9402a77
--- /dev/null
+++ b/samples/BooleanOGSample/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>BooleanOGSample</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/samples/BooleanOGSample/AndroidManifest.xml b/samples/BooleanOGSample/AndroidManifest.xml
new file mode 100644
index 000000000..b0fd4c751
--- /dev/null
+++ b/samples/BooleanOGSample/AndroidManifest.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.facebook.samples.booleanog"
+          android:versionCode="1"
+          android:versionName="1.0">
+    <uses-sdk android:minSdkVersion="8" />
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <application android:label="@string/app_name" android:icon="@drawable/icon" >
+        <activity android:name="LogicActivity"
+                  android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+        <activity android:name="com.facebook.LoginActivity"
+                  android:label="@string/app_name" />
+        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
+    </application>
+</manifest> 
diff --git a/samples/BooleanOGSample/BooleanOGSample.iml b/samples/BooleanOGSample/BooleanOGSample.iml
new file mode 100644
index 000000000..ea4761ccc
--- /dev/null
+++ b/samples/BooleanOGSample/BooleanOGSample.iml
@@ -0,0 +1,55 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+    <orderEntry type="module-library">
+      <library>
+        <CLASSES>
+          <root url="file://$MODULE_DIR$/../../libs" />
+        </CLASSES>
+        <JAVADOC />
+        <SOURCES />
+        <jarDirectory url="file://$MODULE_DIR$/../../libs" recursive="false" />
+      </library>
+    </orderEntry>
+  </component>
+</module>
+
diff --git a/samples/BooleanOGSample/ant.properties b/samples/BooleanOGSample/ant.properties
new file mode 100644
index 000000000..b0971e891
--- /dev/null
+++ b/samples/BooleanOGSample/ant.properties
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff --git a/samples/BooleanOGSample/build.xml b/samples/BooleanOGSample/build.xml
new file mode 100644
index 000000000..ce5402793
--- /dev/null
+++ b/samples/BooleanOGSample/build.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="BooleanOGSample" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties"/>
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties"/>
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env"/>
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME"/>
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties"/>
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+            />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true"/>
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml"/>
+
+</project>
diff --git a/samples/BooleanOGSample/proguard-project.txt b/samples/BooleanOGSample/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/BooleanOGSample/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/samples/BooleanOGSample/project.properties b/samples/BooleanOGSample/project.properties
new file mode 100644
index 000000000..cee0509c6
--- /dev/null
+++ b/samples/BooleanOGSample/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+android.library.reference.1=../../facebook
diff --git a/samples/BooleanOGSample/res/drawable-hdpi/icon.png b/samples/BooleanOGSample/res/drawable-hdpi/icon.png
new file mode 100644
index 000000000..5bc5b2cea
Binary files /dev/null and b/samples/BooleanOGSample/res/drawable-hdpi/icon.png differ
diff --git a/samples/BooleanOGSample/res/drawable-mdpi/icon.png b/samples/BooleanOGSample/res/drawable-mdpi/icon.png
new file mode 100644
index 000000000..f621e908c
Binary files /dev/null and b/samples/BooleanOGSample/res/drawable-mdpi/icon.png differ
diff --git a/samples/BooleanOGSample/res/drawable-xhdpi/icon.png b/samples/BooleanOGSample/res/drawable-xhdpi/icon.png
new file mode 100644
index 000000000..1adb6bfa3
Binary files /dev/null and b/samples/BooleanOGSample/res/drawable-xhdpi/icon.png differ
diff --git a/samples/BooleanOGSample/res/drawable/false_content.png b/samples/BooleanOGSample/res/drawable/false_content.png
new file mode 100644
index 000000000..a86d4d296
Binary files /dev/null and b/samples/BooleanOGSample/res/drawable/false_content.png differ
diff --git a/samples/BooleanOGSample/res/drawable/icon.png b/samples/BooleanOGSample/res/drawable/icon.png
new file mode 100644
index 000000000..f621e908c
Binary files /dev/null and b/samples/BooleanOGSample/res/drawable/icon.png differ
diff --git a/samples/BooleanOGSample/res/drawable/true_content.png b/samples/BooleanOGSample/res/drawable/true_content.png
new file mode 100644
index 000000000..ce7694f83
Binary files /dev/null and b/samples/BooleanOGSample/res/drawable/true_content.png differ
diff --git a/samples/BooleanOGSample/res/layout/content_group.xml b/samples/BooleanOGSample/res/layout/content_group.xml
new file mode 100644
index 000000000..0a7a35b52
--- /dev/null
+++ b/samples/BooleanOGSample/res/layout/content_group.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:id="@+id/content_group"
+              android:layout_height="fill_parent"
+              android:layout_width="fill_parent"
+              android:background="#FFF"
+              android:orientation="vertical">
+
+    <ImageView android:id="@+id/content_image"
+               android:layout_height="fill_parent"
+               android:layout_width="fill_parent"
+               android:layout_weight="1"/>
+
+    <Spinner android:id="@+id/content_spinner"
+             android:layout_height="wrap_content"
+             android:layout_width="fill_parent"
+             android:layout_weight="0"/>
+
+</LinearLayout>
diff --git a/samples/BooleanOGSample/res/layout/friend_activity_row.xml b/samples/BooleanOGSample/res/layout/friend_activity_row.xml
new file mode 100644
index 000000000..c5b1ba3a0
--- /dev/null
+++ b/samples/BooleanOGSample/res/layout/friend_activity_row.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+              android:orientation="horizontal"
+              android:background="#fff">
+
+    <TextView android:id="@+id/friend_action_date"
+              android:layout_height="wrap_content"
+              android:layout_width="fill_parent"
+              android:layout_weight="1"
+              android:textSize="12sp"
+              android:textColor="#000"/>
+
+    <TextView android:id="@+id/friend_action_data"
+              android:layout_height="wrap_content"
+              android:layout_width="fill_parent"
+              android:layout_weight="1"
+              android:textSize="12sp"
+              android:textColor="#000"/>
+
+</LinearLayout>
diff --git a/samples/BooleanOGSample/res/layout/friends_group.xml b/samples/BooleanOGSample/res/layout/friends_group.xml
new file mode 100644
index 000000000..4b2297351
--- /dev/null
+++ b/samples/BooleanOGSample/res/layout/friends_group.xml
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:id="@+id/friends_group"
+              android:layout_height="fill_parent"
+              android:layout_width="fill_parent"
+              android:background="#FFF"
+              android:orientation="vertical">
+
+    <TextView android:layout_height="wrap_content"
+              android:layout_width="fill_parent"
+              android:textColor="#000"
+              android:textSize="20sp"
+              android:text="@string/friends_using_rock_the_logic"/>
+
+    <FrameLayout android:id="@+id/friend_picker_fragment"
+                 android:layout_height="fill_parent"
+                 android:layout_width="fill_parent"
+                 android:layout_weight="1"/>
+
+    <TextView android:layout_height="wrap_content"
+              android:layout_width="fill_parent"
+              android:textColor="#000"
+              android:textSize="20sp"
+              android:text="@string/friend_activity"/>
+
+    <FrameLayout android:layout_height="fill_parent"
+                 android:layout_width="fill_parent"
+                 android:layout_weight="1">
+
+        <ListView android:id="@+id/friend_activity_list"
+                  android:layout_height="fill_parent"
+                  android:layout_width="fill_parent"/>
+
+        <ProgressBar android:id="@+id/friend_activity_progress_bar"
+                     android:layout_width="wrap_content"
+                     android:layout_height="wrap_content"
+                     android:layout_gravity="center"
+                     android:indeterminate="true"
+                     style="@android:style/Widget.ProgressBar"
+                     android:layout_centerInParent="true"
+                     android:visibility="gone"/>
+
+    </FrameLayout>
+
+</LinearLayout>
diff --git a/samples/BooleanOGSample/res/layout/logic_group.xml b/samples/BooleanOGSample/res/layout/logic_group.xml
new file mode 100644
index 000000000..a09978051
--- /dev/null
+++ b/samples/BooleanOGSample/res/layout/logic_group.xml
@@ -0,0 +1,70 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:id="@+id/logic_group"
+              android:orientation="vertical"
+              android:layout_height="fill_parent"
+              android:layout_width="fill_parent"
+              android:background="#999">
+
+    <TextView android:layout_height="wrap_content"
+              android:layout_width="fill_parent"
+              android:layout_weight="1"
+              android:textColor="#fff"
+              android:textSize="32sp"
+              android:gravity="center"
+              android:text="@string/rock_the_logic"/>
+
+    <LinearLayout android:orientation="horizontal"
+                  android:layout_height="wrap_content"
+                  android:layout_width="fill_parent"
+                  android:layout_weight="1">
+        <Spinner android:id="@+id/left_spinner"
+                 android:layout_height="wrap_content"
+                 android:layout_width="wrap_content"
+                 android:layout_weight="1"
+                 android:layout_gravity="center"/>
+        <LinearLayout android:orientation="vertical"
+                      android:layout_height="wrap_content"
+                      android:layout_width="wrap_content"
+                      android:layout_weight="1"
+                      android:layout_gravity="center">
+            <Button android:id="@+id/and_button"
+                    android:layout_height="wrap_content"
+                    android:layout_width="fill_parent"
+                    android:layout_gravity="center"
+                    android:text="@string/and_operation"/>
+            <Button android:id="@+id/or_button"
+                    android:layout_height="wrap_content"
+                    android:layout_width="fill_parent"
+                    android:layout_gravity="center"
+                    android:text="@string/or_operation"/>
+        </LinearLayout>
+        <Spinner android:id="@+id/right_spinner"
+                 android:layout_height="wrap_content"
+                 android:layout_width="wrap_content"
+                 android:layout_weight="1"
+                 android:layout_gravity="center"/>
+    </LinearLayout>
+
+    <TextView android:id="@+id/result_text"
+              android:layout_height="wrap_content"
+              android:layout_width="fill_parent"
+              android:layout_weight="1"
+              android:gravity="center"
+              android:background="#fff"
+              android:textColor="#000"
+              android:textSize="24sp"
+              android:text=""/>
+
+    <TextView android:id="@+id/post_result_text"
+              android:layout_height="wrap_content"
+              android:layout_width="fill_parent"
+              android:layout_weight="1"
+              android:gravity="center"
+              android:background="#fff"
+              android:textColor="#000"
+              android:textSize="12sp"
+              android:text=""/>
+
+</LinearLayout>
diff --git a/samples/BooleanOGSample/res/layout/main.xml b/samples/BooleanOGSample/res/layout/main.xml
new file mode 100644
index 000000000..4bf4833c5
--- /dev/null
+++ b/samples/BooleanOGSample/res/layout/main.xml
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:orientation="vertical"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent">
+
+    <FrameLayout android:id="@+id/body_frame"
+                 android:layout_height="0dip"
+                 android:layout_width="fill_parent"
+                 android:layout_weight="1">
+        <include layout="@layout/logic_group"/>
+        <include layout="@layout/friends_group"/>
+        <include layout="@layout/settings_group"/>
+        <include layout="@layout/content_group"/>
+    </FrameLayout>
+
+    <LinearLayout android:orientation="horizontal"
+                  android:layout_width="fill_parent"
+                  android:layout_height="wrap_content">
+        <Button android:id="@+id/logic_button"
+                android:layout_width="wrap_content"
+                android:layout_height="fill_parent"
+                android:layout_weight="1"
+                android:layout_gravity="center"
+                android:text="@string/navigate_logic"/>
+        <Button android:id="@+id/friends_button"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:layout_gravity="center"
+                android:text="@string/navigate_friends"/>
+        <Button android:id="@+id/content_button"
+                android:layout_width="wrap_content"
+                android:layout_height="fill_parent"
+                android:layout_weight="0"
+                android:layout_gravity="center"
+                android:text="@string/navigate_content"/>
+        <Button android:id="@+id/settings_button"
+                android:layout_width="wrap_content"
+                android:layout_height="fill_parent"
+                android:layout_weight="0"
+                android:layout_gravity="center"
+                android:text="@string/navigate_settings"/>
+    </LinearLayout>
+
+</LinearLayout>
+
diff --git a/samples/BooleanOGSample/res/layout/settings_group.xml b/samples/BooleanOGSample/res/layout/settings_group.xml
new file mode 100644
index 000000000..1fe895539
--- /dev/null
+++ b/samples/BooleanOGSample/res/layout/settings_group.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:id="@+id/settings_group"
+              android:layout_height="fill_parent"
+              android:layout_width="fill_parent">
+
+    <FrameLayout android:id="@+id/login_fragment"
+                 android:layout_height="fill_parent"
+                 android:layout_width="fill_parent"/>
+
+</LinearLayout>
diff --git a/samples/BooleanOGSample/res/values/strings.xml b/samples/BooleanOGSample/res/values/strings.xml
new file mode 100644
index 000000000..cf40380ba
--- /dev/null
+++ b/samples/BooleanOGSample/res/values/strings.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">BooleanOGSample</string>
+    <string name="app_id">369258453126794</string>
+    <string name="navigate_logic">You Rock!</string>
+    <string name="navigate_friends">Rock with Friends</string>
+    <string name="navigate_settings">Settings</string>
+    <string name="navigate_content">Content</string>
+    <string name="rock_the_logic">Rock the Logic</string>
+    <string name="false_value">False</string>
+    <string name="true_value">True</string>
+    <string name="and_operation">AND</string>
+    <string name="or_operation">OR</string>
+    <string name="friends_using_rock_the_logic">Friends using Rock the Logic!</string>
+    <string name="friend_activity">Friend activity</string>
+    <string name="foo">You Rock!</string>
+
+    <string-array name="truth_values">
+        <item>@string/true_value</item>
+        <item>@string/false_value</item>
+    </string-array>
+</resources>
diff --git a/samples/BooleanOGSample/src/com/facebook/samples/booleanog/LogicActivity.java b/samples/BooleanOGSample/src/com/facebook/samples/booleanog/LogicActivity.java
new file mode 100644
index 000000000..0184c7b75
--- /dev/null
+++ b/samples/BooleanOGSample/src/com/facebook/samples/booleanog/LogicActivity.java
@@ -0,0 +1,755 @@
+package com.facebook.samples.booleanog;
+
+import android.app.AlertDialog;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.database.MatrixCursor;
+import android.net.Uri;
+import android.os.Bundle;
+import android.support.v4.app.FragmentManager;
+import android.support.v4.app.FragmentTransaction;
+import android.support.v4.content.LocalBroadcastManager;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.*;
+import com.facebook.*;
+
+import java.text.SimpleDateFormat;
+import java.util.*;
+
+public class LogicActivity extends FacebookActivity {
+
+    private static final String TAG = "BooleanOpenGraphSample";
+
+    private static final String SAVE_ACTIVE_TAB = TAG + ".SAVE_ACTIVE_TAB";
+    private static final String SAVE_CONTENT_SELECTION = TAG + ".SAVE_CONTENT_SELECTION";
+    private static final String SAVE_LEFT_OPERAND_SELECTION = TAG + ".SAVE_LEFT_OPERAND_SELECTION";
+    private static final String SAVE_RIGHT_OPERAND_SELECTION = TAG + ".SAVE_RIGHT_OPERAND_SELECTION";
+    private static final String SAVE_RESULT_TEXT = TAG + ".SAVE_RESULT_TEXT";
+    private static final String SAVE_POST_RESULT_TEXT = TAG + ".SAVE_POST_RESULT_TEXT";
+    private static final String SAVE_PENDING = TAG + ".SAVE_PENDING";
+    private static final String PENDING_POST_PATH = "PENDING_POST_PATH";
+    private static final String PENDING_POST_LEFT = "PENDING_POST_LEFT";
+    private static final String PENDING_POST_RIGHT = "PENDING_POST_RIGHT";
+    private static final String PENDING_POST_RESULT = "PENDING_POST_RESULT";
+
+    private static final String AND_ACTION = "fb_sample_boolean_og:and";
+    private static final String OR_ACTION = "fb_sample_boolean_og:or";
+    private static final String POST_AND_ACTION_PATH = "me/" + AND_ACTION;
+    private static final String POST_OR_ACTION_PATH = "me/" + OR_ACTION;
+    private static final String TRUE_GRAPH_OBJECT_URL = "http://samples.ogp.me/369360019783304";
+    private static final String FALSE_GRAPH_OBJECT_URL = "http://samples.ogp.me/369360256449947";
+    private static final String INSTALLED = "installed";
+    private static final List<String> PERMISSIONS = Arrays.asList("publish_actions");
+
+    private static volatile TruthValueGraphObject TRUE_GRAPH_OBJECT;
+    private static volatile TruthValueGraphObject FALSE_GRAPH_OBJECT;
+    private static volatile int TRUE_SPINNER_INDEX = -1;
+    private static volatile int FALSE_SPINNER_INDEX = -1;
+
+    // Main layout
+    private Button logicButton;
+    private Button friendsButton;
+    private Button settingsButton;
+    private Button contentButton;
+    private String activeTab;
+
+    // Logic group
+    private ViewGroup logicGroup;
+    private Spinner leftSpinner;
+    private Spinner rightSpinner;
+    private Button andButton;
+    private Button orButton;
+    private TextView resultText;
+    private TextView postResultText;
+    private Bundle pendingPost;
+
+    // Friends group
+    private ViewGroup friendsGroup;
+    private FriendPickerFragment friendPickerFragment;
+    private RequestAsyncTask pendingRequest;
+    private SimpleCursorAdapter friendActivityAdapter;
+    private ProgressBar friendActivityProgressBar;
+
+    // Login group
+    private ViewGroup settingsGroup;
+    private LoginFragment loginFragment;
+
+    // Content group
+    private ViewGroup contentGroup;
+    private ImageView contentImage;
+    private Spinner contentSpinner;
+
+    /**
+     * Called when the activity is first created.
+     */
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+
+        // Views
+        logicButton = (Button) findViewById(R.id.logic_button);
+        friendsButton = (Button) findViewById(R.id.friends_button);
+        settingsButton = (Button) findViewById(R.id.settings_button);
+        contentButton = (Button) findViewById(R.id.content_button);
+
+        logicGroup = (ViewGroup) findViewById(R.id.logic_group);
+        leftSpinner = (Spinner) findViewById(R.id.left_spinner);
+        rightSpinner = (Spinner) findViewById(R.id.right_spinner);
+        andButton = (Button) findViewById(R.id.and_button);
+        orButton = (Button) findViewById(R.id.or_button);
+        resultText = (TextView) findViewById(R.id.result_text);
+        postResultText = (TextView) findViewById(R.id.post_result_text);
+
+        friendsGroup = (ViewGroup) findViewById(R.id.friends_group);
+        ListView friendActivityList = (ListView) findViewById(R.id.friend_activity_list);
+        String[] mapColumnNames = {"date", "action"};
+        int[] mapViewIds = {R.id.friend_action_date, R.id.friend_action_data};
+        friendActivityAdapter = new SimpleCursorAdapter(this, R.layout.friend_activity_row, createEmptyCursor(),
+                mapColumnNames, mapViewIds);
+        friendActivityList.setAdapter(friendActivityAdapter);
+        friendActivityProgressBar = (ProgressBar) findViewById(R.id.friend_activity_progress_bar);
+
+        settingsGroup = (ViewGroup) findViewById(R.id.settings_group);
+
+        contentGroup = (ViewGroup) findViewById(R.id.content_group);
+        contentImage = (ImageView) findViewById(R.id.content_image);
+        contentSpinner = (Spinner) findViewById(R.id.content_spinner);
+
+        // Fragments
+        FragmentManager fragmentManager = getSupportFragmentManager();
+        FragmentTransaction transaction = fragmentManager.beginTransaction();
+
+        friendPickerFragment = (FriendPickerFragment) fragmentManager.findFragmentById(R.id.friend_picker_fragment);
+        if (friendPickerFragment == null) {
+            Bundle args = new Bundle();
+            args.putBoolean(FriendPickerFragment.SHOW_TITLE_BAR_BUNDLE_KEY, false);
+            friendPickerFragment = new FriendPickerFragment(args);
+            transaction.add(R.id.friend_picker_fragment, friendPickerFragment);
+        }
+
+        loginFragment = (LoginFragment) fragmentManager.findFragmentById(R.id.login_fragment);
+        if (loginFragment == null) {
+            loginFragment = new LoginFragment();
+            transaction.add(R.id.login_fragment, loginFragment);
+        }
+
+        transaction.commit();
+
+        // Spinners
+        ArrayAdapter<CharSequence> truthAdapter = ArrayAdapter
+                .createFromResource(this, R.array.truth_values, android.R.layout.simple_spinner_item);
+        truthAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
+        leftSpinner.setAdapter(truthAdapter);
+        rightSpinner.setAdapter(truthAdapter);
+        contentSpinner.setAdapter(truthAdapter);
+        leftSpinner.setSelection(0);
+        rightSpinner.setSelection(0);
+
+        // Navigation
+        for (Button button : Arrays.asList(logicButton, friendsButton, settingsButton, contentButton)) {
+            initializeNavigationButton(button);
+        }
+
+        // Logic
+        initializeCalculationButton(andButton);
+        initializeCalculationButton(orButton);
+
+        // Friends
+        friendPickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
+            @Override
+            public void onError(FacebookException error) {
+                LogicActivity.this.onError(error);
+            }
+        });
+        friendPickerFragment.setUserId("me");
+        friendPickerFragment.setMultiSelect(false);
+        friendPickerFragment.setOnSelectionChangedListener(new PickerFragment.OnSelectionChangedListener() {
+            @Override
+            public void onSelectionChanged() {
+                LogicActivity.this.onFriendSelectionChanged();
+            }
+        });
+        friendPickerFragment.setExtraFields(Arrays.asList(INSTALLED));
+        friendPickerFragment.setFilter(new PickerFragment.GraphObjectFilter<GraphUser>() {
+            @Override
+            public boolean includeItem(GraphUser graphObject) {
+                Boolean installed = graphObject.cast(GraphUserWithInstalled.class).getInstalled();
+                return (installed != null) && installed.booleanValue();
+            }
+        });
+
+        // Content
+        contentSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
+            @Override
+            public void onItemSelected(AdapterView<?> adapterView, View view, int i, long l) {
+                LogicActivity.this.onContentSelectionChanged();
+            }
+
+            @Override
+            public void onNothingSelected(AdapterView<?> adapterView) {
+                LogicActivity.this.onContentSelectionChanged();
+            }
+        });
+
+        // Restore saved state
+        Button startButton = logicButton;
+
+        if (savedInstanceState != null) {
+            leftSpinner.setSelection(savedInstanceState.getInt(SAVE_LEFT_OPERAND_SELECTION));
+            rightSpinner.setSelection(savedInstanceState.getInt(SAVE_RIGHT_OPERAND_SELECTION));
+            contentSpinner.setSelection(savedInstanceState.getInt(SAVE_CONTENT_SELECTION));
+            resultText.setText(savedInstanceState.getString(SAVE_RESULT_TEXT));
+            postResultText.setText(savedInstanceState.getString(SAVE_POST_RESULT_TEXT));
+            activeTab = savedInstanceState.getString(SAVE_ACTIVE_TAB);
+            pendingPost = (Bundle) savedInstanceState.getBundle(SAVE_PENDING);
+
+            if (getString(R.string.navigate_friends).equals(activeTab)) {
+                startButton = friendsButton;
+            } else if (getString(R.string.navigate_content).equals(activeTab)) {
+                startButton = contentButton;
+            } else if (getString(R.string.navigate_settings).equals(activeTab)) {
+                startButton = settingsButton;
+            }
+        }
+
+        // Resolve deep-links, if any
+        Boolean deepLinkContent = getDeepLinkContent(getIntent().getData());
+        if (deepLinkContent != null) {
+            startButton = contentButton;
+            contentSpinner.setSelection(getSpinnerPosition(deepLinkContent));
+        }
+
+        onNavigateButtonClick(startButton);
+    }
+
+    // -----------------------------------------------------------------------------------
+    // Activity lifecycle
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        loadIfSessionValid();
+
+        BroadcastReceiver receiver = new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context context, Intent intent) {
+                loadIfSessionValid();
+            }
+        };
+
+        IntentFilter openedFilter = new IntentFilter(Session.ACTION_ACTIVE_SESSION_OPENED);
+        LocalBroadcastManager.getInstance(this).registerReceiver(receiver, openedFilter);
+    }
+
+    private void loadIfSessionValid() {
+        Session session = Session.getActiveSession();
+        if ((session != null) && session.isOpened()) {
+            friendPickerFragment.loadData(false);
+        }
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        outState.putInt(SAVE_LEFT_OPERAND_SELECTION, leftSpinner.getSelectedItemPosition());
+        outState.putInt(SAVE_RIGHT_OPERAND_SELECTION, rightSpinner.getSelectedItemPosition());
+        outState.putInt(SAVE_CONTENT_SELECTION, contentSpinner.getSelectedItemPosition());
+        outState.putString(SAVE_RESULT_TEXT, resultText.getText().toString());
+        outState.putString(SAVE_POST_RESULT_TEXT, postResultText.getText().toString());
+        outState.putString(SAVE_ACTIVE_TAB, activeTab);
+        outState.putBundle(SAVE_PENDING, pendingPost);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+
+        friendPickerFragment.setOnErrorListener(null);
+        friendPickerFragment.setOnSelectionChangedListener(null);
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        loginFragment.onActivityResult(requestCode, resultCode, data);
+        super.onActivityResult(requestCode, resultCode, data);
+    }
+
+    @Override
+    protected void onSessionStateChange(SessionState state, Exception exception) {
+        if (exception != null) {
+            pendingPost = null;
+        } else if (state == SessionState.OPENED_TOKEN_UPDATED) {
+            sendPendingPost();
+        }
+    }
+
+    // -----------------------------------------------------------------------------------
+    // Navigation
+
+    private void initializeNavigationButton(Button button) {
+        button.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                onNavigateButtonClick((Button) view);
+            }
+        });
+    }
+
+    private void onNavigateButtonClick(Button source) {
+        activeTab = source.getText().toString();
+
+        logicGroup.setVisibility(getGroupVisibility(source, logicButton));
+        friendsGroup.setVisibility(getGroupVisibility(source, friendsButton));
+        settingsGroup.setVisibility(getGroupVisibility(source, settingsButton));
+        contentGroup.setVisibility(getGroupVisibility(source, contentButton));
+    }
+
+    private int getGroupVisibility(Button source, Button groupButton) {
+        if (source == groupButton) {
+            return View.VISIBLE;
+        } else {
+            return View.GONE;
+        }
+    }
+
+    // -----------------------------------------------------------------------------------
+    // Logic group
+
+    private void initializeCalculationButton(Button button) {
+        button.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                onOperationButtonClick(view);
+            }
+        });
+    }
+
+    private void onOperationButtonClick(View view) {
+        if (view == andButton) {
+            onAndButtonClick();
+        } else if (view == orButton) {
+            onOrButtonClick();
+        } else {
+            assert false;
+        }
+    }
+
+    private void onAndButtonClick() {
+        boolean leftOperand = getSpinnerBoolean(leftSpinner);
+        boolean rightOperand = getSpinnerBoolean(rightSpinner);
+        boolean result = leftOperand && rightOperand;
+
+        resultText.setText(getLogicText(getString(R.string.and_operation), leftOperand, rightOperand, result));
+        postAction(POST_AND_ACTION_PATH, leftOperand, rightOperand, result);
+    }
+
+    private void onOrButtonClick() {
+        boolean leftOperand = getSpinnerBoolean(leftSpinner);
+        boolean rightOperand = getSpinnerBoolean(rightSpinner);
+        boolean result = leftOperand || rightOperand;
+
+        resultText.setText(getLogicText(getString(R.string.or_operation), leftOperand, rightOperand, result));
+        postAction(POST_OR_ACTION_PATH, leftOperand, rightOperand, result);
+    }
+
+    private String getLogicText(String op, boolean leftOperand, boolean rightOperand, boolean result) {
+        String trueString = getString(R.string.true_value);
+        String falseString = getString(R.string.false_value);
+        String arg0String = leftOperand ? trueString : falseString;
+        String arg1String = rightOperand ? trueString : falseString;
+        String resultString = result ? trueString : falseString;
+
+        return String.format("%s %s %s = %s", arg0String, op, arg1String, resultString);
+    }
+
+    private void postAction(final String actionPath, final boolean leftOperand, final boolean rightOperand,
+            final boolean result) {
+        Bundle post = new Bundle();
+        post.putString(PENDING_POST_PATH, actionPath);
+        post.putBoolean(PENDING_POST_LEFT, leftOperand);
+        post.putBoolean(PENDING_POST_RIGHT, rightOperand);
+        post.putBoolean(PENDING_POST_RESULT, result);
+        pendingPost = post;
+
+        sendPendingPost();
+    }
+
+    private void sendPendingPost() {
+        if (pendingPost == null) {
+            return;
+        }
+
+        Session session = Session.getActiveSession();
+        if ((session == null) || !session.isOpened()) {
+            postResultText.setText("Not logged in, no post generated.");
+            pendingPost = null;
+            return;
+        }
+
+        List<String> permissions = session.getPermissions();
+        if (!permissions.containsAll(PERMISSIONS)) {
+            Session.ReauthorizeRequest reauthRequest = new Session.ReauthorizeRequest(this, PERMISSIONS);
+            session.reauthorizeForPublish(reauthRequest);
+            return;
+        }
+
+        postResultText.setText("Posting action...");
+
+        // For demo purposes, result is just a boolean, but operands are Open Graph objects
+        String actionPath = pendingPost.getString(PENDING_POST_PATH);
+        boolean leftOperand = pendingPost.getBoolean(PENDING_POST_LEFT);
+        boolean rightOperand = pendingPost.getBoolean(PENDING_POST_RIGHT);
+        boolean result = pendingPost.getBoolean(PENDING_POST_RESULT);
+
+        LogicAction action = GraphObjectWrapper.createGraphObject(LogicAction.class);
+        action.setResult(result);
+        action.setTruthvalue(getTruthValueObject(leftOperand));
+        action.setAnothertruthvalue(getTruthValueObject(rightOperand));
+
+        Request.Callback callback = new Request.Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                onPostActionResponse(response);
+            }
+        };
+        Request request = new Request(session, actionPath, null, HttpMethod.POST,
+                callback);
+        request.setGraphObject(action);
+        RequestAsyncTask task = new RequestAsyncTask(request);
+
+        task.execute();
+    }
+
+    private void onPostActionResponse(Response response) {
+        PostResponse postResponse = response.getGraphObjectAs(PostResponse.class);
+
+        String id = null;
+        PostResponse.Body body = null;
+        if (postResponse != null) {
+            id = postResponse.getId();
+            body = postResponse.getBody();
+        }
+
+        PostResponse.Error error = null;
+        if (body != null) {
+            error = body.getError();
+        }
+
+        String errorMessage = null;
+        if (error != null) {
+            errorMessage = error.getMessage();
+        }
+
+        if (errorMessage != null) {
+            postResultText.setText(errorMessage);
+        } else if (response.getError() != null) {
+            postResultText.setText(response.getError().getLocalizedMessage());
+        } else if (id != null) {
+            postResultText.setText("Post id = " + id);
+        } else {
+            postResultText.setText("");
+        }
+    }
+
+    private TruthValueGraphObject getTruthValueObject(boolean value) {
+        if (value) {
+            if (TRUE_GRAPH_OBJECT == null) {
+                TruthValueGraphObject object = GraphObjectWrapper.createGraphObject(TruthValueGraphObject.class);
+                object.setUrl(TRUE_GRAPH_OBJECT_URL);
+                TRUE_GRAPH_OBJECT = object;
+            }
+            return TRUE_GRAPH_OBJECT;
+        } else {
+            if (FALSE_GRAPH_OBJECT == null) {
+                TruthValueGraphObject object = GraphObjectWrapper.createGraphObject(TruthValueGraphObject.class);
+                object.setUrl(FALSE_GRAPH_OBJECT_URL);
+                FALSE_GRAPH_OBJECT = object;
+            }
+            return FALSE_GRAPH_OBJECT;
+        }
+    }
+
+    // -----------------------------------------------------------------------------------
+    // Friends group
+
+    private void onFriendSelectionChanged() {
+        GraphUser user = chooseOne(friendPickerFragment.getSelection());
+        if (user != null) {
+            onChooseFriend(user.getId());
+        } else {
+            friendActivityAdapter.changeCursor(createEmptyCursor());
+        }
+    }
+
+    private void onChooseFriend(String friendId) {
+        friendActivityProgressBar.setVisibility(View.VISIBLE);
+
+        String andPath = String.format("%s/%s", friendId, AND_ACTION);
+        String orPath = String.format("%s/%s", friendId, OR_ACTION);
+        Request getAnds = new Request(Session.getActiveSession(), andPath, null, HttpMethod.GET);
+        Request getOrs = new Request(Session.getActiveSession(), orPath, null, HttpMethod.GET);
+
+        RequestBatch batch = new RequestBatch(getAnds, getOrs);
+
+        if (pendingRequest != null) {
+            pendingRequest.cancel(true);
+        }
+
+        pendingRequest = new RequestAsyncTask(batch) {
+            @Override
+            protected void onPostExecute(List<Response> result) {
+                if (pendingRequest == this) {
+                    pendingRequest = null;
+
+                    LogicActivity.this.onPostExecute(result);
+                }
+            }
+        };
+
+        pendingRequest.execute();
+    }
+
+    private void onPostExecute(List<Response> result) {
+        friendActivityProgressBar.setVisibility(View.GONE);
+
+        ArrayList<ActionRow> publishedItems = createActionRows(result);
+        updateCursor(publishedItems);
+    }
+
+    private ArrayList<ActionRow> createActionRows(List<Response> result) {
+        ArrayList<ActionRow> publishedItems = new ArrayList<ActionRow>();
+
+        for (Response response : result) {
+            if (response.getError() != null) {
+                continue;
+            }
+
+            GraphMultiResult list = response.getGraphObjectAs(GraphMultiResult.class);
+            List<PublishedLogicAction> listData = list.getData().castToListOf(PublishedLogicAction.class);
+
+            for (PublishedLogicAction action : listData) {
+                publishedItems.add(createActionRow(action));
+            }
+        }
+
+        Collections.sort(publishedItems);
+        return publishedItems;
+    }
+
+    private void updateCursor(Iterable<ActionRow> publishedItems) {
+        MatrixCursor cursor = createEmptyCursor();
+        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault());
+
+        int id = 0;
+        for (ActionRow item : publishedItems) {
+            Object[] row = new Object[3];
+            row[0] = id++;
+            row[1] = dateFormat.format(item.publishDate);
+            row[2] = item.actionText;
+            cursor.addRow(row);
+        }
+
+        friendActivityAdapter.changeCursor(cursor);
+        friendActivityAdapter.notifyDataSetChanged();
+    }
+
+    private MatrixCursor createEmptyCursor() {
+        String[] cursorColumns = {"_ID", "date", "action"};
+        return new MatrixCursor(cursorColumns);
+    }
+
+    private ActionRow createActionRow(PublishedLogicAction action) {
+        String actionText = getActionText(action);
+        Date publishDate = action.getPublishTime();
+
+        return new ActionRow(actionText, publishDate);
+    }
+
+    private String getActionText(PublishedLogicAction action) {
+        LogicAction actionData = action.getData();
+        if (actionData == null) {
+            return "";
+        }
+
+        TruthValueGraphObject left = actionData.getTruthvalue();
+        TruthValueGraphObject right = actionData.getAnothertruthvalue();
+        Boolean actionResult = actionData.getResult();
+
+        String verb = action.getType();
+        if (AND_ACTION.equals(verb)) {
+            verb = getString(R.string.and_operation);
+        } else if (OR_ACTION.equals(verb)) {
+            verb = getString(R.string.or_operation);
+        }
+
+        if ((left == null) || (right == null) || (actionResult == null) || (verb == null)) {
+            return "";
+        }
+
+        return String.format("%s %s %s = %s", left.getTitle(), verb, right.getTitle(), actionResult.toString());
+    }
+
+    // -----------------------------------------------------------------------------------
+    // Content group
+
+    private Boolean getDeepLinkContent(Uri deepLinkUri) {
+        if (deepLinkUri != null) {
+            String deepLink = deepLinkUri.toString();
+
+            if (deepLink.startsWith(TRUE_GRAPH_OBJECT_URL)) {
+                return Boolean.TRUE;
+            } else if (deepLink.startsWith(FALSE_GRAPH_OBJECT_URL)) {
+                return Boolean.FALSE;
+            }
+        }
+
+        return null;
+    }
+
+    private void onContentSelectionChanged() {
+        Boolean spinnerBoolean = getSpinnerBoolean(contentSpinner);
+        if (Boolean.TRUE.equals(spinnerBoolean)) {
+            contentImage.setVisibility(View.VISIBLE);
+            contentImage.setImageResource(R.drawable.true_content);
+        } else if (Boolean.FALSE.equals(spinnerBoolean)) {
+            contentImage.setVisibility(View.VISIBLE);
+            contentImage.setImageResource(R.drawable.false_content);
+        } else {
+            contentImage.setImageResource(View.INVISIBLE);
+        }
+    }
+
+    // -----------------------------------------------------------------------------------
+    // Utility methods
+
+    private int getSpinnerPosition(Boolean value) {
+        initializeSpinnerIndexes();
+
+        if (Boolean.TRUE.equals(value)) {
+            return TRUE_SPINNER_INDEX;
+        } else if (Boolean.FALSE.equals(value)) {
+            return FALSE_SPINNER_INDEX;
+        } else {
+            return -1;
+        }
+    }
+
+    private Boolean getSpinnerBoolean(Spinner spinner) {
+        initializeSpinnerIndexes();
+
+        int position = spinner.getSelectedItemPosition();
+        if (position == TRUE_SPINNER_INDEX) {
+            return Boolean.TRUE;
+        } else if (position == FALSE_SPINNER_INDEX) {
+            return Boolean.FALSE;
+        } else {
+            return null;
+        }
+    }
+
+    private void initializeSpinnerIndexes() {
+        if ((TRUE_SPINNER_INDEX < 0) || (FALSE_SPINNER_INDEX < 0)) {
+            String[] truthArray = getResources().getStringArray(R.array.truth_values);
+            List<String> truthList = Arrays.asList(truthArray);
+            TRUE_SPINNER_INDEX = truthList.indexOf(getString(R.string.true_value));
+            FALSE_SPINNER_INDEX = truthList.indexOf(getString(R.string.false_value));
+        }
+    }
+
+    private void onError(Exception error) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setTitle("Error").setMessage(error.getMessage()).setPositiveButton("OK", null);
+        builder.show();
+    }
+
+    private <T> T chooseOne(List<T> ts) {
+        for (T t : ts) {
+            return t;
+        }
+
+        return null;
+    }
+
+    // -----------------------------------------------------------------------------------
+    // Supporting types
+
+    private interface GraphUserWithInstalled extends GraphUser {
+        Boolean getInstalled();
+    }
+
+    private class ActionRow implements Comparable<ActionRow> {
+        final String actionText;
+        final Date publishDate;
+
+        ActionRow(String actionText, Date publishDate) {
+            this.actionText = actionText;
+            this.publishDate = publishDate;
+        }
+
+        @Override
+        public int compareTo(ActionRow other) {
+            if (other == null) {
+                return 1;
+            } else {
+                return publishDate.compareTo(other.publishDate);
+            }
+        }
+    }
+
+    /**
+     * Used to create and consume TruthValue open graph objects.
+     */
+    private interface TruthValueGraphObject extends GraphObject {
+        void setUrl(String url);
+
+        String getTitle();
+    }
+
+    /**
+     * Used to create and consume And an Or open graph actions
+     */
+    private interface LogicAction extends OpenGraphAction {
+        Boolean getResult();
+
+        void setResult(Boolean result);
+
+        TruthValueGraphObject getTruthvalue();
+
+        void setTruthvalue(TruthValueGraphObject truthvalue);
+
+        TruthValueGraphObject getAnothertruthvalue();
+
+        void setAnothertruthvalue(TruthValueGraphObject anothertruthvalue);
+    }
+
+    /**
+     * Used to consume published And and Or open graph actions.
+     */
+    private interface PublishedLogicAction extends OpenGraphAction {
+        LogicAction getData();
+
+        String getType();
+    }
+
+    /**
+     * Used to inspect the response from posting an action
+     */
+    private interface PostResponse extends GraphObject {
+        Body getBody();
+
+        String getId();
+
+        interface Body extends GraphObject {
+            Error getError();
+        }
+
+        interface Error extends GraphObject {
+            String getMessage();
+        }
+    }
+}
diff --git a/samples/FriendPickerSample/.classpath b/samples/FriendPickerSample/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/FriendPickerSample/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/FriendPickerSample/.project b/samples/FriendPickerSample/.project
new file mode 100644
index 000000000..c956fc90d
--- /dev/null
+++ b/samples/FriendPickerSample/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>FriendPickerSample</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/samples/FriendPickerSample/AndroidManifest.xml b/samples/FriendPickerSample/AndroidManifest.xml
new file mode 100644
index 000000000..fe092c910
--- /dev/null
+++ b/samples/FriendPickerSample/AndroidManifest.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.facebook.samples.friendpicker"
+          android:versionCode="1"
+          android:versionName="1.0">
+    <uses-sdk android:minSdkVersion="8"/>
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+    <application android:label="@string/app_name"
+                 android:icon="@drawable/icon"
+                 android:theme="@android:style/Theme.NoTitleBar"
+                 android:name=".FriendPickerApplication"
+            >
+        <activity android:name="FriendPickerSampleActivity"
+                  android:label="@string/app_name"
+                  android:windowSoftInputMode="adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+        <activity android:name="PickFriendsActivity"
+                  android:label="Pick Friends">
+        </activity>
+        <activity android:name="com.facebook.LoginActivity"
+                  android:label="@string/app_name" />
+        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
+    </application>
+</manifest>
diff --git a/samples/FriendPickerSample/FriendPickerSample.iml b/samples/FriendPickerSample/FriendPickerSample.iml
new file mode 100644
index 000000000..bca109a37
--- /dev/null
+++ b/samples/FriendPickerSample/FriendPickerSample.iml
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/samples/FriendPickerSample/ant.properties b/samples/FriendPickerSample/ant.properties
new file mode 100644
index 000000000..b0971e891
--- /dev/null
+++ b/samples/FriendPickerSample/ant.properties
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff --git a/samples/FriendPickerSample/build.xml b/samples/FriendPickerSample/build.xml
new file mode 100644
index 000000000..92f485560
--- /dev/null
+++ b/samples/FriendPickerSample/build.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="FriendPickerSample" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties"/>
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties"/>
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env"/>
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME"/>
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties"/>
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+            />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true"/>
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml"/>
+
+</project>
diff --git a/samples/FriendPickerSample/proguard-project.txt b/samples/FriendPickerSample/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/FriendPickerSample/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/samples/FriendPickerSample/project.properties b/samples/FriendPickerSample/project.properties
new file mode 100644
index 000000000..cee0509c6
--- /dev/null
+++ b/samples/FriendPickerSample/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+android.library.reference.1=../../facebook
diff --git a/samples/FriendPickerSample/res/drawable-hdpi/icon.png b/samples/FriendPickerSample/res/drawable-hdpi/icon.png
new file mode 100644
index 000000000..6a930c6c6
Binary files /dev/null and b/samples/FriendPickerSample/res/drawable-hdpi/icon.png differ
diff --git a/samples/FriendPickerSample/res/drawable-mdpi/icon.png b/samples/FriendPickerSample/res/drawable-mdpi/icon.png
new file mode 100644
index 000000000..33b418b7a
Binary files /dev/null and b/samples/FriendPickerSample/res/drawable-mdpi/icon.png differ
diff --git a/samples/FriendPickerSample/res/drawable-xhdpi/icon.png b/samples/FriendPickerSample/res/drawable-xhdpi/icon.png
new file mode 100644
index 000000000..494e37a8d
Binary files /dev/null and b/samples/FriendPickerSample/res/drawable-xhdpi/icon.png differ
diff --git a/samples/FriendPickerSample/res/drawable/icon.png b/samples/FriendPickerSample/res/drawable/icon.png
new file mode 100644
index 000000000..33b418b7a
Binary files /dev/null and b/samples/FriendPickerSample/res/drawable/icon.png differ
diff --git a/samples/FriendPickerSample/res/layout/main.xml b/samples/FriendPickerSample/res/layout/main.xml
new file mode 100644
index 000000000..4de5bb4de
--- /dev/null
+++ b/samples/FriendPickerSample/res/layout/main.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:orientation="vertical"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+        >
+    <Button
+            android:id="@+id/pickFriendsButton"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:text="Pick Friends"
+            />
+    <TextView
+            android:id="@+id/resultsTextView"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:textColor="#FFFFFF"
+            />
+
+</LinearLayout>
+
diff --git a/samples/FriendPickerSample/res/layout/pick_friends_activity.xml b/samples/FriendPickerSample/res/layout/pick_friends_activity.xml
new file mode 100644
index 000000000..3110f96ce
--- /dev/null
+++ b/samples/FriendPickerSample/res/layout/pick_friends_activity.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:orientation="vertical"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+        >
+    <FrameLayout
+            android:id="@+id/friend_picker_fragment"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            />
+</LinearLayout>
+
diff --git a/samples/FriendPickerSample/res/values/strings.xml b/samples/FriendPickerSample/res/values/strings.xml
new file mode 100644
index 000000000..c22e4869c
--- /dev/null
+++ b/samples/FriendPickerSample/res/values/strings.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">FriendPickerSample</string>
+    <string name="app_id">370546396320150</string>
+</resources>
diff --git a/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerApplication.java b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerApplication.java
new file mode 100644
index 000000000..571005266
--- /dev/null
+++ b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerApplication.java
@@ -0,0 +1,36 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.friendpicker;
+
+import android.app.Application;
+import com.facebook.GraphUser;
+
+import java.util.Collection;
+
+// We use a custom Application class to store our minimal state data (which users have been selected).
+// A real-world application will likely require a more robust data model.
+public class FriendPickerApplication extends Application {
+    private Collection<GraphUser> selectedUsers;
+
+    public Collection<GraphUser> getSelectedUsers() {
+        return selectedUsers;
+    }
+
+    public void setSelectedUsers(Collection<GraphUser> selectedUsers) {
+        this.selectedUsers = selectedUsers;
+    }
+}
diff --git a/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerSampleActivity.java b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerSampleActivity.java
new file mode 100644
index 000000000..38641b72c
--- /dev/null
+++ b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerSampleActivity.java
@@ -0,0 +1,92 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.friendpicker;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+import android.text.TextUtils;
+import android.view.View;
+import android.widget.Button;
+import android.widget.TextView;
+import com.facebook.GraphUser;
+import com.facebook.Session;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+public class FriendPickerSampleActivity extends FragmentActivity {
+    private final int PICK_FRIENDS_ACTIVITY = 1;
+    private Button pickFriendsButton;
+    private TextView resultsTextView;
+
+    /**
+     * Called when the activity is first created.
+     */
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+
+        resultsTextView = (TextView) findViewById(R.id.resultsTextView);
+        pickFriendsButton = (Button) findViewById(R.id.pickFriendsButton);
+        pickFriendsButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View view) {
+                onClickPickFriends();
+            }
+        });
+
+        Session.openActiveSession(this, true);
+    }
+
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        switch (requestCode) {
+            case PICK_FRIENDS_ACTIVITY:
+                String results = "";
+                if (resultCode == RESULT_OK) {
+                    FriendPickerApplication application = (FriendPickerApplication)getApplication();
+                    Collection<GraphUser> selection = application.getSelectedUsers();
+                    if (selection != null && selection.size() > 0) {
+                        ArrayList<String> names = new ArrayList<String>();
+                        for (GraphUser user : selection) {
+                            names.add(user.getName());
+                        }
+                        results = TextUtils.join(", ", names);
+                    } else {
+                        results = "<No friends selected>";
+                    }
+                } else {
+                    results = "<Cancelled>";
+                }
+                resultsTextView.setText(results);
+                break;
+            default:
+                Session.getActiveSession().onActivityResult(this, requestCode, resultCode, data);
+                break;
+        }
+    }
+
+    private void onClickPickFriends() {
+        Intent intent = new Intent(this, PickFriendsActivity.class);
+        // Note: The following line is optional, as multi-select behavior is the default for
+        // FriendPickerFragment. It is here to demonstrate how parameters could be passed to the
+        // friend picker if single-select functionality was desired, or if a different user ID was
+        // desired (for instance, to see friends of a friend).
+        PickFriendsActivity.populateParameters(intent, null, true, true);
+        startActivityForResult(intent, PICK_FRIENDS_ACTIVITY);
+    }
+}
diff --git a/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/PickFriendsActivity.java b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/PickFriendsActivity.java
new file mode 100644
index 000000000..a15c994b1
--- /dev/null
+++ b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/PickFriendsActivity.java
@@ -0,0 +1,102 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.friendpicker;
+
+import android.app.AlertDialog;
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+import com.facebook.FacebookException;
+import com.facebook.FriendPickerFragment;
+import com.facebook.PickerFragment;
+
+// This class provides an example of an Activity that uses FriendPickerFragment to display a list of
+// the user's friends. It takes a programmatic approach to creating the FriendPickerFragment with the
+// desired parameters -- see PickPlaceActivity in the PlacePickerSample project for an example of an
+// Activity creating a fragment (in this case a PlacePickerFragment) via XML layout rather than
+// programmatically.
+public class PickFriendsActivity extends FragmentActivity {
+    FriendPickerFragment friendPickerFragment;
+
+    // A helper to simplify life for callers who want to populate a Bundle with the necessary
+    // parameters. A more sophisticated Activity might define its own set of parameters; our needs
+    // are simple, so we just populate what we want to pass to the FriendPickerFragment.
+    public static void populateParameters(Intent intent, String userId, boolean multiSelect, boolean showTitleBar) {
+        intent.putExtra(FriendPickerFragment.USER_ID_BUNDLE_KEY, userId);
+        intent.putExtra(FriendPickerFragment.MULTI_SELECT_BUNDLE_KEY, multiSelect);
+        intent.putExtra(FriendPickerFragment.SHOW_TITLE_BAR_BUNDLE_KEY, showTitleBar);
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.pick_friends_activity);
+
+        FragmentManager fm = getSupportFragmentManager();
+
+        if (savedInstanceState == null) {
+            // First time through, we create our fragment programmatically.
+            final Bundle args = getIntent().getExtras();
+            friendPickerFragment = new FriendPickerFragment(args);
+            fm.beginTransaction()
+                    .add(R.id.friend_picker_fragment, friendPickerFragment)
+                    .commit();
+        } else {
+            // Subsequent times, our fragment is recreated by the framework and already has saved and
+            // restored its state, so we don't need to specify args again. (In fact, this might be
+            // incorrect if the fragment was modified programmatically since it was created.)
+            friendPickerFragment = (FriendPickerFragment) fm.findFragmentById(R.id.friend_picker_fragment);
+        }
+
+        friendPickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
+            @Override
+            public void onError(FacebookException error) {
+                PickFriendsActivity.this.onError(error);
+            }
+        });
+
+        friendPickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
+            @Override
+            public void onDoneButtonClicked() {
+                // We just store our selection in the Application for other activities to look at.
+                FriendPickerApplication application = (FriendPickerApplication) getApplication();
+                application.setSelectedUsers(friendPickerFragment.getSelection());
+
+                setResult(RESULT_OK, null);
+                finish();
+            }
+        });
+    }
+
+    private void onError(Exception error) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setTitle("Error").setMessage(error.getMessage()).setPositiveButton("OK", null);
+        builder.show();
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        try {
+            // Load data, unless a query has already taken place.
+            friendPickerFragment.loadData(false);
+        } catch (Exception ex) {
+            onError(ex);
+        }
+    }
+}
diff --git a/samples/Hackbook/.classpath b/samples/Hackbook/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/Hackbook/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/Hackbook/.project b/samples/Hackbook/.project
new file mode 100644
index 000000000..c453fce2f
--- /dev/null
+++ b/samples/Hackbook/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Hackbook</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/examples/Hackbook/AndroidManifest.xml b/samples/Hackbook/AndroidManifest.xml
similarity index 94%
rename from examples/Hackbook/AndroidManifest.xml
rename to samples/Hackbook/AndroidManifest.xml
index bc3ea853b..3d48e43b5 100644
--- a/examples/Hackbook/AndroidManifest.xml
+++ b/samples/Hackbook/AndroidManifest.xml
@@ -21,7 +21,8 @@
         </activity>
         <activity android:name=".Hackbook"
             android:label="@string/app_name"
-            android:configChanges="keyboardHidden|orientation">
+            android:configChanges="keyboardHidden|orientation"
+            android:windowSoftInputMode="adjustResize">
         </activity>
         <activity
             android:name=".GraphExplorer"
diff --git a/samples/Hackbook/Hackbook.eml b/samples/Hackbook/Hackbook.eml
new file mode 100644
index 000000000..4104d1ffc
--- /dev/null
+++ b/samples/Hackbook/Hackbook.eml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<component>
+	<exclude-output/>
+	<contentEntry url="file://$MODULE_DIR$"/>
+</component>
diff --git a/samples/Hackbook/Hackbook.iml b/samples/Hackbook/Hackbook.iml
new file mode 100644
index 000000000..c17db1f0a
--- /dev/null
+++ b/samples/Hackbook/Hackbook.iml
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="EclipseModuleManager" forced_jdk="true">
+    <conelement value="com.android.ide.eclipse.adt.LIBRARIES" />
+    <src_description expected_position="1">
+      <src_folder value="file://$MODULE_DIR$/src" expected_position="0" />
+      <src_folder value="file://$MODULE_DIR$/gen" expected_position="1" />
+    </src_description>
+  </component>
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/bin/classes" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+  </component>
+</module>
+
diff --git a/examples/Hackbook/README.md b/samples/Hackbook/README.md
similarity index 100%
rename from examples/Hackbook/README.md
rename to samples/Hackbook/README.md
diff --git a/examples/Hackbook/build.xml b/samples/Hackbook/build.xml
similarity index 100%
rename from examples/Hackbook/build.xml
rename to samples/Hackbook/build.xml
diff --git a/examples/Hackbook/default.properties b/samples/Hackbook/default.properties
similarity index 100%
rename from examples/Hackbook/default.properties
rename to samples/Hackbook/default.properties
diff --git a/samples/Hackbook/proguard-project.txt b/samples/Hackbook/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/Hackbook/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/examples/Hackbook/project.properties b/samples/Hackbook/project.properties
similarity index 100%
rename from examples/Hackbook/project.properties
rename to samples/Hackbook/project.properties
index 1998897e5..d97d486bd 100644
--- a/examples/Hackbook/project.properties
+++ b/samples/Hackbook/project.properties
@@ -12,6 +12,6 @@
 
 # Indicates whether an apk should be generated for each density.
 split.density=false
-android.library.reference.1=../../facebook
 # Project target.
 target=android-8
+android.library.reference.1=../../facebook
diff --git a/examples/Hackbook/res/drawable-hdpi/splash.png b/samples/Hackbook/res/drawable-hdpi/splash.png
similarity index 100%
rename from examples/Hackbook/res/drawable-hdpi/splash.png
rename to samples/Hackbook/res/drawable-hdpi/splash.png
diff --git a/examples/Hackbook/res/drawable/icon.png b/samples/Hackbook/res/drawable/icon.png
similarity index 100%
rename from examples/Hackbook/res/drawable/icon.png
rename to samples/Hackbook/res/drawable/icon.png
diff --git a/examples/Hackbook/res/drawable/icon_hack.png b/samples/Hackbook/res/drawable/icon_hack.png
similarity index 100%
rename from examples/Hackbook/res/drawable/icon_hack.png
rename to samples/Hackbook/res/drawable/icon_hack.png
diff --git a/examples/Hackbook/res/drawable/login.png b/samples/Hackbook/res/drawable/login.png
similarity index 100%
rename from examples/Hackbook/res/drawable/login.png
rename to samples/Hackbook/res/drawable/login.png
diff --git a/examples/Hackbook/res/drawable/login_button.xml b/samples/Hackbook/res/drawable/login_button.xml
similarity index 100%
rename from examples/Hackbook/res/drawable/login_button.xml
rename to samples/Hackbook/res/drawable/login_button.xml
diff --git a/examples/Hackbook/res/drawable/login_down.png b/samples/Hackbook/res/drawable/login_down.png
similarity index 100%
rename from examples/Hackbook/res/drawable/login_down.png
rename to samples/Hackbook/res/drawable/login_down.png
diff --git a/examples/Hackbook/res/drawable/logout.png b/samples/Hackbook/res/drawable/logout.png
similarity index 100%
rename from examples/Hackbook/res/drawable/logout.png
rename to samples/Hackbook/res/drawable/logout.png
diff --git a/examples/Hackbook/res/drawable/logout_button.xml b/samples/Hackbook/res/drawable/logout_button.xml
similarity index 100%
rename from examples/Hackbook/res/drawable/logout_button.xml
rename to samples/Hackbook/res/drawable/logout_button.xml
diff --git a/examples/Hackbook/res/drawable/logout_down.png b/samples/Hackbook/res/drawable/logout_down.png
similarity index 100%
rename from examples/Hackbook/res/drawable/logout_down.png
rename to samples/Hackbook/res/drawable/logout_down.png
diff --git a/examples/Hackbook/res/drawable/me.png b/samples/Hackbook/res/drawable/me.png
similarity index 100%
rename from examples/Hackbook/res/drawable/me.png
rename to samples/Hackbook/res/drawable/me.png
diff --git a/examples/Hackbook/res/drawable/splash.png b/samples/Hackbook/res/drawable/splash.png
similarity index 100%
rename from examples/Hackbook/res/drawable/splash.png
rename to samples/Hackbook/res/drawable/splash.png
diff --git a/examples/Hackbook/res/drawable/x.png b/samples/Hackbook/res/drawable/x.png
similarity index 100%
rename from examples/Hackbook/res/drawable/x.png
rename to samples/Hackbook/res/drawable/x.png
diff --git a/examples/Hackbook/res/layout-land/main.xml b/samples/Hackbook/res/layout-land/main.xml
similarity index 100%
rename from examples/Hackbook/res/layout-land/main.xml
rename to samples/Hackbook/res/layout-land/main.xml
diff --git a/examples/Hackbook/res/layout-port/main.xml b/samples/Hackbook/res/layout-port/main.xml
similarity index 100%
rename from examples/Hackbook/res/layout-port/main.xml
rename to samples/Hackbook/res/layout-port/main.xml
diff --git a/examples/Hackbook/res/layout/connection_item.xml b/samples/Hackbook/res/layout/connection_item.xml
similarity index 100%
rename from examples/Hackbook/res/layout/connection_item.xml
rename to samples/Hackbook/res/layout/connection_item.xml
diff --git a/examples/Hackbook/res/layout/fields_connections_list.xml b/samples/Hackbook/res/layout/fields_connections_list.xml
similarity index 100%
rename from examples/Hackbook/res/layout/fields_connections_list.xml
rename to samples/Hackbook/res/layout/fields_connections_list.xml
diff --git a/examples/Hackbook/res/layout/fields_item.xml b/samples/Hackbook/res/layout/fields_item.xml
similarity index 100%
rename from examples/Hackbook/res/layout/fields_item.xml
rename to samples/Hackbook/res/layout/fields_item.xml
diff --git a/examples/Hackbook/res/layout/fql_query.xml b/samples/Hackbook/res/layout/fql_query.xml
similarity index 100%
rename from examples/Hackbook/res/layout/fql_query.xml
rename to samples/Hackbook/res/layout/fql_query.xml
diff --git a/examples/Hackbook/res/layout/friend_item.xml b/samples/Hackbook/res/layout/friend_item.xml
similarity index 100%
rename from examples/Hackbook/res/layout/friend_item.xml
rename to samples/Hackbook/res/layout/friend_item.xml
diff --git a/examples/Hackbook/res/layout/friends_list.xml b/samples/Hackbook/res/layout/friends_list.xml
similarity index 100%
rename from examples/Hackbook/res/layout/friends_list.xml
rename to samples/Hackbook/res/layout/friends_list.xml
diff --git a/examples/Hackbook/res/layout/graph_explorer.xml b/samples/Hackbook/res/layout/graph_explorer.xml
similarity index 100%
rename from examples/Hackbook/res/layout/graph_explorer.xml
rename to samples/Hackbook/res/layout/graph_explorer.xml
diff --git a/examples/Hackbook/res/layout/main_list_item.xml b/samples/Hackbook/res/layout/main_list_item.xml
similarity index 100%
rename from examples/Hackbook/res/layout/main_list_item.xml
rename to samples/Hackbook/res/layout/main_list_item.xml
diff --git a/examples/Hackbook/res/layout/permission_item.xml b/samples/Hackbook/res/layout/permission_item.xml
similarity index 100%
rename from examples/Hackbook/res/layout/permission_item.xml
rename to samples/Hackbook/res/layout/permission_item.xml
diff --git a/examples/Hackbook/res/layout/permissions_list.xml b/samples/Hackbook/res/layout/permissions_list.xml
similarity index 100%
rename from examples/Hackbook/res/layout/permissions_list.xml
rename to samples/Hackbook/res/layout/permissions_list.xml
diff --git a/examples/Hackbook/res/layout/place_item.xml b/samples/Hackbook/res/layout/place_item.xml
similarity index 100%
rename from examples/Hackbook/res/layout/place_item.xml
rename to samples/Hackbook/res/layout/place_item.xml
diff --git a/examples/Hackbook/res/layout/places_list.xml b/samples/Hackbook/res/layout/places_list.xml
similarity index 100%
rename from examples/Hackbook/res/layout/places_list.xml
rename to samples/Hackbook/res/layout/places_list.xml
diff --git a/examples/Hackbook/res/layout/splash.xml b/samples/Hackbook/res/layout/splash.xml
similarity index 100%
rename from examples/Hackbook/res/layout/splash.xml
rename to samples/Hackbook/res/layout/splash.xml
diff --git a/examples/Hackbook/res/layout/token_refresh.xml b/samples/Hackbook/res/layout/token_refresh.xml
similarity index 100%
rename from examples/Hackbook/res/layout/token_refresh.xml
rename to samples/Hackbook/res/layout/token_refresh.xml
diff --git a/examples/Hackbook/res/layout/update_post_response.xml b/samples/Hackbook/res/layout/update_post_response.xml
similarity index 100%
rename from examples/Hackbook/res/layout/update_post_response.xml
rename to samples/Hackbook/res/layout/update_post_response.xml
diff --git a/examples/Hackbook/res/layout/upload_photo_response.xml b/samples/Hackbook/res/layout/upload_photo_response.xml
similarity index 100%
rename from examples/Hackbook/res/layout/upload_photo_response.xml
rename to samples/Hackbook/res/layout/upload_photo_response.xml
diff --git a/examples/Hackbook/res/values/colors.xml b/samples/Hackbook/res/values/colors.xml
similarity index 100%
rename from examples/Hackbook/res/values/colors.xml
rename to samples/Hackbook/res/values/colors.xml
diff --git a/examples/Hackbook/res/values/strings.xml b/samples/Hackbook/res/values/strings.xml
similarity index 100%
rename from examples/Hackbook/res/values/strings.xml
rename to samples/Hackbook/res/values/strings.xml
diff --git a/examples/Hackbook/src/com/facebook/android/BaseDialogListener.java b/samples/Hackbook/src/com/facebook/android/BaseDialogListener.java
similarity index 100%
rename from examples/Hackbook/src/com/facebook/android/BaseDialogListener.java
rename to samples/Hackbook/src/com/facebook/android/BaseDialogListener.java
diff --git a/examples/Hackbook/src/com/facebook/android/BaseRequestListener.java b/samples/Hackbook/src/com/facebook/android/BaseRequestListener.java
similarity index 99%
rename from examples/Hackbook/src/com/facebook/android/BaseRequestListener.java
rename to samples/Hackbook/src/com/facebook/android/BaseRequestListener.java
index 0e7809f07..b19966cff 100644
--- a/examples/Hackbook/src/com/facebook/android/BaseRequestListener.java
+++ b/samples/Hackbook/src/com/facebook/android/BaseRequestListener.java
@@ -1,13 +1,12 @@
 package com.facebook.android;
 
+import android.util.Log;
+import com.facebook.android.AsyncFacebookRunner.RequestListener;
+
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.net.MalformedURLException;
 
-import android.util.Log;
-
-import com.facebook.android.AsyncFacebookRunner.RequestListener;
-
 /**
  * Skeleton base class for RequestListeners, providing default error handling.
  * Applications should handle these error conditions.
diff --git a/examples/Hackbook/src/com/facebook/android/FQLQuery.java b/samples/Hackbook/src/com/facebook/android/FQLQuery.java
similarity index 99%
rename from examples/Hackbook/src/com/facebook/android/FQLQuery.java
rename to samples/Hackbook/src/com/facebook/android/FQLQuery.java
index 1c2e92b3c..abd038cad 100644
--- a/examples/Hackbook/src/com/facebook/android/FQLQuery.java
+++ b/samples/Hackbook/src/com/facebook/android/FQLQuery.java
@@ -1,9 +1,5 @@
 package com.facebook.android;
 
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
 import android.app.Activity;
 import android.app.Dialog;
 import android.app.ProgressDialog;
@@ -16,6 +12,9 @@
 import android.widget.Button;
 import android.widget.EditText;
 import android.widget.TextView;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
 
 public class FQLQuery extends Dialog {
 
diff --git a/examples/Hackbook/src/com/facebook/android/FieldsConnectionsDialog.java b/samples/Hackbook/src/com/facebook/android/FieldsConnectionsDialog.java
similarity index 96%
rename from examples/Hackbook/src/com/facebook/android/FieldsConnectionsDialog.java
rename to samples/Hackbook/src/com/facebook/android/FieldsConnectionsDialog.java
index 9308301d4..91d15f27e 100644
--- a/examples/Hackbook/src/com/facebook/android/FieldsConnectionsDialog.java
+++ b/samples/Hackbook/src/com/facebook/android/FieldsConnectionsDialog.java
@@ -1,14 +1,5 @@
 package com.facebook.android;
 
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Vector;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
 import android.app.Dialog;
 import android.os.Bundle;
 import android.text.SpannableString;
@@ -17,19 +8,18 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewGroup.LayoutParams;
-import android.widget.AdapterView;
+import android.widget.*;
 import android.widget.AdapterView.OnItemClickListener;
-import android.widget.ArrayAdapter;
-import android.widget.BaseAdapter;
-import android.widget.Button;
-import android.widget.CheckBox;
-import android.widget.CompoundButton;
 import android.widget.CompoundButton.OnCheckedChangeListener;
-import android.widget.ListView;
-import android.widget.TabHost;
 import android.widget.TabHost.TabSpec;
-import android.widget.TextView;
-import android.widget.Toast;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Vector;
 
 public class FieldsConnectionsDialog extends Dialog {
 
diff --git a/examples/Hackbook/src/com/facebook/android/FriendsGetProfilePics.java b/samples/Hackbook/src/com/facebook/android/FriendsGetProfilePics.java
similarity index 100%
rename from examples/Hackbook/src/com/facebook/android/FriendsGetProfilePics.java
rename to samples/Hackbook/src/com/facebook/android/FriendsGetProfilePics.java
index b2bbd046c..f29c1cfff 100644
--- a/examples/Hackbook/src/com/facebook/android/FriendsGetProfilePics.java
+++ b/samples/Hackbook/src/com/facebook/android/FriendsGetProfilePics.java
@@ -1,12 +1,12 @@
 package com.facebook.android;
 
-import java.util.Hashtable;
-import java.util.Stack;
-
 import android.graphics.Bitmap;
 import android.os.AsyncTask;
 import android.widget.BaseAdapter;
 
+import java.util.Hashtable;
+import java.util.Stack;
+
 /*
  * Fetch friends profile pictures request via AsyncTask
  */
diff --git a/examples/Hackbook/src/com/facebook/android/FriendsList.java b/samples/Hackbook/src/com/facebook/android/FriendsList.java
similarity index 96%
rename from examples/Hackbook/src/com/facebook/android/FriendsList.java
rename to samples/Hackbook/src/com/facebook/android/FriendsList.java
index 3c8d871eb..57507b8f1 100644
--- a/examples/Hackbook/src/com/facebook/android/FriendsList.java
+++ b/samples/Hackbook/src/com/facebook/android/FriendsList.java
@@ -1,9 +1,5 @@
 package com.facebook.android;
 
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.content.DialogInterface;
@@ -12,13 +8,11 @@
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.AdapterView;
+import android.widget.*;
 import android.widget.AdapterView.OnItemClickListener;
-import android.widget.BaseAdapter;
-import android.widget.ImageView;
-import android.widget.ListView;
-import android.widget.TextView;
-import android.widget.Toast;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
 
 public class FriendsList extends Activity implements OnItemClickListener {
     private Handler mHandler;
@@ -161,7 +155,6 @@ public View getView(int position, View convertView, ViewGroup parent) {
             try {
                 jsonObject = jsonArray.getJSONObject(position);
             } catch (JSONException e1) {
-                // TODO Auto-generated catch block
                 e1.printStackTrace();
             }
             View hView = convertView;
diff --git a/examples/Hackbook/src/com/facebook/android/GraphExplorer.java b/samples/Hackbook/src/com/facebook/android/GraphExplorer.java
similarity index 98%
rename from examples/Hackbook/src/com/facebook/android/GraphExplorer.java
rename to samples/Hackbook/src/com/facebook/android/GraphExplorer.java
index 094ab738d..097b02006 100644
--- a/examples/Hackbook/src/com/facebook/android/GraphExplorer.java
+++ b/samples/Hackbook/src/com/facebook/android/GraphExplorer.java
@@ -4,14 +4,6 @@
  * The me, delete and back_parent buttons are downloaded from http://icongal.com/
  */
 
-import java.util.Iterator;
-import java.util.Vector;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
 import android.app.Activity;
 import android.app.ProgressDialog;
 import android.content.Context;
@@ -25,11 +17,14 @@
 import android.view.View;
 import android.view.View.OnClickListener;
 import android.view.inputmethod.InputMethodManager;
-import android.widget.Button;
-import android.widget.EditText;
-import android.widget.ScrollView;
-import android.widget.TextView;
-import android.widget.Toast;
+import android.widget.*;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.Iterator;
+import java.util.Vector;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 public class GraphExplorer extends Activity {
     private Button mSubmitButton, mViewURLButton;
diff --git a/examples/Hackbook/src/com/facebook/android/Hackbook.java b/samples/Hackbook/src/com/facebook/android/Hackbook.java
similarity index 98%
rename from examples/Hackbook/src/com/facebook/android/Hackbook.java
rename to samples/Hackbook/src/com/facebook/android/Hackbook.java
index 7b9b4e3d4..0178eed6a 100644
--- a/examples/Hackbook/src/com/facebook/android/Hackbook.java
+++ b/samples/Hackbook/src/com/facebook/android/Hackbook.java
@@ -16,11 +16,6 @@
 
 package com.facebook.android;
 
-import java.io.IOException;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.app.ProgressDialog;
@@ -33,17 +28,14 @@
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.AdapterView;
+import android.widget.*;
 import android.widget.AdapterView.OnItemClickListener;
-import android.widget.ArrayAdapter;
-import android.widget.BaseAdapter;
-import android.widget.ImageView;
-import android.widget.ListView;
-import android.widget.TextView;
-import android.widget.Toast;
-
 import com.facebook.android.SessionEvents.AuthListener;
 import com.facebook.android.SessionEvents.LogoutListener;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
 
 public class Hackbook extends Activity implements OnItemClickListener {
 
@@ -523,7 +515,6 @@ public void run() {
                 });
 
             } catch (JSONException e) {
-                // TODO Auto-generated catch block
                 e.printStackTrace();
             }
         }
diff --git a/examples/Hackbook/src/com/facebook/android/IntentUriHandler.java b/samples/Hackbook/src/com/facebook/android/IntentUriHandler.java
similarity index 100%
rename from examples/Hackbook/src/com/facebook/android/IntentUriHandler.java
rename to samples/Hackbook/src/com/facebook/android/IntentUriHandler.java
diff --git a/examples/Hackbook/src/com/facebook/android/LoginButton.java b/samples/Hackbook/src/com/facebook/android/LoginButton.java
similarity index 99%
rename from examples/Hackbook/src/com/facebook/android/LoginButton.java
rename to samples/Hackbook/src/com/facebook/android/LoginButton.java
index ae9b6bedb..c1f984260 100644
--- a/examples/Hackbook/src/com/facebook/android/LoginButton.java
+++ b/samples/Hackbook/src/com/facebook/android/LoginButton.java
@@ -24,7 +24,6 @@
 import android.util.AttributeSet;
 import android.view.View;
 import android.widget.ImageButton;
-
 import com.facebook.android.Facebook.DialogListener;
 import com.facebook.android.SessionEvents.AuthListener;
 import com.facebook.android.SessionEvents.LogoutListener;
diff --git a/examples/Hackbook/src/com/facebook/android/PermissionsDialog.java b/samples/Hackbook/src/com/facebook/android/PermissionsDialog.java
similarity index 97%
rename from examples/Hackbook/src/com/facebook/android/PermissionsDialog.java
rename to samples/Hackbook/src/com/facebook/android/PermissionsDialog.java
index fa4edbbd8..a7ad7a421 100644
--- a/examples/Hackbook/src/com/facebook/android/PermissionsDialog.java
+++ b/samples/Hackbook/src/com/facebook/android/PermissionsDialog.java
@@ -1,7 +1,5 @@
 package com.facebook.android;
 
-import java.util.Vector;
-
 import android.app.Activity;
 import android.app.Dialog;
 import android.graphics.Color;
@@ -11,19 +9,13 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewGroup.LayoutParams;
-import android.widget.BaseAdapter;
-import android.widget.Button;
-import android.widget.CheckBox;
-import android.widget.CompoundButton;
+import android.widget.*;
 import android.widget.CompoundButton.OnCheckedChangeListener;
-import android.widget.ListView;
-import android.widget.TabHost;
 import android.widget.TabHost.TabSpec;
-import android.widget.TextView;
-import android.widget.Toast;
-
 import com.facebook.android.Facebook.DialogListener;
 
+import java.util.Vector;
+
 public class PermissionsDialog extends Dialog {
 
     private final static int TAB_HEIGHT = 50;
diff --git a/examples/Hackbook/src/com/facebook/android/Places.java b/samples/Hackbook/src/com/facebook/android/Places.java
similarity index 98%
rename from examples/Hackbook/src/com/facebook/android/Places.java
rename to samples/Hackbook/src/com/facebook/android/Places.java
index 4d5e42a4c..01f040886 100644
--- a/examples/Hackbook/src/com/facebook/android/Places.java
+++ b/samples/Hackbook/src/com/facebook/android/Places.java
@@ -1,9 +1,5 @@
 package com.facebook.android;
 
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.app.ProgressDialog;
@@ -21,12 +17,11 @@
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.AdapterView;
+import android.widget.*;
 import android.widget.AdapterView.OnItemClickListener;
-import android.widget.BaseAdapter;
-import android.widget.ListView;
-import android.widget.TextView;
-import android.widget.Toast;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
 
 public class Places extends Activity implements OnItemClickListener {
     private Handler mHandler;
@@ -294,7 +289,6 @@ public View getView(int position, View convertView, ViewGroup parent) {
             try {
                 jsonObject = jsonArray.getJSONObject(position);
             } catch (JSONException e1) {
-                // TODO Auto-generated catch block
                 e1.printStackTrace();
             }
             View hView = convertView;
diff --git a/examples/Hackbook/src/com/facebook/android/SessionEvents.java b/samples/Hackbook/src/com/facebook/android/SessionEvents.java
similarity index 100%
rename from examples/Hackbook/src/com/facebook/android/SessionEvents.java
rename to samples/Hackbook/src/com/facebook/android/SessionEvents.java
diff --git a/examples/Hackbook/src/com/facebook/android/SessionStore.java b/samples/Hackbook/src/com/facebook/android/SessionStore.java
similarity index 100%
rename from examples/Hackbook/src/com/facebook/android/SessionStore.java
rename to samples/Hackbook/src/com/facebook/android/SessionStore.java
diff --git a/examples/Hackbook/src/com/facebook/android/SplashActivity.java b/samples/Hackbook/src/com/facebook/android/SplashActivity.java
similarity index 100%
rename from examples/Hackbook/src/com/facebook/android/SplashActivity.java
rename to samples/Hackbook/src/com/facebook/android/SplashActivity.java
index d288acba7..d1fc5be2d 100644
--- a/examples/Hackbook/src/com/facebook/android/SplashActivity.java
+++ b/samples/Hackbook/src/com/facebook/android/SplashActivity.java
@@ -1,12 +1,12 @@
 package com.facebook.android;
 
-import java.util.Timer;
-import java.util.TimerTask;
-
 import android.app.Activity;
 import android.content.Intent;
 import android.os.Bundle;
 
+import java.util.Timer;
+import java.util.TimerTask;
+
 public class SplashActivity extends Activity {
     private long splashDelay = 1500;
 
diff --git a/examples/Hackbook/src/com/facebook/android/TokenRefreshDialog.java b/samples/Hackbook/src/com/facebook/android/TokenRefreshDialog.java
similarity index 100%
rename from examples/Hackbook/src/com/facebook/android/TokenRefreshDialog.java
rename to samples/Hackbook/src/com/facebook/android/TokenRefreshDialog.java
index aeb147b15..e40d3df4a 100644
--- a/examples/Hackbook/src/com/facebook/android/TokenRefreshDialog.java
+++ b/samples/Hackbook/src/com/facebook/android/TokenRefreshDialog.java
@@ -1,8 +1,5 @@
 package com.facebook.android;
 
-import java.text.DateFormat;
-import java.util.Date;
-
 import android.app.Activity;
 import android.app.Dialog;
 import android.os.Bundle;
@@ -12,6 +9,9 @@
 import android.widget.EditText;
 import android.widget.TextView;
 
+import java.text.DateFormat;
+import java.util.Date;
+
 public class TokenRefreshDialog extends Dialog {
 
     private EditText tokenEdit, tokenExpiresEdit;
diff --git a/examples/Hackbook/src/com/facebook/android/UpdateStatusResultDialog.java b/samples/Hackbook/src/com/facebook/android/UpdateStatusResultDialog.java
similarity index 99%
rename from examples/Hackbook/src/com/facebook/android/UpdateStatusResultDialog.java
rename to samples/Hackbook/src/com/facebook/android/UpdateStatusResultDialog.java
index 463b42535..3c6dc7f4c 100644
--- a/examples/Hackbook/src/com/facebook/android/UpdateStatusResultDialog.java
+++ b/samples/Hackbook/src/com/facebook/android/UpdateStatusResultDialog.java
@@ -1,8 +1,5 @@
 package com.facebook.android;
 
-import org.json.JSONException;
-import org.json.JSONObject;
-
 import android.app.Activity;
 import android.app.Dialog;
 import android.os.Bundle;
@@ -12,6 +9,8 @@
 import android.view.ViewGroup.LayoutParams;
 import android.widget.Button;
 import android.widget.TextView;
+import org.json.JSONException;
+import org.json.JSONObject;
 
 public class UpdateStatusResultDialog extends Dialog {
 
diff --git a/examples/Hackbook/src/com/facebook/android/UploadPhotoResultDialog.java b/samples/Hackbook/src/com/facebook/android/UploadPhotoResultDialog.java
similarity index 99%
rename from examples/Hackbook/src/com/facebook/android/UploadPhotoResultDialog.java
rename to samples/Hackbook/src/com/facebook/android/UploadPhotoResultDialog.java
index 173aae343..6ae234552 100644
--- a/examples/Hackbook/src/com/facebook/android/UploadPhotoResultDialog.java
+++ b/samples/Hackbook/src/com/facebook/android/UploadPhotoResultDialog.java
@@ -1,8 +1,5 @@
 package com.facebook.android;
 
-import org.json.JSONException;
-import org.json.JSONObject;
-
 import android.app.Activity;
 import android.app.Dialog;
 import android.app.ProgressDialog;
@@ -17,6 +14,8 @@
 import android.widget.Button;
 import android.widget.ImageView;
 import android.widget.TextView;
+import org.json.JSONException;
+import org.json.JSONObject;
 
 public class UploadPhotoResultDialog extends Dialog {
 
diff --git a/examples/Hackbook/src/com/facebook/android/Utility.java b/samples/Hackbook/src/com/facebook/android/Utility.java
similarity index 97%
rename from examples/Hackbook/src/com/facebook/android/Utility.java
rename to samples/Hackbook/src/com/facebook/android/Utility.java
index 8f13d2379..56eff55da 100644
--- a/examples/Hackbook/src/com/facebook/android/Utility.java
+++ b/samples/Hackbook/src/com/facebook/android/Utility.java
@@ -1,16 +1,5 @@
 package com.facebook.android;
 
-import java.io.BufferedInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.FilterInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URL;
-import java.net.URLConnection;
-import java.util.Hashtable;
-
-import org.json.JSONObject;
-
 import android.app.Application;
 import android.content.Context;
 import android.database.Cursor;
@@ -20,6 +9,12 @@
 import android.net.Uri;
 import android.net.http.AndroidHttpClient;
 import android.provider.MediaStore;
+import org.json.JSONObject;
+
+import java.io.*;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.Hashtable;
 
 public class Utility extends Application {
 
diff --git a/samples/HelloFacebookSample/.classpath b/samples/HelloFacebookSample/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/HelloFacebookSample/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/HelloFacebookSample/.project b/samples/HelloFacebookSample/.project
new file mode 100644
index 000000000..cb52d544b
--- /dev/null
+++ b/samples/HelloFacebookSample/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>HelloFacebookSample</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/samples/HelloFacebookSample/AndroidManifest.xml b/samples/HelloFacebookSample/AndroidManifest.xml
new file mode 100644
index 000000000..884680908
--- /dev/null
+++ b/samples/HelloFacebookSample/AndroidManifest.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.facebook.samples.hellofacebook"
+          android:versionCode="1"
+          android:versionName="1.0">
+    <uses-sdk android:minSdkVersion="8"/>
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+    <application android:label="@string/app_name"
+                 android:icon="@drawable/icon"
+                 android:theme="@android:style/Theme.NoTitleBar"
+                 android:name=".HelloFacebookApplication"
+            >
+        <activity android:name=".HelloFacebookSampleActivity"
+                  android:label="@string/app_name"
+                  android:windowSoftInputMode="adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+        <activity android:name="PickFriendsActivity"
+                  android:label="Pick Friends">
+        </activity>
+        <activity android:name="PickPlaceActivity"
+                  android:label="Pick Place">
+        </activity>
+        <activity android:name="com.facebook.LoginActivity"
+                  android:label="@string/app_name" />
+    </application>
+</manifest>
diff --git a/samples/HelloFacebookSample/HelloFacebookSample.iml b/samples/HelloFacebookSample/HelloFacebookSample.iml
new file mode 100644
index 000000000..bca109a37
--- /dev/null
+++ b/samples/HelloFacebookSample/HelloFacebookSample.iml
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/samples/HelloFacebookSample/ant.properties b/samples/HelloFacebookSample/ant.properties
new file mode 100644
index 000000000..b0971e891
--- /dev/null
+++ b/samples/HelloFacebookSample/ant.properties
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff --git a/samples/HelloFacebookSample/build.xml b/samples/HelloFacebookSample/build.xml
new file mode 100644
index 000000000..3c65e4a79
--- /dev/null
+++ b/samples/HelloFacebookSample/build.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="HelloFacebookSample" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties"/>
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties"/>
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env"/>
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME"/>
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties"/>
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+            />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true"/>
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml"/>
+
+</project>
diff --git a/samples/HelloFacebookSample/proguard-project.txt b/samples/HelloFacebookSample/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/HelloFacebookSample/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/samples/HelloFacebookSample/project.properties b/samples/HelloFacebookSample/project.properties
new file mode 100644
index 000000000..cee0509c6
--- /dev/null
+++ b/samples/HelloFacebookSample/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+android.library.reference.1=../../facebook
diff --git a/samples/HelloFacebookSample/res/drawable-hdpi/icon.png b/samples/HelloFacebookSample/res/drawable-hdpi/icon.png
new file mode 100644
index 000000000..e603120e1
Binary files /dev/null and b/samples/HelloFacebookSample/res/drawable-hdpi/icon.png differ
diff --git a/samples/HelloFacebookSample/res/drawable-mdpi/icon.png b/samples/HelloFacebookSample/res/drawable-mdpi/icon.png
new file mode 100644
index 000000000..f2fc84fb6
Binary files /dev/null and b/samples/HelloFacebookSample/res/drawable-mdpi/icon.png differ
diff --git a/samples/HelloFacebookSample/res/drawable-xhdpi/icon.png b/samples/HelloFacebookSample/res/drawable-xhdpi/icon.png
new file mode 100644
index 000000000..143a69f21
Binary files /dev/null and b/samples/HelloFacebookSample/res/drawable-xhdpi/icon.png differ
diff --git a/samples/HelloFacebookSample/res/drawable/icon.png b/samples/HelloFacebookSample/res/drawable/icon.png
new file mode 100644
index 000000000..f2fc84fb6
Binary files /dev/null and b/samples/HelloFacebookSample/res/drawable/icon.png differ
diff --git a/samples/HelloFacebookSample/res/layout/main.xml b/samples/HelloFacebookSample/res/layout/main.xml
new file mode 100644
index 000000000..621a9bfe8
--- /dev/null
+++ b/samples/HelloFacebookSample/res/layout/main.xml
@@ -0,0 +1,64 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              xmlns:facebook="http://schemas.android.com/apk/res-auto"
+              android:orientation="vertical"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+              android:background="#FFF"
+        >
+    <com.facebook.LoginButton
+            android:id="@+id/login_button"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="5dp"
+            facebook:confirm_logout="false"
+            facebook:fetch_user_info="true"
+             />
+    <LinearLayout
+            android:layout_width="150dp"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:gravity="center_horizontal"
+            android:orientation="vertical">
+        <TextView
+                android:id="@+id/greeting"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginLeft="10dp"
+                android:layout_gravity="center"
+                android:textColor="#333"
+                android:textSize="18sp" />
+        <com.facebook.ProfilePictureView
+                android:id="@+id/profilePicture"
+                android:layout_height="wrap_content"
+                android:layout_width="wrap_content"
+                android:gravity="center_horizontal"
+                android:layout_marginBottom="10dp"
+                facebook:preset_size="normal" />
+        <Button
+                android:id="@+id/postStatusUpdateButton"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:text="Post Status Update"
+                />
+        <Button
+                android:id="@+id/postPhotoButton"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:text="Post Photo"
+                />
+        <Button
+                android:id="@+id/pickFriendsButton"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:text="Pick Some Friends"
+                />
+        <Button
+                android:id="@+id/pickPlaceButton"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:text="Pick Place"
+                />
+    </LinearLayout>
+</LinearLayout>
+
diff --git a/samples/HelloFacebookSample/res/layout/pick_friends_activity.xml b/samples/HelloFacebookSample/res/layout/pick_friends_activity.xml
new file mode 100644
index 000000000..3110f96ce
--- /dev/null
+++ b/samples/HelloFacebookSample/res/layout/pick_friends_activity.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:orientation="vertical"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+        >
+    <FrameLayout
+            android:id="@+id/friend_picker_fragment"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            />
+</LinearLayout>
+
diff --git a/samples/HelloFacebookSample/res/layout/pick_place_activity.xml b/samples/HelloFacebookSample/res/layout/pick_place_activity.xml
new file mode 100644
index 000000000..27e5b8d3f
--- /dev/null
+++ b/samples/HelloFacebookSample/res/layout/pick_place_activity.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              xmlns:app="http://schemas.android.com/apk/res-auto"
+              android:orientation="vertical"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+        >
+    <fragment
+            android:id="@+id/place_picker_fragment"
+            android:name="com.facebook.PlacePickerFragment"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            app:show_pictures="true"
+            app:show_search_box="true"
+            />
+</LinearLayout>
+
diff --git a/samples/HelloFacebookSample/res/values/strings.xml b/samples/HelloFacebookSample/res/values/strings.xml
new file mode 100644
index 000000000..0fca51e10
--- /dev/null
+++ b/samples/HelloFacebookSample/res/values/strings.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">HelloFacebookSample</string>
+</resources>
diff --git a/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookApplication.java b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookApplication.java
new file mode 100644
index 000000000..2a489df37
--- /dev/null
+++ b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookApplication.java
@@ -0,0 +1,46 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.hellofacebook;
+
+import android.app.Application;
+import com.facebook.GraphPlace;
+import com.facebook.GraphUser;
+
+import java.util.Collection;
+
+// We use a custom Application class to store our minimal state data (which users have been selected).
+// A real-world application will likely require a more robust data model.
+public class HelloFacebookApplication extends Application {
+    private Collection<GraphUser> selectedUsers;
+    private GraphPlace selectedPlace;
+
+    public Collection<GraphUser> getSelectedUsers() {
+        return selectedUsers;
+    }
+
+    public void setSelectedUsers(Collection<GraphUser> selectedUsers) {
+        this.selectedUsers = selectedUsers;
+    }
+
+    public GraphPlace getSelectedPlace() {
+        return selectedPlace;
+    }
+
+    public void setSelectedPlace(GraphPlace selectedPlace) {
+        this.selectedPlace = selectedPlace;
+    }
+}
diff --git a/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookSampleActivity.java b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookSampleActivity.java
new file mode 100644
index 000000000..b964b03bc
--- /dev/null
+++ b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookSampleActivity.java
@@ -0,0 +1,343 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.hellofacebook;
+
+import android.app.AlertDialog;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.location.Location;
+import android.os.Bundle;
+import android.support.v4.content.LocalBroadcastManager;
+import android.text.TextUtils;
+import android.view.View;
+import android.widget.Button;
+import android.widget.TextView;
+import com.facebook.*;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Date;
+import java.util.List;
+
+public class HelloFacebookSampleActivity extends FacebookActivity {
+    @SuppressWarnings("serial")
+    private static final List<String> PERMISSIONS = new ArrayList<String>() {{
+        add("publish_actions");
+    }};
+
+    private final int PICK_FRIENDS_ACTIVITY = 1;
+    private final int PICK_PLACE_ACTIVITY = 2;
+    private final int REAUTHORIZE_ACTIVITY = 3;
+    private final String APP_ID = "355198514515820";
+    private final String PENDING_ACTION_BUNDLE_KEY = "com.facebook.samples.hellofacebook:PendingAction";
+
+    private Button postStatusUpdateButton;
+    private Button postPhotoButton;
+    private Button pickFriendsButton;
+    private Button pickPlaceButton;
+    private LoginButton loginButton;
+    private ProfilePictureView profilePictureView;
+    private TextView greeting;
+    private PendingAction pendingAction = PendingAction.NONE;
+    private final Location SEATTLE_LOCATION = new Location("") {
+        {
+            setLatitude(47.6097);
+            setLongitude(-122.3331);
+        }
+    };
+    private GraphUser user;
+
+    private enum PendingAction {
+        NONE,
+        POST_PHOTO,
+        POST_STATUS_UPDATE
+    }
+
+    /**
+     * Called when the activity is first created.
+     */
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+
+        loginButton = (LoginButton) findViewById(R.id.login_button);
+        loginButton.setApplicationId(APP_ID);
+        loginButton.setUserInfoChangedCallback(new LoginButton.UserInfoChangedCallback() {
+            @Override
+            public void onUserInfoFetched(GraphUser user) {
+                HelloFacebookSampleActivity.this.user = user;
+                updateUI();
+                // It's possible that we were waiting for this.user to be populated in order to post a
+                // status update.
+                handlePendingAction();
+            }
+        });
+
+        profilePictureView = (ProfilePictureView) findViewById(R.id.profilePicture);
+        greeting = (TextView) findViewById(R.id.greeting);
+
+        postStatusUpdateButton = (Button) findViewById(R.id.postStatusUpdateButton);
+        postStatusUpdateButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View view) {
+                onClickPostStatusUpdate();
+            }
+        });
+
+        postPhotoButton = (Button) findViewById(R.id.postPhotoButton);
+        postPhotoButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View view) {
+                onClickPostPhoto();
+            }
+        });
+
+        pickFriendsButton = (Button) findViewById(R.id.pickFriendsButton);
+        pickFriendsButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View view) {
+                onClickPickFriends();
+            }
+        });
+
+        pickPlaceButton = (Button) findViewById(R.id.pickPlaceButton);
+        pickPlaceButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View view) {
+                onClickPickPlace();
+            }
+        });
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+
+        updateUI();
+
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Session.ACTION_ACTIVE_SESSION_OPENED);
+        filter.addAction(Session.ACTION_ACTIVE_SESSION_CLOSED);
+        LocalBroadcastManager.getInstance(this).registerReceiver(receiver, filter);
+    }
+
+    @Override
+    protected void onStop() {
+        super.onStop();
+
+        LocalBroadcastManager.getInstance(this).unregisterReceiver(receiver);
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        outState.putInt(PENDING_ACTION_BUNDLE_KEY, pendingAction.ordinal());
+    }
+
+    @Override
+    protected void onRestoreInstanceState(Bundle savedInstanceState) {
+        super.onRestoreInstanceState(savedInstanceState);
+
+        int ordinal = savedInstanceState.getInt(PENDING_ACTION_BUNDLE_KEY, 0);
+        pendingAction = PendingAction.values()[ordinal];
+    }
+
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+
+        switch (requestCode) {
+            case PICK_FRIENDS_ACTIVITY:
+                String results = "";
+                if (resultCode == RESULT_OK) {
+                    HelloFacebookApplication application = (HelloFacebookApplication) getApplication();
+                    Collection<GraphUser> selection = application.getSelectedUsers();
+                    if (selection != null && selection.size() > 0) {
+                        ArrayList<String> names = new ArrayList<String>();
+                        for (GraphUser user : selection) {
+                            names.add(user.getName());
+                        }
+                        results = TextUtils.join(", ", names);
+                    } else {
+                        results = "<No friends selected>";
+                    }
+                } else {
+                    results = "<Cancelled>";
+                }
+
+                AlertDialog.Builder builder = new AlertDialog.Builder(this);
+                builder.setTitle("You picked:").setMessage(results).setPositiveButton("OK", null);
+                builder.show();
+
+                break;
+
+            case PICK_PLACE_ACTIVITY:
+                results = "";
+                if (resultCode == RESULT_OK) {
+                    HelloFacebookApplication application = (HelloFacebookApplication) getApplication();
+                    GraphPlace selection = application.getSelectedPlace();
+                    if (selection != null) {
+                        results = selection.getName();
+                    } else {
+                        results = "<No place selected>";
+                    }
+                } else {
+                    results = "<Cancelled>";
+                }
+
+                builder = new AlertDialog.Builder(this);
+                builder.setTitle("You picked:").setMessage(results).setPositiveButton("OK", null);
+                builder.show();
+
+                break;
+        }
+    }
+
+    @Override
+    protected void onSessionStateChange(SessionState state, Exception exception) {
+        super.onSessionStateChange(state, exception);
+        if (state == SessionState.OPENED_TOKEN_UPDATED) {
+            handlePendingAction();
+        }
+    }
+
+    private void updateUI() {
+        boolean enableButtons = Session.getActiveSession() != null &&
+                Session.getActiveSession().getState().isOpened();
+
+        postStatusUpdateButton.setEnabled(enableButtons);
+        postPhotoButton.setEnabled(enableButtons);
+        pickFriendsButton.setEnabled(enableButtons);
+        pickPlaceButton.setEnabled(enableButtons);
+
+        if (enableButtons && user != null) {
+            profilePictureView.setUserId(user.getId());
+            greeting.setText(String.format("Hello %s!", user.getFirstName()));
+        } else {
+            profilePictureView.setUserId(null);
+            greeting.setText(null);
+        }
+    }
+
+    @SuppressWarnings("incomplete-switch")
+    private void handlePendingAction() {
+        switch (pendingAction) {
+            case POST_PHOTO:
+                postPhoto();
+                break;
+            case POST_STATUS_UPDATE:
+                postStatusUpdate();
+                break;
+        }
+        pendingAction = PendingAction.NONE;
+    }
+
+    private interface GraphObjectWithId extends GraphObject {
+        String getId();
+    }
+
+    private void showAlert(String message, GraphObject result, Exception exception) {
+        String title = null;
+        String alertMessage = null;
+        if (exception == null) {
+            title = "Success";
+            String id = result.cast(GraphObjectWithId.class).getId();
+            alertMessage = String.format("Successfully posted '%s'.\nPost ID: %s", message, id);
+        } else {
+            title = "Error";
+            alertMessage = exception.getMessage();
+        }
+
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setTitle(title).setMessage(alertMessage).setPositiveButton("OK", null);
+        builder.show();
+    }
+
+    private void onClickPostStatusUpdate() {
+        performPublish(PendingAction.POST_STATUS_UPDATE);
+    }
+
+    private void postStatusUpdate() {
+        if (user != null) {
+            final String message = String
+                    .format("Updating status for %s at %s", user.getFirstName(), (new Date().toString()));
+            Request request = Request
+                    .newStatusUpdateRequest(Session.getActiveSession(), message, new Request.Callback() {
+                        @Override
+                        public void onCompleted(Response response) {
+                            showAlert(message, response.getGraphObject(), response.getError());
+                        }
+                    });
+            Request.executeBatchAsync(request);
+        } else {
+            pendingAction = PendingAction.POST_STATUS_UPDATE;
+        }
+    }
+
+    private void onClickPostPhoto() {
+        performPublish(PendingAction.POST_PHOTO);
+    }
+
+    private void postPhoto() {
+        Bitmap image = BitmapFactory.decodeResource(this.getResources(), R.drawable.icon);
+        Request request = Request.newUploadPhotoRequest(Session.getActiveSession(), image, new Request.Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                showAlert("Photo Post", response.getGraphObject(), response.getError());
+            }
+        });
+        Request.executeBatchAsync(request);
+    }
+
+    private void onClickPickFriends() {
+        Intent intent = new Intent(this, PickFriendsActivity.class);
+        startActivityForResult(intent, PICK_FRIENDS_ACTIVITY);
+    }
+
+    private void onClickPickPlace() {
+        Intent intent = new Intent(this, PickPlaceActivity.class);
+        PickPlaceActivity.populateParameters(intent, SEATTLE_LOCATION, null);
+        startActivityForResult(intent, PICK_PLACE_ACTIVITY);
+    }
+
+    private void performPublish(PendingAction action) {
+        Session session = Session.getActiveSession();
+        if (session != null) {
+            pendingAction = action;
+            if (session.getPermissions().contains("publish_actions")) {
+                // We can do the action right away.
+                handlePendingAction();
+            } else {
+                // We need to reauthorize, then complete the action when we get called back.
+                Session.ReauthorizeRequest reauthRequest = new Session.ReauthorizeRequest(this, PERMISSIONS).
+                        setRequestCode(REAUTHORIZE_ACTIVITY).
+                        setLoginBehavior(SessionLoginBehavior.SSO_WITH_FALLBACK);
+                session.reauthorizeForPublish(reauthRequest);
+            }
+        }
+    }
+
+    private BroadcastReceiver receiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            updateUI();
+        }
+    };
+
+
+}
diff --git a/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/PickFriendsActivity.java b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/PickFriendsActivity.java
new file mode 100644
index 000000000..a9629e8f4
--- /dev/null
+++ b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/PickFriendsActivity.java
@@ -0,0 +1,101 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.hellofacebook;
+
+import android.app.AlertDialog;
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+import com.facebook.FacebookException;
+import com.facebook.FriendPickerFragment;
+import com.facebook.PickerFragment;
+
+// This class provides an example of an Activity that uses FriendPickerFragment to display a list of
+// the user's friends. It takes a programmatic approach to creating the FriendPickerFragment with the
+// desired parameters -- see PickPlaceActivity in the PlacePickerSample project for an example of an
+// Activity creating a fragment (in this case a PlacePickerFragment) via XML layout rather than
+// programmatically.
+public class PickFriendsActivity extends FragmentActivity {
+    FriendPickerFragment friendPickerFragment;
+
+    // A helper to simplify life for callers who want to populate a Bundle with the necessary
+    // parameters. A more sophisticated Activity might define its own set of parameters; our needs
+    // are simple, so we just populate what we want to pass to the FriendPickerFragment.
+    public static void populateParameters(Intent intent, String userId, boolean multiSelect) {
+        intent.putExtra(FriendPickerFragment.USER_ID_BUNDLE_KEY, userId);
+        intent.putExtra(FriendPickerFragment.MULTI_SELECT_BUNDLE_KEY, multiSelect);
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.pick_friends_activity);
+
+        FragmentManager fm = getSupportFragmentManager();
+
+        if (savedInstanceState == null) {
+            // First time through, we create our fragment programmatically.
+            final Bundle args = getIntent().getExtras();
+            friendPickerFragment = new FriendPickerFragment(args);
+            fm.beginTransaction()
+                    .add(R.id.friend_picker_fragment, friendPickerFragment)
+                    .commit();
+        } else {
+            // Subsequent times, our fragment is recreated by the framework and already has saved and
+            // restored its state, so we don't need to specify args again. (In fact, this might be
+            // incorrect if the fragment was modified programmatically since it was created.)
+            friendPickerFragment = (FriendPickerFragment) fm.findFragmentById(R.id.friend_picker_fragment);
+        }
+
+        friendPickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
+            @Override
+            public void onError(FacebookException error) {
+                PickFriendsActivity.this.onError(error);
+            }
+        });
+
+        friendPickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
+            @Override
+            public void onDoneButtonClicked() {
+                // We just store our selection in the Application for other activities to look at.
+                HelloFacebookApplication application = (HelloFacebookApplication) getApplication();
+                application.setSelectedUsers(friendPickerFragment.getSelection());
+
+                setResult(RESULT_OK, null);
+                finish();
+            }
+        });
+    }
+
+    private void onError(Exception error) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setTitle("Error").setMessage(error.getMessage()).setPositiveButton("OK", null);
+        builder.show();
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        try {
+            // Load data, unless a query has already taken place.
+            friendPickerFragment.loadData(false);
+        } catch (Exception ex) {
+            onError(ex);
+        }
+    }
+}
diff --git a/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/PickPlaceActivity.java b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/PickPlaceActivity.java
new file mode 100644
index 000000000..119ebe4ee
--- /dev/null
+++ b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/PickPlaceActivity.java
@@ -0,0 +1,110 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.hellofacebook;
+
+import android.app.AlertDialog;
+import android.content.Intent;
+import android.location.Location;
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+import com.facebook.FacebookException;
+import com.facebook.PickerFragment;
+import com.facebook.PlacePickerFragment;
+
+// This class provides an example of an Activity that uses PlacePickerFragment to display a list of
+// the places. It takes a layout-based approach to creating the PlacePickerFragment with the
+// desired parameters -- see PickFriendActivity in the FriendPickerSample project for an example of an
+// Activity creating a fragment (in this case a FriendPickerFragment) programmatically rather than
+// via XML layout.
+public class PickPlaceActivity extends FragmentActivity {
+    PlacePickerFragment placePickerFragment;
+
+    // A helper to simplify life for callers who want to populate a Bundle with the necessary
+    // parameters. A more sophisticated Activity might define its own set of parameters; our needs
+    // are simple, so we just populate what we want to pass to the PlacePickerFragment.
+    public static void populateParameters(Intent intent, Location location, String searchText) {
+        intent.putExtra(PlacePickerFragment.LOCATION_BUNDLE_KEY, location);
+        intent.putExtra(PlacePickerFragment.SEARCH_TEXT_BUNDLE_KEY, searchText);
+        intent.putExtra(PlacePickerFragment.TITLE_TEXT_BUNDLE_KEY, "Pick a Seattle Place");
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.pick_place_activity);
+
+        FragmentManager fm = getSupportFragmentManager();
+        placePickerFragment = (PlacePickerFragment) fm.findFragmentById(R.id.place_picker_fragment);
+        if (savedInstanceState == null) {
+            // If this is the first time we have created the fragment, update its properties based on
+            // any parameters we received via our Intent.
+            placePickerFragment.setSettingsFromBundle(getIntent().getExtras());
+        }
+
+        placePickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
+            @Override
+            public void onError(FacebookException error) {
+                PickPlaceActivity.this.onError(error);
+            }
+        });
+
+        // We finish the activity when either the Done button is pressed or when a place is
+        // selected (since only a single place can be selected).
+        placePickerFragment.setOnSelectionChangedListener(new PickerFragment.OnSelectionChangedListener() {
+            @Override
+            public void onSelectionChanged() {
+                if (placePickerFragment.getSelection() != null) {
+                    finishActivity();
+                }
+            }
+        });
+
+        placePickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
+            @Override
+            public void onDoneButtonClicked() {
+                finishActivity();
+            }
+        });
+    }
+
+    private void finishActivity() {
+        // We just store our selection in the Application for other activities to look at.
+        HelloFacebookApplication application = (HelloFacebookApplication) getApplication();
+        application.setSelectedPlace(placePickerFragment.getSelection());
+
+        setResult(RESULT_OK, null);
+        finish();
+    }
+
+    private void onError(Exception error) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setTitle("Error").setMessage(error.getMessage()).setPositiveButton("OK", null);
+        builder.show();
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        try {
+            // Load data, unless a query has already taken place.
+            placePickerFragment.loadData(false);
+        } catch (Exception ex) {
+            onError(ex);
+        }
+    }
+}
diff --git a/samples/JustRequestSample/.classpath b/samples/JustRequestSample/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/JustRequestSample/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/JustRequestSample/.project b/samples/JustRequestSample/.project
new file mode 100644
index 000000000..2091c030f
--- /dev/null
+++ b/samples/JustRequestSample/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>JustRequestSample</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/samples/JustRequestSample/AndroidManifest.xml b/samples/JustRequestSample/AndroidManifest.xml
new file mode 100644
index 000000000..24ab1f221
--- /dev/null
+++ b/samples/JustRequestSample/AndroidManifest.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.samples.justrequest"
+    android:versionCode="1"
+    android:versionName="1.0" >
+
+    <uses-sdk android:minSdkVersion="8" />
+    <uses-permission android:name="android.permission.INTERNET"/>
+
+    <application
+        android:icon="@drawable/icon"
+        android:label="@string/app_name" >
+        <activity
+            android:name=".JustRequestSampleActivity"
+            android:label="@string/app_name"
+            android:windowSoftInputMode="adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+        <activity android:name="com.facebook.LoginActivity"
+                  android:label="@string/app_name" />
+    </application>
+
+</manifest>
diff --git a/samples/JustRequestSample/JustRequestSample.iml b/samples/JustRequestSample/JustRequestSample.iml
new file mode 100644
index 000000000..f568c01e8
--- /dev/null
+++ b/samples/JustRequestSample/JustRequestSample.iml
@@ -0,0 +1,54 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="EclipseModuleManager">
+    <conelement value="com.android.ide.eclipse.adt.LIBRARIES" />
+    <src_description expected_position="0">
+      <src_folder value="file://$MODULE_DIR$/src" expected_position="0" />
+      <src_folder value="file://$MODULE_DIR$/gen" expected_position="1" />
+    </src_description>
+  </component>
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/bin/classes" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/samples/JustRequestSample/ant.properties b/samples/JustRequestSample/ant.properties
new file mode 100644
index 000000000..b0971e891
--- /dev/null
+++ b/samples/JustRequestSample/ant.properties
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff --git a/samples/JustRequestSample/build.xml b/samples/JustRequestSample/build.xml
new file mode 100644
index 000000000..3428117f5
--- /dev/null
+++ b/samples/JustRequestSample/build.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="JustRequestSample" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties" />
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties" />
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env" />
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME" />
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties" />
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+    />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true" />
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml" />
+
+</project>
diff --git a/samples/JustRequestSample/com.facebook.samples.justlogin.JustRequestSampleActivity.eml b/samples/JustRequestSample/com.facebook.samples.justlogin.JustRequestSampleActivity.eml
new file mode 100644
index 000000000..4104d1ffc
--- /dev/null
+++ b/samples/JustRequestSample/com.facebook.samples.justlogin.JustRequestSampleActivity.eml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<component>
+	<exclude-output/>
+	<contentEntry url="file://$MODULE_DIR$"/>
+</component>
diff --git a/samples/JustRequestSample/proguard-project.txt b/samples/JustRequestSample/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/JustRequestSample/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/samples/JustRequestSample/project.properties b/samples/JustRequestSample/project.properties
new file mode 100644
index 000000000..cee0509c6
--- /dev/null
+++ b/samples/JustRequestSample/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+android.library.reference.1=../../facebook
diff --git a/samples/JustRequestSample/res/drawable-hdpi/icon.png b/samples/JustRequestSample/res/drawable-hdpi/icon.png
new file mode 100644
index 000000000..a888af1c6
Binary files /dev/null and b/samples/JustRequestSample/res/drawable-hdpi/icon.png differ
diff --git a/samples/JustRequestSample/res/drawable-mdpi/icon.png b/samples/JustRequestSample/res/drawable-mdpi/icon.png
new file mode 100644
index 000000000..2275c8571
Binary files /dev/null and b/samples/JustRequestSample/res/drawable-mdpi/icon.png differ
diff --git a/samples/JustRequestSample/res/drawable-xhdpi/icon.png b/samples/JustRequestSample/res/drawable-xhdpi/icon.png
new file mode 100644
index 000000000..31201f160
Binary files /dev/null and b/samples/JustRequestSample/res/drawable-xhdpi/icon.png differ
diff --git a/samples/JustRequestSample/res/drawable/icon.png b/samples/JustRequestSample/res/drawable/icon.png
new file mode 100644
index 000000000..2275c8571
Binary files /dev/null and b/samples/JustRequestSample/res/drawable/icon.png differ
diff --git a/samples/JustRequestSample/res/layout/main.xml b/samples/JustRequestSample/res/layout/main.xml
new file mode 100644
index 000000000..4f7576e0a
--- /dev/null
+++ b/samples/JustRequestSample/res/layout/main.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:orientation="vertical" >
+
+    <EditText
+        android:id="@+id/editRequests"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:ems="10" >
+
+        <requestFocus />
+    </EditText>
+
+    <Button
+        android:id="@+id/buttonRequest"
+        android:layout_width="122dp"
+        android:layout_height="wrap_content"
+        android:text="@string/request" />
+
+    <TextView
+        android:id="@+id/textViewResults"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:textAppearance="?android:attr/textAppearanceLarge" />
+
+</LinearLayout>
\ No newline at end of file
diff --git a/samples/JustRequestSample/res/values/strings.xml b/samples/JustRequestSample/res/values/strings.xml
new file mode 100644
index 000000000..d47181167
--- /dev/null
+++ b/samples/JustRequestSample/res/values/strings.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="hello">Hello World, JustRequestSampleActivity!</string>
+    <string name="app_name">JustRequestSample</string>
+    <string name="request">Request</string>
+    <string name="instructions">Login to create a link to fetch account data</string>
+    <string name="logout">Log out</string>
+
+</resources>
\ No newline at end of file
diff --git a/samples/JustRequestSample/src/com/facebook/samples/justrequest/JustRequestSampleActivity.java b/samples/JustRequestSample/src/com/facebook/samples/justrequest/JustRequestSampleActivity.java
new file mode 100644
index 000000000..16cdd6188
--- /dev/null
+++ b/samples/JustRequestSample/src/com/facebook/samples/justrequest/JustRequestSampleActivity.java
@@ -0,0 +1,102 @@
+package com.facebook.samples.justrequest;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.Intent;
+import android.os.Bundle;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.TextView;
+import com.facebook.*;
+import com.facebook.Session.StatusCallback;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class JustRequestSampleActivity extends Activity {
+    static final String applicationId = "327064487357152";
+    Button buttonRequest;
+    EditText editRequests;
+    TextView textViewResults;
+    Session session;
+
+    /** Called when the activity is first created. */
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+        this.buttonRequest = (Button) findViewById(R.id.buttonRequest);
+        this.buttonRequest.setOnClickListener(new OnClickListener() {
+            public void onClick(View view) {
+                onClickRequest();
+            }
+        });
+        this.editRequests = (EditText) findViewById(R.id.editRequests);
+        this.textViewResults = (TextView) findViewById(R.id.textViewResults);
+
+        this.session = createSession();
+        Settings.addLoggingBehavior(LoggingBehaviors.INCLUDE_ACCESS_TOKENS);
+    }
+
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        this.session.onActivityResult(this, requestCode, resultCode, data);
+    }
+
+    private void onClickRequest() {
+        if (this.session.isOpened()) {
+            sendRequests();
+        } else {
+            StatusCallback callback = new StatusCallback() {
+                public void call(Session session, SessionState state, Exception exception) {
+                    if (state.isOpened()) {
+                        sendRequests();
+                    } else if (exception != null) {
+                        AlertDialog alertDialog;
+                        alertDialog = new AlertDialog.Builder(JustRequestSampleActivity.this).create();
+                        alertDialog.setTitle("Login failed");
+                        alertDialog.setMessage(exception.getMessage());
+                        alertDialog.show();
+                        JustRequestSampleActivity.this.session = createSession();
+                    }
+                }
+            };
+            this.session.openForRead(new Session.OpenRequest(this).setCallback(callback));
+        }
+    }
+
+    private void sendRequests() {
+        textViewResults.setText("");
+
+        String requestIdsText = editRequests.getText().toString();
+        String[] requestIds = requestIdsText.split(",");
+
+        List<Request> requests = new ArrayList<Request>();
+        for (final String requestId : requestIds) {
+            requests.add(new Request(session, requestId, null, null, new Request.Callback() {
+                public void onCompleted(Response response) {
+                    GraphObject graphObject = response.getGraphObject();
+                    FacebookException error = response.getError();
+                    String s = textViewResults.getText().toString();
+                    if (graphObject != null) {
+                        if (graphObject.getProperty("id") != null) {
+                            s = s + String.format("%s: %s\n", graphObject.getProperty("id"), graphObject.getProperty(
+                                    "name"));
+                        } else {
+                            s = s + String.format("%s: <no such id>\n", requestId); 
+                        }
+                    } else if (error != null) {
+                        s = s + String.format("Error: %s", error.getMessage());
+                    }
+                    textViewResults.setText(s);
+                }
+            }));
+        }
+        Request.executeBatchAndWait(requests);
+    }
+
+    private Session createSession() {
+        return new Session.Builder(this).setApplicationId(applicationId).build();
+    }
+}
diff --git a/samples/PlacePickerSample/.classpath b/samples/PlacePickerSample/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/PlacePickerSample/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/PlacePickerSample/.project b/samples/PlacePickerSample/.project
new file mode 100644
index 000000000..73ec9015a
--- /dev/null
+++ b/samples/PlacePickerSample/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>PlacePickerSample</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/samples/PlacePickerSample/AndroidManifest.xml b/samples/PlacePickerSample/AndroidManifest.xml
new file mode 100644
index 000000000..5cf351e8f
--- /dev/null
+++ b/samples/PlacePickerSample/AndroidManifest.xml
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.facebook.samples.placepicker"
+          android:versionCode="1"
+          android:versionName="1.0">
+    <uses-sdk android:minSdkVersion="8"/>
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+    <application android:label="@string/app_name"
+                 android:icon="@drawable/icon"
+                 android:theme="@android:style/Theme.Black"
+                 android:name=".PlacePickerApplication"
+            >
+        <activity android:name="PlacePickerSampleActivity"
+                  android:label="@string/app_name"
+                  android:windowSoftInputMode="adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+        <activity android:name="PickPlaceActivity"
+                  android:label="Pick Place">
+        </activity>
+        <activity android:name="com.facebook.LoginActivity"
+                  android:label="@string/app_name" />
+        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
+    </application>
+</manifest> 
diff --git a/samples/PlacePickerSample/FriendPickerSample.iml b/samples/PlacePickerSample/FriendPickerSample.iml
new file mode 100644
index 000000000..a6817daf5
--- /dev/null
+++ b/samples/PlacePickerSample/FriendPickerSample.iml
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.1 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/samples/PlacePickerSample/PlacePickerSample.iml b/samples/PlacePickerSample/PlacePickerSample.iml
new file mode 100644
index 000000000..bb7ba685f
--- /dev/null
+++ b/samples/PlacePickerSample/PlacePickerSample.iml
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/samples/PlacePickerSample/ant.properties b/samples/PlacePickerSample/ant.properties
new file mode 100644
index 000000000..b0971e891
--- /dev/null
+++ b/samples/PlacePickerSample/ant.properties
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff --git a/samples/PlacePickerSample/build.xml b/samples/PlacePickerSample/build.xml
new file mode 100644
index 000000000..a80f395cd
--- /dev/null
+++ b/samples/PlacePickerSample/build.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="PlacePickerSample" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties"/>
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties"/>
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env"/>
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME"/>
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties"/>
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+            />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true"/>
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml"/>
+
+</project>
diff --git a/samples/PlacePickerSample/proguard-project.txt b/samples/PlacePickerSample/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/PlacePickerSample/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/samples/PlacePickerSample/project.properties b/samples/PlacePickerSample/project.properties
new file mode 100644
index 000000000..cee0509c6
--- /dev/null
+++ b/samples/PlacePickerSample/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+android.library.reference.1=../../facebook
diff --git a/samples/PlacePickerSample/res/drawable-hdpi/icon.png b/samples/PlacePickerSample/res/drawable-hdpi/icon.png
new file mode 100644
index 000000000..4059334b5
Binary files /dev/null and b/samples/PlacePickerSample/res/drawable-hdpi/icon.png differ
diff --git a/samples/PlacePickerSample/res/drawable-mdpi/icon.png b/samples/PlacePickerSample/res/drawable-mdpi/icon.png
new file mode 100644
index 000000000..1fa3834d0
Binary files /dev/null and b/samples/PlacePickerSample/res/drawable-mdpi/icon.png differ
diff --git a/samples/PlacePickerSample/res/drawable-xhdpi/icon.png b/samples/PlacePickerSample/res/drawable-xhdpi/icon.png
new file mode 100644
index 000000000..2b3083d44
Binary files /dev/null and b/samples/PlacePickerSample/res/drawable-xhdpi/icon.png differ
diff --git a/samples/PlacePickerSample/res/drawable/icon.png b/samples/PlacePickerSample/res/drawable/icon.png
new file mode 100644
index 000000000..1fa3834d0
Binary files /dev/null and b/samples/PlacePickerSample/res/drawable/icon.png differ
diff --git a/samples/PlacePickerSample/res/layout/main.xml b/samples/PlacePickerSample/res/layout/main.xml
new file mode 100644
index 000000000..c1d188f23
--- /dev/null
+++ b/samples/PlacePickerSample/res/layout/main.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:orientation="vertical"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+        >
+    <LinearLayout android:layout_width="fill_parent"
+                  android:layout_height="wrap_content"
+                  android:orientation="horizontal"
+            >
+        <Button
+                android:id="@+id/seattleButton"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="Seattle"
+                android:layout_weight="1"
+                />
+        <Button
+                android:id="@+id/sanFranciscoButton"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="San Francisco"
+                android:layout_weight="1"
+                />
+        <Button
+                android:id="@+id/gpsButton"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="GPS"
+                android:layout_weight="1"
+                />
+    </LinearLayout>
+    <TextView
+            android:id="@+id/resultsTextView"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:textColor="#FFFFFF"
+            />
+</LinearLayout>
+
diff --git a/samples/PlacePickerSample/res/layout/pick_place_activity.xml b/samples/PlacePickerSample/res/layout/pick_place_activity.xml
new file mode 100644
index 000000000..d98c419b3
--- /dev/null
+++ b/samples/PlacePickerSample/res/layout/pick_place_activity.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              xmlns:app="http://schemas.android.com/apk/res-auto"
+              android:orientation="vertical"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+        >
+    <fragment
+            android:id="@+id/place_picker_fragment"
+            android:name="com.facebook.PlacePickerFragment"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            app:show_pictures="true"
+            app:show_title_bar="true"
+            app:show_search_box="true"
+            />
+</LinearLayout>
+
diff --git a/samples/PlacePickerSample/res/values/strings.xml b/samples/PlacePickerSample/res/values/strings.xml
new file mode 100644
index 000000000..a2a3e9114
--- /dev/null
+++ b/samples/PlacePickerSample/res/values/strings.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">PlacePickerSample</string>
+    <string name="app_id">378281678861098</string>
+</resources>
diff --git a/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PickPlaceActivity.java b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PickPlaceActivity.java
new file mode 100644
index 000000000..5c2e52b88
--- /dev/null
+++ b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PickPlaceActivity.java
@@ -0,0 +1,108 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.placepicker;
+
+import android.app.AlertDialog;
+import android.content.Intent;
+import android.location.Location;
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+import com.facebook.FacebookException;
+import com.facebook.PickerFragment;
+import com.facebook.PlacePickerFragment;
+
+// This class provides an example of an Activity that uses PlacePickerFragment to display a list of
+// the places. It takes a layout-based approach to creating the PlacePickerFragment with the
+// desired parameters -- see PickFriendActivity in the FriendPickerSample project for an example of an
+// Activity creating a fragment (in this case a FriendPickerFragment) programmatically rather than
+// via XML layout.
+public class PickPlaceActivity extends FragmentActivity {
+    PlacePickerFragment placePickerFragment;
+
+    // A helper to simplify life for callers who want to populate a Bundle with the necessary
+    // parameters. A more sophisticated Activity might define its own set of parameters; our needs
+    // are simple, so we just populate what we want to pass to the PlacePickerFragment.
+    public static void populateParameters(Intent intent, Location location, String searchText) {
+        intent.putExtra(PlacePickerFragment.LOCATION_BUNDLE_KEY, location);
+        intent.putExtra(PlacePickerFragment.SEARCH_TEXT_BUNDLE_KEY, searchText);
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.pick_place_activity);
+
+        FragmentManager fm = getSupportFragmentManager();
+        placePickerFragment = (PlacePickerFragment) fm.findFragmentById(R.id.place_picker_fragment);
+        if (savedInstanceState == null) {
+            // If this is the first time we have created the fragment, update its properties based on
+            // any parameters we received via our Intent.
+            placePickerFragment.setSettingsFromBundle(getIntent().getExtras());
+        }
+
+        placePickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
+            @Override
+            public void onError(FacebookException error) {
+                PickPlaceActivity.this.onError(error);
+            }
+        });
+
+        // We finish the activity when either the Done button is pressed or when a place is
+        // selected (since only a single place can be selected).
+        placePickerFragment.setOnSelectionChangedListener(new PickerFragment.OnSelectionChangedListener() {
+            @Override
+            public void onSelectionChanged() {
+                if (placePickerFragment.getSelection() != null) {
+                    finishActivity();
+                }
+            }
+        });
+        placePickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
+            @Override
+            public void onDoneButtonClicked() {
+                finishActivity();
+            }
+        });
+    }
+
+    private void finishActivity() {
+        // We just store our selection in the Application for other activities to look at.
+        PlacePickerApplication application = (PlacePickerApplication) getApplication();
+        application.setSelectedPlace(placePickerFragment.getSelection());
+
+        setResult(RESULT_OK, null);
+        finish();
+    }
+
+    private void onError(Exception error) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setTitle("Error").setMessage(error.getMessage()).setPositiveButton("OK", null);
+        builder.show();
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        try {
+            // Load data, unless a query has already taken place.
+            placePickerFragment.loadData(false);
+        } catch (Exception ex) {
+            onError(ex);
+        }
+    }
+}
diff --git a/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerApplication.java b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerApplication.java
new file mode 100644
index 000000000..4181eb5e5
--- /dev/null
+++ b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerApplication.java
@@ -0,0 +1,35 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.placepicker;
+
+import android.app.Application;
+import com.facebook.GraphPlace;
+
+// We use a custom Application class to store our minimal state data (which users have been selected).
+// A real-world application will likely require a more robust data model.
+public class PlacePickerApplication extends Application {
+    public GraphPlace getSelectedPlace() {
+        return selectedPlace;
+    }
+
+    public void setSelectedPlace(GraphPlace selectedPlace) {
+        this.selectedPlace = selectedPlace;
+    }
+
+    private GraphPlace selectedPlace;
+
+}
diff --git a/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerSampleActivity.java b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerSampleActivity.java
new file mode 100644
index 000000000..eab843419
--- /dev/null
+++ b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerSampleActivity.java
@@ -0,0 +1,214 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.placepicker;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.Intent;
+import android.location.Criteria;
+import android.location.Location;
+import android.location.LocationListener;
+import android.location.LocationManager;
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+import android.view.View;
+import android.widget.Button;
+import android.widget.TextView;
+import com.facebook.GraphLocation;
+import com.facebook.GraphPlace;
+import com.facebook.Session;
+
+public class PlacePickerSampleActivity extends FragmentActivity implements LocationListener {
+    private final int PLACE_ACTIVITY = 1;
+    private final Location SEATTLE_LOCATION = new Location("") {
+        {
+            setLatitude(47.6097);
+            setLongitude(-122.3331);
+        }
+    };
+    private final Location SAN_FRANCISCO_LOCATION = new Location("") {
+        {
+            setLatitude(37.7750);
+            setLongitude(-122.4183);
+        }
+    };
+    private final Location PARIS_LOCATION = new Location("") {
+        {
+            setLatitude(48.857875);
+            setLongitude(2.294635);
+        }
+    };
+
+    private TextView resultsTextView;
+    private LocationManager locationManager;
+    private Location lastKnownLocation;
+
+    /**
+     * Called when the activity is first created.
+     */
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+
+        resultsTextView = (TextView) findViewById(R.id.resultsTextView);
+        Button button = (Button) findViewById(R.id.seattleButton);
+        button.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View view) {
+                onClickSeattle();
+            }
+        });
+
+        button = (Button) findViewById(R.id.sanFranciscoButton);
+        button.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View view) {
+                onClickSanFrancisco();
+            }
+        });
+
+        button = (Button) findViewById(R.id.gpsButton);
+        button.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View view) {
+                onClickGPS();
+            }
+        });
+
+        Session.openActiveSession(this, true);
+
+        locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+
+        // Update the display every time we are started (this will be "no place selected" on first
+        // run, or possibly details of a place if the activity is being re-created).
+        displaySelectedPlace(RESULT_OK);
+    }
+
+    private void onError(Exception exception) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setTitle("Error").setMessage(exception.getMessage()).setPositiveButton("OK", null);
+        builder.show();
+    }
+
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        switch (requestCode) {
+            case PLACE_ACTIVITY:
+                displaySelectedPlace(resultCode);
+                break;
+            default:
+                Session.getActiveSession().onActivityResult(this, requestCode, resultCode, data);
+                break;
+        }
+    }
+
+    private void displaySelectedPlace(int resultCode) {
+        String results = "";
+        if (resultCode == RESULT_OK) {
+            PlacePickerApplication application = (PlacePickerApplication) getApplication();
+            GraphPlace selection = application.getSelectedPlace();
+            if (selection != null) {
+                GraphLocation location = selection.getLocation();
+
+                results = String.format("Name: %s\nCategory: %s\nLocation: (%f,%f)\nStreet: %s, %s, %s, %s, %s",
+                        selection.getName(), selection.getCategory(),
+                        location.getLatitude(), location.getLongitude(),
+                        location.getStreet(), location.getCity(), location.getState(), location.getZip(),
+                        location.getCountry());
+            } else {
+                results = "<No place selected>";
+            }
+        } else {
+            results = "<Cancelled>";
+        }
+        resultsTextView.setText(results);
+    }
+
+    public void onLocationChanged(Location location) {
+        lastKnownLocation = location;
+    }
+
+    @Override
+    public void onStatusChanged(String provider, int status, Bundle extras) {
+    }
+
+    @Override
+    public void onProviderEnabled(String provider) {
+    }
+
+    @Override
+    public void onProviderDisabled(String provider) {
+    }
+
+    private void onClickSeattle() {
+        try {
+            Intent intent = new Intent(this, PickPlaceActivity.class);
+            PickPlaceActivity.populateParameters(intent, SEATTLE_LOCATION, null);
+
+            startActivityForResult(intent, PLACE_ACTIVITY);
+        } catch (Exception ex) {
+            onError(ex);
+        }
+    }
+
+    private void onClickSanFrancisco() {
+        try {
+            Intent intent = new Intent(this, PickPlaceActivity.class);
+            PickPlaceActivity.populateParameters(intent, SAN_FRANCISCO_LOCATION, null);
+
+            startActivityForResult(intent, PLACE_ACTIVITY);
+        } catch (Exception ex) {
+            onError(ex);
+        }
+    }
+
+    private void onClickGPS() {
+        try {
+            if (lastKnownLocation == null) {
+                Criteria criteria = new Criteria();
+                String bestProvider = locationManager.getBestProvider(criteria, false);
+                if (bestProvider != null) {
+                    lastKnownLocation = locationManager.getLastKnownLocation(bestProvider);
+                }
+            }
+            if (lastKnownLocation == null) {
+                String model = android.os.Build.MODEL;
+                if (model.equals("sdk") || model.equals("google_sdk") || model.contains("x86")) {
+                    // Looks like they are on an emulator, pretend we're in Paris if we don't have a
+                    // location set.
+                    lastKnownLocation = PARIS_LOCATION;
+                } else {
+                    String text = "Could not obtain your current location.";
+                    AlertDialog.Builder builder = new AlertDialog.Builder(PlacePickerSampleActivity.this);
+                    builder.setTitle("Error").setMessage(text).setPositiveButton("OK", null);
+                    builder.show();
+                    return;
+                }
+            }
+
+            Intent intent = new Intent(this, PickPlaceActivity.class);
+            PickPlaceActivity.populateParameters(intent, lastKnownLocation, null);
+
+            startActivityForResult(intent, PLACE_ACTIVITY);
+        } catch (Exception ex) {
+            onError(ex);
+        }
+    }
+
+}
diff --git a/samples/ProfilePictureSample/.classpath b/samples/ProfilePictureSample/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/ProfilePictureSample/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/ProfilePictureSample/.project b/samples/ProfilePictureSample/.project
new file mode 100644
index 000000000..44914352a
--- /dev/null
+++ b/samples/ProfilePictureSample/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>ProfilePictureSample</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/samples/ProfilePictureSample/AndroidManifest.xml b/samples/ProfilePictureSample/AndroidManifest.xml
new file mode 100644
index 000000000..907d05754
--- /dev/null
+++ b/samples/ProfilePictureSample/AndroidManifest.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.facebook.samples.profilepicture"
+          android:versionCode="1"
+          android:versionName="1.0">
+    <uses-sdk android:minSdkVersion="8"/>
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <application android:label="@string/app_name"
+                 android:icon="@drawable/icon" >
+        <activity
+                android:name=".ProfilePictureSampleActivity"
+                android:label="@string/app_name"
+                android:windowSoftInputMode="adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+</manifest> 
diff --git a/samples/ProfilePictureSample/ProfilePictureSample.iml b/samples/ProfilePictureSample/ProfilePictureSample.iml
new file mode 100644
index 000000000..bca109a37
--- /dev/null
+++ b/samples/ProfilePictureSample/ProfilePictureSample.iml
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/samples/ProfilePictureSample/ant.properties b/samples/ProfilePictureSample/ant.properties
new file mode 100644
index 000000000..b0971e891
--- /dev/null
+++ b/samples/ProfilePictureSample/ant.properties
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff --git a/samples/ProfilePictureSample/build.xml b/samples/ProfilePictureSample/build.xml
new file mode 100644
index 000000000..3454adc93
--- /dev/null
+++ b/samples/ProfilePictureSample/build.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="ProfilePictureSample" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties"/>
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties"/>
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env"/>
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME"/>
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties"/>
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+            />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true"/>
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml"/>
+
+</project>
diff --git a/samples/ProfilePictureSample/proguard-project.txt b/samples/ProfilePictureSample/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/ProfilePictureSample/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/samples/ProfilePictureSample/project.properties b/samples/ProfilePictureSample/project.properties
new file mode 100644
index 000000000..cee0509c6
--- /dev/null
+++ b/samples/ProfilePictureSample/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+android.library.reference.1=../../facebook
diff --git a/samples/ProfilePictureSample/res/drawable-hdpi/icon.png b/samples/ProfilePictureSample/res/drawable-hdpi/icon.png
new file mode 100644
index 000000000..1bc72b1bf
Binary files /dev/null and b/samples/ProfilePictureSample/res/drawable-hdpi/icon.png differ
diff --git a/samples/ProfilePictureSample/res/drawable-mdpi/icon.png b/samples/ProfilePictureSample/res/drawable-mdpi/icon.png
new file mode 100644
index 000000000..e0de1a4ba
Binary files /dev/null and b/samples/ProfilePictureSample/res/drawable-mdpi/icon.png differ
diff --git a/samples/ProfilePictureSample/res/drawable-xhdpi/icon.png b/samples/ProfilePictureSample/res/drawable-xhdpi/icon.png
new file mode 100644
index 000000000..1bc4b231d
Binary files /dev/null and b/samples/ProfilePictureSample/res/drawable-xhdpi/icon.png differ
diff --git a/samples/ProfilePictureSample/res/drawable/icon.png b/samples/ProfilePictureSample/res/drawable/icon.png
new file mode 100644
index 000000000..e0de1a4ba
Binary files /dev/null and b/samples/ProfilePictureSample/res/drawable/icon.png differ
diff --git a/samples/ProfilePictureSample/res/layout/activity_profile_picture_sample.xml b/samples/ProfilePictureSample/res/layout/activity_profile_picture_sample.xml
new file mode 100644
index 000000000..6806bbd20
--- /dev/null
+++ b/samples/ProfilePictureSample/res/layout/activity_profile_picture_sample.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<fragment xmlns:android="http://schemas.android.com/apk/res/android"
+          android:id="@+id/profilePictureSampleFragment"
+          android:layout_width="match_parent"
+          android:layout_height="match_parent"
+          android:name="com.facebook.samples.profilepicture.ProfilePictureSampleFragment"
+        />
diff --git a/samples/ProfilePictureSample/res/layout/fragment_profile_picture_sample.xml b/samples/ProfilePictureSample/res/layout/fragment_profile_picture_sample.xml
new file mode 100644
index 000000000..9fabb4c83
--- /dev/null
+++ b/samples/ProfilePictureSample/res/layout/fragment_profile_picture_sample.xml
@@ -0,0 +1,135 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+            xmlns:app="http://schemas.android.com/apk/res-auto"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        >
+<LinearLayout
+              android:orientation="vertical"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+        >
+    <TextView
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:text="@string/description"
+            android:layout_marginBottom="15dp"
+            />
+    <LinearLayout
+            android:layout_height="wrap_content"
+            android:layout_width="match_parent"
+            android:layout_marginBottom="15dp"
+            android:orientation="horizontal">
+        <LinearLayout
+                android:id="@+id/presetSizeView"
+                android:layout_height="wrap_content"
+                android:layout_width="0dp"
+                android:layout_weight="1"
+                android:orientation="horizontal"
+                >
+            <Button
+                    android:id="@+id/smallerButton"
+                    android:layout_height="40dp"
+                    android:layout_width="40dp"
+                    android:layout_weight="0"
+                    android:text="@string/smaller_button_text"
+                    android:textSize="18dp"
+                    />
+            <Button
+                    android:id="@+id/largerButton"
+                    android:layout_height="40dp"
+                    android:layout_width="40dp"
+                    android:layout_weight="0"
+                    android:text="@string/larger_button_text"
+                    android:textSize="18dp"
+                    android:enabled="false"
+                    />
+            <TextView
+                    android:id="@+id/sizeLabel"
+                    android:layout_height="40dp"
+                    android:layout_width="0dp"
+                    android:layout_weight="1"
+                    android:paddingLeft="10dp"
+                    android:text="@string/large_image_size"
+                    android:textSize="18dp"
+                    />
+        </LinearLayout>
+        <SeekBar
+                android:id="@+id/customSizeView"
+                android:layout_height="wrap_content"
+                android:layout_width="0dp"
+                android:layout_weight="1"
+                android:orientation="horizontal"
+                android:visibility="gone"
+                />
+        <Button
+                android:id="@+id/sizeToggle"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginLeft="10dp"
+                android:text="@string/custom_size_button_text"
+                />
+    </LinearLayout>
+    <LinearLayout
+            android:orientation="horizontal"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="10dp"
+            android:layout_marginBottom="10dp"
+            >
+        <com.facebook.ProfilePictureView
+                android:id="@+id/profilepic"
+                android:layout_height="wrap_content"
+                android:layout_width="0dp"
+                android:layout_weight="1"
+                app:preset_size="large"
+                />
+        <LinearLayout
+                android:id="@+id/userbuttoncontainer"
+                android:orientation="vertical"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="right"
+                >
+            <Button
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:text="@string/user_chris_name"
+                    android:tag="chris.lang.92123"
+                    />
+            <Button
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:text="@string/user_michael_name"
+                    android:tag="michael.marucheck"
+                    />
+            <Button
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:text="@string/user_karthik_name"
+                    android:tag="ksubraman"
+                    />
+            <Button
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:text="@string/user_random_name"
+                    />
+
+            <Button
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:text="@string/user_none_name"
+                    android:tag=""
+                    />
+        </LinearLayout>
+    </LinearLayout>
+
+    <CheckBox
+            android:id="@+id/squareCropToggle"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="@string/cropping_label"
+            android:checked="true"
+            />
+</LinearLayout>
+</ScrollView>
diff --git a/samples/ProfilePictureSample/res/values/strings.xml b/samples/ProfilePictureSample/res/values/strings.xml
new file mode 100644
index 000000000..cb5d00d89
--- /dev/null
+++ b/samples/ProfilePictureSample/res/values/strings.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">ProfilePictureSample</string>
+    <string name="description">Sample app demonstrating the use of ProfilePictureView</string>
+    <string name="cropping_label">Show cropped version</string>
+    <string name="crop_original_button_text">Original</string>
+    <string name="crop_square_button_text">Square</string>
+    <string name="user_chris_name">Chris</string>
+    <string name="user_michael_name">Michael</string>
+    <string name="user_karthik_name">Karthik</string>
+    <string name="user_random_name">Random</string>
+    <string name="user_none_name">None</string>
+    <string name="smaller_button_text">-</string>
+    <string name="larger_button_text">+</string>
+    <string name="large_image_size">Large</string>
+    <string name="normal_image_size">Normal</string>
+    <string name="small_image_size">Small</string>
+    <string name="preset_size_button_text">Use preset size</string>
+    <string name="custom_size_button_text">Use custom size</string>
+</resources>
diff --git a/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleActivity.java b/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleActivity.java
new file mode 100644
index 000000000..217c55afc
--- /dev/null
+++ b/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleActivity.java
@@ -0,0 +1,12 @@
+package com.facebook.samples.profilepicture;
+
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+
+public class ProfilePictureSampleActivity extends FragmentActivity {
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_profile_picture_sample);
+    }
+}
diff --git a/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleFragment.java b/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleFragment.java
new file mode 100644
index 000000000..467c5decd
--- /dev/null
+++ b/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleFragment.java
@@ -0,0 +1,298 @@
+package com.facebook.samples.profilepicture;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.*;
+import com.facebook.ProfilePictureView;
+
+import java.util.Date;
+import java.util.Random;
+
+public class ProfilePictureSampleFragment extends Fragment {
+
+    // Keeping the number of custom sizes low to prevent excessive network chatter.
+    private static final int MAX_CUSTOM_SIZES = 6;
+    private static final int DEFAULT_SIZE_INCREMENT = MAX_CUSTOM_SIZES / 2;
+    private static final String PICTURE_SIZE_TYPE_KEY = "PictureSizeType";
+
+    private static final String[] INTERESTING_IDS = {
+        "zuck",
+        // Recent Presidents and nominees
+        "barackobama",
+        "mittromney",
+        "johnmccain",
+        "johnkerry",
+        "georgewbush",
+        "algore",
+        // Places too!
+        "Disneyland",
+        "SpaceNeedle",
+        "TourEiffel",
+        "sydneyoperahouse",
+        // A selection of 1986 Mets
+        "166020963458360",
+        "108084865880237",
+        "140447466087679",
+        "111825495501392",
+        // The cast of Saved by the Bell
+        "108168249210849",
+        "TiffaniThiessen",
+        "108126672542534",
+        "112886105391693",
+        "MarioLopezExtra",
+        "108504145837165",
+        "dennishaskins",
+        // Eighties bands that have been to Moscow
+        "7220821999",
+        "31938132882",
+        "108023262558391",
+        "209263392372",
+        "104132506290482",
+        "9721897972",
+        "5461947317",
+        "57084011597",
+        // Three people that have never been in my kitchen
+        "24408579964",
+        "111980872152571",
+        "112427772106500",
+        // Trusted anchormen
+        "113415525338717",
+        "105628452803615",
+        "105533779480538",
+    };
+
+    private int pictureSizeType = ProfilePictureView.CUSTOM;
+    private String firstUserId;
+    private Random randomGenerator;
+
+    private ProfilePictureView profilePic;
+    private Button smallerButton;
+    private Button largerButton;
+    private TextView sizeLabel;
+    private View presetSizeView;
+    private SeekBar customSizeView;
+    private CheckBox cropToggle;
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {
+        View v = inflater.inflate(R.layout.fragment_profile_picture_sample, parent, false);
+
+        randomGenerator = new Random((new Date()).getTime());
+
+        profilePic = (ProfilePictureView)v.findViewById(R.id.profilepic);
+        smallerButton = (Button)v.findViewById(R.id.smallerButton);
+        largerButton = (Button)v.findViewById(R.id.largerButton);
+        sizeLabel = (TextView)v.findViewById(R.id.sizeLabel);
+        presetSizeView = v.findViewById(R.id.presetSizeView);
+        customSizeView = (SeekBar)v.findViewById(R.id.customSizeView);
+        cropToggle = (CheckBox)v.findViewById(R.id.squareCropToggle);
+
+        LinearLayout container = (LinearLayout)v.findViewById(R.id.userbuttoncontainer);
+        int numChildren = container.getChildCount();
+        for (int i = 0; i < numChildren; i++) {
+            View childView = container.getChildAt(i);
+            Object tag = childView.getTag();
+            if (childView instanceof Button) {
+                setupUserButton((Button)childView);
+                if (i == 0) {
+                    // Initialize the image to the first user
+                    firstUserId = tag.toString();
+                }
+            }
+        }
+
+        cropToggle.setOnCheckedChangeListener(new CheckBox.OnCheckedChangeListener() {
+            @Override
+            public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
+                profilePic.setCropped(checked);
+            }
+        });
+
+        final Button sizeToggle = (Button)v.findViewById(R.id.sizeToggle);
+        sizeToggle.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                if (pictureSizeType != ProfilePictureView.CUSTOM) {
+                    sizeToggle.setText(R.string.preset_size_button_text);
+                    switchToCustomSize();
+                } else {
+                    sizeToggle.setText(R.string.custom_size_button_text);
+                    switchToPresetSize(ProfilePictureView.LARGE);
+                }
+            }
+        });
+
+        smallerButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                switch(profilePic.getPresetSize()) {
+                    case ProfilePictureView.LARGE:
+                        switchToPresetSize(ProfilePictureView.NORMAL);
+                        break;
+                    case ProfilePictureView.NORMAL:
+                        switchToPresetSize(ProfilePictureView.SMALL);
+                        break;
+                }
+            }
+        });
+
+        largerButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                switch(profilePic.getPresetSize()) {
+                    case ProfilePictureView.NORMAL:
+                        switchToPresetSize(ProfilePictureView.LARGE);
+                        break;
+                    case ProfilePictureView.SMALL:
+                        switchToPresetSize(ProfilePictureView.NORMAL);
+                        break;
+                }
+            }
+        });
+
+        // We will fetch a new image for each change in the SeekBar. So keeping the count low
+        // to prevent too much network chatter. SeekBar reports 0-max, so we will get max+1
+        // notifications of change.
+        customSizeView.setMax(MAX_CUSTOM_SIZES);
+        customSizeView.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
+            @Override
+            public void onProgressChanged(SeekBar seekBar, int i, boolean b) {
+                updateProfilePicForCustomSizeIncrement(i);
+            }
+
+            @Override
+            public void onStartTrackingTouch(SeekBar seekBar) {
+                // NO-OP
+            }
+
+            @Override
+            public void onStopTrackingTouch(SeekBar seekBar) {
+                // NO-OP
+            }
+        });
+
+        restoreState(savedInstanceState);
+
+        return v;
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        // Store the size type since we will use that to switch the Fragment's UI
+        // between CUSTOM & PRESET modes
+        // Other state (userId & isCropped) will be saved/restored directly by
+        // ProfilePictureView
+        outState.putInt(PICTURE_SIZE_TYPE_KEY, pictureSizeType);
+    }
+
+    private void restoreState(Bundle savedInstanceState) {
+        if (savedInstanceState != null) {
+            // Is we have saved state, restore the Fragment to it.
+            // UserId & isCropped will be restored directly by ProfilePictureView
+            pictureSizeType = savedInstanceState.getInt(
+                    PICTURE_SIZE_TYPE_KEY, ProfilePictureView.LARGE);
+
+            if (pictureSizeType == ProfilePictureView.CUSTOM) {
+                switchToCustomSize();
+            } else {
+                switchToPresetSize(pictureSizeType);
+            }
+        } else {
+            // No saved state. Let's go to a default state
+            switchToPresetSize(ProfilePictureView.LARGE);
+            profilePic.setCropped(cropToggle.isChecked());
+
+            // Setting userId last so that only one network request is sent
+            profilePic.setUserId(firstUserId);
+        }
+    }
+
+    private void setupUserButton(Button b) {
+        b.setOnClickListener(new Button.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                Object tag = v.getTag();
+                String userId = null;
+                if (tag != null) {
+                    userId = tag.toString();
+                } else {
+                    // Random id.
+                    userId = INTERESTING_IDS[randomGenerator.nextInt(INTERESTING_IDS.length)];
+                }
+                profilePic.setUserId(userId);
+            }
+        });
+    }
+
+    private void switchToCustomSize() {
+        pictureSizeType = ProfilePictureView.CUSTOM;
+        presetSizeView.setVisibility(View.GONE);
+        customSizeView.setVisibility(View.VISIBLE);
+
+        profilePic.setPresetSize(pictureSizeType);
+
+        customSizeView.setProgress(DEFAULT_SIZE_INCREMENT);
+        updateProfilePicForCustomSizeIncrement(DEFAULT_SIZE_INCREMENT);
+    }
+
+    private void switchToPresetSize(int sizeType) {
+        customSizeView.setVisibility(View.GONE);
+        presetSizeView.setVisibility(View.VISIBLE);
+
+        switch(sizeType) {
+            case ProfilePictureView.SMALL:
+                largerButton.setEnabled(true);
+                smallerButton.setEnabled(false);
+                sizeLabel.setText(R.string.small_image_size);
+                pictureSizeType = sizeType;
+                break;
+            case ProfilePictureView.NORMAL:
+                largerButton.setEnabled(true);
+                smallerButton.setEnabled(true);
+                sizeLabel.setText(R.string.normal_image_size);
+                pictureSizeType = sizeType;
+                break;
+            case ProfilePictureView.LARGE:
+            default:
+                largerButton.setEnabled(false);
+                smallerButton.setEnabled(true);
+                sizeLabel.setText(R.string.large_image_size);
+                pictureSizeType = ProfilePictureView.LARGE;
+                break;
+        }
+
+        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(
+                0,
+                ViewGroup.LayoutParams.WRAP_CONTENT,
+                1
+        );
+
+        profilePic.setLayoutParams(params);
+        profilePic.setPresetSize(pictureSizeType);
+    }
+
+    private void updateProfilePicForCustomSizeIncrement(int i) {
+        if (pictureSizeType != ProfilePictureView.CUSTOM) {
+            return;
+        }
+
+        // This will ensure a minimum size of 51x68 and will scale the image at
+        // a ratio of 3:4 (w:h) as the SeekBar is moved.
+        //
+        // Completely arbitrary
+        //
+        // NOTE: The numbers are in dips.
+        float width = (i * 21) + 51;
+        float height = (i * 28) + 68;
+
+        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(
+                (int)(width * getResources().getDisplayMetrics().density),
+                (int)(height * getResources().getDisplayMetrics().density));
+        profilePic.setLayoutParams(params);
+    }
+}
diff --git a/samples/Scrumptious/.classpath b/samples/Scrumptious/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/Scrumptious/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/Scrumptious/.project b/samples/Scrumptious/.project
new file mode 100644
index 000000000..dfb9212a3
--- /dev/null
+++ b/samples/Scrumptious/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Scrumptious</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/samples/Scrumptious/AndroidManifest.xml b/samples/Scrumptious/AndroidManifest.xml
new file mode 100644
index 000000000..e5db50d58
--- /dev/null
+++ b/samples/Scrumptious/AndroidManifest.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.facebook.scrumptious"
+          android:versionCode="1"
+          android:versionName="1.0">
+    <uses-sdk android:minSdkVersion="8"/>
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
+    <uses-feature android:name="android.hardware.camera"/>
+    <uses-feature android:name="android.hardware.camera.autofocus"/>
+    <application android:label="@string/app_name"
+                 android:icon="@drawable/icon"
+                 android:name=".ScrumptiousApplication">
+        <activity android:name="MainActivity"
+                  android:label="@string/app_name"
+                  android:windowSoftInputMode="adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+        <activity android:name="PickerActivity"
+                  android:label="@string/app_name" />
+        <activity android:name="com.facebook.LoginActivity"
+                  android:label="@string/app_name" />
+        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
+    </application>
+</manifest> 
diff --git a/samples/Scrumptious/Scrumptious.iml b/samples/Scrumptious/Scrumptious.iml
new file mode 100644
index 000000000..549243369
--- /dev/null
+++ b/samples/Scrumptious/Scrumptious.iml
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" exported="" />
+    <orderEntry type="library" exported="" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/samples/Scrumptious/ant.properties b/samples/Scrumptious/ant.properties
new file mode 100644
index 000000000..b0971e891
--- /dev/null
+++ b/samples/Scrumptious/ant.properties
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff --git a/samples/Scrumptious/build.xml b/samples/Scrumptious/build.xml
new file mode 100644
index 000000000..7f943468f
--- /dev/null
+++ b/samples/Scrumptious/build.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="Scrumptious" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties"/>
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties"/>
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env"/>
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME"/>
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties"/>
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+            />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true"/>
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml"/>
+
+</project>
diff --git a/samples/Scrumptious/proguard-project.txt b/samples/Scrumptious/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/Scrumptious/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/samples/Scrumptious/project.properties b/samples/Scrumptious/project.properties
new file mode 100644
index 000000000..cee0509c6
--- /dev/null
+++ b/samples/Scrumptious/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+android.library.reference.1=../../facebook
diff --git a/samples/Scrumptious/res/drawable-hdpi/icon.png b/samples/Scrumptious/res/drawable-hdpi/icon.png
new file mode 100644
index 000000000..0320aeb54
Binary files /dev/null and b/samples/Scrumptious/res/drawable-hdpi/icon.png differ
diff --git a/samples/Scrumptious/res/drawable-mdpi/icon.png b/samples/Scrumptious/res/drawable-mdpi/icon.png
new file mode 100644
index 000000000..5c4b0095f
Binary files /dev/null and b/samples/Scrumptious/res/drawable-mdpi/icon.png differ
diff --git a/samples/Scrumptious/res/drawable-xhdpi/icon.png b/samples/Scrumptious/res/drawable-xhdpi/icon.png
new file mode 100644
index 000000000..796e14ec2
Binary files /dev/null and b/samples/Scrumptious/res/drawable-xhdpi/icon.png differ
diff --git a/samples/Scrumptious/res/drawable/action_eating.png b/samples/Scrumptious/res/drawable/action_eating.png
new file mode 100644
index 000000000..7b951edf0
Binary files /dev/null and b/samples/Scrumptious/res/drawable/action_eating.png differ
diff --git a/samples/Scrumptious/res/drawable/action_location.png b/samples/Scrumptious/res/drawable/action_location.png
new file mode 100644
index 000000000..13dfe86ff
Binary files /dev/null and b/samples/Scrumptious/res/drawable/action_location.png differ
diff --git a/samples/Scrumptious/res/drawable/action_people.png b/samples/Scrumptious/res/drawable/action_people.png
new file mode 100644
index 000000000..19546267c
Binary files /dev/null and b/samples/Scrumptious/res/drawable/action_people.png differ
diff --git a/samples/Scrumptious/res/drawable/button_border.xml b/samples/Scrumptious/res/drawable/button_border.xml
new file mode 100644
index 000000000..76e080b14
--- /dev/null
+++ b/samples/Scrumptious/res/drawable/button_border.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+       android:shape="rectangle">
+    <solid android:color="#FFF" />
+    <corners android:radius="10dp" />
+    <padding android:bottom="10dp" android:left="10dp" android:right="10dp" android:top="10dp" />
+    <stroke android:width="1px" android:color="#222" />
+</shape>
\ No newline at end of file
diff --git a/samples/Scrumptious/res/drawable/facebook.png b/samples/Scrumptious/res/drawable/facebook.png
new file mode 100755
index 000000000..daf8097b1
Binary files /dev/null and b/samples/Scrumptious/res/drawable/facebook.png differ
diff --git a/samples/Scrumptious/res/drawable/icon.png b/samples/Scrumptious/res/drawable/icon.png
new file mode 100644
index 000000000..5c4b0095f
Binary files /dev/null and b/samples/Scrumptious/res/drawable/icon.png differ
diff --git a/samples/Scrumptious/res/layout/listitem.xml b/samples/Scrumptious/res/layout/listitem.xml
new file mode 100644
index 000000000..01f3480a2
--- /dev/null
+++ b/samples/Scrumptious/res/layout/listitem.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="fill_parent"
+              android:layout_height="wrap_content"
+              android:layout_gravity="center_horizontal"
+              android:orientation="horizontal">
+
+    <ImageView
+            android:id="@+id/icon"
+            android:src="@drawable/action_eating"
+            android:layout_width="60dp"
+            android:layout_height="60dp" />
+    <LinearLayout
+            android:orientation="vertical"
+            android:layout_gravity="center_vertical"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginLeft="15dp" >
+        <TextView
+                android:id="@+id/text1"
+                android:text="test"
+                android:textColor="#333"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:textSize="18sp" />
+        <TextView
+                android:id="@+id/text2"
+                android:text="test2"
+                android:textColor="#6699CC"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:textSize="14sp" />
+    </LinearLayout>
+</LinearLayout>
\ No newline at end of file
diff --git a/samples/Scrumptious/res/layout/main.xml b/samples/Scrumptious/res/layout/main.xml
new file mode 100644
index 000000000..6d772e5f3
--- /dev/null
+++ b/samples/Scrumptious/res/layout/main.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        android:orientation="vertical"
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent">
+    <FrameLayout
+            android:id="@+id/body_frame"
+            android:layout_height="fill_parent"
+            android:layout_width="fill_parent"
+            android:layout_weight="1" />
+</LinearLayout>
+
diff --git a/samples/Scrumptious/res/layout/pickers.xml b/samples/Scrumptious/res/layout/pickers.xml
new file mode 100644
index 000000000..3f5c01221
--- /dev/null
+++ b/samples/Scrumptious/res/layout/pickers.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:orientation="vertical"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+        >
+    <FrameLayout
+            android:id="@+id/picker_fragment"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            />
+</LinearLayout>
diff --git a/samples/Scrumptious/res/layout/selection.xml b/samples/Scrumptious/res/layout/selection.xml
new file mode 100644
index 000000000..2a298921b
--- /dev/null
+++ b/samples/Scrumptious/res/layout/selection.xml
@@ -0,0 +1,56 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<ScrollView
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:facebook="http://schemas.android.com/apk/res-auto"
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent"
+        android:background="#FFF">
+    <LinearLayout
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent"
+        android:orientation="vertical">
+
+        <LinearLayout
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="20dp"
+            android:gravity="center_horizontal"
+            android:orientation="horizontal" >
+            <com.facebook.ProfilePictureView
+                android:id="@+id/selection_profile_pic"
+                android:layout_height="wrap_content"
+                android:layout_width="wrap_content"
+                android:layout_gravity="center"
+                android:gravity="center_horizontal"
+                facebook:preset_size="small" />
+            <TextView
+                android:id="@+id/selection_user_name"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginLeft="10dp"
+                android:layout_gravity="center"
+                android:textColor="#333"
+                android:textSize="18sp" />
+        </LinearLayout>
+
+        <com.facebook.scrumptious.FullListView
+            android:id="@+id/selection_list"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_margin="20dp"
+            android:background="@drawable/button_border"/>
+
+        <Button
+            android:id="@+id/announce_button"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center"
+            android:textStyle="bold"
+            android:background="@drawable/button_border"
+            android:layout_marginBottom="20dp"
+            android:text="@string/announce"
+            android:gravity="center" />
+
+    </LinearLayout>
+</ScrollView>
\ No newline at end of file
diff --git a/samples/Scrumptious/res/layout/splash.xml b/samples/Scrumptious/res/layout/splash.xml
new file mode 100644
index 000000000..c7a853060
--- /dev/null
+++ b/samples/Scrumptious/res/layout/splash.xml
@@ -0,0 +1,61 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<ScrollView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:background="#303040" >
+
+    <LinearLayout
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent"
+        android:orientation="vertical">
+
+        <LinearLayout
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="30dp"
+            android:gravity="center_horizontal"
+            android:orientation="horizontal" >
+            <ImageView
+                android:id="@+id/splash_icon"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center"
+                android:layout_marginRight="10dp"
+                android:gravity="center"
+                android:src="@drawable/icon" />
+            <TextView
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center"
+                android:gravity="center"
+                android:textColor="#AFDEFE"
+                android:textSize="28sp"
+                android:typeface="serif"
+                android:textStyle="italic"
+                android:text="@string/app_name" />
+        </LinearLayout>
+
+
+        <TextView
+            android:id="@+id/profile_name"
+            android:layout_width="174dp"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="35dp"
+            android:lines="2"
+            android:textSize="17sp"
+            android:text="@string/get_started"
+            android:layout_gravity="center_horizontal"
+            android:gravity="center_horizontal"/>
+
+        <com.facebook.LoginButton
+            android:id="@+id/login_button"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:layout_marginTop="30dp"
+            android:layout_marginBottom="30dp" />
+
+    </LinearLayout>
+</ScrollView>
diff --git a/samples/Scrumptious/res/values/strings.xml b/samples/Scrumptious/res/values/strings.xml
new file mode 100644
index 000000000..3978898a4
--- /dev/null
+++ b/samples/Scrumptious/res/values/strings.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">Scrumptious</string>
+    <string name="app_id">233936543368280</string>
+    <string name="get_started">To get started, login using Facebook</string>
+    <string name="action_eating">What are you eating?</string>
+    <string name="action_location">Where are you?</string>
+    <string name="action_people">With whom?</string>
+    <string name="action_eating_default">Select one</string>
+    <string name="action_location_default">Select one</string>
+    <string name="action_people_default">Select friends</string>
+    <string name="announce">Announce</string>
+    <string name="login">Login</string>
+    <string name="settings">Settings</string>
+    <string name="select_meal">Select a meal</string>
+    <string name="result_dialog_title">Result</string>
+    <string name="result_dialog_button_text">Thanks!</string>
+    <string name="result_dialog_text">Posted Open Graph action, id: %1$s</string>
+    <string name="progress_dialog_text">Announcing, please wait...</string>
+    <string name="single_user_selected">%1$s</string>
+    <string name="two_users_selected">%1$s and %2$s</string>
+    <string name="multiple_users_selected">%1$s and %2$s others</string>
+    <string name="error_dialog_title">Error</string>
+    <string name="error_dialog_button_text">OK</string>
+    <string name="no_location_error">Could not obtain your current location</string>
+    <string name="select_picture">Select Picture</string>
+
+    <string-array name="food_types">
+        <item>Cheeseburger</item>
+        <item>Pizza</item>
+        <item>Hotdog</item>
+        <item>Italian</item>
+        <item>French</item>
+        <item>Chinese</item>
+        <item>Thai</item>
+        <item>Indian</item>
+    </string-array>
+
+    <string-array name="food_og_urls">
+        <item>http://samples.ogp.me/314483151980285</item> <!-- Cheeseburger -->
+        <item>http://samples.ogp.me/314483221980278</item> <!-- Pizza -->
+        <item>http://samples.ogp.me/314483265313607</item> <!-- Hotdog -->
+        <item>http://samples.ogp.me/314483348646932</item> <!-- Italian -->
+        <item>http://samples.ogp.me/314483375313596</item> <!-- French -->
+        <item>http://samples.ogp.me/314483421980258</item> <!-- Chinese -->
+        <item>http://samples.ogp.me/314483451980255</item> <!-- Thai -->
+        <item>http://samples.ogp.me/314483491980251</item> <!-- Indian -->
+    </string-array>
+</resources>
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/BaseListElement.java b/samples/Scrumptious/src/com/facebook/scrumptious/BaseListElement.java
new file mode 100644
index 000000000..1a833e349
--- /dev/null
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/BaseListElement.java
@@ -0,0 +1,154 @@
+package com.facebook.scrumptious;
+
+import android.content.Intent;
+import android.graphics.drawable.Drawable;
+import android.os.Bundle;
+import android.view.View;
+import android.widget.BaseAdapter;
+import com.facebook.OpenGraphAction;
+
+/**
+ * Base class for a list element in the Scrumptious main display, consisting of an
+ * icon to the left, and a two line display to the right.
+ */
+public abstract class BaseListElement {
+
+    private Drawable icon;
+    private String text1;
+    private String text2;
+    private BaseAdapter adapter;
+    private int requestCode;
+
+    /**
+     * Constructs a new list element.
+     *
+     * @param icon the drawable for the icon
+     * @param text1 the first row of text
+     * @param text2 the second row of text
+     * @param requestCode the requestCode to start new Activities with
+     */
+    public BaseListElement(Drawable icon, String text1, String text2, int requestCode) {
+        this.icon = icon;
+        this.text1 = text1;
+        this.text2 = text2;
+        this.requestCode = requestCode;
+    }
+
+    /**
+     * The Adapter associated with this list element (used for notifying that the
+     * underlying dataset has changed).
+     * @param adapter the adapter associated with this element
+     */
+    public void setAdapter(BaseAdapter adapter) {
+        this.adapter = adapter;
+    }
+
+    /**
+     * Returns the icon.
+     *
+     * @return the icon
+     */
+    public Drawable getIcon() {
+        return icon;
+    }
+
+    /**
+     * Returns the first row of text.
+     *
+     * @return the first row of text
+     */
+    public String getText1() {
+        return text1;
+    }
+
+    /**
+     * Returns the second row of text.
+     *
+     * @return the second row of text
+     */
+    public String getText2() {
+        return text2;
+    }
+
+    /**
+     * Returns the requestCode for starting new Activities.
+     *
+     * @return the requestCode
+     */
+    public int getRequestCode() {
+        return requestCode;
+    }
+
+    /**
+     * Sets the first row of text.
+     *
+     * @param text1 text to set on the first row
+     */
+    public void setText1(String text1) {
+        this.text1 = text1;
+        if (adapter != null) {
+            adapter.notifyDataSetChanged();
+        }
+    }
+
+    /**
+     * Sets the second row of text.
+     *
+     * @param text2 text to set on the second row
+     */
+    public void setText2(String text2) {
+        this.text2 = text2;
+        if (adapter != null) {
+            adapter.notifyDataSetChanged();
+        }
+    }
+
+    /**
+     * Returns the OnClickListener associated with this list element. To be
+     * overridden by the subclasses.
+     *
+     * @return the OnClickListener associated with this list element
+     */
+    protected abstract View.OnClickListener getOnClickListener();
+
+    /**
+     * Populate an OpenGraphAction with the results of this list element.
+     *
+     * @param action the action to populate with data
+     */
+    protected abstract void populateOGAction(OpenGraphAction action);
+
+    /**
+     * Callback if the OnClickListener happens to launch a new Activity.
+     *
+     * @param data the data associated with the result
+     */
+    protected void onActivityResult(Intent data) {}
+
+    /**
+     * Save the state of the current element.
+     *
+     * @param bundle the bundle to save to
+     */
+    protected void onSaveInstanceState(Bundle bundle) {}
+
+    /**
+     * Restore the state from the saved bundle. Returns true if the
+     * state was restored.
+     *
+     * @param savedState the bundle to restore from
+     * @return true if state was restored
+     */
+    protected boolean restoreState(Bundle savedState) {
+        return false;
+    }
+
+    /**
+     * Notifies the associated Adapter that the underlying data has changed,
+     * and to re-layout the view.
+     */
+    protected void notifyDataChanged() {
+        adapter.notifyDataSetChanged();
+    }
+
+}
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/FullListView.java b/samples/Scrumptious/src/com/facebook/scrumptious/FullListView.java
new file mode 100644
index 000000000..84908cfe9
--- /dev/null
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/FullListView.java
@@ -0,0 +1,46 @@
+package com.facebook.scrumptious;
+
+import android.content.Context;
+import android.graphics.Rect;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.ListAdapter;
+import android.widget.ListView;
+
+/**
+ * A subclass of ListView that will always show the full list of elements.
+ * This allows a ListView to be embedded inside a ScrollView.
+ */
+public class FullListView extends ListView {
+
+    public FullListView(Context context) {
+        super(context);
+    }
+
+    public FullListView(Context context, AttributeSet attributeSet) {
+        super(context, attributeSet);
+    }
+
+    public FullListView(Context context, AttributeSet attributeSet, int defStyle) {
+        super(context, attributeSet, defStyle);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+        int width = getMeasuredWidth();
+        int height = 0;
+        ListAdapter adapter = getAdapter();
+        int count = adapter.getCount();
+        for (int i = 0; i < count; i++) {
+            View childView = adapter.getView(i, null, this);
+            childView.measure(MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED),
+                    MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));
+            height += childView.getMeasuredHeight();
+        }
+        Rect bgPadding = new Rect();
+        getBackground().getPadding(bgPadding);
+        height += (count - 1) * getDividerHeight() + bgPadding.top + bgPadding.bottom;
+        setMeasuredDimension(width, height);
+    }
+}
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/MainActivity.java b/samples/Scrumptious/src/com/facebook/scrumptious/MainActivity.java
new file mode 100644
index 000000000..849e82860
--- /dev/null
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/MainActivity.java
@@ -0,0 +1,189 @@
+package com.facebook.scrumptious;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentManager;
+import android.support.v4.app.FragmentTransaction;
+import android.util.Log;
+import android.view.Menu;
+import android.view.MenuItem;
+import com.facebook.FacebookActivity;
+import com.facebook.LoginFragment;
+import com.facebook.Session;
+import com.facebook.SessionState;
+
+public class MainActivity extends FacebookActivity {
+
+    private static final int SPLASH = 0;
+    private static final int SELECTION = 1;
+    private static final int SETTINGS = 2;
+    private static final int FRAGMENT_COUNT = SETTINGS +1;
+    private static final String FRAGMENT_PREFIX = "fragment";
+    private static final String TAG = "Scrumplicious";
+
+    private Fragment[] fragments = new Fragment[FRAGMENT_COUNT];
+    private MenuItem settings;
+    private boolean restoredFragment = false;
+    private boolean isResumed = false;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+
+        for(int i = 0; i < fragments.length; i++) {
+            restoreFragment(savedInstanceState, i);
+        }
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        isResumed = true;
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        isResumed = false;
+    }
+
+    @Override
+    protected void onResumeFragments() {
+        super.onResumeFragments();
+        Session session = Session.getActiveSession();
+        if (session == null || session.getState().isClosed()) {
+            session = new Session(this);
+            Session.setActiveSession(session);
+        }
+
+        FragmentManager manager = getSupportFragmentManager();
+
+        if (restoredFragment) {
+            return;
+        }
+
+        // If we already have a valid token, then we can just open the session silently,
+        // otherwise present the splash screen and ask the user to login.
+        if (session.getState().equals(SessionState.CREATED_TOKEN_LOADED)) {
+            // no need to add any fragments here since it will be handled in onSessionStateChange
+            session.openForRead(this);
+        } else if (session.isOpened()) {
+            // if the session is already open, try to show the selection fragment
+            Fragment fragment = manager.findFragmentById(R.id.body_frame);
+            if (!(fragment instanceof SelectionFragment)) {
+                manager.beginTransaction().replace(R.id.body_frame, fragments[SELECTION]).commit();
+            }
+        } else {
+            FragmentTransaction transaction = manager.beginTransaction();
+            transaction.replace(R.id.body_frame, fragments[SPLASH]).commit();
+        }
+    }
+
+    @Override
+    public boolean onPrepareOptionsMenu(Menu menu) {
+        FragmentManager manager = getSupportFragmentManager();
+        Fragment currentFragment = manager.findFragmentById(R.id.body_frame);
+        // only add the menu when the selection fragment is showing
+        if (currentFragment == fragments[SELECTION]) {
+            if (menu.size() == 0) {
+                settings = menu.add(R.string.settings);
+            }
+            return true;
+        } else {
+            menu.clear();
+            settings = null;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        if (item.equals(settings)) {
+            FragmentManager manager = getSupportFragmentManager();
+            FragmentTransaction transaction = manager.beginTransaction();
+            transaction.add(R.id.body_frame, fragments[SETTINGS]).addToBackStack(null).commit();
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        FragmentManager manager = getSupportFragmentManager();
+        // Since we're only adding one Fragment at a time, we can only save one.
+        Fragment f = manager.findFragmentById(R.id.body_frame);
+        for (int i = 0; i < fragments.length; i++) {
+            if (fragments[i] == f) {
+                manager.putFragment(outState, getBundleKey(i), fragments[i]);
+            }
+        }
+    }
+
+    @Override
+    protected void onSessionStateChange(SessionState state, Exception exception) {
+        if (isResumed) {
+            FragmentManager manager = getSupportFragmentManager();
+            int backStackSize = manager.getBackStackEntryCount();
+            for (int i = 0; i < backStackSize; i++) {
+                manager.popBackStack();
+            }
+            if (state.isOpened()) {
+                if (state.equals(SessionState.OPENED_TOKEN_UPDATED)) {
+                    ((SelectionFragment) fragments[SELECTION]).tokenUpdated();
+                } else {
+                    FragmentTransaction transaction = manager.beginTransaction();
+                    transaction.replace(R.id.body_frame, fragments[SELECTION]).commit();
+                }
+            } else if (state.isClosed()) {
+                FragmentTransaction transaction = manager.beginTransaction();
+                transaction.replace(R.id.body_frame, fragments[SPLASH]).commit();
+            }
+        }
+    }
+
+    /**
+     * Returns the key to be used when saving a Fragment to a Bundle.
+     * @param index the index of the Fragment in the fragments array
+     * @return the key to be used
+     */
+    private String getBundleKey(int index) {
+        return FRAGMENT_PREFIX + Integer.toString(index);
+    }
+
+    /**
+     * Restore fragments from the bundle. If a necessary Fragment cannot be found in the bundle,
+     * a new instance will be created.
+     *
+     * @param savedInstanceState
+     * @param fragmentIndex
+     */
+    private void restoreFragment(Bundle savedInstanceState, int fragmentIndex) {
+        Fragment fragment = null;
+        if (savedInstanceState != null) {
+            FragmentManager manager = getSupportFragmentManager();
+            fragment = manager.getFragment(savedInstanceState, getBundleKey(fragmentIndex));
+        }
+        if (fragment != null) {
+            fragments[fragmentIndex] = fragment;
+            restoredFragment = true;
+        } else {
+            switch (fragmentIndex) {
+                case SPLASH:
+                    fragments[SPLASH] = new SplashFragment();
+                    break;
+                case SELECTION:
+                    fragments[SELECTION] = new SelectionFragment();
+                    break;
+                case SETTINGS:
+                    fragments[SETTINGS] = new LoginFragment();
+                    break;
+                default:
+                    Log.w(TAG, "invalid fragment index");
+                    break;
+            }
+        }
+    }
+
+}
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/PickerActivity.java b/samples/Scrumptious/src/com/facebook/scrumptious/PickerActivity.java
new file mode 100644
index 000000000..152ed375f
--- /dev/null
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/PickerActivity.java
@@ -0,0 +1,217 @@
+package com.facebook.scrumptious;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.location.Criteria;
+import android.location.Location;
+import android.location.LocationListener;
+import android.location.LocationManager;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Looper;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+import com.facebook.FacebookException;
+import com.facebook.FriendPickerFragment;
+import com.facebook.PickerFragment;
+import com.facebook.PlacePickerFragment;
+
+/**
+ * The PickerActivity enhances the Friend or Place Picker by adding a title
+ * and a Done button. The selection results are saved in the ScrumptiousApplication
+ * instance.
+ */
+public class PickerActivity extends FragmentActivity {
+    public static final Uri FRIEND_PICKER = Uri.parse("picker://friend");
+    public static final Uri PLACE_PICKER = Uri.parse("picker://place");
+
+    private static final int SEARCH_RADIUS_METERS = 1000;
+    private static final int SEARCH_RESULT_LIMIT = 50;
+    private static final String SEARCH_TEXT = "restaurant";
+    private static final int LOCATION_CHANGE_THRESHOLD = 50; // meters
+
+    private static final Location SAN_FRANCISCO_LOCATION = new Location("") {{
+            setLatitude(37.7750);
+            setLongitude(-122.4183);
+    }};
+
+    private FriendPickerFragment friendPickerFragment;
+    private PlacePickerFragment placePickerFragment;
+    private LocationListener locationListener;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.pickers);
+
+        Bundle args = getIntent().getExtras();
+        FragmentManager manager = getSupportFragmentManager();
+        Fragment fragmentToShow = null;
+        Uri intentUri = getIntent().getData();
+
+        if (FRIEND_PICKER.equals(intentUri)) {
+            if (savedInstanceState == null) {
+                friendPickerFragment = new FriendPickerFragment(args);
+            } else {
+                friendPickerFragment = (FriendPickerFragment) manager.findFragmentById(R.id.picker_fragment);;
+            }
+
+            friendPickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
+                @Override
+                public void onError(FacebookException error) {
+                    PickerActivity.this.onError(error);
+                }
+            });
+            friendPickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
+                @Override
+                public void onDoneButtonClicked() {
+                    finishActivity();
+                }
+            });
+            fragmentToShow = friendPickerFragment;
+
+        } else if (PLACE_PICKER.equals(intentUri)) {
+            if (savedInstanceState == null) {
+                placePickerFragment = new PlacePickerFragment(args);
+            } else {
+                placePickerFragment = (PlacePickerFragment) manager.findFragmentById(R.id.picker_fragment);
+            }
+            placePickerFragment.setOnSelectionChangedListener(new PickerFragment.OnSelectionChangedListener() {
+                @Override
+                public void onSelectionChanged() {
+                    finishActivity(); // call finish since you can only pick one place
+                }
+            });
+            placePickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
+                @Override
+                public void onError(FacebookException error) {
+                    PickerActivity.this.onError(error);
+                }
+            });
+            placePickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
+                @Override
+                public void onDoneButtonClicked() {
+                    finishActivity();
+                }
+            });
+            fragmentToShow = placePickerFragment;
+        } else {
+            // Nothing to do, finish
+            setResult(RESULT_CANCELED);
+            finish();
+            return;
+        }
+
+        manager.beginTransaction().replace(R.id.picker_fragment, fragmentToShow).commit();
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        if (FRIEND_PICKER.equals(getIntent().getData())) {
+            try {
+                friendPickerFragment.loadData(false);
+            } catch (Exception ex) {
+                onError(ex);
+            }
+        } else if (PLACE_PICKER.equals(getIntent().getData())) {
+            try {
+                Location location = null;
+                Criteria criteria = new Criteria();
+                LocationManager locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
+                String bestProvider = locationManager.getBestProvider(criteria, false);
+                if (bestProvider != null) {
+                    location = locationManager.getLastKnownLocation(bestProvider);
+                    if (locationManager.isProviderEnabled(bestProvider) && locationListener == null) {
+                        locationListener = new LocationListener() {
+                            @Override
+                            public void onLocationChanged(Location location) {
+                                float distance = location.distanceTo(placePickerFragment.getLocation());
+                                if (distance >= LOCATION_CHANGE_THRESHOLD) {
+                                    placePickerFragment.setLocation(location);
+                                    placePickerFragment.loadData(true);
+                                }
+                            }
+                            @Override
+                            public void onStatusChanged(String s, int i, Bundle bundle) {
+                            }
+                            @Override
+                            public void onProviderEnabled(String s) {
+                            }
+                            @Override
+                            public void onProviderDisabled(String s) {
+                            }
+                        };
+                        locationManager.requestLocationUpdates(bestProvider, 1, LOCATION_CHANGE_THRESHOLD,
+                                locationListener, Looper.getMainLooper());
+                    }
+                }
+                if (location == null) {
+                    String model = Build.MODEL;
+                    if (model.equals("sdk") || model.equals("google_sdk") || model.contains("x86")) {
+                        // this may be the emulator, pretend we're in an exotic place
+                        location = SAN_FRANCISCO_LOCATION;
+                    }
+                }
+                if (location != null) {
+                    placePickerFragment.setLocation(location);
+                    placePickerFragment.setRadiusInMeters(SEARCH_RADIUS_METERS);
+                    placePickerFragment.setSearchText(SEARCH_TEXT);
+                    placePickerFragment.setResultsLimit(SEARCH_RESULT_LIMIT);
+                    placePickerFragment.loadData(true);
+                } else {
+                    onError(getResources().getString(R.string.no_location_error), true);
+                }
+            } catch (Exception ex) {
+                onError(ex);
+            }
+        }
+    }
+
+    @Override
+    protected void onStop() {
+        super.onStop();
+        if (locationListener != null) {
+            LocationManager locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
+            locationManager.removeUpdates(locationListener);
+            locationListener = null;
+        }
+    }
+
+    private void onError(Exception error) {
+        onError(error.getLocalizedMessage(), false);
+    }
+
+    private void onError(String error, final boolean finishActivity) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setTitle(R.string.error_dialog_title).
+                setMessage(error).
+                setPositiveButton(R.string.error_dialog_button_text, new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialogInterface, int i) {
+                        if (finishActivity) {
+                            finishActivity();
+                        }
+                    }
+                });
+        builder.show();
+    }
+
+    private void finishActivity() {
+        ScrumptiousApplication app = (ScrumptiousApplication) getApplication();
+        if (FRIEND_PICKER.equals(getIntent().getData())) {
+            if (friendPickerFragment != null) {
+                app.setSelectedUsers(friendPickerFragment.getSelection());
+            }
+        } else if (PLACE_PICKER.equals(getIntent().getData())) {
+            if (placePickerFragment != null) {
+                app.setSelectedPlace(placePickerFragment.getSelection());
+            }
+        }
+        setResult(RESULT_OK, null);
+        finish();
+    }
+}
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/ScrumptiousApplication.java b/samples/Scrumptious/src/com/facebook/scrumptious/ScrumptiousApplication.java
new file mode 100644
index 000000000..5b7ae55cb
--- /dev/null
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/ScrumptiousApplication.java
@@ -0,0 +1,32 @@
+package com.facebook.scrumptious;
+
+import android.app.Application;
+import com.facebook.GraphPlace;
+import com.facebook.GraphUser;
+
+import java.util.List;
+
+/**
+ * Use a custom Application class to pass state data between Activities.
+ */
+public class ScrumptiousApplication extends Application {
+
+    private List<GraphUser> selectedUsers;
+    private GraphPlace selectedPlace;
+
+    public List<GraphUser> getSelectedUsers() {
+        return selectedUsers;
+    }
+
+    public void setSelectedUsers(List<GraphUser> users) {
+        selectedUsers = users;
+    }
+
+    public GraphPlace getSelectedPlace() {
+        return selectedPlace;
+    }
+
+    public void setSelectedPlace(GraphPlace place) {
+        this.selectedPlace = place;
+    }
+}
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/SelectionFragment.java b/samples/Scrumptious/src/com/facebook/scrumptious/SelectionFragment.java
new file mode 100644
index 000000000..f1afe0bd0
--- /dev/null
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/SelectionFragment.java
@@ -0,0 +1,583 @@
+package com.facebook.scrumptious;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.ProgressDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.*;
+import com.facebook.*;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Fragment that represents the main selection screen for Scrumptious.
+ */
+public class SelectionFragment extends Fragment {
+
+    private static final String TAG = "SelectionFragment";
+    private static final String POST_ACTION_PATH = "me/fb_sample_scrumps:eat";
+    private static final String PENDING_ANNOUNCE_KEY = "pendingAnnounce";
+
+    private static final int REAUTH_ACTIVITY_CODE = 100;
+    private static final List<String> PERMISSIONS = Arrays.asList("publish_actions");
+
+    private Button announceButton;
+    private ListView listView;
+    private ProgressDialog progressDialog;
+    private List<BaseListElement> listElements;
+    private ProfilePictureView profilePictureView;
+    private TextView userNameView;
+    private boolean pendingAnnounce;
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        super.onCreateView(inflater, container, savedInstanceState);
+        View view = inflater.inflate(R.layout.selection, container, false);
+
+        profilePictureView = (ProfilePictureView) view.findViewById(R.id.selection_profile_pic);
+        profilePictureView.setCropped(true);
+        userNameView = (TextView) view.findViewById(R.id.selection_user_name);
+        announceButton = (Button) view.findViewById(R.id.announce_button);
+        listView = (ListView) view.findViewById(R.id.selection_list);
+
+        announceButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                handleAnnounce();
+            }
+        });
+        init(savedInstanceState);
+
+        final Session session = Session.getActiveSession();
+        if (session != null && session.isOpened()) {
+            Request request = Request.newMeRequest(session, new Request.GraphUserCallback() {
+                @Override
+                public void onCompleted(GraphUser user, Response response) {
+                    if (session == Session.getActiveSession()) {
+                        if (user != null) {
+                            profilePictureView.setUserId(user.getId());
+                            userNameView.setText(user.getName());
+                        }
+                    }
+                }
+            });
+            Request.executeBatchAsync(request);
+        }
+        return view;
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        if (requestCode == REAUTH_ACTIVITY_CODE) {
+            Session.getActiveSession().onActivityResult(getActivity(), requestCode, resultCode, data);
+        } else if (resultCode == Activity.RESULT_OK && requestCode >= 0 && requestCode < listElements.size()) {
+            listElements.get(requestCode).onActivityResult(data);
+        }
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle bundle) {
+        super.onSaveInstanceState(bundle);
+        for (BaseListElement listElement : listElements) {
+            listElement.onSaveInstanceState(bundle);
+        }
+        bundle.putBoolean(PENDING_ANNOUNCE_KEY, pendingAnnounce);
+    }
+
+    /**
+     * Notifies that the session token has been updated.
+     */
+    public void tokenUpdated() {
+        if (pendingAnnounce) {
+            handleAnnounce();
+        }
+    }
+
+    /**
+     * Resets the view to the initial defaults.
+     */
+    private void init(Bundle savedInstanceState) {
+        announceButton.setEnabled(false);
+
+        listElements = new ArrayList<BaseListElement>();
+
+        listElements.add(new EatListElement(0));
+        listElements.add(new LocationListElement(1));
+        listElements.add(new PeopleListElement(2));
+
+        if (savedInstanceState != null) {
+            for (BaseListElement listElement : listElements) {
+                listElement.restoreState(savedInstanceState);
+            }
+            pendingAnnounce = savedInstanceState.getBoolean(PENDING_ANNOUNCE_KEY, false);
+        }
+
+        listView.setAdapter(new ActionListAdapter(getActivity(), R.id.selection_list, listElements));
+    }
+
+    private void handleAnnounce() {
+        pendingAnnounce = false;
+        Session session = Session.getActiveSession();
+
+        if (session == null || !session.isOpened()) {
+            return;
+        }
+
+        List<String> permissions = session.getPermissions();
+        if (!permissions.containsAll(PERMISSIONS)) {
+            pendingAnnounce = true;
+            Session.ReauthorizeRequest reauthRequest = new Session.ReauthorizeRequest(this, PERMISSIONS).
+                    setRequestCode(REAUTH_ACTIVITY_CODE);
+            session.reauthorizeForPublish(reauthRequest);
+            return;
+        }
+
+        // Show a progress dialog because sometimes the requests can take a while.
+        progressDialog = ProgressDialog.show(getActivity(), "",
+                getActivity().getResources().getString(R.string.progress_dialog_text), true);
+
+        // Run this in a background thread since some of the populate methods may take
+        // a non-trivial amount of time.
+        AsyncTask<Void, Void, Response> task = new AsyncTask<Void, Void, Response>() {
+
+            @Override
+            protected Response doInBackground(Void... voids) {
+                EatAction eatAction = GraphObjectWrapper.createGraphObject(EatAction.class);
+                for (BaseListElement element : listElements) {
+                    element.populateOGAction(eatAction);
+                }
+                Request request = new Request(Session.getActiveSession(),
+                        POST_ACTION_PATH, null, HttpMethod.POST);
+                request.setGraphObject(eatAction);
+                return request.executeAndWait();
+            }
+
+            @Override
+            protected void onPostExecute(Response response) {
+                onPostActionResponse(response);
+             }
+        };
+
+        task.execute();
+    }
+
+    private void onPostActionResponse(Response response) {
+        if (progressDialog != null) {
+            progressDialog.dismiss();
+            progressDialog = null;
+        }
+        String id = getIdFromResponseOrShowError(response);
+        if (id != null) {
+            String dialogBody = String.format(getActivity().getResources().getString(R.string.result_dialog_text), id);
+            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
+            builder.setPositiveButton(R.string.result_dialog_button_text, null).
+                    setTitle(R.string.result_dialog_title).setMessage(dialogBody);
+            builder.show();
+        }
+        init(null);
+    }
+
+    private String getIdFromResponseOrShowError(Response response) {
+        PostResponse postResponse = response.getGraphObjectAs(PostResponse.class);
+
+        String id = null;
+        PostResponse.Body body = null;
+        if (postResponse != null) {
+            id = postResponse.getId();
+            body = postResponse.getBody();
+        }
+
+        String dialogBody = "";
+
+        if (body != null && body.getError() != null) {
+            dialogBody = body.getError().getMessage();
+        } else if (response.getError() != null) {
+            dialogBody = response.getError().getLocalizedMessage();
+        } else if (id != null) {
+            return id;
+        }
+
+        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
+        builder.setPositiveButton(R.string.error_dialog_button_text, null).
+                setTitle(R.string.error_dialog_title).setMessage(dialogBody);
+        builder.show();
+        return null;
+    }
+
+    private void startPickerActivity(Uri data, int requestCode) {
+        Intent intent = new Intent();
+        intent.setData(data);
+        intent.setClass(getActivity(), PickerActivity.class);
+        startActivityForResult(intent, requestCode);
+    }
+
+    /**
+     * Interface representing the Meal Open Graph object.
+     */
+    private interface MealGraphObject extends GraphObject {
+        public String getUrl();
+        public void setUrl(String url);
+
+        public String getId();
+        public void setId(String id);
+    }
+
+    /**
+     * Interface representing the Eat action.
+     */
+    private interface EatAction extends OpenGraphAction {
+        public MealGraphObject getMeal();
+        public void setMeal(MealGraphObject meal);
+    }
+
+    /**
+     * Used to inspect the response from posting an action
+     */
+    private interface PostResponse extends GraphObject {
+        Body getBody();
+
+        String getId();
+
+        interface Body extends GraphObject {
+            Error getError();
+        }
+
+        interface Error extends GraphObject {
+            String getMessage();
+        }
+    }
+
+    private class EatListElement extends BaseListElement {
+
+        private static final String FOOD_KEY = "food";
+        private static final String FOOD_URL_KEY = "food_url";
+
+        private final String[] foodChoices;
+        private final String[] foodUrls;
+        private String foodChoiceUrl = null;
+        private String foodChoice = null;
+
+        public EatListElement(int requestCode) {
+            super(getActivity().getResources().getDrawable(R.drawable.action_eating),
+                  getActivity().getResources().getString(R.string.action_eating),
+                  getActivity().getResources().getString(R.string.action_eating_default),
+                  requestCode);
+            foodChoices = getActivity().getResources().getStringArray(R.array.food_types);
+            foodUrls = getActivity().getResources().getStringArray(R.array.food_og_urls);
+        }
+
+        @Override
+        protected View.OnClickListener getOnClickListener() {
+            return new View.OnClickListener() {
+                @Override
+                public void onClick(View view) {
+                    showMealOptions();
+                }
+            };
+        }
+
+        @Override
+        protected void populateOGAction(OpenGraphAction action) {
+            if (foodChoiceUrl != null) {
+                EatAction eatAction = action.cast(EatAction.class);
+                MealGraphObject meal = GraphObjectWrapper.createGraphObject(MealGraphObject.class);
+                meal.setUrl(foodChoiceUrl);
+                eatAction.setMeal(meal);
+            }
+        }
+
+        @Override
+        protected void onSaveInstanceState(Bundle bundle) {
+            if (foodChoice != null && foodChoiceUrl != null) {
+                bundle.putString(FOOD_KEY, foodChoice);
+                bundle.putString(FOOD_URL_KEY, foodChoiceUrl);
+            }
+        }
+
+        @Override
+        protected boolean restoreState(Bundle savedState) {
+            String food = savedState.getString(FOOD_KEY);
+            String foodUrl = savedState.getString(FOOD_URL_KEY);
+            if (food != null && foodUrl != null) {
+                foodChoice = food;
+                foodChoiceUrl = foodUrl;
+                setFoodText();
+                return true;
+            }
+            return false;
+        }
+
+        private void showMealOptions() {
+            String title = getActivity().getResources().getString(R.string.select_meal);
+            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
+            builder.setTitle(title).
+                    setCancelable(true).
+                    setItems(foodChoices, new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialogInterface, int i) {
+                            foodChoice = foodChoices[i];
+                            foodChoiceUrl = foodUrls[i];
+                            setFoodText();
+                            notifyDataChanged();
+                        }
+                    });
+            builder.show();
+        }
+
+        private void setFoodText() {
+            if (foodChoice != null && foodChoiceUrl != null) {
+                setText2(foodChoice);
+                announceButton.setEnabled(true);
+            } else {
+                setText2(getActivity().getResources().getString(R.string.action_eating_default));
+                announceButton.setEnabled(false);
+            }
+        }
+    }
+
+    private class PeopleListElement extends BaseListElement {
+
+        private static final String FRIENDS_KEY = "friends";
+
+        private List<GraphUser> selectedUsers;
+
+        public PeopleListElement(int requestCode) {
+            super(getActivity().getResources().getDrawable(R.drawable.action_people),
+                  getActivity().getResources().getString(R.string.action_people),
+                  getActivity().getResources().getString(R.string.action_people_default),
+                  requestCode);
+        }
+
+        @Override
+        protected View.OnClickListener getOnClickListener() {
+            return new View.OnClickListener() {
+                @Override
+                public void onClick(View view) {
+                    startPickerActivity(PickerActivity.FRIEND_PICKER, getRequestCode());
+                }
+            };
+        }
+
+        @Override
+        protected void onActivityResult(Intent data) {
+            selectedUsers = ((ScrumptiousApplication) getActivity().getApplication()).getSelectedUsers();
+            setUsersText();
+            notifyDataChanged();
+        }
+
+        @Override
+        protected void populateOGAction(OpenGraphAction action) {
+            if (selectedUsers != null) {
+                action.setTags(selectedUsers);
+            }
+        }
+
+        @Override
+        protected void onSaveInstanceState(Bundle bundle) {
+            if (selectedUsers != null) {
+                bundle.putByteArray(FRIENDS_KEY, getByteArray(selectedUsers));
+            }
+        }
+
+        @Override
+        protected boolean restoreState(Bundle savedState) {
+            byte[] bytes = savedState.getByteArray(FRIENDS_KEY);
+            if (bytes != null) {
+                selectedUsers = restoreByteArray(bytes);
+                setUsersText();
+                return true;
+            }
+            return false;
+        }
+
+        private void setUsersText() {
+            String text = null;
+            if (selectedUsers != null) {
+                if (selectedUsers.size() == 1) {
+                    text = String.format(getResources().getString(R.string.single_user_selected),
+                            selectedUsers.get(0).getName());
+                } else if (selectedUsers.size() == 2) {
+                    text = String.format(getResources().getString(R.string.two_users_selected),
+                            selectedUsers.get(0).getName(), selectedUsers.get(1).getName());
+                } else if (selectedUsers.size() > 2) {
+                    text = String.format(getResources().getString(R.string.multiple_users_selected),
+                            selectedUsers.get(0).getName(), (selectedUsers.size() - 1));
+                }
+            }
+            if (text == null) {
+                text = getResources().getString(R.string.action_people_default);
+            }
+            setText2(text);
+        }
+
+        private byte[] getByteArray(List<GraphUser> users) {
+            // convert the list of GraphUsers to a list of String where each element is
+            // the JSON representation of the GraphUser so it can be stored in a Bundle
+            List<String> usersAsString = new ArrayList<String>(users.size());
+
+            for (GraphUser user : users) {
+                usersAsString.add(user.getInnerJSONObject().toString());
+            }
+            try {
+                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+                new ObjectOutputStream(outputStream).writeObject(usersAsString);
+                return outputStream.toByteArray();
+            } catch (IOException e) {
+                Log.e(TAG, "Unable to serialize users.", e);
+            }
+            return null;
+        }
+
+        private List<GraphUser> restoreByteArray(byte[] bytes) {
+            try {
+                @SuppressWarnings("unchecked")
+                List<String> usersAsString =
+                        (List<String>) (new ObjectInputStream(new ByteArrayInputStream(bytes))).readObject();
+                if (usersAsString != null) {
+                    List<GraphUser> users = new ArrayList<GraphUser>(usersAsString.size());
+                    for (String user : usersAsString) {
+                        GraphUser graphUser = GraphObjectWrapper.createGraphObject(new JSONObject(user), GraphUser.class);
+                        users.add(graphUser);
+                    }
+                    return users;
+                }
+            } catch (ClassNotFoundException e) {
+                Log.e(TAG, "Unable to deserialize users.", e);
+            } catch (IOException e) {
+                Log.e(TAG, "Unable to deserialize users.", e);
+            } catch (JSONException e) {
+                Log.e(TAG, "Unable to deserialize users.", e);
+            }
+            return null;
+        }
+    }
+
+    private class LocationListElement extends BaseListElement {
+
+        private static final String PLACE_KEY = "place";
+
+        private GraphPlace selectedPlace = null;
+
+        public LocationListElement(int requestCode) {
+            super(getActivity().getResources().getDrawable(R.drawable.action_location),
+                  getActivity().getResources().getString(R.string.action_location),
+                  getActivity().getResources().getString(R.string.action_location_default),
+                  requestCode);
+        }
+
+        @Override
+        protected View.OnClickListener getOnClickListener() {
+            return new View.OnClickListener() {
+                @Override
+                public void onClick(View view) {
+                    startPickerActivity(PickerActivity.PLACE_PICKER, getRequestCode());
+                }
+            };
+        }
+
+        @Override
+        protected void onActivityResult(Intent data) {
+            selectedPlace = ((ScrumptiousApplication) getActivity().getApplication()).getSelectedPlace();
+            setPlaceText();
+            notifyDataChanged();
+        }
+
+        @Override
+        protected void populateOGAction(OpenGraphAction action) {
+            if (selectedPlace != null) {
+                action.setPlace(selectedPlace);
+            }
+        }
+
+        @Override
+        protected void onSaveInstanceState(Bundle bundle) {
+            if (selectedPlace != null) {
+                bundle.putString(PLACE_KEY, selectedPlace.getInnerJSONObject().toString());
+            }
+        }
+
+        @Override
+        protected boolean restoreState(Bundle savedState) {
+            String place = savedState.getString(PLACE_KEY);
+            if (place != null) {
+                try {
+                    selectedPlace = GraphObjectWrapper.createGraphObject(new JSONObject(place), GraphPlace.class);
+                    setPlaceText();
+                    return true;
+                } catch (JSONException e) {
+                    Log.e(TAG, "Unable to deserialize place.", e);
+                }
+            }
+            return false;
+        }
+
+        private void setPlaceText() {
+            String text = null;
+            if (selectedPlace != null) {
+                text = selectedPlace.getName();
+            }
+            if (text == null) {
+                text = getResources().getString(R.string.action_location_default);
+            }
+            setText2(text);
+        }
+
+    }
+
+    private class ActionListAdapter extends ArrayAdapter<BaseListElement> {
+        private List<BaseListElement> listElements;
+
+        public ActionListAdapter(Context context, int resourceId, List<BaseListElement> listElements) {
+            super(context, resourceId, listElements);
+            this.listElements = listElements;
+            for (int i = 0; i < listElements.size(); i++) {
+                listElements.get(i).setAdapter(this);
+            }
+        }
+
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+            View view = convertView;
+            if (view == null) {
+                LayoutInflater inflater =
+                        (LayoutInflater) getActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                view = inflater.inflate(R.layout.listitem, null);
+            }
+
+            BaseListElement listElement = listElements.get(position);
+            if (listElement != null) {
+                view.setOnClickListener(listElement.getOnClickListener());
+                ImageView icon = (ImageView) view.findViewById(R.id.icon);
+                TextView text1 = (TextView) view.findViewById(R.id.text1);
+                TextView text2 = (TextView) view.findViewById(R.id.text2);
+                if (icon != null) {
+                    icon.setImageDrawable(listElement.getIcon());
+                }
+                if (text1 != null) {
+                    text1.setText(listElement.getText1());
+                }
+                if (text2 != null) {
+                    text2.setText(listElement.getText2());
+                }
+            }
+            return view;
+        }
+
+    }
+}
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/SplashFragment.java b/samples/Scrumptious/src/com/facebook/scrumptious/SplashFragment.java
new file mode 100644
index 000000000..520edc04d
--- /dev/null
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/SplashFragment.java
@@ -0,0 +1,15 @@
+package com.facebook.scrumptious;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+public class SplashFragment extends Fragment {
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        View view = inflater.inflate(R.layout.splash, container, false);
+        return view;
+    }
+}
diff --git a/samples/SessionLoginSample/.classpath b/samples/SessionLoginSample/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/SessionLoginSample/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/SessionLoginSample/.project b/samples/SessionLoginSample/.project
new file mode 100644
index 000000000..d8c641423
--- /dev/null
+++ b/samples/SessionLoginSample/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SessionLoginSample</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/samples/SessionLoginSample/AndroidManifest.xml b/samples/SessionLoginSample/AndroidManifest.xml
new file mode 100644
index 000000000..dbef2c7ec
--- /dev/null
+++ b/samples/SessionLoginSample/AndroidManifest.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.samples.sessionlogin"
+    android:versionCode="1"
+    android:versionName="1.0" >
+
+    <uses-sdk android:minSdkVersion="8" />
+    <uses-permission android:name="android.permission.INTERNET"/>
+
+    <application
+        android:icon="@drawable/icon"
+        android:label="@string/app_name" >
+        <activity
+            android:name="com.facebook.samples.sessionlogin.SessionLoginSampleActivity"
+            android:label="@string/app_name"
+            android:windowSoftInputMode="adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+        <activity android:name="com.facebook.LoginActivity"
+                  android:label="@string/app_name" />
+        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/applicationId" />
+    </application>
+
+</manifest>
\ No newline at end of file
diff --git a/samples/SessionLoginSample/SessionLoginSample.iml b/samples/SessionLoginSample/SessionLoginSample.iml
new file mode 100644
index 000000000..bca109a37
--- /dev/null
+++ b/samples/SessionLoginSample/SessionLoginSample.iml
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/samples/SessionLoginSample/ant.properties b/samples/SessionLoginSample/ant.properties
new file mode 100644
index 000000000..b0971e891
--- /dev/null
+++ b/samples/SessionLoginSample/ant.properties
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff --git a/samples/SessionLoginSample/build.xml b/samples/SessionLoginSample/build.xml
new file mode 100644
index 000000000..4f044bbee
--- /dev/null
+++ b/samples/SessionLoginSample/build.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="SessionLoginSample" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties" />
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties" />
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env" />
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME" />
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties" />
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+    />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true" />
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml" />
+
+</project>
diff --git a/samples/SessionLoginSample/proguard-project.txt b/samples/SessionLoginSample/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/SessionLoginSample/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/samples/SessionLoginSample/project.properties b/samples/SessionLoginSample/project.properties
new file mode 100644
index 000000000..cee0509c6
--- /dev/null
+++ b/samples/SessionLoginSample/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+android.library.reference.1=../../facebook
diff --git a/samples/SessionLoginSample/res/drawable-hdpi/icon.png b/samples/SessionLoginSample/res/drawable-hdpi/icon.png
new file mode 100644
index 000000000..78d41ad5f
Binary files /dev/null and b/samples/SessionLoginSample/res/drawable-hdpi/icon.png differ
diff --git a/samples/SessionLoginSample/res/drawable-mdpi/icon.png b/samples/SessionLoginSample/res/drawable-mdpi/icon.png
new file mode 100644
index 000000000..22598aa33
Binary files /dev/null and b/samples/SessionLoginSample/res/drawable-mdpi/icon.png differ
diff --git a/samples/SessionLoginSample/res/drawable-xhdpi/icon.png b/samples/SessionLoginSample/res/drawable-xhdpi/icon.png
new file mode 100644
index 000000000..a2c3cb4b2
Binary files /dev/null and b/samples/SessionLoginSample/res/drawable-xhdpi/icon.png differ
diff --git a/samples/SessionLoginSample/res/drawable/icon.png b/samples/SessionLoginSample/res/drawable/icon.png
new file mode 100644
index 000000000..22598aa33
Binary files /dev/null and b/samples/SessionLoginSample/res/drawable/icon.png differ
diff --git a/samples/SessionLoginSample/res/layout/main.xml b/samples/SessionLoginSample/res/layout/main.xml
new file mode 100644
index 000000000..799ff43ff
--- /dev/null
+++ b/samples/SessionLoginSample/res/layout/main.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:orientation="vertical" >
+
+    <TextView
+        android:id="@+id/instructionsOrLink"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:text="@string/instructions"
+        android:autoLink="web"
+        android:linksClickable="true"
+        android:textAppearance="?android:attr/textAppearanceMedium" />
+
+    <Button
+        android:id="@+id/buttonLoginLogout"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:text="@string/login" />
+
+</LinearLayout>
\ No newline at end of file
diff --git a/samples/SessionLoginSample/res/values/strings.xml b/samples/SessionLoginSample/res/values/strings.xml
new file mode 100644
index 000000000..ca3279893
--- /dev/null
+++ b/samples/SessionLoginSample/res/values/strings.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="hello">Hello World, SessionLoginSampleActivity!</string>
+    <string name="app_name">SessionLoginSample</string>
+    <string name="login">Login</string>
+    <string name="instructions">Login to create a link to fetch account data</string>
+    <string name="logout">Log out</string>
+    <string name="applicationId">380615018626574</string>
+
+</resources>
\ No newline at end of file
diff --git a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginSampleActivity.java b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginSampleActivity.java
new file mode 100644
index 000000000..7dba1fee4
--- /dev/null
+++ b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginSampleActivity.java
@@ -0,0 +1,111 @@
+package com.facebook.samples.sessionlogin;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.os.Bundle;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.widget.Button;
+import android.widget.TextView;
+import com.facebook.LoggingBehaviors;
+import com.facebook.Session;
+import com.facebook.SessionState;
+import com.facebook.Settings;
+
+public class SessionLoginSampleActivity extends Activity {
+    static final String URL_PREFIX_FRIENDS = "https://graph.facebook.com/me/friends?access_token=";
+    TextView textInstructionsOrLink;
+    Button buttonLoginLogout;
+    Session.StatusCallback statusCallback = new SessionStatusCallback();
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+        buttonLoginLogout = (Button)findViewById(R.id.buttonLoginLogout);
+        textInstructionsOrLink = (TextView)findViewById(R.id.instructionsOrLink);
+
+        Settings.addLoggingBehavior(LoggingBehaviors.INCLUDE_ACCESS_TOKENS);
+
+        Session session = Session.getActiveSession();
+        if (session == null) {
+            if (savedInstanceState != null) {
+                session = Session.restoreSession(this, null, statusCallback, savedInstanceState);
+            }
+            if (session == null) {
+                session = new Session(this);
+            }
+            Session.setActiveSession(session);
+            if (session.getState().equals(SessionState.CREATED_TOKEN_LOADED)) {
+                session.openForRead(new Session.OpenRequest(this).setCallback(statusCallback));
+            }
+        }
+
+        updateView();
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        Session.getActiveSession().addCallback(statusCallback);
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+        Session.getActiveSession().removeCallback(statusCallback);
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        Session.getActiveSession().onActivityResult(this, requestCode, resultCode, data);
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        Session session = Session.getActiveSession();
+        Session.saveSession(session, outState);
+    }
+
+    private void updateView() {
+        Session session = Session.getActiveSession();
+        if (session.isOpened()) {
+            textInstructionsOrLink.setText(URL_PREFIX_FRIENDS + session.getAccessToken());
+            buttonLoginLogout.setText(R.string.logout);
+            buttonLoginLogout.setOnClickListener(new OnClickListener() {
+                public void onClick(View view) { onClickLogout(); }
+            });
+        } else {
+            textInstructionsOrLink.setText(R.string.instructions);
+            buttonLoginLogout.setText(R.string.login);
+            buttonLoginLogout.setOnClickListener(new OnClickListener() {
+                public void onClick(View view) { onClickLogin(); }
+            });
+        }
+    }
+
+    private void onClickLogin() {
+        Session session = Session.getActiveSession();
+        if (!session.isOpened() && !session.isClosed()) {
+            session.openForRead(new Session.OpenRequest(this).setCallback(statusCallback));
+        } else {
+            Session.openActiveSession(this, true, statusCallback);
+        }
+    }
+
+    private void onClickLogout() {
+        Session session = Session.getActiveSession();
+        if (!session.isClosed()) {
+            session.closeAndClearTokenInformation();
+        }
+    }
+
+    private class SessionStatusCallback implements Session.StatusCallback {
+        @Override
+        public void call(Session session, SessionState state, Exception exception) {
+            updateView();
+        }
+    }
+}
diff --git a/samples/SwitchUserSample/.classpath b/samples/SwitchUserSample/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/SwitchUserSample/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/SwitchUserSample/.project b/samples/SwitchUserSample/.project
new file mode 100644
index 000000000..2f6fda8c3
--- /dev/null
+++ b/samples/SwitchUserSample/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SwitchUserSample</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/samples/SwitchUserSample/AndroidManifest.xml b/samples/SwitchUserSample/AndroidManifest.xml
new file mode 100644
index 000000000..cd27a32b4
--- /dev/null
+++ b/samples/SwitchUserSample/AndroidManifest.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.facebook.samples.switchuser"
+          android:versionCode="1"
+          android:versionName="1.0">
+    <uses-sdk android:minSdkVersion="8"/>
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <application android:label="@string/app_name"
+                 android:icon="@drawable/icon" >
+        <activity android:name=".MainActivity"
+                  android:label="@string/app_name"
+                  android:windowSoftInputMode="adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+        <activity android:name="com.facebook.LoginActivity"
+                  android:label="@string/app_name" />
+        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
+    </application>
+</manifest> 
diff --git a/samples/SwitchUserSample/SwitchUserSample.iml b/samples/SwitchUserSample/SwitchUserSample.iml
new file mode 100644
index 000000000..bca109a37
--- /dev/null
+++ b/samples/SwitchUserSample/SwitchUserSample.iml
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/samples/SwitchUserSample/ant.properties b/samples/SwitchUserSample/ant.properties
new file mode 100644
index 000000000..b0971e891
--- /dev/null
+++ b/samples/SwitchUserSample/ant.properties
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff --git a/samples/SwitchUserSample/build.xml b/samples/SwitchUserSample/build.xml
new file mode 100644
index 000000000..ee88101d7
--- /dev/null
+++ b/samples/SwitchUserSample/build.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="SwitchUserSample" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties"/>
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties"/>
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env"/>
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME"/>
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties"/>
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+            />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true"/>
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml"/>
+
+</project>
diff --git a/samples/SwitchUserSample/proguard-project.txt b/samples/SwitchUserSample/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/SwitchUserSample/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/samples/SwitchUserSample/project.properties b/samples/SwitchUserSample/project.properties
new file mode 100644
index 000000000..cee0509c6
--- /dev/null
+++ b/samples/SwitchUserSample/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+android.library.reference.1=../../facebook
diff --git a/samples/SwitchUserSample/res/drawable-hdpi/icon.png b/samples/SwitchUserSample/res/drawable-hdpi/icon.png
new file mode 100644
index 000000000..cda826b7f
Binary files /dev/null and b/samples/SwitchUserSample/res/drawable-hdpi/icon.png differ
diff --git a/samples/SwitchUserSample/res/drawable-mdpi/icon.png b/samples/SwitchUserSample/res/drawable-mdpi/icon.png
new file mode 100644
index 000000000..ffd35f432
Binary files /dev/null and b/samples/SwitchUserSample/res/drawable-mdpi/icon.png differ
diff --git a/samples/SwitchUserSample/res/drawable-xhdpi/icon.png b/samples/SwitchUserSample/res/drawable-xhdpi/icon.png
new file mode 100644
index 000000000..be63ade0b
Binary files /dev/null and b/samples/SwitchUserSample/res/drawable-xhdpi/icon.png differ
diff --git a/samples/SwitchUserSample/res/drawable/icon.png b/samples/SwitchUserSample/res/drawable/icon.png
new file mode 100644
index 000000000..ffd35f432
Binary files /dev/null and b/samples/SwitchUserSample/res/drawable/icon.png differ
diff --git a/samples/SwitchUserSample/res/layout/fragment_profile.xml b/samples/SwitchUserSample/res/layout/fragment_profile.xml
new file mode 100644
index 000000000..60b3047d8
--- /dev/null
+++ b/samples/SwitchUserSample/res/layout/fragment_profile.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              xmlns:app="http://schemas.android.com/apk/res-auto"
+              android:orientation="vertical"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+        >
+    <TextView
+            android:id="@+id/profileUserName"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginBottom="20dp"
+            android:text="@string/greeting_no_user"
+            android:freezesText="true"
+            />
+    <com.facebook.ProfilePictureView
+            android:id="@+id/profilePic"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            app:preset_size="large"
+            />
+</LinearLayout>
+
diff --git a/samples/SwitchUserSample/res/layout/list_item_user.xml b/samples/SwitchUserSample/res/layout/list_item_user.xml
new file mode 100644
index 000000000..c49bb1af4
--- /dev/null
+++ b/samples/SwitchUserSample/res/layout/list_item_user.xml
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:app="http://schemas.android.com/apk/res-auto"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal"
+        >
+
+    <com.facebook.ProfilePictureView
+            android:id="@+id/slotPic"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            android:layout_weight="0"
+            android:layout_margin="10dp"
+            app:preset_size="small"
+            />
+
+    <TextView
+            android:id="@+id/slotUserName"
+            android:layout_height="wrap_content"
+            android:layout_width="0dp"
+            android:layout_weight="1"
+            android:layout_gravity="center_vertical"
+            />
+
+    <CheckBox
+            android:id="@+id/currentUserIndicator"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            android:layout_weight="0"
+            android:layout_gravity="center_vertical"
+            android:focusable="false"
+            android:enabled="false"
+            />
+
+</LinearLayout>
\ No newline at end of file
diff --git a/samples/SwitchUserSample/res/layout/main.xml b/samples/SwitchUserSample/res/layout/main.xml
new file mode 100644
index 000000000..8cab0a90f
--- /dev/null
+++ b/samples/SwitchUserSample/res/layout/main.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+             android:id="@+id/fragmentContainer"
+             android:layout_width="match_parent"
+             android:layout_height="match_parent"
+        />
\ No newline at end of file
diff --git a/samples/SwitchUserSample/res/menu/context_settings.xml b/samples/SwitchUserSample/res/menu/context_settings.xml
new file mode 100644
index 000000000..79237e4a8
--- /dev/null
+++ b/samples/SwitchUserSample/res/menu/context_settings.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:id="@+id/menu_item_clear_slot"
+          android:title="@string/menu_item_clear_slot"
+          />
+</menu>
\ No newline at end of file
diff --git a/samples/SwitchUserSample/res/menu/options_profile.xml b/samples/SwitchUserSample/res/menu/options_profile.xml
new file mode 100644
index 000000000..a0799a1d5
--- /dev/null
+++ b/samples/SwitchUserSample/res/menu/options_profile.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<menu xmlns:android="http://schemas.android.com/apk/res/android">
+    <item
+            android:id="@+id/menu_item_switch"
+            android:title="@string/menu_item_switch_user"
+            />
+</menu>
\ No newline at end of file
diff --git a/samples/SwitchUserSample/res/values/strings.xml b/samples/SwitchUserSample/res/values/strings.xml
new file mode 100644
index 000000000..3c2535e00
--- /dev/null
+++ b/samples/SwitchUserSample/res/values/strings.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">SwitchUserSample</string>
+    <string name="empty_slot">Empty Slot</string>
+    <string name="greeting_format">Hello, %s!</string>
+    <string name="greeting_no_user">Please select a user via the options menu</string>
+    <string name="menu_item_switch_user">Select User</string>
+    <string name="menu_item_clear_slot">Clear this slot</string>
+    <string name="app_id">327842977278179</string>
+</resources>
diff --git a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/MainActivity.java b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/MainActivity.java
new file mode 100644
index 000000000..7a0e305ad
--- /dev/null
+++ b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/MainActivity.java
@@ -0,0 +1,234 @@
+package com.facebook.samples.switchuser;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+import android.support.v4.app.FragmentTransaction;
+import android.view.MenuItem;
+import com.facebook.*;
+
+public class MainActivity extends FragmentActivity {
+
+    private static final String SHOWING_SETTINGS_KEY = "Showing settings";
+    private static final String TOKEN_CACHE_NAME_KEY = "TokenCacheName";
+
+    private ProfileFragment profileFragment;
+    private SettingsFragment settingsFragment;
+    private boolean isShowingSettings;
+    private Slot currentSlot;
+    private Session currentSession;
+    private Session.StatusCallback sessionStatusCallback;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+
+        restoreFragments(savedInstanceState);
+
+        sessionStatusCallback = new Session.StatusCallback() {
+            @Override
+            public void call(Session session, SessionState state, Exception exception) {
+                onSessionStateChange(session, state, exception);
+            }
+        };
+
+        if (savedInstanceState != null) {
+            if (savedInstanceState.getBoolean(SHOWING_SETTINGS_KEY)) {
+                showSettings();
+            } else {
+                showProfile();
+            }
+
+            SharedPreferencesTokenCache restoredCache = new SharedPreferencesTokenCache(
+                    this,
+                    savedInstanceState.getString(TOKEN_CACHE_NAME_KEY));
+            currentSession = Session.restoreSession(
+                    this,
+                    restoredCache,
+                    sessionStatusCallback,
+                    savedInstanceState);
+        } else {
+            showProfile();
+        }
+    }
+
+    @Override
+    public void onBackPressed() {
+        if (isShowingSettings()) {
+            // This back is from the settings fragment
+            showProfile();
+        } else {
+            // Allow the user to back out of the app as well.
+            super.onBackPressed();
+        }
+    }
+
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        outState.putBoolean(SHOWING_SETTINGS_KEY, isShowingSettings());
+        if (currentSlot != null) {
+            outState.putString(TOKEN_CACHE_NAME_KEY, currentSlot.getTokenCacheName());
+        }
+
+        FragmentManager manager = getSupportFragmentManager();
+        manager.putFragment(outState, SettingsFragment.TAG, settingsFragment);
+        manager.putFragment(outState, ProfileFragment.TAG, profileFragment);
+
+        Session.saveSession(currentSession, outState);
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+
+        settingsFragment.setSlotChangedListener(new SettingsFragment.OnSlotChangedListener() {
+            @Override
+            public void OnSlotChanged(Slot newSlot) {
+                handleSlotChange(newSlot);
+            }
+        });
+
+        profileFragment.setOnOptionsItemSelectedListener(new ProfileFragment.OnOptionsItemSelectedListener() {
+            @Override
+            public boolean onOptionsItemSelected(MenuItem item) {
+                return handleOptionsItemSelected(item);
+            }
+        });
+
+        if (currentSession != null) {
+            currentSession.addCallback(sessionStatusCallback);
+        }
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+
+        settingsFragment.setSlotChangedListener(null);
+        profileFragment.setOnOptionsItemSelectedListener(null);
+
+        if (currentSession != null) {
+            currentSession.removeCallback(sessionStatusCallback);
+        }
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        if (currentSession != null) {
+            currentSession.onActivityResult(this, requestCode, resultCode, data);
+        }
+    }
+
+    private void onSessionStateChange(Session session, SessionState state, Exception exception) {
+        if (session != currentSession) {
+            return;
+        }
+
+        if (state.isOpened()) {
+            // Log in just happened.
+            fetchUserInfo();
+            showProfile();
+        } else if (state.isClosed()) {
+            // Log out just happened. Update the UI.
+            updateFragments(null);
+        }
+    }
+
+    private void restoreFragments(Bundle savedInstanceState) {
+        FragmentManager manager = getSupportFragmentManager();
+        FragmentTransaction transaction = manager.beginTransaction();
+
+        if (savedInstanceState != null) {
+            profileFragment = (ProfileFragment)manager.getFragment(savedInstanceState, ProfileFragment.TAG);
+            settingsFragment = (SettingsFragment)manager.getFragment(savedInstanceState, SettingsFragment.TAG);
+        }
+
+        if (profileFragment == null) {
+            profileFragment = new ProfileFragment();
+            transaction.add(R.id.fragmentContainer, profileFragment, ProfileFragment.TAG);
+        }
+
+        if (settingsFragment == null) {
+            settingsFragment = new SettingsFragment();
+            transaction.add(R.id.fragmentContainer, settingsFragment, SettingsFragment.TAG);
+        }
+
+        transaction.commit();
+    }
+
+    private void showSettings() {
+        isShowingSettings = true;
+
+        FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
+        transaction.hide(profileFragment)
+                .show(settingsFragment)
+                .commit();
+    }
+
+    private boolean isShowingSettings() {
+        return isShowingSettings;
+    }
+
+    private void showProfile() {
+        isShowingSettings = false;
+
+        FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
+        transaction.hide(settingsFragment)
+                .show(profileFragment)
+                .commit();
+    }
+
+    private void fetchUserInfo() {
+        if (currentSession != null && currentSession.isOpened()) {
+            Request request = Request.newMeRequest(currentSession, new Request.GraphUserCallback() {
+                @Override
+                public void onCompleted(GraphUser me, Response response) {
+                    if (response.getRequest().getSession() == currentSession) {
+                        updateFragments(me);
+                    }
+                }
+            });
+            Request.executeBatchAsync(request);
+        }
+    }
+
+    private void handleSlotChange(Slot newSlot) {
+        if (currentSession != null) {
+            currentSession.close();
+            currentSession = null;
+        }
+
+        if (newSlot != null) {
+            currentSlot = newSlot;
+            currentSession = new Session.Builder(this)
+                    .setTokenCache(currentSlot.getTokenCache())
+                    .build();
+            currentSession.addCallback(sessionStatusCallback);
+
+            Session.OpenRequest openRequest = new Session.OpenRequest(this);
+            openRequest.setLoginBehavior(newSlot.getLoginBehavior());
+            openRequest.setRequestCode(Session.DEFAULT_AUTHORIZE_ACTIVITY_CODE);
+            currentSession.openForRead(openRequest);
+        }
+    }
+
+    private boolean handleOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+            case R.id.menu_item_switch:
+                showSettings();
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    private void updateFragments(GraphUser user) {
+        settingsFragment.updateViewForUser(user);
+        profileFragment.updateViewForUser(user);
+    }
+}
diff --git a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/ProfileFragment.java b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/ProfileFragment.java
new file mode 100644
index 000000000..27eabe38b
--- /dev/null
+++ b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/ProfileFragment.java
@@ -0,0 +1,87 @@
+package com.facebook.samples.switchuser;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.view.*;
+import android.widget.TextView;
+import com.facebook.GraphUser;
+import com.facebook.ProfilePictureView;
+
+public class ProfileFragment extends Fragment {
+
+    public static final String TAG = "ProfileFragment";
+
+    private TextView userNameView;
+    private ProfilePictureView profilePictureView;
+    private OnOptionsItemSelectedListener onOptionsItemSelectedListener;
+
+    private GraphUser pendingUpdateForUser;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setHasOptionsMenu(true);
+    }
+
+    @Override
+    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
+        super.onCreateOptionsMenu(menu, inflater);
+        inflater.inflate(R.menu.options_profile, menu);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        boolean handled = false;
+        OnOptionsItemSelectedListener listener = onOptionsItemSelectedListener;
+        if (listener != null) {
+            handled = listener.onOptionsItemSelected(item);
+        }
+
+        if (!handled) {
+            handled = super.onOptionsItemSelected(item);
+        }
+
+        return handled;
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {
+        View v = inflater.inflate(R.layout.fragment_profile, parent, false);
+
+        userNameView = (TextView)v.findViewById(R.id.profileUserName);
+        profilePictureView = (ProfilePictureView)v.findViewById(R.id.profilePic);
+
+        if (pendingUpdateForUser != null) {
+            updateViewForUser(pendingUpdateForUser);
+            pendingUpdateForUser = null;
+        }
+
+        return v;
+    }
+
+    public void setOnOptionsItemSelectedListener(OnOptionsItemSelectedListener listener) {
+        this.onOptionsItemSelectedListener = listener;
+    }
+
+    public void updateViewForUser(GraphUser user) {
+        if (userNameView == null || profilePictureView == null || !isAdded()) {
+            // Fragment not yet added to the view. So let's store which user was intended
+            // for display.
+            pendingUpdateForUser = user;
+            return;
+        }
+
+        if (user == null) {
+            profilePictureView.setUserId(null);
+            userNameView.setText(getString(R.string.greeting_no_user));
+        } else {
+            profilePictureView.setUserId(user.getId());
+            userNameView.setText(
+                    String.format(getString(R.string.greeting_format), user.getFirstName()));
+        }
+    }
+
+    public interface OnOptionsItemSelectedListener {
+        boolean onOptionsItemSelected(MenuItem item);
+    }
+}
diff --git a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/SettingsFragment.java b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/SettingsFragment.java
new file mode 100644
index 000000000..b9a7f9e5b
--- /dev/null
+++ b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/SettingsFragment.java
@@ -0,0 +1,267 @@
+package com.facebook.samples.switchuser;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+import android.support.v4.app.ListFragment;
+import android.view.*;
+import android.widget.*;
+import com.facebook.GraphUser;
+import com.facebook.ProfilePictureView;
+import com.facebook.SessionLoginBehavior;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+public class SettingsFragment extends ListFragment {
+
+    public static final String TAG = "SettingsFragment";
+
+    private static final String CURRENT_SLOT_KEY = "CurrentSlot";
+
+    private SlotManager slotManager;
+    private OnSlotChangedListener slotChangedListener;
+    private boolean hasPendingNotifySlotChanged;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        slotManager = new SlotManager();
+        slotManager.restore(
+                getActivity(),
+                savedInstanceState != null ?
+                        savedInstanceState.getInt(CURRENT_SLOT_KEY, SlotManager.NO_SLOT) :
+                        SlotManager.NO_SLOT);
+        ArrayList<Slot> slotList = new ArrayList<Slot>(
+                Arrays.asList(slotManager.getAllSlots()));
+
+        setListAdapter(new SlotAdapter(slotList));
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {
+        View v = super.onCreateView(inflater, parent, savedInstanceState);
+        registerForContextMenu(v.findViewById(android.R.id.list));
+
+        return v;
+    }
+
+    @Override
+    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {
+        super.onCreateContextMenu(menu, v, menuInfo);
+        getActivity().getMenuInflater().inflate(R.menu.context_settings, menu);
+    }
+
+    @Override
+    public void onListItemClick(ListView l, View v, int position, long id) {
+        slotManager.toggleSlot(position);
+    }
+
+    @Override
+    public boolean onContextItemSelected(MenuItem item) {
+        AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo)item.getMenuInfo();
+        SlotAdapter adapter = (SlotAdapter)getListAdapter();
+        Slot slot = adapter.getItem(info.position);
+
+        switch (item.getItemId()) {
+            case R.id.menu_item_clear_slot:
+                if (slot.getUserId() != null) {
+                    // Clear out data that this app stored in the cache
+                    // Not calling Session.closeAndClearTokenInformation() because we have additional
+                    // data stored in the cache.
+                    slot.clear();
+                    if (slot == slotManager.getSelectedSlot()) {
+                        slotManager.toggleSlot(info.position);
+                    }
+
+                    updateListView();
+                }
+                return true;
+        }
+
+        return super.onContextItemSelected(item);
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        outState.putInt(CURRENT_SLOT_KEY, slotManager.getSelectedSlotNumber());
+    }
+
+    public void setSlotChangedListener(OnSlotChangedListener listener) {
+        slotChangedListener = listener;
+        if (listener != null && hasPendingNotifySlotChanged) {
+            notifySlotChanged();
+            hasPendingNotifySlotChanged = false;
+        }
+    }
+
+    public void updateViewForUser(GraphUser user) {
+        if (slotManager == null) {
+            // Fragment has not had onCreate called yet.
+            return;
+        }
+
+        if (user != null) {
+            Slot s = slotManager.getSelectedSlot();
+            if (s != null) {
+                s.update(user);
+            }
+        } else {
+            // If the user is null, then there isn't an actively selected
+            // user. This can happen if the user cancelled a login. So make sure that
+            // SlotManager is updated properly.
+            slotManager.setSelectedSlotNumber(SlotManager.NO_SLOT);
+        }
+
+        updateListView();
+    }
+
+    private void notifySlotChanged() {
+        OnSlotChangedListener listener = slotChangedListener;
+        if (listener != null) {
+            Slot newSlot = slotManager.getSelectedSlot();
+            listener.OnSlotChanged(newSlot);
+        } else {
+            hasPendingNotifySlotChanged = true;
+        }
+    }
+
+    private void updateListView() {
+        SlotAdapter adapter = (SlotAdapter)getListAdapter();
+        adapter.notifyDataSetChanged();
+    }
+
+    public interface OnSlotChangedListener {
+        void OnSlotChanged(Slot newSlot);
+    }
+
+    private class SlotAdapter extends ArrayAdapter<Slot> {
+
+        public SlotAdapter(ArrayList<Slot> slots) {
+            super(getActivity(), android.R.layout.simple_list_item_1, slots);
+        }
+
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+            if (null == convertView) {
+                convertView = getActivity().getLayoutInflater()
+                        .inflate(R.layout.list_item_user, null);
+            }
+
+            Slot slot = getItem(position);
+            String userName = slot.getUserName();
+            if (userName == null) {
+                userName = getString(R.string.empty_slot);
+            }
+
+            ProfilePictureView profilePictureView = (ProfilePictureView)convertView.findViewById(
+                    R.id.slotPic);
+            profilePictureView.setCropped(true);
+            profilePictureView.setUserId(slot.getUserId());
+
+            TextView userNameTextView = (TextView)convertView.findViewById(
+                    R.id.slotUserName);
+            userNameTextView.setText(userName);
+
+            CheckBox currentUserCheckBox = (CheckBox)convertView.findViewById(
+                    R.id.currentUserIndicator);
+            currentUserCheckBox.setChecked(slotManager.getSelectedSlot() == slot);
+
+            return convertView;
+        }
+
+    }
+
+    private class SlotManager {
+        static final int NO_SLOT = -1;
+
+        private final static int MAX_SLOTS = 4;
+
+        private static final String SETTINGS_CURRENT_SLOT_KEY = "CurrentSlot";
+        private static final String SETTINGS_NAME = "UserManagerSettings";
+
+        private SharedPreferences settings;
+        private int selectedSlotNumber = NO_SLOT;
+
+        private Slot[] slots;
+
+        void restore(Context context, int oldSelectedSlot) {
+            if (context == null) {
+                throw new NullPointerException("context cannot be null");
+            }
+
+            Context applicationContext = context.getApplicationContext();
+            applicationContext = (applicationContext == null) ? context : applicationContext;
+
+            slots = new Slot[MAX_SLOTS];
+            for (int i = 0; i < MAX_SLOTS; i++) {
+                SessionLoginBehavior loginBehavior = (i == 0) ?
+                        SessionLoginBehavior.SSO_WITH_FALLBACK :
+                        SessionLoginBehavior.SUPPRESS_SSO;
+                slots[i] = new Slot(applicationContext, i, loginBehavior);
+            }
+
+            // Restore the last known state from when the app ran last.
+            settings = applicationContext.getSharedPreferences(SETTINGS_NAME, Context.MODE_PRIVATE);
+            int savedSlotNumber = settings.getInt(SETTINGS_CURRENT_SLOT_KEY, NO_SLOT);
+            if (savedSlotNumber != NO_SLOT && savedSlotNumber != oldSelectedSlot) {
+                // This will trigger the full flow of creating and opening the right session
+                toggleSlot(savedSlotNumber);
+            } else {
+                // We already knew which slot was selected. So don't notify that a new slot was
+                // selected since that will close out the old session and recreate a new one. And
+                // doing so will have the effect of clearing out state like the profile pic.
+                setSelectedSlotNumber(savedSlotNumber);
+            }
+        }
+
+        void toggleSlot(int slot) {
+            validateSlot(slot);
+
+            if (slot == selectedSlotNumber) {
+                setSelectedSlotNumber(NO_SLOT);
+            } else {
+                setSelectedSlotNumber(slot);
+            }
+
+            notifySlotChanged();
+        }
+
+        Slot getSelectedSlot() {
+            if (selectedSlotNumber == NO_SLOT) {
+                return null;
+            } else {
+                return getSlot(selectedSlotNumber);
+            }
+        }
+
+        int getSelectedSlotNumber() {
+            return selectedSlotNumber;
+        }
+
+        Slot[] getAllSlots() {
+            return slots;
+        }
+
+        Slot getSlot(int slot) {
+            validateSlot(slot);
+
+            return slots[slot];
+        }
+
+        private void setSelectedSlotNumber(int slot) {
+            // Store the selected slot number for when the app is closed and restarted
+            settings.edit().putInt(SETTINGS_CURRENT_SLOT_KEY, slot).commit();
+            selectedSlotNumber = slot;
+        }
+
+        private void validateSlot(int slot) {
+            if (slot <= NO_SLOT || slot >= MAX_SLOTS) {
+                throw new IllegalArgumentException(
+                        String.format("Choose a slot between 0 and %d inclusively", MAX_SLOTS-1));
+            }
+        }
+    }
+}
diff --git a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/Slot.java b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/Slot.java
new file mode 100644
index 000000000..6930ff119
--- /dev/null
+++ b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/Slot.java
@@ -0,0 +1,74 @@
+package com.facebook.samples.switchuser;
+
+import android.content.Context;
+import android.os.Bundle;
+import com.facebook.*;
+
+public class Slot {
+
+    private static final String CACHE_NAME_FORMAT = "TokenCache%d";
+    private static final String CACHE_USER_ID_KEY = "SwitchUserSampleUserId";
+    private static final String CACHE_USER_NAME_KEY = "SwitchUserSampleUserName";
+
+    private String tokenCacheName;
+    private String userName;
+    private String userId;
+    private SharedPreferencesTokenCache tokenCache;
+    private SessionLoginBehavior loginBehavior;
+
+    public Slot(Context context, int slotNumber, SessionLoginBehavior loginBehavior) {
+        this.loginBehavior = loginBehavior;
+        this.tokenCacheName = String.format(CACHE_NAME_FORMAT, slotNumber);
+        this.tokenCache = new SharedPreferencesTokenCache(
+                context,
+                tokenCacheName);
+
+        restore();
+    }
+
+    public String getTokenCacheName() {
+        return tokenCacheName;
+    }
+
+    public String getUserName() {
+        return userName;
+    }
+
+    public String getUserId() {
+        return userId;
+    }
+
+    public SessionLoginBehavior getLoginBehavior() {
+        return loginBehavior;
+    }
+
+    public SharedPreferencesTokenCache getTokenCache() {
+        return tokenCache;
+    }
+
+    public void update(GraphUser user) {
+        if (user == null) {
+            return;
+        }
+
+        userId = user.getId();
+        userName = user.getName();
+
+        Bundle userInfo = tokenCache.load();
+        userInfo.putString(CACHE_USER_ID_KEY, userId);
+        userInfo.putString(CACHE_USER_NAME_KEY, userName);
+
+        tokenCache.save(userInfo);
+    }
+
+    public void clear() {
+        tokenCache.clear();
+        restore();
+    }
+
+    private void restore() {
+        Bundle userInfo = tokenCache.load();
+        userId = userInfo.getString(CACHE_USER_ID_KEY);
+        userName = userInfo.getString(CACHE_USER_NAME_KEY);
+    }
+}
diff --git a/scripts/build_and_test.sh b/scripts/build_and_test.sh
new file mode 100755
index 000000000..a0649b7d5
--- /dev/null
+++ b/scripts/build_and_test.sh
@@ -0,0 +1,51 @@
+#!/bin/sh
+#
+# Copyright 2012 Facebook
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+# 
+#    http://www.apache.org/licenses/LICENSE-2.0
+# 
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+function die() {
+  echo "$@"
+  exit 1
+}
+
+# Find enlistment root
+cd $(dirname $0) >/dev/null
+SDK=$(git rev-parse --show-toplevel) ||
+  die "Could not access git"
+
+# Build all samples
+cd $SDK/samples
+for SAMPLE in *; do
+  if [[ -d $SAMPLE ]]; then
+    cd $SAMPLE
+    ant clean ||
+      die "Error running 'ant clean' on sample $SAMPLE"
+    ant debug ||
+      die "Error running 'ant debug' on sample $SAMPLE"
+    cd ..
+  fi
+done
+
+# Remove any stale test bits, ignore errors here
+adb uninstall com.facebook.sdk.tests 2>/dev/null
+
+# Build and run tests
+cd $SDK/facebook/tests
+ant clean ||
+  die "Error running 'ant clean' on facebook sdk"
+ant debug install ||
+  die "Error running 'ant debug install' on facebook sdk"
+ant run-tests ||
+  die "Error running 'ant run-tests' on facebook sdk"
diff --git a/scripts/configure_unit_tests.sh b/scripts/configure_unit_tests.sh
new file mode 100755
index 000000000..7ed817c09
--- /dev/null
+++ b/scripts/configure_unit_tests.sh
@@ -0,0 +1,48 @@
+#!/bin/sh
+#
+# Copyright 2012 Facebook
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+# 
+#    http://www.apache.org/licenses/LICENSE-2.0
+# 
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+# this script configures your Android simulator for unit tests
+# Note: On Mac OS X, an easy way to generate a MACHINE_UNIQUE_USER_TAG is with the following:
+#   system_profiler SPHardwareDataType | grep -i "Serial Number (system):" | awk '{print $4}'
+
+. ${FB_SDK_SCRIPT:-$(dirname $0)}/common.sh
+
+if [ "$#" -lt 2 ]; then
+    echo "Usage: $0 APP_ID APP_SECRET [MACHINE_UNIQUE_USER_KEY]"
+    echo "  APP_ID                   your unit-testing Facebook application's App ID"
+    echo "  APP_SECRET               your unit-testing Facebook application's App Secret"
+    echo "  MACHINE_UNIQUE_USER_TAG  optional text used to ensure this machine will use its own set of test users rather than sharing"
+    die 'Arguments do not conform to usage'
+fi
+
+function write_config_json {
+    CONFIG_JSON_FILE="$FB_SDK_TESTS"/assets/config.json
+
+    mkdir -p "$FB_SDK_TESTS"/assets
+
+    # use heredoc syntax to output the json
+    cat > "$CONFIG_JSON_FILE" \
+<<DELIMIT
+{"applicationId":"$1","applicationSecret":"$2","machineUniqueUserTag":"$3"}
+DELIMIT
+# end heredoc
+
+    echo "wrote unit test config file at $CONFIG_JSON_FILE" 
+}
+
+write_config_json $1 $2 $3
+
diff --git a/tests/default.properties b/tests/default.properties
deleted file mode 100644
index 6d3f02d2c..000000000
--- a/tests/default.properties
+++ /dev/null
@@ -1,12 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-# 
-# This file must be checked in Version Control Systems.
-# 
-# To customize properties used by the Ant build system use,
-# "build.properties", and override values to adapt the script to your
-# project structure.
-
-android.library.reference.1=../facebook/
-# Project target.
-target=android-3
