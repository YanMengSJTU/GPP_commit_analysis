diff --git a/.gitignore b/.gitignore
index 56fe04416..d67742076 100644
--- a/.gitignore
+++ b/.gitignore
@@ -13,3 +13,5 @@ facebook/lint.xml
 facebook/tests/lint.xml
 facebook/tests/assets/config.json
 .idea/workspace.xml
+.idea/dictionaries/
+.idea/inspectionProfiles/
diff --git a/.idea/compiler.xml b/.idea/compiler.xml
index b5ac196ca..02e121244 100644
--- a/.idea/compiler.xml
+++ b/.idea/compiler.xml
@@ -1,11 +1,10 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="CompilerConfiguration">
-    <option name="DEFAULT_COMPILER" value="Javac" />
+    <option name="DEFAULT_COMPILER" value="Eclipse" />
     <excludeFromCompile>
       <directory url="file://$PROJECT_DIR$/facebook/gen" includeSubdirectories="true" />
-      <directory url="file://$PROJECT_DIR$/samples/JustLoginSample/gen" includeSubdirectories="true" />
-      <directory url="file://$PROJECT_DIR$/samples/JustRequestSample/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/GraphApiSample/gen" includeSubdirectories="true" />
       <directory url="file://$PROJECT_DIR$/examples/Hackbook/gen" includeSubdirectories="true" />
       <directory url="file://$PROJECT_DIR$/facebook/TestApp/gen" includeSubdirectories="true" />
       <directory url="file://$PROJECT_DIR$/facebook/tests/gen" includeSubdirectories="true" />
@@ -18,6 +17,7 @@
       <directory url="file://$PROJECT_DIR$/samples/Scrumptious/gen" includeSubdirectories="true" />
       <directory url="file://$PROJECT_DIR$/samples/SwitchUserSample/gen" includeSubdirectories="true" />
       <directory url="file://$PROJECT_DIR$/samples/HelloFacebookSample/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/Hackbook/gen" includeSubdirectories="true" />
     </excludeFromCompile>
     <resourceExtensions />
     <wildcardResourcePatterns>
diff --git a/.idea/modules.xml b/.idea/modules.xml
index c9eb2bbdd..d6163f7ac 100644
--- a/.idea/modules.xml
+++ b/.idea/modules.xml
@@ -4,9 +4,9 @@
     <modules>
       <module fileurl="file://$PROJECT_DIR$/samples/BooleanOGSample/BooleanOGSample.iml" filepath="$PROJECT_DIR$/samples/BooleanOGSample/BooleanOGSample.iml" />
       <module fileurl="file://$PROJECT_DIR$/samples/FriendPickerSample/FriendPickerSample.iml" filepath="$PROJECT_DIR$/samples/FriendPickerSample/FriendPickerSample.iml" />
-      <module fileurl="file://$PROJECT_DIR$/examples/Hackbook/Hackbook.iml" filepath="$PROJECT_DIR$/examples/Hackbook/Hackbook.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/GraphApiSample/GraphApiSample.iml" filepath="$PROJECT_DIR$/samples/GraphApiSample/GraphApiSample.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/Hackbook/Hackbook.iml" filepath="$PROJECT_DIR$/samples/Hackbook/Hackbook.iml" />
       <module fileurl="file://$PROJECT_DIR$/samples/HelloFacebookSample/HelloFacebookSample.iml" filepath="$PROJECT_DIR$/samples/HelloFacebookSample/HelloFacebookSample.iml" />
-      <module fileurl="file://$PROJECT_DIR$/samples/JustRequestSample/JustRequestSample.iml" filepath="$PROJECT_DIR$/samples/JustRequestSample/JustRequestSample.iml" />
       <module fileurl="file://$PROJECT_DIR$/samples/PlacePickerSample/PlacePickerSample.iml" filepath="$PROJECT_DIR$/samples/PlacePickerSample/PlacePickerSample.iml" />
       <module fileurl="file://$PROJECT_DIR$/samples/ProfilePictureSample/ProfilePictureSample.iml" filepath="$PROJECT_DIR$/samples/ProfilePictureSample/ProfilePictureSample.iml" />
       <module fileurl="file://$PROJECT_DIR$/samples/Scrumptious/Scrumptious.iml" filepath="$PROJECT_DIR$/samples/Scrumptious/Scrumptious.iml" />
diff --git a/.idea/runConfigurations/SdkTests.xml b/.idea/runConfigurations/SdkTests.xml
deleted file mode 100644
index def33dc66..000000000
--- a/.idea/runConfigurations/SdkTests.xml
+++ /dev/null
@@ -1,23 +0,0 @@
-<component name="ProjectRunConfigurationManager">
-  <configuration default="false" name="SdkTests" type="AndroidTestRunConfigurationType" factoryName="Android Tests">
-    <module name="SdkTests" />
-    <option name="TESTING_TYPE" value="0" />
-    <option name="INSTRUMENTATION_RUNNER_CLASS" value="" />
-    <option name="METHOD_NAME" value="" />
-    <option name="CLASS_NAME" value="" />
-    <option name="PACKAGE_NAME" value="" />
-    <option name="TARGET_SELECTION_MODE" value="EMULATOR" />
-    <option name="PREFERRED_AVD" value="and4.0.3x86" />
-    <option name="COMMAND_LINE" value="" />
-    <option name="WIPE_USER_DATA" value="false" />
-    <option name="DISABLE_BOOT_ANIMATION" value="false" />
-    <option name="NETWORK_SPEED" value="full" />
-    <option name="NETWORK_LATENCY" value="none" />
-    <option name="CLEAR_LOGCAT" value="false" />
-    <RunnerSettings RunnerId="AndroidDebugRunner" />
-    <RunnerSettings RunnerId="Run" />
-    <ConfigurationWrapper RunnerId="AndroidDebugRunner" />
-    <ConfigurationWrapper RunnerId="Run" />
-    <method />
-  </configuration>
-</component>
\ No newline at end of file
diff --git a/facebook/TestApp/SdkTestApp.iml b/facebook/TestApp/SdkTestApp.iml
index f75bae6df..1e6d309b6 100644
--- a/facebook/TestApp/SdkTestApp.iml
+++ b/facebook/TestApp/SdkTestApp.iml
@@ -34,6 +34,7 @@
           <path>/res-overlay</path>
         </resOverlayFolders>
         <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
         <additionalNativeLibs />
       </configuration>
     </facet>
diff --git a/facebook/TestApp/res/layout/main.xml b/facebook/TestApp/res/layout/main.xml
index db98bc8c4..da713e268 100644
--- a/facebook/TestApp/res/layout/main.xml
+++ b/facebook/TestApp/res/layout/main.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="match_parent"
diff --git a/facebook/TestApp/res/values/strings.xml b/facebook/TestApp/res/values/strings.xml
index c29c37b9a..b2e26a0c0 100644
--- a/facebook/TestApp/res/values/strings.xml
+++ b/facebook/TestApp/res/values/strings.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <string name="app_name">StatusActivity</string>
 </resources>
diff --git a/facebook/TestApp/src/com/facebook/sdk/StatusActivity.java b/facebook/TestApp/src/com/facebook/sdk/StatusActivity.java
index 6448b64a9..d0930d9ad 100644
--- a/facebook/TestApp/src/com/facebook/sdk/StatusActivity.java
+++ b/facebook/TestApp/src/com/facebook/sdk/StatusActivity.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.sdk;
 
 import android.app.Activity;
diff --git a/facebook/android-sdk.iml b/facebook/android-sdk.iml
index 641785433..52b1b195c 100644
--- a/facebook/android-sdk.iml
+++ b/facebook/android-sdk.iml
@@ -34,6 +34,7 @@
           <path>/res-overlay</path>
         </resOverlayFolders>
         <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
         <additionalNativeLibs />
       </configuration>
     </facet>
diff --git a/facebook/ant.properties b/facebook/ant.properties
index deea2247d..b206ddecc 100644
--- a/facebook/ant.properties
+++ b/facebook/ant.properties
@@ -1 +1,2 @@
-jar.libs.dir=../lib
\ No newline at end of file
+jar.libs.dir=../lib
+java.compilerargs=-Xlint -Werror
\ No newline at end of file
diff --git a/facebook/res/drawable/com_facebook_button_check.xml b/facebook/res/drawable/com_facebook_button_check.xml
index 49079dca4..a201c2634 100644
--- a/facebook/res/drawable/com_facebook_button_check.xml
+++ b/facebook/res/drawable/com_facebook_button_check.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 <selector xmlns:android="http://schemas.android.com/apk/res/android">
   <item android:state_checked="true" android:drawable="@drawable/com_facebook_button_check_on" />
   <item android:drawable="@drawable/com_facebook_button_check_off" />
diff --git a/facebook/res/drawable/com_facebook_loginbutton_blue.xml b/facebook/res/drawable/com_facebook_loginbutton_blue.xml
index 6de365058..8dba4d0ac 100644
--- a/facebook/res/drawable/com_facebook_loginbutton_blue.xml
+++ b/facebook/res/drawable/com_facebook_loginbutton_blue.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 <selector xmlns:android="http://schemas.android.com/apk/res/android" >
     <item android:state_pressed="true" 
           android:drawable="@drawable/com_facebook_loginbutton_blue_pressed" />
diff --git a/facebook/res/drawable/com_facebook_loginbutton_silver.xml b/facebook/res/drawable/com_facebook_loginbutton_silver.xml
index 88e32ebce..4ecb0c8c7 100644
--- a/facebook/res/drawable/com_facebook_loginbutton_silver.xml
+++ b/facebook/res/drawable/com_facebook_loginbutton_silver.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 <selector xmlns:android="http://schemas.android.com/apk/res/android" >
     <item android:state_pressed="true" 
           android:drawable="@drawable/com_facebook_button_grey_pressed" />
diff --git a/facebook/res/drawable/com_facebook_loginfragment_background_gradient.xml b/facebook/res/drawable/com_facebook_loginfragment_background_gradient.xml
deleted file mode 100644
index 11a7a445f..000000000
--- a/facebook/res/drawable/com_facebook_loginfragment_background_gradient.xml
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle">
-    <gradient
-      android:startColor="#5774B5"
-      android:endColor="#2C4988"
-      android:gradientRadius="495"
-      android:type="radial"/>
-</shape>    
diff --git a/facebook/res/drawable/com_facebook_picker_item_background.xml b/facebook/res/drawable/com_facebook_picker_item_background.xml
index 420d3da28..005870250 100644
--- a/facebook/res/drawable/com_facebook_picker_item_background.xml
+++ b/facebook/res/drawable/com_facebook_picker_item_background.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 <selector xmlns:android="http://schemas.android.com/apk/res/android">
 
     <!-- Even though these two point to the same resource, have two states so the drawable will invalidate itself when coming out of pressed state. -->
diff --git a/facebook/res/drawable/com_facebook_picker_list_selector.xml b/facebook/res/drawable/com_facebook_picker_list_selector.xml
index a943a5165..ce9ed5ba8 100644
--- a/facebook/res/drawable/com_facebook_picker_list_selector.xml
+++ b/facebook/res/drawable/com_facebook_picker_list_selector.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 <selector xmlns:android="http://schemas.android.com/apk/res/android">
 
     <item android:state_window_focused="false" android:drawable="@android:color/transparent" />
diff --git a/facebook/res/drawable/com_facebook_picker_top_button.xml b/facebook/res/drawable/com_facebook_picker_top_button.xml
index c1cf56359..4b7a7caa9 100644
--- a/facebook/res/drawable/com_facebook_picker_top_button.xml
+++ b/facebook/res/drawable/com_facebook_picker_top_button.xml
@@ -1,7 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 <shape xmlns:android="http://schemas.android.com/apk/res/android">
     <gradient
             android:startColor="#3f5b96"
             android:endColor="#2d4984"
             android:angle="270"/>
-</shape>
\ No newline at end of file
+</shape>
diff --git a/facebook/res/drawable/com_facebook_profile_picture_blank_portrait.png b/facebook/res/drawable/com_facebook_profile_picture_blank_portrait.png
old mode 100755
new mode 100644
index 1ea13d41a..107d7f89e
Binary files a/facebook/res/drawable/com_facebook_profile_picture_blank_portrait.png and b/facebook/res/drawable/com_facebook_profile_picture_blank_portrait.png differ
diff --git a/facebook/res/drawable/com_facebook_profile_picture_blank_square.png b/facebook/res/drawable/com_facebook_profile_picture_blank_square.png
old mode 100755
new mode 100644
index bf10aebff..8b4a76a0e
Binary files a/facebook/res/drawable/com_facebook_profile_picture_blank_square.png and b/facebook/res/drawable/com_facebook_profile_picture_blank_square.png differ
diff --git a/facebook/res/drawable/com_facebook_top_background.xml b/facebook/res/drawable/com_facebook_top_background.xml
index 9da6daaaf..2f598d5f2 100644
--- a/facebook/res/drawable/com_facebook_top_background.xml
+++ b/facebook/res/drawable/com_facebook_top_background.xml
@@ -1,3 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 <shape xmlns:android="http://schemas.android.com/apk/res/android">
   <gradient
       android:startColor="#FF5975b0"
diff --git a/facebook/res/drawable/com_facebook_top_button.xml b/facebook/res/drawable/com_facebook_top_button.xml
index 5e9474da6..479e8596d 100644
--- a/facebook/res/drawable/com_facebook_top_button.xml
+++ b/facebook/res/drawable/com_facebook_top_button.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 
 <selector xmlns:android="http://schemas.android.com/apk/res/android">
     <item android:state_pressed="true"
diff --git a/facebook/res/drawable/com_facebook_usersettingsfragment_background_gradient.xml b/facebook/res/drawable/com_facebook_usersettingsfragment_background_gradient.xml
new file mode 100644
index 000000000..44c1a3c9a
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_usersettingsfragment_background_gradient.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle">
+    <gradient
+      android:startColor="#5774B5"
+      android:endColor="#2C4988"
+      android:gradientRadius="495"
+      android:type="radial"/>
+</shape>    
diff --git a/facebook/res/layout/com_facebook_friendpickerfragment.xml b/facebook/res/layout/com_facebook_friendpickerfragment.xml
index 97efbf059..76b50c1d5 100644
--- a/facebook/res/layout/com_facebook_friendpickerfragment.xml
+++ b/facebook/res/layout/com_facebook_friendpickerfragment.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 
 <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
               android:layout_width="fill_parent"
diff --git a/facebook/res/layout/com_facebook_login_activity_layout.xml b/facebook/res/layout/com_facebook_login_activity_layout.xml
new file mode 100644
index 000000000..09b28999f
--- /dev/null
+++ b/facebook/res/layout/com_facebook_login_activity_layout.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent">
+
+    <ProgressBar android:indeterminate="true"
+                 android:layout_width="wrap_content"
+                 android:layout_height="50dip"
+                 android:id="@+id/com_facebook_login_activity_progress_bar"
+                 android:layout_centerInParent="true"
+                 android:visibility="gone"
+                 android:indeterminateOnly="true"
+            />
+</RelativeLayout>
diff --git a/facebook/res/layout/com_facebook_picker_activity_circle_row.xml b/facebook/res/layout/com_facebook_picker_activity_circle_row.xml
index eb72bf0a5..29e8bc81b 100644
--- a/facebook/res/layout/com_facebook_picker_activity_circle_row.xml
+++ b/facebook/res/layout/com_facebook_picker_activity_circle_row.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <RelativeLayout
         xmlns:android="http://schemas.android.com/apk/res/android"
         android:layout_height="50dip"
diff --git a/facebook/res/layout/com_facebook_picker_checkbox.xml b/facebook/res/layout/com_facebook_picker_checkbox.xml
index a8fe8f405..8adf7b3d7 100644
--- a/facebook/res/layout/com_facebook_picker_checkbox.xml
+++ b/facebook/res/layout/com_facebook_picker_checkbox.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <CheckBox
     xmlns:android="http://schemas.android.com/apk/res/android"
     android:id="@+id/com_facebook_picker_checkbox"
diff --git a/facebook/res/layout/com_facebook_picker_image.xml b/facebook/res/layout/com_facebook_picker_image.xml
index 34206449c..7793e3b3e 100644
--- a/facebook/res/layout/com_facebook_picker_image.xml
+++ b/facebook/res/layout/com_facebook_picker_image.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <ImageView
     xmlns:android="http://schemas.android.com/apk/res/android"
     android:id="@+id/com_facebook_picker_image"
diff --git a/facebook/res/layout/com_facebook_picker_list_row.xml b/facebook/res/layout/com_facebook_picker_list_row.xml
index 896704292..8f439bfe0 100644
--- a/facebook/res/layout/com_facebook_picker_list_row.xml
+++ b/facebook/res/layout/com_facebook_picker_list_row.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout
         xmlns:android="http://schemas.android.com/apk/res/android"
         android:layout_height="wrap_content"
diff --git a/facebook/res/layout/com_facebook_picker_list_section_header.xml b/facebook/res/layout/com_facebook_picker_list_section_header.xml
index 77530bf01..cfb18beb9 100644
--- a/facebook/res/layout/com_facebook_picker_list_section_header.xml
+++ b/facebook/res/layout/com_facebook_picker_list_section_header.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <TextView
     xmlns:android="http://schemas.android.com/apk/res/android"
     android:id="@+id/com_facebook_picker_list_section_header"
diff --git a/facebook/res/layout/com_facebook_picker_search_box.xml b/facebook/res/layout/com_facebook_picker_search_box.xml
index ce5e8dd90..786668e78 100644
--- a/facebook/res/layout/com_facebook_picker_search_box.xml
+++ b/facebook/res/layout/com_facebook_picker_search_box.xml
@@ -1,6 +1,21 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 
 <EditText xmlns:android="http://schemas.android.com/apk/res/android"
               android:layout_width="wrap_content"
               android:layout_height="fill_parent">
-</EditText>
\ No newline at end of file
+</EditText>
diff --git a/facebook/res/layout/com_facebook_picker_title_bar.xml b/facebook/res/layout/com_facebook_picker_title_bar.xml
index 55ba5e0c4..bcd3141f7 100644
--- a/facebook/res/layout/com_facebook_picker_title_bar.xml
+++ b/facebook/res/layout/com_facebook_picker_title_bar.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 
 <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
                 android:id="@+id/com_facebook_picker_top_bar"
diff --git a/facebook/res/layout/com_facebook_picker_title_bar_stub.xml b/facebook/res/layout/com_facebook_picker_title_bar_stub.xml
index 524f7c6e5..fac0bde28 100644
--- a/facebook/res/layout/com_facebook_picker_title_bar_stub.xml
+++ b/facebook/res/layout/com_facebook_picker_title_bar_stub.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 
 <merge xmlns:android="http://schemas.android.com/apk/res/android">
     <ViewStub android:id="@+id/com_facebook_picker_title_bar_stub"
@@ -7,4 +22,4 @@
               android:layout_height="48dip"
               android:layout_width="fill_parent"/>
 
-</merge>
\ No newline at end of file
+</merge>
diff --git a/facebook/res/layout/com_facebook_placepickerfragment.xml b/facebook/res/layout/com_facebook_placepickerfragment.xml
index 5ce0423fd..8928b85d3 100644
--- a/facebook/res/layout/com_facebook_placepickerfragment.xml
+++ b/facebook/res/layout/com_facebook_placepickerfragment.xml
@@ -1,9 +1,26 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 
 <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
               android:layout_width="fill_parent"
               android:layout_height="fill_parent"
-              android:background="#FFFFFF">
+              android:background="#FFFFFF"
+              android:descendantFocusability="beforeDescendants"
+              android:focusableInTouchMode="true">
 
     <include layout="@layout/com_facebook_picker_title_bar_stub"/>
 
diff --git a/facebook/res/layout/com_facebook_placepickerfragment_list_row.xml b/facebook/res/layout/com_facebook_placepickerfragment_list_row.xml
index e1aac9281..4341923c8 100644
--- a/facebook/res/layout/com_facebook_placepickerfragment_list_row.xml
+++ b/facebook/res/layout/com_facebook_placepickerfragment_list_row.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout
         xmlns:android="http://schemas.android.com/apk/res/android"
         android:layout_height="wrap_content"
diff --git a/facebook/res/layout/com_facebook_loginfragment.xml b/facebook/res/layout/com_facebook_usersettingsfragment.xml
similarity index 56%
rename from facebook/res/layout/com_facebook_loginfragment.xml
rename to facebook/res/layout/com_facebook_usersettingsfragment.xml
index 97702f0b7..c36a74543 100644
--- a/facebook/res/layout/com_facebook_loginfragment.xml
+++ b/facebook/res/layout/com_facebook_usersettingsfragment.xml
@@ -1,17 +1,33 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <ScrollView
     xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:loginView="http://schemas.android.com/apk/res-auto"
     android:layout_width="fill_parent"
     android:layout_height="fill_parent"
-    android:background="@drawable/com_facebook_loginfragment_background_gradient" >
+    android:background="@drawable/com_facebook_usersettingsfragment_background_gradient" >
     <LinearLayout
         android:layout_width="fill_parent"
         android:layout_height="fill_parent"
         android:orientation="vertical">
 
         <ImageView
-            android:id="@+id/com_facebook_loginfragment_logo_image"
+            android:id="@+id/com_facebook_usersettingsfragment_logo_image"
             android:layout_width="193dp"
             android:layout_height="44dp"
             android:layout_gravity="center_horizontal"
@@ -20,7 +36,7 @@
             android:contentDescription="@string/com_facebook_logo_content_description"/>
 
         <TextView
-            android:id="@+id/com_facebook_loginfragment_profile_name"
+            android:id="@+id/com_facebook_usersettingsfragment_profile_name"
             android:layout_width="fill_parent"
             android:layout_height="100dp"
             android:lines="1"
@@ -29,15 +45,15 @@
             android:layout_marginTop="35dp"
             android:gravity="center"/>
     
-        <com.facebook.LoginButton
-            android:id="@+id/com_facebook_loginfragment_login_button"
+        <com.facebook.widget.LoginButton
+            android:id="@+id/com_facebook_usersettingsfragment_login_button"
             android:layout_width="wrap_content"
             android:layout_height="wrap_content"
             android:layout_gravity="center_horizontal"
             android:layout_marginTop="35dp"
             android:layout_marginBottom="35dp"
-            loginView:login_text="@string/com_facebook_loginfragment_log_in_button"
+            loginView:login_text="@string/com_facebook_usersettingsfragment_log_in_button"
             style="@style/com_facebook_loginview_silver_style" />
     
     </LinearLayout>
-</ScrollView>
\ No newline at end of file
+</ScrollView>
diff --git a/facebook/res/values-es/strings.xml b/facebook/res/values-es/strings.xml
index fbcef142c..23b2b9fc5 100644
--- a/facebook/res/values-es/strings.xml
+++ b/facebook/res/values-es/strings.xml
@@ -1,5 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
+    <string name="com_facebook_dialogloginactivity_ok_button">Aceptar</string>
     <string name="com_facebook_loginview_log_out_button">Cerrar Sesión</string>
     <string name="com_facebook_loginview_log_in_button">Iniciar Sesión</string>
     <string name="com_facebook_loginview_logged_in_as">Sesión iniciada como: %1$s</string>
@@ -7,10 +24,21 @@
     <string name="com_facebook_loginview_log_out_action">Cerrar sesión</string>
     <string name="com_facebook_loginview_cancel_action">Cancelar</string>
     <string name="com_facebook_logo_content_description">Logo de Facebook</string>
-    <string name="com_facebook_loginfragment_log_in_button">Iniciar Sesión&#8230;</string>
-    <string name="com_facebook_loginfragment_logged_in">Sesión iniciada</string>
-    <string name="com_facebook_loginfragment_not_logged_in">No has iniciado sesión</string>
+    <string name="com_facebook_usersettingsfragment_log_in_button">Iniciar Sesión&#8230;</string>
+    <string name="com_facebook_usersettingsfragment_logged_in">Sesión iniciada</string>
+    <string name="com_facebook_usersettingsfragment_not_logged_in">No has iniciado sesión</string>
     <string name="com_facebook_placepicker_subtitle_format">%1$s • %2$,d estuvieron aquí</string>
     <string name="com_facebook_placepicker_subtitle_catetory_only_format">%1$s</string>
     <string name="com_facebook_placepicker_subtitle_were_here_only_format">es:%1$,d estuvieron aquí</string>
+    <string name="com_facebook_picker_done_button_text">Aceptar</string>
+    <string name="com_facebook_choose_friends">Elige Amigos</string>
+    <string name="com_facebook_nearby">Cercano</string>
+    <string name="com_facebook_loading">Cargando</string>
+    <string name="com_facebook_internet_permission_error_title">Error de AndroidManifest</string>
+    <string name="com_facebook_internet_permission_error_message">WebView inicio de sesión requiere permiso INTERNET</string>
+    <string name="com_facebook_requesterror_web_login">Por favor, iniciar sesión a través https://www.facebook.com o https://m.facebook.com para volver a activar la aplicación para conectar con Facebook.</string>
+    <string name="com_facebook_requesterror_relogin">La aplicación no se conecta con Facebook, inicie sesión y volver a conectar esta aplicación.</string>
+    <string name="com_facebook_requesterror_password_changed">Su contraseña de Facebook ha cambiado, por favor vuelva a conectar la aplicación con Facebook.</string>
+    <string name="com_facebook_requesterror_reconnect">Se produjo un error al conectar con Facebook, por favor vuelva a conectar la aplicación con Facebook.</string>
+    <string name="com_facebook_requesterror_permissions">Una conexión de aplicación con Facebook falló debido a permisos insuficientes, por favor, conceda los permisos de aplicaciones para realizar la operación.</string>
 </resources>
diff --git a/facebook/res/values-he/strings.xml b/facebook/res/values-he/strings.xml
index b6135754e..8b1c7ae44 100644
--- a/facebook/res/values-he/strings.xml
+++ b/facebook/res/values-he/strings.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <string name="com_facebook_loginview_log_out_button">התנתק</string>
     <string name="com_facebook_loginview_log_in_button">התחבר</string>
@@ -6,11 +22,23 @@
     <string name="com_facebook_loginview_logged_in_using_facebook">מחובר באמצעות פייסבוק</string>
     <string name="com_facebook_loginview_log_out_action">התנתק</string>
     <string name="com_facebook_loginview_cancel_action">בטל</string>
-    <string name="com_facebook_logo_content_description">Facebook Logo</string>
-    <string name="com_facebook_loginfragment_log_in_button">התחבר&#8230;</string>
-    <string name="com_facebook_loginfragment_logged_in">מחובר</string>
-    <string name="com_facebook_loginfragment_not_logged_in">לא מחובר</string>
+    <string name="com_facebook_logo_content_description">פייסבוק לוגו</string>
+    <string name="com_facebook_usersettingsfragment_log_in_button">התחבר&#8230;</string>
+    <string name="com_facebook_usersettingsfragment_logged_in">מחובר</string>
+    <string name="com_facebook_usersettingsfragment_not_logged_in">לא מחובר</string>
     <string name="com_facebook_placepicker_subtitle_format">%1$s • %2$,d היו פה</string>
     <string name="com_facebook_placepicker_subtitle_catetory_only_format">%1$s</string>
     <string name="com_facebook_placepicker_subtitle_were_here_only_format">%1$,d היו פה</string>
-</resources>
+    <string name="com_facebook_picker_done_button_text">בצע</string>
+    <string name="com_facebook_choose_friends">בחר חברים</string>
+    <string name="com_facebook_nearby">קרוב אליי</string>
+    <string name="com_facebook_loading">..מעלה</string>
+    <string name="com_facebook_internet_permission_error_title">AndroidManifest שגיאת</string>
+    <string name="com_facebook_internet_permission_error_message">ההתחברות לתצוגת אתר דורשת אישור אינטרנט</string>
+    <string name="com_facebook_requesterror_web_login">.כדי לאפשר מחדש לאפליקציה להתחבר עם פייסבוק https://www.facebook.com או https://m.facebook.com אנא היכנס דרך</string>
+    <string name="com_facebook_requesterror_relogin">.האפליקציה אינה מחוברת לפייסבוק, אנא היכנס וחבר מחדש את האפליקציה</string>
+    <string name="com_facebook_requesterror_password_changed">.הסיסמה שלך בפייסבוק השתנתה, אנא חבר מחדש את האפליקציה עם פייסבוק</string>
+    <string name="com_facebook_requesterror_reconnect">.ארעה שגיאה בעת החיבור עם פייסבוק, חבר בבקשה מחדש את האפליקציה עם פייסבוק</string>
+    <string name="com_facebook_requesterror_permissions">.חיבור האפליקציה עם פייסבוק נכשל בשל הרשאות לא מספקות, אנא הענק הרשאות לאפליקציה בכדי שהפעולה תוכל להתבצע</string>
+    <string name="com_facebook_dialogloginactivity_ok_button">אישור</string>
+</resources>
\ No newline at end of file
diff --git a/facebook/res/values-iw/strings.xml b/facebook/res/values-iw/strings.xml
index b6135754e..8b1c7ae44 100644
--- a/facebook/res/values-iw/strings.xml
+++ b/facebook/res/values-iw/strings.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <string name="com_facebook_loginview_log_out_button">התנתק</string>
     <string name="com_facebook_loginview_log_in_button">התחבר</string>
@@ -6,11 +22,23 @@
     <string name="com_facebook_loginview_logged_in_using_facebook">מחובר באמצעות פייסבוק</string>
     <string name="com_facebook_loginview_log_out_action">התנתק</string>
     <string name="com_facebook_loginview_cancel_action">בטל</string>
-    <string name="com_facebook_logo_content_description">Facebook Logo</string>
-    <string name="com_facebook_loginfragment_log_in_button">התחבר&#8230;</string>
-    <string name="com_facebook_loginfragment_logged_in">מחובר</string>
-    <string name="com_facebook_loginfragment_not_logged_in">לא מחובר</string>
+    <string name="com_facebook_logo_content_description">פייסבוק לוגו</string>
+    <string name="com_facebook_usersettingsfragment_log_in_button">התחבר&#8230;</string>
+    <string name="com_facebook_usersettingsfragment_logged_in">מחובר</string>
+    <string name="com_facebook_usersettingsfragment_not_logged_in">לא מחובר</string>
     <string name="com_facebook_placepicker_subtitle_format">%1$s • %2$,d היו פה</string>
     <string name="com_facebook_placepicker_subtitle_catetory_only_format">%1$s</string>
     <string name="com_facebook_placepicker_subtitle_were_here_only_format">%1$,d היו פה</string>
-</resources>
+    <string name="com_facebook_picker_done_button_text">בצע</string>
+    <string name="com_facebook_choose_friends">בחר חברים</string>
+    <string name="com_facebook_nearby">קרוב אליי</string>
+    <string name="com_facebook_loading">..מעלה</string>
+    <string name="com_facebook_internet_permission_error_title">AndroidManifest שגיאת</string>
+    <string name="com_facebook_internet_permission_error_message">ההתחברות לתצוגת אתר דורשת אישור אינטרנט</string>
+    <string name="com_facebook_requesterror_web_login">.כדי לאפשר מחדש לאפליקציה להתחבר עם פייסבוק https://www.facebook.com או https://m.facebook.com אנא היכנס דרך</string>
+    <string name="com_facebook_requesterror_relogin">.האפליקציה אינה מחוברת לפייסבוק, אנא היכנס וחבר מחדש את האפליקציה</string>
+    <string name="com_facebook_requesterror_password_changed">.הסיסמה שלך בפייסבוק השתנתה, אנא חבר מחדש את האפליקציה עם פייסבוק</string>
+    <string name="com_facebook_requesterror_reconnect">.ארעה שגיאה בעת החיבור עם פייסבוק, חבר בבקשה מחדש את האפליקציה עם פייסבוק</string>
+    <string name="com_facebook_requesterror_permissions">.חיבור האפליקציה עם פייסבוק נכשל בשל הרשאות לא מספקות, אנא הענק הרשאות לאפליקציה בכדי שהפעולה תוכל להתבצע</string>
+    <string name="com_facebook_dialogloginactivity_ok_button">אישור</string>
+</resources>
\ No newline at end of file
diff --git a/facebook/res/values/attrs.xml b/facebook/res/values/attrs.xml
index 8b497b70b..6f9f6d11e 100644
--- a/facebook/res/values/attrs.xml
+++ b/facebook/res/values/attrs.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <declare-styleable name="com_facebook_picker_fragment">
         <attr name="show_pictures" format="boolean"/>
@@ -31,5 +47,6 @@
             <enum name="normal" value="-3" />
             <enum name="large" value="-4" />
         </attr>
+        <attr name="is_cropped" format="boolean" />
     </declare-styleable>
 </resources>
diff --git a/facebook/res/values/strings.xml b/facebook/res/values/strings.xml
index bfce323e5..ffef00c0f 100644
--- a/facebook/res/values/strings.xml
+++ b/facebook/res/values/strings.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <string name="com_facebook_dialogloginactivity_ok_button">OK</string>
     <string name="com_facebook_loginview_log_out_button">Log Out</string>
@@ -8,13 +24,21 @@
     <string name="com_facebook_loginview_log_out_action">Log Out</string>
     <string name="com_facebook_loginview_cancel_action">Cancel</string>
     <string name="com_facebook_logo_content_description">Facebook Logo</string>
-    <string name="com_facebook_loginfragment_log_in_button">Log In&#8230;</string>
-    <string name="com_facebook_loginfragment_logged_in">Logged In</string>
-    <string name="com_facebook_loginfragment_not_logged_in">Not Logged In</string>
+    <string name="com_facebook_usersettingsfragment_log_in_button">Log In&#8230;</string>
+    <string name="com_facebook_usersettingsfragment_logged_in">Logged In</string>
+    <string name="com_facebook_usersettingsfragment_not_logged_in">Not Logged In</string>
     <string name="com_facebook_placepicker_subtitle_format">%1$s • %2$,d were here</string>
     <string name="com_facebook_placepicker_subtitle_catetory_only_format">%1$s</string>
     <string name="com_facebook_placepicker_subtitle_were_here_only_format">%1$,d were here</string>
     <string name="com_facebook_picker_done_button_text">Done</string>
     <string name="com_facebook_choose_friends">Choose Friends</string>
     <string name="com_facebook_nearby">Nearby</string>
+    <string name="com_facebook_loading">Loading...</string>
+    <string name="com_facebook_internet_permission_error_title">AndroidManifest Error</string>
+    <string name="com_facebook_internet_permission_error_message">WebView login requires INTERNET permission</string>
+    <string name="com_facebook_requesterror_web_login">Please log in via https://www.facebook.com or https://m.facebook.com to re-enable the app to connect with Facebook.</string>
+    <string name="com_facebook_requesterror_relogin">The app is not connected with Facebook, please log in and reconnect this app.</string>
+    <string name="com_facebook_requesterror_password_changed">Your password on Facebook has changed, please reconnect the app with Facebook.</string>
+    <string name="com_facebook_requesterror_reconnect">An error occurred when connecting with Facebook, please reconnect the app with Facebook.</string>
+    <string name="com_facebook_requesterror_permissions">An app connection with Facebook failed due to insufficient permissions, please grant the app permissions to perform the operation.</string>
 </resources>
diff --git a/facebook/res/values/styles.xml b/facebook/res/values/styles.xml
index 04e22cbc1..ee5e1e11d 100644
--- a/facebook/res/values/styles.xml
+++ b/facebook/res/values/styles.xml
@@ -1,12 +1,28 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources xmlns:android="http://schemas.android.com/apk/res/android">
     <color name="com_facebook_blue">#3B5998</color>
     
-    <color name="com_facebook_loginfragment_connected_text_color">#FFFFFF</color>
-    <color name="com_facebook_loginfragment_connected_shadow_color">#000000</color>
-    <color name="com_facebook_loginfragment_not_connected_text_color">#A6AED7</color>
-    <dimen name="com_facebook_loginfragment_profile_picture_width">64dp</dimen>
-    <dimen name="com_facebook_loginfragment_profile_picture_height">64dp</dimen>
+    <color name="com_facebook_usersettingsfragment_connected_text_color">#FFFFFF</color>
+    <color name="com_facebook_usersettingsfragment_connected_shadow_color">#000000</color>
+    <color name="com_facebook_usersettingsfragment_not_connected_text_color">#A6AED7</color>
+    <dimen name="com_facebook_usersettingsfragment_profile_picture_width">64dp</dimen>
+    <dimen name="com_facebook_usersettingsfragment_profile_picture_height">64dp</dimen>
     
     <dimen name="com_facebook_loginview_padding_left">42dp</dimen>
     <dimen name="com_facebook_loginview_padding_right">0dp</dimen>
diff --git a/facebook/src/com/facebook/AccessToken.java b/facebook/src/com/facebook/AccessToken.java
index b24241cf9..28cbeb481 100644
--- a/facebook/src/com/facebook/AccessToken.java
+++ b/facebook/src/com/facebook/AccessToken.java
@@ -19,6 +19,9 @@
 import android.annotation.SuppressLint;
 import android.content.Intent;
 import android.os.Bundle;
+import android.text.TextUtils;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
 
 import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
@@ -28,86 +31,211 @@
 import java.util.Date;
 import java.util.List;
 
-final class AccessToken implements Serializable {
+/**
+ * This class represents an access token returned by the Facebook Login service, along with associated
+ * metadata such as its expiration date and permissions. In general, the {@link Session} class will
+ * abstract away the need to worry about the details of an access token, but there are situations
+ * (such as handling native links, importing previously-obtained access tokens, etc.) where it is
+ * useful to deal with access tokens directly. Factory methods are provided to construct access tokens.
+ * <p/>
+ * For more information on access tokens, see
+ * https://developers.facebook.com/docs/concepts/login/access-tokens-and-types/.
+ */
+public final class AccessToken implements Serializable {
     private static final long serialVersionUID = 1L;
     static final String ACCESS_TOKEN_KEY = "access_token";
     static final String EXPIRES_IN_KEY = "expires_in";
     private static final Date MIN_DATE = new Date(Long.MIN_VALUE);
     private static final Date MAX_DATE = new Date(Long.MAX_VALUE);
+    private static final Date DEFAULT_EXPIRATION_TIME = MAX_DATE;
+    private static final Date DEFAULT_LAST_REFRESH_TIME = new Date();
+    private static final AccessTokenSource DEFAULT_ACCESS_TOKEN_SOURCE = AccessTokenSource.FACEBOOK_APPLICATION_WEB;
+    private static final Date ALREADY_EXPIRED_EXPIRATION_TIME = MIN_DATE;
 
     private final Date expires;
     private final List<String> permissions;
     private final String token;
-    private final boolean isSSO;
+    private final AccessTokenSource source;
     private final Date lastRefresh;
 
-    AccessToken(String token, Date expires, List<String> permissions, boolean isSSO, Date lastRefresh) {
+    AccessToken(String token, Date expires, List<String> permissions, AccessTokenSource source, Date lastRefresh) {
+        if (permissions == null) {
+            permissions = Collections.emptyList();
+        }
+
         this.expires = expires;
-        this.permissions = permissions;
+        this.permissions = Collections.unmodifiableList(permissions);
         this.token = token;
-        this.isSSO = isSSO;
+        this.source = source;
         this.lastRefresh = lastRefresh;
     }
 
-    String getToken() {
+    /**
+     * Gets the string representing the access token.
+     *
+     * @return the string representing the access token
+     */
+    public String getToken() {
         return this.token;
     }
 
-    Date getExpires() {
+    /**
+     * Gets the date at which the access token expires.
+     *
+     * @return the expiration date of the token
+     */
+    public Date getExpires() {
         return this.expires;
     }
 
-    List<String> getPermissions() {
+    /**
+     * Gets the list of permissions associated with this access token. Note that the most up-to-date
+     * list of permissions is maintained by the Facebook service, so this list may be outdated if
+     * permissions have been added or removed since the time the AccessToken object was created. For
+     * more information on permissions, see https://developers.facebook.com/docs/reference/login/#permissions.
+     *
+     * @return a read-only list of strings representing the permissions granted via this access token
+     */
+    public List<String> getPermissions() {
         return this.permissions;
     }
 
-    boolean getIsSSO() {
-        return this.isSSO;
+    /**
+     * Gets the {@link AccessTokenSource} indicating how this access token was obtained.
+     *
+     * @return the enum indicating how the access token was obtained
+     */
+    public AccessTokenSource getSource() {
+        return source;
     }
 
-    Date getLastRefresh() {
+    /**
+     * Gets the date at which the token was last refreshed. Since tokens expire, the Facebook SDK
+     * will attempt to renew them periodically.
+     *
+     * @return the date at which this token was last refreshed
+     */
+    public Date getLastRefresh() {
         return this.lastRefresh;
     }
 
+    /**
+     * Creates a new AccessToken using the supplied information from a previously-obtained access
+     * token (for instance, from an already-cached access token obtained prior to integration with the
+     * Facebook SDK).
+     *
+     * @param accessToken       the access token string obtained from Facebook
+     * @param expirationTime    the expiration date associated with the token; if null, an infinite expiration time is
+     *                          assumed (but will become correct when the token is refreshed)
+     * @param lastRefreshTime   the last time the token was refreshed (or when it was first obtained); if null,
+     *                          the current time is used.
+     * @param accessTokenSource an enum indicating how the token was originally obtained (in most cases,
+     *                          this will be either AccessTokenSource.FACEBOOK_APPLICATION or
+     *                          AccessTokenSource.WEB_VIEW); if null, FACEBOOK_APPLICATION is assumed.
+     * @param permissions       the permissions that were requested when the token was obtained (or when
+     *                          it was last reauthorized); may be null if permission set is unknown
+     * @return a new AccessToken
+     */
+    public static AccessToken createFromExistingAccessToken(String accessToken, Date expirationTime,
+            Date lastRefreshTime, AccessTokenSource accessTokenSource, List<String> permissions) {
+        if (expirationTime == null) {
+            expirationTime = DEFAULT_EXPIRATION_TIME;
+        }
+        if (lastRefreshTime == null) {
+            lastRefreshTime = DEFAULT_LAST_REFRESH_TIME;
+        }
+        if (accessTokenSource == null) {
+            accessTokenSource = DEFAULT_ACCESS_TOKEN_SOURCE;
+        }
+
+        return new AccessToken(accessToken, expirationTime, permissions, accessTokenSource, lastRefreshTime);
+    }
+
+    /**
+     * Creates a new AccessToken using the information contained in an Intent populated by the Facebook
+     * application in order to launch a native link. For more information on native linking, please see
+     * https://developers.facebook.com/docs/mobile/android/deep_linking/.
+     *
+     * @param intent the Intent that was used to start an Activity; must not be null
+     * @return a new AccessToken, or null if the Intent did not contain enough data to create one
+     */
+    public static AccessToken createFromNativeLinkingIntent(Intent intent) {
+        Validate.notNull(intent, "intent");
+
+        if (intent.getExtras() == null) {
+            return null;
+        }
+
+        return createFromBundle(null, intent.getExtras(), AccessTokenSource.FACEBOOK_APPLICATION_WEB, new Date());
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+
+        builder.append("{AccessToken");
+        builder.append(" token:").append(tokenToString());
+        appendPermissions(builder);
+        builder.append("}");
+
+        return builder.toString();
+    }
+
     static AccessToken createEmptyToken(List<String> permissions) {
-        return new AccessToken("", MIN_DATE, permissions, false, MIN_DATE);
+        return new AccessToken("", ALREADY_EXPIRED_EXPIRATION_TIME, permissions, AccessTokenSource.NONE,
+                DEFAULT_LAST_REFRESH_TIME);
     }
 
-    static AccessToken createFromString(String token, List<String> permissions) {
-        return new AccessToken(token, MAX_DATE, permissions, false, new Date());
+    static AccessToken createFromString(String token, List<String> permissions, AccessTokenSource source) {
+        return new AccessToken(token, DEFAULT_EXPIRATION_TIME, permissions, source, DEFAULT_LAST_REFRESH_TIME);
     }
 
-    static AccessToken createFromDialog(List<String> requestedPermissions, Bundle bundle) {
-        return createNew(requestedPermissions, bundle, false, new Date());
+    static AccessToken createFromNativeLogin(Bundle bundle, AccessTokenSource source) {
+        Date expires = getBundleLongAsDate(
+                bundle, NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, new Date(0));
+        ArrayList<String> permissions = bundle.getStringArrayList(NativeProtocol.EXTRA_PERMISSIONS);
+        String token = bundle.getString(NativeProtocol.EXTRA_ACCESS_TOKEN);
+
+        return createNew(permissions, token, expires, source);
     }
 
-    static AccessToken createFromSSO(List<String> requestedPermissions, Intent data) {
-        return createNew(requestedPermissions, data.getExtras(), true, new Date());
+    static AccessToken createFromWebBundle(List<String> requestedPermissions, Bundle bundle, AccessTokenSource source) {
+        Date expires = getBundleLongAsDate(bundle, EXPIRES_IN_KEY, new Date());
+        String token = bundle.getString(ACCESS_TOKEN_KEY);
+
+        return createNew(requestedPermissions, token, expires, source);
     }
 
     @SuppressLint("FieldGetter")
-    static AccessToken createForRefresh(AccessToken current, Bundle bundle) {
-        // isSSO is set true since only SSO tokens support refresh. Token refresh returns the expiration date in
+    static AccessToken createFromRefresh(AccessToken current, Bundle bundle) {
+        // Only tokens obtained via SSO support refresh. Token refresh returns the expiration date in
         // seconds from the epoch rather than seconds from now.
+        assert (current.source == AccessTokenSource.FACEBOOK_APPLICATION_WEB ||
+                current.source == AccessTokenSource.FACEBOOK_APPLICATION_NATIVE ||
+                current.source == AccessTokenSource.FACEBOOK_APPLICATION_SERVICE);
 
-        return createNew(current.getPermissions(), bundle, true, new Date(0));
+        Date expires = getBundleLongAsDate(bundle, EXPIRES_IN_KEY, new Date(0));
+        String token = bundle.getString(ACCESS_TOKEN_KEY);
+
+        return createNew(current.getPermissions(), token, expires, current.source);
     }
 
-    private static AccessToken createNew(List<String> requestedPermissions, Bundle bundle, boolean isSSO,
-            Date expirationBase) {
-        String token = bundle.getString(ACCESS_TOKEN_KEY);
-        Date expires = getExpiresInDate(bundle, expirationBase);
+    static AccessToken createFromTokenWithRefreshedPermissions(AccessToken token, List<String> permissions) {
+        return new AccessToken(token.token, token.expires, permissions, token.source, token.lastRefresh);
+    }
 
-        if (Utility.isNullOrEmpty(token) || (expires == null)) {
-            return null;
+    private static AccessToken createNew(
+            List<String> requestedPermissions, String accessToken, Date expires, AccessTokenSource source) {
+        if (Utility.isNullOrEmpty(accessToken) || (expires == null)) {
+            return createEmptyToken(requestedPermissions);
+        } else {
+            return new AccessToken(accessToken, expires, requestedPermissions, source, new Date());
         }
-
-        return new AccessToken(token, expires, requestedPermissions, isSSO, new Date());
     }
 
     static AccessToken createFromCache(Bundle bundle) {
         // Copy the list so we can guarantee immutable
-        List<String> originalPermissions = bundle.getStringArrayList(TokenCache.PERMISSIONS_KEY);
+        List<String> originalPermissions = bundle.getStringArrayList(TokenCachingStrategy.PERMISSIONS_KEY);
         List<String> permissions;
         if (originalPermissions == null) {
             permissions = Collections.emptyList();
@@ -115,19 +243,19 @@ static AccessToken createFromCache(Bundle bundle) {
             permissions = Collections.unmodifiableList(new ArrayList<String>(originalPermissions));
         }
 
-        return new AccessToken(bundle.getString(TokenCache.TOKEN_KEY), TokenCache.getDate(bundle,
-                TokenCache.EXPIRATION_DATE_KEY), permissions, bundle.getBoolean(TokenCache.IS_SSO_KEY),
-                TokenCache.getDate(bundle, TokenCache.LAST_REFRESH_DATE_KEY));
+        return new AccessToken(bundle.getString(TokenCachingStrategy.TOKEN_KEY), TokenCachingStrategy.getDate(bundle,
+                TokenCachingStrategy.EXPIRATION_DATE_KEY), permissions, TokenCachingStrategy.getSource(bundle),
+                TokenCachingStrategy.getDate(bundle, TokenCachingStrategy.LAST_REFRESH_DATE_KEY));
     }
 
     Bundle toCacheBundle() {
         Bundle bundle = new Bundle();
 
-        bundle.putString(TokenCache.TOKEN_KEY, this.token);
-        TokenCache.putDate(bundle, TokenCache.EXPIRATION_DATE_KEY, expires);
-        bundle.putStringArrayList(TokenCache.PERMISSIONS_KEY, new ArrayList<String>(permissions));
-        bundle.putBoolean(TokenCache.IS_SSO_KEY, isSSO);
-        TokenCache.putDate(bundle, TokenCache.LAST_REFRESH_DATE_KEY, lastRefresh);
+        bundle.putString(TokenCachingStrategy.TOKEN_KEY, this.token);
+        TokenCachingStrategy.putDate(bundle, TokenCachingStrategy.EXPIRATION_DATE_KEY, expires);
+        bundle.putStringArrayList(TokenCachingStrategy.PERMISSIONS_KEY, new ArrayList<String>(permissions));
+        bundle.putSerializable(TokenCachingStrategy.TOKEN_SOURCE_KEY, source);
+        TokenCachingStrategy.putDate(bundle, TokenCachingStrategy.LAST_REFRESH_DATE_KEY, lastRefresh);
 
         return bundle;
     }
@@ -136,22 +264,23 @@ boolean isInvalid() {
         return Utility.isNullOrEmpty(this.token) || new Date().after(this.expires);
     }
 
-    @Override
-    public String toString() {
-        StringBuilder builder = new StringBuilder();
+    private static AccessToken createFromBundle(List<String> requestedPermissions, Bundle bundle,
+            AccessTokenSource source,
+            Date expirationBase) {
+        String token = bundle.getString(ACCESS_TOKEN_KEY);
+        Date expires = getBundleLongAsDate(bundle, EXPIRES_IN_KEY, expirationBase);
 
-        builder.append("{AccessToken");
-        builder.append(" token:").append(tokenToString());
-        appendPermissions(builder);
-        builder.append("}");
+        if (Utility.isNullOrEmpty(token) || (expires == null)) {
+            return null;
+        }
 
-        return builder.toString();
+        return new AccessToken(token, expires, requestedPermissions, source, new Date());
     }
 
     private String tokenToString() {
         if (this.token == null) {
             return "null";
-        } else if (Settings.isLoggingBehaviorEnabled(LoggingBehaviors.INCLUDE_ACCESS_TOKENS)) {
+        } else if (Settings.isLoggingBehaviorEnabled(LoggingBehavior.INCLUDE_ACCESS_TOKENS)) {
             return this.token;
         } else {
             return "ACCESS_TOKEN_REMOVED";
@@ -164,12 +293,8 @@ private void appendPermissions(StringBuilder builder) {
             builder.append("null");
         } else {
             builder.append("[");
-            for (int i = 0; i < this.permissions.size(); i++) {
-                if (i > 0) {
-                    builder.append(", ");
-                }
-                builder.append(this.permissions.get(i));
-            }
+            builder.append(TextUtils.join(", ", permissions));
+            builder.append("]");
         }
     }
 
@@ -178,25 +303,25 @@ private void appendPermissions(StringBuilder builder) {
         private final Date expires;
         private final List<String> permissions;
         private final String token;
-        private final boolean isSSO;
+        private final AccessTokenSource source;
         private final Date lastRefresh;
 
         private SerializationProxyV1(String token, Date expires,
-                List<String> permissions, boolean isSSO, Date lastRefresh) {
+                List<String> permissions, AccessTokenSource source, Date lastRefresh) {
             this.expires = expires;
             this.permissions = permissions;
             this.token = token;
-            this.isSSO = isSSO;
+            this.source = source;
             this.lastRefresh = lastRefresh;
         }
 
         private Object readResolve() {
-            return new AccessToken(token, expires, permissions, isSSO, lastRefresh);
+            return new AccessToken(token, expires, permissions, source, lastRefresh);
         }
     }
 
     private Object writeReplace() {
-        return new SerializationProxyV1(token, expires, permissions, isSSO, lastRefresh);
+        return new SerializationProxyV1(token, expires, permissions, source, lastRefresh);
     }
 
     // have a readObject that throws to prevent spoofing
@@ -205,19 +330,19 @@ private void readObject(ObjectInputStream stream) throws InvalidObjectException
     }
 
 
-    private static Date getExpiresInDate(Bundle bundle, Date expirationBase) {
+    private static Date getBundleLongAsDate(Bundle bundle, String key, Date dateBase) {
         if (bundle == null) {
             return null;
         }
 
         long secondsFromBase = Long.MIN_VALUE;
 
-        Object secondsObject = bundle.get(EXPIRES_IN_KEY);
+        Object secondsObject = bundle.get(key);
         if (secondsObject instanceof Long) {
-            secondsFromBase = (Long)secondsObject;
+            secondsFromBase = (Long) secondsObject;
         } else if (secondsObject instanceof String) {
             try {
-                secondsFromBase = Long.parseLong((String)secondsObject);
+                secondsFromBase = Long.parseLong((String) secondsObject);
             } catch (NumberFormatException e) {
                 return null;
             }
@@ -228,7 +353,7 @@ private static Date getExpiresInDate(Bundle bundle, Date expirationBase) {
         if (secondsFromBase == 0) {
             return new Date(Long.MAX_VALUE);
         } else {
-            return new Date(expirationBase.getTime() + (secondsFromBase * 1000L));
+            return new Date(dateBase.getTime() + (secondsFromBase * 1000L));
         }
     }
 }
diff --git a/facebook/src/com/facebook/AccessTokenSource.java b/facebook/src/com/facebook/AccessTokenSource.java
new file mode 100644
index 000000000..8d231f1b1
--- /dev/null
+++ b/facebook/src/com/facebook/AccessTokenSource.java
@@ -0,0 +1,63 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Indicates where a Facebook access token was obtained from.
+ */
+public enum AccessTokenSource {
+    /**
+     * Indicates an access token has not been obtained, or is otherwise invalid.
+     */
+    NONE(false),
+    /**
+     * Indicates an access token was obtained by the user logging in through the
+     * Facebook app for Android using the web login dialog.
+     */
+    FACEBOOK_APPLICATION_WEB(true),
+    /**
+     * Indicates an access token was obtained by the user logging in through the
+     * Facebook app for Android using the native login dialog.
+     */
+    FACEBOOK_APPLICATION_NATIVE(true),
+    /**
+     * Indicates an access token was obtained by asking the Facebook app for the
+     * current token based on permissions the user has already granted to the app.
+     * No dialog was shown to the user in this case.
+     */
+    FACEBOOK_APPLICATION_SERVICE(true),
+    /**
+     * Indicates an access token was obtained by the user logging in through the
+     * Web-based dialog.
+     */
+    WEB_VIEW(false),
+    /**
+     * Indicates an access token is for a test user rather than an actual
+     * Facebook user.
+     */
+    TEST_USER(true);
+
+    private final boolean canExtendToken;
+
+    AccessTokenSource(boolean canExtendToken) {
+        this.canExtendToken = canExtendToken;
+    }
+
+    boolean canExtendToken() {
+        return canExtendToken;
+    }
+}
diff --git a/facebook/src/com/facebook/AuthorizationClient.java b/facebook/src/com/facebook/AuthorizationClient.java
new file mode 100644
index 000000000..f1f4348f9
--- /dev/null
+++ b/facebook/src/com/facebook/AuthorizationClient.java
@@ -0,0 +1,806 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.Manifest;
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+import android.text.TextUtils;
+import android.webkit.CookieSyncManager;
+import com.facebook.android.R;
+import com.facebook.internal.ServerProtocol;
+import com.facebook.internal.Utility;
+import com.facebook.model.GraphMultiResult;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphObjectList;
+import com.facebook.model.GraphUser;
+import com.facebook.widget.WebDialog;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+
+class AuthorizationClient implements Serializable {
+    private static final long serialVersionUID = 1L;
+
+    List<AuthHandler> handlersToTry;
+    AuthHandler currentHandler;
+    transient Context context;
+    transient StartActivityDelegate startActivityDelegate;
+    transient OnCompletedListener onCompletedListener;
+    transient BackgroundProcessingListener backgroundProcessingListener;
+    transient boolean checkedInternetPermission;
+    AuthorizationRequest pendingRequest;
+
+    interface OnCompletedListener {
+        void onCompleted(Result result);
+    }
+
+    interface BackgroundProcessingListener {
+        void onBackgroundProcessingStarted();
+
+        void onBackgroundProcessingStopped();
+    }
+
+    interface StartActivityDelegate {
+        public void startActivityForResult(Intent intent, int requestCode);
+
+        public Activity getActivityContext();
+    }
+
+    void setContext(final Context context) {
+        this.context = context;
+        // We rely on individual requests to tell us how to start an activity.
+        startActivityDelegate = null;
+    }
+
+    void setContext(final Activity activity) {
+        this.context = activity;
+
+        // If we are used in the context of an activity, we will always use that activity to
+        // call startActivityForResult.
+        startActivityDelegate = new StartActivityDelegate() {
+            @Override
+            public void startActivityForResult(Intent intent, int requestCode) {
+                activity.startActivityForResult(intent, requestCode);
+            }
+
+            @Override
+            public Activity getActivityContext() {
+                return activity;
+            }
+        };
+    }
+
+    void startOrContinueAuth(AuthorizationRequest request) {
+        if (getInProgress()) {
+            continueAuth();
+        } else {
+            authorize(request);
+        }
+    }
+
+    void authorize(AuthorizationRequest request) {
+        if (request == null) {
+            return;
+        }
+
+        if (pendingRequest != null) {
+            throw new FacebookException("Attempted to authorize while a request is pending.");
+        }
+
+        if (request.needsNewTokenValidation() && !checkInternetPermission()) {
+            // We're going to need INTERNET permission later and don't have it, so fail early.
+            return;
+        }
+        pendingRequest = request;
+        handlersToTry = getHandlerTypes(request);
+        tryNextHandler();
+    }
+
+    void continueAuth() {
+        if (pendingRequest == null || currentHandler == null) {
+            throw new FacebookException("Attempted to continue authorization without a pending request.");
+        }
+
+        if (currentHandler.needsRestart()) {
+            currentHandler.cancel();
+            tryCurrentHandler();
+        }
+    }
+
+    boolean getInProgress() {
+        return pendingRequest != null && currentHandler != null;
+    }
+
+    void cancelCurrentHandler() {
+        if (currentHandler != null) {
+            currentHandler.cancel();
+        }
+    }
+
+    boolean onActivityResult(int requestCode, int resultCode, Intent data) {
+        if (requestCode == pendingRequest.getRequestCode()) {
+            return currentHandler.onActivityResult(requestCode, resultCode, data);
+        }
+        return false;
+    }
+
+    private List<AuthHandler> getHandlerTypes(AuthorizationRequest request) {
+        ArrayList<AuthHandler> handlers = new ArrayList<AuthHandler>();
+
+        final SessionLoginBehavior behavior = request.getLoginBehavior();
+        if (behavior.allowsKatanaAuth()) {
+            if (!request.isLegacy()) {
+                handlers.add(new GetTokenAuthHandler());
+                handlers.add(new KatanaLoginDialogAuthHandler());
+            }
+            handlers.add(new KatanaProxyAuthHandler());
+        }
+
+        if (behavior.allowsWebViewAuth()) {
+            handlers.add(new WebViewAuthHandler());
+        }
+
+        return handlers;
+    }
+
+    boolean checkInternetPermission() {
+        if (checkedInternetPermission) {
+            return true;
+        }
+
+        int permissionCheck = checkPermission(Manifest.permission.INTERNET);
+        if (permissionCheck != PackageManager.PERMISSION_GRANTED) {
+            String errorType = context.getString(R.string.com_facebook_internet_permission_error_title);
+            String errorDescription = context.getString(R.string.com_facebook_internet_permission_error_message);
+            complete(Result.createErrorResult(errorType, errorDescription));
+
+            return false;
+        }
+
+        checkedInternetPermission = true;
+        return true;
+    }
+
+    void tryNextHandler() {
+        while (handlersToTry != null && !handlersToTry.isEmpty()) {
+            currentHandler = handlersToTry.remove(0);
+
+            boolean started = tryCurrentHandler();
+
+            if (started) {
+                return;
+            }
+        }
+
+        if (pendingRequest != null) {
+            // We went through all handlers without successfully attempting an auth.
+            completeWithFailure();
+        }
+    }
+
+    private void completeWithFailure() {
+        complete(Result.createErrorResult("Login attempt failed.", null));
+    }
+
+    boolean tryCurrentHandler() {
+        if (currentHandler.needsInternetPermission() && !checkInternetPermission()) {
+            return false;
+        }
+        return currentHandler.tryAuthorize(pendingRequest);
+    }
+
+    void completeAndValidate(Result outcome) {
+        // Do we need to validate a successful result (as in the case of a reauth)?
+        if (outcome.token != null && pendingRequest.needsNewTokenValidation()) {
+            validateSameFbidAndFinish(outcome);
+        } else {
+            // We're done, just notify the listener.
+            complete(outcome);
+        }
+    }
+
+    void complete(Result outcome) {
+        handlersToTry = null;
+        currentHandler = null;
+        pendingRequest = null;
+
+        notifyOnCompleteListener(outcome);
+    }
+
+    OnCompletedListener getOnCompletedListener() {
+        return onCompletedListener;
+    }
+
+    void setOnCompletedListener(OnCompletedListener onCompletedListener) {
+        this.onCompletedListener = onCompletedListener;
+    }
+
+    BackgroundProcessingListener getBackgroundProcessingListener() {
+        return backgroundProcessingListener;
+    }
+
+    void setBackgroundProcessingListener(BackgroundProcessingListener backgroundProcessingListener) {
+        this.backgroundProcessingListener = backgroundProcessingListener;
+    }
+
+    StartActivityDelegate getStartActivityDelegate() {
+        if (startActivityDelegate != null) {
+            return startActivityDelegate;
+        } else if (pendingRequest != null) {
+            // Wrap the request's delegate in our own.
+            return new StartActivityDelegate() {
+                @Override
+                public void startActivityForResult(Intent intent, int requestCode) {
+                    pendingRequest.getStartActivityDelegate().startActivityForResult(intent, requestCode);
+                }
+
+                @Override
+                public Activity getActivityContext() {
+                    return pendingRequest.getStartActivityDelegate().getActivityContext();
+                }
+            };
+        }
+        return null;
+    }
+
+    int checkPermission(String permission) {
+        return context.checkCallingOrSelfPermission(permission);
+    }
+
+    void validateSameFbidAndFinish(Result pendingResult) {
+        if (pendingResult.token == null) {
+            throw new FacebookException("Can't validate without a token");
+        }
+
+        RequestBatch batch = createReauthValidationBatch(pendingResult);
+
+        notifyBackgroundProcessingStart();
+
+        batch.executeAsync();
+    }
+
+    RequestBatch createReauthValidationBatch(final Result pendingResult) {
+        // We need to ensure that the token we got represents the same fbid as the old one. We issue
+        // a "me" request using the current token, a "me" request using the new token, and a "me/permissions"
+        // request using the current token to get the permissions of the user.
+
+        final ArrayList<String> fbids = new ArrayList<String>();
+        final ArrayList<String> tokenPermissions = new ArrayList<String>();
+        final String newToken = pendingResult.token.getToken();
+
+        Request.Callback meCallback = new Request.Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                try {
+                    GraphUser user = response.getGraphObjectAs(GraphUser.class);
+                    if (user != null) {
+                        fbids.add(user.getId());
+                    }
+                } catch (Exception ex) {
+                }
+            }
+        };
+
+        String validateSameFbidAsToken = pendingRequest.getPreviousAccessToken();
+        Request requestCurrentTokenMe = createGetProfileIdRequest(validateSameFbidAsToken);
+        requestCurrentTokenMe.setCallback(meCallback);
+
+        Request requestNewTokenMe = createGetProfileIdRequest(newToken);
+        requestNewTokenMe.setCallback(meCallback);
+
+        Request requestCurrentTokenPermissions = createGetPermissionsRequest(validateSameFbidAsToken);
+        requestCurrentTokenPermissions.setCallback(new Request.Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                try {
+                    GraphMultiResult result = response.getGraphObjectAs(GraphMultiResult.class);
+                    if (result != null) {
+                        GraphObjectList<GraphObject> data = result.getData();
+                        if (data != null && data.size() == 1) {
+                            GraphObject permissions = data.get(0);
+
+                            // The keys are the permission names.
+                            tokenPermissions.addAll(permissions.asMap().keySet());
+                        }
+                    }
+                } catch (Exception ex) {
+                }
+            }
+        });
+
+        RequestBatch batch = new RequestBatch(requestCurrentTokenMe, requestNewTokenMe,
+                requestCurrentTokenPermissions);
+        batch.setBatchApplicationId(pendingRequest.getApplicationId());
+        batch.addCallback(new RequestBatch.Callback() {
+            @Override
+            public void onBatchCompleted(RequestBatch batch) {
+                try {
+                    Result result = null;
+                    if (fbids.size() == 2 && fbids.get(0) != null && fbids.get(1) != null &&
+                            fbids.get(0).equals(fbids.get(1))) {
+                        // Modify the token to have the right permission set.
+                        AccessToken tokenWithPermissions = AccessToken
+                                .createFromTokenWithRefreshedPermissions(pendingResult.token,
+                                        tokenPermissions);
+                        result = Result.createTokenResult(tokenWithPermissions);
+                    } else {
+                        result = Result
+                                .createErrorResult("User logged in as different Facebook user.", null);
+                    }
+                    complete(result);
+                } catch (Exception ex) {
+                    complete(Result.createErrorResult("Caught exception", ex.getMessage()));
+                } finally {
+                    notifyBackgroundProcessingStop();
+                }
+            }
+        });
+
+        return batch;
+    }
+
+    Request createGetPermissionsRequest(String accessToken) {
+        Bundle parameters = new Bundle();
+        parameters.putString("fields", "id");
+        parameters.putString("access_token", accessToken);
+        return new Request(null, "me/permissions", parameters, HttpMethod.GET, null);
+    }
+
+    Request createGetProfileIdRequest(String accessToken) {
+        Bundle parameters = new Bundle();
+        parameters.putString("fields", "id");
+        parameters.putString("access_token", accessToken);
+        return new Request(null, "me", parameters, HttpMethod.GET, null);
+    }
+
+    private void notifyOnCompleteListener(Result outcome) {
+        if (onCompletedListener != null) {
+            onCompletedListener.onCompleted(outcome);
+        }
+    }
+
+    private void notifyBackgroundProcessingStart() {
+        if (backgroundProcessingListener != null) {
+            backgroundProcessingListener.onBackgroundProcessingStarted();
+        }
+    }
+
+    private void notifyBackgroundProcessingStop() {
+        if (backgroundProcessingListener != null) {
+            backgroundProcessingListener.onBackgroundProcessingStopped();
+        }
+    }
+
+    abstract class AuthHandler implements Serializable {
+        private static final long serialVersionUID = 1L;
+
+        abstract boolean tryAuthorize(AuthorizationRequest request);
+
+        boolean onActivityResult(int requestCode, int resultCode, Intent data) {
+            return false;
+        }
+
+        boolean needsRestart() {
+            return false;
+        }
+
+        boolean needsInternetPermission() {
+            return false;
+        }
+
+        void cancel() {
+        }
+    }
+
+    class WebViewAuthHandler extends AuthHandler {
+        private static final long serialVersionUID = 1L;
+        private transient WebDialog loginDialog;
+
+        @Override
+        boolean needsRestart() {
+            // Because we are presenting WebView UI within the current context, we need to explicitly
+            // restart the process if the context goes away and is recreated.
+            return true;
+        }
+
+        @Override
+        boolean needsInternetPermission() {
+            return true;
+        }
+
+        @Override
+        void cancel() {
+            if (loginDialog != null) {
+                loginDialog.dismiss();
+                loginDialog = null;
+            }
+        }
+
+        @Override
+        boolean tryAuthorize(final AuthorizationRequest request) {
+            String applicationId = request.getApplicationId();
+            Bundle parameters = new Bundle();
+            if (!Utility.isNullOrEmpty(request.getPermissions())) {
+                parameters.putString(ServerProtocol.DIALOG_PARAM_SCOPE, TextUtils.join(",", request.getPermissions()));
+            }
+
+            // The call to clear cookies will create the first instance of CookieSyncManager if necessary
+            Utility.clearFacebookCookies(context);
+
+            WebDialog.OnCompleteListener listener = new WebDialog.OnCompleteListener() {
+                @Override
+                public void onComplete(Bundle values, FacebookException error) {
+                    onWebDialogComplete(request, values, error);
+                }
+            };
+
+            WebDialog.Builder builder =
+                    new AuthDialogBuilder(getStartActivityDelegate().getActivityContext(), applicationId, parameters)
+                            .setOnCompleteListener(listener);
+            loginDialog = builder.build();
+            loginDialog.show();
+
+            return true;
+        }
+
+        void onWebDialogComplete(AuthorizationRequest request, Bundle values,
+                FacebookException error) {
+            Result outcome;
+            if (values != null) {
+                // Ensure any cookies set by the dialog are saved
+                // This is to work around a bug where CookieManager may fail to instantiate if CookieSyncManager
+                // has never been created.
+                CookieSyncManager syncManager = CookieSyncManager.createInstance(context);
+                syncManager.sync();
+
+                AccessToken token = AccessToken
+                        .createFromWebBundle(request.getPermissions(), values, AccessTokenSource.WEB_VIEW);
+                outcome = Result.createTokenResult(token);
+
+            } else {
+                if (error instanceof FacebookOperationCanceledException) {
+                    outcome = Result.createCancelResult("User canceled log in.");
+                } else {
+                    outcome = Result.createErrorResult(error.getMessage(), null);
+                }
+            }
+            completeAndValidate(outcome);
+        }
+    }
+
+    class GetTokenAuthHandler extends AuthHandler {
+        private static final long serialVersionUID = 1L;
+        private transient GetTokenClient getTokenClient;
+
+        @Override
+        void cancel() {
+            if (getTokenClient != null) {
+                getTokenClient.cancel();
+                getTokenClient = null;
+            }
+        }
+
+        boolean tryAuthorize(final AuthorizationRequest request) {
+            getTokenClient = new GetTokenClient(context, request.getApplicationId());
+            if (!getTokenClient.start()) {
+                return false;
+            }
+
+            notifyBackgroundProcessingStart();
+
+            GetTokenClient.CompletedListener callback = new GetTokenClient.CompletedListener() {
+                @Override
+                public void completed(Bundle result) {
+                    getTokenCompleted(request, result);
+                }
+            };
+
+            getTokenClient.setCompletedListener(callback);
+            return true;
+        }
+
+        void getTokenCompleted(AuthorizationRequest request, Bundle result) {
+            getTokenClient = null;
+
+            notifyBackgroundProcessingStop();
+
+            if (result != null) {
+                ArrayList<String> currentPermissions = result.getStringArrayList(NativeProtocol.EXTRA_PERMISSIONS);
+                List<String> permissions = request.getPermissions();
+                if ((currentPermissions != null) &&
+                        ((permissions == null) || currentPermissions.containsAll(permissions))) {
+                    // We got all the permissions we needed, so we can complete the auth now.
+                    AccessToken token = AccessToken
+                            .createFromNativeLogin(result, AccessTokenSource.FACEBOOK_APPLICATION_SERVICE);
+                    Result outcome = Result.createTokenResult(token);
+                    completeAndValidate(outcome);
+                    return;
+                }
+
+                // We didn't get all the permissions we wanted, so update the request with just the permissions
+                // we still need.
+                ArrayList<String> newPermissions = new ArrayList<String>();
+                for (String permission : permissions) {
+                    if (!currentPermissions.contains(permission)) {
+                        newPermissions.add(permission);
+                    }
+                }
+                request.setPermissions(newPermissions);
+            }
+
+            tryNextHandler();
+        }
+    }
+
+    abstract class KatanaAuthHandler extends AuthHandler {
+        private static final long serialVersionUID = 1L;
+
+        protected boolean tryIntent(Intent intent, int requestCode) {
+            if (intent == null) {
+                return false;
+            }
+
+            try {
+                getStartActivityDelegate().startActivityForResult(intent, requestCode);
+            } catch (ActivityNotFoundException e) {
+                return false;
+            }
+
+            return true;
+        }
+    }
+
+    class KatanaLoginDialogAuthHandler extends KatanaAuthHandler {
+        private static final long serialVersionUID = 1L;
+
+        @Override
+        boolean tryAuthorize(AuthorizationRequest request) {
+            Intent intent = NativeProtocol.createLoginDialog20121101Intent(context, request.getApplicationId(),
+                    new ArrayList<String>(request.getPermissions()),
+                    request.getDefaultAudience().getNativeProtocolAudience());
+
+            return tryIntent(intent, request.getRequestCode());
+        }
+
+        @Override
+        boolean onActivityResult(int requestCode, int resultCode, Intent data) {
+            if (NativeProtocol.isServiceDisabledResult20121101(data)) {
+                tryNextHandler();
+            } else {
+                // Handle stuff
+                Result outcome = null;
+
+                if (resultCode == Activity.RESULT_CANCELED) {
+                    outcome = Result.createCancelResult(
+                            data.getStringExtra(NativeProtocol.STATUS_ERROR_DESCRIPTION));
+                } else if (resultCode != Activity.RESULT_OK) {
+                    outcome = Result
+                            .createErrorResult("Unexpected resultCode from authorization.", null);
+                } else {
+                    outcome = handleResultOk(data);
+                }
+
+                if (outcome != null) {
+                    completeAndValidate(outcome);
+                } else {
+                    tryNextHandler();
+                }
+            }
+            return true;
+        }
+
+        private Result handleResultOk(Intent data) {
+            Bundle extras = data.getExtras();
+            String errorType = extras.getString(NativeProtocol.STATUS_ERROR_TYPE);
+            if (errorType == null) {
+                return Result.createTokenResult(
+                        AccessToken.createFromNativeLogin(extras, AccessTokenSource.FACEBOOK_APPLICATION_NATIVE));
+            } else if (NativeProtocol.ERROR_SERVICE_DISABLED.equals(errorType)) {
+                return null;
+            } else if (NativeProtocol.ERROR_USER_CANCELED.equals(errorType)) {
+                return Result.createCancelResult(null);
+            } else {
+                return Result.createErrorResult(errorType, extras.getString("error_description"));
+            }
+        }
+    }
+
+    class KatanaProxyAuthHandler extends KatanaAuthHandler {
+        private static final long serialVersionUID = 1L;
+
+        @Override
+        boolean tryAuthorize(AuthorizationRequest request) {
+            Intent intent = NativeProtocol.createProxyAuthIntent(context,
+                    request.getApplicationId(), request.getPermissions());
+
+            return tryIntent(intent, request.getRequestCode());
+        }
+
+        @Override
+        boolean onActivityResult(int requestCode, int resultCode, Intent data) {
+            // Handle stuff
+            Result outcome = null;
+
+            if (resultCode == Activity.RESULT_CANCELED) {
+                outcome = Result.createCancelResult(data.getStringExtra("error"));
+            } else if (resultCode != Activity.RESULT_OK) {
+                outcome = Result.createErrorResult("Unexpected resultCode from authorization.", null);
+            } else {
+                outcome = handleResultOk(data);
+            }
+
+            if (outcome != null) {
+                completeAndValidate(outcome);
+            } else {
+                tryNextHandler();
+            }
+            return true;
+        }
+
+        private Result handleResultOk(Intent data) {
+            Bundle extras = data.getExtras();
+            String error = extras.getString("error");
+            if (error == null) {
+                error = extras.getString("error_type");
+            }
+
+            if (error == null) {
+                AccessToken token = AccessToken.createFromWebBundle(pendingRequest.getPermissions(), extras,
+                        AccessTokenSource.FACEBOOK_APPLICATION_WEB);
+                return Result.createTokenResult(token);
+            } else if (ServerProtocol.errorsProxyAuthDisabled.contains(error)) {
+                return null;
+            } else if (ServerProtocol.errorsUserCanceled.contains(error)) {
+                return Result.createCancelResult(null);
+            } else {
+                return Result.createErrorResult(error, extras.getString("error_description"));
+            }
+        }
+    }
+
+    static class AuthDialogBuilder extends WebDialog.Builder {
+        private static final String OAUTH_DIALOG = "oauth";
+        static final String REDIRECT_URI = "fbconnect://success";
+
+        public AuthDialogBuilder(Context context, String applicationId, Bundle parameters) {
+            super(context, applicationId, OAUTH_DIALOG, parameters);
+        }
+
+        @Override
+        public WebDialog build() {
+            Bundle parameters = getParameters();
+            parameters.putString(ServerProtocol.DIALOG_PARAM_REDIRECT_URI, REDIRECT_URI);
+            parameters.putString(ServerProtocol.DIALOG_PARAM_CLIENT_ID, getApplicationId());
+
+            return new WebDialog(getContext(), OAUTH_DIALOG, parameters, getTheme(), getListener());
+        }
+    }
+
+    static class AuthorizationRequest implements Serializable {
+        private static final long serialVersionUID = 1L;
+
+        private transient final StartActivityDelegate startActivityDelegate;
+        private SessionLoginBehavior loginBehavior;
+        private int requestCode;
+        private boolean isLegacy = false;
+        private List<String> permissions;
+        private SessionDefaultAudience defaultAudience;
+        private String applicationId;
+        private String previousAccessToken;
+
+        AuthorizationRequest(SessionLoginBehavior loginBehavior, int requestCode, boolean isLegacy,
+                List<String> permissions, SessionDefaultAudience defaultAudience, String applicationId,
+                String validateSameFbidAsToken, StartActivityDelegate startActivityDelegate) {
+            this.loginBehavior = loginBehavior;
+            this.requestCode = requestCode;
+            this.isLegacy = isLegacy;
+            this.permissions = permissions;
+            this.defaultAudience = defaultAudience;
+            this.applicationId = applicationId;
+            this.previousAccessToken = validateSameFbidAsToken;
+            this.startActivityDelegate = startActivityDelegate;
+
+        }
+
+        StartActivityDelegate getStartActivityDelegate() {
+            return startActivityDelegate;
+        }
+
+        List<String> getPermissions() {
+            return permissions;
+        }
+
+        void setPermissions(List<String> permissions) {
+            this.permissions = permissions;
+        }
+
+        SessionLoginBehavior getLoginBehavior() {
+            return loginBehavior;
+        }
+
+        int getRequestCode() {
+            return requestCode;
+        }
+
+        SessionDefaultAudience getDefaultAudience() {
+            return defaultAudience;
+        }
+
+        String getApplicationId() {
+            return applicationId;
+        }
+
+        boolean isLegacy() {
+            return isLegacy;
+        }
+
+        void setIsLegacy(boolean isLegacy) {
+            this.isLegacy = isLegacy;
+        }
+
+        String getPreviousAccessToken() {
+            return previousAccessToken;
+        }
+
+        boolean needsNewTokenValidation() {
+            return previousAccessToken != null && !isLegacy;
+        }
+    }
+
+
+    static class Result implements Serializable {
+        private static final long serialVersionUID = 1L;
+
+        enum Code {
+            SUCCESS,
+            CANCEL,
+            ERROR
+        }
+
+        final Code code;
+        final AccessToken token;
+        final String errorMessage;
+
+        private Result(Code code, AccessToken token, String errorMessage) {
+            this.token = token;
+            this.errorMessage = errorMessage;
+            this.code = code;
+        }
+
+        static Result createTokenResult(AccessToken token) {
+            return new Result(Code.SUCCESS, token, null);
+        }
+
+        static Result createCancelResult(String message) {
+            return new Result(Code.CANCEL, null, message);
+        }
+
+        static Result createErrorResult(String errorType, String errorDescription) {
+            String message = errorType;
+            if (errorDescription != null) {
+                message += ": " + errorDescription;
+            }
+            return new Result(Code.ERROR, null, message);
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookActivity.java b/facebook/src/com/facebook/FacebookActivity.java
deleted file mode 100644
index fcc8d7cbe..000000000
--- a/facebook/src/com/facebook/FacebookActivity.java
+++ /dev/null
@@ -1,328 +0,0 @@
-/**
- * Copyright 2012 Facebook
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.content.Intent;
-import android.os.Bundle;
-import android.support.v4.app.FragmentActivity;
-
-import java.util.Date;
-import java.util.List;
-
-/**
- * <p>Basic implementation of an Activity that uses a Session to perform 
- * Single Sign On (SSO).</p>
- * 
- * <p>Numerous Activity lifecycle methods are overridden in this class
- * to manage session information. If you override Activity lifecycle methods,
- * be sure to call the appropriate {@code super} method.
- * 
- * <p>The methods in this class are not thread-safe</p>
- */
-public class FacebookActivity extends FragmentActivity {
-
-    private static final String SESSION_IS_ACTIVE_KEY = "com.facebook.sdk.FacebookActivity.sessionIsActiveKey";
-
-    private SessionTracker sessionTracker;
-
-    /**
-     * Initializes the state in FacebookActivity. This method will try to restore the Session
-     * if one was saved. If the restored Session object was the active Session, it will also set
-     * the restored Session as the active Session (unless there's currently an active Session
-     * already set).
-     */
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        Session.StatusCallback callback = new DefaultSessionStatusCallback();
-        sessionTracker = new SessionTracker(this, callback);
-        if (savedInstanceState != null) {
-            Session session = Session.restoreSession(this, null, callback, savedInstanceState);
-            if (session != null) {
-                if (savedInstanceState.getBoolean(SESSION_IS_ACTIVE_KEY)) {
-                    if (Session.getActiveSession() == null) {
-                        Session.setActiveSession(session);
-                    }
-                } else {
-                    sessionTracker.setSession(session);
-                }
-            }
-        }
-    }
-
-    /**
-     * Called when the activity that was launched exits. This method manages session
-     * information when a session is opened. If this method is overridden in subclasses,
-     * be sure to call {@code super.onActivityResult(...)} first.
-     */
-    @Override
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        super.onActivityResult(requestCode, resultCode, data);
-        sessionTracker.getSession().onActivityResult(this, requestCode, resultCode, data);
-    }
-
-    @Override
-    public void onDestroy() {
-        super.onDestroy();
-        sessionTracker.stopTracking();
-    }
-
-    /**
-     * This method will save the session state so that it can be restored during
-     * onCreate.
-     */
-    @Override
-    protected void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        Session currentSession = sessionTracker.getSession();
-        Session.saveSession(currentSession, outState);
-        outState.putBoolean(SESSION_IS_ACTIVE_KEY, sessionTracker.isTrackingActiveSession());
-    }
-
-    // METHOD TO BE OVERRIDDEN
-    
-    /**
-     * Called when the session state changes. Override this method to take action
-     * on session state changes.
-     * 
-     * @param state the new Session state
-     * @param exception any exceptions that occurred during the state change
-     */
-    protected void onSessionStateChange(SessionState state, Exception exception) {
-    }
-
-    /** 
-     * Use the supplied Session object instead of the active Session.
-     * 
-     * @param newSession the Session object to use
-     */
-    protected void setSession(Session newSession) {
-        sessionTracker.setSession(newSession);
-    }
-
-    // ACCESSORS (CANNOT BE OVERRIDDEN)
-
-    /**
-     * Gets the current session for this Activity
-     *
-     * @return the current session, or null if one has not been set.
-     */
-    protected final Session getSession() {
-        return sessionTracker.getSession();
-    }
-
-    /**
-     * Determines whether the current session is open.
-     * 
-     * @return true if the current session is open
-     */
-    protected final boolean isSessionOpen() {
-        return sessionTracker.getOpenSession() != null;
-    }
-    
-    /**
-     * Gets the current state of the session or null if no session has been created.
-     * 
-     * @return the current state of the session
-     */
-    protected final SessionState getSessionState() {
-        Session currentSession = sessionTracker.getSession();
-        return (currentSession != null) ? currentSession.getState() : null;
-    }
-    
-    /**
-     * Gets the access token associated with the current session or null if no 
-     * session has been created.
-     * 
-     * @return the access token
-     */
-    protected final String getAccessToken() {
-        Session currentSession = sessionTracker.getOpenSession();
-        return (currentSession != null) ? currentSession.getAccessToken() : null;
-    }
-
-    /**
-     * Gets the date at which the current session will expire or null if no session 
-     * has been created.
-     * 
-     * @return the date at which the current session will expire
-     */
-    protected final Date getExpirationDate() {
-        Session currentSession = sessionTracker.getOpenSession();
-        return (currentSession != null) ? currentSession.getExpirationDate() : null;
-    }
-    
-    /**
-     * Closes the current session.
-     */
-    protected final void closeSession() {
-        Session currentSession = sessionTracker.getOpenSession();
-        if (currentSession != null) {
-            currentSession.close();
-        }
-    }
-    
-    /**
-     * Closes the current session as well as clearing the token cache.
-     */
-    protected final void closeSessionAndClearTokenInformation() {
-        Session currentSession = sessionTracker.getOpenSession();
-        if (currentSession != null) {
-            currentSession.closeAndClearTokenInformation();
-        }
-    }
-    
-    /**
-     * Gets the permissions associated with the current session or null if no session 
-     * has been created.
-     * 
-     * @return the permissions associated with the current session
-     */
-    protected final List<String> getSessionPermissions() {
-        Session currentSession = sessionTracker.getSession();
-        return (currentSession != null) ? currentSession.getPermissions() : null;
-    }
-
-    /**
-     * Opens a new session. This method will use the application id from
-     * the associated meta-data value and an empty list of permissions.
-     * <p>
-     * If no session exists for this Activity, or if the current session has been closed,
-     * this will create a new Session object and set it as the active session. If a session
-     * exists for this Activity but is not yet open, this will try to open the session.
-     * If a session is already open for this Activity, this does nothing.
-     * </p>
-     */
-    protected final void openSession() {
-        openSessionForRead(null, null);
-    }
-    
-    /**
-     * Opens a new session with read permissions. If either applicationID or permissions
-     * is null, this method will default to using the values from the associated
-     * meta-data value and an empty list respectively.
-     * <p>
-     * If no session exists for this Activity, or if the current session has been closed,
-     * this will create a new Session object and set it as the active session. If a session
-     * exists for this Activity but is not yet open, this will try to open the session.
-     * If a session is already open for this Activity, this does nothing.
-     * </p>
-     *
-     * @param applicationId the applicationID, can be null
-     * @param permissions the permissions list, can be null
-     */
-    protected final void openSessionForRead(String applicationId, List<String> permissions) {
-        openSessionForRead(applicationId, permissions, SessionLoginBehavior.SSO_WITH_FALLBACK,
-                Session.DEFAULT_AUTHORIZE_ACTIVITY_CODE);
-    }
-    
-    /**
-     * Opens a new session with read permissions. If either applicationID or permissions
-     * is null, this method will default to using the values from the associated
-     * meta-data value and an empty list respectively.
-     * <p>
-     * If no session exists for this Activity, or if the current session has been closed,
-     * this will create a new Session object and set it as the active session. If a session
-     * exists for this Activity but is not yet open, this will try to open the session.
-     * If a session is already open for this Activity, this does nothing.
-     * </p>
-     *
-     * @param applicationId the applicationID, can be null
-     * @param permissions the permissions list, can be null
-     * @param behavior the login behavior to use with the session
-     * @param activityCode the activity code to use for the SSO activity
-     */
-    protected final void openSessionForRead(String applicationId, List<String> permissions,
-            SessionLoginBehavior behavior, int activityCode) {
-        openSession(applicationId, permissions, behavior, activityCode, Session.AuthorizationType.READ);
-    }
-
-    /**
-     * Opens a new session with publish permissions. If the applicationID is null,
-     * this method will default to using the value from the associated
-     * meta-data value. The permissions list cannot be null.
-     * <p>
-     * If no session exists for this Activity, or if the current session has been closed,
-     * this will create a new Session object and set it as the active session. If a session
-     * exists for this Activity but is not yet open, this will try to open the session.
-     * If a session is already open for this Activity, this does nothing.
-     * </p>
-     *
-     * @param applicationId the applicationID, can be null
-     * @param permissions the permissions list, cannot be null
-     */
-    protected final void openSessionForPublish(String applicationId, List<String> permissions) {
-        openSessionForPublish(applicationId, permissions, SessionLoginBehavior.SSO_WITH_FALLBACK,
-                Session.DEFAULT_AUTHORIZE_ACTIVITY_CODE);
-    }
-
-    /**
-     * Opens a new session with publish permissions. If the applicationID is null,
-     * this method will default to using the value from the associated
-     * meta-data value. The permissions list cannot be null.
-     * <p>
-     * If no session exists for this Activity, or if the current session has been closed,
-     * this will create a new Session object and set it as the active session. If a session
-     * exists for this Activity but is not yet open, this will try to open the session.
-     * If a session is already open for this Activity, this does nothing.
-     * </p>
-     *
-     * @param applicationId the applicationID, can be null
-     * @param permissions the permissions list, cannot be null
-     * @param behavior the login behavior to use with the session
-     * @param activityCode the activity code to use for the SSO activity
-     */
-    protected final void openSessionForPublish(String applicationId, List<String> permissions,
-            SessionLoginBehavior behavior, int activityCode) {
-        openSession(applicationId, permissions, behavior, activityCode, Session.AuthorizationType.PUBLISH);
-    }
-
-    private void openSession(String applicationId, List<String> permissions,
-            SessionLoginBehavior behavior, int activityCode, Session.AuthorizationType authType) {
-        Session currentSession = sessionTracker.getSession();
-        if (currentSession == null || currentSession.getState().isClosed()) {
-            Session session = new Session.Builder(this).setApplicationId(applicationId).build();
-            Session.setActiveSession(session);
-            currentSession = session;
-        }
-        if (!currentSession.isOpened()) {
-            Session.OpenRequest openRequest = new Session.OpenRequest(this).
-                    setPermissions(permissions).
-                    setLoginBehavior(behavior).
-                    setRequestCode(activityCode);
-            if (Session.AuthorizationType.PUBLISH.equals(authType)) {
-                currentSession.openForPublish(openRequest);
-            } else {
-                currentSession.openForRead(openRequest);
-            }
-        }
-    }
-
-    /**
-     * The default callback implementation for the session.
-     */
-    private class DefaultSessionStatusCallback implements Session.StatusCallback {
-
-        @Override
-        public void call(Session session, 
-                         SessionState state,
-                         Exception exception) {
-            FacebookActivity.this.onSessionStateChange(state, exception);
-        }
-        
-    }
-}
diff --git a/facebook/src/com/facebook/FacebookAuthorizationException.java b/facebook/src/com/facebook/FacebookAuthorizationException.java
index 01f7876c6..b8273e500 100644
--- a/facebook/src/com/facebook/FacebookAuthorizationException.java
+++ b/facebook/src/com/facebook/FacebookAuthorizationException.java
@@ -17,7 +17,7 @@
 package com.facebook;
 
 /**
- * An Exception indicating that a Session failed to open or reauthorize.
+ * An Exception indicating that a Session failed to open or obtain new permissions.
  */
 public class FacebookAuthorizationException extends FacebookException {
     static final long serialVersionUID = 1;
diff --git a/facebook/src/com/facebook/FacebookDialogException.java b/facebook/src/com/facebook/FacebookDialogException.java
new file mode 100644
index 000000000..0285837ad
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookDialogException.java
@@ -0,0 +1,53 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Represents an error condition relating to displaying a Facebook Web dialog.
+ */
+public class FacebookDialogException extends FacebookException {
+    static final long serialVersionUID = 1;
+    private int errorCode;
+    private String failingUrl;
+
+    /**
+     * Constructs a new FacebookException.
+     */
+    public FacebookDialogException(String message, int errorCode, String failingUrl) {
+        super(message);
+        this.errorCode = errorCode;
+        this.failingUrl = failingUrl;
+    }
+
+    /**
+     * Gets the error code received by the WebView. See:
+     * http://developer.android.com/reference/android/webkit/WebViewClient.html
+     *
+     * @return the error code
+     */
+    public int getErrorCode() {
+        return errorCode;
+    }
+
+    /**
+     * Gets the URL that the dialog was trying to load.
+     * @return the URL
+     */
+    public String getFailingUrl() {
+        return failingUrl;
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookException.java b/facebook/src/com/facebook/FacebookException.java
index 83f3112c2..3525dbe47 100644
--- a/facebook/src/com/facebook/FacebookException.java
+++ b/facebook/src/com/facebook/FacebookException.java
@@ -1,5 +1,5 @@
 /**
- * Copyright 2010 Facebook, Inc.
+ * Copyright 2012 Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
diff --git a/facebook/src/com/facebook/FacebookGraphObjectException.java b/facebook/src/com/facebook/FacebookGraphObjectException.java
index 6e0932ab5..a03828a9f 100644
--- a/facebook/src/com/facebook/FacebookGraphObjectException.java
+++ b/facebook/src/com/facebook/FacebookGraphObjectException.java
@@ -1,7 +1,23 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook;
 
 /**
- * Represents an error specific to the {@link GraphObject GraphObject} class.
+ * Represents an error specific to the {@link com.facebook.model.GraphObject GraphObject} class.
  */
 public class FacebookGraphObjectException extends FacebookException {
     static final long serialVersionUID = 1;
diff --git a/facebook/src/com/facebook/FacebookOperationCanceledException.java b/facebook/src/com/facebook/FacebookOperationCanceledException.java
index f45589532..ed6d998db 100644
--- a/facebook/src/com/facebook/FacebookOperationCanceledException.java
+++ b/facebook/src/com/facebook/FacebookOperationCanceledException.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook;
 
 /**
diff --git a/facebook/src/com/facebook/FacebookRequestError.java b/facebook/src/com/facebook/FacebookRequestError.java
new file mode 100644
index 000000000..f4946c583
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookRequestError.java
@@ -0,0 +1,451 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import com.facebook.android.R;
+import com.facebook.internal.Utility;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.net.HttpURLConnection;
+
+/**
+ * This class represents an error that occurred during a Facebook request.
+ * <p/>
+ * In general, one would call {@link #getCategory()} to determine the type
+ * of error that occurred, and act accordingly. The app can also call
+ * {@link #getUserActionMessageId()} in order to get the resource id for a
+ * string that can be displayed to the user. For more information on error
+ * handling, see <a href="https://developers.facebook.com/docs/reference/api/errors/">
+ * https://developers.facebook.com/docs/reference/api/errors/</a>
+ */
+public final class FacebookRequestError {
+
+    /** Represents an invalid or unknown error code from the server. */
+    public static final int INVALID_ERROR_CODE = -1;
+
+    /**
+     * Indicates that there was no valid HTTP status code returned, indicating
+     * that either the error occurred locally, before the request was sent, or
+     * that something went wrong with the HTTP connection. Check the exception
+     * from {@link #getException()};
+     */
+    public static final int INVALID_HTTP_STATUS_CODE = -1;
+
+    private static final int INVALID_MESSAGE_ID = 0;
+
+    private static final String CODE_KEY = "code";
+    private static final String BODY_KEY = "body";
+    private static final String ERROR_KEY = "error";
+    private static final String ERROR_TYPE_FIELD_KEY = "type";
+    private static final String ERROR_CODE_FIELD_KEY = "code";
+    private static final String ERROR_MESSAGE_FIELD_KEY = "message";
+    private static final String ERROR_CODE_KEY = "error_code";
+    private static final String ERROR_SUB_CODE_KEY = "error_subcode";
+    private static final String ERROR_MSG_KEY = "error_msg";
+    private static final String ERROR_REASON_KEY = "error_reason";
+
+    private static class Range {
+        private final int start, end;
+
+        private Range(int start, int end) {
+            this.start = start;
+            this.end = end;
+        }
+
+        boolean contains(int value) {
+            return start <= value && value <= end;
+        }
+    }
+
+    private static final int EC_UNKNOWN_ERROR = 1;
+    private static final int EC_SERVICE_UNAVAILABLE = 2;
+    private static final int EC_APP_TOO_MANY_CALLS = 4;
+    private static final int EC_USER_TOO_MANY_CALLS = 17;
+    private static final int EC_PERMISSION_DENIED = 10;
+    private static final int EC_INVALID_SESSION = 102;
+    private static final int EC_INVALID_TOKEN = 190;
+    private static final Range EC_RANGE_PERMISSION = new Range(200, 299);
+    private static final int EC_APP_NOT_INSTALLED = 458;
+    private static final int EC_USER_CHECKPOINTED = 459;
+    private static final int EC_PASSWORD_CHANGED = 460;
+    private static final int EC_UNCONFIRMED_USER = 464;
+
+    private static final Range HTTP_RANGE_SUCCESS = new Range(200, 299);
+    private static final Range HTTP_RANGE_CLIENT_ERROR = new Range(400, 499);
+    private static final Range HTTP_RANGE_SERVER_ERROR = new Range(500, 599);
+
+    private final int userActionMessageId;
+    private final boolean shouldNotifyUser;
+    private final Category category;
+    private final int requestStatusCode;
+    private final int errorCode;
+    private final int subErrorCode;
+    private final String errorType;
+    private final String errorMessage;
+    private final JSONObject requestResult;
+    private final JSONObject requestResultBody;
+    private final Object batchRequestResult;
+    private final HttpURLConnection connection;
+    private final FacebookException exception;
+
+    private FacebookRequestError(int requestStatusCode, int errorCode,
+            int subErrorCode, String errorType, String errorMessage, JSONObject requestResultBody,
+            JSONObject requestResult, Object batchRequestResult, HttpURLConnection connection,
+            FacebookException exception) {
+        this.requestStatusCode = requestStatusCode;
+        this.errorCode = errorCode;
+        this.subErrorCode = subErrorCode;
+        this.errorType = errorType;
+        this.errorMessage = errorMessage;
+        this.requestResultBody = requestResultBody;
+        this.requestResult = requestResult;
+        this.batchRequestResult = batchRequestResult;
+        this.connection = connection;
+
+        boolean isLocalException = false;
+        if (exception != null) {
+            this.exception = exception;
+            isLocalException =  true;
+        } else {
+            this.exception = new FacebookServiceException(this, errorMessage);
+        }
+
+        // Initializes the error categories based on the documented error codes as outlined here
+        // https://developers.facebook.com/docs/reference/api/errors/
+        Category errorCategory = null;
+        int messageId = INVALID_MESSAGE_ID;
+        boolean shouldNotify = false;
+        if (isLocalException) {
+            errorCategory = Category.CLIENT;
+            messageId = INVALID_MESSAGE_ID;
+        } else {
+            if (errorCode == EC_UNKNOWN_ERROR || errorCode == EC_SERVICE_UNAVAILABLE) {
+                errorCategory = Category.SERVER;
+            } else if (errorCode == EC_APP_TOO_MANY_CALLS || errorCode == EC_USER_TOO_MANY_CALLS) {
+                errorCategory = Category.THROTTLING;
+            } else if (errorCode == EC_PERMISSION_DENIED || EC_RANGE_PERMISSION.contains(errorCode)) {
+                errorCategory = Category.PERMISSION;
+                messageId = R.string.com_facebook_requesterror_permissions;
+            } else if (errorCode == EC_INVALID_SESSION || errorCode == EC_INVALID_TOKEN) {
+                if (subErrorCode == EC_USER_CHECKPOINTED || subErrorCode == EC_UNCONFIRMED_USER) {
+                    errorCategory = Category.AUTHENTICATION_RETRY;
+                    messageId = R.string.com_facebook_requesterror_web_login;
+                    shouldNotify = true;
+                } else {
+                    errorCategory = Category.AUTHENTICATION_REOPEN_SESSION;
+
+                    if (subErrorCode == EC_APP_NOT_INSTALLED) {
+                        messageId = R.string.com_facebook_requesterror_relogin;
+                    } else if (subErrorCode == EC_PASSWORD_CHANGED) {
+                        messageId = R.string.com_facebook_requesterror_password_changed;
+                    } else {
+                        messageId = R.string.com_facebook_requesterror_reconnect;
+                    }
+                }
+            }
+
+            if (errorCategory == null) {
+                if (HTTP_RANGE_CLIENT_ERROR.contains(requestStatusCode)) {
+                    errorCategory = Category.BAD_REQUEST;
+                } else if (HTTP_RANGE_SERVER_ERROR.contains(requestStatusCode)) {
+                    errorCategory = Category.SERVER;
+                } else {
+                    errorCategory = Category.OTHER;
+                }
+            }
+        }
+
+        this.category = errorCategory;
+        this.userActionMessageId = messageId;
+        this.shouldNotifyUser = shouldNotify;
+    }
+
+    private FacebookRequestError(int requestStatusCode, int errorCode,
+            int subErrorCode, String errorType, String errorMessage, JSONObject requestResultBody,
+            JSONObject requestResult, Object batchRequestResult, HttpURLConnection connection) {
+        this(requestStatusCode, errorCode, subErrorCode, errorType, errorMessage,
+                requestResultBody, requestResult, batchRequestResult, connection, null);
+    }
+
+    FacebookRequestError(HttpURLConnection connection, Exception exception) {
+        this(INVALID_HTTP_STATUS_CODE, INVALID_ERROR_CODE, INVALID_ERROR_CODE,
+                null, null, null, null, null, connection,
+                (exception instanceof FacebookException) ?
+                        (FacebookException) exception : new FacebookException(exception));
+    }
+
+    public FacebookRequestError(int errorCode, String errorType, String errorMessage) {
+        this(INVALID_HTTP_STATUS_CODE, errorCode, INVALID_ERROR_CODE, errorType, errorMessage,
+                null, null, null, null, null);
+    }
+
+    /**
+     * Returns the resource id for a user-friendly message for the application to
+     * present to the user.
+     *
+     * @return a user-friendly message to present to the user
+     */
+    public int getUserActionMessageId() {
+        return userActionMessageId;
+    }
+
+    /**
+     * Returns whether direct user action is required to successfully continue with the Facebook
+     * operation. If user action is required, apps can also call {@link #getUserActionMessageId()}
+     * in order to get a resource id for a message to show the user.
+     *
+     * @return whether direct user action is required
+     */
+    public boolean shouldNotifyUser() {
+        return shouldNotifyUser;
+    }
+
+    /**
+     * Returns the category in which the error belongs. Applications can use the category
+     * to determine how best to handle the errors (e.g. exponential backoff for retries if
+     * being throttled).
+     *
+     * @return the category in which the error belong
+     */
+    public Category getCategory() {
+        return category;
+    }
+
+    /**
+     * Returns the HTTP status code for this particular request.
+     *
+     * @return the HTTP status code for the request
+     */
+    public int getRequestStatusCode() {
+        return requestStatusCode;
+    }
+
+    /**
+     * Returns the error code returned from Facebook.
+     *
+     * @return the error code returned from Facebook
+     */
+    public int getErrorCode() {
+        return errorCode;
+    }
+
+    /**
+     * Returns the sub-error code returned from Facebook.
+     *
+     * @return the sub-error code returned from Facebook
+     */
+    public int getSubErrorCode() {
+        return subErrorCode;
+    }
+
+    /**
+     * Returns the type of error as a raw string. This is generally less useful
+     * than using the {@link #getCategory()} method, but can provide further details
+     * on the error.
+     *
+     * @return the type of error as a raw string
+     */
+    public String getErrorType() {
+        return errorType;
+    }
+
+    /**
+     * Returns the error message returned from Facebook.
+     *
+     * @return the error message returned from Facebook
+     */
+    public String getErrorMessage() {
+        if (errorMessage != null) {
+            return errorMessage;
+        } else {
+            return exception.getLocalizedMessage();
+        }
+    }
+
+    /**
+     * Returns the body portion of the response corresponding to the request from Facebook.
+     *
+     * @return the body of the response for the request
+     */
+    public JSONObject getRequestResultBody() {
+        return requestResultBody;
+    }
+
+    /**
+     * Returns the full JSON response for the corresponding request. In a non-batch request,
+     * this would be the raw response in the form of a JSON object. In a batch request, this
+     * result will contain the body of the response as well as the HTTP headers that pertain
+     * to the specific request (in the form of a "headers" JSONArray).
+     *
+     * @return the full JSON response for the request
+     */
+    public JSONObject getRequestResult() {
+        return requestResult;
+    }
+
+    /**
+     * Returns the full JSON response for the batch request. If the request was not a batch
+     * request, then the result from this method is the same as {@link #getRequestResult()}.
+     * In case of a batch request, the result will be a JSONArray where the elements
+     * correspond to the requests in the batch. Callers should check the return type against
+     * either JSONObject or JSONArray and cast accordingly.
+     *
+     * @return the full JSON response for the batch
+     */
+    public Object getBatchRequestResult() {
+        return batchRequestResult;
+    }
+
+    /**
+     * Returns the HTTP connection that was used to make the request.
+     *
+     * @return the HTTP connection used to make the request
+     */
+    public HttpURLConnection getConnection() {
+        return connection;
+    }
+
+    /**
+     * Returns the exception associated with this request, if any.
+     *
+     * @return the exception associated with this request
+     */
+    public FacebookException getException() {
+        return exception;
+    }
+
+    @Override
+    public String toString() {
+        return new StringBuilder("{HttpStatus: ")
+                .append(requestStatusCode)
+                .append(", errorCode: ")
+                .append(errorCode)
+                .append(", errorType: ")
+                .append(errorType)
+                .append(", errorMessage: ")
+                .append(errorMessage)
+                .append("}")
+                .toString();
+    }
+
+    static FacebookRequestError checkResponseAndCreateError(JSONObject singleResult,
+            Object batchResult, HttpURLConnection connection) {
+        try {
+            if (singleResult.has(CODE_KEY)) {
+                int responseCode = singleResult.getInt(CODE_KEY);
+                Object body = Utility.getStringPropertyAsJSON(singleResult, BODY_KEY,
+                        Response.NON_JSON_RESPONSE_PROPERTY);
+
+                if (body != null && body instanceof JSONObject) {
+                    JSONObject jsonBody = (JSONObject) body;
+                    // Does this response represent an error from the service? We might get either an "error"
+                    // with several sub-properties, or else one or more top-level fields containing error info.
+                    String errorType = null;
+                    String errorMessage = null;
+                    int errorCode = INVALID_ERROR_CODE;
+                    int errorSubCode = INVALID_ERROR_CODE;
+
+                    boolean hasError = false;
+                    if (jsonBody.has(ERROR_KEY)) {
+                        // We assume the error object is correctly formatted.
+                        JSONObject error = (JSONObject) Utility.getStringPropertyAsJSON(jsonBody, ERROR_KEY, null);
+
+                        errorType = error.optString(ERROR_TYPE_FIELD_KEY, null);
+                        errorMessage = error.optString(ERROR_MESSAGE_FIELD_KEY, null);
+                        errorCode = error.optInt(ERROR_CODE_FIELD_KEY, INVALID_ERROR_CODE);
+                        errorSubCode = error.optInt(ERROR_SUB_CODE_KEY, INVALID_ERROR_CODE);
+                        hasError = true;
+                    } else if (jsonBody.has(ERROR_CODE_KEY) || jsonBody.has(ERROR_MSG_KEY)
+                            || jsonBody.has(ERROR_REASON_KEY)) {
+                        errorType = jsonBody.optString(ERROR_REASON_KEY, null);
+                        errorMessage = jsonBody.optString(ERROR_MSG_KEY, null);
+                        errorCode = jsonBody.optInt(ERROR_CODE_KEY, INVALID_ERROR_CODE);
+                        errorSubCode = jsonBody.optInt(ERROR_SUB_CODE_KEY, INVALID_ERROR_CODE);
+                        hasError = true;
+                    }
+
+                    if (hasError) {
+                        return new FacebookRequestError(responseCode, errorCode, errorSubCode,
+                                errorType, errorMessage, jsonBody, singleResult, batchResult, connection);
+                    }
+                }
+
+                // If we didn't get error details, but we did get a failure response code, report it.
+                if (!HTTP_RANGE_SUCCESS.contains(responseCode)) {
+                    return new FacebookRequestError(responseCode, INVALID_ERROR_CODE,
+                            INVALID_ERROR_CODE, null, null,
+                            singleResult.has(BODY_KEY) ?
+                                    (JSONObject) Utility.getStringPropertyAsJSON(
+                                            singleResult, BODY_KEY, Response.NON_JSON_RESPONSE_PROPERTY) : null,
+                            singleResult, batchResult, connection);
+                }
+            }
+        } catch (JSONException e) {
+            // defer the throwing of a JSONException to the graph object proxy
+        }
+        return null;
+    }
+
+    /**
+     * An enum that represents the Facebook SDK classification for the error that occurred.
+     */
+    public enum Category {
+        /**
+         * Indicates that the error is authentication related, and that the app should retry
+         * the request after some user action.
+         */
+        AUTHENTICATION_RETRY,
+
+        /**
+         * Indicates that the error is authentication related, and that the app should close
+         * the session and reopen it.
+         */
+        AUTHENTICATION_REOPEN_SESSION,
+
+        /** Indicates that the error is permission related. */
+        PERMISSION,
+
+        /**
+         * Indicates that the error implies the server had an unexpected failure or may be
+         * temporarily unavailable.
+         */
+        SERVER,
+
+        /** Indicates that the error results from the server throttling the client. */
+        THROTTLING,
+
+        /**
+         * Indicates that the error is Facebook-related but cannot be categorized at this time,
+         * and is likely newer than the current version of the SDK.
+         */
+        OTHER,
+
+        /**
+         * Indicates that the error is an application error resulting in a bad or malformed
+         * request to the server.
+         */
+        BAD_REQUEST,
+
+        /**
+         * Indicates that this is a client-side error. Examples of this can include, but are
+         * not limited to, JSON parsing errors or {@link java.io.IOException}s.
+         */
+        CLIENT
+    };
+
+}
diff --git a/facebook/src/com/facebook/FacebookSdkVersion.java b/facebook/src/com/facebook/FacebookSdkVersion.java
index 172d0d660..f315c7c52 100644
--- a/facebook/src/com/facebook/FacebookSdkVersion.java
+++ b/facebook/src/com/facebook/FacebookSdkVersion.java
@@ -16,17 +16,7 @@
 
 package com.facebook;
 
-/**
- * Specifies sdk-version-specific data.
- */
-public final class FacebookSdkVersion {
-    /**
-     * The build version string of this SDK.
-     */
-    public static final String BUILD = "3.0.1.b";
-
-    /**
-     * The migration bundle string with which this version of the SDK was tested.
-     */
-    public static final String MIGRATION_BUNDLE = "fbsdk:20120913";
+final class FacebookSdkVersion {
+    public static final String BUILD = "3.0.0";
+    public static final String MIGRATION_BUNDLE = "fbsdk:20121026";
 }
diff --git a/facebook/src/com/facebook/FacebookServiceErrorException.java b/facebook/src/com/facebook/FacebookServiceErrorException.java
deleted file mode 100644
index 87d6e719a..000000000
--- a/facebook/src/com/facebook/FacebookServiceErrorException.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/**
- * Copyright 2012 Facebook
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import org.json.JSONObject;
-
-/**
- * Represents an error returned from the Facebook service in response to a request.
- */
-public class FacebookServiceErrorException extends FacebookException {
-    /**
-     * Indicates no error code was returned by Facebook.
-     */
-    public static final int UNKNOWN_ERROR_CODE = -1;
-
-    private final int httpResponseCode;
-    private final int facebookErrorCode;
-    private final String facebookErrorType;
-    private final JSONObject responseBody;
-
-    static final long serialVersionUID = 1;
-
-    /**
-     * Constructs a new FacebookServiceErrorException.
-     * 
-     * @param responseCode the HTTP response code returned by Facebook
-     */
-    public FacebookServiceErrorException(int responseCode) {
-        this(responseCode, UNKNOWN_ERROR_CODE, null, null, null);
-    }
-
-    /**
-     * Constructs a new FacebookServiceErrorException.
-     * 
-     * @param responseCode the HTTP response code returned by Facebook
-     * @param facebookErrorCode the error code returned by Facebook
-     * @param facebookErrorType the error type returned by Facebook
-     * @param message the error message returned by Facebook
-     * @param responseBody the complete error response returned by Facebook.
-     */
-    public FacebookServiceErrorException(int responseCode, int facebookErrorCode, String facebookErrorType,
-            String message, JSONObject responseBody) {
-        super(message);
-        this.httpResponseCode = responseCode;
-        this.facebookErrorCode = facebookErrorCode;
-        this.facebookErrorType = facebookErrorType;
-        this.responseBody = responseBody;
-    }
-
-    /**
-     * Returns the HTTP response code returned by Facebook.
-     * @return the HTTP response code returned by Facebook
-     */
-    public final int getHttpResponseCode() {
-        return this.httpResponseCode;
-    }
-
-    /**
-     * Returns the error code returned by Facebook.
-     * @return the error code returned by Facebook
-     */
-    public final int getFacebookErrorCode() {
-        return this.facebookErrorCode;
-    }
-
-    /**
-     * Returns the error type returned by Facebook.
-     * @return the error type returned by Facebook
-     */
-    public final String getFacebookErrorType() {
-        return this.facebookErrorType;
-    }
-
-    /**
-     * Returns the complete error response returned by Facebook.
-     * @return the complete error resposne returned by Facebook
-     */
-    public final JSONObject getResponseBody() {
-        return this.responseBody;
-    }
-
-    /**
-     * Returns a debugging string.
-     */
-    @Override
-    public final String toString() {
-        return new StringBuilder().append("{FacebookServiceErrorException: ").append("httpResponseCode: ")
-                .append(this.httpResponseCode).append(", facebookErrorCode: ").append(this.facebookErrorCode)
-                .append(", facebookErrorType: ").append(this.facebookErrorType).append(", message: ")
-                .append(this.getMessage()).append("}").toString();
-    }
-
-}
diff --git a/facebook/src/com/facebook/FacebookServiceException.java b/facebook/src/com/facebook/FacebookServiceException.java
new file mode 100644
index 000000000..d8a342941
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookServiceException.java
@@ -0,0 +1,63 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Represents an error returned from the Facebook service in response to a request.
+ */
+public class FacebookServiceException extends FacebookException {
+
+    private final FacebookRequestError error;
+
+    private static final long serialVersionUID = 1;
+
+    /**
+     * Constructs a new FacebookServiceException.
+     *
+     * @param error the error from the request
+     */
+    public FacebookServiceException(FacebookRequestError error, String errorMessage) {
+        super(errorMessage);
+        this.error = error;
+    }
+
+    /**
+     * Returns an object that encapsulates complete information representing the error returned by Facebook.
+     *
+     * @return complete information representing the error.
+     */
+    public final FacebookRequestError getRequestError() {
+        return error;
+    }
+
+    @Override
+    public final String toString() {
+        return new StringBuilder()
+                .append("{FacebookServiceException: ")
+                .append("httpResponseCode: ")
+                .append(error.getRequestStatusCode())
+                .append(", facebookErrorCode: ")
+                .append(error.getErrorCode())
+                .append(", facebookErrorType: ")
+                .append(error.getErrorType())
+                .append(", message: ")
+                .append(error.getErrorMessage())
+                .append("}")
+                .toString();
+    }
+
+}
diff --git a/facebook/src/com/facebook/GetTokenClient.java b/facebook/src/com/facebook/GetTokenClient.java
new file mode 100644
index 000000000..6a284a77e
--- /dev/null
+++ b/facebook/src/com/facebook/GetTokenClient.java
@@ -0,0 +1,128 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.*;
+
+final class GetTokenClient implements ServiceConnection {
+    final Context context;
+    final String applicationId;
+    final Handler handler;
+    CompletedListener listener;
+    boolean running;
+    Messenger sender;
+
+    GetTokenClient(Context context, String applicationId) {
+        Context applicationContext = context.getApplicationContext();
+
+        this.context = (applicationContext != null) ? applicationContext : context;
+        this.applicationId = applicationId;
+
+        handler = new Handler() {
+            @Override
+            public void handleMessage(Message message) {
+                GetTokenClient.this.handleMessage(message);
+            }
+        };
+    }
+
+    void setCompletedListener(CompletedListener listener) {
+        this.listener = listener;
+    }
+
+    boolean start() {
+        Intent intent = new Intent(NativeProtocol.INTENT_ACTION_PLATFORM_SERVICE);
+        intent.addCategory(Intent.CATEGORY_DEFAULT);
+        intent = NativeProtocol.validateKatanaServiceIntent(context, intent);
+
+        if (intent == null) {
+            callback(null);
+            return false;
+        } else {
+            running = true;
+            context.bindService(intent, this, Context.BIND_AUTO_CREATE);
+            return true;
+        }
+    }
+
+    void cancel() {
+        running = false;
+    }
+
+    @Override
+    public void onServiceConnected(ComponentName name, IBinder service) {
+        sender = new Messenger(service);
+        getToken();
+    }
+
+    @Override
+    public void onServiceDisconnected(ComponentName name) {
+        sender = null;
+        context.unbindService(this);
+        callback(null);
+    }
+
+    private void getToken() {
+        Bundle data = new Bundle();
+        data.putString(NativeProtocol.EXTRA_APPLICATION_ID, applicationId);
+
+        Message request = Message.obtain(null, NativeProtocol.MESSAGE_GET_ACCESS_TOKEN_REQUEST);
+        request.arg1 = NativeProtocol.PROTOCOL_VERSION_20121101;
+        request.setData(data);
+        request.replyTo = new Messenger(handler);
+
+        try {
+            sender.send(request);
+        } catch (RemoteException e) {
+            callback(null);
+        }
+    }
+
+    private void handleMessage(Message message) {
+        if (message.what == NativeProtocol.MESSAGE_GET_ACCESS_TOKEN_REPLY) {
+            Bundle extras = message.getData();
+            String errorType = extras.getString(NativeProtocol.STATUS_ERROR_TYPE);
+            if (errorType != null) {
+                callback(null);
+            } else {
+                callback(extras);
+            }
+            context.unbindService(this);
+        }
+    }
+
+    private void callback(Bundle result) {
+        if (!running) {
+            return;
+        }
+        running = false;
+
+        CompletedListener callback = listener;
+        if (callback != null) {
+            callback.completed(result);
+        }
+    }
+
+    interface CompletedListener {
+        void completed(Bundle result);
+    }
+}
diff --git a/facebook/src/com/facebook/GraphObject.java b/facebook/src/com/facebook/GraphObject.java
deleted file mode 100644
index 8597c10cf..000000000
--- a/facebook/src/com/facebook/GraphObject.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/**
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import org.json.JSONObject;
-
-import java.util.Map;
-
-/**
- * GraphObject is the primary interface used by the Facebook SDK for Android to represent objects in the Facebook
- * Social Graph and the Facebook Open Graph (OG). It is the base interface for all typed access to graph objects
- * in the SDK. No concrete classes implement GraphObject or its derived interfaces. Rather, they are implemented as
- * proxies (see the {@link GraphObjectWrapper GraphObjectWrapper} class) that provide strongly-typed property
- * getters and setters to access the underlying data. Since the primary use case for graph objects is sending and
- * receiving them over the wire to/from Facebook services, they are represented as JSONObjects. No validation is done
- * that a graph object is actually of a specific type -- any graph object can be treated as any GraphObject-derived
- * interface, and the presence or absence of specific properties determines its suitability for use as that
- * particular type of object.
- * <br/>
- */
-public interface GraphObject {
-    /**
-     * Returns a new proxy that treats this graph object as a different GraphObject-derived type.
-     * @param graphObjectClass the type of GraphObject to return
-     * @return a new instance of the GraphObject-derived-type that references the same underlying data
-     */
-    public <T extends GraphObject> T cast(Class<T> graphObjectClass);
-
-    /**
-     * Returns a Java Collections map of names and properties.  Modifying the returned map modifies the
-     * inner JSON representation.
-     * @return a Java Collections map representing the GraphObject state
-     */
-    public Map<String, Object> asMap();
-
-    /**
-     * Gets the underlying JSONObject representation of this graph object.
-     * @return the underlying JSONObject representation of this graph object
-     */
-    public JSONObject getInnerJSONObject();
-
-    /**
-     * Gets a property of the GraphObject
-     * @param propertyName the name of the property to get
-     * @return the value of the named property
-     */
-    public Object getProperty(String propertyName);
-
-    /**
-     * Sets a property of the GraphObject
-     * @param propertyName the name of the property to set
-     * @param propertyValue the value of the named property to set
-     */
-    public void setProperty(String propertyName, Object propertyValue);
-
-    /**
-     * Removes a property of the GraphObject
-     * @param propertyName the name of the property to remove
-     */
-    public void removeProperty(String propertyName);
-}
diff --git a/facebook/src/com/facebook/GraphObjectCursor.java b/facebook/src/com/facebook/GraphObjectCursor.java
deleted file mode 100644
index eccc3d4bd..000000000
--- a/facebook/src/com/facebook/GraphObjectCursor.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package com.facebook;
-
-interface GraphObjectCursor<T extends GraphObject> {
-    boolean isFromCache();
-
-    boolean areMoreObjectsAvailable();
-
-    int getCount();
-
-    int getPosition();
-
-    boolean move(int offset);
-
-    boolean moveToPosition(int position);
-
-    boolean moveToFirst();
-
-    boolean moveToLast();
-
-    boolean moveToNext();
-
-    boolean moveToPrevious();
-
-    boolean isFirst();
-
-    boolean isLast();
-
-    boolean isBeforeFirst();
-
-    boolean isAfterLast();
-
-    T getGraphObject();
-
-    void close();
-
-    boolean isClosed();
-}
diff --git a/facebook/src/com/facebook/GraphObjectWrapper.java b/facebook/src/com/facebook/GraphObjectWrapper.java
deleted file mode 100644
index 7656c363b..000000000
--- a/facebook/src/com/facebook/GraphObjectWrapper.java
+++ /dev/null
@@ -1,661 +0,0 @@
-/**
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.lang.reflect.*;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.*;
-
-/**
- * Creates proxies that implement GraphObject, GraphObjectList, and their derived types. These proxies allow access
- * to underlying collections and name/value property bags via strongly-typed property getters and setters.
- * <p/>
- * This supports get/set properties that use primitive types, JSON types, Date, other GraphObject types, Iterable,
- * Collection, List, and GraphObjectList.
- */
-public final class GraphObjectWrapper {
-    private static final HashSet<Class<?>> verifiedGraphObjectClasses = new HashSet<Class<?>>();
-    private static final SimpleDateFormat[] dateFormats = new SimpleDateFormat[] {
-            new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.US),
-            new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.US), new SimpleDateFormat("yyyy-MM-dd", Locale.US), };
-
-    // No objects of this type should exist.
-    private GraphObjectWrapper() {
-    }
-
-    /**
-     * Creates a GraphObject proxy that provides typed access to the data in an underlying JSONObject.
-     * @param json the JSONObject containing the data to be exposed
-     * @return a GraphObject that represents the underlying data
-     *
-     * @throws FacebookException
-     *            If the passed in Class is not a valid GraphObject interface
-     */
-    public static GraphObject createGraphObject(JSONObject json) {
-        return createGraphObject(json, GraphObject.class);
-    }
-
-    /**
-     * Creates a GraphObject-derived proxy that provides typed access to the data in an underlying JSONObject.
-     * @param json the JSONObject containing the data to be exposed
-     * @param graphObjectClass the GraphObject-derived type to return
-     * @return a graphObjectClass that represents the underlying data
-     *
-     * @throws FacebookException
-     *            If the passed in Class is not a valid GraphObject interface
-     */
-    public static <T extends GraphObject> T createGraphObject(JSONObject json, Class<T> graphObjectClass) {
-        return createGraphObjectProxy(graphObjectClass, json);
-    }
-
-    /**
-     * Creates a GraphObject proxy that initially contains no data.
-     * @return a GraphObject with no data
-     *
-     * @throws FacebookException
-     *            If the passed in Class is not a valid GraphObject interface
-     */
-    public static GraphObject createGraphObject() {
-        return createGraphObject(GraphObject.class);
-    }
-
-    /**
-     * Creates a GraphObject-derived proxy that initially contains no data.
-     * @param graphObjectClass the GraphObject-derived type to return
-     * @return a graphObjectClass with no data
-     *
-     * @throws FacebookException
-     *            If the passed in Class is not a valid GraphObject interface
-     */
-    public static <T extends GraphObject> T createGraphObject(Class<T> graphObjectClass) {
-        return createGraphObjectProxy(graphObjectClass, new JSONObject());
-    }
-
-    /**
-     * Determines if two GraphObjects represent the same underlying graph object, based on their IDs.
-     * @param a a graph object
-     * @param b another graph object
-     * @return true if both graph objects have an ID and it is the same ID, false otherwise
-     */
-    public static boolean hasSameId(GraphObject a, GraphObject b) {
-        if (a == null || b == null || !a.asMap().containsKey("id") || !b.asMap().containsKey("id")) {
-            return false;
-        }
-        if (a.equals(b)) {
-            return true;
-        }
-        Object idA = a.getProperty("id");
-        Object idB = b.getProperty("id");
-        if (idA == null || idB == null || !(idA instanceof String) || !(idB instanceof String)) {
-            return false;
-        }
-        return idA.equals(idB);
-    }
-
-    static <T> GraphObjectList<T> wrapArray(JSONArray array, Class<T> objectClass) {
-        return new GraphObjectListImpl<T>(array, objectClass);
-    }
-
-    static <T> GraphObjectList<T> createArray(Class<T> objectClass) {
-        return wrapArray(new JSONArray(), objectClass);
-    }
-
-    private static <T extends GraphObject> T createGraphObjectProxy(Class<T> graphObjectClass, JSONObject state) {
-        verifyCanProxyClass(graphObjectClass);
-
-        Class<?>[] interfaces = new Class[] { graphObjectClass };
-        GraphObjectProxy graphObjectProxy = new GraphObjectProxy(state, graphObjectClass);
-
-        @SuppressWarnings("unchecked")
-        T graphObject = (T) Proxy.newProxyInstance(GraphObject.class.getClassLoader(), interfaces, graphObjectProxy);
-
-        return graphObject;
-    }
-
-    private static Map<String, Object> createGraphObjectProxyForMap(JSONObject state) {
-        Class<?>[] interfaces = new Class[]{Map.class};
-        GraphObjectProxy graphObjectProxy = new GraphObjectProxy(state, Map.class);
-
-        @SuppressWarnings("unchecked")
-        Map<String, Object> graphObject = (Map<String, Object>) Proxy
-                .newProxyInstance(GraphObject.class.getClassLoader(), interfaces, graphObjectProxy);
-
-        return graphObject;
-    }
-
-    private static synchronized <T extends GraphObject> boolean hasClassBeenVerified(Class<T> graphObjectClass) {
-        return verifiedGraphObjectClasses.contains(graphObjectClass);
-    }
-
-    private static synchronized <T extends GraphObject> void recordClassHasBeenVerified(Class<T> graphObjectClass) {
-        verifiedGraphObjectClasses.add(graphObjectClass);
-    }
-
-    private static <T extends GraphObject> void verifyCanProxyClass(Class<T> graphObjectClass) {
-        if (hasClassBeenVerified(graphObjectClass)) {
-            return;
-        }
-
-        if (!graphObjectClass.isInterface()) {
-            throw new FacebookGraphObjectException("GraphObjectWrapper can only wrap interfaces, not class: "
-                    + graphObjectClass.getName());
-        }
-
-        Method[] methods = graphObjectClass.getMethods();
-        for (Method method : methods) {
-            String methodName = method.getName();
-            int parameterCount = method.getParameterTypes().length;
-            Class<?> returnType = method.getReturnType();
-            boolean hasPropertyNameOverride = method.isAnnotationPresent(PropertyName.class);
-
-            if (method.getDeclaringClass().isAssignableFrom(GraphObject.class)) {
-                // Don't worry about any methods from GraphObject or one of its base classes.
-                continue;
-            } else if (parameterCount == 1 && returnType == Void.TYPE) {
-                if (hasPropertyNameOverride) {
-                    // If a property override is present, it MUST be valid. We don't fallback
-                    // to using the method name
-                    if (!Utility.isNullOrEmpty(method.getAnnotation(PropertyName.class).value())) {
-                        continue;
-                    }
-                } else if (methodName.startsWith("set") && methodName.length() > 3) {
-                    // Looks like a valid setter
-                    continue;
-                }
-            } else if (parameterCount == 0 && returnType != Void.TYPE) {
-                if (hasPropertyNameOverride) {
-                    // If a property override is present, it MUST be valid. We don't fallback
-                    // to using the method name
-                    if (!Utility.isNullOrEmpty(method.getAnnotation(PropertyName.class).value())) {
-                        continue;
-                    }
-                } else if (methodName.startsWith("get") && methodName.length() > 3) {
-                    // Looks like a valid getter
-                    continue;
-                }
-            }
-
-            throw new FacebookGraphObjectException("GraphObjectWrapper can't proxy method: " + method.toString());
-        }
-
-        recordClassHasBeenVerified(graphObjectClass);
-    }
-
-    // If expectedType is a generic type, expectedTypeAsParameterizedType must be provided in order to determine
-    // generic parameter types.
-    static <U> U coerceValueToExpectedType(Object value, Class<U> expectedType,
-            ParameterizedType expectedTypeAsParameterizedType) {
-        if (value == null) {
-            return null;
-        }
-
-        Class<?> valueType = value.getClass();
-        if (expectedType.isAssignableFrom(valueType)) {
-            @SuppressWarnings("unchecked")
-            U result = (U) value;
-            return result;
-        }
-
-        if (expectedType.isPrimitive()) {
-            // If the result is a primitive, let the runtime succeed or fail at unboxing it.
-            @SuppressWarnings("unchecked")
-            U result = (U) value;
-            return result;
-        }
-
-        if (GraphObject.class.isAssignableFrom(expectedType)) {
-            @SuppressWarnings("unchecked")
-            Class<? extends GraphObject> graphObjectClass = (Class<? extends GraphObject>) expectedType;
-
-            // We need a GraphObject, but we don't have one.
-            if (JSONObject.class.isAssignableFrom(valueType)) {
-                // We can wrap a JSONObject as a GraphObject.
-                @SuppressWarnings("unchecked")
-                U result = (U) createGraphObjectProxy(graphObjectClass, (JSONObject) value);
-                return result;
-            } else if (GraphObject.class.isAssignableFrom(valueType)) {
-                // We can cast a GraphObject-derived class to another GraphObject-derived class.
-                @SuppressWarnings("unchecked")
-                U result = (U) ((GraphObject) value).cast(graphObjectClass);
-                return result;
-            } else {
-                throw new FacebookGraphObjectException("Can't create GraphObject from " + valueType.getName());
-            }
-        } else if (Iterable.class.equals(expectedType) || Collection.class.equals(expectedType)
-                || List.class.equals(expectedType) || GraphObjectList.class.equals(expectedType)) {
-            if (expectedTypeAsParameterizedType == null) {
-                throw new FacebookGraphObjectException("can't infer generic type of: " + expectedType.toString());
-            }
-
-            Type[] actualTypeArguments = expectedTypeAsParameterizedType.getActualTypeArguments();
-
-            if (actualTypeArguments == null || actualTypeArguments.length != 1
-                    || !(actualTypeArguments[0] instanceof Class<?>)) {
-                throw new FacebookGraphObjectException(
-                        "Expect collection properties to be of a type with exactly one generic parameter.");
-            }
-            Class<?> collectionGenericArgument = (Class<?>) actualTypeArguments[0];
-
-            if (JSONArray.class.isAssignableFrom(valueType)) {
-                JSONArray jsonArray = (JSONArray) value;
-                @SuppressWarnings("unchecked")
-                U result = (U) wrapArray(jsonArray, collectionGenericArgument);
-                return result;
-            } else {
-                throw new FacebookGraphObjectException("Can't create Collection from " + valueType.getName());
-            }
-        } else if (String.class.equals(expectedType)) {
-            if (Number.class.isAssignableFrom(valueType)) {
-                @SuppressWarnings("unchecked")
-                U result = (U) String.format("%d", value);
-                return result;
-            }
-        } else if (Date.class.equals(expectedType)) {
-            if (String.class.isAssignableFrom(valueType)) {
-                for (SimpleDateFormat format : dateFormats) {
-                    try {
-                        Date date = format.parse((String) value);
-                        if (date != null) {
-                            @SuppressWarnings("unchecked")
-                            U result = (U) date;
-                            return result;
-                        }
-                    } catch (ParseException e) {
-                        // Keep going.
-                    }
-                }
-            }
-        }
-        throw new FacebookGraphObjectException("Can't convert type" + valueType.getName() + " to "
-                + expectedType.getName());
-    }
-
-    private static Object getUnderlyingJSONObject(Object obj) {
-        Class<?> objClass = obj.getClass();
-        if (GraphObject.class.isAssignableFrom(objClass)) {
-            GraphObject graphObject = (GraphObject) obj;
-            return graphObject.getInnerJSONObject();
-        } else if (GraphObjectList.class.isAssignableFrom(objClass)) {
-            GraphObjectList<?> graphObjectList = (GraphObjectList<?>) obj;
-            return graphObjectList.getInnerJSONArray();
-        }
-        return obj;
-    }
-
-    private abstract static class ProxyBase<STATE> implements InvocationHandler {
-        // Pre-loaded Method objects for the methods in java.lang.Object
-        private static final String EQUALS_METHOD = "equals";
-        private static final String TOSTRING_METHOD = "toString";
-
-        protected final STATE state;
-
-        protected ProxyBase(STATE state) {
-            this.state = state;
-        }
-
-        // Declared to return Object just to simplify implementation of proxy helpers.
-        protected final Object throwUnexpectedMethodSignature(Method method) {
-            throw new FacebookGraphObjectException(getClass().getName() + " got an unexpected method signature: "
-                    + method.toString());
-        }
-
-        protected final Object proxyObjectMethods(Object proxy, Method method, Object[] args) throws Throwable {
-            String methodName = method.getName();
-            if (methodName.equals(EQUALS_METHOD)) {
-                Object other = args[0];
-
-                if (other == null) {
-                    return false;
-                }
-
-                InvocationHandler handler = Proxy.getInvocationHandler(other);
-                if (!(handler instanceof GraphObjectProxy)) {
-                    return false;
-                }
-                GraphObjectProxy otherProxy = (GraphObjectProxy) handler;
-                return this.state.equals(otherProxy.state);
-            } else if (methodName.equals(TOSTRING_METHOD)) {
-                return toString();
-            }
-
-            // For others, just defer to the implementation object.
-            return method.invoke(this.state, args);
-        }
-
-    }
-
-    private final static class GraphObjectProxy extends ProxyBase<JSONObject> {
-        private static final String CLEAR_METHOD = "clear";
-        private static final String CONTAINSKEY_METHOD = "containsKey";
-        private static final String CONTAINSVALUE_METHOD = "containsValue";
-        private static final String ENTRYSET_METHOD = "entrySet";
-        private static final String GET_METHOD = "get";
-        private static final String ISEMPTY_METHOD = "isEmpty";
-        private static final String KEYSET_METHOD = "keySet";
-        private static final String PUT_METHOD = "put";
-        private static final String PUTALL_METHOD = "putAll";
-        private static final String REMOVE_METHOD = "remove";
-        private static final String SIZE_METHOD = "size";
-        private static final String VALUES_METHOD = "values";
-        private static final String CAST_METHOD = "cast";
-        private static final String CASTTOMAP_METHOD = "asMap";
-        private static final String GETPROPERTY_METHOD = "getProperty";
-        private static final String SETPROPERTY_METHOD = "setProperty";
-        private static final String REMOVEPROPERTY_METHOD = "removeProperty";
-        private static final String GETINNERJSONOBJECT_METHOD = "getInnerJSONObject";
-
-        private final Class<?> graphObjectClass;
-
-        public GraphObjectProxy(JSONObject state, Class<?> graphObjectClass) {
-            super(state);
-            this.graphObjectClass = graphObjectClass;
-        }
-
-        @Override
-        public String toString() {
-            return String.format("GraphObject{graphObjectClass=%s, state=%s}", graphObjectClass.getSimpleName(), state);
-        }
-
-        @Override
-        public final Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-            Class<?> declaringClass = method.getDeclaringClass();
-
-            if (declaringClass == Object.class) {
-                return proxyObjectMethods(proxy, method, args);
-            } else if (declaringClass == Map.class) {
-                return proxyMapMethods(method, args);
-            } else if (declaringClass == GraphObject.class) {
-                return proxyGraphObjectMethods(proxy, method, args);
-            } else if (GraphObject.class.isAssignableFrom(declaringClass)) {
-                return proxyGraphObjectGettersAndSetters(method, args);
-            }
-
-            return throwUnexpectedMethodSignature(method);
-        }
-
-        private final Object proxyMapMethods(Method method, Object[] args) {
-            String methodName = method.getName();
-            if (methodName.equals(CLEAR_METHOD)) {
-                Utility.jsonObjectClear(this.state);
-                return null;
-            } else if (methodName.equals(CONTAINSKEY_METHOD)) {
-                return this.state.has((String) args[0]);
-            } else if (methodName.equals(CONTAINSVALUE_METHOD)) {
-                return Utility.jsonObjectContainsValue(this.state, args[0]);
-            } else if (methodName.equals(ENTRYSET_METHOD)) {
-                return Utility.jsonObjectEntrySet(this.state);
-            } else if (methodName.equals(GET_METHOD)) {
-                return this.state.opt((String) args[0]);
-            } else if (methodName.equals(ISEMPTY_METHOD)) {
-                return this.state.length() == 0;
-            } else if (methodName.equals(KEYSET_METHOD)) {
-                return Utility.jsonObjectKeySet(this.state);
-            } else if (methodName.equals(PUT_METHOD)) {
-                return setJSONProperty(args);
-            } else if (methodName.equals(PUTALL_METHOD)) {
-                Map<String, Object> map = null;
-                if (args[0] instanceof Map) {
-                    @SuppressWarnings("unchecked")
-                    Map<String, Object> castMap = (Map<String, Object>) args[0];
-                    map = castMap;
-                } else if (args[0] instanceof GraphObject) {
-                    map = ((GraphObject) args[0]).asMap();
-                }
-                Utility.jsonObjectPutAll(this.state, map);
-                return null;
-            } else if (methodName.equals(REMOVE_METHOD)) {
-                this.state.remove((String) args[0]);
-                return null;
-            } else if (methodName.equals(SIZE_METHOD)) {
-                return this.state.length();
-            } else if (methodName.equals(VALUES_METHOD)) {
-                return Utility.jsonObjectValues(this.state);
-            }
-
-            return throwUnexpectedMethodSignature(method);
-        }
-
-        private final Object proxyGraphObjectMethods(Object proxy, Method method, Object[] args) {
-            String methodName = method.getName();
-            if (methodName.equals(CAST_METHOD)) {
-                @SuppressWarnings("unchecked")
-                Class<? extends GraphObject> graphObjectClass = (Class<? extends GraphObject>) args[0];
-
-                if (graphObjectClass != null &&
-                        graphObjectClass.isAssignableFrom(this.graphObjectClass)) {
-                    return proxy;
-                }
-                return GraphObjectWrapper.createGraphObjectProxy(graphObjectClass, this.state);
-            } else if (methodName.equals(GETINNERJSONOBJECT_METHOD)) {
-                InvocationHandler handler = Proxy.getInvocationHandler(proxy);
-                GraphObjectProxy otherProxy = (GraphObjectProxy) handler;
-                return otherProxy.state;
-            } else if (methodName.equals(CASTTOMAP_METHOD)) {
-                return GraphObjectWrapper.createGraphObjectProxyForMap(this.state);
-            } else if (methodName.equals(GETPROPERTY_METHOD)) {
-                return state.opt((String) args[0]);
-            } else if (methodName.equals(SETPROPERTY_METHOD)) {
-                return setJSONProperty(args);
-            } else if (methodName.equals(REMOVEPROPERTY_METHOD)) {
-                this.state.remove((String) args[0]);
-                return null;
-            }
-
-            return throwUnexpectedMethodSignature(method);
-        }
-
-        private final Object proxyGraphObjectGettersAndSetters(Method method, Object[] args) throws JSONException {
-            String methodName = method.getName();
-            int parameterCount = method.getParameterTypes().length;
-            PropertyName propertyNameOverride = method.getAnnotation(PropertyName.class);
-
-            String key = propertyNameOverride != null ? propertyNameOverride.value() :
-                    Utility.convertCamelCaseToLowercaseWithUnderscores(methodName.substring(3));
-
-            // If it's a get or a set on a GraphObject-derived class, we can handle it.
-            if (parameterCount == 0) {
-                // Has to be a getter. ASSUMPTION: The GraphObject-derived class has been verified
-                Object value = this.state.opt(key);
-
-                Class<?> expectedType = method.getReturnType();
-
-                Type genericReturnType = method.getGenericReturnType();
-                ParameterizedType parameterizedReturnType = null;
-                if (genericReturnType instanceof ParameterizedType) {
-                    parameterizedReturnType = (ParameterizedType) genericReturnType;
-                }
-
-                value = coerceValueToExpectedType(value, expectedType, parameterizedReturnType);
-
-                return value;
-            } else if (parameterCount == 1) {
-                // Has to be a setter. ASSUMPTION: The GraphObject-derived class has been verified
-                Object value = args[0];
-                // If this is a wrapped object, store the underlying JSONObject instead, in order to serialize
-                // correctly.
-                if (GraphObject.class.isAssignableFrom(value.getClass())) {
-                    value = ((GraphObject) value).getInnerJSONObject();
-                } else if (GraphObjectList.class.isAssignableFrom(value.getClass())) {
-                    value = ((GraphObjectList<?>) value).getInnerJSONArray();
-                } else if (Iterable.class.isAssignableFrom(value.getClass())) {
-                    JSONArray jsonArray = new JSONArray();
-                    Iterable<?> iterable = (Iterable<?>) value;
-                    for (Object o : iterable ) {
-                        if (GraphObject.class.isAssignableFrom(o.getClass())) {
-                            jsonArray.put(((GraphObject)o).getInnerJSONObject());
-                        } else {
-                            jsonArray.put(o);
-                        }
-                    }
-                    value = jsonArray;
-                }
-                this.state.putOpt(key, value);
-                return null;
-            }
-
-            return throwUnexpectedMethodSignature(method);
-        }
-
-        private Object setJSONProperty(Object[] args) {
-            String name = (String) args[0];
-            Object property = args[1];
-            Object value = getUnderlyingJSONObject(property);
-            try {
-                state.putOpt(name, value);
-            } catch (JSONException e) {
-                throw new IllegalArgumentException(e);
-            }
-            return null;
-        }
-    }
-
-    private final static class GraphObjectListImpl<T> extends AbstractList<T> implements GraphObjectList<T> {
-        private final JSONArray state;
-        private final Class<?> itemType;
-
-        public GraphObjectListImpl(JSONArray state, Class<?> itemType) {
-            Validate.notNull(state, "state");
-            Validate.notNull(itemType, "itemType");
-
-            this.state = state;
-            this.itemType = itemType;
-        }
-
-        @Override
-        public String toString() {
-            return String.format("GraphObjectList{itemType=%s, state=%s}", itemType.getSimpleName(), state);
-        }
-
-        @Override
-        public void add(int location, T object) {
-            // We only support adding at the end of the list, due to JSONArray restrictions.
-            if (location < 0) {
-                throw new IndexOutOfBoundsException();
-            } else if (location < size()) {
-                throw new UnsupportedOperationException("Only adding items at the end of the list is supported.");
-            }
-
-            put(location, object);
-        }
-
-        @Override
-        public T set(int location, T object) {
-            checkIndex(location);
-
-            T result = get(location);
-            put(location, object);
-            return result;
-        }
-
-        @Override
-        public int hashCode() {
-            return state.hashCode();
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-            if (this == obj)
-                return true;
-            if (getClass() != obj.getClass()) {
-                return false;
-            }
-            @SuppressWarnings("unchecked")
-            GraphObjectListImpl<T> other = (GraphObjectListImpl<T>) obj;
-            return state.equals(other.state);
-        }
-
-        @SuppressWarnings("unchecked")
-        @Override
-        public T get(int location) {
-            checkIndex(location);
-
-            Object value = state.opt(location);
-
-            // Class<?> expectedType = method.getReturnType();
-            // Type genericType = method.getGenericReturnType();
-            T result = (T) coerceValueToExpectedType(value, itemType, null);
-
-            return result;
-        }
-
-        @Override
-        public int size() {
-            return state.length();
-        }
-
-        @Override
-        public final <U extends GraphObject> GraphObjectList<U> castToListOf(Class<U> graphObjectClass) {
-            if (GraphObject.class.isAssignableFrom(itemType)) {
-                if (graphObjectClass.isAssignableFrom(itemType)) {
-                    @SuppressWarnings("unchecked")
-                    GraphObjectList<U> result = (GraphObjectList<U>)this;
-                    return result;
-                }
-
-                return wrapArray(state, graphObjectClass);
-            } else {
-                throw new FacebookGraphObjectException("Can't cast GraphObjectCollection of non-GraphObject type "
-                        + itemType);
-            }
-        }
-
-        @Override
-        public final JSONArray getInnerJSONArray() {
-            return state;
-        }
-
-        @Override
-        public void clear() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public boolean remove(Object o) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public boolean removeAll(Collection<?> c) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public boolean retainAll(Collection<?> c) {
-            throw new UnsupportedOperationException();
-        }
-
-        private void checkIndex(int index) {
-            if (index < 0 || index >= state.length()) {
-                throw new IndexOutOfBoundsException();
-            }
-        }
-
-        private void put(int index, T obj) {
-            Object underlyingObject = getUnderlyingJSONObject(obj);
-            try {
-                state.put(index, underlyingObject);
-            } catch (JSONException e) {
-                throw new IllegalArgumentException(e);
-            }
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/ImageDownloader.java b/facebook/src/com/facebook/ImageDownloader.java
deleted file mode 100644
index 42d7f1b49..000000000
--- a/facebook/src/com/facebook/ImageDownloader.java
+++ /dev/null
@@ -1,75 +0,0 @@
-package com.facebook;
-
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.os.AsyncTask;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URL;
-import java.util.EnumSet;
-
-class ImageDownloader {
-
-    /**
-     * Downloads the image specified in the passed in request.
-     * If a callback is specified, it is guaranteed to be invoked on the calling thread.
-     * @param request Request to process
-     */
-    static void downloadAsync(ImageRequest request) {
-        ImageDownloadTask downloadTask = new ImageDownloadTask();
-        downloadTask.execute(request);
-    }
-
-    private static class ImageDownloadTask extends AsyncTask<ImageRequest, Void, ImageResponse> {
-        @Override
-        protected ImageResponse doInBackground(ImageRequest... requests) {
-            Bitmap bitmap = null;
-            Exception error = null;
-            ImageRequest request = requests[0];
-            boolean isCachedRedirect = false;
-
-            if (!request.isCancelled()) {
-                URL url = request.getImageUrl();
-                InputStream stream = null;
-                try {
-                    if (request.isCachedRedirectAllowed()) {
-                        stream = ImageResponseCache.getCachedImageStream(
-                                url,
-                                request.getContext(),
-                                EnumSet.of(ImageResponseCache.Options.FOLLOW_REDIRECTS));
-                        isCachedRedirect = stream != null;
-                    }
-
-                    if (!isCachedRedirect) {
-                        stream = ImageResponseCache.getImageStream(
-                                url,
-                                request.getContext(),
-                                ImageResponseCache.Options.NONE);
-                    }
-
-                    if (stream != null) {
-                        bitmap = BitmapFactory.decodeStream(stream);
-                    }
-                } catch (IOException e) {
-                    error = e;
-                } finally {
-                    Utility.closeQuietly(stream);
-                }
-            }
-
-            return new ImageResponse(request, error, isCachedRedirect, bitmap);
-        }
-
-        @Override
-        protected void onPostExecute(ImageResponse response) {
-            super.onPostExecute(response);
-
-            ImageRequest request = response.getRequest();
-            ImageRequest.Callback callback = request.getCallback();
-            if (!request.isCancelled() && callback != null) {
-                callback.onCompleted(response);
-            }
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/ImageRequest.java b/facebook/src/com/facebook/ImageRequest.java
deleted file mode 100644
index 3b68b5f2e..000000000
--- a/facebook/src/com/facebook/ImageRequest.java
+++ /dev/null
@@ -1,101 +0,0 @@
-package com.facebook;
-
-import android.content.Context;
-import android.net.Uri;
-
-import java.net.MalformedURLException;
-import java.net.URL;
-
-class ImageRequest {
-
-    interface Callback {
-        void onCompleted(ImageResponse response);
-    }
-
-    static final int UNSPECIFIED_DIMENSION = 0;
-
-    private static final String PROFILEPIC_URL_FORMAT =
-            "https://graph.facebook.com/%s/picture";
-    private static final String HEIGHT_PARAM = "height";
-    private static final String WIDTH_PARAM = "width";
-    private static final String MIGRATION_PARAM = "migration_overrides";
-    private static final String MIGRATION_VALUE = "{october_2012:true}";
-
-    private Context context;
-    private URL imageUrl;
-    private Callback callback;
-    private boolean isCancelled;
-    private boolean allowCachedRedirects;
-
-    static ImageRequest createProfilePictureImageRequest(
-            Context context,
-            String userId,
-            int width,
-            int height,
-            boolean allowCachedImage,
-            Callback callback)
-        throws MalformedURLException {
-
-        Validate.notNullOrEmpty(userId, "userId");
-
-        width = Math.max(width, UNSPECIFIED_DIMENSION);
-        height = Math.max(height, UNSPECIFIED_DIMENSION);
-
-        if (width == UNSPECIFIED_DIMENSION && height == UNSPECIFIED_DIMENSION) {
-            throw new IllegalArgumentException("Either width or height must be greater than 0");
-        }
-
-        Uri.Builder builder = new Uri.Builder().encodedPath(String.format(PROFILEPIC_URL_FORMAT, userId));
-
-        if (height != UNSPECIFIED_DIMENSION) {
-            builder.appendQueryParameter(HEIGHT_PARAM, String.valueOf(height));
-        }
-
-        if (width != UNSPECIFIED_DIMENSION) {
-            builder.appendQueryParameter(WIDTH_PARAM, String.valueOf(width));
-        }
-
-        builder.appendQueryParameter(MIGRATION_PARAM, MIGRATION_VALUE);
-
-        return new ImageRequest(context, new URL(builder.toString()), allowCachedImage, callback);
-    }
-
-    ImageRequest(Context context, URL imageUrl, boolean allowCachedRedirects, Callback callback) {
-        Validate.notNull(imageUrl, "imageUrl");
-        this.context = context;
-        this.imageUrl = imageUrl;
-        this.callback = callback;
-        this.allowCachedRedirects = allowCachedRedirects;
-    }
-
-    Context getContext() {
-        return context;
-    }
-
-    URL getImageUrl() {
-        return imageUrl;
-    }
-
-    Callback getCallback() {
-        return callback;
-    }
-
-    /**
-     * Will prevent the registered callback from firing.
-     * This method is only reliable when called from the UI thread. If you cancel a request
-     * from a non-UI thread, the registered callback may be invoked. For multi-threaded
-     * scenarios, it is best to check whether the ImageRequest has been cancelled in the
-     * callback.
-     */
-    void cancel() {
-        isCancelled = true;
-    }
-
-    boolean isCancelled() {
-        return isCancelled;
-    }
-
-    boolean isCachedRedirectAllowed() {
-        return allowCachedRedirects;
-    }
-}
diff --git a/facebook/src/com/facebook/ImageResponseCache.java b/facebook/src/com/facebook/ImageResponseCache.java
deleted file mode 100644
index 252f622a1..000000000
--- a/facebook/src/com/facebook/ImageResponseCache.java
+++ /dev/null
@@ -1,230 +0,0 @@
-/**
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.content.Context;
-import android.util.Log;
-
-import java.io.BufferedInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.net.HttpURLConnection;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.EnumSet;
-
-class ImageResponseCache {
-    static final String TAG = ImageResponseCache.class.getSimpleName();
-    private static final String REDIRECT_CONTENT_TAG = TAG + "_Redirect";
-
-    private volatile static FileLruCache imageCache;
-
-    static InputStream getCachedImageStream(URL url, Context context) {
-        return getCachedImageStream(url, context, Options.NONE);
-    }
-
-    // Get stream from cache, or return null if the image is not cached.
-    // Does not throw if there was an error.
-    static InputStream getCachedImageStream(URL url, Context context, EnumSet<Options> options) {
-        InputStream imageStream = null;
-        if (url != null) {
-            if (options.contains(Options.FOLLOW_REDIRECTS)) {
-                url = getRedirectedURL(context, url.toString());
-            }
-
-            if (isCDNURL(url)) {
-                try {
-                    FileLruCache cache = getCache(context);
-                    imageStream = cache.get(url.toString());
-                } catch (IOException e) {
-                    Logger.log(LoggingBehaviors.CACHE, Log.WARN, TAG, e.toString());
-                }
-            }
-        }
-
-        return imageStream;
-    }
-
-    synchronized static FileLruCache getCache(Context context) throws IOException{
-        if (imageCache == null) {
-            imageCache = new FileLruCache(context.getApplicationContext(), TAG, new FileLruCache.Limits());
-        }
-        return imageCache;
-    }
-
-    static InputStream getImageStream(URL url, Context context) throws IOException {
-        return getImageStream(
-                url,
-                context,
-                EnumSet.of(Options.FOLLOW_REDIRECTS, Options.RETURN_STREAM_ON_HTTP_ERROR));
-    }
-
-    // Get stream from cache if present, otherwise get from web.
-    // If not cached and the uri points to a CDN, store the result in cache.
-    static InputStream getImageStream(URL url, Context context, EnumSet<Options> options) throws IOException {
-        Validate.notNull(url, "url");
-        Validate.notNull(context, "context");
-
-        InputStream stream = null;
-        boolean performRequest = true;
-        while (performRequest) {
-            performRequest = false;
-            // See if the url has been cached
-            stream = getCachedImageStream(url, context);
-            if (stream != null) {
-                break;
-            }
-
-            // Since it isn't cached, make the network call
-            HttpURLConnection connection = (HttpURLConnection)url.openConnection();
-            connection.setInstanceFollowRedirects(options.contains(Options.FOLLOW_REDIRECTS));
-
-            switch (connection.getResponseCode()) {
-                case HttpURLConnection.HTTP_MOVED_PERM:
-                case HttpURLConnection.HTTP_MOVED_TEMP:
-                    // redirect. So we need to perform further requests
-                    String redirectLocation = connection.getHeaderField("location");
-                    if (!Utility.isNullOrEmpty(redirectLocation)) {
-                        cacheImageRedirect(context, url, redirectLocation);
-                        url = new URL(redirectLocation);
-                        performRequest = true;
-                    }
-                    break;
-
-                case HttpURLConnection.HTTP_OK:
-                    // image should be available
-                    stream = cacheImageFromStream(
-                            context,
-                            url,
-                            new BufferedHttpInputStream(connection.getInputStream(), connection));
-                    break;
-
-                default:
-                    if (options.contains(Options.RETURN_STREAM_ON_HTTP_ERROR)) {
-                        // If response is not HTTP_OK, return error stream
-                        stream = new BufferedHttpInputStream(connection.getErrorStream(), connection);
-                    }
-                    break;
-            }
-        }
-
-        return stream;
-    }
-
-    private static InputStream cacheImageFromStream(Context context, URL url, InputStream stream) {
-        if (isCDNURL(url)) {
-            try {
-                FileLruCache cache = getCache(context);
-
-                // Wrap stream with a caching stream
-                stream = cache.interceptAndPut(url.toString(), stream);
-            } catch (IOException e) {
-                // Caching is best effort
-            }
-        }
-        return stream;
-    }
-
-    private static void cacheImageRedirect(Context context, URL fromUrl, String toUrl) {
-        OutputStream redirectStream = null;
-        try {
-            FileLruCache cache = getCache(context);
-            redirectStream = cache.openPutStream(fromUrl.toString(), REDIRECT_CONTENT_TAG);
-            redirectStream.write(toUrl.getBytes());
-        } catch (IOException e) {
-            // Caching is best effort
-        } finally {
-            Utility.closeQuietly(redirectStream);
-        }
-    }
-
-    private static URL getRedirectedURL(Context context, String url) {
-        URL finalUrl = null;
-        InputStreamReader reader = null;
-        try {
-            InputStream stream;
-            FileLruCache cache = getCache(context);
-            boolean redirectExists = false;
-            while ((stream = cache.get(url, REDIRECT_CONTENT_TAG)) != null) {
-                redirectExists = true;
-
-                // Get the redirected url
-                reader = new InputStreamReader(stream);
-                char[] buffer = new char[128];
-                int bufferLength;
-                StringBuilder urlBuilder = new StringBuilder();
-                while ((bufferLength = reader.read(buffer, 0, buffer.length)) > 0) {
-                    urlBuilder.append(buffer, 0, bufferLength);
-                }
-                Utility.closeQuietly(reader);
-
-                // Iterate to the next url in the redirection
-                url = urlBuilder.toString();
-            }
-
-            if (redirectExists) {
-                finalUrl = new URL(url);
-            }
-        } catch (MalformedURLException e) {
-            // caching is best effort, so ignore the exception
-        } catch (IOException ioe) {
-        } finally {
-            Utility.closeQuietly(reader);
-        }
-
-        return finalUrl;
-    }
-
-    private static boolean isCDNURL(URL url) {
-        if (url != null) {
-            String uriHost = url.getHost();
-
-            if (uriHost.endsWith("fbcdn.net")) {
-                return true;
-            }
-
-            if (uriHost.startsWith("fbcdn") && uriHost.endsWith("akamaihd.net")) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    private static class BufferedHttpInputStream extends BufferedInputStream {
-        HttpURLConnection connection;
-        BufferedHttpInputStream(InputStream stream, HttpURLConnection connection) {
-            super(stream, Utility.DEFAULT_STREAM_BUFFER_SIZE);
-            this.connection = connection;
-        }
-
-        @Override
-        public void close() throws IOException {
-            super.close();
-            Utility.disconnectQuietly(connection);
-        }
-    }
-
-    enum Options {
-        FOLLOW_REDIRECTS,
-        RETURN_STREAM_ON_HTTP_ERROR;
-        public static final EnumSet<Options> NONE = EnumSet.noneOf(Options.class);
-    }
-}
-
diff --git a/facebook/src/com/facebook/LegacyHelper.java b/facebook/src/com/facebook/LegacyHelper.java
new file mode 100644
index 000000000..afcda0b26
--- /dev/null
+++ b/facebook/src/com/facebook/LegacyHelper.java
@@ -0,0 +1,31 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.os.Bundle;
+
+/**
+ * LegacyHelper is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the methods in this class is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public class LegacyHelper {
+    @Deprecated
+    public static void extendTokenCompleted(Session session, Bundle bundle) {
+        session.extendTokenCompleted(bundle);
+    }
+}
diff --git a/facebook/src/com/facebook/LoggingBehaviors.java b/facebook/src/com/facebook/LoggingBehavior.java
similarity index 93%
rename from facebook/src/com/facebook/LoggingBehaviors.java
rename to facebook/src/com/facebook/LoggingBehavior.java
index 9b8eda90c..621bf64f8 100644
--- a/facebook/src/com/facebook/LoggingBehaviors.java
+++ b/facebook/src/com/facebook/LoggingBehavior.java
@@ -19,9 +19,9 @@
 /**
  * Specifies different categories of logging messages that can be generated.
  *
- * @see Settings#addLoggingBehavior(LoggingBehaviors)
+ * @see Settings#addLoggingBehavior(LoggingBehavior)
  */
-public enum LoggingBehaviors {
+public enum LoggingBehavior {
     /**
      * Indicates that HTTP requests and a summary of responses should be logged.
      */
diff --git a/facebook/src/com/facebook/LoginActivity.java b/facebook/src/com/facebook/LoginActivity.java
index 5b17da788..2b45eeb08 100644
--- a/facebook/src/com/facebook/LoginActivity.java
+++ b/facebook/src/com/facebook/LoginActivity.java
@@ -1,127 +1,142 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook;
 
-import android.Manifest;
 import android.app.Activity;
-import android.app.AlertDialog;
-import android.app.Dialog;
-import android.content.DialogInterface;
 import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.net.Uri;
 import android.os.Bundle;
-import android.webkit.CookieSyncManager;
-import com.facebook.android.*;
+import android.view.View;
+import com.facebook.android.R;
 
 /**
- * This class addresses the issue of a potential window leak during
- * dialog authorization if the Activity containing the dialog is destroyed
- * (e.g. if the user rotates the device).
- * <p/>
- * Add this activity to your AndroidManifest.xml to ensure proper handling
- * of dialog authorization.
+ * This Activity is a necessary part of the overall Facebook login process
+ * but is not meant to be used directly. Add this activity to your
+ * AndroidManifest.xml to ensure proper handling of Facebook login.
+ * <pre>
+ * {@code
+ * <activity android:name="com.facebook.LoginActivity"
+ *           android:theme="@android:style/Theme.Translucent.NoTitleBar"
+ *           android:label="@string/app_name" />
+ * }
+ * </pre>
+ * Do not start this activity directly.
  */
 public class LoginActivity extends Activity {
-    private Dialog loginDialog;
-    private Dialog errorDialog;
+    static final String RESULT_KEY = "com.facebook.LoginActivity:Result";
+
+    private static final String NULL_CALLING_PKG_ERROR_MSG =
+            "Cannot call LoginActivity with a null calling package. " +
+                    "This can occur if the launchMode of the caller is singleInstance.";
+    private static final String SAVED_CALLING_PKG_KEY = "callingPackage";
+    private static final String SAVED_AUTH_CLIENT = "authorizationClient";
+    private static final String EXTRA_REQUEST = "request";
+
+    private String callingPackage;
+    private AuthorizationClient authorizationClient;
+    private AuthorizationClient.AuthorizationRequest request;
 
     @Override
-    public void onResume() {
-        super.onResume();
-        int permissionCheck = checkCallingOrSelfPermission(Manifest.permission.INTERNET);
-        if (permissionCheck != PackageManager.PERMISSION_GRANTED) {
-            AlertDialog.Builder builder = new AlertDialog.Builder(this);
-            builder.setTitle("AndroidManifest Error")
-                   .setMessage("WebView login requires INTERNET permission")
-                   .setCancelable(true)
-                   .setPositiveButton(R.string.com_facebook_dialogloginactivity_ok_button,
-                           new DialogInterface.OnClickListener() {
-                               @Override
-                               public void onClick(DialogInterface dialogInterface, int i) {
-                                   finish();
-                               }
-                           })
-                   .setOnCancelListener(new DialogInterface.OnCancelListener() {
-                       @Override
-                       public void onCancel(DialogInterface dialogInterface) {
-                           finish();
-                       }
-                   });
-            errorDialog = builder.create();
-            errorDialog.show();
-            setResult(Activity.RESULT_CANCELED);
-            return;
-        }
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.com_facebook_login_activity_layout);
 
-        Bundle parameters = new Bundle();
-        String permissions = getIntent().getStringExtra("scope");
-        if (!Utility.isNullOrEmpty(permissions)) {
-            parameters.putString(ServerProtocol.DIALOG_PARAM_SCOPE, permissions);
+        if (savedInstanceState != null) {
+            callingPackage = savedInstanceState.getString(SAVED_CALLING_PKG_KEY);
+            authorizationClient = (AuthorizationClient) savedInstanceState.getSerializable(SAVED_AUTH_CLIENT);
+        } else {
+            callingPackage = getCallingPackage();
+            authorizationClient = new AuthorizationClient();
+            request = (AuthorizationClient.AuthorizationRequest) getIntent().getSerializableExtra(EXTRA_REQUEST);
         }
 
-        // The call to clear cookies will create the first instance of CookieSyncManager if necessary
-        Utility.clearFacebookCookies(this);
-
-        Facebook.DialogListener listener = new Facebook.DialogListener() {
-            public void onComplete(Bundle bundle) {
-                // Ensure any cookies set by the dialog are saved
-                CookieSyncManager.getInstance().sync();
-                setResultAndFinish(Activity.RESULT_OK, bundle);
+        authorizationClient.setContext(this);
+        authorizationClient.setOnCompletedListener(new AuthorizationClient.OnCompletedListener() {
+            @Override
+            public void onCompleted(AuthorizationClient.Result outcome) {
+                onAuthClientCompleted(outcome);
             }
-
-            public void onError(DialogError error) {
-                Bundle bundle = null;
-                if (error != null) {
-                    bundle = new Bundle();
-                    bundle.putInt(Session.WEB_VIEW_ERROR_CODE_KEY, error.getErrorCode());
-                    bundle.putString(Session.WEB_VIEW_FAILING_URL_KEY, error.getFailingUrl());
-                    bundle.putString("error", error.getMessage());
-                }
-                setResultAndFinish(Activity.RESULT_OK, bundle);
+        });
+        authorizationClient.setBackgroundProcessingListener(new AuthorizationClient.BackgroundProcessingListener() {
+            @Override
+            public void onBackgroundProcessingStarted() {
+                findViewById(R.id.com_facebook_login_activity_progress_bar).setVisibility(View.VISIBLE);
             }
 
-            public void onFacebookError(FacebookError error) {
-                Bundle bundle = null;
-                if (error != null && error.getMessage() != null) {
-                    bundle = new Bundle();
-                    bundle.putString("error", error.getMessage());
-                }
-                setResultAndFinish(Activity.RESULT_OK, bundle);
+            @Override
+            public void onBackgroundProcessingStopped() {
+                findViewById(R.id.com_facebook_login_activity_progress_bar).setVisibility(View.GONE);
             }
+        });
+    }
 
-            public void onCancel() {
-                setResultAndFinish(Activity.RESULT_CANCELED, null);
-            }
+    private void onAuthClientCompleted(AuthorizationClient.Result outcome) {
+        request = null;
 
-            private void setResultAndFinish(int resultCode, Bundle bundle) {
-                if (bundle != null) {
-                    Intent intent = new Intent();
-                    intent.putExtras(bundle);
-                    setResult(resultCode, intent);
-                } else {
-                    setResult(resultCode);
-                }
-                finish();
-            }
-        };
+        int resultCode = (outcome.code == AuthorizationClient.Result.Code.CANCEL) ?
+                RESULT_CANCELED : RESULT_OK;
+
+        Bundle bundle = new Bundle();
+        bundle.putSerializable(RESULT_KEY, outcome);
+
+        Intent resultIntent = new Intent();
+        resultIntent.putExtras(bundle);
+        setResult(resultCode, resultIntent);
+
+        finish();
+    }
 
-        parameters.putString(ServerProtocol.DIALOG_PARAM_DISPLAY, "touch");
-        parameters.putString(ServerProtocol.DIALOG_PARAM_REDIRECT_URI, "fbconnect://success");
-        parameters.putString(ServerProtocol.DIALOG_PARAM_TYPE, "user_agent");
-        parameters.putString(ServerProtocol.DIALOG_PARAM_CLIENT_ID, getIntent().getStringExtra("client_id"));
+    @Override
+    public void onResume() {
+        super.onResume();
+
+        // If the calling package is null, this generally means that the callee was started
+        // with a launchMode of singleInstance. Unfortunately, Android does not allow a result
+        // to be set when the callee is a singleInstance, so we throw an exception here.
+        if (callingPackage == null) {
+            throw new FacebookException(NULL_CALLING_PKG_ERROR_MSG);
+        }
 
-        Uri uri = Utility.buildUri(ServerProtocol.DIALOG_AUTHORITY, ServerProtocol.DIALOG_OAUTH_PATH, parameters);
-        loginDialog = new FbDialog(this, uri.toString(), listener);
-        loginDialog.show();
+        authorizationClient.startOrContinueAuth(request);
     }
 
     @Override
     public void onPause() {
         super.onPause();
-        if (errorDialog != null && errorDialog.isShowing()) {
-            errorDialog.dismiss();
-        }
-        if (loginDialog != null && loginDialog.isShowing()) {
-            loginDialog.dismiss();
-        }
+
+        authorizationClient.cancelCurrentHandler();
+        findViewById(R.id.com_facebook_login_activity_progress_bar).setVisibility(View.GONE);
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        outState.putString(SAVED_CALLING_PKG_KEY, callingPackage);
+        outState.putSerializable(SAVED_AUTH_CLIENT, authorizationClient);
+    }
+
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        authorizationClient.onActivityResult(requestCode, resultCode, data);
+    }
+
+    static Bundle populateIntentExtras(AuthorizationClient.AuthorizationRequest request) {
+        Bundle extras = new Bundle();
+        extras.putSerializable(EXTRA_REQUEST, request);
+        return extras;
     }
 }
diff --git a/facebook/src/com/facebook/NativeProtocol.java b/facebook/src/com/facebook/NativeProtocol.java
index ab6627f5a..c416b37f0 100644
--- a/facebook/src/com/facebook/NativeProtocol.java
+++ b/facebook/src/com/facebook/NativeProtocol.java
@@ -16,6 +16,19 @@
 
 package com.facebook;
 
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.content.pm.Signature;
+import android.os.Bundle;
+import android.text.TextUtils;
+import com.facebook.internal.Utility;
+
+import java.util.ArrayList;
+import java.util.List;
+
 final class NativeProtocol {
     static final String KATANA_PACKAGE = "com.facebook.katana";
     static final String KATANA_PROXY_AUTH_ACTIVITY = "com.facebook.katana.ProxyAuth";
@@ -41,4 +54,201 @@
                     + "73149fb2232a10d247663b26a9031e15f84bc1c74d141ff98a02d76f85b2c8ab2"
                     + "571b6469b232d8e768a7f7ca04f7abe4a775615916c07940656b58717457b42bd"
                     + "928a2";
+    private static final String BASIC_INFO = "basic_info";
+    public static final String KATANA_PROXY_AUTH_PERMISSIONS_KEY = "scope";
+    public static final String KATANA_PROXY_AUTH_APP_ID_KEY = "client_id";
+
+    static final boolean validateSignature(Context context, String packageName) {
+        PackageInfo packageInfo = null;
+        try {
+            packageInfo = context.getPackageManager().getPackageInfo(packageName,
+                    PackageManager.GET_SIGNATURES);
+        } catch (PackageManager.NameNotFoundException e) {
+            return false;
+        }
+
+        for (Signature signature : packageInfo.signatures) {
+            if (signature.toCharsString().equals(KATANA_SIGNATURE)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    static Intent validateKatanaActivityIntent(Context context, Intent intent) {
+        if (intent == null) {
+            return null;
+        }
+
+        ResolveInfo resolveInfo = context.getPackageManager().resolveActivity(intent, 0);
+        if (resolveInfo == null) {
+            return null;
+        }
+
+        if (!validateSignature(context, resolveInfo.activityInfo.packageName)) {
+            return null;
+        }
+
+        return intent;
+    }
+
+    static Intent validateKatanaServiceIntent(Context context, Intent intent) {
+        if (intent == null) {
+            return null;
+        }
+
+        ResolveInfo resolveInfo = context.getPackageManager().resolveService(intent, 0);
+        if (resolveInfo == null) {
+            return null;
+        }
+
+        if (!validateSignature(context, resolveInfo.serviceInfo.packageName)) {
+            return null;
+        }
+
+        return intent;
+    }
+
+    static Intent createProxyAuthIntent(Context context, String applicationId, List<String> permissions) {
+        Intent intent = new Intent()
+                .setClassName(KATANA_PACKAGE, KATANA_PROXY_AUTH_ACTIVITY)
+                .putExtra(KATANA_PROXY_AUTH_APP_ID_KEY, applicationId);
+
+        if (!Utility.isNullOrEmpty(permissions)) {
+            intent.putExtra(KATANA_PROXY_AUTH_PERMISSIONS_KEY, TextUtils.join(",", permissions));
+        }
+
+        return validateKatanaActivityIntent(context, intent);
+    }
+
+    static Intent createTokenRefreshIntent(Context context) {
+        Intent intent = new Intent();
+        intent.setClassName(KATANA_PACKAGE, KATANA_TOKEN_REFRESH_ACTIVITY);
+
+        return validateKatanaServiceIntent(context, intent);
+    }
+
+    // ---------------------------------------------------------------------------------------------
+    // Native Protocol updated 2012-11
+
+    static final String INTENT_ACTION_PLATFORM_ACTIVITY = "com.facebook.platform.PLATFORM_ACTIVITY";
+    static final String INTENT_ACTION_PLATFORM_SERVICE = "com.facebook.platform.PLATFORM_SERVICE";
+
+    static final int PROTOCOL_VERSION_20121101 = 20121101;
+    static final String EXTRA_PROTOCOL_VERSION = "com.facebook.platform.protocol.PROTOCOL_VERSION";
+    static final String EXTRA_PROTOCOL_ACTION = "com.facebook.platform.protocol.PROTOCOL_ACTION";
+
+    // Messages supported by PlatformService:
+    static final int MESSAGE_GET_ACCESS_TOKEN_REQUEST = 0x10000;
+    static final int MESSAGE_GET_ACCESS_TOKEN_REPLY   = 0x10001;
+
+    // MESSAGE_ERROR_REPLY data keys:
+    // See STATUS_*
+
+    // MESSAGE_GET_ACCESS_TOKEN_REQUEST data keys:
+    // EXTRA_APPLICATION_ID
+
+    // MESSAGE_GET_ACCESS_TOKEN_REPLY data keys:
+    // EXTRA_ACCESS_TOKEN
+    // EXTRA_EXPIRES_SECONDS_SINCE_EPOCH
+    // EXTRA_PERMISSIONS
+
+    // Values of EXTRA_PROTOCOL_ACTION supported by PlatformActivity:
+    static final String ACTION_LOGIN_DIALOG = "com.facebook.platform.action.request.LOGIN_DIALOG";
+
+    // Values of EXTRA_PROTOCOL_ACTION values returned by PlatformActivity:
+    static final String ACTION_LOGIN_DIALOG_REPLY =
+            "com.facebook.platform.action.reply.LOGIN_DIALOG";
+
+    // Extras supported for ACTION_LOGIN_DIALOG:
+    static final String EXTRA_PERMISSIONS = "com.facebook.platform.extra.PERMISSIONS";
+    static final String EXTRA_WRITE_PRIVACY = "com.facebook.platform.extra.WRITE_PRIVACY";
+    static final String EXTRA_APPLICATION_ID = "com.facebook.platform.extra.APPLICATION_ID";
+
+    // Extras returned by setResult() for ACTION_LOGIN_DIALOG
+    static final String EXTRA_ACCESS_TOKEN = "com.facebook.platform.extra.ACCESS_TOKEN";
+    static final String EXTRA_EXPIRES_SECONDS_SINCE_EPOCH =
+            "com.facebook.platform.extra.EXPIRES_SECONDS_SINCE_EPOCH";
+    // EXTRA_PERMISSIONS
+
+    // Keys for status data in MESSAGE_ERROR_REPLY from PlatformService and for error
+    // extras returned by PlatformActivity's setResult() in case of errors:
+    static final String STATUS_ERROR_TYPE = "com.facebook.platform.status.ERROR_TYPE";
+    static final String STATUS_ERROR_DESCRIPTION =
+            "com.facebook.platform.status.ERROR_DESCRIPTION";
+    static final String STATUS_ERROR_CODE = "com.facebook.platform.status.ERROR_CODE";
+    static final String STATUS_ERROR_SUBCODE = "com.facebook.platform.status.ERROR_SUBCODE";
+    static final String STATUS_ERROR_JSON = "com.facebook.platform.status.ERROR_JSON";
+
+    // Expected values for ERROR_KEY_TYPE.  Clients should tolerate other values:
+    static final String ERROR_UNKNOWN_ERROR = "UnknownError";
+    static final String ERROR_PROTOCOL_ERROR = "ProtocolError";
+    static final String ERROR_USER_CANCELED = "UserCanceled";
+    static final String ERROR_APPLICATION_ERROR = "ApplicationError";
+    static final String ERROR_NETWORK_ERROR = "NetworkError";
+    static final String ERROR_PERMISSION_DENIED = "PermissionDenied";
+    static final String ERROR_SERVICE_DISABLED = "ServiceDisabled";
+
+    static final String AUDIENCE_ME = "SELF";
+    static final String AUDIENCE_FRIENDS = "ALL_FRIENDS";
+    static final String AUDIENCE_EVERYONE = "EVERYONE";
+
+    static Intent createLoginDialog20121101Intent(Context context, String applicationId, ArrayList<String> permissions,
+            String audience) {
+        Intent intent = new Intent()
+                    .setAction(INTENT_ACTION_PLATFORM_ACTIVITY)
+                    .addCategory(Intent.CATEGORY_DEFAULT)
+                    .putExtra(EXTRA_PROTOCOL_VERSION, PROTOCOL_VERSION_20121101)
+                    .putExtra(EXTRA_PROTOCOL_ACTION, ACTION_LOGIN_DIALOG)
+                    .putExtra(EXTRA_APPLICATION_ID, applicationId)
+                    .putStringArrayListExtra(EXTRA_PERMISSIONS, ensureDefaultPermissions(permissions))
+                    .putExtra(EXTRA_WRITE_PRIVACY, ensureDefaultAudience(audience));
+        return validateKatanaActivityIntent(context, intent);
+    }
+
+    private static String ensureDefaultAudience(String audience) {
+        if (Utility.isNullOrEmpty(audience)) {
+            return AUDIENCE_ME;
+        } else {
+            return audience;
+        }
+    }
+
+    private static ArrayList<String> ensureDefaultPermissions(ArrayList<String> permissions) {
+        ArrayList<String> updated;
+
+        // Return if we are doing publish, or if basic_info is already included
+        if (Utility.isNullOrEmpty(permissions)) {
+            updated = new ArrayList<String>();
+        } else {
+            for (String permission : permissions) {
+                if (Session.isPublishPermission(permission) || BASIC_INFO.equals(permission)) {
+                    return permissions;
+                }
+            }
+            updated = new ArrayList<String>(permissions);
+        }
+
+        updated.add(BASIC_INFO);
+        return updated;
+    }
+
+    static boolean isServiceDisabledResult20121101(Intent data) {
+        int protocolVersion = data.getIntExtra(EXTRA_PROTOCOL_VERSION, 0);
+        String errorType = data.getStringExtra(STATUS_ERROR_TYPE);
+
+        return ((PROTOCOL_VERSION_20121101 == protocolVersion) && ERROR_SERVICE_DISABLED.equals(errorType));
+    }
+
+    static AccessTokenSource getAccessTokenSourceFromNative(Bundle extras) {
+        long expected = PROTOCOL_VERSION_20121101;
+        long actual = extras.getInt(EXTRA_PROTOCOL_VERSION, 0);
+
+        if (expected == actual) {
+            return AccessTokenSource.FACEBOOK_APPLICATION_NATIVE;
+        } else {
+            return AccessTokenSource.FACEBOOK_APPLICATION_WEB;
+        }
+    }
 }
diff --git a/facebook/src/com/facebook/NonCachingTokenCachingStrategy.java b/facebook/src/com/facebook/NonCachingTokenCachingStrategy.java
new file mode 100644
index 000000000..f055d5e92
--- /dev/null
+++ b/facebook/src/com/facebook/NonCachingTokenCachingStrategy.java
@@ -0,0 +1,39 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.os.Bundle;
+
+/**
+ * Implements a trivial {@link TokenCachingStrategy} that does not actually cache any tokens.
+ * It is intended for use when an access token may be used on a temporary basis but should not be
+ * cached for future use (for instance, when handling a deep link).
+ */
+public class NonCachingTokenCachingStrategy extends TokenCachingStrategy {
+    @Override
+    public Bundle load() {
+        return null;
+    }
+
+    @Override
+    public void save(Bundle bundle) {
+    }
+
+    @Override
+    public void clear() {
+    }
+}
diff --git a/facebook/src/com/facebook/PickerFragment.java b/facebook/src/com/facebook/PickerFragment.java
deleted file mode 100644
index 9eb911c70..000000000
--- a/facebook/src/com/facebook/PickerFragment.java
+++ /dev/null
@@ -1,244 +0,0 @@
-/**
- * Copyright 2012 Facebook
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.os.Bundle;
-
-import java.util.Collection;
-import java.util.Set;
-
-/**
- * Provides functionality common to SDK UI elements that allow the user to pick one or more
- * graph objects (e.g., places, friends) from a list of possibilities. The UI is exposed as a
- * Fragment to allow to it to be included in an Activity along with other Fragments. The Fragments
- * can be configured by passing parameters as part of their Intent bundle, or (for certain
- * properties) by specifying attributes in their XML layout files.
- * <br/>
- * PickerFragments support callbacks that will be called in the event of an error, when the
- * underlying data has been changed, or when the set of selected graph objects changes.
- */
-public interface PickerFragment<T extends GraphObject> {
-    /**
-     * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
-     * picker should show pictures (if available) for the graph objects.
-     */
-    static final String SHOW_PICTURES_BUNDLE_KEY = "com.facebook.PickerFragment.ShowPictures";
-    /**
-     * The key for a String parameter in the fragment's Intent bundle to indicate which extra fields
-     * beyond the default fields should be retrieved for any graph objects in the results.
-     */
-    static final String EXTRA_FIELDS_BUNDLE_KEY = "com.facebook.PickerFragment.ExtraFields";
-    /**
-     * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
-     * picker should display a title bar with a Done button.
-     */
-    static final String SHOW_TITLE_BAR_BUNDLE_KEY = "com.facebook.PickerFragment.ShowTitleBar";
-    /**
-     * The key for a String parameter in the fragment's Intent bundle to indicate the text to
-     * display in the title bar.
-     */
-    static final String TITLE_TEXT_BUNDLE_KEY = "com.facebook.PickerFragment.TitleText";
-    /**
-     * The key for a String parameter in the fragment's Intent bundle to indicate the text to
-     * display in the Done btuton.
-     */
-    static final String DONE_BUTTON_TEXT_BUNDLE_KEY = "com.facebook.PickerFragment.DoneButtonText";
-
-    /**
-     * Gets the current OnDataChangedListener for this fragment, which will be called whenever
-     * the underlying data being displaying in the picker has changed.
-     * @return the OnDataChangedListener, or null if there is none
-     */
-    OnDataChangedListener getOnDataChangedListener();
-
-    /**
-     * Sets the current OnDataChangedListener for this fragment, which will be called whenever
-     * the underlying data being displaying in the picker has changed.
-     * @param onDataChangedListener     the OnDataChangedListener, or null if there is none
-     */
-    void setOnDataChangedListener(OnDataChangedListener onDataChangedListener);
-
-    /**
-     * Gets the current OnSelectionChangedListener for this fragment, which will be called
-     * whenever the user selects or unselects a graph object in the list.
-     * @return the OnSelectionChangedListener, or null if there is none
-     */
-    OnSelectionChangedListener getOnSelectionChangedListener();
-
-    /**
-     * Sets the current OnSelectionChangedListener for this fragment, which will be called
-     * whenever the user selects or unselects a graph object in the list.
-     * @param onSelectionChangedListener     the OnSelectionChangedListener, or null if there is none
-     */
-    void setOnSelectionChangedListener(
-            OnSelectionChangedListener onSelectionChangedListener);
-
-    /**
-     * Gets the current OnDoneButtonClickedListener for this fragment, which will be called
-     * when the user clicks the Done button.
-     * @return the OnDoneButtonClickedListener, or null if there is none
-     */
-    OnDoneButtonClickedListener getOnDoneButtonClickedListener();
-
-    /**
-     * Sets the current OnDoneButtonClickedListener for this fragment, which will be called
-     * when the user clicks the Done button. This will only be possible if the title bar is
-     * being shown in this fragment.
-     * @param onDoneButtonClickedListener     the OnDoneButtonClickedListener, or null if there is none
-     */
-    void setOnDoneButtonClickedListener(OnDoneButtonClickedListener onDoneButtonClickedListener);
-
-    /**
-     * Gets the current OnErrorListener for this fragment, which will be called in the event
-     * of network or other errors encountered while populating the graph objects in the list.
-     * @return the OnErrorListener, or null if there is none
-     */
-    OnErrorListener getOnErrorListener();
-
-    /**
-     * Sets the current OnErrorListener for this fragment, which will be called in the event
-     * of network or other errors encountered while populating the graph objects in the list.
-     * @param onErrorListener    the OnErrorListener, or null if there is none
-     */
-    void setOnErrorListener(OnErrorListener onErrorListener);
-
-    /**
-     * Gets the current filter for this fragment, which will be called for each graph object
-     * returned from the service to determine if it should be displayed in the list.
-     * If no filter is specified, all retrieved graph objects will be displayed.
-     * @return the GraphObjectFilter, or null if there is none
-     */
-    GraphObjectFilter<T> getFilter();
-
-    /**
-     * Sets the current filter for this fragment, which will be called for each graph object
-     * returned from the service to determine if it should be displayed in the list.
-     * If no filter is specified, all retrieved graph objects will be displayed.
-     * @param filter     the GraphObjectFilter, or null if there is none
-     */
-    void setFilter(GraphObjectFilter<T> filter);
-
-    /**
-     * Gets the Session to use for any Facebook requests this fragment will make.
-     * @return the Session that will be used for any Facebook requests, or null if there is none
-     */
-    Session getSession();
-
-    /**
-     * Sets the Session to use for any Facebook requests this fragment will make. If the
-     * parameter is null, the fragment will use the current active session, if any.
-     * @param session   the Session to use for Facebook requests, or null to use the active session
-     */
-    void setSession(Session session);
-
-    /**
-     * Gets whether to display pictures, if available, for displayed graph objects.
-     * @return true if pictures should be displayed, false if not
-     */
-    boolean getShowPictures();
-
-    /**
-     * Gets whether to display pictures, if available, for displayed graph objects.
-     * @param showPictures   true if pictures should be displayed, false if not
-     */
-    void setShowPictures(boolean showPictures);
-
-    /**
-     * Gets the extra fields to request for the retrieved graph objects.
-     * @return the extra fields to request
-     */
-    Set<String> getExtraFields();
-
-    /**
-     * Sets the extra fields to request for the retrieved graph objects.
-     * @param fields     the extra fields to request
-     */
-    void setExtraFields(Collection<String> fields);
-
-    /**
-     * Causes the picker to load data from the service and display it to the user.
-     * @param forceReload if true, data will be loaded even if there is already data being displayed;
-     *                    if false, data will not be re-loaded if it is already displayed
-     */
-    void loadData(boolean forceReload);
-
-    /**
-     * Updates the properties of the PickerFragment based on the contents of the supplied Bundle;
-     * calling Activities may use this to pass additional configuration information to the
-     * PickerFragment beyond what is specified in its XML layout.
-     * @param inState   a Bundle containing keys corresponding to properties of the PickerFragment
-     */
-    void setSettingsFromBundle(Bundle inState);
-
-    /**
-     * Callback interface that will be called when a network or other error is encountered
-     * while retrieving graph objects.
-     */
-    interface OnErrorListener {
-        /**
-         * Called when a network or other error is encountered.
-         * @param error     a FacebookException representing the error that was encountered.
-         */
-        void onError(FacebookException error);
-    }
-
-    /**
-     * Callback interface that will be called when the underlying data being displayed in the
-     * picker has been updated.
-     */
-    interface OnDataChangedListener {
-        /**
-         * Called when the set of data being displayed in the picker has changed.
-         */
-        void onDataChanged();
-    }
-
-    /**
-     * Callback interface that will be called when the user selects or unselects graph objects
-     * in the picker.
-     */
-    interface OnSelectionChangedListener {
-        /**
-         * Called when the user selects or unselects graph objects in the picker.
-         */
-        void onSelectionChanged();
-    }
-
-    /**
-     * Callback interface that will be called when the user clicks the Done button on the
-     * title bar.
-     */
-    interface OnDoneButtonClickedListener {
-        /**
-         * Called when the user clicks the Done button.
-         */
-        void onDoneButtonClicked();
-    }
-
-    /**
-     * Callback interface that will be called to determine if a graph object should be displayed.
-     * @param <T>
-     */
-    interface GraphObjectFilter<T> {
-        /**
-         * Called to determine if a graph object should be displayed.
-         * @param graphObject       the graph object
-         * @return true to display the graph object, false to hide it
-         */
-        boolean includeItem(T graphObject);
-    }
-}
diff --git a/facebook/src/com/facebook/PrioritizedWorkQueue.java b/facebook/src/com/facebook/PrioritizedWorkQueue.java
deleted file mode 100644
index d67bc3f7c..000000000
--- a/facebook/src/com/facebook/PrioritizedWorkQueue.java
+++ /dev/null
@@ -1,264 +0,0 @@
-package com.facebook;
-
-import java.util.concurrent.Executor;
-
-class PrioritizedWorkQueue {
-    public static final int PRIORITY_RUNNING = -1;
-    public static final int PRIORITY_ACTIVE = 0;
-    public static final int PRIORITY_BACKGROUND = 1;
-    private static final int PRIORITY_COUNT = 2;
-    private static final int DEFAULT_MAX_CONCURRENT = 8;
-
-    private final WorkNode[] queues = new WorkNode[PRIORITY_COUNT];
-    private final int maxConcurrent;
-    private final Executor executor;
-
-    private WorkNode runningItems = null;
-    private int runningCount = 0;
-
-    PrioritizedWorkQueue() {
-        this(DEFAULT_MAX_CONCURRENT, Settings.getExecutor());
-    }
-
-    PrioritizedWorkQueue(int maxConcurrent, Executor executor) {
-        this.maxConcurrent = maxConcurrent;
-        this.executor = executor;
-    }
-
-    WorkItem addActiveWorkItem(Runnable callback) {
-        WorkNode node = new WorkNode(callback);
-        synchronized (queues) {
-            queues[node.priority] = node.addToList(queues[node.priority]);
-        }
-
-        startItem();
-        return node;
-    }
-
-    void backgroundAll() {
-        setPriorityOnAll(PRIORITY_BACKGROUND);
-    }
-
-    void validate() {
-        synchronized (queues) {
-            // Verify that priority on items agrees with the priority of the queue they are in
-            for (int priority = 0; priority < PRIORITY_COUNT; priority++) {
-                if (queues[priority] != null) {
-                    WorkNode walk = queues[priority];
-                    do {
-                        walk.verify(priority);
-                        walk = walk.getNext();
-                    } while (walk != queues[priority]);
-                }
-            }
-
-            // Verify that all running items know they are running, and counts match
-            int count = 0;
-
-            if (runningItems != null) {
-                WorkNode walk = runningItems;
-                do {
-                    walk.verify(PRIORITY_RUNNING);
-                    count++;
-                    walk = walk.getNext();
-                } while (walk != runningItems);
-            }
-
-            assert runningCount == count;
-        }
-    }
-
-    private void startItem() {
-        finishItemAndStartNew(null);
-    }
-
-    private void finishItemAndStartNew(WorkNode finished) {
-        WorkNode ready = null;
-
-        synchronized (queues) {
-            if (finished != null) {
-                runningItems = finished.removeFromList(runningItems);
-                runningCount--;
-            }
-
-            if (runningCount < maxConcurrent) {
-                ready = extractNextReadyItem();
-
-                if (ready != null) {
-                    ready.setPriorityRunning();
-                    runningItems = ready.addToList(runningItems);
-                    runningCount++;
-                }
-            }
-        }
-
-        if (ready != null) {
-            execute(ready);
-        }
-    }
-
-    private void execute(final WorkNode node) {
-        executor.execute(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    node.getCallback().run();
-                } finally {
-                    finishItemAndStartNew(node);
-                }
-            }
-        });
-    }
-
-    private WorkNode extractNextReadyItem() {
-        for (int priority = 0; priority < PRIORITY_COUNT; priority++) {
-            WorkNode ready = queues[priority];
-            if (ready != null) {
-                queues[priority] = ready.removeFromList(queues[priority]);
-                return ready;
-            }
-        }
-
-        return null;
-    }
-
-    private void setPriorityOnAll(int priority) {
-        synchronized (queues) {
-            for (int i = 0; i < PRIORITY_COUNT; i++) {
-                if (i != priority) {
-                    WorkNode move = queues[i];
-                    if (move != null) {
-                        do {
-                            move.priority = priority;
-                            move = move.getNext();
-                        } while (move != queues[i]);
-
-                        queues[i] = null;
-                        queues[priority] = move.spliceLists(queues[priority]);
-                    }
-                }
-            }
-        }
-    }
-
-    private class WorkNode implements WorkItem {
-        private final Runnable callback;
-        private int priority;
-        private WorkNode next;
-        private WorkNode prev;
-
-        WorkNode(Runnable callback) {
-            this.callback = callback;
-            this.priority = PRIORITY_ACTIVE;
-        }
-
-        @Override
-        public boolean cancel() {
-            synchronized (queues) {
-                if ((priority != PRIORITY_RUNNING) && (next != null)) {
-                    queues[priority] = removeFromList(queues[priority]);
-                    return true;
-                }
-            }
-
-            return false;
-        }
-
-        @Override
-        public void setPriority(int newPriority) {
-            assert priority >= 0;
-            assert priority < PRIORITY_COUNT;
-
-            synchronized (queues) {
-                if (priority != PRIORITY_RUNNING) {
-                    if (next != null) {
-                        queues[priority] = removeFromList(queues[priority]);
-                    }
-                    priority = newPriority;
-                    queues[priority] = addToList(queues[priority]);
-                }
-            }
-        }
-
-        @Override
-        public int getPriority() {
-            return priority;
-        }
-
-        void setPriorityRunning() {
-            synchronized (queues) {
-                priority = PRIORITY_RUNNING;
-            }
-        }
-
-        Runnable getCallback() {
-            return callback;
-        }
-
-        WorkNode getNext() {
-            return next;
-        }
-
-        WorkNode addToList(WorkNode list) {
-            assert next == null;
-            assert prev == null;
-
-            if (list == null) {
-                list = next = prev = this;
-            } else {
-                next = list;
-                prev = list.prev;
-                next.prev = prev.next = this;
-            }
-
-            return list;
-        }
-
-        WorkNode removeFromList(WorkNode list) {
-            assert next != null;
-            assert prev != null;
-
-            if (list == this) {
-                if (next == this) {
-                    list = null;
-                } else {
-                    list = next;
-                }
-            }
-
-            next.prev = prev;
-            prev.next = next;
-            next = prev = null;
-
-            return list;
-        }
-
-        WorkNode spliceLists(WorkNode list) {
-            if (list == null) {
-                list = this;
-            } else {
-                WorkNode listPrev = list.prev;
-
-                list.prev = prev;
-                prev.next = list;
-
-                listPrev.next = this;
-                prev = listPrev;
-            }
-
-            return list;
-        }
-
-        void verify(int expectedPriority) {
-            assert priority == expectedPriority;
-            assert prev.next == this;
-            assert next.prev == this;
-        }
-    }
-
-    interface WorkItem {
-        boolean cancel();
-        int getPriority();
-        void setPriority(int priority);
-    }
-}
diff --git a/facebook/src/com/facebook/PropertyName.java b/facebook/src/com/facebook/PropertyName.java
deleted file mode 100644
index 6613d1096..000000000
--- a/facebook/src/com/facebook/PropertyName.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package com.facebook;
-
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-
-/**
- * Use this annotation on getters and setters in an interface that derives from
- * GraphObject, if you wish to override the default property name that is inferred
- * from the name of the method.
- *
- * If this annotation is specified on a method, it must contain a non-empty String
- * value that represents the name of the property that the method is a getter or setter
- * for.
- */
-@Retention(RetentionPolicy.RUNTIME)
-public @interface PropertyName {
-    String value();
-}
\ No newline at end of file
diff --git a/facebook/src/com/facebook/Request.java b/facebook/src/com/facebook/Request.java
index 166790ca0..837ce4a65 100644
--- a/facebook/src/com/facebook/Request.java
+++ b/facebook/src/com/facebook/Request.java
@@ -24,6 +24,11 @@
 import android.os.ParcelFileDescriptor;
 import android.text.TextUtils;
 import android.util.Pair;
+import com.facebook.internal.ServerProtocol;
+import com.facebook.model.*;
+import com.facebook.internal.Logger;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -43,17 +48,17 @@
  * href="https://developers.facebook.com/docs/reference/rest/">REST API</a>. The Request class provides functionality
  * relating to serializing and deserializing requests and responses, making calls in batches (with a single round-trip
  * to the service) and making calls asynchronously.
- * 
+ *
  * The particular service endpoint that a request targets is determined by either a graph path (see the
  * {@link #setGraphPath(String) setGraphPath} method) or a REST method name (see the {@link #setRestMethod(String)
  * setRestMethod} method); a single request may not target both.
- * 
+ *
  * A Request can be executed either anonymously or representing an authenticated user. In the former case, no Session
  * needs to be specified, while in the latter, a Session that is in an opened state must be provided. If requests are
  * executed in a batch, a Facebook application ID must be associated with the batch, either by supplying a Session for
  * at least one of the requests in the batch (the first one found in the batch will be used) or by calling the
  * {@link #setDefaultBatchApplicationId(String) setDefaultBatchApplicationId} method.
- * 
+ *
  * After completion of a request, its Session, if any, will be checked to determine if its Facebook access token needs
  * to be extended; if so, a request to extend it will be issued in the background.
  */
@@ -67,6 +72,7 @@
     private static final String ME = "me";
     private static final String MY_FRIENDS = "me/friends";
     private static final String MY_PHOTOS = "me/photos";
+    private static final String MY_VIDEOS = "me/videos";
     private static final String SEARCH = "search";
     private static final String MY_FEED = "me/feed";
 
@@ -92,9 +98,9 @@
     private static final String ATTACHMENT_FILENAME_PREFIX = "file";
     private static final String ATTACHED_FILES_PARAM = "attached_files";
     private static final String MIGRATION_BUNDLE_PARAM = "migration_bundle";
+    private static final String ISO_8601_FORMAT_STRING = "yyyy-MM-dd'T'HH:mm:ssZ";
 
     private static final String MIME_BOUNDARY = "3i2ndDfv2rTHiSisAbouNdArYfORhtTPEefj3q2f";
-    private static final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.US);
 
     private static String defaultBatchApplicationId;
 
@@ -108,6 +114,7 @@
     private boolean batchEntryOmitResultOnSuccess = true;
     private Bundle parameters;
     private Callback callback;
+    private String overriddenURL;
 
     /**
      * Constructs a request without a session, graph path, or any other parameters.
@@ -121,7 +128,7 @@ public Request() {
      * case the request is sent without an access token and thus is not executed in the context of any particular user.
      * Only certain graph requests can be expected to succeed in this case. If a Session is provided, it must be in an
      * opened state or the request will fail.
-     * 
+     *
      * @param session
      *            the Session to use, or null
      * @param graphPath
@@ -136,9 +143,9 @@ public Request(Session session, String graphPath) {
      * provided, in which case the request is sent without an access token and thus is not executed in the context of
      * any particular user. Only certain graph requests can be expected to succeed in this case. If a Session is
      * provided, it must be in an opened state or the request will fail.
-     * 
+     *
      * Depending on the httpMethod parameter, the object at the graph path may be retrieved, created, or deleted.
-     * 
+     *
      * @param session
      *            the Session to use, or null
      * @param graphPath
@@ -158,9 +165,9 @@ public Request(Session session, String graphPath, Bundle parameters, HttpMethod
      * provided, in which case the request is sent without an access token and thus is not executed in the context of
      * any particular user. Only certain graph requests can be expected to succeed in this case. If a Session is
      * provided, it must be in an opened state or the request will fail.
-     * 
+     *
      * Depending on the httpMethod parameter, the object at the graph path may be retrieved, created, or deleted.
-     * 
+     *
      * @param session
      *            the Session to use, or null
      * @param graphPath
@@ -191,10 +198,19 @@ public Request(Session session, String graphPath, Bundle parameters, HttpMethod
         }
     }
 
+    Request(Session session, URL overriddenURL) {
+        this.session = session;
+        this.overriddenURL = overriddenURL.toString();
+
+        setHttpMethod(HttpMethod.GET);
+
+        this.parameters = new Bundle();
+    }
+
     /**
      * Creates a new Request configured to post a GraphObject to a particular graph path, to either create or update the
      * object at that path.
-     * 
+     *
      * @param session
      *            the Session to use, or null; if non-null, the session must be in an opened state
      * @param graphPath
@@ -213,7 +229,7 @@ public static Request newPostRequest(Session session, String graphPath, GraphObj
 
     /**
      * Creates a new Request configured to make a call to the Facebook REST API.
-     * 
+     *
      * @param session
      *            the Session to use, or null; if non-null, the session must be in an opened state
      * @param restMethod
@@ -233,7 +249,7 @@ public static Request newRestRequest(Session session, String restMethod, Bundle
 
     /**
      * Creates a new Request configured to retrieve a user's own profile.
-     * 
+     *
      * @param session
      *            the Session to use, or null; if non-null, the session must be in an opened state
      * @param callback
@@ -254,7 +270,7 @@ public void onCompleted(Response response) {
 
     /**
      * Creates a new Request configured to retrieve a user's friend list.
-     * 
+     *
      * @param session
      *            the Session to use, or null; if non-null, the session must be in an opened state
      * @param callback
@@ -275,7 +291,7 @@ public void onCompleted(Response response) {
 
     /**
      * Creates a new Request configured to upload a photo to the user's default photo album.
-     * 
+     *
      * @param session
      *            the Session to use, or null; if non-null, the session must be in an opened state
      * @param image
@@ -309,9 +325,27 @@ public static Request newUploadPhotoRequest(Session session, File file,
         return new Request(session, MY_PHOTOS, parameters, HttpMethod.POST, callback);
     }
 
+    /**
+     * Creates a new Request configured to upload a photo to the user's default photo album. The photo
+     * will be read from the specified file descriptor.
+     *
+     * @param session  the Session to use, or null; if non-null, the session must be in an opened state
+     * @param file     the file to upload
+     * @param callback a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newUploadVideoRequest(Session session, File file,
+            Callback callback) throws FileNotFoundException {
+        ParcelFileDescriptor descriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
+        Bundle parameters = new Bundle(1);
+        parameters.putParcelable(file.getName(), descriptor);
+
+        return new Request(session, MY_VIDEOS, parameters, HttpMethod.POST, callback);
+    }
+
     /**
      * Creates a new Request configured to retrieve a particular graph path.
-     * 
+     *
      * @param session
      *            the Session to use, or null; if non-null, the session must be in an opened state
      * @param graphPath
@@ -326,15 +360,16 @@ public static Request newGraphPathRequest(Session session, String graphPath, Cal
 
     /**
      * Creates a new Request that is configured to perform a search for places near a specified location via the Graph
-     * API.
-     * 
+     * API. At least one of location or searchText must be specified.
+     *
      * @param session
      *            the Session to use, or null; if non-null, the session must be in an opened state
      * @param location
      *            the location around which to search; only the latitude and longitude components of the location are
      *            meaningful
      * @param radiusInMeters
-     *            the radius around the location to search, specified in meters
+     *            the radius around the location to search, specified in meters; this is ignored if
+     *            no location is specified
      * @param resultsLimit
      *            the maximum number of results to return
      * @param searchText
@@ -353,10 +388,12 @@ public static Request newPlacesSearchRequest(Session session, Location location,
 
         Bundle parameters = new Bundle(5);
         parameters.putString("type", "place");
-        parameters.putString("limit", String.format("%d", resultsLimit));
-        parameters.putString("distance", String.format("%d", radiusInMeters));
-        parameters.putString("center",
-                String.format(Locale.US, "%f,%f", location.getLatitude(), location.getLongitude()));
+        parameters.putInt("limit", resultsLimit);
+        if (location != null) {
+            parameters.putString("center",
+                    String.format(Locale.US, "%f,%f", location.getLatitude(), location.getLongitude()));
+            parameters.putInt("distance", radiusInMeters);
+        }
         if (!Utility.isNullOrEmpty(searchText)) {
             parameters.putString("q", searchText);
         }
@@ -393,7 +430,7 @@ public static Request newStatusUpdateRequest(Session session, String message, Ca
 
     /**
      * Returns the GraphObject, if any, associated with this request.
-     * 
+     *
      * @return the GraphObject associated with this requeset, or null if there is none
      */
     public final GraphObject getGraphObject() {
@@ -402,7 +439,7 @@ public final GraphObject getGraphObject() {
 
     /**
      * Sets the GraphObject associated with this request. This is meaningful only for POST requests.
-     * 
+     *
      * @param graphObject
      *            the GraphObject to upload along with this request
      */
@@ -412,7 +449,7 @@ public final void setGraphObject(GraphObject graphObject) {
 
     /**
      * Returns the graph path of this request, if any.
-     * 
+     *
      * @return the graph path of this request, or null if there is none
      */
     public final String getGraphPath() {
@@ -421,7 +458,7 @@ public final String getGraphPath() {
 
     /**
      * Sets the graph path of this request. A graph path may not be set if a REST method has been specified.
-     * 
+     *
      * @param graphPath
      *            the graph path for this request
      */
@@ -431,7 +468,7 @@ public final void setGraphPath(String graphPath) {
 
     /**
      * Returns the {@link HttpMethod} to use for this request.
-     * 
+     *
      * @return the HttpMethod
      */
     public final HttpMethod getHttpMethod() {
@@ -440,17 +477,20 @@ public final HttpMethod getHttpMethod() {
 
     /**
      * Sets the {@link HttpMethod} to use for this request.
-     * 
+     *
      * @param httpMethod
      *            the HttpMethod, or null for the default (HttpMethod.GET).
      */
     public final void setHttpMethod(HttpMethod httpMethod) {
+        if (overriddenURL != null && httpMethod != HttpMethod.GET) {
+            throw new FacebookException("Can't change HTTP method on request with overridden URL.");
+            }
         this.httpMethod = (httpMethod != null) ? httpMethod : HttpMethod.GET;
     }
 
     /**
      * Returns the parameters for this request.
-     * 
+     *
      * @return the parameters
      */
     public final Bundle getParameters() {
@@ -459,7 +499,7 @@ public final Bundle getParameters() {
 
     /**
      * Sets the parameters for this request.
-     * 
+     *
      * @param parameters
      *            the parameters
      */
@@ -469,7 +509,7 @@ public final void setParameters(Bundle parameters) {
 
     /**
      * Returns the REST method to call for this request.
-     * 
+     *
      * @return the REST method
      */
     public final String getRestMethod() {
@@ -478,7 +518,7 @@ public final String getRestMethod() {
 
     /**
      * Sets the REST method to call for this request. A REST method may not be set if a graph path has been specified.
-     * 
+     *
      * @param restMethod
      *            the REST method to call
      */
@@ -488,7 +528,7 @@ public final void setRestMethod(String restMethod) {
 
     /**
      * Returns the Session associated with this request.
-     * 
+     *
      * @return the Session associated with this request, or null if none has been specified
      */
     public final Session getSession() {
@@ -498,7 +538,7 @@ public final Session getSession() {
     /**
      * Sets the Session to use for this request. The Session does not need to be opened at the time it is specified, but
      * it must be opened by the time the request is executed.
-     * 
+     *
      * @param session
      *            the Session to use for this request
      */
@@ -508,7 +548,7 @@ public final void setSession(Session session) {
 
     /**
      * Returns the name of this request's entry in a batched request.
-     * 
+     *
      * @return the name of this request's batch entry, or null if none has been specified
      */
     public final String getBatchEntryName() {
@@ -520,7 +560,7 @@ public final String getBatchEntryName() {
      * as part of a batched request. It can be used to specified dependencies between requests. See <a
      * href="https://developers.facebook.com/docs/reference/api/batch/">Batch Requests</a> in the Graph API
      * documentation for more details.
-     * 
+     *
      * @param batchEntryName
      *            the name of this request's entry in a batched request, which must be unique within a particular batch
      *            of requests
@@ -579,7 +619,7 @@ public final void setBatchEntryOmitResultOnSuccess(boolean batchEntryOmitResultO
      * Gets the default Facebook application ID that will be used to submit batched requests if none of those requests
      * specifies a Session. Batched requests require an application ID, so either at least one request in a batch must
      * specify a Session or the application ID must be specified explicitly.
-     * 
+     *
      * @return the Facebook application ID to use for batched requests if none can be determined
      */
     public static final String getDefaultBatchApplicationId() {
@@ -590,7 +630,7 @@ public static final String getDefaultBatchApplicationId() {
      * Sets the default application ID that will be used to submit batched requests if none of those requests specifies
      * a Session. Batched requests require an application ID, so either at least one request in a batch must specify a
      * Session or the application ID must be specified explicitly.
-     * 
+     *
      * @param applicationId
      *            the Facebook application ID to use for batched requests if none can be determined
      */
@@ -600,7 +640,7 @@ public static final void setDefaultBatchApplicationId(String applicationId) {
 
     /**
      * Returns the callback which will be called when the request finishes.
-     * 
+     *
      * @return the callback
      */
     public final Callback getCallback() {
@@ -609,7 +649,7 @@ public final Callback getCallback() {
 
     /**
      * Sets the callback which will be called when the request finishes.
-     * 
+     *
      * @param callback
      *            the callback
      */
@@ -635,7 +675,7 @@ public final void setCallback(Callback callback) {
      */
     public static RequestAsyncTask executePostRequestAsync(Session session, String graphPath, GraphObject graphObject,
             Callback callback) {
-        return newPostRequest(session, graphPath,graphObject, callback).executeAsync();
+        return newPostRequest(session, graphPath, graphObject, callback).executeAsync();
     }
 
     /**
@@ -815,7 +855,7 @@ public final RequestAsyncTask executeAsync() {
     /**
      * Serializes one or more requests but does not execute them. The resulting HttpURLConnection can be executed
      * explicitly by the caller.
-     * 
+     *
      * @param requests
      *            one or more Requests to serialize
      * @return an HttpURLConnection which is ready to execute
@@ -875,7 +915,8 @@ public static HttpURLConnection toHttpConnection(RequestBatch requests) {
             if (requests.size() == 1) {
                 // Single request case.
                 Request request = requests.get(0);
-                url = request.getUrlForSingleRequest();
+                // In the non-batch case, the URL we use really is the same one returned by getUrlForSingleRequest.
+                url = new URL(request.getUrlForSingleRequest());
             } else {
                 // Batch case -- URL is just the graph API base, individual request URLs are serialized
                 // as relative_url parameters within each batch entry.
@@ -903,10 +944,10 @@ public static HttpURLConnection toHttpConnection(RequestBatch requests) {
      * Executes a single request on the current thread and returns the response.
      * <p/>
      * This should only be used if you have transitioned off the UI thread.
-     * 
+     *
      * @param request
      *            the Request to execute
-     * 
+     *
      * @return the Response object representing the results of the request
      *
      * @throws FacebookException
@@ -929,7 +970,7 @@ public static Response executeAndWait(Request request) {
      *
      * @param requests
      *            the Requests to execute
-     * 
+     *
      * @return a list of Response objects representing the results of the requests; responses are returned in the same
      *         order as the requests were specified.
      *
@@ -1000,7 +1041,7 @@ public static Response executeAndWait(Request request) {
      * succeeded or failed, a callback must be specified (see the {@link #setCallback(Callback) setCallback} method).
      * <p/>
      * This should only be called from the UI thread.
-     * 
+     *
      * @param requests
      *            the Requests to execute
      * @return a RequestAsyncTask that is executing the request
@@ -1050,7 +1091,7 @@ public static RequestAsyncTask executeBatchAsync(RequestBatch requests) {
         Validate.notEmptyAndContainsNoNulls(requests, "requests");
 
         RequestAsyncTask asyncTask = new RequestAsyncTask(requests);
-        asyncTask.execute();
+        asyncTask.executeOnSettingsExecutor();
         return asyncTask;
     }
 
@@ -1159,15 +1200,17 @@ public static RequestAsyncTask executeConnectionAsync(HttpURLConnection connecti
      */
     public static RequestAsyncTask executeConnectionAsync(Handler callbackHandler, HttpURLConnection connection,
             RequestBatch requests) {
+        Validate.notNull(connection, "connection");
+
         RequestAsyncTask asyncTask = new RequestAsyncTask(connection, requests);
         requests.setCallbackHandler(callbackHandler);
-        asyncTask.execute();
+        asyncTask.executeOnSettingsExecutor();
         return asyncTask;
     }
 
     /**
      * Returns a string representation of this Request, useful for debugging.
-     * 
+     *
      * @return the debugging information
      */
     @Override
@@ -1178,7 +1221,7 @@ public String toString() {
                 .append(parameters).append("}").toString();
     }
 
-    private static void runCallbacks(RequestBatch requests, List<Response> responses) {
+    static void runCallbacks(final RequestBatch requests, List<Response> responses) {
         int numRequests = requests.size();
 
         // Compile the list of callbacks to call and then run them either on this thread or via the Handler we received
@@ -1196,6 +1239,11 @@ public void run() {
                     for (Pair<Callback, Response> pair : callbacks) {
                         pair.first.onCompleted(pair.second);
                     }
+
+                    List<RequestBatch.Callback> batchCallbacks = requests.getCallbacks();
+                    for (RequestBatch.Callback batchCallback : batchCallbacks) {
+                        batchCallback.onBatchCompleted(requests);
+                    }
                 }
             };
 
@@ -1223,10 +1271,14 @@ static HttpURLConnection createConnection(URL url) throws IOException {
 
 
     private void addCommonParameters() {
-        if (this.session != null && !this.parameters.containsKey(ACCESS_TOKEN_PARAM)) {
-            String accessToken = this.session.getAccessToken();
-            Logger.registerAccessToken(accessToken);
-            this.parameters.putString(ACCESS_TOKEN_PARAM, accessToken);
+        if (this.session != null) {
+            if (!this.session.isOpened()) {
+                throw new FacebookException("Session provided to a Request in un-opened state.");
+            } else if (!this.parameters.containsKey(ACCESS_TOKEN_PARAM)) {
+                String accessToken = this.session.getAccessToken();
+                Logger.registerAccessToken(accessToken);
+                this.parameters.putString(ACCESS_TOKEN_PARAM, accessToken);
+            }
         }
         this.parameters.putString(SDK_PARAM, SDK_ANDROID);
         this.parameters.putString(FORMAT_PARAM, FORMAT_JSON);
@@ -1239,22 +1291,32 @@ private String appendParametersToBaseUrl(String baseUrl) {
         for (String key : keys) {
             Object value = this.parameters.get(key);
 
-            if (!(value instanceof String)) {
+            if (value == null) {
+                value = "";
+            }
+
+            if (isSupportedParameterType(value)) {
+                value = parameterToString(value);
+            } else {
                 if (httpMethod == HttpMethod.GET) {
-                    throw new IllegalArgumentException("Cannot use GET to upload a file.");
+                    throw new IllegalArgumentException(String.format("Unsupported parameter type for GET request: %s",
+                                    value.getClass().getSimpleName()));
                 }
-
-                // Skip non-strings. We add them later as attachments.
                 continue;
             }
+
             uriBuilder.appendQueryParameter(key, value.toString());
         }
 
         return uriBuilder.toString();
     }
 
-    final String getUrlStringForBatchedRequest() throws MalformedURLException {
-        String baseUrl = null;
+    final String getUrlForBatchedRequest() {
+        if (overriddenURL != null) {
+            throw new FacebookException("Can't override URL for a batch request");
+        }
+
+        String baseUrl;
         if (this.restMethod != null) {
             baseUrl = ServerProtocol.BATCHED_REST_METHOD_URL_BASE + this.restMethod;
         } else {
@@ -1262,12 +1324,15 @@ final String getUrlStringForBatchedRequest() throws MalformedURLException {
         }
 
         addCommonParameters();
-        // We don't convert to a URL because it may only be part of a URL.
         return appendParametersToBaseUrl(baseUrl);
     }
 
-    final URL getUrlForSingleRequest() throws MalformedURLException {
-        String baseUrl = null;
+    final String getUrlForSingleRequest() {
+        if (overriddenURL != null) {
+            return overriddenURL.toString();
+        }
+
+        String baseUrl;
         if (this.restMethod != null) {
             baseUrl = ServerProtocol.REST_URL_BASE + this.restMethod;
         } else {
@@ -1275,9 +1340,10 @@ final URL getUrlForSingleRequest() throws MalformedURLException {
         }
 
         addCommonParameters();
-        return new URL(appendParametersToBaseUrl(baseUrl));
+        return appendParametersToBaseUrl(baseUrl);
     }
 
+
     private void serializeToBatch(JSONArray batch, Bundle attachments) throws JSONException, IOException {
         JSONObject batchEntry = new JSONObject();
 
@@ -1289,7 +1355,7 @@ private void serializeToBatch(JSONArray batch, Bundle attachments) throws JSONEx
             batchEntry.put(BATCH_ENTRY_DEPENDS_ON_PARAM, this.batchEntryDependsOn);
         }
 
-        String relativeURL = getUrlStringForBatchedRequest();
+        String relativeURL = getUrlForBatchedRequest();
         batchEntry.put(BATCH_RELATIVE_URL_PARAM, relativeURL);
         batchEntry.put(BATCH_METHOD_PARAM, httpMethod);
         if (this.session != null) {
@@ -1302,7 +1368,7 @@ private void serializeToBatch(JSONArray batch, Bundle attachments) throws JSONEx
         Set<String> keys = this.parameters.keySet();
         for (String key : keys) {
             Object value = this.parameters.get(key);
-            if (Serializer.isSupportedAttachmentType(value)) {
+            if (isSupportedAttachmentType(value)) {
                 // Make the name unique across this entire batch.
                 String name = String.format("%s%d", ATTACHMENT_FILENAME_PREFIX, attachments.size());
                 attachmentNames.add(name);
@@ -1339,7 +1405,7 @@ private void validate() {
 
     final static void serializeToUrlConnection(RequestBatch requests, HttpURLConnection connection)
     throws IOException, JSONException {
-        Logger logger = new Logger(LoggingBehaviors.REQUESTS, "Request");
+        Logger logger = new Logger(LoggingBehavior.REQUESTS, "Request");
 
         int numRequests = requests.size();
 
@@ -1478,6 +1544,7 @@ private static void processGraphObjectProperty(String key, Object value, KeyValu
             // dates in ISO-8601 format. Pre-migration apps can send as Unix timestamps. Since the future is ISO-8601,
             // that is what we support here. Apps that need pre-migration behavior can explicitly send these as
             // integer timestamps rather than Dates.
+            final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat(ISO_8601_FORMAT_STRING, Locale.US);
             serializer.writeString(key, iso8601DateFormat.format(date));
         }
     }
@@ -1487,7 +1554,7 @@ private static void serializeParameters(Bundle bundle, Serializer serializer) th
 
         for (String key : keys) {
             Object value = bundle.get(key);
-            if (Serializer.isSupportedParameterType(value)) {
+            if (isSupportedParameterType(value)) {
                 serializer.writeObject(key, value);
             }
         }
@@ -1498,7 +1565,7 @@ private static void serializeAttachments(Bundle bundle, Serializer serializer) t
 
         for (String key : keys) {
             Object value = bundle.get(key);
-            if (Serializer.isSupportedAttachmentType(value)) {
+            if (isSupportedAttachmentType(value)) {
                 serializer.writeObject(key, value);
             }
         }
@@ -1529,8 +1596,12 @@ private static String getUserAgent() {
         return userAgent;
     }
 
-    private static String getBatchAppId(Collection<Request> requests) {
-        for (Request request : requests) {
+    private static String getBatchAppId(RequestBatch batch) {
+        if (!Utility.isNullOrEmpty(batch.getBatchApplicationId())) {
+            return batch.getBatchApplicationId();
+        }
+
+        for (Request request : batch) {
             Session session = request.session;
             if (session != null) {
                 return session.getApplicationId();
@@ -1553,6 +1624,27 @@ private static String getBatchAppId(Collection<Request> requests) {
         return data.castToListOf(clazz);
     }
 
+    private static boolean isSupportedAttachmentType(Object value) {
+        return value instanceof Bitmap || value instanceof byte[] || value instanceof ParcelFileDescriptor;
+    }
+
+    private static boolean isSupportedParameterType(Object value) {
+        return value instanceof String || value instanceof Boolean || value instanceof Number ||
+                value instanceof Date;
+    }
+
+    private static String parameterToString(Object value) {
+        if (value instanceof String) {
+            return (String) value;
+        } else if (value instanceof Boolean || value instanceof Number) {
+            return value.toString();
+        } else if (value instanceof Date) {
+            final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat(ISO_8601_FORMAT_STRING, Locale.US);
+            return iso8601DateFormat.format(value);
+        }
+        throw new IllegalArgumentException("Unsupported parameter type.");
+    }
+
     private interface KeyValueSerializer {
         void writeString(String key, String value) throws IOException;
     }
@@ -1568,8 +1660,8 @@ public Serializer(BufferedOutputStream outputStream, Logger logger) {
         }
 
         public void writeObject(String key, Object value) throws IOException {
-            if (value instanceof String) {
-                writeString(key, (String) value);
+            if (isSupportedParameterType(value)) {
+                writeString(key, parameterToString(value));
             } else if (value instanceof Bitmap) {
                 writeBitmap(key, (Bitmap) value);
             } else if (value instanceof byte[]) {
@@ -1668,14 +1760,6 @@ public void writeLine(String format, Object... args) throws IOException {
             write("\r\n");
         }
 
-        public static boolean isSupportedAttachmentType(Object value) {
-            return value instanceof Bitmap || value instanceof byte[] || value instanceof ParcelFileDescriptor;
-        }
-
-        public static boolean isSupportedParameterType(Object value) {
-            return value instanceof String;
-        }
-
     }
 
     /**
@@ -1685,7 +1769,7 @@ public static boolean isSupportedParameterType(Object value) {
     public interface Callback {
         /**
          * The method that will be called when a request completes.
-         * 
+         *
          * @param response
          *            the Response of this request, which may include error information if the request was unsuccessful
          */
diff --git a/facebook/src/com/facebook/RequestAsyncTask.java b/facebook/src/com/facebook/RequestAsyncTask.java
index 66bdec673..359836db0 100644
--- a/facebook/src/com/facebook/RequestAsyncTask.java
+++ b/facebook/src/com/facebook/RequestAsyncTask.java
@@ -21,9 +21,12 @@
 import android.os.Handler;
 import android.util.Log;
 
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.net.HttpURLConnection;
 import java.util.Collection;
 import java.util.List;
+import java.util.concurrent.Executor;
 
 /**
  * Defines an AsyncTask suitable for executing a Request in the background. May be subclassed
@@ -32,15 +35,28 @@
 @TargetApi(3)
 public class RequestAsyncTask extends AsyncTask<Void, Void, List<Response>> {
     private static final String TAG = RequestAsyncTask.class.getCanonicalName();
+    private static Method executeOnExecutorMethod;
 
     private final HttpURLConnection connection;
     private final RequestBatch requests;
 
     private Exception exception;
 
+    static {
+        for (Method method : AsyncTask.class.getMethods()) {
+            if ("executeOnExecutor".equals(method.getName())) {
+                Class<?>[] parameters = method.getParameterTypes();
+                if ((parameters.length == 2) && (parameters[0] == Executor.class) && parameters[1].isArray()) {
+                    executeOnExecutorMethod = method;
+                    break;
+                }
+            }
+        }
+    }
+
     /**
      * Constructor. Serialization of the requests will be done in the background, so any serialization-
-     * related errors will be returned via the Response.getError() method.
+     * related errors will be returned via the Response.getException() method.
      *
      * @param requests the requests to execute
      */
@@ -50,7 +66,7 @@ public RequestAsyncTask(Request... requests) {
 
     /**
      * Constructor. Serialization of the requests will be done in the background, so any serialization-
-     * related errors will be returned via the Response.getError() method.
+     * related errors will be returned via the Response.getException() method.
      *
      * @param requests the requests to execute
      */
@@ -60,7 +76,7 @@ public RequestAsyncTask(Collection<Request> requests) {
 
     /**
      * Constructor. Serialization of the requests will be done in the background, so any serialization-
-     * related errors will be returned via the Response.getError() method.
+     * related errors will be returned via the Response.getException() method.
      *
      * @param requests the requests to execute
      */
@@ -112,6 +128,10 @@ protected final Exception getException() {
         return exception;
     }
 
+    protected final RequestBatch getRequests() {
+        return requests;
+    }
+
     @Override
     public String toString() {
         return new StringBuilder().append("{RequestAsyncTask: ").append(" connection: ").append(connection)
@@ -133,7 +153,7 @@ protected void onPostExecute(List<Response> result) {
         super.onPostExecute(result);
 
         if (exception != null) {
-            Log.d(TAG, String.format("onPostExecute: exception encountered during request: ", exception.getMessage()));
+            Log.d(TAG, String.format("onPostExecute: exception encountered during request: %s", exception.getMessage()));
         }
     }
 
@@ -141,7 +161,7 @@ protected void onPostExecute(List<Response> result) {
     protected List<Response> doInBackground(Void... params) {
         try {
             if (connection == null) {
-                return Request.executeBatchAndWait(requests);
+                return requests.executeAndWait();
             } else {
                 return Request.executeConnectionAndWait(connection, requests);
             }
@@ -150,4 +170,20 @@ protected void onPostExecute(List<Response> result) {
             return null;
         }
     }
+
+    RequestAsyncTask executeOnSettingsExecutor() {
+        try {
+            if (executeOnExecutorMethod != null) {
+                executeOnExecutorMethod.invoke(this, Settings.getExecutor(), null);
+                return this;
+            }
+        } catch (InvocationTargetException e) {
+            // fall-through
+        } catch (IllegalAccessException e) {
+            // fall-through
+        }
+
+        this.execute();
+        return this;
+    }
 }
diff --git a/facebook/src/com/facebook/RequestBatch.java b/facebook/src/com/facebook/RequestBatch.java
index 59ce5a043..de3f5517a 100644
--- a/facebook/src/com/facebook/RequestBatch.java
+++ b/facebook/src/com/facebook/RequestBatch.java
@@ -18,24 +18,21 @@
 
 import android.os.Handler;
 
-import java.util.AbstractList;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
+import java.util.*;
 import java.util.concurrent.atomic.AtomicInteger;
 
 /**
- * RequestBatch contains a list of Request objects that can be sent to facebook in a single round-trip.
+ * RequestBatch contains a list of Request objects that can be sent to Facebook in a single round-trip.
  */
 public class RequestBatch extends AbstractList<Request> {
     private static AtomicInteger idGenerator = new AtomicInteger();
 
-    private String cacheKey;
     private Handler callbackHandler;
-    private boolean forceRoundTrip;
-    private ArrayList<Request> requests = new ArrayList<Request>();
+    private List<Request> requests = new ArrayList<Request>();
     private int timeoutInMilliseconds = 0;
     private final String id = Integer.valueOf(idGenerator.incrementAndGet()).toString();
+    private List<Callback> callbacks = new ArrayList<Callback>();
+    private String batchApplicationId;
 
     /**
      * Constructor. Creates an empty batch.
@@ -57,7 +54,7 @@ public RequestBatch(Collection<Request> requests) {
      * @param requests the requests to add to the batch
      */
     public RequestBatch(Request... requests) {
-        this.requests = Utility.arrayList(requests);
+        this.requests = Arrays.asList(requests);
     }
 
     /**
@@ -66,10 +63,9 @@ public RequestBatch(Request... requests) {
      */
     public RequestBatch(RequestBatch requests) {
         this.requests = new ArrayList<Request>(requests);
-        this.cacheKey = requests.cacheKey;
         this.callbackHandler = requests.callbackHandler;
-        this.forceRoundTrip = requests.forceRoundTrip;
         this.timeoutInMilliseconds = requests.timeoutInMilliseconds;
+        this.callbacks = new ArrayList<Callback>(requests.callbacks);
     }
 
     /**
@@ -91,6 +87,26 @@ public void setTimeout(int timeoutInMilliseconds) {
         this.timeoutInMilliseconds = timeoutInMilliseconds;
     }
 
+    /**
+     * Adds a batch-level callback which will be called when the entire batch has finished executing.
+     *
+     * @param callback the callback
+     */
+    public void addCallback(Callback callback) {
+        if (!callbacks.contains(callback)) {
+            callbacks.add(callback);
+        }
+    }
+
+    /**
+     * Removes a batch-level callback.
+     *
+     * @param callback the callback
+     */
+    public void removeCallback(Callback callback) {
+        callbacks.remove(callback);
+    }
+
     @Override
     public final boolean add(Request request) {
         return requests.add(request);
@@ -130,32 +146,28 @@ final String getId() {
         return id;
     }
 
-    final String getCacheKey() {
-        return cacheKey;
-    }
-
-    final void setCacheKey(String cacheKey) {
-        this.cacheKey = cacheKey;
+    final Handler getCallbackHandler() {
+        return callbackHandler;
     }
 
-    final boolean getForceRoundTrip() {
-        return forceRoundTrip;
+    final void setCallbackHandler(Handler callbackHandler) {
+        this.callbackHandler = callbackHandler;
     }
 
-    final void setForceRoundTrip(boolean forceRoundTrip) {
-        this.forceRoundTrip = forceRoundTrip;
+    final List<Request> getRequests() {
+        return requests;
     }
 
-    final Handler getCallbackHandler() {
-        return callbackHandler;
+    final List<Callback> getCallbacks() {
+        return callbacks;
     }
 
-    final void setCallbackHandler(Handler callbackHandler) {
-        this.callbackHandler = callbackHandler;
+    final String getBatchApplicationId() {
+        return batchApplicationId;
     }
 
-    final ArrayList<Request> getRequests() {
-        return requests;
+    final void setBatchApplicationId(String batchApplicationId) {
+        this.batchApplicationId = batchApplicationId;
     }
 
     /**
@@ -172,7 +184,7 @@ final void setCallbackHandler(Handler callbackHandler) {
      * @throws NullPointerException if the passed in RequestBatch or any of its contents are null
      */
     public final List<Response> executeAndWait() {
-        return Request.executeBatchAndWait(this);
+        return executeAndWaitImpl();
     }
 
     /**
@@ -189,6 +201,27 @@ final void setCallbackHandler(Handler callbackHandler) {
      * @throws NullPointerException if any of the contents of this batch are null
      */
     public final RequestAsyncTask executeAsync() {
+        return executeAsyncImpl();
+    }
+
+    /**
+     * Specifies the interface that consumers of the RequestBatch class can implement in order to be notified when the
+     * entire batch completes execution. It will be called after all per-Request callbacks are called.
+     */
+    public interface Callback {
+        /**
+         * The method that will be called when a batch completes.
+         *
+         * @param batch     the RequestBatch containing the Requests which were executed
+         */
+        void onBatchCompleted(RequestBatch batch);
+    }
+
+    List<Response> executeAndWaitImpl() {
+        return Request.executeBatchAndWait(this);
+    }
+
+    RequestAsyncTask executeAsyncImpl() {
         return Request.executeBatchAsync(this);
     }
 }
diff --git a/facebook/src/com/facebook/Response.java b/facebook/src/com/facebook/Response.java
index d36b3027f..dd13cf592 100644
--- a/facebook/src/com/facebook/Response.java
+++ b/facebook/src/com/facebook/Response.java
@@ -17,6 +17,9 @@
 package com.facebook;
 
 import android.content.Context;
+import com.facebook.internal.*;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphObjectList;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -25,6 +28,8 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -36,7 +41,7 @@
     private final GraphObject graphObject;
     private final GraphObjectList<GraphObject> graphObjectList;
     private final boolean isFromCache;
-    private final FacebookException error;
+    private final FacebookRequestError error;
     private final Request request;
 
     /**
@@ -50,34 +55,32 @@
 
     private static final String CODE_KEY = "code";
     private static final String BODY_KEY = "body";
-    private static final String ERROR_KEY = "error";
-    private static final String ERROR_TYPE_FIELD_KEY = "type";
-    private static final String ERROR_CODE_FIELD_KEY = "code";
-    private static final String ERROR_MESSAGE_FIELD_KEY = "message";
-    private static final String ERROR_CODE_KEY = "error_code";
-    private static final String ERROR_MSG_KEY = "error_msg";
-    private static final String ERROR_REASON_KEY = "error_reason";
 
     private static final String RESPONSE_LOG_TAG = "Response";
 
     private static final String RESPONSE_CACHE_TAG = "ResponseCache";
     private static FileLruCache responseCache;
 
-    private Response(Request request, HttpURLConnection connection, GraphObject graphObject,
-            GraphObjectList<GraphObject> graphObjects, boolean isFromCache) {
-        if (graphObject != null && graphObjects != null) {
-            throw new FacebookException("Expected either a graphObject or multiple graphObjects, but not both.");
-        }
-
+    Response(Request request, HttpURLConnection connection, GraphObject graphObject, boolean isFromCache) {
         this.request = request;
         this.connection = connection;
         this.graphObject = graphObject;
+        this.graphObjectList = null;
+        this.isFromCache = isFromCache;
+        this.error = null;
+    }
+
+    Response(Request request, HttpURLConnection connection, GraphObjectList<GraphObject> graphObjects,
+            boolean isFromCache) {
+        this.request = request;
+        this.connection = connection;
+        this.graphObject = null;
         this.graphObjectList = graphObjects;
         this.isFromCache = isFromCache;
         this.error = null;
     }
 
-    private Response(Request request, HttpURLConnection connection, FacebookException error) {
+    Response(Request request, HttpURLConnection connection, FacebookRequestError error) {
         this.request = request;
         this.connection = connection;
         this.graphObject = null;
@@ -87,17 +90,17 @@ private Response(Request request, HttpURLConnection connection, FacebookExceptio
     }
 
     /**
-     * Returns the error returned for this request, if any.
-     * 
-     * @return the error encountered, or null if the request succeeded
+     * Returns information about any errors that may have occurred during the request.
+     *
+     * @return the error from the server, or null if there was no server error
      */
-    public final FacebookException getError() {
+    public final FacebookRequestError getError() {
         return error;
     }
 
     /**
      * The single graph object returned for this request, if any.
-     * 
+     *
      * @return the graph object returned, or null if none was returned (or if the result was a list)
      */
     public final GraphObject getGraphObject() {
@@ -106,13 +109,10 @@ public final GraphObject getGraphObject() {
 
     /**
      * The single graph object returned for this request, if any, cast into a particular type of GraphObject.
-     * 
-     * @param graphObjectClass
-     *            the GraphObject-derived interface to cast the graph object into
-     * @return the graph object returned, or null if none was returned (or if the result was a list)
      *
-     * @throws FacebookException
-     *            If the passed in Class is not a valid GraphObject interface
+     * @param graphObjectClass the GraphObject-derived interface to cast the graph object into
+     * @return the graph object returned, or null if none was returned (or if the result was a list)
+     * @throws FacebookException If the passed in Class is not a valid GraphObject interface
      */
     public final <T extends GraphObject> T getGraphObjectAs(Class<T> graphObjectClass) {
         if (graphObject == null) {
@@ -126,7 +126,7 @@ public final GraphObject getGraphObject() {
 
     /**
      * The list of graph objects returned for this request, if any.
-     * 
+     *
      * @return the list of graph objects returned, or null if none was returned (or if the result was not a list)
      */
     public final GraphObjectList<GraphObject> getGraphObjectList() {
@@ -135,13 +135,10 @@ public final GraphObject getGraphObject() {
 
     /**
      * The list of graph objects returned for this request, if any, cast into a particular type of GraphObject.
-     * 
-     * @param graphObjectClass
-     *            the GraphObject-derived interface to cast the graph objects into
-     * @return the list of graph objects returned, or null if none was returned (or if the result was not a list)
      *
-     * @throws FacebookException
-     *            If the passed in Class is not a valid GraphObject interface
+     * @param graphObjectClass the GraphObject-derived interface to cast the graph objects into
+     * @return the list of graph objects returned, or null if none was returned (or if the result was not a list)
+     * @throws FacebookException If the passed in Class is not a valid GraphObject interface
      */
     public final <T extends GraphObject> GraphObjectList<T> getGraphObjectListAs(Class<T> graphObjectClass) {
         if (graphObjectList == null) {
@@ -153,7 +150,7 @@ public final GraphObject getGraphObject() {
     /**
      * Returns the HttpURLConnection that this response was generated from. If the response was retrieved
      * from the cache, this will be null.
-     * 
+     *
      * @return the connection, or null
      */
     public final HttpURLConnection getConnection() {
@@ -162,12 +159,69 @@ public final HttpURLConnection getConnection() {
 
     /**
      * Returns the request that this response is for.
+     *
      * @return the request that this response is for
      */
     public Request getRequest() {
         return request;
     }
 
+    /**
+     * Indicates whether paging is being done forward or backward.
+     */
+    public enum PagingDirection {
+        /**
+         * Indicates that paging is being performed in the forward direction.
+         */
+        NEXT,
+        /**
+         * Indicates that paging is being performed in the backward direction.
+         */
+        PREVIOUS
+    }
+
+    /**
+     * If a Response contains results that contain paging information, returns a new
+     * Request that will retrieve the next page of results, in whichever direction
+     * is desired. If no paging information is available, returns null.
+     *
+     * @param direction enum indicating whether to page forward or backward
+     * @return a Request that will retrieve the next page of results in the desired
+     *         direction, or null if no paging information is available
+     */
+    public Request getRequestForPagedResults(PagingDirection direction) {
+        String link = null;
+        if (graphObject != null) {
+            PagedResults pagedResults = graphObject.cast(PagedResults.class);
+            PagingInfo pagingInfo = pagedResults.getPaging();
+            if (pagingInfo != null) {
+                if (direction == PagingDirection.NEXT) {
+                    link = pagingInfo.getNext();
+                } else {
+                    link = pagingInfo.getPrevious();
+                }
+            }
+        }
+        if (Utility.isNullOrEmpty(link)) {
+            return null;
+        }
+
+        if (link != null && link.equals(request.getUrlForSingleRequest())) {
+            // We got the same "next" link as we just tried to retrieve. This could happen if cached
+            // data is invalid. All we can do in this case is pretend we have finished.
+            return null;
+        }
+
+        Request pagingRequest;
+        try {
+            pagingRequest = new Request(request.getSession(), new URL(link));
+        } catch (MalformedURLException e) {
+            return null;
+        }
+
+        return pagingRequest;
+    }
+
     /**
      * Provides a debugging string for this response.
      */
@@ -182,11 +236,16 @@ public String toString() {
 
         return new StringBuilder().append("{Response: ").append(" responseCode: ").append(responseCode)
                 .append(", graphObject: ").append(graphObject).append(", error: ").append(error)
-                .append(", isFromCache:" ).append(isFromCache).append("}")
+                .append(", isFromCache:").append(isFromCache).append("}")
                 .toString();
     }
 
-    final boolean getIsFromCache() {
+    /**
+     * Indicates whether the response was retrieved from a local cache or from the server.
+     *
+     * @return true if the response was cached locally, false if it was retrieved from the server
+     */
+    public final boolean getIsFromCache() {
         return isFromCache;
     }
 
@@ -205,20 +264,35 @@ static FileLruCache getResponseCache() {
     static List<Response> fromHttpConnection(HttpURLConnection connection, RequestBatch requests) {
         InputStream stream = null;
 
-        // Try loading from cache.  If that fails, load from the network.
-        FileLruCache cache = getResponseCache();
-        String cacheKey = requests.getCacheKey();
-        if (!requests.getForceRoundTrip() && (cache != null) && (cacheKey != null)) {
-            try {
-                stream = cache.get(cacheKey);
-                if (stream != null) {
-                    return createResponsesFromStream(stream, null, requests, true);
+        FileLruCache cache = null;
+        String cacheKey = null;
+        if (requests instanceof CacheableRequestBatch) {
+            CacheableRequestBatch cacheableRequestBatch = (CacheableRequestBatch) requests;
+            cache = getResponseCache();
+            cacheKey = cacheableRequestBatch.getCacheKeyOverride();
+            if (Utility.isNullOrEmpty(cacheKey)) {
+                if (requests.size() == 1) {
+                    // Default for single requests is to use the URL.
+                    cacheKey = requests.get(0).getUrlForSingleRequest();
+                } else {
+                    Logger.log(LoggingBehavior.REQUESTS, RESPONSE_CACHE_TAG,
+                            "Not using cache for cacheable request because no key was specified");
+                }
+            }
+
+            // Try loading from cache.  If that fails, load from the network.
+            if (!cacheableRequestBatch.getForceRoundTrip() && cache != null && !Utility.isNullOrEmpty(cacheKey)) {
+                try {
+                    stream = cache.get(cacheKey);
+                    if (stream != null) {
+                        return createResponsesFromStream(stream, null, requests, true);
+                    }
+                } catch (FacebookException exception) { // retry via roundtrip below
+                } catch (JSONException exception) {
+                } catch (IOException exception) {
+                } finally {
+                    Utility.closeQuietly(stream);
                 }
-            } catch (FacebookException exception) { // retry via roundtrip below
-            } catch (JSONException exception) {
-            } catch (IOException exception) {
-            } finally {
-                Utility.closeQuietly(stream);
             }
         }
 
@@ -238,13 +312,13 @@ static FileLruCache getResponseCache() {
 
             return createResponsesFromStream(stream, connection, requests, false);
         } catch (FacebookException facebookException) {
-            Logger.log(LoggingBehaviors.REQUESTS, RESPONSE_LOG_TAG, "Response <Error>: %s", facebookException);
+            Logger.log(LoggingBehavior.REQUESTS, RESPONSE_LOG_TAG, "Response <Error>: %s", facebookException);
             return constructErrorResponses(requests, connection, facebookException);
         } catch (JSONException exception) {
-            Logger.log(LoggingBehaviors.REQUESTS, RESPONSE_LOG_TAG, "Response <Error>: %s", exception);
+            Logger.log(LoggingBehavior.REQUESTS, RESPONSE_LOG_TAG, "Response <Error>: %s", exception);
             return constructErrorResponses(requests, connection, new FacebookException(exception));
         } catch (IOException exception) {
-            Logger.log(LoggingBehaviors.REQUESTS, RESPONSE_LOG_TAG, "Response <Error>: %s", exception);
+            Logger.log(LoggingBehavior.REQUESTS, RESPONSE_LOG_TAG, "Response <Error>: %s", exception);
             return constructErrorResponses(requests, connection, new FacebookException(exception));
         } finally {
             Utility.closeQuietly(stream);
@@ -255,7 +329,7 @@ static FileLruCache getResponseCache() {
             RequestBatch requests, boolean isFromCache) throws FacebookException, JSONException, IOException {
 
         String responseString = Utility.readStreamToString(stream);
-        Logger.log(LoggingBehaviors.INCLUDE_RAW_RESPONSES, RESPONSE_LOG_TAG,
+        Logger.log(LoggingBehavior.INCLUDE_RAW_RESPONSES, RESPONSE_LOG_TAG,
                 "Response (raw)\n  Size: %d\n  Response:\n%s\n", responseString.length(),
                 responseString);
 
@@ -263,7 +337,7 @@ static FileLruCache getResponseCache() {
         Object resultObject = tokener.nextValue();
 
         List<Response> responses = createResponsesFromObject(connection, requests, resultObject, isFromCache);
-        Logger.log(LoggingBehaviors.REQUESTS, RESPONSE_LOG_TAG, "Response\n  Id: %s\n  Size: %d\n  Responses:\n%s\n",
+        Logger.log(LoggingBehavior.REQUESTS, RESPONSE_LOG_TAG, "Response\n  Id: %s\n  Size: %d\n  Responses:\n%s\n",
                 requests.getId(), responseString.length(), responses);
 
         return responses;
@@ -275,6 +349,7 @@ static FileLruCache getResponseCache() {
 
         int numRequests = requests.size();
         List<Response> responses = new ArrayList<Response>(numRequests);
+        Object originalResult = object;
 
         if (numRequests == 1) {
             Request request = requests.get(0);
@@ -293,14 +368,14 @@ static FileLruCache getResponseCache() {
                 // Pretend we got an array of 1 back.
                 object = jsonArray;
             } catch (JSONException e) {
-                responses.add(new Response(request, connection, new FacebookException(e)));
+                responses.add(new Response(request, connection, new FacebookRequestError(connection, e)));
             } catch (IOException e) {
-                responses.add(new Response(request, connection, new FacebookException(e)));
+                responses.add(new Response(request, connection, new FacebookRequestError(connection, e)));
             }
         }
 
         if (!(object instanceof JSONArray) || ((JSONArray) object).length() != numRequests) {
-            FacebookException exception = new FacebookException("TODO unexpected number of results");
+            FacebookException exception = new FacebookException("Unexpected number of results");
             throw exception;
         }
 
@@ -310,106 +385,77 @@ static FileLruCache getResponseCache() {
             Request request = requests.get(i);
             try {
                 Object obj = jsonArray.get(i);
-                responses.add(createResponseFromObject(request, connection, obj, isFromCache));
+                responses.add(createResponseFromObject(request, connection, obj, isFromCache, originalResult));
             } catch (JSONException e) {
-                responses.add(new Response(request, connection, new FacebookException(e)));
+                responses.add(new Response(request, connection, new FacebookRequestError(connection, e)));
             } catch (FacebookException e) {
-                responses.add(new Response(request, connection, e));
+                responses.add(new Response(request, connection, new FacebookRequestError(connection, e)));
             }
         }
 
         return responses;
     }
 
-    private static Response createResponseFromObject(Request request, HttpURLConnection connection, Object object, boolean isFromCache) throws JSONException {
+    private static Response createResponseFromObject(Request request, HttpURLConnection connection, Object object,
+            boolean isFromCache, Object originalResult) throws JSONException {
         if (object instanceof JSONObject) {
             JSONObject jsonObject = (JSONObject) object;
 
-            FacebookServiceErrorException exception = checkResponseAndCreateException(jsonObject);
-            if (exception != null) {
-                if (exception.getFacebookErrorCode() == INVALID_SESSION_FACEBOOK_ERROR_CODE) {
+            FacebookRequestError error =
+                    FacebookRequestError.checkResponseAndCreateError(jsonObject, originalResult, connection);
+            if (error != null) {
+                if (error.getErrorCode() == INVALID_SESSION_FACEBOOK_ERROR_CODE) {
                     Session session = request.getSession();
                     if (session != null) {
                         session.closeAndClearTokenInformation();
                     }
                 }
-                throw exception;
+                return new Response(request, connection, error);
             }
 
             Object body = Utility.getStringPropertyAsJSON(jsonObject, BODY_KEY, NON_JSON_RESPONSE_PROPERTY);
 
-            GraphObject graphObject = null;
-            GraphObjectList<GraphObject> graphObjectList = null;
             if (body instanceof JSONObject) {
-                graphObject = GraphObjectWrapper.createGraphObject((JSONObject) body);
+                GraphObject graphObject = GraphObject.Factory.create((JSONObject) body);
+                return new Response(request, connection, graphObject, isFromCache);
             } else if (body instanceof JSONArray) {
-                graphObjectList = GraphObjectWrapper.wrapArray((JSONArray) body, GraphObject.class);
+                GraphObjectList<GraphObject> graphObjectList = GraphObject.Factory.createList(
+                        (JSONArray) body, GraphObject.class);
+                return new Response(request, connection, graphObjectList, isFromCache);
             }
-            return new Response(request, connection, graphObject, graphObjectList, isFromCache);
-        } else if (object == JSONObject.NULL) {
-            return new Response(request, connection, null, null, isFromCache);
+            // We didn't get a body we understand how to handle, so pretend we got nothing.
+            object = JSONObject.NULL;
+        }
+
+        if (object == JSONObject.NULL) {
+            return new Response(request, connection, (GraphObject)null, isFromCache);
         } else {
             throw new FacebookException("Got unexpected object type in response, class: "
                     + object.getClass().getSimpleName());
         }
     }
 
-    private static FacebookServiceErrorException checkResponseAndCreateException(JSONObject jsonObject) {
-        try {
-            if (jsonObject.has(CODE_KEY)) {
-                int responseCode = jsonObject.getInt(CODE_KEY);
-                Object body = Utility.getStringPropertyAsJSON(jsonObject, BODY_KEY, NON_JSON_RESPONSE_PROPERTY);
-
-                if (body != null && body instanceof JSONObject) {
-                    JSONObject jsonBody = (JSONObject) body;
-                    // Does this response represent an error from the service? We might get either an "error"
-                    // with several sub-properties, or else one or more top-level fields containing error info.
-                    String errorType = null;
-                    String errorMessage = null;
-                    int errorCode = -1;
-
-                    boolean hasError = false;
-                    if (jsonBody.has(ERROR_KEY)) {
-                        // We assume the error object is correctly formatted.
-                        JSONObject error = (JSONObject) Utility.getStringPropertyAsJSON(jsonBody, ERROR_KEY, null);
-
-                        errorType = error.optString(ERROR_TYPE_FIELD_KEY, null);
-                        errorMessage = error.optString(ERROR_MESSAGE_FIELD_KEY, null);
-                        errorCode = error.optInt(ERROR_CODE_FIELD_KEY, -1);
-                        hasError = true;
-                    } else if (jsonBody.has(ERROR_CODE_KEY) || jsonBody.has(ERROR_MSG_KEY)
-                            || jsonBody.has(ERROR_REASON_KEY)) {
-                        errorType = jsonBody.optString(ERROR_REASON_KEY, null);
-                        errorMessage = jsonBody.optString(ERROR_MSG_KEY, null);
-                        errorCode = jsonBody.optInt(ERROR_CODE_KEY, -1);
-                        hasError = true;
-                    }
-
-                    if (hasError) {
-                        return new FacebookServiceErrorException(responseCode, errorCode, errorType, errorMessage,
-                                jsonBody);
-                    }
-                }
-
-                // If we didn't get error details, but we did get a failure response code, report it.
-                if (responseCode < 200 || responseCode >= 300) {
-                    return new FacebookServiceErrorException(responseCode);
-                }
-            }
-        } catch (JSONException e) {
-        }
-
-        return null;
-    }
-
     static List<Response> constructErrorResponses(List<Request> requests, HttpURLConnection connection,
             FacebookException error) {
         int count = requests.size();
         List<Response> responses = new ArrayList<Response>(count);
         for (int i = 0; i < count; ++i) {
-            Response response = new Response(requests.get(i), connection, error);
+            Response response = new Response(requests.get(i), connection, new FacebookRequestError(connection, error));
             responses.add(response);
         }
         return responses;
     }
+
+    interface PagingInfo extends GraphObject {
+        String getNext();
+
+        String getPrevious();
+    }
+
+    interface PagedResults extends GraphObject {
+        GraphObjectList<GraphObject> getData();
+
+        PagingInfo getPaging();
+    }
+
 }
diff --git a/facebook/src/com/facebook/ServerProtocol.java b/facebook/src/com/facebook/ServerProtocol.java
deleted file mode 100644
index 619729e47..000000000
--- a/facebook/src/com/facebook/ServerProtocol.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/**
- * Copyright 2012 Facebook
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import java.util.Collection;
-
-final class ServerProtocol {
-    static final String FACEBOOK_COM = "facebook.com";
-    static final String DIALOG_AUTHORITY = "m." + FACEBOOK_COM;
-    static final String DIALOG_OAUTH_PATH = "dialog/oauth";
-    static final String DIALOG_PARAM_SCOPE = "scope";
-    static final String DIALOG_PARAM_CLIENT_ID = "client_id";
-    static final String DIALOG_PARAM_DISPLAY = "display";
-    static final String DIALOG_PARAM_REDIRECT_URI = "redirect_uri";
-    static final String DIALOG_PARAM_TYPE = "type";
-
-    // URL components
-    static final String GRAPH_URL = "https://graph." + FACEBOOK_COM;
-    static final String GRAPH_URL_BASE = "https://graph." + FACEBOOK_COM + "/";
-    static final String REST_URL_BASE = "https://api." + FACEBOOK_COM + "/method/";
-    static final String BATCHED_REST_METHOD_URL_BASE = "method/";
-
-    static final Collection<String> errorsProxyAuthDisabled =
-            Utility.unmodifiableCollection("service_disabled", "AndroidAuthKillSwitchException");
-    static final Collection<String> errorsUserCanceled =
-            Utility.unmodifiableCollection("access_denied", "OAuthAccessDeniedException");
-}
diff --git a/facebook/src/com/facebook/Session.java b/facebook/src/com/facebook/Session.java
index 939c6e5ce..694ccf3fb 100644
--- a/facebook/src/com/facebook/Session.java
+++ b/facebook/src/com/facebook/Session.java
@@ -16,24 +16,16 @@
 
 package com.facebook;
 
-import android.Manifest;
 import android.app.Activity;
-import android.app.AlertDialog;
 import android.content.*;
-import android.content.pm.*;
-import android.content.pm.PackageManager.NameNotFoundException;
-import android.net.Uri;
+import android.content.pm.ResolveInfo;
 import android.os.*;
 import android.support.v4.app.Fragment;
 import android.support.v4.content.LocalBroadcastManager;
-import android.text.TextUtils;
 import android.util.Log;
-import android.webkit.CookieSyncManager;
-import com.facebook.android.DialogError;
-import com.facebook.android.Facebook.DialogListener;
-import com.facebook.android.FacebookError;
-import com.facebook.android.FbDialog;
-import com.facebook.android.Util;
+import com.facebook.internal.SessionAuthorizationType;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
 
 import java.io.*;
 import java.lang.ref.WeakReference;
@@ -46,7 +38,7 @@
  * </p>
  * <p>
  * Sessions must be opened before they can be used to make a Request. When a
- * Session is created, it attempts to initialize itself from a TokenCache.
+ * Session is created, it attempts to initialize itself from a TokenCachingStrategy.
  * Closing the session can optionally clear this cache.  The Session lifecycle
  * uses {@link SessionState SessionState} to indicate its state.
  * </p>
@@ -65,7 +57,7 @@
 
     /**
      * The default activity code used for authorization.
-     * 
+     *
      * @see #openForRead(OpenRequest)
      *      open
      */
@@ -112,7 +104,7 @@
      * the {@link android.support.v4.content.LocalBroadcastManager}.
      */
     public static final String ACTION_ACTIVE_SESSION_CLOSED = "com.facebook.sdk.ACTIVE_SESSION_CLOSED";
-    
+
     /**
      * Session takes application id as a constructor parameter. If this is null,
      * Session will attempt to load the application id from
@@ -120,19 +112,20 @@
      */
     public static final String APPLICATION_ID_PROPERTY = "com.facebook.sdk.ApplicationId";
 
-    private static Object staticLock = new Object();
+    private static final Object STATIC_LOCK = new Object();
     private static Session activeSession;
     private static volatile Context staticContext;
 
     // Token extension constants
     private static final int TOKEN_EXTEND_THRESHOLD_SECONDS = 24 * 60 * 60; // 1
-                                                                            // day
+    // day
     private static final int TOKEN_EXTEND_RETRY_SECONDS = 60 * 60; // 1 hour
 
     private static final String SESSION_BUNDLE_SAVE_KEY = "com.facebook.sdk.Session.saveSessionKey";
     private static final String AUTH_BUNDLE_SAVE_KEY = "com.facebook.sdk.Session.authBundleKey";
     private static final String PUBLISH_PERMISSION_PREFIX = "publish";
     private static final String MANAGE_PERMISSION_PREFIX = "manage";
+
     @SuppressWarnings("serial")
     private static final Set<String> OTHER_PUBLISH_PERMISSIONS = new HashSet<String>() {{
         add("ads_management");
@@ -144,18 +137,18 @@
     private SessionState state;
     private AccessToken tokenInfo;
     private Date lastAttemptedTokenExtendDate = new Date(0);
-    private boolean shouldAutoPublish = true;
 
     private AuthorizationRequest pendingRequest;
+    private AuthorizationClient authorizationClient;
 
     // The following are not serialized with the Session object
     private volatile Bundle authorizationBundle;
-    private List<StatusCallback> callbacks;
+    private final List<StatusCallback> callbacks;
     private Handler handler;
     private AutoPublishAsyncTask autoPublishAsyncTask;
     // This is the object that synchronizes access to state and tokenInfo
-    private Object lock = new Object();
-    private TokenCache tokenCache;
+    private final Object lock = new Object();
+    private TokenCachingStrategy tokenCachingStrategy;
     private volatile TokenRefreshRequest currentTokenRefreshRequest;
 
     /**
@@ -200,57 +193,59 @@ private Session(String applicationId, SessionState state,
         this.state = state;
         this.tokenInfo = tokenInfo;
         this.lastAttemptedTokenExtendDate = lastAttemptedTokenExtendDate;
-        this.shouldAutoPublish = shouldAutoPublish;
         this.pendingRequest = pendingRequest;
-        lock = new Object();
         handler = new Handler(Looper.getMainLooper());
         currentTokenRefreshRequest = null;
-        tokenCache = null;
+        tokenCachingStrategy = null;
         callbacks = new ArrayList<StatusCallback>();
     }
 
     /**
      * Initializes a new Session with the specified context.
-     * 
-     * @param currentContext
-     *            The Activity or Service creating this Session.
+     *
+     * @param currentContext The Activity or Service creating this Session.
      */
     public Session(Context currentContext) {
         this(currentContext, null, null, true);
     }
 
-    Session(Context context, String applicationId, TokenCache tokenCache, boolean shouldAutoPublish) {
+    Session(Context context, String applicationId, TokenCachingStrategy tokenCachingStrategy) {
+        this(context, applicationId, tokenCachingStrategy, true);
+    }
+
+    Session(Context context, String applicationId, TokenCachingStrategy tokenCachingStrategy,
+            boolean loadTokenFromCache) {
         // if the application ID passed in is null, try to get it from the
         // meta-data in the manifest.
         if ((context != null) && (applicationId == null)) {
-            applicationId = getMetadataApplicationId(context);
+            applicationId = Utility.getMetadataApplicationId(context);
         }
 
         Validate.notNull(applicationId, "applicationId");
 
         initializeStaticContext(context);
 
-        if (tokenCache == null) {
-            tokenCache = new SharedPreferencesTokenCache(staticContext);
+        if (tokenCachingStrategy == null) {
+            tokenCachingStrategy = new SharedPreferencesTokenCachingStrategy(staticContext);
         }
 
         this.applicationId = applicationId;
-        this.tokenCache = tokenCache;
+        this.tokenCachingStrategy = tokenCachingStrategy;
         this.state = SessionState.CREATED;
         this.pendingRequest = null;
         this.callbacks = new ArrayList<StatusCallback>();
         this.handler = new Handler(Looper.getMainLooper());
-        this.shouldAutoPublish = shouldAutoPublish;
 
-        Bundle tokenState = tokenCache.load();
-        if (TokenCache.hasTokenInformation(tokenState)) {
-            Date cachedExpirationDate = TokenCache.getDate(tokenState, TokenCache.EXPIRATION_DATE_KEY);
+        Bundle tokenState = loadTokenFromCache ? tokenCachingStrategy.load() : null;
+        if (TokenCachingStrategy.hasTokenInformation(tokenState)) {
+            Date cachedExpirationDate = TokenCachingStrategy
+                    .getDate(tokenState, TokenCachingStrategy.EXPIRATION_DATE_KEY);
             Date now = new Date();
 
             if ((cachedExpirationDate == null) || cachedExpirationDate.before(now)) {
                 // If expired or we require new permissions, clear out the
                 // current token cache.
-                tokenCache.clear();
+                tokenCachingStrategy.clear();
                 this.tokenInfo = AccessToken.createEmptyToken(Collections.<String>emptyList());
             } else {
                 // Otherwise we have a valid token, so use it.
@@ -263,10 +258,10 @@ public Session(Context currentContext) {
     }
 
     /**
-     * Returns a Bundle containing data that was returned from facebook during
+     * Returns a Bundle containing data that was returned from Facebook during
      * authorization.
-     * 
-     * @return a Bundle containing data that was returned from facebook during
+     *
+     * @return a Bundle containing data that was returned from Facebook during
      *         authorization.
      */
     public final Bundle getAuthorizationBundle() {
@@ -277,7 +272,7 @@ public final Bundle getAuthorizationBundle() {
 
     /**
      * Returns a boolean indicating whether the session is opened.
-     * 
+     *
      * @return a boolean indicating whether the session is opened.
      */
     public final boolean isOpened() {
@@ -295,7 +290,7 @@ public final boolean isClosed() {
     /**
      * Returns the current state of the Session.
      * See {@link SessionState} for details.
-     * 
+     *
      * @return the current state of the Session.
      */
     public final SessionState getState() {
@@ -306,7 +301,7 @@ public final SessionState getState() {
 
     /**
      * Returns the application id associated with this Session.
-     * 
+     *
      * @return the application id associated with this Session.
      */
     public final String getApplicationId() {
@@ -315,12 +310,12 @@ public final String getApplicationId() {
 
     /**
      * Returns the access token String.
-     * 
-     * @return the access token String.
+     *
+     * @return the access token String, or null if there is no access token
      */
     public final String getAccessToken() {
         synchronized (this.lock) {
-            return this.tokenInfo.getToken();
+            return (this.tokenInfo == null) ? null : this.tokenInfo.getToken();
         }
     }
 
@@ -330,14 +325,14 @@ public final String getAccessToken() {
      * </p>
      * <p>
      * Note that Session automatically attempts to extend the lifetime of Tokens
-     * as needed when facebook requests are made.
+     * as needed when Facebook requests are made.
      * </p>
-     * 
-     * @return the Date at which the current token will expire.
+     *
+     * @return the Date at which the current token will expire, or null if there is no access token
      */
     public final Date getExpirationDate() {
         synchronized (this.lock) {
-            return this.tokenInfo.getExpires();
+            return (this.tokenInfo == null) ? null : this.tokenInfo.getExpires();
         }
     }
 
@@ -348,15 +343,15 @@ public final Date getExpirationDate() {
      * <p>
      * If there is a valid token, this represents the permissions granted by
      * that token. This can change during calls to
-     * {@link #reauthorizeForRead(com.facebook.Session.ReauthorizeRequest)}
-     * or {@link #reauthorizeForPublish(com.facebook.Session.ReauthorizeRequest)}.
+     * {@link #requestNewReadPermissions}
+     * or {@link #requestNewPublishPermissions}.
      * </p>
-     * 
-     * @return the list of permissions associated with the session.
+     *
+     * @return the list of permissions associated with the session, or null if there is no access token
      */
     public final List<String> getPermissions() {
         synchronized (this.lock) {
-            return this.tokenInfo.getPermissions();
+            return (this.tokenInfo == null) ? null : this.tokenInfo.getPermissions();
         }
     }
 
@@ -382,15 +377,12 @@ public final Date getExpirationDate() {
      * UnsuportedOperationException.
      * </p>
      *
-     * @param openRequest
-     *         the open request, can be null only if the Session is in the
-     *         {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED} state
-     *
-     * @throws FacebookException
-     *         if any publish permissions are requested
+     * @param openRequest the open request, can be null only if the Session is in the
+     *                    {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED} state
+     * @throws FacebookException if any publish or manage permissions are requested
      */
     public final void openForRead(OpenRequest openRequest) {
-        open(openRequest, AuthorizationType.READ);
+        open(openRequest, SessionAuthorizationType.READ);
     }
 
     /**
@@ -406,7 +398,7 @@ public final void openForRead(OpenRequest openRequest) {
      * </p>
      * <p>
      * The permissions associated with the openRequest passed to this method must
-     * be publish permissions only and must be non-empty. Any read permissions
+     * be publish or manage permissions only and must be non-empty. Any read permissions
      * will result in a warning, and may fail during server-side authorization.
      * </p>
      * <p>
@@ -415,154 +407,117 @@ public final void openForRead(OpenRequest openRequest) {
      * UnsuportedOperationException.
      * </p>
      *
-     * @param openRequest
-     *         the open request, can be null only if the Session is in the
-     *         {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED} state
-     *
-     * @throws FacebookException
-     *         if the passed in request is null or has no permissions set.
+     * @param openRequest the open request, can be null only if the Session is in the
+     *                    {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED} state
+     * @throws FacebookException if the passed in request is null or has no permissions set.
      */
     public final void openForPublish(OpenRequest openRequest) {
-        open(openRequest, AuthorizationType.PUBLISH);
+        open(openRequest, SessionAuthorizationType.PUBLISH);
     }
 
     /**
-     * <p>
-     * Logs a user in to Facebook.
-     * </p>
-     * <p>
-     * A session may not be used with {@link Request Request} and other classes
-     * in the SDK until it is open. If, prior to calling open, the session is in
-     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
-     * state, then the Session becomes usable immediately with no user interaction.
-     * Otherwise, this will open the Session with basic permissions.
-     * </p>
-     * <p>
-     * Any open method must be called at most once, and cannot be called after the
-     * Session is closed. Calling the method at an invalid time will result in
-     * UnsuportedOperationException.
-     * </p>
+     * Opens a session based on an existing Facebook access token. This method should be used
+     * only in instances where an application has previously obtained an access token and wishes
+     * to import it into the Session/TokenCachingStrategy-based session-management system. An
+     * example would be an application which previously did not use the Facebook SDK for Android
+     * and implemented its own session-management scheme, but wishes to implement an upgrade path
+     * for existing users so they do not need to log in again when upgrading to a version of
+     * the app that uses the SDK.
+     * <p/>
+     * No validation is done that the token, token source, or permissions are actually valid.
+     * It is the caller's responsibility to ensure that these accurately reflect the state of
+     * the token that has been passed in, or calls to the Facebook API may fail.
      *
-     * @param activity
-     *         the Activity used to open the Session
+     * @param accessToken the access token obtained from Facebook
+     * @param callback    a callback that will be called when the session status changes; may be null
      */
-    public final void openForRead(Activity activity) {
-        openForRead(new OpenRequest(activity));
-    }
+    public final void open(AccessToken accessToken, StatusCallback callback) {
+        synchronized (this.lock) {
+            if (pendingRequest != null) {
+                throw new UnsupportedOperationException(
+                        "Session: an attempt was made to open a session that has a pending request.");
+            }
 
-    /**
-     * <p>
-     * Logs a user in to Facebook.
-     * </p>
-     * <p>
-     * A session may not be used with {@link Request Request} and other classes
-     * in the SDK until it is open. If, prior to calling open, the session is in
-     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
-     * state, then the Session becomes usable immediately with no user interaction.
-     * Otherwise, this will open the Session with basic permissions.
-     * </p>
-     * <p>
-     * Any open method must be called at most once, and cannot be called after the
-     * Session is closed. Calling the method at an invalid time will result in
-     * UnsuportedOperationException.
-     * </p>
-     *
-     * @param fragment
-     *         the Fragment used to open the Session
-     */
-    public final void openForRead(Fragment fragment) {
-        openForRead(new OpenRequest(fragment));
-    }
+            if (state != SessionState.CREATED && state != SessionState.CREATED_TOKEN_LOADED) {
+                throw new UnsupportedOperationException(
+                        "Session: an attempt was made to open an already opened session.");
+            }
 
-    /**
-     * <p>
-     * Logs a user in to Facebook.
-     * </p>
-     * <p>
-     * This method should only be called if the session is in
-     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
-     * state.
-     * </p>
-     * <p>
-     * Any open method must be called at most once, and cannot be called after the
-     * Session is closed. Calling the method at an invalid time will result in
-     * UnsuportedOperationException.
-     * </p>
-     *
-     * @throws UnsupportedOperationException
-     *          If the session is in an invalid state.
-     */
-    public final void open() {
-        if (state.equals(SessionState.CREATED_TOKEN_LOADED)) {
-            openForRead((OpenRequest) null);
-        } else {
-            throw new UnsupportedOperationException(String.format(
-                    "Cannot call open without an OpenRequest when the state is %s",
-                    state.toString()));
+            if (callback != null) {
+                addCallback(callback);
+            }
+
+            this.tokenInfo = accessToken;
+
+            if (this.tokenCachingStrategy != null) {
+                this.tokenCachingStrategy.save(accessToken.toCacheBundle());
+            }
+
+            final SessionState oldState = state;
+            state = SessionState.OPENED;
+            this.postStateChange(oldState, state, null);
         }
+
+        autoPublishAsync();
     }
 
     /**
      * <p>
-     * Reauthorizes the Session, with additional read permissions.
+     * Issues a request to add new read permissions to the Session.
      * </p>
      * <p>
      * If successful, this will update the set of permissions on this session to
      * match the newPermissions. If this fails, the Session remains unchanged.
      * </p>
      * <p>
-     * The permissions associated with the reauthorizeRequest passed to this method must
+     * The permissions associated with the newPermissionsRequest passed to this method must
      * be read permissions only (or null/empty). It is not allowed to pass publish
      * permissions to this method and will result in an exception being thrown.
      * </p>
      *
-     * @param reauthorizeRequest the reauthorization request
+     * @param newPermissionsRequest the new permissions request
      */
-    public final void reauthorizeForRead(ReauthorizeRequest reauthorizeRequest) {
-        reauthorize(reauthorizeRequest, AuthorizationType.READ);
+    public final void requestNewReadPermissions(NewPermissionsRequest newPermissionsRequest) {
+        requestNewPermissions(newPermissionsRequest, SessionAuthorizationType.READ);
     }
 
     /**
      * <p>
-     * Reauthorizes the Session, with additional publish permissions.
+     * Issues a request to add new publish or manage permissions to the Session.
      * </p>
      * <p>
      * If successful, this will update the set of permissions on this session to
      * match the newPermissions. If this fails, the Session remains unchanged.
      * </p>
      * <p>
-     * The permissions associated with the reauthorizeRequest passed to this method must
-     * be publish permissions only and must be non-empty. Any read permissions
+     * The permissions associated with the newPermissionsRequest passed to this method must
+     * be publish or manage permissions only and must be non-empty. Any read permissions
      * will result in a warning, and may fail during server-side authorization.
      * </p>
      *
-     * @param reauthorizeRequest the reauthorization request
+     * @param newPermissionsRequest the new permissions request
      */
-    public final void reauthorizeForPublish(ReauthorizeRequest reauthorizeRequest) {
-        reauthorize(reauthorizeRequest, AuthorizationType.PUBLISH);
+    public final void requestNewPublishPermissions(NewPermissionsRequest newPermissionsRequest) {
+        requestNewPermissions(newPermissionsRequest, SessionAuthorizationType.PUBLISH);
     }
 
     /**
      * Provides an implementation for {@link Activity#onActivityResult
      * onActivityResult} that updates the Session based on information returned
      * during the authorization flow. The Activity that calls open or
-     * reauthorize should forward the resulting onActivityResult call here to
+     * requestNewPermissions should forward the resulting onActivityResult call here to
      * update the Session state based on the contents of the resultCode and
      * data.
-     * 
-     * @param currentActivity
-     *            The Activity that is forwarding the onActivityResult call.
-     * @param requestCode
-     *            The requestCode parameter from the forwarded call. When this
-     *            onActivityResult occurs as part of facebook authorization
-     *            flow, this value is the activityCode passed to open or
-     *            authorize.
-     * @param resultCode
-     *            An int containing the resultCode parameter from the forwarded
-     *            call.
-     * @param data
-     *            The Intent passed as the data parameter from the forwarded
-     *            call.
+     *
+     * @param currentActivity The Activity that is forwarding the onActivityResult call.
+     * @param requestCode     The requestCode parameter from the forwarded call. When this
+     *                        onActivityResult occurs as part of Facebook authorization
+     *                        flow, this value is the activityCode passed to open or
+     *                        authorize.
+     * @param resultCode      An int containing the resultCode parameter from the forwarded
+     *                        call.
+     * @param data            The Intent passed as the data parameter from the forwarded
+     *                        call.
      * @return A boolean indicating whether the requestCode matched a pending
      *         authorization request for this Session.
      */
@@ -571,67 +526,32 @@ public final boolean onActivityResult(Activity currentActivity, int requestCode,
 
         initializeStaticContext(currentActivity);
 
-        AuthorizationRequest currentRequest = null;
-        AuthorizationRequest retryRequest = null;
-        AccessToken newToken = null;
-        Exception exception = null;
-
         synchronized (lock) {
             if (pendingRequest == null || (requestCode != pendingRequest.getRequestCode())) {
                 return false;
-            } else {
-                currentRequest = pendingRequest;
             }
         }
 
-        this.authorizationBundle = null;
-
-        if (resultCode == Activity.RESULT_CANCELED) {
-            if (data == null) {
-                // User pressed the 'back' button
-                exception = new FacebookOperationCanceledException("Log in was canceled by the user");
-            } else {
-                this.authorizationBundle = data.getExtras();
-                exception = new FacebookAuthorizationException(this.authorizationBundle.getString("error"));
-            }
-        } else if (resultCode == Activity.RESULT_OK) {
-            Validate.notNull(data, "data");
-
-            this.authorizationBundle = data.getExtras();
-            String error = this.authorizationBundle.getString("error");
-            if (error == null) {
-                error = this.authorizationBundle.getString("error_type");
-            }
-            if (error != null) {
-                if (ServerProtocol.errorsProxyAuthDisabled.contains(error)) {
-                    retryRequest = currentRequest.setLoginBehavior(SessionLoginBehavior.SUPPRESS_SSO);
-                } else if (ServerProtocol.errorsUserCanceled.contains(error)) {
-                    exception = new FacebookOperationCanceledException("User canceled log in.");
-                } else {
-                    String description = this.authorizationBundle.getString("error_description");
-                    if (description != null) {
-                        error = error + ": " + description;
-                    }
-                    exception = new FacebookAuthorizationException(error);
-                }
-            } else {
-                newToken = AccessToken.createFromSSO(currentRequest.permissions, data);
-            }
-        }
+        AccessToken newToken = null;
+        Exception exception = null;
 
-        if (retryRequest != null) {
-            synchronized (lock) {
-                if (pendingRequest == currentRequest) {
-                    pendingRequest = retryRequest;
-                } else {
-                    retryRequest = null;
-                }
+        if (data != null) {
+            AuthorizationClient.Result result = (AuthorizationClient.Result) data.getSerializableExtra(
+                    LoginActivity.RESULT_KEY);
+            if (result != null) {
+                // This came from LoginActivity.
+                handleAuthorizationResult(resultCode, result);
+                return true;
+            } else if (authorizationClient != null) {
+                // Delegate to the auth client.
+                authorizationClient.onActivityResult(requestCode, resultCode, data);
+                return true;
             }
-            authorize(retryRequest);
-        } else {
-            finishAuth(newToken, exception);
+        } else if (resultCode == Activity.RESULT_CANCELED) {
+            exception = new FacebookOperationCanceledException("User canceled operation.");
         }
 
+        finishAuthOrReauth(newToken, exception);
         return true;
     }
 
@@ -645,19 +565,19 @@ public final void close() {
             final SessionState oldState = this.state;
 
             switch (this.state) {
-            case CREATED:
-            case OPENING:
-                this.state = SessionState.CLOSED_LOGIN_FAILED;
-                postStateChange(oldState, this.state, new FacebookException(
-                        "Log in attempt aborted."));
-                break;
-
-            case CREATED_TOKEN_LOADED:
-            case OPENED:
-            case OPENED_TOKEN_UPDATED:
-                this.state = SessionState.CLOSED;
-                postStateChange(oldState, this.state, null);
-                break;
+                case CREATED:
+                case OPENING:
+                    this.state = SessionState.CLOSED_LOGIN_FAILED;
+                    postStateChange(oldState, this.state, new FacebookException(
+                            "Log in attempt aborted."));
+                    break;
+
+                case CREATED_TOKEN_LOADED:
+                case OPENED:
+                case OPENED_TOKEN_UPDATED:
+                    this.state = SessionState.CLOSED;
+                    postStateChange(oldState, this.state, null);
+                    break;
             }
         }
     }
@@ -667,61 +587,70 @@ public final void close() {
      * cache related to the Session.
      */
     public final void closeAndClearTokenInformation() {
-        if (this.tokenCache != null) {
-            this.tokenCache.clear();
+        if (this.tokenCachingStrategy != null) {
+            this.tokenCachingStrategy.clear();
         }
         Utility.clearFacebookCookies(staticContext);
         close();
     }
 
+    /**
+     * Adds a callback that will be called when the state of this Session changes.
+     *
+     * @param callback the callback
+     */
+    public final void addCallback(StatusCallback callback) {
+        synchronized (callbacks) {
+            if (callback != null && !callbacks.contains(callback)) {
+                callbacks.add(callback);
+            }
+        }
+    }
+
+    /**
+     * Removes a StatusCallback from this Session.
+     *
+     * @param callback the callback
+     */
+    public final void removeCallback(StatusCallback callback) {
+        synchronized (callbacks) {
+            callbacks.remove(callback);
+        }
+    }
+
     @Override
-    public final String toString() {
+    public String toString() {
         return new StringBuilder().append("{Session").append(" state:").append(this.state).append(", token:")
                 .append((this.tokenInfo == null) ? "null" : this.tokenInfo).append(", appId:")
                 .append((this.applicationId == null) ? "null" : this.applicationId).append("}").toString();
     }
 
-    /**
-     * <p>
-     * Do not use this method.
-     * </p>
-     * <p>
-     * Refreshes the token based on information obtained from the Facebook
-     * class. This is exposed to enable the com.facebook.android.Facebook class
-     * to refresh the token in its underlying Session. Normally Session
-     * automatically updates its token. This is only provided for backwards
-     * compatibility and may be removed in a future release.
-     * </p>
-     * 
-     * @param bundle
-     *            Opaque Bundle of data from the Facebook class.
-     */
-    public void internalRefreshToken(Bundle bundle) {
+    void extendTokenCompleted(Bundle bundle) {
         synchronized (this.lock) {
             final SessionState oldState = this.state;
 
             switch (this.state) {
-            case OPENED:
-                this.state = SessionState.OPENED_TOKEN_UPDATED;
-                postStateChange(oldState, this.state, null);
-                break;
-            case OPENED_TOKEN_UPDATED:
-                break;
-            default:
-                // Silently ignore attempts to refresh token if we are not open
-                Log.d(TAG, "refreshToken ignored in state " + this.state);
-                return;
+                case OPENED:
+                    this.state = SessionState.OPENED_TOKEN_UPDATED;
+                    postStateChange(oldState, this.state, null);
+                    break;
+                case OPENED_TOKEN_UPDATED:
+                    break;
+                default:
+                    // Silently ignore attempts to refresh token if we are not open
+                    Log.d(TAG, "refreshToken ignored in state " + this.state);
+                    return;
             }
-            this.tokenInfo = AccessToken.createForRefresh(this.tokenInfo, bundle);
-            if (this.tokenCache != null) {
-                this.tokenCache.save(this.tokenInfo.toCacheBundle());
+            this.tokenInfo = AccessToken.createFromRefresh(this.tokenInfo, bundle);
+            if (this.tokenCachingStrategy != null) {
+                this.tokenCachingStrategy.save(this.tokenInfo.toCacheBundle());
             }
         }
     }
 
     private Object writeReplace() {
         return new SerializationProxyV1(applicationId, state, tokenInfo,
-                lastAttemptedTokenExtendDate, shouldAutoPublish, pendingRequest);
+                lastAttemptedTokenExtendDate, false, pendingRequest);
     }
 
     // have a readObject that throws to prevent spoofing
@@ -733,10 +662,10 @@ private void readObject(ObjectInputStream stream) throws InvalidObjectException
      * Save the Session object into the supplied Bundle.
      *
      * @param session the Session to save
-     * @param bundle the Bundle to save the Session to
+     * @param bundle  the Bundle to save the Session to
      */
     public static final void saveSession(Session session, Bundle bundle) {
-        if (bundle != null && session != null) {
+        if (bundle != null && session != null && !bundle.containsKey(SESSION_BUNDLE_SAVE_KEY)) {
             ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
             try {
                 new ObjectOutputStream(outputStream).writeObject(session);
@@ -752,20 +681,16 @@ public static final void saveSession(Session session, Bundle bundle) {
      * Restores the saved session from a Bundle, if any. Returns the restored Session or
      * null if it could not be restored.
      *
-     * @param context
-     *            the Activity or Service creating the Session, must not be null
-     * @param cache
-     *            the TokenCache to use to load and store the token. If this is
-     *            null, a default token cache that stores data in
-     *            SharedPreferences will be used
-     * @param callback
-     *            the callback to notify for Session state changes, can be null
-     * @param bundle
-     *            the bundle to restore the Session from
+     * @param context         the Activity or Service creating the Session, must not be null
+     * @param cachingStrategy the TokenCachingStrategy to use to load and store the token. If this is
+     *                        null, a default token cachingStrategy that stores data in
+     *                        SharedPreferences will be used
+     * @param callback        the callback to notify for Session state changes, can be null
+     * @param bundle          the bundle to restore the Session from
      * @return the restored Session, or null
      */
     public static final Session restoreSession(
-            Context context, TokenCache cache, StatusCallback callback, Bundle bundle) {
+            Context context, TokenCachingStrategy cachingStrategy, StatusCallback callback, Bundle bundle) {
         if (bundle == null) {
             return null;
         }
@@ -775,15 +700,15 @@ public static final Session restoreSession(
             try {
                 Session session = (Session) (new ObjectInputStream(is)).readObject();
                 initializeStaticContext(context);
-                if (cache != null) {
-                    session.tokenCache = cache;
+                if (cachingStrategy != null) {
+                    session.tokenCachingStrategy = cachingStrategy;
                 } else {
-                    session.tokenCache = new SharedPreferencesTokenCache(context);
+                    session.tokenCachingStrategy = new SharedPreferencesTokenCachingStrategy(context);
                 }
                 if (callback != null) {
                     session.addCallback(callback);
                 }
-                session.authorizationBundle =  bundle.getBundle(AUTH_BUNDLE_SAVE_KEY);
+                session.authorizationBundle = bundle.getBundle(AUTH_BUNDLE_SAVE_KEY);
                 return session;
             } catch (ClassNotFoundException e) {
                 Log.w(TAG, "Unable to restore session", e);
@@ -797,11 +722,11 @@ public static final Session restoreSession(
 
     /**
      * Returns the current active Session, or null if there is none.
-     * 
+     *
      * @return the current active Session, or null if there is none.
      */
     public static final Session getActiveSession() {
-        synchronized (Session.staticLock) {
+        synchronized (Session.STATIC_LOCK) {
             return Session.activeSession;
         }
     }
@@ -817,13 +742,12 @@ public static final Session getActiveSession() {
      * <p>
      * It is legal to set this to null, or to a Session that is not yet open.
      * </p>
-     * 
-     * @param session
-     *            A Session to use as the active Session, or null to indicate
-     *            that there is no active Session.
+     *
+     * @param session A Session to use as the active Session, or null to indicate
+     *                that there is no active Session.
      */
     public static final void setActiveSession(Session session) {
-        synchronized (Session.staticLock) {
+        synchronized (Session.STATIC_LOCK) {
             if (session != Session.activeSession) {
                 Session oldSession = Session.activeSession;
 
@@ -852,11 +776,10 @@ public static final void setActiveSession(Session session) {
      * Create a new Session, and if a token cache is available, open the
      * Session and make it active without any user interaction.
      *
-     * @param context
-     *         The Context creating this session
+     * @param context The Context creating this session
      * @return The new session or null if one could not be created
      */
-    public static Session openActiveSession(Context context) {
+    public static Session openActiveSessionFromCache(Context context) {
         return openActiveSession(context, false, null);
     }
 
@@ -870,35 +793,11 @@ public static Session openActiveSession(Context context) {
      * it if it requires no user interaction (i.e. the token cache is available and
      * there are cached tokens).
      *
-     * @param activity
-     *            The Activity that is opening the new Session.
-     * @param allowLoginUI
-     *            if false, only sets the active session and opens it if it
-     *            does not require user interaction
-     * @return The new Session or null if one could not be created
-     */
-    public static Session openActiveSession(Activity activity, boolean allowLoginUI) {
-        return openActiveSession(activity, allowLoginUI, (StatusCallback) null);
-    }
-
-    /**
-     * If allowLoginUI is true, this will create a new Session, make it active, and
-     * open it. If the default token cache is not available, then this will request
-     * basic permissions. If the default token cache is available and cached tokens
-     * are loaded, this will use the cached token and associated permissions.
-     * <p/>
-     * If allowedLoginUI is false, this will only create the active session and open
-     * it if it requires no user interaction (i.e. the token cache is available and
-     * there are cached tokens).
-     * 
-     * @param activity
-     *            The Activity that is opening the new Session.
-     * @param allowLoginUI
-     *            if false, only sets the active session and opens it if it
-     *            does not require user interaction
-     * @param callback
-     *            The {@link StatusCallback SessionStatusCallback} to
-     *            notify regarding Session state changes.
+     * @param activity     The Activity that is opening the new Session.
+     * @param allowLoginUI if false, only sets the active session and opens it if it
+     *                     does not require user interaction
+     * @param callback     The {@link StatusCallback SessionStatusCallback} to
+     *                     notify regarding Session state changes. May be null.
      * @return The new Session or null if one could not be created
      */
     public static Session openActiveSession(Activity activity, boolean allowLoginUI,
@@ -916,55 +815,55 @@ public static Session openActiveSession(Activity activity, boolean allowLoginUI,
      * it if it requires no user interaction (i.e. the token cache is available and
      * there are cached tokens).
      *
-     * @param context
-     *            The Activity or Service creating this Session
-     * @param fragment
-     *            The Fragment that is opening the new Session.
-     * @param allowLoginUI
-     *            if false, only sets the active session and opens it if it
-     *            does not require user interaction
+     * @param context      The Activity or Service creating this Session
+     * @param fragment     The Fragment that is opening the new Session.
+     * @param allowLoginUI if false, only sets the active session and opens it if it
+     *                     does not require user interaction
+     * @param callback     The {@link StatusCallback SessionStatusCallback} to
+     *                     notify regarding Session state changes.
      * @return The new Session or null if one could not be created
      */
-    public static Session openActiveSession(Context context, Fragment fragment, boolean allowLoginUI) {
-        return openActiveSession(context, fragment, allowLoginUI, null);
+    public static Session openActiveSession(Context context, Fragment fragment,
+            boolean allowLoginUI, StatusCallback callback) {
+        return openActiveSession(context, allowLoginUI, new OpenRequest(fragment).setCallback(callback));
     }
 
     /**
-     * If allowLoginUI is true, this will create a new Session, make it active, and
-     * open it. If the default token cache is not available, then this will request
-     * basic permissions. If the default token cache is available and cached tokens
-     * are loaded, this will use the cached token and associated permissions.
+     * Opens a session based on an existing Facebook access token, and also makes this session
+     * the currently active session. This method should be used
+     * only in instances where an application has previously obtained an access token and wishes
+     * to import it into the Session/TokenCachingStrategy-based session-management system. A primary
+     * example would be an application which previously did not use the Facebook SDK for Android
+     * and implemented its own session-management scheme, but wishes to implement an upgrade path
+     * for existing users so they do not need to log in again when upgrading to a version of
+     * the app that uses the SDK. In general, this method will be called only once, when the app
+     * detects that it has been upgraded -- after that, the usual Session lifecycle methods
+     * should be used to manage the session and its associated token.
      * <p/>
-     * If allowedLoginUI is false, this will only create the active session and open
-     * it if it requires no user interaction (i.e. the token cache is available and
-     * there are cached tokens).
+     * No validation is done that the token, token source, or permissions are actually valid.
+     * It is the caller's responsibility to ensure that these accurately reflect the state of
+     * the token that has been passed in, or calls to the Facebook API may fail.
      *
-     * @param context
-     *            The Activity or Service creating this Session
-     * @param fragment
-     *            The Fragment that is opening the new Session.
-     * @param allowLoginUI
-     *            if false, only sets the active session and opens it if it
-     *            does not require user interaction
-     * @param callback
-     *            The {@link StatusCallback SessionStatusCallback} to
-     *            notify regarding Session state changes.
+     * @param context     the Context to use for creation the session
+     * @param accessToken the access token obtained from Facebook
+     * @param callback    a callback that will be called when the session status changes; may be null
      * @return The new Session or null if one could not be created
      */
-    public static Session openActiveSession(Context context, Fragment fragment,
-            boolean allowLoginUI, StatusCallback callback) {
-        return openActiveSession(context, allowLoginUI, new OpenRequest(fragment).setCallback(callback));
+    public static Session openActiveSessionWithAccessToken(Context context, AccessToken accessToken,
+            StatusCallback callback) {
+        Session session = new Session(context, null, null, false);
+
+        setActiveSession(session);
+        session.open(accessToken, callback);
+
+        return session;
     }
 
     private static Session openActiveSession(Context context, boolean allowLoginUI, OpenRequest openRequest) {
         Session session = new Builder(context).build();
         if (SessionState.CREATED_TOKEN_LOADED.equals(session.getState()) || allowLoginUI) {
             setActiveSession(session);
-            if (openRequest != null) {
-                session.openForRead(openRequest);
-            } else {
-                session.open();
-            }
+            session.openForRead(openRequest);
             return session;
         }
         return null;
@@ -984,13 +883,14 @@ static void initializeStaticContext(Context currentContext) {
     void authorize(AuthorizationRequest request) {
         boolean started = false;
 
+        request.setApplicationId(applicationId);
+
         autoPublishAsync();
 
-        if (!started && request.allowKatana()) {
-            started = tryKatanaProxyAuth(request);
-        }
-        if (!started && request.allowWebView()) {
-            started = tryDialogAuth(request);
+        started = tryLoginActivity(request);
+
+        if (!started && request.isLegacy) {
+            started = tryLegacyAuth(request);
         }
 
         if (!started) {
@@ -1010,28 +910,16 @@ void authorize(AuthorizationRequest request) {
         }
     }
 
-    public final void addCallback(StatusCallback callback) {
-        synchronized(callbacks) {
-            if (callback != null && !callbacks.contains(callback)) {
-                callbacks.add(callback);
-            }
-        }
-    }
-
-    public final void removeCallback(StatusCallback callback) {
-        synchronized(callbacks) {
-            callbacks.remove(callback);
-        }
-    }
-
-    private void open(OpenRequest openRequest, AuthorizationType authType) {
+    private void open(OpenRequest openRequest, SessionAuthorizationType authType) {
         validatePermissions(openRequest, authType);
         validateLoginBehavior(openRequest);
+
         SessionState newState;
         synchronized (this.lock) {
             if (pendingRequest != null) {
-                throw new UnsupportedOperationException(
-                        "Session: an attempt was made to open a session that has a pending request.");
+                postStateChange(state, state, new UnsupportedOperationException(
+                        "Session: an attempt was made to open a session that has a pending request."));
+                return;
             }
             final SessionState oldState = this.state;
 
@@ -1070,37 +958,37 @@ private void open(OpenRequest openRequest, AuthorizationType authType) {
         }
     }
 
-    private void reauthorize(ReauthorizeRequest reauthorizeRequest, AuthorizationType authType) {
-        validatePermissions(reauthorizeRequest, authType);
-        validateLoginBehavior(reauthorizeRequest);
-        if (reauthorizeRequest != null) {
+    private void requestNewPermissions(NewPermissionsRequest newPermissionsRequest, SessionAuthorizationType authType) {
+        validatePermissions(newPermissionsRequest, authType);
+        validateLoginBehavior(newPermissionsRequest);
+
+        if (newPermissionsRequest != null) {
             synchronized (this.lock) {
                 if (pendingRequest != null) {
                     throw new UnsupportedOperationException(
-                            "Session: an attempt was made to reauthorize a session that has a pending request.");
+                            "Session: an attempt was made to request new permissions for a session that has a pending request.");
                 }
                 switch (this.state) {
                     case OPENED:
                     case OPENED_TOKEN_UPDATED:
-                        pendingRequest = reauthorizeRequest;
+                        pendingRequest = newPermissionsRequest;
                         break;
                     default:
                         throw new UnsupportedOperationException(
-                                "Session: an attempt was made to reauthorize a session that is not currently open.");
+                                "Session: an attempt was made to request new permissions for a session that is not currently open.");
                 }
             }
 
-            authorize(reauthorizeRequest);
+            newPermissionsRequest.setValidateSameFbidAsToken(getAccessToken());
+            authorize(newPermissionsRequest);
         }
     }
 
     private void validateLoginBehavior(AuthorizationRequest request) {
-        if (request != null && !request.suppressLoginActivityVerification &&
-                (SessionLoginBehavior.SSO_WITH_FALLBACK.equals(request.getLoginBehavior()) ||
-                 SessionLoginBehavior.SUPPRESS_SSO.equals(request.getLoginBehavior()))) {
+        if (request != null && !request.isLegacy) {
             Intent intent = new Intent();
             intent.setClass(getStaticContext(), LoginActivity.class);
-            if (!resolveIntent(intent, false)) {
+            if (!resolveIntent(intent)) {
                 throw new FacebookException(String.format(
                         "Cannot use SessionLoginBehavior %s when %s is not declared as an activity in AndroidManifest.xml",
                         request.getLoginBehavior(), LoginActivity.class.getName()));
@@ -1108,33 +996,33 @@ private void validateLoginBehavior(AuthorizationRequest request) {
         }
     }
 
-    private void validatePermissions(AuthorizationRequest request, AuthorizationType authType) {
+    private void validatePermissions(AuthorizationRequest request, SessionAuthorizationType authType) {
         if (request == null || Utility.isNullOrEmpty(request.getPermissions())) {
-            if (AuthorizationType.PUBLISH.equals(authType)) {
-                throw new FacebookException("Cannot request publish authorization with no permissions.");
+            if (SessionAuthorizationType.PUBLISH.equals(authType)) {
+                throw new FacebookException("Cannot request publish or manage authorization with no permissions.");
             }
             return; // nothing to check
         }
         for (String permission : request.getPermissions()) {
             if (isPublishPermission(permission)) {
-                if (AuthorizationType.READ.equals(authType)) {
+                if (SessionAuthorizationType.READ.equals(authType)) {
                     throw new FacebookException(
                             String.format(
-                                    "Cannot pass a publish permission (%s) to a request for read authorization",
+                                    "Cannot pass a publish or manage permission (%s) to a request for read authorization",
                                     permission));
                 }
             } else {
-                if (AuthorizationType.PUBLISH.equals(authType)) {
+                if (SessionAuthorizationType.PUBLISH.equals(authType)) {
                     Log.w(TAG,
                             String.format(
-                                    "Should not pass a read permission (%s) to a request for publish authorization",
+                                    "Should not pass a read permission (%s) to a request for publish or manage authorization",
                                     permission));
                 }
             }
         }
     }
 
-    private boolean isPublishPermission(String permission) {
+    static boolean isPublishPermission(String permission) {
         return permission != null &&
                 (permission.startsWith(PUBLISH_PERMISSION_PREFIX) ||
                         permission.startsWith(MANAGE_PERMISSION_PREFIX) ||
@@ -1142,14 +1030,27 @@ private boolean isPublishPermission(String permission) {
 
     }
 
-    private boolean tryActivityAuth(Intent intent, AuthorizationRequest request, boolean validateSignature) {
-        intent.putExtra("client_id", this.applicationId);
-
-        if (!Utility.isNullOrEmpty(request.getPermissions())) {
-            intent.putExtra("scope", TextUtils.join(",", request.getPermissions()));
+    private void handleAuthorizationResult(int resultCode, AuthorizationClient.Result result) {
+        AccessToken newToken = null;
+        Exception exception = null;
+        if (resultCode == Activity.RESULT_OK) {
+            if (result.code == AuthorizationClient.Result.Code.SUCCESS) {
+                newToken = result.token;
+            } else {
+                exception = new FacebookAuthorizationException(result.errorMessage);
+            }
+        } else if (resultCode == Activity.RESULT_CANCELED) {
+            exception = new FacebookOperationCanceledException(result.errorMessage);
         }
 
-        if (!resolveIntent(intent, validateSignature)) {
+        authorizationClient = null;
+        finishAuthOrReauth(newToken, exception);
+    }
+
+    private boolean tryLoginActivity(AuthorizationRequest request) {
+        Intent intent = getLoginActivityIntent(request);
+
+        if (!resolveIntent(intent)) {
             return false;
         }
 
@@ -1158,152 +1059,114 @@ private boolean tryActivityAuth(Intent intent, AuthorizationRequest request, boo
         } catch (ActivityNotFoundException e) {
             return false;
         }
+
         return true;
     }
 
-    private boolean resolveIntent(Intent intent, boolean validateSignature) {
+    private boolean resolveIntent(Intent intent) {
         ResolveInfo resolveInfo = getStaticContext().getPackageManager().resolveActivity(intent, 0);
-        if ((resolveInfo == null) ||
-                (validateSignature && !validateFacebookAppSignature(resolveInfo.activityInfo.packageName))) {
+        if (resolveInfo == null) {
             return false;
         }
         return true;
     }
 
-    private boolean tryDialogAuth(final AuthorizationRequest request) {
+    private Intent getLoginActivityIntent(AuthorizationRequest request) {
         Intent intent = new Intent();
-
         intent.setClass(getStaticContext(), LoginActivity.class);
-        if (tryActivityAuth(intent, request, false)) {
-            return true;
-        }
-
-        Log.w(TAG,
-                String.format("Please add %s as an activity to your AndroidManifest.xml",
-                        LoginActivity.class.getName()));
-
-        int permissionCheck = getStaticContext().checkCallingOrSelfPermission(Manifest.permission.INTERNET);
-        Activity activityContext = request.getStartActivityDelegate().getActivityContext();
-        if (permissionCheck != PackageManager.PERMISSION_GRANTED) {
-            AlertDialog.Builder builder = new AlertDialog.Builder(activityContext);
-            builder.setTitle("AndroidManifest Error");
-            builder.setMessage("WebView login requires INTERNET permission");
-            builder.create().show();
-            return false;
-        }
-
-        Bundle parameters = new Bundle();
-        if (!Utility.isNullOrEmpty(request.getPermissions())) {
-            String scope = TextUtils.join(",", request.getPermissions());
-            parameters.putString(ServerProtocol.DIALOG_PARAM_SCOPE, scope);
-        }
-
-        // The call to clear cookies will create the first instance of CookieSyncManager if necessary
-        Utility.clearFacebookCookies(getStaticContext());
+        intent.setAction(request.getLoginBehavior().toString());
 
-        DialogListener listener = new DialogListener() {
-            public void onComplete(Bundle bundle) {
-                // Ensure any cookies set by the dialog are saved
-                CookieSyncManager.getInstance().sync();
-                AccessToken newToken = AccessToken.createFromDialog(request.getPermissions(), bundle);
-                Session.this.authorizationBundle = bundle;
-                Session.this.finishAuth(newToken, null);
-            }
+        // Let LoginActivity populate extras appropriately
+        AuthorizationClient.AuthorizationRequest authClientRequest = request.getAuthorizationClientRequest();
+        Bundle extras = LoginActivity.populateIntentExtras(authClientRequest);
+        intent.putExtras(extras);
 
-            public void onError(DialogError error) {
-                Bundle bundle = new Bundle();
-                bundle.putInt(WEB_VIEW_ERROR_CODE_KEY, error.getErrorCode());
-                bundle.putString(WEB_VIEW_FAILING_URL_KEY, error.getFailingUrl());
-                Session.this.authorizationBundle = bundle;
+        return intent;
+    }
 
-                Exception exception = new FacebookAuthorizationException(error.getMessage());
-                Session.this.finishAuth(null, exception);
+    private boolean tryLegacyAuth(final AuthorizationRequest request) {
+        authorizationClient = new AuthorizationClient();
+        authorizationClient.setOnCompletedListener(new AuthorizationClient.OnCompletedListener() {
+            @Override
+            public void onCompleted(AuthorizationClient.Result result) {
+                handleAuthorizationResult(Activity.RESULT_OK, result);
             }
+        });
+        authorizationClient.setContext(getStaticContext());
+        authorizationClient.startOrContinueAuth(request.getAuthorizationClientRequest());
 
-            public void onFacebookError(FacebookError error) {
-                Exception exception = new FacebookAuthorizationException(error.getMessage());
-                Session.this.finishAuth(null, exception);
-            }
+        return true;
+    }
 
-            public void onCancel() {
-                Exception exception = new FacebookOperationCanceledException("User canceled log in.");
-                Session.this.finishAuth(null, exception);
-            }
-        };
+    @SuppressWarnings("incomplete-switch")
+    void finishAuthOrReauth(AccessToken newToken, Exception exception) {
+        // If the token we came up with is expired/invalid, then auth failed.
+        if ((newToken != null) && newToken.isInvalid()) {
+            newToken = null;
+            exception = new FacebookException("Invalid access token.");
+        }
 
-        parameters.putString(ServerProtocol.DIALOG_PARAM_DISPLAY, "touch");
-        parameters.putString(ServerProtocol.DIALOG_PARAM_REDIRECT_URI, "fbconnect://success");
-        parameters.putString(ServerProtocol.DIALOG_PARAM_TYPE, "user_agent");
-        parameters.putString(ServerProtocol.DIALOG_PARAM_CLIENT_ID, this.applicationId);
+        synchronized (this.lock) {
+            switch (this.state) {
+                case OPENING:
+                    // This means we are authorizing for the first time in this Session.
+                    finishAuthorization(newToken, exception);
+                    break;
 
-        Uri uri = Utility.buildUri(ServerProtocol.DIALOG_AUTHORITY, ServerProtocol.DIALOG_OAUTH_PATH, parameters);
-        new FbDialog(activityContext, uri.toString(), listener).show();
+                case OPENED:
+                case OPENED_TOKEN_UPDATED:
+                    // This means we are reauthorizing.
+                    finishReauthorization(newToken, exception);
 
-        return true;
+                    break;
+            }
+        }
     }
 
-    private boolean tryKatanaProxyAuth(AuthorizationRequest request) {
-        Intent intent = new Intent();
+    private void finishAuthorization(AccessToken newToken, Exception exception) {
+        final SessionState oldState = state;
+        if (newToken != null) {
+            tokenInfo = newToken;
+            saveTokenToCache(newToken);
 
-        intent.setClassName(NativeProtocol.KATANA_PACKAGE, NativeProtocol.KATANA_PROXY_AUTH_ACTIVITY);
-        return tryActivityAuth(intent, request, true);
+            state = SessionState.OPENED;
+        } else if (exception != null) {
+            state = SessionState.CLOSED_LOGIN_FAILED;
+        }
+        pendingRequest = null;
+        postStateChange(oldState, state, exception);
     }
 
-    private boolean validateFacebookAppSignature(String packageName) {
-        PackageInfo packageInfo = null;
-        try {
-            packageInfo = staticContext.getPackageManager().getPackageInfo(packageName,
-                    PackageManager.GET_SIGNATURES);
-        } catch (NameNotFoundException e) {
-            return false;
-        }
+    private void finishReauthorization(final AccessToken newToken, Exception exception) {
+        final SessionState oldState = state;
 
-        for (Signature signature : packageInfo.signatures) {
-            if (signature.toCharsString().equals(NativeProtocol.KATANA_SIGNATURE)) {
-                return true;
-            }
+        if (newToken != null) {
+            tokenInfo = newToken;
+            saveTokenToCache(newToken);
+
+            state = SessionState.OPENED_TOKEN_UPDATED;
         }
 
-        return false;
+        pendingRequest = null;
+        postStateChange(oldState, state, exception);
     }
 
-    @SuppressWarnings("incomplete-switch")
-    void finishAuth(AccessToken newToken, Exception exception) {
-        // If the token we came up with is expired/invalid, then auth failed.
-        if ((newToken != null) && newToken.isInvalid()) {
-            newToken = null;
-            exception = new FacebookException("Invalid access token.");
+    private void saveTokenToCache(AccessToken newToken) {
+        if (newToken != null && tokenCachingStrategy != null) {
+            tokenCachingStrategy.save(newToken.toCacheBundle());
         }
+    }
 
-        // Update the cache if we have a new token.
-        if ((newToken != null) && (this.tokenCache != null)) {
-            this.tokenCache.save(newToken.toCacheBundle());
+    void postStateChange(final SessionState oldState, final SessionState newState, final Exception exception) {
+        if (oldState == newState && exception == null) {
+            return;
         }
 
-        synchronized (this.lock) {
-            final SessionState oldState = this.state;
-
-            switch (this.state) {
-            case OPENING:
-            case OPENED:
-            case OPENED_TOKEN_UPDATED:
-                if (newToken != null) {
-                    this.tokenInfo = newToken;
-                    this.state = (oldState == SessionState.OPENING) ? SessionState.OPENED
-                            : SessionState.OPENED_TOKEN_UPDATED;
-                } else if (exception != null) {
-                    this.state = (oldState == SessionState.OPENING) ? SessionState.CLOSED_LOGIN_FAILED
-                            : oldState;
-                }
-                postStateChange(oldState, this.state, exception);
-                break;
-            }
-            pendingRequest = null;
+        if (newState.isClosed()) {
+            this.tokenInfo = AccessToken.createEmptyToken(Collections.<String>emptyList());
         }
-    }
 
-    void postStateChange(final SessionState oldState, final SessionState newState, final Exception exception) {
-        synchronized(callbacks) {
+        synchronized (callbacks) {
             // Need to schedule the callbacks inside the same queue to preserve ordering.
             // Otherwise these callbacks could have been added to the queue before the SessionTracker
             // gets the ACTIVE_SESSION_SET action.
@@ -1316,7 +1179,7 @@ public void run() {
                                 callback.call(Session.this, newState, exception);
                             }
                         };
-        
+
                         runWithHandlerOrExecutor(handler, closure);
                     }
                 }
@@ -1378,7 +1241,7 @@ boolean shouldExtendAccessToken() {
 
         Date now = new Date();
 
-        if (state.isOpened() && tokenInfo.getIsSSO()
+        if (state.isOpened() && tokenInfo.getSource().canExtendToken()
                 && now.getTime() - lastAttemptedTokenExtendDate.getTime() > TOKEN_EXTEND_RETRY_SECONDS * 1000
                 && now.getTime() - tokenInfo.getLastRefresh().getTime() > TOKEN_EXTEND_THRESHOLD_SECONDS * 1000) {
             result = true;
@@ -1407,20 +1270,6 @@ void setCurrentTokenRefreshRequest(TokenRefreshRequest request) {
         this.currentTokenRefreshRequest = request;
     }
 
-    static String getMetadataApplicationId(Context context) {
-        try {
-            ApplicationInfo ai = context.getPackageManager().getApplicationInfo(
-                    context.getPackageName(), PackageManager.GET_META_DATA);
-            if (ai.metaData != null) {
-                return ai.metaData.getString(APPLICATION_ID_PROPERTY);
-            }
-        } catch (NameNotFoundException e) {
-            // if we can't find it in the manifest, just return null
-        }
-
-        return null;
-    }
-
     class TokenRefreshRequest implements ServiceConnection {
 
         final Messenger messageReceiver = new Messenger(
@@ -1429,11 +1278,8 @@ static String getMetadataApplicationId(Context context) {
         Messenger messageSender = null;
 
         public void bind() {
-            Intent intent = new Intent();
-            intent.setClassName(NativeProtocol.KATANA_PACKAGE, NativeProtocol.KATANA_TOKEN_REFRESH_ACTIVITY);
-
-            ResolveInfo resolveInfo = staticContext.getPackageManager().resolveService(intent, 0);
-            if (resolveInfo != null && validateFacebookAppSignature(resolveInfo.serviceInfo.packageName)
+            Intent intent = NativeProtocol.createTokenRefreshIntent(getStaticContext());
+            if (intent != null
                     && staticContext.bindService(intent, new TokenRefreshRequest(), Context.BIND_AUTO_CREATE)) {
                 setLastAttemptedTokenExtendDate(new Date());
             } else {
@@ -1476,7 +1322,7 @@ private void refreshToken() {
                 cleanup();
             }
         }
-        
+
     }
 
     // Creating a static Handler class to reduce the possibility of a memory leak.
@@ -1501,7 +1347,7 @@ public void handleMessage(Message msg) {
             Session session = sessionWeakReference.get();
 
             if (session != null && token != null) {
-                session.internalRefreshToken(msg.getData());
+                session.extendTokenCompleted(msg.getData());
             }
 
             TokenRefreshRequest request = refreshRequestWeakReference.get();
@@ -1516,31 +1362,31 @@ public void handleMessage(Message msg) {
 
     /**
      * Provides asynchronous notification of Session state changes.
-     * 
+     *
      * @see Session#open open
      */
     public interface StatusCallback {
         public void call(Session session, SessionState state, Exception exception);
     }
-    
+
     @Override
     public int hashCode() {
         return 0;
     }
-    
+
     @Override
     public boolean equals(Object otherObj) {
         if (!(otherObj instanceof Session)) {
             return false;
         }
         Session other = (Session) otherObj;
-        
+
         return areEqual(other.applicationId, applicationId) &&
                 areEqual(other.authorizationBundle, authorizationBundle) &&
                 areEqual(other.state, state) &&
                 areEqual(other.getExpirationDate(), getExpirationDate());
     }
-    
+
     private static boolean areEqual(Object a, Object b) {
         if (a == null) {
             return b == null;
@@ -1555,8 +1401,7 @@ private static boolean areEqual(Object a, Object b) {
     public static final class Builder {
         private final Context context;
         private String applicationId;
-        private TokenCache tokenCache;
-        private boolean shouldAutoPublishInstall = true;
+        private TokenCachingStrategy tokenCachingStrategy;
 
         /**
          * Constructs a new Builder associated with the context.
@@ -1579,18 +1424,13 @@ public Builder setApplicationId(final String applicationId) {
         }
 
         /**
-         * Sets the TokenCache for the Session.
+         * Sets the TokenCachingStrategy for the Session.
          *
-         * @param tokenCache the token cache to use
+         * @param tokenCachingStrategy the token cache to use
          * @return the Builder instance
          */
-        public Builder setTokenCache(final TokenCache tokenCache) {
-            this.tokenCache = tokenCache;
-            return this;
-        }
-
-        public Builder setShouldAutoPublishInstall(boolean shouldAutoPublishInstall) {
-            this.shouldAutoPublishInstall = shouldAutoPublishInstall;
+        public Builder setTokenCachingStrategy(final TokenCachingStrategy tokenCachingStrategy) {
+            this.tokenCachingStrategy = tokenCachingStrategy;
             return this;
         }
 
@@ -1600,25 +1440,20 @@ public Builder setShouldAutoPublishInstall(boolean shouldAutoPublishInstall) {
          * @return a new Session
          */
         public Session build() {
-            return new Session(context, applicationId, tokenCache, shouldAutoPublishInstall);
+            return new Session(context, applicationId, tokenCachingStrategy);
         }
     }
 
-    private interface StartActivityDelegate {
+    interface StartActivityDelegate {
         public void startActivityForResult(Intent intent, int requestCode);
 
         public Activity getActivityContext();
     }
 
-    enum AuthorizationType {
-        READ,
-        PUBLISH
-    }
-
     private void autoPublishAsync() {
         AutoPublishAsyncTask asyncTask = null;
         synchronized (this) {
-            if (autoPublishAsyncTask == null && shouldAutoPublish) {
+            if (autoPublishAsyncTask == null && Settings.getShouldAutoPublishInstall()) {
                 // copy the application id to guarantee thread safety against our container.
                 String applicationId = Session.this.applicationId;
 
@@ -1651,7 +1486,7 @@ protected Void doInBackground(Void... voids) {
             try {
                 Settings.publishInstallAndWait(mApplicationContext, mApplicationId);
             } catch (Exception e) {
-                Util.logd("Facebook-publish", e.getMessage());
+                Utility.logd("Facebook-publish", e.getMessage());
             }
             return null;
         }
@@ -1665,6 +1500,9 @@ protected void onPostExecute(Void result) {
         }
     }
 
+    /**
+     * Base class for authorization requests {@link OpenRequest} and {@link NewPermissionsRequest}.
+     */
     public static class AuthorizationRequest implements Serializable {
 
         private static final long serialVersionUID = 1L;
@@ -1673,8 +1511,11 @@ protected void onPostExecute(Void result) {
         private SessionLoginBehavior loginBehavior = SessionLoginBehavior.SSO_WITH_FALLBACK;
         private int requestCode = DEFAULT_AUTHORIZE_ACTIVITY_CODE;
         private StatusCallback statusCallback;
-        private boolean suppressLoginActivityVerification = false;
+        private boolean isLegacy = false;
         private List<String> permissions = Collections.emptyList();
+        private SessionDefaultAudience defaultAudience = SessionDefaultAudience.FRIENDS;
+        private String applicationId;
+        private String validateSameFbidAsToken;
 
         AuthorizationRequest(final Activity activity) {
             startActivityDelegate = new StartActivityDelegate() {
@@ -1708,7 +1549,8 @@ public Activity getActivityContext() {
          * Constructor to be used for V1 serialization only, DO NOT CHANGE.
          */
         private AuthorizationRequest(SessionLoginBehavior loginBehavior, int requestCode,
-                List<String> permissions, boolean suppressLoginActivityVerification) {
+                List<String> permissions, String defaultAudience, boolean isLegacy, String applicationId,
+                String validateSameFbidAsToken) {
             startActivityDelegate = new StartActivityDelegate() {
                 @Override
                 public void startActivityForResult(Intent intent, int requestCode) {
@@ -1725,16 +1567,23 @@ public Activity getActivityContext() {
             this.loginBehavior = loginBehavior;
             this.requestCode = requestCode;
             this.permissions = permissions;
-            this.suppressLoginActivityVerification = suppressLoginActivityVerification;
+            this.defaultAudience = SessionDefaultAudience.valueOf(defaultAudience);
+            this.isLegacy = isLegacy;
+            this.applicationId = applicationId;
+            this.validateSameFbidAsToken = validateSameFbidAsToken;
         }
 
         /**
          * Used for backwards compatibility with Facebook.java only, DO NOT USE.
          *
-         * @param suppressVerification
+         * @param isLegacy
          */
-        public void suppressLoginActivityVerification(boolean suppressVerification) {
-            suppressLoginActivityVerification = suppressVerification;
+        public void setIsLegacy(boolean isLegacy) {
+            this.isLegacy = isLegacy;
+        }
+
+        boolean isLegacy() {
+            return isLegacy;
         }
 
         AuthorizationRequest setCallback(StatusCallback statusCallback) {
@@ -1779,30 +1628,57 @@ AuthorizationRequest setPermissions(List<String> permissions) {
             return permissions;
         }
 
+        AuthorizationRequest setDefaultAudience(SessionDefaultAudience defaultAudience) {
+            if (defaultAudience != null) {
+                this.defaultAudience = defaultAudience;
+            }
+            return this;
+        }
+
+        SessionDefaultAudience getDefaultAudience() {
+            return defaultAudience;
+        }
+
         StartActivityDelegate getStartActivityDelegate() {
             return startActivityDelegate;
         }
 
-        boolean allowKatana() {
-            switch (loginBehavior) {
-                case SSO_ONLY: return true;
-                case SUPPRESS_SSO: return false;
-                default: return true;
-            }
+        String getApplicationId() {
+            return applicationId;
         }
 
-        boolean allowWebView() {
-            switch (loginBehavior) {
-                case SSO_ONLY: return false;
-                case SUPPRESS_SSO: return true;
-                default: return true;
-            }
+        void setApplicationId(String applicationId) {
+            this.applicationId = applicationId;
+        }
+
+        String getValidateSameFbidAsToken() {
+            return validateSameFbidAsToken;
+        }
+
+        void setValidateSameFbidAsToken(String validateSameFbidAsToken) {
+            this.validateSameFbidAsToken = validateSameFbidAsToken;
+        }
+
+        AuthorizationClient.AuthorizationRequest getAuthorizationClientRequest() {
+            AuthorizationClient.StartActivityDelegate delegate = new AuthorizationClient.StartActivityDelegate() {
+                @Override
+                public void startActivityForResult(Intent intent, int requestCode) {
+                    startActivityDelegate.startActivityForResult(intent, requestCode);
+                }
+
+                @Override
+                public Activity getActivityContext() {
+                    return startActivityDelegate.getActivityContext();
+                }
+            };
+            return new AuthorizationClient.AuthorizationRequest(loginBehavior, requestCode, isLegacy,
+                    permissions, defaultAudience, applicationId, validateSameFbidAsToken, delegate);
         }
 
         // package private so subclasses can use it
         Object writeReplace() {
-            return new AuthRequestSerializationProxyV1(loginBehavior, requestCode, permissions,
-                    suppressLoginActivityVerification);
+            return new AuthRequestSerializationProxyV1(
+                    loginBehavior, requestCode, permissions, defaultAudience.name(), isLegacy, applicationId, validateSameFbidAsToken);
         }
 
         // have a readObject that throws to prevent spoofing
@@ -1815,20 +1691,27 @@ void readObject(ObjectInputStream stream) throws InvalidObjectException {
             private static final long serialVersionUID = -8748347685113614927L;
             private final SessionLoginBehavior loginBehavior;
             private final int requestCode;
-            private boolean suppressLoginActivityVerification;
+            private boolean isLegacy;
             private final List<String> permissions;
+            private final String defaultAudience;
+            private final String applicationId;
+            private final String validateSameFbidAsToken;
 
             private AuthRequestSerializationProxyV1(SessionLoginBehavior loginBehavior,
-                    int requestCode, List<String> permissions, boolean suppressVerification) {
+                    int requestCode, List<String> permissions, String defaultAudience, boolean isLegacy,
+                    String applicationId, String validateSameFbidAsToken) {
                 this.loginBehavior = loginBehavior;
                 this.requestCode = requestCode;
                 this.permissions = permissions;
-                this.suppressLoginActivityVerification = suppressVerification;
+                this.defaultAudience = defaultAudience;
+                this.isLegacy = isLegacy;
+                this.applicationId = applicationId;
+                this.validateSameFbidAsToken = validateSameFbidAsToken;
             }
 
             private Object readResolve() {
-                return new AuthorizationRequest(loginBehavior, requestCode, permissions,
-                        suppressLoginActivityVerification);
+                return new AuthorizationRequest(loginBehavior, requestCode, permissions, defaultAudience, isLegacy,
+                        applicationId, validateSameFbidAsToken);
             }
         }
     }
@@ -1860,9 +1743,8 @@ public OpenRequest(Fragment fragment) {
         /**
          * Sets the StatusCallback for the OpenRequest.
          *
-         * @param statusCallback
-         *            The {@link StatusCallback SessionStatusCallback} to
-         *            notify regarding Session state changes.
+         * @param statusCallback The {@link StatusCallback SessionStatusCallback} to
+         *                       notify regarding Session state changes.
          * @return the OpenRequest object to allow for chaining
          */
         public final OpenRequest setCallback(StatusCallback statusCallback) {
@@ -1873,10 +1755,9 @@ public final OpenRequest setCallback(StatusCallback statusCallback) {
         /**
          * Sets the login behavior for the OpenRequest.
          *
-         * @param loginBehavior
-         *            The {@link SessionLoginBehavior SessionLoginBehavior} that
-         *            specifies what behaviors should be attempted during
-         *            authorization.
+         * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
+         *                      specifies what behaviors should be attempted during
+         *                      authorization.
          * @return the OpenRequest object to allow for chaining
          */
         public final OpenRequest setLoginBehavior(SessionLoginBehavior loginBehavior) {
@@ -1887,11 +1768,10 @@ public final OpenRequest setLoginBehavior(SessionLoginBehavior loginBehavior) {
         /**
          * Sets the request code for the OpenRequest.
          *
-         * @param requestCode
-         *            An integer that identifies this request. This integer will be used
-         *            as the request code in {@link Activity#onActivityResult
-         *            onActivityResult}. This integer should be >= 0. If a value < 0 is
-         *            passed in, then a default value will be used.
+         * @param requestCode An integer that identifies this request. This integer will be used
+         *                    as the request code in {@link Activity#onActivityResult
+         *                    onActivityResult}. This integer should be >= 0. If a value < 0 is
+         *                    passed in, then a default value will be used.
          * @return the OpenRequest object to allow for chaining
          */
         public final OpenRequest setRequestCode(int requestCode) {
@@ -1902,86 +1782,106 @@ public final OpenRequest setRequestCode(int requestCode) {
         /**
          * Sets the permissions for the OpenRequest.
          *
-         * @param permissions
-         *            A List&lt;String&gt; representing the permissions to request
-         *            during the authentication flow. A null or empty List
-         *            represents basic permissions.
+         * @param permissions A List&lt;String&gt; representing the permissions to request
+         *                    during the authentication flow. A null or empty List
+         *                    represents basic permissions.
          * @return the OpenRequest object to allow for chaining
          */
         public final OpenRequest setPermissions(List<String> permissions) {
             super.setPermissions(permissions);
             return this;
         }
+
+        /**
+         * Sets the defaultAudience for the OpenRequest.
+         * <p/>
+         * This is only used during Native login using a sufficiently recent facebook app.
+         *
+         * @param defaultAudience A SessionDefaultAudience representing the default audience setting to request.
+         * @return the OpenRequest object to allow for chaining
+         */
+        public final OpenRequest setDefaultAudience(SessionDefaultAudience defaultAudience) {
+            super.setDefaultAudience(defaultAudience);
+            return this;
+        }
     }
 
     /**
-     * A request to be used to reauthorize a Session.
+     * A request to be used to request new permissions for a Session.
      */
-    public static final class ReauthorizeRequest extends AuthorizationRequest {
+    public static final class NewPermissionsRequest extends AuthorizationRequest {
         private static final long serialVersionUID = 1L;
 
         /**
-         * Constructs a ReauthorizeRequest.
+         * Constructs a NewPermissionsRequest.
          *
-         * @param activity the Activity used to reauthorize
+         * @param activity    the Activity used to issue the request
          * @param permissions additional permissions to request
          */
-        public ReauthorizeRequest(Activity activity, List<String> permissions) {
+        public NewPermissionsRequest(Activity activity, List<String> permissions) {
             super(activity);
             setPermissions(permissions);
         }
 
         /**
-         * Constructs a ReauthorizeRequest.
+         * Constructs a NewPermissionsRequest.
          *
-         * @param fragment the Fragment used to reauthorize
+         * @param fragment    the Fragment used to issue the request
          * @param permissions additional permissions to request
          */
-        public ReauthorizeRequest(Fragment fragment, List<String> permissions) {
+        public NewPermissionsRequest(Fragment fragment, List<String> permissions) {
             super(fragment);
             setPermissions(permissions);
         }
 
         /**
-         * Sets the StatusCallback for the ReauthorizeRequest.
+         * Sets the StatusCallback for the NewPermissionsRequest.
          *
-         * @param statusCallback
-         *            The {@link StatusCallback SessionStatusCallback} to
-         *            notify regarding Session state changes.
-         * @return the ReauthorizeRequest object to allow for chaining
+         * @param statusCallback The {@link StatusCallback SessionStatusCallback} to
+         *                       notify regarding Session state changes.
+         * @return the NewPermissionsRequest object to allow for chaining
          */
-        public final ReauthorizeRequest setCallback(StatusCallback statusCallback) {
+        public final NewPermissionsRequest setCallback(StatusCallback statusCallback) {
             super.setCallback(statusCallback);
             return this;
         }
 
         /**
-         * Sets the login behavior for the ReauthorizeRequest.
+         * Sets the login behavior for the NewPermissionsRequest.
          *
-         * @param loginBehavior
-         *            The {@link SessionLoginBehavior SessionLoginBehavior} that
-         *            specifies what behaviors should be attempted during
-         *            authorization.
-         * @return the ReauthorizeRequest object to allow for chaining
+         * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
+         *                      specifies what behaviors should be attempted during
+         *                      authorization.
+         * @return the NewPermissionsRequest object to allow for chaining
          */
-        public final ReauthorizeRequest setLoginBehavior(SessionLoginBehavior loginBehavior) {
+        public final NewPermissionsRequest setLoginBehavior(SessionLoginBehavior loginBehavior) {
             super.setLoginBehavior(loginBehavior);
             return this;
         }
 
         /**
-         * Sets the request code for the ReauthorizeRequest.
+         * Sets the request code for the NewPermissionsRequest.
          *
-         * @param requestCode
-         *            An integer that identifies this request. This integer will be used
-         *            as the request code in {@link Activity#onActivityResult
-         *            onActivityResult}. This integer should be >= 0. If a value < 0 is
-         *            passed in, then a default value will be used.
-         * @return the ReauthorizeRequest object to allow for chaining
+         * @param requestCode An integer that identifies this request. This integer will be used
+         *                    as the request code in {@link Activity#onActivityResult
+         *                    onActivityResult}. This integer should be >= 0. If a value < 0 is
+         *                    passed in, then a default value will be used.
+         * @return the NewPermissionsRequest object to allow for chaining
          */
-        public final ReauthorizeRequest setRequestCode(int requestCode) {
+        public final NewPermissionsRequest setRequestCode(int requestCode) {
             super.setRequestCode(requestCode);
             return this;
         }
+
+        /**
+         * Sets the defaultAudience for the OpenRequest.
+         *
+         * @param defaultAudience A SessionDefaultAudience representing the default audience setting to request.
+         * @return the NewPermissionsRequest object to allow for chaining
+         */
+        public final NewPermissionsRequest setDefaultAudience(SessionDefaultAudience defaultAudience) {
+            super.setDefaultAudience(defaultAudience);
+            return this;
+        }
     }
 }
diff --git a/facebook/src/com/facebook/SessionDefaultAudience.java b/facebook/src/com/facebook/SessionDefaultAudience.java
new file mode 100644
index 000000000..eaac2b369
--- /dev/null
+++ b/facebook/src/com/facebook/SessionDefaultAudience.java
@@ -0,0 +1,55 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Certain operations such as publishing a status or publishing a photo require an audience. When the user
+ * grants an application permission to perform a publish operation, a default audience is selected as the
+ * publication ceiling for the application. This enumerated value allows the application to select which
+ * audience to ask the user to grant publish permission for.
+ */
+public enum SessionDefaultAudience {
+    /**
+     * Represents an invalid default audience value, can be used when only reading.
+     */
+    NONE(null),
+
+    /**
+     * Indicates only the user is able to see posts made by the application.
+     */
+    ONLY_ME(NativeProtocol.AUDIENCE_ME),
+
+    /**
+     * Indicates that the user's friends are able to see posts made by the application.
+     */
+    FRIENDS(NativeProtocol.AUDIENCE_FRIENDS),
+
+    /**
+     * Indicates that all Facebook users are able to see posts made by the application.
+     */
+    EVERYONE(NativeProtocol.AUDIENCE_EVERYONE);
+
+    private final String nativeProtocolAudience;
+
+    private SessionDefaultAudience(String protocol) {
+        nativeProtocolAudience = protocol;
+    }
+
+    String getNativeProtocolAudience() {
+        return nativeProtocolAudience;
+    }
+}
diff --git a/facebook/src/com/facebook/SessionLoginBehavior.java b/facebook/src/com/facebook/SessionLoginBehavior.java
index 68d3ffabe..cc300dbd2 100644
--- a/facebook/src/com/facebook/SessionLoginBehavior.java
+++ b/facebook/src/com/facebook/SessionLoginBehavior.java
@@ -20,24 +20,40 @@
  * Specifies the behaviors to try during
  * {@link Session#openForRead(com.facebook.Session.OpenRequest) openForRead},
  * {@link Session#openForPublish(com.facebook.Session.OpenRequest) openForPublish},
- * {@link Session#reauthorizeForRead(com.facebook.Session.ReauthorizeRequest) reauthorizeForRead}, or
- * {@link Session#reauthorizeForPublish(com.facebook.Session.ReauthorizeRequest) reauthorizeForPublish}.
+ * {@link Session#requestNewReadPermissions(com.facebook.Session.NewPermissionsRequest) requestNewReadPermissions}, or
+ * {@link Session#requestNewPublishPermissions(com.facebook.Session.NewPermissionsRequest) requestNewPublishPermissions}.
  */
 public enum SessionLoginBehavior {
     /**
      * Specifies that Session should attempt Single Sign On (SSO), and if that
      * does not work fall back to dialog auth. This is the default behavior.
      */
-    SSO_WITH_FALLBACK,
+    SSO_WITH_FALLBACK(true, true),
 
     /**
      * Specifies that Session should only attempt SSO. If SSO fails, then the
-     * open or reauthorize call fails.
+     * open or new permissions call fails.
      */
-    SSO_ONLY,
+    SSO_ONLY(true, false),
 
     /**
      * Specifies that SSO should not be attempted, and to only use dialog auth.
      */
-    SUPPRESS_SSO;
+    SUPPRESS_SSO(false, true);
+
+    private final boolean allowsKatanaAuth;
+    private final boolean allowsWebViewAuth;
+
+    private SessionLoginBehavior(boolean allowsKatanaAuth, boolean allowsWebViewAuth) {
+        this.allowsKatanaAuth = allowsKatanaAuth;
+        this.allowsWebViewAuth = allowsWebViewAuth;
+    }
+
+    boolean allowsKatanaAuth() {
+        return allowsKatanaAuth;
+    }
+
+    boolean allowsWebViewAuth() {
+        return allowsWebViewAuth;
+    }
 }
diff --git a/facebook/src/com/facebook/SessionState.java b/facebook/src/com/facebook/SessionState.java
index 8fb8de2fb..45250624f 100644
--- a/facebook/src/com/facebook/SessionState.java
+++ b/facebook/src/com/facebook/SessionState.java
@@ -39,7 +39,7 @@
      * </p>
      * <p>
      * If you are using Session from an Android Service, you must provide a
-     * TokenCache implementation that contains a valid token to the Session
+     * TokenCachingStrategy implementation that contains a valid token to the Session
      * constructor. The resulting Session will be created in this state, and you
      * can then safely call open, passing null for the Activity.
      * </p>
diff --git a/facebook/src/com/facebook/Settings.java b/facebook/src/com/facebook/Settings.java
index fc601575f..f0a8f7ed0 100644
--- a/facebook/src/com/facebook/Settings.java
+++ b/facebook/src/com/facebook/Settings.java
@@ -23,7 +23,10 @@
 import android.net.Uri;
 import android.os.AsyncTask;
 import android.os.Bundle;
-import com.facebook.android.Util;
+import com.facebook.android.BuildConfig;
+import com.facebook.internal.Utility;
+import com.facebook.model.GraphObject;
+import com.facebook.internal.Validate;
 import org.json.JSONException;
 
 import java.lang.reflect.Field;
@@ -37,9 +40,10 @@
  * Allows some customization of sdk behavior.
  */
 public final class Settings {
-    static final String LOG_TAG_BASE = "FacebookSDK.";
-    private static final HashSet<LoggingBehaviors> loggingBehaviors = new HashSet<LoggingBehaviors>();
+    private static final HashSet<LoggingBehavior> loggingBehaviors = new HashSet<LoggingBehavior>();
     private static volatile Executor executor;
+    private static volatile boolean shouldAutoPublishInstall;
+
     private static final int DEFAULT_CORE_POOL_SIZE = 5;
     private static final int DEFAULT_MAXIMUM_POOL_SIZE = 128;
     private static final int DEFAULT_KEEP_ALIVE = 1;
@@ -76,9 +80,9 @@ public Thread newThread(Runnable runnable) {
      *
      * @return a set containing enabled logging behaviors
      */
-    public static final Set<LoggingBehaviors> getLoggingBehaviors() {
+    public static final Set<LoggingBehavior> getLoggingBehaviors() {
         synchronized (loggingBehaviors) {
-            return Collections.unmodifiableSet(new HashSet<LoggingBehaviors>(loggingBehaviors));
+            return Collections.unmodifiableSet(new HashSet<LoggingBehavior>(loggingBehaviors));
         }
     }
 
@@ -91,7 +95,7 @@ public Thread newThread(Runnable runnable) {
      * @param behavior
      *          The LoggingBehavior to enable
      */
-    public static final void addLoggingBehavior(LoggingBehaviors behavior) {
+    public static final void addLoggingBehavior(LoggingBehavior behavior) {
         synchronized (loggingBehaviors) {
             loggingBehaviors.add(behavior);
         }
@@ -106,7 +110,7 @@ public static final void addLoggingBehavior(LoggingBehaviors behavior) {
      * @param behavior
      *          The LoggingBehavior to disable
      */
-    public static final void removeLoggingBehavior(LoggingBehaviors behavior) {
+    public static final void removeLoggingBehavior(LoggingBehavior behavior) {
         synchronized (loggingBehaviors) {
             loggingBehaviors.remove(behavior);
         }
@@ -134,9 +138,9 @@ public static final void clearLoggingBehaviors() {
      *          The LoggingBehavior to check
      * @return whether behavior is enabled
      */
-    public static final boolean isLoggingBehaviorEnabled(LoggingBehaviors behavior) {
+    public static final boolean isLoggingBehaviorEnabled(LoggingBehavior behavior) {
         synchronized (loggingBehaviors) {
-            return loggingBehaviors.contains(behavior);
+            return BuildConfig.DEBUG && loggingBehaviors.contains(behavior);
         }
     }
 
@@ -217,9 +221,27 @@ public void run() {
     }
 
     /**
-     * Manually publish install attribution to the facebook graph.  Internally handles tracking repeat calls to prevent
+     * Sets whether opening a Session should automatically publish install attribution to the Facebook graph.
+     *
+     * @param shouldAutoPublishInstall true to automatically publish, false to not
+     */
+    public static void setShouldAutoPublishInstall(boolean shouldAutoPublishInstall) {
+        Settings.shouldAutoPublishInstall = shouldAutoPublishInstall;
+    }
+
+    /**
+     * Gets whether opening a Session should automatically publish install attribution to the Facebook graph.
+     *
+     * @return true to automatically publish, false to not
+     */
+    public static boolean getShouldAutoPublishInstall() {
+        return shouldAutoPublishInstall;
+    }
+
+    /**
+     * Manually publish install attribution to the Facebook graph.  Internally handles tracking repeat calls to prevent
      * multiple installs being published to the graph.
-     * @param context
+     * @param context the current Context
      * @return returns false on error.  Applications should retry until true is returned.  Safe to call again after
      * true is returned.
      */
@@ -247,7 +269,7 @@ public static boolean publishInstallAndWait(final Context context, final String
                 }
 
                 if ((Boolean)doesSupportAttribution) {
-                    GraphObject publishParams = GraphObjectWrapper.createGraphObject();
+                    GraphObject publishParams = GraphObject.Factory.create();
                     publishParams.setProperty(ANALYTICS_EVENT, MOBILE_INSTALL_EVENT);
                     publishParams.setProperty(ATTRIBUTION_KEY, attributionId);
 
@@ -258,14 +280,15 @@ public static boolean publishInstallAndWait(final Context context, final String
 
                     // denote success since no error threw from the post.
                     SharedPreferences.Editor editor = preferences.edit();
-                    editor.putLong(pingKey, System.currentTimeMillis());
+                    lastPing = System.currentTimeMillis();
+                    editor.putLong(pingKey, lastPing);
                     editor.commit();
                 }
             }
-            return true;
+            return lastPing != 0;
         } catch (Exception e) {
             // if there was an error, fall through to the failure case.
-            Util.logd("Facebook-publish", e.getMessage());
+            Utility.logd("Facebook-publish", e.getMessage());
         }
         return false;
     }
diff --git a/facebook/src/com/facebook/SharedPreferencesTokenCache.java b/facebook/src/com/facebook/SharedPreferencesTokenCachingStrategy.java
similarity index 87%
rename from facebook/src/com/facebook/SharedPreferencesTokenCache.java
rename to facebook/src/com/facebook/SharedPreferencesTokenCachingStrategy.java
index 86b638f2e..9a1683528 100644
--- a/facebook/src/com/facebook/SharedPreferencesTokenCache.java
+++ b/facebook/src/com/facebook/SharedPreferencesTokenCachingStrategy.java
@@ -1,5 +1,5 @@
 /**
- * Copyright 2010 Facebook, Inc.
+ * Copyright 2012 Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,6 +20,9 @@
 import android.content.SharedPreferences;
 import android.os.Bundle;
 import android.util.Log;
+import com.facebook.internal.Logger;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -30,7 +33,7 @@
 
 /*
  * <p>
- * An implementation of {@link TokenCache TokenCache} that uses Android SharedPreferences
+ * An implementation of {@link TokenCachingStrategy TokenCachingStrategy} that uses Android SharedPreferences
  * to persist information.
  * </p>
  * <p>
@@ -40,13 +43,14 @@
  * are also supported.
  * </p>
  */
-public class SharedPreferencesTokenCache extends TokenCache {
+public class SharedPreferencesTokenCachingStrategy extends TokenCachingStrategy {
 
-    private static final String DEFAULT_CACHE_KEY = "com.facebook.SharedPreferencesTokenCache.DEFAULT_KEY";
-    private static final String TAG = SharedPreferencesTokenCache.class.getSimpleName();
+    private static final String DEFAULT_CACHE_KEY = "com.facebook.SharedPreferencesTokenCachingStrategy.DEFAULT_KEY";
+    private static final String TAG = SharedPreferencesTokenCachingStrategy.class.getSimpleName();
 
     private static final String JSON_VALUE_TYPE = "valueType";
     private static final String JSON_VALUE = "value";
+    private static final String JSON_VALUE_ENUM_TYPE = "enumType";
 
     private static final String TYPE_BOOLEAN = "bool";
     private static final String TYPE_BOOLEAN_ARRAY = "bool[]";
@@ -66,12 +70,13 @@
     private static final String TYPE_CHAR_ARRAY = "char[]";
     private static final String TYPE_STRING = "string";
     private static final String TYPE_STRING_LIST = "stringList";
+    private static final String TYPE_ENUM = "enum";
 
     private String cacheKey;
     private SharedPreferences cache;
 
     /**
-     * Creates a default {@link SharedPreferencesTokenCache SharedPreferencesTokenCache}
+     * Creates a default {@link SharedPreferencesTokenCachingStrategy SharedPreferencesTokenCachingStrategy}
      * instance that provides access to a single set of token information.
      *
      * @param context
@@ -79,12 +84,12 @@
      *
      * @throws NullPointerException if the passed in Context is null
      */
-    public SharedPreferencesTokenCache(Context context) {
+    public SharedPreferencesTokenCachingStrategy(Context context) {
         this(context, null);
     }
 
     /**
-     * Creates a {@link SharedPreferencesTokenCache SharedPreferencesTokenCache} instance
+     * Creates a {@link SharedPreferencesTokenCachingStrategy SharedPreferencesTokenCachingStrategy} instance
      * that is distinct for the passed in cacheKey.
      *
      * @param context
@@ -95,7 +100,7 @@ public SharedPreferencesTokenCache(Context context) {
      *
      * @throws NullPointerException if the passed in Context is null
      */
-    public SharedPreferencesTokenCache(Context context, String cacheKey) {
+    public SharedPreferencesTokenCachingStrategy(Context context, String cacheKey) {
         Validate.notNull(context, "context");
 
         this.cacheKey = Utility.isNullOrEmpty(cacheKey) ? DEFAULT_CACHE_KEY : cacheKey;
@@ -126,7 +131,8 @@ public Bundle load() {
                 deserializeKey(key, settings);
             } catch (JSONException e) {
                 // Error in the cache. So consider it corrupted and return null
-                Logger.log(LoggingBehaviors.CACHE, Log.WARN, TAG, "Error reading cached value for key: '" + key + "' -- " + e);
+                Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG,
+                        "Error reading cached value for key: '" + key + "' -- " + e);
                 return null;
             }
         }
@@ -151,7 +157,7 @@ public void save(Bundle bundle) {
                 serializeKey(key, bundle, editor);
             } catch (JSONException e) {
                 // Error in the bundle. Don't store a partial cache.
-                Logger.log(LoggingBehaviors.CACHE, Log.WARN, TAG, "Error processing value for key: '" + key + "' -- " + e);
+                Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, "Error processing value for key: '" + key + "' -- " + e);
 
                 // Bypass the commit and just return. This cancels the entire edit transaction
                 return;
@@ -160,7 +166,7 @@ public void save(Bundle bundle) {
 
         boolean successfulCommit = editor.commit();
         if (!successfulCommit) {
-            Logger.log(LoggingBehaviors.CACHE, Log.WARN, TAG, "SharedPreferences.Editor.commit() was not successful");
+            Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, "SharedPreferences.Editor.commit() was not successful");
         }
     }
 
@@ -210,6 +216,10 @@ private void serializeKey(String key, Bundle bundle, SharedPreferences.Editor ed
         } else if (value instanceof String) {
             supportedType = TYPE_STRING;
             json.put(JSON_VALUE, (String)value);
+        } else if (value instanceof Enum<?>) {
+            supportedType = TYPE_ENUM;
+            json.put(JSON_VALUE, value.toString());
+            json.put(JSON_VALUE_ENUM_TYPE, value.getClass().getName());
         } else {
             // Optimistically create a JSONArray. If not an array type, we can null
             // it out later
@@ -377,6 +387,17 @@ private void deserializeKey(String key, Bundle bundle)
                 stringList.add(i, jsonStringValue == JSONObject.NULL ? null : (String)jsonStringValue);
             }
             bundle.putStringArrayList(key, stringList);
+        } else if (valueType.equals(TYPE_ENUM)) {
+            try {
+                String enumType = json.getString(JSON_VALUE_ENUM_TYPE);
+                @SuppressWarnings({ "unchecked", "rawtypes" })
+                Class<? extends Enum> enumClass = (Class<? extends Enum>) Class.forName(enumType);
+                @SuppressWarnings("unchecked")
+                Enum<?> enumValue = Enum.valueOf(enumClass, json.getString(JSON_VALUE));
+                bundle.putSerializable(key, enumValue);
+            } catch (ClassNotFoundException e) {
+            } catch (IllegalArgumentException e) {
+            }
         }
     }
 }
diff --git a/facebook/tests/src/com/facebook/TestSession.java b/facebook/src/com/facebook/TestSession.java
similarity index 66%
rename from facebook/tests/src/com/facebook/TestSession.java
rename to facebook/src/com/facebook/TestSession.java
index ecf717363..0c6651812 100644
--- a/facebook/tests/src/com/facebook/TestSession.java
+++ b/facebook/src/com/facebook/TestSession.java
@@ -20,11 +20,46 @@
 import android.os.Bundle;
 import android.text.TextUtils;
 import android.util.Log;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphObjectList;
+import com.facebook.internal.Logger;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
 import org.json.JSONException;
 import org.json.JSONObject;
 
 import java.util.*;
 
+/**
+ * Implements an subclass of Session that knows about test users for a particular
+ * application. This should never be used from a real application, but may be useful
+ * for writing unit tests, etc.
+ * <p/>
+ * Facebook allows developers to create test accounts for testing their applications'
+ * Facebook integration (see https://developers.facebook.com/docs/test_users/). This class
+ * simplifies use of these accounts for writing unit tests. It is not designed for use in
+ * production application code.
+ * <p/>
+ * The main use case for this class is using {@link #createSessionWithPrivateUser(android.app.Activity, java.util.List)}
+ * or {@link #createSessionWithSharedUser(android.app.Activity, java.util.List)}
+ * to create a session for a test user. Two modes are supported. In "shared" mode, an attempt
+ * is made to find an existing test user that has the required permissions. If no such user is available,
+ * a new one is created with the required permissions. In "private" mode, designed for
+ * scenarios which require a new user in a known clean state, a new test user will always be
+ * created, and it will be automatically deleted when the TestSession is closed. The session
+ * obeys the same lifecycle as a regular Session, meaning it must be opened after creation before
+ * it can be used to make calls to the Facebook API.
+ * <p/>
+ * Prior to creating a TestSession, two static methods must be called to initialize the
+ * application ID and application Secret to be used for managing test users. These methods are
+ * {@link #setTestApplicationId(String)} and {@link #setTestApplicationSecret(String)}.
+ * <p/>
+ * Note that the shared test user functionality depends on a naming convention for the test users.
+ * It is important that any testing of functionality which will mutate the permissions for a
+ * test user NOT use a shared test user, or this scheme will break down. If a shared test user
+ * seems to be in an invalid state, it can be deleted manually via the Web interface at
+ * https://developers.facebook.com/apps/APP_ID/permissions?role=test+users.
+ */
 public class TestSession extends Session {
     private static final long serialVersionUID = 1L;
 
@@ -32,12 +67,11 @@
         PRIVATE, SHARED
     }
 
-    private static final String LOG_TAG = Settings.LOG_TAG_BASE + "TestSession";
+    private static final String LOG_TAG = Logger.LOG_TAG_BASE + "TestSession";
 
     private static Map<String, TestAccount> appTestAccounts;
     private static String testApplicationSecret;
     private static String testApplicationId;
-    private static String machineUniqueUserTag;
 
     private final String sessionUniqueUserTag;
     private final List<String> requestedPermissions;
@@ -46,9 +80,9 @@
 
     private boolean wasAskedToExtendAccessToken;
 
-    protected TestSession(Activity activity, List<String> permissions, TokenCache tokenCache,
-            String machineUniqueUserTag, String sessionUniqueUserTag, Mode mode) {
-        super(activity, TestSession.testApplicationId, tokenCache, false);
+    TestSession(Activity activity, List<String> permissions, TokenCachingStrategy tokenCachingStrategy,
+            String sessionUniqueUserTag, Mode mode) {
+        super(activity, TestSession.testApplicationId, tokenCachingStrategy);
 
         Validate.notNull(permissions, "permissions");
 
@@ -61,54 +95,109 @@ protected TestSession(Activity activity, List<String> permissions, TokenCache to
         this.requestedPermissions = permissions;
     }
 
+    /**
+     * Constructs a TestSession which creates a test user on open, and destroys the user on
+     * close; This method should not be used in application code -- but is useful for creating unit tests
+     * that use the Facebook SDK.
+     *
+     * @param activity    the Activity to use for opening the session
+     * @param permissions list of strings containing permissions to request; nil will result in
+     *                    a common set of permissions (email, publish_actions) being requested
+     * @return a new TestSession that is in the CREATED state, ready to be opened
+     */
     public static TestSession createSessionWithPrivateUser(Activity activity, List<String> permissions) {
         return createTestSession(activity, permissions, Mode.PRIVATE, null);
     }
 
+    /**
+     * Constructs a TestSession which uses a shared test user with the right permissions,
+     * creating one if necessary on open (but not deleting it on close, so it can be re-used in later
+     * tests).
+     * <p/>
+     * This method should not be used in application code -- but is useful for creating unit tests
+     * that use the Facebook SDK.
+     *
+     * @param activity    the Activity to use for opening the session
+     * @param permissions list of strings containing permissions to request; nil will result in
+     *                    a common set of permissions (email, publish_actions) being requested
+     * @return a new TestSession that is in the CREATED state, ready to be opened
+     */
     public static TestSession createSessionWithSharedUser(Activity activity, List<String> permissions) {
         return createSessionWithSharedUser(activity, permissions, null);
     }
 
+    /**
+     * Constructs a TestSession which uses a shared test user with the right permissions,
+     * creating one if necessary on open (but not deleting it on close, so it can be re-used in later
+     * tests).
+     * <p/>
+     * This method should not be used in application code -- but is useful for creating unit tests
+     * that use the Facebook SDK.
+     *
+     * @param activity             the Activity to use for opening the session
+     * @param permissions          list of strings containing permissions to request; nil will result in
+     *                             a common set of permissions (email, publish_actions) being requested
+     * @param sessionUniqueUserTag a string which will be used to make this user unique among other
+     *                             users with the same permissions. Useful for tests which require two or more users to interact
+     *                             with each other, and which therefore must have sessions associated with different users.
+     * @return a new TestSession that is in the CREATED state, ready to be opened
+     */
     public static TestSession createSessionWithSharedUser(Activity activity, List<String> permissions,
             String sessionUniqueUserTag) {
         return createTestSession(activity, permissions, Mode.SHARED, sessionUniqueUserTag);
     }
 
-    public static final String getAppAccessToken() {
-        return testApplicationId + "|" + testApplicationSecret;
-    }
-
+    /**
+     * Gets the Facebook Application ID for the application under test.
+     *
+     * @return the application ID
+     */
     public static synchronized String getTestApplicationId() {
         return testApplicationId;
     }
 
-    public static synchronized void setTestApplicationId(String value) {
-        if (testApplicationId != null && !testApplicationId.equals(value)) {
+    /**
+     * Sets the Facebook Application ID for the application under test. This must be specified
+     * prior to creating a TestSession.
+     *
+     * @param applicationId the application ID
+     */
+    public static synchronized void setTestApplicationId(String applicationId) {
+        if (testApplicationId != null && !testApplicationId.equals(applicationId)) {
             throw new FacebookException("Can't have more than one test application ID");
         }
-        testApplicationId = value;
+        testApplicationId = applicationId;
     }
 
+    /**
+     * Gets the Facebook Application Secret for the application under test.
+     *
+     * @return the application secret
+     */
     public static synchronized String getTestApplicationSecret() {
         return testApplicationSecret;
     }
 
-    public static synchronized void setTestApplicationSecret(String value) {
-        if (testApplicationSecret != null && !testApplicationSecret.equals(value)) {
+    /**
+     * Sets the Facebook Application Secret for the application under test. This must be specified
+     * prior to creating a TestSession.
+     *
+     * @param applicationSecret the application secret
+     */
+    public static synchronized void setTestApplicationSecret(String applicationSecret) {
+        if (testApplicationSecret != null && !testApplicationSecret.equals(applicationSecret)) {
             throw new FacebookException("Can't have more than one test application secret");
         }
-        testApplicationSecret = value;
+        testApplicationSecret = applicationSecret;
     }
 
-    public static synchronized String getMachineUniqueUserTag() {
-        return machineUniqueUserTag;
-    }
-
-    public static synchronized void setMachineUniqueUserTag(String value) {
-        if (machineUniqueUserTag != null && !machineUniqueUserTag.equals(value)) {
-            throw new FacebookException("Can't have more than one machine-unique user tag");
-        }
-        machineUniqueUserTag = value;
+    /**
+     * Gets the ID of the test user that this TestSession is authenticated as.
+     *
+     * @return the Facebook user ID of the test user
+     */
+    public final String getTestUserId() {
+        return testAccountId;
     }
 
     private static synchronized TestSession createTestSession(Activity activity, List<String> permissions, Mode mode,
@@ -121,7 +210,7 @@ private static synchronized TestSession createTestSession(Activity activity, Lis
             permissions = Arrays.asList("email", "publish_actions");
         }
 
-        return new TestSession(activity, permissions, new TestTokenCache(), machineUniqueUserTag, sessionUniqueUserTag,
+        return new TestSession(activity, permissions, new TestTokenCachingStrategy(), sessionUniqueUserTag,
                 mode);
     }
 
@@ -161,7 +250,7 @@ private static synchronized void retrieveTestAccountsForAppIfNeeded() {
         Response response = request.executeAndWait();
 
         if (response.getError() != null) {
-            throw response.getError();
+            throw response.getError().getException();
         }
 
         FqlResponse fqlResponse = response.getGraphObjectAs(FqlResponse.class);
@@ -213,8 +302,12 @@ private static synchronized TestAccount findTestAccountMatchingIdentifier(String
         return null;
     }
 
-    public final String getTestUserId() {
-        return testAccountId;
+    @Override
+    public final String toString() {
+        String superString = super.toString();
+
+        return new StringBuilder().append("{TestSession").append(" testUserId:").append(testAccountId)
+                .append(" ").append(superString).append("}").toString();
     }
 
     @Override
@@ -238,14 +331,15 @@ void postStateChange(final SessionState oldState, final SessionState newState, f
         }
     }
 
-    public boolean getWasAskedToExtendAccessToken() {
+    boolean getWasAskedToExtendAccessToken() {
         return wasAskedToExtendAccessToken;
     }
 
-    public void forceExtendAccessToken(boolean forceExtendAccessToken) {
+    void forceExtendAccessToken(boolean forceExtendAccessToken) {
         AccessToken currentToken = getTokenInfo();
         setTokenInfo(
-                new AccessToken(currentToken.getToken(), new Date(), currentToken.getPermissions(), true, new Date(0)));
+                new AccessToken(currentToken.getToken(), new Date(), currentToken.getPermissions(),
+                        AccessTokenSource.TEST_USER, new Date(0)));
         setLastAttemptedTokenExtendDate(new Date(0));
     }
 
@@ -266,6 +360,10 @@ void fakeTokenRefreshAttempt() {
         setCurrentTokenRefreshRequest(new TokenRefreshRequest());
     }
 
+    static final String getAppAccessToken() {
+        return testApplicationId + "|" + testApplicationSecret;
+    }
+
     private void findOrCreateSharedTestAccount() {
         TestAccount testAccount = findTestAccountMatchingIdentifier(getSharedTestAccountIdentifier());
         if (testAccount != null) {
@@ -278,8 +376,9 @@ private void findOrCreateSharedTestAccount() {
     private void finishAuthWithTestAccount(TestAccount testAccount) {
         testAccountId = testAccount.getId();
 
-        AccessToken accessToken = AccessToken.createFromString(testAccount.getAccessToken(), requestedPermissions);
-        finishAuth(accessToken, null);
+        AccessToken accessToken = AccessToken.createFromString(testAccount.getAccessToken(), requestedPermissions,
+                AccessTokenSource.TEST_USER);
+        finishAuthOrReauth(accessToken, null);
     }
 
     private TestAccount createTestAccountAndFinishAuth() {
@@ -299,10 +398,10 @@ private TestAccount createTestAccountAndFinishAuth() {
         Request createUserRequest = new Request(null, graphPath, parameters, HttpMethod.POST);
         Response response = createUserRequest.executeAndWait();
 
-        FacebookException error = response.getError();
+        FacebookRequestError error = response.getError();
         TestAccount testAccount = response.getGraphObjectAs(TestAccount.class);
         if (error != null) {
-            finishAuth(null, error);
+            finishAuthOrReauth(null, error.getException());
             return null;
         } else {
             assert testAccount != null;
@@ -327,10 +426,10 @@ private void deleteTestAccount(String testAccountId, String appAccessToken) {
         Request request = new Request(null, testAccountId, parameters, HttpMethod.DELETE);
         Response response = request.executeAndWait();
 
-        Exception error = response.getError();
+        FacebookRequestError error = response.getError();
         GraphObject graphObject = response.getGraphObject();
         if (error != null) {
-            Log.w(LOG_TAG, String.format("Could not delete test account %s: %s", testAccountId, error.toString()));
+            Log.w(LOG_TAG, String.format("Could not delete test account %s: %s", testAccountId, error.getException().toString()));
         } else if (graphObject.getProperty(Response.NON_JSON_RESPONSE_PROPERTY) == (Boolean) false) {
             Log.w(LOG_TAG, String.format("Could not delete test account %s: unknown reason", testAccountId));
         }
@@ -343,10 +442,9 @@ private String getPermissionsString() {
     private String getSharedTestAccountIdentifier() {
         // We use long even though hashes are ints to avoid sign issues.
         long permissionsHash = getPermissionsString().hashCode() & 0xffffffffL;
-        long machineTagHash = (machineUniqueUserTag != null) ? machineUniqueUserTag.hashCode() & 0xffffffffL : 0;
         long sessionTagHash = (sessionUniqueUserTag != null) ? sessionUniqueUserTag.hashCode() & 0xffffffffL : 0;
 
-        long combinedHash = permissionsHash ^ machineTagHash ^ sessionTagHash;
+        long combinedHash = permissionsHash ^ sessionTagHash;
         return validNameStringFromInteger(combinedHash);
     }
 
@@ -397,7 +495,7 @@ private String validNameStringFromInteger(long i) {
         GraphObjectList<FqlResult> getData();
     }
 
-    private static final class TestTokenCache extends TokenCache {
+    private static final class TestTokenCachingStrategy extends TokenCachingStrategy {
         private Bundle bundle;
 
         @Override
diff --git a/facebook/src/com/facebook/TokenCache.java b/facebook/src/com/facebook/TokenCachingStrategy.java
similarity index 85%
rename from facebook/src/com/facebook/TokenCache.java
rename to facebook/src/com/facebook/TokenCachingStrategy.java
index 44fe3bd90..cb3271ac8 100644
--- a/facebook/src/com/facebook/TokenCache.java
+++ b/facebook/src/com/facebook/TokenCachingStrategy.java
@@ -1,5 +1,5 @@
 /**
- * Copyright 2010 Facebook, Inc.
+ * Copyright 2012 Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 package com.facebook;
 
 import android.os.Bundle;
+import com.facebook.internal.Validate;
 
 import java.util.ArrayList;
 import java.util.Date;
@@ -27,61 +28,62 @@
  * A base class for implementations of a {@link Session Session} token cache.
  * </p>
  * <p>
- * The Session constructor optionally takes a TokenCache, from which it will
+ * The Session constructor optionally takes a TokenCachingStrategy, from which it will
  * attempt to load a cached token during construction. Also, whenever the
  * Session updates its token, it will also save the token and associated state
- * to the TokenCache.
+ * to the TokenCachingStrategy.
  * </p>
  * <p>
  * This is the only mechanism supported for an Android service to use Session.
- * The service can create a custom TokenCache that returns the Session provided
+ * The service can create a custom TokenCachingStrategy that returns the Session provided
  * by an Activity through which the user logged in to Facebook.
  * </p>
  */
-public abstract class TokenCache {
+public abstract class TokenCachingStrategy {
     /**
      * The key used by Session to store the token value in the Bundle during
      * load and save.
      */
-    public static final String TOKEN_KEY = "com.facebook.TokenCache.Token";
+    public static final String TOKEN_KEY = "com.facebook.TokenCachingStrategy.Token";
 
     /**
      * The key used by Session to store the expiration date value in the Bundle
      * during load and save.
      */
-    public static final String EXPIRATION_DATE_KEY = "com.facebook.TokenCache.ExpirationDate";
+    public static final String EXPIRATION_DATE_KEY = "com.facebook.TokenCachingStrategy.ExpirationDate";
 
     /**
      * The key used by Session to store the last refresh date value in the
      * Bundle during load and save.
      */
-    public static final String LAST_REFRESH_DATE_KEY = "com.facebook.TokenCache.LastRefreshDate";
+    public static final String LAST_REFRESH_DATE_KEY = "com.facebook.TokenCachingStrategy.LastRefreshDate";
 
     /**
      * The key used by Session to store the user's id value in the Bundle during
      * load and save.
      */
-    public static final String USER_FBID_KEY = "com.facebook.TokenCache.UserFBID";
+    public static final String USER_FBID_KEY = "com.facebook.TokenCachingStrategy.UserFBID";
 
     /**
-     * The key used by Session to store a boolean indicating whether the token
-     * was SSO in the Bundle during load and save.
+     * The key used by Session to store an enum indicating the source of the token
+     * in the Bundle during load and save.
      */
-    public static final String IS_SSO_KEY = "com.facebook.TokenCache.IsSSO";
+    public static final String TOKEN_SOURCE_KEY = "com.facebook.TokenCachingStrategy.AccessTokenSource";
 
     /**
      * The key used by Session to store the list of permissions granted by the
      * token in the Bundle during load and save.
      */
-    public static final String PERMISSIONS_KEY = "com.facebook.TokenCache.Permissions";
+    public static final String PERMISSIONS_KEY = "com.facebook.TokenCachingStrategy.Permissions";
 
     private static final long INVALID_BUNDLE_MILLISECONDS = Long.MIN_VALUE;
+    private static final String IS_SSO_KEY = "com.facebook.TokenCachingStrategy.IsSSO";
 
     /**
      * Called during Session construction to get the token state. Typically this
      * is loaded from a persistent store that was previously initialized via
      * save.  The caller may choose to keep a reference to the returned Bundle
-     * indefinitely.  Therefore the TokenCache should not store the returned Bundle
+     * indefinitely.  Therefore the TokenCachingStrategy should not store the returned Bundle
      * and should return a new Bundle on every call to this method.
      *
      * @return A Bundle that represents the token state that was loaded.
@@ -265,38 +267,36 @@ public static void putPermissions(Bundle bundle, List<String> value) {
     }
 
     /**
-     * Gets the cached boolean indicating whether the token came from SSO from a
-     * Bundle.
-     * 
+     * Gets the cached enum indicating the source of the token from the Bundle.
+     *
      * @param bundle
-     *            A Bundle in which the boolean indicating whether the token
-     *            came from SSO was stored.
-     * @return the cached boolean indicating whether the token came from SSO, or
-     *         null.
+     *            A Bundle in which the enum was stored.
+     * @return enum indicating the source of the token
      *
      * @throws NullPointerException if the passed in Bundle is null
      */
-    public static boolean getIsSSO(Bundle bundle) {
+    public static AccessTokenSource getSource(Bundle bundle) {
         Validate.notNull(bundle, "bundle");
-        return bundle.getBoolean(IS_SSO_KEY);
+        if (bundle.containsKey(TokenCachingStrategy.TOKEN_SOURCE_KEY)) {
+            return (AccessTokenSource) bundle.getSerializable(TokenCachingStrategy.TOKEN_SOURCE_KEY);
+        } else {
+            boolean isSSO = bundle.getBoolean(TokenCachingStrategy.IS_SSO_KEY);
+            return isSSO ? AccessTokenSource.FACEBOOK_APPLICATION_WEB : AccessTokenSource.WEB_VIEW;
+        }
     }
-
     /**
-     * Puts the boolean indicating whether the token came from SSO into a
-     * Bundle.
-     * 
+     * Puts the enum indicating the source of the token into a Bundle.
+     *
      * @param bundle
-     *            A Bundle in which the boolean indicating whether the token
-     *            came from SSO should be stored.
+     *            A Bundle in which the enum should be stored.
      * @param value
-     *            The boolean indicating whether the token came from SSO, or
-     *            null.
+     *            enum indicating the source of the token
      *
      * @throws NullPointerException if the passed in Bundle is null
      */
-    public static void putIsSSO(Bundle bundle, boolean value) {
+    public static void putSource(Bundle bundle, AccessTokenSource value) {
         Validate.notNull(bundle, "bundle");
-        bundle.putBoolean(IS_SSO_KEY, value);
+        bundle.putSerializable(TOKEN_SOURCE_KEY, value);
     }
 
     /**
diff --git a/facebook/src/com/facebook/UiLifecycleHelper.java b/facebook/src/com/facebook/UiLifecycleHelper.java
new file mode 100644
index 000000000..5d42267f6
--- /dev/null
+++ b/facebook/src/com/facebook/UiLifecycleHelper.java
@@ -0,0 +1,167 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.support.v4.content.LocalBroadcastManager;
+
+/**
+ * This class helps to create, automatically open (if applicable), save, and
+ * restore the Active Session in a way that is similar to Android UI lifecycles.
+ * <p>
+ * When using this class, clients MUST call all the public methods from the
+ * respective methods in either an Activity or Fragment. Failure to call all the
+ * methods can result in improperly initialized or uninitialized Sessions.
+ */
+public class UiLifecycleHelper {
+
+    private final static String ACTIVITY_NULL_MESSAGE = "activity cannot be null";
+
+    private final Activity activity;
+    private final Session.StatusCallback callback;
+    private final BroadcastReceiver receiver;
+    private final LocalBroadcastManager broadcastManager;
+
+    /**
+     * Creates a new UiLifecycleHelper.
+     *
+     * @param activity the Activity associated with the helper. If calling from a Fragment,
+     *                 use {@link android.support.v4.app.Fragment#getActivity()}
+     * @param callback the callback for Session status changes, can be null
+     */
+    public UiLifecycleHelper(Activity activity, Session.StatusCallback callback) {
+        if (activity == null) {
+            throw new IllegalArgumentException(ACTIVITY_NULL_MESSAGE);
+        }
+        this.activity = activity;
+        this.callback = callback;
+        this.receiver = new ActiveSessionBroadcastReceiver();
+        this.broadcastManager = LocalBroadcastManager.getInstance(activity);
+    }
+
+    /**
+     * To be called from an Activity or Fragment's onCreate method.
+     *
+     * @param savedInstanceState the previously saved state
+     */
+    public void onCreate(Bundle savedInstanceState) {
+        Session session = Session.getActiveSession();
+        if (session == null) {
+            if (savedInstanceState != null) {
+                session = Session.restoreSession(activity, null, callback, savedInstanceState);
+            }
+            if (session == null) {
+                session = new Session(activity);
+            }
+            Session.setActiveSession(session);
+        }
+
+        // add the broadcast receiver
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Session.ACTION_ACTIVE_SESSION_SET);
+        filter.addAction(Session.ACTION_ACTIVE_SESSION_UNSET);
+
+        // Add a broadcast receiver to listen to when the active Session
+        // is set or unset, and add/remove our callback as appropriate
+        broadcastManager.registerReceiver(receiver, filter);
+    }
+
+    /**
+     * To be called from an Activity or Fragment's onResume method.
+     */
+    public void onResume() {
+        Session session = Session.getActiveSession();
+        if (session != null) {
+            if (callback != null) {
+                session.addCallback(callback);
+            }
+            if (SessionState.CREATED_TOKEN_LOADED.equals(session.getState())) {
+                session.openForRead(null);
+            }
+        }
+
+    }
+
+    /**
+     * To be called from an Activity or Fragment's onActivityResult method.
+     *
+     * @param requestCode the request code
+     * @param resultCode the result code
+     * @param data the result data
+     */
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        Session session = Session.getActiveSession();
+        if (session != null) {
+            session.onActivityResult(activity, requestCode, resultCode, data);
+        }
+    }
+
+    /**
+     * To be called from an Activity or Fragment's onSaveInstanceState method.
+     *
+     * @param outState the bundle to save state in
+     */
+    public void onSaveInstanceState(Bundle outState) {
+        Session.saveSession(Session.getActiveSession(), outState);
+    }
+
+    /**
+     * To be called from an Activity or Fragment's onPause method.
+     */
+    public void onPause() {
+        if (callback != null) {
+            Session session = Session.getActiveSession();
+            if (session != null) {
+                session.removeCallback(callback);
+            }
+        }
+    }
+
+    /**
+     * To be called from an Activity or Fragment's onDestroy method.
+     */
+    public void onDestroy() {
+        // remove the broadcast receiver
+        broadcastManager.unregisterReceiver(receiver);
+    }
+
+    /**
+     * The BroadcastReceiver implementation that either adds or removes the callback
+     * from the active Session object as it's SET or UNSET.
+     */
+    private class ActiveSessionBroadcastReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (Session.ACTION_ACTIVE_SESSION_SET.equals(intent.getAction())) {
+                Session session = Session.getActiveSession();
+                if (session != null && callback != null) {
+                    session.addCallback(callback);
+                }
+            } else if (Session.ACTION_ACTIVE_SESSION_UNSET.equals(intent.getAction())) {
+                Session session = Session.getActiveSession();
+                if (session != null && callback != null) {
+                    session.removeCallback(callback);
+                }
+            }
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/Validate.java b/facebook/src/com/facebook/Validate.java
deleted file mode 100644
index 63bc8eb55..000000000
--- a/facebook/src/com/facebook/Validate.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package com.facebook;
-
-import java.util.Collection;
-
-final class Validate {
-    static void notNull(Object arg, String name) {
-        if (arg == null) {
-            throw new NullPointerException("Argument " + name + " cannot be null");
-        }
-    }
-
-    static <T> void notEmpty(Collection<T> container, String name) {
-        if (container.isEmpty()) {
-            throw new IllegalArgumentException("Container '" + name + "' cannot be empty");
-        }
-    }
-
-    static <T> void containsNoNulls(Collection<T> container, String name) {
-        Validate.notNull(container, name);
-        for (T item : container) {
-            if (item == null) {
-                throw new NullPointerException("Container '" + name + "' cannot contain null values");
-            }
-        }
-    }
-
-    static <T> void notEmptyAndContainsNoNulls(Collection<T> container, String name) {
-        Validate.containsNoNulls(container, name);
-        Validate.notEmpty(container, name);
-    }
-
-    static void notNullOrEmpty(String arg, String name) {
-        if (Utility.isNullOrEmpty(arg)) {
-            throw new IllegalArgumentException("Argument " + name + " cannot be null or empty");
-        }
-    }
-
-    static void oneOf(Object arg, String name, Object... values) {
-        for (Object value : values) {
-            if (value != null) {
-                if (value.equals(arg)) {
-                    return;
-                }
-            } else {
-                if (arg == null) {
-                    return;
-                }
-            }
-        }
-        throw new IllegalArgumentException("Argument " + name + " was not one of the allowed values");
-    }
-}
diff --git a/facebook/src/com/facebook/android/AsyncFacebookRunner.java b/facebook/src/com/facebook/android/AsyncFacebookRunner.java
index eb9754f60..2420fd4b3 100644
--- a/facebook/src/com/facebook/android/AsyncFacebookRunner.java
+++ b/facebook/src/com/facebook/android/AsyncFacebookRunner.java
@@ -1,5 +1,5 @@
-/*
- * Copyright 2010 Facebook, Inc.
+/**
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -37,6 +37,8 @@
  * functionality could be built, such as rate-limiting of requests, as per
  * a specific application's needs.
  *
+ * @deprecated
+ *
  * @see RequestListener
  *        The callback interface.
  *
@@ -44,6 +46,7 @@
  *          Yariv Sadan (yariv@fb.com),
  *          Luke Shepard (lshepard@fb.com)
  */
+@Deprecated
 public class AsyncFacebookRunner {
 
     Facebook fb;
diff --git a/facebook/src/com/facebook/android/DialogError.java b/facebook/src/com/facebook/android/DialogError.java
index cdb1a883e..a99c4e613 100644
--- a/facebook/src/com/facebook/android/DialogError.java
+++ b/facebook/src/com/facebook/android/DialogError.java
@@ -1,5 +1,5 @@
-/*
- * Copyright 2010 Facebook, Inc.
+/**
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,8 +18,18 @@
 
 /**
  * Encapsulation of Dialog Error.
+ * <p/>
+ * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
+ * <p/>
+ * All public members of this class are intentionally deprecated.
+ * New code should instead use
+ * {@link com.facebook.FacebookException}
+ * <p/>
+ * Adding @Deprecated to this class causes warnings in other deprecated classes
+ * that reference this one.  That is the only reason this entire class is not
+ * deprecated.
  *
- * @author ssoneff@facebook.com
+ * @devDocDeprecated
  */
 public class DialogError extends Throwable {
 
@@ -34,16 +44,19 @@
     /** The URL that the dialog was trying to load */
     private String mFailingUrl;
 
+    @Deprecated
     public DialogError(String message, int errorCode, String failingUrl) {
         super(message);
         mErrorCode = errorCode;
         mFailingUrl = failingUrl;
     }
 
+    @Deprecated
     public int getErrorCode() {
         return mErrorCode;
     }
 
+    @Deprecated
     public String getFailingUrl() {
         return mFailingUrl;
     }
diff --git a/facebook/src/com/facebook/android/Facebook.java b/facebook/src/com/facebook/android/Facebook.java
index b1d9a0624..2b439e7d7 100644
--- a/facebook/src/com/facebook/android/Facebook.java
+++ b/facebook/src/com/facebook/android/Facebook.java
@@ -1,5 +1,5 @@
-/*
- * Copyright 2010 Facebook, Inc.
+/**
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -38,29 +38,41 @@
 import java.util.List;
 
 /**
- * NOTE:  New code should not use this class for anything other than dialog
- * functionality.  This class is maintained for backwards compatibility and
- * because not all dialogs are supported natively yet.  However, we do not
- * intend to add new features to this class, and new code should target
- * Session, Request, and native controls instead.
+ * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
+ * <p/>
+ * All public members of this class are intentionally deprecated.
+ * New code should instead use
+ * {@link Session} to manage session state,
+ * {@link Request} to make API requests, and
+ * {@link com.facebook.widget.WebDialog} to make dialog requests.
  * <p/>
- * The getSession/setSession methods enable incrementally moving some code
- * to use newer APIs while the rest of the application continues to function
- * against this API.
+ * Adding @Deprecated to this class causes warnings in other deprecated classes
+ * that reference this one.  That is the only reason this entire class is not
+ * deprecated.
+ *
+ * @devDocDeprecated
  */
 public class Facebook {
 
     // Strings used in the authorization flow
+    @Deprecated
     public static final String REDIRECT_URI = "fbconnect://success";
+    @Deprecated
     public static final String CANCEL_URI = "fbconnect://cancel";
+    @Deprecated
     public static final String TOKEN = "access_token";
+    @Deprecated
     public static final String EXPIRES = "expires_in";
+    @Deprecated
     public static final String SINGLE_SIGN_ON_DISABLED = "service_disabled";
 
+    @Deprecated
     public static final Uri ATTRIBUTION_ID_CONTENT_URI =
         Uri.parse("content://com.facebook.katana.provider.AttributionIdProvider");
+    @Deprecated
     public static final String ATTRIBUTION_ID_COLUMN_NAME = "aid";
 
+    @Deprecated
     public static final int FORCE_DIALOG_AUTH = -1;
 
     private static final String LOGIN = "oauth";
@@ -69,8 +81,11 @@
     private static final int DEFAULT_AUTH_ACTIVITY_CODE = 32665;
 
     // Facebook server endpoints: may be modified in a subclass for testing
+    @Deprecated
     protected static String DIALOG_BASE_URL = "https://m.facebook.com/dialog/";
+    @Deprecated
     protected static String GRAPH_BASE_URL = "https://graph.facebook.com/";
+    @Deprecated
     protected static String RESTSERVER_URL = "https://api.facebook.com/restserver.php";
 
     private final Object lock = new Object();
@@ -86,15 +101,13 @@
 
     private volatile Session session; // must synchronize this.sync to write
     private boolean sessionInvalidated; // must synchronize this.sync to access
-    private SetterTokenCache tokenCache;
+    private SetterTokenCachingStrategy tokenCache;
     private volatile Session userSetSession;
 
     // If the last time we extended the access token was more than 24 hours ago
     // we try to refresh the access token again.
     final private long REFRESH_TOKEN_BARRIER = 24L * 60L * 60L * 1000L;
 
-    private boolean shouldAutoPublishInstall = true;
-
     /**
      * Constructor for Facebook object.
      * 
@@ -102,6 +115,7 @@
      *            Your Facebook application ID. Found at
      *            www.facebook.com/developers/apps.php.
      */
+    @Deprecated
     public Facebook(String appId) {
         if (appId == null) {
             throw new IllegalArgumentException("You must specify your application ID when instantiating "
@@ -278,8 +292,7 @@ private void authorize(Activity activity, String[] permissions, int activityCode
         checkUserSession("authorize");
         pendingOpeningSession = new Session.Builder(activity).
                 setApplicationId(mAppId).
-                setTokenCache(getTokenCache()).
-                setShouldAutoPublishInstall(getShouldAutoPublishInstall()).
+                setTokenCachingStrategy(getTokenCache()).
                 build();
         pendingAuthorizationActivity = activity;
         pendingAuthorizationPermissions = (permissions != null) ? permissions : new String[0];
@@ -301,7 +314,7 @@ public void call(Session callbackSession, SessionState state, Exception exceptio
     }
 
     private void openSession(Session session, Session.OpenRequest openRequest, boolean isPublish) {
-        openRequest.suppressLoginActivityVerification(true);
+        openRequest.setIsLegacy(true);
         if (isPublish) {
             session.openForPublish(openRequest);
         } else {
@@ -309,6 +322,7 @@ private void openSession(Session session, Session.OpenRequest openRequest, boole
         }
     }
 
+    @SuppressWarnings("deprecation")
     private void onSessionCallback(Session callbackSession, SessionState state, Exception exception,
             DialogListener listener) {
         Bundle extras = callbackSession.getAuthorizationBundle();
@@ -554,6 +568,7 @@ private void refreshToken() {
         }
 
         @Override
+        @SuppressWarnings("deprecation")
         public void handleMessage(Message msg) {
             Facebook facebook = facebookWeakReference.get();
             TokenRefreshServiceConnection connection = connectionWeakReference.get();
@@ -574,7 +589,7 @@ public void handleMessage(Message msg) {
                 if (refreshSession != null) {
                     // Session.internalRefreshToken expects the original bundle with expires_in in seconds from
                     // epoch.
-                    refreshSession.internalRefreshToken(msg.getData());
+                    LegacyHelper.extendTokenCompleted(refreshSession, msg.getData());
                 }
 
                 if (connection.serviceListener != null) {
@@ -780,6 +795,7 @@ public String request(String graphPath, Bundle params, String httpMethod) throws
     }
 
     // Internal call to avoid deprecated warnings.
+    @SuppressWarnings("deprecation")
     String requestImpl(String graphPath, Bundle params, String httpMethod) throws FileNotFoundException,
             MalformedURLException, IOException {
         params.putString("format", "json");
@@ -795,7 +811,9 @@ String requestImpl(String graphPath, Bundle params, String httpMethod) throws Fi
      * <p/>
      * Note that this method is asynchronous and the callback will be invoked in
      * the original calling thread (not in a background thread).
-     * 
+     *
+     * This method is deprecated. See {@link com.facebook.widget.WebDialog}.
+     *
      * @param context
      *            The Android context in which we will generate this dialog.
      * @param action
@@ -805,6 +823,7 @@ String requestImpl(String graphPath, Bundle params, String httpMethod) throws Fi
      *            Callback interface to notify the application when the dialog
      *            has completed.
      */
+    @Deprecated
     public void dialog(Context context, String action, DialogListener listener) {
         dialog(context, action, new Bundle(), listener);
     }
@@ -815,6 +834,8 @@ public void dialog(Context context, String action, DialogListener listener) {
      * <p/>
      * Note that this method is asynchronous and the callback will be invoked in
      * the original calling thread (not in a background thread).
+     *
+     * This method is deprecated. See {@link com.facebook.widget.WebDialog}.
      * 
      * @param context
      *            The Android context in which we will generate this dialog.
@@ -826,9 +847,8 @@ public void dialog(Context context, String action, DialogListener listener) {
      *            Callback interface to notify the application when the dialog
      *            has completed.
      */
+    @Deprecated
     public void dialog(Context context, String action, Bundle parameters, final DialogListener listener) {
-
-        String endpoint = DIALOG_BASE_URL + action;
         parameters.putString("display", "touch");
         parameters.putString("redirect_uri", REDIRECT_URI);
 
@@ -837,16 +857,16 @@ public void dialog(Context context, String action, Bundle parameters, final Dial
             parameters.putString("client_id", mAppId);
         } else {
             parameters.putString("app_id", mAppId);
+            // We do not want to add an access token when displaying the auth dialog.
+            if (isSessionValid()) {
+                parameters.putString(TOKEN, getAccessToken());
+            }
         }
 
-        if (isSessionValid()) {
-            parameters.putString(TOKEN, getAccessToken());
-        }
-        String url = endpoint + "?" + Util.encodeUrl(parameters);
         if (context.checkCallingOrSelfPermission(Manifest.permission.INTERNET) != PackageManager.PERMISSION_GRANTED) {
             Util.showAlert(context, "Error", "Application requires permission to access the Internet");
         } else {
-            new FbDialog(context, url, listener).show();
+            new FbDialog(context, action, parameters, listener).show();
         }
     }
 
@@ -855,6 +875,7 @@ public void dialog(Context context, String action, Bundle parameters, final Dial
      *
      * @return boolean - whether this object has an non-expired session token
      */
+    @Deprecated
     public boolean isSessionValid() {
         return (getAccessToken() != null)
                 && ((getAccessExpires() == 0) || (System.currentTimeMillis() < getAccessExpires()));
@@ -869,6 +890,7 @@ public boolean isSessionValid() {
      *
      * @param session the Session object to use, cannot be null
      */
+    @Deprecated
     public void setSession(Session session) {
         if (session == null) {
             throw new IllegalArgumentException("session cannot be null");
@@ -890,6 +912,7 @@ private void checkUserSession(String methodName) {
      * 
      * @return Session - underlying session
      */
+    @Deprecated
     public final Session getSession() {
         while (true) {
             String cachedToken = null;
@@ -925,7 +948,7 @@ public final Session getSession() {
 
             Session newSession = new Session.Builder(pendingAuthorizationActivity).
                     setApplicationId(mAppId).
-                    setTokenCache(getTokenCache()).
+                    setTokenCachingStrategy(getTokenCache()).
                     build();
             if (newSession.getState() != SessionState.CREATED_TOKEN_LOADED) {
                 return null;
@@ -963,6 +986,7 @@ public final Session getSession() {
      *
      * @return String - access token
      */
+    @Deprecated
     public String getAccessToken() {
         Session s = getSession();
         if (s != null) {
@@ -978,6 +1002,7 @@ public String getAccessToken() {
      *
      * @return long - session expiration time
      */
+    @Deprecated
     public long getAccessExpires() {
         Session s = getSession();
         if (s != null) {
@@ -993,6 +1018,7 @@ public long getAccessExpires() {
      *
      * @return long - timestamp of the last token update.
      */
+    @Deprecated
     public long getLastAccessUpdate() {
         return lastAccessUpdateMillisecondsAfterEpoch;
     }
@@ -1098,11 +1124,11 @@ public void setAppId(String appId) {
         }
     }
 
-    private TokenCache getTokenCache() {
+    private TokenCachingStrategy getTokenCache() {
         // Intentionally not volatile/synchronized--it is okay if we race to
         // create more than one of these.
         if (tokenCache == null) {
-            tokenCache = new SetterTokenCache();
+            tokenCache = new SetterTokenCachingStrategy();
         }
         return tokenCache;
     }
@@ -1127,18 +1153,18 @@ private TokenCache getTokenCache() {
         }
     }
 
-    private class SetterTokenCache extends TokenCache {
+    private class SetterTokenCachingStrategy extends TokenCachingStrategy {
 
         @Override
         public Bundle load() {
             Bundle bundle = new Bundle();
 
             if (accessToken != null) {
-                TokenCache.putToken(bundle, accessToken);
-                TokenCache.putExpirationMilliseconds(bundle, accessExpiresMillisecondsAfterEpoch);
-                TokenCache.putPermissions(bundle, stringList(pendingAuthorizationPermissions));
-                TokenCache.putIsSSO(bundle, false);
-                TokenCache.putLastRefreshMilliseconds(bundle, lastAccessUpdateMillisecondsAfterEpoch);
+                TokenCachingStrategy.putToken(bundle, accessToken);
+                TokenCachingStrategy.putExpirationMilliseconds(bundle, accessExpiresMillisecondsAfterEpoch);
+                TokenCachingStrategy.putPermissions(bundle, stringList(pendingAuthorizationPermissions));
+                TokenCachingStrategy.putSource(bundle, AccessTokenSource.WEB_VIEW);
+                TokenCachingStrategy.putLastRefreshMilliseconds(bundle, lastAccessUpdateMillisecondsAfterEpoch);
             }
 
             return bundle;
@@ -1146,10 +1172,10 @@ public Bundle load() {
 
         @Override
         public void save(Bundle bundle) {
-            accessToken = TokenCache.getToken(bundle);
-            accessExpiresMillisecondsAfterEpoch = TokenCache.getExpirationMilliseconds(bundle);
-            pendingAuthorizationPermissions = stringArray(TokenCache.getPermissions(bundle));
-            lastAccessUpdateMillisecondsAfterEpoch = TokenCache.getLastRefreshMilliseconds(bundle);
+            accessToken = TokenCachingStrategy.getToken(bundle);
+            accessExpiresMillisecondsAfterEpoch = TokenCachingStrategy.getExpirationMilliseconds(bundle);
+            pendingAuthorizationPermissions = stringArray(TokenCachingStrategy.getPermissions(bundle));
+            lastAccessUpdateMillisecondsAfterEpoch = TokenCachingStrategy.getLastRefreshMilliseconds(bundle);
         }
 
         @Override
@@ -1183,7 +1209,7 @@ public static String getAttributionId(ContentResolver contentResolver) {
      */
     @Deprecated
     public boolean getShouldAutoPublishInstall() {
-        return shouldAutoPublishInstall;
+        return Settings.getShouldAutoPublishInstall();
     }
 
     /**
@@ -1195,11 +1221,11 @@ public boolean getShouldAutoPublishInstall() {
      */
     @Deprecated
     public void setShouldAutoPublishInstall(boolean value) {
-        shouldAutoPublishInstall = value;
+        Settings.setShouldAutoPublishInstall(value);
     }
 
     /**
-     * Manually publish install attribution to the facebook graph.  Internally handles tracking repeat calls to prevent
+     * Manually publish install attribution to the Facebook graph.  Internally handles tracking repeat calls to prevent
      * multiple installs being published to the graph.
      * <p/>
      * This method is deprecated.  See {@link Facebook} and {@link Settings} for more info.
@@ -1217,7 +1243,18 @@ public boolean publishInstall(final Context context) {
 
     /**
      * Callback interface for dialog requests.
-     * 
+     * <p/>
+     * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
+     * <p/>
+     * All public members of this class are intentionally deprecated.
+     * New code should instead use
+     * {@link com.facebook.widget.WebDialog}
+     * <p/>
+     * Adding @Deprecated to this class causes warnings in other deprecated classes
+     * that reference this one.  That is the only reason this entire class is not
+     * deprecated.
+     *
+     * @devDocDeprecated
      */
     public static interface DialogListener {
 
@@ -1259,6 +1296,18 @@ public boolean publishInstall(final Context context) {
 
     /**
      * Callback interface for service requests.
+     * <p/>
+     * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
+     * <p/>
+     * All public members of this class are intentionally deprecated.
+     * New code should instead use
+     * {@link Session} to manage session state.
+     * <p/>
+     * Adding @Deprecated to this class causes warnings in other deprecated classes
+     * that reference this one.  That is the only reason this entire class is not
+     * deprecated.
+     *
+     * @devDocDeprecated
      */
     public static interface ServiceListener {
 
@@ -1282,6 +1331,7 @@ public boolean publishInstall(final Context context) {
 
     }
 
+    @Deprecated
     public static final String FB_APP_SIGNATURE =
         "30820268308201d102044a9c4610300d06092a864886f70d0101040500307a310"
         + "b3009060355040613025553310b30090603550408130243413112301006035504"
diff --git a/facebook/src/com/facebook/android/FacebookError.java b/facebook/src/com/facebook/android/FacebookError.java
index 3a2c6cd43..41ae794fc 100644
--- a/facebook/src/com/facebook/android/FacebookError.java
+++ b/facebook/src/com/facebook/android/FacebookError.java
@@ -1,5 +1,5 @@
-/*
- * Copyright 2010 Facebook, Inc.
+/**
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,8 +19,18 @@
 /**
  * Encapsulation of a Facebook Error: a Facebook request that could not be
  * fulfilled.
+ * <p/>
+ * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
+ * <p/>
+ * All public members of this class are intentionally deprecated.
+ * New code should instead use
+ * {@link com.facebook.FacebookException}
+ * <p/>
+ * Adding @Deprecated to this class causes warnings in other deprecated classes
+ * that reference this one.  That is the only reason this entire class is not
+ * deprecated.
  *
- * @author ssoneff@facebook.com
+ * @devDocDeprecated
  */
 public class FacebookError extends RuntimeException {
 
@@ -29,20 +39,24 @@
     private int mErrorCode = 0;
     private String mErrorType;
 
+    @Deprecated
     public FacebookError(String message) {
         super(message);
     }
 
+    @Deprecated
     public FacebookError(String message, String type, int code) {
         super(message);
         mErrorType = type;
         mErrorCode = code;
     }
 
+    @Deprecated
     public int getErrorCode() {
         return mErrorCode;
     }
 
+    @Deprecated
     public String getErrorType() {
         return mErrorType;
     }
diff --git a/facebook/src/com/facebook/android/FbDialog.java b/facebook/src/com/facebook/android/FbDialog.java
index e556365b8..603e69280 100644
--- a/facebook/src/com/facebook/android/FbDialog.java
+++ b/facebook/src/com/facebook/android/FbDialog.java
@@ -1,5 +1,5 @@
-/*
- * Copyright 2010 Facebook, Inc.
+/**
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,271 +16,68 @@
 
 package com.facebook.android;
 
-import android.annotation.SuppressLint;
-import android.app.Dialog;
-import android.app.ProgressDialog;
 import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.graphics.Bitmap;
-import android.graphics.Color;
-import android.graphics.drawable.Drawable;
-import android.net.Uri;
-import android.net.http.SslError;
 import android.os.Bundle;
-import android.view.View;
-import android.view.ViewGroup.LayoutParams;
-import android.view.Window;
-import android.webkit.SslErrorHandler;
-import android.webkit.WebView;
-import android.webkit.WebViewClient;
-import android.widget.FrameLayout;
-import android.widget.ImageView;
-import android.widget.LinearLayout;
+import com.facebook.*;
 import com.facebook.android.Facebook.DialogListener;
+import com.facebook.widget.WebDialog;
 
-public class FbDialog extends Dialog {
-
-    static final int FB_BLUE = 0xFF6D84B4;
-    static final float[] DIMENSIONS_DIFF_LANDSCAPE = {20, 60};
-    static final float[] DIMENSIONS_DIFF_PORTRAIT = {40, 60};
-    static final FrameLayout.LayoutParams FILL =
-        new FrameLayout.LayoutParams(LayoutParams.MATCH_PARENT,
-                         LayoutParams.MATCH_PARENT);
-    static final int MARGIN = 4;
-    static final int PADDING = 2;
-    static final String DISPLAY_STRING = "touch";
-    static final String FB_ICON = "icon.png";
-
-    private String mUrl;
+/**
+ * This class is deprecated. See {@link com.facebook.widget.WebDialog}.
+ */
+@Deprecated
+public class FbDialog extends WebDialog {
     private DialogListener mListener;
-    private ProgressDialog mSpinner;
-    private ImageView mCrossImage;
-    private WebView mWebView;
-    private FrameLayout mContent;
 
     public FbDialog(Context context, String url, DialogListener listener) {
-        super(context, android.R.style.Theme_Translucent_NoTitleBar);
-        mUrl = url;
-        mListener = new SingleDispatchDialogListener(listener);
+        this(context, url, listener, DEFAULT_THEME);
     }
 
-    @Override
-    public void dismiss() {
-        if (mWebView != null) {
-            mWebView.stopLoading();
-        }
-        if (mSpinner.isShowing()) {
-            mSpinner.dismiss();
-        }
-        super.dismiss();
+    public FbDialog(Context context, String url, DialogListener listener, int theme) {
+        super(context, url, theme);
+        setDialogListener(listener);
     }
 
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        setOnCancelListener(new OnCancelListener() {
-            @Override
-            public void onCancel(DialogInterface dialogInterface) {
-                mListener.onCancel();
-            }
-        });
-
-        mSpinner = new ProgressDialog(getContext());
-        mSpinner.requestWindowFeature(Window.FEATURE_NO_TITLE);
-        mSpinner.setMessage("Loading...");
-        mSpinner.setOnCancelListener(new OnCancelListener() {
-            @Override
-            public void onCancel(DialogInterface dialogInterface) {
-                mListener.onCancel();
-                FbDialog.this.dismiss();
-            }
-        });
-        
-        requestWindowFeature(Window.FEATURE_NO_TITLE);
-        mContent = new FrameLayout(getContext());
-
-        /* Create the 'x' image, but don't add to the mContent layout yet
-         * at this point, we only need to know its drawable width and height 
-         * to place the webview
-         */
-        createCrossImage();
-        
-        /* Now we know 'x' drawable width and height, 
-         * layout the webivew and add it the mContent layout
-         */
-        int crossWidth = mCrossImage.getDrawable().getIntrinsicWidth();
-        setUpWebView(crossWidth / 2);
-        
-        /* Finally add the 'x' image to the mContent layout and
-         * add mContent to the Dialog view
-         */
-        mContent.addView(mCrossImage, new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));
-        addContentView(mContent, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
-    }
-    
-    private void createCrossImage() {
-        mCrossImage = new ImageView(getContext());
-        // Dismiss the dialog when user click on the 'x'
-        mCrossImage.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                mListener.onCancel();
-                FbDialog.this.dismiss();
-            }
-        });
-        Drawable crossDrawable = getContext().getResources().getDrawable(R.drawable.com_facebook_close);
-        mCrossImage.setImageDrawable(crossDrawable);
-        /* 'x' should not be visible while webview is loading
-         * make it visible only after webview has fully loaded
-        */
-        mCrossImage.setVisibility(View.INVISIBLE);
+    public FbDialog(Context context, String action, Bundle parameters, DialogListener listener) {
+        super(context, action, parameters, DEFAULT_THEME, null);
+        setDialogListener(listener);
     }
 
-    @SuppressLint("SetJavaScriptEnabled") 
-    private void setUpWebView(int margin) {
-        LinearLayout webViewContainer = new LinearLayout(getContext());
-        mWebView = new WebView(getContext());
-        mWebView.setVerticalScrollBarEnabled(false);
-        mWebView.setHorizontalScrollBarEnabled(false);
-        mWebView.setWebViewClient(new FbDialog.FbWebViewClient());
-        mWebView.getSettings().setJavaScriptEnabled(true);
-        mWebView.loadUrl(mUrl);
-        mWebView.setLayoutParams(FILL);
-        mWebView.setVisibility(View.INVISIBLE);
-        mWebView.getSettings().setSavePassword(false);
-        
-        webViewContainer.setPadding(margin, margin, margin, margin);
-        webViewContainer.addView(mWebView);
-        mContent.addView(webViewContainer);
+    public FbDialog(Context context, String action, Bundle parameters, DialogListener listener,
+            int theme) {
+        super(context, action, parameters, theme, null);
+        setDialogListener(listener);
     }
 
-    private class FbWebViewClient extends WebViewClient {
-
-        @Override
-        public boolean shouldOverrideUrlLoading(WebView view, String url) {
-            Util.logd("Facebook-WebView", "Redirect URL: " + url);
-            if (url.startsWith(Facebook.REDIRECT_URI)) {
-                Bundle values = Util.parseUrl(url);
-
-                String error = values.getString("error");
-                if (error == null) {
-                    error = values.getString("error_type");
-                }
-
-                if (error == null) {
-                    mListener.onComplete(values);
-                } else if (error.equals("access_denied") ||
-                           error.equals("OAuthAccessDeniedException")) {
-                    mListener.onCancel();
-                } else {
-                    mListener.onFacebookError(new FacebookError(error));
-                }
-
-                FbDialog.this.dismiss();
-                return true;
-            } else if (url.startsWith(Facebook.CANCEL_URI)) {
-                mListener.onCancel();
-                FbDialog.this.dismiss();
-                return true;
-            } else if (url.contains(DISPLAY_STRING)) {
-                return false;
+    private void setDialogListener(DialogListener listener) {
+        this.mListener = listener;
+        setOnCompleteListener(new OnCompleteListener() {
+            @Override
+            public void onComplete(Bundle values, FacebookException error) {
+                callDialogListener(values, error);
             }
-            // launch non-dialog URLs in a full browser
-            getContext().startActivity(
-                    new Intent(Intent.ACTION_VIEW, Uri.parse(url)));
-            return true;
-        }
-
-        @Override
-        public void onReceivedError(WebView view, int errorCode,
-                String description, String failingUrl) {
-            super.onReceivedError(view, errorCode, description, failingUrl);
-            mListener.onError(
-                    new DialogError(description, errorCode, failingUrl));
-            FbDialog.this.dismiss();
-        }
-
-        @Override
-        public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {
-            super.onReceivedSslError(view, handler, error);
-
-            mListener.onError(new DialogError(null, ERROR_FAILED_SSL_HANDSHAKE, null));
-            handler.cancel();
-            FbDialog.this.dismiss();
-        }
-
-        @Override
-        public void onPageStarted(WebView view, String url, Bitmap favicon) {
-            Util.logd("Facebook-WebView", "Webview loading URL: " + url);
-            super.onPageStarted(view, url, favicon);
-            mSpinner.show();
-        }
-
-        @Override
-        public void onPageFinished(WebView view, String url) {
-            super.onPageFinished(view, url);
-            mSpinner.dismiss();
-            /* 
-             * Once webview is fully loaded, set the mContent background to be transparent
-             * and make visible the 'x' image. 
-             */
-            mContent.setBackgroundColor(Color.TRANSPARENT);
-            mWebView.setVisibility(View.VISIBLE);
-            mCrossImage.setVisibility(View.VISIBLE);
-        }
+        });
     }
 
-    /**
-     * Ensure that only one listener method is called per dialog. This class is not thread
-     * safe and assumes that all onXXX calls will be made in the same thread (preferably the
-     * main thread). It is package private for testing purposes.
-     */
-    static class SingleDispatchDialogListener implements DialogListener {
-
-        private final DialogListener wrapped;
-        private boolean allowDispatch;
-
-        public SingleDispatchDialogListener(DialogListener listener) {
-            wrapped = listener;
-            allowDispatch = true;
+    private void callDialogListener(Bundle values, FacebookException error) {
+        if (mListener == null) {
+            return;
         }
 
-        @Override
-        public void onComplete(Bundle values) {
-            if (checkAndSetDispatch(false)) {
-                wrapped.onComplete(values);
-            }
-        }
-
-        @Override
-        public void onFacebookError(FacebookError e) {
-            if (checkAndSetDispatch(false)) {
-                wrapped.onFacebookError(e);
-            }
-        }
-
-        @Override
-        public void onError(DialogError e) {
-            if (checkAndSetDispatch(false)) {
-                wrapped.onError(e);
-            }
-        }
-
-        @Override
-        public void onCancel() {
-            if (checkAndSetDispatch(false)) {
-                wrapped.onCancel();
-            }
-        }
-
-        private boolean checkAndSetDispatch(boolean finalValue) {
-            if (wrapped != null && allowDispatch) {
-                allowDispatch = finalValue;
-                return true;
+        if (values != null) {
+            mListener.onComplete(values);
+        } else {
+            if (error instanceof FacebookDialogException) {
+                FacebookDialogException facebookDialogException = (FacebookDialogException) error;
+                DialogError dialogError = new DialogError(facebookDialogException.getMessage(),
+                        facebookDialogException.getErrorCode(), facebookDialogException.getFailingUrl());
+                mListener.onError(dialogError);
+            } else if (error instanceof FacebookOperationCanceledException) {
+                mListener.onCancel();
+            } else {
+                FacebookError facebookError = new FacebookError(error.getMessage());
+                mListener.onFacebookError(facebookError);
             }
-            return false;
         }
     }
 }
diff --git a/facebook/src/com/facebook/android/Util.java b/facebook/src/com/facebook/android/Util.java
index 52dda1232..231c1e78c 100644
--- a/facebook/src/com/facebook/android/Util.java
+++ b/facebook/src/com/facebook/android/Util.java
@@ -1,5 +1,5 @@
-/*
- * Copyright 2010 Facebook, Inc.
+/**
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,7 +19,7 @@
 import android.app.AlertDialog.Builder;
 import android.content.Context;
 import android.os.Bundle;
-import android.util.Log;
+import com.facebook.internal.Utility;
 import org.json.JSONException;
 import org.json.JSONObject;
 
@@ -28,18 +28,21 @@
 
 /**
  * Utility class supporting the Facebook Object.
+ * <p/>
+ * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
+ * <p/>
+ * All public members of this class are intentionally deprecated.
+ * New code should instead use
+ * {@link com.facebook.Request}
+ * <p/>
+ * Adding @Deprecated to this class causes warnings in other deprecated classes
+ * that reference this one.  That is the only reason this entire class is not
+ * deprecated.
  *
- * @author ssoneff@facebook.com
- *
+ * @devDocDeprecated
  */
 public final class Util {
 
-    /**
-     * Set this to true to enable log output.  Remember to turn this back off
-     * before releasing.  Sending sensitive data to log is a security risk.
-     */
-    private static boolean ENABLE_LOG = false;
-
     private final static String UTF8 = "UTF-8";
 
     /**
@@ -50,6 +53,7 @@
      * @param boundary the random string as boundary
      * @return a string of the post body
      */
+    @Deprecated
     public static String encodePostBody(Bundle parameters, String boundary) {
         if (parameters == null) return "";
         StringBuilder sb = new StringBuilder();
@@ -68,6 +72,7 @@ public static String encodePostBody(Bundle parameters, String boundary) {
         return sb.toString();
     }
 
+    @Deprecated
     public static String encodeUrl(Bundle parameters) {
         if (parameters == null) {
             return "";
@@ -88,6 +93,7 @@ public static String encodeUrl(Bundle parameters) {
         return sb.toString();
     }
 
+    @Deprecated
     public static Bundle decodeUrl(String s) {
         Bundle params = new Bundle();
         if (s != null) {
@@ -116,6 +122,7 @@ public static Bundle decodeUrl(String s) {
      * @param url the URL to parse
      * @return a dictionary bundle of keys and values
      */
+    @Deprecated
     public static Bundle parseUrl(String url) {
         // hack to prevent MalformedURLException
         url = url.replace("fbconnect", "http");
@@ -143,6 +150,7 @@ public static Bundle parseUrl(String url) {
      * @throws MalformedURLException - if the URL format is invalid
      * @throws IOException - if a network problem occurs
      */
+    @Deprecated
     public static String openUrl(String url, String method, Bundle params)
           throws MalformedURLException, IOException {
         // random string as boundary for multi-part http post
@@ -154,7 +162,7 @@ public static String openUrl(String url, String method, Bundle params)
         if (method.equals("GET")) {
             url = url + "?" + encodeUrl(params);
         }
-        Util.logd("Facebook-Util", method + " URL: " + url);
+        Utility.logd("Facebook-Util", method + " URL: " + url);
         HttpURLConnection conn =
             (HttpURLConnection) new URL(url).openConnection();
         conn.setRequestProperty("User-Agent", System.getProperties().
@@ -216,6 +224,7 @@ public static String openUrl(String url, String method, Bundle params)
         return response;
     }
 
+    @Deprecated
     private static String read(InputStream in) throws IOException {
         StringBuilder sb = new StringBuilder();
         BufferedReader r = new BufferedReader(new InputStreamReader(in), 1000);
@@ -241,6 +250,7 @@ private static String read(InputStream in) throws IOException {
      * @throws JSONException - if the response is not valid JSON
      * @throws FacebookError - if an error condition is set
      */
+    @Deprecated
     public static JSONObject parseJson(String response)
           throws JSONException, FacebookError {
         // Edge case: when sending a POST request to /[post_id]/likes
@@ -289,24 +299,11 @@ public static JSONObject parseJson(String response)
      * @param text
      *          Alert dialog message
      */
+    @Deprecated
     public static void showAlert(Context context, String title, String text) {
         Builder alertBuilder = new Builder(context);
         alertBuilder.setTitle(title);
         alertBuilder.setMessage(text);
         alertBuilder.create().show();
     }
-
-    /**
-     * A proxy for Log.d api that kills log messages in release build. It
-     * not recommended to send sensitive information to log output in
-     * shipping apps.
-     *
-     * @param tag
-     * @param msg
-     */
-    public static void logd(String tag, String msg) {
-        if (ENABLE_LOG) {
-            Log.d(tag, msg);
-        }
-    }
 }
diff --git a/facebook/src/com/facebook/internal/CacheableRequestBatch.java b/facebook/src/com/facebook/internal/CacheableRequestBatch.java
new file mode 100644
index 000000000..26a1595c2
--- /dev/null
+++ b/facebook/src/com/facebook/internal/CacheableRequestBatch.java
@@ -0,0 +1,57 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import com.facebook.Request;
+import com.facebook.RequestBatch;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public class CacheableRequestBatch extends RequestBatch {
+    private String cacheKey;
+    private boolean forceRoundTrip;
+
+    public CacheableRequestBatch() {
+    }
+
+    public CacheableRequestBatch(Request... requests) {
+        super(requests);
+    }
+
+    public final String getCacheKeyOverride() {
+        return cacheKey;
+    }
+
+    // If this is set, the provided string will override the default key (the URL) for single requests.
+    // There is no default for multi-request batches, so no caching will be done unless the override is
+    // specified.
+    public final void setCacheKeyOverride(String cacheKey) {
+        this.cacheKey = cacheKey;
+    }
+
+    public final boolean getForceRoundTrip() {
+        return forceRoundTrip;
+    }
+
+    public final void setForceRoundTrip(boolean forceRoundTrip) {
+        this.forceRoundTrip = forceRoundTrip;
+    }
+
+}
diff --git a/facebook/src/com/facebook/FileLruCache.java b/facebook/src/com/facebook/internal/FileLruCache.java
similarity index 70%
rename from facebook/src/com/facebook/FileLruCache.java
rename to facebook/src/com/facebook/internal/FileLruCache.java
index 8cc2459eb..1fe81b5e1 100644
--- a/facebook/src/com/facebook/FileLruCache.java
+++ b/facebook/src/com/facebook/internal/FileLruCache.java
@@ -1,5 +1,5 @@
 /**
- * Copyright 2010 Facebook, Inc.
+ * Copyright 2012 Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,10 +14,12 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.internal;
 
 import android.content.Context;
 import android.util.Log;
+import com.facebook.LoggingBehavior;
+import com.facebook.Settings;
 import org.json.JSONException;
 import org.json.JSONObject;
 import org.json.JSONTokener;
@@ -28,7 +30,32 @@
 import java.util.PriorityQueue;
 import java.util.concurrent.atomic.AtomicLong;
 
-final class FileLruCache {
+// This class is intended to be thread-safe.
+//
+// There are two classes of files:  buffer files and cache files:
+// - A buffer file is in the process of being written, and there is an open stream on the file.  These files are
+//   named as "bufferN" where N is an incrementing integer.  On startup, we delete all existing files of this form.
+//   Once the stream is closed, we rename the buffer file to a cache file or attempt to delete if this fails.  We
+//   do not otherwise ever attempt to delete these files.
+// - A cache file is a non-changing file that is named by the md5 hash of the cache key.  We monitor the size of
+//   these files in aggregate and remove the oldest one(s) to stay under quota.  This process does not block threads
+//   calling into this class, so theoretically we could go arbitrarily over quota but in practice this should not
+//   happen because deleting files should be much cheaper than downloading new file content.
+//
+// Since there can only ever be one thread accessing a particular buffer file, we do not synchronize access to these.
+// We do assume that file rename is atomic when converting a buffer file to a cache file, and that if multiple files
+// are renamed to a single target that exactly one of them continues to exist.
+//
+// Standard POSIX file semantics guarantee being able to continue to use a file handle even after the
+// corresponding file has been deleted.  Given this and that cache files never change other than deleting in trim(),
+// we only have to ensure that there is at most one trim() process deleting files at any given time.
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public final class FileLruCache {
     static final String TAG = FileLruCache.class.getSimpleName();
     private static final String HEADER_CACHEKEY_KEY = "key";
     private static final String HEADER_CACHE_CONTENT_TAG_KEY = "tag";
@@ -38,12 +65,15 @@
     private final String tag;
     private final Limits limits;
     private final File directory;
+    private boolean isTrimPending;
+    private final Object lock;
 
     // The value of tag should be a final String that works as a directory name.
-    FileLruCache(Context context, String tag, Limits limits) {
+    public FileLruCache(Context context, String tag, Limits limits) {
         this.tag = tag;
         this.limits = limits;
         this.directory = new File(context.getCacheDir(), tag);
+        this.lock = new Object();
 
         // Ensure the cache dir exists
         this.directory.mkdirs();
@@ -52,17 +82,44 @@
         BufferFile.deleteAll(this.directory);
     }
 
-    void clear() throws IOException {
+    // Other code in this class is not necessarily robust to having buffer files deleted concurrently.
+    // If this is ever used for non-test code, we should make sure the synchronization is correct.  See
+    // the threading notes at the top of this class.
+    public void clearForTest() throws IOException {
         for (File file : this.directory.listFiles()) {
             file.delete();
         }
     }
 
-    InputStream get(String key) throws IOException {
+    // This is not robust to files changing dynamically underneath it and should therefore only be used
+    // for test code.  If we ever need this for product code we need to think through synchronization.
+    // See the threading notes at the top of this class.
+    //
+    // Also, since trim() runs asynchronously now, this blocks until any pending trim has completed.
+    long sizeInBytesForTest() {
+        synchronized (lock) {
+            while (isTrimPending) {
+                try {
+                    lock.wait();
+                } catch (InterruptedException e) {
+                    // intentional no-op
+                }
+            }
+        }
+
+        File[] files = this.directory.listFiles();
+        long total = 0;
+        for (File file : files) {
+            total += file.length();
+        }
+        return total;
+    }
+
+    public InputStream get(String key) throws IOException {
         return get(key, null);
     }
 
-    InputStream get(String key, String contentTag) throws IOException {
+    public InputStream get(String key, String contentTag) throws IOException {
         File file = new File(this.directory, Utility.md5hash(key));
 
         FileInputStream input = null;
@@ -87,12 +144,14 @@ InputStream get(String key, String contentTag) throws IOException {
             }
 
             String headerContentTag = header.optString(HEADER_CACHE_CONTENT_TAG_KEY, null);
-            if (headerContentTag != contentTag) {
+
+            if ((contentTag == null && headerContentTag != null) ||
+                    (contentTag != null && !contentTag.equals(headerContentTag))) {
                 return null;
             }
 
             long accessTime = new Date().getTime();
-            Logger.log(LoggingBehaviors.CACHE, TAG, "Setting lastModified to " + Long.valueOf(accessTime) + " for "
+            Logger.log(LoggingBehavior.CACHE, TAG, "Setting lastModified to " + Long.valueOf(accessTime) + " for "
                     + file.getName());
             file.setLastModified(accessTime);
 
@@ -109,7 +168,7 @@ OutputStream openPutStream(final String key) throws IOException {
         return openPutStream(key, null);
     }
 
-    OutputStream openPutStream(final String key, String contentTag) throws IOException {
+    public OutputStream openPutStream(final String key, String contentTag) throws IOException {
         final File buffer = BufferFile.newFile(this.directory);
         buffer.delete();
         if (!buffer.createNewFile()) {
@@ -120,18 +179,14 @@ OutputStream openPutStream(final String key, String contentTag) throws IOExcepti
         try {
             file = new FileOutputStream(buffer);
         } catch (FileNotFoundException e) {
-            Logger.log(LoggingBehaviors.CACHE, Log.WARN, TAG, "Error creating buffer output stream: " + e);
+            Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, "Error creating buffer output stream: " + e);
             throw new IOException(e.getMessage());
         }
 
         StreamCloseCallback renameToTargetCallback = new StreamCloseCallback() {
             @Override
             public void onClose() {
-                final File target = new File(directory, Utility.md5hash(key));
-                if (!buffer.renameTo(target)) {
-                    buffer.delete();
-                }
-                trim();
+                renameToTargetAndTrim(key, buffer);
             }
         };
 
@@ -153,7 +208,7 @@ public void onClose() {
             return buffered;
         } catch (JSONException e) {
             // JSON is an implementation detail of the cache, so don't let JSON exceptions out.
-            Logger.log(LoggingBehaviors.CACHE, Log.WARN, TAG, "Error creating JSON header for cache file: " + e);
+            Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, "Error creating JSON header for cache file: " + e);
             throw new IOException(e.getMessage());
         } finally {
             if (!success) {
@@ -162,48 +217,75 @@ public void onClose() {
         }
     }
 
+    private void renameToTargetAndTrim(String key, File buffer) {
+        final File target = new File(directory, Utility.md5hash(key));
+
+        // This is triggered by close().  By the time close() returns, the file should be cached, so this needs to
+        // happen synchronously on this thread.
+        //
+        // However, it does not need to be synchronized, since in the race we will just start an unnecesary trim
+        // operation.  Avoiding the cost of holding the lock across the file operation seems worth this cost.
+        if (!buffer.renameTo(target)) {
+            buffer.delete();
+        }
+
+        postTrim();
+    }
+
     // Opens an output stream for the key, and creates an input stream wrapper to copy
     // the contents of input into the new output stream.  The effect is to store a
     // copy of input, and associate that data with key.
-    InputStream interceptAndPut(String key, InputStream input) throws IOException {
+    public InputStream interceptAndPut(String key, InputStream input) throws IOException {
         OutputStream output = openPutStream(key);
         return new CopyingInputStream(input, output);
     }
 
-    long sizeInBytes() {
-        File[] files = this.directory.listFiles();
-        long total = 0;
-        for (File file : files) {
-            total += file.length();
-        }
-        return total;
+    public String toString() {
+        return "{FileLruCache:" + " tag:" + this.tag + " file:" + this.directory.getName() + "}";
     }
 
-    public synchronized String toString() {
-        return "{FileLruCache:" + " tag:" + this.tag + " file:" + this.directory.getName() + "}";
+    private void postTrim() {
+        synchronized (lock) {
+            if (!isTrimPending) {
+                isTrimPending = true;
+                Settings.getExecutor().execute(new Runnable() {
+                    @Override
+                    public void run() {
+                        trim();
+                    }
+                });
+            }
+        }
     }
 
     private void trim() {
-        Logger.log(LoggingBehaviors.CACHE, TAG, "trim started");
-        PriorityQueue<ModifiedFile> heap = new PriorityQueue<ModifiedFile>();
-        long size = 0;
-        long count = 0;
-        for (File file : this.directory.listFiles(BufferFile.excludeBufferFiles())) {
-            ModifiedFile modified = new ModifiedFile(file);
-            heap.add(modified);
-            Logger.log(LoggingBehaviors.CACHE, TAG, "  trim considering time=" + Long.valueOf(modified.getModified())
-                    + " name=" + modified.getFile().getName());
-
-            size += file.length();
-            count++;
-        }
-
-        while ((size > limits.getByteCount()) || (count > limits.getFileCount())) {
-            File file = heap.remove().getFile();
-            Logger.log(LoggingBehaviors.CACHE, TAG, "  trim removing " + file.getName());
-            size -= file.length();
-            count--;
-            file.delete();
+        try {
+            Logger.log(LoggingBehavior.CACHE, TAG, "trim started");
+            PriorityQueue<ModifiedFile> heap = new PriorityQueue<ModifiedFile>();
+            long size = 0;
+            long count = 0;
+            for (File file : this.directory.listFiles(BufferFile.excludeBufferFiles())) {
+                ModifiedFile modified = new ModifiedFile(file);
+                heap.add(modified);
+                Logger.log(LoggingBehavior.CACHE, TAG, "  trim considering time=" + Long.valueOf(modified.getModified())
+                        + " name=" + modified.getFile().getName());
+
+                size += file.length();
+                count++;
+            }
+
+            while ((size > limits.getByteCount()) || (count > limits.getFileCount())) {
+                File file = heap.remove().getFile();
+                Logger.log(LoggingBehavior.CACHE, TAG, "  trim removing " + file.getName());
+                size -= file.length();
+                count--;
+                file.delete();
+            }
+        } finally {
+            synchronized (lock) {
+                isTrimPending = false;
+                lock.notifyAll();
+            }
         }
     }
 
@@ -278,7 +360,7 @@ static JSONObject readHeader(InputStream stream) throws IOException {
             for (int i = 0; i < 3; i++) {
                 int b = stream.read();
                 if (b == -1) {
-                    Logger.log(LoggingBehaviors.CACHE, TAG,
+                    Logger.log(LoggingBehavior.CACHE, TAG,
                             "readHeader: stream.read returned -1 while reading header size");
                     return null;
                 }
@@ -291,7 +373,7 @@ static JSONObject readHeader(InputStream stream) throws IOException {
             while (count < headerBytes.length) {
                 int readCount = stream.read(headerBytes, count, headerBytes.length - count);
                 if (readCount < 1) {
-                    Logger.log(LoggingBehaviors.CACHE, TAG,
+                    Logger.log(LoggingBehavior.CACHE, TAG,
                             "readHeader: stream.read stopped at " + Integer.valueOf(count) + " when expected "
                                     + headerBytes.length);
                     return null;
@@ -305,7 +387,7 @@ static JSONObject readHeader(InputStream stream) throws IOException {
             try {
                 Object parsed = tokener.nextValue();
                 if (!(parsed instanceof JSONObject)) {
-                    Logger.log(LoggingBehaviors.CACHE, TAG, "readHeader: expected JSONObject, got " + parsed.getClass().getCanonicalName());
+                    Logger.log(LoggingBehavior.CACHE, TAG, "readHeader: expected JSONObject, got " + parsed.getClass().getCanonicalName());
                     return null;
                 }
                 header = (JSONObject) parsed;
@@ -442,11 +524,11 @@ public long skip(long byteCount) throws IOException {
         }
     }
 
-    static final class Limits {
+    public static final class Limits {
         private int byteCount;
         private int fileCount;
 
-        Limits() {
+        public Limits() {
             // A Samsung Galaxy Nexus can create 1k files in half a second.  By the time
             // it gets to 5k files it takes 5 seconds.  10k files took 15 seconds.  This
             // continues to slow down as files are added.  This assumes all files are in
diff --git a/facebook/src/com/facebook/Logger.java b/facebook/src/com/facebook/internal/Logger.java
similarity index 77%
rename from facebook/src/com/facebook/Logger.java
rename to facebook/src/com/facebook/internal/Logger.java
index 2aff1caf0..6a232c6c8 100644
--- a/facebook/src/com/facebook/Logger.java
+++ b/facebook/src/com/facebook/internal/Logger.java
@@ -14,17 +14,25 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.internal;
 
 import android.util.Log;
+import com.facebook.LoggingBehavior;
+import com.facebook.Settings;
 
 import java.util.HashMap;
 import java.util.Map;
 
-class Logger {
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public class Logger {
+    public static final String LOG_TAG_BASE = "FacebookSDK.";
     private static final HashMap<String, String> stringsToReplace = new HashMap<String, String>();
 
-    private final LoggingBehaviors behavior;
+    private final LoggingBehavior behavior;
     private final String tag;
     private StringBuilder contents;
     private int priority = Log.DEBUG;
@@ -36,27 +44,27 @@ public synchronized static void registerStringToReplace(String original, String
     }
 
     public synchronized static void registerAccessToken(String accessToken) {
-        if (Settings.isLoggingBehaviorEnabled(LoggingBehaviors.INCLUDE_ACCESS_TOKENS) == false) {
+        if (Settings.isLoggingBehaviorEnabled(LoggingBehavior.INCLUDE_ACCESS_TOKENS) == false) {
             registerStringToReplace(accessToken, "ACCESS_TOKEN_REMOVED");
         }
     }
 
-    public static void log(LoggingBehaviors behavior, String tag, String string) {
+    public static void log(LoggingBehavior behavior, String tag, String string) {
         log(behavior, Log.DEBUG, tag, string);
     }
 
-    public static void log(LoggingBehaviors behavior, String tag, String format, Object... args) {
+    public static void log(LoggingBehavior behavior, String tag, String format, Object... args) {
         if (Settings.isLoggingBehaviorEnabled(behavior)) {
             String string = String.format(format, args);
             log(behavior, Log.DEBUG, tag, string);
         }
     }
 
-    public static void log(LoggingBehaviors behavior, int priority, String tag, String string) {
+    public static void log(LoggingBehavior behavior, int priority, String tag, String string) {
         if (Settings.isLoggingBehaviorEnabled(behavior)) {
             string = replaceStrings(string);
-            if (tag.startsWith(Settings.LOG_TAG_BASE) == false) {
-                tag = Settings.LOG_TAG_BASE + tag;
+            if (tag.startsWith(LOG_TAG_BASE) == false) {
+                tag = LOG_TAG_BASE + tag;
             }
             Log.println(priority, tag, string);
         }
@@ -69,11 +77,11 @@ private synchronized static String replaceStrings(String string) {
         return string;
     }
 
-    public Logger(LoggingBehaviors behavior, String tag) {
+    public Logger(LoggingBehavior behavior, String tag) {
         Validate.notNullOrEmpty(tag, "tag");
 
         this.behavior = behavior;
-        this.tag = Settings.LOG_TAG_BASE + tag;
+        this.tag = LOG_TAG_BASE + tag;
         this.contents = new StringBuilder();
     }
 
diff --git a/facebook/src/com/facebook/internal/ServerProtocol.java b/facebook/src/com/facebook/internal/ServerProtocol.java
new file mode 100644
index 000000000..6cb65324d
--- /dev/null
+++ b/facebook/src/com/facebook/internal/ServerProtocol.java
@@ -0,0 +1,48 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import com.facebook.internal.Utility;
+
+import java.util.Collection;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public final class ServerProtocol {
+    static final String FACEBOOK_COM = "facebook.com";
+    public static final String DIALOG_AUTHORITY = "m." + FACEBOOK_COM;
+    public static final String DIALOG_PATH = "dialog/";
+    public static final String DIALOG_PARAM_SCOPE = "scope";
+    public static final String DIALOG_PARAM_CLIENT_ID = "client_id";
+    public static final String DIALOG_PARAM_DISPLAY = "display";
+    public static final String DIALOG_PARAM_REDIRECT_URI = "redirect_uri";
+    public static final String DIALOG_PARAM_TYPE = "type";
+
+    // URL components
+    public static final String GRAPH_URL = "https://graph." + FACEBOOK_COM;
+    public static final String GRAPH_URL_BASE = "https://graph." + FACEBOOK_COM + "/";
+    public static final String REST_URL_BASE = "https://api." + FACEBOOK_COM + "/method/";
+    public static final String BATCHED_REST_METHOD_URL_BASE = "method/";
+
+    public static final Collection<String> errorsProxyAuthDisabled =
+            Utility.unmodifiableCollection("service_disabled", "AndroidAuthKillSwitchException");
+    public static final Collection<String> errorsUserCanceled =
+            Utility.unmodifiableCollection("access_denied", "OAuthAccessDeniedException");
+}
diff --git a/facebook/src/com/facebook/internal/SessionAuthorizationType.java b/facebook/src/com/facebook/internal/SessionAuthorizationType.java
new file mode 100644
index 000000000..6684019a1
--- /dev/null
+++ b/facebook/src/com/facebook/internal/SessionAuthorizationType.java
@@ -0,0 +1,27 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public enum SessionAuthorizationType {
+    READ,
+    PUBLISH
+}
diff --git a/facebook/src/com/facebook/SessionTracker.java b/facebook/src/com/facebook/internal/SessionTracker.java
similarity index 90%
rename from facebook/src/com/facebook/SessionTracker.java
rename to facebook/src/com/facebook/internal/SessionTracker.java
index d22898644..e013de5c5 100644
--- a/facebook/src/com/facebook/SessionTracker.java
+++ b/facebook/src/com/facebook/internal/SessionTracker.java
@@ -14,19 +14,22 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.internal;
 
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.support.v4.content.LocalBroadcastManager;
+import com.facebook.Session;
+import com.facebook.SessionState;
 
 /**
- * A Session tracker that tracks either the active Session or the
- * passed in Session object. This class is not thread safe.
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
  */
-class SessionTracker {
+public class SessionTracker {
 
     private Session session;
     private final Session.StatusCallback callback;
@@ -41,7 +44,7 @@
      * @param callback the callback to use whenever the active Session's 
      *                 state changes
      */
-    SessionTracker(Context context, Session.StatusCallback callback) {
+    public SessionTracker(Context context, Session.StatusCallback callback) {
         this(context, callback, null);
     }
     
@@ -66,7 +69,7 @@
      * @param session the Session object to track
      * @param startTracking whether to start tracking the Session right away
      */
-    SessionTracker(Context context, Session.StatusCallback callback, Session session, boolean startTracking) {
+    public SessionTracker(Context context, Session.StatusCallback callback, Session session, boolean startTracking) {
         this.callback = new CallbackWrapper(callback);
         this.session = session;
         this.receiver = new ActiveSessionBroadcastReceiver();
@@ -82,7 +85,7 @@
      * 
      * @return the current Session associated with this tracker
      */
-    Session getSession() {
+    public Session getSession() {
         return (session == null) ? Session.getActiveSession() : session;
     }
 
@@ -92,7 +95,7 @@ Session getSession() {
      * 
      * @return the current Session if it's open, otherwise returns null
      */
-    Session getOpenSession() {
+    public Session getOpenSession() {
         Session openSession = getSession();
         if (openSession != null && openSession.isOpened()) {
             return openSession;
@@ -105,7 +108,7 @@ Session getOpenSession() {
      * 
      * @param newSession the new Session object to track
      */
-    void setSession(Session newSession) {
+    public void setSession(Session newSession) {
         if (newSession == null) {
             if (session != null) {
                 // We're current tracking a Session. Remove the callback
@@ -140,7 +143,7 @@ void setSession(Session newSession) {
     /**
      * Start tracking the Session (either active or the one given). 
      */
-    void startTracking() {
+    public void startTracking() {
         if (isTracking) {
             return;
         }
@@ -158,7 +161,7 @@ void startTracking() {
      * Stop tracking the Session and remove any callbacks attached
      * to those sessions.
      */
-    void stopTracking() {
+    public void stopTracking() {
         if (!isTracking) {
             return;
         }
@@ -175,7 +178,7 @@ void stopTracking() {
      * 
      * @return true if currently tracking the Session
      */
-    boolean isTracking() {
+    public boolean isTracking() {
         return isTracking;
     }
 
@@ -184,7 +187,7 @@ boolean isTracking() {
      *
      * @return true if the currently tracked session is the active Session.
      */
-    boolean isTrackingActiveSession() {
+    public boolean isTrackingActiveSession() {
         return session == null;
     }
     
diff --git a/facebook/src/com/facebook/Utility.java b/facebook/src/com/facebook/internal/Utility.java
similarity index 60%
rename from facebook/src/com/facebook/Utility.java
rename to facebook/src/com/facebook/internal/Utility.java
index c5583ae45..371e5d056 100644
--- a/facebook/src/com/facebook/Utility.java
+++ b/facebook/src/com/facebook/internal/Utility.java
@@ -14,18 +14,21 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.internal;
 
-import android.annotation.SuppressLint;
 import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
 import android.net.Uri;
 import android.os.Bundle;
 import android.os.Parcelable;
 import android.text.TextUtils;
-import android.view.View;
-import android.view.animation.AlphaAnimation;
+import android.util.Log;
 import android.webkit.CookieManager;
 import android.webkit.CookieSyncManager;
+import com.facebook.FacebookException;
+import com.facebook.Session;
+import com.facebook.android.BuildConfig;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -36,22 +39,25 @@
 import java.net.URLConnection;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
-import java.text.Collator;
 import java.util.*;
-import java.util.Map.Entry;
 
-final class Utility {
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public final class Utility {
     static final String LOG_TAG = "FacebookSDK";
     private static final String HASH_ALGORITHM_MD5 = "MD5";
-    private static final String URL_SCHEME = "http";
+    private static final String URL_SCHEME = "https";
 
     // This is the default used by the buffer streams, but they trace a warning if you do not specify.
-    static final int DEFAULT_STREAM_BUFFER_SIZE = 8192;
+    public static final int DEFAULT_STREAM_BUFFER_SIZE = 8192;
 
     // Returns true iff all items in subset are in superset, treating null and
     // empty collections as
     // the same.
-    static <T> boolean isSubset(Collection<T> subset, Collection<T> superset) {
+    public static <T> boolean isSubset(Collection<T> subset, Collection<T> superset) {
         if ((superset == null) || (superset.size() == 0)) {
             return ((subset == null) || (subset.size() == 0));
         }
@@ -65,19 +71,19 @@
         return true;
     }
 
-    static <T> boolean isNullOrEmpty(Collection<T> c) {
+    public static <T> boolean isNullOrEmpty(Collection<T> c) {
         return (c == null) || (c.size() == 0);
     }
 
-    static boolean isNullOrEmpty(String s) {
+    public static boolean isNullOrEmpty(String s) {
         return (s == null) || (s.length() == 0);
     }
 
-    static <T> Collection<T> unmodifiableCollection(T... ts) {
+    public static <T> Collection<T> unmodifiableCollection(T... ts) {
         return Collections.unmodifiableCollection(Arrays.asList(ts));
     }
 
-    static <T> ArrayList<T> arrayList(T... ts) {
+    public static <T> ArrayList<T> arrayList(T... ts) {
         ArrayList<T> arrayList = new ArrayList<T>(ts.length);
         for (T t : ts) {
             arrayList.add(t);
@@ -103,7 +109,7 @@ static String md5hash(String key) {
         return builder.toString();
     }
 
-    static Uri buildUri(String authority, String path, Bundle parameters) {
+    public static Uri buildUri(String authority, String path, Bundle parameters) {
         Uri.Builder builder = new Uri.Builder();
         builder.scheme(URL_SCHEME);
         builder.authority(authority);
@@ -117,7 +123,7 @@ static Uri buildUri(String authority, String path, Bundle parameters) {
         return builder.build();
     }
 
-    static void putObjectInBundle(Bundle bundle, String key, Object value) {
+    public static void putObjectInBundle(Bundle bundle, String key, Object value) {
         if (value instanceof String) {
             bundle.putString(key, (String) value);
         } else if (value instanceof Parcelable) {
@@ -129,7 +135,7 @@ static void putObjectInBundle(Bundle bundle, String key, Object value) {
         }
     }
 
-    static void closeQuietly(Closeable closeable) {
+    public static void closeQuietly(Closeable closeable) {
         try {
             if (closeable != null) {
                 closeable.close();
@@ -139,118 +145,24 @@ static void closeQuietly(Closeable closeable) {
         }
     }
 
-    static void disconnectQuietly(HttpURLConnection connection) {
-        if (connection != null) {
-            connection.disconnect();
-        }
-    }
-
-    static void disconnectQuietly(URLConnection connection) {
+    public static void disconnectQuietly(URLConnection connection) {
         if (connection instanceof HttpURLConnection) {
             ((HttpURLConnection)connection).disconnect();
         }
     }
 
-    static String convertCamelCaseToLowercaseWithUnderscores(String string) {
-        string = string.replaceAll("([a-z])([A-Z])", "$1_$2");
-        return string.toLowerCase();
-    }
-
-    static void jsonObjectClear(JSONObject jsonObject) {
-        @SuppressWarnings("unchecked")
-        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
-        while (keys.hasNext()) {
-            keys.next();
-            keys.remove();
-        }
-    }
-
-    static boolean jsonObjectContainsValue(JSONObject jsonObject, Object value) {
-        @SuppressWarnings("unchecked")
-        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
-        while (keys.hasNext()) {
-            Object thisValue = jsonObject.opt(keys.next());
-            if (thisValue != null && thisValue.equals(value)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private final static class JSONObjectEntry implements Entry<String, Object> {
-        private final String key;
-        private final Object value;
-
-        JSONObjectEntry(String key, Object value) {
-            this.key = key;
-            this.value = value;
-        }
-
-        @SuppressLint("FieldGetter")
-        @Override
-        public String getKey() {
-            return this.key;
-        }
-
-        @Override
-        public Object getValue() {
-            return this.value;
-        }
-
-        @Override
-        public Object setValue(Object object) {
-            throw new UnsupportedOperationException("JSONObjectEntry is immutable");
-        }
-
-    }
-
-    static Set<Entry<String, Object>> jsonObjectEntrySet(JSONObject jsonObject) {
-        HashSet<Entry<String, Object>> result = new HashSet<Entry<String, Object>>();
-
-        @SuppressWarnings("unchecked")
-        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
-        while (keys.hasNext()) {
-            String key = keys.next();
-            Object value = jsonObject.opt(key);
-            result.add(new JSONObjectEntry(key, value));
-        }
-
-        return result;
-    }
-
-    static Set<String> jsonObjectKeySet(JSONObject jsonObject) {
-        HashSet<String> result = new HashSet<String>();
-
-        @SuppressWarnings("unchecked")
-        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
-        while (keys.hasNext()) {
-            result.add(keys.next());
-        }
-
-        return result;
-    }
-
-    static void jsonObjectPutAll(JSONObject jsonObject, Map<String, Object> map) {
-        Set<Entry<String, Object>> entrySet = map.entrySet();
-        for (Entry<String, Object> entry : entrySet) {
-            try {
-                jsonObject.putOpt(entry.getKey(), entry.getValue());
-            } catch (JSONException e) {
-                throw new IllegalArgumentException(e);
+    public static String getMetadataApplicationId(Context context) {
+        try {
+            ApplicationInfo ai = context.getPackageManager().getApplicationInfo(
+                    context.getPackageName(), PackageManager.GET_META_DATA);
+            if (ai.metaData != null) {
+                return ai.metaData.getString(Session.APPLICATION_ID_PROPERTY);
             }
+        } catch (PackageManager.NameNotFoundException e) {
+            // if we can't find it in the manifest, just return null
         }
-    }
-
-    static Collection<Object> jsonObjectValues(JSONObject jsonObject) {
-        ArrayList<Object> result = new ArrayList<Object>();
 
-        @SuppressWarnings("unchecked")
-        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
-        while (keys.hasNext()) {
-            result.add(jsonObject.opt(keys.next()));
-        }
-
-        return result;
+        return null;
     }
 
     static Map<String, Object> convertJSONObjectToHashMap(JSONObject jsonObject) {
@@ -272,7 +184,7 @@ static void jsonObjectPutAll(JSONObject jsonObject, Map<String, Object> map) {
     }
 
     // Returns either a JSONObject or JSONArray representation of the 'key' property of 'jsonObject'.
-    static Object getStringPropertyAsJSON(JSONObject jsonObject, String key, String nonJSONPropertyKey)
+    public static Object getStringPropertyAsJSON(JSONObject jsonObject, String key, String nonJSONPropertyKey)
             throws JSONException {
         Object value = jsonObject.opt(key);
         if (value != null && value instanceof String) {
@@ -299,7 +211,7 @@ static Object getStringPropertyAsJSON(JSONObject jsonObject, String key, String
 
     }
 
-    static String readStreamToString(InputStream inputStream) throws IOException {
+    public static String readStreamToString(InputStream inputStream) throws IOException {
         BufferedInputStream bufferedInputStream = null;
         InputStreamReader reader = null;
         try {
@@ -321,33 +233,7 @@ static String readStreamToString(InputStream inputStream) throws IOException {
         }
     }
 
-    static int compareGraphObjects(GraphObject a, GraphObject b, Collection<String> sortFields,
-            Collator collator) {
-        for (String sortField : sortFields) {
-            String sa = (String) a.getProperty(sortField);
-            String sb = (String) b.getProperty(sortField);
-
-            if (sa != null && sb != null) {
-                int result = collator.compare(sa, sb);
-                if (result != 0) {
-                    return result;
-                }
-            } else if (!(sa == null && sb == null)) {
-                return (sa == null) ? -1 : 1;
-            }
-        }
-        return 0;
-    }
-
-    static void setAlpha(View view, float alpha) {
-        // Set the alpha appropriately (setAlpha is API >= 11, this technique works on all API levels).
-        AlphaAnimation alphaAnimation = new AlphaAnimation(alpha, alpha);
-        alphaAnimation.setDuration(0);
-        alphaAnimation.setFillAfter(true);
-        view.startAnimation(alphaAnimation);
-    }
-
-    static boolean stringsEqualOrEmpty(String a, String b) {
+    public static boolean stringsEqualOrEmpty(String a, String b) {
         boolean aEmpty = TextUtils.isEmpty(a);
         boolean bEmpty = TextUtils.isEmpty(b);
 
@@ -395,4 +281,10 @@ public static void clearFacebookCookies(Context context) {
         clearCookiesForDomain(context, "https://facebook.com");
         clearCookiesForDomain(context, "https://.facebook.com");
     }
+
+    public static void logd(String tag, String msg) {
+        if (BuildConfig.DEBUG) {
+            Log.d(tag, msg);
+        }
+    }
 }
diff --git a/facebook/src/com/facebook/internal/Validate.java b/facebook/src/com/facebook/internal/Validate.java
new file mode 100644
index 000000000..c66dee731
--- /dev/null
+++ b/facebook/src/com/facebook/internal/Validate.java
@@ -0,0 +1,73 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import java.util.Collection;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public final class Validate {
+    public static void notNull(Object arg, String name) {
+        if (arg == null) {
+            throw new NullPointerException("Argument " + name + " cannot be null");
+        }
+    }
+
+    public static <T> void notEmpty(Collection<T> container, String name) {
+        if (container.isEmpty()) {
+            throw new IllegalArgumentException("Container '" + name + "' cannot be empty");
+        }
+    }
+
+    public static <T> void containsNoNulls(Collection<T> container, String name) {
+        Validate.notNull(container, name);
+        for (T item : container) {
+            if (item == null) {
+                throw new NullPointerException("Container '" + name + "' cannot contain null values");
+            }
+        }
+    }
+
+    public static <T> void notEmptyAndContainsNoNulls(Collection<T> container, String name) {
+        Validate.containsNoNulls(container, name);
+        Validate.notEmpty(container, name);
+    }
+
+    public static void notNullOrEmpty(String arg, String name) {
+        if (Utility.isNullOrEmpty(arg)) {
+            throw new IllegalArgumentException("Argument " + name + " cannot be null or empty");
+        }
+    }
+
+    public static void oneOf(Object arg, String name, Object... values) {
+        for (Object value : values) {
+            if (value != null) {
+                if (value.equals(arg)) {
+                    return;
+                }
+            } else {
+                if (arg == null) {
+                    return;
+                }
+            }
+        }
+        throw new IllegalArgumentException("Argument " + name + " was not one of the allowed values");
+    }
+}
diff --git a/facebook/src/com/facebook/internal/package-info.java b/facebook/src/com/facebook/internal/package-info.java
new file mode 100644
index 000000000..4392d0f35
--- /dev/null
+++ b/facebook/src/com/facebook/internal/package-info.java
@@ -0,0 +1,6 @@
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+package com.facebook.internal;
\ No newline at end of file
diff --git a/facebook/src/com/facebook/GraphLocation.java b/facebook/src/com/facebook/model/GraphLocation.java
similarity index 98%
rename from facebook/src/com/facebook/GraphLocation.java
rename to facebook/src/com/facebook/model/GraphLocation.java
index 93dbcef63..7fec04b96 100644
--- a/facebook/src/com/facebook/GraphLocation.java
+++ b/facebook/src/com/facebook/model/GraphLocation.java
@@ -1,5 +1,5 @@
 /**
- * Copyright 2010 Facebook, Inc.
+ * Copyright 2012 Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,12 +14,12 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.model;
 
 /**
  * Provides a strongly-typed representation of a Location as defined by the Graph API.
  *
- * Note that this interface is intended to be used with GraphObjectWrapper
+ * Note that this interface is intended to be used with GraphObject.Factory
  * and not implemented directly.
  */
 public interface GraphLocation extends GraphObject {
diff --git a/facebook/src/com/facebook/GraphMultiResult.java b/facebook/src/com/facebook/model/GraphMultiResult.java
similarity index 93%
rename from facebook/src/com/facebook/GraphMultiResult.java
rename to facebook/src/com/facebook/model/GraphMultiResult.java
index 0332f6648..f5d65569f 100644
--- a/facebook/src/com/facebook/GraphMultiResult.java
+++ b/facebook/src/com/facebook/model/GraphMultiResult.java
@@ -1,5 +1,5 @@
 /**
- * Copyright 2010 Facebook, Inc.
+ * Copyright 2012 Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.model;
 
 /**
  * Defines a GraphObject that represents the result of a query that returns multiple GraphObjects
  * nested under a "data" property.
  *
- * Note that this interface is intended to be used with GraphObjectWrapper
+ * Note that this interface is intended to be used with GraphObject.Factory
  * and not implemented directly.
  */
 public interface GraphMultiResult extends GraphObject {
diff --git a/facebook/src/com/facebook/model/GraphObject.java b/facebook/src/com/facebook/model/GraphObject.java
new file mode 100644
index 000000000..9b78f062a
--- /dev/null
+++ b/facebook/src/com/facebook/model/GraphObject.java
@@ -0,0 +1,745 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.model;
+
+import com.facebook.FacebookGraphObjectException;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.lang.reflect.*;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.*;
+
+/**
+ * GraphObject is the primary interface used by the Facebook SDK for Android to represent objects in the Facebook
+ * Social Graph and the Facebook Open Graph (OG). It is the base interface for all typed access to graph objects
+ * in the SDK. No concrete classes implement GraphObject or its derived interfaces. Rather, they are implemented as
+ * proxies (see the {@link com.facebook.model.GraphObject.Factory Factory} class) that provide strongly-typed property
+ * getters and setters to access the underlying data. Since the primary use case for graph objects is sending and
+ * receiving them over the wire to/from Facebook services, they are represented as JSONObjects. No validation is done
+ * that a graph object is actually of a specific type -- any graph object can be treated as any GraphObject-derived
+ * interface, and the presence or absence of specific properties determines its suitability for use as that
+ * particular type of object.
+ * <br/>
+ */
+public interface GraphObject {
+    /**
+     * Returns a new proxy that treats this graph object as a different GraphObject-derived type.
+     * @param graphObjectClass the type of GraphObject to return
+     * @return a new instance of the GraphObject-derived-type that references the same underlying data
+     */
+    public <T extends GraphObject> T cast(Class<T> graphObjectClass);
+
+    /**
+     * Returns a Java Collections map of names and properties.  Modifying the returned map modifies the
+     * inner JSON representation.
+     * @return a Java Collections map representing the GraphObject state
+     */
+    public Map<String, Object> asMap();
+
+    /**
+     * Gets the underlying JSONObject representation of this graph object.
+     * @return the underlying JSONObject representation of this graph object
+     */
+    public JSONObject getInnerJSONObject();
+
+    /**
+     * Gets a property of the GraphObject
+     * @param propertyName the name of the property to get
+     * @return the value of the named property
+     */
+    public Object getProperty(String propertyName);
+
+    /**
+     * Sets a property of the GraphObject
+     * @param propertyName the name of the property to set
+     * @param propertyValue the value of the named property to set
+     */
+    public void setProperty(String propertyName, Object propertyValue);
+
+    /**
+     * Removes a property of the GraphObject
+     * @param propertyName the name of the property to remove
+     */
+    public void removeProperty(String propertyName);
+
+    /**
+     * Creates proxies that implement GraphObject, GraphObjectList, and their derived types. These proxies allow access
+     * to underlying collections and name/value property bags via strongly-typed property getters and setters.
+     * <p/>
+     * This supports get/set properties that use primitive types, JSON types, Date, other GraphObject types, Iterable,
+     * Collection, List, and GraphObjectList.
+     */
+    final class Factory {
+        private static final HashSet<Class<?>> verifiedGraphObjectClasses = new HashSet<Class<?>>();
+        private static final SimpleDateFormat[] dateFormats = new SimpleDateFormat[] {
+                new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.US),
+                new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.US), new SimpleDateFormat("yyyy-MM-dd", Locale.US), };
+
+        // No objects of this type should exist.
+        private Factory() {
+        }
+
+        /**
+         * Creates a GraphObject proxy that provides typed access to the data in an underlying JSONObject.
+         * @param json the JSONObject containing the data to be exposed
+         * @return a GraphObject that represents the underlying data
+         *
+         * @throws com.facebook.FacebookException
+         *            If the passed in Class is not a valid GraphObject interface
+         */
+        public static GraphObject create(JSONObject json) {
+            return create(json, GraphObject.class);
+        }
+
+        /**
+         * Creates a GraphObject-derived proxy that provides typed access to the data in an underlying JSONObject.
+         * @param json the JSONObject containing the data to be exposed
+         * @param graphObjectClass the GraphObject-derived type to return
+         * @return a graphObjectClass that represents the underlying data
+         *
+         * @throws com.facebook.FacebookException
+         *            If the passed in Class is not a valid GraphObject interface
+         */
+        public static <T extends GraphObject> T create(JSONObject json, Class<T> graphObjectClass) {
+            return createGraphObjectProxy(graphObjectClass, json);
+        }
+
+        /**
+         * Creates a GraphObject proxy that initially contains no data.
+         * @return a GraphObject with no data
+         *
+         * @throws com.facebook.FacebookException
+         *            If the passed in Class is not a valid GraphObject interface
+         */
+        public static GraphObject create() {
+            return create(GraphObject.class);
+        }
+
+        /**
+         * Creates a GraphObject-derived proxy that initially contains no data.
+         * @param graphObjectClass the GraphObject-derived type to return
+         * @return a graphObjectClass with no data
+         *
+         * @throws com.facebook.FacebookException
+         *            If the passed in Class is not a valid GraphObject interface
+         */
+        public static <T extends GraphObject> T create(Class<T> graphObjectClass) {
+            return createGraphObjectProxy(graphObjectClass, new JSONObject());
+        }
+
+        /**
+         * Determines if two GraphObjects represent the same underlying graph object, based on their IDs.
+         * @param a a graph object
+         * @param b another graph object
+         * @return true if both graph objects have an ID and it is the same ID, false otherwise
+         */
+        public static boolean hasSameId(GraphObject a, GraphObject b) {
+            if (a == null || b == null || !a.asMap().containsKey("id") || !b.asMap().containsKey("id")) {
+                return false;
+            }
+            if (a.equals(b)) {
+                return true;
+            }
+            Object idA = a.getProperty("id");
+            Object idB = b.getProperty("id");
+            if (idA == null || idB == null || !(idA instanceof String) || !(idB instanceof String)) {
+                return false;
+            }
+            return idA.equals(idB);
+        }
+
+        /**
+         * Creates a GraphObjectList-derived proxy that provides typed access to the data in an underlying JSONArray.
+         * @param array the JSONArray containing the data to be exposed
+         * @param graphObjectClass the GraphObject-derived type to return
+         * @return a graphObjectClass that represents the underlying data
+         *
+         * @throws com.facebook.FacebookException
+         *            If the passed in Class is not a valid GraphObject interface
+         */
+        public static <T> GraphObjectList<T> createList(JSONArray array, Class<T> graphObjectClass) {
+            return new GraphObjectListImpl<T>(array, graphObjectClass);
+        }
+
+        /**
+         * Creates a GraphObjectList-derived proxy that initially contains no data.
+         * @param graphObjectClass the GraphObject-derived type to return
+         * @return a GraphObjectList with no data
+         *
+         * @throws com.facebook.FacebookException
+         *            If the passed in Class is not a valid GraphObject interface
+         */
+        public static <T> GraphObjectList<T> createList(Class<T> graphObjectClass) {
+            return createList(new JSONArray(), graphObjectClass);
+        }
+
+        private static <T extends GraphObject> T createGraphObjectProxy(Class<T> graphObjectClass, JSONObject state) {
+            verifyCanProxyClass(graphObjectClass);
+
+            Class<?>[] interfaces = new Class[] { graphObjectClass };
+            GraphObjectProxy graphObjectProxy = new GraphObjectProxy(state, graphObjectClass);
+
+            @SuppressWarnings("unchecked")
+            T graphObject = (T) Proxy.newProxyInstance(GraphObject.class.getClassLoader(), interfaces, graphObjectProxy);
+
+            return graphObject;
+        }
+
+        private static Map<String, Object> createGraphObjectProxyForMap(JSONObject state) {
+            Class<?>[] interfaces = new Class[]{Map.class};
+            GraphObjectProxy graphObjectProxy = new GraphObjectProxy(state, Map.class);
+
+            @SuppressWarnings("unchecked")
+            Map<String, Object> graphObject = (Map<String, Object>) Proxy
+                    .newProxyInstance(GraphObject.class.getClassLoader(), interfaces, graphObjectProxy);
+
+            return graphObject;
+        }
+
+        private static synchronized <T extends GraphObject> boolean hasClassBeenVerified(Class<T> graphObjectClass) {
+            return verifiedGraphObjectClasses.contains(graphObjectClass);
+        }
+
+        private static synchronized <T extends GraphObject> void recordClassHasBeenVerified(Class<T> graphObjectClass) {
+            verifiedGraphObjectClasses.add(graphObjectClass);
+        }
+
+        private static <T extends GraphObject> void verifyCanProxyClass(Class<T> graphObjectClass) {
+            if (hasClassBeenVerified(graphObjectClass)) {
+                return;
+            }
+
+            if (!graphObjectClass.isInterface()) {
+                throw new FacebookGraphObjectException("Factory can only wrap interfaces, not class: "
+                        + graphObjectClass.getName());
+            }
+
+            Method[] methods = graphObjectClass.getMethods();
+            for (Method method : methods) {
+                String methodName = method.getName();
+                int parameterCount = method.getParameterTypes().length;
+                Class<?> returnType = method.getReturnType();
+                boolean hasPropertyNameOverride = method.isAnnotationPresent(PropertyName.class);
+
+                if (method.getDeclaringClass().isAssignableFrom(GraphObject.class)) {
+                    // Don't worry about any methods from GraphObject or one of its base classes.
+                    continue;
+                } else if (parameterCount == 1 && returnType == Void.TYPE) {
+                    if (hasPropertyNameOverride) {
+                        // If a property override is present, it MUST be valid. We don't fallback
+                        // to using the method name
+                        if (!Utility.isNullOrEmpty(method.getAnnotation(PropertyName.class).value())) {
+                            continue;
+                        }
+                    } else if (methodName.startsWith("set") && methodName.length() > 3) {
+                        // Looks like a valid setter
+                        continue;
+                    }
+                } else if (parameterCount == 0 && returnType != Void.TYPE) {
+                    if (hasPropertyNameOverride) {
+                        // If a property override is present, it MUST be valid. We don't fallback
+                        // to using the method name
+                        if (!Utility.isNullOrEmpty(method.getAnnotation(PropertyName.class).value())) {
+                            continue;
+                        }
+                    } else if (methodName.startsWith("get") && methodName.length() > 3) {
+                        // Looks like a valid getter
+                        continue;
+                    }
+                }
+
+                throw new FacebookGraphObjectException("Factory can't proxy method: " + method.toString());
+            }
+
+            recordClassHasBeenVerified(graphObjectClass);
+        }
+
+        // If expectedType is a generic type, expectedTypeAsParameterizedType must be provided in order to determine
+        // generic parameter types.
+        static <U> U coerceValueToExpectedType(Object value, Class<U> expectedType,
+                ParameterizedType expectedTypeAsParameterizedType) {
+            if (value == null) {
+                return null;
+            }
+
+            Class<?> valueType = value.getClass();
+            if (expectedType.isAssignableFrom(valueType)) {
+                @SuppressWarnings("unchecked")
+                U result = (U) value;
+                return result;
+            }
+
+            if (expectedType.isPrimitive()) {
+                // If the result is a primitive, let the runtime succeed or fail at unboxing it.
+                @SuppressWarnings("unchecked")
+                U result = (U) value;
+                return result;
+            }
+
+            if (GraphObject.class.isAssignableFrom(expectedType)) {
+                @SuppressWarnings("unchecked")
+                Class<? extends GraphObject> graphObjectClass = (Class<? extends GraphObject>) expectedType;
+
+                // We need a GraphObject, but we don't have one.
+                if (JSONObject.class.isAssignableFrom(valueType)) {
+                    // We can wrap a JSONObject as a GraphObject.
+                    @SuppressWarnings("unchecked")
+                    U result = (U) createGraphObjectProxy(graphObjectClass, (JSONObject) value);
+                    return result;
+                } else if (GraphObject.class.isAssignableFrom(valueType)) {
+                    // We can cast a GraphObject-derived class to another GraphObject-derived class.
+                    @SuppressWarnings("unchecked")
+                    U result = (U) ((GraphObject) value).cast(graphObjectClass);
+                    return result;
+                } else {
+                    throw new FacebookGraphObjectException("Can't create GraphObject from " + valueType.getName());
+                }
+            } else if (Iterable.class.equals(expectedType) || Collection.class.equals(expectedType)
+                    || List.class.equals(expectedType) || GraphObjectList.class.equals(expectedType)) {
+                if (expectedTypeAsParameterizedType == null) {
+                    throw new FacebookGraphObjectException("can't infer generic type of: " + expectedType.toString());
+                }
+
+                Type[] actualTypeArguments = expectedTypeAsParameterizedType.getActualTypeArguments();
+
+                if (actualTypeArguments == null || actualTypeArguments.length != 1
+                        || !(actualTypeArguments[0] instanceof Class<?>)) {
+                    throw new FacebookGraphObjectException(
+                            "Expect collection properties to be of a type with exactly one generic parameter.");
+                }
+                Class<?> collectionGenericArgument = (Class<?>) actualTypeArguments[0];
+
+                if (JSONArray.class.isAssignableFrom(valueType)) {
+                    JSONArray jsonArray = (JSONArray) value;
+                    @SuppressWarnings("unchecked")
+                    U result = (U) createList(jsonArray, collectionGenericArgument);
+                    return result;
+                } else {
+                    throw new FacebookGraphObjectException("Can't create Collection from " + valueType.getName());
+                }
+            } else if (String.class.equals(expectedType)) {
+                if (Double.class.isAssignableFrom(valueType) ||
+                        Float.class.isAssignableFrom(valueType)) {
+                    @SuppressWarnings("unchecked")
+                    U result = (U) String.format("%f", value);
+                    return result;
+                } else if (Number.class.isAssignableFrom(valueType)) {
+                    @SuppressWarnings("unchecked")
+                    U result = (U) String.format("%d", value);
+                    return result;
+                }
+            } else if (Date.class.equals(expectedType)) {
+                if (String.class.isAssignableFrom(valueType)) {
+                    for (SimpleDateFormat format : dateFormats) {
+                        try {
+                            Date date = format.parse((String) value);
+                            if (date != null) {
+                                @SuppressWarnings("unchecked")
+                                U result = (U) date;
+                                return result;
+                            }
+                        } catch (ParseException e) {
+                            // Keep going.
+                        }
+                    }
+                }
+            }
+            throw new FacebookGraphObjectException("Can't convert type" + valueType.getName() + " to "
+                    + expectedType.getName());
+        }
+
+        static String convertCamelCaseToLowercaseWithUnderscores(String string) {
+            string = string.replaceAll("([a-z])([A-Z])", "$1_$2");
+            return string.toLowerCase(Locale.US);
+        }
+
+        private static Object getUnderlyingJSONObject(Object obj) {
+            Class<?> objClass = obj.getClass();
+            if (GraphObject.class.isAssignableFrom(objClass)) {
+                GraphObject graphObject = (GraphObject) obj;
+                return graphObject.getInnerJSONObject();
+            } else if (GraphObjectList.class.isAssignableFrom(objClass)) {
+                GraphObjectList<?> graphObjectList = (GraphObjectList<?>) obj;
+                return graphObjectList.getInnerJSONArray();
+            }
+            return obj;
+        }
+
+        private abstract static class ProxyBase<STATE> implements InvocationHandler {
+            // Pre-loaded Method objects for the methods in java.lang.Object
+            private static final String EQUALS_METHOD = "equals";
+            private static final String TOSTRING_METHOD = "toString";
+
+            protected final STATE state;
+
+            protected ProxyBase(STATE state) {
+                this.state = state;
+            }
+
+            // Declared to return Object just to simplify implementation of proxy helpers.
+            protected final Object throwUnexpectedMethodSignature(Method method) {
+                throw new FacebookGraphObjectException(getClass().getName() + " got an unexpected method signature: "
+                        + method.toString());
+            }
+
+            protected final Object proxyObjectMethods(Object proxy, Method method, Object[] args) throws Throwable {
+                String methodName = method.getName();
+                if (methodName.equals(EQUALS_METHOD)) {
+                    Object other = args[0];
+
+                    if (other == null) {
+                        return false;
+                    }
+
+                    InvocationHandler handler = Proxy.getInvocationHandler(other);
+                    if (!(handler instanceof GraphObjectProxy)) {
+                        return false;
+                    }
+                    GraphObjectProxy otherProxy = (GraphObjectProxy) handler;
+                    return this.state.equals(otherProxy.state);
+                } else if (methodName.equals(TOSTRING_METHOD)) {
+                    return toString();
+                }
+
+                // For others, just defer to the implementation object.
+                return method.invoke(this.state, args);
+            }
+
+        }
+
+        private final static class GraphObjectProxy extends ProxyBase<JSONObject> {
+            private static final String CLEAR_METHOD = "clear";
+            private static final String CONTAINSKEY_METHOD = "containsKey";
+            private static final String CONTAINSVALUE_METHOD = "containsValue";
+            private static final String ENTRYSET_METHOD = "entrySet";
+            private static final String GET_METHOD = "get";
+            private static final String ISEMPTY_METHOD = "isEmpty";
+            private static final String KEYSET_METHOD = "keySet";
+            private static final String PUT_METHOD = "put";
+            private static final String PUTALL_METHOD = "putAll";
+            private static final String REMOVE_METHOD = "remove";
+            private static final String SIZE_METHOD = "size";
+            private static final String VALUES_METHOD = "values";
+            private static final String CAST_METHOD = "cast";
+            private static final String CASTTOMAP_METHOD = "asMap";
+            private static final String GETPROPERTY_METHOD = "getProperty";
+            private static final String SETPROPERTY_METHOD = "setProperty";
+            private static final String REMOVEPROPERTY_METHOD = "removeProperty";
+            private static final String GETINNERJSONOBJECT_METHOD = "getInnerJSONObject";
+
+            private final Class<?> graphObjectClass;
+
+            public GraphObjectProxy(JSONObject state, Class<?> graphObjectClass) {
+                super(state);
+                this.graphObjectClass = graphObjectClass;
+            }
+
+            @Override
+            public String toString() {
+                return String.format("GraphObject{graphObjectClass=%s, state=%s}", graphObjectClass.getSimpleName(), state);
+            }
+
+            @Override
+            public final Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+                Class<?> declaringClass = method.getDeclaringClass();
+
+                if (declaringClass == Object.class) {
+                    return proxyObjectMethods(proxy, method, args);
+                } else if (declaringClass == Map.class) {
+                    return proxyMapMethods(method, args);
+                } else if (declaringClass == GraphObject.class) {
+                    return proxyGraphObjectMethods(proxy, method, args);
+                } else if (GraphObject.class.isAssignableFrom(declaringClass)) {
+                    return proxyGraphObjectGettersAndSetters(method, args);
+                }
+
+                return throwUnexpectedMethodSignature(method);
+            }
+
+            private final Object proxyMapMethods(Method method, Object[] args) {
+                String methodName = method.getName();
+                if (methodName.equals(CLEAR_METHOD)) {
+                    JsonUtil.jsonObjectClear(this.state);
+                    return null;
+                } else if (methodName.equals(CONTAINSKEY_METHOD)) {
+                    return this.state.has((String) args[0]);
+                } else if (methodName.equals(CONTAINSVALUE_METHOD)) {
+                    return JsonUtil.jsonObjectContainsValue(this.state, args[0]);
+                } else if (methodName.equals(ENTRYSET_METHOD)) {
+                    return JsonUtil.jsonObjectEntrySet(this.state);
+                } else if (methodName.equals(GET_METHOD)) {
+                    return this.state.opt((String) args[0]);
+                } else if (methodName.equals(ISEMPTY_METHOD)) {
+                    return this.state.length() == 0;
+                } else if (methodName.equals(KEYSET_METHOD)) {
+                    return JsonUtil.jsonObjectKeySet(this.state);
+                } else if (methodName.equals(PUT_METHOD)) {
+                    return setJSONProperty(args);
+                } else if (methodName.equals(PUTALL_METHOD)) {
+                    Map<String, Object> map = null;
+                    if (args[0] instanceof Map<?, ?>) {
+                        @SuppressWarnings("unchecked")
+                        Map<String, Object> castMap = (Map<String, Object>) args[0];
+                        map = castMap;
+                    } else if (args[0] instanceof GraphObject) {
+                        map = ((GraphObject) args[0]).asMap();
+                    }
+                    JsonUtil.jsonObjectPutAll(this.state, map);
+                    return null;
+                } else if (methodName.equals(REMOVE_METHOD)) {
+                    this.state.remove((String) args[0]);
+                    return null;
+                } else if (methodName.equals(SIZE_METHOD)) {
+                    return this.state.length();
+                } else if (methodName.equals(VALUES_METHOD)) {
+                    return JsonUtil.jsonObjectValues(this.state);
+                }
+
+                return throwUnexpectedMethodSignature(method);
+            }
+
+            private final Object proxyGraphObjectMethods(Object proxy, Method method, Object[] args) {
+                String methodName = method.getName();
+                if (methodName.equals(CAST_METHOD)) {
+                    @SuppressWarnings("unchecked")
+                    Class<? extends GraphObject> graphObjectClass = (Class<? extends GraphObject>) args[0];
+
+                    if (graphObjectClass != null &&
+                            graphObjectClass.isAssignableFrom(this.graphObjectClass)) {
+                        return proxy;
+                    }
+                    return Factory.createGraphObjectProxy(graphObjectClass, this.state);
+                } else if (methodName.equals(GETINNERJSONOBJECT_METHOD)) {
+                    InvocationHandler handler = Proxy.getInvocationHandler(proxy);
+                    GraphObjectProxy otherProxy = (GraphObjectProxy) handler;
+                    return otherProxy.state;
+                } else if (methodName.equals(CASTTOMAP_METHOD)) {
+                    return Factory.createGraphObjectProxyForMap(this.state);
+                } else if (methodName.equals(GETPROPERTY_METHOD)) {
+                    return state.opt((String) args[0]);
+                } else if (methodName.equals(SETPROPERTY_METHOD)) {
+                    return setJSONProperty(args);
+                } else if (methodName.equals(REMOVEPROPERTY_METHOD)) {
+                    this.state.remove((String) args[0]);
+                    return null;
+                }
+
+                return throwUnexpectedMethodSignature(method);
+            }
+
+            private final Object proxyGraphObjectGettersAndSetters(Method method, Object[] args) throws JSONException {
+                String methodName = method.getName();
+                int parameterCount = method.getParameterTypes().length;
+                PropertyName propertyNameOverride = method.getAnnotation(PropertyName.class);
+
+                String key = propertyNameOverride != null ? propertyNameOverride.value() :
+                        convertCamelCaseToLowercaseWithUnderscores(methodName.substring(3));
+
+                // If it's a get or a set on a GraphObject-derived class, we can handle it.
+                if (parameterCount == 0) {
+                    // Has to be a getter. ASSUMPTION: The GraphObject-derived class has been verified
+                    Object value = this.state.opt(key);
+
+                    Class<?> expectedType = method.getReturnType();
+
+                    Type genericReturnType = method.getGenericReturnType();
+                    ParameterizedType parameterizedReturnType = null;
+                    if (genericReturnType instanceof ParameterizedType) {
+                        parameterizedReturnType = (ParameterizedType) genericReturnType;
+                    }
+
+                    value = coerceValueToExpectedType(value, expectedType, parameterizedReturnType);
+
+                    return value;
+                } else if (parameterCount == 1) {
+                    // Has to be a setter. ASSUMPTION: The GraphObject-derived class has been verified
+                    Object value = args[0];
+                    // If this is a wrapped object, store the underlying JSONObject instead, in order to serialize
+                    // correctly.
+                    if (GraphObject.class.isAssignableFrom(value.getClass())) {
+                        value = ((GraphObject) value).getInnerJSONObject();
+                    } else if (GraphObjectList.class.isAssignableFrom(value.getClass())) {
+                        value = ((GraphObjectList<?>) value).getInnerJSONArray();
+                    } else if (Iterable.class.isAssignableFrom(value.getClass())) {
+                        JSONArray jsonArray = new JSONArray();
+                        Iterable<?> iterable = (Iterable<?>) value;
+                        for (Object o : iterable ) {
+                            if (GraphObject.class.isAssignableFrom(o.getClass())) {
+                                jsonArray.put(((GraphObject)o).getInnerJSONObject());
+                            } else {
+                                jsonArray.put(o);
+                            }
+                        }
+                        value = jsonArray;
+                    }
+                    this.state.putOpt(key, value);
+                    return null;
+                }
+
+                return throwUnexpectedMethodSignature(method);
+            }
+
+            private Object setJSONProperty(Object[] args) {
+                String name = (String) args[0];
+                Object property = args[1];
+                Object value = getUnderlyingJSONObject(property);
+                try {
+                    state.putOpt(name, value);
+                } catch (JSONException e) {
+                    throw new IllegalArgumentException(e);
+                }
+                return null;
+            }
+        }
+
+        private final static class GraphObjectListImpl<T> extends AbstractList<T> implements GraphObjectList<T> {
+            private final JSONArray state;
+            private final Class<?> itemType;
+
+            public GraphObjectListImpl(JSONArray state, Class<?> itemType) {
+                Validate.notNull(state, "state");
+                Validate.notNull(itemType, "itemType");
+
+                this.state = state;
+                this.itemType = itemType;
+            }
+
+            @Override
+            public String toString() {
+                return String.format("GraphObjectList{itemType=%s, state=%s}", itemType.getSimpleName(), state);
+            }
+
+            @Override
+            public void add(int location, T object) {
+                // We only support adding at the end of the list, due to JSONArray restrictions.
+                if (location < 0) {
+                    throw new IndexOutOfBoundsException();
+                } else if (location < size()) {
+                    throw new UnsupportedOperationException("Only adding items at the end of the list is supported.");
+                }
+
+                put(location, object);
+            }
+
+            @Override
+            public T set(int location, T object) {
+                checkIndex(location);
+
+                T result = get(location);
+                put(location, object);
+                return result;
+            }
+
+            @Override
+            public int hashCode() {
+                return state.hashCode();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (this == obj)
+                    return true;
+                if (getClass() != obj.getClass()) {
+                    return false;
+                }
+                @SuppressWarnings("unchecked")
+                GraphObjectListImpl<T> other = (GraphObjectListImpl<T>) obj;
+                return state.equals(other.state);
+            }
+
+            @SuppressWarnings("unchecked")
+            @Override
+            public T get(int location) {
+                checkIndex(location);
+
+                Object value = state.opt(location);
+
+                // Class<?> expectedType = method.getReturnType();
+                // Type genericType = method.getGenericReturnType();
+                T result = (T) coerceValueToExpectedType(value, itemType, null);
+
+                return result;
+            }
+
+            @Override
+            public int size() {
+                return state.length();
+            }
+
+            @Override
+            public final <U extends GraphObject> GraphObjectList<U> castToListOf(Class<U> graphObjectClass) {
+                if (GraphObject.class.isAssignableFrom(itemType)) {
+                    if (graphObjectClass.isAssignableFrom(itemType)) {
+                        @SuppressWarnings("unchecked")
+                        GraphObjectList<U> result = (GraphObjectList<U>)this;
+                        return result;
+                    }
+
+                    return createList(state, graphObjectClass);
+                } else {
+                    throw new FacebookGraphObjectException("Can't cast GraphObjectCollection of non-GraphObject type "
+                            + itemType);
+                }
+            }
+
+            @Override
+            public final JSONArray getInnerJSONArray() {
+                return state;
+            }
+
+            @Override
+            public void clear() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean remove(Object o) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean removeAll(Collection<?> c) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean retainAll(Collection<?> c) {
+                throw new UnsupportedOperationException();
+            }
+
+            private void checkIndex(int index) {
+                if (index < 0 || index >= state.length()) {
+                    throw new IndexOutOfBoundsException();
+                }
+            }
+
+            private void put(int index, T obj) {
+                Object underlyingObject = getUnderlyingJSONObject(obj);
+                try {
+                    state.put(index, underlyingObject);
+                } catch (JSONException e) {
+                    throw new IllegalArgumentException(e);
+                }
+            }
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/GraphObjectList.java b/facebook/src/com/facebook/model/GraphObjectList.java
similarity index 88%
rename from facebook/src/com/facebook/GraphObjectList.java
rename to facebook/src/com/facebook/model/GraphObjectList.java
index 34e9dc231..311e0dcd9 100644
--- a/facebook/src/com/facebook/GraphObjectList.java
+++ b/facebook/src/com/facebook/model/GraphObjectList.java
@@ -1,5 +1,5 @@
 /**
- * Copyright 2010 Facebook, Inc.
+ * Copyright 2012 Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.model;
 
 import org.json.JSONArray;
 
@@ -22,7 +22,7 @@
 
 /**
  * GraphObjectList is the primary representation of a collection of graph objects in the Facebook SDK for Android.
- * It is not implemented by any concrete classes, but rather by a proxy (see the {@link GraphObjectWrapper GraphObjectWrapper}
+ * It is not implemented by any concrete classes, but rather by a proxy (see the {@link com.facebook.model.GraphObject.Factory Factory}
  * class). A GraphObjectList can actually contain elements of any type, not just graph objects, but its principal
  * use in the SDK is to contain types derived from GraphObject.
  * <br/>
@@ -36,7 +36,7 @@
      * GraphObject-derived type.
      * @param graphObjectClass the GraphObject-derived type to return a list of
      * @return a list representing the same underlying data, exposed as the new GraphObject-derived type
-     * @throws FacebookGraphObjectException if T does not derive from GraphObject
+     * @throws com.facebook.FacebookGraphObjectException if T does not derive from GraphObject
      */
     public <U extends GraphObject> GraphObjectList<U> castToListOf(Class<U> graphObjectClass);
     /**
diff --git a/facebook/src/com/facebook/GraphPlace.java b/facebook/src/com/facebook/model/GraphPlace.java
similarity index 96%
rename from facebook/src/com/facebook/GraphPlace.java
rename to facebook/src/com/facebook/model/GraphPlace.java
index 14aa43640..c4ef6889d 100644
--- a/facebook/src/com/facebook/GraphPlace.java
+++ b/facebook/src/com/facebook/model/GraphPlace.java
@@ -1,5 +1,5 @@
 /**
- * Copyright 2010 Facebook, Inc.
+ * Copyright 2012 Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,12 +14,12 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.model;
 
 /**
  * Provides a strongly-typed representation of a Place as defined by the Graph API.
  *
- * Note that this interface is intended to be used with GraphObjectWrapper
+ * Note that this interface is intended to be used with GraphObject.Factory
  * and not implemented directly.
  */
 public interface GraphPlace extends GraphObject {
diff --git a/facebook/src/com/facebook/GraphUser.java b/facebook/src/com/facebook/model/GraphUser.java
similarity index 98%
rename from facebook/src/com/facebook/GraphUser.java
rename to facebook/src/com/facebook/model/GraphUser.java
index 6b6eec6b7..cc684d3ae 100644
--- a/facebook/src/com/facebook/GraphUser.java
+++ b/facebook/src/com/facebook/model/GraphUser.java
@@ -1,5 +1,5 @@
 /**
- * Copyright 2010 Facebook, Inc.
+ * Copyright 2012 Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,12 +14,12 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.model;
 
 /**
  * Provides a strongly-typed representation of a User as defined by the Graph API.
  *
- * Note that this interface is intended to be used with GraphObjectWrapper
+ * Note that this interface is intended to be used with GraphObject.Factory
  * and not implemented directly.
  */
 public interface GraphUser extends GraphObject {
diff --git a/facebook/src/com/facebook/model/JsonUtil.java b/facebook/src/com/facebook/model/JsonUtil.java
new file mode 100644
index 000000000..bd46f6e2a
--- /dev/null
+++ b/facebook/src/com/facebook/model/JsonUtil.java
@@ -0,0 +1,122 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.model;
+
+import android.annotation.SuppressLint;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.*;
+
+class JsonUtil {
+    static void jsonObjectClear(JSONObject jsonObject) {
+        @SuppressWarnings("unchecked")
+        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
+        while (keys.hasNext()) {
+            keys.next();
+            keys.remove();
+        }
+    }
+
+    static boolean jsonObjectContainsValue(JSONObject jsonObject, Object value) {
+        @SuppressWarnings("unchecked")
+        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
+        while (keys.hasNext()) {
+            Object thisValue = jsonObject.opt(keys.next());
+            if (thisValue != null && thisValue.equals(value)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private final static class JSONObjectEntry implements Map.Entry<String, Object> {
+        private final String key;
+        private final Object value;
+
+        JSONObjectEntry(String key, Object value) {
+            this.key = key;
+            this.value = value;
+        }
+
+        @SuppressLint("FieldGetter")
+        @Override
+        public String getKey() {
+            return this.key;
+        }
+
+        @Override
+        public Object getValue() {
+            return this.value;
+        }
+
+        @Override
+        public Object setValue(Object object) {
+            throw new UnsupportedOperationException("JSONObjectEntry is immutable");
+        }
+
+    }
+
+    static Set<Map.Entry<String, Object>> jsonObjectEntrySet(JSONObject jsonObject) {
+        HashSet<Map.Entry<String, Object>> result = new HashSet<Map.Entry<String, Object>>();
+
+        @SuppressWarnings("unchecked")
+        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
+        while (keys.hasNext()) {
+            String key = keys.next();
+            Object value = jsonObject.opt(key);
+            result.add(new JSONObjectEntry(key, value));
+        }
+
+        return result;
+    }
+
+    static Set<String> jsonObjectKeySet(JSONObject jsonObject) {
+        HashSet<String> result = new HashSet<String>();
+
+        @SuppressWarnings("unchecked")
+        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
+        while (keys.hasNext()) {
+            result.add(keys.next());
+        }
+
+        return result;
+    }
+
+    static void jsonObjectPutAll(JSONObject jsonObject, Map<String, Object> map) {
+        Set<Map.Entry<String, Object>> entrySet = map.entrySet();
+        for (Map.Entry<String, Object> entry : entrySet) {
+            try {
+                jsonObject.putOpt(entry.getKey(), entry.getValue());
+            } catch (JSONException e) {
+                throw new IllegalArgumentException(e);
+            }
+        }
+    }
+
+    static Collection<Object> jsonObjectValues(JSONObject jsonObject) {
+        ArrayList<Object> result = new ArrayList<Object>();
+
+        @SuppressWarnings("unchecked")
+        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
+        while (keys.hasNext()) {
+            result.add(jsonObject.opt(keys.next()));
+        }
+
+        return result;
+    }
+}
diff --git a/facebook/src/com/facebook/OpenGraphAction.java b/facebook/src/com/facebook/model/OpenGraphAction.java
similarity index 98%
rename from facebook/src/com/facebook/OpenGraphAction.java
rename to facebook/src/com/facebook/model/OpenGraphAction.java
index 4a55bd66c..9e007a89d 100644
--- a/facebook/src/com/facebook/OpenGraphAction.java
+++ b/facebook/src/com/facebook/model/OpenGraphAction.java
@@ -1,5 +1,5 @@
 /**
- * Copyright 2010 Facebook, Inc.
+ * Copyright 2012 Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.model;
 
 import org.json.JSONObject;
 
@@ -25,7 +25,7 @@
  * Provides a strongly-typed representation of an Open Graph Action.
  * For more documentation of OG Actions, see: https://developers.facebook.com/docs/opengraph/actions/
  *
- * Note that this interface is intended to be used with GraphObjectWrapper
+ * Note that this interface is intended to be used with GraphObject.Factory
  * and not implemented directly.
  */
 public interface OpenGraphAction extends GraphObject {
diff --git a/facebook/src/com/facebook/model/PropertyName.java b/facebook/src/com/facebook/model/PropertyName.java
new file mode 100644
index 000000000..36da6edda
--- /dev/null
+++ b/facebook/src/com/facebook/model/PropertyName.java
@@ -0,0 +1,34 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.model;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * Use this annotation on getters and setters in an interface that derives from
+ * GraphObject, if you wish to override the default property name that is inferred
+ * from the name of the method.
+ *
+ * If this annotation is specified on a method, it must contain a non-empty String
+ * value that represents the name of the property that the method is a getter or setter
+ * for.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+public @interface PropertyName {
+    String value();
+}
\ No newline at end of file
diff --git a/facebook/src/com/facebook/FacebookFragment.java b/facebook/src/com/facebook/widget/FacebookFragment.java
similarity index 73%
rename from facebook/src/com/facebook/FacebookFragment.java
rename to facebook/src/com/facebook/widget/FacebookFragment.java
index d75aa625c..1084185c5 100644
--- a/facebook/src/com/facebook/FacebookFragment.java
+++ b/facebook/src/com/facebook/widget/FacebookFragment.java
@@ -14,11 +14,16 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.widget;
 
 import android.content.Intent;
 import android.os.Bundle;
 import android.support.v4.app.Fragment;
+import com.facebook.Session;
+import com.facebook.SessionLoginBehavior;
+import com.facebook.SessionState;
+import com.facebook.internal.SessionAuthorizationType;
+import com.facebook.internal.SessionTracker;
 
 import java.util.Date;
 import java.util.List;
@@ -67,7 +72,9 @@ public void onDestroy() {
      * @param newSession the Session object to use
      */
     public void setSession(Session newSession) {
-        sessionTracker.setSession(newSession);
+        if (sessionTracker != null) {
+            sessionTracker.setSession(newSession);
+        }
     }
 
     // METHOD TO BE OVERRIDDEN
@@ -90,7 +97,10 @@ protected void onSessionStateChange(SessionState state, Exception exception) {
      * @return the current Session object.
      */
     protected final Session getSession() {
-        return sessionTracker.getSession();
+        if (sessionTracker != null) {
+            return sessionTracker.getSession();
+        }
+        return null;
     }
 
     /**
@@ -99,7 +109,10 @@ protected final Session getSession() {
      * @return true if the current session is open
      */
     protected final boolean isSessionOpen() {
-        return sessionTracker.getOpenSession() != null;
+        if (sessionTracker != null) {
+            return sessionTracker.getOpenSession() != null;
+        }
+        return false;
     }
     
     /**
@@ -108,8 +121,11 @@ protected final boolean isSessionOpen() {
      * @return the current state of the session
      */
     protected final SessionState getSessionState() {
-        Session currentSession = sessionTracker.getSession();
-        return (currentSession != null) ? currentSession.getState() : null;
+        if (sessionTracker != null) {
+            Session currentSession = sessionTracker.getSession();
+            return (currentSession != null) ? currentSession.getState() : null;
+        }
+        return null;
     }
     
     /**
@@ -119,8 +135,11 @@ protected final SessionState getSessionState() {
      * @return the access token
      */
     protected final String getAccessToken() {
-        Session currentSession = sessionTracker.getOpenSession();
-        return (currentSession != null) ? currentSession.getAccessToken() : null;
+        if (sessionTracker != null) {
+            Session currentSession = sessionTracker.getOpenSession();
+            return (currentSession != null) ? currentSession.getAccessToken() : null;
+        }
+        return null;
     }
 
     /**
@@ -130,17 +149,22 @@ protected final String getAccessToken() {
      * @return the date at which the current session will expire
      */
     protected final Date getExpirationDate() {
-        Session currentSession = sessionTracker.getOpenSession();
-        return (currentSession != null) ? currentSession.getExpirationDate() : null;
+        if (sessionTracker != null) {
+            Session currentSession = sessionTracker.getOpenSession();
+            return (currentSession != null) ? currentSession.getExpirationDate() : null;
+        }
+        return null;
     }
     
     /**
      * Closes the current session.
      */
     protected final void closeSession() {
-        Session currentSession = sessionTracker.getOpenSession();
-        if (currentSession != null) {
-            currentSession.close();
+        if (sessionTracker != null) {
+            Session currentSession = sessionTracker.getOpenSession();
+            if (currentSession != null) {
+                currentSession.close();
+            }
         }
     }
     
@@ -148,9 +172,11 @@ protected final void closeSession() {
      * Closes the current session as well as clearing the token cache.
      */
     protected final void closeSessionAndClearTokenInformation() {
-        Session currentSession = sessionTracker.getOpenSession();
-        if (currentSession != null) {
-            currentSession.closeAndClearTokenInformation();
+        if (sessionTracker != null) {
+            Session currentSession = sessionTracker.getOpenSession();
+            if (currentSession != null) {
+                currentSession.closeAndClearTokenInformation();
+            }
         }
     }
     
@@ -161,8 +187,11 @@ protected final void closeSessionAndClearTokenInformation() {
      * @return the permissions associated with the current session
      */
     protected final List<String> getSessionPermissions() {
-        Session currentSession = sessionTracker.getSession();
-        return (currentSession != null) ? currentSession.getPermissions() : null;
+        if (sessionTracker != null) {
+            Session currentSession = sessionTracker.getSession();
+            return (currentSession != null) ? currentSession.getPermissions() : null;
+        }
+        return null;
     }
 
     /**
@@ -198,7 +227,7 @@ protected final void openSessionForRead(String applicationId, List<String> permi
      */
     protected final void openSessionForRead(String applicationId, List<String> permissions,
             SessionLoginBehavior behavior, int activityCode) {
-        openSession(applicationId, permissions, behavior, activityCode, Session.AuthorizationType.READ);
+        openSession(applicationId, permissions, behavior, activityCode, SessionAuthorizationType.READ);
     }
 
     /**
@@ -226,26 +255,28 @@ protected final void openSessionForPublish(String applicationId, List<String> pe
      */
     protected final void openSessionForPublish(String applicationId, List<String> permissions,
             SessionLoginBehavior behavior, int activityCode) {
-        openSession(applicationId, permissions, behavior, activityCode, Session.AuthorizationType.PUBLISH);
+        openSession(applicationId, permissions, behavior, activityCode, SessionAuthorizationType.PUBLISH);
     }
 
     private void openSession(String applicationId, List<String> permissions,
-            SessionLoginBehavior behavior, int activityCode, Session.AuthorizationType authType) {
-        Session currentSession = sessionTracker.getSession();
-        if (currentSession == null || currentSession.getState().isClosed()) {
-            Session session = new Session.Builder(getActivity()).setApplicationId(applicationId).build();
-            Session.setActiveSession(session);
-            currentSession = session;
-        }
-        if (!currentSession.isOpened()) {
-            Session.OpenRequest openRequest = new Session.OpenRequest(this).
-                    setPermissions(permissions).
-                    setLoginBehavior(behavior).
-                    setRequestCode(activityCode);
-            if (Session.AuthorizationType.PUBLISH.equals(authType)) {
-                currentSession.openForPublish(openRequest);
-            } else {
-                currentSession.openForRead(openRequest);
+            SessionLoginBehavior behavior, int activityCode, SessionAuthorizationType authType) {
+        if (sessionTracker != null) {
+            Session currentSession = sessionTracker.getSession();
+            if (currentSession == null || currentSession.getState().isClosed()) {
+                Session session = new Session.Builder(getActivity()).setApplicationId(applicationId).build();
+                Session.setActiveSession(session);
+                currentSession = session;
+            }
+            if (!currentSession.isOpened()) {
+                Session.OpenRequest openRequest = new Session.OpenRequest(this).
+                        setPermissions(permissions).
+                        setLoginBehavior(behavior).
+                        setRequestCode(activityCode);
+                if (SessionAuthorizationType.PUBLISH.equals(authType)) {
+                    currentSession.openForPublish(openRequest);
+                } else {
+                    currentSession.openForRead(openRequest);
+                }
             }
         }
     }
diff --git a/facebook/src/com/facebook/FriendPickerFragment.java b/facebook/src/com/facebook/widget/FriendPickerFragment.java
similarity index 94%
rename from facebook/src/com/facebook/FriendPickerFragment.java
rename to facebook/src/com/facebook/widget/FriendPickerFragment.java
index bbc290f9b..831b3a0c4 100644
--- a/facebook/src/com/facebook/FriendPickerFragment.java
+++ b/facebook/src/com/facebook/widget/FriendPickerFragment.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.widget;
 
 import android.annotation.SuppressLint;
 import android.app.Activity;
@@ -22,7 +22,9 @@
 import android.os.Bundle;
 import android.text.TextUtils;
 import android.util.AttributeSet;
+import com.facebook.*;
 import com.facebook.android.R;
+import com.facebook.model.GraphUser;
 
 import java.util.Arrays;
 import java.util.HashSet;
@@ -33,17 +35,17 @@
  * Provides a Fragment that displays a list of a user's friends and allows one or more of the
  * friends to be selected.
  */
-public class FriendPickerFragment extends GraphObjectListFragment<GraphUser> {
+public class FriendPickerFragment extends PickerFragment<GraphUser> {
     /**
      * The key for a String parameter in the fragment's Intent bundle to indicate what user's
      * friends should be shown. The default is to display the currently authenticated user's friends.
      */
-    public static final String USER_ID_BUNDLE_KEY = "com.facebook.FriendPickerFragment.UserId";
+    public static final String USER_ID_BUNDLE_KEY = "com.facebook.widget.FriendPickerFragment.UserId";
     /**
      * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
      * picker should allow more than one friend to be selected or not.
      */
-    public static final String MULTI_SELECT_BUNDLE_KEY = "com.facebook.FriendPickerFragment.MultiSelect";
+    public static final String MULTI_SELECT_BUNDLE_KEY = "com.facebook.widget.FriendPickerFragment.MultiSelect";
 
     private static final String ID = "id";
     private static final String NAME = "name";
@@ -138,8 +140,8 @@ void saveSettingsToBundle(Bundle outState) {
     }
 
     @Override
-    GraphObjectListFragmentAdapter<GraphUser> createAdapter() {
-        GraphObjectListFragmentAdapter<GraphUser> adapter = new GraphObjectListFragmentAdapter<GraphUser>(
+    PickerFragmentAdapter<GraphUser> createAdapter() {
+        PickerFragmentAdapter<GraphUser> adapter = new PickerFragmentAdapter<GraphUser>(
                 this.getActivity()) {
 
             @Override
@@ -189,15 +191,18 @@ String getDefaultTitleText() {
     private Request createRequest(String userID, Set<String> extraFields, Session session) {
         Request request = Request.newGraphPathRequest(session, userID + "/friends", null);
 
-        String pictureField = adapter.getPictureFieldSpecifier();
         Set<String> fields = new HashSet<String>(extraFields);
         String[] requiredFields = new String[]{
                 ID,
-                NAME,
-                pictureField
+                NAME
         };
         fields.addAll(Arrays.asList(requiredFields));
 
+        String pictureField = adapter.getPictureFieldSpecifier();
+        if (pictureField != null) {
+            fields.add(pictureField);
+        }
+
         Bundle parameters = request.getParameters();
         parameters.putString("fields", TextUtils.join(",", fields));
         request.setParameters(parameters);
diff --git a/facebook/src/com/facebook/GraphObjectAdapter.java b/facebook/src/com/facebook/widget/GraphObjectAdapter.java
similarity index 72%
rename from facebook/src/com/facebook/GraphObjectAdapter.java
rename to facebook/src/com/facebook/widget/GraphObjectAdapter.java
index ddef18c90..dbf66809c 100644
--- a/facebook/src/com/facebook/GraphObjectAdapter.java
+++ b/facebook/src/com/facebook/widget/GraphObjectAdapter.java
@@ -14,40 +14,37 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.widget;
 
 import android.content.Context;
 import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.os.Handler;
-import android.os.Looper;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewStub;
 import android.widget.*;
+import com.facebook.*;
 import com.facebook.android.R;
+import com.facebook.model.GraphObject;
 import org.json.JSONObject;
 
-import java.io.IOException;
-import java.io.InputStream;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.text.Collator;
 import java.util.*;
 
 class GraphObjectAdapter<T extends GraphObject> extends BaseAdapter implements SectionIndexer {
-    private static final PrioritizedWorkQueue downloadWorkQueue = new PrioritizedWorkQueue();
+    private static final int DISPLAY_SECTIONS_THRESHOLD = 1;
+    private static final int HEADER_VIEW_TYPE = 0;
+    private static final int GRAPH_OBJECT_VIEW_TYPE = 1;
+    private static final int ACTIVITY_CIRCLE_VIEW_TYPE = 2;
+    private static final int MAX_PREFETCHED_PICTURES = 20;
 
-    private final int DISPLAY_SECTIONS_THRESHOLD = 1;
-    private final int HEADER_VIEW_TYPE = 0;
-    private final int GRAPH_OBJECT_VIEW_TYPE = 1;
-    private final int ACTIVITY_CIRCLE_VIEW_TYPE = 2;
-
-    private final String ID = "id";
-    private final String NAME = "name";
-    private final String PICTURE = "picture";
+    private static final String ID = "id";
+    private static final String NAME = "name";
+    private static final String PICTURE = "picture";
 
+    private final Map<String, ImageRequest> pendingRequests = new HashMap<String, ImageRequest>();
     private final LayoutInflater inflater;
     private List<String> sectionKeys = new ArrayList<String>();
     private Map<String, ArrayList<T>> graphObjectsBySection = new HashMap<String, ArrayList<T>>();
@@ -55,12 +52,15 @@
     private boolean displaySections;
     private List<String> sortFields;
     private String groupByField;
-    private PictureDownloader pictureDownloader;
     private boolean showPicture;
     private boolean showCheckbox;
     private Filter<T> filter;
     private DataNeededListener dataNeededListener;
     private GraphObjectCursor<T> cursor;
+    private Context context;
+    private Map<String, ImageResponse> prefetchedPictureCache = new HashMap<String, ImageResponse>();
+    private ArrayList<String> prefetchedProfilePictureIds = new ArrayList<String>();
+
 
     public interface DataNeededListener {
         public void onDataNeeded();
@@ -97,6 +97,7 @@ public Type getType() {
     }
 
     public GraphObjectAdapter(Context context) {
+        this.context = context;
         this.inflater = LayoutInflater.from(context);
     }
 
@@ -162,17 +163,63 @@ public void rebuildAndNotify() {
         notifyDataSetChanged();
     }
 
-    public void cancelPendingDownloads() {
-        PictureDownloader downloader = pictureDownloader;
-        if (downloader != null) {
-            downloader.cancelAllDownloads();
+    public void prioritizeViewRange(int firstVisibleItem, int lastVisibleItem, int prefetchBuffer) {
+        if (lastVisibleItem < firstVisibleItem) {
+            return;
+        }
+
+        // We want to prioritize requests for items which are visible but do not have pictures
+        // loaded yet. We also want to pre-fetch pictures for items which are not yet visible
+        // but are within a buffer on either side of the visible items, on the assumption that
+        // they will be visible soon. For these latter items, we'll store the images in memory
+        // in the hopes we can immediately populate their image view when needed.
+
+        // Prioritize the requests in reverse order since each call to prioritizeRequest will just
+        // move it to the front of the queue. And we want the earliest ones in the range to be at
+        // the front of the queue, so all else being equal, the list will appear to populate from
+        // the top down.
+        for (int i = lastVisibleItem; i >= 0; i--) {
+            SectionAndItem<T> sectionAndItem = getSectionAndItem(i);
+            if (sectionAndItem.graphObject != null) {
+                String id = getIdOfGraphObject(sectionAndItem.graphObject);
+                ImageRequest request = pendingRequests.get(id);
+                if (request != null) {
+                    ImageDownloader.prioritizeRequest(request);
+                }
+            }
         }
-    }
 
-    public void prioritizeViewRange(int start, int count) {
-        PictureDownloader downloader = pictureDownloader;
-        if (downloader != null) {
-            downloader.prioritizeViewRange(start, count);
+        // For items which are not visible, but within the buffer on either side, we want to
+        // fetch those items and store them in a small in-memory cache of bitmaps.
+        int start = Math.max(0, firstVisibleItem - prefetchBuffer);
+        int end = Math.min(lastVisibleItem + prefetchBuffer, getCount() - 1);
+        ArrayList<T> graphObjectsToPrefetchPicturesFor = new ArrayList<T>();
+        // Add the IDs before and after the visible range.
+        for (int i = start; i < firstVisibleItem; ++i) {
+            SectionAndItem<T> sectionAndItem = getSectionAndItem(i);
+            if (sectionAndItem.graphObject != null) {
+                graphObjectsToPrefetchPicturesFor.add(sectionAndItem.graphObject);
+            }
+        }
+        for (int i = lastVisibleItem + 1; i <= end; ++i) {
+            SectionAndItem<T> sectionAndItem = getSectionAndItem(i);
+            if (sectionAndItem.graphObject != null) {
+                graphObjectsToPrefetchPicturesFor.add(sectionAndItem.graphObject);
+            }
+        }
+        for (T graphObject : graphObjectsToPrefetchPicturesFor) {
+            URL url = getPictureUrlOfGraphObject(graphObject);
+            final String id = getIdOfGraphObject(graphObject);
+
+            // This URL already have been requested for pre-fetching, but we want to act in an LRU manner, so move
+            // it to the end of the list regardless.
+            boolean alreadyPrefetching = prefetchedProfilePictureIds.remove(id);
+            prefetchedProfilePictureIds.add(id);
+
+            // If we've already requested it for pre-fetching, no need to do so again.
+            if (!alreadyPrefetching) {
+                downloadProfilePicture(id, url, null);
+            }
         }
     }
 
@@ -203,7 +250,7 @@ protected URL getPictureUrlOfGraphObject(T graphObject) {
         if (o instanceof String) {
             url = (String) o;
         } else if (o instanceof JSONObject) {
-            ItemPicture itemPicture = GraphObjectWrapper.createGraphObject((JSONObject) o).cast(ItemPicture.class);
+            ItemPicture itemPicture = GraphObject.Factory.create((JSONObject) o).cast(ItemPicture.class);
             ItemPictureData data = itemPicture.getData();
             if (data != null) {
                 url = data.getUrl();
@@ -232,7 +279,7 @@ protected View getSectionHeaderView(String sectionHeader, View convertView, View
     }
 
     protected View getGraphObjectView(T graphObject, View convertView, ViewGroup parent) {
-        View result = (View) convertView;
+        View result = convertView;
 
         if (result == null) {
             result = createGraphObjectView(graphObject, convertView);
@@ -243,10 +290,10 @@ protected View getGraphObjectView(T graphObject, View convertView, ViewGroup par
     }
 
     private View getActivityCircleView(View convertView, ViewGroup parent) {
-        View result = (View) convertView;
+        View result = convertView;
 
         if (result == null) {
-            result = (View) inflater.inflate(R.layout.com_facebook_picker_activity_circle_row, null);
+            result = inflater.inflate(R.layout.com_facebook_picker_activity_circle_row, null);
         }
         ProgressBar activityCircle = (ProgressBar) result.findViewById(R.id.com_facebook_picker_row_activity_circle);
         activityCircle.setVisibility(View.VISIBLE);
@@ -317,7 +364,15 @@ protected void populateGraphObjectView(View view, T graphObject) {
 
             if (pictureURL != null) {
                 ImageView profilePic = (ImageView) view.findViewById(R.id.com_facebook_picker_image);
-                getPictureDownloader().download(id, pictureURL, profilePic);
+
+                // See if we have already pre-fetched this; if not, download it.
+                if (prefetchedPictureCache.containsKey(id)) {
+                    ImageResponse response = prefetchedPictureCache.get(id);
+                    profilePic.setImageBitmap(response.getBitmap());
+                    profilePic.setTag(response.getRequest().getImageUrl());
+                } else {
+                    downloadProfilePicture(id, pictureURL, profilePic);
+                }
             }
         }
     }
@@ -375,14 +430,6 @@ private boolean shouldShowActivityCircleCell() {
         return (cursor != null) && cursor.areMoreObjectsAvailable() && (dataNeededListener != null) && !isEmpty();
     }
 
-    private PictureDownloader getPictureDownloader() {
-        if (pictureDownloader == null) {
-            pictureDownloader = new PictureDownloader();
-        }
-
-        return pictureDownloader;
-    }
-
     private void rebuildSections() {
         sectionKeys = new ArrayList<String>();
         graphObjectsBySection = new HashMap<String, ArrayList<T>>();
@@ -421,7 +468,7 @@ private void rebuildSections() {
                 Collections.sort(section, new Comparator<GraphObject>() {
                     @Override
                     public int compare(GraphObject a, GraphObject b) {
-                        return Utility.compareGraphObjects(a, b, sortFields, collator);
+                        return compareGraphObjects(a, b, sortFields, collator);
                     }
                 });
             }
@@ -507,7 +554,7 @@ int getPosition(String sectionKey, T graphObject) {
 
         // Now find index of this item within that section.
         for (T t : graphObjectsBySection.get(sectionKey)) {
-            if (GraphObjectWrapper.hasSameId(t, graphObject)) {
+            if (GraphObject.Factory.hasSameId(t, graphObject)) {
                 return position;
             }
             position++;
@@ -642,7 +689,7 @@ public int getPositionForSection(int section) {
     public int getSectionForPosition(int position) {
         SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
         if (sectionAndItem != null &&
-            sectionAndItem.getType() != SectionAndItem.Type.ACTIVITY_CIRCLE) {
+                sectionAndItem.getType() != SectionAndItem.Type.ACTIVITY_CIRCLE) {
             return Math.max(0, Math.min(sectionKeys.indexOf(sectionAndItem.sectionKey), sectionKeys.size() - 1));
         }
         return 0;
@@ -663,115 +710,82 @@ public int getSectionForPosition(int position) {
         return result;
     }
 
-    private class PictureDownloader {
-        private final Map<String, PictureDownload> pendingDownloads = new HashMap<String, PictureDownload>();
-        private final Handler handler = new Handler();
-
-        void download(String id, URL pictureURL, ImageView imageView) {
-            validateIsUIThread(true);
-
-            if (pictureURL != null && !pictureURL.equals(imageView.getTag())) {
-                imageView.setTag(id);
-
-                PictureDownload download = new PictureDownload(id, pictureURL, imageView);
-
-                imageView.setImageResource(getDefaultPicture());
-                start(download);
-            }
+    private void downloadProfilePicture(final String profileId, URL pictureURL, final ImageView imageView) {
+        if (pictureURL == null) {
+            return;
         }
 
-        void cancelAllDownloads() {
-            validateIsUIThread(true);
-
-            for (PictureDownload download : pendingDownloads.values()) {
-                download.workItem.cancel();
+        // If we don't have an imageView, we are pre-fetching this image to store in-memory because we
+        // think the user might scroll to its corresponding list row. If we do have an imageView, we
+        // only want to queue a download if the view's tag isn't already set to the URL (which would mean
+        // it's already got the correct picture).
+        boolean prefetching = imageView == null;
+        if (prefetching || !pictureURL.equals(imageView.getTag())) {
+            if (!prefetching) {
+                // Setting the tag to the profile ID indicates that we're currently downloading the
+                // picture for this profile; we'll set it to the actual picture URL when complete.
+                imageView.setTag(profileId);
+                imageView.setImageResource(getDefaultPicture());
             }
 
-            pendingDownloads.clear();
-        }
-
-        void prioritizeViewRange(int start, int count) {
-            validateIsUIThread(true);
-
-            downloadWorkQueue.backgroundAll();
-            for (int i = start; i < (start + count); i++) {
-                SectionAndItem<T> sectionAndItem = getSectionAndItem(i);
-                if (sectionAndItem.graphObject != null) {
-                    String id = getIdOfGraphObject(sectionAndItem.graphObject);
-                    PictureDownload download = pendingDownloads.get(id);
-                    if (download != null) {
-                        download.workItem.setPriority(PrioritizedWorkQueue.PRIORITY_ACTIVE);
-                    }
+            ImageRequest.Builder builder = new ImageRequest.Builder(context.getApplicationContext(), pictureURL)
+                    .setCallerTag(this)
+                    .setCallback(
+                            new ImageRequest.Callback() {
+                                @Override
+                                public void onCompleted(ImageResponse response) {
+                                    processImageResponse(response, profileId, imageView);
+                                }
+                            });
+
+            ImageRequest newRequest = builder.build();
+            pendingRequests.put(profileId, newRequest);
+
+            ImageDownloader.downloadAsync(newRequest);
+        }
+    }
+
+    private void processImageResponse(ImageResponse response, String graphObjectId, ImageView imageView) {
+        pendingRequests.remove(graphObjectId);
+        if (imageView == null) {
+            // This was a pre-fetch request.
+            if (response.getBitmap() != null) {
+                // Is the cache too big?
+                if (prefetchedPictureCache.size() >= MAX_PREFETCHED_PICTURES) {
+                    // Find the oldest one and remove it.
+                    String oldestId = prefetchedProfilePictureIds.remove(0);
+                    prefetchedPictureCache.remove(oldestId);
                 }
+                prefetchedPictureCache.put(graphObjectId, response);
             }
-        }
-
-        private void start(final PictureDownload download) {
-            validateIsUIThread(true);
-
-            if (pendingDownloads.containsKey(download.graphObjectId)) {
-                PictureDownload inProgress = pendingDownloads.get(download.graphObjectId);
-                inProgress.imageView = download.imageView;
-            } else {
-                pendingDownloads.put(download.graphObjectId, download);
-                download.workItem = downloadWorkQueue.addActiveWorkItem(new Runnable() {
-                    @Override
-                    public void run() {
-                        getStream(download);
-                    }
-                });
-            }
-        }
-
-        private void getStream(final PictureDownload download) {
-            validateIsUIThread(false);
-
-            InputStream stream = null;
-            try {
-                stream = ImageResponseCache.getImageStream(download.pictureURL, download.context);
-                final Bitmap bitmap = (stream != null) ? BitmapFactory.decodeStream(stream) : null;
-
-                handler.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        updateView(download, bitmap);
-                    }
-                });
-            } catch (IOException e) {
-            } finally {
-                Utility.closeQuietly(stream);
+        } else if (imageView != null && graphObjectId.equals(imageView.getTag())) {
+            Exception error = response.getError();
+            Bitmap bitmap = response.getBitmap();
+            if (error == null && bitmap != null) {
+                imageView.setImageBitmap(bitmap);
+                imageView.setTag(response.getRequest().getImageUrl());
             }
         }
+    }
 
-        private void updateView(final PictureDownload download, final Bitmap bitmap) {
-            validateIsUIThread(true);
+    private static int compareGraphObjects(GraphObject a, GraphObject b, Collection<String> sortFields,
+            Collator collator) {
+        for (String sortField : sortFields) {
+            String sa = (String) a.getProperty(sortField);
+            String sb = (String) b.getProperty(sortField);
 
-            pendingDownloads.remove(download.graphObjectId);
-            if (download.graphObjectId.equals(download.imageView.getTag())) {
-                download.imageView.setImageBitmap(bitmap);
-                download.imageView.setTag(download.pictureURL);
+            if (sa != null && sb != null) {
+                int result = collator.compare(sa, sb);
+                if (result != 0) {
+                    return result;
+                }
+            } else if (!(sa == null && sb == null)) {
+                return (sa == null) ? -1 : 1;
             }
         }
-
-        void validateIsUIThread(boolean uiThreadExpected) {
-            assert uiThreadExpected == (handler.getLooper() == Looper.myLooper());
-        }
+        return 0;
     }
 
-    private class PictureDownload {
-        public final String graphObjectId;
-        public final URL pictureURL;
-        public final Context context;
-        public ImageView imageView;
-        public PrioritizedWorkQueue.WorkItem workItem;
-
-        public PictureDownload(String graphObjectId, URL pictureURL, ImageView imageView) {
-            this.graphObjectId = graphObjectId;
-            this.pictureURL = pictureURL;
-            this.imageView = imageView;
-            context = imageView.getContext().getApplicationContext();
-        }
-    }
 
     // Graph object type to navigate the JSON that sometimes comes back instead of a URL string
     private interface ItemPicture extends GraphObject {
diff --git a/facebook/src/com/facebook/widget/GraphObjectCursor.java b/facebook/src/com/facebook/widget/GraphObjectCursor.java
new file mode 100644
index 000000000..a86e4a302
--- /dev/null
+++ b/facebook/src/com/facebook/widget/GraphObjectCursor.java
@@ -0,0 +1,55 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import com.facebook.model.GraphObject;
+
+interface GraphObjectCursor<T extends GraphObject> {
+    boolean isFromCache();
+
+    boolean areMoreObjectsAvailable();
+
+    int getCount();
+
+    int getPosition();
+
+    boolean move(int offset);
+
+    boolean moveToPosition(int position);
+
+    boolean moveToFirst();
+
+    boolean moveToLast();
+
+    boolean moveToNext();
+
+    boolean moveToPrevious();
+
+    boolean isFirst();
+
+    boolean isLast();
+
+    boolean isBeforeFirst();
+
+    boolean isAfterLast();
+
+    T getGraphObject();
+
+    void close();
+
+    boolean isClosed();
+}
diff --git a/facebook/src/com/facebook/GraphObjectPagingLoader.java b/facebook/src/com/facebook/widget/GraphObjectPagingLoader.java
similarity index 65%
rename from facebook/src/com/facebook/GraphObjectPagingLoader.java
rename to facebook/src/com/facebook/widget/GraphObjectPagingLoader.java
index 1c7cd0a2b..f36eeb48e 100644
--- a/facebook/src/com/facebook/GraphObjectPagingLoader.java
+++ b/facebook/src/com/facebook/widget/GraphObjectPagingLoader.java
@@ -14,23 +14,22 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.widget;
 
 import android.content.Context;
 import android.os.Handler;
 import android.support.v4.content.Loader;
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.MalformedURLException;
-import java.net.URL;
+import com.facebook.*;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphObjectList;
+import com.facebook.internal.CacheableRequestBatch;
 
 class GraphObjectPagingLoader<T extends GraphObject> extends Loader<SimpleGraphObjectCursor<T>> {
     private final Class<T> graphObjectClass;
     private boolean skipRoundtripIfCached;
     private Request originalRequest;
     private Request currentRequest;
-    private String nextLink;
+    private Request nextRequest;
     private OnErrorListener onErrorListener;
     private SimpleGraphObjectCursor<T> cursor;
     private boolean appendResults = false;
@@ -59,7 +58,7 @@ public void setOnErrorListener(OnErrorListener listener) {
     }
 
     public void clearResults() {
-        nextLink = null;
+        nextRequest = null;
         originalRequest = null;
         currentRequest = null;
 
@@ -84,30 +83,20 @@ public void refreshOriginalRequest(long afterDelay) {
     }
 
     public void followNextLink() {
-        if (nextLink != null) {
+        if (nextRequest != null) {
             appendResults = true;
-            currentRequest = Request.newGraphPathRequest(originalRequest.getSession(), null, new Request.Callback() {
+            currentRequest = nextRequest;
+
+            currentRequest.setCallback(new Request.Callback() {
                 @Override
                 public void onCompleted(Response response) {
                     requestCompleted(response);
                 }
             });
 
-            // We rely on the "next" link returned to us being in the right format to return the results we expect.
-            HttpURLConnection connection = null;
-            try {
-                connection = Request.createConnection(new URL(nextLink));
-            } catch (IOException e) {
-                if (onErrorListener != null) {
-                    onErrorListener.onError(new FacebookException(e), this);
-                }
-                return;
-            }
-
             loading = true;
-            RequestBatch batch = putRequestIntoBatch(currentRequest, skipRoundtripIfCached);
-            batch.setCacheKey(nextLink.toString());
-            Request.executeConnectionAsync(connection, batch);
+            CacheableRequestBatch batch = putRequestIntoBatch(currentRequest, skipRoundtripIfCached);
+            Request.executeBatchAsync(batch);
         }
     }
 
@@ -137,7 +126,7 @@ protected void onStartLoading() {
     private void startLoading(Request request, boolean skipRoundtripIfCached, long afterDelay) {
         this.skipRoundtripIfCached = skipRoundtripIfCached;
         appendResults = false;
-        nextLink = null;
+        nextRequest = null;
         currentRequest = request;
         currentRequest.setCallback(new Request.Callback() {
             @Override
@@ -164,14 +153,10 @@ public void run() {
         }
     }
 
-    private RequestBatch putRequestIntoBatch(Request request, boolean skipRoundtripIfCached) {
+    private CacheableRequestBatch putRequestIntoBatch(Request request, boolean skipRoundtripIfCached) {
         // We just use the request URL as the cache key.
-        RequestBatch batch = new RequestBatch(request);
-        try {
-            batch.setCacheKey(request.getUrlForSingleRequest().toString());
-        } catch (MalformedURLException e) {
-            throw new FacebookException(e);
-        }
+        CacheableRequestBatch batch = new CacheableRequestBatch(request);
+        // We use the default cache key (request URL).
         batch.setForceRoundTrip(!skipRoundtripIfCached);
         return batch;
     }
@@ -185,66 +170,57 @@ private void requestCompleted(Response response) {
         loading = false;
         currentRequest = null;
 
-        FacebookException error = response.getError();
-        PagedResults result = response.getGraphObjectAs(PagedResults.class);
-        if (result == null && error == null) {
-            error = new FacebookException("GraphObjectPagingLoader received neither a result nor an error.");
+        FacebookRequestError requestError = response.getError();
+        FacebookException exception = (requestError == null) ? null : requestError.getException();
+        if (response.getGraphObject() == null && exception == null) {
+            exception = new FacebookException("GraphObjectPagingLoader received neither a result nor an error.");
         }
 
-        if (error != null) {
-            nextLink = null;
+        if (exception != null) {
+            nextRequest = null;
 
             if (onErrorListener != null) {
-                onErrorListener.onError(error, this);
+                onErrorListener.onError(exception, this);
             }
         } else {
-            boolean fromCache = response.getIsFromCache();
-            addResults(result, fromCache);
-            // Once we get any set of results NOT from the cache, stop trying to get any future ones
-            // from it.
-            if (!fromCache) {
-                skipRoundtripIfCached = false;
-            }
+            addResults(response);
         }
     }
 
-    private void addResults(PagedResults result, boolean fromCache) {
+    private void addResults(Response response) {
         SimpleGraphObjectCursor<T> cursorToModify = (cursor == null || !appendResults) ? new SimpleGraphObjectCursor<T>() :
                 new SimpleGraphObjectCursor<T>(cursor);
 
+        PagedResults result = response.getGraphObjectAs(PagedResults.class);
+        boolean fromCache = response.getIsFromCache();
+
         GraphObjectList<T> data = result.getData().castToListOf(graphObjectClass);
         boolean haveData = data.size() > 0;
 
         if (haveData) {
-            PagingInfo paging = result.getPaging();
-            if (nextLink != null && nextLink.equals(paging.getNext())) {
-                // We got the same "next" link as we just tried to retrieve. This could happen if cached
-                // data is invalid. All we can do in this case is pretend we have finished.
-                haveData = false;
-            } else {
-                nextLink = paging.getNext();
-
-                cursorToModify.addGraphObjects(data, fromCache);
-                cursorToModify.setMoreObjectsAvailable(true);
-            }
+            nextRequest = response.getRequestForPagedResults(Response.PagingDirection.NEXT);
+
+            cursorToModify.addGraphObjects(data, fromCache);
+            cursorToModify.setMoreObjectsAvailable(true);
         }
+
         if (!haveData) {
             cursorToModify.setMoreObjectsAvailable(false);
             cursorToModify.setFromCache(fromCache);
 
-            nextLink = null;
+            nextRequest = null;
         }
 
-        deliverResult(cursorToModify);
-    }
+        // Once we get any set of results NOT from the cache, stop trying to get any future ones
+        // from it.
+        if (!fromCache) {
+            skipRoundtripIfCached = false;
+        }
 
-    interface PagingInfo extends GraphObject {
-        String getNext();
+        deliverResult(cursorToModify);
     }
 
     interface PagedResults extends GraphObject {
         GraphObjectList<GraphObject> getData();
-
-        PagingInfo getPaging();
     }
 }
diff --git a/facebook/src/com/facebook/widget/ImageDownloader.java b/facebook/src/com/facebook/widget/ImageDownloader.java
new file mode 100644
index 000000000..4ea4b5494
--- /dev/null
+++ b/facebook/src/com/facebook/widget/ImageDownloader.java
@@ -0,0 +1,343 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.os.Handler;
+import com.facebook.FacebookException;
+import com.facebook.internal.Utility;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.*;
+
+class ImageDownloader {
+    private static final int DOWNLOAD_QUEUE_MAX_CONCURRENT = WorkQueue.DEFAULT_MAX_CONCURRENT;
+    private static final int CACHE_READ_QUEUE_MAX_CONCURRENT = 2;
+    private static final Handler handler = new Handler();
+    private static WorkQueue downloadQueue = new WorkQueue(DOWNLOAD_QUEUE_MAX_CONCURRENT);
+    private static WorkQueue cacheReadQueue = new WorkQueue(CACHE_READ_QUEUE_MAX_CONCURRENT);
+
+    private static final Map<RequestKey, DownloaderContext> pendingRequests = new HashMap<RequestKey, DownloaderContext>();
+
+    /**
+     * Downloads the image specified in the passed in request.
+     * If a callback is specified, it is guaranteed to be invoked on the calling thread.
+     * @param request Request to process
+     */
+    static void downloadAsync(ImageRequest request) {
+        if (request == null) {
+            return;
+        }
+
+        // NOTE: This is the ONLY place where the original request's Url is read. From here on,
+        // we will keep track of the Url separately. This is because we might be dealing with a
+        // redirect response and the Url might change. We can't create our own new ImageRequests
+        // for these changed Urls since the caller might be doing some book-keeping with the request's
+        // object reference. So we keep the old references and just map them to new urls in the downloader
+        RequestKey key = new RequestKey(request.getImageUrl(), request.getCallerTag());
+        synchronized (pendingRequests) {
+            DownloaderContext downloaderContext = pendingRequests.get(key);
+            if (downloaderContext != null) {
+                downloaderContext.request = request;
+                downloaderContext.isCancelled = false;
+                downloaderContext.workItem.moveToFront();
+            } else {
+                enqueueCacheRead(request, key, request.isCachedRedirectAllowed());
+            }
+        }
+    }
+
+    static boolean cancelRequest(ImageRequest request) {
+        boolean cancelled = false;
+        RequestKey key = new RequestKey(request.getImageUrl(), request.getCallerTag());
+        synchronized (pendingRequests) {
+            DownloaderContext downloaderContext = pendingRequests.get(key);
+            if (downloaderContext != null) {
+                // If we were able to find the request in our list of pending requests, then we will
+                // definitely be able to prevent an ImageResponse from being issued. This is regardless
+                // of whether a cache-read or network-download is underway for this request.
+                cancelled = true;
+
+                if (downloaderContext.workItem.cancel()) {
+                    pendingRequests.remove(key);
+                } else {
+                    // May be attempting a cache-read right now. So keep track of the cancellation
+                    // to prevent network calls etc
+                    downloaderContext.isCancelled = true;
+                }
+            }
+        }
+
+        return cancelled;
+    }
+
+    static void prioritizeRequest(ImageRequest request) {
+        RequestKey key = new RequestKey(request.getImageUrl(), request.getCallerTag());
+        synchronized (pendingRequests) {
+            DownloaderContext downloaderContext = pendingRequests.get(key);
+            if (downloaderContext != null) {
+                downloaderContext.workItem.moveToFront();
+            }
+        }
+    }
+
+    private static void enqueueCacheRead(ImageRequest request, RequestKey key, boolean allowCachedRedirects) {
+        enqueueRequest(
+                request,
+                key,
+                cacheReadQueue,
+                new CacheReadWorkItem(request.getContext(), key, allowCachedRedirects));
+    }
+
+    private static void enqueueDownload(ImageRequest request, RequestKey key) {
+        enqueueRequest(
+                request,
+                key,
+                downloadQueue,
+                new DownloadImageWorkItem(request.getContext(), key));
+    }
+
+    private static void enqueueRequest(
+            ImageRequest request,
+            RequestKey key,
+            WorkQueue workQueue,
+            Runnable workItem) {
+        synchronized (pendingRequests) {
+            DownloaderContext downloaderContext = new DownloaderContext();
+            downloaderContext.request = request;
+            pendingRequests.put(key, downloaderContext);
+
+            // The creation of the WorkItem should be done after the pending request has been registered.
+            // This is necessary since the WorkItem might kick off right away and attempt to retrieve
+            // the request's DownloaderContext prior to it being ready for access.
+            //
+            // It is also necessary to hold on to the lock until after the workItem is created, since
+            // calls to cancelRequest or prioritizeRequest might come in and expect a registered
+            // request to have a workItem available as well.
+            downloaderContext.workItem = workQueue.addActiveWorkItem(workItem);
+        }
+    }
+
+    private static void issueResponse(
+            RequestKey key,
+            final Exception error,
+            final Bitmap bitmap,
+            final boolean isCachedRedirect) {
+        // Once the old downloader context is removed, we are thread-safe since this is the
+        // only reference to it
+        DownloaderContext completedRequestContext = removePendingRequest(key);
+        if (completedRequestContext != null && !completedRequestContext.isCancelled) {
+            final ImageRequest request = completedRequestContext.request;
+            final ImageRequest.Callback callback = request.getCallback();
+            if (callback != null) {
+                handler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        ImageResponse response = new ImageResponse(
+                                request,
+                                error,
+                                isCachedRedirect,
+                                bitmap);
+                        callback.onCompleted(response);
+                    }
+                });
+            }
+        }
+    }
+
+    private static void readFromCache(RequestKey key, Context context, boolean allowCachedRedirects) {
+        InputStream cachedStream = null;
+        boolean isCachedRedirect = false;
+        if (allowCachedRedirects) {
+            URL redirectUrl = UrlRedirectCache.getRedirectedUrl(context, key.url);
+            if (redirectUrl != null) {
+                cachedStream = ImageResponseCache.getCachedImageStream(redirectUrl, context);
+                isCachedRedirect = cachedStream != null;
+            }
+        }
+
+        if (!isCachedRedirect) {
+            cachedStream = ImageResponseCache.getCachedImageStream(key.url, context);
+        }
+
+        if (cachedStream != null) {
+            // We were able to find a cached image.
+            Bitmap bitmap = BitmapFactory.decodeStream(cachedStream);
+            Utility.closeQuietly(cachedStream);
+            issueResponse(key, null, bitmap, isCachedRedirect);
+        } else {
+            // Once the old downloader context is removed, we are thread-safe since this is the
+            // only reference to it
+            DownloaderContext downloaderContext = removePendingRequest(key);
+            if (downloaderContext != null && !downloaderContext.isCancelled) {
+                enqueueDownload(downloaderContext.request, key);
+            }
+        }
+    }
+
+    private static void download(RequestKey key, Context context) {
+        HttpURLConnection connection = null;
+        InputStream stream = null;
+        Exception error = null;
+        Bitmap bitmap = null;
+        boolean issueResponse = true;
+
+        try {
+            connection = (HttpURLConnection) key.url.openConnection();
+            connection.setInstanceFollowRedirects(false);
+
+            switch (connection.getResponseCode()) {
+                case HttpURLConnection.HTTP_MOVED_PERM:
+                case HttpURLConnection.HTTP_MOVED_TEMP:
+                    // redirect. So we need to perform further requests
+                    issueResponse = false;
+
+                    String redirectLocation = connection.getHeaderField("location");
+                    if (!Utility.isNullOrEmpty(redirectLocation)) {
+                        URL redirectUrl = new URL(redirectLocation);
+                        UrlRedirectCache.cacheUrlRedirect(context, key.url, redirectUrl);
+
+                        // Once the old downloader context is removed, we are thread-safe since this is the
+                        // only reference to it
+                        DownloaderContext downloaderContext = removePendingRequest(key);
+                        if (downloaderContext != null && !downloaderContext.isCancelled) {
+                            enqueueCacheRead(
+                                    downloaderContext.request,
+                                    new RequestKey(redirectUrl, key.tag),
+                                    false);
+                        }
+                    }
+                    break;
+
+                case HttpURLConnection.HTTP_OK:
+                    // image should be available
+                    stream = ImageResponseCache.interceptAndCacheImageStream(context, connection);
+                    bitmap = BitmapFactory.decodeStream(stream);
+                    break;
+
+                default:
+                    stream = connection.getErrorStream();
+                    InputStreamReader reader = new InputStreamReader(stream);
+                    char[] buffer = new char[128];
+                    int bufferLength;
+                    StringBuilder errorMessageBuilder = new StringBuilder();
+                    while ((bufferLength = reader.read(buffer, 0, buffer.length)) > 0) {
+                        errorMessageBuilder.append(buffer, 0, bufferLength);
+                    }
+                    Utility.closeQuietly(reader);
+
+                    error = new FacebookException(errorMessageBuilder.toString());
+                    break;
+            }
+        } catch (IOException e) {
+            error = e;
+        } finally {
+            Utility.closeQuietly(stream);
+            Utility.disconnectQuietly(connection);
+        }
+
+        if (issueResponse) {
+            issueResponse(key, error, bitmap, false);
+        }
+    }
+
+    private static DownloaderContext removePendingRequest(RequestKey key) {
+        synchronized (pendingRequests) {
+            return pendingRequests.remove(key);
+        }
+    }
+
+    private static class RequestKey {
+        private static final int HASH_SEED = 29; // Some random prime number
+        private static final int HASH_MULTIPLIER = 37; // Some random prime number
+
+        URL url;
+        Object tag;
+
+        RequestKey(URL url, Object tag) {
+            this.url = url;
+            this.tag = tag;
+        }
+
+        @Override
+        public int hashCode() {
+            int result = HASH_SEED;
+
+            result = (result * HASH_MULTIPLIER) + url.hashCode();
+            result = (result * HASH_MULTIPLIER) + tag.hashCode();
+
+            return result;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            boolean isEqual = false;
+
+            if (o != null && o instanceof RequestKey) {
+                RequestKey compareTo = (RequestKey)o;
+                isEqual = compareTo.url == url && compareTo.tag == tag;
+            }
+
+            return isEqual;
+        }
+    }
+
+    private static class DownloaderContext {
+        WorkQueue.WorkItem workItem;
+        ImageRequest request;
+        boolean isCancelled;
+    }
+
+    private static class CacheReadWorkItem implements Runnable {
+        private Context context;
+        private RequestKey key;
+        private boolean allowCachedRedirects;
+
+        CacheReadWorkItem(Context context, RequestKey key, boolean allowCachedRedirects) {
+            this.context = context;
+            this.key = key;
+            this.allowCachedRedirects = allowCachedRedirects;
+        }
+
+        @Override
+        public void run() {
+            readFromCache(key, context, allowCachedRedirects);
+        }
+    }
+
+    private static class DownloadImageWorkItem implements Runnable {
+        private Context context;
+        private RequestKey key;
+
+        DownloadImageWorkItem(Context context, RequestKey key) {
+            this.context = context;
+            this.key = key;
+        }
+
+        @Override
+        public void run() {
+            download(key, context);
+        }
+
+    }
+}
diff --git a/facebook/src/com/facebook/widget/ImageRequest.java b/facebook/src/com/facebook/widget/ImageRequest.java
new file mode 100644
index 000000000..81494109d
--- /dev/null
+++ b/facebook/src/com/facebook/widget/ImageRequest.java
@@ -0,0 +1,145 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.content.Context;
+import android.net.Uri;
+import com.facebook.internal.Validate;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+
+class ImageRequest {
+
+    interface Callback {
+        /**
+         * This method should always be called on the UI thread. ImageDownloader makes
+         * sure to do this when it is responsible for issuing the ImageResponse
+         * @param response
+         */
+        void onCompleted(ImageResponse response);
+    }
+
+    static final int UNSPECIFIED_DIMENSION = 0;
+
+    private static final String PROFILEPIC_URL_FORMAT =
+            "https://graph.facebook.com/%s/picture";
+    private static final String HEIGHT_PARAM = "height";
+    private static final String WIDTH_PARAM = "width";
+    private static final String MIGRATION_PARAM = "migration_overrides";
+    private static final String MIGRATION_VALUE = "{october_2012:true}";
+
+    private Context context;
+    private URL imageUrl;
+    private Callback callback;
+    private boolean allowCachedRedirects;
+    private Object callerTag;
+
+    static URL getProfilePictureUrl(
+            String userId,
+            int width,
+            int height)
+        throws MalformedURLException {
+
+        Validate.notNullOrEmpty(userId, "userId");
+
+        width = Math.max(width, UNSPECIFIED_DIMENSION);
+        height = Math.max(height, UNSPECIFIED_DIMENSION);
+
+        if (width == UNSPECIFIED_DIMENSION && height == UNSPECIFIED_DIMENSION) {
+            throw new IllegalArgumentException("Either width or height must be greater than 0");
+        }
+
+        Uri.Builder builder = new Uri.Builder().encodedPath(String.format(PROFILEPIC_URL_FORMAT, userId));
+
+        if (height != UNSPECIFIED_DIMENSION) {
+            builder.appendQueryParameter(HEIGHT_PARAM, String.valueOf(height));
+        }
+
+        if (width != UNSPECIFIED_DIMENSION) {
+            builder.appendQueryParameter(WIDTH_PARAM, String.valueOf(width));
+        }
+
+        builder.appendQueryParameter(MIGRATION_PARAM, MIGRATION_VALUE);
+
+        return new URL(builder.toString());
+    }
+
+    private ImageRequest(Builder builder) {
+        this.context = builder.context;
+        this.imageUrl = builder.imageUrl;
+        this.callback = builder.callback;
+        this.allowCachedRedirects = builder.allowCachedRedirects;
+        this.callerTag = builder.callerTag == null ? new Object() : builder.callerTag;
+    }
+
+    Context getContext() {
+        return context;
+    }
+
+    URL getImageUrl() {
+        return imageUrl;
+    }
+
+    Callback getCallback() {
+        return callback;
+    }
+
+    boolean isCachedRedirectAllowed() {
+        return allowCachedRedirects;
+    }
+
+    Object getCallerTag() {
+        return callerTag;
+    }
+
+    static class Builder {
+        // Required
+        private Context context;
+        private URL imageUrl;
+
+        // Optional
+        private Callback callback;
+        private boolean allowCachedRedirects;
+        private Object callerTag;
+
+        Builder(Context context, URL imageUrl) {
+            Validate.notNull(imageUrl, "imageUrl");
+            this.context = context;
+            this.imageUrl = imageUrl;
+        }
+
+        Builder setCallback(Callback callback) {
+            this.callback = callback;
+            return this;
+        }
+
+        Builder setCallerTag(Object callerTag) {
+            this.callerTag = callerTag;
+            return this;
+        }
+
+        Builder setAllowCachedRedirects(boolean allowCachedRedirects) {
+            this.allowCachedRedirects = allowCachedRedirects;
+            return this;
+        }
+
+        ImageRequest build() {
+            return new ImageRequest(this);
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/ImageResponse.java b/facebook/src/com/facebook/widget/ImageResponse.java
similarity index 52%
rename from facebook/src/com/facebook/ImageResponse.java
rename to facebook/src/com/facebook/widget/ImageResponse.java
index 040455837..98c52e8b8 100644
--- a/facebook/src/com/facebook/ImageResponse.java
+++ b/facebook/src/com/facebook/widget/ImageResponse.java
@@ -1,4 +1,20 @@
-package com.facebook;
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
 
 import android.graphics.Bitmap;
 
diff --git a/facebook/src/com/facebook/widget/ImageResponseCache.java b/facebook/src/com/facebook/widget/ImageResponseCache.java
new file mode 100644
index 000000000..05799e53a
--- /dev/null
+++ b/facebook/src/com/facebook/widget/ImageResponseCache.java
@@ -0,0 +1,113 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.content.Context;
+import android.util.Log;
+import com.facebook.internal.Logger;
+import com.facebook.LoggingBehavior;
+import com.facebook.internal.Utility;
+import com.facebook.internal.FileLruCache;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+
+class ImageResponseCache {
+    static final String TAG = ImageResponseCache.class.getSimpleName();
+
+    private volatile static FileLruCache imageCache;
+
+    synchronized static FileLruCache getCache(Context context) throws IOException{
+        if (imageCache == null) {
+            imageCache = new FileLruCache(context.getApplicationContext(), TAG, new FileLruCache.Limits());
+        }
+        return imageCache;
+    }
+
+    // Get stream from cache, or return null if the image is not cached.
+    // Does not throw if there was an error.
+    static InputStream getCachedImageStream(URL url, Context context) {
+        InputStream imageStream = null;
+        if (url != null) {
+            if (isCDNURL(url)) {
+                try {
+                    FileLruCache cache = getCache(context);
+                    imageStream = cache.get(url.toString());
+                } catch (IOException e) {
+                    Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, e.toString());
+                }
+            }
+        }
+
+        return imageStream;
+    }
+
+    static InputStream interceptAndCacheImageStream(Context context, HttpURLConnection connection) throws IOException {
+        InputStream stream = null;
+        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {
+            URL url = connection.getURL();
+            stream = connection.getInputStream(); // Default stream in case caching fails
+            if (isCDNURL(url)) {
+                try {
+                    FileLruCache cache = getCache(context);
+
+                    // Wrap stream with a caching stream
+                    stream = cache.interceptAndPut(
+                            url.toString(),
+                            new BufferedHttpInputStream(stream, connection));
+                } catch (IOException e) {
+                    // Caching is best effort
+                }
+            }
+        }
+        return stream;
+    }
+
+   private static boolean isCDNURL(URL url) {
+        if (url != null) {
+            String uriHost = url.getHost();
+
+            if (uriHost.endsWith("fbcdn.net")) {
+                return true;
+            }
+
+            if (uriHost.startsWith("fbcdn") && uriHost.endsWith("akamaihd.net")) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private static class BufferedHttpInputStream extends BufferedInputStream {
+        HttpURLConnection connection;
+        BufferedHttpInputStream(InputStream stream, HttpURLConnection connection) {
+            super(stream, Utility.DEFAULT_STREAM_BUFFER_SIZE);
+            this.connection = connection;
+        }
+
+        @Override
+        public void close() throws IOException {
+            super.close();
+            Utility.disconnectQuietly(connection);
+        }
+    }
+}
+
diff --git a/facebook/src/com/facebook/LoginButton.java b/facebook/src/com/facebook/widget/LoginButton.java
similarity index 62%
rename from facebook/src/com/facebook/LoginButton.java
rename to facebook/src/com/facebook/widget/LoginButton.java
index 0b9b85430..ea65d0a81 100644
--- a/facebook/src/com/facebook/LoginButton.java
+++ b/facebook/src/com/facebook/widget/LoginButton.java
@@ -13,7 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.facebook;
+
+package com.facebook.widget;
 
 import android.app.Activity;
 import android.app.AlertDialog;
@@ -28,7 +29,12 @@
 import android.view.Gravity;
 import android.view.View;
 import android.widget.Button;
+import com.facebook.*;
 import com.facebook.android.R;
+import com.facebook.model.GraphUser;
+import com.facebook.internal.SessionAuthorizationType;
+import com.facebook.internal.SessionTracker;
+import com.facebook.internal.Utility;
 
 import java.util.Collections;
 import java.util.List;
@@ -40,15 +46,13 @@
  * This control will create and use the active session upon construction
  * if it has the available data (if the app ID is specified in the manifest).
  * It will also open the active session if it does not require user interaction
- * (i.e. if the session is in the {@link SessionState#CREATED_TOKEN_LOADED} state.
+ * (i.e. if the session is in the {@link com.facebook.SessionState#CREATED_TOKEN_LOADED} state.
  * Developers can override the use of the active session by calling
- * the {@link #setSession(Session)} method.
+ * the {@link #setSession(com.facebook.Session)} method.
  */
 public class LoginButton extends Button {
 
     private static final String TAG = LoginButton.class.getName();
-    private List<String> permissions = Collections.<String>emptyList();
-    private Session.AuthorizationType authorizationType = null;
     private String applicationId = null;
     private SessionTracker sessionTracker;
     private GraphUser user = null;
@@ -59,7 +63,95 @@
     private String logoutText;
     private UserInfoChangedCallback userInfoChangedCallback;
     private Fragment parentFragment;
-    private OnErrorListener onErrorListener;
+    private LoginButtonProperties properties = new LoginButtonProperties();
+
+    static class LoginButtonProperties {
+        private SessionDefaultAudience defaultAudience = SessionDefaultAudience.FRIENDS;
+        private List<String> permissions = Collections.<String>emptyList();
+        private SessionAuthorizationType authorizationType = null;
+        private OnErrorListener onErrorListener;
+        private SessionLoginBehavior loginBehavior = SessionLoginBehavior.SSO_WITH_FALLBACK;
+        private Session.StatusCallback sessionStatusCallback;
+
+        public void setOnErrorListener(OnErrorListener onErrorListener) {
+            this.onErrorListener = onErrorListener;
+        }
+
+        public OnErrorListener getOnErrorListener() {
+            return onErrorListener;
+        }
+
+        public void setDefaultAudience(SessionDefaultAudience defaultAudience) {
+            this.defaultAudience = defaultAudience;
+        }
+
+        public SessionDefaultAudience getDefaultAudience() {
+            return defaultAudience;
+        }
+
+        public void setReadPermissions(List<String> permissions, Session session) {
+            if (SessionAuthorizationType.PUBLISH.equals(authorizationType)) {
+                throw new UnsupportedOperationException(
+                        "Cannot call setReadPermissions after setPublishPermissions has been called.");
+            }
+            if (validatePermissions(permissions, SessionAuthorizationType.READ, session)) {
+                this.permissions = permissions;
+                authorizationType = SessionAuthorizationType.READ;
+            }
+        }
+
+        public void setPublishPermissions(List<String> permissions, Session session) {
+            if (SessionAuthorizationType.READ.equals(authorizationType)) {
+                throw new UnsupportedOperationException(
+                        "Cannot call setPublishPermissions after setReadPermissions has been called.");
+            }
+            if (validatePermissions(permissions, SessionAuthorizationType.PUBLISH, session)) {
+                this.permissions = permissions;
+                authorizationType = SessionAuthorizationType.PUBLISH;
+            }
+        }
+
+        private boolean validatePermissions(List<String> permissions,
+                SessionAuthorizationType authType, Session currentSession) {
+            if (SessionAuthorizationType.PUBLISH.equals(authType)) {
+                if (Utility.isNullOrEmpty(permissions)) {
+                    throw new IllegalArgumentException("Permissions for publish actions cannot be null or empty.");
+                }
+            }
+            if (currentSession != null && currentSession.isOpened()) {
+                if (!Utility.isSubset(permissions, currentSession.getPermissions())) {
+                    Log.e(TAG, "Cannot set additional permissions when session is already open.");
+                    return false;
+                }
+            }
+            return true;
+        }
+
+        List<String> getPermissions() {
+            return permissions;
+        }
+
+        public void clearPermissions() {
+            permissions = null;
+            authorizationType = null;
+        }
+
+        public void setLoginBehavior(SessionLoginBehavior loginBehavior) {
+            this.loginBehavior = loginBehavior;
+        }
+
+        public SessionLoginBehavior getLoginBehavior() {
+            return loginBehavior;
+        }
+
+        public void setSessionStatusCallback(Session.StatusCallback callback) {
+            this.sessionStatusCallback = callback;
+        }
+
+        public Session.StatusCallback getSessionStatusCallback() {
+            return sessionStatusCallback;
+        }
+    }
 
     /**
      * Specifies a callback interface that will be called when the button's notion of the current
@@ -87,7 +179,7 @@
 
     /**
      * Create the LoginButton.
-     * 
+     *
      * @see View#View(Context)
      */
     public LoginButton(Context context) {
@@ -96,36 +188,47 @@ public LoginButton(Context context) {
         // since onFinishInflate won't be called, we need to finish initialization ourselves
         finishInit();
     }
-    
+
     /**
      * Create the LoginButton by inflating from XML
-     * 
+     *
      * @see View#View(Context, AttributeSet)
      */
     public LoginButton(Context context, AttributeSet attrs) {
         super(context, attrs);
+
         if (attrs.getStyleAttribute() == 0) {
-            // apparently there's no method of setting a default style in xml,
-            // so in case the users do not explicitly specify a style, we need 
-            // to use sensible defaults.
-            this.setBackgroundResource(R.drawable.com_facebook_loginbutton_blue);
-            this.setTextColor(getResources().getColor(R.color.com_facebook_loginview_text_color));
-            this.setTextSize(TypedValue.COMPLEX_UNIT_PX, getResources().getDimension(R.dimen.com_facebook_loginview_text_size));
-            this.setPadding(getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_left),
-                            getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_top),
-                            getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_right),
-                            getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_bottom));
-            this.setWidth(getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_width));
-            this.setHeight(getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_height));
-            this.setGravity(Gravity.CENTER);
+                // apparently there's no method of setting a default style in xml,
+                // so in case the users do not explicitly specify a style, we need
+                // to use sensible defaults.
+                this.setTextColor(getResources().getColor(R.color.com_facebook_loginview_text_color));
+                this.setTextSize(TypedValue.COMPLEX_UNIT_PX,
+                        getResources().getDimension(R.dimen.com_facebook_loginview_text_size));
+                this.setPadding(getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_left),
+                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_top),
+                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_right),
+                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_bottom));
+                this.setWidth(getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_width));
+                this.setHeight(getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_height));
+                this.setGravity(Gravity.CENTER);
+
+            parseAttributes(attrs);
+            if(isInEditMode()) {
+                // cannot use a drawable in edit mode, so setting the background color instead
+                // of a background resource.
+                this.setBackgroundColor(getResources().getColor(R.color.com_facebook_blue));
+                // hardcoding in edit mode as getResources().getString() doesn't seem to work in IntelliJ
+                loginText = "Log in";
+            } else {
+                this.setBackgroundResource(R.drawable.com_facebook_loginbutton_blue);
+                initializeActiveSessionWithCachedToken(context);
+            }
         }
-        parseAttributes(attrs);
-        initializeActiveSessionWithCachedToken(context);
     }
 
     /**
      * Create the LoginButton by inflating from XML and applying a style.
-     * 
+     *
      * @see View#View(Context, AttributeSet, int)
      */
     public LoginButton(Context context, AttributeSet attrs, int defStyle) {
@@ -141,7 +244,7 @@ public LoginButton(Context context, AttributeSet attrs, int defStyle) {
      * @param onErrorListener The listener object to set
      */
     public void setOnErrorListener(OnErrorListener onErrorListener) {
-        this.onErrorListener = onErrorListener;
+        properties.setOnErrorListener(onErrorListener);
     }
 
     /**
@@ -150,9 +253,31 @@ public void setOnErrorListener(OnErrorListener onErrorListener) {
      * @return The OnErrorListener
      */
     public OnErrorListener getOnErrorListener() {
-        return onErrorListener;
+        return properties.getOnErrorListener();
+    }
+
+    /**
+     * Sets the default audience to use when the session is opened.
+     * This value is only useful when specifying write permissions for the native
+     * login dialog.
+     *
+     * @param defaultAudience the default audience value to use
+     */
+    public void setDefaultAudience(SessionDefaultAudience defaultAudience) {
+        properties.setDefaultAudience(defaultAudience);
+    }
+
+    /**
+     * Gets the default audience to use when the session is opened.
+     * This value is only useful when specifying write permissions for the native
+     * login dialog.
+     *
+     * @return the default audience value to use
+     */
+    public SessionDefaultAudience getDefaultAudience() {
+        return properties.getDefaultAudience();
     }
-    
+
     /**
      * Set the permissions to use when the session is opened. The permissions here
      * can only be read permissions. If any publish permissions are included, the login
@@ -169,20 +294,13 @@ public OnErrorListener getOnErrorListener() {
      * it's important to always pass in a consistent set of permissions to this method, or
      * manage the setting of permissions outside of the LoginButton class altogether
      * (by managing the session explicitly).
-     * 
+     *
      * @param permissions the read permissions to use
      *
      * @throws UnsupportedOperationException if setPublishPermissions has been called
      */
     public void setReadPermissions(List<String> permissions) {
-        if (Session.AuthorizationType.PUBLISH.equals(authorizationType)) {
-            throw new UnsupportedOperationException(
-                    "Cannot call setReadPermissions after setPublishPermissions has been called.");
-        }
-        if (validatePermissions(permissions, Session.AuthorizationType.READ)) {
-            this.permissions = permissions;
-            authorizationType = Session.AuthorizationType.READ;
-        }
+        properties.setReadPermissions(permissions, sessionTracker.getSession());
     }
 
     /**
@@ -208,42 +326,46 @@ public void setReadPermissions(List<String> permissions) {
      * @throws IllegalArgumentException if permissions is null or empty
      */
     public void setPublishPermissions(List<String> permissions) {
-        if (Session.AuthorizationType.READ.equals(authorizationType)) {
-            throw new UnsupportedOperationException(
-                    "Cannot call setPublishPermissions after setReadPermissions has been called.");
-        }
-        if (validatePermissions(permissions, Session.AuthorizationType.PUBLISH)) {
-            this.permissions = permissions;
-            authorizationType = Session.AuthorizationType.PUBLISH;
-        }
+        properties.setPublishPermissions(permissions, sessionTracker.getSession());
     }
 
-    private boolean validatePermissions(List<String> permissions, Session.AuthorizationType authType) {
-        if (Session.AuthorizationType.PUBLISH.equals(authType)) {
-            if (Utility.isNullOrEmpty(permissions)) {
-                throw new IllegalArgumentException("Permissions for publish actions cannot be null or empty.");
-            }
-        }
-        Session openSession = sessionTracker.getOpenSession();
-        if (openSession != null) {
-            if (!Utility.isSubset(permissions, openSession.getPermissions())) {
-                Log.e(TAG, "Cannot set additional permissions when session is already open.");
-                return false;
-            }
-        }
-        return true;
-    }
+
     /**
      * Clears the permissions currently associated with this LoginButton.
      */
     public void clearPermissions() {
-        permissions = null;
-        authorizationType = null;
+        properties.clearPermissions();
+    }
+
+    /**
+     * Sets the login behavior for the session that will be opened. If null is specified,
+     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
+     * will be used.
+     *
+     * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
+     *                      specifies what behaviors should be attempted during
+     *                      authorization.
+     */
+    public void setLoginBehavior(SessionLoginBehavior loginBehavior) {
+        properties.setLoginBehavior(loginBehavior);
+    }
+
+    /**
+     * Gets the login behavior for the session that will be opened. If null is returned,
+     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
+     * will be used.
+     *
+     * @return loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
+     *                      specifies what behaviors should be attempted during
+     *                      authorization.
+     */
+    public SessionLoginBehavior getLoginBehavior() {
+        return properties.getLoginBehavior();
     }
 
     /**
      * Set the application ID to be used to open the session.
-     * 
+     *
      * @param applicationId the application ID to use
      */
     public void setApplicationId(String applicationId) {
@@ -267,6 +389,27 @@ public void setUserInfoChangedCallback(UserInfoChangedCallback userInfoChangedCa
         this.userInfoChangedCallback = userInfoChangedCallback;
     }
 
+    /**
+     * Sets the callback interface that will be called whenever the status of the Session
+     * associated with this LoginButton changes. Note that updates will only be sent to the
+     * callback while the LoginButton is actually attached to a window.
+     *
+     * @param callback the callback interface
+     */
+    public void setSessionStatusCallback(Session.StatusCallback callback) {
+        properties.setSessionStatusCallback(callback);
+    }
+
+    /**
+     * Sets the callback interface that will be called whenever the status of the Session
+     * associated with this LoginButton changes.
+
+     * @return the callback interface
+     */
+    public Session.StatusCallback getSessionStatusCallback() {
+        return properties.getSessionStatusCallback();
+    }
+
     /**
      * Provides an implementation for {@link Activity#onActivityResult
      * onActivityResult} that updates the Session based on information returned
@@ -274,10 +417,10 @@ public void setUserInfoChangedCallback(UserInfoChangedCallback userInfoChangedCa
      * should forward the resulting onActivityResult call here to
      * update the Session state based on the contents of the resultCode and
      * data.
-     * 
+     *
      * @param requestCode
      *            The requestCode parameter from the forwarded call. When this
-     *            onActivityResult occurs as part of facebook authorization
+     *            onActivityResult occurs as part of Facebook authorization
      *            flow, this value is the activityCode passed to open or
      *            authorize.
      * @param resultCode
@@ -299,7 +442,7 @@ public boolean onActivityResult(int requestCode, int resultCode, Intent data) {
             return false;
         }
     }
-    
+
     /**
      * Set the Session object to use instead of the active Session. Since a Session
      * cannot be reused, if the user logs out from this Session, and tries to
@@ -307,7 +450,7 @@ public boolean onActivityResult(int requestCode, int resultCode, Intent data) {
      * <p/>
      * If the passed in session is currently opened, this method will also attempt to
      * load some user information for display (if needed).
-     * 
+     *
      * @param newSession the Session object to use
      * @throws FacebookException if errors occur during the loading of user information
      */
@@ -324,10 +467,12 @@ public void onFinishInflate() {
     }
 
     private void finishInit() {
-        sessionTracker = new SessionTracker(getContext(), new LoginButtonCallback(), null, false);
         setOnClickListener(new LoginClickListener());
         setButtonText();
-        fetchUserInfo();
+        if (!isInEditMode()) {
+            sessionTracker = new SessionTracker(getContext(), new LoginButtonCallback(), null, false);
+            fetchUserInfo();
+        }
     }
 
     /**
@@ -345,7 +490,7 @@ public void setFragment(Fragment fragment) {
     @Override
     protected void onAttachedToWindow() {
         super.onAttachedToWindow();
-        if (!sessionTracker.isTracking()) {
+        if (sessionTracker != null && !sessionTracker.isTracking()) {
             sessionTracker.startTracking();
             fetchUserInfo();
             setButtonText();
@@ -355,12 +500,18 @@ protected void onAttachedToWindow() {
     @Override
     protected void onDetachedFromWindow() {
         super.onDetachedFromWindow();
-        sessionTracker.stopTracking();
+        if (sessionTracker != null) {
+            sessionTracker.stopTracking();
+        }
     }
 
     // For testing purposes only
     List<String> getPermissions() {
-        return permissions;
+        return properties.getPermissions();
+    }
+
+    void setProperties(LoginButtonProperties properties) {
+        this.properties = properties;
     }
 
     private void parseAttributes(AttributeSet attrs) {
@@ -370,16 +521,15 @@ private void parseAttributes(AttributeSet attrs) {
         loginText = a.getString(R.styleable.com_facebook_login_view_login_text);
         logoutText = a.getString(R.styleable.com_facebook_login_view_logout_text);
         a.recycle();
-
     }
-   
+
     private void setButtonText() {
-        if (sessionTracker.getOpenSession() != null) {
+        if (sessionTracker != null && sessionTracker.getOpenSession() != null) {
             setText((logoutText != null) ? logoutText :
-                getResources().getString(R.string.com_facebook_loginview_log_out_button));
+                    getResources().getString(R.string.com_facebook_loginview_log_out_button));
         } else {
-            setText((loginText != null) ? loginText : 
-                getResources().getString(R.string.com_facebook_loginview_log_in_button));
+            setText((loginText != null) ? loginText :
+                    getResources().getString(R.string.com_facebook_loginview_log_in_button));
         }
     }
 
@@ -393,19 +543,12 @@ private boolean initializeActiveSessionWithCachedToken(Context context) {
             return session.isOpened();
         }
 
-        String applicationId = Session.getMetadataApplicationId(context);
+        String applicationId = Utility.getMetadataApplicationId(context);
         if (applicationId == null) {
             return false;
         }
 
-        session = new Session(context);
-        if (session.getState() != SessionState.CREATED_TOKEN_LOADED) {
-            return false;
-        }
-
-        Session.setActiveSession(session);
-        session.open();
-        return true;
+        return Session.openActiveSessionFromCache(context) != null;
     }
 
     private void fetchUserInfo() {
@@ -423,7 +566,7 @@ public void onCompleted(GraphUser me,  Response response) {
                                 }
                             }
                             if (response.getError() != null) {
-                                handleError(response.getError());
+                                handleError(response.getError().getException());
                             }
                         }
                     });
@@ -487,9 +630,11 @@ public void onClick(DialogInterface dialog, int which) {
                     }
 
                     if (openRequest != null) {
-                        openRequest.setPermissions(permissions);
+                        openRequest.setDefaultAudience(properties.defaultAudience);
+                        openRequest.setPermissions(properties.permissions);
+                        openRequest.setLoginBehavior(properties.loginBehavior);
 
-                        if (Session.AuthorizationType.PUBLISH.equals(authorizationType)) {
+                        if (SessionAuthorizationType.PUBLISH.equals(properties.authorizationType)) {
                             currentSession.openForPublish(openRequest);
                         } else {
                             currentSession.openForRead(openRequest);
@@ -509,15 +654,19 @@ public void call(Session session, SessionState state,
             if (exception != null) {
                 handleError(exception);
             }
+
+            if (properties.sessionStatusCallback != null) {
+                properties.sessionStatusCallback.call(session, state, exception);
+            }
         }
     };
 
     void handleError(Exception exception) {
-        if (onErrorListener != null) {
+        if (properties.onErrorListener != null) {
             if (exception instanceof FacebookException) {
-                onErrorListener.onError((FacebookException)exception);
+                properties.onErrorListener.onError((FacebookException)exception);
             } else {
-                onErrorListener.onError(new FacebookException(exception));
+                properties.onErrorListener.onError(new FacebookException(exception));
             }
         }
     }
diff --git a/facebook/src/com/facebook/GraphObjectListFragment.java b/facebook/src/com/facebook/widget/PickerFragment.java
similarity index 63%
rename from facebook/src/com/facebook/GraphObjectListFragment.java
rename to facebook/src/com/facebook/widget/PickerFragment.java
index 4b3e2eacb..bea02692f 100644
--- a/facebook/src/com/facebook/GraphObjectListFragment.java
+++ b/facebook/src/com/facebook/widget/PickerFragment.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.widget;
 
 import android.app.Activity;
 import android.content.Context;
@@ -30,14 +30,55 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewStub;
+import android.view.animation.AlphaAnimation;
 import android.widget.*;
+import com.facebook.*;
 import com.facebook.android.R;
+import com.facebook.model.GraphObject;
+import com.facebook.internal.SessionTracker;
 
 import java.util.*;
 
-abstract class GraphObjectListFragment<T extends GraphObject> extends Fragment
-        implements PickerFragment<T>, LoaderManager.LoaderCallbacks<SimpleGraphObjectCursor<T>> {
-    private static final String SELECTION_BUNDLE_KEY = "com.facebook.android.GraphObjectListFragment.Selection";
+/**
+ * Provides functionality common to SDK UI elements that allow the user to pick one or more
+ * graph objects (e.g., places, friends) from a list of possibilities. The UI is exposed as a
+ * Fragment to allow to it to be included in an Activity along with other Fragments. The Fragments
+ * can be configured by passing parameters as part of their Intent bundle, or (for certain
+ * properties) by specifying attributes in their XML layout files.
+ * <br/>
+ * PickerFragments support callbacks that will be called in the event of an error, when the
+ * underlying data has been changed, or when the set of selected graph objects changes.
+ */
+public abstract class PickerFragment<T extends GraphObject> extends Fragment {
+    /**
+     * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
+     * picker should show pictures (if available) for the graph objects.
+     */
+    public static final String SHOW_PICTURES_BUNDLE_KEY = "com.facebook.widget.PickerFragment.ShowPictures";
+    /**
+     * The key for a String parameter in the fragment's Intent bundle to indicate which extra fields
+     * beyond the default fields should be retrieved for any graph objects in the results.
+     */
+    public static final String EXTRA_FIELDS_BUNDLE_KEY = "com.facebook.widget.PickerFragment.ExtraFields";
+    /**
+     * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
+     * picker should display a title bar with a Done button.
+     */
+    public static final String SHOW_TITLE_BAR_BUNDLE_KEY = "com.facebook.widget.PickerFragment.ShowTitleBar";
+    /**
+     * The key for a String parameter in the fragment's Intent bundle to indicate the text to
+     * display in the title bar.
+     */
+    public static final String TITLE_TEXT_BUNDLE_KEY = "com.facebook.widget.PickerFragment.TitleText";
+    /**
+     * The key for a String parameter in the fragment's Intent bundle to indicate the text to
+     * display in the Done btuton.
+     */
+    public static final String DONE_BUTTON_TEXT_BUNDLE_KEY = "com.facebook.widget.PickerFragment.DoneButtonText";
+
+    private static final String SELECTION_BUNDLE_KEY = "com.facebook.android.PickerFragment.Selection";
+    private static final String ACTIVITY_CIRCLE_SHOW_KEY = "com.facebook.android.PickerFragment.ActivityCircleShown";
+    private static final int PROFILE_PICTURE_PREFETCH_BUFFER = 5;
 
     private final int layout;
     private OnErrorListener onErrorListener;
@@ -62,11 +103,11 @@
     private Drawable titleBarBackground;
     private Drawable doneButtonBackground;
 
-    GraphObjectListFragment(Class<T> graphObjectClass, int layout, Bundle args) {
+    PickerFragment(Class<T> graphObjectClass, int layout, Bundle args) {
         this.graphObjectClass = graphObjectClass;
         this.layout = layout;
 
-        setGraphObjectListFragmentSettingsFromBundle(args);
+        setPickerFragmentSettingsFromBundle(args);
     }
 
     @Override
@@ -157,6 +198,16 @@ public void call(Session session, SessionState state, Exception exception) {
         if (showTitleBar) {
             inflateTitleBar((ViewGroup) getView());
         }
+
+        if (activityCircle != null && savedInstanceState != null) {
+            boolean shown = savedInstanceState.getBoolean(ACTIVITY_CIRCLE_SHOW_KEY, false);
+            if (shown) {
+                displayActivityCircle();
+            } else {
+                // Should be hidden already, but just to be sure.
+                hideActivityCircle();
+            }
+        }
     }
 
     @Override
@@ -176,6 +227,9 @@ public void onSaveInstanceState(Bundle outState) {
 
         saveSettingsToBundle(outState);
         selectionStrategy.saveSelectionToBundle(outState, SELECTION_BUNDLE_KEY);
+        if (activityCircle != null) {
+            outState.putBoolean(ACTIVITY_CIRCLE_SHOW_KEY, activityCircle.getVisibility() == View.VISIBLE);
+        }
     }
 
     @Override
@@ -184,81 +238,161 @@ public void setArguments(Bundle args) {
         setSettingsFromBundle(args);
     }
 
-    @Override
+    /**
+     * Gets the current OnDataChangedListener for this fragment, which will be called whenever
+     * the underlying data being displaying in the picker has changed.
+     *
+     * @return the OnDataChangedListener, or null if there is none
+     */
     public OnDataChangedListener getOnDataChangedListener() {
         return onDataChangedListener;
     }
 
-    @Override
+    /**
+     * Sets the current OnDataChangedListener for this fragment, which will be called whenever
+     * the underlying data being displaying in the picker has changed.
+     *
+     * @param onDataChangedListener the OnDataChangedListener, or null if there is none
+     */
     public void setOnDataChangedListener(OnDataChangedListener onDataChangedListener) {
         this.onDataChangedListener = onDataChangedListener;
     }
 
-    @Override
+    /**
+     * Gets the current OnSelectionChangedListener for this fragment, which will be called
+     * whenever the user selects or unselects a graph object in the list.
+     *
+     * @return the OnSelectionChangedListener, or null if there is none
+     */
     public OnSelectionChangedListener getOnSelectionChangedListener() {
         return onSelectionChangedListener;
     }
 
-    @Override
+    /**
+     * Sets the current OnSelectionChangedListener for this fragment, which will be called
+     * whenever the user selects or unselects a graph object in the list.
+     *
+     * @param onSelectionChangedListener the OnSelectionChangedListener, or null if there is none
+     */
     public void setOnSelectionChangedListener(
             OnSelectionChangedListener onSelectionChangedListener) {
         this.onSelectionChangedListener = onSelectionChangedListener;
     }
 
-    @Override
+    /**
+     * Gets the current OnDoneButtonClickedListener for this fragment, which will be called
+     * when the user clicks the Done button.
+     *
+     * @return the OnDoneButtonClickedListener, or null if there is none
+     */
     public OnDoneButtonClickedListener getOnDoneButtonClickedListener() {
         return onDoneButtonClickedListener;
     }
 
-    @Override
+    /**
+     * Sets the current OnDoneButtonClickedListener for this fragment, which will be called
+     * when the user clicks the Done button. This will only be possible if the title bar is
+     * being shown in this fragment.
+     *
+     * @param onDoneButtonClickedListener the OnDoneButtonClickedListener, or null if there is none
+     */
     public void setOnDoneButtonClickedListener(OnDoneButtonClickedListener onDoneButtonClickedListener) {
         this.onDoneButtonClickedListener = onDoneButtonClickedListener;
     }
 
-    @Override
+    /**
+     * Gets the current OnErrorListener for this fragment, which will be called in the event
+     * of network or other errors encountered while populating the graph objects in the list.
+     *
+     * @return the OnErrorListener, or null if there is none
+     */
     public OnErrorListener getOnErrorListener() {
         return onErrorListener;
     }
 
-    @Override
+    /**
+     * Sets the current OnErrorListener for this fragment, which will be called in the event
+     * of network or other errors encountered while populating the graph objects in the list.
+     *
+     * @param onErrorListener the OnErrorListener, or null if there is none
+     */
     public void setOnErrorListener(OnErrorListener onErrorListener) {
         this.onErrorListener = onErrorListener;
     }
 
-    @Override
+    /**
+     * Gets the current filter for this fragment, which will be called for each graph object
+     * returned from the service to determine if it should be displayed in the list.
+     * If no filter is specified, all retrieved graph objects will be displayed.
+     *
+     * @return the GraphObjectFilter, or null if there is none
+     */
     public GraphObjectFilter<T> getFilter() {
         return filter;
     }
 
-    @Override
+    /**
+     * Sets the current filter for this fragment, which will be called for each graph object
+     * returned from the service to determine if it should be displayed in the list.
+     * If no filter is specified, all retrieved graph objects will be displayed.
+     *
+     * @param filter the GraphObjectFilter, or null if there is none
+     */
     public void setFilter(GraphObjectFilter<T> filter) {
         this.filter = filter;
     }
 
-    @Override
+    /**
+     * Gets the Session to use for any Facebook requests this fragment will make.
+     *
+     * @return the Session that will be used for any Facebook requests, or null if there is none
+     */
     public Session getSession() {
         return sessionTracker.getSession();
     }
 
-    @Override
+    /**
+     * Sets the Session to use for any Facebook requests this fragment will make. If the
+     * parameter is null, the fragment will use the current active session, if any.
+     *
+     * @param session the Session to use for Facebook requests, or null to use the active session
+     */
     public void setSession(Session session) {
         sessionTracker.setSession(session);
     }
 
-    @Override
+    /**
+     * Gets whether to display pictures, if available, for displayed graph objects.
+     *
+     * @return true if pictures should be displayed, false if not
+     */
     public boolean getShowPictures() {
         return showPictures;
     }
 
-    @Override
+    /**
+     * Sets whether to display pictures, if available, for displayed graph objects.
+     *
+     * @param showPictures true if pictures should be displayed, false if not
+     */
     public void setShowPictures(boolean showPictures) {
         this.showPictures = showPictures;
     }
 
+    /**
+     * Gets the extra fields to request for the retrieved graph objects.
+     *
+     * @return the extra fields to request
+     */
     public Set<String> getExtraFields() {
         return new HashSet<String>(extraFields);
     }
 
+    /**
+     * Sets the extra fields to request for the retrieved graph objects.
+     *
+     * @param fields the extra fields to request
+     */
     public void setExtraFields(Collection<String> fields) {
         extraFields = new HashSet<String>();
         if (fields != null) {
@@ -266,35 +400,93 @@ public void setExtraFields(Collection<String> fields) {
         }
     }
 
-    @Override
-    public void loadData(boolean forceReload) {
-        if (!forceReload && !adapter.isEmpty()) {
-            return;
-        }
+    /**
+     * Sets whether to show a title bar with a Done button. This must be
+     * called prior to the Fragment going through its creation lifecycle to have an effect.
+     *
+     * @param showTitleBar true if a title bar should be displayed, false if not
+     */
+    public void setShowTitleBar(boolean showTitleBar) {
+        this.showTitleBar = showTitleBar;
+    }
 
-        loadDataSkippingRoundTripIfCached();
+    /**
+     * Gets whether to show a title bar with a Done button. The default is true.
+     *
+     * @return true if a title bar will be shown, false if not.
+     */
+    public boolean getShowTitleBar() {
+        return showTitleBar;
     }
 
-    @Override
-    public void setSettingsFromBundle(Bundle inState) {
-        setGraphObjectListFragmentSettingsFromBundle(inState);
+    /**
+     * Sets the text to show in the title bar, if a title bar is to be shown. This must be
+     * called prior to the Fragment going through its creation lifecycle to have an effect, or
+     * the default will be used.
+     *
+     * @param titleText the text to show in the title bar
+     */
+    public void setTitleText(String titleText) {
+        this.titleText = titleText;
     }
 
-    @Override
-    public GraphObjectPagingLoader<T> onCreateLoader(int id, Bundle args) {
-        // This is called when a new Loader needs to be created.  This
-        // sample only has one Loader with no arguments, so it is simple.
-        return new GraphObjectPagingLoader<T>(getActivity(), graphObjectClass);
+    /**
+     * Gets the text to show in the title bar, if a title bar is to be shown.
+     *
+     * @return the text to show in the title bar
+     */
+    public String getTitleText() {
+        if (titleText == null) {
+            titleText = getDefaultTitleText();
+        }
+        return titleText;
     }
 
-    @Override
-    public void onLoaderReset(Loader<SimpleGraphObjectCursor<T>> loader) {
-        adapter.changeCursor(null);
+    /**
+     * Sets the text to show in the Done button, if a title bar is to be shown. This must be
+     * called prior to the Fragment going through its creation lifecycle to have an effect, or
+     * the default will be used.
+     *
+     * @param doneButtonText the text to show in the Done button
+     */
+    public void setDoneButtonText(String doneButtonText) {
+        this.doneButtonText = doneButtonText;
     }
 
-    @Override
-    public void onLoadFinished(Loader<SimpleGraphObjectCursor<T>> loader, SimpleGraphObjectCursor<T> data) {
-        adapter.changeCursor(data);
+    /**
+     * Gets the text to show in the Done button, if a title bar is to be shown.
+     *
+     * @return the text to show in the Done button
+     */
+    public String getDoneButtonText() {
+        if (doneButtonText == null) {
+            doneButtonText = getDefaultDoneButtonText();
+        }
+        return doneButtonText;
+    }
+
+    /**
+     * Causes the picker to load data from the service and display it to the user.
+     *
+     * @param forceReload if true, data will be loaded even if there is already data being displayed (or loading);
+     *                    if false, data will not be re-loaded if it is already displayed (or loading)
+     */
+    public void loadData(boolean forceReload) {
+        if (!forceReload && loadingStrategy.isDataPresentOrLoading()) {
+            return;
+        }
+        loadDataSkippingRoundTripIfCached();
+    }
+
+    /**
+     * Updates the properties of the PickerFragment based on the contents of the supplied Bundle;
+     * calling Activities may use this to pass additional configuration information to the
+     * PickerFragment beyond what is specified in its XML layout.
+     *
+     * @param inState a Bundle containing keys corresponding to properties of the PickerFragment
+     */
+    public void setSettingsFromBundle(Bundle inState) {
+        setPickerFragmentSettingsFromBundle(inState);
     }
 
     boolean filterIncludesItem(T graphObject) {
@@ -320,7 +512,7 @@ void saveSettingsToBundle(Bundle outState) {
 
     abstract Request getRequestForLoadData(Session session);
 
-    abstract GraphObjectListFragmentAdapter<T> createAdapter();
+    abstract PickerFragmentAdapter<T> createAdapter();
 
     abstract LoadingStrategy createLoadingStrategy();
 
@@ -348,7 +540,7 @@ void layoutActivityCircle() {
         // If we've got no data, make the activity circle full-opacity. Otherwise we'll dim it to avoid
         //  cluttering the UI.
         float alpha = (!adapter.isEmpty()) ? .25f : 1.0f;
-        Utility.setAlpha(activityCircle, alpha);
+        setAlpha(activityCircle, alpha);
     }
 
     void hideActivityCircle() {
@@ -369,7 +561,16 @@ void setSelectionStrategy(SelectionStrategy selectionStrategy) {
         }
     }
 
-    private void setGraphObjectListFragmentSettingsFromBundle(Bundle inState) {
+    private static void setAlpha(View view, float alpha) {
+        // Set the alpha appropriately (setAlpha is API >= 11, this technique works on all API levels).
+        AlphaAnimation alphaAnimation = new AlphaAnimation(alpha, alpha);
+        alphaAnimation.setDuration(0);
+        alphaAnimation.setFillAfter(true);
+        view.startAnimation(alphaAnimation);
+    }
+
+
+    private void setPickerFragmentSettingsFromBundle(Bundle inState) {
         // We do this in a separate non-overridable method so it is safe to call from the constructor.
         if (inState != null) {
             showPictures = inState.getBoolean(SHOW_PICTURES_BUNDLE_KEY, showPictures);
@@ -417,16 +618,13 @@ private void inflateTitleBar(ViewGroup view) {
                     @Override
                     public void onClick(View v) {
                         if (onDoneButtonClickedListener != null) {
-                            onDoneButtonClickedListener.onDoneButtonClicked();
+                            onDoneButtonClickedListener.onDoneButtonClicked(PickerFragment.this);
                         }
                     }
                 });
 
-                if (doneButtonText == null) {
-                    doneButtonText = getDefaultDoneButtonText();
-                }
-                if (doneButtonText != null) {
-                    doneButton.setText(doneButtonText);
+                if (getDoneButtonText() != null) {
+                    doneButton.setText(getDoneButtonText());
                 }
 
                 if (doneButtonBackground != null) {
@@ -436,11 +634,8 @@ public void onClick(View v) {
 
             titleTextView = (TextView) view.findViewById(R.id.com_facebook_picker_title);
             if (titleTextView != null) {
-                if (titleText == null) {
-                    titleText = getDefaultTitleText();
-                }
-                if (titleText != null) {
-                    titleTextView.setText(titleText);
+                if (getTitleText() != null) {
+                    titleTextView.setText(getTitleText());
                 }
             }
         }
@@ -454,7 +649,7 @@ private void onListItemClick(ListView listView, View v, int position) {
         adapter.notifyDataSetChanged();
 
         if (onSelectionChangedListener != null) {
-            onSelectionChangedListener.onSelectionChanged();
+            onSelectionChangedListener.onSelectionChanged(PickerFragment.this);
         }
     }
 
@@ -479,10 +674,10 @@ private void clearResults() {
 
             // Tell anyone who cares the data and selection has changed, if they have.
             if (wasData && onDataChangedListener != null) {
-                onDataChangedListener.onDataChanged();
+                onDataChangedListener.onDataChanged(PickerFragment.this);
             }
             if (wasSelection && onSelectionChangedListener != null) {
-                onSelectionChangedListener.onSelectionChanged();
+                onSelectionChangedListener.onSelectionChanged(PickerFragment.this);
             }
         }
     }
@@ -522,34 +717,91 @@ void updateAdapter(SimpleGraphObjectCursor<T> data) {
             }
 
             if (dataChanged && onDataChangedListener != null) {
-                onDataChangedListener.onDataChanged();
+                onDataChangedListener.onDataChanged(PickerFragment.this);
             }
         }
     }
 
     private void reprioritizeDownloads() {
-        int firstVisibleItem = listView.getFirstVisiblePosition();
         int lastVisibleItem = listView.getLastVisiblePosition();
-
         if (lastVisibleItem >= 0) {
-            int visibleItemCount = lastVisibleItem + 1 - firstVisibleItem;
-            adapter.prioritizeViewRange(firstVisibleItem, visibleItemCount);
+            int firstVisibleItem = listView.getFirstVisiblePosition();
+            adapter.prioritizeViewRange(firstVisibleItem, lastVisibleItem, PROFILE_PICTURE_PREFETCH_BUFFER);
         }
     }
 
     private ListView.OnScrollListener onScrollListener = new ListView.OnScrollListener() {
         @Override
         public void onScrollStateChanged(AbsListView view, int scrollState) {
-            if (scrollState == ListView.OnScrollListener.SCROLL_STATE_IDLE) {
-                reprioritizeDownloads();
-            }
         }
 
         @Override
         public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
+            reprioritizeDownloads();
         }
     };
 
+    /**
+     * Callback interface that will be called when a network or other error is encountered
+     * while retrieving graph objects.
+     */
+    public interface OnErrorListener {
+        /**
+         * Called when a network or other error is encountered.
+         *
+         * @param error a FacebookException representing the error that was encountered.
+         */
+        void onError(PickerFragment<?> fragment, FacebookException error);
+    }
+
+    /**
+     * Callback interface that will be called when the underlying data being displayed in the
+     * picker has been updated.
+     */
+    public interface OnDataChangedListener {
+        /**
+         * Called when the set of data being displayed in the picker has changed.
+         */
+        void onDataChanged(PickerFragment<?> fragment);
+    }
+
+    /**
+     * Callback interface that will be called when the user selects or unselects graph objects
+     * in the picker.
+     */
+    public interface OnSelectionChangedListener {
+        /**
+         * Called when the user selects or unselects graph objects in the picker.
+         */
+        void onSelectionChanged(PickerFragment<?> fragment);
+    }
+
+    /**
+     * Callback interface that will be called when the user clicks the Done button on the
+     * title bar.
+     */
+    public interface OnDoneButtonClickedListener {
+        /**
+         * Called when the user clicks the Done button.
+         */
+        void onDoneButtonClicked(PickerFragment<?> fragment);
+    }
+
+    /**
+     * Callback interface that will be called to determine if a graph object should be displayed.
+     *
+     * @param <T>
+     */
+    public interface GraphObjectFilter<T> {
+        /**
+         * Called to determine if a graph object should be displayed.
+         *
+         * @param graphObject the graph object
+         * @return true to display the graph object, false to hide it
+         */
+        boolean includeItem(T graphObject);
+    }
+
     abstract class LoadingStrategy {
         protected final static int CACHED_RESULT_REFRESH_DELAY = 2 * 1000;
 
@@ -587,7 +839,7 @@ public void onLoaderReset(Loader<SimpleGraphObjectCursor<T>> loader) {
                 public void onError(FacebookException error, GraphObjectPagingLoader<?> loader) {
                     hideActivityCircle();
                     if (onErrorListener != null) {
-                        onErrorListener.onError(error);
+                        onErrorListener.onError(PickerFragment.this, error);
                     }
                 }
             });
@@ -614,13 +866,22 @@ public void clearResults() {
         public void startLoading(Request request) {
             if (loader != null) {
                 loader.startLoading(request, true);
+                onStartLoading(loader, request);
             }
         }
 
+        public boolean isDataPresentOrLoading() {
+            return !adapter.isEmpty() || loader.isLoading();
+        }
+
         protected GraphObjectPagingLoader<T> onCreateLoader() {
             return new GraphObjectPagingLoader<T>(getActivity(), graphObjectClass);
         }
 
+        protected void onStartLoading(GraphObjectPagingLoader<T> loader, Request request) {
+            displayActivityCircle();
+        }
+
         protected void onLoadReset(GraphObjectPagingLoader<T> loader) {
             adapter.changeCursor(null);
         }
@@ -758,8 +1019,8 @@ boolean shouldShowCheckBoxIfUnselected() {
         }
     }
 
-    abstract class GraphObjectListFragmentAdapter<U extends GraphObject> extends GraphObjectAdapter<T> {
-        public GraphObjectListFragmentAdapter(Context context) {
+    abstract class PickerFragmentAdapter<U extends GraphObject> extends GraphObjectAdapter<T> {
+        public PickerFragmentAdapter(Context context) {
             super(context);
         }
 
@@ -771,8 +1032,9 @@ boolean isGraphObjectSelected(String graphObjectId) {
         @Override
         void updateCheckboxState(CheckBox checkBox, boolean graphObjectSelected) {
             checkBox.setChecked(graphObjectSelected);
-            checkBox.setVisibility(selectionStrategy.shouldShowCheckBoxIfUnselected() ?
-                    View.VISIBLE : View.GONE);
+            int visible = (graphObjectSelected || selectionStrategy
+                    .shouldShowCheckBoxIfUnselected()) ? View.VISIBLE : View.GONE;
+            checkBox.setVisibility(visible);
         }
     }
 }
diff --git a/facebook/src/com/facebook/PlacePickerFragment.java b/facebook/src/com/facebook/widget/PlacePickerFragment.java
similarity index 87%
rename from facebook/src/com/facebook/PlacePickerFragment.java
rename to facebook/src/com/facebook/widget/PlacePickerFragment.java
index 331dc4821..b08208c7f 100644
--- a/facebook/src/com/facebook/PlacePickerFragment.java
+++ b/facebook/src/com/facebook/widget/PlacePickerFragment.java
@@ -14,9 +14,10 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.widget;
 
 import android.app.Activity;
+import android.content.Context;
 import android.content.res.TypedArray;
 import android.location.Location;
 import android.os.Bundle;
@@ -28,39 +29,44 @@
 import android.util.AttributeSet;
 import android.view.ViewGroup;
 import android.view.ViewStub;
+import android.view.inputmethod.InputMethodManager;
 import android.widget.EditText;
 import android.widget.ListView;
 import android.widget.RelativeLayout;
+import com.facebook.*;
 import com.facebook.android.R;
+import com.facebook.model.GraphPlace;
+import com.facebook.internal.Logger;
+import com.facebook.internal.Utility;
 
 import java.util.*;
 
-public class PlacePickerFragment extends GraphObjectListFragment<GraphPlace> {
+public class PlacePickerFragment extends PickerFragment<GraphPlace> {
     /**
      * The key for an int parameter in the fragment's Intent bundle to indicate the radius in meters around
      * the center point to search. The default is 1000 meters.
      */
-    public static final String RADIUS_IN_METERS_BUNDLE_KEY = "com.facebook.PlacePickerFragment.RadiusInMeters";
+    public static final String RADIUS_IN_METERS_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.RadiusInMeters";
     /**
      * The key for an int parameter in the fragment's Intent bundle to indicate what how many results to
      * return at a time. The default is 100 results.
      */
-    public static final String RESULTS_LIMIT_BUNDLE_KEY = "com.facebook.PlacePickerFragment.ResultsLimit";
+    public static final String RESULTS_LIMIT_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.ResultsLimit";
     /**
      * The key for a String parameter in the fragment's Intent bundle to indicate what search text should
      * be sent to the service. The default is to have no search text.
      */
-    public static final String SEARCH_TEXT_BUNDLE_KEY = "com.facebook.PlacePickerFragment.SearchText";
+    public static final String SEARCH_TEXT_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.SearchText";
     /**
      * The key for a Location parameter in the fragment's Intent bundle to indicate what geographical
      * location should be the center of the search.
      */
-    public static final String LOCATION_BUNDLE_KEY = "com.facebook.PlacePickerFragment.Location";
+    public static final String LOCATION_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.Location";
     /**
      * The key for a boolean parameter in the fragment's Intent bundle to indicate that the fragment
      * should display a search box and automatically update the search text as it changes.
      */
-    public static final String SHOW_SEARCH_BOX_BUNDLE_KEY = "com.facebook.PlacePickerFragment.ShowSearchBox";
+    public static final String SHOW_SEARCH_BOX_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.ShowSearchBox";
 
     /**
      * The default radius around the center point to search.
@@ -173,7 +179,8 @@ public String getSearchText() {
 
     /**
      * Sets the search text (e.g., category, name) to search for. Either the location or the search
-     * text (or both) must be specified.
+     * text (or both) must be specified. If a search box is displayed, this will update its contents
+     * to the specified text.
      *
      * @param searchText the search text
      */
@@ -182,23 +189,32 @@ public void setSearchText(String searchText) {
             searchText = null;
         }
         this.searchText = searchText;
+        if (this.searchBox != null) {
+            this.searchBox.setText(searchText);
+        }
     }
 
     /**
      * Sets the search text and reloads the data in the control. This is used to provide search-box
      * functionality where the user may be typing or editing text rapidly. It uses a timer to avoid repeated
-     * requerying, preferring to wait until the user pauses typing to refresh the data.
+     * requerying, preferring to wait until the user pauses typing to refresh the data. Note that this
+     * method will NOT update the text in the search box, if any, as it is intended to be called as a result
+     * of changes to the search box (and is public to enable applications to provide their own search box
+     * UI instead of the default one).
      *
      * @param searchText                 the search text
      * @param forceReloadEventIfSameText if true, will reload even if the search text has not changed; if false,
      *                                   identical search text will not force a reload
      */
-    public void setSearchTextAndReload(String searchText, boolean forceReloadEventIfSameText) {
+    public void onSearchBoxTextChanged(String searchText, boolean forceReloadEventIfSameText) {
         if (!forceReloadEventIfSameText && Utility.stringsEqualOrEmpty(this.searchText, searchText)) {
             return;
         }
 
-        setSearchText(searchText);
+        if (TextUtils.isEmpty(searchText)) {
+            searchText = null;
+        }
+        this.searchText = searchText;
 
         // If search text is being set in response to user input, it is wasteful to send a new request
         // with every keystroke. Send a request the first time the search text is set, then set up a 2-second timer
@@ -270,10 +286,33 @@ public void onActivityCreated(final Bundle savedInstanceState) {
                 }
 
                 searchBox.addTextChangedListener(new SearchTextWatcher());
+                if (!TextUtils.isEmpty(searchText)) {
+                    searchBox.setText(searchText);
+                }
             }
         }
     }
 
+    @Override
+    public void onAttach(Activity activity) {
+        super.onAttach(activity);
+
+        if (searchBox != null) {
+            InputMethodManager imm = (InputMethodManager)getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);
+            imm.showSoftInput(searchBox, InputMethodManager.SHOW_IMPLICIT);
+        }
+    }
+
+    @Override
+    public void onDetach() {
+        super.onDetach();
+
+        if (searchBox != null) {
+            InputMethodManager imm = (InputMethodManager)getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);
+            imm.hideSoftInputFromWindow(searchBox.getWindowToken(), 0);
+        }
+    }
+
     void saveSettingsToBundle(Bundle outState) {
         super.saveSettingsToBundle(outState);
 
@@ -300,8 +339,8 @@ String getDefaultTitleText() {
     }
 
     @Override
-    GraphObjectListFragmentAdapter<GraphPlace> createAdapter() {
-        GraphObjectListFragmentAdapter<GraphPlace> adapter = new GraphObjectListFragmentAdapter<GraphPlace>(
+    PickerFragmentAdapter<GraphPlace> createAdapter() {
+        PickerFragmentAdapter<GraphPlace> adapter = new PickerFragmentAdapter<GraphPlace>(
                 this.getActivity()) {
             @Override
             protected CharSequence getSubTitleOfGraphObject(GraphPlace graphObject) {
@@ -351,18 +390,21 @@ private Request createRequest(Location location, int radiusInMeters, int results
         Request request = Request.newPlacesSearchRequest(session, location, radiusInMeters, resultsLimit, searchText,
                 null);
 
-        String pictureField = adapter.getPictureFieldSpecifier();
         Set<String> fields = new HashSet<String>(extraFields);
         String[] requiredFields = new String[]{
                 ID,
                 NAME,
                 LOCATION,
                 CATEGORY,
-                WERE_HERE_COUNT,
-                pictureField
+                WERE_HERE_COUNT
         };
         fields.addAll(Arrays.asList(requiredFields));
 
+        String pictureField = adapter.getPictureFieldSpecifier();
+        if (pictureField != null) {
+            fields.add(pictureField);
+        }
+
         Bundle parameters = request.getParameters();
         parameters.putString("fields", TextUtils.join(",", fields));
         request.setParameters(parameters);
@@ -415,9 +457,9 @@ public void run() {
                         if (error != null) {
                             OnErrorListener onErrorListener = getOnErrorListener();
                             if (onErrorListener != null) {
-                                onErrorListener.onError(error);
+                                onErrorListener.onError(PlacePickerFragment.this, error);
                             } else {
-                                Logger.log(LoggingBehaviors.REQUESTS, TAG, "Error loading data : %s", error);
+                                Logger.log(LoggingBehavior.REQUESTS, TAG, "Error loading data : %s", error);
                             }
                         }
                     }
@@ -478,7 +520,7 @@ public void beforeTextChanged(CharSequence s, int start, int count, int after) {
 
         @Override
         public void onTextChanged(CharSequence s, int start, int before, int count) {
-            setSearchTextAndReload(s.toString(), false);
+            onSearchBoxTextChanged(s.toString(), false);
         }
 
         @Override
diff --git a/facebook/src/com/facebook/ProfilePictureView.java b/facebook/src/com/facebook/widget/ProfilePictureView.java
similarity index 82%
rename from facebook/src/com/facebook/ProfilePictureView.java
rename to facebook/src/com/facebook/widget/ProfilePictureView.java
index d514eddd8..d599f5d7b 100644
--- a/facebook/src/com/facebook/ProfilePictureView.java
+++ b/facebook/src/com/facebook/widget/ProfilePictureView.java
@@ -1,5 +1,5 @@
 /**
- * Copyright 2010 Facebook, Inc.
+ * Copyright 2012 Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,11 +14,12 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.widget;
 
 import android.content.Context;
 import android.content.res.TypedArray;
 import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
 import android.os.Bundle;
 import android.os.Parcelable;
 import android.util.AttributeSet;
@@ -26,12 +27,16 @@
 import android.view.ViewGroup;
 import android.widget.FrameLayout;
 import android.widget.ImageView;
+import com.facebook.FacebookException;
+import com.facebook.LoggingBehavior;
 import com.facebook.android.R;
+import com.facebook.internal.Logger;
+import com.facebook.internal.Utility;
 
 import java.net.MalformedURLException;
 
 /**
- * View that displays the profile photo of a supplied user ID, while conforming
+ * View that displays the profile photo of a supplied profile ID, while conforming
  * to user specified dimensions.
  */
 public class ProfilePictureView extends FrameLayout {
@@ -87,8 +92,9 @@
     public static final int LARGE = -4;
 
     private static final int MIN_SIZE = 1;
+    private static final boolean IS_CROPPED_DEFAULT_VALUE = true;
     private static final String SUPER_STATE_KEY = "ProfilePictureView_superState";
-    private static final String USER_ID_KEY = "ProfilePictureView_userId";
+    private static final String PROFILE_ID_KEY = "ProfilePictureView_profileId";
     private static final String PRESET_SIZE_KEY = "ProfilePictureView_presetSize";
     private static final String IS_CROPPED_KEY = "ProfilePictureView_isCropped";
     private static final String BITMAP_KEY = "ProfilePictureView_bitmap";
@@ -96,10 +102,10 @@
     private static final String BITMAP_HEIGHT_KEY = "ProfilePictureView_height";
     private static final String PENDING_REFRESH_KEY = "ProfilePictureView_refresh";
 
-    private String userId;
+    private String profileId;
     private int queryHeight = ImageRequest.UNSPECIFIED_DIMENSION;
     private int queryWidth = ImageRequest.UNSPECIFIED_DIMENSION;
-    private boolean isCropped;
+    private boolean isCropped = IS_CROPPED_DEFAULT_VALUE;
     private Bitmap imageContents;
     private ImageView image;
     private int presetSizeType = CUSTOM;
@@ -195,24 +201,29 @@ public final void setCropped(boolean showCroppedVersion) {
     }
 
     /**
-     * Returns the user Id for the current profile photo
+     * Returns the profile Id for the current profile photo
      *
-     * @return The user Id
+     * @return The profile Id
      */
-    public final String getUserId() {
-        return userId;
+    public final String getProfileId() {
+        return profileId;
     }
 
     /**
-     * Sets the user Id for this profile photo
+     * Sets the profile Id for this profile photo
      *
-     * @param userId The userId
+     * @param profileId The profileId
      *               NULL/Empty String will show the blank profile photo
      */
-    public final void setUserId(String userId) {
-        boolean force = Utility.isNullOrEmpty(this.userId) || !this.userId.equalsIgnoreCase(userId);
-        this.userId = userId;
+    public final void setProfileId(String profileId) {
+        boolean force = false;
+        if (Utility.isNullOrEmpty(this.profileId) || !this.profileId.equalsIgnoreCase(profileId)) {
+            // Clear out the old profilePicture before requesting for the new one.
+            setBlankProfilePicture();
+            force = true;
+        }
 
+        this.profileId = profileId;
         refreshImage(force);
     }
 
@@ -289,14 +300,14 @@ protected void onLayout(boolean changed, int left, int top, int right, int botto
     /**
      * Some of the current state is returned as a Bundle to allow quick restoration
      * of the ProfilePictureView object in scenarios like orientation changes.
-     * @return
+     * @return a Parcelable containing the current state
      */
     @Override
     protected Parcelable onSaveInstanceState() {
         Parcelable superState = super.onSaveInstanceState();
         Bundle instanceState = new Bundle();
         instanceState.putParcelable(SUPER_STATE_KEY, superState);
-        instanceState.putString(USER_ID_KEY, userId);
+        instanceState.putString(PROFILE_ID_KEY, profileId);
         instanceState.putInt(PRESET_SIZE_KEY, presetSizeType);
         instanceState.putBoolean(IS_CROPPED_KEY, isCropped);
         instanceState.putParcelable(BITMAP_KEY, imageContents);
@@ -309,7 +320,7 @@ protected Parcelable onSaveInstanceState() {
 
     /**
      * If the passed in state is a Bundle, an attempt is made to restore from it.
-     * @param state
+     * @param state a Parcelable containing the current state
      */
     @Override
     protected void onRestoreInstanceState(Parcelable state) {
@@ -319,16 +330,13 @@ protected void onRestoreInstanceState(Parcelable state) {
             Bundle instanceState = (Bundle)state;
             super.onRestoreInstanceState(instanceState.getParcelable(SUPER_STATE_KEY));
 
-            userId = instanceState.getString(USER_ID_KEY);
+            profileId = instanceState.getString(PROFILE_ID_KEY);
             presetSizeType = instanceState.getInt(PRESET_SIZE_KEY);
             isCropped = instanceState.getBoolean(IS_CROPPED_KEY);
-            imageContents = (Bitmap)instanceState.getParcelable(BITMAP_KEY);
             queryWidth = instanceState.getInt(BITMAP_WIDTH_KEY);
             queryHeight = instanceState.getInt(BITMAP_HEIGHT_KEY);
 
-            if (image != null && imageContents != null) {
-                image.setImageBitmap(imageContents);
-            }
+            setImageBitmap((Bitmap)instanceState.getParcelable(BITMAP_KEY));
 
             if (instanceState.getBoolean(PENDING_REFRESH_KEY)) {
                 refreshImage(true);
@@ -366,47 +374,65 @@ private void initialize(Context context) {
     private void parseAttributes(AttributeSet attrs) {
         TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.com_facebook_profile_picture_view);
         setPresetSize(a.getInt(R.styleable.com_facebook_profile_picture_view_preset_size, CUSTOM));
+        isCropped = a.getBoolean(R.styleable.com_facebook_profile_picture_view_is_cropped, IS_CROPPED_DEFAULT_VALUE);
         a.recycle();
     }
 
     private void refreshImage(boolean force) {
         boolean changed = updateImageQueryParameters();
-        if (Utility.isNullOrEmpty(userId) ||
+        // Note: do not use Utility.isNullOrEmpty here as this will cause the Eclipse
+        // Graphical Layout editor to fail in some cases
+        if (profileId == null || profileId.length() == 0 ||
                 ((queryWidth == ImageRequest.UNSPECIFIED_DIMENSION) &&
                         (queryHeight == ImageRequest.UNSPECIFIED_DIMENSION))) {
-            int blankImage = isCropped() ?
-                    R.drawable.com_facebook_profile_picture_blank_square :
-                    R.drawable.com_facebook_profile_picture_blank_portrait;
-
-            image.setImageDrawable(getResources().getDrawable(blankImage));
+            setBlankProfilePicture();
         } else if (changed || force) {
             sendImageRequest(true);
         }
     }
 
+    private void setBlankProfilePicture() {
+        int blankImageResource = isCropped() ?
+                R.drawable.com_facebook_profile_picture_blank_square :
+                R.drawable.com_facebook_profile_picture_blank_portrait;
+        setImageBitmap( BitmapFactory.decodeResource(getResources(), blankImageResource));
+    }
+
+    private void setImageBitmap(Bitmap imageBitmap) {
+        if (image != null && imageBitmap != null) {
+            imageContents = imageBitmap; // Hold for save-restore cycles
+            image.setImageBitmap(imageBitmap);
+        }
+    }
+
     private void sendImageRequest(boolean allowCachedResponse) {
         try {
-            ImageRequest request = ImageRequest.createProfilePictureImageRequest(
+            ImageRequest.Builder requestBuilder = new ImageRequest.Builder(
                     getContext(),
-                    userId,
-                    queryWidth,
-                    queryHeight,
-                    allowCachedResponse,
+                    ImageRequest.getProfilePictureUrl(profileId, queryWidth,  queryHeight));
+
+            ImageRequest request = requestBuilder.setAllowCachedRedirects(allowCachedResponse)
+                    .setCallerTag(this)
+                    .setCallback(
                     new ImageRequest.Callback() {
                         @Override
                         public void onCompleted(ImageResponse response) {
                             processResponse(response);
                         }
-                    });
-
-            ImageDownloader.downloadAsync(request);
+                    })
+                    .build();
 
+            // Make sure to cancel the old request before sending the new one to prevent
+            // accidental cancellation of the new request. This could happen if the URL and
+            // caller tag stayed the same.
             if (lastRequest != null) {
-                lastRequest.cancel();
+                ImageDownloader.cancelRequest(lastRequest);
             }
             lastRequest = request;
+
+            ImageDownloader.downloadAsync(request);
         } catch (MalformedURLException e) {
-            Logger.log(LoggingBehaviors.REQUESTS, Log.ERROR, TAG, e.toString());
+            Logger.log(LoggingBehavior.REQUESTS, Log.ERROR, TAG, e.toString());
         }
     }
 
@@ -416,18 +442,18 @@ private void processResponse(ImageResponse response) {
         // 2. Detached this view, in which case the response should be discarded.
         if (response.getRequest() == lastRequest) {
             lastRequest = null;
-            imageContents = response.getBitmap();
+            Bitmap responseImage = response.getBitmap();
             Exception error = response.getError();
             if (error != null) {
                 OnErrorListener listener = onErrorListener;
                 if (listener != null) {
                     listener.onError(new FacebookException(
-                            "Error in downloading profile picture for userId: " + getUserId(), error));
+                            "Error in downloading profile picture for profileId: " + getProfileId(), error));
                 } else {
-                    Logger.log(LoggingBehaviors.REQUESTS, Log.ERROR, TAG, error.toString());
+                    Logger.log(LoggingBehavior.REQUESTS, Log.ERROR, TAG, error.toString());
                 }
-            } else if (imageContents != null) {
-                image.setImageBitmap(imageContents);
+            } else if (responseImage != null) {
+                setImageBitmap(responseImage);
 
                 if (response.isCachedRedirect()) {
                     sendImageRequest(false);
@@ -467,7 +493,7 @@ private boolean updateImageQueryParameters() {
     }
 
     private int getPresetSizeInPixels(boolean forcePreset) {
-        int dimensionId = 0;
+        int dimensionId;
         switch (presetSizeType) {
             case SMALL:
                 dimensionId = R.dimen.com_facebook_profilepictureview_preset_size_small;
diff --git a/facebook/src/com/facebook/SimpleGraphObjectCursor.java b/facebook/src/com/facebook/widget/SimpleGraphObjectCursor.java
similarity index 83%
rename from facebook/src/com/facebook/SimpleGraphObjectCursor.java
rename to facebook/src/com/facebook/widget/SimpleGraphObjectCursor.java
index f8385ccf8..08c46b4ba 100644
--- a/facebook/src/com/facebook/SimpleGraphObjectCursor.java
+++ b/facebook/src/com/facebook/widget/SimpleGraphObjectCursor.java
@@ -1,6 +1,23 @@
-package com.facebook;
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
 
 import android.database.CursorIndexOutOfBoundsException;
+import com.facebook.model.GraphObject;
 
 import java.util.ArrayList;
 import java.util.Collection;
diff --git a/facebook/src/com/facebook/widget/UrlRedirectCache.java b/facebook/src/com/facebook/widget/UrlRedirectCache.java
new file mode 100644
index 000000000..278e3e4e1
--- /dev/null
+++ b/facebook/src/com/facebook/widget/UrlRedirectCache.java
@@ -0,0 +1,101 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.content.Context;
+import com.facebook.internal.FileLruCache;
+import com.facebook.internal.Utility;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+
+class UrlRedirectCache {
+    static final String TAG = UrlRedirectCache.class.getSimpleName();
+    private static final String REDIRECT_CONTENT_TAG = TAG + "_Redirect";
+
+    private volatile static FileLruCache urlRedirectCache;
+
+    synchronized static FileLruCache getCache(Context context) throws IOException{
+        if (urlRedirectCache == null) {
+            urlRedirectCache = new FileLruCache(context.getApplicationContext(), TAG, new FileLruCache.Limits());
+        }
+        return urlRedirectCache;
+    }
+
+    static URL getRedirectedUrl(Context context, URL url) {
+        if (url == null) {
+            return null;
+        }
+
+        String urlString = url.toString();
+        URL finalUrl = null;
+        InputStreamReader reader = null;
+        try {
+            InputStream stream;
+            FileLruCache cache = getCache(context);
+            boolean redirectExists = false;
+            while ((stream = cache.get(urlString, REDIRECT_CONTENT_TAG)) != null) {
+                redirectExists = true;
+
+                // Get the redirected url
+                reader = new InputStreamReader(stream);
+                char[] buffer = new char[128];
+                int bufferLength;
+                StringBuilder urlBuilder = new StringBuilder();
+                while ((bufferLength = reader.read(buffer, 0, buffer.length)) > 0) {
+                    urlBuilder.append(buffer, 0, bufferLength);
+                }
+                Utility.closeQuietly(reader);
+
+                // Iterate to the next url in the redirection
+                urlString = urlBuilder.toString();
+            }
+
+            if (redirectExists) {
+                finalUrl = new URL(urlString);
+            }
+        } catch (MalformedURLException e) {
+            // caching is best effort, so ignore the exception
+        } catch (IOException ioe) {
+        } finally {
+            Utility.closeQuietly(reader);
+        }
+
+        return finalUrl;
+    }
+
+    static void cacheUrlRedirect(Context context, URL fromUrl, URL toUrl) {
+        if (fromUrl == null || toUrl == null) {
+            return;
+        }
+
+        OutputStream redirectStream = null;
+        try {
+            FileLruCache cache = getCache(context);
+            redirectStream = cache.openPutStream(fromUrl.toString(), REDIRECT_CONTENT_TAG);
+            redirectStream.write(toUrl.toString().getBytes());
+        } catch (IOException e) {
+            // Caching is best effort
+        } finally {
+            Utility.closeQuietly(redirectStream);
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/LoginFragment.java b/facebook/src/com/facebook/widget/UserSettingsFragment.java
similarity index 57%
rename from facebook/src/com/facebook/LoginFragment.java
rename to facebook/src/com/facebook/widget/UserSettingsFragment.java
index 5342a458b..74d7aa5e9 100644
--- a/facebook/src/com/facebook/LoginFragment.java
+++ b/facebook/src/com/facebook/widget/UserSettingsFragment.java
@@ -13,28 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.facebook;
+
+package com.facebook.widget;
 
 import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
-import android.os.AsyncTask;
 import android.os.Bundle;
 import android.text.TextUtils;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.TextView;
+import com.facebook.*;
 import com.facebook.android.R;
+import com.facebook.model.GraphUser;
 
-import java.io.IOException;
-import java.io.InputStream;
 import java.net.MalformedURLException;
 import java.net.URL;
-import java.net.URLConnection;
 import java.util.List;
-import java.util.concurrent.RejectedExecutionException;
 
 /**
  * A Fragment that displays a Login/Logout button as well as the user's
@@ -43,34 +40,39 @@
  * This Fragment will create and use the active session upon construction
  * if it has the available data (if the app ID is specified in the manifest).
  * It will also open the active session if it does not require user interaction
- * (i.e. if the session is in the {@link SessionState#CREATED_TOKEN_LOADED} state.
+ * (i.e. if the session is in the {@link com.facebook.SessionState#CREATED_TOKEN_LOADED} state.
  * Developers can override the use of the active session by calling
- * the {@link #setSession(Session)} method.
+ * the {@link #setSession(com.facebook.Session)} method.
  */
-public class LoginFragment extends FacebookFragment {
+public class UserSettingsFragment extends FacebookFragment {
 
     private static final String NAME = "name";
     private static final String ID = "id";
     private static final String PICTURE = "picture";
     private static final String FIELDS = "fields";
     
-    private static final String PICTURE_URL = "https://graph.facebook.com/%s/picture?width=%d&height=%d";
-    
     private static final String REQUEST_FIELDS = TextUtils.join(",", new String[] {ID, NAME, PICTURE});
 
     private LoginButton loginButton;
+    private LoginButton.LoginButtonProperties loginButtonProperties = new LoginButton.LoginButtonProperties();
     private TextView connectedStateLabel;
     private GraphUser user;
     private Session userInfoSession; // the Session used to fetch the current user info
     private Drawable userProfilePic;
     private String userProfilePicID;
+    private Session.StatusCallback sessionStatusCallback;
 
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        View view = inflater.inflate(R.layout.com_facebook_loginfragment, container, false);
-        loginButton = (LoginButton) view.findViewById(R.id.com_facebook_loginfragment_login_button);
+        View view = inflater.inflate(R.layout.com_facebook_usersettingsfragment, container, false);
+        loginButton = (LoginButton) view.findViewById(R.id.com_facebook_usersettingsfragment_login_button);
+        loginButton.setProperties(loginButtonProperties);
         loginButton.setFragment(this);
-        connectedStateLabel = (TextView) view.findViewById(R.id.com_facebook_loginfragment_profile_name);
+        Session session = getSession();
+        if (session != null && !session.equals(Session.getActiveSession())) {
+            loginButton.setSession(session);
+        }
+        connectedStateLabel = (TextView) view.findViewById(R.id.com_facebook_usersettingsfragment_profile_name);
         
         // if no background is set for some reason, then default to Facebook blue
         if (view.getBackground() == null) {
@@ -88,7 +90,7 @@ public void onCreate(Bundle savedInstanceState) {
     }
 
     /**
-     * @throws FacebookException if errors occur during the loading of user information
+     * @throws com.facebook.FacebookException if errors occur during the loading of user information
      */
     @Override
     public void onResume() {
@@ -106,16 +108,40 @@ public void onResume() {
      * load some user information for display (if needed).
      *
      * @param newSession the Session object to use
-     * @throws FacebookException if errors occur during the loading of user information
+     * @throws com.facebook.FacebookException if errors occur during the loading of user information
      */
     @Override
     public void setSession(Session newSession) {
         super.setSession(newSession);
-        loginButton.setSession(newSession);
+        if (loginButton != null) {
+            loginButton.setSession(newSession);
+        }
         fetchUserInfo();
         updateUI();
     }
 
+    /**
+     * Sets the default audience to use when the session is opened.
+     * This value is only useful when specifying write permissions for the native
+     * login dialog.
+     *
+     * @param defaultAudience the default audience value to use
+     */
+    public void setDefaultAudience(SessionDefaultAudience defaultAudience) {
+        loginButtonProperties.setDefaultAudience(defaultAudience);
+    }
+
+    /**
+     * Gets the default audience to use when the session is opened.
+     * This value is only useful when specifying write permissions for the native
+     * login dialog.
+     *
+     * @return the default audience value to use
+     */
+    public SessionDefaultAudience getDefaultAudience() {
+        return loginButtonProperties.getDefaultAudience();
+    }
+
     /**
      * Set the permissions to use when the session is opened. The permissions here
      * can only be read permissions. If any publish permissions are included, the login
@@ -128,7 +154,7 @@ public void setSession(Session newSession) {
      * after the session is opened, and the list of permissions passed in is not a subset
      * of the permissions granted during the authorization, it will log an error.
      * <p/>
-     * Since the session can be automatically opened when the LoginFragment is constructed,
+     * Since the session can be automatically opened when the UserSettingsFragment is constructed,
      * it's important to always pass in a consistent set of permissions to this method, or
      * manage the setting of permissions outside of the LoginButton class altogether
      * (by managing the session explicitly).
@@ -138,7 +164,7 @@ public void setSession(Session newSession) {
      * @throws UnsupportedOperationException if setPublishPermissions has been called
      */
     public void setReadPermissions(List<String> permissions) {
-        loginButton.setReadPermissions(permissions);
+        loginButtonProperties.setReadPermissions(permissions, getSession());
     }
 
     /**
@@ -164,39 +190,95 @@ public void setReadPermissions(List<String> permissions) {
      * @throws IllegalArgumentException if permissions is null or empty
      */
     public void setPublishPermissions(List<String> permissions) {
-        loginButton.setPublishPermissions(permissions);
+        loginButtonProperties.setPublishPermissions(permissions, getSession());
     }
 
+
     /**
      * Clears the permissions currently associated with this LoginButton.
      */
     public void clearPermissions() {
-        loginButton.clearPermissions();
+        loginButtonProperties.clearPermissions();
+    }
+
+    /**
+     * Sets the login behavior for the session that will be opened. If null is specified,
+     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
+     * will be used.
+     *
+     * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
+     *                      specifies what behaviors should be attempted during
+     *                      authorization.
+     */
+    public void setLoginBehavior(SessionLoginBehavior loginBehavior) {
+        loginButtonProperties.setLoginBehavior(loginBehavior);
+    }
+
+    /**
+     * Gets the login behavior for the session that will be opened. If null is returned,
+     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
+     * will be used.
+     *
+     * @return loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
+     *                      specifies what behaviors should be attempted during
+     *                      authorization.
+     */
+    public SessionLoginBehavior getLoginBehavior() {
+        return loginButtonProperties.getLoginBehavior();
     }
 
     /**
-     * Sets an OnErrorListener for this instance of LoginFragment to call into when
+     * Sets an OnErrorListener for this instance of UserSettingsFragment to call into when
      * certain exceptions occur.
      *
      * @param onErrorListener The listener object to set
      */
     public void setOnErrorListener(LoginButton.OnErrorListener onErrorListener) {
-        loginButton.setOnErrorListener(onErrorListener);
+        loginButtonProperties.setOnErrorListener(onErrorListener);
     }
 
     /**
-     * Returns the current OnErrorListener for this instance of LoginFragment.
+     * Returns the current OnErrorListener for this instance of UserSettingsFragment.
      *
      * @return The OnErrorListener
      */
     public LoginButton.OnErrorListener getOnErrorListener() {
-        return loginButton.getOnErrorListener();
+        return loginButtonProperties.getOnErrorListener();
+    }
+
+    /**
+     * Sets the callback interface that will be called whenever the status of the Session
+     * associated with this LoginButton changes.
+     *
+     * @param callback the callback interface
+     */
+    public void setSessionStatusCallback(Session.StatusCallback callback) {
+        this.sessionStatusCallback = callback;
+    }
+
+    /**
+     * Sets the callback interface that will be called whenever the status of the Session
+     * associated with this LoginButton changes.
+
+     * @return the callback interface
+     */
+    public Session.StatusCallback getSessionStatusCallback() {
+        return sessionStatusCallback;
     }
 
     @Override
     protected void onSessionStateChange(SessionState state, Exception exception) {
         fetchUserInfo();
         updateUI();
+
+        if (sessionStatusCallback != null) {
+            sessionStatusCallback.call(getSession(), state, exception);
+        }
+    }
+
+    // For Testing Only
+    List<String> getPermissions() {
+        return loginButtonProperties.getPermissions();
     }
     
     private void fetchUserInfo() {
@@ -211,7 +293,7 @@ public void onCompleted(GraphUser me, Response response) {
                             updateUI();
                         }
                         if (response.getError() != null) {
-                            loginButton.handleError(response.getError());
+                            loginButton.handleError(response.getError().getException());
                         }
                     }
                 });
@@ -231,92 +313,81 @@ private void updateUI() {
             return;
         }
         if (isSessionOpen()) {
-            connectedStateLabel.setTextColor(getResources().getColor(R.color.com_facebook_loginfragment_connected_text_color));
+            connectedStateLabel.setTextColor(getResources().getColor(R.color.com_facebook_usersettingsfragment_connected_text_color));
             connectedStateLabel.setShadowLayer(1f, 0f, -1f,
-                    getResources().getColor(R.color.com_facebook_loginfragment_connected_shadow_color));
+                    getResources().getColor(R.color.com_facebook_usersettingsfragment_connected_shadow_color));
             
             if (user != null) {
-                URL pictureURL = getPictureUrlOfUser();
-                // Do we already have the right picture? If so, leave it alone.
-                if (pictureURL != null && !pictureURL.equals(connectedStateLabel.getTag())) {
-                    if (user.getId().equals(userProfilePicID)) {
-                        connectedStateLabel.setCompoundDrawables(null, userProfilePic, null, null);
-                        connectedStateLabel.setTag(pictureURL);
-                    } else {
-                        try {
-                            ProfilePictureDownloadTask task = new ProfilePictureDownloadTask(user.getId());
-                            task.execute(pictureURL);
-                        } catch (RejectedExecutionException exception) {
+                ImageRequest request = getImageRequest();
+                if (request != null) {
+                    URL requestUrl = request.getImageUrl();
+                    // Do we already have the right picture? If so, leave it alone.
+                    if (!requestUrl.equals(connectedStateLabel.getTag())) {
+                        if (user.getId().equals(userProfilePicID)) {
+                            connectedStateLabel.setCompoundDrawables(null, userProfilePic, null, null);
+                            connectedStateLabel.setTag(requestUrl);
+                        } else {
+                            ImageDownloader.downloadAsync(request);
                         }
                     }
                 }
                 connectedStateLabel.setText(user.getName());
             } else {
-                connectedStateLabel.setText(getResources().getString(R.string.com_facebook_loginfragment_logged_in));
+                connectedStateLabel.setText(getResources().getString(
+                        R.string.com_facebook_usersettingsfragment_logged_in));
                 Drawable noProfilePic = getResources().getDrawable(R.drawable.com_facebook_profile_default_icon);
-                noProfilePic.setBounds(0, 0, 
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginfragment_profile_picture_width),
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginfragment_profile_picture_height));
+                noProfilePic.setBounds(0, 0,
+                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_width),
+                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_height));
                 connectedStateLabel.setCompoundDrawables(null, noProfilePic, null, null);
             }
         } else {
-            int textColor = getResources().getColor(R.color.com_facebook_loginfragment_not_connected_text_color);
+            int textColor = getResources().getColor(R.color.com_facebook_usersettingsfragment_not_connected_text_color);
             connectedStateLabel.setTextColor(textColor);
             connectedStateLabel.setShadowLayer(0f, 0f, 0f, textColor);
-            connectedStateLabel.setText(getResources().getString(R.string.com_facebook_loginfragment_not_logged_in));
+            connectedStateLabel.setText(getResources().getString(
+                    R.string.com_facebook_usersettingsfragment_not_logged_in));
             connectedStateLabel.setCompoundDrawables(null, null, null, null);
             connectedStateLabel.setTag(null);
         }
     }
 
-    private URL getPictureUrlOfUser() {
+    private ImageRequest getImageRequest() {
+        ImageRequest request = null;
         try {
-            return new URL(String.format(PICTURE_URL, user.getId(), 
-                    getResources().getDimensionPixelSize(R.dimen.com_facebook_loginfragment_profile_picture_width),
-                    getResources().getDimensionPixelSize(R.dimen.com_facebook_loginfragment_profile_picture_height)));
+            ImageRequest.Builder requestBuilder = new ImageRequest.Builder(
+                    getActivity(),
+                    ImageRequest.getProfilePictureUrl(
+                            user.getId(),
+                            getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_width),
+                            getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_height)));
+
+            request = requestBuilder.setCallerTag(this)
+                    .setCallback(
+                            new ImageRequest.Callback() {
+                                @Override
+                                public void onCompleted(ImageResponse response) {
+                                    processImageResponse(user.getId(), response);
+                                }
+                            })
+                    .build();
         } catch (MalformedURLException e) {
         }
-        return null;
+        return request;
     }
 
-    private class ProfilePictureDownloadTask extends AsyncTask<URL, Void, Bitmap> {
-        private URL tag;
-        private String id;
-
-        public ProfilePictureDownloadTask(String id) {
-            this.id = id;
-        }
-        
-        @Override
-        protected Bitmap doInBackground(URL... params) {
-            URLConnection connection = null;
-            InputStream stream = null;
-            try {
-                tag = params[0];
-                connection = tag.openConnection();
-                stream = connection.getInputStream();
-                Bitmap bitmap = BitmapFactory.decodeStream(stream);
-                return bitmap;
-            } catch (IOException e) {
-            } finally {
-                Utility.closeQuietly(stream);
-                Utility.disconnectQuietly(connection);
-            }
-            return null;
-        }
-
-        @Override
-        protected void onPostExecute(Bitmap bitmap) {
-            super.onPostExecute(bitmap);
-            if (LoginFragment.this.isVisible()) {
-                BitmapDrawable drawable = new BitmapDrawable(LoginFragment.this.getResources(), bitmap);
+    private void processImageResponse(String id, ImageResponse response) {
+        if (response != null) {
+            Bitmap bitmap = response.getBitmap();
+            if (bitmap != null) {
+                BitmapDrawable drawable = new BitmapDrawable(UserSettingsFragment.this.getResources(), bitmap);
                 drawable.setBounds(0, 0,
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginfragment_profile_picture_width),
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginfragment_profile_picture_height));
+                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_width),
+                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_height));
                 userProfilePic = drawable;
                 userProfilePicID = id;
                 connectedStateLabel.setCompoundDrawables(null, drawable, null, null);
-                connectedStateLabel.setTag(tag);
+                connectedStateLabel.setTag(response.getRequest().getImageUrl());
             }
         }
     }
diff --git a/facebook/src/com/facebook/widget/WebDialog.java b/facebook/src/com/facebook/widget/WebDialog.java
new file mode 100644
index 000000000..7aea576c7
--- /dev/null
+++ b/facebook/src/com/facebook/widget/WebDialog.java
@@ -0,0 +1,733 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.annotation.SuppressLint;
+import android.app.Dialog;
+import android.app.ProgressDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.net.http.SslError;
+import android.os.Bundle;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.Window;
+import android.webkit.SslErrorHandler;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import com.facebook.*;
+import com.facebook.android.*;
+import com.facebook.internal.Logger;
+import com.facebook.internal.ServerProtocol;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+
+/**
+ * This class provides a mechanism for displaying Facebook Web dialogs inside a Dialog. Helper
+ * methods are provided to construct commonly-used dialogs, or a caller can specify arbitrary
+ * parameters to call other dialogs.
+ */
+public class WebDialog extends Dialog {
+    private static final String LOG_TAG = Logger.LOG_TAG_BASE + "WebDialog";
+    private static final String DISPLAY_TOUCH = "touch";
+    private static final String USER_AGENT = "user_agent";
+    static final String REDIRECT_URI = "fbconnect://success";
+    static final String CANCEL_URI = "fbconnect://cancel";
+
+    public static final int DEFAULT_THEME = android.R.style.Theme_Translucent_NoTitleBar;
+
+    private String url;
+    private OnCompleteListener onCompleteListener;
+    private WebView webView;
+    private ProgressDialog spinner;
+    private ImageView crossImageView;
+    private FrameLayout contentFrameLayout;
+    private boolean listenerCalled = false;
+    private boolean isDetached = false;
+
+    /**
+     * Interface that implements a listener to be called when the user's interaction with the
+     * dialog completes, whether because the dialog finished successfully, or it was cancelled,
+     * or an error was encountered.
+     */
+    public interface OnCompleteListener {
+        /**
+         * Called when the dialog completes.
+         *
+         * @param values on success, contains the values returned by the dialog
+         * @param error  on an error, contains an exception describing the error
+         */
+        void onComplete(Bundle values, FacebookException error);
+    }
+
+    /**
+     * Constructor which can be used to display a dialog with an already-constructed URL.
+     *
+     * @param context the context to use to display the dialog
+     * @param url     the URL of the Web Dialog to display; no validation is done on this URL, but it should
+     *                be a valid URL pointing to a Facebook Web Dialog
+     */
+    public WebDialog(Context context, String url) {
+        this(context, url, DEFAULT_THEME);
+    }
+
+    /**
+     * Constructor which can be used to display a dialog with an already-constructed URL and a custom theme.
+     *
+     * @param context the context to use to display the dialog
+     * @param url     the URL of the Web Dialog to display; no validation is done on this URL, but it should
+     *                be a valid URL pointing to a Facebook Web Dialog
+     * @param theme   identifier of a theme to pass to the Dialog class
+     */
+    public WebDialog(Context context, String url, int theme) {
+        super(context, theme);
+        this.url = url;
+    }
+
+    /**
+     * Constructor which will construct the URL of the Web dialog based on the specified parameters.
+     *
+     * @param context    the context to use to display the dialog
+     * @param action     the portion of the dialog URL following "dialog/"
+     * @param parameters parameters which will be included as part of the URL
+     * @param theme      identifier of a theme to pass to the Dialog class
+     * @param listener the listener to notify, or null if no notification is desired
+     */
+    public WebDialog(Context context, String action, Bundle parameters, int theme, OnCompleteListener listener) {
+        super(context, theme);
+
+        if (parameters == null) {
+            parameters = new Bundle();
+        }
+        parameters.putString(ServerProtocol.DIALOG_PARAM_DISPLAY, DISPLAY_TOUCH);
+        parameters.putString(ServerProtocol.DIALOG_PARAM_TYPE, USER_AGENT);
+
+        Uri uri = Utility.buildUri(ServerProtocol.DIALOG_AUTHORITY, ServerProtocol.DIALOG_PATH + action, parameters);
+        this.url = uri.toString();
+        onCompleteListener = listener;
+    }
+
+    /**
+     * Sets the listener which will be notified when the dialog finishes.
+     *
+     * @param listener the listener to notify, or null if no notification is desired
+     */
+    public void setOnCompleteListener(OnCompleteListener listener) {
+        onCompleteListener = listener;
+    }
+
+    /**
+     * Gets the listener which will be notified when the dialog finishes.
+     *
+     * @return the listener, or null if none has been specified
+     */
+    public OnCompleteListener getOnCompleteListener() {
+        return onCompleteListener;
+    }
+
+    @Override
+    public void dismiss() {
+        if (webView != null) {
+            webView.stopLoading();
+        }
+        if (!isDetached) {
+            if (spinner.isShowing()) {
+                spinner.dismiss();
+            }
+            super.dismiss();
+        }
+    }
+
+    @Override
+    public void onDetachedFromWindow() {
+        isDetached = true;
+        super.onDetachedFromWindow();
+    }
+
+    @Override
+    public void onAttachedToWindow() {
+        isDetached = false;
+        super.onAttachedToWindow();
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        setOnCancelListener(new OnCancelListener() {
+            @Override
+            public void onCancel(DialogInterface dialogInterface) {
+                sendCancelToListener();
+            }
+        });
+
+        spinner = new ProgressDialog(getContext());
+        spinner.requestWindowFeature(Window.FEATURE_NO_TITLE);
+        spinner.setMessage(getContext().getString(R.string.com_facebook_loading));
+        spinner.setOnCancelListener(new OnCancelListener() {
+            @Override
+            public void onCancel(DialogInterface dialogInterface) {
+                sendCancelToListener();
+                WebDialog.this.dismiss();
+            }
+        });
+
+        requestWindowFeature(Window.FEATURE_NO_TITLE);
+        contentFrameLayout = new FrameLayout(getContext());
+
+        /* Create the 'x' image, but don't add to the contentFrameLayout layout yet
+         * at this point, we only need to know its drawable width and height
+         * to place the webview
+         */
+        createCrossImage();
+
+        /* Now we know 'x' drawable width and height,
+        * layout the webivew and add it the contentFrameLayout layout
+        */
+        int crossWidth = crossImageView.getDrawable().getIntrinsicWidth();
+        setUpWebView(crossWidth / 2);
+
+        /* Finally add the 'x' image to the contentFrameLayout layout and
+        * add contentFrameLayout to the Dialog view
+        */
+        contentFrameLayout.addView(crossImageView, new ViewGroup.LayoutParams(
+                ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
+        addContentView(contentFrameLayout,
+                new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
+    }
+
+    private void sendSuccessToListener(Bundle values) {
+        if (onCompleteListener != null && !listenerCalled) {
+            listenerCalled = true;
+            onCompleteListener.onComplete(values, null);
+        }
+    }
+
+    private void sendErrorToListener(Throwable error) {
+        if (onCompleteListener != null && !listenerCalled) {
+            listenerCalled = true;
+            FacebookException facebookException = null;
+            if (error instanceof FacebookException) {
+                facebookException = (FacebookException) error;
+            } else {
+                facebookException = new FacebookException(error);
+            }
+            onCompleteListener.onComplete(null, facebookException);
+        }
+    }
+
+    private void sendCancelToListener() {
+        sendErrorToListener(new FacebookOperationCanceledException());
+    }
+
+    private void createCrossImage() {
+        crossImageView = new ImageView(getContext());
+        // Dismiss the dialog when user click on the 'x'
+        crossImageView.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                sendCancelToListener();
+                WebDialog.this.dismiss();
+            }
+        });
+        Drawable crossDrawable = getContext().getResources().getDrawable(R.drawable.com_facebook_close);
+        crossImageView.setImageDrawable(crossDrawable);
+        /* 'x' should not be visible while webview is loading
+         * make it visible only after webview has fully loaded
+        */
+        crossImageView.setVisibility(View.INVISIBLE);
+    }
+
+    @SuppressLint("SetJavaScriptEnabled")
+    private void setUpWebView(int margin) {
+        LinearLayout webViewContainer = new LinearLayout(getContext());
+        webView = new WebView(getContext());
+        webView.setVerticalScrollBarEnabled(false);
+        webView.setHorizontalScrollBarEnabled(false);
+        webView.setWebViewClient(new DialogWebViewClient());
+        webView.getSettings().setJavaScriptEnabled(true);
+        webView.loadUrl(url);
+        webView.setLayoutParams(new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
+                ViewGroup.LayoutParams.MATCH_PARENT));
+        webView.setVisibility(View.INVISIBLE);
+        webView.getSettings().setSavePassword(false);
+
+        webViewContainer.setPadding(margin, margin, margin, margin);
+        webViewContainer.addView(webView);
+        contentFrameLayout.addView(webViewContainer);
+    }
+
+    private class DialogWebViewClient extends WebViewClient {
+        @Override
+        @SuppressWarnings("deprecation")
+        public boolean shouldOverrideUrlLoading(WebView view, String url) {
+            Utility.logd(LOG_TAG, "Redirect URL: " + url);
+            if (url.startsWith(WebDialog.REDIRECT_URI)) {
+                Bundle values = Util.parseUrl(url);
+
+                String error = values.getString("error");
+                if (error == null) {
+                    error = values.getString("error_type");
+                }
+
+                String errorMessage = values.getString("error_msg");
+                if (errorMessage == null) {
+                    errorMessage = values.getString("error_description");
+                }
+                String errorCodeString = values.getString("error_code");
+                int errorCode = FacebookRequestError.INVALID_ERROR_CODE;
+                if (!Utility.isNullOrEmpty(errorCodeString)) {
+                    try {
+                        errorCode = Integer.parseInt(errorCodeString);
+                    } catch (NumberFormatException ex) {
+                        errorCode = FacebookRequestError.INVALID_ERROR_CODE;
+                    }
+                }
+
+                if (Utility.isNullOrEmpty(error) && Utility
+                        .isNullOrEmpty(errorMessage) && errorCode == FacebookRequestError.INVALID_ERROR_CODE) {
+                    sendSuccessToListener(values);
+                } else if (error != null && (error.equals("access_denied") ||
+                        error.equals("OAuthAccessDeniedException"))) {
+                    sendCancelToListener();
+                } else {
+                    FacebookRequestError requestError = new FacebookRequestError(errorCode, error, errorMessage);
+                    sendErrorToListener(new FacebookServiceException(requestError, errorMessage));
+                }
+
+                WebDialog.this.dismiss();
+                return true;
+            } else if (url.startsWith(WebDialog.CANCEL_URI)) {
+                sendCancelToListener();
+                WebDialog.this.dismiss();
+                return true;
+            } else if (url.contains(DISPLAY_TOUCH)) {
+                return false;
+            }
+            // launch non-dialog URLs in a full browser
+            getContext().startActivity(
+                    new Intent(Intent.ACTION_VIEW, Uri.parse(url)));
+            return true;
+        }
+
+        @Override
+        public void onReceivedError(WebView view, int errorCode,
+                String description, String failingUrl) {
+            super.onReceivedError(view, errorCode, description, failingUrl);
+            sendErrorToListener(new FacebookDialogException(description, errorCode, failingUrl));
+            WebDialog.this.dismiss();
+        }
+
+        @Override
+        public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {
+            super.onReceivedSslError(view, handler, error);
+
+            sendErrorToListener(new FacebookDialogException(null, ERROR_FAILED_SSL_HANDSHAKE, null));
+            handler.cancel();
+            WebDialog.this.dismiss();
+        }
+
+        @Override
+        public void onPageStarted(WebView view, String url, Bitmap favicon) {
+            Utility.logd(LOG_TAG, "Webview loading URL: " + url);
+            super.onPageStarted(view, url, favicon);
+            if (!isDetached) {
+                spinner.show();
+            }
+        }
+
+        @Override
+        public void onPageFinished(WebView view, String url) {
+            super.onPageFinished(view, url);
+            if (!isDetached) {
+                spinner.dismiss();
+            }
+            /*
+             * Once web view is fully loaded, set the contentFrameLayout background to be transparent
+             * and make visible the 'x' image.
+             */
+            contentFrameLayout.setBackgroundColor(Color.TRANSPARENT);
+            webView.setVisibility(View.VISIBLE);
+            crossImageView.setVisibility(View.VISIBLE);
+        }
+    }
+
+    private static class BuilderBase<CONCRETE extends BuilderBase<?>> {
+        private static final String APP_ID_PARAM = "app_id";
+        public static final String ACCESS_TOKEN = "access_token";
+
+        private Context context;
+        private Session session;
+        private String applicationId;
+        private String action;
+        private int theme = DEFAULT_THEME;
+        private OnCompleteListener listener;
+        private Bundle parameters;
+
+        protected BuilderBase(Context context, Session session, String action, Bundle parameters) {
+            Validate.notNull(session, "session");
+            if (!session.isOpened()) {
+                throw new FacebookException("Attempted to use a Session that was not open.");
+            }
+            this.session = session;
+
+            finishInit(context, action, parameters);
+        }
+
+        protected BuilderBase(Context context, String applicationId, String action, Bundle parameters) {
+            Validate.notNullOrEmpty(applicationId, "applicationId");
+            this.applicationId = applicationId;
+
+            finishInit(context, action, parameters);
+        }
+
+        /**
+         * Sets a theme identifier which will be passed to the underlying Dialog.
+         *
+         * @param theme a theme identifier which will be passed to the Dialog class
+         * @return the builder
+         */
+        public CONCRETE setTheme(int theme) {
+            this.theme = theme;
+            @SuppressWarnings("unchecked")
+            CONCRETE result = (CONCRETE) this;
+            return result;
+        }
+
+        /**
+         * Sets the listener which will be notified when the dialog finishes.
+         *
+         * @param listener the listener to notify, or null if no notification is desired
+         * @return the builder
+         */
+        public CONCRETE setOnCompleteListener(OnCompleteListener listener) {
+            this.listener = listener;
+            @SuppressWarnings("unchecked")
+            CONCRETE result = (CONCRETE) this;
+            return result;
+        }
+
+        /**
+         * Constructs a WebDialog using the parameters provided. The dialog is not shown,
+         * but is ready to be shown by calling Dialog.show().
+         *
+         * @return the WebDialog
+         */
+        public WebDialog build() {
+            if (session != null && session.isOpened()) {
+                parameters.putString(APP_ID_PARAM, session.getApplicationId());
+                parameters.putString(ACCESS_TOKEN, session.getAccessToken());
+            } else {
+                parameters.putString(APP_ID_PARAM, applicationId);
+            }
+
+            if (!parameters.containsKey(ServerProtocol.DIALOG_PARAM_REDIRECT_URI)) {
+                parameters.putString(ServerProtocol.DIALOG_PARAM_REDIRECT_URI, REDIRECT_URI);
+            }
+
+            return new WebDialog(context, action, parameters, theme, listener);
+        }
+
+        protected String getApplicationId() {
+            return applicationId;
+        }
+
+        protected Context getContext() {
+            return context;
+        }
+
+        protected int getTheme() {
+            return theme;
+        }
+
+        protected Bundle getParameters() {
+            return parameters;
+        }
+
+        protected WebDialog.OnCompleteListener getListener() {
+            return listener;
+        }
+
+        private void finishInit(Context context, String action, Bundle parameters) {
+            this.context = context;
+            this.action = action;
+            if (parameters != null) {
+                this.parameters = parameters;
+            } else {
+                this.parameters = new Bundle();
+            }
+        }
+    }
+
+    /**
+     * Provides a builder that allows construction of an arbitary Facebook web dialog.
+     */
+    public static class Builder extends BuilderBase<Builder> {
+        /**
+         * Constructor that builds a dialog for an authenticated user.
+         *
+         * @param context the Context within which the dialog will be shown.
+         * @param session the Session representing an authenticating user to use for
+         *                showing the dialog; must not be null, and must be opened.
+         * @param action the portion of the dialog URL following www.facebook.com/dialog/.
+         *               See https://developers.facebook.com/docs/reference/dialogs/ for details.
+         * @param parameters a Bundle containing parameters to pass as part of the URL.
+         */
+        public Builder(Context context, Session session, String action, Bundle parameters) {
+            super(context, session, action, parameters);
+        }
+
+        /**
+         * Constructor that builds a dialog without an authenticated user.
+         *
+         * @param context the Context within which the dialog will be shown.
+         * @param applicationId the application ID to be included in the dialog URL.
+         * @param action the portion of the dialog URL following www.facebook.com/dialog/.
+         *               See https://developers.facebook.com/docs/reference/dialogs/ for details.
+         * @param parameters a Bundle containing parameters to pass as part of the URL.
+         */
+        public Builder(Context context, String applicationId, String action, Bundle parameters) {
+            super(context, applicationId, action, parameters);
+        }
+    }
+
+    /**
+     * Provides a builder that allows construction of the parameters for showing
+     * the Feed Dialog (https://developers.facebook.com/docs/reference/dialogs/feed/).
+     */
+    public static class FeedDialogBuilder extends BuilderBase<FeedDialogBuilder> {
+        private static final String FEED_DIALOG = "feed";
+        private static final String FROM_PARAM = "from";
+        private static final String TO_PARAM = "to";
+        private static final String LINK_PARAM = "link";
+        private static final String PICTURE_PARAM = "picture";
+        private static final String SOURCE_PARAM = "source";
+        private static final String NAME_PARAM = "name";
+        private static final String CAPTION_PARAM = "caption";
+        private static final String DESCRIPTION_PARAM = "description";
+
+        /**
+         * Constructor.
+         *
+         * @param context the Context within which the dialog will be shown.
+         * @param session the Session representing an authenticating user to use for
+         *                showing the dialog; must not be null, and must be opened.
+         */
+        public FeedDialogBuilder(Context context, Session session) {
+            super(context, session, FEED_DIALOG, null);
+        }
+
+        /**
+         * Constructor.
+         *
+         * @param context    the Context within which the dialog will be shown.
+         * @param parameters a Bundle containing parameters to pass as part of the
+         *                   dialog URL. No validation is done on these parameters; it is
+         *                   the caller's responsibility to ensure they are valid.
+         * @param session    the Session representing an authenticating user to use for
+         *                   showing the dialog; must not be null, and must be opened.
+         */
+        public FeedDialogBuilder(Context context, Session session, Bundle parameters) {
+            super(context, session, FEED_DIALOG, parameters);
+        }
+
+        /**
+         * Sets the ID of the profile that is posting to Facebook. If none is specified,
+         * the default is "me". This profile must be either the authenticated user or a
+         * Page that the user is an administrator of.
+         *
+         * @param id Facebook ID of the profile to post from
+         * @return the builder
+         */
+        public FeedDialogBuilder setFrom(String id) {
+            getParameters().putString(FROM_PARAM, id);
+            return this;
+        }
+
+        /**
+         * Sets the ID of the profile that the story will be published to. If not specified, it
+         * will default to the same profile that the story is being published from.
+         *
+         * @param id Facebook ID of the profile to post to
+         * @return the builder
+         */
+        public FeedDialogBuilder setTo(String id) {
+            getParameters().putString(TO_PARAM, id);
+            return this;
+        }
+
+        /**
+         * Sets the URL of a link to be shared.
+         *
+         * @param link the URL
+         * @return the builder
+         */
+        public FeedDialogBuilder setLink(String link) {
+            getParameters().putString(LINK_PARAM, link);
+            return this;
+        }
+
+        /**
+         * Sets the URL of a picture to be shared.
+         *
+         * @param picture the URL of the picture
+         * @return the builder
+         */
+        public FeedDialogBuilder setPicture(String picture) {
+            getParameters().putString(PICTURE_PARAM, picture);
+            return this;
+        }
+
+        /**
+         * Sets the URL of a media file attached to this post. If this is set, any picture
+         * set via setPicture will be ignored.
+         *
+         * @param source the URL of the media file
+         * @return the builder
+         */
+        public FeedDialogBuilder setSource(String source) {
+            getParameters().putString(SOURCE_PARAM, source);
+            return this;
+        }
+
+        /**
+         * Sets the name of the item being shared.
+         *
+         * @param name the name
+         * @return the builder
+         */
+        public FeedDialogBuilder setName(String name) {
+            getParameters().putString(NAME_PARAM, name);
+            return this;
+        }
+
+        /**
+         * Sets the caption to be displayed.
+         *
+         * @param caption the caption
+         * @return the builder
+         */
+        public FeedDialogBuilder setCaption(String caption) {
+            getParameters().putString(CAPTION_PARAM, caption);
+            return this;
+        }
+
+        /**
+         * Sets the description to be displayed.
+         *
+         * @param description the description
+         * @return the builder
+         */
+        public FeedDialogBuilder setDescription(String description) {
+            getParameters().putString(DESCRIPTION_PARAM, description);
+            return this;
+        }
+    }
+
+    /**
+     * Provides a builder that allows construction of the parameters for showing
+     * the Feed Dialog (https://developers.facebook.com/docs/reference/dialogs/feed/).
+     */
+    public static class RequestsDialogBuilder extends BuilderBase<RequestsDialogBuilder> {
+        private static final String APPREQUESTS_DIALOG = "apprequests";
+        private static final String MESSAGE_PARAM = "message";
+        private static final String TO_PARAM = "to";
+        private static final String DATA_PARAM = "data";
+        private static final String TITLE_PARAM = "title";
+
+        /**
+         * Constructor.
+         *
+         * @param context the Context within which the dialog will be shown.
+         * @param session the Session representing an authenticating user to use for
+         *                showing the dialog; must not be null, and must be opened.
+         */
+        public RequestsDialogBuilder(Context context, Session session) {
+            super(context, session, APPREQUESTS_DIALOG, null);
+        }
+
+        /**
+         * Constructor.
+         *
+         * @param context    the Context within which the dialog will be shown.
+         * @param parameters a Bundle containing parameters to pass as part of the
+         *                   dialog URL. No validation is done on these parameters; it is
+         *                   the caller's responsibility to ensure they are valid.
+         * @param session    the Session representing an authenticating user to use for
+         *                   showing the dialog; must not be null, and must be opened.
+         */
+        public RequestsDialogBuilder(Context context, Session session, Bundle parameters) {
+            super(context, session, APPREQUESTS_DIALOG, parameters);
+        }
+
+        /**
+         * Sets the string users receiving the request will see. The maximum length
+         * is 60 characters.
+         *
+         * @param message the message
+         * @return the builder
+         */
+        public RequestsDialogBuilder setMessage(String message) {
+            getParameters().putString(MESSAGE_PARAM, message);
+            return this;
+        }
+
+        /**
+         * Sets the user ID or user name the request will be sent to. If this is not
+         * specified, a friend selector will be displayed and the user can select up
+         * to 50 friends.
+         *
+         * @param id the id or user name to send the request to
+         * @return the builder
+         */
+        public RequestsDialogBuilder setTo(String id) {
+            getParameters().putString(TO_PARAM, id);
+            return this;
+        }
+
+        /**
+         * Sets optional data which can be used for tracking; maximum length is 255
+         * characters.
+         *
+         * @param data the data
+         * @return the builder
+         */
+        public RequestsDialogBuilder setData(String data) {
+            getParameters().putString(DATA_PARAM, data);
+            return this;
+        }
+
+        /**
+         * Sets an optional title for the dialog; maximum length is 50 characters.
+         *
+         * @param title the title
+         * @return the builder
+         */
+        public RequestsDialogBuilder setTitle(String title) {
+            getParameters().putString(TITLE_PARAM, title);
+            return this;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/widget/WorkQueue.java b/facebook/src/com/facebook/widget/WorkQueue.java
new file mode 100644
index 000000000..adcee1d71
--- /dev/null
+++ b/facebook/src/com/facebook/widget/WorkQueue.java
@@ -0,0 +1,221 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import com.facebook.Settings;
+
+import java.util.concurrent.Executor;
+
+class WorkQueue {
+    public static final int DEFAULT_MAX_CONCURRENT = 8;
+
+    private final Object workLock = new Object();
+    private WorkNode pendingJobs;
+
+    private final int maxConcurrent;
+    private final Executor executor;
+
+    private WorkNode runningJobs = null;
+    private int runningCount = 0;
+
+    WorkQueue() {
+        this(DEFAULT_MAX_CONCURRENT);
+    }
+
+    WorkQueue(int maxConcurrent) {
+        this(maxConcurrent, Settings.getExecutor());
+    }
+
+    WorkQueue(int maxConcurrent, Executor executor) {
+        this.maxConcurrent = maxConcurrent;
+        this.executor = executor;
+    }
+
+    WorkItem addActiveWorkItem(Runnable callback) {
+        return addActiveWorkItem(callback, true);
+    }
+
+    WorkItem addActiveWorkItem(Runnable callback, boolean addToFront) {
+        WorkNode node = new WorkNode(callback);
+        synchronized (workLock) {
+            pendingJobs = node.addToList(pendingJobs, addToFront);
+        }
+
+        startItem();
+        return node;
+    }
+
+    void validate() {
+        synchronized (workLock) {
+            // Verify that all running items know they are running, and counts match
+            int count = 0;
+
+            if (runningJobs != null) {
+                WorkNode walk = runningJobs;
+                do {
+                    walk.verify(true);
+                    count++;
+                    walk = walk.getNext();
+                } while (walk != runningJobs);
+            }
+
+            assert runningCount == count;
+        }
+    }
+
+    private void startItem() {
+        finishItemAndStartNew(null);
+    }
+
+    private void finishItemAndStartNew(WorkNode finished) {
+        WorkNode ready = null;
+
+        synchronized (workLock) {
+            if (finished != null) {
+                runningJobs = finished.removeFromList(runningJobs);
+                runningCount--;
+            }
+
+            if (runningCount < maxConcurrent) {
+                ready = pendingJobs; // Head of the pendingJobs queue
+                if (ready != null) {
+                    // The Queue reassignments are necessary since 'ready' might have been
+                    // added / removed from the front of either queue, which changes its
+                    // respective head.
+                    pendingJobs = ready.removeFromList(pendingJobs);
+                    runningJobs = ready.addToList(runningJobs, false);
+                    runningCount++;
+
+                    ready.setIsRunning(true);
+                }
+            }
+        }
+
+        if (ready != null) {
+            execute(ready);
+        }
+    }
+
+    private void execute(final WorkNode node) {
+        executor.execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    node.getCallback().run();
+                } finally {
+                    finishItemAndStartNew(node);
+                }
+            }
+        });
+    }
+
+    private class WorkNode implements WorkItem {
+        private final Runnable callback;
+        private WorkNode next;
+        private WorkNode prev;
+        private boolean isRunning;
+
+        WorkNode(Runnable callback) {
+            this.callback = callback;
+        }
+
+        @Override
+        public boolean cancel() {
+            synchronized (workLock) {
+                if (!isRunning()) {
+                    pendingJobs = removeFromList(pendingJobs);
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        @Override
+        public void moveToFront() {
+            synchronized (workLock) {
+                if (!isRunning()) {
+                    pendingJobs = removeFromList(pendingJobs);
+                    pendingJobs = addToList(pendingJobs, true);
+                }
+            }
+        }
+
+        @Override
+        public boolean isRunning() {
+            return isRunning;
+        }
+
+        Runnable getCallback() {
+            return callback;
+        }
+
+        WorkNode getNext() {
+            return next;
+        }
+
+        void setIsRunning(boolean isRunning) {
+            this.isRunning = isRunning;
+        }
+
+        WorkNode addToList(WorkNode list, boolean addToFront) {
+            assert next == null;
+            assert prev == null;
+
+            if (list == null) {
+                list = next = prev = this;
+            } else {
+                next = list;
+                prev = list.prev;
+                next.prev = prev.next = this;
+            }
+
+            return addToFront ? this : list;
+        }
+
+        WorkNode removeFromList(WorkNode list) {
+            assert next != null;
+            assert prev != null;
+
+            if (list == this) {
+                if (next == this) {
+                    list = null;
+                } else {
+                    list = next;
+                }
+            }
+
+            next.prev = prev;
+            prev.next = next;
+            next = prev = null;
+
+            return list;
+        }
+
+        void verify(boolean shouldBeRunning) {
+            assert prev.next == this;
+            assert next.prev == this;
+            assert isRunning() == shouldBeRunning;
+        }
+    }
+
+    interface WorkItem {
+        boolean cancel();
+        boolean isRunning();
+        void moveToFront();
+    }
+}
diff --git a/facebook/tests/AndroidManifest.xml b/facebook/tests/AndroidManifest.xml
index a93331391..1509af65d 100644
--- a/facebook/tests/AndroidManifest.xml
+++ b/facebook/tests/AndroidManifest.xml
@@ -12,10 +12,12 @@
     <application>
         <uses-library android:name="android.test.runner"/>
         <activity android:name="com.facebook.FacebookTestCase$FacebookTestActivity"/>
-        <activity android:name="com.facebook.FriendPickerFragmentTests$TestActivity"/>
-        <activity android:name="com.facebook.PlacePickerFragmentTests$TestActivity"/>
-        <activity android:name="com.facebook.GraphObjectPagingLoaderTests$TestActivity"/>
+        <activity android:name="com.facebook.widget.FriendPickerFragmentTests$TestActivity"/>
+        <activity android:name="com.facebook.widget.PlacePickerFragmentTests$TestActivity"/>
+        <activity android:name="com.facebook.widget.GraphObjectPagingLoaderTests$TestActivity"/>
+        <activity android:name="com.facebook.widget.UserSettingsFragmentTests$TestActivity"/>
         <activity android:name="com.facebook.LoginActivity" />
+        <activity android:name="com.facebook.FacebookActivityTests$FacebookTestActivity" />
         <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
     </application>
     <!--
diff --git a/facebook/tests/SdkTests.iml b/facebook/tests/SdkTests.iml
index 9843b7e24..0db1700c9 100644
--- a/facebook/tests/SdkTests.iml
+++ b/facebook/tests/SdkTests.iml
@@ -34,6 +34,7 @@
           <path>/res-overlay</path>
         </resOverlayFolders>
         <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
         <additionalNativeLibs />
       </configuration>
     </facet>
diff --git a/facebook/tests/assets/DarkScreen.mov b/facebook/tests/assets/DarkScreen.mov
new file mode 100644
index 000000000..2e86e5c49
Binary files /dev/null and b/facebook/tests/assets/DarkScreen.mov differ
diff --git a/facebook/tests/res/layout/friend_picker_test_layout_1.xml b/facebook/tests/res/layout/friend_picker_test_layout_1.xml
index 31fedd78a..34c2c9a48 100644
--- a/facebook/tests/res/layout/friend_picker_test_layout_1.xml
+++ b/facebook/tests/res/layout/friend_picker_test_layout_1.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
               xmlns:app="http://schemas.android.com/apk/res-auto"
@@ -7,11 +22,11 @@
 
     <fragment
             android:id="@+id/friend_picker_fragment"
-            android:name="com.facebook.FriendPickerFragment"
+            android:name="com.facebook.widget.FriendPickerFragment"
             android:layout_width="fill_parent"
             android:layout_height="fill_parent"
             app:show_pictures="false"
             app:multi_select="false"
             app:extra_fields="middle_name,link"
             />
-</LinearLayout>
\ No newline at end of file
+</LinearLayout>
diff --git a/facebook/tests/res/layout/place_picker_test_layout_1.xml b/facebook/tests/res/layout/place_picker_test_layout_1.xml
index 51ba709fc..9f2789178 100644
--- a/facebook/tests/res/layout/place_picker_test_layout_1.xml
+++ b/facebook/tests/res/layout/place_picker_test_layout_1.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
               xmlns:app="http://schemas.android.com/apk/res-auto"
@@ -7,7 +22,7 @@
 
     <fragment
             android:id="@+id/place_picker_fragment"
-            android:name="com.facebook.PlacePickerFragment"
+            android:name="com.facebook.widget.PlacePickerFragment"
             android:layout_width="fill_parent"
             android:layout_height="fill_parent"
             app:show_pictures="false"
@@ -16,4 +31,4 @@
             app:search_text="coffee"
             app:extra_fields="checkins,general_info"
             />
-</LinearLayout>
\ No newline at end of file
+</LinearLayout>
diff --git a/facebook/tests/res/values/strings.xml b/facebook/tests/res/values/strings.xml
index 6d33d2b96..fa585a791 100644
--- a/facebook/tests/res/values/strings.xml
+++ b/facebook/tests/res/values/strings.xml
@@ -1,3 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <string name="app_id">1234567890</string>
-</resources>
\ No newline at end of file
+</resources>
diff --git a/facebook/tests/src/com/facebook/AccessTokenTests.java b/facebook/tests/src/com/facebook/AccessTokenTests.java
index 18ee7cbfd..957d433c2 100644
--- a/facebook/tests/src/com/facebook/AccessTokenTests.java
+++ b/facebook/tests/src/com/facebook/AccessTokenTests.java
@@ -22,6 +22,7 @@
 import android.test.suitebuilder.annotation.LargeTest;
 import android.test.suitebuilder.annotation.MediumTest;
 import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.internal.Utility;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -35,9 +36,9 @@
     @MediumTest
     @LargeTest
     public void testEmptyToken() {
-        List<String> permissions = list();
+        List<String> permissions = Utility.arrayList();
         AccessToken token = AccessToken.createEmptyToken(permissions);
-        assertSamePermissions(permissions, token);
+        TestUtils.assertSamePermissions(permissions, token);
         assertEquals("", token.getToken());
         assertTrue(token.isInvalid());
         assertTrue(token.getExpires().before(new Date()));
@@ -47,9 +48,9 @@ public void testEmptyToken() {
     @MediumTest
     @LargeTest
     public void testEmptyTokenWithPermissions() {
-        List<String> permissions = list("stream_publish");
+        List<String> permissions = Utility.arrayList("stream_publish");
         AccessToken token = AccessToken.createEmptyToken(permissions);
-        assertSamePermissions(permissions, token);
+        TestUtils.assertSamePermissions(permissions, token);
         assertEquals("", token.getToken());
         assertTrue(token.isInvalid());
         assertTrue(token.getExpires().before(new Date()));
@@ -59,17 +60,17 @@ public void testEmptyTokenWithPermissions() {
     @MediumTest
     @LargeTest
     public void testFromDialog() {
-        List<String> permissions = list("stream_publish", "go_outside_and_play");
+        List<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
         String token = "AnImaginaryTokenValue";
 
         Bundle bundle = new Bundle();
         bundle.putString("access_token", token);
         bundle.putString("expires_in", "60");
 
-        AccessToken accessToken = AccessToken.createFromDialog(permissions, bundle);
-        assertSamePermissions(permissions, accessToken);
+        AccessToken accessToken = AccessToken.createFromWebBundle(permissions, bundle, AccessTokenSource.WEB_VIEW);
+        TestUtils.assertSamePermissions(permissions, accessToken);
         assertEquals(token, accessToken.getToken());
-        assertFalse(accessToken.getIsSSO());
+        assertEquals(AccessTokenSource.WEB_VIEW, accessToken.getSource());
         assertTrue(!accessToken.isInvalid());
     }
 
@@ -77,7 +78,7 @@ public void testFromDialog() {
     @MediumTest
     @LargeTest
     public void testFromSSOWithExpiresString() {
-        List<String> permissions = list("stream_publish", "go_outside_and_play");
+        List<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
         String token = "AnImaginaryTokenValue";
 
         Intent intent = new Intent();
@@ -85,10 +86,12 @@ public void testFromSSOWithExpiresString() {
         intent.putExtra("expires_in", "60");
         intent.putExtra("extra_extra", "Something unrelated");
 
-        AccessToken accessToken = AccessToken.createFromSSO(permissions, intent);
-        assertSamePermissions(permissions, accessToken);
+        AccessToken accessToken = AccessToken
+                .createFromWebBundle(permissions, intent.getExtras(), AccessTokenSource.FACEBOOK_APPLICATION_WEB);
+
+        TestUtils.assertSamePermissions(permissions, accessToken);
         assertEquals(token, accessToken.getToken());
-        assertTrue(accessToken.getIsSSO());
+        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
         assertTrue(!accessToken.isInvalid());
     }
 
@@ -96,7 +99,7 @@ public void testFromSSOWithExpiresString() {
     @MediumTest
     @LargeTest
     public void testFromSSOWithExpiresLong() {
-        List<String> permissions = list("stream_publish", "go_outside_and_play");
+        List<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
         String token = "AnImaginaryTokenValue";
 
         Intent intent = new Intent();
@@ -104,10 +107,32 @@ public void testFromSSOWithExpiresLong() {
         intent.putExtra("expires_in", 60L);
         intent.putExtra("extra_extra", "Something unrelated");
 
-        AccessToken accessToken = AccessToken.createFromSSO(permissions, intent);
-        assertSamePermissions(permissions, accessToken);
+        AccessToken accessToken = AccessToken
+                .createFromWebBundle(permissions, intent.getExtras(), AccessTokenSource.FACEBOOK_APPLICATION_WEB);
+        TestUtils.assertSamePermissions(permissions, accessToken);
+        assertEquals(token, accessToken.getToken());
+        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
+        assertTrue(!accessToken.isInvalid());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testFromNativeLogin() {
+        ArrayList<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
+        String token = "AnImaginaryTokenValue";
+
+        long nowSeconds = new Date().getTime() / 1000;
+        Intent intent = new Intent();
+        intent.putExtra(NativeProtocol.EXTRA_ACCESS_TOKEN, token);
+        intent.putExtra(NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, nowSeconds + 60L);
+        intent.putExtra(NativeProtocol.EXTRA_PERMISSIONS, permissions);
+
+        AccessToken accessToken = AccessToken.createFromNativeLogin(
+                intent.getExtras(), AccessTokenSource.FACEBOOK_APPLICATION_NATIVE);
+        TestUtils.assertSamePermissions(permissions, accessToken);
         assertEquals(token, accessToken.getToken());
-        assertTrue(accessToken.getIsSSO());
+        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_NATIVE, accessToken.getSource());
         assertTrue(!accessToken.isInvalid());
     }
 
@@ -115,56 +140,58 @@ public void testFromSSOWithExpiresLong() {
     @MediumTest
     @LargeTest
     public void testCacheRoundtrip() {
-        ArrayList<String> permissions = list("stream_publish", "go_outside_and_play");
+        ArrayList<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
         String token = "AnImaginaryTokenValue";
-        Date later = nowPlusSeconds(60);
-        Date earlier = nowPlusSeconds(-60);
+        Date later = TestUtils.nowPlusSeconds(60);
+        Date earlier = TestUtils.nowPlusSeconds(-60);
 
         Bundle bundle = new Bundle();
-        TokenCache.putToken(bundle, token);
-        TokenCache.putExpirationDate(bundle, later);
-        TokenCache.putIsSSO(bundle, true);
-        TokenCache.putLastRefreshDate(bundle, earlier);
-        TokenCache.putPermissions(bundle, permissions);
+        TokenCachingStrategy.putToken(bundle, token);
+        TokenCachingStrategy.putExpirationDate(bundle, later);
+        TokenCachingStrategy.putSource(bundle, AccessTokenSource.FACEBOOK_APPLICATION_WEB);
+        TokenCachingStrategy.putLastRefreshDate(bundle, earlier);
+        TokenCachingStrategy.putPermissions(bundle, permissions);
 
         AccessToken accessToken = AccessToken.createFromCache(bundle);
-        assertSamePermissions(permissions, accessToken);
+        TestUtils.assertSamePermissions(permissions, accessToken);
         assertEquals(token, accessToken.getToken());
-        assertTrue(accessToken.getIsSSO());
+        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
         assertTrue(!accessToken.isInvalid());
 
         Bundle cache = accessToken.toCacheBundle();
-        assertEqualContents(bundle, cache);
+        TestUtils.assertEqualContents(bundle, cache);
     }
 
-    @SmallTest @MediumTest @LargeTest
+    @SmallTest
+    @MediumTest
+    @LargeTest
     public void testCachePutGet() {
         Bundle bundle = new Bundle();
 
         for (String token : new String[] { "", "A completely random token value" }) {
-            TokenCache.putToken(bundle, token);
-            assertEquals(token, TokenCache.getToken(bundle));
+            TokenCachingStrategy.putToken(bundle, token);
+            assertEquals(token, TokenCachingStrategy.getToken(bundle));
         }
 
         for (Date date : new Date[] { new Date(42), new Date() }) {
-            TokenCache.putExpirationDate(bundle, date);
-            assertEquals(date, TokenCache.getExpirationDate(bundle));
+            TokenCachingStrategy.putExpirationDate(bundle, date);
+            assertEquals(date, TokenCachingStrategy.getExpirationDate(bundle));
 
-            TokenCache.putLastRefreshDate(bundle, date);
-            assertEquals(date, TokenCache.getLastRefreshDate(bundle));
+            TokenCachingStrategy.putLastRefreshDate(bundle, date);
+            assertEquals(date, TokenCachingStrategy.getLastRefreshDate(bundle));
         }
 
         for (long milliseconds : new long[] { 0, -1, System.currentTimeMillis() }) {
-            TokenCache.putExpirationMilliseconds(bundle, milliseconds);
-            assertEquals(milliseconds, TokenCache.getExpirationMilliseconds(bundle));
+            TokenCachingStrategy.putExpirationMilliseconds(bundle, milliseconds);
+            assertEquals(milliseconds, TokenCachingStrategy.getExpirationMilliseconds(bundle));
 
-            TokenCache.putLastRefreshMilliseconds(bundle, milliseconds);
-            assertEquals(milliseconds, TokenCache.getLastRefreshMilliseconds(bundle));
+            TokenCachingStrategy.putLastRefreshMilliseconds(bundle, milliseconds);
+            assertEquals(milliseconds, TokenCachingStrategy.getLastRefreshMilliseconds(bundle));
         }
 
-        for (boolean isSSO : new boolean[] { true, false }) {
-            TokenCache.putIsSSO(bundle, isSSO);
-            assertEquals(isSSO, TokenCache.getIsSSO(bundle));
+        for (AccessTokenSource source : AccessTokenSource.values()) {
+            TokenCachingStrategy.putSource(bundle, source);
+            assertEquals(source, TokenCachingStrategy.getSource(bundle));
         }
 
         List<String> normalList = Arrays.asList("", "Another completely random token value");
@@ -175,75 +202,78 @@ public void testCachePutGet() {
         List<List<String>> permissionLists = Arrays
                 .asList(normalList, emptyList, normalArrayList, emptyArrayList);
         for (List<String> list : permissionLists) {
-            TokenCache.putPermissions(bundle, list);
-            assertSamePermissions(list, TokenCache.getPermissions(bundle));
+            TokenCachingStrategy.putPermissions(bundle, list);
+            TestUtils.assertSamePermissions(list, TokenCachingStrategy.getPermissions(bundle));
         }
         normalArrayList.add(null);
     }
-    
+
     @SmallTest
+    @MediumTest
+    @LargeTest
     public void testBasicSerialization() throws IOException {
         AccessToken accessToken = AccessToken.createFromString("a token",
-                Arrays.asList("permission_1", "permission_2"));
+                Arrays.asList("permission_1", "permission_2"), AccessTokenSource.WEB_VIEW);
         AccessToken res = TestUtils.serializeAndUnserialize(accessToken);
         
         // if one field got serialized most likely all other non transient fields
         // got serialized correctly.
         assertEquals(accessToken.getPermissions(), res.getPermissions());
         assertEquals(accessToken.getToken(), res.getToken());
+        assertEquals(accessToken.getSource(), res.getSource());
     }
 
-    private ArrayList<String> list(String... ss) {
-        ArrayList<String> result = new ArrayList<String>();
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testPermissionsAreImmutable() {
+        List<String> permissions = Arrays.asList("go to Jail", "do not pass Go");
+        AccessToken accessToken = new AccessToken("some token", new Date(), permissions,
+                AccessTokenSource.FACEBOOK_APPLICATION_WEB, new Date());
 
-        for (String s : ss) {
-            result.add(s);
-        }
+        permissions = accessToken.getPermissions();
 
-        return result;
+        try {
+            permissions.add("can't touch this");
+            fail();
+        } catch (UnsupportedOperationException ex) {
+        }
     }
 
-    private static Date nowPlusSeconds(long offset) {
-        return new Date(new Date().getTime() + (offset * 1000L));
-    }
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreateFromExistingTokenDefaults() {
+        final String token = "A token of my esteem";
 
-    private static void assertSamePermissions(List<String> expected, AccessToken actual) {
-        if (expected == null) {
-            assertEquals(null, actual.getPermissions());
-        } else {
-            for (String p : expected) {
-                assertTrue(actual.getPermissions().contains(p));
-            }
-            for (String p : actual.getPermissions()) {
-                assertTrue(expected.contains(p));
-            }
-        }
-    }
+        AccessToken accessToken = AccessToken.createFromExistingAccessToken(token, null, null, null, null);
 
-    private static void assertSamePermissions(List<String> expected, List<String> actual) {
-        if (expected == null) {
-            assertEquals(null, actual);
-        } else {
-            for (String p : expected) {
-                assertTrue(actual.contains(p));
-            }
-            for (String p : actual) {
-                assertTrue(expected.contains(p));
-            }
-        }
+        assertEquals(token, accessToken.getToken());
+        assertEquals(new Date(Long.MAX_VALUE), accessToken.getExpires());
+        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
+        assertEquals(0, accessToken.getPermissions().size());
+        // Allow slight variation for test execution time
+        long delta = accessToken.getLastRefresh().getTime() - new Date().getTime();
+        assertTrue(delta < 1000);
     }
 
-    private static void assertEqualContents(Bundle a, Bundle b) {
-        for (String key : a.keySet()) {
-            if (!b.containsKey(key)) {
-                fail("bundle does not include key " + key);
-            }
-            assertEquals(a.get(key), b.get(key));
-        }
-        for (String key : b.keySet()) {
-            if (!a.containsKey(key)) {
-                fail("bundle does not include key " + key);
-            }
-        }
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreateFromExistingToken() {
+        final String token = "A token of my esteem";
+        final List<String> permissions = Arrays.asList("walk", "chew gum");
+        final Date expires = new Date(2025, 5, 3);
+        final Date lastRefresh = new Date(2023, 8, 15);
+        final AccessTokenSource source = AccessTokenSource.WEB_VIEW;
+
+        AccessToken accessToken = AccessToken
+                .createFromExistingAccessToken(token, expires, lastRefresh, source, permissions);
+
+        assertEquals(token, accessToken.getToken());
+        assertEquals(expires, accessToken.getExpires());
+        assertEquals(lastRefresh, accessToken.getLastRefresh());
+        assertEquals(source, accessToken.getSource());
+        assertEquals(permissions, accessToken.getPermissions());
     }
 }
diff --git a/facebook/tests/src/com/facebook/AsyncRequestTests.java b/facebook/tests/src/com/facebook/AsyncRequestTests.java
index 4fec540b6..b662f54da 100644
--- a/facebook/tests/src/com/facebook/AsyncRequestTests.java
+++ b/facebook/tests/src/com/facebook/AsyncRequestTests.java
@@ -13,12 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.facebook;
 
 import android.graphics.Bitmap;
 import android.test.suitebuilder.annotation.LargeTest;
 import android.test.suitebuilder.annotation.MediumTest;
 import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphPlace;
+import com.facebook.model.GraphUser;
 
 import java.net.HttpURLConnection;
 import java.util.Arrays;
diff --git a/facebook/tests/src/com/facebook/AuthorizationClientTests.java b/facebook/tests/src/com/facebook/AuthorizationClientTests.java
new file mode 100644
index 000000000..22695f73a
--- /dev/null
+++ b/facebook/tests/src/com/facebook/AuthorizationClientTests.java
@@ -0,0 +1,684 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.model.GraphMultiResult;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphObjectList;
+import com.facebook.model.GraphUser;
+
+import java.io.*;
+import java.util.*;
+
+public class AuthorizationClientTests extends FacebookTestCase {
+    private static final String ACCESS_TOKEN = "An access token";
+    private static final long EXPIRES_IN_DELTA = 3600 * 24 * 60;
+    private static final ArrayList<String> PERMISSIONS = new ArrayList<String>(
+            Arrays.asList("go outside", "come back in"));
+    private static final String ERROR_MESSAGE = "This is bad!";
+
+    class MockAuthorizationClient extends AuthorizationClient {
+        Result result;
+        boolean triedNextHandler = false;
+
+        MockAuthorizationClient() {
+            setContext(getActivity());
+        }
+
+        AuthorizationClient.AuthorizationRequest getRequest() {
+            return pendingRequest;
+        }
+
+        void setRequest(AuthorizationClient.AuthorizationRequest request) {
+            pendingRequest = request;
+        }
+
+        @Override
+        void complete(Result result) {
+            this.result = result;
+        }
+
+        @Override
+        void tryNextHandler() {
+            triedNextHandler = true;
+        }
+    }
+
+    // WebViewAuthHandler tests
+
+    AuthorizationClient.AuthorizationRequest createRequest() {
+        Session.AuthorizationRequest request = new Session.AuthorizationRequest(getActivity());
+        request.setPermissions(PERMISSIONS);
+        return request.getAuthorizationClientRequest();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testWebViewHandlesSuccess() {
+        Bundle bundle = new Bundle();
+        bundle.putString("access_token", ACCESS_TOKEN);
+        bundle.putString("expires_in", String.format("%d", EXPIRES_IN_DELTA));
+        bundle.putString("code", "Something else");
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.WebViewAuthHandler handler = client.new WebViewAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onWebDialogComplete(request, bundle, null);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
+
+        AccessToken token = client.result.token;
+        assertNotNull(token);
+        assertEquals(ACCESS_TOKEN, token.getToken());
+        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
+        assertEquals(PERMISSIONS, token.getPermissions());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testWebViewHandlesCancel() {
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.WebViewAuthHandler handler = client.new WebViewAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onWebDialogComplete(request, null, new FacebookOperationCanceledException());
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.CANCEL, client.result.code);
+        assertNull(client.result.token);
+        assertNotNull(client.result.errorMessage);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testWebViewHandlesError() {
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.WebViewAuthHandler handler = client.new WebViewAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onWebDialogComplete(request, null, new FacebookException(ERROR_MESSAGE));
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.ERROR, client.result.code);
+        assertNull(client.result.token);
+        assertNotNull(client.result.errorMessage);
+        assertEquals(client.result.errorMessage, ERROR_MESSAGE);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testWebViewChecksInternetPermission() {
+        MockAuthorizationClient client = new MockAuthorizationClient() {
+            @Override
+            int checkPermission(String permission) {
+                return PackageManager.PERMISSION_DENIED;
+            }
+        };
+        AuthorizationClient.WebViewAuthHandler handler = client.new WebViewAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onWebDialogComplete(request, null, new FacebookException(ERROR_MESSAGE));
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.ERROR, client.result.code);
+        assertNull(client.result.token);
+        assertNotNull(client.result.errorMessage);
+    }
+
+    // GetTokenAuthHandler tests
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testGetTokenHandlesSuccessWithAllPermissions() {
+        Bundle bundle = new Bundle();
+        bundle.putStringArrayList(NativeProtocol.EXTRA_PERMISSIONS, PERMISSIONS);
+        bundle.putLong(NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, new Date().getTime() / 1000 + EXPIRES_IN_DELTA);
+        bundle.putString(NativeProtocol.EXTRA_ACCESS_TOKEN, ACCESS_TOKEN);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.GetTokenAuthHandler handler = client.new GetTokenAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.getTokenCompleted(request, bundle);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
+
+        AccessToken token = client.result.token;
+        assertNotNull(token);
+        assertEquals(ACCESS_TOKEN, token.getToken());
+        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
+        assertEquals(PERMISSIONS, token.getPermissions());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testGetTokenHandlesSuccessWithSomePermissions() {
+        Bundle bundle = new Bundle();
+        bundle.putStringArrayList(NativeProtocol.EXTRA_PERMISSIONS, new ArrayList<String>(Arrays.asList("go outside")));
+        bundle.putLong(NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, new Date().getTime() / 1000 + EXPIRES_IN_DELTA);
+        bundle.putString(NativeProtocol.EXTRA_ACCESS_TOKEN, ACCESS_TOKEN);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.GetTokenAuthHandler handler = client.new GetTokenAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        assertEquals(PERMISSIONS.size(), request.getPermissions().size());
+
+        client.setRequest(request);
+        handler.getTokenCompleted(request, bundle);
+
+        assertNull(client.result);
+        assertTrue(client.triedNextHandler);
+
+        assertEquals(1, request.getPermissions().size());
+        assertTrue(request.getPermissions().contains("come back in"));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testGetTokenHandlesNoResult() {
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.GetTokenAuthHandler handler = client.new GetTokenAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        assertEquals(PERMISSIONS.size(), request.getPermissions().size());
+
+        client.setRequest(request);
+        handler.getTokenCompleted(request, null);
+
+        assertNull(client.result);
+        assertTrue(client.triedNextHandler);
+
+        assertEquals(PERMISSIONS.size(), request.getPermissions().size());
+    }
+
+    // KatanaLoginDialogAuthHandler tests
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testLoginDialogHandlesSuccess() {
+        Bundle bundle = new Bundle();
+        bundle.putStringArrayList(NativeProtocol.EXTRA_PERMISSIONS, PERMISSIONS);
+        bundle.putLong(NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, new Date().getTime() / 1000 + EXPIRES_IN_DELTA);
+        bundle.putString(NativeProtocol.EXTRA_ACCESS_TOKEN, ACCESS_TOKEN);
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.KatanaLoginDialogAuthHandler handler = client.new KatanaLoginDialogAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onActivityResult(0, Activity.RESULT_OK, intent);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
+
+        AccessToken token = client.result.token;
+        assertNotNull(token);
+        assertEquals(ACCESS_TOKEN, token.getToken());
+        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
+        assertEquals(PERMISSIONS, token.getPermissions());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testLoginDialogHandlesCancel() {
+        Bundle bundle = new Bundle();
+        bundle.putString(NativeProtocol.STATUS_ERROR_DESCRIPTION, ERROR_MESSAGE);
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.KatanaLoginDialogAuthHandler handler = client.new KatanaLoginDialogAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onActivityResult(0, Activity.RESULT_CANCELED, intent);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.CANCEL, client.result.code);
+
+        AccessToken token = client.result.token;
+        assertNull(token);
+        assertNotNull(client.result.errorMessage);
+        assertEquals(ERROR_MESSAGE, client.result.errorMessage);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testLoginDialogHandlesError() {
+        Bundle bundle = new Bundle();
+        bundle.putString(NativeProtocol.STATUS_ERROR_TYPE, ERROR_MESSAGE);
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.KatanaLoginDialogAuthHandler handler = client.new KatanaLoginDialogAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onActivityResult(0, Activity.RESULT_OK, intent);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.ERROR, client.result.code);
+
+        AccessToken token = client.result.token;
+        assertNull(token);
+        assertNotNull(client.result.errorMessage);
+        assertEquals(ERROR_MESSAGE, client.result.errorMessage);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testLoginDialogHandlesDisabled() {
+        Bundle bundle = new Bundle();
+        bundle.putInt(NativeProtocol.EXTRA_PROTOCOL_VERSION, NativeProtocol.PROTOCOL_VERSION_20121101);
+        bundle.putString(NativeProtocol.STATUS_ERROR_TYPE, NativeProtocol.ERROR_SERVICE_DISABLED);
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.KatanaLoginDialogAuthHandler handler = client.new KatanaLoginDialogAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onActivityResult(0, Activity.RESULT_OK, intent);
+
+        assertNull(client.result);
+        assertTrue(client.triedNextHandler);
+    }
+
+    // KatanaProxyAuthHandler tests
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testProxyAuthHandlesSuccess() {
+        Bundle bundle = new Bundle();
+        bundle.putLong(AccessToken.EXPIRES_IN_KEY, EXPIRES_IN_DELTA);
+        bundle.putString(AccessToken.ACCESS_TOKEN_KEY, ACCESS_TOKEN);
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.KatanaProxyAuthHandler handler = client.new KatanaProxyAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onActivityResult(0, Activity.RESULT_OK, intent);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
+
+        AccessToken token = client.result.token;
+        assertNotNull(token);
+        assertEquals(ACCESS_TOKEN, token.getToken());
+        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
+        assertEquals(PERMISSIONS, token.getPermissions());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testProxyAuthHandlesCancel() {
+        Bundle bundle = new Bundle();
+        bundle.putString("error", ERROR_MESSAGE);
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.KatanaProxyAuthHandler handler = client.new KatanaProxyAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onActivityResult(0, Activity.RESULT_CANCELED, intent);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.CANCEL, client.result.code);
+
+        assertNull(client.result.token);
+        assertNotNull(client.result.errorMessage);
+        assertTrue(client.result.errorMessage.contains(ERROR_MESSAGE));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testProxyAuthHandlesCancelErrorMessage() {
+        Bundle bundle = new Bundle();
+        bundle.putString("error", "access_denied");
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.KatanaProxyAuthHandler handler = client.new KatanaProxyAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onActivityResult(0, Activity.RESULT_CANCELED, intent);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.CANCEL, client.result.code);
+
+        assertNull(client.result.token);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testProxyAuthHandlesDisabled() {
+        Bundle bundle = new Bundle();
+        bundle.putString("error", "service_disabled");
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.KatanaProxyAuthHandler handler = client.new KatanaProxyAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onActivityResult(0, Activity.RESULT_OK, intent);
+
+        assertNull(client.result);
+        assertTrue(client.triedNextHandler);
+    }
+
+    // Reauthorization validation tests
+
+    class MockValidatingAuthorizationClient extends MockAuthorizationClient {
+        private final HashMap<String, String> mapAccessTokenToFbid = new HashMap<String, String>();
+        private List<String> permissionsToReport = Arrays.asList();
+        private TestBlocker blocker;
+
+        public MockValidatingAuthorizationClient(TestBlocker blocker) {
+            this.blocker = blocker;
+        }
+
+        public void addAccessTokenToFbidMapping(String accessToken, String fbid) {
+            mapAccessTokenToFbid.put(accessToken, fbid);
+        }
+
+        public void addAccessTokenToFbidMapping(AccessToken accessToken, String fbid) {
+            mapAccessTokenToFbid.put(accessToken.getToken(), fbid);
+        }
+
+        public void setPermissionsToReport(List<String> permissionsToReport) {
+            this.permissionsToReport = permissionsToReport;
+        }
+
+        @Override
+        void complete(Result result) {
+            super.complete(result);
+            blocker.signal();
+        }
+
+        @Override
+        Request createGetProfileIdRequest(final String accessToken) {
+            return new MockRequest() {
+                @Override
+                public Response createResponse() {
+                    String fbid = mapAccessTokenToFbid.get(accessToken);
+                    GraphUser user = GraphObject.Factory.create(GraphUser.class);
+                    user.setId(fbid);
+                    return new Response(this, null, user, false);
+                }
+            };
+        }
+
+        @Override
+        Request createGetPermissionsRequest(String accessToken) {
+            final List<String> permissions = permissionsToReport;
+            return new MockRequest() {
+                @Override
+                public Response createResponse() {
+                    GraphObject permissionsObject = GraphObject.Factory.create();
+                    if (permissions != null) {
+                        for (String permission : permissions) {
+                            permissionsObject.setProperty(permission, 1);
+                        }
+                    }
+                    GraphObjectList<GraphObject> data = GraphObject.Factory.createList(GraphObject.class);
+                    data.add(permissionsObject);
+
+                    GraphMultiResult result = GraphObject.Factory.create(GraphMultiResult.class);
+                    result.setProperty("data", data);
+
+                    return new Response(this, null, result, false);
+                }
+            };
+        }
+
+        @Override
+        RequestBatch createReauthValidationBatch(final Result pendingResult) {
+            RequestBatch batch = super.createReauthValidationBatch(pendingResult);
+
+            batch.setCallbackHandler(blocker.getHandler());
+            // Turn it into a MockRequestBatch.
+            return new MockRequestBatch(batch);
+        }
+    }
+
+    static final String USER_1_FBID = "user1";
+    static final String USER_1_ACCESS_TOKEN = "An access token for user 1";
+    static final String USER_2_FBID = "user2";
+    static final String USER_2_ACCESS_TOKEN = "An access token for user 2";
+
+    AuthorizationClient.AuthorizationRequest createNewPermissionRequest(String accessToken) {
+        Session.NewPermissionsRequest request = new Session.NewPermissionsRequest(getActivity(), PERMISSIONS);
+        request.setValidateSameFbidAsToken(accessToken);
+        return request.getAuthorizationClientRequest();
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testReauthorizationWithSameFbidSucceeds() throws Exception {
+        TestBlocker blocker = getTestBlocker();
+
+        MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient(blocker);
+        client.addAccessTokenToFbidMapping(USER_1_ACCESS_TOKEN, USER_1_FBID);
+        client.addAccessTokenToFbidMapping(USER_2_ACCESS_TOKEN, USER_2_FBID);
+        client.setPermissionsToReport(PERMISSIONS);
+
+        AuthorizationClient.AuthorizationRequest request = createNewPermissionRequest(USER_1_ACCESS_TOKEN);
+        client.setRequest(request);
+
+        AccessToken token = AccessToken.createFromExistingAccessToken(USER_1_ACCESS_TOKEN, null, null, null, PERMISSIONS);
+        AuthorizationClient.Result result = AuthorizationClient.Result.createTokenResult(token);
+
+        client.completeAndValidate(result);
+
+        blocker.waitForSignals(1);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
+
+        AccessToken resultToken = client.result.token;
+        assertNotNull(resultToken);
+        assertEquals(USER_1_ACCESS_TOKEN, resultToken.getToken());
+        assertEquals(PERMISSIONS, resultToken.getPermissions());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testReauthorizationWithFewerPermissionsSucceeds() throws Exception {
+        TestBlocker blocker = getTestBlocker();
+
+        MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient(blocker);
+        client.addAccessTokenToFbidMapping(USER_1_ACCESS_TOKEN, USER_1_FBID);
+        client.addAccessTokenToFbidMapping(USER_2_ACCESS_TOKEN, USER_2_FBID);
+        client.setPermissionsToReport(Arrays.asList("go outside"));
+
+        AuthorizationClient.AuthorizationRequest request = createNewPermissionRequest(USER_1_ACCESS_TOKEN);
+        client.setRequest(request);
+
+        AccessToken token = AccessToken.createFromExistingAccessToken(USER_1_ACCESS_TOKEN, null, null, null, PERMISSIONS);
+        AuthorizationClient.Result result = AuthorizationClient.Result.createTokenResult(token);
+
+        client.completeAndValidate(result);
+
+        blocker.waitForSignals(1);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
+
+        AccessToken resultToken = client.result.token;
+        assertNotNull(resultToken);
+        assertEquals(USER_1_ACCESS_TOKEN, resultToken.getToken());
+        assertEquals(Arrays.asList("go outside"), resultToken.getPermissions());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testReauthorizationWithDifferentFbidsFails() throws Exception {
+        TestBlocker blocker = getTestBlocker();
+
+        MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient(blocker);
+        client.addAccessTokenToFbidMapping(USER_1_ACCESS_TOKEN, USER_1_FBID);
+        client.addAccessTokenToFbidMapping(USER_2_ACCESS_TOKEN, USER_2_FBID);
+        client.setPermissionsToReport(PERMISSIONS);
+
+        AuthorizationClient.AuthorizationRequest request = createNewPermissionRequest(USER_1_ACCESS_TOKEN);
+        client.setRequest(request);
+
+        AccessToken token = AccessToken.createFromExistingAccessToken(USER_2_ACCESS_TOKEN, null, null, null, PERMISSIONS);
+        AuthorizationClient.Result result = AuthorizationClient.Result.createTokenResult(token);
+
+        client.completeAndValidate(result);
+
+        blocker.waitForSignals(1);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.ERROR, client.result.code);
+
+        assertNull(client.result.token);
+        assertNotNull(client.result.errorMessage);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testLegacyReauthDoesntValidate() throws Exception {
+        TestBlocker blocker = getTestBlocker();
+
+        MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient(blocker);
+        AuthorizationClient.AuthorizationRequest request = createNewPermissionRequest(USER_1_ACCESS_TOKEN);
+        request.setIsLegacy(true);
+        client.setRequest(request);
+
+        AccessToken token = AccessToken.createFromExistingAccessToken(USER_2_ACCESS_TOKEN, null, null, null, PERMISSIONS);
+        AuthorizationClient.Result result = AuthorizationClient.Result.createTokenResult(token);
+
+        client.completeAndValidate(result);
+
+        AccessToken resultToken = client.result.token;
+        assertNotNull(resultToken);
+        assertEquals(USER_2_ACCESS_TOKEN, resultToken.getToken());
+        assertEquals(PERMISSIONS, resultToken.getPermissions());
+    }
+
+    // Serialization tests
+
+    static class DoNothingAuthorizationClient extends AuthorizationClient {
+        // Don't actually do anything.
+        @Override
+        boolean tryCurrentHandler() {
+            return true;
+        }
+    }
+
+    public void testSerialization() throws IOException, ClassNotFoundException {
+        AuthorizationClient client = new DoNothingAuthorizationClient();
+
+        // Call this to set up some state.
+        client.setContext(getActivity());
+        client.setOnCompletedListener(new AuthorizationClient.OnCompletedListener() {
+            @Override
+            public void onCompleted(AuthorizationClient.Result result) {
+            }
+        });
+        client.setBackgroundProcessingListener(new AuthorizationClient.BackgroundProcessingListener() {
+            @Override
+            public void onBackgroundProcessingStarted() {
+            }
+
+            @Override
+            public void onBackgroundProcessingStopped() {
+            }
+        });
+        client.authorize(createRequest());
+
+        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+        ObjectOutputStream outputStream = new ObjectOutputStream(byteArrayOutputStream);
+        outputStream.writeObject(client);
+        outputStream.close();
+
+        byte [] byteArray = byteArrayOutputStream.toByteArray();
+
+        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArray);
+        ObjectInputStream inputStream = new ObjectInputStream(byteArrayInputStream);
+
+        Object obj = inputStream.readObject();
+        assertNotNull(obj);
+        assertTrue(obj instanceof AuthorizationClient);
+
+        AuthorizationClient resultClient = (AuthorizationClient)obj;
+        assertNull(resultClient.startActivityDelegate);
+        assertNull(resultClient.onCompletedListener);
+        assertNull(resultClient.backgroundProcessingListener);
+        assertNull(resultClient.context);
+        assertNotNull(resultClient.currentHandler);
+        assertTrue(resultClient.currentHandler instanceof AuthorizationClient.GetTokenAuthHandler);
+        assertNotNull(resultClient.handlersToTry);
+        assertTrue(resultClient.handlersToTry.size() > 0);
+        assertNotNull(resultClient.pendingRequest);
+        assertEquals(PERMISSIONS, resultClient.pendingRequest.getPermissions());
+    }
+}
diff --git a/facebook/tests/src/com/facebook/BatchRequestTests.java b/facebook/tests/src/com/facebook/BatchRequestTests.java
index a6c67c49b..e94c450ac 100644
--- a/facebook/tests/src/com/facebook/BatchRequestTests.java
+++ b/facebook/tests/src/com/facebook/BatchRequestTests.java
@@ -13,17 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.facebook;
 
 import android.graphics.Bitmap;
-import android.os.Handler;
 import android.test.suitebuilder.annotation.LargeTest;
 import android.test.suitebuilder.annotation.MediumTest;
 import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphPlace;
+import com.facebook.model.GraphUser;
+import com.facebook.internal.CacheableRequestBatch;
 
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
 
 public class BatchRequestTests extends FacebookTestCase {
     protected void setUp() throws Exception {
@@ -37,7 +42,7 @@ protected void setUp() throws Exception {
     @MediumTest
     @LargeTest
     public void testCreateEmptyRequestBatch() {
-        RequestBatch batch = new RequestBatch();
+        CacheableRequestBatch batch = new CacheableRequestBatch();
 
         Request meRequest = Request.newMeRequest(null, null);
         assertEquals(0, batch.size());
@@ -46,15 +51,9 @@ public void testCreateEmptyRequestBatch() {
         assertEquals(meRequest, batch.get(0));
 
         String key = "The Key";
-        assertNull(batch.getCacheKey());
-        batch.setCacheKey(key);
-        assertEquals(key, batch.getCacheKey());
-
-        TestBlocker blocker = getTestBlocker();
-        Handler handler = blocker.getHandler();
-        assertNull(batch.getCallbackHandler());
-        batch.setCallbackHandler(handler);
-        assertNotNull(batch.getCallbackHandler());
+        assertNull(batch.getCacheKeyOverride());
+        batch.setCacheKeyOverride(key);
+        assertEquals(key, batch.getCacheKeyOverride());
 
         assertTrue(!batch.getForceRoundTrip());
         batch.setForceRoundTrip(true);
@@ -117,11 +116,10 @@ public void testFacebookErrorResponsesCreateErrors() {
         assertTrue(responses.get(0).getError() != null);
         assertTrue(responses.get(1).getError() != null);
 
-        FacebookException exception1 = responses.get(0).getError();
-        assertTrue(exception1 instanceof FacebookServiceErrorException);
-        FacebookServiceErrorException serviceException1 = (FacebookServiceErrorException) exception1;
-        assertTrue(serviceException1.getFacebookErrorType() != null);
-        assertTrue(serviceException1.getFacebookErrorCode() != FacebookServiceErrorException.UNKNOWN_ERROR_CODE);
+        FacebookRequestError error = responses.get(0).getError();
+        assertTrue(error.getException() instanceof FacebookServiceException);
+        assertTrue(error.getErrorType() != null);
+        assertTrue(error.getErrorCode() != FacebookRequestError.INVALID_ERROR_CODE);
     }
 
     @LargeTest
@@ -272,6 +270,20 @@ public void testMixedSuccessAndFailure() {
         }
     }
 
+    @MediumTest
+    @LargeTest
+    public void testClosedSessionDoesntAppendAccessToken() {
+        TestSession session = openTestSessionWithSharedUser();
+        session.close();
+        Request request1 = new Request(session, "me", null, null, new ExpectFailureCallback());
+        Request request2 = new Request(session, "me", null, null, new ExpectFailureCallback());
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(request1, request2);
+        task.executeOnBlockerThread();
+
+        waitAndAssertSuccess(2);
+    }
+
     @LargeTest
     public void testBatchUploadPhoto() {
         TestSession session = openTestSessionWithSharedUserAndPermissions(null, "user_photos");
@@ -333,13 +345,13 @@ public void onCompleted(Response response) {
     @MediumTest
     @LargeTest
     public void testCacheMyFriendsRequest() throws IOException {
-        Response.getResponseCache().clear();
+        Response.getResponseCache().clearForTest();
         TestSession session = openTestSessionWithSharedUser();
 
         Request request = Request.newMyFriendsRequest(session, null);
 
-        RequestBatch batch = new RequestBatch(request);
-        batch.setCacheKey("MyFriends");
+        CacheableRequestBatch batch = new CacheableRequestBatch(request);
+        batch.setCacheKeyOverride("MyFriends");
 
         // Running the request with empty cache should hit the server.
         List<Response> responses = Request.executeBatchAndWait(batch);
@@ -372,20 +384,20 @@ public void testCacheMyFriendsRequest() throws IOException {
         assertNull(response.getError());
         assertTrue(!response.getIsFromCache());
 
-        Response.getResponseCache().clear();
+        Response.getResponseCache().clearForTest();
     }
 
     @MediumTest
     @LargeTest
     public void testCacheMeAndMyFriendsRequest() throws IOException {
-        Response.getResponseCache().clear();
+        Response.getResponseCache().clearForTest();
         TestSession session = openTestSessionWithSharedUser();
 
         Request requestMe = Request.newMeRequest(session, null);
         Request requestMyFriends = Request.newMyFriendsRequest(session, null);
 
-        RequestBatch batch = new RequestBatch(new Request[] { requestMyFriends, requestMe });
-        batch.setCacheKey("MyFriends");
+        CacheableRequestBatch batch = new CacheableRequestBatch(new Request[] { requestMyFriends, requestMe });
+        batch.setCacheKeyOverride("MyFriends");
 
         // Running the request with empty cache should hit the server.
         List<Response> responses = Request.executeBatchAndWait(batch);
@@ -421,7 +433,7 @@ public void testCacheMeAndMyFriendsRequest() throws IOException {
             assertTrue(!response.getIsFromCache());
         }
 
-        Response.getResponseCache().clear();
+        Response.getResponseCache().clearForTest();
     }
 
     @MediumTest
@@ -464,4 +476,62 @@ public void testExplicitDependencyCanIncludeFirstResponse() {
         assertNotNull(meResponse.getGraphObject());
         assertNotNull(myFriendsResponse.getGraphObject());
     }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testAddAndRemoveBatchCallbacks() {
+        RequestBatch batch = new RequestBatch();
+
+        RequestBatch.Callback callback1 = new RequestBatch.Callback() {
+            @Override
+            public void onBatchCompleted(RequestBatch batch) {
+            }
+        };
+
+        RequestBatch.Callback callback2 = new RequestBatch.Callback() {
+            @Override
+            public void onBatchCompleted(RequestBatch batch) {
+            }
+        };
+
+        batch.addCallback(callback1);
+        batch.addCallback(callback2);
+
+        assertEquals(2, batch.getCallbacks().size());
+
+        batch.removeCallback(callback1);
+        batch.removeCallback(callback2);
+
+        assertEquals(0, batch.getCallbacks().size());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testBatchCallbackIsCalled() {
+        final AtomicInteger count = new AtomicInteger();
+        Request request1 = Request.newGraphPathRequest(null, "4", new Request.Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                count.incrementAndGet();
+            }
+        });
+        Request request2 = Request.newGraphPathRequest(null, "4", new Request.Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                count.incrementAndGet();
+            }
+        });
+
+        RequestBatch batch = new RequestBatch(request1, request2);
+        batch.addCallback(new RequestBatch.Callback() {
+            @Override
+            public void onBatchCompleted(RequestBatch batch) {
+                count.incrementAndGet();
+            }
+        });
+
+        batch.executeAndWait();
+        assertEquals(3, count.get());
+    }
 }
diff --git a/facebook/tests/src/com/facebook/FacebookActivityTestCase.java b/facebook/tests/src/com/facebook/FacebookActivityTestCase.java
index eba3175b1..a3292c30f 100644
--- a/facebook/tests/src/com/facebook/FacebookActivityTestCase.java
+++ b/facebook/tests/src/com/facebook/FacebookActivityTestCase.java
@@ -25,13 +25,14 @@
 import android.os.Handler;
 import android.test.ActivityInstrumentationTestCase2;
 import android.util.Log;
+import com.facebook.model.GraphObject;
+import com.facebook.internal.Utility;
 import junit.framework.AssertionFailedError;
 import org.json.JSONException;
 import org.json.JSONObject;
 import org.json.JSONTokener;
 
-import java.io.IOException;
-import java.io.InputStream;
+import java.io.*;
 import java.net.HttpURLConnection;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -68,13 +69,12 @@ protected TestSession getTestSessionWithSharedUser() {
 
     // Returns an un-opened TestSession
     protected TestSession getTestSessionWithSharedUser(String sessionUniqueUserTag) {
-        return getTestSessionWithSharedUserAndPermissions(sessionUniqueUserTag, (String[]) null);
+        return getTestSessionWithSharedUserAndPermissions(sessionUniqueUserTag, new ArrayList<String>());
     }
 
     protected TestSession getTestSessionWithSharedUserAndPermissions(String sessionUniqueUserTag,
-            String... permissions) {
-        List<String> permissionsList = (permissions != null) ? Arrays.asList(permissions) : null;
-        return TestSession.createSessionWithSharedUser(getActivity(), permissionsList, sessionUniqueUserTag);
+            List<String> permissions) {
+        return TestSession.createSessionWithSharedUser(getActivity(), permissions, sessionUniqueUserTag);
     }
 
     // Returns an un-opened TestSession
@@ -102,6 +102,12 @@ protected TestSession openTestSessionWithSharedUser(String sessionUniqueUserTag)
 
     protected TestSession openTestSessionWithSharedUserAndPermissions(String sessionUniqueUserTag,
             String... permissions) {
+        List<String> permissionList = (permissions != null) ? Arrays.asList(permissions) : null;
+        return openTestSessionWithSharedUserAndPermissions(sessionUniqueUserTag, permissionList);
+    }
+
+    protected TestSession openTestSessionWithSharedUserAndPermissions(String sessionUniqueUserTag,
+            List<String> permissions) {
         final TestBlocker blocker = getTestBlocker();
         TestSession session = getTestSessionWithSharedUserAndPermissions(sessionUniqueUserTag, permissions);
         openSession(getActivity(), session, blocker);
@@ -171,11 +177,8 @@ protected synchronized void readApplicationIdAndSecret() {
                     fail(errorMessage + "one or both config values are missing");
                 }
 
-                String machineUniqueUserTag = jsonObject.optString("machineUniqueUserTag");
-
                 TestSession.setTestApplicationId(applicationId);
                 TestSession.setTestApplicationSecret(applicationSecret);
-                TestSession.setMachineUniqueUserTag(machineUniqueUserTag);
             } catch (IOException e) {
                 fail(errorMessage + e.toString());
             } catch (JSONException e) {
@@ -228,8 +231,8 @@ protected void setUp() throws Exception {
         readApplicationIdAndSecret();
 
         // These are useful for debugging unit test failures.
-        Settings.addLoggingBehavior(LoggingBehaviors.REQUESTS);
-        Settings.addLoggingBehavior(LoggingBehaviors.INCLUDE_ACCESS_TOKENS);
+        Settings.addLoggingBehavior(LoggingBehavior.REQUESTS);
+        Settings.addLoggingBehavior(LoggingBehavior.INCLUDE_ACCESS_TOKENS);
 
         // We want the UI thread to be in StrictMode to catch any violations.
         turnOnStrictModeForUiThread();
@@ -243,6 +246,19 @@ protected void tearDown() throws Exception {
         }
     }
 
+    protected Bundle getNativeLinkingExtras(String token) {
+        Bundle extras = new Bundle();
+        String extraLaunchUriString = String
+                .format("fbrpc://facebook/nativethirdparty?app_id=%s&package_name=com.facebook.sdk.tests&class_name=com.facebook.FacebookActivityTests$FacebookTestActivity&access_token=%s",
+                        TestSession.getTestApplicationId(), token);
+        extras.putString("extra_launch_uri", extraLaunchUriString);
+        extras.putString("expires_in", "3600");
+        extras.putLong("app_id", Long.parseLong(TestSession.getTestApplicationId()));
+        extras.putString("access_token", token);
+
+        return extras;
+    }
+
     interface GraphObjectPostResult extends GraphObject {
         String getId();
     }
@@ -252,8 +268,7 @@ protected GraphObject getAndAssert(Session session, String id) {
         Response response = request.executeAndWait();
         assertNotNull(response);
 
-        Exception exception = response.getError();
-        assertNull(exception);
+        assertNull(response.getError());
 
         GraphObject result = response.getGraphObject();
         assertNotNull(result);
@@ -266,8 +281,7 @@ protected GraphObject postGetAndAssert(Session session, String path, GraphObject
         Response response = request.executeAndWait();
         assertNotNull(response);
 
-        Exception exception = response.getError();
-        assertNull(exception);
+        assertNull(response.getError());
 
         GraphObjectPostResult result = response.getGraphObjectAs(GraphObjectPostResult.class);
         assertNotNull(result);
@@ -318,7 +332,7 @@ protected void setBatchApplicationIdForTestApp() {
     }
 
     protected GraphObject createStatusUpdate() {
-        GraphObject statusUpdate = GraphObjectWrapper.createGraphObject();
+        GraphObject statusUpdate = GraphObject.Factory.create();
         String message = String.format(
                 "Check out my awesome new status update posted at: %s. Some chars for you: +\"[]:,", new Date());
         statusUpdate.setProperty("message", message);
@@ -336,10 +350,8 @@ protected void issueFriendRequest(TestSession session, String targetUserId) {
         Request request = Request.newPostRequest(session, graphPath, null, null);
         Response response = request.executeAndWait();
         // We will get a 400 error if the users are already friends.
-        FacebookException error = response.getError();
-        assertTrue(error == null ||
-                (error instanceof FacebookServiceErrorException && ((FacebookServiceErrorException) error)
-                        .getHttpResponseCode() == 400));
+        FacebookRequestError error = response.getError();
+        assertTrue(error == null || error.getRequestStatusCode() == 400);
     }
 
     protected void makeTestUsersFriends(TestSession session1, TestSession session2) {
@@ -347,6 +359,16 @@ protected void makeTestUsersFriends(TestSession session1, TestSession session2)
         issueFriendRequest(session2, session1.getTestUserId());
     }
 
+    protected void assertDateEqualsWithinDelta(Date expected, Date actual, long deltaInMsec) {
+        long delta = Math.abs(expected.getTime() - actual.getTime());
+        assertTrue(delta < deltaInMsec);
+    }
+
+    protected void assertDateDiffersWithinDelta(Date expected, Date actual, long expectedDifference, long deltaInMsec) {
+        long delta = Math.abs(expected.getTime() - actual.getTime()) - expectedDifference;
+        assertTrue(delta < deltaInMsec);
+    }
+
     protected void assertNoErrors(List<Response> responses) {
         for (int i = 0; i < responses.size(); ++i) {
             Response response = responses.get(i);
@@ -355,6 +377,32 @@ protected void assertNoErrors(List<Response> responses) {
         }
     }
 
+    protected File createTempFileFromAsset(String assetPath) throws IOException {
+        InputStream inputStream = null;
+        FileOutputStream outStream = null;
+
+        try {
+            AssetManager assets = getInstrumentation().getContext().getResources().getAssets();
+            inputStream = assets.open(assetPath);
+
+            File outputDir = getActivity().getCacheDir(); // context being the Activity pointer
+            File outputFile = File.createTempFile("prefix", assetPath, outputDir);
+            outStream = new FileOutputStream(outputFile);
+
+            final int bufferSize = 1024 * 2;
+            byte[] buffer = new byte[bufferSize];
+            int n = 0;
+            while ((n = inputStream.read(buffer)) != -1) {
+                outStream.write(buffer, 0, n);
+            }
+
+            return outputFile;
+        } finally {
+            Utility.closeQuietly(outStream);
+            Utility.closeQuietly(inputStream);
+        }
+    }
+
     protected void runOnBlockerThread(final Runnable runnable, boolean waitForCompletion) {
         Runnable runnableToPost = runnable;
         final ConditionVariable condition = waitForCompletion ? new ConditionVariable(!waitForCompletion) : null;
@@ -525,7 +573,7 @@ public void onCompleted(Response response) {
 
                 // We expect either success or failure.
                 if (expectSuccess && response.getError() != null) {
-                    throw response.getError();
+                    throw response.getError().getException();
                 } else if (!expectSuccess && response.getError() == null) {
                     throw new FacebookException("Expected failure case, received no error");
                 }
@@ -558,7 +606,38 @@ public ExpectFailureCallback() {
         }
     }
 
+    public static abstract class MockRequest extends Request {
+        public abstract Response createResponse();
+    }
+
+    public static class MockRequestBatch extends RequestBatch {
+        public MockRequestBatch(MockRequest... requests) {
+            super(requests);
+        }
+
+        // Caller must ensure that all the requests in the batch are, in fact, MockRequests.
+        public MockRequestBatch(RequestBatch requests) {
+            super(requests);
+        }
+
+        @Override
+        List<Response> executeAndWaitImpl() {
+            List<Request> requests = getRequests();
+
+            List<Response> responses = new ArrayList<Response>();
+            for (Request request : requests) {
+                MockRequest mockRequest = (MockRequest) request;
+                responses.add(mockRequest.createResponse());
+            }
+
+            Request.runCallbacks(this, responses);
+
+            return responses;
+        }
+    }
+
     private AtomicBoolean strictModeOnForUiThread = new AtomicBoolean();
+
     protected void turnOnStrictModeForUiThread() {
         // We only ever need to do this once. If the boolean is true, we know that the next runnable
         // posted to the UI thread will have strict mode on.
diff --git a/facebook/tests/src/com/facebook/FacebookActivityTests.java b/facebook/tests/src/com/facebook/FacebookActivityTests.java
new file mode 100644
index 000000000..df7177214
--- /dev/null
+++ b/facebook/tests/src/com/facebook/FacebookActivityTests.java
@@ -0,0 +1,75 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+
+public class FacebookActivityTests extends FacebookActivityTestCase<FacebookActivityTests.FacebookTestActivity> {
+    public FacebookActivityTests() {
+        super(FacebookActivityTests.FacebookTestActivity.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+
+        Session activeSession = Session.getActiveSession();
+        if (activeSession != null) {
+            activeSession.closeAndClearTokenInformation();
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testLaunchingWithEmptyIntent() {
+        Intent intent = new Intent(Intent.ACTION_MAIN);
+        setActivityIntent(intent);
+        FacebookTestActivity activity = getActivity();
+
+        assertNull(Session.getActiveSession());
+        assertFalse(activity.hasNativeLinkIntentForTesting());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testLaunchingWithValidNativeLinkingIntent() {
+        final String token = "A token less unique than most";
+
+        Intent intent = new Intent(Intent.ACTION_MAIN);
+        intent.putExtras(getNativeLinkingExtras(token));
+        setActivityIntent(intent);
+
+        assertNull(Session.getActiveSession());
+
+        FacebookTestActivity activity = getActivity();
+        Session activeSession = Session.getActiveSession();
+        assertNull(activeSession);
+        assertTrue(activity.hasNativeLinkIntentForTesting());
+    }
+
+    public static class FacebookTestActivity extends Activity {
+        public boolean hasNativeLinkIntentForTesting() {
+            return AccessToken.createFromNativeLinkingIntent(getIntent()) != null;
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/FacebookRequestErrorTests.java b/facebook/tests/src/com/facebook/FacebookRequestErrorTests.java
new file mode 100644
index 000000000..34b6c45b8
--- /dev/null
+++ b/facebook/tests/src/com/facebook/FacebookRequestErrorTests.java
@@ -0,0 +1,321 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import com.facebook.sdk.tests.R;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+public class FacebookRequestErrorTests extends FacebookTestCase {
+    public static final String ERROR_SINGLE_RESPONSE =
+            "{\n" +
+            "  \"error\": {\n" +
+            "    \"message\": \"Unknown path components: /unknown\",\n" +
+            "    \"type\": \"OAuthException\",\n" +
+            "    \"code\": 2500\n" +
+            "  }\n" +
+            "}";
+
+    public static final String ERROR_BATCH_RESPONSE =
+            "[\n" +
+            "  {\n" +
+            "    \"headers\": [\n" +
+            "      {\n" +
+            "        \"value\": \"*\",\n" +
+            "        \"name\": \"Access-Control-Allow-Origin\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"no-store\",\n" +
+            "        \"name\": \"Cache-Control\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"close\",\n" +
+            "        \"name\": \"Connection\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"text\\/javascript; charset=UTF-8\",\n" +
+            "        \"name\": \"Content-Type\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"Sat, 01 Jan 2000 00:00:00 GMT\",\n" +
+            "        \"name\": \"Expires\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"no-cache\",\n" +
+            "        \"name\": \"Pragma\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"OAuth \\\"Facebook Platform\\\" \\\"invalid_request\\\" \\\"An active access token must be used to query information about the current user.\\\"\",\n" +
+            "        \"name\": \"WWW-Authenticate\"\n" +
+            "      }\n" +
+            "    ],\n" +
+            "    \"body\": \"{\\\"error\\\":{\\\"message\\\":\\\"An active access token must be used to query information about the current user.\\\",\\\"type\\\":\\\"OAuthException\\\",\\\"code\\\":2500}}\",\n" +
+            "    \"code\": 400\n" +
+            "  },\n" +
+            "  {\n" +
+            "    \"headers\": [\n" +
+            "      {\n" +
+            "        \"value\": \"*\",\n" +
+            "        \"name\": \"Access-Control-Allow-Origin\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"no-store\",\n" +
+            "        \"name\": \"Cache-Control\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"close\",\n" +
+            "        \"name\": \"Connection\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"text\\/javascript; charset=UTF-8\",\n" +
+            "        \"name\": \"Content-Type\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"Sat, 01 Jan 2000 00:00:00 GMT\",\n" +
+            "        \"name\": \"Expires\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"no-cache\",\n" +
+            "        \"name\": \"Pragma\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"OAuth \\\"Facebook Platform\\\" \\\"invalid_request\\\" \\\"An active access token must be used to query information about the current user.\\\"\",\n" +
+            "        \"name\": \"WWW-Authenticate\"\n" +
+            "      }\n" +
+            "    ],\n" +
+            "    \"body\": \"{\\\"error\\\":{\\\"message\\\":\\\"An active access token must be used to query information about the current user.\\\",\\\"type\\\":\\\"OAuthException\\\",\\\"code\\\":2500}}\",\n" +
+            "    \"code\": 400\n" +
+            "  }\n" +
+            "]";
+
+
+    public static final String ERROR_SINGLE_RESPONSE_THROTTLE =
+            "{\n" +
+            "  \"error\": {\n" +
+            "    \"message\": \"Application request limit reached\",\n" +
+            "    \"code\": 4\n" +
+            "  }\n" +
+            "}";
+
+    public static final String ERROR_SINGLE_RESPONSE_SERVER =
+            "{\n" +
+            "  \"error\": {\n" +
+            "    \"message\": \"Some Server Error\",\n" +
+            "    \"code\": 2\n" +
+            "  }\n" +
+            "}";
+
+    public static final String ERROR_SINGLE_RESPONSE_PERMISSION =
+            "{\n" +
+            "  \"error\": {\n" +
+            "    \"type\": \"OAuthException\",\n" +
+            "    \"message\": \"(#200) Requires extended permission: publish_actions\",\n" +
+            "    \"code\": 200\n" +
+            "  }\n" +
+            "}";
+
+    public static final String ERROR_SINGLE_RESPONSE_WEB_LOGIN =
+            "{\n" +
+            "  \"error\": {\n" +
+            "    \"message\": \"User need to login\",\n" +
+            "    \"type\": \"OAuthException\",\n" +
+            "    \"code\": 102,\n" +
+            "    \"error_subcode\": 459\n" +
+            "  }\n" +
+            "}";
+
+    public static final String ERROR_SINGLE_RESPONSE_RELOGIN =
+            "{\n" +
+            "  \"error\": {\n" +
+            "    \"message\": \"User need to relogin\",\n" +
+            "    \"type\": \"OAuthException\",\n" +
+            "    \"code\": 102\n" +
+            "  }\n" +
+            "}";
+
+    public static final String ERROR_SINGLE_RESPONSE_RELOGIN_DELETED_APP =
+            "{\n" +
+            "  \"error\": {\n" +
+            "    \"message\": \"User need to relogin\",\n" +
+            "    \"type\": \"OAuthException\",\n" +
+            "    \"code\": 190,\n" +
+            "    \"error_subcode\": 458\n" +
+            "  }\n" +
+            "}";
+
+    public void testClientException() {
+        final String errorMsg = "some error happened";
+        FacebookRequestError error = new FacebookRequestError(null, new FacebookException(errorMsg));
+        assertEquals(errorMsg, error.getErrorMessage());
+        assertEquals(FacebookRequestError.Category.CLIENT, error.getCategory());
+        assertEquals(FacebookRequestError.INVALID_ERROR_CODE, error.getErrorCode());
+        assertEquals(FacebookRequestError.INVALID_HTTP_STATUS_CODE, error.getRequestStatusCode());
+        assertEquals(0, error.getUserActionMessageId());
+    }
+
+    public void testSingleRequestWithoutBody() throws JSONException {
+        JSONObject withStatusCode = new JSONObject();
+        withStatusCode.put("code", 400);
+        FacebookRequestError error =
+                FacebookRequestError.checkResponseAndCreateError(withStatusCode, withStatusCode, null);
+        assertNotNull(error);
+        assertEquals(400, error.getRequestStatusCode());
+        assertEquals(FacebookRequestError.Category.BAD_REQUEST, error.getCategory());
+        assertEquals(0, error.getUserActionMessageId());
+    }
+
+    public void testSingleErrorWithBody() throws JSONException {
+        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE);
+        JSONObject withStatusCodeAndBody = new JSONObject();
+        withStatusCodeAndBody.put("code", 400);
+        withStatusCodeAndBody.put("body", originalResponse);
+        FacebookRequestError error =
+                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+        assertNotNull(error);
+        assertEquals(400, error.getRequestStatusCode());
+        assertEquals("Unknown path components: /unknown", error.getErrorMessage());
+        assertEquals("OAuthException", error.getErrorType());
+        assertEquals(2500, error.getErrorCode());
+        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
+        assertEquals(FacebookRequestError.Category.BAD_REQUEST, error.getCategory());
+        assertEquals(0, error.getUserActionMessageId());
+    }
+
+    public void testBatchRequest() throws JSONException {
+        JSONArray batchResponse = new JSONArray(ERROR_BATCH_RESPONSE);
+        assertEquals(2, batchResponse.length());
+        JSONObject firstResponse = (JSONObject) batchResponse.get(0);
+        FacebookRequestError error =
+                FacebookRequestError.checkResponseAndCreateError(firstResponse, batchResponse, null);
+        assertNotNull(error);
+        assertEquals(400, error.getRequestStatusCode());
+        assertEquals("An active access token must be used to query information about the current user.",
+                error.getErrorMessage());
+        assertEquals("OAuthException", error.getErrorType());
+        assertEquals(2500, error.getErrorCode());
+        assertTrue(error.getBatchRequestResult() instanceof  JSONArray);
+        assertEquals(FacebookRequestError.Category.BAD_REQUEST, error.getCategory());
+        assertEquals(0, error.getUserActionMessageId());
+    }
+
+    public void testSingleThrottledError() throws JSONException {
+        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_THROTTLE);
+        JSONObject withStatusCodeAndBody = new JSONObject();
+        withStatusCodeAndBody.put("code", 403);
+        withStatusCodeAndBody.put("body", originalResponse);
+        FacebookRequestError error =
+                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+        assertNotNull(error);
+        assertEquals(403, error.getRequestStatusCode());
+        assertEquals("Application request limit reached", error.getErrorMessage());
+        assertNull(error.getErrorType());
+        assertEquals(4, error.getErrorCode());
+        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
+        assertEquals(FacebookRequestError.Category.THROTTLING, error.getCategory());
+        assertEquals(0, error.getUserActionMessageId());
+    }
+
+    public void testSingleServerError() throws JSONException {
+        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_SERVER);
+        JSONObject withStatusCodeAndBody = new JSONObject();
+        withStatusCodeAndBody.put("code", 500);
+        withStatusCodeAndBody.put("body", originalResponse);
+        FacebookRequestError error =
+                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+        assertNotNull(error);
+        assertEquals(500, error.getRequestStatusCode());
+        assertEquals("Some Server Error", error.getErrorMessage());
+        assertNull(error.getErrorType());
+        assertEquals(2, error.getErrorCode());
+        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
+        assertEquals(FacebookRequestError.Category.SERVER, error.getCategory());
+        assertEquals(0, error.getUserActionMessageId());
+    }
+
+    public void testSinglePermissionError() throws JSONException {
+        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_PERMISSION);
+        JSONObject withStatusCodeAndBody = new JSONObject();
+        withStatusCodeAndBody.put("code", 400);
+        withStatusCodeAndBody.put("body", originalResponse);
+        FacebookRequestError error =
+                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+        assertNotNull(error);
+        assertEquals(400, error.getRequestStatusCode());
+        assertEquals("(#200) Requires extended permission: publish_actions", error.getErrorMessage());
+        assertEquals("OAuthException", error.getErrorType());
+        assertEquals(200, error.getErrorCode());
+        assertEquals(FacebookRequestError.INVALID_ERROR_CODE, error.getSubErrorCode());
+        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
+        assertEquals(FacebookRequestError.Category.PERMISSION, error.getCategory());
+        assertEquals(R.string.com_facebook_requesterror_permissions, error.getUserActionMessageId());
+    }
+
+    public void testSingleWebLoginError() throws JSONException {
+        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_WEB_LOGIN);
+        JSONObject withStatusCodeAndBody = new JSONObject();
+        withStatusCodeAndBody.put("code", 400);
+        withStatusCodeAndBody.put("body", originalResponse);
+        FacebookRequestError error =
+                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+        assertNotNull(error);
+        assertEquals(400, error.getRequestStatusCode());
+        assertEquals("User need to login", error.getErrorMessage());
+        assertEquals("OAuthException", error.getErrorType());
+        assertEquals(102, error.getErrorCode());
+        assertEquals(459, error.getSubErrorCode());
+        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
+        assertEquals(FacebookRequestError.Category.AUTHENTICATION_RETRY, error.getCategory());
+        assertEquals(R.string.com_facebook_requesterror_web_login, error.getUserActionMessageId());
+    }
+
+    public void testSingleReloginError() throws JSONException {
+        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_RELOGIN);
+        JSONObject withStatusCodeAndBody = new JSONObject();
+        withStatusCodeAndBody.put("code", 400);
+        withStatusCodeAndBody.put("body", originalResponse);
+        FacebookRequestError error =
+                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+        assertNotNull(error);
+        assertEquals(400, error.getRequestStatusCode());
+        assertEquals("User need to relogin", error.getErrorMessage());
+        assertEquals("OAuthException", error.getErrorType());
+        assertEquals(102, error.getErrorCode());
+        assertEquals(FacebookRequestError.INVALID_ERROR_CODE, error.getSubErrorCode());
+        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
+        assertEquals(FacebookRequestError.Category.AUTHENTICATION_REOPEN_SESSION, error.getCategory());
+        assertEquals(R.string.com_facebook_requesterror_reconnect, error.getUserActionMessageId());
+    }
+
+    public void testSingleReloginDeletedAppError() throws JSONException {
+        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_RELOGIN_DELETED_APP);
+        JSONObject withStatusCodeAndBody = new JSONObject();
+        withStatusCodeAndBody.put("code", 400);
+        withStatusCodeAndBody.put("body", originalResponse);
+        FacebookRequestError error =
+                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+        assertNotNull(error);
+        assertEquals(400, error.getRequestStatusCode());
+        assertEquals("User need to relogin", error.getErrorMessage());
+        assertEquals("OAuthException", error.getErrorType());
+        assertEquals(190, error.getErrorCode());
+        assertEquals(458, error.getSubErrorCode());
+        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
+        assertEquals(FacebookRequestError.Category.AUTHENTICATION_REOPEN_SESSION, error.getCategory());
+        assertEquals(R.string.com_facebook_requesterror_relogin, error.getUserActionMessageId());
+    }
+}
diff --git a/facebook/tests/src/com/facebook/FacebookTestCase.java b/facebook/tests/src/com/facebook/FacebookTestCase.java
index 9900de8a3..88e28c4a7 100644
--- a/facebook/tests/src/com/facebook/FacebookTestCase.java
+++ b/facebook/tests/src/com/facebook/FacebookTestCase.java
@@ -21,8 +21,8 @@
 public class FacebookTestCase extends FacebookActivityTestCase<FacebookTestCase.FacebookTestActivity> {
     public FacebookTestCase() {
         super(FacebookTestCase.FacebookTestActivity.class);
-        Settings.addLoggingBehavior(LoggingBehaviors.REQUESTS);
-        Settings.addLoggingBehavior(LoggingBehaviors.INCLUDE_RAW_RESPONSES);
+        Settings.addLoggingBehavior(LoggingBehavior.REQUESTS);
+        Settings.addLoggingBehavior(LoggingBehavior.INCLUDE_RAW_RESPONSES);
     }
 
     public static class FacebookTestActivity extends Activity {
diff --git a/facebook/tests/src/com/facebook/GraphRequestTests.java b/facebook/tests/src/com/facebook/GraphRequestTests.java
index a00a11239..0f4212164 100644
--- a/facebook/tests/src/com/facebook/GraphRequestTests.java
+++ b/facebook/tests/src/com/facebook/GraphRequestTests.java
@@ -13,9 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.facebook;
 
 import android.test.suitebuilder.annotation.LargeTest;
+import com.facebook.model.GraphObject;
 
 import java.util.Date;
 
@@ -31,7 +33,7 @@ public void testCommentRoundTrip() {
         GraphObject createdStatus = batchCreateAndGet(session, "me/feed", status, null, GraphObject.class);
         String statusID = (String) createdStatus.getProperty("id");
 
-        GraphObject comment = GraphObjectWrapper.createGraphObject();
+        GraphObject comment = GraphObject.Factory.create();
         final String commentMessage = "It truly is a wonderful status update.";
         comment.setProperty("message", commentMessage);
 
@@ -63,7 +65,7 @@ public void testCommentRoundTrip() {
     public void testEventRoundTrip() {
         TestSession session = openTestSessionWithSharedUserAndPermissions(null, "create_event");
 
-        GraphObject event = GraphObjectWrapper.createGraphObject();
+        GraphObject event = GraphObject.Factory.create();
         // Android emulators tend to not have the right date/time. To avoid issues with posting events in the past
         // or too far in the future, we use a constant year. This test will break in 2030, angering our robot overlords.
         Date startTime = new Date(130, 2, 17, 12, 34, 56);
diff --git a/facebook/tests/src/com/facebook/RequestTests.java b/facebook/tests/src/com/facebook/RequestTests.java
index f016ffe6c..f91eab2cd 100644
--- a/facebook/tests/src/com/facebook/RequestTests.java
+++ b/facebook/tests/src/com/facebook/RequestTests.java
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.facebook;
 
 import android.graphics.Bitmap;
@@ -22,11 +23,13 @@
 import android.test.suitebuilder.annotation.LargeTest;
 import android.test.suitebuilder.annotation.MediumTest;
 import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.model.*;
 
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.net.HttpURLConnection;
+import java.net.URISyntaxException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -46,7 +49,7 @@ public void testCreateRequest() {
     @MediumTest
     @LargeTest
     public void testCreatePostRequest() {
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject();
+        GraphObject graphObject = GraphObject.Factory.create();
         Request request = Request.newPostRequest(null, "me/statuses", graphObject, null);
         assertTrue(request != null);
         assertEquals(HttpMethod.POST, request.getHttpMethod());
@@ -94,7 +97,7 @@ public void testCreateUploadPhotoRequest() {
     @SmallTest
     @MediumTest
     @LargeTest
-    public void testCreatePlacesSearchRequest() {
+    public void testCreatePlacesSearchRequestWithLocation() {
         Location location = new Location("");
         location.setLatitude(47.6204);
         location.setLongitude(-122.3491);
@@ -109,28 +112,23 @@ public void testCreatePlacesSearchRequest() {
     @SmallTest
     @MediumTest
     @LargeTest
-    public void testCreatePlacesSearchRequestRequiresLocationOrSearchText() {
-        try {
-            Request request = Request.newPlacesSearchRequest(null, null, 1000, 50, null, null);
+    public void testCreatePlacesSearchRequestWithSearchText() {
+        Request request = Request.newPlacesSearchRequest(null, null, 1000, 50, "Starbucks", null);
 
-            assertTrue(request != null);
-            assertEquals(HttpMethod.GET, request.getHttpMethod());
-            assertEquals("search", request.getGraphPath());
-
-            fail("expected exception");
-        } catch (FacebookException exception) {
-            // Success
-        }
+        assertTrue(request != null);
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+        assertEquals("search", request.getGraphPath());
     }
 
     @SmallTest
     @MediumTest
     @LargeTest
-    public void testCreatePlacesSearchRequestRequiresLocation() {
+    public void testCreatePlacesSearchRequestRequiresLocationOrSearchText() {
         try {
-            Request.newPlacesSearchRequest(null, null, 1000, 50, null, null);
-            fail("expected NullPointerException");
+            Request request = Request.newPlacesSearchRequest(null, null, 1000, 50, null, null);
+            fail("expected exception");
         } catch (FacebookException exception) {
+            // Success
         }
     }
 
@@ -278,14 +276,15 @@ public void testFacebookErrorResponseCreatesError() {
 
         assertTrue(response != null);
 
-        FacebookException exception = response.getError();
-        assertTrue(exception != null);
+        FacebookRequestError error = response.getError();
+        assertNotNull(error);
+        FacebookException exception = error.getException();
+        assertNotNull(exception);
 
-        assertTrue(exception instanceof FacebookServiceErrorException);
-        FacebookServiceErrorException serviceException = (FacebookServiceErrorException) exception;
-        assertTrue(serviceException.getFacebookErrorType() != null);
-        assertTrue(serviceException.getFacebookErrorCode() != FacebookServiceErrorException.UNKNOWN_ERROR_CODE);
-        assertTrue(serviceException.getResponseBody() != null);
+        assertTrue(exception instanceof FacebookServiceException);
+        assertNotNull(error.getErrorType());
+        assertTrue(error.getErrorCode() != FacebookRequestError.INVALID_ERROR_CODE);
+        assertNotNull(error.getRequestResultBody());
     }
 
     @LargeTest
@@ -301,13 +300,12 @@ public void testFacebookSuccessResponseWithErrorCodeCreatesError() {
 
         assertTrue(response != null);
 
-        FacebookException exception = response.getError();
-        assertTrue(exception != null);
+        FacebookRequestError error = response.getError();
+        assertNotNull(error);
 
-        assertTrue(exception instanceof FacebookServiceErrorException);
-        FacebookServiceErrorException serviceException = (FacebookServiceErrorException) exception;
-        assertTrue(serviceException.getFacebookErrorCode() != FacebookServiceErrorException.UNKNOWN_ERROR_CODE);
-        assertTrue(serviceException.getResponseBody() != null);
+        assertTrue(error.getException() instanceof FacebookServiceException);
+        assertTrue(error.getErrorCode() != FacebookRequestError.INVALID_ERROR_CODE);
+        assertNotNull(error.getRequestResultBody());
     }
 
     @MediumTest
@@ -317,8 +315,7 @@ public void testRequestWithUnopenedSessionFails() {
         Request request = new Request(session, "me");
         Response response = request.executeAndWait();
 
-        FacebookException exception = response.getError();
-        assertNotNull(exception);
+        assertNotNull(response.getError());
     }
 
     @MediumTest
@@ -332,8 +329,7 @@ public void testExecuteRequestMe() {
     }
 
     static void validateMeResponse(TestSession session, Response response) {
-        FacebookException exception = response.getError();
-        assertNull(exception);
+        assertNull(response.getError());
 
         GraphUser me = response.getGraphObjectAs(GraphUser.class);
         assertNotNull(me);
@@ -365,7 +361,7 @@ static void validateMyFriendsResponse(TestSession session, Response response) {
 
     @MediumTest
     @LargeTest
-    public void testExecutePlaceRequest() {
+    public void testExecutePlaceRequestWithLocation() {
         TestSession session = openTestSessionWithSharedUser();
 
         Location location = new Location("");
@@ -385,6 +381,47 @@ public void testExecutePlaceRequest() {
         assertNotNull(results);
     }
 
+    @MediumTest
+    @LargeTest
+    public void testExecutePlaceRequestWithSearchText() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        // Pass a distance without a location to ensure it is correctly ignored.
+        Request request = Request.newPlacesSearchRequest(session, null, 1000, 5, "Starbucks", null);
+        Response response = request.executeAndWait();
+        assertNotNull(response);
+
+        assertNull(response.getError());
+
+        GraphMultiResult graphResult = response.getGraphObjectAs(GraphMultiResult.class);
+        assertNotNull(graphResult);
+
+        List<GraphObject> results = graphResult.getData();
+        assertNotNull(results);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecutePlaceRequestWithLocationAndSearchText() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Location location = new Location("");
+        location.setLatitude(47.6204);
+        location.setLongitude(-122.3491);
+
+        Request request = Request.newPlacesSearchRequest(session, location, 1000, 5, "Starbucks", null);
+        Response response = request.executeAndWait();
+        assertNotNull(response);
+
+        assertNull(response.getError());
+
+        GraphMultiResult graphResult = response.getGraphObjectAs(GraphMultiResult.class);
+        assertNotNull(graphResult);
+
+        List<GraphObject> results = graphResult.getData();
+        assertNotNull(results);
+    }
+
     @LargeTest
     public void testExecuteUploadPhoto() {
         TestSession session = openTestSessionWithSharedUser();
@@ -394,8 +431,7 @@ public void testExecuteUploadPhoto() {
         Response response = request.executeAndWait();
         assertNotNull(response);
 
-        Exception exception = response.getError();
-        assertNull(exception);
+        assertNull(response.getError());
 
         GraphObject result = response.getGraphObject();
         assertNotNull(result);
@@ -422,14 +458,13 @@ public void testExecuteUploadPhotoViaFile() throws IOException {
             Response response = request.executeAndWait();
             assertNotNull(response);
 
-            Exception exception = response.getError();
-            assertNull(exception);
+            assertNull(response.getError());
 
             GraphObject result = response.getGraphObject();
             assertNotNull(result);
         } finally {
             if (outStream != null) {
-                outStream.close();;
+                outStream.close();
             }
             if (outputFile != null) {
                 outputFile.delete();
@@ -437,6 +472,30 @@ public void testExecuteUploadPhotoViaFile() throws IOException {
         }
     }
 
+    @LargeTest
+    public void testUploadVideoFile() throws IOException, URISyntaxException {
+        File tempFile = null;
+        try {
+            TestSession session = openTestSessionWithSharedUser();
+            tempFile = createTempFileFromAsset("DarkScreen.mov");
+
+            Request request = Request.newUploadVideoRequest(session, tempFile, null);
+            Response response = request.executeAndWait();
+            assertNotNull(response);
+
+            assertNull(response.getError());
+
+            GraphObject result = response.getGraphObject();
+            assertNotNull(result);
+        } catch (Exception ex) {
+            return;
+        } finally {
+            if (tempFile != null) {
+                tempFile.delete();
+            }
+        }
+    }
+
     @LargeTest
     public void testPostStatusUpdate() {
         TestSession session = openTestSessionWithSharedUser();
@@ -523,6 +582,103 @@ public void testCantSetBothGraphPathAndRestMethod() {
         request.setGraphPath("me");
         request.setRestMethod("amethod");
         request.setCallback(new ExpectFailureCallback());
-        request.executeAndWait();
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(request);
+        task.executeOnBlockerThread();
+
+        waitAndAssertSuccess(1);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testClosedSessionDoesntAppendAccessToken() {
+        TestSession session = openTestSessionWithSharedUser();
+        session.close();
+        Request request = new Request(session, "me", null, null, new ExpectFailureCallback());
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(request);
+        task.executeOnBlockerThread();
+
+        waitAndAssertSuccess(1);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCantUseComplexParameterInGetRequest() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Bundle parameters = new Bundle();
+        parameters.putShortArray("foo", new short[1]);
+
+        Request request = new Request(session, "me", parameters, HttpMethod.GET, new ExpectFailureCallback());
+        Response response = request.executeAndWait();
+
+        FacebookRequestError error = response.getError();
+        assertNotNull(error);
+        FacebookException exception = error.getException();
+        assertNotNull(exception);
+        assertTrue(exception.getMessage().contains("short[]"));
+    }
+
+    private final Location SEATTLE_LOCATION = new Location("") {
+        {
+            setLatitude(47.6097);
+            setLongitude(-122.3331);
+        }
+    };
+
+    @LargeTest
+    public void testPaging() {
+        TestSession session = openTestSessionWithSharedUser();
+        final List<GraphPlace> returnedPlaces = new ArrayList<GraphPlace>();
+        Request request = Request
+                .newPlacesSearchRequest(session, SEATTLE_LOCATION, 1000, 5, null, new Request.GraphPlaceListCallback() {
+                    @Override
+                    public void onCompleted(List<GraphPlace> places, Response response) {
+                        returnedPlaces.addAll(places);
+                    }
+                });
+        Response response = request.executeAndWait();
+
+        assertNull(response.getError());
+        assertNotNull(response.getGraphObject());
+        assertNotSame(0, returnedPlaces.size());
+
+        returnedPlaces.clear();
+
+        Request nextRequest = response.getRequestForPagedResults(Response.PagingDirection.NEXT);
+        assertNotNull(nextRequest);
+
+        nextRequest.setCallback(request.getCallback());
+        response = nextRequest.executeAndWait();
+
+        assertNull(response.getError());
+        assertNotNull(response.getGraphObject());
+        assertNotSame(0, returnedPlaces.size());
+
+        returnedPlaces.clear();
+
+        Request previousRequest = response.getRequestForPagedResults(Response.PagingDirection.PREVIOUS);
+        assertNotNull(previousRequest);
+
+        previousRequest.setCallback(request.getCallback());
+        response = previousRequest.executeAndWait();
+
+        assertNull(response.getError());
+        assertNotNull(response.getGraphObject());
+        assertNotSame(0, returnedPlaces.size());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testRequestWithClosedSessionThrowsException() {
+        TestSession session = getTestSessionWithSharedUser();
+        assertFalse(session.isOpened());
+
+        Request request = new Request(session, "4");
+        Response response = request.executeAndWait();
+
+        assertNotNull(response.getError());
     }
 }
diff --git a/facebook/tests/src/com/facebook/SessionTests.java b/facebook/tests/src/com/facebook/SessionTests.java
index 53b864ac9..01a794464 100644
--- a/facebook/tests/src/com/facebook/SessionTests.java
+++ b/facebook/tests/src/com/facebook/SessionTests.java
@@ -16,18 +16,28 @@
 
 package com.facebook;
 
+import android.content.Intent;
 import android.content.IntentFilter;
 import android.support.v4.content.LocalBroadcastManager;
 import android.test.suitebuilder.annotation.LargeTest;
 import android.test.suitebuilder.annotation.MediumTest;
 import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.internal.Utility;
 
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
 
 public class SessionTests extends SessionTestsBase {
 
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        new SharedPreferencesTokenCachingStrategy(getActivity()).clear();
+    }
+
     @SmallTest
     @MediumTest
     @LargeTest
@@ -162,7 +172,7 @@ public void testSetActiveSession() {
         final WaitForBroadcastReceiver receiverSet = new WaitForBroadcastReceiver();
         final WaitForBroadcastReceiver receiverUnset = new WaitForBroadcastReceiver();
         final LocalBroadcastManager broadcastManager = LocalBroadcastManager.getInstance(getActivity());
-        
+
         try {
             Runnable initializeOnBlockerThread = new Runnable() {
                 @Override
@@ -186,7 +196,7 @@ public void run() {
 
             Session session0 = new Session.Builder(getActivity()).
                     setApplicationId("FakeAppId").
-                    setTokenCache(new MockTokenCache()).
+                    setTokenCachingStrategy(new MockTokenCachingStrategy()).
                     build();
             assertEquals(SessionState.CREATED_TOKEN_LOADED, session0.getState());
 
@@ -198,7 +208,7 @@ public void run() {
 
             // When we open it, then we should see the Opened event.
             receiverOpened.incrementExpectCount();
-            session0.open();
+            session0.openForRead(null);
             receiverOpened.waitForExpectedCalls();
 
             // Setting to itself should not fire events
@@ -210,10 +220,10 @@ public void run() {
             WaitForBroadcastReceiver.incrementExpectCounts(receiverClosed, receiverUnset, receiverSet, receiverOpened);
             Session session1 = new Session.Builder(getActivity()).
                     setApplicationId("FakeAppId").
-                    setTokenCache(new MockTokenCache()).
+                    setTokenCachingStrategy(new MockTokenCachingStrategy()).
                     build();
             assertEquals(SessionState.CREATED_TOKEN_LOADED, session1.getState());
-            session1.open();
+            session1.openForRead(null);
             assertEquals(SessionState.OPENED, session1.getState());
             Session.setActiveSession(session1);
             WaitForBroadcastReceiver.waitForExpectedCalls(receiverClosed, receiverUnset, receiverSet, receiverOpened);
@@ -235,10 +245,11 @@ public void run() {
     @LargeTest
     public void testOpenSuccess() {
         ArrayList<String> permissions = new ArrayList<String>();
-        MockTokenCache cache = new MockTokenCache(null, 0);
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
         SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
         ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-        AccessToken openToken = AccessToken.createFromString("A token of thanks", permissions);
+        AccessToken openToken = AccessToken
+                .createFromString("A token of thanks", permissions, AccessTokenSource.TEST_USER);
 
         // Verify state with no token in cache
         assertEquals(SessionState.CREATED, session.getState());
@@ -256,7 +267,7 @@ public void testOpenSuccess() {
 
         // Verify we saved the token to cache.
         assertTrue(cache.getSavedState() != null);
-        assertEquals(openToken.getToken(), TokenCache.getToken(cache.getSavedState()));
+        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
 
         // Verify token information is cleared.
         session.closeAndClearTokenInformation();
@@ -269,21 +280,22 @@ public void testOpenSuccess() {
     }
 
     @SmallTest
-     @MediumTest
-     @LargeTest
-     public void testOpenForPublishSuccess() {
+    @MediumTest
+    @LargeTest
+    public void testOpenForPublishSuccess() {
         ArrayList<String> permissions = new ArrayList<String>();
-        MockTokenCache cache = new MockTokenCache(null, 0);
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
         SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
         ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-        AccessToken openToken = AccessToken.createFromString("A token of thanks", permissions);
+        AccessToken openToken = AccessToken
+                .createFromString("A token of thanks", permissions, AccessTokenSource.TEST_USER);
 
         // Verify state with no token in cache
         assertEquals(SessionState.CREATED, session.getState());
 
         session.addAuthorizeResult(openToken);
         session.openForPublish(new Session.OpenRequest(getActivity()).setCallback(statusRecorder).
-                setPermissions(Arrays.asList(new String[] {
+                setPermissions(Arrays.asList(new String[]{
                         "publish_something",
                         "manage_something",
                         "ads_management",
@@ -301,7 +313,7 @@ public void testOpenForPublishSuccess() {
 
         // Verify we saved the token to cache.
         assertTrue(cache.getSavedState() != null);
-        assertEquals(openToken.getToken(), TokenCache.getToken(cache.getSavedState()));
+        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
 
         // Verify token information is cleared.
         session.closeAndClearTokenInformation();
@@ -318,17 +330,18 @@ public void testOpenForPublishSuccess() {
     @LargeTest
     public void testOpenForPublishSuccessWithReadPermissions() {
         ArrayList<String> permissions = new ArrayList<String>();
-        MockTokenCache cache = new MockTokenCache(null, 0);
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
         SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
         ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-        AccessToken openToken = AccessToken.createFromString("A token of thanks", permissions);
+        AccessToken openToken = AccessToken
+                .createFromString("A token of thanks", permissions, AccessTokenSource.TEST_USER);
 
         // Verify state with no token in cache
         assertEquals(SessionState.CREATED, session.getState());
 
         session.addAuthorizeResult(openToken);
         session.openForPublish(new Session.OpenRequest(getActivity()).setCallback(statusRecorder).
-                setPermissions(Arrays.asList(new String[] {
+                setPermissions(Arrays.asList(new String[]{
                         "publish_something",
                         "manage_something",
                         "ads_management",
@@ -347,7 +360,7 @@ public void testOpenForPublishSuccessWithReadPermissions() {
 
         // Verify we saved the token to cache.
         assertTrue(cache.getSavedState() != null);
-        assertEquals(openToken.getToken(), TokenCache.getToken(cache.getSavedState()));
+        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
 
         // Verify token information is cleared.
         session.closeAndClearTokenInformation();
@@ -365,7 +378,7 @@ public void testOpenForPublishSuccessWithReadPermissions() {
     public void testOpenFromTokenCache() {
         SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
         String token = "A token less unique than most";
-        MockTokenCache cache = new MockTokenCache(token, DEFAULT_TIMEOUT_MILLISECONDS);
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(token, DEFAULT_TIMEOUT_MILLISECONDS);
         ScriptedSession session = createScriptedSessionOnBlockerThread("app-id", cache);
 
         // Verify state when we have a token in cache.
@@ -393,9 +406,10 @@ public void testOpenFromTokenCache() {
     @MediumTest
     @LargeTest
     public void testOpenActiveFromEmptyTokenCache() {
-        assertNull(Session.openActiveSession(getActivity(), false));
-    }
+        new SharedPreferencesTokenCachingStrategy(getActivity()).clear();
 
+        assertNull(Session.openActiveSessionFromCache(getActivity()));
+    }
 
 
     @SmallTest
@@ -403,7 +417,7 @@ public void testOpenActiveFromEmptyTokenCache() {
     @LargeTest
     public void testOpenFailure() {
         SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        MockTokenCache cache = new MockTokenCache(null, 0);
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
         ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
         Exception openException = new Exception();
 
@@ -426,69 +440,68 @@ public void testOpenFailure() {
     @LargeTest
     public void testOpenForReadFailure() {
         SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        MockTokenCache cache = new MockTokenCache(null, 0);
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
         ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
 
         try {
             session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder).
-                    setPermissions(Arrays.asList(new String[] {"publish_something"})));
+                    setPermissions(Arrays.asList(new String[]{"publish_something"})));
             fail("should not reach here without an exception");
         } catch (FacebookException e) {
-            assertTrue(e.getMessage().contains("Cannot pass a publish permission"));
+            assertTrue(e.getMessage().contains("Cannot pass a publish or manage permission"));
         } finally {
             stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
             statusRecorder.close();
         }
     }
 
-
-
     @SmallTest
     @MediumTest
     @LargeTest
-    public void testReauthorizeSuccess() {
+    public void testRequestNewReadPermissionsSuccess() {
         ArrayList<String> permissions = new ArrayList<String>();
         SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        MockTokenCache cache = new MockTokenCache(null, 0);
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
         ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
 
         // Session.open
-        final AccessToken openToken = AccessToken.createFromString("Allows playing outside", permissions);
+        final AccessToken openToken = AccessToken
+                .createFromString("Allows playing outside", permissions, AccessTokenSource.TEST_USER);
         permissions.add("play_outside");
 
-        session.addAuthorizeResult(openToken);
+        session.addAuthorizeResult(openToken, "play_outside");
         session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
         statusRecorder.waitForCall(session, SessionState.OPENING, null);
         statusRecorder.waitForCall(session, SessionState.OPENED, null);
 
         verifySessionHasToken(session, openToken);
         assertTrue(cache.getSavedState() != null);
-        assertEquals(openToken.getToken(), TokenCache.getToken(cache.getSavedState()));
+        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
 
         // Successful Session.reauthorize with new permissions
         final AccessToken reauthorizeToken = AccessToken.createFromString(
-                "Allows playing outside and eating ice cream", permissions);
+                "Allows playing outside and eating ice cream", permissions, AccessTokenSource.TEST_USER);
         permissions.add("eat_ice_cream");
 
-        session.addAuthorizeResult(reauthorizeToken);
-        session.reauthorizeForRead(new Session.ReauthorizeRequest(getActivity(), permissions));
+        session.addAuthorizeResult(reauthorizeToken, "play_outside", "eat_ice_cream");
+        session.requestNewReadPermissions(new Session.NewPermissionsRequest(getActivity(), permissions));
         statusRecorder.waitForCall(session, SessionState.OPENED_TOKEN_UPDATED, null);
 
         verifySessionHasToken(session, reauthorizeToken);
         assertTrue(cache.getSavedState() != null);
-        assertEquals(reauthorizeToken.getToken(), TokenCache.getToken(cache.getSavedState()));
+        assertEquals(reauthorizeToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
 
         // Failing reauthorization with new permissions
         final Exception reauthorizeException = new Exception("Don't run with scissors");
         permissions.add("run_with_scissors");
 
         session.addAuthorizeResult(reauthorizeException);
-        session.reauthorizeForRead(new Session.ReauthorizeRequest(getActivity(), permissions));
+        session.requestNewReadPermissions(new Session.NewPermissionsRequest(getActivity(), permissions));
         statusRecorder.waitForCall(session, SessionState.OPENED_TOKEN_UPDATED, reauthorizeException);
 
         // Verify we do not overwrite cache if reauthorize fails
         assertTrue(cache.getSavedState() != null);
-        assertEquals(reauthorizeToken.getToken(), TokenCache.getToken(cache.getSavedState()));
+        assertEquals(reauthorizeToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
 
         // Wait a bit so we can fail if any unexpected calls arrive on the
         // recorders.
@@ -499,52 +512,134 @@ public void testReauthorizeSuccess() {
     @SmallTest
     @MediumTest
     @LargeTest
-    public void testReauthorizeForPublishSuccess() {
+    public void testRequestNewPublishPermissionsSuccess() {
         ArrayList<String> permissions = new ArrayList<String>();
         SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        MockTokenCache cache = new MockTokenCache(null, 0);
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
         ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
 
         // Session.open
-        final AccessToken openToken = AccessToken.createFromString("Allows playing outside", permissions);
+        final AccessToken openToken = AccessToken
+                .createFromString("Allows playing outside", permissions, AccessTokenSource.TEST_USER);
         permissions.add("play_outside");
 
-        session.addAuthorizeResult(openToken);
+        session.addAuthorizeResult(openToken, "play_outside");
         session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
         statusRecorder.waitForCall(session, SessionState.OPENING, null);
         statusRecorder.waitForCall(session, SessionState.OPENED, null);
 
         verifySessionHasToken(session, openToken);
         assertTrue(cache.getSavedState() != null);
-        assertEquals(openToken.getToken(), TokenCache.getToken(cache.getSavedState()));
+        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
 
         // Successful Session.reauthorize with new permissions
         final AccessToken reauthorizeToken = AccessToken.createFromString(
-                "Allows playing outside and publish eating ice cream", permissions);
+                "Allows playing outside and publish eating ice cream", permissions, AccessTokenSource.TEST_USER);
         permissions.add("publish_eat_ice_cream");
 
-        session.addAuthorizeResult(reauthorizeToken);
-        session.reauthorizeForPublish(new Session.ReauthorizeRequest(getActivity(), permissions));
+        session.addAuthorizeResult(reauthorizeToken, "play_outside", "publish_eat_ice_cream");
+        session.requestNewPublishPermissions(new Session.NewPermissionsRequest(getActivity(), permissions));
         statusRecorder.waitForCall(session, SessionState.OPENED_TOKEN_UPDATED, null);
 
         verifySessionHasToken(session, reauthorizeToken);
         assertTrue(cache.getSavedState() != null);
-        assertEquals(reauthorizeToken.getToken(), TokenCache.getToken(cache.getSavedState()));
+        assertEquals(reauthorizeToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
 
         // Failing reauthorization with publish permissions on a read request
         permissions.add("publish_run_with_scissors");
 
         try {
-            session.reauthorizeForRead(new Session.ReauthorizeRequest(getActivity(), permissions));
+            session.requestNewReadPermissions(new Session.NewPermissionsRequest(getActivity(), permissions));
             fail("Should not reach here without an exception");
         } catch (FacebookException e) {
-            assertTrue(e.getMessage().contains("Cannot pass a publish permission"));
+            assertTrue(e.getMessage().contains("Cannot pass a publish or manage permission"));
         } finally {
             stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
             statusRecorder.close();
         }
     }
 
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenWithAccessToken() {
+        String token = "This is a fake token.";
+        Date expirationDate = new Date(new Date().getTime() + 3600 * 1000);
+        Date lastRefreshDate = new Date();
+        List<String> permissions = Arrays.asList(new String[]{"email", "publish_stream"});
+
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        AccessToken accessToken = AccessToken.createFromExistingAccessToken(token, expirationDate, lastRefreshDate,
+                AccessTokenSource.FACEBOOK_APPLICATION_WEB, permissions);
+        session.open(accessToken, statusRecorder);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        AccessToken expectedToken = new AccessToken(token, expirationDate, permissions,
+                AccessTokenSource.FACEBOOK_APPLICATION_WEB, lastRefreshDate);
+        verifySessionHasToken(session, expectedToken);
+
+        // Verify we get a close callback.
+        session.close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Verify we saved the token to cache.
+        assertTrue(cache.getSavedState() != null);
+        assertEquals(expectedToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenWithAccessTokenWithDefaults() {
+        String token = "This is a fake token.";
+
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        AccessToken accessToken = AccessToken.createFromExistingAccessToken(token, null, null, null, null);
+        session.open(accessToken, statusRecorder);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        assertEquals(token, session.getAccessToken());
+        assertEquals(new Date(Long.MAX_VALUE), session.getExpirationDate());
+        assertEquals(0, session.getPermissions().size());
+
+        // Verify we get a close callback.
+        session.close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Verify we saved the token to cache.
+        assertTrue(cache.getSavedState() != null);
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
     @MediumTest
     @LargeTest
     public void testSessionWillExtendTokenIfNeeded() {
@@ -569,15 +664,14 @@ public void testSessionWillNotExtendTokenIfCurrentlyAttempting() {
         assertFalse(session.getWasAskedToExtendAccessToken());
     }
 
-    
+
     @LargeTest
     public void testBasicSerialization() throws IOException, ClassNotFoundException {
         // Try to test the happy path, that there are no unserializable fields
         // in the session.
-        Session session0 = new Session.Builder(getActivity()).setApplicationId("fakeID").
-                setShouldAutoPublishInstall(false).build();
+        Session session0 = new Session.Builder(getActivity()).setApplicationId("fakeID").build();
         Session session1 = TestUtils.serializeAndUnserialize(session0);
-        
+
         // do some basic assertions
         assertNotNull(session0.getAccessToken());
         assertEquals(session0, session1);
@@ -591,7 +685,116 @@ public void testBasicSerialization() throws IOException, ClassNotFoundException
         assertEquals(authRequest0.getLoginBehavior(), authRequest1.getLoginBehavior());
         assertEquals(authRequest0.getRequestCode(), authRequest1.getRequestCode());
     }
-    
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenSessionWithNativeLinkingIntent() {
+        String token = "A token less unique than most";
+
+        Intent intent = new Intent(Intent.ACTION_MAIN);
+        intent.putExtras(getNativeLinkingExtras(token));
+
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, DEFAULT_TIMEOUT_MILLISECONDS);
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+
+        assertEquals(SessionState.CREATED, session.getState());
+
+        AccessToken accessToken = AccessToken.createFromNativeLinkingIntent(intent);
+        assertNotNull(accessToken);
+        session.open(accessToken, statusRecorder);
+
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        assertEquals(token, session.getAccessToken());
+        // Expiration time should be 3600s after now (allow 5s variation for test execution time)
+        long delta = session.getExpirationDate().getTime() - new Date().getTime();
+        assertTrue(Math.abs(delta - 3600 * 1000) < 5000);
+        assertEquals(0, session.getPermissions().size());
+        assertEquals(Utility.getMetadataApplicationId(getActivity()), session.getApplicationId());
+
+        // Verify we get a close callback.
+        session.close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        assertFalse(cache.getSavedState() == null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenActiveSessionWithNativeLinkingIntent() {
+        Session activeSession = Session.getActiveSession();
+        if (activeSession != null) {
+            activeSession.closeAndClearTokenInformation();
+        }
+
+        SharedPreferencesTokenCachingStrategy tokenCache = new SharedPreferencesTokenCachingStrategy(getActivity());
+        assertEquals(0, tokenCache.load().size());
+
+        String token = "A token less unique than most";
+
+        Intent intent = new Intent(Intent.ACTION_MAIN);
+        intent.putExtras(getNativeLinkingExtras(token));
+
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+
+        AccessToken accessToken = AccessToken.createFromNativeLinkingIntent(intent);
+        assertNotNull(accessToken);
+        Session session = Session.openActiveSessionWithAccessToken(getActivity(), accessToken, statusRecorder);
+        assertEquals(session, Session.getActiveSession());
+
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        assertNotSame(0, tokenCache.load().size());
+
+        assertEquals(token, session.getAccessToken());
+        // Expiration time should be 3600s after now (allow 5s variation for test execution time)
+        long delta = session.getExpirationDate().getTime() - new Date().getTime();
+        assertTrue(Math.abs(delta - 3600 * 1000) < 5000);
+        assertEquals(0, session.getPermissions().size());
+        assertEquals(Utility.getMetadataApplicationId(getActivity()), session.getApplicationId());
+
+        // Verify we get a close callback.
+        session.close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpeningSessionWithPendingRequestResultsInExceptionCallback() {
+        ArrayList<String> permissions = new ArrayList<String>();
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+        AccessToken openToken = AccessToken
+                .createFromString("A token of thanks", permissions, AccessTokenSource.TEST_USER);
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+        session.addPendingAuthorizeResult();
+
+        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
+        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENING, new UnsupportedOperationException());
+
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
     static IntentFilter getActiveSessionFilter(String... actions) {
         IntentFilter filter = new IntentFilter();
 
@@ -610,6 +813,6 @@ static IntentFilter getActiveSessionAllFilter() {
     private void verifySessionHasToken(Session session, AccessToken token) {
         assertEquals(token.getToken(), session.getAccessToken());
         assertEquals(token.getExpires(), session.getExpirationDate());
-        assertEquals(token.getPermissions(), session.getPermissions());
+        TestUtils.assertAtLeastExpectedPermissions(token.getPermissions(), session.getPermissions());
     }
 }
diff --git a/facebook/tests/src/com/facebook/SessionTestsBase.java b/facebook/tests/src/com/facebook/SessionTestsBase.java
index d6b0d970a..52d759683 100644
--- a/facebook/tests/src/com/facebook/SessionTestsBase.java
+++ b/facebook/tests/src/com/facebook/SessionTestsBase.java
@@ -22,23 +22,28 @@
 import android.os.Bundle;
 import android.os.ConditionVariable;
 import android.os.Looper;
+import com.facebook.internal.Utility;
+import com.facebook.model.GraphMultiResult;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphObjectList;
+import com.facebook.model.GraphUser;
 
-import java.util.LinkedList;
+import java.util.*;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
 
 public class SessionTestsBase extends FacebookTestCase {
-    static final int DEFAULT_TIMEOUT_MILLISECONDS = 10 * 1000;
+    public static final int DEFAULT_TIMEOUT_MILLISECONDS = 10 * 1000;
     static final int SIMULATED_WORKING_MILLISECONDS = 20;
-    static final int STRAY_CALLBACK_WAIT_MILLISECONDS = 50;
-    
-    ScriptedSession createScriptedSessionOnBlockerThread(TokenCache cache) {
-        return createScriptedSessionOnBlockerThread("SomeApplicationId", cache);
+    public static final int STRAY_CALLBACK_WAIT_MILLISECONDS = 50;
+
+    public ScriptedSession createScriptedSessionOnBlockerThread(TokenCachingStrategy cachingStrategy) {
+        return createScriptedSessionOnBlockerThread(Utility.getMetadataApplicationId(getActivity()), cachingStrategy);
     }
 
     ScriptedSession createScriptedSessionOnBlockerThread(final String applicationId,
-            final TokenCache cache) {
+            final TokenCachingStrategy cachingStrategy) {
         class MutableState {
             ScriptedSession session;
         }
@@ -48,14 +53,14 @@ ScriptedSession createScriptedSessionOnBlockerThread(final String applicationId,
         runOnBlockerThread(new Runnable() {
             @Override
             public void run() {
-                mutable.session = new ScriptedSession(getActivity(), applicationId, cache);
+                mutable.session = new ScriptedSession(getActivity(), applicationId, cachingStrategy);
             }
         }, true);
 
         return mutable.session;
     }
 
-    static void stall(int stallMsec) {
+    public static void stall(int stallMsec) {
         try {
             Thread.sleep(stallMsec);
         } catch (InterruptedException e) {
@@ -63,64 +68,107 @@ static void stall(int stallMsec) {
         }
     }
 
-    static class ScriptedSession extends Session {
+    public class ScriptedSession extends Session {
         private static final long serialVersionUID = 1L;
         private final LinkedList<AuthorizeResult> pendingAuthorizations = new LinkedList<AuthorizeResult>();
+        private AuthorizationRequest lastRequest;
+        private AuthorizeResult currentAuthorization = null;
+
+        public ScriptedSession(Context currentContext, String applicationId, TokenCachingStrategy tokenCachingStrategy) {
+            super(currentContext, applicationId, tokenCachingStrategy);
+        }
 
-        ScriptedSession(Context currentContext, String applicationId, TokenCache tokenCache) {
-            super(currentContext, applicationId, tokenCache, false);
+        public void addAuthorizeResult(String token, List<String> permissions, AccessTokenSource source) {
+            addAuthorizeResult(AccessToken.createFromString(token, permissions, source));
         }
 
         public void addAuthorizeResult(AccessToken token) {
             pendingAuthorizations.add(new AuthorizeResult(token));
         }
 
+        public void addAuthorizeResult(AccessToken token, List<String> permissions) {
+            pendingAuthorizations.add(new AuthorizeResult(token, permissions));
+        }
+
+        public void addAuthorizeResult(AccessToken token, String... permissions) {
+            pendingAuthorizations.add(new AuthorizeResult(token, Arrays.asList(permissions)));
+        }
+
         public void addAuthorizeResult(Exception exception) {
             pendingAuthorizations.add(new AuthorizeResult(exception));
         }
 
+        public void addPendingAuthorizeResult() {
+            pendingAuthorizations.add(new AuthorizeResult());
+        }
+
+        public AuthorizationRequest getLastRequest() {
+            return lastRequest;
+        }
+
+        public SessionDefaultAudience getLastRequestAudience() {
+            return lastRequest.getDefaultAudience();
+        }
+
         // Overrides authorize to return the next AuthorizeResult we added.
         @Override
         void authorize(final AuthorizationRequest request) {
-            Settings.getExecutor().execute(new Runnable() {
+            lastRequest = request;
+            getActivity().runOnUiThread(new Runnable() {
                 @Override
                 public void run() {
                     stall(SIMULATED_WORKING_MILLISECONDS);
-                    AuthorizeResult result = pendingAuthorizations.poll();
+                    currentAuthorization = pendingAuthorizations.poll();
 
-                    if (result == null) {
+                    if (currentAuthorization == null) {
                         fail("Missing call to addScriptedAuthorization");
                     }
-
-                    finishAuth(result.token, result.exception);
+                    if (!currentAuthorization.leaveAsPending) {
+                        finishAuthOrReauth(currentAuthorization.token, currentAuthorization.exception);
+                    }
                 }
             });
         }
 
-        private static class AuthorizeResult {
+        private class AuthorizeResult {
             final AccessToken token;
             final Exception exception;
+            final List<String> resultingPermissions;
+            final boolean leaveAsPending;
 
-            private AuthorizeResult(AccessToken token, Exception exception) {
+            private AuthorizeResult(AccessToken token, Exception exception, List<String> permissions) {
                 this.token = token;
                 this.exception = exception;
+                this.resultingPermissions = permissions;
+                this.leaveAsPending = false;
+            }
+
+            private AuthorizeResult() {
+                this.token = null;
+                this.exception = null;
+                this.resultingPermissions = null;
+                this.leaveAsPending = true;
+            }
+
+            AuthorizeResult(AccessToken token, List<String> permissions) {
+                this(token, null, permissions);
             }
 
             AuthorizeResult(AccessToken token) {
-                this(token, null);
+                this(token, null, null);
             }
 
             AuthorizeResult(Exception exception) {
-                this(null, exception);
+                this(null, exception, null);
             }
         }
     }
 
-    static class SessionStatusCallbackRecorder implements Session.StatusCallback {
+    public static class SessionStatusCallbackRecorder implements Session.StatusCallback {
         private final BlockingQueue<Call> calls = new LinkedBlockingQueue<Call>();
         volatile boolean isClosed = false;
 
-        void waitForCall(Session session, SessionState state, Exception exception) {
+        public void waitForCall(Session session, SessionState state, Exception exception) {
             Call call = null;
 
             try {
@@ -134,10 +182,15 @@ void waitForCall(Session session, SessionState state, Exception exception) {
 
             assertEquals(session, call.session);
             assertEquals(state, call.state);
-            assertEquals(exception, call.exception);
+            if (exception != null && call.exception != null) {
+                assertEquals(exception.getClass(), call.exception.getClass());
+            } else {
+                // They should both be null if either of them is.
+                assertTrue(exception == call.exception);
+            }
         }
 
-        void close() {
+        public void close() {
             isClosed = true;
             assertEquals(0, calls.size());
         }
@@ -151,7 +204,7 @@ public void call(Session session, SessionState state, Exception exception) {
             if (isClosed) {
                 fail("Reauthorize callback called after closed");
             }
-            assertEquals("Callback should run on main UI thread", Thread.currentThread(), 
+            assertEquals("Callback should run on main UI thread", Thread.currentThread(),
                     Looper.getMainLooper().getThread());
         }
 
@@ -169,22 +222,22 @@ public void call(Session session, SessionState state, Exception exception) {
 
     }
 
-    static class MockTokenCache extends TokenCache {
+    public static class MockTokenCachingStrategy extends TokenCachingStrategy {
         private final String token;
         private final long expires_in;
         private Bundle saved;
 
-        MockTokenCache() {
+        MockTokenCachingStrategy() {
             this("FakeToken", DEFAULT_TIMEOUT_MILLISECONDS);
         }
 
-        MockTokenCache(String token, long expires_in) {
+        public MockTokenCachingStrategy(String token, long expires_in) {
             this.token = token;
             this.expires_in = expires_in;
             this.saved = null;
         }
 
-        Bundle getSavedState() {
+        public Bundle getSavedState() {
             return saved;
         }
 
@@ -195,8 +248,8 @@ public Bundle load() {
             if (token != null) {
                 bundle = new Bundle();
 
-                TokenCache.putToken(bundle, token);
-                TokenCache.putExpirationMilliseconds(bundle, System.currentTimeMillis() + expires_in);
+                TokenCachingStrategy.putToken(bundle, token);
+                TokenCachingStrategy.putExpirationMilliseconds(bundle, System.currentTimeMillis() + expires_in);
             }
 
             return bundle;
diff --git a/facebook/tests/src/com/facebook/SettingsTests.java b/facebook/tests/src/com/facebook/SettingsTests.java
index 114c047d7..554c5a047 100644
--- a/facebook/tests/src/com/facebook/SettingsTests.java
+++ b/facebook/tests/src/com/facebook/SettingsTests.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook;
 
 import android.os.ConditionVariable;
diff --git a/facebook/tests/src/com/facebook/SharedPreferencesTokenCacheTests.java b/facebook/tests/src/com/facebook/SharedPreferencesTokenCacheTests.java
index 8309f7baf..6f676ac19 100644
--- a/facebook/tests/src/com/facebook/SharedPreferencesTokenCacheTests.java
+++ b/facebook/tests/src/com/facebook/SharedPreferencesTokenCacheTests.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook;
 
 import android.os.Bundle;
@@ -5,6 +21,7 @@
 import android.test.suitebuilder.annotation.LargeTest;
 import android.test.suitebuilder.annotation.MediumTest;
 import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.internal.Utility;
 import junit.framework.Assert;
 
 import java.lang.reflect.Array;
@@ -31,6 +48,7 @@
     private static final String CHAR_ARRAY_KEY = "charArrayKey";
     private static final String STRING_KEY = "stringKey";
     private static final String STRING_LIST_KEY = "stringListKey";
+    private static final String SERIALIZABLE_KEY = "serializableKey";
 
     private static Random random = new Random((new Date()).getTime());
 
@@ -58,13 +76,14 @@ public void testAllTypes() {
         putCharArray(CHAR_ARRAY_KEY, originalBundle);
         putString(STRING_KEY, originalBundle);
         putStringList(STRING_LIST_KEY, originalBundle);
+        originalBundle.putSerializable(SERIALIZABLE_KEY, AccessTokenSource.FACEBOOK_APPLICATION_WEB);
 
         ensureApplicationContext();
 
-        SharedPreferencesTokenCache cache = new SharedPreferencesTokenCache(getContext());
+        SharedPreferencesTokenCachingStrategy cache = new SharedPreferencesTokenCachingStrategy(getContext());
         cache.save(originalBundle);
 
-        SharedPreferencesTokenCache cache2 = new SharedPreferencesTokenCache(getContext());
+        SharedPreferencesTokenCachingStrategy cache2 = new SharedPreferencesTokenCachingStrategy(getContext());
         Bundle cachedBundle = cache2.load();
 
         Assert.assertEquals(originalBundle.getBoolean(BOOLEAN_KEY), cachedBundle.getBoolean(BOOLEAN_KEY));
@@ -86,6 +105,8 @@ public void testAllTypes() {
         Assert.assertEquals(originalBundle.getString(STRING_KEY), cachedBundle.getString(STRING_KEY));
         assertListEquals(originalBundle.getStringArrayList(STRING_LIST_KEY), cachedBundle.getStringArrayList(
                 STRING_LIST_KEY));
+        Assert.assertEquals(originalBundle.getSerializable(SERIALIZABLE_KEY),
+                cachedBundle.getSerializable(SERIALIZABLE_KEY));
     }
 
     @SmallTest
@@ -101,16 +122,16 @@ public void testMultipleCaches() {
 
         ensureApplicationContext();
 
-        SharedPreferencesTokenCache cache1 = new SharedPreferencesTokenCache(getContext());
-        SharedPreferencesTokenCache cache2 = new SharedPreferencesTokenCache(getContext(), "CustomCache");
+        SharedPreferencesTokenCachingStrategy cache1 = new SharedPreferencesTokenCachingStrategy(getContext());
+        SharedPreferencesTokenCachingStrategy cache2 = new SharedPreferencesTokenCachingStrategy(getContext(), "CustomCache");
 
         cache1.save(bundle1);
         cache2.save(bundle2);
 
         // Get new references to make sure we are getting persisted data.
         // Reverse the cache references for fun.
-        cache1 = new SharedPreferencesTokenCache(getContext(), "CustomCache");
-        cache2 = new SharedPreferencesTokenCache(getContext());
+        cache1 = new SharedPreferencesTokenCachingStrategy(getContext(), "CustomCache");
+        cache2 = new SharedPreferencesTokenCachingStrategy(getContext());
 
         Bundle newBundle1 = cache1.load(), newBundle2 = cache2.load();
 
@@ -120,6 +141,38 @@ public void testMultipleCaches() {
         Assert.assertEquals(bundle1.getString(STRING_KEY), newBundle2.getString(STRING_KEY));
     }
 
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCacheRoundtrip() {
+        ArrayList<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
+        String token = "AnImaginaryTokenValue";
+        Date later = TestUtils.nowPlusSeconds(60);
+        Date earlier = TestUtils.nowPlusSeconds(-60);
+
+        SharedPreferencesTokenCachingStrategy cache = new SharedPreferencesTokenCachingStrategy(getContext());
+        cache.clear();
+
+        Bundle bundle = new Bundle();
+        TokenCachingStrategy.putToken(bundle, token);
+        TokenCachingStrategy.putExpirationDate(bundle, later);
+        TokenCachingStrategy.putSource(bundle, AccessTokenSource.FACEBOOK_APPLICATION_NATIVE);
+        TokenCachingStrategy.putLastRefreshDate(bundle, earlier);
+        TokenCachingStrategy.putPermissions(bundle, permissions);
+
+        cache.save(bundle);
+        bundle = cache.load();
+
+        AccessToken accessToken = AccessToken.createFromCache(bundle);
+        TestUtils.assertSamePermissions(permissions, accessToken);
+        assertEquals(token, accessToken.getToken());
+        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_NATIVE, accessToken.getSource());
+        assertTrue(!accessToken.isInvalid());
+
+        Bundle cachedBundle = accessToken.toCacheBundle();
+        TestUtils.assertEqualContents(bundle, cachedBundle);
+    }
+
     private static void assertArrayEquals(Object a1, Object a2) {
         Assert.assertNotNull(a1);
         Assert.assertNotNull(a2);
diff --git a/facebook/tests/src/com/facebook/TestSessionTests.java b/facebook/tests/src/com/facebook/TestSessionTests.java
index 4c466d4d0..34c74b9c0 100644
--- a/facebook/tests/src/com/facebook/TestSessionTests.java
+++ b/facebook/tests/src/com/facebook/TestSessionTests.java
@@ -129,18 +129,6 @@ public void testCannotChangeTestApplicationSecretOnceSet() {
         }
     }
 
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCannotChangeMachineUniqueUserTagOnceSet() {
-        try {
-            TestSession.setMachineUniqueUserTag("hello");
-            TestSession.setMachineUniqueUserTag("world");
-            fail("expected exception");
-        } catch (FacebookException e) {
-        }
-    }
-
     private int countTestUsers() {
         TestSession session = getTestSessionWithSharedUser(null);
 
diff --git a/facebook/tests/src/com/facebook/TestUtils.java b/facebook/tests/src/com/facebook/TestUtils.java
index 49bd6fc8b..16ee40d39 100644
--- a/facebook/tests/src/com/facebook/TestUtils.java
+++ b/facebook/tests/src/com/facebook/TestUtils.java
@@ -16,7 +16,12 @@
 
 package com.facebook;
 
+import android.os.Bundle;
+import junit.framework.Assert;
+
 import java.io.*;
+import java.util.Date;
+import java.util.List;
 
 public class TestUtils {
     public static <T extends Serializable> T serializeAndUnserialize(T t) {
@@ -35,4 +40,56 @@
             throw new RuntimeException(e);
         }
     }
+
+    static Date nowPlusSeconds(long offset) {
+        return new Date(new Date().getTime() + (offset * 1000L));
+    }
+
+    static void assertSamePermissions(List<String> expected, AccessToken actual) {
+        if (expected == null) {
+            Assert.assertEquals(null, actual.getPermissions());
+        } else {
+            for (String p : expected) {
+                Assert.assertTrue(actual.getPermissions().contains(p));
+            }
+            for (String p : actual.getPermissions()) {
+                Assert.assertTrue(expected.contains(p));
+            }
+        }
+    }
+
+    static void assertSamePermissions(List<String> expected, List<String> actual) {
+        if (expected == null) {
+            Assert.assertEquals(null, actual);
+        } else {
+            for (String p : expected) {
+                Assert.assertTrue(actual.contains(p));
+            }
+            for (String p : actual) {
+                Assert.assertTrue(expected.contains(p));
+            }
+        }
+    }
+
+    static void assertAtLeastExpectedPermissions(List<String> expected, List<String> actual) {
+        if (expected != null) {
+            for (String p : expected) {
+                Assert.assertTrue(actual.contains(p));
+            }
+        }
+    }
+
+    static void assertEqualContents(Bundle a, Bundle b) {
+        for (String key : a.keySet()) {
+            if (!b.containsKey(key)) {
+                Assert.fail("bundle does not include key " + key);
+            }
+            Assert.assertEquals(a.get(key), b.get(key));
+        }
+        for (String key : b.keySet()) {
+            if (!a.containsKey(key)) {
+                Assert.fail("bundle does not include key " + key);
+            }
+        }
+    }
 }
diff --git a/facebook/tests/src/com/facebook/android/FbDialogTests.java b/facebook/tests/src/com/facebook/android/FbDialogTests.java
deleted file mode 100644
index e3854c483..000000000
--- a/facebook/tests/src/com/facebook/android/FbDialogTests.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package com.facebook.android;
-
-import android.os.Bundle;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-
-public class FbDialogTests extends AndroidTestCase {
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testDialogListener() {
-        Facebook.DialogListener testListener = new Facebook.DialogListener() {
-            @Override
-            public void onComplete(Bundle values) {
-                assertNotNull("Got a bundle", values);
-            }
-
-            @Override
-            public void onFacebookError(FacebookError e) {
-                fail("Should not reach this method");
-            }
-
-            @Override
-            public void onError(DialogError e) {
-                fail("Should not reach this method");
-            }
-
-            @Override
-            public void onCancel() {
-                fail("Should not reach this method");
-            }
-        };
-
-        Facebook.DialogListener singleDispatchListener =
-                new FbDialog.SingleDispatchDialogListener(testListener);
-
-        singleDispatchListener.onComplete(new Bundle());
-        singleDispatchListener.onFacebookError(null);
-        singleDispatchListener.onError(null);
-        singleDispatchListener.onCancel();
-    }
-}
diff --git a/facebook/tests/src/com/facebook/FileLruCacheTests.java b/facebook/tests/src/com/facebook/internal/FileLruCacheTests.java
similarity index 94%
rename from facebook/tests/src/com/facebook/FileLruCacheTests.java
rename to facebook/tests/src/com/facebook/internal/FileLruCacheTests.java
index 90ccb2e59..52065e514 100644
--- a/facebook/tests/src/com/facebook/FileLruCacheTests.java
+++ b/facebook/tests/src/com/facebook/internal/FileLruCacheTests.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.internal;
 
 import android.test.AndroidTestCase;
 import android.test.suitebuilder.annotation.LargeTest;
@@ -41,7 +41,7 @@ public void testCacheOutputStream() throws IOException {
 
         put(cache, key, data);
         checkValue(cache, key, data);
-        cache.clear();
+        cache.clearForTest();
     }
 
     @SmallTest @MediumTest @LargeTest
@@ -53,7 +53,7 @@ public void testCacheInputStream() throws IOException {
 
         // Limit to 2x to allow for extra header data
         FileLruCache cache = new FileLruCache(getContext(), "testCacheInputStream", limitCacheSize(2*dataSize));
-        cache.clear();
+        cache.clearForTest();
 
         InputStream wrapped = cache.interceptAndPut(key, stream);
         consumeAndClose(wrapped);
@@ -68,14 +68,14 @@ public void testCacheClear() throws IOException {
 
         // Limit to 2x to allow for extra header data
         FileLruCache cache = new FileLruCache(getContext(), "testCacheClear", limitCacheSize(2*dataSize));
-        cache.clear();
+        cache.clearForTest();
 
         put(cache, key, data);
         checkValue(cache, key, data);
 
-        cache.clear();
+        cache.clearForTest();
         assertEquals(false, hasValue(cache, key));
-        assertEquals(0, cache.sizeInBytes());
+        assertEquals(0, cache.sizeInBytesForTest());
     }
 
     @SmallTest @MediumTest @LargeTest
@@ -87,7 +87,7 @@ public void testSizeInBytes() throws IOException {
 
         // Limit to 2x to allow for extra header data
         FileLruCache cache = new FileLruCache(getContext(), "testSizeInBytes", limitCacheSize(2*cacheSize));
-        cache.clear();
+        cache.clearForTest();
 
         for (int i = 0; i < count; i++) {
             put(cache, i, data);
@@ -97,8 +97,8 @@ public void testSizeInBytes() throws IOException {
             // than the data content but not more than twice as large.  This guarantees
             // that sizeInBytes is doing at least approximately the right thing.
             int totalDataSize = (i + 1) * dataSize;
-            assertTrue(cache.sizeInBytes() > totalDataSize);
-            assertTrue(cache.sizeInBytes() < 2 * totalDataSize);
+            assertTrue(cache.sizeInBytesForTest() > totalDataSize);
+            assertTrue(cache.sizeInBytesForTest() < 2 * totalDataSize);
         }
         for (int i = 0; i < count; i++) {
             String key = Integer.valueOf(i).toString();
@@ -116,7 +116,7 @@ public void testCacheSizeLimit() throws IOException {
         // Here we do not set the limit to 2x to make sure we hit the limit well before we have
         // added all the data.
         FileLruCache cache = new FileLruCache(getContext(), "testCacheSizeLimit", limitCacheSize(cacheSize));
-        cache.clear();
+        cache.clearForTest();
 
         for (int i = 0; i < count; i++) {
             put(cache, i, data);
@@ -126,8 +126,8 @@ public void testCacheSizeLimit() throws IOException {
             // This changes verification such that the final cache size lands somewhere
             // between half and full quota.
             int totalDataSize = (i + 1) * dataSize;
-            assertTrue(cache.sizeInBytes() > Math.min(totalDataSize, cacheSize/2));
-            assertTrue(cache.sizeInBytes() < Math.min(2 * totalDataSize, cacheSize));
+            assertTrue(cache.sizeInBytesForTest() > Math.min(totalDataSize, cacheSize/2));
+            assertTrue(cache.sizeInBytesForTest() < Math.min(2 * totalDataSize, cacheSize));
         }
 
         // Verify that some keys exist and others do not
@@ -157,7 +157,7 @@ public void testCacheCountLimit() throws IOException {
 
         // Here we only limit by count, and we allow half of the entries.
         FileLruCache cache = new FileLruCache(getContext(), "testCacheCountLimit", limitCacheCount(cacheCount));
-        cache.clear();
+        cache.clearForTest();
 
         for (int i = 0; i < count; i++) {
             put(cache, i, data);
@@ -189,7 +189,7 @@ public void testCacheLru() throws IOException, InterruptedException {
 
         // Limit by count, and allow all the keep keys plus one other.
         FileLruCache cache = new FileLruCache(getContext(), "testCacheLru", limitCacheCount(keepCount + 1));
-        cache.clear();
+        cache.clearForTest();
 
         for (int i = 0; i < keepCount; i++) {
             put(cache, i, data);
@@ -227,7 +227,7 @@ public void testConcurrentWritesToSameKey() throws IOException, InterruptedExcep
 
         final FileLruCache cache = new FileLruCache(
                 getContext(), "testConcurrentWritesToSameKey", limitCacheCount(count+1));
-        cache.clear();
+        cache.clearForTest();
 
         Runnable run = new Runnable() {
             @Override
diff --git a/facebook/tests/src/com/facebook/SessionTrackerTests.java b/facebook/tests/src/com/facebook/internal/SessionTrackerTests.java
similarity index 78%
rename from facebook/tests/src/com/facebook/SessionTrackerTests.java
rename to facebook/tests/src/com/facebook/internal/SessionTrackerTests.java
index 561e617cd..77cbc8158 100644
--- a/facebook/tests/src/com/facebook/SessionTrackerTests.java
+++ b/facebook/tests/src/com/facebook/internal/SessionTrackerTests.java
@@ -14,11 +14,13 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.internal;
 
 import android.test.suitebuilder.annotation.LargeTest;
 import android.test.suitebuilder.annotation.MediumTest;
 import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.*;
+import com.facebook.internal.SessionTracker;
 
 import java.util.Collections;
 
@@ -32,64 +34,60 @@
     // Tests the SessionDelegate while tracking the active session
     public void testDelegateWithActiveSession() throws Exception {
         Session.setActiveSession(null);
-        final SessionStatusCallbackRecorder statusRecorder = 
+        final SessionStatusCallbackRecorder statusRecorder =
                 new SessionStatusCallbackRecorder();
-        final MockTokenCache cache = new MockTokenCache(null, 0);
-        final ScriptedSession session = 
+        final MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        final ScriptedSession session =
                 createScriptedSessionOnBlockerThread(cache);
 
-        final AccessToken openToken = AccessToken.createFromString(TOKEN_STR, 
-                Collections.<String>emptyList());
-        session.addAuthorizeResult(openToken);
+        session.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
 
         final SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder);
-        Session.setActiveSession(session); 
-        
-        session.openForRead(getActivity());
-        
+        Session.setActiveSession(session);
+
+        session.openForRead(new Session.OpenRequest(getActivity()));
+
         statusRecorder.waitForCall(session, SessionState.OPENING, null);
         statusRecorder.waitForCall(session, SessionState.OPENED, null);
         assertNotNull("Session should be open", tracker.getOpenSession());
         assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
         tracker.getOpenSession().close();
         statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-        
+
         stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
         tracker.stopTracking();
         statusRecorder.close();
     }
-    
+
     @SmallTest
     @MediumTest
     @LargeTest
     // Tests the SessionDelegate while tracking a passed in session from the constructor
     public void testDelegateWithSessionInConstructor() throws Exception {
-        final SessionStatusCallbackRecorder statusRecorder = 
+        final SessionStatusCallbackRecorder statusRecorder =
                 new SessionStatusCallbackRecorder();
-        final MockTokenCache cache = new MockTokenCache(null, 0);
-        final ScriptedSession session = 
+        final MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        final ScriptedSession session =
                 createScriptedSessionOnBlockerThread(cache);
 
-        final AccessToken openToken = AccessToken.createFromString(TOKEN_STR, 
-                Collections.<String>emptyList());
-        session.addAuthorizeResult(openToken);
+        session.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
 
         SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder, session);
-        
-        session.openForRead(getActivity());
-        
+
+        session.openForRead(new Session.OpenRequest(getActivity()));
+
         statusRecorder.waitForCall(session, SessionState.OPENING, null);
         statusRecorder.waitForCall(session, SessionState.OPENED, null);
         assertNotNull("Session should be open", tracker.getOpenSession());
         assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
         tracker.getOpenSession().close();
         statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-        
+
         stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
         tracker.stopTracking();
         statusRecorder.close();
     }
-    
+
     @SmallTest
     @MediumTest
     @LargeTest
@@ -97,44 +95,42 @@ public void testDelegateWithSessionInConstructor() throws Exception {
     public void testDelegateWithActiveSessionThenNewSession() throws Exception {
         Session.setActiveSession(null);
         final SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        final MockTokenCache cache = new MockTokenCache(null, 0);
+        final MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
         final ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
 
-        final AccessToken openToken = AccessToken.createFromString(TOKEN_STR, 
-                Collections.<String>emptyList());
-        session.addAuthorizeResult(openToken);
+        session.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
 
         SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder);
-        Session.setActiveSession(session); 
-        
-        session.openForRead(getActivity());
-        
+        Session.setActiveSession(session);
+
+        session.openForRead(new Session.OpenRequest(getActivity()));
+
         statusRecorder.waitForCall(session, SessionState.OPENING, null);
         statusRecorder.waitForCall(session, SessionState.OPENED, null);
         assertNotNull("Session should be open", tracker.getOpenSession());
         assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
         tracker.getOpenSession().close();
         statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-        
+
         final ScriptedSession newSession = createScriptedSessionOnBlockerThread(cache);
-        newSession.addAuthorizeResult(openToken);
-        
+        newSession.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
+
         tracker.setSession(newSession);
         assertNull("Session should not be open", tracker.getOpenSession());
-        newSession.openForRead(getActivity());
-        
+        newSession.openForRead(new Session.OpenRequest(getActivity()));
+
         statusRecorder.waitForCall(newSession, SessionState.OPENING, null);
         statusRecorder.waitForCall(newSession, SessionState.OPENED, null);
         assertNotNull("Session should be open", tracker.getOpenSession());
         assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
         tracker.getOpenSession().close();
         statusRecorder.waitForCall(newSession, SessionState.CLOSED, null);
-        
+
         stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
         tracker.stopTracking();
         statusRecorder.close();
     }
-    
+
     @SmallTest
     @MediumTest
     @LargeTest
@@ -142,27 +138,25 @@ public void testDelegateWithActiveSessionThenNewSession() throws Exception {
     public void testDelegateWithSessionThenActiveSession() throws Exception {
         Session.setActiveSession(null);
         final SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        final MockTokenCache cache = new MockTokenCache(null, 0);
+        final MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
         final ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
 
-        final AccessToken openToken = AccessToken.createFromString(TOKEN_STR, 
-                Collections.<String>emptyList());
-        session.addAuthorizeResult(openToken);
+        session.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
 
         final SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder, session);
-        
-        session.openForRead(getActivity());
-        
+
+        session.openForRead(new Session.OpenRequest(getActivity()));
+
         statusRecorder.waitForCall(session, SessionState.OPENING, null);
         statusRecorder.waitForCall(session, SessionState.OPENED, null);
         assertNotNull("Session should be open", tracker.getOpenSession());
         assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
         tracker.getOpenSession().close();
         statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-        
+
         final ScriptedSession newSession = createScriptedSessionOnBlockerThread(cache);
-        newSession.addAuthorizeResult(openToken);
-        
+        newSession.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
+
         // need to run on the blocker thread so that when we register the 
         // BroadcastReceivers, the handler gets run on the right thread
         runOnBlockerThread(new Runnable() {
@@ -171,17 +165,17 @@ public void run() {
                 Session.setActiveSession(newSession);
             }
         }, true);
-        
+
         assertNull("Session should not be open", tracker.getOpenSession());
-        newSession.openForRead(getActivity());
-        
+        newSession.openForRead(new Session.OpenRequest(getActivity()));
+
         statusRecorder.waitForCall(newSession, SessionState.OPENING, null);
         statusRecorder.waitForCall(newSession, SessionState.OPENED, null);
         assertNotNull("Session should be open", tracker.getOpenSession());
         assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
         tracker.getOpenSession().close();
         statusRecorder.waitForCall(newSession, SessionState.CLOSED, null);
-        
+
         stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
         tracker.stopTracking();
         statusRecorder.close();
diff --git a/facebook/tests/src/com/facebook/ValidateTests.java b/facebook/tests/src/com/facebook/internal/ValidateTests.java
similarity index 75%
rename from facebook/tests/src/com/facebook/ValidateTests.java
rename to facebook/tests/src/com/facebook/internal/ValidateTests.java
index 751c3a1a2..f04934ef3 100644
--- a/facebook/tests/src/com/facebook/ValidateTests.java
+++ b/facebook/tests/src/com/facebook/internal/ValidateTests.java
@@ -1,7 +1,24 @@
-package com.facebook;
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
 
 import android.test.AndroidTestCase;
 import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.internal.Validate;
 
 import java.util.Arrays;
 
diff --git a/facebook/tests/src/com/facebook/GraphObjectWrapperTests.java b/facebook/tests/src/com/facebook/model/GraphObjectFactoryTests.java
similarity index 79%
rename from facebook/tests/src/com/facebook/GraphObjectWrapperTests.java
rename to facebook/tests/src/com/facebook/model/GraphObjectFactoryTests.java
index a6196a349..c60208db6 100644
--- a/facebook/tests/src/com/facebook/GraphObjectWrapperTests.java
+++ b/facebook/tests/src/com/facebook/model/GraphObjectFactoryTests.java
@@ -1,5 +1,5 @@
 /**
- * Copyright 2010 Facebook, Inc.
+ * Copyright 2012 Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,12 +14,13 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.model;
 
 import android.test.AndroidTestCase;
 import android.test.suitebuilder.annotation.LargeTest;
 import android.test.suitebuilder.annotation.MediumTest;
 import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.FacebookGraphObjectException;
 import junit.framework.Assert;
 import org.json.JSONArray;
 import org.json.JSONException;
@@ -28,13 +29,13 @@
 import java.util.*;
 import java.util.Map.Entry;
 
-public final class GraphObjectWrapperTests extends AndroidTestCase {
+public final class GraphObjectFactoryTests extends AndroidTestCase {
 
     @SmallTest
     @MediumTest
     @LargeTest
     public void testCreateEmptyGraphObject() {
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject();
+        GraphObject graphObject = GraphObject.Factory.create();
         assertTrue(graphObject != null);
     }
 
@@ -42,7 +43,7 @@ public void testCreateEmptyGraphObject() {
     @MediumTest
     @LargeTest
     public void testCanTreatAsMap() {
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject();
+        GraphObject graphObject = GraphObject.Factory.create();
 
         graphObject.setProperty("hello", "world");
         assertEquals("world", (String) graphObject.asMap().get("hello"));
@@ -52,7 +53,7 @@ public void testCanTreatAsMap() {
     @MediumTest
     @LargeTest
     public void testCanTreatAsGraphPlace() {
-        GraphPlace graphPlace = GraphObjectWrapper.createGraphObject(GraphPlace.class);
+        GraphPlace graphPlace = GraphObject.Factory.create(GraphPlace.class);
 
         graphPlace.setName("hello");
         assertEquals("hello", graphPlace.getName());
@@ -62,7 +63,7 @@ public void testCanTreatAsGraphPlace() {
     @MediumTest
     @LargeTest
     public void testCanTreatAsGraphUser() {
-        GraphUser graphUser = GraphObjectWrapper.createGraphObject(GraphUser.class);
+        GraphUser graphUser = GraphObject.Factory.create(GraphUser.class);
 
         graphUser.setFirstName("Michael");
         assertEquals("Michael", graphUser.getFirstName());
@@ -79,7 +80,7 @@ public void testCanTreatAsGraphUser() {
     @MediumTest
     @LargeTest
     public void testCanCastBetweenGraphObjectTypes() {
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject();
+        GraphObject graphObject = GraphObject.Factory.create();
 
         graphObject.setProperty("first_name", "Mickey");
 
@@ -103,7 +104,7 @@ public void testCanCastBetweenGraphObjectTypes() {
     @MediumTest
     @LargeTest
     public void testCastingToSameTypeGivesSameObject() {
-        Base base = GraphObjectWrapper.createGraphObject(Base.class);
+        Base base = GraphObject.Factory.create(Base.class);
 
         Base cast = base.cast(Base.class);
 
@@ -114,7 +115,7 @@ public void testCastingToSameTypeGivesSameObject() {
     @MediumTest
     @LargeTest
     public void testCastingToBaseTypeGivesSameObject() {
-        Derived derived = GraphObjectWrapper.createGraphObject(Derived.class);
+        Derived derived = GraphObject.Factory.create(Derived.class);
 
         Base cast = derived.cast(Base.class);
         assertTrue(derived == cast);
@@ -127,10 +128,10 @@ public void testCastingToBaseTypeGivesSameObject() {
     @MediumTest
     @LargeTest
     public void testCanSetComplexTypes() {
-        GraphLocation graphLocation = GraphObjectWrapper.createGraphObject(GraphLocation.class);
+        GraphLocation graphLocation = GraphObject.Factory.create(GraphLocation.class);
         graphLocation.setCity("Seattle");
 
-        GraphPlace graphPlace = GraphObjectWrapper.createGraphObject(GraphPlace.class);
+        GraphPlace graphPlace = GraphObject.Factory.create(GraphPlace.class);
         graphPlace.setLocation(graphLocation);
 
         assertEquals(graphLocation, graphPlace.getLocation());
@@ -149,7 +150,7 @@ public void testCanConvertFromJSON() throws JSONException {
         jsonPlace.put("location", jsonLocation);
         jsonPlace.put("name", "Eiffel Tower");
 
-        GraphPlace graphPlace = GraphObjectWrapper.createGraphObject(jsonPlace, GraphPlace.class);
+        GraphPlace graphPlace = GraphObject.Factory.create(jsonPlace, GraphPlace.class);
         GraphLocation graphLocation = graphPlace.getLocation();
         assertEquals("Paris", graphLocation.getCity());
     }
@@ -158,7 +159,7 @@ public void testCanConvertFromJSON() throws JSONException {
     @MediumTest
     @LargeTest
     public void testCanConvertFromGraphObject() throws JSONException {
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject();
+        GraphObject graphObject = GraphObject.Factory.create();
         graphObject.setProperty("city", "Paris");
         graphObject.setProperty("country", "France");
 
@@ -166,7 +167,7 @@ public void testCanConvertFromGraphObject() throws JSONException {
         jsonPlace.put("location", graphObject);
         jsonPlace.put("name", "Eiffel Tower");
 
-        GraphPlace graphPlace = GraphObjectWrapper.createGraphObject(jsonPlace, GraphPlace.class);
+        GraphPlace graphPlace = GraphObject.Factory.create(jsonPlace, GraphPlace.class);
         GraphLocation graphLocation = graphPlace.getLocation();
         assertEquals("Paris", graphLocation.getCity());
     }
@@ -174,12 +175,31 @@ public void testCanConvertFromGraphObject() throws JSONException {
     private abstract class GraphObjectClass implements GraphObject {
     }
 
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanConvertNumbers() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("double_as_string", 3.14159);
+        jsonObject.put("int_as_string", 42);
+
+        GraphMetric metric = GraphObject.Factory.create(jsonObject, GraphMetric.class);
+        assertEquals("42", metric.getIntAsString());
+        assertNotNull(metric.getDoubleAsString());
+        assertTrue(metric.getDoubleAsString().startsWith("3.14159"));
+    }
+
+    private interface GraphMetric extends GraphObject {
+        String getIntAsString();
+        String getDoubleAsString();
+    }
+
     @SmallTest
     @MediumTest
     @LargeTest
     public void testCantWrapNonInterface() {
         try {
-            GraphObjectWrapper.createGraphObject(GraphObjectClass.class);
+            GraphObject.Factory.create(GraphObjectClass.class);
             fail("Expected exception");
         } catch (FacebookGraphObjectException exception) {
         }
@@ -194,7 +214,7 @@ public void testCantWrapNonInterface() {
     @LargeTest
     public void testCantWrapBadZeroParameterMethodName() {
         try {
-            GraphObjectWrapper.createGraphObject(BadNoParameterMethodNameGraphObject.class);
+            GraphObject.Factory.create(BadNoParameterMethodNameGraphObject.class);
             fail("Expected exception");
         } catch (FacebookGraphObjectException exception) {
         }
@@ -209,7 +229,7 @@ public void testCantWrapBadZeroParameterMethodName() {
     @LargeTest
     public void testCantWrapBadSingleParameterMethodName() {
         try {
-            GraphObjectWrapper.createGraphObject(BadSingleParameterMethodNameGraphObject.class);
+            GraphObject.Factory.create(BadSingleParameterMethodNameGraphObject.class);
             fail("Expected exception");
         } catch (FacebookGraphObjectException exception) {
         }
@@ -224,7 +244,7 @@ public void testCantWrapBadSingleParameterMethodName() {
     @LargeTest
     public void testCantWrapBadGetterName() {
         try {
-            GraphObjectWrapper.createGraphObject(BadGetterNameGraphObject.class);
+            GraphObject.Factory.create(BadGetterNameGraphObject.class);
             fail("Expected exception");
         } catch (FacebookGraphObjectException exception) {
         }
@@ -239,7 +259,7 @@ public void testCantWrapBadGetterName() {
     @LargeTest
     public void testCantWrapBadGetterParams() {
         try {
-            GraphObjectWrapper.createGraphObject(BadGetterParamsGraphObject.class);
+            GraphObject.Factory.create(BadGetterParamsGraphObject.class);
             fail("Expected exception");
         } catch (FacebookGraphObjectException exception) {
         }
@@ -254,7 +274,7 @@ public void testCantWrapBadGetterParams() {
     @LargeTest
     public void testCantWrapBadGetterReturnType() {
         try {
-            GraphObjectWrapper.createGraphObject(BadGetterReturnTypeGraphObject.class);
+            GraphObject.Factory.create(BadGetterReturnTypeGraphObject.class);
             fail("Expected exception");
         } catch (FacebookGraphObjectException exception) {
         }
@@ -269,7 +289,7 @@ public void testCantWrapBadGetterReturnType() {
     @LargeTest
     public void testCantWrapBadSetterName() {
         try {
-            GraphObjectWrapper.createGraphObject(BadSetterNameGraphObject.class);
+            GraphObject.Factory.create(BadSetterNameGraphObject.class);
             fail("Expected exception");
         } catch (FacebookGraphObjectException exception) {
         }
@@ -284,7 +304,7 @@ public void testCantWrapBadSetterName() {
     @LargeTest
     public void testCantWrapBadSetterParams() {
         try {
-            GraphObjectWrapper.createGraphObject(BadSetterParamsGraphObject.class);
+            GraphObject.Factory.create(BadSetterParamsGraphObject.class);
             fail("Expected exception");
         } catch (FacebookGraphObjectException exception) {
         }
@@ -299,7 +319,7 @@ public void testCantWrapBadSetterParams() {
     @LargeTest
     public void testCantWrapBadSetterReturnType() {
         try {
-            GraphObjectWrapper.createGraphObject(BadSetterReturnTypeGraphObject.class);
+            GraphObject.Factory.create(BadSetterReturnTypeGraphObject.class);
             fail("Expected exception");
         } catch (FacebookGraphObjectException exception) {
         }
@@ -316,7 +336,7 @@ public void testCantWrapBadSetterReturnType() {
     @LargeTest
     public void testCantWrapBadBaseInterface() {
         try {
-            GraphObjectWrapper.createGraphObject(BadBaseInterfaceGraphObject.class);
+            GraphObject.Factory.create(BadBaseInterfaceGraphObject.class);
             fail("Expected exception");
         } catch (FacebookGraphObjectException exception) {
         }
@@ -346,7 +366,7 @@ public void testCantWrapBadBaseInterface() {
     @LargeTest
     public void testCanOverrideGraphPropertyNames() {
         GoodPropertyOverrideInterfaceGraphObject graphObject =
-                GraphObjectWrapper.createGraphObject(GoodPropertyOverrideInterfaceGraphObject.class);
+                GraphObject.Factory.create(GoodPropertyOverrideInterfaceGraphObject.class);
 
         String testValue = "flu-blah";
         graphObject.setDefaultName(testValue);
@@ -371,7 +391,7 @@ public void testCanOverrideGraphPropertyNames() {
     @LargeTest
     public void testCantWrapBadPropertyNameOverrides() {
         try {
-            GraphObjectWrapper.createGraphObject(BadPropertyOverrideInterfaceGraphObject.class);
+            GraphObject.Factory.create(BadPropertyOverrideInterfaceGraphObject.class);
             fail("Expected exception");
         } catch (FacebookGraphObjectException exception) {
         }
@@ -381,7 +401,7 @@ public void testCantWrapBadPropertyNameOverrides() {
     @MediumTest
     @LargeTest
     public void testObjectEquals() {
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject();
+        GraphObject graphObject = GraphObject.Factory.create();
         graphObject.setProperty("aKey", "aValue");
 
         assertTrue(graphObject.equals(graphObject));
@@ -390,7 +410,7 @@ public void testObjectEquals() {
         assertTrue(graphObject.equals(graphPlace));
         assertTrue(graphPlace.equals(graphObject));
 
-        GraphObject aDifferentGraphObject = GraphObjectWrapper.createGraphObject();
+        GraphObject aDifferentGraphObject = GraphObject.Factory.create();
         aDifferentGraphObject.setProperty("aKey", "aDifferentValue");
         assertFalse(graphObject.equals(aDifferentGraphObject));
     }
@@ -403,7 +423,7 @@ public void testGetProperty() throws JSONException {
         jsonObject.put("hello", "world");
         jsonObject.put("hocus", "pocus");
 
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
         assertEquals("world", graphObject.getProperty("hello"));
         assertTrue(graphObject.getProperty("fred") == null);
     }
@@ -413,7 +433,7 @@ public void testGetProperty() throws JSONException {
     @LargeTest
     public void testSetProperty() throws JSONException {
         JSONObject jsonObject = new JSONObject();
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
 
         graphObject.setProperty("hello", "world");
         graphObject.setProperty("don't imagine", "purple elephants");
@@ -428,7 +448,7 @@ public void testSetProperty() throws JSONException {
     public void testRemoveProperty() throws JSONException {
         JSONObject jsonObject = new JSONObject();
         jsonObject.put("whirled", "peas");
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
 
         graphObject.setProperty("hello", "world");
         graphObject.setProperty("don't imagine", "purple elephants");
@@ -444,7 +464,7 @@ public void testMapClear() throws JSONException {
         JSONObject jsonObject = new JSONObject();
         jsonObject.put("hello", "world");
 
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
 
         assertEquals(1, jsonObject.length());
 
@@ -460,7 +480,7 @@ public void testMapContainsKey() throws JSONException {
         JSONObject jsonObject = new JSONObject();
         jsonObject.put("hello", "world");
 
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
 
         assertTrue(graphObject.asMap().containsKey("hello"));
         assertFalse(graphObject.asMap().containsKey("hocus"));
@@ -473,7 +493,7 @@ public void testMapContainsValue() throws JSONException {
         JSONObject jsonObject = new JSONObject();
         jsonObject.put("hello", "world");
 
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
 
         assertTrue(graphObject.asMap().containsValue("world"));
         assertFalse(graphObject.asMap().containsValue("pocus"));
@@ -487,7 +507,7 @@ public void testMapEntrySet() throws JSONException {
         jsonObject.put("hello", "world");
         jsonObject.put("hocus", "pocus");
 
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
 
         Set<Entry<String, Object>> entrySet = graphObject.asMap().entrySet();
         assertEquals(2, entrySet.size());
@@ -501,7 +521,7 @@ public void testMapGet() throws JSONException {
         jsonObject.put("hello", "world");
         jsonObject.put("hocus", "pocus");
 
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
         assertEquals("world", graphObject.asMap().get("hello"));
         assertTrue(graphObject.getProperty("fred") == null);
     }
@@ -510,7 +530,7 @@ public void testMapGet() throws JSONException {
     @MediumTest
     @LargeTest
     public void testMapGetReturnsNullForMissingProperty() throws JSONException {
-        GraphUser graphUser = GraphObjectWrapper.createGraphObject(GraphUser.class);
+        GraphUser graphUser = GraphObject.Factory.create(GraphUser.class);
         assertNull(graphUser.getBirthday());
     }
 
@@ -520,7 +540,7 @@ public void testMapGetReturnsNullForMissingProperty() throws JSONException {
     public void testMapIsEmpty() throws JSONException {
         JSONObject jsonObject = new JSONObject();
 
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
         assertTrue(graphObject.asMap().isEmpty());
 
         jsonObject.put("hello", "world");
@@ -536,7 +556,7 @@ public void testMapKeySet() throws JSONException {
         jsonObject.put("hello", "world");
         jsonObject.put("hocus", "pocus");
 
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
 
         Set<String> keySet = graphObject.asMap().keySet();
         assertEquals(2, keySet.size());
@@ -551,7 +571,7 @@ public void testMapKeySet() throws JSONException {
     public void testMapPut() throws JSONException {
         JSONObject jsonObject = new JSONObject();
 
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
         graphObject.setProperty("hello", "world");
         graphObject.setProperty("hocus", "pocus");
 
@@ -565,11 +585,11 @@ public void testMapPut() throws JSONException {
     public void testMapPutOfWrapperPutsJSONObject() throws JSONException {
         JSONObject jsonObject = new JSONObject();
 
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
         graphObject.setProperty("hello", "world");
         graphObject.setProperty("hocus", "pocus");
 
-        GraphObject parentObject = GraphObjectWrapper.createGraphObject();
+        GraphObject parentObject = GraphObject.Factory.create();
         parentObject.setProperty("key", graphObject);
 
         JSONObject jsonParent = parentObject.getInnerJSONObject();
@@ -585,11 +605,12 @@ public void testMapPutOfWrapperPutsJSONObject() throws JSONException {
     public void testMapPutOfWrapperPutsJSONArray() throws JSONException {
         JSONArray jsonArray = new JSONArray();
 
-        GraphObjectList<String> graphObjectList = GraphObjectWrapper.wrapArray(jsonArray, String.class);
+        GraphObjectList<String> graphObjectList = GraphObject.Factory
+                .createList(jsonArray, String.class);
         graphObjectList.add("hello");
         graphObjectList.add("world");
 
-        GraphObject parentObject = GraphObjectWrapper.createGraphObject();
+        GraphObject parentObject = GraphObject.Factory.create();
         parentObject.setProperty("key", graphObjectList);
 
         JSONObject jsonParent = parentObject.getInnerJSONObject();
@@ -608,7 +629,7 @@ public void testMapPutAll() throws JSONException {
         map.put("hocus", "pocus");
 
         JSONObject jsonObject = new JSONObject();
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
 
         graphObject.asMap().putAll(map);
         assertEquals("pocus", jsonObject.get("hocus"));
@@ -623,7 +644,7 @@ public void testMapRemove() throws JSONException {
         jsonObject.put("hello", "world");
         jsonObject.put("hocus", "pocus");
 
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
         graphObject.removeProperty("hello");
 
         assertEquals(1, jsonObject.length());
@@ -637,7 +658,7 @@ public void testMapSize() throws JSONException {
         jsonObject.put("hello", "world");
         jsonObject.put("hocus", "pocus");
 
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
 
         assertEquals(2, graphObject.asMap().size());
     }
@@ -650,7 +671,7 @@ public void testMapValues() throws JSONException {
         jsonObject.put("hello", "world");
         jsonObject.put("hocus", "pocus");
 
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
 
         Collection<Object> values = graphObject.asMap().values();
 
@@ -666,7 +687,7 @@ public void testGetInnerJSONObject() throws JSONException {
         jsonObject.put("hello", "world");
         jsonObject.put("hocus", "pocus");
 
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
 
         assertEquals(jsonObject, graphObject.getInnerJSONObject());
     }
@@ -675,8 +696,8 @@ public void testGetInnerJSONObject() throws JSONException {
     @MediumTest
     @LargeTest
     public void testSettingGraphObjectProxyStoresJSONObject() throws JSONException {
-        GraphPlace graphPlace = GraphObjectWrapper.createGraphObject(GraphPlace.class);
-        GraphLocation graphLocation = GraphObjectWrapper.createGraphObject(GraphLocation.class);
+        GraphPlace graphPlace = GraphObject.Factory.create(GraphPlace.class);
+        GraphLocation graphLocation = GraphObject.Factory.create(GraphLocation.class);
 
         graphPlace.setLocation(graphLocation);
 
@@ -699,7 +720,7 @@ public void testSettingGraphObjectProxyStoresJSONObject() throws JSONException {
     @MediumTest
     @LargeTest
     public void testGetStringsAsDates() {
-        DateGraphObject dates = GraphObjectWrapper.createGraphObject(DateGraphObject.class);
+        DateGraphObject dates = GraphObject.Factory.create(DateGraphObject.class);
         dates.setProperty("date1", "2012-07-04");
         dates.setProperty("date2", "2012-07-04T19:30:50");
         dates.setProperty("date3", "2012-07-04T19:20:40-0400");
@@ -740,7 +761,7 @@ public void testGetStringsAsDates() {
     public void testCollectionAdd() throws JSONException {
         JSONArray array = new JSONArray();
 
-        Collection<Integer> collection = GraphObjectWrapper.wrapArray(array, Integer.class);
+        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
         collection.add(5);
 
         assertTrue(array.length() == 1);
@@ -755,7 +776,7 @@ public void testCollectionAddAll() throws JSONException {
 
         Collection<Integer> collectionToAdd = Arrays.asList(5, -1);
 
-        Collection<Integer> collection = GraphObjectWrapper.wrapArray(array, Integer.class);
+        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
         collection.addAll(collectionToAdd);
 
         assertTrue(array.length() == 2);
@@ -770,7 +791,7 @@ public void testCollectionContains() throws JSONException {
         JSONArray array = new JSONArray();
         array.put(5);
 
-        Collection<Integer> collection = GraphObjectWrapper.wrapArray(array, Integer.class);
+        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
         assertTrue(collection.contains(5));
         assertFalse(collection.contains(6));
     }
@@ -783,7 +804,7 @@ public void testCollectionContainsAll() throws JSONException {
         array.put(5);
         array.put(-1);
 
-        Collection<Integer> collection = GraphObjectWrapper.wrapArray(array, Integer.class);
+        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
         assertTrue(collection.containsAll(Arrays.asList(5)));
         assertTrue(collection.containsAll(Arrays.asList(5, -1)));
         assertFalse(collection.containsAll(Arrays.asList(5, -1, 2)));
@@ -795,7 +816,7 @@ public void testCollectionContainsAll() throws JSONException {
     public void testCollectionIsEmpty() throws JSONException {
         JSONArray array = new JSONArray();
 
-        Collection<Integer> collection = GraphObjectWrapper.wrapArray(array, Integer.class);
+        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
         assertTrue(collection.isEmpty());
 
         array.put(5);
@@ -810,7 +831,7 @@ public void testCollectionIterator() throws JSONException {
         array.put(5);
         array.put(-1);
 
-        Collection<Integer> collection = GraphObjectWrapper.wrapArray(array, Integer.class);
+        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
         Iterator<Integer> iter = collection.iterator();
         assertTrue(iter.hasNext());
         assertTrue(iter.next() == 5);
@@ -827,12 +848,12 @@ public void testCollectionIterator() throws JSONException {
     @MediumTest
     @LargeTest
     public void testCollectionIteratorOfGraphObject() throws JSONException {
-        Collection<GraphLocation> collection = GraphObjectWrapper.createArray(GraphLocation.class);
+        Collection<GraphLocation> collection = GraphObject.Factory.createList(GraphLocation.class);
 
-        GraphLocation seattle = GraphObjectWrapper.createGraphObject(GraphLocation.class);
+        GraphLocation seattle = GraphObject.Factory.create(GraphLocation.class);
         seattle.setCity("Seattle");
         collection.add(seattle);
-        GraphLocation paris = GraphObjectWrapper.createGraphObject(GraphLocation.class);
+        GraphLocation paris = GraphObject.Factory.create(GraphLocation.class);
         paris.setCity("Paris");
         collection.add(paris);
 
@@ -854,7 +875,7 @@ public void testCollectionIteratorOfGraphObject() throws JSONException {
     public void testCollectionSize() throws JSONException {
         JSONArray array = new JSONArray();
 
-        Collection<Integer> collection = GraphObjectWrapper.wrapArray(array, Integer.class);
+        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
         assertEquals(0, collection.size());
 
         array.put(5);
@@ -866,7 +887,7 @@ public void testCollectionSize() throws JSONException {
     @LargeTest
     public void testCollectionClearThrows() throws JSONException {
         try {
-            Collection<Integer> collection = GraphObjectWrapper.createArray(Integer.class);
+            Collection<Integer> collection = GraphObject.Factory.createList(Integer.class);
             collection.clear();
             fail("Expected exception");
         } catch (UnsupportedOperationException exception) {
@@ -878,7 +899,7 @@ public void testCollectionClearThrows() throws JSONException {
     @LargeTest
     public void testCollectionRemoveThrows() throws JSONException {
         try {
-            Collection<Integer> collection = GraphObjectWrapper.createArray(Integer.class);
+            Collection<Integer> collection = GraphObject.Factory.createList(Integer.class);
             collection.remove(5);
             fail("Expected exception");
         } catch (UnsupportedOperationException exception) {
@@ -890,7 +911,7 @@ public void testCollectionRemoveThrows() throws JSONException {
     @LargeTest
     public void testCollectionRemoveAllThrows() throws JSONException {
         try {
-            Collection<Integer> collection = GraphObjectWrapper.createArray(Integer.class);
+            Collection<Integer> collection = GraphObject.Factory.createList(Integer.class);
             collection.removeAll(Arrays.asList());
             fail("Expected exception");
         } catch (UnsupportedOperationException exception) {
@@ -902,7 +923,7 @@ public void testCollectionRemoveAllThrows() throws JSONException {
     @LargeTest
     public void testCollectionRetainAllThrows() throws JSONException {
         try {
-            Collection<Integer> collection = GraphObjectWrapper.createArray(Integer.class);
+            Collection<Integer> collection = GraphObject.Factory.createList(Integer.class);
             collection.retainAll(Arrays.asList());
             fail("Expected exception");
         } catch (UnsupportedOperationException exception) {
@@ -926,7 +947,7 @@ public void testObjectWrapsJSONCollection() throws JSONException {
         JSONObject jsonLocations = new JSONObject();
         jsonLocations.put("locations", jsonArray);
 
-        Locations locations = GraphObjectWrapper.createGraphObject(jsonLocations, Locations.class);
+        Locations locations = GraphObject.Factory.create(jsonLocations, Locations.class);
         Collection<GraphLocation> locationsGraphObjectCollection = locations.getLocations();
         assertTrue(locationsGraphObjectCollection != null);
 
@@ -939,14 +960,14 @@ public void testObjectWrapsJSONCollection() throws JSONException {
     @MediumTest
     @LargeTest
     public void testObjectWrapsIterable() throws JSONException {
-        GraphUser user = GraphObjectWrapper.createGraphObject(GraphUser.class);
+        GraphUser user = GraphObject.Factory.create(GraphUser.class);
         user.setFirstName("Foo");
         user.setLastName("Bar");
 
         List<GraphUser> users = new ArrayList<GraphUser>();
         users.add(user);
 
-        OpenGraphAction action = GraphObjectWrapper.createGraphObject(OpenGraphAction.class);
+        OpenGraphAction action = GraphObject.Factory.create(OpenGraphAction.class);
         action.setTags(users);
 
         String json = action.getInnerJSONObject().toString();
@@ -974,8 +995,9 @@ public void testCollectionWrapsJSONObject() throws JSONException {
 
         JSONArray jsonArray = new JSONArray();
         jsonArray.put(jsonLocation);
-        Collection<GraphLocation> locationsGraphObjectCollection = GraphObjectWrapper.wrapArray(jsonArray,
-                GraphLocation.class);
+        Collection<GraphLocation> locationsGraphObjectCollection = GraphObject.Factory
+                .createList(jsonArray,
+                        GraphLocation.class);
         assertTrue(locationsGraphObjectCollection != null);
 
         GraphLocation graphLocation = locationsGraphObjectCollection.iterator().next();
@@ -988,7 +1010,7 @@ public void testCollectionWrapsJSONObject() throws JSONException {
     @LargeTest
     public void testCannotCastCollectionOfNonGraphObjects() throws JSONException {
         try {
-            GraphObjectList<Integer> collection = GraphObjectWrapper.createArray(Integer.class);
+            GraphObjectList<Integer> collection = GraphObject.Factory.createList(Integer.class);
             collection.castToListOf(GraphLocation.class);
             fail("Expected exception");
         } catch (FacebookGraphObjectException exception) {
@@ -1005,7 +1027,8 @@ public void testCanCastCollectionOfGraphObjects() throws JSONException {
         JSONArray jsonArray = new JSONArray();
         jsonArray.put(jsonSeattle);
 
-        GraphObjectList<GraphObject> collection = GraphObjectWrapper.wrapArray(jsonArray, GraphObject.class);
+        GraphObjectList<GraphObject> collection = GraphObject.Factory
+                .createList(jsonArray, GraphObject.class);
 
         GraphObjectList<GraphLocation> locationCollection = collection.castToListOf(GraphLocation.class);
         assertTrue(locationCollection != null);
@@ -1019,7 +1042,7 @@ public void testCanCastCollectionOfGraphObjects() throws JSONException {
     @MediumTest
     @LargeTest
     public void testCastingCollectionToSameTypeGivesSameObject() {
-        GraphObjectList<Base> base = GraphObjectWrapper.createArray(Base.class);
+        GraphObjectList<Base> base = GraphObject.Factory.createList(Base.class);
 
         GraphObjectList<Base> cast = base.castToListOf(Base.class);
 
@@ -1030,7 +1053,7 @@ public void testCastingCollectionToSameTypeGivesSameObject() {
     @MediumTest
     @LargeTest
     public void testCastingCollectionToBaseTypeGivesSameObject() {
-        GraphObjectList<Derived> derived = GraphObjectWrapper.createArray(Derived.class);
+        GraphObjectList<Derived> derived = GraphObject.Factory.createList(Derived.class);
 
         GraphObjectList<Base> cast = derived.castToListOf(Base.class);
 
@@ -1043,7 +1066,8 @@ public void testCastingCollectionToBaseTypeGivesSameObject() {
     public void testCanGetInnerJSONArray() throws JSONException {
         JSONArray jsonArray = new JSONArray();
 
-        GraphObjectList<GraphObject> collection = GraphObjectWrapper.wrapArray(jsonArray, GraphObject.class);
+        GraphObjectList<GraphObject> collection = GraphObject.Factory
+                .createList(jsonArray, GraphObject.class);
 
         assertEquals(jsonArray, collection.getInnerJSONArray());
     }
@@ -1056,7 +1080,8 @@ public void testCanGetRandomAccess() throws JSONException {
         jsonArray.put("Seattle");
         jsonArray.put("Menlo Park");
 
-        GraphObjectList<String> collection = GraphObjectWrapper.wrapArray(jsonArray, String.class);
+        GraphObjectList<String> collection = GraphObject.Factory
+                .createList(jsonArray, String.class);
 
         assertEquals("Menlo Park", collection.get(1));
     }
@@ -1067,7 +1092,8 @@ public void testCanGetRandomAccess() throws JSONException {
     public void testCanSetRandomAccess() throws JSONException {
         JSONArray jsonArray = new JSONArray();
 
-        GraphObjectList<String> collection = GraphObjectWrapper.wrapArray(jsonArray, String.class);
+        GraphObjectList<String> collection = GraphObject.Factory
+                .createList(jsonArray, String.class);
 
         collection.add("Seattle");
         collection.add("Menlo Park");
@@ -1082,11 +1108,12 @@ public void testCanSetRandomAccess() throws JSONException {
     public void testCollectionPutOfWrapperPutsJSONObject() throws JSONException {
         JSONObject jsonObject = new JSONObject();
 
-        GraphObject graphObject = GraphObjectWrapper.createGraphObject(jsonObject);
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
         graphObject.setProperty("hello", "world");
         graphObject.setProperty("hocus", "pocus");
 
-        GraphObjectList<GraphObject> parentList = GraphObjectWrapper.createArray(GraphObject.class);
+        GraphObjectList<GraphObject> parentList = GraphObject.Factory
+                .createList(GraphObject.class);
         parentList.add(graphObject);
 
         JSONArray jsonArray = parentList.getInnerJSONArray();
@@ -1103,4 +1130,16 @@ public void testCollectionPutOfWrapperPutsJSONObject() throws JSONException {
         assertNotNull(obj);
         assertEquals(jsonObject, obj);
     }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCamelCaseToLowercase() {
+        assertEquals("hello_world", GraphObject.Factory
+                .convertCamelCaseToLowercaseWithUnderscores("HelloWorld"));
+        assertEquals("hello_world", GraphObject.Factory
+                .convertCamelCaseToLowercaseWithUnderscores("helloWorld"));
+    }
+
+
 }
diff --git a/facebook/tests/src/com/facebook/UtilityTests.java b/facebook/tests/src/com/facebook/model/JsonUtilTests.java
similarity index 76%
rename from facebook/tests/src/com/facebook/UtilityTests.java
rename to facebook/tests/src/com/facebook/model/JsonUtilTests.java
index b2e97c10a..0c55d30ea 100644
--- a/facebook/tests/src/com/facebook/UtilityTests.java
+++ b/facebook/tests/src/com/facebook/model/JsonUtilTests.java
@@ -1,5 +1,5 @@
 /**
- * Copyright 2010 Facebook, Inc.
+ * Copyright 2012 Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.model;
 
 import android.test.AndroidTestCase;
 import android.test.suitebuilder.annotation.LargeTest;
@@ -28,13 +28,7 @@
 import java.util.Map.Entry;
 import java.util.Set;
 
-public final class UtilityTests extends AndroidTestCase {
-
-    @SmallTest @MediumTest @LargeTest
-    public void testCamelCaseToLowercase() {
-        assertEquals("hello_world", Utility.convertCamelCaseToLowercaseWithUnderscores("HelloWorld"));
-        assertEquals("hello_world", Utility.convertCamelCaseToLowercaseWithUnderscores("helloWorld"));
-    }
+public final class JsonUtilTests extends AndroidTestCase {
 
     @SmallTest @MediumTest @LargeTest
     public void testJsonObjectClear() throws JSONException {
@@ -43,7 +37,7 @@ public void testJsonObjectClear() throws JSONException {
         jsonObject.put("hello", "world");
         jsonObject.put("hocus", "pocus");
 
-        Utility.jsonObjectClear(jsonObject);
+        JsonUtil.jsonObjectClear(jsonObject);
         assertEquals(0, jsonObject.length());
     }
 
@@ -54,8 +48,8 @@ public void testJsonObjectContainsValue() throws JSONException {
         jsonObject.put("hello", "world");
         jsonObject.put("hocus", "pocus");
 
-        assertTrue(Utility.jsonObjectContainsValue(jsonObject, "pocus"));
-        assertFalse(Utility.jsonObjectContainsValue(jsonObject, "Fred"));
+        assertTrue(JsonUtil.jsonObjectContainsValue(jsonObject, "pocus"));
+        assertFalse(JsonUtil.jsonObjectContainsValue(jsonObject, "Fred"));
     }
 
     @SmallTest @MediumTest @LargeTest
@@ -65,7 +59,7 @@ public void testJsonObjectEntrySet() throws JSONException {
         jsonObject.put("hello", "world");
         jsonObject.put("hocus", "pocus");
 
-        Set<Entry<String, Object>> entrySet = Utility.jsonObjectEntrySet(jsonObject);
+        Set<Entry<String, Object>> entrySet = JsonUtil.jsonObjectEntrySet(jsonObject);
         assertEquals(2, entrySet.size());
     }
 
@@ -76,7 +70,7 @@ public void testJsonObjectKeySet() throws JSONException {
         jsonObject.put("hello", "world");
         jsonObject.put("hocus", "pocus");
 
-        Set<String> keySet = Utility.jsonObjectKeySet(jsonObject);
+        Set<String> keySet = JsonUtil.jsonObjectKeySet(jsonObject);
         assertEquals(2, keySet.size());
         assertTrue(keySet.contains("hello"));
         assertFalse(keySet.contains("world"));
@@ -89,7 +83,7 @@ public void testJsonObjectPutAll() throws JSONException {
         map.put("hocus", "pocus");
 
         JSONObject jsonObject = new JSONObject();
-        Utility.jsonObjectPutAll(jsonObject, map);
+        JsonUtil.jsonObjectPutAll(jsonObject, map);
 
         assertEquals("pocus", jsonObject.get("hocus"));
         assertEquals(2, jsonObject.length());
@@ -101,7 +95,7 @@ public void testJsonObjectValues() throws JSONException {
         jsonObject.put("hello", "world");
         jsonObject.put("hocus", "pocus");
 
-        Collection<Object> values = Utility.jsonObjectValues(jsonObject);
+        Collection<Object> values = JsonUtil.jsonObjectValues(jsonObject);
 
         assertEquals(2, values.size());
         assertTrue(values.contains("world"));
diff --git a/facebook/tests/src/com/facebook/FragmentTestCase.java b/facebook/tests/src/com/facebook/widget/FragmentTestCase.java
similarity index 78%
rename from facebook/tests/src/com/facebook/FragmentTestCase.java
rename to facebook/tests/src/com/facebook/widget/FragmentTestCase.java
index db974969a..e948bc300 100644
--- a/facebook/tests/src/com/facebook/FragmentTestCase.java
+++ b/facebook/tests/src/com/facebook/widget/FragmentTestCase.java
@@ -1,9 +1,26 @@
-package com.facebook;
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
 
 import android.os.Bundle;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.widget.LinearLayout;
+import com.facebook.FacebookActivityTestCase;
 
 public class FragmentTestCase<T extends FragmentTestCase.TestFragmentActivity<?>> extends FacebookActivityTestCase<T> {
     public FragmentTestCase(Class<T> activityClass) {
diff --git a/facebook/tests/src/com/facebook/FriendPickerFragmentTests.java b/facebook/tests/src/com/facebook/widget/FriendPickerFragmentTests.java
similarity index 97%
rename from facebook/tests/src/com/facebook/FriendPickerFragmentTests.java
rename to facebook/tests/src/com/facebook/widget/FriendPickerFragmentTests.java
index 5141857e8..b7a24cfba 100644
--- a/facebook/tests/src/com/facebook/FriendPickerFragmentTests.java
+++ b/facebook/tests/src/com/facebook/widget/FriendPickerFragmentTests.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.widget;
 
 import android.os.Bundle;
 import android.test.TouchUtils;
@@ -23,6 +23,8 @@
 import android.view.View;
 import android.widget.CheckBox;
 import android.widget.ListView;
+import com.facebook.TestBlocker;
+import com.facebook.TestSession;
 import com.facebook.sdk.tests.R;
 
 import java.util.Arrays;
@@ -120,7 +122,7 @@ public void run() {
                 fragment.setSession(session1);
                 fragment.setOnDataChangedListener(new PickerFragment.OnDataChangedListener() {
                     @Override
-                    public void onDataChanged() {
+                    public void onDataChanged(PickerFragment<?> fragment) {
                         blocker.signal();
                     }
                 });
diff --git a/facebook/tests/src/com/facebook/GraphObjectPagingLoaderTests.java b/facebook/tests/src/com/facebook/widget/GraphObjectPagingLoaderTests.java
similarity index 98%
rename from facebook/tests/src/com/facebook/GraphObjectPagingLoaderTests.java
rename to facebook/tests/src/com/facebook/widget/GraphObjectPagingLoaderTests.java
index dce2f1d06..104bd49f1 100644
--- a/facebook/tests/src/com/facebook/GraphObjectPagingLoaderTests.java
+++ b/facebook/tests/src/com/facebook/widget/GraphObjectPagingLoaderTests.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.widget;
 
 import android.location.Location;
 import android.os.Bundle;
@@ -23,6 +23,8 @@
 import android.support.v4.content.Loader;
 import android.test.suitebuilder.annotation.LargeTest;
 import android.test.suitebuilder.annotation.MediumTest;
+import com.facebook.*;
+import com.facebook.model.GraphPlace;
 
 public class GraphObjectPagingLoaderTests extends FragmentTestCase<GraphObjectPagingLoaderTests.TestActivity> {
     public GraphObjectPagingLoaderTests() {
diff --git a/facebook/tests/src/com/facebook/ImageResponseCacheTests.java b/facebook/tests/src/com/facebook/widget/ImageResponseCacheTests.java
similarity index 86%
rename from facebook/tests/src/com/facebook/ImageResponseCacheTests.java
rename to facebook/tests/src/com/facebook/widget/ImageResponseCacheTests.java
index c18cd31cb..f1ca93ca8 100644
--- a/facebook/tests/src/com/facebook/ImageResponseCacheTests.java
+++ b/facebook/tests/src/com/facebook/widget/ImageResponseCacheTests.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.widget;
 
 import android.content.Context;
 import android.graphics.Bitmap;
@@ -22,9 +22,12 @@
 import android.test.AndroidTestCase;
 import android.test.suitebuilder.annotation.LargeTest;
 import android.test.suitebuilder.annotation.MediumTest;
+import com.facebook.internal.Utility;
+import com.facebook.widget.ImageResponseCache;
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.net.HttpURLConnection;
 import java.net.URL;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
@@ -35,7 +38,7 @@
     public void testImageCaching() throws IOException {
         // In unit test, since we need verify first access the image is not in cache
         // we need clear the cache first
-        ImageResponseCache.getCache(safeGetContext()).clear();
+        ImageResponseCache.getCache(safeGetContext()).clearForTest();
         String imgUrl = "http://sphotos-b.xx.fbcdn.net/hphotos-snc7/300716_163831917043403_1106723719_n.jpg";
         
         Bitmap bmp1 = readImage(imgUrl, false);
@@ -63,7 +66,11 @@ private Bitmap readImage(String uri, boolean expectedFromCache) {
             boolean isInCache = (ImageResponseCache.getCache(safeGetContext()).get(url.toString()) != null);
             assertTrue(isInCache == expectedFromCache);
             // Read the image
-            istream = ImageResponseCache.getImageStream(url, safeGetContext());
+            istream = ImageResponseCache.getCachedImageStream(url, safeGetContext());
+            if (istream == null) {
+                HttpURLConnection connection = (HttpURLConnection)url.openConnection();
+                istream = ImageResponseCache.interceptAndCacheImageStream(safeGetContext(), connection);
+            }
             assertTrue(istream != null);
             bmp = BitmapFactory.decodeStream(istream);
             assertTrue(bmp != null);
diff --git a/facebook/tests/src/com/facebook/LoginButtonTest.java b/facebook/tests/src/com/facebook/widget/LoginButtonTest.java
similarity index 66%
rename from facebook/tests/src/com/facebook/LoginButtonTest.java
rename to facebook/tests/src/com/facebook/widget/LoginButtonTest.java
index 2fdeb6023..863585575 100644
--- a/facebook/tests/src/com/facebook/LoginButtonTest.java
+++ b/facebook/tests/src/com/facebook/widget/LoginButtonTest.java
@@ -1,8 +1,27 @@
-package com.facebook;
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
 
 import android.test.suitebuilder.annotation.LargeTest;
 import android.test.suitebuilder.annotation.MediumTest;
 import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.*;
+import com.facebook.widget.LoginButton;
+import junit.framework.Assert;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -16,29 +35,45 @@
     @SmallTest
     @MediumTest
     @LargeTest
-    public void testLoginButton() {
-        SessionTestsBase.MockTokenCache cache = new SessionTestsBase.MockTokenCache(null, 0);
-        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
+    public void testLoginButton() throws Throwable {
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        final ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
         SessionTestsBase.SessionStatusCallbackRecorder statusRecorder = new SessionTestsBase.SessionStatusCallbackRecorder();
-        AccessToken openToken = AccessToken.createFromString("A token of thanks", new ArrayList<String>());
+
+        session.addAuthorizeResult("A token of thanks", new ArrayList<String>(), AccessTokenSource.TEST_USER);
+        session.addCallback(statusRecorder);
 
         // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
+        Assert.assertEquals(SessionState.CREATED, session.getState());
 
-        final LoginButton button = new LoginButton(getActivity());
-        button.setSession(session);
-        session.addAuthorizeResult(openToken);
-        session.addCallback(statusRecorder);
+        // Add another status recorder to ensure that the callback we hand to LoginButton
+        // also gets called as expected. We expect to get the same order of calls as statusRecorder does.
+        final SessionStatusCallbackRecorder loginButtonStatusRecorder = new SessionStatusCallbackRecorder();
 
-        button.performClick();
+        // Create the button. To get session status updates, we need to actually attach the
+        // button to a window, which must be done on the UI thread.
+        final LoginButton button = new LoginButton(getActivity());
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                getActivity().setContentView(button);
+                button.setSession(session);
+                button.setSessionStatusCallback(loginButtonStatusRecorder);
+                button.performClick();
+            }
+        });
 
         statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        loginButtonStatusRecorder.waitForCall(session, SessionState.OPENING, null);
+
         statusRecorder.waitForCall(session, SessionState.OPENED, null);
+        loginButtonStatusRecorder.waitForCall(session, SessionState.OPENED, null);
 
         // Verify token information is cleared.
         session.closeAndClearTokenInformation();
         assertTrue(cache.getSavedState() == null);
         statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+        loginButtonStatusRecorder.waitForCall(session, SessionState.CLOSED, null);
 
         // Wait a bit so we can fail if any unexpected calls arrive on the
         // recorder.
@@ -50,7 +85,7 @@ public void testLoginButton() {
     @MediumTest
     @LargeTest
     public void testLoginFail() {
-        SessionTestsBase.MockTokenCache cache = new SessionTestsBase.MockTokenCache(null, 0);
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
         ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
         final Exception openException = new Exception("Open failed!");
         final AtomicBoolean clicked = new AtomicBoolean(false);
@@ -93,10 +128,9 @@ public void onError(FacebookException exception) {
     @MediumTest
     @LargeTest
     public void testCanAddReadPermissions() {
-        SessionTestsBase.MockTokenCache cache = new SessionTestsBase.MockTokenCache(null, 0);
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
         ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
         SessionTestsBase.SessionStatusCallbackRecorder statusRecorder = new SessionTestsBase.SessionStatusCallbackRecorder();
-        AccessToken openToken = AccessToken.createFromString("A token of thanks", new ArrayList<String>());
 
         // Verify state with no token in cache
         assertEquals(SessionState.CREATED, session.getState());
@@ -104,7 +138,7 @@ public void testCanAddReadPermissions() {
         final LoginButton button = new LoginButton(getActivity());
         button.setSession(session);
         button.setReadPermissions(Arrays.asList(new String[] {"read_permission", "read_another"}));
-        session.addAuthorizeResult(openToken);
+        session.addAuthorizeResult("A token of thanks", new ArrayList<String>(), AccessTokenSource.TEST_USER);
         session.addCallback(statusRecorder);
 
         button.performClick();
@@ -127,11 +161,10 @@ public void testCanAddReadPermissions() {
     @MediumTest
     @LargeTest
     public void testCanAddPublishPermissions() {
-        SessionTestsBase.MockTokenCache cache = new SessionTestsBase.MockTokenCache(null, 0);
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
         ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
         SessionTestsBase.SessionStatusCallbackRecorder statusRecorder =
                 new SessionTestsBase.SessionStatusCallbackRecorder();
-        AccessToken openToken = AccessToken.createFromString("A token of thanks", new ArrayList<String>());
 
         // Verify state with no token in cache
         assertEquals(SessionState.CREATED, session.getState());
@@ -139,7 +172,7 @@ public void testCanAddPublishPermissions() {
         final LoginButton button = new LoginButton(getActivity());
         button.setSession(session);
         button.setPublishPermissions(Arrays.asList(new String[] {"publish_permission", "publish_another"}));
-        session.addAuthorizeResult(openToken);
+        session.addAuthorizeResult("A token of thanks", new ArrayList<String>(), AccessTokenSource.TEST_USER);
         session.addCallback(statusRecorder);
 
         button.performClick();
@@ -200,18 +233,18 @@ public void testCanAddReadThenPublishPermissionsWithClear() {
     @MediumTest
     @LargeTest
     public void testCantAddMorePermissionsToOpenSession() {
-        SessionTestsBase.MockTokenCache cache = new SessionTestsBase.MockTokenCache(null, 0);
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
         ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
         SessionTestsBase.SessionStatusCallbackRecorder statusRecorder =
                 new SessionTestsBase.SessionStatusCallbackRecorder();
-        AccessToken openToken = AccessToken.createFromString("A token of thanks",
-                Arrays.asList(new String[] {"read_permission", "read_another"}));
 
         // Verify state with no token in cache
         assertEquals(SessionState.CREATED, session.getState());
 
         final LoginButton button = new LoginButton(getActivity());
-        button.setSession(session);        session.addAuthorizeResult(openToken);
+        button.setSession(session);
+        session.addAuthorizeResult("A token of thanks",
+                Arrays.asList(new String[] {"read_permission", "read_another"}), AccessTokenSource.TEST_USER);
         session.addCallback(statusRecorder);
 
         button.performClick();
@@ -239,4 +272,42 @@ public void testCantAddMorePermissionsToOpenSession() {
         statusRecorder.close();
     }
 
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanSetDefaultAudience() {
+        SessionTestsBase.MockTokenCachingStrategy cache = new SessionTestsBase.MockTokenCachingStrategy(null, 0);
+        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
+        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder =
+                new SessionTestsBase.SessionStatusCallbackRecorder();
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        final LoginButton button = new LoginButton(getActivity());
+        button.setSession(session);
+        button.setPublishPermissions(Arrays.asList(new String[] {"publish_permission", "publish_another"}));
+        button.setDefaultAudience(SessionDefaultAudience.FRIENDS);
+        session.addAuthorizeResult("A token of thanks", new ArrayList<String>(), AccessTokenSource.TEST_USER);
+        session.addCallback(statusRecorder);
+
+        button.performClick();
+
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        assertNotNull(session.getLastRequest());
+        assertEquals(SessionDefaultAudience.FRIENDS, session.getLastRequestAudience());
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
 }
diff --git a/facebook/tests/src/com/facebook/PlacePickerFragmentTests.java b/facebook/tests/src/com/facebook/widget/PlacePickerFragmentTests.java
similarity index 96%
rename from facebook/tests/src/com/facebook/PlacePickerFragmentTests.java
rename to facebook/tests/src/com/facebook/widget/PlacePickerFragmentTests.java
index 160bcc59c..50655185f 100644
--- a/facebook/tests/src/com/facebook/PlacePickerFragmentTests.java
+++ b/facebook/tests/src/com/facebook/widget/PlacePickerFragmentTests.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package com.facebook.widget;
 
 import android.location.Location;
 import android.os.Bundle;
@@ -23,6 +23,7 @@
 import android.test.suitebuilder.annotation.MediumTest;
 import android.view.View;
 import android.widget.ListView;
+import com.facebook.*;
 import com.facebook.sdk.tests.R;
 
 import java.util.Collection;
@@ -133,13 +134,13 @@ public void run() {
 
                 fragment.setOnDataChangedListener(new PickerFragment.OnDataChangedListener() {
                     @Override
-                    public void onDataChanged() {
+                    public void onDataChanged(PickerFragment<?> fragment) {
                         blocker.signal();
                     }
                 });
                 fragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
                     @Override
-                    public void onError(FacebookException error) {
+                    public void onError(PickerFragment<?> fragment, FacebookException error) {
                         fail("Got unexpected error: " + error.toString());
                     }
                 });
@@ -202,13 +203,13 @@ public void run() {
 
                 fragment.setOnDataChangedListener(new PickerFragment.OnDataChangedListener() {
                     @Override
-                    public void onDataChanged() {
+                    public void onDataChanged(PickerFragment<?> fragment) {
                         blocker1.signal();
                     }
                 });
                 fragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
                     @Override
-                    public void onError(FacebookException error) {
+                    public void onError(PickerFragment<?> fragment, FacebookException error) {
                         fail("Got unexpected error: " + error.getMessage());
                     }
                 });
diff --git a/facebook/tests/src/com/facebook/widget/UserSettingsFragmentTests.java b/facebook/tests/src/com/facebook/widget/UserSettingsFragmentTests.java
new file mode 100644
index 000000000..d13215bd0
--- /dev/null
+++ b/facebook/tests/src/com/facebook/widget/UserSettingsFragmentTests.java
@@ -0,0 +1,65 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.os.Bundle;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import com.facebook.SessionDefaultAudience;
+import com.facebook.SessionLoginBehavior;
+
+import java.util.Arrays;
+import java.util.List;
+
+public class UserSettingsFragmentTests extends FragmentTestCase<UserSettingsFragmentTests.TestActivity> {
+
+    public UserSettingsFragmentTests() {
+        super(TestActivity.class);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCanSetParametersViaLayout() throws Throwable {
+        TestActivity activity = getActivity();
+        assertNotNull(activity);
+
+        final UserSettingsFragment fragment = activity.getFragment();
+        assertNotNull(fragment);
+
+        assertEquals(SessionLoginBehavior.SUPPRESS_SSO, fragment.getLoginBehavior());
+        assertEquals(SessionDefaultAudience.EVERYONE, fragment.getDefaultAudience());
+        List<String> permissions = fragment.getPermissions();
+        assertEquals(2, permissions.size());
+        assertEquals("read_1", permissions.get(0));
+    }
+
+    public static class TestActivity extends FragmentTestCase.TestFragmentActivity<UserSettingsFragment> {
+        public TestActivity() {
+            super(UserSettingsFragment.class);
+        }
+
+        @Override
+        public void onCreate(Bundle savedInstanceState) {
+            super.onCreate(savedInstanceState);
+            getSupportFragmentManager().executePendingTransactions();
+            UserSettingsFragment fragment = getFragment();
+            fragment.setLoginBehavior(SessionLoginBehavior.SUPPRESS_SSO);
+            fragment.setReadPermissions(Arrays.asList("read_1", "read_2"));
+            fragment.setDefaultAudience(SessionDefaultAudience.EVERYONE);
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/PrioritizedWorkQueueTests.java b/facebook/tests/src/com/facebook/widget/WorkQueueTests.java
similarity index 73%
rename from facebook/tests/src/com/facebook/PrioritizedWorkQueueTests.java
rename to facebook/tests/src/com/facebook/widget/WorkQueueTests.java
index f39149082..0b377d57c 100644
--- a/facebook/tests/src/com/facebook/PrioritizedWorkQueueTests.java
+++ b/facebook/tests/src/com/facebook/widget/WorkQueueTests.java
@@ -1,20 +1,38 @@
-package com.facebook;
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
 
 import android.test.suitebuilder.annotation.LargeTest;
 import android.test.suitebuilder.annotation.MediumTest;
 import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.FacebookTestCase;
+import com.facebook.widget.WorkQueue;
 
-import java.security.SecureRandom;
 import java.util.ArrayList;
 import java.util.concurrent.Executor;
+import java.security.SecureRandom;
 
-public class PrioritizedWorkQueueTests extends FacebookTestCase {
+public class WorkQueueTests extends FacebookTestCase {
 
     @SmallTest
     @MediumTest
     @LargeTest
     public void testEmptyValidate() {
-        PrioritizedWorkQueue manager = new PrioritizedWorkQueue();
+        WorkQueue manager = new WorkQueue();
         manager.validate();
     }
 
@@ -28,7 +46,7 @@ public void testRunSomething() {
         ScriptableExecutor executor = new ScriptableExecutor();
         assertEquals(0, executor.getPendingCount());
 
-        PrioritizedWorkQueue manager = new PrioritizedWorkQueue(1, executor);
+        WorkQueue manager = new WorkQueue(1, executor);
 
         addActiveWorkItem(manager, run);
         assertEquals(1, executor.getPendingCount());
@@ -47,7 +65,7 @@ public void testRunSequence() {
 
         CountingRunnable run = new CountingRunnable();
         ScriptableExecutor executor = new ScriptableExecutor();
-        PrioritizedWorkQueue manager = new PrioritizedWorkQueue(1, executor);
+        WorkQueue manager = new WorkQueue(1, executor);
 
         for (int i = 0; i < workTotal; i++) {
             addActiveWorkItem(manager, run);
@@ -71,7 +89,7 @@ public void testRunParallel() {
 
         CountingRunnable run = new CountingRunnable();
         ScriptableExecutor executor = new ScriptableExecutor();
-        PrioritizedWorkQueue manager = new PrioritizedWorkQueue(workTotal, executor);
+        WorkQueue manager = new WorkQueue(workTotal, executor);
 
         for (int i = 0; i < workTotal; i++) {
             assertEquals(i, executor.getPendingCount());
@@ -93,10 +111,10 @@ public void testRunParallel() {
     public void testSimpleCancel() {
         CountingRunnable run = new CountingRunnable();
         ScriptableExecutor executor = new ScriptableExecutor();
-        PrioritizedWorkQueue manager = new PrioritizedWorkQueue(1, executor);
+        WorkQueue manager = new WorkQueue(1, executor);
 
         addActiveWorkItem(manager, run);
-        PrioritizedWorkQueue.WorkItem work1 = addActiveWorkItem(manager, run);
+        WorkQueue.WorkItem work1 = addActiveWorkItem(manager, run);
         cancelWork(manager, work1);
 
         assertEquals(1, executor.getPendingCount());
@@ -107,16 +125,16 @@ public void testSimpleCancel() {
     @SmallTest
     @MediumTest
     @LargeTest
-    public void testPriority() {
+    public void testMoveToFront() {
         final int firstCount = 8;
         final int highCount = 17;
 
-        ArrayList<PrioritizedWorkQueue.WorkItem> highWorkItems = new ArrayList<PrioritizedWorkQueue.WorkItem>();
+        ArrayList<WorkQueue.WorkItem> highWorkItems = new ArrayList<WorkQueue.WorkItem>();
         CountingRunnable highRun = new CountingRunnable();
         CountingRunnable firstRun = new CountingRunnable();
         CountingRunnable lowRun = new CountingRunnable();
         ScriptableExecutor executor = new ScriptableExecutor();
-        PrioritizedWorkQueue manager = new PrioritizedWorkQueue(firstCount, executor);
+        WorkQueue manager = new WorkQueue(firstCount, executor);
 
         for (int i = 0; i < firstCount; i++) {
             addActiveWorkItem(manager, firstRun);
@@ -132,10 +150,8 @@ public void testPriority() {
         }
 
         assertEquals(firstCount, executor.getPendingCount());
-        backgroundAll(manager);
-        for (PrioritizedWorkQueue.WorkItem highItem : highWorkItems) {
-            int priority = setPriority(manager, highItem, PrioritizedWorkQueue.PRIORITY_ACTIVE);
-            assertEquals(priority, PrioritizedWorkQueue.PRIORITY_ACTIVE);
+        for (WorkQueue.WorkItem highItem : highWorkItems) {
+            prioritizeWork(manager, highItem);
         }
 
         for (int i = 0; i < firstCount; i++) {
@@ -162,7 +178,7 @@ public void testPriority() {
 
     @LargeTest
     public void testThreadStress() {
-        PrioritizedWorkQueue manager = new PrioritizedWorkQueue();
+        WorkQueue manager = new WorkQueue();
         ArrayList<StressRunnable> runnables = new ArrayList<StressRunnable>();
         final int threadCount = 20;
 
@@ -179,64 +195,56 @@ public void testThreadStress() {
         }
     }
 
-    private PrioritizedWorkQueue.WorkItem addActiveWorkItem(PrioritizedWorkQueue manager, Runnable runnable) {
+    private WorkQueue.WorkItem addActiveWorkItem(WorkQueue manager, Runnable runnable) {
         manager.validate();
-        PrioritizedWorkQueue.WorkItem workItem = manager.addActiveWorkItem(runnable);
+        WorkQueue.WorkItem workItem = manager.addActiveWorkItem(runnable);
         manager.validate();
         return workItem;
     }
 
-    private void executeNext(PrioritizedWorkQueue manager, ScriptableExecutor executor) {
+    private void executeNext(WorkQueue manager, ScriptableExecutor executor) {
         manager.validate();
         executor.runNext();
         manager.validate();
     }
 
-    private void cancelWork(PrioritizedWorkQueue manager, PrioritizedWorkQueue.WorkItem workItem) {
+    private void cancelWork(WorkQueue manager, WorkQueue.WorkItem workItem) {
         manager.validate();
         workItem.cancel();
         manager.validate();
     }
 
-    private int setPriority(PrioritizedWorkQueue manager, PrioritizedWorkQueue.WorkItem workItem, int priority) {
-        manager.validate();
-        workItem.setPriority(priority);
-        manager.validate();
-        return workItem.getPriority();
-    }
-
-    private void backgroundAll(PrioritizedWorkQueue manager) {
+    private void prioritizeWork(WorkQueue manager, WorkQueue.WorkItem workItem) {
         manager.validate();
-        manager.backgroundAll();
+        workItem.moveToFront();
         manager.validate();
     }
 
     static class StressRunnable implements Runnable {
-        static ArrayList<PrioritizedWorkQueue.WorkItem> tracked = new ArrayList<PrioritizedWorkQueue.WorkItem>();
+        static ArrayList<WorkQueue.WorkItem> tracked = new ArrayList<WorkQueue.WorkItem>();
 
-        final PrioritizedWorkQueue manager;
+        final WorkQueue manager;
         final SecureRandom random = new SecureRandom();
         final int iterationCount;
         int iterationIndex = 0;
         boolean isDone = false;
 
-        StressRunnable(PrioritizedWorkQueue manager, int iterationCount) {
+        StressRunnable(WorkQueue manager, int iterationCount) {
             this.manager = manager;
             this.iterationCount = iterationCount;
         }
 
         @Override
         public void run() {
-            // Each iteration runs a random action against the PrioritizedWorkQueue.
+            // Each iteration runs a random action against the WorkQueue.
             if (iterationIndex++ < iterationCount) {
                 final int sleepWeight = 80;
-                final int backgroundWeight = 10;
-                final int trackThisWeight = 3;
-                final int prioritizeTrackedWeight = 3;
+                final int trackThisWeight = 10;
+                final int prioritizeTrackedWeight = 6;
                 final int validateWeight = 2;
                 int weight = 0;
-                final int n = random.nextInt(sleepWeight + backgroundWeight + trackThisWeight + prioritizeTrackedWeight + validateWeight);
-                PrioritizedWorkQueue.WorkItem workItem = manager.addActiveWorkItem(this);
+                final int n = random.nextInt(sleepWeight + trackThisWeight + prioritizeTrackedWeight + validateWeight);
+                WorkQueue.WorkItem workItem = manager.addActiveWorkItem(this);
 
                 if (n < (weight += sleepWeight)) {
                     // Sleep
@@ -244,9 +252,6 @@ public void run() {
                         Thread.sleep(n/4);
                     } catch (InterruptedException e) {
                     }
-                } else if (n < (weight += backgroundWeight)) {
-                    // Move this work item to be background
-                    workItem.setPriority(PrioritizedWorkQueue.PRIORITY_BACKGROUND);
                 } else if (n < (weight += trackThisWeight)) {
                     // Track this work item to activate later
                     synchronized (tracked) {
@@ -254,16 +259,15 @@ public void run() {
                     }
                 } else if (n < (weight += prioritizeTrackedWeight)) {
                     // Background all pending items, prioritize tracked items, and clear tracked list
-                    ArrayList<PrioritizedWorkQueue.WorkItem> items = new ArrayList<PrioritizedWorkQueue.WorkItem>();
+                    ArrayList<WorkQueue.WorkItem> items = new ArrayList<WorkQueue.WorkItem>();
 
                     synchronized (tracked) {
                         items.addAll(tracked);
                         tracked.clear();
                     }
 
-                    manager.backgroundAll();
-                    for (PrioritizedWorkQueue.WorkItem item : items) {
-                        item.setPriority(PrioritizedWorkQueue.PRIORITY_ACTIVE);
+                    for (WorkQueue.WorkItem item : items) {
+                        item.moveToFront();
                     }
                 } else {
                     // Validate
diff --git a/samples/BooleanOGSample/AndroidManifest.xml b/samples/BooleanOGSample/AndroidManifest.xml
index b0fd4c751..d2ac13fc1 100644
--- a/samples/BooleanOGSample/AndroidManifest.xml
+++ b/samples/BooleanOGSample/AndroidManifest.xml
@@ -14,6 +14,7 @@
             </intent-filter>
         </activity>
         <activity android:name="com.facebook.LoginActivity"
+                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
                   android:label="@string/app_name" />
         <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
     </application>
diff --git a/samples/BooleanOGSample/BooleanOGSample.iml b/samples/BooleanOGSample/BooleanOGSample.iml
index ea4761ccc..fa41c247b 100644
--- a/samples/BooleanOGSample/BooleanOGSample.iml
+++ b/samples/BooleanOGSample/BooleanOGSample.iml
@@ -27,6 +27,7 @@
           <path>/res-overlay</path>
         </resOverlayFolders>
         <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
         <additionalNativeLibs />
       </configuration>
     </facet>
diff --git a/samples/BooleanOGSample/ant.properties b/samples/BooleanOGSample/ant.properties
index b0971e891..939105d52 100644
--- a/samples/BooleanOGSample/ant.properties
+++ b/samples/BooleanOGSample/ant.properties
@@ -15,3 +15,4 @@
 #  'key.alias' for the name of the key to use.
 # The password will be asked during the build when you use the 'release' target.
 
+java.compilerargs=-Xlint -Werror
diff --git a/samples/BooleanOGSample/res/layout/content_group.xml b/samples/BooleanOGSample/res/layout/content_group.xml
index 0a7a35b52..151c17e41 100644
--- a/samples/BooleanOGSample/res/layout/content_group.xml
+++ b/samples/BooleanOGSample/res/layout/content_group.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
               android:id="@+id/content_group"
diff --git a/samples/BooleanOGSample/res/layout/friend_activity_row.xml b/samples/BooleanOGSample/res/layout/friend_activity_row.xml
index c5b1ba3a0..895cc334e 100644
--- a/samples/BooleanOGSample/res/layout/friend_activity_row.xml
+++ b/samples/BooleanOGSample/res/layout/friend_activity_row.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
               android:layout_width="fill_parent"
diff --git a/samples/BooleanOGSample/res/layout/friends_group.xml b/samples/BooleanOGSample/res/layout/friends_group.xml
index 4b2297351..ba7276d5c 100644
--- a/samples/BooleanOGSample/res/layout/friends_group.xml
+++ b/samples/BooleanOGSample/res/layout/friends_group.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
               android:id="@+id/friends_group"
diff --git a/samples/BooleanOGSample/res/layout/logic_group.xml b/samples/BooleanOGSample/res/layout/logic_group.xml
index a09978051..27449519a 100644
--- a/samples/BooleanOGSample/res/layout/logic_group.xml
+++ b/samples/BooleanOGSample/res/layout/logic_group.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
               android:id="@+id/logic_group"
diff --git a/samples/BooleanOGSample/res/layout/main.xml b/samples/BooleanOGSample/res/layout/main.xml
index 4bf4833c5..7ca777d60 100644
--- a/samples/BooleanOGSample/res/layout/main.xml
+++ b/samples/BooleanOGSample/res/layout/main.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
               android:orientation="vertical"
               android:layout_width="fill_parent"
diff --git a/samples/BooleanOGSample/res/layout/settings_group.xml b/samples/BooleanOGSample/res/layout/settings_group.xml
index 1fe895539..5cee0a29a 100644
--- a/samples/BooleanOGSample/res/layout/settings_group.xml
+++ b/samples/BooleanOGSample/res/layout/settings_group.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
               android:id="@+id/settings_group"
diff --git a/samples/BooleanOGSample/res/values/strings.xml b/samples/BooleanOGSample/res/values/strings.xml
index cf40380ba..2aef901c1 100644
--- a/samples/BooleanOGSample/res/values/strings.xml
+++ b/samples/BooleanOGSample/res/values/strings.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <string name="app_name">BooleanOGSample</string>
     <string name="app_id">369258453126794</string>
@@ -14,9 +30,19 @@
     <string name="friends_using_rock_the_logic">Friends using Rock the Logic!</string>
     <string name="friend_activity">Friend activity</string>
     <string name="foo">You Rock!</string>
-
+    <string name="feature_requires_login_title">Social Features Disabled</string>
+    <string name="feature_requires_login_message">
+        There is no open session with Facebook.
+        Use the Settings tab to log in and use the social features of this application.
+    </string>
+    <string name="error_dialog_title">Error</string>
+    <string name="ok_button">OK</string>
     <string-array name="truth_values">
         <item>@string/true_value</item>
         <item>@string/false_value</item>
     </string-array>
+    <string name="native_link_already_logged_in">
+        You attempted to launch the app from the Facebook app, but are already logged in as a different
+        user. Please log out and try again.
+    </string>
 </resources>
diff --git a/samples/BooleanOGSample/src/com/facebook/samples/booleanog/LogicActivity.java b/samples/BooleanOGSample/src/com/facebook/samples/booleanog/LogicActivity.java
index 0184c7b75..bd8b6fbb6 100644
--- a/samples/BooleanOGSample/src/com/facebook/samples/booleanog/LogicActivity.java
+++ b/samples/BooleanOGSample/src/com/facebook/samples/booleanog/LogicActivity.java
@@ -1,25 +1,44 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.samples.booleanog;
 
 import android.app.AlertDialog;
-import android.content.BroadcastReceiver;
-import android.content.Context;
 import android.content.Intent;
-import android.content.IntentFilter;
 import android.database.MatrixCursor;
 import android.net.Uri;
 import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
 import android.support.v4.app.FragmentTransaction;
-import android.support.v4.content.LocalBroadcastManager;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.*;
 import com.facebook.*;
+import com.facebook.model.*;
+import com.facebook.widget.FriendPickerFragment;
+import com.facebook.widget.UserSettingsFragment;
+import com.facebook.widget.PickerFragment;
 
 import java.text.SimpleDateFormat;
 import java.util.*;
 
-public class LogicActivity extends FacebookActivity {
+public class LogicActivity extends FragmentActivity {
 
     private static final String TAG = "BooleanOpenGraphSample";
 
@@ -30,6 +49,7 @@
     private static final String SAVE_RESULT_TEXT = TAG + ".SAVE_RESULT_TEXT";
     private static final String SAVE_POST_RESULT_TEXT = TAG + ".SAVE_POST_RESULT_TEXT";
     private static final String SAVE_PENDING = TAG + ".SAVE_PENDING";
+    private static final String SAVE_FRIEND_ACTIONS = TAG + ".SAVE_FRIEND_ACTIONS";
     private static final String PENDING_POST_PATH = "PENDING_POST_PATH";
     private static final String PENDING_POST_LEFT = "PENDING_POST_LEFT";
     private static final String PENDING_POST_RIGHT = "PENDING_POST_RIGHT";
@@ -72,22 +92,37 @@
     private RequestAsyncTask pendingRequest;
     private SimpleCursorAdapter friendActivityAdapter;
     private ProgressBar friendActivityProgressBar;
+    private ArrayList<ActionRow> friendActionList;
 
     // Login group
     private ViewGroup settingsGroup;
-    private LoginFragment loginFragment;
+    private UserSettingsFragment userSettingsFragment;
 
     // Content group
     private ViewGroup contentGroup;
     private ImageView contentImage;
     private Spinner contentSpinner;
 
-    /**
-     * Called when the activity is first created.
-     */
+    private UiLifecycleHelper uiHelper;
+    private Session.StatusCallback callback = new Session.StatusCallback() {
+        @Override
+        public void call(Session session, SessionState state, Exception exception) {
+            if (exception != null) {
+                pendingPost = null;
+            } else if (state == SessionState.OPENED) {
+                friendPickerFragment.loadData(false);
+            } else if (state == SessionState.OPENED_TOKEN_UPDATED) {
+                sendPendingPost();
+            }
+        }
+    };
+
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
+        uiHelper = new UiLifecycleHelper(this, callback);
+        uiHelper.onCreate(savedInstanceState);
+
         setContentView(R.layout.main);
 
         // Views
@@ -131,10 +166,10 @@ public void onCreate(Bundle savedInstanceState) {
             transaction.add(R.id.friend_picker_fragment, friendPickerFragment);
         }
 
-        loginFragment = (LoginFragment) fragmentManager.findFragmentById(R.id.login_fragment);
-        if (loginFragment == null) {
-            loginFragment = new LoginFragment();
-            transaction.add(R.id.login_fragment, loginFragment);
+        userSettingsFragment = (UserSettingsFragment) fragmentManager.findFragmentById(R.id.login_fragment);
+        if (userSettingsFragment == null) {
+            userSettingsFragment = new UserSettingsFragment();
+            transaction.add(R.id.login_fragment, userSettingsFragment);
         }
 
         transaction.commit();
@@ -161,7 +196,7 @@ public void onCreate(Bundle savedInstanceState) {
         // Friends
         friendPickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
             @Override
-            public void onError(FacebookException error) {
+            public void onError(PickerFragment<?> fragment, FacebookException error) {
                 LogicActivity.this.onError(error);
             }
         });
@@ -169,7 +204,7 @@ public void onError(FacebookException error) {
         friendPickerFragment.setMultiSelect(false);
         friendPickerFragment.setOnSelectionChangedListener(new PickerFragment.OnSelectionChangedListener() {
             @Override
-            public void onSelectionChanged() {
+            public void onSelectionChanged(PickerFragment<?> fragment) {
                 LogicActivity.this.onFriendSelectionChanged();
             }
         });
@@ -205,7 +240,12 @@ public void onNothingSelected(AdapterView<?> adapterView) {
             resultText.setText(savedInstanceState.getString(SAVE_RESULT_TEXT));
             postResultText.setText(savedInstanceState.getString(SAVE_POST_RESULT_TEXT));
             activeTab = savedInstanceState.getString(SAVE_ACTIVE_TAB);
-            pendingPost = (Bundle) savedInstanceState.getBundle(SAVE_PENDING);
+            pendingPost = savedInstanceState.getBundle(SAVE_PENDING);
+
+            friendActionList = savedInstanceState.getParcelableArrayList(SAVE_FRIEND_ACTIONS);
+            if ((friendActionList != null) && (friendActionList.size() > 0)) {
+                updateCursor(friendActionList);
+            }
 
             if (getString(R.string.navigate_friends).equals(activeTab)) {
                 startButton = friendsButton;
@@ -216,45 +256,33 @@ public void onNothingSelected(AdapterView<?> adapterView) {
             }
         }
 
-        // Resolve deep-links, if any
-        Boolean deepLinkContent = getDeepLinkContent(getIntent().getData());
-        if (deepLinkContent != null) {
-            startButton = contentButton;
-            contentSpinner.setSelection(getSpinnerPosition(deepLinkContent));
+        if (!handleNativeLink()) {
+            onNavigateButtonClick(startButton);
         }
-
-        onNavigateButtonClick(startButton);
     }
 
     // -----------------------------------------------------------------------------------
     // Activity lifecycle
 
     @Override
-    protected void onStart() {
+    public void onStart() {
         super.onStart();
-        loadIfSessionValid();
-
-        BroadcastReceiver receiver = new BroadcastReceiver() {
-            @Override
-            public void onReceive(Context context, Intent intent) {
-                loadIfSessionValid();
-            }
-        };
-
-        IntentFilter openedFilter = new IntentFilter(Session.ACTION_ACTIVE_SESSION_OPENED);
-        LocalBroadcastManager.getInstance(this).registerReceiver(receiver, openedFilter);
-    }
-
-    private void loadIfSessionValid() {
         Session session = Session.getActiveSession();
-        if ((session != null) && session.isOpened()) {
+        if (session != null && session.isOpened()) {
             friendPickerFragment.loadData(false);
         }
     }
 
+    @Override
+    public void onResume() {
+        super.onResume();
+        uiHelper.onResume();
+    }
+
     @Override
     protected void onSaveInstanceState(Bundle outState) {
         super.onSaveInstanceState(outState);
+        uiHelper.onSaveInstanceState(outState);
 
         outState.putInt(SAVE_LEFT_OPERAND_SELECTION, leftSpinner.getSelectedItemPosition());
         outState.putInt(SAVE_RIGHT_OPERAND_SELECTION, rightSpinner.getSelectedItemPosition());
@@ -263,11 +291,19 @@ protected void onSaveInstanceState(Bundle outState) {
         outState.putString(SAVE_POST_RESULT_TEXT, postResultText.getText().toString());
         outState.putString(SAVE_ACTIVE_TAB, activeTab);
         outState.putBundle(SAVE_PENDING, pendingPost);
+        outState.putParcelableArrayList(SAVE_FRIEND_ACTIONS, friendActionList);
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        uiHelper.onPause();
     }
 
     @Override
     public void onDestroy() {
         super.onDestroy();
+        uiHelper.onDestroy();
 
         friendPickerFragment.setOnErrorListener(null);
         friendPickerFragment.setOnSelectionChangedListener(null);
@@ -275,17 +311,8 @@ public void onDestroy() {
 
     @Override
     public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        loginFragment.onActivityResult(requestCode, resultCode, data);
         super.onActivityResult(requestCode, resultCode, data);
-    }
-
-    @Override
-    protected void onSessionStateChange(SessionState state, Exception exception) {
-        if (exception != null) {
-            pendingPost = null;
-        } else if (state == SessionState.OPENED_TOKEN_UPDATED) {
-            sendPendingPost();
-        }
+        uiHelper.onActivityResult(requestCode, resultCode, data);
     }
 
     // -----------------------------------------------------------------------------------
@@ -307,6 +334,18 @@ private void onNavigateButtonClick(Button source) {
         friendsGroup.setVisibility(getGroupVisibility(source, friendsButton));
         settingsGroup.setVisibility(getGroupVisibility(source, settingsButton));
         contentGroup.setVisibility(getGroupVisibility(source, contentButton));
+
+        // Show an error if viewing friends and there is no logged in user.
+        if (source == friendsButton) {
+            Session session = Session.getActiveSession();
+            if ((session == null) || !session.isOpened()) {
+                new AlertDialog.Builder(this)
+                        .setTitle(R.string.feature_requires_login_title)
+                        .setMessage(R.string.feature_requires_login_message)
+                        .setPositiveButton(R.string.ok_button, null)
+                        .show();
+            }
+        }
     }
 
     private int getGroupVisibility(Button source, Button groupButton) {
@@ -393,8 +432,8 @@ private void sendPendingPost() {
 
         List<String> permissions = session.getPermissions();
         if (!permissions.containsAll(PERMISSIONS)) {
-            Session.ReauthorizeRequest reauthRequest = new Session.ReauthorizeRequest(this, PERMISSIONS);
-            session.reauthorizeForPublish(reauthRequest);
+            Session.NewPermissionsRequest newPermissionsRequest = new Session.NewPermissionsRequest(this, PERMISSIONS);
+            session.requestNewPublishPermissions(newPermissionsRequest);
             return;
         }
 
@@ -406,7 +445,7 @@ private void sendPendingPost() {
         boolean rightOperand = pendingPost.getBoolean(PENDING_POST_RIGHT);
         boolean result = pendingPost.getBoolean(PENDING_POST_RESULT);
 
-        LogicAction action = GraphObjectWrapper.createGraphObject(LogicAction.class);
+        LogicAction action = GraphObject.Factory.create(LogicAction.class);
         action.setResult(result);
         action.setTruthvalue(getTruthValueObject(leftOperand));
         action.setAnothertruthvalue(getTruthValueObject(rightOperand));
@@ -427,30 +466,10 @@ public void onCompleted(Response response) {
 
     private void onPostActionResponse(Response response) {
         PostResponse postResponse = response.getGraphObjectAs(PostResponse.class);
-
-        String id = null;
-        PostResponse.Body body = null;
-        if (postResponse != null) {
-            id = postResponse.getId();
-            body = postResponse.getBody();
-        }
-
-        PostResponse.Error error = null;
-        if (body != null) {
-            error = body.getError();
-        }
-
-        String errorMessage = null;
-        if (error != null) {
-            errorMessage = error.getMessage();
-        }
-
-        if (errorMessage != null) {
-            postResultText.setText(errorMessage);
+        if (postResponse != null && postResponse.getId() != null) {
+            postResultText.setText("Post id = " + postResponse.getId());
         } else if (response.getError() != null) {
-            postResultText.setText(response.getError().getLocalizedMessage());
-        } else if (id != null) {
-            postResultText.setText("Post id = " + id);
+            postResultText.setText(response.getError().getErrorMessage());
         } else {
             postResultText.setText("");
         }
@@ -459,14 +478,16 @@ private void onPostActionResponse(Response response) {
     private TruthValueGraphObject getTruthValueObject(boolean value) {
         if (value) {
             if (TRUE_GRAPH_OBJECT == null) {
-                TruthValueGraphObject object = GraphObjectWrapper.createGraphObject(TruthValueGraphObject.class);
+                TruthValueGraphObject object = GraphObject.Factory
+                        .create(TruthValueGraphObject.class);
                 object.setUrl(TRUE_GRAPH_OBJECT_URL);
                 TRUE_GRAPH_OBJECT = object;
             }
             return TRUE_GRAPH_OBJECT;
         } else {
             if (FALSE_GRAPH_OBJECT == null) {
-                TruthValueGraphObject object = GraphObjectWrapper.createGraphObject(TruthValueGraphObject.class);
+                TruthValueGraphObject object = GraphObject.Factory
+                        .create(TruthValueGraphObject.class);
                 object.setUrl(FALSE_GRAPH_OBJECT_URL);
                 FALSE_GRAPH_OBJECT = object;
             }
@@ -517,8 +538,8 @@ protected void onPostExecute(List<Response> result) {
     private void onPostExecute(List<Response> result) {
         friendActivityProgressBar.setVisibility(View.GONE);
 
-        ArrayList<ActionRow> publishedItems = createActionRows(result);
-        updateCursor(publishedItems);
+        friendActionList = createActionRows(result);
+        updateCursor(friendActionList);
     }
 
     private ArrayList<ActionRow> createActionRows(List<Response> result) {
@@ -627,6 +648,32 @@ private void onContentSelectionChanged() {
     // -----------------------------------------------------------------------------------
     // Utility methods
 
+    private boolean handleNativeLink() {
+        Session existingSession = Session.getActiveSession();
+        // If we have a valid existing session, we'll use it; if not, open one using the provided Intent
+        // but do not cache the token (we don't want to use the same user identity the next time the
+        // app is run).
+        if (existingSession == null || !existingSession.isOpened()) {
+            AccessToken accessToken = AccessToken.createFromNativeLinkingIntent(getIntent());
+            if (accessToken != null) {
+                Session newSession = new Session.Builder(this).setTokenCachingStrategy(new NonCachingTokenCachingStrategy())
+                        .build();
+                newSession.open(accessToken, null);
+
+                Session.setActiveSession(newSession);
+            }
+        }
+        // See if we have a deep link in addition.
+        Boolean deepLinkContent = getDeepLinkContent(getIntent().getData());
+        if (deepLinkContent != null) {
+            onNavigateButtonClick(contentButton);
+            contentSpinner.setSelection(getSpinnerPosition(deepLinkContent));
+            return true;
+        }
+
+        return false;
+    }
+
     private int getSpinnerPosition(Boolean value) {
         initializeSpinnerIndexes();
 
@@ -662,9 +709,15 @@ private void initializeSpinnerIndexes() {
     }
 
     private void onError(Exception error) {
-        AlertDialog.Builder builder = new AlertDialog.Builder(this);
-        builder.setTitle("Error").setMessage(error.getMessage()).setPositiveButton("OK", null);
-        builder.show();
+        showErrorMessage(error.getMessage());
+    }
+
+    private void showErrorMessage(String message) {
+        new AlertDialog.Builder(this)
+                .setTitle(R.string.error_dialog_title)
+                .setMessage(message)
+                .setPositiveButton(R.string.ok_button, null)
+                .show();
     }
 
     private <T> T chooseOne(List<T> ts) {
@@ -682,7 +735,7 @@ private void onError(Exception error) {
         Boolean getInstalled();
     }
 
-    private class ActionRow implements Comparable<ActionRow> {
+    private static class ActionRow implements Comparable<ActionRow>, Parcelable {
         final String actionText;
         final Date publishDate;
 
@@ -699,6 +752,32 @@ public int compareTo(ActionRow other) {
                 return publishDate.compareTo(other.publishDate);
             }
         }
+
+        @Override
+        public int describeContents() {
+            return 0;
+        }
+
+        @Override
+        public void writeToParcel(Parcel parcel, int flags) {
+            parcel.writeString(actionText);
+            parcel.writeLong(publishDate.getTime());
+        }
+
+        @SuppressWarnings("unused")
+        public final Creator<ActionRow> CREATOR = new Creator<ActionRow>() {
+            @Override
+            public ActionRow createFromParcel(Parcel parcel) {
+                String actionText = parcel.readString();
+                Date publishDate = new Date(parcel.readLong());
+                return new ActionRow(actionText, publishDate);
+            }
+
+            @Override
+            public ActionRow[] newArray(int size) {
+                return new ActionRow[size];
+            }
+        };
     }
 
     /**
@@ -740,16 +819,6 @@ public int compareTo(ActionRow other) {
      * Used to inspect the response from posting an action
      */
     private interface PostResponse extends GraphObject {
-        Body getBody();
-
         String getId();
-
-        interface Body extends GraphObject {
-            Error getError();
-        }
-
-        interface Error extends GraphObject {
-            String getMessage();
-        }
     }
 }
diff --git a/samples/FriendPickerSample/AndroidManifest.xml b/samples/FriendPickerSample/AndroidManifest.xml
index fe092c910..d8f1911cd 100644
--- a/samples/FriendPickerSample/AndroidManifest.xml
+++ b/samples/FriendPickerSample/AndroidManifest.xml
@@ -23,6 +23,7 @@
                   android:label="Pick Friends">
         </activity>
         <activity android:name="com.facebook.LoginActivity"
+                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
                   android:label="@string/app_name" />
         <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
     </application>
diff --git a/samples/FriendPickerSample/FriendPickerSample.iml b/samples/FriendPickerSample/FriendPickerSample.iml
index bca109a37..4aac86509 100644
--- a/samples/FriendPickerSample/FriendPickerSample.iml
+++ b/samples/FriendPickerSample/FriendPickerSample.iml
@@ -27,6 +27,7 @@
           <path>/res-overlay</path>
         </resOverlayFolders>
         <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
         <additionalNativeLibs />
       </configuration>
     </facet>
diff --git a/samples/FriendPickerSample/ant.properties b/samples/FriendPickerSample/ant.properties
index b0971e891..939105d52 100644
--- a/samples/FriendPickerSample/ant.properties
+++ b/samples/FriendPickerSample/ant.properties
@@ -15,3 +15,4 @@
 #  'key.alias' for the name of the key to use.
 # The password will be asked during the build when you use the 'release' target.
 
+java.compilerargs=-Xlint -Werror
diff --git a/samples/FriendPickerSample/res/layout/main.xml b/samples/FriendPickerSample/res/layout/main.xml
index 4de5bb4de..e767ff16f 100644
--- a/samples/FriendPickerSample/res/layout/main.xml
+++ b/samples/FriendPickerSample/res/layout/main.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
               android:orientation="vertical"
               android:layout_width="fill_parent"
diff --git a/samples/FriendPickerSample/res/layout/pick_friends_activity.xml b/samples/FriendPickerSample/res/layout/pick_friends_activity.xml
index 3110f96ce..3dbf01b9a 100644
--- a/samples/FriendPickerSample/res/layout/pick_friends_activity.xml
+++ b/samples/FriendPickerSample/res/layout/pick_friends_activity.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
               android:orientation="vertical"
               android:layout_width="fill_parent"
diff --git a/samples/FriendPickerSample/res/values/strings.xml b/samples/FriendPickerSample/res/values/strings.xml
index c22e4869c..ebe6e4bcf 100644
--- a/samples/FriendPickerSample/res/values/strings.xml
+++ b/samples/FriendPickerSample/res/values/strings.xml
@@ -1,5 +1,23 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <string name="app_name">FriendPickerSample</string>
     <string name="app_id">370546396320150</string>
+    <string name="error_dialog_title">Error</string>
+    <string name="ok_button">OK</string>
 </resources>
diff --git a/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerApplication.java b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerApplication.java
index 571005266..d72c593eb 100644
--- a/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerApplication.java
+++ b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerApplication.java
@@ -17,7 +17,7 @@
 package com.facebook.samples.friendpicker;
 
 import android.app.Application;
-import com.facebook.GraphUser;
+import com.facebook.model.GraphUser;
 
 import java.util.Collection;
 
diff --git a/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerSampleActivity.java b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerSampleActivity.java
index 38641b72c..42cdfc69e 100644
--- a/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerSampleActivity.java
+++ b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerSampleActivity.java
@@ -23,20 +23,18 @@
 import android.view.View;
 import android.widget.Button;
 import android.widget.TextView;
-import com.facebook.GraphUser;
+import com.facebook.model.GraphUser;
 import com.facebook.Session;
 
 import java.util.ArrayList;
 import java.util.Collection;
 
 public class FriendPickerSampleActivity extends FragmentActivity {
-    private final int PICK_FRIENDS_ACTIVITY = 1;
+    private static final int PICK_FRIENDS_ACTIVITY = 1;
     private Button pickFriendsButton;
     private TextView resultsTextView;
 
-    /**
-     * Called when the activity is first created.
-     */
+
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
@@ -50,29 +48,24 @@ public void onClick(View view) {
             }
         });
 
-        Session.openActiveSession(this, true);
+        if (Session.getActiveSession() == null ||
+                Session.getActiveSession().isClosed()) {
+            Session.openActiveSession(this, true, null);
+        }
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+
+        // Update the display every time we are started.
+        displaySelectedFriends(RESULT_OK);
     }
 
     public void onActivityResult(int requestCode, int resultCode, Intent data) {
         switch (requestCode) {
             case PICK_FRIENDS_ACTIVITY:
-                String results = "";
-                if (resultCode == RESULT_OK) {
-                    FriendPickerApplication application = (FriendPickerApplication)getApplication();
-                    Collection<GraphUser> selection = application.getSelectedUsers();
-                    if (selection != null && selection.size() > 0) {
-                        ArrayList<String> names = new ArrayList<String>();
-                        for (GraphUser user : selection) {
-                            names.add(user.getName());
-                        }
-                        results = TextUtils.join(", ", names);
-                    } else {
-                        results = "<No friends selected>";
-                    }
-                } else {
-                    results = "<Cancelled>";
-                }
-                resultsTextView.setText(results);
+                displaySelectedFriends(resultCode);
                 break;
             default:
                 Session.getActiveSession().onActivityResult(this, requestCode, resultCode, data);
@@ -80,7 +73,28 @@ public void onActivityResult(int requestCode, int resultCode, Intent data) {
         }
     }
 
+    private void displaySelectedFriends(int resultCode) {
+        String results = "";
+        FriendPickerApplication application = (FriendPickerApplication) getApplication();
+
+        Collection<GraphUser> selection = application.getSelectedUsers();
+        if (selection != null && selection.size() > 0) {
+            ArrayList<String> names = new ArrayList<String>();
+            for (GraphUser user : selection) {
+                names.add(user.getName());
+            }
+            results = TextUtils.join(", ", names);
+        } else {
+            results = "<No friends selected>";
+        }
+
+        resultsTextView.setText(results);
+    }
+
     private void onClickPickFriends() {
+        FriendPickerApplication application = (FriendPickerApplication) getApplication();
+        application.setSelectedUsers(null);
+
         Intent intent = new Intent(this, PickFriendsActivity.class);
         // Note: The following line is optional, as multi-select behavior is the default for
         // FriendPickerFragment. It is here to demonstrate how parameters could be passed to the
diff --git a/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/PickFriendsActivity.java b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/PickFriendsActivity.java
index a15c994b1..d7232f374 100644
--- a/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/PickFriendsActivity.java
+++ b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/PickFriendsActivity.java
@@ -22,8 +22,8 @@
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
 import com.facebook.FacebookException;
-import com.facebook.FriendPickerFragment;
-import com.facebook.PickerFragment;
+import com.facebook.widget.FriendPickerFragment;
+import com.facebook.widget.PickerFragment;
 
 // This class provides an example of an Activity that uses FriendPickerFragment to display a list of
 // the user's friends. It takes a programmatic approach to creating the FriendPickerFragment with the
@@ -65,14 +65,14 @@ public void onCreate(Bundle savedInstanceState) {
 
         friendPickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
             @Override
-            public void onError(FacebookException error) {
+            public void onError(PickerFragment<?> fragment, FacebookException error) {
                 PickFriendsActivity.this.onError(error);
             }
         });
 
         friendPickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
             @Override
-            public void onDoneButtonClicked() {
+            public void onDoneButtonClicked(PickerFragment<?> fragment) {
                 // We just store our selection in the Application for other activities to look at.
                 FriendPickerApplication application = (FriendPickerApplication) getApplication();
                 application.setSelectedUsers(friendPickerFragment.getSelection());
@@ -84,9 +84,11 @@ public void onDoneButtonClicked() {
     }
 
     private void onError(Exception error) {
-        AlertDialog.Builder builder = new AlertDialog.Builder(this);
-        builder.setTitle("Error").setMessage(error.getMessage()).setPositiveButton("OK", null);
-        builder.show();
+        new AlertDialog.Builder(this)
+                .setTitle(R.string.error_dialog_title)
+                .setMessage(error.getMessage())
+                .setPositiveButton(R.string.ok_button, null)
+                .show();
     }
 
     @Override
diff --git a/samples/JustRequestSample/.classpath b/samples/GraphApiSample/.classpath
similarity index 100%
rename from samples/JustRequestSample/.classpath
rename to samples/GraphApiSample/.classpath
diff --git a/samples/JustRequestSample/.project b/samples/GraphApiSample/.project
similarity index 96%
rename from samples/JustRequestSample/.project
rename to samples/GraphApiSample/.project
index 2091c030f..cb993bbc8 100644
--- a/samples/JustRequestSample/.project
+++ b/samples/GraphApiSample/.project
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <projectDescription>
-	<name>JustRequestSample</name>
+	<name>GraphApiSample</name>
 	<comment></comment>
 	<projects>
 	</projects>
diff --git a/samples/JustRequestSample/AndroidManifest.xml b/samples/GraphApiSample/AndroidManifest.xml
similarity index 83%
rename from samples/JustRequestSample/AndroidManifest.xml
rename to samples/GraphApiSample/AndroidManifest.xml
index 24ab1f221..3647ce9a0 100644
--- a/samples/JustRequestSample/AndroidManifest.xml
+++ b/samples/GraphApiSample/AndroidManifest.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.facebook.samples.justrequest"
+    package="com.facebook.samples.graphapi"
     android:versionCode="1"
     android:versionName="1.0" >
 
@@ -11,7 +11,7 @@
         android:icon="@drawable/icon"
         android:label="@string/app_name" >
         <activity
-            android:name=".JustRequestSampleActivity"
+            android:name=".GraphApiSampleActivity"
             android:label="@string/app_name"
             android:windowSoftInputMode="adjustResize">
             <intent-filter>
@@ -21,6 +21,7 @@
             </intent-filter>
         </activity>
         <activity android:name="com.facebook.LoginActivity"
+                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
                   android:label="@string/app_name" />
     </application>
 
diff --git a/samples/JustRequestSample/JustRequestSample.iml b/samples/GraphApiSample/GraphApiSample.iml
similarity index 97%
rename from samples/JustRequestSample/JustRequestSample.iml
rename to samples/GraphApiSample/GraphApiSample.iml
index f568c01e8..8de1db588 100644
--- a/samples/JustRequestSample/JustRequestSample.iml
+++ b/samples/GraphApiSample/GraphApiSample.iml
@@ -34,6 +34,7 @@
           <path>/res-overlay</path>
         </resOverlayFolders>
         <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
         <additionalNativeLibs />
       </configuration>
     </facet>
diff --git a/samples/JustRequestSample/ant.properties b/samples/GraphApiSample/ant.properties
similarity index 95%
rename from samples/JustRequestSample/ant.properties
rename to samples/GraphApiSample/ant.properties
index b0971e891..939105d52 100644
--- a/samples/JustRequestSample/ant.properties
+++ b/samples/GraphApiSample/ant.properties
@@ -15,3 +15,4 @@
 #  'key.alias' for the name of the key to use.
 # The password will be asked during the build when you use the 'release' target.
 
+java.compilerargs=-Xlint -Werror
diff --git a/samples/JustRequestSample/build.xml b/samples/GraphApiSample/build.xml
similarity index 98%
rename from samples/JustRequestSample/build.xml
rename to samples/GraphApiSample/build.xml
index 3428117f5..b2456a58c 100644
--- a/samples/JustRequestSample/build.xml
+++ b/samples/GraphApiSample/build.xml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<project name="JustRequestSample" default="help">
+<project name="GraphApiSample" default="help">
 
     <!-- The local.properties file is created and updated by the 'android' tool.
          It contains the path to the SDK. It should *NOT* be checked into
diff --git a/samples/JustRequestSample/proguard-project.txt b/samples/GraphApiSample/proguard-project.txt
similarity index 100%
rename from samples/JustRequestSample/proguard-project.txt
rename to samples/GraphApiSample/proguard-project.txt
diff --git a/samples/JustRequestSample/project.properties b/samples/GraphApiSample/project.properties
similarity index 100%
rename from samples/JustRequestSample/project.properties
rename to samples/GraphApiSample/project.properties
diff --git a/samples/JustRequestSample/res/drawable-hdpi/icon.png b/samples/GraphApiSample/res/drawable-hdpi/icon.png
similarity index 100%
rename from samples/JustRequestSample/res/drawable-hdpi/icon.png
rename to samples/GraphApiSample/res/drawable-hdpi/icon.png
diff --git a/samples/JustRequestSample/res/drawable-mdpi/icon.png b/samples/GraphApiSample/res/drawable-mdpi/icon.png
similarity index 100%
rename from samples/JustRequestSample/res/drawable-mdpi/icon.png
rename to samples/GraphApiSample/res/drawable-mdpi/icon.png
diff --git a/samples/JustRequestSample/res/drawable-xhdpi/icon.png b/samples/GraphApiSample/res/drawable-xhdpi/icon.png
similarity index 100%
rename from samples/JustRequestSample/res/drawable-xhdpi/icon.png
rename to samples/GraphApiSample/res/drawable-xhdpi/icon.png
diff --git a/samples/JustRequestSample/res/drawable/icon.png b/samples/GraphApiSample/res/drawable/icon.png
similarity index 100%
rename from samples/JustRequestSample/res/drawable/icon.png
rename to samples/GraphApiSample/res/drawable/icon.png
diff --git a/samples/JustRequestSample/res/layout/main.xml b/samples/GraphApiSample/res/layout/main.xml
similarity index 57%
rename from samples/JustRequestSample/res/layout/main.xml
rename to samples/GraphApiSample/res/layout/main.xml
index 4f7576e0a..3861aebbf 100644
--- a/samples/JustRequestSample/res/layout/main.xml
+++ b/samples/GraphApiSample/res/layout/main.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="fill_parent"
     android:layout_height="fill_parent"
@@ -25,4 +41,4 @@
         android:layout_height="match_parent"
         android:textAppearance="?android:attr/textAppearanceLarge" />
 
-</LinearLayout>
\ No newline at end of file
+</LinearLayout>
diff --git a/samples/GraphApiSample/res/values/strings.xml b/samples/GraphApiSample/res/values/strings.xml
new file mode 100644
index 000000000..f30f73b1f
--- /dev/null
+++ b/samples/GraphApiSample/res/values/strings.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<resources>
+
+    <string name="hello">Hello World, GraphApiSampleActivity!</string>
+    <string name="app_name">GraphApiSample</string>
+    <string name="request">Request</string>
+    <string name="instructions">Login to create a link to fetch account data</string>
+    <string name="logout">Log out</string>
+    <string name="login_failed_dialog_title">Login failed</string>
+    <string name="ok_button">OK</string>
+
+</resources>
diff --git a/samples/JustRequestSample/src/com/facebook/samples/justrequest/JustRequestSampleActivity.java b/samples/GraphApiSample/src/com/facebook/samples/graphapi/GraphApiSampleActivity.java
similarity index 53%
rename from samples/JustRequestSample/src/com/facebook/samples/justrequest/JustRequestSampleActivity.java
rename to samples/GraphApiSample/src/com/facebook/samples/graphapi/GraphApiSampleActivity.java
index 16cdd6188..b3b1c2f44 100644
--- a/samples/JustRequestSample/src/com/facebook/samples/justrequest/JustRequestSampleActivity.java
+++ b/samples/GraphApiSample/src/com/facebook/samples/graphapi/GraphApiSampleActivity.java
@@ -1,4 +1,20 @@
-package com.facebook.samples.justrequest;
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.graphapi;
 
 import android.app.Activity;
 import android.app.AlertDialog;
@@ -11,18 +27,21 @@
 import android.widget.TextView;
 import com.facebook.*;
 import com.facebook.Session.StatusCallback;
+import com.facebook.model.GraphObject;
 
 import java.util.ArrayList;
 import java.util.List;
 
-public class JustRequestSampleActivity extends Activity {
-    static final String applicationId = "327064487357152";
+public class GraphApiSampleActivity extends Activity {
+    static final String applicationId = "307234779396415";
+    static final String PENDING_REQUEST_BUNDLE_KEY = "com.facebook.samples.graphapi:PendingRequest";
+
     Button buttonRequest;
     EditText editRequests;
     TextView textViewResults;
     Session session;
+    boolean pendingRequest;
 
-    /** Called when the activity is first created. */
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
@@ -37,11 +56,29 @@ public void onClick(View view) {
         this.textViewResults = (TextView) findViewById(R.id.textViewResults);
 
         this.session = createSession();
-        Settings.addLoggingBehavior(LoggingBehaviors.INCLUDE_ACCESS_TOKENS);
+        Settings.addLoggingBehavior(LoggingBehavior.INCLUDE_ACCESS_TOKENS);
     }
 
     public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        this.session.onActivityResult(this, requestCode, resultCode, data);
+        if (this.session.onActivityResult(this, requestCode, resultCode, data) &&
+                pendingRequest &&
+                this.session.getState().isOpened()) {
+            sendRequests();
+        }
+    }
+
+    @Override
+    protected void onRestoreInstanceState(Bundle savedInstanceState) {
+        super.onRestoreInstanceState(savedInstanceState);
+
+        pendingRequest = savedInstanceState.getBoolean(PENDING_REQUEST_BUNDLE_KEY, pendingRequest);
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        outState.putBoolean(PENDING_REQUEST_BUNDLE_KEY, pendingRequest);
     }
 
     private void onClickRequest() {
@@ -50,18 +87,17 @@ private void onClickRequest() {
         } else {
             StatusCallback callback = new StatusCallback() {
                 public void call(Session session, SessionState state, Exception exception) {
-                    if (state.isOpened()) {
-                        sendRequests();
-                    } else if (exception != null) {
-                        AlertDialog alertDialog;
-                        alertDialog = new AlertDialog.Builder(JustRequestSampleActivity.this).create();
-                        alertDialog.setTitle("Login failed");
-                        alertDialog.setMessage(exception.getMessage());
-                        alertDialog.show();
-                        JustRequestSampleActivity.this.session = createSession();
+                    if (exception != null) {
+                        new AlertDialog.Builder(GraphApiSampleActivity.this)
+                                .setTitle(R.string.login_failed_dialog_title)
+                                .setMessage(exception.getMessage())
+                                .setPositiveButton(R.string.ok_button, null)
+                                .show();
+                        GraphApiSampleActivity.this.session = createSession();
                     }
                 }
             };
+            pendingRequest = true;
             this.session.openForRead(new Session.OpenRequest(this).setCallback(callback));
         }
     }
@@ -77,26 +113,32 @@ private void sendRequests() {
             requests.add(new Request(session, requestId, null, null, new Request.Callback() {
                 public void onCompleted(Response response) {
                     GraphObject graphObject = response.getGraphObject();
-                    FacebookException error = response.getError();
+                    FacebookRequestError error = response.getError();
                     String s = textViewResults.getText().toString();
                     if (graphObject != null) {
                         if (graphObject.getProperty("id") != null) {
                             s = s + String.format("%s: %s\n", graphObject.getProperty("id"), graphObject.getProperty(
                                     "name"));
                         } else {
-                            s = s + String.format("%s: <no such id>\n", requestId); 
+                            s = s + String.format("%s: <no such id>\n", requestId);
                         }
                     } else if (error != null) {
-                        s = s + String.format("Error: %s", error.getMessage());
+                        s = s + String.format("Error: %s", error.getErrorMessage());
                     }
                     textViewResults.setText(s);
                 }
             }));
         }
+        pendingRequest = false;
         Request.executeBatchAndWait(requests);
     }
 
     private Session createSession() {
-        return new Session.Builder(this).setApplicationId(applicationId).build();
+        Session activeSession = Session.getActiveSession();
+        if (activeSession == null || activeSession.getState().isClosed()) {
+            activeSession = new Session.Builder(this).setApplicationId(applicationId).build();
+            Session.setActiveSession(activeSession);
+        }
+        return activeSession;
     }
 }
diff --git a/samples/Hackbook/Hackbook.iml b/samples/Hackbook/Hackbook.iml
index c17db1f0a..b82318051 100644
--- a/samples/Hackbook/Hackbook.iml
+++ b/samples/Hackbook/Hackbook.iml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <module type="JAVA_MODULE" version="4">
-  <component name="EclipseModuleManager" forced_jdk="true">
+  <component name="EclipseModuleManager">
     <conelement value="com.android.ide.eclipse.adt.LIBRARIES" />
     <src_description expected_position="1">
       <src_folder value="file://$MODULE_DIR$/src" expected_position="0" />
@@ -34,16 +34,16 @@
           <path>/res-overlay</path>
         </resOverlayFolders>
         <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
         <additionalNativeLibs />
       </configuration>
     </facet>
   </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="false">
-    <output url="file://$MODULE_DIR$/bin/classes" />
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
     <exclude-output />
     <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
       <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
     </content>
     <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
diff --git a/samples/Hackbook/res/drawable/login_button.xml b/samples/Hackbook/res/drawable/login_button.xml
index 73dc6c3ab..fff9888c6 100644
--- a/samples/Hackbook/res/drawable/login_button.xml
+++ b/samples/Hackbook/res/drawable/login_button.xml
@@ -1,5 +1,21 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <selector xmlns:android="http://schemas.android.com/apk/res/android">
 	<item android:state_pressed="true" android:drawable="@drawable/login_down" />
 	<item android:drawable="@drawable/login" /> <!-- default -->
-</selector>
\ No newline at end of file
+</selector>
diff --git a/samples/Hackbook/res/drawable/logout_button.xml b/samples/Hackbook/res/drawable/logout_button.xml
index 58f57656b..0c0c42eb0 100644
--- a/samples/Hackbook/res/drawable/logout_button.xml
+++ b/samples/Hackbook/res/drawable/logout_button.xml
@@ -1,5 +1,21 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <selector xmlns:android="http://schemas.android.com/apk/res/android">
     <item android:state_pressed="true" android:drawable="@drawable/logout_down" />
     <item android:drawable="@drawable/logout" /> <!-- default -->
-</selector>
\ No newline at end of file
+</selector>
diff --git a/samples/Hackbook/res/layout-land/main.xml b/samples/Hackbook/res/layout-land/main.xml
index 2dc8e244a..a5431efb9 100644
--- a/samples/Hackbook/res/layout-land/main.xml
+++ b/samples/Hackbook/res/layout-land/main.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
diff --git a/samples/Hackbook/res/layout-port/main.xml b/samples/Hackbook/res/layout-port/main.xml
index 2dc8e244a..a5431efb9 100644
--- a/samples/Hackbook/res/layout-port/main.xml
+++ b/samples/Hackbook/res/layout-port/main.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
diff --git a/samples/Hackbook/res/layout/connection_item.xml b/samples/Hackbook/res/layout/connection_item.xml
index e556c0685..2e0942d06 100644
--- a/samples/Hackbook/res/layout/connection_item.xml
+++ b/samples/Hackbook/res/layout/connection_item.xml
@@ -1,3 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="fill_parent"
     android:layout_height="?android:attr/listPreferredItemHeight">
diff --git a/samples/Hackbook/res/layout/fields_connections_list.xml b/samples/Hackbook/res/layout/fields_connections_list.xml
index 06b48f89e..56a30b868 100644
--- a/samples/Hackbook/res/layout/fields_connections_list.xml
+++ b/samples/Hackbook/res/layout/fields_connections_list.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
diff --git a/samples/Hackbook/res/layout/fields_item.xml b/samples/Hackbook/res/layout/fields_item.xml
index c072d7bd2..0e6c6da11 100644
--- a/samples/Hackbook/res/layout/fields_item.xml
+++ b/samples/Hackbook/res/layout/fields_item.xml
@@ -1,3 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
diff --git a/samples/Hackbook/res/layout/fql_query.xml b/samples/Hackbook/res/layout/fql_query.xml
index ddda019b2..925cd85cd 100644
--- a/samples/Hackbook/res/layout/fql_query.xml
+++ b/samples/Hackbook/res/layout/fql_query.xml
@@ -1,3 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout
     android:layout_width="fill_parent"
     android:layout_height="fill_parent"
diff --git a/samples/Hackbook/res/layout/friend_item.xml b/samples/Hackbook/res/layout/friend_item.xml
index c1c6728ed..08f167dfe 100644
--- a/samples/Hackbook/res/layout/friend_item.xml
+++ b/samples/Hackbook/res/layout/friend_item.xml
@@ -1,3 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="fill_parent"
     android:padding="6dip"
diff --git a/samples/Hackbook/res/layout/friends_list.xml b/samples/Hackbook/res/layout/friends_list.xml
index 82e565181..c6bd45b2d 100644
--- a/samples/Hackbook/res/layout/friends_list.xml
+++ b/samples/Hackbook/res/layout/friends_list.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
diff --git a/samples/Hackbook/res/layout/graph_explorer.xml b/samples/Hackbook/res/layout/graph_explorer.xml
index a7ebee4fa..9269d45dc 100644
--- a/samples/Hackbook/res/layout/graph_explorer.xml
+++ b/samples/Hackbook/res/layout/graph_explorer.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
diff --git a/samples/Hackbook/res/layout/main_list_item.xml b/samples/Hackbook/res/layout/main_list_item.xml
index 2ac0fac97..eefb54494 100644
--- a/samples/Hackbook/res/layout/main_list_item.xml
+++ b/samples/Hackbook/res/layout/main_list_item.xml
@@ -1,3 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <TextView xmlns:android="http://schemas.android.com/apk/res/android"
     android:id="@+id/main_api_item"
     android:padding="10dip"
diff --git a/samples/Hackbook/res/layout/permission_item.xml b/samples/Hackbook/res/layout/permission_item.xml
index 57eb43a8b..8acabe5dd 100644
--- a/samples/Hackbook/res/layout/permission_item.xml
+++ b/samples/Hackbook/res/layout/permission_item.xml
@@ -1,3 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="fill_parent"
     android:layout_height="?android:attr/listPreferredItemHeight">
diff --git a/samples/Hackbook/res/layout/permissions_list.xml b/samples/Hackbook/res/layout/permissions_list.xml
index f5592c5ae..f8aafe41f 100644
--- a/samples/Hackbook/res/layout/permissions_list.xml
+++ b/samples/Hackbook/res/layout/permissions_list.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
diff --git a/samples/Hackbook/res/layout/place_item.xml b/samples/Hackbook/res/layout/place_item.xml
index cbc139e42..ff89942e1 100644
--- a/samples/Hackbook/res/layout/place_item.xml
+++ b/samples/Hackbook/res/layout/place_item.xml
@@ -1,3 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="fill_parent"
     android:padding="6dip"
diff --git a/samples/Hackbook/res/layout/places_list.xml b/samples/Hackbook/res/layout/places_list.xml
index f63bb2884..578774425 100644
--- a/samples/Hackbook/res/layout/places_list.xml
+++ b/samples/Hackbook/res/layout/places_list.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
diff --git a/samples/Hackbook/res/layout/splash.xml b/samples/Hackbook/res/layout/splash.xml
index 211860639..21f1e2dae 100644
--- a/samples/Hackbook/res/layout/splash.xml
+++ b/samples/Hackbook/res/layout/splash.xml
@@ -1,3 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <ImageView android:id="@+id/imageView1" xmlns:android="http://schemas.android.com/apk/res/android"
     android:src="@drawable/splash"
     android:scaleType="fitXY"
diff --git a/samples/Hackbook/res/layout/token_refresh.xml b/samples/Hackbook/res/layout/token_refresh.xml
index 811cd598a..d3b662e93 100644
--- a/samples/Hackbook/res/layout/token_refresh.xml
+++ b/samples/Hackbook/res/layout/token_refresh.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
diff --git a/samples/Hackbook/res/layout/update_post_response.xml b/samples/Hackbook/res/layout/update_post_response.xml
index 2a0bd90a6..34460d7d7 100644
--- a/samples/Hackbook/res/layout/update_post_response.xml
+++ b/samples/Hackbook/res/layout/update_post_response.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
diff --git a/samples/Hackbook/res/layout/upload_photo_response.xml b/samples/Hackbook/res/layout/upload_photo_response.xml
index 3b8bd7743..49af55d85 100644
--- a/samples/Hackbook/res/layout/upload_photo_response.xml
+++ b/samples/Hackbook/res/layout/upload_photo_response.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
diff --git a/samples/Hackbook/res/values/colors.xml b/samples/Hackbook/res/values/colors.xml
index cb999e5cc..095921db0 100644
--- a/samples/Hackbook/res/values/colors.xml
+++ b/samples/Hackbook/res/values/colors.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <color name="white">#ffffff</color>
     <color name="black">#000000</color>
@@ -7,4 +23,4 @@
     <color name="lite_blue">#4E78A0</color>
     <color name="blue">#0000FF</color>
     <color name="grey">#FF909090</color>
-</resources>
\ No newline at end of file
+</resources>
diff --git a/samples/Hackbook/res/values/strings.xml b/samples/Hackbook/res/values/strings.xml
index a2aeda13e..73d278723 100644
--- a/samples/Hackbook/res/values/strings.xml
+++ b/samples/Hackbook/res/values/strings.xml
@@ -1,7 +1,23 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <string name="app_name">Hackbook for Android</string>
-    <string name="app_desc">Checkout out Hackbook for Android to learn how you can make your android apps social using Facebook Platform.</string>
+    <string name="app_desc">Check out Hackbook for Android to learn how you can make your android apps social using Facebook Platform.</string>
     <string name="app_action">I am using the Hackbook for Android</string>
     <string name="request_message">Learn how to make your android apps social.</string>
     <string name="request">Request!</string>
diff --git a/samples/Hackbook/src/com/facebook/android/BaseDialogListener.java b/samples/Hackbook/src/com/facebook/android/BaseDialogListener.java
index dbd5b3360..62f039148 100644
--- a/samples/Hackbook/src/com/facebook/android/BaseDialogListener.java
+++ b/samples/Hackbook/src/com/facebook/android/BaseDialogListener.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android;
 
 import com.facebook.android.Facebook.DialogListener;
diff --git a/samples/Hackbook/src/com/facebook/android/BaseRequestListener.java b/samples/Hackbook/src/com/facebook/android/BaseRequestListener.java
index b19966cff..474470e41 100644
--- a/samples/Hackbook/src/com/facebook/android/BaseRequestListener.java
+++ b/samples/Hackbook/src/com/facebook/android/BaseRequestListener.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android;
 
 import android.util.Log;
@@ -11,6 +27,7 @@
  * Skeleton base class for RequestListeners, providing default error handling.
  * Applications should handle these error conditions.
  */
+@SuppressWarnings("deprecation")
 public abstract class BaseRequestListener implements RequestListener {
 
     @Override
diff --git a/samples/Hackbook/src/com/facebook/android/FQLQuery.java b/samples/Hackbook/src/com/facebook/android/FQLQuery.java
index abd038cad..33b469b87 100644
--- a/samples/Hackbook/src/com/facebook/android/FQLQuery.java
+++ b/samples/Hackbook/src/com/facebook/android/FQLQuery.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android;
 
 import android.app.Activity;
@@ -16,6 +32,7 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
+@SuppressWarnings("deprecation")
 public class FQLQuery extends Dialog {
 
     private EditText mFQLQuery;
diff --git a/samples/Hackbook/src/com/facebook/android/FieldsConnectionsDialog.java b/samples/Hackbook/src/com/facebook/android/FieldsConnectionsDialog.java
index 91d15f27e..ad6b44880 100644
--- a/samples/Hackbook/src/com/facebook/android/FieldsConnectionsDialog.java
+++ b/samples/Hackbook/src/com/facebook/android/FieldsConnectionsDialog.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android;
 
 import android.app.Dialog;
diff --git a/samples/Hackbook/src/com/facebook/android/FriendsGetProfilePics.java b/samples/Hackbook/src/com/facebook/android/FriendsGetProfilePics.java
index f29c1cfff..6e50a5191 100644
--- a/samples/Hackbook/src/com/facebook/android/FriendsGetProfilePics.java
+++ b/samples/Hackbook/src/com/facebook/android/FriendsGetProfilePics.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android;
 
 import android.graphics.Bitmap;
diff --git a/samples/Hackbook/src/com/facebook/android/FriendsList.java b/samples/Hackbook/src/com/facebook/android/FriendsList.java
index 57507b8f1..9ad8db031 100644
--- a/samples/Hackbook/src/com/facebook/android/FriendsList.java
+++ b/samples/Hackbook/src/com/facebook/android/FriendsList.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android;
 
 import android.app.Activity;
@@ -56,6 +72,7 @@ public void onCreate(Bundle savedInstanceState) {
      * wall.
      */
     @Override
+    @SuppressWarnings("deprecation")
     public void onItemClick(AdapterView<?> arg0, View v, int position, long arg3) {
         try {
             final long friendId;
diff --git a/samples/Hackbook/src/com/facebook/android/GraphExplorer.java b/samples/Hackbook/src/com/facebook/android/GraphExplorer.java
index 097b02006..0ca605f5e 100644
--- a/samples/Hackbook/src/com/facebook/android/GraphExplorer.java
+++ b/samples/Hackbook/src/com/facebook/android/GraphExplorer.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android;
 
 /*
@@ -26,6 +42,7 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+@SuppressWarnings("deprecation")
 public class GraphExplorer extends Activity {
     private Button mSubmitButton, mViewURLButton;
     private Button mGetPermissionsButton;
diff --git a/samples/Hackbook/src/com/facebook/android/Hackbook.java b/samples/Hackbook/src/com/facebook/android/Hackbook.java
index 0178eed6a..816a10aa7 100644
--- a/samples/Hackbook/src/com/facebook/android/Hackbook.java
+++ b/samples/Hackbook/src/com/facebook/android/Hackbook.java
@@ -1,5 +1,5 @@
-/*
- * Copyright 2004 - Present Facebook, Inc.
+/**
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -37,6 +37,7 @@
 
 import java.io.IOException;
 
+@SuppressWarnings("deprecation")
 public class Hackbook extends Activity implements OnItemClickListener {
 
     /*
@@ -502,7 +503,8 @@ public void onComplete(final String response, final Object state) {
             try {
                 jsonObject = new JSONObject(response);
 
-                final String picURL = jsonObject.getString("picture");
+                final String picURL = jsonObject.getJSONObject("picture")
+                        .getJSONObject("data").getString("url");
                 final String name = jsonObject.getString("name");
                 Utility.userUID = jsonObject.getString("id");
 
diff --git a/samples/Hackbook/src/com/facebook/android/IntentUriHandler.java b/samples/Hackbook/src/com/facebook/android/IntentUriHandler.java
index ac55c2136..6b1601108 100644
--- a/samples/Hackbook/src/com/facebook/android/IntentUriHandler.java
+++ b/samples/Hackbook/src/com/facebook/android/IntentUriHandler.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android;
 
 import android.app.Activity;
diff --git a/samples/Hackbook/src/com/facebook/android/LoginButton.java b/samples/Hackbook/src/com/facebook/android/LoginButton.java
index c1f984260..30189b88c 100644
--- a/samples/Hackbook/src/com/facebook/android/LoginButton.java
+++ b/samples/Hackbook/src/com/facebook/android/LoginButton.java
@@ -1,5 +1,5 @@
-/*
- * Copyright 2010 Facebook, Inc.
+/**
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -28,6 +28,7 @@
 import com.facebook.android.SessionEvents.AuthListener;
 import com.facebook.android.SessionEvents.LogoutListener;
 
+@SuppressWarnings("deprecation")
 public class LoginButton extends ImageButton {
 
     private Facebook mFb;
diff --git a/samples/Hackbook/src/com/facebook/android/PermissionsDialog.java b/samples/Hackbook/src/com/facebook/android/PermissionsDialog.java
index a7ad7a421..4e4d4dc3e 100644
--- a/samples/Hackbook/src/com/facebook/android/PermissionsDialog.java
+++ b/samples/Hackbook/src/com/facebook/android/PermissionsDialog.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android;
 
 import android.app.Activity;
@@ -16,6 +32,7 @@
 
 import java.util.Vector;
 
+@SuppressWarnings("deprecation")
 public class PermissionsDialog extends Dialog {
 
     private final static int TAB_HEIGHT = 50;
diff --git a/samples/Hackbook/src/com/facebook/android/Places.java b/samples/Hackbook/src/com/facebook/android/Places.java
index 01f040886..43dbca4bd 100644
--- a/samples/Hackbook/src/com/facebook/android/Places.java
+++ b/samples/Hackbook/src/com/facebook/android/Places.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android;
 
 import android.app.Activity;
@@ -23,6 +39,7 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
+@SuppressWarnings("deprecation")
 public class Places extends Activity implements OnItemClickListener {
     private Handler mHandler;
     private JSONObject location;
diff --git a/samples/Hackbook/src/com/facebook/android/SessionEvents.java b/samples/Hackbook/src/com/facebook/android/SessionEvents.java
index f32a11e07..55295f174 100644
--- a/samples/Hackbook/src/com/facebook/android/SessionEvents.java
+++ b/samples/Hackbook/src/com/facebook/android/SessionEvents.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2010 Facebook, Inc.
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
diff --git a/samples/Hackbook/src/com/facebook/android/SessionStore.java b/samples/Hackbook/src/com/facebook/android/SessionStore.java
index db2438b01..8e4dcda58 100644
--- a/samples/Hackbook/src/com/facebook/android/SessionStore.java
+++ b/samples/Hackbook/src/com/facebook/android/SessionStore.java
@@ -1,5 +1,5 @@
-/*
- * Copyright 2010 Facebook, Inc.
+/**
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,6 +20,7 @@
 import android.content.SharedPreferences;
 import android.content.SharedPreferences.Editor;
 
+@SuppressWarnings("deprecation")
 public class SessionStore {
 
     private static final String TOKEN = "access_token";
diff --git a/samples/Hackbook/src/com/facebook/android/SplashActivity.java b/samples/Hackbook/src/com/facebook/android/SplashActivity.java
index d1fc5be2d..7255c0fce 100644
--- a/samples/Hackbook/src/com/facebook/android/SplashActivity.java
+++ b/samples/Hackbook/src/com/facebook/android/SplashActivity.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android;
 
 import android.app.Activity;
diff --git a/samples/Hackbook/src/com/facebook/android/TokenRefreshDialog.java b/samples/Hackbook/src/com/facebook/android/TokenRefreshDialog.java
index e40d3df4a..5a46dec71 100644
--- a/samples/Hackbook/src/com/facebook/android/TokenRefreshDialog.java
+++ b/samples/Hackbook/src/com/facebook/android/TokenRefreshDialog.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android;
 
 import android.app.Activity;
@@ -12,6 +28,7 @@
 import java.text.DateFormat;
 import java.util.Date;
 
+@SuppressWarnings("deprecation")
 public class TokenRefreshDialog extends Dialog {
 
     private EditText tokenEdit, tokenExpiresEdit;
diff --git a/samples/Hackbook/src/com/facebook/android/UpdateStatusResultDialog.java b/samples/Hackbook/src/com/facebook/android/UpdateStatusResultDialog.java
index 3c6dc7f4c..1bb9e6137 100644
--- a/samples/Hackbook/src/com/facebook/android/UpdateStatusResultDialog.java
+++ b/samples/Hackbook/src/com/facebook/android/UpdateStatusResultDialog.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android;
 
 import android.app.Activity;
@@ -12,6 +28,7 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
+@SuppressWarnings("deprecation")
 public class UpdateStatusResultDialog extends Dialog {
 
     private Bundle values;
diff --git a/samples/Hackbook/src/com/facebook/android/UploadPhotoResultDialog.java b/samples/Hackbook/src/com/facebook/android/UploadPhotoResultDialog.java
index 6ae234552..7ec3c5e21 100644
--- a/samples/Hackbook/src/com/facebook/android/UploadPhotoResultDialog.java
+++ b/samples/Hackbook/src/com/facebook/android/UploadPhotoResultDialog.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android;
 
 import android.app.Activity;
@@ -17,6 +33,7 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
+@SuppressWarnings("deprecation")
 public class UploadPhotoResultDialog extends Dialog {
 
     private String response, photo_id;
diff --git a/samples/Hackbook/src/com/facebook/android/Utility.java b/samples/Hackbook/src/com/facebook/android/Utility.java
index 56eff55da..251a77419 100644
--- a/samples/Hackbook/src/com/facebook/android/Utility.java
+++ b/samples/Hackbook/src/com/facebook/android/Utility.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android;
 
 import android.app.Application;
@@ -19,6 +35,7 @@
 public class Utility extends Application {
 
     public static Facebook mFacebook;
+    @SuppressWarnings("deprecation")
     public static AsyncFacebookRunner mAsyncRunner;
     public static JSONObject mFriendsList;
     public static String userUID = null;
@@ -143,6 +160,9 @@ public static int getOrientation(Context context, Uri photoUri) {
         }
 
         cursor.moveToFirst();
-        return cursor.getInt(0);
+        int orientation = cursor.getInt(0);
+        cursor.close();
+
+        return orientation;
     }
 }
diff --git a/samples/HelloFacebookSample/AndroidManifest.xml b/samples/HelloFacebookSample/AndroidManifest.xml
index 884680908..246d0de24 100644
--- a/samples/HelloFacebookSample/AndroidManifest.xml
+++ b/samples/HelloFacebookSample/AndroidManifest.xml
@@ -9,7 +9,6 @@
     <application android:label="@string/app_name"
                  android:icon="@drawable/icon"
                  android:theme="@android:style/Theme.NoTitleBar"
-                 android:name=".HelloFacebookApplication"
             >
         <activity android:name=".HelloFacebookSampleActivity"
                   android:label="@string/app_name"
@@ -19,13 +18,9 @@
                 <category android:name="android.intent.category.LAUNCHER"/>
             </intent-filter>
         </activity>
-        <activity android:name="PickFriendsActivity"
-                  android:label="Pick Friends">
-        </activity>
-        <activity android:name="PickPlaceActivity"
-                  android:label="Pick Place">
-        </activity>
         <activity android:name="com.facebook.LoginActivity"
+                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
                   android:label="@string/app_name" />
+        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
     </application>
 </manifest>
diff --git a/samples/HelloFacebookSample/HelloFacebookSample.iml b/samples/HelloFacebookSample/HelloFacebookSample.iml
index bca109a37..4aac86509 100644
--- a/samples/HelloFacebookSample/HelloFacebookSample.iml
+++ b/samples/HelloFacebookSample/HelloFacebookSample.iml
@@ -27,6 +27,7 @@
           <path>/res-overlay</path>
         </resOverlayFolders>
         <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
         <additionalNativeLibs />
       </configuration>
     </facet>
diff --git a/samples/HelloFacebookSample/ant.properties b/samples/HelloFacebookSample/ant.properties
index b0971e891..939105d52 100644
--- a/samples/HelloFacebookSample/ant.properties
+++ b/samples/HelloFacebookSample/ant.properties
@@ -15,3 +15,4 @@
 #  'key.alias' for the name of the key to use.
 # The password will be asked during the build when you use the 'release' target.
 
+java.compilerargs=-Xlint -Werror
diff --git a/samples/HelloFacebookSample/res/layout/main.xml b/samples/HelloFacebookSample/res/layout/main.xml
index 621a9bfe8..f326848b2 100644
--- a/samples/HelloFacebookSample/res/layout/main.xml
+++ b/samples/HelloFacebookSample/res/layout/main.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
               xmlns:facebook="http://schemas.android.com/apk/res-auto"
               android:orientation="vertical"
@@ -6,59 +22,70 @@
               android:layout_height="fill_parent"
               android:background="#FFF"
         >
-    <com.facebook.LoginButton
-            android:id="@+id/login_button"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_marginTop="5dp"
-            facebook:confirm_logout="false"
-            facebook:fetch_user_info="true"
-             />
-    <LinearLayout
-            android:layout_width="150dp"
-            android:layout_height="wrap_content"
-            android:layout_gravity="center_horizontal"
-            android:gravity="center_horizontal"
-            android:orientation="vertical">
-        <TextView
-                android:id="@+id/greeting"
+    <LinearLayout android:orientation="vertical"
+                  android:layout_width="fill_parent"
+                  android:layout_height="fill_parent"
+                  android:background="#FFF"
+                  android:id="@+id/main_ui_container">
+        <com.facebook.widget.LoginButton
+                android:id="@+id/login_button"
                 android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
-                android:layout_marginLeft="10dp"
-                android:layout_gravity="center"
-                android:textColor="#333"
-                android:textSize="18sp" />
-        <com.facebook.ProfilePictureView
-                android:id="@+id/profilePicture"
-                android:layout_height="wrap_content"
-                android:layout_width="wrap_content"
-                android:gravity="center_horizontal"
-                android:layout_marginBottom="10dp"
-                facebook:preset_size="normal" />
-        <Button
-                android:id="@+id/postStatusUpdateButton"
-                android:layout_width="fill_parent"
-                android:layout_height="wrap_content"
-                android:text="Post Status Update"
+                android:layout_marginTop="5dp"
+                facebook:confirm_logout="false"
+                facebook:fetch_user_info="true"
                 />
-        <Button
-                android:id="@+id/postPhotoButton"
-                android:layout_width="fill_parent"
+        <LinearLayout
+                android:layout_width="150dp"
                 android:layout_height="wrap_content"
-                android:text="Post Photo"
-                />
-        <Button
-                android:id="@+id/pickFriendsButton"
-                android:layout_width="fill_parent"
-                android:layout_height="wrap_content"
-                android:text="Pick Some Friends"
-                />
-        <Button
-                android:id="@+id/pickPlaceButton"
-                android:layout_width="fill_parent"
-                android:layout_height="wrap_content"
-                android:text="Pick Place"
-                />
+                android:layout_gravity="center_horizontal"
+                android:gravity="center_horizontal"
+                android:orientation="vertical">
+            <TextView
+                    android:id="@+id/greeting"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_marginLeft="10dp"
+                    android:layout_gravity="center"
+                    android:textColor="#333"
+                    android:textSize="18sp"/>
+            <com.facebook.widget.ProfilePictureView
+                    android:id="@+id/profilePicture"
+                    android:layout_height="wrap_content"
+                    android:layout_width="wrap_content"
+                    android:gravity="center_horizontal"
+                    android:layout_marginBottom="10dp"
+                    facebook:preset_size="normal"/>
+            <Button
+                    android:id="@+id/postStatusUpdateButton"
+                    android:layout_width="fill_parent"
+                    android:layout_height="wrap_content"
+                    android:text="Post Status Update"
+                    />
+            <Button
+                    android:id="@+id/postPhotoButton"
+                    android:layout_width="fill_parent"
+                    android:layout_height="wrap_content"
+                    android:text="Post Photo"
+                    />
+            <Button
+                    android:id="@+id/pickFriendsButton"
+                    android:layout_width="fill_parent"
+                    android:layout_height="wrap_content"
+                    android:text="Pick Some Friends"
+                    />
+            <Button
+                    android:id="@+id/pickPlaceButton"
+                    android:layout_width="fill_parent"
+                    android:layout_height="wrap_content"
+                    android:text="Pick Place"
+                    />
+        </LinearLayout>
     </LinearLayout>
+    <FrameLayout
+            android:id="@+id/fragment_container"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"/>
+
 </LinearLayout>
 
diff --git a/samples/HelloFacebookSample/res/layout/pick_friends_activity.xml b/samples/HelloFacebookSample/res/layout/pick_friends_activity.xml
deleted file mode 100644
index 3110f96ce..000000000
--- a/samples/HelloFacebookSample/res/layout/pick_friends_activity.xml
+++ /dev/null
@@ -1,13 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:orientation="vertical"
-              android:layout_width="fill_parent"
-              android:layout_height="fill_parent"
-        >
-    <FrameLayout
-            android:id="@+id/friend_picker_fragment"
-            android:layout_width="fill_parent"
-            android:layout_height="fill_parent"
-            />
-</LinearLayout>
-
diff --git a/samples/HelloFacebookSample/res/layout/pick_place_activity.xml b/samples/HelloFacebookSample/res/layout/pick_place_activity.xml
deleted file mode 100644
index 27e5b8d3f..000000000
--- a/samples/HelloFacebookSample/res/layout/pick_place_activity.xml
+++ /dev/null
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              xmlns:app="http://schemas.android.com/apk/res-auto"
-              android:orientation="vertical"
-              android:layout_width="fill_parent"
-              android:layout_height="fill_parent"
-        >
-    <fragment
-            android:id="@+id/place_picker_fragment"
-            android:name="com.facebook.PlacePickerFragment"
-            android:layout_width="fill_parent"
-            android:layout_height="fill_parent"
-            app:show_pictures="true"
-            app:show_search_box="true"
-            />
-</LinearLayout>
-
diff --git a/samples/HelloFacebookSample/res/values/strings.xml b/samples/HelloFacebookSample/res/values/strings.xml
index 0fca51e10..c55cdb9d1 100644
--- a/samples/HelloFacebookSample/res/values/strings.xml
+++ b/samples/HelloFacebookSample/res/values/strings.xml
@@ -1,4 +1,34 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <string name="app_name">HelloFacebookSample</string>
+    <string name="cancelled">Cancelled</string>
+    <string name="permission_not_granted">Unable to perform selected action because permissions were not granted.</string>
+    <string name="ok">OK</string>
+    <string name="hello_user">Hello %1$s!</string>
+    <string name="success">Success</string>
+    <string name="successfully_posted_post">Successfully posted \'%1$s\'.\nPost ID: %2$s</string>
+    <string name="error">Error</string>
+    <string name="status_update">Updating status for %1$s at %2$s</string>
+    <string name="photo_post">Photo Post</string>
+    <string name="you_picked">You picked:</string>
+    <string name="no_friends_selected">&lt;No friends selected&gt;</string>
+    <string name="no_place_selected">&lt;No place selected&gt;</string>
+    <string name="pick_seattle_place">Pick a Seattle Place</string>
+    <string name="app_id">355198514515820</string>
 </resources>
diff --git a/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookApplication.java b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookApplication.java
deleted file mode 100644
index 2a489df37..000000000
--- a/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookApplication.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/**
- * Copyright 2012 Facebook
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.samples.hellofacebook;
-
-import android.app.Application;
-import com.facebook.GraphPlace;
-import com.facebook.GraphUser;
-
-import java.util.Collection;
-
-// We use a custom Application class to store our minimal state data (which users have been selected).
-// A real-world application will likely require a more robust data model.
-public class HelloFacebookApplication extends Application {
-    private Collection<GraphUser> selectedUsers;
-    private GraphPlace selectedPlace;
-
-    public Collection<GraphUser> getSelectedUsers() {
-        return selectedUsers;
-    }
-
-    public void setSelectedUsers(Collection<GraphUser> selectedUsers) {
-        this.selectedUsers = selectedUsers;
-    }
-
-    public GraphPlace getSelectedPlace() {
-        return selectedPlace;
-    }
-
-    public void setSelectedPlace(GraphPlace selectedPlace) {
-        this.selectedPlace = selectedPlace;
-    }
-}
diff --git a/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookSampleActivity.java b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookSampleActivity.java
index b964b03bc..52be10092 100644
--- a/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookSampleActivity.java
+++ b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookSampleActivity.java
@@ -17,36 +17,37 @@
 package com.facebook.samples.hellofacebook;
 
 import android.app.AlertDialog;
-import android.content.BroadcastReceiver;
-import android.content.Context;
 import android.content.Intent;
-import android.content.IntentFilter;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.location.Location;
 import android.os.Bundle;
-import android.support.v4.content.LocalBroadcastManager;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
 import android.text.TextUtils;
 import android.view.View;
+import android.view.ViewGroup;
 import android.widget.Button;
 import android.widget.TextView;
 import com.facebook.*;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphPlace;
+import com.facebook.model.GraphUser;
+import com.facebook.widget.*;
+
+import java.util.*;
+
+public class HelloFacebookSampleActivity extends FragmentActivity {
+
+    private static final List<String> PERMISSIONS = Arrays.asList("publish_actions");
+    private static final Location SEATTLE_LOCATION = new Location("") {
+        {
+            setLatitude(47.6097);
+            setLongitude(-122.3331);
+        }
+    };
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Date;
-import java.util.List;
-
-public class HelloFacebookSampleActivity extends FacebookActivity {
-    @SuppressWarnings("serial")
-    private static final List<String> PERMISSIONS = new ArrayList<String>() {{
-        add("publish_actions");
-    }};
-
-    private final int PICK_FRIENDS_ACTIVITY = 1;
-    private final int PICK_PLACE_ACTIVITY = 2;
-    private final int REAUTHORIZE_ACTIVITY = 3;
-    private final String APP_ID = "355198514515820";
     private final String PENDING_ACTION_BUNDLE_KEY = "com.facebook.samples.hellofacebook:PendingAction";
 
     private Button postStatusUpdateButton;
@@ -57,12 +58,7 @@
     private ProfilePictureView profilePictureView;
     private TextView greeting;
     private PendingAction pendingAction = PendingAction.NONE;
-    private final Location SEATTLE_LOCATION = new Location("") {
-        {
-            setLatitude(47.6097);
-            setLongitude(-122.3331);
-        }
-    };
+    private ViewGroup controlsContainer;
     private GraphUser user;
 
     private enum PendingAction {
@@ -70,17 +66,29 @@
         POST_PHOTO,
         POST_STATUS_UPDATE
     }
+    private UiLifecycleHelper uiHelper;
+
+    private Session.StatusCallback callback = new Session.StatusCallback() {
+        @Override
+        public void call(Session session, SessionState state, Exception exception) {
+            onSessionStateChange(session, state, exception);
+        }
+    };
 
-    /**
-     * Called when the activity is first created.
-     */
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
+        uiHelper = new UiLifecycleHelper(this, callback);
+        uiHelper.onCreate(savedInstanceState);
+
+        if (savedInstanceState != null) {
+            String name = savedInstanceState.getString(PENDING_ACTION_BUNDLE_KEY);
+            pendingAction = PendingAction.valueOf(name);
+        }
+
         setContentView(R.layout.main);
 
         loginButton = (LoginButton) findViewById(R.id.login_button);
-        loginButton.setApplicationId(APP_ID);
         loginButton.setUserInfoChangedCallback(new LoginButton.UserInfoChangedCallback() {
             @Override
             public void onUserInfoFetched(GraphUser user) {
@@ -122,103 +130,88 @@ public void onClick(View view) {
                 onClickPickPlace();
             }
         });
-    }
 
-    @Override
-    protected void onStart() {
-        super.onStart();
-
-        updateUI();
+        controlsContainer = (ViewGroup) findViewById(R.id.main_ui_container);
+
+        final FragmentManager fm = getSupportFragmentManager();
+        Fragment fragment = fm.findFragmentById(R.id.fragment_container);
+        if (fragment != null) {
+            // If we're being re-created and have a fragment, we need to a) hide the main UI controls and
+            // b) hook up its listeners again.
+            controlsContainer.setVisibility(View.GONE);
+            if (fragment instanceof FriendPickerFragment) {
+                setFriendPickerListeners((FriendPickerFragment) fragment);
+            } else if (fragment instanceof PlacePickerFragment) {
+                setPlacePickerListeners((PlacePickerFragment) fragment);
+            }
+        }
 
-        IntentFilter filter = new IntentFilter();
-        filter.addAction(Session.ACTION_ACTIVE_SESSION_OPENED);
-        filter.addAction(Session.ACTION_ACTIVE_SESSION_CLOSED);
-        LocalBroadcastManager.getInstance(this).registerReceiver(receiver, filter);
+        // Listen for changes in the back stack so we know if a fragment got popped off because the user
+        // clicked the back button.
+        fm.addOnBackStackChangedListener(new FragmentManager.OnBackStackChangedListener() {
+            @Override
+            public void onBackStackChanged() {
+                if (fm.getBackStackEntryCount() == 0) {
+                    // We need to re-show our UI.
+                    controlsContainer.setVisibility(View.VISIBLE);
+                }
+            }
+        });
     }
 
     @Override
-    protected void onStop() {
-        super.onStop();
+    protected void onResume() {
+        super.onResume();
+        uiHelper.onResume();
 
-        LocalBroadcastManager.getInstance(this).unregisterReceiver(receiver);
+        updateUI();
     }
 
     @Override
     protected void onSaveInstanceState(Bundle outState) {
         super.onSaveInstanceState(outState);
+        uiHelper.onSaveInstanceState(outState);
 
-        outState.putInt(PENDING_ACTION_BUNDLE_KEY, pendingAction.ordinal());
+        outState.putString(PENDING_ACTION_BUNDLE_KEY, pendingAction.name());
     }
 
     @Override
-    protected void onRestoreInstanceState(Bundle savedInstanceState) {
-        super.onRestoreInstanceState(savedInstanceState);
-
-        int ordinal = savedInstanceState.getInt(PENDING_ACTION_BUNDLE_KEY, 0);
-        pendingAction = PendingAction.values()[ordinal];
-    }
-
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
         super.onActivityResult(requestCode, resultCode, data);
+        uiHelper.onActivityResult(requestCode, resultCode, data);
+    }
 
-        switch (requestCode) {
-            case PICK_FRIENDS_ACTIVITY:
-                String results = "";
-                if (resultCode == RESULT_OK) {
-                    HelloFacebookApplication application = (HelloFacebookApplication) getApplication();
-                    Collection<GraphUser> selection = application.getSelectedUsers();
-                    if (selection != null && selection.size() > 0) {
-                        ArrayList<String> names = new ArrayList<String>();
-                        for (GraphUser user : selection) {
-                            names.add(user.getName());
-                        }
-                        results = TextUtils.join(", ", names);
-                    } else {
-                        results = "<No friends selected>";
-                    }
-                } else {
-                    results = "<Cancelled>";
-                }
-
-                AlertDialog.Builder builder = new AlertDialog.Builder(this);
-                builder.setTitle("You picked:").setMessage(results).setPositiveButton("OK", null);
-                builder.show();
-
-                break;
-
-            case PICK_PLACE_ACTIVITY:
-                results = "";
-                if (resultCode == RESULT_OK) {
-                    HelloFacebookApplication application = (HelloFacebookApplication) getApplication();
-                    GraphPlace selection = application.getSelectedPlace();
-                    if (selection != null) {
-                        results = selection.getName();
-                    } else {
-                        results = "<No place selected>";
-                    }
-                } else {
-                    results = "<Cancelled>";
-                }
-
-                builder = new AlertDialog.Builder(this);
-                builder.setTitle("You picked:").setMessage(results).setPositiveButton("OK", null);
-                builder.show();
-
-                break;
-        }
+    @Override
+    public void onPause() {
+        super.onPause();
+        uiHelper.onPause();
     }
 
     @Override
-    protected void onSessionStateChange(SessionState state, Exception exception) {
-        super.onSessionStateChange(state, exception);
-        if (state == SessionState.OPENED_TOKEN_UPDATED) {
+    public void onDestroy() {
+        super.onDestroy();
+        uiHelper.onDestroy();
+    }
+
+    private void onSessionStateChange(Session session, SessionState state, Exception exception) {
+        if (pendingAction != PendingAction.NONE &&
+                (exception instanceof FacebookOperationCanceledException ||
+                exception instanceof FacebookAuthorizationException)) {
+                new AlertDialog.Builder(HelloFacebookSampleActivity.this)
+                    .setTitle(R.string.cancelled)
+                    .setMessage(R.string.permission_not_granted)
+                    .setPositiveButton(R.string.ok, null)
+                    .show();
+            pendingAction = PendingAction.NONE;
+        } else if (state == SessionState.OPENED_TOKEN_UPDATED) {
             handlePendingAction();
         }
+        updateUI();
     }
 
     private void updateUI() {
-        boolean enableButtons = Session.getActiveSession() != null &&
-                Session.getActiveSession().getState().isOpened();
+        Session session = Session.getActiveSession();
+        boolean enableButtons = (session != null && session.isOpened());
 
         postStatusUpdateButton.setEnabled(enableButtons);
         postPhotoButton.setEnabled(enableButtons);
@@ -226,17 +219,22 @@ private void updateUI() {
         pickPlaceButton.setEnabled(enableButtons);
 
         if (enableButtons && user != null) {
-            profilePictureView.setUserId(user.getId());
-            greeting.setText(String.format("Hello %s!", user.getFirstName()));
+            profilePictureView.setProfileId(user.getId());
+            greeting.setText(getString(R.string.hello_user, user.getFirstName()));
         } else {
-            profilePictureView.setUserId(null);
+            profilePictureView.setProfileId(null);
             greeting.setText(null);
         }
     }
 
     @SuppressWarnings("incomplete-switch")
     private void handlePendingAction() {
-        switch (pendingAction) {
+        PendingAction previouslyPendingAction = pendingAction;
+        // These actions may re-set pendingAction if they are still pending, but we assume they
+        // will succeed.
+        pendingAction = PendingAction.NONE;
+
+        switch (previouslyPendingAction) {
             case POST_PHOTO:
                 postPhoto();
                 break;
@@ -244,28 +242,29 @@ private void handlePendingAction() {
                 postStatusUpdate();
                 break;
         }
-        pendingAction = PendingAction.NONE;
     }
 
     private interface GraphObjectWithId extends GraphObject {
         String getId();
     }
 
-    private void showAlert(String message, GraphObject result, Exception exception) {
+    private void showPublishResult(String message, GraphObject result, FacebookRequestError error) {
         String title = null;
         String alertMessage = null;
-        if (exception == null) {
-            title = "Success";
+        if (error == null) {
+            title = getString(R.string.success);
             String id = result.cast(GraphObjectWithId.class).getId();
-            alertMessage = String.format("Successfully posted '%s'.\nPost ID: %s", message, id);
+            alertMessage = getString(R.string.successfully_posted_post, message, id);
         } else {
-            title = "Error";
-            alertMessage = exception.getMessage();
+            title = getString(R.string.error);
+            alertMessage = error.getErrorMessage();
         }
 
-        AlertDialog.Builder builder = new AlertDialog.Builder(this);
-        builder.setTitle(title).setMessage(alertMessage).setPositiveButton("OK", null);
-        builder.show();
+        new AlertDialog.Builder(this)
+                .setTitle(title)
+                .setMessage(alertMessage)
+                .setPositiveButton(R.string.ok, null)
+                .show();
     }
 
     private void onClickPostStatusUpdate() {
@@ -273,17 +272,16 @@ private void onClickPostStatusUpdate() {
     }
 
     private void postStatusUpdate() {
-        if (user != null) {
-            final String message = String
-                    .format("Updating status for %s at %s", user.getFirstName(), (new Date().toString()));
+        if (user != null && hasPublishPermission()) {
+            final String message = getString(R.string.status_update, user.getFirstName(), (new Date().toString()));
             Request request = Request
                     .newStatusUpdateRequest(Session.getActiveSession(), message, new Request.Callback() {
                         @Override
                         public void onCompleted(Response response) {
-                            showAlert(message, response.getGraphObject(), response.getError());
+                            showPublishResult(message, response.getGraphObject(), response.getError());
                         }
                     });
-            Request.executeBatchAsync(request);
+            request.executeAsync();
         } else {
             pendingAction = PendingAction.POST_STATUS_UPDATE;
         }
@@ -294,50 +292,146 @@ private void onClickPostPhoto() {
     }
 
     private void postPhoto() {
-        Bitmap image = BitmapFactory.decodeResource(this.getResources(), R.drawable.icon);
-        Request request = Request.newUploadPhotoRequest(Session.getActiveSession(), image, new Request.Callback() {
+        if (hasPublishPermission()) {
+            Bitmap image = BitmapFactory.decodeResource(this.getResources(), R.drawable.icon);
+            Request request = Request.newUploadPhotoRequest(Session.getActiveSession(), image, new Request.Callback() {
+                @Override
+                public void onCompleted(Response response) {
+                    showPublishResult(getString(R.string.photo_post), response.getGraphObject(), response.getError());
+                }
+            });
+            request.executeAsync();
+        } else {
+            pendingAction = PendingAction.POST_PHOTO;
+        }
+    }
+
+    private void showPickerFragment(PickerFragment<?> fragment) {
+        fragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
             @Override
-            public void onCompleted(Response response) {
-                showAlert("Photo Post", response.getGraphObject(), response.getError());
+            public void onError(PickerFragment<?> pickerFragment, FacebookException error) {
+                showAlert(getString(R.string.error), error.getMessage());
             }
         });
-        Request.executeBatchAsync(request);
+
+        FragmentManager fm = getSupportFragmentManager();
+        fm.beginTransaction()
+                .replace(R.id.fragment_container, fragment)
+                .addToBackStack(null)
+                .commit();
+
+        controlsContainer.setVisibility(View.GONE);
+
+        // We want the fragment fully created so we can use it immediately.
+        fm.executePendingTransactions();
+
+        fragment.loadData(false);
     }
 
     private void onClickPickFriends() {
-        Intent intent = new Intent(this, PickFriendsActivity.class);
-        startActivityForResult(intent, PICK_FRIENDS_ACTIVITY);
+        final FriendPickerFragment fragment = new FriendPickerFragment();
+
+        setFriendPickerListeners(fragment);
+
+        showPickerFragment(fragment);
+    }
+
+    private void setFriendPickerListeners(final FriendPickerFragment fragment) {
+        fragment.setOnDoneButtonClickedListener(new FriendPickerFragment.OnDoneButtonClickedListener() {
+            @Override
+            public void onDoneButtonClicked(PickerFragment<?> pickerFragment) {
+                onFriendPickerDone(fragment);
+            }
+        });
+    }
+
+    private void onFriendPickerDone(FriendPickerFragment fragment) {
+        FragmentManager fm = getSupportFragmentManager();
+        fm.popBackStack();
+
+        String results = "";
+
+        Collection<GraphUser> selection = fragment.getSelection();
+        if (selection != null && selection.size() > 0) {
+            ArrayList<String> names = new ArrayList<String>();
+            for (GraphUser user : selection) {
+                names.add(user.getName());
+            }
+            results = TextUtils.join(", ", names);
+        } else {
+            results = getString(R.string.no_friends_selected);
+        }
+
+        showAlert(getString(R.string.you_picked), results);
+    }
+
+    private void onPlacePickerDone(PlacePickerFragment fragment) {
+        FragmentManager fm = getSupportFragmentManager();
+        fm.popBackStack();
+
+        String result = "";
+
+        GraphPlace selection = fragment.getSelection();
+        if (selection != null) {
+            result = selection.getName();
+        } else {
+            result = getString(R.string.no_place_selected);
+        }
+
+        showAlert(getString(R.string.you_picked), result);
     }
 
     private void onClickPickPlace() {
-        Intent intent = new Intent(this, PickPlaceActivity.class);
-        PickPlaceActivity.populateParameters(intent, SEATTLE_LOCATION, null);
-        startActivityForResult(intent, PICK_PLACE_ACTIVITY);
+        final PlacePickerFragment fragment = new PlacePickerFragment();
+        fragment.setLocation(SEATTLE_LOCATION);
+        fragment.setTitleText(getString(R.string.pick_seattle_place));
+
+        setPlacePickerListeners(fragment);
+
+        showPickerFragment(fragment);
+    }
+
+    private void setPlacePickerListeners(final PlacePickerFragment fragment) {
+        fragment.setOnDoneButtonClickedListener(new PlacePickerFragment.OnDoneButtonClickedListener() {
+            @Override
+            public void onDoneButtonClicked(PickerFragment<?> pickerFragment) {
+                onPlacePickerDone(fragment);
+            }
+        });
+        fragment.setOnSelectionChangedListener(new PlacePickerFragment.OnSelectionChangedListener() {
+            @Override
+            public void onSelectionChanged(PickerFragment<?> pickerFragment) {
+                if (fragment.getSelection() != null) {
+                    onPlacePickerDone(fragment);
+                }
+            }
+        });
+    }
+
+    private void showAlert(String title, String message) {
+        new AlertDialog.Builder(this)
+                .setTitle(title)
+                .setMessage(message)
+                .setPositiveButton(R.string.ok, null)
+                .show();
+    }
+
+    private boolean hasPublishPermission() {
+        Session session = Session.getActiveSession();
+        return session != null && session.getPermissions().contains("publish_actions");
     }
 
     private void performPublish(PendingAction action) {
         Session session = Session.getActiveSession();
         if (session != null) {
             pendingAction = action;
-            if (session.getPermissions().contains("publish_actions")) {
+            if (hasPublishPermission()) {
                 // We can do the action right away.
                 handlePendingAction();
             } else {
-                // We need to reauthorize, then complete the action when we get called back.
-                Session.ReauthorizeRequest reauthRequest = new Session.ReauthorizeRequest(this, PERMISSIONS).
-                        setRequestCode(REAUTHORIZE_ACTIVITY).
-                        setLoginBehavior(SessionLoginBehavior.SSO_WITH_FALLBACK);
-                session.reauthorizeForPublish(reauthRequest);
+                // We need to get new permissions, then complete the action when we get called back.
+                session.requestNewPublishPermissions(new Session.NewPermissionsRequest(this, PERMISSIONS));
             }
         }
     }
-
-    private BroadcastReceiver receiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            updateUI();
-        }
-    };
-
-
 }
diff --git a/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/PickFriendsActivity.java b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/PickFriendsActivity.java
deleted file mode 100644
index a9629e8f4..000000000
--- a/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/PickFriendsActivity.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/**
- * Copyright 2012 Facebook
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.samples.hellofacebook;
-
-import android.app.AlertDialog;
-import android.content.Intent;
-import android.os.Bundle;
-import android.support.v4.app.FragmentActivity;
-import android.support.v4.app.FragmentManager;
-import com.facebook.FacebookException;
-import com.facebook.FriendPickerFragment;
-import com.facebook.PickerFragment;
-
-// This class provides an example of an Activity that uses FriendPickerFragment to display a list of
-// the user's friends. It takes a programmatic approach to creating the FriendPickerFragment with the
-// desired parameters -- see PickPlaceActivity in the PlacePickerSample project for an example of an
-// Activity creating a fragment (in this case a PlacePickerFragment) via XML layout rather than
-// programmatically.
-public class PickFriendsActivity extends FragmentActivity {
-    FriendPickerFragment friendPickerFragment;
-
-    // A helper to simplify life for callers who want to populate a Bundle with the necessary
-    // parameters. A more sophisticated Activity might define its own set of parameters; our needs
-    // are simple, so we just populate what we want to pass to the FriendPickerFragment.
-    public static void populateParameters(Intent intent, String userId, boolean multiSelect) {
-        intent.putExtra(FriendPickerFragment.USER_ID_BUNDLE_KEY, userId);
-        intent.putExtra(FriendPickerFragment.MULTI_SELECT_BUNDLE_KEY, multiSelect);
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.pick_friends_activity);
-
-        FragmentManager fm = getSupportFragmentManager();
-
-        if (savedInstanceState == null) {
-            // First time through, we create our fragment programmatically.
-            final Bundle args = getIntent().getExtras();
-            friendPickerFragment = new FriendPickerFragment(args);
-            fm.beginTransaction()
-                    .add(R.id.friend_picker_fragment, friendPickerFragment)
-                    .commit();
-        } else {
-            // Subsequent times, our fragment is recreated by the framework and already has saved and
-            // restored its state, so we don't need to specify args again. (In fact, this might be
-            // incorrect if the fragment was modified programmatically since it was created.)
-            friendPickerFragment = (FriendPickerFragment) fm.findFragmentById(R.id.friend_picker_fragment);
-        }
-
-        friendPickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
-            @Override
-            public void onError(FacebookException error) {
-                PickFriendsActivity.this.onError(error);
-            }
-        });
-
-        friendPickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
-            @Override
-            public void onDoneButtonClicked() {
-                // We just store our selection in the Application for other activities to look at.
-                HelloFacebookApplication application = (HelloFacebookApplication) getApplication();
-                application.setSelectedUsers(friendPickerFragment.getSelection());
-
-                setResult(RESULT_OK, null);
-                finish();
-            }
-        });
-    }
-
-    private void onError(Exception error) {
-        AlertDialog.Builder builder = new AlertDialog.Builder(this);
-        builder.setTitle("Error").setMessage(error.getMessage()).setPositiveButton("OK", null);
-        builder.show();
-    }
-
-    @Override
-    protected void onStart() {
-        super.onStart();
-        try {
-            // Load data, unless a query has already taken place.
-            friendPickerFragment.loadData(false);
-        } catch (Exception ex) {
-            onError(ex);
-        }
-    }
-}
diff --git a/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/PickPlaceActivity.java b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/PickPlaceActivity.java
deleted file mode 100644
index 119ebe4ee..000000000
--- a/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/PickPlaceActivity.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/**
- * Copyright 2012 Facebook
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.samples.hellofacebook;
-
-import android.app.AlertDialog;
-import android.content.Intent;
-import android.location.Location;
-import android.os.Bundle;
-import android.support.v4.app.FragmentActivity;
-import android.support.v4.app.FragmentManager;
-import com.facebook.FacebookException;
-import com.facebook.PickerFragment;
-import com.facebook.PlacePickerFragment;
-
-// This class provides an example of an Activity that uses PlacePickerFragment to display a list of
-// the places. It takes a layout-based approach to creating the PlacePickerFragment with the
-// desired parameters -- see PickFriendActivity in the FriendPickerSample project for an example of an
-// Activity creating a fragment (in this case a FriendPickerFragment) programmatically rather than
-// via XML layout.
-public class PickPlaceActivity extends FragmentActivity {
-    PlacePickerFragment placePickerFragment;
-
-    // A helper to simplify life for callers who want to populate a Bundle with the necessary
-    // parameters. A more sophisticated Activity might define its own set of parameters; our needs
-    // are simple, so we just populate what we want to pass to the PlacePickerFragment.
-    public static void populateParameters(Intent intent, Location location, String searchText) {
-        intent.putExtra(PlacePickerFragment.LOCATION_BUNDLE_KEY, location);
-        intent.putExtra(PlacePickerFragment.SEARCH_TEXT_BUNDLE_KEY, searchText);
-        intent.putExtra(PlacePickerFragment.TITLE_TEXT_BUNDLE_KEY, "Pick a Seattle Place");
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.pick_place_activity);
-
-        FragmentManager fm = getSupportFragmentManager();
-        placePickerFragment = (PlacePickerFragment) fm.findFragmentById(R.id.place_picker_fragment);
-        if (savedInstanceState == null) {
-            // If this is the first time we have created the fragment, update its properties based on
-            // any parameters we received via our Intent.
-            placePickerFragment.setSettingsFromBundle(getIntent().getExtras());
-        }
-
-        placePickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
-            @Override
-            public void onError(FacebookException error) {
-                PickPlaceActivity.this.onError(error);
-            }
-        });
-
-        // We finish the activity when either the Done button is pressed or when a place is
-        // selected (since only a single place can be selected).
-        placePickerFragment.setOnSelectionChangedListener(new PickerFragment.OnSelectionChangedListener() {
-            @Override
-            public void onSelectionChanged() {
-                if (placePickerFragment.getSelection() != null) {
-                    finishActivity();
-                }
-            }
-        });
-
-        placePickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
-            @Override
-            public void onDoneButtonClicked() {
-                finishActivity();
-            }
-        });
-    }
-
-    private void finishActivity() {
-        // We just store our selection in the Application for other activities to look at.
-        HelloFacebookApplication application = (HelloFacebookApplication) getApplication();
-        application.setSelectedPlace(placePickerFragment.getSelection());
-
-        setResult(RESULT_OK, null);
-        finish();
-    }
-
-    private void onError(Exception error) {
-        AlertDialog.Builder builder = new AlertDialog.Builder(this);
-        builder.setTitle("Error").setMessage(error.getMessage()).setPositiveButton("OK", null);
-        builder.show();
-    }
-
-    @Override
-    protected void onStart() {
-        super.onStart();
-        try {
-            // Load data, unless a query has already taken place.
-            placePickerFragment.loadData(false);
-        } catch (Exception ex) {
-            onError(ex);
-        }
-    }
-}
diff --git a/samples/JustRequestSample/com.facebook.samples.justlogin.JustRequestSampleActivity.eml b/samples/JustRequestSample/com.facebook.samples.justlogin.JustRequestSampleActivity.eml
deleted file mode 100644
index 4104d1ffc..000000000
--- a/samples/JustRequestSample/com.facebook.samples.justlogin.JustRequestSampleActivity.eml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<component>
-	<exclude-output/>
-	<contentEntry url="file://$MODULE_DIR$"/>
-</component>
diff --git a/samples/JustRequestSample/res/values/strings.xml b/samples/JustRequestSample/res/values/strings.xml
deleted file mode 100644
index d47181167..000000000
--- a/samples/JustRequestSample/res/values/strings.xml
+++ /dev/null
@@ -1,10 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-
-    <string name="hello">Hello World, JustRequestSampleActivity!</string>
-    <string name="app_name">JustRequestSample</string>
-    <string name="request">Request</string>
-    <string name="instructions">Login to create a link to fetch account data</string>
-    <string name="logout">Log out</string>
-
-</resources>
\ No newline at end of file
diff --git a/samples/PlacePickerSample/AndroidManifest.xml b/samples/PlacePickerSample/AndroidManifest.xml
index 5cf351e8f..b0697ff65 100644
--- a/samples/PlacePickerSample/AndroidManifest.xml
+++ b/samples/PlacePickerSample/AndroidManifest.xml
@@ -24,6 +24,7 @@
                   android:label="Pick Place">
         </activity>
         <activity android:name="com.facebook.LoginActivity"
+                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
                   android:label="@string/app_name" />
         <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
     </application>
diff --git a/samples/PlacePickerSample/PlacePickerSample.iml b/samples/PlacePickerSample/PlacePickerSample.iml
index bb7ba685f..13e1c77ae 100644
--- a/samples/PlacePickerSample/PlacePickerSample.iml
+++ b/samples/PlacePickerSample/PlacePickerSample.iml
@@ -27,6 +27,7 @@
           <path>/res-overlay</path>
         </resOverlayFolders>
         <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
         <additionalNativeLibs />
       </configuration>
     </facet>
diff --git a/samples/PlacePickerSample/ant.properties b/samples/PlacePickerSample/ant.properties
index b0971e891..939105d52 100644
--- a/samples/PlacePickerSample/ant.properties
+++ b/samples/PlacePickerSample/ant.properties
@@ -15,3 +15,4 @@
 #  'key.alias' for the name of the key to use.
 # The password will be asked during the build when you use the 'release' target.
 
+java.compilerargs=-Xlint -Werror
diff --git a/samples/PlacePickerSample/res/layout/main.xml b/samples/PlacePickerSample/res/layout/main.xml
index c1d188f23..7c4c7f1d0 100644
--- a/samples/PlacePickerSample/res/layout/main.xml
+++ b/samples/PlacePickerSample/res/layout/main.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
               android:orientation="vertical"
               android:layout_width="fill_parent"
diff --git a/samples/PlacePickerSample/res/layout/pick_place_activity.xml b/samples/PlacePickerSample/res/layout/pick_place_activity.xml
index d98c419b3..8601f57e4 100644
--- a/samples/PlacePickerSample/res/layout/pick_place_activity.xml
+++ b/samples/PlacePickerSample/res/layout/pick_place_activity.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
               xmlns:app="http://schemas.android.com/apk/res-auto"
               android:orientation="vertical"
@@ -7,7 +23,7 @@
         >
     <fragment
             android:id="@+id/place_picker_fragment"
-            android:name="com.facebook.PlacePickerFragment"
+            android:name="com.facebook.widget.PlacePickerFragment"
             android:layout_width="fill_parent"
             android:layout_height="fill_parent"
             app:show_pictures="true"
diff --git a/samples/PlacePickerSample/res/values/strings.xml b/samples/PlacePickerSample/res/values/strings.xml
index a2a3e9114..2248b47dd 100644
--- a/samples/PlacePickerSample/res/values/strings.xml
+++ b/samples/PlacePickerSample/res/values/strings.xml
@@ -1,5 +1,24 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <string name="app_name">PlacePickerSample</string>
     <string name="app_id">378281678861098</string>
+    <string name="error_dialog_title">Error</string>
+    <string name="ok_button">OK</string>
+    <string name="no_location">Could not obtain your current location.</string>
 </resources>
diff --git a/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PickPlaceActivity.java b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PickPlaceActivity.java
index 5c2e52b88..c02da9bdc 100644
--- a/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PickPlaceActivity.java
+++ b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PickPlaceActivity.java
@@ -23,8 +23,8 @@
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
 import com.facebook.FacebookException;
-import com.facebook.PickerFragment;
-import com.facebook.PlacePickerFragment;
+import com.facebook.widget.PickerFragment;
+import com.facebook.widget.PlacePickerFragment;
 
 // This class provides an example of an Activity that uses PlacePickerFragment to display a list of
 // the places. It takes a layout-based approach to creating the PlacePickerFragment with the
@@ -57,7 +57,7 @@ public void onCreate(Bundle savedInstanceState) {
 
         placePickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
             @Override
-            public void onError(FacebookException error) {
+            public void onError(PickerFragment<?> fragment, FacebookException error) {
                 PickPlaceActivity.this.onError(error);
             }
         });
@@ -66,7 +66,7 @@ public void onError(FacebookException error) {
         // selected (since only a single place can be selected).
         placePickerFragment.setOnSelectionChangedListener(new PickerFragment.OnSelectionChangedListener() {
             @Override
-            public void onSelectionChanged() {
+            public void onSelectionChanged(PickerFragment<?> fragment) {
                 if (placePickerFragment.getSelection() != null) {
                     finishActivity();
                 }
@@ -74,7 +74,7 @@ public void onSelectionChanged() {
         });
         placePickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
             @Override
-            public void onDoneButtonClicked() {
+            public void onDoneButtonClicked(PickerFragment<?> fragment) {
                 finishActivity();
             }
         });
@@ -90,9 +90,11 @@ private void finishActivity() {
     }
 
     private void onError(Exception error) {
-        AlertDialog.Builder builder = new AlertDialog.Builder(this);
-        builder.setTitle("Error").setMessage(error.getMessage()).setPositiveButton("OK", null);
-        builder.show();
+        new AlertDialog.Builder(this)
+                .setTitle(R.string.error_dialog_title)
+                .setMessage(error.getMessage())
+                .setPositiveButton(R.string.ok_button, null)
+                .show();
     }
 
     @Override
diff --git a/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerApplication.java b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerApplication.java
index 4181eb5e5..344c38732 100644
--- a/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerApplication.java
+++ b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerApplication.java
@@ -17,7 +17,7 @@
 package com.facebook.samples.placepicker;
 
 import android.app.Application;
-import com.facebook.GraphPlace;
+import com.facebook.model.GraphPlace;
 
 // We use a custom Application class to store our minimal state data (which users have been selected).
 // A real-world application will likely require a more robust data model.
diff --git a/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerSampleActivity.java b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerSampleActivity.java
index eab843419..2be700ed4 100644
--- a/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerSampleActivity.java
+++ b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerSampleActivity.java
@@ -28,25 +28,25 @@
 import android.view.View;
 import android.widget.Button;
 import android.widget.TextView;
-import com.facebook.GraphLocation;
-import com.facebook.GraphPlace;
+import com.facebook.model.GraphLocation;
+import com.facebook.model.GraphPlace;
 import com.facebook.Session;
 
 public class PlacePickerSampleActivity extends FragmentActivity implements LocationListener {
-    private final int PLACE_ACTIVITY = 1;
-    private final Location SEATTLE_LOCATION = new Location("") {
+    private static final int PLACE_ACTIVITY = 1;
+    private static final Location SEATTLE_LOCATION = new Location("") {
         {
             setLatitude(47.6097);
             setLongitude(-122.3331);
         }
     };
-    private final Location SAN_FRANCISCO_LOCATION = new Location("") {
+    private static final Location SAN_FRANCISCO_LOCATION = new Location("") {
         {
             setLatitude(37.7750);
             setLongitude(-122.4183);
         }
     };
-    private final Location PARIS_LOCATION = new Location("") {
+    private static final Location PARIS_LOCATION = new Location("") {
         {
             setLatitude(48.857875);
             setLongitude(2.294635);
@@ -57,9 +57,6 @@
     private LocationManager locationManager;
     private Location lastKnownLocation;
 
-    /**
-     * Called when the activity is first created.
-     */
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
@@ -87,7 +84,10 @@ public void onClick(View view) {
             }
         });
 
-        Session.openActiveSession(this, true);
+        if (Session.getActiveSession() == null ||
+                Session.getActiveSession().isClosed()) {
+            Session.openActiveSession(this, true, null);
+        }
 
         locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
     }
@@ -120,23 +120,21 @@ public void onActivityResult(int requestCode, int resultCode, Intent data) {
 
     private void displaySelectedPlace(int resultCode) {
         String results = "";
-        if (resultCode == RESULT_OK) {
-            PlacePickerApplication application = (PlacePickerApplication) getApplication();
-            GraphPlace selection = application.getSelectedPlace();
-            if (selection != null) {
-                GraphLocation location = selection.getLocation();
-
-                results = String.format("Name: %s\nCategory: %s\nLocation: (%f,%f)\nStreet: %s, %s, %s, %s, %s",
-                        selection.getName(), selection.getCategory(),
-                        location.getLatitude(), location.getLongitude(),
-                        location.getStreet(), location.getCity(), location.getState(), location.getZip(),
-                        location.getCountry());
-            } else {
-                results = "<No place selected>";
-            }
+        PlacePickerApplication application = (PlacePickerApplication) getApplication();
+
+        GraphPlace selection = application.getSelectedPlace();
+        if (selection != null) {
+            GraphLocation location = selection.getLocation();
+
+            results = String.format("Name: %s\nCategory: %s\nLocation: (%f,%f)\nStreet: %s, %s, %s, %s, %s",
+                    selection.getName(), selection.getCategory(),
+                    location.getLatitude(), location.getLongitude(),
+                    location.getStreet(), location.getCity(), location.getState(), location.getZip(),
+                    location.getCountry());
         } else {
-            results = "<Cancelled>";
+            results = "<No place selected>";
         }
+
         resultsTextView.setText(results);
     }
 
@@ -156,12 +154,19 @@ public void onProviderEnabled(String provider) {
     public void onProviderDisabled(String provider) {
     }
 
+    private void startPickPlaceActivity(Location location) {
+        PlacePickerApplication application = (PlacePickerApplication) getApplication();
+        application.setSelectedPlace(null);
+
+        Intent intent = new Intent(this, PickPlaceActivity.class);
+        PickPlaceActivity.populateParameters(intent, location, null);
+
+        startActivityForResult(intent, PLACE_ACTIVITY);
+    }
+
     private void onClickSeattle() {
         try {
-            Intent intent = new Intent(this, PickPlaceActivity.class);
-            PickPlaceActivity.populateParameters(intent, SEATTLE_LOCATION, null);
-
-            startActivityForResult(intent, PLACE_ACTIVITY);
+            startPickPlaceActivity(SEATTLE_LOCATION);
         } catch (Exception ex) {
             onError(ex);
         }
@@ -169,10 +174,7 @@ private void onClickSeattle() {
 
     private void onClickSanFrancisco() {
         try {
-            Intent intent = new Intent(this, PickPlaceActivity.class);
-            PickPlaceActivity.populateParameters(intent, SAN_FRANCISCO_LOCATION, null);
-
-            startActivityForResult(intent, PLACE_ACTIVITY);
+            startPickPlaceActivity(SAN_FRANCISCO_LOCATION);
         } catch (Exception ex) {
             onError(ex);
         }
@@ -194,18 +196,15 @@ private void onClickGPS() {
                     // location set.
                     lastKnownLocation = PARIS_LOCATION;
                 } else {
-                    String text = "Could not obtain your current location.";
-                    AlertDialog.Builder builder = new AlertDialog.Builder(PlacePickerSampleActivity.this);
-                    builder.setTitle("Error").setMessage(text).setPositiveButton("OK", null);
-                    builder.show();
+                    new AlertDialog.Builder(this)
+                            .setTitle(R.string.error_dialog_title)
+                            .setMessage(R.string.no_location)
+                            .setPositiveButton(R.string.ok_button, null)
+                            .show();
                     return;
                 }
             }
-
-            Intent intent = new Intent(this, PickPlaceActivity.class);
-            PickPlaceActivity.populateParameters(intent, lastKnownLocation, null);
-
-            startActivityForResult(intent, PLACE_ACTIVITY);
+            startPickPlaceActivity(lastKnownLocation);
         } catch (Exception ex) {
             onError(ex);
         }
diff --git a/samples/ProfilePictureSample/ProfilePictureSample.iml b/samples/ProfilePictureSample/ProfilePictureSample.iml
index bca109a37..4aac86509 100644
--- a/samples/ProfilePictureSample/ProfilePictureSample.iml
+++ b/samples/ProfilePictureSample/ProfilePictureSample.iml
@@ -27,6 +27,7 @@
           <path>/res-overlay</path>
         </resOverlayFolders>
         <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
         <additionalNativeLibs />
       </configuration>
     </facet>
diff --git a/samples/ProfilePictureSample/ant.properties b/samples/ProfilePictureSample/ant.properties
index b0971e891..939105d52 100644
--- a/samples/ProfilePictureSample/ant.properties
+++ b/samples/ProfilePictureSample/ant.properties
@@ -15,3 +15,4 @@
 #  'key.alias' for the name of the key to use.
 # The password will be asked during the build when you use the 'release' target.
 
+java.compilerargs=-Xlint -Werror
diff --git a/samples/ProfilePictureSample/res/layout/activity_profile_picture_sample.xml b/samples/ProfilePictureSample/res/layout/activity_profile_picture_sample.xml
index 6806bbd20..87877789a 100644
--- a/samples/ProfilePictureSample/res/layout/activity_profile_picture_sample.xml
+++ b/samples/ProfilePictureSample/res/layout/activity_profile_picture_sample.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <fragment xmlns:android="http://schemas.android.com/apk/res/android"
           android:id="@+id/profilePictureSampleFragment"
           android:layout_width="match_parent"
diff --git a/samples/ProfilePictureSample/res/layout/fragment_profile_picture_sample.xml b/samples/ProfilePictureSample/res/layout/fragment_profile_picture_sample.xml
index 9fabb4c83..8735c788a 100644
--- a/samples/ProfilePictureSample/res/layout/fragment_profile_picture_sample.xml
+++ b/samples/ProfilePictureSample/res/layout/fragment_profile_picture_sample.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
             xmlns:app="http://schemas.android.com/apk/res-auto"
         android:layout_width="match_parent"
@@ -77,12 +93,13 @@
             android:layout_marginTop="10dp"
             android:layout_marginBottom="10dp"
             >
-        <com.facebook.ProfilePictureView
+        <com.facebook.widget.ProfilePictureView
                 android:id="@+id/profilepic"
                 android:layout_height="wrap_content"
                 android:layout_width="0dp"
                 android:layout_weight="1"
                 app:preset_size="large"
+                app:is_cropped="true"
                 />
         <LinearLayout
                 android:id="@+id/userbuttoncontainer"
diff --git a/samples/ProfilePictureSample/res/values/strings.xml b/samples/ProfilePictureSample/res/values/strings.xml
index cb5d00d89..a9b3c10d5 100644
--- a/samples/ProfilePictureSample/res/values/strings.xml
+++ b/samples/ProfilePictureSample/res/values/strings.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <string name="app_name">ProfilePictureSample</string>
     <string name="description">Sample app demonstrating the use of ProfilePictureView</string>
diff --git a/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleActivity.java b/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleActivity.java
index 217c55afc..9b35d3e21 100644
--- a/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleActivity.java
+++ b/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleActivity.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.samples.profilepicture;
 
 import android.os.Bundle;
diff --git a/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleFragment.java b/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleFragment.java
index 467c5decd..1efec3fb5 100644
--- a/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleFragment.java
+++ b/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleFragment.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.samples.profilepicture;
 
 import android.os.Bundle;
@@ -6,7 +22,7 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.*;
-import com.facebook.ProfilePictureView;
+import com.facebook.widget.ProfilePictureView;
 
 import java.util.Date;
 import java.util.Random;
@@ -78,19 +94,19 @@
 
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {
-        View v = inflater.inflate(R.layout.fragment_profile_picture_sample, parent, false);
+        View fragmentView = inflater.inflate(R.layout.fragment_profile_picture_sample, parent, false);
 
         randomGenerator = new Random((new Date()).getTime());
 
-        profilePic = (ProfilePictureView)v.findViewById(R.id.profilepic);
-        smallerButton = (Button)v.findViewById(R.id.smallerButton);
-        largerButton = (Button)v.findViewById(R.id.largerButton);
-        sizeLabel = (TextView)v.findViewById(R.id.sizeLabel);
-        presetSizeView = v.findViewById(R.id.presetSizeView);
-        customSizeView = (SeekBar)v.findViewById(R.id.customSizeView);
-        cropToggle = (CheckBox)v.findViewById(R.id.squareCropToggle);
+        profilePic = (ProfilePictureView) fragmentView.findViewById(R.id.profilepic);
+        smallerButton = (Button) fragmentView.findViewById(R.id.smallerButton);
+        largerButton = (Button) fragmentView.findViewById(R.id.largerButton);
+        sizeLabel = (TextView) fragmentView.findViewById(R.id.sizeLabel);
+        presetSizeView = fragmentView.findViewById(R.id.presetSizeView);
+        customSizeView = (SeekBar) fragmentView.findViewById(R.id.customSizeView);
+        cropToggle = (CheckBox) fragmentView.findViewById(R.id.squareCropToggle);
 
-        LinearLayout container = (LinearLayout)v.findViewById(R.id.userbuttoncontainer);
+        LinearLayout container = (LinearLayout) fragmentView.findViewById(R.id.userbuttoncontainer);
         int numChildren = container.getChildCount();
         for (int i = 0; i < numChildren; i++) {
             View childView = container.getChildAt(i);
@@ -111,7 +127,7 @@ public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
             }
         });
 
-        final Button sizeToggle = (Button)v.findViewById(R.id.sizeToggle);
+        final Button sizeToggle = (Button) fragmentView.findViewById(R.id.sizeToggle);
         sizeToggle.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View view) {
@@ -176,7 +192,7 @@ public void onStopTrackingTouch(SeekBar seekBar) {
 
         restoreState(savedInstanceState);
 
-        return v;
+        return fragmentView;
     }
 
     @Override
@@ -208,7 +224,7 @@ private void restoreState(Bundle savedInstanceState) {
             profilePic.setCropped(cropToggle.isChecked());
 
             // Setting userId last so that only one network request is sent
-            profilePic.setUserId(firstUserId);
+            profilePic.setProfileId(firstUserId);
         }
     }
 
@@ -224,7 +240,7 @@ public void onClick(View v) {
                     // Random id.
                     userId = INTERESTING_IDS[randomGenerator.nextInt(INTERESTING_IDS.length)];
                 }
-                profilePic.setUserId(userId);
+                profilePic.setProfileId(userId);
             }
         });
     }
diff --git a/samples/Scrumptious/AndroidManifest.xml b/samples/Scrumptious/AndroidManifest.xml
index e5db50d58..ac9de56bc 100644
--- a/samples/Scrumptious/AndroidManifest.xml
+++ b/samples/Scrumptious/AndroidManifest.xml
@@ -22,6 +22,7 @@
         <activity android:name="PickerActivity"
                   android:label="@string/app_name" />
         <activity android:name="com.facebook.LoginActivity"
+                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
                   android:label="@string/app_name" />
         <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
     </application>
diff --git a/samples/Scrumptious/Scrumptious.iml b/samples/Scrumptious/Scrumptious.iml
index 549243369..e7d82c334 100644
--- a/samples/Scrumptious/Scrumptious.iml
+++ b/samples/Scrumptious/Scrumptious.iml
@@ -27,6 +27,7 @@
           <path>/res-overlay</path>
         </resOverlayFolders>
         <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
         <additionalNativeLibs />
       </configuration>
     </facet>
diff --git a/samples/Scrumptious/ant.properties b/samples/Scrumptious/ant.properties
index b0971e891..939105d52 100644
--- a/samples/Scrumptious/ant.properties
+++ b/samples/Scrumptious/ant.properties
@@ -15,3 +15,4 @@
 #  'key.alias' for the name of the key to use.
 # The password will be asked during the build when you use the 'release' target.
 
+java.compilerargs=-Xlint -Werror
diff --git a/samples/Scrumptious/res/drawable/button_border.xml b/samples/Scrumptious/res/drawable/button_border.xml
index 76e080b14..96c32725f 100644
--- a/samples/Scrumptious/res/drawable/button_border.xml
+++ b/samples/Scrumptious/res/drawable/button_border.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 
 <shape xmlns:android="http://schemas.android.com/apk/res/android"
        android:shape="rectangle">
@@ -6,4 +21,4 @@
     <corners android:radius="10dp" />
     <padding android:bottom="10dp" android:left="10dp" android:right="10dp" android:top="10dp" />
     <stroke android:width="1px" android:color="#222" />
-</shape>
\ No newline at end of file
+</shape>
diff --git a/samples/Scrumptious/res/layout/listitem.xml b/samples/Scrumptious/res/layout/listitem.xml
index 01f3480a2..2aa461efe 100644
--- a/samples/Scrumptious/res/layout/listitem.xml
+++ b/samples/Scrumptious/res/layout/listitem.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
               android:layout_width="fill_parent"
@@ -32,4 +47,4 @@
                 android:layout_height="wrap_content"
                 android:textSize="14sp" />
     </LinearLayout>
-</LinearLayout>
\ No newline at end of file
+</LinearLayout>
diff --git a/samples/Scrumptious/res/layout/main.xml b/samples/Scrumptious/res/layout/main.xml
index 6d772e5f3..9c93f3521 100644
--- a/samples/Scrumptious/res/layout/main.xml
+++ b/samples/Scrumptious/res/layout/main.xml
@@ -1,13 +1,37 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout
         xmlns:android="http://schemas.android.com/apk/res/android"
         android:orientation="vertical"
         android:layout_width="fill_parent"
         android:layout_height="fill_parent">
-    <FrameLayout
-            android:id="@+id/body_frame"
-            android:layout_height="fill_parent"
-            android:layout_width="fill_parent"
-            android:layout_weight="1" />
+
+    <fragment android:name="com.facebook.scrumptious.SelectionFragment"
+              android:id="@+id/selectionFragment"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent" />
+    <fragment android:name="com.facebook.scrumptious.SplashFragment"
+              android:id="@+id/splashFragment"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent" />
+    <fragment android:name="com.facebook.widget.UserSettingsFragment"
+              android:id="@+id/userSettingsFragment"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent" />
 </LinearLayout>
 
diff --git a/samples/Scrumptious/res/layout/pickers.xml b/samples/Scrumptious/res/layout/pickers.xml
index 3f5c01221..137b5cbbe 100644
--- a/samples/Scrumptious/res/layout/pickers.xml
+++ b/samples/Scrumptious/res/layout/pickers.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
               android:orientation="vertical"
               android:layout_width="fill_parent"
diff --git a/samples/Scrumptious/res/layout/selection.xml b/samples/Scrumptious/res/layout/selection.xml
index 2a298921b..2d849837e 100644
--- a/samples/Scrumptious/res/layout/selection.xml
+++ b/samples/Scrumptious/res/layout/selection.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 
 <ScrollView
         xmlns:android="http://schemas.android.com/apk/res/android"
@@ -17,7 +32,7 @@
             android:layout_marginTop="20dp"
             android:gravity="center_horizontal"
             android:orientation="horizontal" >
-            <com.facebook.ProfilePictureView
+            <com.facebook.widget.ProfilePictureView
                 android:id="@+id/selection_profile_pic"
                 android:layout_height="wrap_content"
                 android:layout_width="wrap_content"
@@ -53,4 +68,4 @@
             android:gravity="center" />
 
     </LinearLayout>
-</ScrollView>
\ No newline at end of file
+</ScrollView>
diff --git a/samples/Scrumptious/res/layout/splash.xml b/samples/Scrumptious/res/layout/splash.xml
index c7a853060..a9d43f639 100644
--- a/samples/Scrumptious/res/layout/splash.xml
+++ b/samples/Scrumptious/res/layout/splash.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 
 <ScrollView
     xmlns:android="http://schemas.android.com/apk/res/android"
@@ -49,7 +64,7 @@
             android:layout_gravity="center_horizontal"
             android:gravity="center_horizontal"/>
 
-        <com.facebook.LoginButton
+        <com.facebook.widget.LoginButton
             android:id="@+id/login_button"
             android:layout_width="wrap_content"
             android:layout_height="wrap_content"
diff --git a/samples/Scrumptious/res/values/strings.xml b/samples/Scrumptious/res/values/strings.xml
index 3978898a4..bd35bc311 100644
--- a/samples/Scrumptious/res/values/strings.xml
+++ b/samples/Scrumptious/res/values/strings.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <string name="app_name">Scrumptious</string>
     <string name="app_id">233936543368280</string>
@@ -6,8 +22,8 @@
     <string name="action_eating">What are you eating?</string>
     <string name="action_location">Where are you?</string>
     <string name="action_people">With whom?</string>
-    <string name="action_eating_default">Select one</string>
-    <string name="action_location_default">Select one</string>
+    <string name="action_eating_default">Select a meal</string>
+    <string name="action_location_default">Select a place</string>
     <string name="action_people_default">Select friends</string>
     <string name="announce">Announce</string>
     <string name="login">Login</string>
@@ -22,8 +38,15 @@
     <string name="multiple_users_selected">%1$s and %2$s others</string>
     <string name="error_dialog_title">Error</string>
     <string name="error_dialog_button_text">OK</string>
+    <string name="error_dialog_default_text">No response from server.</string>
     <string name="no_location_error">Could not obtain your current location</string>
     <string name="select_picture">Select Picture</string>
+    <string name="error_authentication_retry">An error occurred that requires your attention. %1$s</string>
+    <string name="error_authentication_reopen">An error occurred, please re-login.</string>
+    <string name="error_permission">Please allow us to post on your behalf.</string>
+    <string name="error_server">The server is busy, please retry later.</string>
+    <string name="error_bad_request">An error occurred, please contact the developer with the following message: %1$s</string>
+    <string name="error_unknown">An unknown error occurred, please contact the developer with the following message: %1$s</string>
 
     <string-array name="food_types">
         <item>Cheeseburger</item>
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/BaseListElement.java b/samples/Scrumptious/src/com/facebook/scrumptious/BaseListElement.java
index 1a833e349..13de99f44 100644
--- a/samples/Scrumptious/src/com/facebook/scrumptious/BaseListElement.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/BaseListElement.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.scrumptious;
 
 import android.content.Intent;
@@ -5,7 +21,7 @@
 import android.os.Bundle;
 import android.view.View;
 import android.widget.BaseAdapter;
-import com.facebook.OpenGraphAction;
+import com.facebook.model.OpenGraphAction;
 
 /**
  * Base class for a list element in the Scrumptious main display, consisting of an
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/FullListView.java b/samples/Scrumptious/src/com/facebook/scrumptious/FullListView.java
index 84908cfe9..a210f09fb 100644
--- a/samples/Scrumptious/src/com/facebook/scrumptious/FullListView.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/FullListView.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.scrumptious;
 
 import android.content.Context;
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/MainActivity.java b/samples/Scrumptious/src/com/facebook/scrumptious/MainActivity.java
index 849e82860..a9934df92 100644
--- a/samples/Scrumptious/src/com/facebook/scrumptious/MainActivity.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/MainActivity.java
@@ -1,91 +1,122 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.scrumptious;
 
+import android.content.Intent;
 import android.os.Bundle;
 import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
 import android.support.v4.app.FragmentTransaction;
-import android.util.Log;
 import android.view.Menu;
 import android.view.MenuItem;
-import com.facebook.FacebookActivity;
-import com.facebook.LoginFragment;
 import com.facebook.Session;
 import com.facebook.SessionState;
+import com.facebook.UiLifecycleHelper;
 
-public class MainActivity extends FacebookActivity {
+public class MainActivity extends FragmentActivity {
 
     private static final int SPLASH = 0;
     private static final int SELECTION = 1;
     private static final int SETTINGS = 2;
     private static final int FRAGMENT_COUNT = SETTINGS +1;
-    private static final String FRAGMENT_PREFIX = "fragment";
-    private static final String TAG = "Scrumplicious";
 
     private Fragment[] fragments = new Fragment[FRAGMENT_COUNT];
     private MenuItem settings;
-    private boolean restoredFragment = false;
     private boolean isResumed = false;
+    private UiLifecycleHelper uiHelper;
+    private Session.StatusCallback callback = new Session.StatusCallback() {
+        @Override
+        public void call(Session session, SessionState state, Exception exception) {
+            onSessionStateChange(session, state, exception);
+        }
+    };
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
+
+        uiHelper = new UiLifecycleHelper(this, callback);
+        uiHelper.onCreate(savedInstanceState);
+
         setContentView(R.layout.main);
 
+        FragmentManager fm = getSupportFragmentManager();
+        fragments[SPLASH] = fm.findFragmentById(R.id.splashFragment);
+        fragments[SELECTION] = fm.findFragmentById(R.id.selectionFragment);
+        fragments[SETTINGS] = fm.findFragmentById(R.id.userSettingsFragment);
+
+        FragmentTransaction transaction = fm.beginTransaction();
         for(int i = 0; i < fragments.length; i++) {
-            restoreFragment(savedInstanceState, i);
+            transaction.hide(fragments[i]);
         }
+        transaction.commit();
     }
 
     @Override
     public void onResume() {
         super.onResume();
+        uiHelper.onResume();
         isResumed = true;
     }
 
     @Override
     public void onPause() {
         super.onPause();
+        uiHelper.onPause();
         isResumed = false;
     }
 
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        uiHelper.onActivityResult(requestCode, resultCode, data);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        uiHelper.onDestroy();
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        uiHelper.onSaveInstanceState(outState);
+    }
+
     @Override
     protected void onResumeFragments() {
         super.onResumeFragments();
         Session session = Session.getActiveSession();
-        if (session == null || session.getState().isClosed()) {
-            session = new Session(this);
-            Session.setActiveSession(session);
-        }
-
-        FragmentManager manager = getSupportFragmentManager();
-
-        if (restoredFragment) {
-            return;
-        }
 
-        // If we already have a valid token, then we can just open the session silently,
-        // otherwise present the splash screen and ask the user to login.
-        if (session.getState().equals(SessionState.CREATED_TOKEN_LOADED)) {
-            // no need to add any fragments here since it will be handled in onSessionStateChange
-            session.openForRead(this);
-        } else if (session.isOpened()) {
+        if (session != null && session.isOpened()) {
             // if the session is already open, try to show the selection fragment
-            Fragment fragment = manager.findFragmentById(R.id.body_frame);
-            if (!(fragment instanceof SelectionFragment)) {
-                manager.beginTransaction().replace(R.id.body_frame, fragments[SELECTION]).commit();
-            }
+            showFragment(SELECTION, false);
         } else {
-            FragmentTransaction transaction = manager.beginTransaction();
-            transaction.replace(R.id.body_frame, fragments[SPLASH]).commit();
+            // otherwise present the splash screen and ask the user to login.
+            showFragment(SPLASH, false);
         }
     }
 
     @Override
     public boolean onPrepareOptionsMenu(Menu menu) {
-        FragmentManager manager = getSupportFragmentManager();
-        Fragment currentFragment = manager.findFragmentById(R.id.body_frame);
         // only add the menu when the selection fragment is showing
-        if (currentFragment == fragments[SELECTION]) {
+        if (fragments[SELECTION].isVisible()) {
             if (menu.size() == 0) {
                 settings = menu.add(R.string.settings);
             }
@@ -100,90 +131,42 @@ public boolean onPrepareOptionsMenu(Menu menu) {
     @Override
     public boolean onOptionsItemSelected(MenuItem item) {
         if (item.equals(settings)) {
-            FragmentManager manager = getSupportFragmentManager();
-            FragmentTransaction transaction = manager.beginTransaction();
-            transaction.add(R.id.body_frame, fragments[SETTINGS]).addToBackStack(null).commit();
+            showFragment(SETTINGS, true);
             return true;
         }
         return false;
     }
 
-    @Override
-    protected void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        FragmentManager manager = getSupportFragmentManager();
-        // Since we're only adding one Fragment at a time, we can only save one.
-        Fragment f = manager.findFragmentById(R.id.body_frame);
-        for (int i = 0; i < fragments.length; i++) {
-            if (fragments[i] == f) {
-                manager.putFragment(outState, getBundleKey(i), fragments[i]);
-            }
-        }
-    }
-
-    @Override
-    protected void onSessionStateChange(SessionState state, Exception exception) {
+    private void onSessionStateChange(Session session, SessionState state, Exception exception) {
         if (isResumed) {
             FragmentManager manager = getSupportFragmentManager();
             int backStackSize = manager.getBackStackEntryCount();
             for (int i = 0; i < backStackSize; i++) {
                 manager.popBackStack();
             }
-            if (state.isOpened()) {
-                if (state.equals(SessionState.OPENED_TOKEN_UPDATED)) {
-                    ((SelectionFragment) fragments[SELECTION]).tokenUpdated();
-                } else {
-                    FragmentTransaction transaction = manager.beginTransaction();
-                    transaction.replace(R.id.body_frame, fragments[SELECTION]).commit();
-                }
+            // check for the OPENED state instead of session.isOpened() since for the
+            // OPENED_TOKEN_UPDATED state, the selection fragment should already be showing.
+            if (state.equals(SessionState.OPENED)) {
+                showFragment(SELECTION, false);
             } else if (state.isClosed()) {
-                FragmentTransaction transaction = manager.beginTransaction();
-                transaction.replace(R.id.body_frame, fragments[SPLASH]).commit();
+                showFragment(SPLASH, false);
             }
         }
     }
 
-    /**
-     * Returns the key to be used when saving a Fragment to a Bundle.
-     * @param index the index of the Fragment in the fragments array
-     * @return the key to be used
-     */
-    private String getBundleKey(int index) {
-        return FRAGMENT_PREFIX + Integer.toString(index);
-    }
-
-    /**
-     * Restore fragments from the bundle. If a necessary Fragment cannot be found in the bundle,
-     * a new instance will be created.
-     *
-     * @param savedInstanceState
-     * @param fragmentIndex
-     */
-    private void restoreFragment(Bundle savedInstanceState, int fragmentIndex) {
-        Fragment fragment = null;
-        if (savedInstanceState != null) {
-            FragmentManager manager = getSupportFragmentManager();
-            fragment = manager.getFragment(savedInstanceState, getBundleKey(fragmentIndex));
-        }
-        if (fragment != null) {
-            fragments[fragmentIndex] = fragment;
-            restoredFragment = true;
-        } else {
-            switch (fragmentIndex) {
-                case SPLASH:
-                    fragments[SPLASH] = new SplashFragment();
-                    break;
-                case SELECTION:
-                    fragments[SELECTION] = new SelectionFragment();
-                    break;
-                case SETTINGS:
-                    fragments[SETTINGS] = new LoginFragment();
-                    break;
-                default:
-                    Log.w(TAG, "invalid fragment index");
-                    break;
+    private void showFragment(int fragmentIndex, boolean addToBackStack) {
+        FragmentManager fm = getSupportFragmentManager();
+        FragmentTransaction transaction = fm.beginTransaction();
+        for (int i = 0; i < fragments.length; i++) {
+            if (i == fragmentIndex) {
+                transaction.show(fragments[i]);
+            } else {
+                transaction.hide(fragments[i]);
             }
         }
+        if (addToBackStack) {
+            transaction.addToBackStack(null);
+        }
+        transaction.commit();
     }
-
 }
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/PickerActivity.java b/samples/Scrumptious/src/com/facebook/scrumptious/PickerActivity.java
index 152ed375f..41a81894e 100644
--- a/samples/Scrumptious/src/com/facebook/scrumptious/PickerActivity.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/PickerActivity.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.scrumptious;
 
 import android.app.AlertDialog;
@@ -15,9 +31,9 @@
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
 import com.facebook.FacebookException;
-import com.facebook.FriendPickerFragment;
-import com.facebook.PickerFragment;
-import com.facebook.PlacePickerFragment;
+import com.facebook.widget.FriendPickerFragment;
+import com.facebook.widget.PickerFragment;
+import com.facebook.widget.PlacePickerFragment;
 
 /**
  * The PickerActivity enhances the Friend or Place Picker by adding a title
@@ -30,7 +46,7 @@
 
     private static final int SEARCH_RADIUS_METERS = 1000;
     private static final int SEARCH_RESULT_LIMIT = 50;
-    private static final String SEARCH_TEXT = "restaurant";
+    private static final String SEARCH_TEXT = "Restaurant";
     private static final int LOCATION_CHANGE_THRESHOLD = 50; // meters
 
     private static final Location SAN_FRANCISCO_LOCATION = new Location("") {{
@@ -61,13 +77,13 @@ public void onCreate(Bundle savedInstanceState) {
 
             friendPickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
                 @Override
-                public void onError(FacebookException error) {
+                public void onError(PickerFragment<?> fragment, FacebookException error) {
                     PickerActivity.this.onError(error);
                 }
             });
             friendPickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
                 @Override
-                public void onDoneButtonClicked() {
+                public void onDoneButtonClicked(PickerFragment<?> fragment) {
                     finishActivity();
                 }
             });
@@ -81,19 +97,19 @@ public void onDoneButtonClicked() {
             }
             placePickerFragment.setOnSelectionChangedListener(new PickerFragment.OnSelectionChangedListener() {
                 @Override
-                public void onSelectionChanged() {
+                public void onSelectionChanged(PickerFragment<?> fragment) {
                     finishActivity(); // call finish since you can only pick one place
                 }
             });
             placePickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
                 @Override
-                public void onError(FacebookException error) {
+                public void onError(PickerFragment<?> fragment, FacebookException error) {
                     PickerActivity.this.onError(error);
                 }
             });
             placePickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
                 @Override
-                public void onDoneButtonClicked() {
+                public void onDoneButtonClicked(PickerFragment<?> fragment) {
                     finishActivity();
                 }
             });
@@ -161,7 +177,7 @@ public void onProviderDisabled(String s) {
                     placePickerFragment.setRadiusInMeters(SEARCH_RADIUS_METERS);
                     placePickerFragment.setSearchText(SEARCH_TEXT);
                     placePickerFragment.setResultsLimit(SEARCH_RESULT_LIMIT);
-                    placePickerFragment.loadData(true);
+                    placePickerFragment.loadData(false);
                 } else {
                     onError(getResources().getString(R.string.no_location_error), true);
                 }
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/ScrumptiousApplication.java b/samples/Scrumptious/src/com/facebook/scrumptious/ScrumptiousApplication.java
index 5b7ae55cb..79e5857b0 100644
--- a/samples/Scrumptious/src/com/facebook/scrumptious/ScrumptiousApplication.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/ScrumptiousApplication.java
@@ -1,8 +1,24 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.scrumptious;
 
 import android.app.Application;
-import com.facebook.GraphPlace;
-import com.facebook.GraphUser;
+import com.facebook.model.GraphPlace;
+import com.facebook.model.GraphUser;
 
 import java.util.List;
 
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/SelectionFragment.java b/samples/Scrumptious/src/com/facebook/scrumptious/SelectionFragment.java
index f1afe0bd0..2a9b43672 100644
--- a/samples/Scrumptious/src/com/facebook/scrumptious/SelectionFragment.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/SelectionFragment.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.scrumptious;
 
 import android.app.Activity;
@@ -16,6 +32,8 @@
 import android.view.ViewGroup;
 import android.widget.*;
 import com.facebook.*;
+import com.facebook.model.*;
+import com.facebook.widget.ProfilePictureView;
 import org.json.JSONException;
 import org.json.JSONObject;
 
@@ -32,6 +50,7 @@
     private static final String TAG = "SelectionFragment";
     private static final String POST_ACTION_PATH = "me/fb_sample_scrumps:eat";
     private static final String PENDING_ANNOUNCE_KEY = "pendingAnnounce";
+    private static final Uri M_FACEBOOK_URL = Uri.parse("http://m.facebook.com");
 
     private static final int REAUTH_ACTIVITY_CODE = 100;
     private static final List<String> PERMISSIONS = Arrays.asList("publish_actions");
@@ -44,6 +63,27 @@
     private TextView userNameView;
     private boolean pendingAnnounce;
 
+    private UiLifecycleHelper uiHelper;
+    private Session.StatusCallback callback = new Session.StatusCallback() {
+        @Override
+        public void call(final Session session, final SessionState state, final Exception exception) {
+            onSessionStateChange(session, state, exception);
+        }
+    };
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        uiHelper = new UiLifecycleHelper(getActivity(), callback);
+        uiHelper.onCreate(savedInstanceState);
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        uiHelper.onResume();
+    }
+
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
         super.onCreateView(inflater, container, savedInstanceState);
@@ -63,21 +103,6 @@ public void onClick(View view) {
         });
         init(savedInstanceState);
 
-        final Session session = Session.getActiveSession();
-        if (session != null && session.isOpened()) {
-            Request request = Request.newMeRequest(session, new Request.GraphUserCallback() {
-                @Override
-                public void onCompleted(GraphUser user, Response response) {
-                    if (session == Session.getActiveSession()) {
-                        if (user != null) {
-                            profilePictureView.setUserId(user.getId());
-                            userNameView.setText(user.getName());
-                        }
-                    }
-                }
-            });
-            Request.executeBatchAsync(request);
-        }
         return view;
     }
 
@@ -85,7 +110,7 @@ public void onCompleted(GraphUser user, Response response) {
     public void onActivityResult(int requestCode, int resultCode, Intent data) {
         super.onActivityResult(requestCode, resultCode, data);
         if (requestCode == REAUTH_ACTIVITY_CODE) {
-            Session.getActiveSession().onActivityResult(getActivity(), requestCode, resultCode, data);
+            uiHelper.onActivityResult(requestCode, resultCode, data);
         } else if (resultCode == Activity.RESULT_OK && requestCode >= 0 && requestCode < listElements.size()) {
             listElements.get(requestCode).onActivityResult(data);
         }
@@ -98,17 +123,59 @@ public void onSaveInstanceState(Bundle bundle) {
             listElement.onSaveInstanceState(bundle);
         }
         bundle.putBoolean(PENDING_ANNOUNCE_KEY, pendingAnnounce);
+        uiHelper.onSaveInstanceState(bundle);
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        uiHelper.onPause();
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        uiHelper.onDestroy();
     }
 
     /**
      * Notifies that the session token has been updated.
      */
-    public void tokenUpdated() {
+    private void tokenUpdated() {
         if (pendingAnnounce) {
             handleAnnounce();
         }
     }
 
+    private void onSessionStateChange(final Session session, SessionState state, Exception exception) {
+        if (session != null && session.isOpened()) {
+            if (state.equals(SessionState.OPENED_TOKEN_UPDATED)) {
+                tokenUpdated();
+            } else {
+                makeMeRequest(session);
+            }
+        }
+    }
+
+    private void makeMeRequest(final Session session) {
+        Request request = Request.newMeRequest(session, new Request.GraphUserCallback() {
+            @Override
+            public void onCompleted(GraphUser user, Response response) {
+                if (session == Session.getActiveSession()) {
+                    if (user != null) {
+                        profilePictureView.setProfileId(user.getId());
+                        userNameView.setText(user.getName());
+                    }
+                }
+                if (response.getError() != null) {
+                    handleError(response.getError());
+                }
+            }
+        });
+        request.executeAsync();
+
+    }
+
     /**
      * Resets the view to the initial defaults.
      */
@@ -129,6 +196,11 @@ private void init(Bundle savedInstanceState) {
         }
 
         listView.setAdapter(new ActionListAdapter(getActivity(), R.id.selection_list, listElements));
+
+        Session session = Session.getActiveSession();
+        if (session != null && session.isOpened()) {
+            makeMeRequest(session);
+        }
     }
 
     private void handleAnnounce() {
@@ -142,9 +214,7 @@ private void handleAnnounce() {
         List<String> permissions = session.getPermissions();
         if (!permissions.containsAll(PERMISSIONS)) {
             pendingAnnounce = true;
-            Session.ReauthorizeRequest reauthRequest = new Session.ReauthorizeRequest(this, PERMISSIONS).
-                    setRequestCode(REAUTH_ACTIVITY_CODE);
-            session.reauthorizeForPublish(reauthRequest);
+            requestPublishPermissions(session);
             return;
         }
 
@@ -158,7 +228,7 @@ private void handleAnnounce() {
 
             @Override
             protected Response doInBackground(Void... voids) {
-                EatAction eatAction = GraphObjectWrapper.createGraphObject(EatAction.class);
+                EatAction eatAction = GraphObject.Factory.create(EatAction.class);
                 for (BaseListElement element : listElements) {
                     element.populateOGAction(eatAction);
                 }
@@ -177,47 +247,123 @@ protected void onPostExecute(Response response) {
         task.execute();
     }
 
+    private void requestPublishPermissions(Session session) {
+        if (session != null) {
+            Session.NewPermissionsRequest newPermissionsRequest = new Session.NewPermissionsRequest(this, PERMISSIONS)
+                    // demonstrate how to set an audience for the publish permissions,
+                    // if none are set, this defaults to FRIENDS
+                    .setDefaultAudience(SessionDefaultAudience.FRIENDS)
+                    .setRequestCode(REAUTH_ACTIVITY_CODE);
+            session.requestNewPublishPermissions(newPermissionsRequest);
+        }
+    }
+
     private void onPostActionResponse(Response response) {
         if (progressDialog != null) {
             progressDialog.dismiss();
             progressDialog = null;
         }
-        String id = getIdFromResponseOrShowError(response);
-        if (id != null) {
-            String dialogBody = String.format(getActivity().getResources().getString(R.string.result_dialog_text), id);
-            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
-            builder.setPositiveButton(R.string.result_dialog_button_text, null).
-                    setTitle(R.string.result_dialog_title).setMessage(dialogBody);
-            builder.show();
+        if (getActivity() == null) {
+            // if the user removes the app from the website, then a request will
+            // have caused the session to close (since the token is no longer valid),
+            // which means the splash fragment will be shown rather than this one,
+            // causing activity to be null. If the activity is null, then we cannot
+            // show any dialogs, so we return.
+            return;
         }
-        init(null);
-    }
 
-    private String getIdFromResponseOrShowError(Response response) {
         PostResponse postResponse = response.getGraphObjectAs(PostResponse.class);
 
-        String id = null;
-        PostResponse.Body body = null;
-        if (postResponse != null) {
-            id = postResponse.getId();
-            body = postResponse.getBody();
+        if (postResponse != null && postResponse.getId() != null) {
+            String dialogBody = String.format(getString(R.string.result_dialog_text), postResponse.getId());
+            new AlertDialog.Builder(getActivity())
+                    .setPositiveButton(R.string.result_dialog_button_text, null)
+                    .setTitle(R.string.result_dialog_title)
+                    .setMessage(dialogBody)
+                    .show();
+            init(null);
+        } else {
+            handleError(response.getError());
         }
+    }
 
-        String dialogBody = "";
+    private void handleError(FacebookRequestError error) {
+        DialogInterface.OnClickListener listener = null;
+        String dialogBody = null;
+
+        if (error == null) {
+            dialogBody = getString(R.string.error_dialog_default_text);
+        } else {
+            switch (error.getCategory()) {
+                case AUTHENTICATION_RETRY:
+                    // tell the user what happened by getting the message id, and
+                    // retry the operation later
+                    String userAction = (error.shouldNotifyUser()) ? "" :
+                            getString(error.getUserActionMessageId());
+                    dialogBody = getString(R.string.error_authentication_retry, userAction);
+                    listener = new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialogInterface, int i) {
+                            Intent intent = new Intent(Intent.ACTION_VIEW, M_FACEBOOK_URL);
+                            startActivity(intent);
+                        }
+                    };
+                    break;
+
+                case AUTHENTICATION_REOPEN_SESSION:
+                    // close the session and reopen it.
+                    dialogBody = getString(R.string.error_authentication_reopen);
+                    listener = new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialogInterface, int i) {
+                            Session session = Session.getActiveSession();
+                            if (session != null && !session.isClosed()) {
+                                session.closeAndClearTokenInformation();
+                            }
+                        }
+                    };
+                    break;
 
-        if (body != null && body.getError() != null) {
-            dialogBody = body.getError().getMessage();
-        } else if (response.getError() != null) {
-            dialogBody = response.getError().getLocalizedMessage();
-        } else if (id != null) {
-            return id;
+                case PERMISSION:
+                    // request the publish permission
+                    dialogBody = getString(R.string.error_permission);
+                    listener = new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialogInterface, int i) {
+                            pendingAnnounce = true;
+                            requestPublishPermissions(Session.getActiveSession());
+                        }
+                    };
+                    break;
+
+                case SERVER:
+                case THROTTLING:
+                    // this is usually temporary, don't clear the fields, and
+                    // ask the user to try again
+                    dialogBody = getString(R.string.error_server);
+                    break;
+
+                case BAD_REQUEST:
+                    // this is likely a coding error, ask the user to file a bug
+                    dialogBody = getString(R.string.error_bad_request, error.getErrorMessage());
+                    break;
+
+                case OTHER:
+                case CLIENT:
+                default:
+                    // an unknown issue occurred, this could be a code error, or
+                    // a server side issue, log the issue, and either ask the
+                    // user to retry, or file a bug
+                    dialogBody = getString(R.string.error_unknown, error.getErrorMessage());
+                    break;
+            }
         }
 
-        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
-        builder.setPositiveButton(R.string.error_dialog_button_text, null).
-                setTitle(R.string.error_dialog_title).setMessage(dialogBody);
-        builder.show();
-        return null;
+        new AlertDialog.Builder(getActivity())
+                .setPositiveButton(R.string.error_dialog_button_text, listener)
+                .setTitle(R.string.error_dialog_title)
+                .setMessage(dialogBody)
+                .show();
     }
 
     private void startPickerActivity(Uri data, int requestCode) {
@@ -250,17 +396,7 @@ private void startPickerActivity(Uri data, int requestCode) {
      * Used to inspect the response from posting an action
      */
     private interface PostResponse extends GraphObject {
-        Body getBody();
-
         String getId();
-
-        interface Body extends GraphObject {
-            Error getError();
-        }
-
-        interface Error extends GraphObject {
-            String getMessage();
-        }
     }
 
     private class EatListElement extends BaseListElement {
@@ -296,7 +432,7 @@ public void onClick(View view) {
         protected void populateOGAction(OpenGraphAction action) {
             if (foodChoiceUrl != null) {
                 EatAction eatAction = action.cast(EatAction.class);
-                MealGraphObject meal = GraphObjectWrapper.createGraphObject(MealGraphObject.class);
+                MealGraphObject meal = GraphObject.Factory.create(MealGraphObject.class);
                 meal.setUrl(foodChoiceUrl);
                 eatAction.setMeal(meal);
             }
@@ -452,7 +588,8 @@ private void setUsersText() {
                 if (usersAsString != null) {
                     List<GraphUser> users = new ArrayList<GraphUser>(usersAsString.size());
                     for (String user : usersAsString) {
-                        GraphUser graphUser = GraphObjectWrapper.createGraphObject(new JSONObject(user), GraphUser.class);
+                        GraphUser graphUser = GraphObject.Factory
+                                .create(new JSONObject(user), GraphUser.class);
                         users.add(graphUser);
                     }
                     return users;
@@ -517,7 +654,8 @@ protected boolean restoreState(Bundle savedState) {
             String place = savedState.getString(PLACE_KEY);
             if (place != null) {
                 try {
-                    selectedPlace = GraphObjectWrapper.createGraphObject(new JSONObject(place), GraphPlace.class);
+                    selectedPlace = GraphObject.Factory
+                            .create(new JSONObject(place), GraphPlace.class);
                     setPlaceText();
                     return true;
                 } catch (JSONException e) {
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/SplashFragment.java b/samples/Scrumptious/src/com/facebook/scrumptious/SplashFragment.java
index 520edc04d..d75436d49 100644
--- a/samples/Scrumptious/src/com/facebook/scrumptious/SplashFragment.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/SplashFragment.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.scrumptious;
 
 import android.os.Bundle;
diff --git a/samples/SessionLoginSample/AndroidManifest.xml b/samples/SessionLoginSample/AndroidManifest.xml
index dbef2c7ec..c1272829b 100644
--- a/samples/SessionLoginSample/AndroidManifest.xml
+++ b/samples/SessionLoginSample/AndroidManifest.xml
@@ -11,7 +11,7 @@
         android:icon="@drawable/icon"
         android:label="@string/app_name" >
         <activity
-            android:name="com.facebook.samples.sessionlogin.SessionLoginSampleActivity"
+            android:name=".SessionLoginSampleActivity"
             android:label="@string/app_name"
             android:windowSoftInputMode="adjustResize">
             <intent-filter>
@@ -20,9 +20,17 @@
                 <category android:name="android.intent.category.LAUNCHER" />
             </intent-filter>
         </activity>
+        <activity
+                android:name=".LoginUsingActivityActivity">
+        </activity>
+        <activity
+                android:name=".LoginUsingCustomFragmentActivity">
+        </activity>
         <activity android:name="com.facebook.LoginActivity"
+                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
                   android:label="@string/app_name" />
+        <activity android:name=".LoginUsingLoginFragmentActivity"/>
         <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/applicationId" />
     </application>
 
-</manifest>
\ No newline at end of file
+</manifest>
diff --git a/samples/SessionLoginSample/SessionLoginSample.iml b/samples/SessionLoginSample/SessionLoginSample.iml
index bca109a37..4aac86509 100644
--- a/samples/SessionLoginSample/SessionLoginSample.iml
+++ b/samples/SessionLoginSample/SessionLoginSample.iml
@@ -27,6 +27,7 @@
           <path>/res-overlay</path>
         </resOverlayFolders>
         <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
         <additionalNativeLibs />
       </configuration>
     </facet>
diff --git a/samples/SessionLoginSample/ant.properties b/samples/SessionLoginSample/ant.properties
index b0971e891..939105d52 100644
--- a/samples/SessionLoginSample/ant.properties
+++ b/samples/SessionLoginSample/ant.properties
@@ -15,3 +15,4 @@
 #  'key.alias' for the name of the key to use.
 # The password will be asked during the build when you use the 'release' target.
 
+java.compilerargs=-Xlint -Werror
diff --git a/samples/SessionLoginSample/res/layout/activity.xml b/samples/SessionLoginSample/res/layout/activity.xml
new file mode 100644
index 000000000..acc8c45c2
--- /dev/null
+++ b/samples/SessionLoginSample/res/layout/activity.xml
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:orientation="vertical" >
+
+    <TextView
+        android:id="@+id/instructionsOrLink"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:text="@string/instructions"
+        android:autoLink="web"
+        android:linksClickable="true"
+        android:textAppearance="?android:attr/textAppearanceMedium" />
+
+    <Button
+        android:id="@+id/buttonLoginLogout"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:text="@string/login" />
+
+</LinearLayout>
diff --git a/samples/SessionLoginSample/res/layout/custom_fragment_activity.xml b/samples/SessionLoginSample/res/layout/custom_fragment_activity.xml
new file mode 100644
index 000000000..c0be0bbd8
--- /dev/null
+++ b/samples/SessionLoginSample/res/layout/custom_fragment_activity.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:orientation="vertical" >
+
+    <fragment android:layout_height="fill_parent"
+              android:layout_width="fill_parent"
+              android:id="@+id/fragment"
+              android:name="com.facebook.samples.sessionlogin.SessionLoginFragment" />
+
+</LinearLayout>
diff --git a/samples/SessionLoginSample/res/layout/fragment.xml b/samples/SessionLoginSample/res/layout/fragment.xml
new file mode 100644
index 000000000..55da93ac9
--- /dev/null
+++ b/samples/SessionLoginSample/res/layout/fragment.xml
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+              android:orientation="vertical">
+
+<TextView
+            android:id="@+id/instructionsOrLink"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:text="@string/instructions"
+            android:autoLink="web"
+            android:linksClickable="true"
+            android:textAppearance="?android:attr/textAppearanceMedium" />
+
+    <Button
+            android:id="@+id/buttonLoginLogout"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:text="@string/login" />
+
+</LinearLayout>
diff --git a/samples/SessionLoginSample/res/layout/login_fragment_activity.xml b/samples/SessionLoginSample/res/layout/login_fragment_activity.xml
new file mode 100644
index 000000000..b7ce7ce30
--- /dev/null
+++ b/samples/SessionLoginSample/res/layout/login_fragment_activity.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent">
+
+    <fragment android:layout_height="fill_parent"
+              android:layout_width="fill_parent"
+              android:id="@+id/login_fragment"
+              android:name="com.facebook.widget.UserSettingsFragment" />
+
+</LinearLayout>
\ No newline at end of file
diff --git a/samples/SessionLoginSample/res/layout/main.xml b/samples/SessionLoginSample/res/layout/main.xml
index 799ff43ff..f5237dda5 100644
--- a/samples/SessionLoginSample/res/layout/main.xml
+++ b/samples/SessionLoginSample/res/layout/main.xml
@@ -1,22 +1,41 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="fill_parent"
     android:layout_height="fill_parent"
     android:orientation="vertical" >
 
-    <TextView
-        android:id="@+id/instructionsOrLink"
+    <Button
+        android:id="@+id/buttonLoginActivity"
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
-        android:text="@string/instructions"
-        android:autoLink="web"
-        android:linksClickable="true"
-        android:textAppearance="?android:attr/textAppearanceMedium" />
+        android:text="@string/login_using_activity" />
 
     <Button
-        android:id="@+id/buttonLoginLogout"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:text="@string/login" />
+            android:id="@+id/buttonLoginCustomFragment"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:text="@string/login_using_custom_fragment" />
+
+    <Button
+            android:id="@+id/buttonLoginFragment"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:text="@string/login_using_usersettingsfragment" />
 
-</LinearLayout>
\ No newline at end of file
+</LinearLayout>
diff --git a/samples/SessionLoginSample/res/values/strings.xml b/samples/SessionLoginSample/res/values/strings.xml
index ca3279893..a06061580 100644
--- a/samples/SessionLoginSample/res/values/strings.xml
+++ b/samples/SessionLoginSample/res/values/strings.xml
@@ -1,6 +1,25 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
 
+    <string name="login_using_activity">Login using Activity</string>
+    <string name="login_using_custom_fragment">Login using Custom Fragment</string>
+    <string name="login_using_usersettingsfragment">Login using UserSettingsFragment</string>
     <string name="hello">Hello World, SessionLoginSampleActivity!</string>
     <string name="app_name">SessionLoginSample</string>
     <string name="login">Login</string>
@@ -8,4 +27,4 @@
     <string name="logout">Log out</string>
     <string name="applicationId">380615018626574</string>
 
-</resources>
\ No newline at end of file
+</resources>
diff --git a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingActivityActivity.java b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingActivityActivity.java
new file mode 100644
index 000000000..8ac0884f5
--- /dev/null
+++ b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingActivityActivity.java
@@ -0,0 +1,128 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.sessionlogin;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.os.Bundle;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.widget.Button;
+import android.widget.TextView;
+import com.facebook.LoggingBehavior;
+import com.facebook.Session;
+import com.facebook.SessionState;
+import com.facebook.Settings;
+
+public class LoginUsingActivityActivity extends Activity {
+    private static final String URL_PREFIX_FRIENDS = "https://graph.facebook.com/me/friends?access_token=";
+
+    private TextView textInstructionsOrLink;
+    private Button buttonLoginLogout;
+    private Session.StatusCallback statusCallback = new SessionStatusCallback();
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity);
+        buttonLoginLogout = (Button)findViewById(R.id.buttonLoginLogout);
+        textInstructionsOrLink = (TextView)findViewById(R.id.instructionsOrLink);
+
+        Settings.addLoggingBehavior(LoggingBehavior.INCLUDE_ACCESS_TOKENS);
+
+        Session session = Session.getActiveSession();
+        if (session == null) {
+            if (savedInstanceState != null) {
+                session = Session.restoreSession(this, null, statusCallback, savedInstanceState);
+            }
+            if (session == null) {
+                session = new Session(this);
+            }
+            Session.setActiveSession(session);
+            if (session.getState().equals(SessionState.CREATED_TOKEN_LOADED)) {
+                session.openForRead(new Session.OpenRequest(this).setCallback(statusCallback));
+            }
+        }
+
+        updateView();
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        Session.getActiveSession().addCallback(statusCallback);
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+        Session.getActiveSession().removeCallback(statusCallback);
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        Session.getActiveSession().onActivityResult(this, requestCode, resultCode, data);
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        Session session = Session.getActiveSession();
+        Session.saveSession(session, outState);
+    }
+
+    private void updateView() {
+        Session session = Session.getActiveSession();
+        if (session.isOpened()) {
+            textInstructionsOrLink.setText(URL_PREFIX_FRIENDS + session.getAccessToken());
+            buttonLoginLogout.setText(R.string.logout);
+            buttonLoginLogout.setOnClickListener(new OnClickListener() {
+                public void onClick(View view) { onClickLogout(); }
+            });
+        } else {
+            textInstructionsOrLink.setText(R.string.instructions);
+            buttonLoginLogout.setText(R.string.login);
+            buttonLoginLogout.setOnClickListener(new OnClickListener() {
+                public void onClick(View view) { onClickLogin(); }
+            });
+        }
+    }
+
+    private void onClickLogin() {
+        Session session = Session.getActiveSession();
+        if (!session.isOpened() && !session.isClosed()) {
+            session.openForRead(new Session.OpenRequest(this).setCallback(statusCallback));
+        } else {
+            Session.openActiveSession(this, true, statusCallback);
+        }
+    }
+
+    private void onClickLogout() {
+        Session session = Session.getActiveSession();
+        if (!session.isClosed()) {
+            session.closeAndClearTokenInformation();
+        }
+    }
+
+    private class SessionStatusCallback implements Session.StatusCallback {
+        @Override
+        public void call(Session session, SessionState state, Exception exception) {
+            updateView();
+        }
+    }
+}
diff --git a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingCustomFragmentActivity.java b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingCustomFragmentActivity.java
new file mode 100644
index 000000000..4769dda32
--- /dev/null
+++ b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingCustomFragmentActivity.java
@@ -0,0 +1,28 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.sessionlogin;
+
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+
+public class LoginUsingCustomFragmentActivity extends FragmentActivity {
+
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.custom_fragment_activity);
+    }
+}
diff --git a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingLoginFragmentActivity.java b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingLoginFragmentActivity.java
new file mode 100644
index 000000000..ff20bf257
--- /dev/null
+++ b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingLoginFragmentActivity.java
@@ -0,0 +1,52 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.sessionlogin;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+import android.util.Log;
+import com.facebook.Session;
+import com.facebook.SessionState;
+import com.facebook.widget.UserSettingsFragment;
+
+public class LoginUsingLoginFragmentActivity extends FragmentActivity {
+    private UserSettingsFragment userSettingsFragment;
+
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        setContentView(R.layout.login_fragment_activity);
+
+        FragmentManager fragmentManager = getSupportFragmentManager();
+        userSettingsFragment = (UserSettingsFragment) fragmentManager.findFragmentById(R.id.login_fragment);
+        userSettingsFragment.setSessionStatusCallback(new Session.StatusCallback() {
+            @Override
+            public void call(Session session, SessionState state, Exception exception) {
+                Log.d("LoginUsingLoginFragmentActivity", String.format("New session state: %s", state.toString()));
+            }
+        });
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        userSettingsFragment.onActivityResult(requestCode, resultCode, data);
+        super.onActivityResult(requestCode, resultCode, data);
+    }
+
+}
\ No newline at end of file
diff --git a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginFragment.java b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginFragment.java
new file mode 100644
index 000000000..7f2164f7b
--- /dev/null
+++ b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginFragment.java
@@ -0,0 +1,131 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.sessionlogin;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.TextView;
+import com.facebook.LoggingBehavior;
+import com.facebook.Session;
+import com.facebook.SessionState;
+import com.facebook.Settings;
+
+public class SessionLoginFragment extends Fragment {
+    private static final String URL_PREFIX_FRIENDS = "https://graph.facebook.com/me/friends?access_token=";
+
+    private TextView textInstructionsOrLink;
+    private Button buttonLoginLogout;
+    private Session.StatusCallback statusCallback = new SessionStatusCallback();
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        View view = inflater.inflate(R.layout.fragment, container, false);
+
+        buttonLoginLogout = (Button) view.findViewById(R.id.buttonLoginLogout);
+        textInstructionsOrLink = (TextView) view.findViewById(R.id.instructionsOrLink);
+
+        Settings.addLoggingBehavior(LoggingBehavior.INCLUDE_ACCESS_TOKENS);
+
+        Session session = Session.getActiveSession();
+        if (session == null) {
+            if (savedInstanceState != null) {
+                session = Session.restoreSession(getActivity(), null, statusCallback, savedInstanceState);
+            }
+            if (session == null) {
+                session = new Session(getActivity());
+            }
+            Session.setActiveSession(session);
+            if (session.getState().equals(SessionState.CREATED_TOKEN_LOADED)) {
+                session.openForRead(new Session.OpenRequest(this).setCallback(statusCallback));
+            }
+        }
+
+        updateView();
+
+        return view;
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        Session.getActiveSession().addCallback(statusCallback);
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+        Session.getActiveSession().removeCallback(statusCallback);
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        Session.getActiveSession().onActivityResult(getActivity(), requestCode, resultCode, data);
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        Session session = Session.getActiveSession();
+        Session.saveSession(session, outState);
+    }
+
+    private void updateView() {
+        Session session = Session.getActiveSession();
+        if (session.isOpened()) {
+            textInstructionsOrLink.setText(URL_PREFIX_FRIENDS + session.getAccessToken());
+            buttonLoginLogout.setText(R.string.logout);
+            buttonLoginLogout.setOnClickListener(new View.OnClickListener() {
+                public void onClick(View view) { onClickLogout(); }
+            });
+        } else {
+            textInstructionsOrLink.setText(R.string.instructions);
+            buttonLoginLogout.setText(R.string.login);
+            buttonLoginLogout.setOnClickListener(new View.OnClickListener() {
+                public void onClick(View view) { onClickLogin(); }
+            });
+        }
+    }
+
+    private void onClickLogin() {
+        Session session = Session.getActiveSession();
+        if (!session.isOpened() && !session.isClosed()) {
+            session.openForRead(new Session.OpenRequest(this).setCallback(statusCallback));
+        } else {
+            Session.openActiveSession(getActivity(), this, true, statusCallback);
+        }
+    }
+
+    private void onClickLogout() {
+        Session session = Session.getActiveSession();
+        if (!session.isClosed()) {
+            session.closeAndClearTokenInformation();
+        }
+    }
+
+    private class SessionStatusCallback implements Session.StatusCallback {
+        @Override
+        public void call(Session session, SessionState state, Exception exception) {
+            updateView();
+        }
+    }
+}
diff --git a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginSampleActivity.java b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginSampleActivity.java
index 7dba1fee4..a6ce9bb97 100644
--- a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginSampleActivity.java
+++ b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginSampleActivity.java
@@ -1,111 +1,72 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.samples.sessionlogin;
 
 import android.app.Activity;
 import android.content.Intent;
 import android.os.Bundle;
 import android.view.View;
-import android.view.View.OnClickListener;
 import android.widget.Button;
-import android.widget.TextView;
-import com.facebook.LoggingBehaviors;
-import com.facebook.Session;
-import com.facebook.SessionState;
-import com.facebook.Settings;
 
 public class SessionLoginSampleActivity extends Activity {
-    static final String URL_PREFIX_FRIENDS = "https://graph.facebook.com/me/friends?access_token=";
-    TextView textInstructionsOrLink;
-    Button buttonLoginLogout;
-    Session.StatusCallback statusCallback = new SessionStatusCallback();
 
-    @Override
+    private Button buttonLoginActivity;
+    private Button buttonCustomFragment;
+    private Button buttonLoginFragment;
+
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        setContentView(R.layout.main);
-        buttonLoginLogout = (Button)findViewById(R.id.buttonLoginLogout);
-        textInstructionsOrLink = (TextView)findViewById(R.id.instructionsOrLink);
 
-        Settings.addLoggingBehavior(LoggingBehaviors.INCLUDE_ACCESS_TOKENS);
+        setContentView(R.layout.main);
 
-        Session session = Session.getActiveSession();
-        if (session == null) {
-            if (savedInstanceState != null) {
-                session = Session.restoreSession(this, null, statusCallback, savedInstanceState);
-            }
-            if (session == null) {
-                session = new Session(this);
-            }
-            Session.setActiveSession(session);
-            if (session.getState().equals(SessionState.CREATED_TOKEN_LOADED)) {
-                session.openForRead(new Session.OpenRequest(this).setCallback(statusCallback));
+        // We demonstrate three different ways of managing session login/logout behavior:
+        // 1) LoginUsingActivityActivity implements an Activity that handles all of its own
+        //    session management.
+        // 2) LoginUsingCustomFragmentActivity uses a Fragment that handles session management;
+        //    this Fragment could be composed as part of a more complex Activity, although in this
+        //    case it is the only UI that the Activity displays.
+        // 3) LoginUsingLoginFragmentActivity is similar to LoginUsingCustomFragmentActivity, but
+        //    uses the UserSettingsFragment class provided by the SDK to handle session management. As
+        //    in (2), this Fragment could be composed as part of a more complex Activity in a real app.
+        buttonLoginActivity = (Button) findViewById(R.id.buttonLoginActivity);
+        buttonLoginActivity.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                Intent intent = new Intent(SessionLoginSampleActivity.this, LoginUsingActivityActivity.class);
+                startActivity(intent);
             }
-        }
-
-        updateView();
-    }
-
-    @Override
-    public void onStart() {
-        super.onStart();
-        Session.getActiveSession().addCallback(statusCallback);
-    }
-
-    @Override
-    public void onStop() {
-        super.onStop();
-        Session.getActiveSession().removeCallback(statusCallback);
-    }
+        });
 
-    @Override
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        super.onActivityResult(requestCode, resultCode, data);
-        Session.getActiveSession().onActivityResult(this, requestCode, resultCode, data);
-    }
-
-    @Override
-    protected void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        Session session = Session.getActiveSession();
-        Session.saveSession(session, outState);
-    }
-
-    private void updateView() {
-        Session session = Session.getActiveSession();
-        if (session.isOpened()) {
-            textInstructionsOrLink.setText(URL_PREFIX_FRIENDS + session.getAccessToken());
-            buttonLoginLogout.setText(R.string.logout);
-            buttonLoginLogout.setOnClickListener(new OnClickListener() {
-                public void onClick(View view) { onClickLogout(); }
-            });
-        } else {
-            textInstructionsOrLink.setText(R.string.instructions);
-            buttonLoginLogout.setText(R.string.login);
-            buttonLoginLogout.setOnClickListener(new OnClickListener() {
-                public void onClick(View view) { onClickLogin(); }
-            });
-        }
-    }
-
-    private void onClickLogin() {
-        Session session = Session.getActiveSession();
-        if (!session.isOpened() && !session.isClosed()) {
-            session.openForRead(new Session.OpenRequest(this).setCallback(statusCallback));
-        } else {
-            Session.openActiveSession(this, true, statusCallback);
-        }
-    }
-
-    private void onClickLogout() {
-        Session session = Session.getActiveSession();
-        if (!session.isClosed()) {
-            session.closeAndClearTokenInformation();
-        }
-    }
+        buttonCustomFragment = (Button) findViewById(R.id.buttonLoginCustomFragment);
+        buttonCustomFragment.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                Intent intent = new Intent(SessionLoginSampleActivity.this, LoginUsingCustomFragmentActivity.class);
+                startActivity(intent);
+            }
+        });
 
-    private class SessionStatusCallback implements Session.StatusCallback {
-        @Override
-        public void call(Session session, SessionState state, Exception exception) {
-            updateView();
-        }
+        buttonLoginFragment = (Button) findViewById(R.id.buttonLoginFragment);
+        buttonLoginFragment.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                Intent intent = new Intent(SessionLoginSampleActivity.this, LoginUsingLoginFragmentActivity.class);
+                startActivity(intent);
+            }
+        });
     }
-}
+}
\ No newline at end of file
diff --git a/samples/SwitchUserSample/AndroidManifest.xml b/samples/SwitchUserSample/AndroidManifest.xml
index cd27a32b4..8107b8d41 100644
--- a/samples/SwitchUserSample/AndroidManifest.xml
+++ b/samples/SwitchUserSample/AndroidManifest.xml
@@ -16,6 +16,7 @@
             </intent-filter>
         </activity>
         <activity android:name="com.facebook.LoginActivity"
+                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
                   android:label="@string/app_name" />
         <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
     </application>
diff --git a/samples/SwitchUserSample/SwitchUserSample.iml b/samples/SwitchUserSample/SwitchUserSample.iml
index bca109a37..4aac86509 100644
--- a/samples/SwitchUserSample/SwitchUserSample.iml
+++ b/samples/SwitchUserSample/SwitchUserSample.iml
@@ -27,6 +27,7 @@
           <path>/res-overlay</path>
         </resOverlayFolders>
         <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
         <additionalNativeLibs />
       </configuration>
     </facet>
diff --git a/samples/SwitchUserSample/ant.properties b/samples/SwitchUserSample/ant.properties
index b0971e891..939105d52 100644
--- a/samples/SwitchUserSample/ant.properties
+++ b/samples/SwitchUserSample/ant.properties
@@ -15,3 +15,4 @@
 #  'key.alias' for the name of the key to use.
 # The password will be asked during the build when you use the 'release' target.
 
+java.compilerargs=-Xlint -Werror
diff --git a/samples/SwitchUserSample/res/layout/fragment_profile.xml b/samples/SwitchUserSample/res/layout/fragment_profile.xml
index 60b3047d8..509a8a215 100644
--- a/samples/SwitchUserSample/res/layout/fragment_profile.xml
+++ b/samples/SwitchUserSample/res/layout/fragment_profile.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
               xmlns:app="http://schemas.android.com/apk/res-auto"
               android:orientation="vertical"
@@ -13,7 +29,7 @@
             android:text="@string/greeting_no_user"
             android:freezesText="true"
             />
-    <com.facebook.ProfilePictureView
+    <com.facebook.widget.ProfilePictureView
             android:id="@+id/profilePic"
             android:layout_height="wrap_content"
             android:layout_width="wrap_content"
diff --git a/samples/SwitchUserSample/res/layout/list_item_user.xml b/samples/SwitchUserSample/res/layout/list_item_user.xml
index c49bb1af4..021f8a184 100644
--- a/samples/SwitchUserSample/res/layout/list_item_user.xml
+++ b/samples/SwitchUserSample/res/layout/list_item_user.xml
@@ -1,4 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 
 <LinearLayout
         xmlns:android="http://schemas.android.com/apk/res/android"
@@ -8,7 +23,7 @@
         android:orientation="horizontal"
         >
 
-    <com.facebook.ProfilePictureView
+    <com.facebook.widget.ProfilePictureView
             android:id="@+id/slotPic"
             android:layout_height="wrap_content"
             android:layout_width="wrap_content"
@@ -35,4 +50,4 @@
             android:enabled="false"
             />
 
-</LinearLayout>
\ No newline at end of file
+</LinearLayout>
diff --git a/samples/SwitchUserSample/res/layout/main.xml b/samples/SwitchUserSample/res/layout/main.xml
index 8cab0a90f..a223f1d3e 100644
--- a/samples/SwitchUserSample/res/layout/main.xml
+++ b/samples/SwitchUserSample/res/layout/main.xml
@@ -1,6 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:id="@+id/fragmentContainer"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
-        />
\ No newline at end of file
+        />
diff --git a/samples/SwitchUserSample/res/menu/context_settings.xml b/samples/SwitchUserSample/res/menu/context_settings.xml
index 79237e4a8..c1aa76530 100644
--- a/samples/SwitchUserSample/res/menu/context_settings.xml
+++ b/samples/SwitchUserSample/res/menu/context_settings.xml
@@ -1,6 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <menu xmlns:android="http://schemas.android.com/apk/res/android">
     <item android:id="@+id/menu_item_clear_slot"
           android:title="@string/menu_item_clear_slot"
           />
-</menu>
\ No newline at end of file
+</menu>
diff --git a/samples/SwitchUserSample/res/menu/options_profile.xml b/samples/SwitchUserSample/res/menu/options_profile.xml
index a0799a1d5..2457088f0 100644
--- a/samples/SwitchUserSample/res/menu/options_profile.xml
+++ b/samples/SwitchUserSample/res/menu/options_profile.xml
@@ -1,8 +1,23 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
 
 <menu xmlns:android="http://schemas.android.com/apk/res/android">
     <item
             android:id="@+id/menu_item_switch"
             android:title="@string/menu_item_switch_user"
             />
-</menu>
\ No newline at end of file
+</menu>
diff --git a/samples/SwitchUserSample/res/values/strings.xml b/samples/SwitchUserSample/res/values/strings.xml
index 3c2535e00..4195ef509 100644
--- a/samples/SwitchUserSample/res/values/strings.xml
+++ b/samples/SwitchUserSample/res/values/strings.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <string name="app_name">SwitchUserSample</string>
     <string name="empty_slot">Empty Slot</string>
diff --git a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/MainActivity.java b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/MainActivity.java
index 7a0e305ad..8b4c9d482 100644
--- a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/MainActivity.java
+++ b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/MainActivity.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.samples.switchuser;
 
 import android.content.Intent;
@@ -7,6 +23,7 @@
 import android.support.v4.app.FragmentTransaction;
 import android.view.MenuItem;
 import com.facebook.*;
+import com.facebook.model.GraphUser;
 
 public class MainActivity extends FragmentActivity {
 
@@ -41,7 +58,7 @@ public void call(Session session, SessionState state, Exception exception) {
                 showProfile();
             }
 
-            SharedPreferencesTokenCache restoredCache = new SharedPreferencesTokenCache(
+            SharedPreferencesTokenCachingStrategy restoredCache = new SharedPreferencesTokenCachingStrategy(
                     this,
                     savedInstanceState.getString(TOKEN_CACHE_NAME_KEY));
             currentSession = Session.restoreSession(
@@ -87,7 +104,7 @@ protected void onResume() {
 
         settingsFragment.setSlotChangedListener(new SettingsFragment.OnSlotChangedListener() {
             @Override
-            public void OnSlotChanged(Slot newSlot) {
+            public void onSlotChanged(Slot newSlot) {
                 handleSlotChange(newSlot);
             }
         });
@@ -193,7 +210,7 @@ public void onCompleted(GraphUser me, Response response) {
                     }
                 }
             });
-            Request.executeBatchAsync(request);
+            request.executeAsync();
         }
     }
 
@@ -206,7 +223,7 @@ private void handleSlotChange(Slot newSlot) {
         if (newSlot != null) {
             currentSlot = newSlot;
             currentSession = new Session.Builder(this)
-                    .setTokenCache(currentSlot.getTokenCache())
+                    .setTokenCachingStrategy(currentSlot.getTokenCache())
                     .build();
             currentSession.addCallback(sessionStatusCallback);
 
diff --git a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/ProfileFragment.java b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/ProfileFragment.java
index 27eabe38b..885fc93f9 100644
--- a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/ProfileFragment.java
+++ b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/ProfileFragment.java
@@ -1,11 +1,27 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.samples.switchuser;
 
 import android.os.Bundle;
 import android.support.v4.app.Fragment;
 import android.view.*;
 import android.widget.TextView;
-import com.facebook.GraphUser;
-import com.facebook.ProfilePictureView;
+import com.facebook.model.GraphUser;
+import com.facebook.widget.ProfilePictureView;
 
 public class ProfileFragment extends Fragment {
 
@@ -72,10 +88,10 @@ public void updateViewForUser(GraphUser user) {
         }
 
         if (user == null) {
-            profilePictureView.setUserId(null);
-            userNameView.setText(getString(R.string.greeting_no_user));
+            profilePictureView.setProfileId(null);
+            userNameView.setText(R.string.greeting_no_user);
         } else {
-            profilePictureView.setUserId(user.getId());
+            profilePictureView.setProfileId(user.getId());
             userNameView.setText(
                     String.format(getString(R.string.greeting_format), user.getFirstName()));
         }
diff --git a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/SettingsFragment.java b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/SettingsFragment.java
index b9a7f9e5b..b140e2577 100644
--- a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/SettingsFragment.java
+++ b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/SettingsFragment.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.samples.switchuser;
 
 import android.content.Context;
@@ -6,8 +22,8 @@
 import android.support.v4.app.ListFragment;
 import android.view.*;
 import android.widget.*;
-import com.facebook.GraphUser;
-import com.facebook.ProfilePictureView;
+import com.facebook.model.GraphUser;
+import com.facebook.widget.ProfilePictureView;
 import com.facebook.SessionLoginBehavior;
 
 import java.util.ArrayList;
@@ -40,27 +56,27 @@ public void onCreate(Bundle savedInstanceState) {
 
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {
-        View v = super.onCreateView(inflater, parent, savedInstanceState);
-        registerForContextMenu(v.findViewById(android.R.id.list));
+        View view = super.onCreateView(inflater, parent, savedInstanceState);
+        registerForContextMenu(view.findViewById(android.R.id.list));
 
-        return v;
+        return view;
     }
 
     @Override
-    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {
-        super.onCreateContextMenu(menu, v, menuInfo);
+    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
+        super.onCreateContextMenu(menu, view, menuInfo);
         getActivity().getMenuInflater().inflate(R.menu.context_settings, menu);
     }
 
     @Override
-    public void onListItemClick(ListView l, View v, int position, long id) {
+    public void onListItemClick(ListView l, View view, int position, long id) {
         slotManager.toggleSlot(position);
     }
 
     @Override
     public boolean onContextItemSelected(MenuItem item) {
-        AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo)item.getMenuInfo();
-        SlotAdapter adapter = (SlotAdapter)getListAdapter();
+        AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
+        SlotAdapter adapter = (SlotAdapter) getListAdapter();
         Slot slot = adapter.getItem(info.position);
 
         switch (item.getItemId()) {
@@ -122,19 +138,19 @@ private void notifySlotChanged() {
         OnSlotChangedListener listener = slotChangedListener;
         if (listener != null) {
             Slot newSlot = slotManager.getSelectedSlot();
-            listener.OnSlotChanged(newSlot);
+            listener.onSlotChanged(newSlot);
         } else {
             hasPendingNotifySlotChanged = true;
         }
     }
 
     private void updateListView() {
-        SlotAdapter adapter = (SlotAdapter)getListAdapter();
+        SlotAdapter adapter = (SlotAdapter) getListAdapter();
         adapter.notifyDataSetChanged();
     }
 
     public interface OnSlotChangedListener {
-        void OnSlotChanged(Slot newSlot);
+        void onSlotChanged(Slot newSlot);
     }
 
     private class SlotAdapter extends ArrayAdapter<Slot> {
@@ -156,16 +172,16 @@ public View getView(int position, View convertView, ViewGroup parent) {
                 userName = getString(R.string.empty_slot);
             }
 
-            ProfilePictureView profilePictureView = (ProfilePictureView)convertView.findViewById(
+            ProfilePictureView profilePictureView = (ProfilePictureView) convertView.findViewById(
                     R.id.slotPic);
             profilePictureView.setCropped(true);
-            profilePictureView.setUserId(slot.getUserId());
+            profilePictureView.setProfileId(slot.getUserId());
 
-            TextView userNameTextView = (TextView)convertView.findViewById(
+            TextView userNameTextView = (TextView) convertView.findViewById(
                     R.id.slotUserName);
             userNameTextView.setText(userName);
 
-            CheckBox currentUserCheckBox = (CheckBox)convertView.findViewById(
+            CheckBox currentUserCheckBox = (CheckBox) convertView.findViewById(
                     R.id.currentUserIndicator);
             currentUserCheckBox.setChecked(slotManager.getSelectedSlot() == slot);
 
@@ -189,7 +205,7 @@ public View getView(int position, View convertView, ViewGroup parent) {
 
         void restore(Context context, int oldSelectedSlot) {
             if (context == null) {
-                throw new NullPointerException("context cannot be null");
+                throw new IllegalArgumentException("context cannot be null");
             }
 
             Context applicationContext = context.getApplicationContext();
diff --git a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/Slot.java b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/Slot.java
index 6930ff119..0dee18160 100644
--- a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/Slot.java
+++ b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/Slot.java
@@ -1,8 +1,25 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.samples.switchuser;
 
 import android.content.Context;
 import android.os.Bundle;
 import com.facebook.*;
+import com.facebook.model.GraphUser;
 
 public class Slot {
 
@@ -13,13 +30,13 @@
     private String tokenCacheName;
     private String userName;
     private String userId;
-    private SharedPreferencesTokenCache tokenCache;
+    private SharedPreferencesTokenCachingStrategy tokenCache;
     private SessionLoginBehavior loginBehavior;
 
     public Slot(Context context, int slotNumber, SessionLoginBehavior loginBehavior) {
         this.loginBehavior = loginBehavior;
         this.tokenCacheName = String.format(CACHE_NAME_FORMAT, slotNumber);
-        this.tokenCache = new SharedPreferencesTokenCache(
+        this.tokenCache = new SharedPreferencesTokenCachingStrategy(
                 context,
                 tokenCacheName);
 
@@ -42,7 +59,7 @@ public SessionLoginBehavior getLoginBehavior() {
         return loginBehavior;
     }
 
-    public SharedPreferencesTokenCache getTokenCache() {
+    public SharedPreferencesTokenCachingStrategy getTokenCache() {
         return tokenCache;
     }
 
diff --git a/scripts/configure_unit_tests.sh b/scripts/configure_unit_tests.sh
index 7ed817c09..d0e6c9481 100755
--- a/scripts/configure_unit_tests.sh
+++ b/scripts/configure_unit_tests.sh
@@ -19,7 +19,9 @@
 # Note: On Mac OS X, an easy way to generate a MACHINE_UNIQUE_USER_TAG is with the following:
 #   system_profiler SPHardwareDataType | grep -i "Serial Number (system):" | awk '{print $4}'
 
-. ${FB_SDK_SCRIPT:-$(dirname $0)}/common.sh
+cd $(dirname $0)/..
+FB_SDK_ROOT=$(pwd)
+FB_SDK_TESTS=$FB_SDK_ROOT/facebook/tests
 
 if [ "$#" -lt 2 ]; then
     echo "Usage: $0 APP_ID APP_SECRET [MACHINE_UNIQUE_USER_KEY]"
diff --git a/tests/res/layout/main.xml b/tests/res/layout/main.xml
index 1d0daf1c5..bc121048b 100644
--- a/tests/res/layout/main.xml
+++ b/tests/res/layout/main.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical" android:layout_width="fill_parent"
     android:layout_height="fill_parent" android:background="@drawable/black"
diff --git a/tests/res/values/colors.xml b/tests/res/values/colors.xml
index 2aa7e8e36..2f916914f 100644
--- a/tests/res/values/colors.xml
+++ b/tests/res/values/colors.xml
@@ -1,5 +1,21 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <drawable name="white">#ffffff</drawable>
     <drawable name="black">#000000</drawable>
-</resources>
\ No newline at end of file
+</resources>
diff --git a/tests/res/values/strings.xml b/tests/res/values/strings.xml
index 1c7c09076..a8fa46759 100644
--- a/tests/res/values/strings.xml
+++ b/tests/res/values/strings.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <string name="hello">Hello World, Tests!</string>
     <string name="login">Test Login</string>
diff --git a/tests/src/com/facebook/android/tests/Tests.java b/tests/src/com/facebook/android/tests/Tests.java
index 3f771e128..4fb93d730 100644
--- a/tests/src/com/facebook/android/tests/Tests.java
+++ b/tests/src/com/facebook/android/tests/Tests.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android.tests;
 
 import java.io.FileNotFoundException;
