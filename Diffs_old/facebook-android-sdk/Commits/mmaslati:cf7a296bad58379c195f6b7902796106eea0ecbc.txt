diff --git a/facebook/build.gradle b/facebook/build.gradle
index 426647fa3..90d99fb91 100644
--- a/facebook/build.gradle
+++ b/facebook/build.gradle
@@ -39,6 +39,7 @@ android {
     defaultConfig {
         minSdkVersion Integer.parseInt(project.ANDROID_BUILD_MIN_SDK_VERSION)
         targetSdkVersion Integer.parseInt(project.ANDROID_BUILD_TARGET_SDK_VERSION)
+        consumerProguardFiles 'proguard-project.txt'
     }
 
     lintOptions {
diff --git a/facebook/proguard-project.txt b/facebook/proguard-project.txt
index f2fe1559a..1eca961d7 100644
--- a/facebook/proguard-project.txt
+++ b/facebook/proguard-project.txt
@@ -18,3 +18,11 @@
 #-keepclassmembers class fqcn.of.javascript.interface.for.webview {
 #   public *;
 #}
+
+-keepclassmembers class * implements java.io.Serializable {
+    private static final java.io.ObjectStreamField[] serialPersistentFields;
+    private void writeObject(java.io.ObjectOutputStream);
+    private void readObject(java.io.ObjectInputStream);
+    java.lang.Object writeReplace();
+    java.lang.Object readResolve();
+}
\ No newline at end of file
diff --git a/facebook/src/androidTest/java/com/facebook/login/LoginClientTests.java b/facebook/src/androidTest/java/com/facebook/login/LoginClientTests.java
index 2dba1ba93..e780e860c 100644
--- a/facebook/src/androidTest/java/com/facebook/login/LoginClientTests.java
+++ b/facebook/src/androidTest/java/com/facebook/login/LoginClientTests.java
@@ -20,6 +20,7 @@
 
 package com.facebook.login;
 
+import android.annotation.SuppressLint;
 import android.support.v4.app.Fragment;
 import android.test.suitebuilder.annotation.LargeTest;
 
@@ -33,6 +34,7 @@
     private static final Set<String> PERMISSIONS = new HashSet<String>(
             Arrays.asList("go outside", "come back in"));
 
+    @SuppressLint("ParcelCreator")
     class MockLoginClient extends LoginClient {
         Result result;
         boolean triedNextHandler = false;
@@ -70,6 +72,7 @@ void tryNextHandler() {
         );
     }
 
+    @SuppressLint("ParcelCreator")
     class MockValidatingLoginClient extends MockLoginClient {
         private final HashMap<String, String> mapAccessTokenToFbid = new HashMap<String, String>();
         private Set<String> permissionsToReport = new HashSet<String>();
diff --git a/facebook/src/main/AndroidManifest.xml b/facebook/src/main/AndroidManifest.xml
index 9cb15ab25..ca7520f0c 100644
--- a/facebook/src/main/AndroidManifest.xml
+++ b/facebook/src/main/AndroidManifest.xml
@@ -26,5 +26,14 @@
     <!-- Force Custom Tabs Library to be used below API Level 15 -->
     <uses-sdk tools:overrideLibrary="android.support.customtabs"/>
 
-    <application/>
+    <application>
+        <activity
+            android:name="com.facebook.FacebookActivity"
+            android:configChanges="keyboard|keyboardHidden|screenLayout|screenSize|orientation"
+            android:theme="@android:style/Theme.Translucent.NoTitleBar" />
+        <activity
+            android:name="com.facebook.CustomTabActivity"
+            android:exported="true">
+        </activity>
+    </application>
 </manifest>
diff --git a/facebook/src/main/java/com/facebook/AccessTokenSource.java b/facebook/src/main/java/com/facebook/AccessTokenSource.java
index 64f077004..547627a3b 100644
--- a/facebook/src/main/java/com/facebook/AccessTokenSource.java
+++ b/facebook/src/main/java/com/facebook/AccessTokenSource.java
@@ -53,7 +53,7 @@
      * Indicates an access token was obtained by the user logging in through the
      * Web-based dialog on a Chrome Custom Tab.
      */
-    CUSTOM_TAB(true),
+    CHROME_CUSTOM_TAB(true),
     /**
      * Indicates an access token is for a test user rather than an actual
      * Facebook user.
diff --git a/facebook/src/main/java/com/facebook/FacebookActivity.java b/facebook/src/main/java/com/facebook/FacebookActivity.java
index 4527ee0bd..5440724e1 100644
--- a/facebook/src/main/java/com/facebook/FacebookActivity.java
+++ b/facebook/src/main/java/com/facebook/FacebookActivity.java
@@ -27,6 +27,7 @@
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
+import android.util.Log;
 
 import com.facebook.internal.FacebookDialogFragment;
 import com.facebook.internal.NativeProtocol;
@@ -56,6 +57,7 @@
     public static String PASS_THROUGH_CANCEL_ACTION = "PassThrough";
     private static String FRAGMENT_TAG = "SingleFragment";
     private static final int API_EC_DIALOG_CANCEL = 4201;
+    private static final String TAG = FacebookActivity.class.getName();
 
     private Fragment singleFragment;
 
@@ -66,6 +68,19 @@ private static final String getRedirectUrl() {
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
+
+        // Some apps using this sdk don't put the sdk initialize code in the application
+        // on create method. This can cause issues when opening this activity after an application
+        // has been killed since the sdk won't be initialized. Attempt to initialize the sdk
+        // here if it hasn't already been initialized.
+        if (!FacebookSdk.isInitialized()) {
+            Log.d(
+                TAG,
+                "Facebook SDK not initialized. Make sure you call sdkInitialize inside " +
+                        "your Application's onCreate method.");
+            FacebookSdk.sdkInitialize(getApplicationContext());
+        }
+
         setContentView(R.layout.com_facebook_activity_layout);
 
         Intent intent = getIntent();
diff --git a/facebook/src/main/java/com/facebook/FacebookSdk.java b/facebook/src/main/java/com/facebook/FacebookSdk.java
index 02faa1948..ef3848b77 100644
--- a/facebook/src/main/java/com/facebook/FacebookSdk.java
+++ b/facebook/src/main/java/com/facebook/FacebookSdk.java
@@ -69,7 +69,6 @@
     private static volatile String applicationName;
     private static volatile String appClientToken;
     private static volatile int webDialogTheme;
-    //TODO 10636734: revert intern
     private static final String FACEBOOK_COM = "facebook.com";
     private static volatile String facebookDomain = FACEBOOK_COM;
     private static AtomicLong onProgressThreshold = new AtomicLong(65536);
@@ -185,7 +184,7 @@ public static synchronized void sdkInitialize(Context applicationContext) {
      *                 sdk is already initialized.
      */
     public static synchronized void sdkInitialize(
-            Context applicationContext,
+            final Context applicationContext,
             final InitializeCallback callback) {
         if (sdkInitialized) {
             if (callback != null) {
@@ -225,8 +224,8 @@ public File call() throws Exception {
                     }
                 });
 
-        FutureTask<Void> accessTokenLoadFutureTask =
-                new FutureTask<Void>(new Callable<Void>() {
+        FutureTask<Void> futureTask =
+                new FutureTask<>(new Callable<Void>() {
                     @Override
                     public Void call() throws Exception {
                         AccessTokenManager.getInstance().loadCurrentAccessToken();
@@ -241,10 +240,15 @@ public Void call() throws Exception {
                         if (callback != null) {
                             callback.onInitialized();
                         }
+
+                        // Flush any app events that might have been persisted during last run.
+                        AppEventsLogger.newLogger(
+                                applicationContext.getApplicationContext()).flush();
+
                         return null;
                     }
                 });
-        getExecutor().execute(accessTokenLoadFutureTask);
+        getExecutor().execute(futureTask);
     }
 
     /**
diff --git a/facebook/src/main/java/com/facebook/FacebookSdkVersion.java b/facebook/src/main/java/com/facebook/FacebookSdkVersion.java
index 855771232..23bdfa2b5 100644
--- a/facebook/src/main/java/com/facebook/FacebookSdkVersion.java
+++ b/facebook/src/main/java/com/facebook/FacebookSdkVersion.java
@@ -21,5 +21,5 @@
 package com.facebook;
 
 final class FacebookSdkVersion {
-    public static final String BUILD = "4.11.0";
+    public static final String BUILD = "4.12.0";
 }
diff --git a/facebook/src/main/java/com/facebook/appevents/AccessTokenAppIdPair.java b/facebook/src/main/java/com/facebook/appevents/AccessTokenAppIdPair.java
new file mode 100644
index 000000000..5888b96ed
--- /dev/null
+++ b/facebook/src/main/java/com/facebook/appevents/AccessTokenAppIdPair.java
@@ -0,0 +1,87 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.appevents;
+
+import com.facebook.AccessToken;
+import com.facebook.FacebookSdk;
+import com.facebook.internal.Utility;
+
+import java.io.Serializable;
+
+class AccessTokenAppIdPair implements Serializable {
+    private static final long serialVersionUID = 1L;
+    private final String accessTokenString;
+    private final String applicationId;
+
+    public AccessTokenAppIdPair(AccessToken accessToken) {
+        this(accessToken.getToken(), FacebookSdk.getApplicationId());
+    }
+
+    public AccessTokenAppIdPair(String accessTokenString, String applicationId) {
+        this.accessTokenString = Utility.isNullOrEmpty(accessTokenString)
+                ? null
+                : accessTokenString;
+        this.applicationId = applicationId;
+    }
+
+    public String getAccessTokenString() {
+        return accessTokenString;
+    }
+
+    public String getApplicationId() {
+        return applicationId;
+    }
+
+    @Override
+    public int hashCode() {
+        return (accessTokenString == null ? 0 : accessTokenString.hashCode()) ^
+                (applicationId == null ? 0 : applicationId.hashCode());
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (!(o instanceof AccessTokenAppIdPair)) {
+            return false;
+        }
+        AccessTokenAppIdPair p = (AccessTokenAppIdPair) o;
+        return Utility.areObjectsEqual(p.accessTokenString, accessTokenString) &&
+                Utility.areObjectsEqual(p.applicationId, applicationId);
+    }
+
+    static class SerializationProxyV1 implements Serializable {
+        private static final long serialVersionUID = -2488473066578201069L;
+        private final String accessTokenString;
+        private final String appId;
+
+        private SerializationProxyV1(String accessTokenString, String appId) {
+            this.accessTokenString = accessTokenString;
+            this.appId = appId;
+        }
+
+        private Object readResolve() {
+            return new AccessTokenAppIdPair(accessTokenString, appId);
+        }
+    }
+
+    private Object writeReplace() {
+        return new SerializationProxyV1(accessTokenString, applicationId);
+    }
+}
diff --git a/facebook/src/main/java/com/facebook/appevents/AppEvent.java b/facebook/src/main/java/com/facebook/appevents/AppEvent.java
new file mode 100644
index 000000000..a2d9d4c0d
--- /dev/null
+++ b/facebook/src/main/java/com/facebook/appevents/AppEvent.java
@@ -0,0 +1,206 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.appevents;
+
+import android.os.Bundle;
+import android.support.annotation.Nullable;
+
+import com.facebook.FacebookException;
+import com.facebook.LoggingBehavior;
+import com.facebook.appevents.internal.Constants;
+import com.facebook.internal.Logger;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.Serializable;
+import java.util.HashSet;
+import java.util.Locale;
+import java.util.UUID;
+
+class AppEvent implements Serializable {
+    private static final long serialVersionUID = 1L;
+
+    private JSONObject jsonObject;
+    private boolean isImplicit;
+    private static final HashSet<String> validatedIdentifiers = new HashSet<String>();
+    private String name;
+
+    public AppEvent(
+            String contextName,
+            String eventName,
+            Double valueToSum,
+            Bundle parameters,
+            boolean isImplicitlyLogged,
+            @Nullable final UUID currentSessionId
+    ) {
+        try {
+            validateIdentifier(eventName);
+
+            this.name = eventName;
+            isImplicit = isImplicitlyLogged;
+            jsonObject = new JSONObject();
+
+            jsonObject.put("_eventName", eventName);
+            jsonObject.put(Constants.LOG_TIME_APP_EVENT_KEY, System.currentTimeMillis() / 1000);
+            jsonObject.put("_ui", contextName);
+            if (currentSessionId != null) {
+                jsonObject.put("_session_id", currentSessionId);
+            }
+
+            if (valueToSum != null) {
+                jsonObject.put("_valueToSum", valueToSum.doubleValue());
+            }
+
+            if (isImplicit) {
+                jsonObject.put("_implicitlyLogged", "1");
+            }
+
+            if (parameters != null) {
+                for (String key : parameters.keySet()) {
+
+                    validateIdentifier(key);
+
+                    Object value = parameters.get(key);
+                    if (!(value instanceof String) && !(value instanceof Number)) {
+                        throw new FacebookException(
+                                String.format(
+                                        "Parameter value '%s' for key '%s' should be a string" +
+                                                " or a numeric type.",
+                                        value,
+                                        key)
+                        );
+                    }
+
+                    jsonObject.put(key, value.toString());
+                }
+            }
+
+            if (!isImplicit) {
+                Logger.log(LoggingBehavior.APP_EVENTS, "AppEvents",
+                        "Created app event '%s'", jsonObject.toString());
+            }
+        } catch (JSONException jsonException) {
+
+            // If any of the above failed, just consider this an illegal event.
+            Logger.log(LoggingBehavior.APP_EVENTS, "AppEvents",
+                    "JSON encoding for app event failed: '%s'", jsonException.toString());
+            jsonObject = null;
+
+        } catch (FacebookException e) {
+            // If any of the above failed, just consider this an illegal event.
+            Logger.log(LoggingBehavior.APP_EVENTS, "AppEvents",
+                    "Invalid app event name or parameter:", e.toString());
+            jsonObject = null;
+        }
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    private AppEvent(String jsonString, boolean isImplicit) throws JSONException {
+        jsonObject = new JSONObject(jsonString);
+        this.isImplicit = isImplicit;
+    }
+
+    public boolean getIsImplicit() {
+        return isImplicit;
+    }
+
+    public JSONObject getJSONObject() {
+        return jsonObject;
+    }
+
+    // throw exception if not valid.
+    private void validateIdentifier(String identifier) throws FacebookException {
+
+        // Identifier should be 40 chars or less, and only have 0-9A-Za-z, underscore, hyphen,
+        // and space (but no hyphen or space in the first position).
+        final String regex = "^[0-9a-zA-Z_]+[0-9a-zA-Z _-]*$";
+
+        final int MAX_IDENTIFIER_LENGTH = 40;
+        if (identifier == null
+                || identifier.length() == 0
+                || identifier.length() > MAX_IDENTIFIER_LENGTH) {
+            if (identifier == null) {
+                identifier = "<None Provided>";
+            }
+            throw new FacebookException(
+                    String.format(
+                            Locale.ROOT,
+                            "Identifier '%s' must be less than %d characters",
+                            identifier,
+                            MAX_IDENTIFIER_LENGTH)
+            );
+        }
+
+        boolean alreadyValidated = false;
+        synchronized (validatedIdentifiers) {
+            alreadyValidated = validatedIdentifiers.contains(identifier);
+        }
+
+        if (!alreadyValidated) {
+            if (identifier.matches(regex)) {
+                synchronized (validatedIdentifiers) {
+                    validatedIdentifiers.add(identifier);
+                }
+            } else {
+                throw new FacebookException(
+                        String.format(
+                                "Skipping event named '%s' due to illegal name - must be " +
+                                        "under 40 chars and alphanumeric, _, - or space, and " +
+                                        "not start with a space or hyphen.",
+                                identifier
+                        )
+                );
+            }
+        }
+    }
+
+    static class SerializationProxyV1 implements Serializable {
+        private static final long serialVersionUID = -2488473066578201069L;
+        private final String jsonString;
+        private final boolean isImplicit;
+
+        private SerializationProxyV1(String jsonString, boolean isImplicit) {
+            this.jsonString = jsonString;
+            this.isImplicit = isImplicit;
+        }
+
+        private Object readResolve() throws JSONException {
+            return new AppEvent(jsonString, isImplicit);
+        }
+    }
+
+    private Object writeReplace() {
+        return new SerializationProxyV1(jsonObject.toString(), isImplicit);
+    }
+
+    @Override
+    public String toString() {
+        return String.format(
+                "\"%s\", implicit: %b, json: %s",
+                jsonObject.optString("_eventName"),
+                isImplicit,
+                jsonObject.toString());
+    }
+}
diff --git a/facebook/src/main/java/com/facebook/appevents/AppEventCollection.java b/facebook/src/main/java/com/facebook/appevents/AppEventCollection.java
new file mode 100644
index 000000000..0acdf12fb
--- /dev/null
+++ b/facebook/src/main/java/com/facebook/appevents/AppEventCollection.java
@@ -0,0 +1,92 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.appevents;
+
+import android.content.Context;
+
+import com.facebook.internal.AttributionIdentifiers;
+
+import java.util.HashMap;
+import java.util.Set;
+
+class AppEventCollection {
+    private final HashMap<AccessTokenAppIdPair, SessionEventsState> stateMap;
+
+    public AppEventCollection() {
+        stateMap = new HashMap<>();
+    }
+
+    public synchronized void addPersistedEvents(PersistedEvents persistedEvents) {
+        if (persistedEvents == null) {
+            return;
+        }
+
+        for (AccessTokenAppIdPair accessTokenAppIdPair : persistedEvents.keySet()) {
+            SessionEventsState sessionEventsState = getSessionEventsState(accessTokenAppIdPair);
+
+            for (AppEvent appEvent : persistedEvents.get(accessTokenAppIdPair)) {
+                sessionEventsState.addEvent(appEvent);
+            }
+        }
+    }
+
+    public synchronized void addEvent(
+            AccessTokenAppIdPair accessTokenAppIdPair,
+            AppEvent appEvent) {
+        SessionEventsState eventsState = getSessionEventsState(accessTokenAppIdPair);
+        eventsState.addEvent(appEvent);
+    }
+
+    public synchronized Set<AccessTokenAppIdPair> keySet() {
+        return stateMap.keySet();
+    }
+
+    public synchronized SessionEventsState get(AccessTokenAppIdPair accessTokenAppIdPair) {
+        return stateMap.get(accessTokenAppIdPair);
+    }
+
+    public synchronized int getEventCount() {
+        int count = 0;
+        for (SessionEventsState sessionEventsState : stateMap.values()) {
+            count += sessionEventsState.getAccumulatedEventCount();
+        }
+
+        return count;
+    }
+
+    private synchronized SessionEventsState getSessionEventsState(
+            AccessTokenAppIdPair accessTokenAppId) {
+        SessionEventsState eventsState = stateMap.get(accessTokenAppId);
+        if (eventsState == null) {
+            Context context = AppEventsLogger.getApplicationContext();
+
+            // Retrieve attributionId, but we will only send it if attribution is supported for the
+            // app.
+            eventsState = new SessionEventsState(
+                    AttributionIdentifiers.getAttributionIdentifiers(context),
+                    AppEventsLogger.getAnonymousAppDeviceGUID(context));
+        }
+
+        stateMap.put(accessTokenAppId, eventsState);
+
+        return eventsState;
+    }
+}
diff --git a/facebook/src/main/java/com/facebook/appevents/AppEventQueue.java b/facebook/src/main/java/com/facebook/appevents/AppEventQueue.java
new file mode 100644
index 000000000..63bbe490a
--- /dev/null
+++ b/facebook/src/main/java/com/facebook/appevents/AppEventQueue.java
@@ -0,0 +1,315 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.appevents;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.content.LocalBroadcastManager;
+import android.util.Log;
+
+import com.facebook.FacebookRequestError;
+import com.facebook.FacebookSdk;
+import com.facebook.GraphRequest;
+import com.facebook.GraphResponse;
+import com.facebook.LoggingBehavior;
+import com.facebook.internal.Logger;
+import com.facebook.internal.Utility;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+
+class AppEventQueue {
+    private static final String TAG = AppEventQueue.class.getName();
+
+    private static final int NUM_LOG_EVENTS_TO_TRY_TO_FLUSH_AFTER = 100;
+    private static final int FLUSH_PERIOD_IN_SECONDS = 15;
+
+    private static volatile AppEventCollection appEventCollection = new AppEventCollection();
+    private static final ScheduledExecutorService singleThreadExecutor =
+            Executors.newSingleThreadScheduledExecutor();
+    private static ScheduledFuture scheduledFuture;
+
+    // Only call for the singleThreadExecutor
+    private static final Runnable flushRunnable = new Runnable() {
+        @Override
+        public void run() {
+            scheduledFuture = null;
+
+            if (AppEventsLogger.getFlushBehavior() !=
+                    AppEventsLogger.FlushBehavior.EXPLICIT_ONLY) {
+                flushAndWait(FlushReason.TIMER);
+            }
+        }
+    };
+
+    public static void persistToDisk() {
+        singleThreadExecutor.execute(new Runnable() {
+            @Override
+            public void run() {
+                AppEventStore.persistEvents(appEventCollection);
+                appEventCollection = new AppEventCollection();
+            }
+        });
+    }
+
+    public static void flush(
+            final FlushReason reason) {
+        singleThreadExecutor.execute(new Runnable() {
+            @Override
+            public void run() {
+                flushAndWait(reason);
+            }
+        });
+    }
+
+    public static void add(
+            final AccessTokenAppIdPair accessTokenAppId,
+            final AppEvent appEvent) {
+        singleThreadExecutor.execute(new Runnable() {
+            @Override
+            public void run() {
+                appEventCollection.addEvent(accessTokenAppId, appEvent);
+
+                if (AppEventsLogger.getFlushBehavior() !=
+                        AppEventsLogger.FlushBehavior.EXPLICIT_ONLY
+                        && appEventCollection.getEventCount() >
+                        NUM_LOG_EVENTS_TO_TRY_TO_FLUSH_AFTER) {
+                    flushAndWait(FlushReason.EVENT_THRESHOLD);
+                } else if (scheduledFuture == null) {
+                    scheduledFuture = singleThreadExecutor.schedule(
+                            flushRunnable,
+                            FLUSH_PERIOD_IN_SECONDS,
+                            TimeUnit.SECONDS
+                    );
+                }
+            }
+        });
+    }
+
+    public static Set<AccessTokenAppIdPair> getKeySet() {
+        // This is safe to call outside of the singleThreadExecutor since
+        // the appEventCollection is volatile and the modifying methods within the
+        // class are synchronized.
+        return appEventCollection.keySet();
+    }
+
+    static void flushAndWait(FlushReason reason) {
+        // Read and send any persisted events
+        PersistedEvents result = AppEventStore.readAndClearStore();
+        // Add any of the persisted app events to our list of events to send
+        appEventCollection.addPersistedEvents(result);
+
+        FlushStatistics flushResults;
+
+        try {
+            flushResults = sendEventsToServer(
+                    reason,
+                    appEventCollection);
+        } catch (Exception e) {
+            Log.w(TAG, "Caught unexpected exception while flushing app events: ", e);
+            return;
+        }
+
+        if (flushResults != null) {
+            final Intent intent = new Intent(AppEventsLogger.ACTION_APP_EVENTS_FLUSHED);
+            intent.putExtra(
+                    AppEventsLogger.APP_EVENTS_EXTRA_NUM_EVENTS_FLUSHED,
+                    flushResults.numEvents);
+            intent.putExtra(
+                    AppEventsLogger.APP_EVENTS_EXTRA_FLUSH_RESULT,
+                    flushResults.result);
+            Context context = AppEventsLogger.getApplicationContext();
+            LocalBroadcastManager.getInstance(context).sendBroadcast(intent);
+        }
+    }
+
+    private static FlushStatistics sendEventsToServer(
+            FlushReason reason,
+            AppEventCollection appEventCollection) {
+        FlushStatistics flushResults = new FlushStatistics();
+
+        Context context = AppEventsLogger.getApplicationContext();
+        boolean limitEventUsage = FacebookSdk.getLimitEventAndDataUsage(context);
+
+        List<GraphRequest> requestsToExecute = new ArrayList<>();
+        for (AccessTokenAppIdPair accessTokenAppId : appEventCollection.keySet()) {
+            GraphRequest request = buildRequestForSession(
+                    accessTokenAppId,
+                    appEventCollection.get(accessTokenAppId),
+                    limitEventUsage,
+                    flushResults);
+            if (request != null) {
+                requestsToExecute.add(request);
+            }
+        }
+
+        if (requestsToExecute.size() > 0) {
+            Logger.log(LoggingBehavior.APP_EVENTS, TAG, "Flushing %d events due to %s.",
+                    flushResults.numEvents,
+                    reason.toString());
+
+            for (GraphRequest request : requestsToExecute) {
+                // Execute the request synchronously. Callbacks will take care of handling errors
+                // and updating our final overall result.
+                request.executeAndWait();
+            }
+            return flushResults;
+        }
+
+        return null;
+    }
+
+    private static GraphRequest buildRequestForSession(
+            final AccessTokenAppIdPair accessTokenAppId,
+            final SessionEventsState appEvents,
+            final boolean limitEventUsage,
+            final FlushStatistics flushState) {
+        String applicationId = accessTokenAppId.getApplicationId();
+
+        Utility.FetchedAppSettings fetchedAppSettings =
+                Utility.queryAppSettings(applicationId, false);
+
+        final GraphRequest postRequest = GraphRequest.newPostRequest(
+                null,
+                String.format("%s/activities", applicationId),
+                null,
+                null);
+
+        Bundle requestParameters = postRequest.getParameters();
+        if (requestParameters == null) {
+            requestParameters = new Bundle();
+        }
+        requestParameters.putString("access_token", accessTokenAppId.getAccessTokenString());
+        String pushNotificationsRegistrationId =
+                AppEventsLogger.getPushNotificationsRegistrationId();
+        if (pushNotificationsRegistrationId != null) {
+            requestParameters.putString("device_token", pushNotificationsRegistrationId);
+        }
+
+        postRequest.setParameters(requestParameters);
+
+        if (fetchedAppSettings == null) {
+            return null;
+        }
+
+        int numEvents = appEvents.populateRequest(
+                postRequest,
+                AppEventsLogger.getApplicationContext(),
+                fetchedAppSettings.supportsImplicitLogging(),
+                limitEventUsage);
+
+        if (numEvents == 0) {
+            return null;
+        }
+
+        flushState.numEvents += numEvents;
+
+        postRequest.setCallback(new GraphRequest.Callback() {
+            @Override
+            public void onCompleted(GraphResponse response) {
+                handleResponse(
+                        accessTokenAppId,
+                        postRequest,
+                        response,
+                        appEvents,
+                        flushState);
+            }
+        });
+
+        return postRequest;
+    }
+
+    private static void handleResponse(
+            final AccessTokenAppIdPair accessTokenAppId,
+            GraphRequest request,
+            GraphResponse response,
+            final SessionEventsState appEvents,
+            FlushStatistics flushState) {
+        FacebookRequestError error = response.getError();
+        String resultDescription = "Success";
+
+        FlushResult flushResult = FlushResult.SUCCESS;
+
+        if (error != null) {
+            final int NO_CONNECTIVITY_ERROR_CODE = -1;
+            if (error.getErrorCode() == NO_CONNECTIVITY_ERROR_CODE) {
+                resultDescription = "Failed: No Connectivity";
+                flushResult = FlushResult.NO_CONNECTIVITY;
+            } else {
+                resultDescription = String.format("Failed:\n  Response: %s\n  Error %s",
+                        response.toString(),
+                        error.toString());
+                flushResult = FlushResult.SERVER_ERROR;
+            }
+        }
+
+        if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.APP_EVENTS)) {
+            String eventsJsonString = (String) request.getTag();
+            String prettyPrintedEvents;
+
+            try {
+                JSONArray jsonArray = new JSONArray(eventsJsonString);
+                prettyPrintedEvents = jsonArray.toString(2);
+            } catch (JSONException exc) {
+                prettyPrintedEvents = "<Can't encode events for debug logging>";
+            }
+
+            Logger.log(LoggingBehavior.APP_EVENTS, TAG,
+                    "Flush completed\nParams: %s\n  Result: %s\n  Events JSON: %s",
+                    request.getGraphObject().toString(),
+                    resultDescription,
+                    prettyPrintedEvents);
+        }
+
+        appEvents.clearInFlightAndStats(error != null);
+
+        if (flushResult == FlushResult.NO_CONNECTIVITY) {
+            // We may call this for multiple requests in a batch, which is slightly inefficient
+            // since in principle we could call it once for all failed requests, but the impact is
+            // likely to be minimal. We don't call this for other server errors, because if an event
+            // failed because it was malformed, etc., continually retrying it will cause subsequent
+            // events to not be logged either.
+            FacebookSdk.getExecutor().execute(new Runnable() {
+                @Override
+                public void run() {
+                    AppEventStore.persistEvents(accessTokenAppId, appEvents);
+                }
+            });
+        }
+
+        if (flushResult != FlushResult.SUCCESS) {
+            // We assume that connectivity issues are more significant to report than server issues.
+            if (flushState.result != FlushResult.NO_CONNECTIVITY) {
+                flushState.result = flushResult;
+            }
+        }
+    }
+}
diff --git a/facebook/src/main/java/com/facebook/appevents/AppEventStore.java b/facebook/src/main/java/com/facebook/appevents/AppEventStore.java
new file mode 100644
index 000000000..6d7c8df01
--- /dev/null
+++ b/facebook/src/main/java/com/facebook/appevents/AppEventStore.java
@@ -0,0 +1,178 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.appevents;
+
+import android.content.Context;
+import android.os.Looper;
+import android.util.Log;
+
+import com.facebook.BuildConfig;
+import com.facebook.internal.Utility;
+
+import junit.framework.Assert;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.ObjectStreamClass;
+import java.util.HashMap;
+import java.util.List;
+
+class AppEventStore {
+    private static final String TAG = AppEventStore.class.getName();
+    private static final String PERSISTED_EVENTS_FILENAME = "AppEventsLogger.persistedevents";
+
+    public static synchronized void persistEvents(
+            final AccessTokenAppIdPair accessTokenAppIdPair,
+            final SessionEventsState appEvents) {
+        assertIsNotMainThread();
+        PersistedEvents persistedEvents = readAndClearStore();
+
+        if (persistedEvents.containsKey(accessTokenAppIdPair)) {
+            persistedEvents
+                    .get(accessTokenAppIdPair)
+                    .addAll(appEvents.getEventsToPersist());
+        } else {
+            persistedEvents.put(accessTokenAppIdPair, appEvents.getEventsToPersist());
+        }
+
+        saveEventsToDisk(persistedEvents);
+    }
+
+    public static synchronized void persistEvents(
+            final AppEventCollection eventsToPersist) {
+        assertIsNotMainThread();
+        PersistedEvents persistedEvents = new PersistedEvents();
+        for (AccessTokenAppIdPair accessTokenAppIdPair : eventsToPersist.keySet()) {
+            SessionEventsState sessionEventsState = eventsToPersist.get(
+                    accessTokenAppIdPair);
+            persistedEvents.put(
+                    accessTokenAppIdPair,
+                    sessionEventsState.getEventsToPersist());
+        }
+
+        saveEventsToDisk(persistedEvents);
+    }
+
+    // Only call from singleThreadExecutor
+    public static synchronized PersistedEvents readAndClearStore() {
+        assertIsNotMainThread();
+
+        MovedClassObjectInputStream ois = null;
+        HashMap<AccessTokenAppIdPair, List<AppEvent>> obj = null;
+        PersistedEvents persistedEvents = null;
+        Context context = AppEventsLogger.getApplicationContext();
+        try {
+            InputStream is = context.openFileInput(PERSISTED_EVENTS_FILENAME);
+            ois = new MovedClassObjectInputStream(new BufferedInputStream(is));
+
+            obj = (HashMap<AccessTokenAppIdPair, List<AppEvent>>) ois.readObject();
+        } catch (FileNotFoundException e) {
+            // Expected if we never persisted any events.
+        } catch (Exception e) {
+            Log.w(TAG, "Got unexpected exception while reading events: " + e.toString());
+        } finally {
+            Utility.closeQuietly(ois);
+
+
+            try {
+                // Note: We delete the store before we store the events; this means we'd
+                // prefer to lose some events in the case of exception rather than
+                // potentially log them twice.
+                // Always delete this file after the above try catch to recover from read
+                // errors.
+                context.getFileStreamPath(PERSISTED_EVENTS_FILENAME).delete();
+                if (obj != null) {
+                    persistedEvents = new PersistedEvents(obj);
+                }
+            } catch (Exception ex) {
+                Log.w(
+                        TAG,
+                        "Got unexpected exception when removing events file: " + ex.toString());
+            }
+        }
+
+        if (persistedEvents == null) {
+            persistedEvents = new PersistedEvents();
+        }
+
+        return persistedEvents;
+    }
+
+    // Only call from singleThreadExecutor
+    private static void saveEventsToDisk(
+            PersistedEvents eventsToPersist) {
+        ObjectOutputStream oos = null;
+        try {
+            Context context = AppEventsLogger.getApplicationContext();
+            oos = new ObjectOutputStream(
+                    new BufferedOutputStream(
+                            context.openFileOutput(PERSISTED_EVENTS_FILENAME, 0)));
+            oos.writeObject(eventsToPersist);
+        } catch (Exception e) {
+            Log.w(TAG, "Got unexpected exception while persisting events: " + e.toString());
+        } finally {
+            Utility.closeQuietly(oos);
+        }
+    }
+
+    private static void assertIsNotMainThread() {
+        if (BuildConfig.DEBUG){
+            boolean isMainThread = Looper.myLooper() == Looper.getMainLooper();
+            Assert.assertFalse(
+                    "Call cannot be made on the main thread",
+                    isMainThread);
+        }
+    }
+
+    private static class MovedClassObjectInputStream extends ObjectInputStream {
+        private static final String ACCESS_TOKEN_APP_ID_PAIR_SERIALIZATION_PROXY_V1_CLASS_NAME =
+                "com.facebook.appevents.AppEventsLogger$AccessTokenAppIdPair$SerializationProxyV1";
+        private static final String APP_EVENT_SERIALIZATION_PROXY_V1_CLASS_NAME =
+                "com.facebook.appevents.AppEventsLogger$AppEvent$SerializationProxyV1";
+
+        public MovedClassObjectInputStream(InputStream in) throws IOException {
+            super(in);
+        }
+
+        @Override
+        protected ObjectStreamClass readClassDescriptor()
+                throws IOException, ClassNotFoundException {
+            ObjectStreamClass resultClassDescriptor = super.readClassDescriptor();
+
+            if (resultClassDescriptor.getName().equals(
+                    ACCESS_TOKEN_APP_ID_PAIR_SERIALIZATION_PROXY_V1_CLASS_NAME)) {
+                resultClassDescriptor = ObjectStreamClass.lookup(
+                        com.facebook.appevents.AccessTokenAppIdPair.SerializationProxyV1.class);
+            } else if (resultClassDescriptor.getName().equals(
+                    APP_EVENT_SERIALIZATION_PROXY_V1_CLASS_NAME)) {
+                resultClassDescriptor = ObjectStreamClass.lookup(
+                        com.facebook.appevents.AppEvent.SerializationProxyV1.class);
+            }
+
+            return resultClassDescriptor;
+        }
+    }
+}
diff --git a/facebook/src/main/java/com/facebook/appevents/AppEventsLogger.java b/facebook/src/main/java/com/facebook/appevents/AppEventsLogger.java
index ce6beeaab..61883a439 100644
--- a/facebook/src/main/java/com/facebook/appevents/AppEventsLogger.java
+++ b/facebook/src/main/java/com/facebook/appevents/AppEventsLogger.java
@@ -55,8 +55,11 @@
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
+import java.io.ObjectStreamClass;
 import java.io.Serializable;
 import java.io.UnsupportedEncodingException;
 import java.math.BigDecimal;
@@ -171,8 +174,6 @@
     // Constants
     private static final String TAG = AppEventsLogger.class.getCanonicalName();
 
-    private static final int NUM_LOG_EVENTS_TO_TRY_TO_FLUSH_AFTER = 100;
-    private static final int FLUSH_PERIOD_IN_SECONDS = 15;
     private static final int APP_SUPPORTS_ATTRIBUTION_ID_RECHECK_PERIOD_IN_SECONDS = 60 * 60 * 24;
     private static final int FLUSH_APP_SESSION_INFO_IN_SECONDS = 30;
 
@@ -192,11 +193,8 @@
     private final String contextName;
     private final AccessTokenAppIdPair accessTokenAppId;
 
-    private static Map<AccessTokenAppIdPair, SessionEventsState> stateMap =
-            new ConcurrentHashMap<AccessTokenAppIdPair, SessionEventsState>();
     private static ScheduledThreadPoolExecutor backgroundExecutor;
     private static FlushBehavior flushBehavior = FlushBehavior.AUTO;
-    private static boolean requestInFlight;
     private static Context applicationContext;
     private static Object staticLock = new Object();
     private static String anonymousAppDeviceGUID;
@@ -205,66 +203,6 @@
     private static boolean isActivateAppEventRequested;
     private static String pushNotificationsRegistrationId;
 
-    private static class AccessTokenAppIdPair implements Serializable {
-        private static final long serialVersionUID = 1L;
-        private final String accessTokenString;
-        private final String applicationId;
-
-        AccessTokenAppIdPair(AccessToken accessToken) {
-            this(accessToken.getToken(), FacebookSdk.getApplicationId());
-        }
-
-        AccessTokenAppIdPair(String accessTokenString, String applicationId) {
-            this.accessTokenString = Utility.isNullOrEmpty(accessTokenString)
-                    ? null
-                    : accessTokenString;
-            this.applicationId = applicationId;
-        }
-
-        String getAccessTokenString() {
-            return accessTokenString;
-        }
-
-        String getApplicationId() {
-            return applicationId;
-        }
-
-        @Override
-        public int hashCode() {
-            return (accessTokenString == null ? 0 : accessTokenString.hashCode()) ^
-                    (applicationId == null ? 0 : applicationId.hashCode());
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (!(o instanceof AccessTokenAppIdPair)) {
-                return false;
-            }
-            AccessTokenAppIdPair p = (AccessTokenAppIdPair) o;
-            return Utility.areObjectsEqual(p.accessTokenString, accessTokenString) &&
-                    Utility.areObjectsEqual(p.applicationId, applicationId);
-        }
-
-        private static class SerializationProxyV1 implements Serializable {
-            private static final long serialVersionUID = -2488473066578201069L;
-            private final String accessTokenString;
-            private final String appId;
-
-            private SerializationProxyV1(String accessTokenString, String appId) {
-                this.accessTokenString = accessTokenString;
-                this.appId = appId;
-            }
-
-            private Object readResolve() {
-                return new AccessTokenAppIdPair(accessTokenString, appId);
-            }
-        }
-
-        private Object writeReplace() {
-            return new SerializationProxyV1(accessTokenString, applicationId);
-        }
-    }
-
     /**
      * Notifies the events system that the app has launched and activate and deactivate events
      * should start being logged automatically. This should be called from the OnCreate method
@@ -716,7 +654,7 @@ public void logPushNotificationOpen(Bundle payload, String action) {
      * the value of getFlushBehavior.  This method allows for explicit, app invoked flushing.
      */
     public void flush() {
-        flush(FlushReason.EXPLICIT);
+        AppEventQueue.flush(FlushReason.EXPLICIT);
     }
 
     /**
@@ -728,7 +666,7 @@ public void flush() {
      */
     public static void onContextStop() {
         // TODO: (v4) add onContextStop() to samples that use the logger.
-        PersistedEvents.persistEvents(applicationContext, stateMap);
+        AppEventQueue.persistToDisk();
     }
 
     /**
@@ -751,6 +689,11 @@ public static void setPushNotificationsRegistrationId(String registrationId) {
         }
     }
 
+    static String getPushNotificationsRegistrationId() {
+        synchronized (staticLock) {
+            return pushNotificationsRegistrationId;
+        }
+    }
     /**
      * This method is intended only for internal use by the Facebook SDK and other use is
      * unsupported.
@@ -777,24 +720,6 @@ public String getApplicationId() {
     // Private implementation
     //
 
-    @SuppressWarnings("UnusedDeclaration")
-    private enum FlushReason {
-        EXPLICIT,
-        TIMER,
-        SESSION_CHANGE,
-        PERSISTED_EVENTS,
-        EVENT_THRESHOLD,
-        EAGER_FLUSHING_EVENT,
-    }
-
-    @SuppressWarnings("UnusedDeclaration")
-    private enum FlushResult {
-        SUCCESS,
-        SERVER_ERROR,
-        NO_CONNECTIVITY,
-        UNKNOWN_ERROR
-    }
-
     /**
      * Constructor is private, newLogger() methods should be used to build an instance.
      */
@@ -837,28 +762,12 @@ private static void initializeTimersIfNeeded() {
             backgroundExecutor = new ScheduledThreadPoolExecutor(1);
         }
 
-        final Runnable flushRunnable = new Runnable() {
-            @Override
-            public void run() {
-                if (getFlushBehavior() != FlushBehavior.EXPLICIT_ONLY) {
-                    flushAndWait(FlushReason.TIMER);
-                }
-            }
-        };
-
-        backgroundExecutor.scheduleAtFixedRate(
-                flushRunnable,
-                0,
-                FLUSH_PERIOD_IN_SECONDS,
-                TimeUnit.SECONDS
-        );
-
         final Runnable attributionRecheckRunnable = new Runnable() {
             @Override
             public void run() {
-                Set<String> applicationIds = new HashSet<String>();
+                Set<String> applicationIds = new HashSet<>();
                 synchronized (staticLock) {
-                    for (AccessTokenAppIdPair accessTokenAppId : stateMap.keySet()) {
+                    for (AccessTokenAppIdPair accessTokenAppId : AppEventQueue.getKeySet()) {
                         applicationIds.add(accessTokenAppId.getApplicationId());
                     }
                 }
@@ -876,6 +785,10 @@ public void run() {
         );
     }
 
+    static Context getApplicationContext() {
+        return applicationContext;
+    }
+
     private void logEvent(
             String eventName,
             Double valueToSum,
@@ -895,17 +808,10 @@ private void logEvent(
     private static void logEvent(final Context context,
                                  final AppEvent event,
                                  final AccessTokenAppIdPair accessTokenAppId) {
-        FacebookSdk.getExecutor().execute(new Runnable() {
-            @Override
-            public void run() {
-                SessionEventsState state = getSessionEventsState(context, accessTokenAppId);
-                state.addEvent(event);
-                flushIfNecessary();
-            }
-        });
+        AppEventQueue.add(accessTokenAppId, event);
 
         // Make sure Activated_App is always before other app events
-        if (!event.isImplicit && !isActivateAppEventRequested) {
+        if (!event.getIsImplicit() && !isActivateAppEventRequested) {
             if (event.getName() == AppEventsConstants.EVENT_NAME_ACTIVATED_APP) {
                 isActivateAppEventRequested = true;
             } else {
@@ -920,282 +826,10 @@ public void run() {
 
     static void eagerFlush() {
         if (getFlushBehavior() != FlushBehavior.EXPLICIT_ONLY) {
-            flush(FlushReason.EAGER_FLUSHING_EVENT);
+            AppEventQueue.flush(FlushReason.EAGER_FLUSHING_EVENT);
         }
     }
 
-    private static void flushIfNecessary() {
-        synchronized (staticLock) {
-            if (getFlushBehavior() != FlushBehavior.EXPLICIT_ONLY) {
-                if (getAccumulatedEventCount() > NUM_LOG_EVENTS_TO_TRY_TO_FLUSH_AFTER) {
-                    flush(FlushReason.EVENT_THRESHOLD);
-                }
-            }
-        }
-    }
-
-    private static int getAccumulatedEventCount() {
-        synchronized (staticLock) {
-
-            int result = 0;
-            for (SessionEventsState state : stateMap.values()) {
-                result += state.getAccumulatedEventCount();
-            }
-            return result;
-        }
-    }
-
-    // Creates a new SessionEventsState if not already in the map.
-    private static SessionEventsState getSessionEventsState(
-            Context context,
-            AccessTokenAppIdPair accessTokenAppId) {
-        // Do this work outside of the lock to prevent deadlocks in implementation of
-        // AdvertisingIdClient.getAdvertisingIdInfo, because that implementation blocks waiting on
-        // the main thread, which may also grab this staticLock.
-        SessionEventsState state = stateMap.get(accessTokenAppId);
-        AttributionIdentifiers attributionIdentifiers = null;
-        if (state == null) {
-            // Retrieve attributionId, but we will only send it if attribution is supported for the
-            // app.
-            attributionIdentifiers = AttributionIdentifiers.getAttributionIdentifiers(context);
-        }
-
-        synchronized (staticLock) {
-            // Check state again while we're locked.
-            state = stateMap.get(accessTokenAppId);
-            if (state == null) {
-                state = new SessionEventsState(
-                        attributionIdentifiers,
-                        context.getPackageName(),
-                        getAnonymousAppDeviceGUID(context));
-                stateMap.put(accessTokenAppId, state);
-            }
-            return state;
-        }
-    }
-
-    private static SessionEventsState getSessionEventsState(AccessTokenAppIdPair accessTokenAppId) {
-        synchronized (staticLock) {
-            return stateMap.get(accessTokenAppId);
-        }
-    }
-
-    private static void flush(final FlushReason reason) {
-
-        FacebookSdk.getExecutor().execute(new Runnable() {
-            @Override
-            public void run() {
-                flushAndWait(reason);
-            }
-        });
-    }
-
-    private static void flushAndWait(final FlushReason reason) {
-
-        Set<AccessTokenAppIdPair> keysToFlush;
-        synchronized (staticLock) {
-            if (requestInFlight) {
-                return;
-            }
-            requestInFlight = true;
-            keysToFlush = new HashSet<AccessTokenAppIdPair>(stateMap.keySet());
-        }
-
-        accumulatePersistedEvents();
-
-        FlushStatistics flushResults = null;
-        try {
-            flushResults = buildAndExecuteRequests(reason, keysToFlush);
-        } catch (Exception e) {
-            Utility.logd(TAG, "Caught unexpected exception while flushing: ", e);
-        }
-
-        synchronized (staticLock) {
-            requestInFlight = false;
-        }
-
-        if (flushResults != null) {
-            final Intent intent = new Intent(ACTION_APP_EVENTS_FLUSHED);
-            intent.putExtra(APP_EVENTS_EXTRA_NUM_EVENTS_FLUSHED, flushResults.numEvents);
-            intent.putExtra(APP_EVENTS_EXTRA_FLUSH_RESULT, flushResults.result);
-            LocalBroadcastManager.getInstance(applicationContext).sendBroadcast(intent);
-        }
-    }
-
-    private static FlushStatistics buildAndExecuteRequests(
-            FlushReason reason,
-            Set<AccessTokenAppIdPair> keysToFlush) {
-        FlushStatistics flushResults = new FlushStatistics();
-
-        boolean limitEventUsage = FacebookSdk.getLimitEventAndDataUsage(applicationContext);
-
-        List<GraphRequest> requestsToExecute = new ArrayList<GraphRequest>();
-        for (AccessTokenAppIdPair accessTokenAppId : keysToFlush) {
-            SessionEventsState sessionEventsState = getSessionEventsState(accessTokenAppId);
-            if (sessionEventsState == null) {
-                continue;
-            }
-
-            GraphRequest request = buildRequestForSession(
-                    accessTokenAppId,
-                    sessionEventsState,
-                    limitEventUsage,
-                    flushResults);
-            if (request != null) {
-                requestsToExecute.add(request);
-            }
-        }
-
-        if (requestsToExecute.size() > 0) {
-            Logger.log(LoggingBehavior.APP_EVENTS, TAG, "Flushing %d events due to %s.",
-                    flushResults.numEvents,
-                    reason.toString());
-
-            for (GraphRequest request : requestsToExecute) {
-                // Execute the request synchronously. Callbacks will take care of handling errors
-                // and updating our final overall result.
-                request.executeAndWait();
-            }
-            return flushResults;
-        }
-
-        return null;
-    }
-
-    private static class FlushStatistics {
-        public int numEvents = 0;
-        public FlushResult result = FlushResult.SUCCESS;
-    }
-
-    private static GraphRequest buildRequestForSession(
-            final AccessTokenAppIdPair accessTokenAppId,
-            final SessionEventsState sessionEventsState,
-            final boolean limitEventUsage,
-            final FlushStatistics flushState) {
-        String applicationId = accessTokenAppId.getApplicationId();
-
-        Utility.FetchedAppSettings fetchedAppSettings =
-                Utility.queryAppSettings(applicationId, false);
-
-        final GraphRequest postRequest = GraphRequest.newPostRequest(
-                null,
-                String.format("%s/activities", applicationId),
-                null,
-                null);
-
-        Bundle requestParameters = postRequest.getParameters();
-        if (requestParameters == null) {
-            requestParameters = new Bundle();
-        }
-        requestParameters.putString("access_token", accessTokenAppId.getAccessTokenString());
-        if (pushNotificationsRegistrationId != null) {
-            requestParameters.putString("device_token", pushNotificationsRegistrationId);
-        }
-
-        postRequest.setParameters(requestParameters);
-
-        if (fetchedAppSettings == null) {
-            return null;
-        }
-
-        int numEvents = sessionEventsState.populateRequest(
-                postRequest,
-                fetchedAppSettings.supportsImplicitLogging(),
-                limitEventUsage);
-
-        if (numEvents == 0) {
-            return null;
-        }
-
-        flushState.numEvents += numEvents;
-
-        postRequest.setCallback(new GraphRequest.Callback() {
-            @Override
-            public void onCompleted(GraphResponse response) {
-                handleResponse(accessTokenAppId, postRequest, response, sessionEventsState, flushState);
-            }
-        });
-
-        return postRequest;
-    }
-
-    private static void handleResponse(
-            AccessTokenAppIdPair accessTokenAppId,
-            GraphRequest request,
-            GraphResponse response,
-            SessionEventsState sessionEventsState,
-            FlushStatistics flushState) {
-        FacebookRequestError error = response.getError();
-        String resultDescription = "Success";
-
-        FlushResult flushResult = FlushResult.SUCCESS;
-
-        if (error != null) {
-            final int NO_CONNECTIVITY_ERROR_CODE = -1;
-            if (error.getErrorCode() == NO_CONNECTIVITY_ERROR_CODE) {
-                resultDescription = "Failed: No Connectivity";
-                flushResult = FlushResult.NO_CONNECTIVITY;
-            } else {
-                resultDescription = String.format("Failed:\n  Response: %s\n  Error %s",
-                        response.toString(),
-                        error.toString());
-                flushResult = FlushResult.SERVER_ERROR;
-            }
-        }
-
-        if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.APP_EVENTS)) {
-            String eventsJsonString = (String) request.getTag();
-            String prettyPrintedEvents;
-
-            try {
-                JSONArray jsonArray = new JSONArray(eventsJsonString);
-                prettyPrintedEvents = jsonArray.toString(2);
-            } catch (JSONException exc) {
-                prettyPrintedEvents = "<Can't encode events for debug logging>";
-            }
-
-            Logger.log(LoggingBehavior.APP_EVENTS, TAG,
-                    "Flush completed\nParams: %s\n  Result: %s\n  Events JSON: %s",
-                    request.getGraphObject().toString(),
-                    resultDescription,
-                    prettyPrintedEvents);
-        }
-
-        sessionEventsState.clearInFlightAndStats(error != null);
-
-        if (flushResult == FlushResult.NO_CONNECTIVITY) {
-            // We may call this for multiple requests in a batch, which is slightly inefficient
-            // since in principle we could call it once for all failed requests, but the impact is
-            // likely to be minimal. We don't call this for other server errors, because if an event
-            // failed because it was malformed, etc., continually retrying it will cause subsequent
-            // events to not be logged either.
-            PersistedEvents.persistEvents(applicationContext, accessTokenAppId, sessionEventsState);
-        }
-
-        if (flushResult != FlushResult.SUCCESS) {
-            // We assume that connectivity issues are more significant to report than server issues.
-            if (flushState.result != FlushResult.NO_CONNECTIVITY) {
-                flushState.result = flushResult;
-            }
-        }
-    }
-
-    private static int accumulatePersistedEvents() {
-        PersistedEvents persistedEvents = PersistedEvents.readAndClearStore(applicationContext);
-
-        int result = 0;
-        for (AccessTokenAppIdPair accessTokenAppId : persistedEvents.keySet()) {
-            SessionEventsState sessionEventsState =
-                    getSessionEventsState(applicationContext, accessTokenAppId);
-
-            List<AppEvent> events = persistedEvents.getEvents(accessTokenAppId);
-            sessionEventsState.accumulatePersistedEvents(events);
-            result += events.size();
-        }
-
-        return result;
-    }
-
     /**
      * Invoke this method, rather than throwing an Exception, for situations where user/server input
      * might reasonably cause this to occur, and thus don't want an exception thrown at production
@@ -1313,311 +947,10 @@ public static String getAnonymousAppDeviceGUID(Context context) {
     // Deprecated Stuff
     //
 
+    // Since we moved some private classes to internal classes outside the AppEventsLogger class
+    // for backwards compatibility we can override the classDescriptor to resolve to the correct
+    // class
 
-    private static class SessionEventsState {
-        private List<AppEvent> accumulatedEvents = new ArrayList<AppEvent>();
-        private List<AppEvent> inFlightEvents = new ArrayList<AppEvent>();
-        private int numSkippedEventsDueToFullBuffer;
-        private AttributionIdentifiers attributionIdentifiers;
-        private String packageName;
-        private String anonymousAppDeviceGUID;
-
-        public static final String EVENT_COUNT_KEY = "event_count";
-        public static final String ENCODED_EVENTS_KEY = "encoded_events";
-        public static final String NUM_SKIPPED_KEY = "num_skipped";
-
-        private final int MAX_ACCUMULATED_LOG_EVENTS = 1000;
-
-        public SessionEventsState(
-                AttributionIdentifiers identifiers,
-                String packageName,
-                String anonymousGUID) {
-            this.attributionIdentifiers = identifiers;
-            this.packageName = packageName;
-            this.anonymousAppDeviceGUID = anonymousGUID;
-        }
-
-        // Synchronize here and in other methods on this class, because could be coming in from
-        // different AppEventsLoggers on different threads pointing at the same session.
-        public synchronized void addEvent(AppEvent event) {
-            if (accumulatedEvents.size() + inFlightEvents.size() >= MAX_ACCUMULATED_LOG_EVENTS) {
-                numSkippedEventsDueToFullBuffer++;
-            } else {
-                accumulatedEvents.add(event);
-            }
-        }
-
-        public synchronized int getAccumulatedEventCount() {
-            return accumulatedEvents.size();
-        }
-
-        public synchronized void clearInFlightAndStats(boolean moveToAccumulated) {
-            if (moveToAccumulated) {
-                accumulatedEvents.addAll(inFlightEvents);
-            }
-            inFlightEvents.clear();
-            numSkippedEventsDueToFullBuffer = 0;
-        }
-
-        public int populateRequest(GraphRequest request, boolean includeImplicitEvents,
-                                   boolean limitEventUsage) {
-
-            int numSkipped;
-            JSONArray jsonArray;
-            synchronized (this) {
-                numSkipped = numSkippedEventsDueToFullBuffer;
-
-                // move all accumulated events to inFlight.
-                inFlightEvents.addAll(accumulatedEvents);
-                accumulatedEvents.clear();
-
-                jsonArray = new JSONArray();
-                for (AppEvent event : inFlightEvents) {
-                    if (includeImplicitEvents || !event.getIsImplicit()) {
-                        jsonArray.put(event.getJSONObject());
-                    }
-                }
-
-                if (jsonArray.length() == 0) {
-                    return 0;
-                }
-            }
-
-            populateRequest(request, numSkipped, jsonArray, limitEventUsage);
-            return jsonArray.length();
-        }
-
-        public synchronized List<AppEvent> getEventsToPersist() {
-            // We will only persist accumulated events, not ones currently in-flight. This means if
-            // an in-flight request fails, those requests will not be persisted and thus might be
-            // lost if the process terminates while the flush is in progress.
-            List<AppEvent> result = accumulatedEvents;
-            accumulatedEvents = new ArrayList<AppEvent>();
-            return result;
-        }
-
-        public synchronized void accumulatePersistedEvents(List<AppEvent> events) {
-            // We won't skip events due to a full buffer, since we already accumulated them once and
-            // persisted them. But they will count against the buffer size when further events are
-            // accumulated.
-            accumulatedEvents.addAll(events);
-        }
-
-        private void populateRequest(GraphRequest request, int numSkipped, JSONArray events,
-                                     boolean limitEventUsage) {
-            JSONObject publishParams = null;
-            try {
-                publishParams = AppEventsLoggerUtility.getJSONObjectForGraphAPICall(
-                        AppEventsLoggerUtility.GraphAPIActivityType.CUSTOM_APP_EVENTS,
-                        attributionIdentifiers,
-                        anonymousAppDeviceGUID,
-                        limitEventUsage,
-                        applicationContext);
-
-                if (numSkippedEventsDueToFullBuffer > 0) {
-                    publishParams.put("num_skipped_events", numSkipped);
-                }
-            } catch (JSONException e) {
-                // Swallow
-                publishParams = new JSONObject();
-            }
-            request.setGraphObject(publishParams);
-
-            Bundle requestParameters = request.getParameters();
-            if (requestParameters == null) {
-                requestParameters = new Bundle();
-            }
-
-            String jsonString = events.toString();
-            if (jsonString != null) {
-                requestParameters.putByteArray(
-                        "custom_events_file",
-                        getStringAsByteArray(jsonString));
-                request.setTag(jsonString);
-            }
-            request.setParameters(requestParameters);
-        }
-
-        private byte[] getStringAsByteArray(String jsonString) {
-            byte[] jsonUtf8 = null;
-            try {
-                jsonUtf8 = jsonString.getBytes("UTF-8");
-            } catch (UnsupportedEncodingException e) {
-                // shouldn't happen, but just in case:
-                Utility.logd("Encoding exception: ", e);
-            }
-            return jsonUtf8;
-        }
-    }
-
-    static class AppEvent implements Serializable {
-        private static final long serialVersionUID = 1L;
-
-        private JSONObject jsonObject;
-        private boolean isImplicit;
-        private static final HashSet<String> validatedIdentifiers = new HashSet<String>();
-        private String name;
-
-        public AppEvent(
-                String contextName,
-                String eventName,
-                Double valueToSum,
-                Bundle parameters,
-                boolean isImplicitlyLogged,
-                @Nullable final UUID currentSessionId
-        ) {
-            try {
-                validateIdentifier(eventName);
-
-                this.name = eventName;
-                isImplicit = isImplicitlyLogged;
-                jsonObject = new JSONObject();
-
-                jsonObject.put("_eventName", eventName);
-                jsonObject.put(Constants.LOG_TIME_APP_EVENT_KEY, System.currentTimeMillis() / 1000);
-                jsonObject.put("_ui", contextName);
-                if (currentSessionId != null) {
-                    jsonObject.put("_session_id", currentSessionId);
-                }
-
-                if (valueToSum != null) {
-                    jsonObject.put("_valueToSum", valueToSum.doubleValue());
-                }
-
-                if (isImplicit) {
-                    jsonObject.put("_implicitlyLogged", "1");
-                }
-
-                if (parameters != null) {
-                    for (String key : parameters.keySet()) {
-
-                        validateIdentifier(key);
-
-                        Object value = parameters.get(key);
-                        if (!(value instanceof String) && !(value instanceof Number)) {
-                            throw new FacebookException(
-                                    String.format(
-                                            "Parameter value '%s' for key '%s' should be a string" +
-                                                    " or a numeric type.",
-                                            value,
-                                            key)
-                            );
-                        }
-
-                        jsonObject.put(key, value.toString());
-                    }
-                }
-
-                if (!isImplicit) {
-                    Logger.log(LoggingBehavior.APP_EVENTS, "AppEvents",
-                            "Created app event '%s'", jsonObject.toString());
-                }
-            } catch (JSONException jsonException) {
-
-                // If any of the above failed, just consider this an illegal event.
-                Logger.log(LoggingBehavior.APP_EVENTS, "AppEvents",
-                        "JSON encoding for app event failed: '%s'", jsonException.toString());
-                jsonObject = null;
-
-            } catch (FacebookException e) {
-                // If any of the above failed, just consider this an illegal event.
-                Logger.log(LoggingBehavior.APP_EVENTS, "AppEvents",
-                        "Invalid app event name or parameter:", e.toString());
-                jsonObject = null;
-            }
-        }
-
-        public String getName() {
-            return name;
-        }
-
-        private AppEvent(String jsonString, boolean isImplicit) throws JSONException {
-            jsonObject = new JSONObject(jsonString);
-            this.isImplicit = isImplicit;
-        }
-
-        public boolean getIsImplicit() {
-            return isImplicit;
-        }
-
-        public JSONObject getJSONObject() {
-            return jsonObject;
-        }
-
-        // throw exception if not valid.
-        private void validateIdentifier(String identifier) throws FacebookException {
-
-            // Identifier should be 40 chars or less, and only have 0-9A-Za-z, underscore, hyphen,
-            // and space (but no hyphen or space in the first position).
-            final String regex = "^[0-9a-zA-Z_]+[0-9a-zA-Z _-]*$";
-
-            final int MAX_IDENTIFIER_LENGTH = 40;
-            if (identifier == null
-                    || identifier.length() == 0
-                    || identifier.length() > MAX_IDENTIFIER_LENGTH) {
-                if (identifier == null) {
-                    identifier = "<None Provided>";
-                }
-                throw new FacebookException(
-                    String.format(
-                            Locale.ROOT,
-                            "Identifier '%s' must be less than %d characters",
-                            identifier,
-                            MAX_IDENTIFIER_LENGTH)
-                );
-            }
-
-            boolean alreadyValidated = false;
-            synchronized (validatedIdentifiers) {
-                alreadyValidated = validatedIdentifiers.contains(identifier);
-            }
-
-            if (!alreadyValidated) {
-                if (identifier.matches(regex)) {
-                    synchronized (validatedIdentifiers) {
-                        validatedIdentifiers.add(identifier);
-                    }
-                } else {
-                    throw new FacebookException(
-                            String.format(
-                                    "Skipping event named '%s' due to illegal name - must be " +
-                                            "under 40 chars and alphanumeric, _, - or space, and " +
-                                            "not start with a space or hyphen.",
-                                    identifier
-                            )
-                    );
-                }
-            }
-        }
-
-        private static class SerializationProxyV1 implements Serializable {
-            private static final long serialVersionUID = -2488473066578201069L;
-            private final String jsonString;
-            private final boolean isImplicit;
-
-            private SerializationProxyV1(String jsonString, boolean isImplicit) {
-                this.jsonString = jsonString;
-                this.isImplicit = isImplicit;
-            }
-
-            private Object readResolve() throws JSONException {
-                return new AppEvent(jsonString, isImplicit);
-            }
-        }
-
-        private Object writeReplace() {
-            return new SerializationProxyV1(jsonObject.toString(), isImplicit);
-        }
-
-        @Override
-        public String toString() {
-            return String.format(
-                    "\"%s\", implicit: %b, json: %s",
-                    jsonObject.optString("_eventName"),
-                    isImplicit,
-                    jsonObject.toString());
-        }
-    }
 
     static class PersistedAppSessionInfo {
         private static final String PERSISTED_SESSION_INFO_FILENAME =
@@ -1642,9 +975,8 @@ private static void restoreAppSessionInformation(Context context) {
             synchronized (staticLock) {
                 if (!isLoaded) {
                     try {
-                        ois =
-                                new ObjectInputStream(
-                                        context.openFileInput(PERSISTED_SESSION_INFO_FILENAME));
+                        ois = new ObjectInputStream(
+                            context.openFileInput(PERSISTED_SESSION_INFO_FILENAME));
                         appSessionInfoMap = (HashMap<AccessTokenAppIdPair, FacebookTimeSpentData>)
                                 ois.readObject();
                         Logger.log(
@@ -1653,7 +985,10 @@ private static void restoreAppSessionInformation(Context context) {
                                 "App session info loaded");
                     } catch (FileNotFoundException fex) {
                     } catch (Exception e) {
-                        Log.d(TAG, "Got unexpected exception: " + e.toString());
+                        Log.w(
+                                TAG,
+                                "Got unexpected exception restoring app session info: "
+                                        + e.toString());
                     } finally {
                         Utility.closeQuietly(ois);
                         context.deleteFile(PERSISTED_SESSION_INFO_FILENAME);
@@ -1691,7 +1026,10 @@ static void saveAppSessionInformation(Context context) {
                                 "AppEvents",
                                 "App session info saved");
                     } catch (Exception e) {
-                        Log.d(TAG, "Got unexpected exception: " + e.toString());
+                        Log.w(
+                                TAG,
+                                "Got unexpected exception while writing app session info: "
+                                        + e.toString());
                     } finally {
                         Utility.closeQuietly(oos);
                     }
@@ -1752,115 +1090,4 @@ private static void onTimeSpentDataUpdate() {
             }
         }
     }
-
-    // Read/write operations are thread-safe/atomic across all instances of PersistedEvents, but
-    // modifications to any individual instance are not thread-safe.
-    static class PersistedEvents {
-        static final String PERSISTED_EVENTS_FILENAME = "AppEventsLogger.persistedevents";
-
-        private Context context;
-        private HashMap<AccessTokenAppIdPair, List<AppEvent>> persistedEvents =
-                new HashMap<AccessTokenAppIdPair, List<AppEvent>>();
-
-        private PersistedEvents(Context context) {
-            this.context = context;
-        }
-
-        public static PersistedEvents readAndClearStore(Context context) {
-            synchronized (staticLock) {
-                PersistedEvents persistedEvents = new PersistedEvents(context);
-
-                persistedEvents.readAndClearStore();
-
-                return persistedEvents;
-            }
-        }
-
-        public static void persistEvents(Context context, AccessTokenAppIdPair accessTokenAppId,
-                                         SessionEventsState eventsToPersist) {
-            Map<AccessTokenAppIdPair, SessionEventsState> map = new HashMap<AccessTokenAppIdPair, SessionEventsState>();
-            map.put(accessTokenAppId, eventsToPersist);
-            persistEvents(context, map);
-        }
-
-        public static void persistEvents(
-                Context context,
-                Map<AccessTokenAppIdPair,
-                        SessionEventsState> eventsToPersist) {
-            synchronized (staticLock) {
-                // Note that we don't track which instance of AppEventsLogger added a particular
-                // event to SessionEventsState; when a particular Context is being destroyed, we'll
-                // persist all accumulated events. More sophisticated tracking could be done to try
-                // to reduce unnecessary persisting of events, but the overall number of events is
-                // not expected to be large.
-                PersistedEvents persistedEvents = readAndClearStore(context);
-
-                for (Map.Entry<AccessTokenAppIdPair, SessionEventsState> entry
-                        : eventsToPersist.entrySet()) {
-                    List<AppEvent> events = entry.getValue().getEventsToPersist();
-                    if (events.size() == 0) {
-                        continue;
-                    }
-
-                    persistedEvents.addEvents(entry.getKey(), events);
-                }
-
-                persistedEvents.write();
-            }
-        }
-
-        public Set<AccessTokenAppIdPair> keySet() {
-            return persistedEvents.keySet();
-        }
-
-        public List<AppEvent> getEvents(AccessTokenAppIdPair accessTokenAppId) {
-            return persistedEvents.get(accessTokenAppId);
-        }
-
-        private void write() {
-            ObjectOutputStream oos = null;
-            try {
-                oos = new ObjectOutputStream(
-                        new BufferedOutputStream(
-                                context.openFileOutput(PERSISTED_EVENTS_FILENAME, 0)));
-                oos.writeObject(persistedEvents);
-            } catch (Exception e) {
-                Log.d(TAG, "Got unexpected exception: " + e.toString());
-            } finally {
-                Utility.closeQuietly(oos);
-            }
-        }
-
-        private void readAndClearStore() {
-            ObjectInputStream ois = null;
-            try {
-                ois = new ObjectInputStream(
-                        new BufferedInputStream(context.openFileInput(PERSISTED_EVENTS_FILENAME)));
-
-                @SuppressWarnings("unchecked")
-                HashMap<AccessTokenAppIdPair, List<AppEvent>> obj =
-                        (HashMap<AccessTokenAppIdPair, List<AppEvent>>) ois.readObject();
-
-                // Note: We delete the store before we store the events; this means we'd prefer to
-                // lose some events in the case of exception rather than potentially log them twice.
-                context.getFileStreamPath(PERSISTED_EVENTS_FILENAME).delete();
-                persistedEvents = obj;
-            } catch (FileNotFoundException e) {
-                // Expected if we never persisted any events.
-            } catch (Exception e) {
-                Log.d(TAG, "Got unexpected exception: " + e.toString());
-            } finally {
-                Utility.closeQuietly(ois);
-            }
-        }
-
-        public void addEvents(
-                AccessTokenAppIdPair accessTokenAppId,
-                List<AppEvent> eventsToPersist) {
-            if (!persistedEvents.containsKey(accessTokenAppId)) {
-                persistedEvents.put(accessTokenAppId, new ArrayList<AppEvent>());
-            }
-            persistedEvents.get(accessTokenAppId).addAll(eventsToPersist);
-        }
-    }
 }
diff --git a/facebook/src/main/java/com/facebook/appevents/FlushReason.java b/facebook/src/main/java/com/facebook/appevents/FlushReason.java
new file mode 100644
index 000000000..48e4ed827
--- /dev/null
+++ b/facebook/src/main/java/com/facebook/appevents/FlushReason.java
@@ -0,0 +1,30 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.appevents;
+
+enum FlushReason {
+    EXPLICIT,
+    TIMER,
+    SESSION_CHANGE,
+    PERSISTED_EVENTS,
+    EVENT_THRESHOLD,
+    EAGER_FLUSHING_EVENT,
+}
diff --git a/facebook/src/main/java/com/facebook/appevents/FlushResult.java b/facebook/src/main/java/com/facebook/appevents/FlushResult.java
new file mode 100644
index 000000000..064dc3190
--- /dev/null
+++ b/facebook/src/main/java/com/facebook/appevents/FlushResult.java
@@ -0,0 +1,28 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.appevents;
+
+public enum FlushResult {
+    SUCCESS,
+    SERVER_ERROR,
+    NO_CONNECTIVITY,
+    UNKNOWN_ERROR
+}
diff --git a/facebook/src/main/java/com/facebook/appevents/FlushStatistics.java b/facebook/src/main/java/com/facebook/appevents/FlushStatistics.java
new file mode 100644
index 000000000..5e8e6efe0
--- /dev/null
+++ b/facebook/src/main/java/com/facebook/appevents/FlushStatistics.java
@@ -0,0 +1,26 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.appevents;
+
+class FlushStatistics {
+    public int numEvents = 0;
+    public FlushResult result = FlushResult.SUCCESS;
+}
diff --git a/facebook/src/main/java/com/facebook/appevents/PersistedEvents.java b/facebook/src/main/java/com/facebook/appevents/PersistedEvents.java
new file mode 100644
index 000000000..0163f8ea6
--- /dev/null
+++ b/facebook/src/main/java/com/facebook/appevents/PersistedEvents.java
@@ -0,0 +1,33 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.appevents;
+
+import java.util.HashMap;
+import java.util.List;
+
+public class PersistedEvents extends HashMap<AccessTokenAppIdPair, List<AppEvent>> {
+    public PersistedEvents() {
+        super();
+    }
+    public PersistedEvents(HashMap<AccessTokenAppIdPair, List<AppEvent>> appEventMap) {
+        super(appEventMap);
+    }
+}
diff --git a/facebook/src/main/java/com/facebook/appevents/SessionEventsState.java b/facebook/src/main/java/com/facebook/appevents/SessionEventsState.java
new file mode 100644
index 000000000..cf1890073
--- /dev/null
+++ b/facebook/src/main/java/com/facebook/appevents/SessionEventsState.java
@@ -0,0 +1,178 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.appevents;
+
+import android.content.Context;
+import android.os.Bundle;
+
+import com.facebook.GraphRequest;
+import com.facebook.internal.AppEventsLoggerUtility;
+import com.facebook.internal.AttributionIdentifiers;
+import com.facebook.internal.Utility;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+import java.util.List;
+
+class SessionEventsState {
+    private List<AppEvent> accumulatedEvents = new ArrayList<AppEvent>();
+    private List<AppEvent> inFlightEvents = new ArrayList<AppEvent>();
+    private int numSkippedEventsDueToFullBuffer;
+    private AttributionIdentifiers attributionIdentifiers;
+    private String anonymousAppDeviceGUID;
+
+    private final int MAX_ACCUMULATED_LOG_EVENTS = 1000;
+
+    public SessionEventsState(
+            AttributionIdentifiers identifiers,
+            String anonymousGUID) {
+        this.attributionIdentifiers = identifiers;
+        this.anonymousAppDeviceGUID = anonymousGUID;
+    }
+
+    // Synchronize here and in other methods on this class, because could be coming in from
+    // different AppEventsLoggers on different threads pointing at the same session.
+    public synchronized void addEvent(AppEvent event) {
+        if (accumulatedEvents.size() + inFlightEvents.size() >= MAX_ACCUMULATED_LOG_EVENTS) {
+            numSkippedEventsDueToFullBuffer++;
+        } else {
+            accumulatedEvents.add(event);
+        }
+    }
+
+    public synchronized int getAccumulatedEventCount() {
+        return accumulatedEvents.size();
+    }
+
+    public synchronized void clearInFlightAndStats(boolean moveToAccumulated) {
+        if (moveToAccumulated) {
+            accumulatedEvents.addAll(inFlightEvents);
+        }
+        inFlightEvents.clear();
+        numSkippedEventsDueToFullBuffer = 0;
+    }
+
+    public int populateRequest(
+            GraphRequest request,
+            Context applicationContext,
+            boolean includeImplicitEvents,
+            boolean limitEventUsage) {
+
+        int numSkipped;
+        JSONArray jsonArray;
+        synchronized (this) {
+            numSkipped = numSkippedEventsDueToFullBuffer;
+
+            // move all accumulated events to inFlight.
+            inFlightEvents.addAll(accumulatedEvents);
+            accumulatedEvents.clear();
+
+            jsonArray = new JSONArray();
+            for (AppEvent event : inFlightEvents) {
+                if (includeImplicitEvents || !event.getIsImplicit()) {
+                    jsonArray.put(event.getJSONObject());
+                }
+            }
+
+            if (jsonArray.length() == 0) {
+                return 0;
+            }
+        }
+
+        populateRequest(
+                request,
+                applicationContext,
+                numSkipped,
+                jsonArray,
+                limitEventUsage);
+        return jsonArray.length();
+    }
+
+    public synchronized List<AppEvent> getEventsToPersist() {
+        // We will only persist accumulated events, not ones currently in-flight. This means if
+        // an in-flight request fails, those requests will not be persisted and thus might be
+        // lost if the process terminates while the flush is in progress.
+        List<AppEvent> result = accumulatedEvents;
+        accumulatedEvents = new ArrayList<AppEvent>();
+        return result;
+    }
+
+    public synchronized void accumulatePersistedEvents(List<AppEvent> events) {
+        // We won't skip events due to a full buffer, since we already accumulated them once and
+        // persisted them. But they will count against the buffer size when further events are
+        // accumulated.
+        accumulatedEvents.addAll(events);
+    }
+
+    private void populateRequest(
+            GraphRequest request,
+            Context applicationContext,
+            int numSkipped,
+            JSONArray events,
+            boolean limitEventUsage) {
+        JSONObject publishParams = null;
+        try {
+            publishParams = AppEventsLoggerUtility.getJSONObjectForGraphAPICall(
+                    AppEventsLoggerUtility.GraphAPIActivityType.CUSTOM_APP_EVENTS,
+                    attributionIdentifiers,
+                    anonymousAppDeviceGUID,
+                    limitEventUsage,
+                    applicationContext);
+
+            if (numSkippedEventsDueToFullBuffer > 0) {
+                publishParams.put("num_skipped_events", numSkipped);
+            }
+        } catch (JSONException e) {
+            // Swallow
+            publishParams = new JSONObject();
+        }
+        request.setGraphObject(publishParams);
+
+        Bundle requestParameters = request.getParameters();
+        if (requestParameters == null) {
+            requestParameters = new Bundle();
+        }
+
+        String jsonString = events.toString();
+        if (jsonString != null) {
+            requestParameters.putByteArray(
+                    "custom_events_file",
+                    getStringAsByteArray(jsonString));
+            request.setTag(jsonString);
+        }
+        request.setParameters(requestParameters);
+    }
+
+    private byte[] getStringAsByteArray(String jsonString) {
+        byte[] jsonUtf8 = null;
+        try {
+            jsonUtf8 = jsonString.getBytes("UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            // shouldn't happen, but just in case:
+            Utility.logd("Encoding exception: ", e);
+        }
+        return jsonUtf8;
+    }
+}
diff --git a/facebook/src/main/java/com/facebook/appevents/internal/ActivityLifecycleTracker.java b/facebook/src/main/java/com/facebook/appevents/internal/ActivityLifecycleTracker.java
index bc1a1db10..9c027ab13 100644
--- a/facebook/src/main/java/com/facebook/appevents/internal/ActivityLifecycleTracker.java
+++ b/facebook/src/main/java/com/facebook/appevents/internal/ActivityLifecycleTracker.java
@@ -141,7 +141,8 @@ public void run() {
         singleThreadExecutor.execute(handleActivityCreate);
     }
 
-    private static void onActivityResumed(final Activity activity) {
+    // Public in order to allow unity sdk to correctly log app events
+    public static void onActivityResumed(final Activity activity) {
         foregroundActivityCount.incrementAndGet();
         cancelCurrentTask();
         final long currentTime = System.currentTimeMillis();
@@ -258,7 +259,7 @@ private static void assertIsMainThread() {
         if (BuildConfig.DEBUG){
             boolean isMainThread = Looper.myLooper() == Looper.getMainLooper();
             Assert.assertTrue(
-                    "Activity Lifecycle Callback not runnin on main thread",
+                    "Activity Lifecycle Callback not running on main thread",
                     isMainThread);
         }
     }
diff --git a/facebook/src/main/java/com/facebook/internal/NativeProtocol.java b/facebook/src/main/java/com/facebook/internal/NativeProtocol.java
index 0edde69e1..4800cf950 100644
--- a/facebook/src/main/java/com/facebook/internal/NativeProtocol.java
+++ b/facebook/src/main/java/com/facebook/internal/NativeProtocol.java
@@ -29,6 +29,8 @@
 import android.os.Build;
 import android.os.Bundle;
 import android.text.TextUtils;
+import android.util.Log;
+
 import com.facebook.FacebookException;
 import com.facebook.FacebookOperationCanceledException;
 import com.facebook.FacebookSdk;
@@ -50,6 +52,8 @@
 
     public static final int NO_PROTOCOL_AVAILABLE = -1;
 
+    private static final String TAG = NativeProtocol.class.getName();
+
     private static final String FACEBOOK_PROXY_AUTH_ACTIVITY = "com.facebook.katana.ProxyAuth";
     private static final String FACEBOOK_TOKEN_REFRESH_ACTIVITY =
             "com.facebook.katana.platform.TokenRefreshService";
@@ -311,7 +315,6 @@ protected String getPackage() {
         }
     }
 
-    private static final NativeAppInfo FACEBOOK_APP_INFO = new KatanaAppInfo();
     private static List<NativeAppInfo> facebookAppInfoList = buildFacebookAppList();
     private static Map<String, List<NativeAppInfo>> actionToAppInfoMap = buildActionToAppInfoMap();
     private static AtomicBoolean protocolVersionsAsyncUpdating = new AtomicBoolean(false);
@@ -321,7 +324,7 @@ protected String getPackage() {
 
         // Katana needs to be the first thing in the list since it will get selected as the default
         // FACEBOOK_APP_INFO
-        list.add(FACEBOOK_APP_INFO);
+        list.add(new KatanaAppInfo());
         list.add(new WakizashiAppInfo());
 
         return list;
@@ -789,7 +792,18 @@ public void run() {
             String contentProviderName = appInfo.getPackage() + PLATFORM_PROVIDER;
             ProviderInfo pInfo = pm.resolveContentProvider(contentProviderName, 0);
             if (pInfo != null) {
-                c = contentResolver.query(uri, projection, null, null, null);
+                try {
+                    c = contentResolver.query(uri, projection, null, null, null);
+                } catch (NullPointerException|SecurityException ex) {
+                    Log.e(TAG, "Failed to query content resolver.");
+                    // Meizu devices running Android 5.0+ have a bug where they can throw a
+                    // NullPointerException when trying resolve a ContentProvider. Additionally,
+                    // rarely some 5.0+ devices have a bug which can rarely cause a
+                    // SecurityException to be thrown. This will cause a incorrect indication
+                    // of if the FB app installed but it is better then crashing.
+                    c = null;
+                }
+
                 if (c != null) {
                     while (c.moveToNext()) {
                         int version = c.getInt(c.getColumnIndex(PLATFORM_PROVIDER_VERSION_COLUMN));
@@ -797,13 +811,13 @@ public void run() {
                     }
                 }
             }
-
-            return allAvailableVersions;
         } finally {
             if (c != null) {
                 c.close();
             }
         }
+
+        return allAvailableVersions;
     }
 
     public static int computeLatestAvailableVersionFromVersionSpec(
diff --git a/facebook/src/main/java/com/facebook/login/CustomTabLoginMethodHandler.java b/facebook/src/main/java/com/facebook/login/CustomTabLoginMethodHandler.java
index 5dbdff349..9cba702c8 100644
--- a/facebook/src/main/java/com/facebook/login/CustomTabLoginMethodHandler.java
+++ b/facebook/src/main/java/com/facebook/login/CustomTabLoginMethodHandler.java
@@ -59,7 +59,7 @@ String getNameForLogging() {
 
     @Override
     AccessTokenSource getTokenSource() {
-        return AccessTokenSource.CUSTOM_TAB;
+        return AccessTokenSource.CHROME_CUSTOM_TAB;
     }
 
     @Override
diff --git a/facebook/src/main/java/com/facebook/login/LoginManager.java b/facebook/src/main/java/com/facebook/login/LoginManager.java
index 33cbcac15..688549dff 100644
--- a/facebook/src/main/java/com/facebook/login/LoginManager.java
+++ b/facebook/src/main/java/com/facebook/login/LoginManager.java
@@ -589,7 +589,7 @@ public static void setSuccessResult(Intent intent, Bundle values) {
         AccessToken token = LoginMethodHandler.createAccessTokenFromWebBundle(
                 request.getPermissions(),
                 values,
-                AccessTokenSource.CUSTOM_TAB,
+                AccessTokenSource.CHROME_CUSTOM_TAB,
                 request.getApplicationId());
         LoginClient.Result result = LoginClient.Result.createTokenResult(request, token);
         intent.putExtra(LoginFragment.RESULT_KEY, result);
diff --git a/facebook/src/main/java/com/facebook/login/WebLoginMethodHandler.java b/facebook/src/main/java/com/facebook/login/WebLoginMethodHandler.java
index 0a0db1937..b820bd9a4 100644
--- a/facebook/src/main/java/com/facebook/login/WebLoginMethodHandler.java
+++ b/facebook/src/main/java/com/facebook/login/WebLoginMethodHandler.java
@@ -108,13 +108,9 @@ protected Bundle addExtraParameters(Bundle parameters, final LoginClient.Request
         parameters.putString(
                 ServerProtocol.DIALOG_PARAM_RETURN_SCOPES,
                 ServerProtocol.DIALOG_RETURN_SCOPES_TRUE);
-
-        // Set the re-request auth type for requests
-        if (request.isRerequest()) {
-            parameters.putString(
-                    ServerProtocol.DIALOG_PARAM_AUTH_TYPE,
-                    ServerProtocol.DIALOG_REREQUEST_AUTH_TYPE);
-        }
+        parameters.putString(
+                ServerProtocol.DIALOG_PARAM_AUTH_TYPE,
+                ServerProtocol.DIALOG_REREQUEST_AUTH_TYPE);
 
         return parameters;
     }
diff --git a/facebook/src/main/java/com/facebook/login/WebViewLoginMethodHandler.java b/facebook/src/main/java/com/facebook/login/WebViewLoginMethodHandler.java
index cb7245c6c..e83ead459 100644
--- a/facebook/src/main/java/com/facebook/login/WebViewLoginMethodHandler.java
+++ b/facebook/src/main/java/com/facebook/login/WebViewLoginMethodHandler.java
@@ -134,13 +134,9 @@ public WebDialog build() {
             parameters.putString(
                     ServerProtocol.DIALOG_PARAM_RETURN_SCOPES,
                     ServerProtocol.DIALOG_RETURN_SCOPES_TRUE);
-
-            // Set the re-request auth type for requests
-            if (isRerequest) {
-                parameters.putString(
+            parameters.putString(
                         ServerProtocol.DIALOG_PARAM_AUTH_TYPE,
                         ServerProtocol.DIALOG_REREQUEST_AUTH_TYPE);
-            }
 
             return new WebDialog(getContext(), OAUTH_DIALOG, parameters, getTheme(), getListener());
         }
diff --git a/facebook/src/main/java/com/facebook/share/internal/LikeContent.java b/facebook/src/main/java/com/facebook/share/internal/LikeContent.java
index 481c03575..ffd46cbce 100644
--- a/facebook/src/main/java/com/facebook/share/internal/LikeContent.java
+++ b/facebook/src/main/java/com/facebook/share/internal/LikeContent.java
@@ -126,11 +126,5 @@ public Builder readFrom(final LikeContent content) {
                     .setObjectId(content.getObjectId())
                     .setObjectType(content.getObjectType());
         }
-
-        @Override
-        public Builder readFrom(final Parcel parcel) {
-            return this.readFrom((LikeContent) parcel
-                    .readParcelable(LikeContent.class.getClassLoader()));
-        }
     }
 }
diff --git a/facebook/src/main/java/com/facebook/share/internal/ShareFeedContent.java b/facebook/src/main/java/com/facebook/share/internal/ShareFeedContent.java
index 2ae7bf88f..295ca4047 100644
--- a/facebook/src/main/java/com/facebook/share/internal/ShareFeedContent.java
+++ b/facebook/src/main/java/com/facebook/share/internal/ShareFeedContent.java
@@ -186,13 +186,5 @@ public Builder readFrom(final ShareFeedContent model) {
                     .setMediaSource(model.getMediaSource())
                     ;
         }
-
-        @Override
-        public Builder readFrom(final Parcel parcel) {
-            return this.readFrom(
-                    (ShareFeedContent) parcel.readParcelable(
-                            ShareFeedContent.class.getClassLoader()));
-        }
-
     }
 }
diff --git a/facebook/src/main/java/com/facebook/share/internal/WebDialogParameters.java b/facebook/src/main/java/com/facebook/share/internal/WebDialogParameters.java
index 3cff1b099..68d7774b6 100644
--- a/facebook/src/main/java/com/facebook/share/internal/WebDialogParameters.java
+++ b/facebook/src/main/java/com/facebook/share/internal/WebDialogParameters.java
@@ -193,6 +193,18 @@ public static Bundle createForFeed(ShareLinkContent shareLinkContent) {
                 ShareConstants.WEB_DIALOG_PARAM_PICTURE,
                 Utility.getUriString(shareLinkContent.getImageUrl()));
 
+        Utility.putNonEmptyString(
+                webParams,
+                ShareConstants.WEB_DIALOG_PARAM_QUOTE,
+                shareLinkContent.getQuote());
+
+        ShareHashtag shareHashtag = shareLinkContent.getShareHashtag();
+        if (shareHashtag != null) {
+            Utility.putNonEmptyString(
+                    webParams,
+                    ShareConstants.WEB_DIALOG_PARAM_HASHTAG,
+                    shareLinkContent.getShareHashtag().getHashtag());
+        }
         return webParams;
     }
 
diff --git a/facebook/src/main/java/com/facebook/share/model/AppGroupCreationContent.java b/facebook/src/main/java/com/facebook/share/model/AppGroupCreationContent.java
index a63f5f9dd..d85a06756 100644
--- a/facebook/src/main/java/com/facebook/share/model/AppGroupCreationContent.java
+++ b/facebook/src/main/java/com/facebook/share/model/AppGroupCreationContent.java
@@ -164,12 +164,5 @@ public Builder readFrom(final AppGroupCreationContent content) {
                     .setDescription(content.getDescription())
                     .setAppGroupPrivacy(content.getAppGroupPrivacy());
         }
-
-        @Override
-        public Builder readFrom(final Parcel parcel) {
-            return this.readFrom(
-                    (AppGroupCreationContent) parcel.readParcelable(
-                            AppGroupCreationContent.class.getClassLoader()));
-        }
     }
 }
diff --git a/facebook/src/main/java/com/facebook/share/model/AppInviteContent.java b/facebook/src/main/java/com/facebook/share/model/AppInviteContent.java
index 46d313295..00bd93361 100644
--- a/facebook/src/main/java/com/facebook/share/model/AppInviteContent.java
+++ b/facebook/src/main/java/com/facebook/share/model/AppInviteContent.java
@@ -200,12 +200,6 @@ public Builder readFrom(final AppInviteContent content) {
                     .setPromotionDetails(content.getPromotionText(), content.getPromotionCode());
         }
 
-        @Override
-        public Builder readFrom(final Parcel parcel) {
-            return this.readFrom((AppInviteContent) parcel
-                    .readParcelable(AppInviteContent.class.getClassLoader()));
-        }
-
         private boolean isAlphanumericWithSpaces(String str) {
             for (int i=0; i<str.length(); i++) {
                 char c = str.charAt(i);
diff --git a/facebook/src/main/java/com/facebook/share/model/GameRequestContent.java b/facebook/src/main/java/com/facebook/share/model/GameRequestContent.java
index 3f1b81c2b..d9d185471 100644
--- a/facebook/src/main/java/com/facebook/share/model/GameRequestContent.java
+++ b/facebook/src/main/java/com/facebook/share/model/GameRequestContent.java
@@ -303,8 +303,7 @@ public Builder readFrom(final GameRequestContent content) {
                     .setSuggestions(content.getSuggestions());
         }
 
-        @Override
-        public Builder readFrom(final Parcel parcel) {
+        Builder readFrom(final Parcel parcel) {
             return this.readFrom(
                     (GameRequestContent) parcel.readParcelable(
                             GameRequestContent.class.getClassLoader()));
diff --git a/facebook/src/main/java/com/facebook/share/model/ShareHashtag.java b/facebook/src/main/java/com/facebook/share/model/ShareHashtag.java
index 2d8207c18..95fdbdc90 100644
--- a/facebook/src/main/java/com/facebook/share/model/ShareHashtag.java
+++ b/facebook/src/main/java/com/facebook/share/model/ShareHashtag.java
@@ -100,8 +100,7 @@ public Builder readFrom(final ShareHashtag model) {
             return this.setHashtag(model.getHashtag());
         }
 
-        @Override
-        public Builder readFrom(final Parcel parcel) {
+        Builder readFrom(final Parcel parcel) {
             return this.readFrom(
                     (ShareHashtag)parcel.readParcelable(ShareHashtag.class.getClassLoader()));
         }
diff --git a/facebook/src/main/java/com/facebook/share/model/ShareLinkContent.java b/facebook/src/main/java/com/facebook/share/model/ShareLinkContent.java
index f8f062a83..f95134a75 100644
--- a/facebook/src/main/java/com/facebook/share/model/ShareLinkContent.java
+++ b/facebook/src/main/java/com/facebook/share/model/ShareLinkContent.java
@@ -183,13 +183,5 @@ public Builder readFrom(final ShareLinkContent model) {
                     .setQuote(model.getQuote())
                     ;
         }
-
-        @Override
-        public Builder readFrom(final Parcel parcel) {
-            return this.readFrom(
-                    (ShareLinkContent) parcel.readParcelable(
-                            ShareLinkContent.class.getClassLoader()));
-        }
-
     }
 }
diff --git a/facebook/src/main/java/com/facebook/share/model/ShareMedia.java b/facebook/src/main/java/com/facebook/share/model/ShareMedia.java
index bdf8aa502..f1be45be7 100644
--- a/facebook/src/main/java/com/facebook/share/model/ShareMedia.java
+++ b/facebook/src/main/java/com/facebook/share/model/ShareMedia.java
@@ -23,8 +23,10 @@
 import android.os.Bundle;
 import android.os.Parcel;
 import android.os.ParcelFormatException;
+import android.os.Parcelable;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 
 /**
@@ -63,28 +65,9 @@ public int describeContents() {
 
     @Override
     public void writeToParcel(Parcel dest, int flags) {
-        dest.writeString(this.getMediaType().name());
         dest.writeBundle(params);
     }
 
-    @SuppressWarnings("unused")
-    public static final Creator<ShareMedia> CREATOR = new Creator<ShareMedia>() {
-        public ShareMedia createFromParcel(final Parcel in) {
-            switch (Type.valueOf(in.readString())) {
-                case PHOTO:
-                    return new SharePhoto(in);
-                case VIDEO:
-                    return new ShareVideo(in);
-                default:
-                    throw new ParcelFormatException("ShareMedia has invalid type");
-            }
-        }
-
-        public ShareMedia[] newArray(final int size) {
-            return new ShareMedia[size];
-        }
-    };
-
     public abstract Type getMediaType();
 
     /**
@@ -120,14 +103,21 @@ public B readFrom(final M model) {
             return this.setParameters(model.getParameters());
         }
 
-        public static void writeListTo(final Parcel out, final List<ShareMedia> media) {
-            out.writeTypedList(media);
+        static void writeListTo(
+                final Parcel out,
+                int parcelFlags,
+                final List<ShareMedia> media) {
+            out.writeParcelableArray((ShareMedia[]) media.toArray(), parcelFlags);
         }
 
-        public static List<ShareMedia> readListFrom(final Parcel in) {
-            final List<ShareMedia> list = new ArrayList<>();
-            in.readTypedList(list, CREATOR);
-            return list;
+        static List<ShareMedia> readListFrom(final Parcel in) {
+            Parcelable[] parcelables = in.readParcelableArray(
+                    ShareMedia.class.getClassLoader());
+            List<ShareMedia> shareMedia = new ArrayList<>(parcelables.length);
+            for (Parcelable parcelable : parcelables) {
+                shareMedia.add((ShareMedia) parcelable);
+            }
+            return shareMedia;
         }
     }
 }
diff --git a/facebook/src/main/java/com/facebook/share/model/ShareMediaContent.java b/facebook/src/main/java/com/facebook/share/model/ShareMediaContent.java
index aa3e2fbd3..3474d1a16 100644
--- a/facebook/src/main/java/com/facebook/share/model/ShareMediaContent.java
+++ b/facebook/src/main/java/com/facebook/share/model/ShareMediaContent.java
@@ -24,6 +24,7 @@
 import android.support.annotation.Nullable;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
@@ -38,7 +39,9 @@ private ShareMediaContent(final Builder builder) {
 
     ShareMediaContent(final Parcel in) {
         super(in);
-        this.media = Collections.unmodifiableList(ShareMedia.Builder.readListFrom(in));
+        ShareMedia[] shareMedia = (ShareMedia[])in.readParcelableArray(
+                ShareMedia.class.getClassLoader());
+        this.media = Arrays.asList(shareMedia);
     }
 
     /**
@@ -57,7 +60,7 @@ public int describeContents() {
 
     public void writeToParcel(final Parcel out, final int flags) {
         super.writeToParcel(out, flags);
-        ShareMedia.Builder.writeListTo(out, this.media);
+        out.writeParcelableArray((ShareMedia[])this.media.toArray(), flags);
     }
 
     @SuppressWarnings("unused")
@@ -130,13 +133,6 @@ public Builder readFrom(final ShareMediaContent model) {
                     .addMedia(model.getMedia());
         }
 
-        @Override
-        public Builder readFrom(final Parcel parcel) {
-            return this.readFrom(
-                    (ShareMediaContent) parcel.readParcelable(
-                            ShareMediaContent.class.getClassLoader()));
-        }
-
         /**
          * Replaces the media for the builder.
          *
diff --git a/facebook/src/main/java/com/facebook/share/model/ShareModelBuilder.java b/facebook/src/main/java/com/facebook/share/model/ShareModelBuilder.java
index 794f1d5c2..4e8fe2968 100644
--- a/facebook/src/main/java/com/facebook/share/model/ShareModelBuilder.java
+++ b/facebook/src/main/java/com/facebook/share/model/ShareModelBuilder.java
@@ -37,12 +37,4 @@
      * @return The builder.
      */
     public E readFrom(P model);
-
-    /**
-     * Reads the values from a parcel into the builder.  The parcel must have packaged an instance
-     * of the ShareModel that came from the same type of builder.
-     * @param parcel The Parcel that contains the ShareModel.
-     * @return The builder.
-     */
-    public E readFrom(Parcel parcel);
 }
diff --git a/facebook/src/main/java/com/facebook/share/model/ShareOpenGraphAction.java b/facebook/src/main/java/com/facebook/share/model/ShareOpenGraphAction.java
index 81f5767ed..683cddd21 100644
--- a/facebook/src/main/java/com/facebook/share/model/ShareOpenGraphAction.java
+++ b/facebook/src/main/java/com/facebook/share/model/ShareOpenGraphAction.java
@@ -98,8 +98,7 @@ public Builder readFrom(final ShareOpenGraphAction model) {
                     ;
         }
 
-        @Override
-        public Builder readFrom(final Parcel parcel) {
+        Builder readFrom(final Parcel parcel) {
             return this.readFrom(
                     (ShareOpenGraphAction) parcel.readParcelable(
                             ShareOpenGraphAction.class.getClassLoader()));
diff --git a/facebook/src/main/java/com/facebook/share/model/ShareOpenGraphContent.java b/facebook/src/main/java/com/facebook/share/model/ShareOpenGraphContent.java
index 5806c9c8c..725b1cc82 100644
--- a/facebook/src/main/java/com/facebook/share/model/ShareOpenGraphContent.java
+++ b/facebook/src/main/java/com/facebook/share/model/ShareOpenGraphContent.java
@@ -144,12 +144,5 @@ public Builder readFrom(final com.facebook.share.model.ShareOpenGraphContent mod
                     ;
         }
 
-        @Override
-        public Builder readFrom(final Parcel parcel) {
-            return this.readFrom(
-                    (com.facebook.share.model.ShareOpenGraphContent) parcel.readParcelable(
-                            ShareOpenGraphContent.class.getClassLoader()));
-        }
-
     }
 }
diff --git a/facebook/src/main/java/com/facebook/share/model/ShareOpenGraphObject.java b/facebook/src/main/java/com/facebook/share/model/ShareOpenGraphObject.java
index 15c10ab69..368207022 100644
--- a/facebook/src/main/java/com/facebook/share/model/ShareOpenGraphObject.java
+++ b/facebook/src/main/java/com/facebook/share/model/ShareOpenGraphObject.java
@@ -70,8 +70,7 @@ public ShareOpenGraphObject build() {
             return new ShareOpenGraphObject(this);
         }
 
-        @Override
-        public Builder readFrom(final Parcel parcel) {
+        Builder readFrom(final Parcel parcel) {
             return this.readFrom(
                     (ShareOpenGraphObject)parcel.readParcelable(
                             ShareOpenGraphObject.class.getClassLoader()));
diff --git a/facebook/src/main/java/com/facebook/share/model/SharePhoto.java b/facebook/src/main/java/com/facebook/share/model/SharePhoto.java
index 6f0e167fa..fdd834ac3 100644
--- a/facebook/src/main/java/com/facebook/share/model/SharePhoto.java
+++ b/facebook/src/main/java/com/facebook/share/model/SharePhoto.java
@@ -23,6 +23,7 @@
 import android.graphics.Bitmap;
 import android.net.Uri;
 import android.os.Parcel;
+import android.os.Parcelable;
 import android.support.annotation.Nullable;
 
 import java.util.ArrayList;
@@ -104,6 +105,20 @@ public void writeToParcel(final Parcel out, final int flags) {
         out.writeString(caption);
     }
 
+    public static final Parcelable.Creator<SharePhoto> CREATOR =
+            new Parcelable.Creator<SharePhoto>() {
+
+                @Override
+                public SharePhoto createFromParcel(final Parcel source) {
+                    return new SharePhoto(source);
+                }
+
+                @Override
+                public SharePhoto[] newArray(final int size) {
+                    return new SharePhoto[size];
+                }
+            };
+
     @Override
     public Type getMediaType() {
         return Type.PHOTO;
@@ -190,31 +205,31 @@ public Builder readFrom(final SharePhoto model) {
                     ;
         }
 
-        @Override
-        public Builder readFrom(final Parcel parcel) {
+        Builder readFrom(final Parcel parcel) {
             return this.readFrom(
                     (SharePhoto) parcel.readParcelable(SharePhoto.class.getClassLoader()));
         }
 
         /*
-         * For backwards compatability with SharePhotoContent.  Prefer ShareMediaContent for new
+         * For backwards compatibility with SharePhotoContent.  Prefer ShareMediaContent for new
          * code.
          */
-        public static void writePhotoListTo(
+        static void writePhotoListTo(
                 final Parcel out,
+                int parcelFlags,
                 final List<SharePhoto> photos) {
-            final List<ShareMedia> list = new ArrayList<>();
-            for (SharePhoto photo : photos) {
-                list.add(photo);
+            ShareMedia[] array = new ShareMedia[photos.size()];
+            for (int i = 0; i < photos.size(); ++i) {
+                array[i] = photos.get(i);
             }
-            writeListTo(out, list);
+            out.writeParcelableArray(array, parcelFlags);
         }
 
         /*
-         * For backwards compatability with SharePhotoContent.  Prefer ShareMediaContent for new
+         * For backwards compatibility with SharePhotoContent.  Prefer ShareMediaContent for new
          * code.
          */
-        public static List<SharePhoto> readPhotoListFrom(final Parcel in) {
+        static List<SharePhoto> readPhotoListFrom(final Parcel in) {
             final List<ShareMedia> media = readListFrom(in);
             final List<SharePhoto> photos = new ArrayList<>();
             for (ShareMedia medium : media) {
diff --git a/facebook/src/main/java/com/facebook/share/model/SharePhotoContent.java b/facebook/src/main/java/com/facebook/share/model/SharePhotoContent.java
index 12feb4345..fccbc67de 100644
--- a/facebook/src/main/java/com/facebook/share/model/SharePhotoContent.java
+++ b/facebook/src/main/java/com/facebook/share/model/SharePhotoContent.java
@@ -45,6 +45,7 @@ private SharePhotoContent(final Builder builder) {
 
     SharePhotoContent(final Parcel in) {
         super(in);
+
         this.photos = Collections.unmodifiableList(SharePhoto.Builder.readPhotoListFrom(in));
     }
 
@@ -63,7 +64,7 @@ public int describeContents() {
 
     public void writeToParcel(final Parcel out, final int flags) {
         super.writeToParcel(out, flags);
-        SharePhoto.Builder.writePhotoListTo(out, this.photos);
+        SharePhoto.Builder.writePhotoListTo(out, flags, this.photos);
     }
 
     @SuppressWarnings("unused")
@@ -125,13 +126,6 @@ public Builder readFrom(final SharePhotoContent model) {
                     .addPhotos(model.getPhotos());
         }
 
-        @Override
-        public Builder readFrom(final Parcel parcel) {
-            return this.readFrom(
-                    (SharePhotoContent) parcel.readParcelable(
-                            SharePhotoContent.class.getClassLoader()));
-        }
-
         /**
          * Replaces the photos for the builder.
          * @param photos {@link java.util.List} of {@link com.facebook.share.model.SharePhoto}s to add.
diff --git a/facebook/src/main/java/com/facebook/share/model/ShareVideo.java b/facebook/src/main/java/com/facebook/share/model/ShareVideo.java
index 3cccd6160..0a919f6f2 100644
--- a/facebook/src/main/java/com/facebook/share/model/ShareVideo.java
+++ b/facebook/src/main/java/com/facebook/share/model/ShareVideo.java
@@ -22,6 +22,7 @@
 
 import android.net.Uri;
 import android.os.Parcel;
+import android.os.Parcelable;
 import android.support.annotation.Nullable;
 
 /**
@@ -60,6 +61,20 @@ public void writeToParcel(final Parcel out, final int flags) {
         out.writeParcelable(this.localUrl, 0);
     }
 
+    public static final Parcelable.Creator<ShareVideo> CREATOR =
+        new Parcelable.Creator<ShareVideo>() {
+
+            @Override
+            public ShareVideo createFromParcel(final Parcel source) {
+                return new ShareVideo(source);
+            }
+
+            @Override
+            public ShareVideo[] newArray(final int size) {
+                return new ShareVideo[size];
+            }
+        };
+
     @Override
     public Type getMediaType() {
         return Type.VIDEO;
@@ -95,8 +110,7 @@ public Builder readFrom(final ShareVideo model) {
                     .setLocalUrl(model.getLocalUrl());
         }
 
-        @Override
-        public Builder readFrom(final Parcel parcel) {
+        Builder readFrom(final Parcel parcel) {
             return this.readFrom(
                     (ShareVideo) parcel.readParcelable(ShareVideo.class.getClassLoader()));
         }
diff --git a/facebook/src/main/java/com/facebook/share/model/ShareVideoContent.java b/facebook/src/main/java/com/facebook/share/model/ShareVideoContent.java
index 24b510210..ed82b3fb3 100644
--- a/facebook/src/main/java/com/facebook/share/model/ShareVideoContent.java
+++ b/facebook/src/main/java/com/facebook/share/model/ShareVideoContent.java
@@ -193,12 +193,5 @@ public Builder readFrom(final ShareVideoContent model) {
                     .setVideo(model.getVideo())
                     ;
         }
-
-        @Override
-        public Builder readFrom(final Parcel parcel) {
-            return this.readFrom((ShareVideoContent)parcel.readParcelable(
-                    ShareVideoContent.class.getClassLoader()));
-        }
-
     }
 }
diff --git a/facebook/src/test/java/com/facebook/login/CustomTabLoginMethodHandlerTest.java b/facebook/src/test/java/com/facebook/login/CustomTabLoginMethodHandlerTest.java
new file mode 100644
index 000000000..9c0a39969
--- /dev/null
+++ b/facebook/src/test/java/com/facebook/login/CustomTabLoginMethodHandlerTest.java
@@ -0,0 +1,187 @@
+/**
+ * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
+ *
+ * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,
+ * copy, modify, and distribute this software in source code or binary form for use
+ * in connection with the web services and APIs provided by Facebook.
+ *
+ * As with any software that integrates with the Facebook platform, your use of
+ * this software is subject to the Facebook Developer Principles and Policies
+ * [http://developers.facebook.com/policy/]. This copyright notice shall be
+ * included in all copies or substantial portions of the software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.login;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+
+import com.facebook.AccessToken;
+import com.facebook.FacebookException;
+import com.facebook.FacebookOperationCanceledException;
+import com.facebook.FacebookSdk;
+import com.facebook.TestUtils;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+
+import org.junit.Test;
+import org.mockito.ArgumentCaptor;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.powermock.api.mockito.PowerMockito.mockStatic;
+import static org.powermock.api.mockito.PowerMockito.when;
+
+@PrepareForTest({
+        LoginClient.class,
+        Validate.class,
+        Utility.class,
+        FacebookSdk.class,
+        AccessToken.class })
+public class CustomTabLoginMethodHandlerTest extends LoginHandlerTestCase {
+    private final static String SIGNED_REQUEST_STR = "ggarbage.eyJhbGdvcml0aG0iOiJITUFDSEEyNTYiLCJ"
+            + "jb2RlIjoid2h5bm90IiwiaXNzdWVkX2F0IjoxNDIyNTAyMDkyLCJ1c2VyX2lkIjoiMTIzIn0";
+
+    @Test
+    public void testCustomTabHandlesSuccess() {
+        final Bundle bundle = new Bundle();
+        bundle.putString("access_token", ACCESS_TOKEN);
+        bundle.putString("expires_in", String.format("%d", EXPIRES_IN_DELTA));
+        bundle.putString("code", "Something else");
+        bundle.putString("signed_request", SIGNED_REQUEST_STR);
+
+        final CustomTabLoginMethodHandler handler =
+                new CustomTabLoginMethodHandler(mockLoginClient);
+
+        final LoginClient.Request request = createRequest();
+        handler.onComplete(request, bundle, null);
+
+        final ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
+                ArgumentCaptor.forClass(LoginClient.Result.class);
+        verify(mockLoginClient, times(1)).completeAndValidate(resultArgumentCaptor.capture());
+
+        final LoginClient.Result result = resultArgumentCaptor.getValue();
+        assertNotNull(result);
+        assertEquals(LoginClient.Result.Code.SUCCESS, result.code);
+
+        final AccessToken token = result.token;
+        assertNotNull(token);
+        assertEquals(ACCESS_TOKEN, token.getToken());
+        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
+        TestUtils.assertSamePermissions(PERMISSIONS, token.getPermissions());
+    }
+
+    @Test
+    public void testCustomTabHandlesCancel() {
+        final CustomTabLoginMethodHandler handler =
+                new CustomTabLoginMethodHandler(mockLoginClient);
+
+        final LoginClient.Request request = createRequest();
+        handler.onComplete(request, null, new FacebookOperationCanceledException());
+
+        final ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
+                ArgumentCaptor.forClass(LoginClient.Result.class);
+        verify(mockLoginClient, times(1)).completeAndValidate(resultArgumentCaptor.capture());
+        final LoginClient.Result result = resultArgumentCaptor.getValue();
+
+        assertNotNull(result);
+        assertEquals(LoginClient.Result.Code.CANCEL, result.code);
+        assertNull(result.token);
+        assertNotNull(result.errorMessage);
+    }
+
+    @Test
+    public void testCustomTabHandlesError() {
+        final CustomTabLoginMethodHandler handler =
+                new CustomTabLoginMethodHandler(mockLoginClient);
+
+        final LoginClient.Request request = createRequest();
+        handler.onComplete(request, null, new FacebookException(ERROR_MESSAGE));
+
+        final ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
+                ArgumentCaptor.forClass(LoginClient.Result.class);
+        verify(mockLoginClient, times(1)).completeAndValidate(resultArgumentCaptor.capture());
+        final LoginClient.Result result = resultArgumentCaptor.getValue();
+
+        assertNotNull(result);
+        assertEquals(LoginClient.Result.Code.ERROR, result.code);
+        assertNull(result.token);
+        assertNotNull(result.errorMessage);
+        assertEquals(ERROR_MESSAGE, result.errorMessage);
+    }
+
+    @Test
+    public void testTryAuthorizeNeedsRedirectActivity() {
+        final CustomTabLoginMethodHandler handler =
+                new CustomTabLoginMethodHandler(mockLoginClient);
+        final LoginClient.Request request = createRequest();
+
+        mockTryAuthorize();
+
+        mockChromeCustomTabsSupported(true);
+        mockCustomTabsAllowed(true);
+        mockCustomTabRedirectActivity(true);
+        assertTrue(handler.tryAuthorize(request));
+
+        mockCustomTabsAllowed(false);
+        assertFalse(handler.tryAuthorize(request));
+    }
+
+    private void mockTryAuthorize() {
+        mockStatic(FacebookSdk.class);
+        when(FacebookSdk.isInitialized()).thenReturn(true);
+        mockStatic(AccessToken.class);
+        when(AccessToken.getCurrentAccessToken()).thenReturn(null);
+    }
+
+    private void mockChromeCustomTabsSupported(final boolean supported) {
+        final List<ResolveInfo> resolveInfos = new ArrayList<>();
+        if (supported) {
+            resolveInfos.add(new ResolveInfo());
+        }
+        final PackageManager packageManager = mock(PackageManager.class);
+        when(packageManager.queryIntentServices(any(Intent.class), anyInt()))
+                .thenReturn(resolveInfos);
+        activity = mock(FragmentActivity.class);
+        when(mockLoginClient.getActivity()).thenReturn(activity);
+        when(activity.getPackageManager()).thenReturn(packageManager);
+    }
+
+    private void mockCustomTabRedirectActivity(final boolean hasActivity) {
+        mockStatic(Validate.class);
+        when(Validate.hasCustomTabRedirectActivity(any(Context.class))).thenReturn(hasActivity);
+    }
+
+    private void mockCustomTabsAllowed(final boolean allowed) {
+        final Utility.FetchedAppSettings settings = mock(Utility.FetchedAppSettings.class);
+        when(settings.getCustomTabsEnabled()).thenReturn(allowed);
+        mockStatic(Utility.class);
+        when(Utility.getAppSettingsWithoutQuery(anyString())).thenReturn(settings);
+    }
+
+}
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index fd7e590e5..13372aef5 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 77afe8196..b5273f08d 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue May 10 16:51:44 PDT 2016
+#Fri May 13 11:07:42 PDT 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-bin.zip
diff --git a/gradlew b/gradlew
index 91a7e269e..9d82f7891 100755
--- a/gradlew
+++ b/gradlew
@@ -42,11 +42,6 @@ case "`uname`" in
     ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
 # Attempt to set APP_HOME
 # Resolve links: $0 may be a link
 PRG="$0"
@@ -61,9 +56,9 @@ while [ -h "$PRG" ] ; do
     fi
 done
 SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
+cd "`dirname \"$PRG\"`/" >/dev/null
 APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
+cd "$SAVED" >/dev/null
 
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
@@ -114,6 +109,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
diff --git a/samples/HelloFacebookSample/AndroidManifest.xml b/samples/HelloFacebookSample/AndroidManifest.xml
index 454494221..c0fb8d48b 100644
--- a/samples/HelloFacebookSample/AndroidManifest.xml
+++ b/samples/HelloFacebookSample/AndroidManifest.xml
@@ -43,12 +43,9 @@
         </activity>
         <activity
             android:name="com.facebook.FacebookActivity"
-            android:configChanges="keyboard|keyboardHidden|screenLayout|screenSize|orientation"
-            android:label="@string/app_name"
-            android:theme="@android:style/Theme.Translucent.NoTitleBar" />
+            android:label="@string/app_name"/>
         <activity
-            android:name="com.facebook.CustomTabActivity"
-            android:exported="true">
+            android:name="com.facebook.CustomTabActivity">
             <intent-filter>
                 <action android:name="android.intent.action.VIEW" />
 
diff --git a/samples/Iconicus/AndroidManifest.xml b/samples/Iconicus/AndroidManifest.xml
index 16cd19340..4823cc0d7 100644
--- a/samples/Iconicus/AndroidManifest.xml
+++ b/samples/Iconicus/AndroidManifest.xml
@@ -59,12 +59,9 @@
         </activity>
         <activity
             android:name="com.facebook.FacebookActivity"
-            android:configChanges="keyboard|keyboardHidden|screenLayout|screenSize|orientation"
-            android:label="@string/app_name"
-            android:theme="@android:style/Theme.Translucent.NoTitleBar" />
+            android:label="@string/app_name"/>
         <activity
-            android:name="com.facebook.CustomTabActivity"
-            android:exported="true">
+            android:name="com.facebook.CustomTabActivity">
             <intent-filter>
                 <action android:name="android.intent.action.VIEW" />
 
diff --git a/samples/RPSSample/AndroidManifest.xml b/samples/RPSSample/AndroidManifest.xml
index 8fa6f400f..68d3b58fa 100644
--- a/samples/RPSSample/AndroidManifest.xml
+++ b/samples/RPSSample/AndroidManifest.xml
@@ -54,12 +54,9 @@
         </activity>
         <activity
             android:name="com.facebook.FacebookActivity"
-            android:configChanges="keyboard|keyboardHidden|screenLayout|screenSize|orientation"
-            android:label="@string/app_name"
-            android:theme="@android:style/Theme.Translucent.NoTitleBar" />
+            android:label="@string/app_name"/>
         <activity
-            android:name="com.facebook.CustomTabActivity"
-            android:exported="true">
+            android:name="com.facebook.CustomTabActivity">
             <intent-filter>
                 <action android:name="android.intent.action.VIEW" />
 
diff --git a/samples/Scrumptious/AndroidManifest.xml b/samples/Scrumptious/AndroidManifest.xml
index 0cccb0cc1..a06051789 100644
--- a/samples/Scrumptious/AndroidManifest.xml
+++ b/samples/Scrumptious/AndroidManifest.xml
@@ -51,12 +51,9 @@
             android:label="@string/app_name" />
         <activity
             android:name="com.facebook.FacebookActivity"
-            android:configChanges="keyboard|keyboardHidden|screenLayout|screenSize|orientation"
-            android:label="@string/app_name"
-            android:theme="@android:style/Theme.Translucent.NoTitleBar" />
+            android:label="@string/app_name"/>
         <activity
-            android:name="com.facebook.CustomTabActivity"
-            android:exported="true">
+            android:name="com.facebook.CustomTabActivity">
             <intent-filter>
                 <action android:name="android.intent.action.VIEW" />
                 <category android:name="android.intent.category.DEFAULT" />
diff --git a/samples/Scrumptious/src/com/example/scrumptious/PickerActivity.java b/samples/Scrumptious/src/com/example/scrumptious/PickerActivity.java
index 09dc84ebf..1d8a57bc6 100644
--- a/samples/Scrumptious/src/com/example/scrumptious/PickerActivity.java
+++ b/samples/Scrumptious/src/com/example/scrumptious/PickerActivity.java
@@ -20,17 +20,21 @@
 
 package com.example.scrumptious;
 
+import android.Manifest;
+import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.app.Fragment;
 import android.app.FragmentManager;
 import android.content.Context;
 import android.content.DialogInterface;
+import android.content.pm.PackageManager;
 import android.location.Criteria;
 import android.location.Location;
 import android.location.LocationListener;
 import android.location.LocationManager;
 import android.net.Uri;
+import android.os.Build;
 import android.os.Bundle;
 import android.os.Looper;
 import android.widget.Toast;
@@ -127,6 +131,7 @@ public void onDoneButtonClicked(PickerFragment fragment) {
     }
 
     @Override
+    @SuppressLint("MissingPermission")
     protected void onStart() {
         super.onStart();
         if (FRIEND_PICKER.equals(getIntent().getData())) {
@@ -141,7 +146,7 @@ protected void onStart() {
                 Criteria criteria = new Criteria();
                 LocationManager locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
                 String bestProvider = locationManager.getBestProvider(criteria, false);
-                if (bestProvider != null) {
+                if (bestProvider != null && checkForLocationPermissionsAndRequest()) {
                     location = locationManager.getLastKnownLocation(bestProvider);
                     if (locationManager.isProviderEnabled(bestProvider) && locationListener == null) {
                         locationListener = new LocationListener() {
@@ -185,11 +190,15 @@ public void onProviderDisabled(String s) {
     }
 
     @Override
+    @SuppressLint("MissingPermission")
     protected void onStop() {
         super.onStop();
         if (locationListener != null) {
-            LocationManager locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
-            locationManager.removeUpdates(locationListener);
+            if (hasLocationPermissions()) {
+                LocationManager locationManager =
+                        (LocationManager)getSystemService(Context.LOCATION_SERVICE);
+                locationManager.removeUpdates(locationListener);
+            }
             locationListener = null;
         }
     }
@@ -229,4 +238,36 @@ private void finishActivity() {
         setResult(RESULT_OK, null);
         finish();
     }
+
+    private boolean checkForLocationPermissionsAndRequest() {
+        if (!hasLocationPermissions()) {
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+                requestPermissions(
+                        new String[]{
+                                Manifest.permission.ACCESS_FINE_LOCATION,
+                                Manifest.permission.ACCESS_COARSE_LOCATION
+                        },
+                        0);
+            }
+
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    private boolean hasLocationPermissions() {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
+            return true;
+        }
+
+        if (checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION)
+                != PackageManager.PERMISSION_GRANTED
+                && checkSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION)
+                != PackageManager.PERMISSION_GRANTED) {
+            return false;
+        }
+
+        return true;
+    }
 }
diff --git a/samples/ShareIt/AndroidManifest.xml b/samples/ShareIt/AndroidManifest.xml
index fede962e1..697a3eaae 100644
--- a/samples/ShareIt/AndroidManifest.xml
+++ b/samples/ShareIt/AndroidManifest.xml
@@ -41,12 +41,9 @@
         </activity>
         <activity
             android:name="com.facebook.FacebookActivity"
-            android:configChanges="keyboard|keyboardHidden|screenLayout|screenSize|orientation"
-            android:label="@string/app_name"
-            android:theme="@android:style/Theme.Translucent.NoTitleBar" />
+            android:label="@string/app_name"/>
         <activity
-            android:name="com.facebook.CustomTabActivity"
-            android:exported="true">
+            android:name="com.facebook.CustomTabActivity">
             <intent-filter>
                 <action android:name="android.intent.action.VIEW" />
                 <category android:name="android.intent.category.DEFAULT" />
diff --git a/samples/SwitchUserSample/AndroidManifest.xml b/samples/SwitchUserSample/AndroidManifest.xml
index 955229445..a4a75cc57 100644
--- a/samples/SwitchUserSample/AndroidManifest.xml
+++ b/samples/SwitchUserSample/AndroidManifest.xml
@@ -41,12 +41,9 @@
         </activity>
         <activity
             android:name="com.facebook.FacebookActivity"
-            android:configChanges="keyboard|keyboardHidden|screenLayout|screenSize|orientation"
-            android:label="@string/app_name"
-            android:theme="@android:style/Theme.Translucent.NoTitleBar" />
+            android:label="@string/app_name"/>
         <activity
-            android:name="com.facebook.CustomTabActivity"
-            android:exported="true">
+            android:name="com.facebook.CustomTabActivity">
             <intent-filter>
                 <action android:name="android.intent.action.VIEW" />
 
