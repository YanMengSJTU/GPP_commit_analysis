diff --git a/README.mdown b/README.mdown
index c52e978a9..b86902191 100644
--- a/README.mdown
+++ b/README.mdown
@@ -6,18 +6,31 @@ This open-source library allows you to integrate Facebook into your Android app.
 Learn more about about the provided samples, documentation, integrating the SDK into your app, accessing source code, and more at https://developers.facebook.com/android
 
 TRY IT OUT
-
+----------
 1. Check-out the tutorials available online at https://developers.facebook.com/docs/getting-started/facebook-sdk-for-android/3.0/
-
 2. Start coding! Visit https://developers.facebook.com/android for tutorials and reference documentation.
 
-LICENSE
+FEATURES
+--------
+* Login - https://developers.facebook.com/docs/facebook-login
+* Sharing - https://developers.facebook.com/docs/sharing
+* App Links - https://developers.facebook.com/docs/applinks
+* Graph API - https://developers.facebook.com/docs/android/graph
 
+GIVE FEEDBACK
+-------------
+Please report bugs or issues to https://developers.facebook.com/bugs/
+
+You can also join the Facebook Developers Group on Facebook (https://www.facebook.com/groups/fbdevelopers/) or ask questions on Stack Overflow (http://facebook.stackoverflow.com)
+
+LICENSE
+-------
 Except as otherwise noted, the Facebook SDK for Android is licensed under the Apache License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0.html).
 
 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the specific language governing permissions and limitations under the License.
 
 DEVELOPER TERMS
+---------------
 
 - By enabling Facebook integrations, including through this SDK, you can share information with Facebook, including information about peopleâ€™s use of your app. Facebook will use information received in accordance with our Data Use Policy (https://www.facebook.com/about/privacy/), including to provide you with insights about the effectiveness of your ads and the use of your app.  These integrations also enable us and our partners to serve ads on and off Facebook.
 
diff --git a/facebook/TestApp/build.gradle b/facebook/TestApp/build.gradle
index b76fed903..024c5b289 100644
--- a/facebook/TestApp/build.gradle
+++ b/facebook/TestApp/build.gradle
@@ -1,4 +1,4 @@
-apply plugin: 'android'
+apply plugin: 'android-library'
 
 dependencies {
     compile project(':facebook')
diff --git a/facebook/build.gradle b/facebook/build.gradle
index c9fc51094..d2280edc4 100644
--- a/facebook/build.gradle
+++ b/facebook/build.gradle
@@ -1,5 +1,7 @@
 apply plugin: 'android-library'
 
+project.group = 'com.facebook.android'
+
 dependencies {
     compile 'com.android.support:support-v4:20.0.+'
     compile files('libs/bolts-android-1.1.2.jar')
@@ -26,3 +28,100 @@ android {
         }
     }
 }
+
+apply plugin: 'maven'
+apply plugin: 'signing'
+
+def isSnapshot = version.endsWith('-SNAPSHOT')
+def ossrhUsername = hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : ""
+def ossrhPassword = hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : ""
+
+task setVersion {
+    // The version will be derived from source
+    project.version = null
+    def sdkVersionFile = file('src/com/facebook/FacebookSdkVersion.java')
+    sdkVersionFile.eachLine{
+        def matcher = (it =~ /(?:.*BUILD = \")(.*)(?:\".*)/)
+        if (matcher.matches()) {
+          project.version = matcher[0][1]
+          return
+        }
+    }
+    if (project.version.is('unspecified')) {
+      throw new GradleScriptException('Version could not be found.', null)
+    }
+}
+
+uploadArchives {
+    repositories.mavenDeployer {
+        beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
+
+        repository(url: "https://oss.sonatype.org/service/local/staging/deploy/maven2/") {
+            authentication(userName: ossrhUsername, password: ossrhPassword)
+        }
+
+        snapshotRepository(url: "https://oss.sonatype.org/content/repositories/snapshots/") {
+            authentication(userName: ossrhUsername, password: ossrhPassword)
+        }
+
+        pom.project {
+            name 'Facebook-Android-SDK'
+            artifactId = 'facebook-android-sdk'
+            packaging 'aar'
+            description 'Facebook Android SDK'
+            url 'https://github.com/facebook/facebook-android-sdk'
+
+            scm {
+                connection 'scm:git@github.com:facebook/facebook-android-sdk.git'
+                developerConnection 'scm:git@github.com:facebook/facebook-android-sdk.git'
+                url 'https://github.com/facebook/facebook-android-sdk'
+            }
+
+            licenses {
+                license {
+                    name 'The Apache Software License, Version 2.0'
+                    url 'https://github.com/facebook/facebook-android-sdk/blob/master/LICENSE.txt'
+                    distribution 'repo'
+                }
+            }
+
+            developers {
+                developer {
+                    id 'facebook'
+                    name 'Facebook'
+                }
+            }
+        }
+    }
+}
+
+uploadArchives.dependsOn(setVersion)
+
+signing {
+    required { !isSnapshot && gradle.taskGraph.hasTask("uploadArchives") }
+    sign configurations.archives
+}
+
+task androidJavadocs(type: Javadoc) {
+    source = android.sourceSets.main.java.srcDirs
+    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+}
+
+task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
+    classifier = 'javadoc'
+    from androidJavadocs.destinationDir
+}
+
+task androidSourcesJar(type: Jar) {
+    classifier = 'sources'
+    from android.sourceSets.main.java.sourceFiles
+}
+
+artifacts {
+    archives androidSourcesJar
+    archives androidJavadocsJar
+}
+
+afterEvaluate {
+    androidJavadocs.classpath += project.android.libraryVariants.toList().first().javaCompile.classpath
+}
diff --git a/facebook/facebook.iml b/facebook/facebook.iml
index 0b3944c1d..e2ec228bf 100644
--- a/facebook/facebook.iml
+++ b/facebook/facebook.iml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="quizlet-gradle.facebook-android-sdk" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
+<module external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="com.facebook.android" external.system.module.version="3.19.1" type="JAVA_MODULE" version="4">
   <component name="FacetManager">
     <facet type="android-gradle" name="Android-Gradle">
       <configuration>
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_like_background.png b/facebook/res/drawable-hdpi/com_facebook_button_like_background.png
new file mode 100644
index 000000000..32814c82a
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_button_like_background.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_like_background_selected.png b/facebook/res/drawable-hdpi/com_facebook_button_like_background_selected.png
new file mode 100644
index 000000000..b2c580e2a
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_button_like_background_selected.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_like_icon.png b/facebook/res/drawable-hdpi/com_facebook_button_like_icon.png
new file mode 100644
index 000000000..1dc9f6d24
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_button_like_icon.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_like_icon_selected.png b/facebook/res/drawable-hdpi/com_facebook_button_like_icon_selected.png
new file mode 100644
index 000000000..722362ae8
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_button_like_icon_selected.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_like_pressed.png b/facebook/res/drawable-hdpi/com_facebook_button_like_pressed.png
new file mode 100644
index 000000000..047eaa6c4
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_button_like_pressed.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_like_background.png b/facebook/res/drawable-xhdpi/com_facebook_button_like_background.png
new file mode 100644
index 000000000..3c25c433e
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_button_like_background.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_like_background_selected.png b/facebook/res/drawable-xhdpi/com_facebook_button_like_background_selected.png
new file mode 100644
index 000000000..accfdfc6e
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_button_like_background_selected.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_like_icon.png b/facebook/res/drawable-xhdpi/com_facebook_button_like_icon.png
new file mode 100644
index 000000000..db8fcad20
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_button_like_icon.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_like_icon_selected.png b/facebook/res/drawable-xhdpi/com_facebook_button_like_icon_selected.png
new file mode 100644
index 000000000..96e9a308b
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_button_like_icon_selected.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_like_pressed.png b/facebook/res/drawable-xhdpi/com_facebook_button_like_pressed.png
new file mode 100644
index 000000000..d990a4e53
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_button_like_pressed.png differ
diff --git a/facebook/res/drawable-xxhdpi/com_facebook_button_like_background.png b/facebook/res/drawable-xxhdpi/com_facebook_button_like_background.png
new file mode 100644
index 000000000..bead08dc5
Binary files /dev/null and b/facebook/res/drawable-xxhdpi/com_facebook_button_like_background.png differ
diff --git a/facebook/res/drawable-xxhdpi/com_facebook_button_like_background_selected.png b/facebook/res/drawable-xxhdpi/com_facebook_button_like_background_selected.png
new file mode 100644
index 000000000..85e4e873c
Binary files /dev/null and b/facebook/res/drawable-xxhdpi/com_facebook_button_like_background_selected.png differ
diff --git a/facebook/res/drawable-xxhdpi/com_facebook_button_like_icon.png b/facebook/res/drawable-xxhdpi/com_facebook_button_like_icon.png
new file mode 100644
index 000000000..1d67cab7b
Binary files /dev/null and b/facebook/res/drawable-xxhdpi/com_facebook_button_like_icon.png differ
diff --git a/facebook/res/drawable-xxhdpi/com_facebook_button_like_icon_selected.png b/facebook/res/drawable-xxhdpi/com_facebook_button_like_icon_selected.png
new file mode 100644
index 000000000..45319d90b
Binary files /dev/null and b/facebook/res/drawable-xxhdpi/com_facebook_button_like_icon_selected.png differ
diff --git a/facebook/res/drawable-xxhdpi/com_facebook_button_like_pressed.png b/facebook/res/drawable-xxhdpi/com_facebook_button_like_pressed.png
new file mode 100644
index 000000000..f6b49ca9c
Binary files /dev/null and b/facebook/res/drawable-xxhdpi/com_facebook_button_like_pressed.png differ
diff --git a/facebook/res/drawable/com_facebook_button_like.xml b/facebook/res/drawable/com_facebook_button_like.xml
new file mode 100644
index 000000000..ff7a04b64
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_button_like.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <item
+        android:drawable="@drawable/com_facebook_button_like_pressed"
+        android:state_focused="true"
+        android:state_pressed="true"
+        />
+    <item
+        android:drawable="@drawable/com_facebook_button_like_pressed"
+        android:state_focused="false"
+        android:state_pressed="true"
+        />
+    <item
+        android:drawable="@drawable/com_facebook_button_like_background"
+        android:state_focused="true"
+        android:state_pressed="false"
+        />
+    <item
+        android:drawable="@drawable/com_facebook_button_like_background"
+        android:state_focused="false"
+        android:state_pressed="false"
+        />
+
+</selector>
diff --git a/facebook/res/drawable/com_facebook_button_like_background.png b/facebook/res/drawable/com_facebook_button_like_background.png
new file mode 100644
index 000000000..e7723b5a0
Binary files /dev/null and b/facebook/res/drawable/com_facebook_button_like_background.png differ
diff --git a/facebook/res/drawable/com_facebook_button_like_background_selected.png b/facebook/res/drawable/com_facebook_button_like_background_selected.png
new file mode 100644
index 000000000..68c70bcee
Binary files /dev/null and b/facebook/res/drawable/com_facebook_button_like_background_selected.png differ
diff --git a/facebook/res/drawable/com_facebook_button_like_icon.png b/facebook/res/drawable/com_facebook_button_like_icon.png
new file mode 100644
index 000000000..30a955592
Binary files /dev/null and b/facebook/res/drawable/com_facebook_button_like_icon.png differ
diff --git a/facebook/res/drawable/com_facebook_button_like_icon_selected.png b/facebook/res/drawable/com_facebook_button_like_icon_selected.png
new file mode 100644
index 000000000..ead35ca29
Binary files /dev/null and b/facebook/res/drawable/com_facebook_button_like_icon_selected.png differ
diff --git a/facebook/res/drawable/com_facebook_button_like_pressed.png b/facebook/res/drawable/com_facebook_button_like_pressed.png
new file mode 100644
index 000000000..fc5a53534
Binary files /dev/null and b/facebook/res/drawable/com_facebook_button_like_pressed.png differ
diff --git a/facebook/res/drawable/com_facebook_button_like_selected.xml b/facebook/res/drawable/com_facebook_button_like_selected.xml
new file mode 100644
index 000000000..042f23ea8
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_button_like_selected.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <item
+            android:drawable="@drawable/com_facebook_button_like_pressed"
+            android:state_focused="true"
+            android:state_pressed="true"
+            />
+    <item
+            android:drawable="@drawable/com_facebook_button_like_pressed"
+            android:state_focused="false"
+            android:state_pressed="true"
+            />
+    <item
+            android:drawable="@drawable/com_facebook_button_like_background_selected"
+            android:state_focused="true"
+            android:state_pressed="false"
+            />
+    <item
+            android:drawable="@drawable/com_facebook_button_like_background_selected"
+            android:state_focused="false"
+            android:state_pressed="false"
+            />
+
+
+</selector>
diff --git a/facebook/res/layout/com_facebook_friendpickerfragment.xml b/facebook/res/layout/com_facebook_friendpickerfragment.xml
index b42f15e7d..1fc9f44fa 100644
--- a/facebook/res/layout/com_facebook_friendpickerfragment.xml
+++ b/facebook/res/layout/com_facebook_friendpickerfragment.xml
@@ -16,16 +16,16 @@
 -->
 
 <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:layout_width="fill_parent"
-              android:layout_height="fill_parent"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
               android:background="#FFFFFF">
 
     <include layout="@layout/com_facebook_picker_title_bar_stub"/>
 
     <ListView
             android:id="@+id/com_facebook_picker_list_view"
-            android:layout_width="fill_parent"
-            android:layout_height="fill_parent"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
             android:divider="@drawable/com_facebook_list_divider"
             android:fastScrollEnabled="true"
             android:scrollbars="vertical"
diff --git a/facebook/res/layout/com_facebook_login_activity_layout.xml b/facebook/res/layout/com_facebook_login_activity_layout.xml
index 09b28999f..66e50bd8d 100644
--- a/facebook/res/layout/com_facebook_login_activity_layout.xml
+++ b/facebook/res/layout/com_facebook_login_activity_layout.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 
 <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:layout_width="fill_parent"
-              android:layout_height="fill_parent">
+              android:layout_width="match_parent"
+              android:layout_height="match_parent">
 
     <ProgressBar android:indeterminate="true"
                  android:layout_width="wrap_content"
diff --git a/facebook/res/layout/com_facebook_picker_activity_circle_row.xml b/facebook/res/layout/com_facebook_picker_activity_circle_row.xml
index de3e7e323..7f631b093 100644
--- a/facebook/res/layout/com_facebook_picker_activity_circle_row.xml
+++ b/facebook/res/layout/com_facebook_picker_activity_circle_row.xml
@@ -18,7 +18,7 @@
 <RelativeLayout
         xmlns:android="http://schemas.android.com/apk/res/android"
         android:layout_height="50dip"
-        android:layout_width="fill_parent"
+        android:layout_width="match_parent"
         >
     <ProgressBar android:indeterminate="true"
                  android:layout_width="wrap_content"
diff --git a/facebook/res/layout/com_facebook_picker_list_row.xml b/facebook/res/layout/com_facebook_picker_list_row.xml
index 8f6725b11..74537abe3 100644
--- a/facebook/res/layout/com_facebook_picker_list_row.xml
+++ b/facebook/res/layout/com_facebook_picker_list_row.xml
@@ -18,7 +18,7 @@
 <LinearLayout
         xmlns:android="http://schemas.android.com/apk/res/android"
         android:layout_height="wrap_content"
-        android:layout_width="fill_parent"
+        android:layout_width="match_parent"
         >
     <ViewStub
             android:id="@+id/com_facebook_picker_profile_pic_stub"
diff --git a/facebook/res/layout/com_facebook_picker_list_section_header.xml b/facebook/res/layout/com_facebook_picker_list_section_header.xml
index ef04e3bc9..21c6fbd03 100644
--- a/facebook/res/layout/com_facebook_picker_list_section_header.xml
+++ b/facebook/res/layout/com_facebook_picker_list_section_header.xml
@@ -18,7 +18,7 @@
 <TextView
     xmlns:android="http://schemas.android.com/apk/res/android"
     android:id="@+id/com_facebook_picker_list_section_header"
-    android:layout_width="fill_parent"
+    android:layout_width="match_parent"
     android:layout_height="wrap_content"
     android:textStyle="bold"
     android:background="@drawable/com_facebook_list_section_header_background"
diff --git a/facebook/res/layout/com_facebook_picker_title_bar.xml b/facebook/res/layout/com_facebook_picker_title_bar.xml
index ecadecac9..07e70dc65 100644
--- a/facebook/res/layout/com_facebook_picker_title_bar.xml
+++ b/facebook/res/layout/com_facebook_picker_title_bar.xml
@@ -17,7 +17,7 @@
 
 <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
                 android:id="@+id/com_facebook_picker_top_bar"
-                android:layout_width="fill_parent"
+                android:layout_width="match_parent"
                 android:layout_height="48dp"
                 android:background="@drawable/com_facebook_top_background"
                 android:gravity="right">
@@ -40,13 +40,13 @@
     <LinearLayout
             android:id="@+id/com_facebook_picker_divider"
             android:layout_width="1dp"
-            android:layout_height="fill_parent"
+            android:layout_height="match_parent"
             android:background="#40000000"
             android:layout_alignLeft="@id/com_facebook_picker_done_button"/>
     <TextView
             android:id="@+id/com_facebook_picker_title"
-            android:layout_width="fill_parent"
-            android:layout_height="fill_parent"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
             android:textSize="22sp"
             android:textColor="#FFFFFF"
             android:gravity="left|center_vertical"
diff --git a/facebook/res/layout/com_facebook_picker_title_bar_stub.xml b/facebook/res/layout/com_facebook_picker_title_bar_stub.xml
index ebbffd883..481fe6805 100644
--- a/facebook/res/layout/com_facebook_picker_title_bar_stub.xml
+++ b/facebook/res/layout/com_facebook_picker_title_bar_stub.xml
@@ -20,6 +20,6 @@
               android:inflatedId="@+id/com_facebook_picker_title_bar"
               android:layout="@layout/com_facebook_picker_title_bar"
               android:layout_height="48dip"
-              android:layout_width="fill_parent"/>
+              android:layout_width="match_parent"/>
 
 </merge>
diff --git a/facebook/res/layout/com_facebook_placepickerfragment.xml b/facebook/res/layout/com_facebook_placepickerfragment.xml
index 56c5cc8ee..87374c731 100644
--- a/facebook/res/layout/com_facebook_placepickerfragment.xml
+++ b/facebook/res/layout/com_facebook_placepickerfragment.xml
@@ -16,8 +16,8 @@
 -->
 
 <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:layout_width="fill_parent"
-              android:layout_height="fill_parent"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
               android:background="#FFFFFF"
               android:descendantFocusability="beforeDescendants"
               android:focusableInTouchMode="true">
@@ -26,8 +26,8 @@
 
     <ListView
             android:id="@+id/com_facebook_picker_list_view"
-            android:layout_width="fill_parent"
-            android:layout_height="fill_parent"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
             android:layout_alignParentTop="true"
             android:divider="@null"
             android:fastScrollEnabled="true"
diff --git a/facebook/res/layout/com_facebook_usersettingsfragment.xml b/facebook/res/layout/com_facebook_usersettingsfragment.xml
index c35c18654..17d29b8c7 100644
--- a/facebook/res/layout/com_facebook_usersettingsfragment.xml
+++ b/facebook/res/layout/com_facebook_usersettingsfragment.xml
@@ -18,11 +18,11 @@
 <ScrollView
     xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:loginView="http://schemas.android.com/apk/res-auto"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
     android:background="@drawable/com_facebook_usersettingsfragment_background_gradient" >
     <LinearLayout
-        android:layout_width="fill_parent"
+        android:layout_width="match_parent"
         android:layout_height="wrap_content"
         android:orientation="vertical">
 
@@ -37,7 +37,7 @@
 
         <TextView
             android:id="@+id/com_facebook_usersettingsfragment_profile_name"
-            android:layout_width="fill_parent"
+            android:layout_width="match_parent"
             android:layout_height="100dp"
             android:lines="1"
             android:textSize="16sp"
diff --git a/facebook/res/values/attrs.xml b/facebook/res/values/attrs.xml
index 21c3bacef..64c365c2d 100644
--- a/facebook/res/values/attrs.xml
+++ b/facebook/res/values/attrs.xml
@@ -49,4 +49,26 @@
         </attr>
         <attr name="is_cropped" format="boolean" />
     </declare-styleable>
+    <declare-styleable name="com_facebook_like_view">
+        <attr name="foreground_color" format="color" />
+        <attr name="object_id" format="string" />
+        <attr name="style">
+            <!-- Keep in sync with Enums in LikeView -->
+            <enum name="standard" value="0" />
+            <enum name="button" value="1" />
+            <enum name="box_count" value="2" />
+        </attr>
+        <attr name="auxiliary_view_position">
+            <!-- Keep in sync with Enums in LikeView -->
+            <enum name="bottom" value="0" />
+            <enum name="inline" value="1" />
+            <enum name="top" value="2" />
+        </attr>
+        <attr name="horizontal_alignment">
+            <!-- Keep in sync with Enums in LikeView -->
+            <enum name="center" value="0" />
+            <enum name="left" value="1" />
+            <enum name="right" value="2" />
+        </attr>
+    </declare-styleable>
 </resources>
diff --git a/facebook/res/values/strings.xml b/facebook/res/values/strings.xml
index e73d31fc0..ee6445ebf 100644
--- a/facebook/res/values/strings.xml
+++ b/facebook/res/values/strings.xml
@@ -17,6 +17,8 @@
 
 <resources>
     <string name="com_facebook_dialogloginactivity_ok_button">OK</string>
+    <string name="com_facebook_like_button_not_liked">Like</string>
+    <string name="com_facebook_like_button_liked">Liked</string>
     <string name="com_facebook_loginview_log_out_button">Log out</string>
     <string name="com_facebook_loginview_log_in_button">Log in with Facebook</string>
     <string name="com_facebook_loginview_logged_in_as">Logged in as: %1$s</string>
diff --git a/facebook/res/values/styles.xml b/facebook/res/values/styles.xml
index 926b60346..11c954d48 100644
--- a/facebook/res/values/styles.xml
+++ b/facebook/res/values/styles.xml
@@ -32,6 +32,28 @@
     <color name="com_facebook_loginview_text_color">#FFFFFF</color>
     <dimen name="com_facebook_loginview_text_size">16.0sp</dimen>
 
+    <dimen name="com_facebook_likeview_text_size">11.0sp</dimen>
+    <color name="com_facebook_likeview_text_color">#6a7180</color>
+    <dimen name="com_facebook_likeview_edge_padding">2dp</dimen>
+    <dimen name="com_facebook_likeview_internal_padding">6dp</dimen>
+
+    <dimen name="com_facebook_likebutton_padding_left">8dp</dimen>
+    <dimen name="com_facebook_likebutton_padding_right">8dp</dimen>
+    <dimen name="com_facebook_likebutton_padding_top">0dp</dimen>
+    <dimen name="com_facebook_likebutton_padding_bottom">0dp</dimen>
+    <dimen name="com_facebook_likebutton_compound_drawable_padding">8dp</dimen>
+    <color name="com_facebook_likebutton_text_color">#FFFFFF</color>
+    <dimen name="com_facebook_likebutton_text_size">13.0sp</dimen>
+
+    <dimen name="com_facebook_likeboxcountview_caret_width">6dp</dimen>
+    <dimen name="com_facebook_likeboxcountview_caret_height">3dp</dimen>
+    <dimen name="com_facebook_likeboxcountview_border_radius">3dp</dimen>
+    <dimen name="com_facebook_likeboxcountview_border_width">1dp</dimen>
+    <color name="com_facebook_likeboxcountview_border_color">#6a7180</color>
+    <color name="com_facebook_likeboxcountview_text_color">#6a7180</color>
+    <dimen name="com_facebook_likeboxcountview_text_size">11.0sp</dimen>
+    <dimen name="com_facebook_likeboxcountview_text_padding">6dp</dimen>
+
     <dimen name="com_facebook_profilepictureview_preset_size_small">50dp</dimen>
     <dimen name="com_facebook_profilepictureview_preset_size_normal">100dp</dimen>
     <dimen name="com_facebook_profilepictureview_preset_size_large">180dp</dimen>
diff --git a/facebook/src/com/facebook/AppEventsLogger.java b/facebook/src/com/facebook/AppEventsLogger.java
index c1ccd1dea..cf3ebf607 100644
--- a/facebook/src/com/facebook/AppEventsLogger.java
+++ b/facebook/src/com/facebook/AppEventsLogger.java
@@ -17,8 +17,8 @@
 package com.facebook;
 
 import android.app.Activity;
-import android.content.Context;
 import android.content.ComponentName;
+import android.content.Context;
 import android.content.Intent;
 import android.os.Bundle;
 import android.support.v4.content.LocalBroadcastManager;
@@ -33,9 +33,21 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
-import java.io.*;
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.FileNotFoundException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.io.UnsupportedEncodingException;
 import java.math.BigDecimal;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
@@ -73,7 +85,7 @@
  * in a number of situations:
  * <ul>
  * <li>when an event count threshold is passed (currently 100 logged events).</li>
- * <li>when a time threshold is passed (currently 60 seconds).</li>
+ * <li>when a time threshold is passed (currently 15 seconds).</li>
  * <li>when an app has gone to background and is then brought back to the foreground.</li>
  * </ul>
  * <li>
@@ -135,7 +147,7 @@
     private static final String TAG = AppEventsLogger.class.getCanonicalName();
 
     private static final int NUM_LOG_EVENTS_TO_TRY_TO_FLUSH_AFTER = 100;
-    private static final int FLUSH_PERIOD_IN_SECONDS = 60;
+    private static final int FLUSH_PERIOD_IN_SECONDS = 15;
     private static final int APP_SUPPORTS_ATTRIBUTION_ID_RECHECK_PERIOD_IN_SECONDS = 60 * 60 * 24;
     private static final int FLUSH_APP_SESSION_INFO_IN_SECONDS = 30;
 
@@ -783,7 +795,7 @@ private static void flushAndWait(final FlushReason reason) {
         try {
             flushResults = buildAndExecuteRequests(reason, keysToFlush);
         } catch (Exception e) {
-            Log.d(TAG, "Caught unexpected exception while flushing: " + e.toString());
+            Utility.logd(TAG, "Caught unexpected exception while flushing: ", e);
         }
 
         synchronized (staticLock) {
@@ -859,6 +871,10 @@ private static Request buildRequestForSession(final AccessTokenAppIdPair accessT
         requestParameters.putString("access_token", accessTokenAppId.getAccessToken());
         postRequest.setParameters(requestParameters);
 
+        if (fetchedAppSettings == null) {
+            return null;
+        }
+
         int numEvents = sessionEventsState.populateRequest(postRequest, fetchedAppSettings.supportsImplicitLogging(),
                 fetchedAppSettings.supportsAttribution(), limitEventUsage);
         if (numEvents == 0) {
@@ -1184,15 +1200,13 @@ public AppEvent(
                 Bundle parameters,
                 boolean isImplicitlyLogged
         ) {
+            try {
+                validateIdentifier(eventName);
 
-            validateIdentifier(eventName);
-
-            this.name = eventName;
-
-            isImplicit = isImplicitlyLogged;
-            jsonObject = new JSONObject();
+                this.name = eventName;
+                isImplicit = isImplicitlyLogged;
+                jsonObject = new JSONObject();
 
-            try {
                 jsonObject.put("_eventName", eventName);
                 jsonObject.put("_logTime", System.currentTimeMillis() / 1000);
                 jsonObject.put("_ui", Utility.getActivityName(context));
@@ -1240,6 +1254,11 @@ public AppEvent(
                         "JSON encoding for app event failed: '%s'", jsonException.toString());
                 jsonObject = null;
 
+            } catch (FacebookException e) {
+                // If any of the above failed, just consider this an illegal event.
+                Logger.log(LoggingBehavior.APP_EVENTS, "AppEvents",
+                        "Invalid app event name or parameter:", e.toString());
+                jsonObject = null;
             }
         }
 
@@ -1261,7 +1280,7 @@ public JSONObject getJSONObject() {
         }
 
         // throw exception if not valid.
-        private void validateIdentifier(String identifier) {
+        private void validateIdentifier(String identifier) throws FacebookException {
 
             // Identifier should be 40 chars or less, and only have 0-9A-Za-z, underscore, hyphen, and space (but no
             // hyphen or space in the first position).
@@ -1296,7 +1315,6 @@ private void validateIdentifier(String identifier) {
                     );
                 }
             }
-
         }
 
         private static class SerializationProxyV1 implements Serializable {
diff --git a/facebook/src/com/facebook/AuthorizationClient.java b/facebook/src/com/facebook/AuthorizationClient.java
index 00a0c0726..8b05e00fa 100644
--- a/facebook/src/com/facebook/AuthorizationClient.java
+++ b/facebook/src/com/facebook/AuthorizationClient.java
@@ -582,6 +582,9 @@ boolean needsInternetPermission() {
         @Override
         void cancel() {
             if (loginDialog != null) {
+                // Since we are calling dismiss explicitly, we need to remove the completion listener to prevent
+                // responding to the upcoming "Cancel" result.
+                loginDialog.setOnCompleteListener(null);
                 loginDialog.dismiss();
                 loginDialog = null;
             }
diff --git a/facebook/src/com/facebook/BoltsMeasurementEventListener.java b/facebook/src/com/facebook/BoltsMeasurementEventListener.java
index 6e1d71039..b9a6e57cb 100644
--- a/facebook/src/com/facebook/BoltsMeasurementEventListener.java
+++ b/facebook/src/com/facebook/BoltsMeasurementEventListener.java
@@ -4,6 +4,7 @@
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.os.Bundle;
 import android.support.v4.content.LocalBroadcastManager;
 
 public class BoltsMeasurementEventListener extends BroadcastReceiver {
@@ -51,6 +52,12 @@ protected void finalize() throws Throwable {
     public void onReceive(Context context, Intent intent) {
         AppEventsLogger appEventsLogger = AppEventsLogger.newLogger(context);
         String eventName = BOLTS_MEASUREMENT_EVENT_PREFIX + intent.getStringExtra(MEASUREMENT_EVENT_NAME_KEY);
-        appEventsLogger.logEvent(eventName, intent.getBundleExtra(MEASUREMENT_EVENT_ARGS_KEY));
+        Bundle eventArgs = intent.getBundleExtra(MEASUREMENT_EVENT_ARGS_KEY);
+        Bundle logData = new Bundle();
+        for(String key : eventArgs.keySet()) {
+           String safeKey = key.replaceAll("[^0-9a-zA-Z _-]", "-").replaceAll("^[ -]*", "").replaceAll("[ -]*$", "");
+           logData.putString(safeKey, (String)eventArgs.get(key));
+        }
+        appEventsLogger.logEvent(eventName, logData);
     }
 }
diff --git a/facebook/src/com/facebook/FacebookSdkVersion.java b/facebook/src/com/facebook/FacebookSdkVersion.java
index 06121fa31..9b9671ece 100644
--- a/facebook/src/com/facebook/FacebookSdkVersion.java
+++ b/facebook/src/com/facebook/FacebookSdkVersion.java
@@ -17,5 +17,5 @@
 package com.facebook;
 
 final class FacebookSdkVersion {
-    public static final String BUILD = "3.18.0";
+    public static final String BUILD = "3.19.1";
 }
diff --git a/facebook/src/com/facebook/FacebookTimeSpentData.java b/facebook/src/com/facebook/FacebookTimeSpentData.java
index 2a5e2155c..029a8452d 100644
--- a/facebook/src/com/facebook/FacebookTimeSpentData.java
+++ b/facebook/src/com/facebook/FacebookTimeSpentData.java
@@ -253,9 +253,9 @@ private void logAppDeactivatedEvent(AppEventsLogger logger,
         eventParams.putInt(
                 AppEventsConstants.EVENT_NAME_SESSION_INTERRUPTIONS,
                 interruptionCount);
-        eventParams.putInt(
+        eventParams.putString(
                 AppEventsConstants.EVENT_NAME_TIME_BETWEEN_SESSIONS,
-                getQuantaIndex(interruptionDurationMillis));
+                String.format("session_quanta_%d", getQuantaIndex(interruptionDurationMillis)));
         eventParams.putString(
                 AppEventsConstants.EVENT_PARAM_SOURCE_APPLICATION,
                 firstOpenSourceApplication);
diff --git a/facebook/src/com/facebook/Request.java b/facebook/src/com/facebook/Request.java
index 9b95938c8..32fcfd050 100644
--- a/facebook/src/com/facebook/Request.java
+++ b/facebook/src/com/facebook/Request.java
@@ -124,6 +124,7 @@
     private String overriddenURL;
     private Object tag;
     private String version;
+    private boolean skipClientToken = false;
 
     /**
      * Constructs a request without a session, graph path, or any other parameters.
@@ -905,6 +906,13 @@ public final void setVersion(String version) {
         this.version = version;
     }
 
+    /**
+     * This is an internal function that is not meant to be used by developers.
+     */
+    public final void setSkipClientToken(boolean skipClientToken) {
+        this.skipClientToken = skipClientToken;
+    }
+
     /**
      * Returns the parameters for this request.
      *
@@ -1698,7 +1706,7 @@ private void addCommonParameters() {
                 Logger.registerAccessToken(accessToken);
                 this.parameters.putString(ACCESS_TOKEN_PARAM, accessToken);
             }
-        } else if (!this.parameters.containsKey(ACCESS_TOKEN_PARAM)) {
+        } else if (!skipClientToken && !this.parameters.containsKey(ACCESS_TOKEN_PARAM)) {
             String appID = Settings.getApplicationId();
             String clientToken = Settings.getClientToken();
             if (!Utility.isNullOrEmpty(appID) && !Utility.isNullOrEmpty(clientToken)) {
@@ -1912,7 +1920,9 @@ final static void serializeToUrlConnection(RequestBatch requests, HttpURLConnect
             processRequest(requests, logger, numRequests, url, outputStream);
         }
         finally {
-            outputStream.close();
+            if (outputStream != null) {
+                outputStream.close();
+            }
         }
 
         logger.log();
diff --git a/facebook/src/com/facebook/Settings.java b/facebook/src/com/facebook/Settings.java
index c08376c1d..7a2d943c5 100644
--- a/facebook/src/com/facebook/Settings.java
+++ b/facebook/src/com/facebook/Settings.java
@@ -20,12 +20,15 @@
 import android.content.Context;
 import android.content.SharedPreferences;
 import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
+import android.content.pm.Signature;
 import android.database.Cursor;
 import android.net.Uri;
 import android.os.AsyncTask;
 import android.os.Handler;
 import android.os.Looper;
+import android.util.Base64;
 import android.util.Log;
 import com.facebook.android.BuildConfig;
 import com.facebook.internal.AttributionIdentifiers;
@@ -36,6 +39,8 @@
 import org.json.JSONObject;
 
 import java.lang.reflect.Field;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
@@ -61,7 +66,7 @@
     private static volatile String facebookDomain = FACEBOOK_COM;
     private static AtomicLong onProgressThreshold = new AtomicLong(65536);
     private static volatile boolean platformCompatibilityEnabled;
-    private static volatile boolean isLoggingEnabled = BuildConfig.DEBUG;
+    private static volatile boolean isDebugEnabled = BuildConfig.DEBUG;
 
     private static final int DEFAULT_CORE_POOL_SIZE = 5;
     private static final int DEFAULT_MAXIMUM_POOL_SIZE = 128;
@@ -112,6 +117,12 @@ public static synchronized void sdkInitialize(Context context) {
         if (sdkInitialized == true) {
           return;
         }
+
+        // Make sure we've loaded default settings if we haven't already.
+        Settings.loadDefaultsFromMetadataIfNeeded(context);
+        // Load app settings from network so that dialog configs are available
+        Utility.loadAppSettingsAsync(context, Settings.getApplicationId());
+
         BoltsMeasurementEventListener.getInstance(context.getApplicationContext());
         sdkInitialized = true;
     }
@@ -184,24 +195,39 @@ public static final void clearLoggingBehaviors() {
      */
     public static final boolean isLoggingBehaviorEnabled(LoggingBehavior behavior) {
         synchronized (loggingBehaviors) {
-            return Settings.isLoggingEnabled() && loggingBehaviors.contains(behavior);
+            return Settings.isDebugEnabled() && loggingBehaviors.contains(behavior);
         }
     }
 
     /**
-     * Indicates if logging is enabled.
+     * This method is deprecated.  Use {@link Settings#isDebugEnabled()} instead.
      */
+    @Deprecated
     public static final boolean isLoggingEnabled() {
-        return isLoggingEnabled;
+        return isDebugEnabled();
     }
 
     /**
-     * Used to enable or disable logging, defaults to BuildConfig.DEBUG.
-     * @param enabled
-     *          Logging is enabled if true, disabled if false.
+     * This method is deprecated.  Use {@link Settings#setIsDebugEnabled(boolean)} instead.
      */
+    @Deprecated
     public static final void setIsLoggingEnabled(boolean enabled) {
-        isLoggingEnabled = enabled;
+        setIsDebugEnabled(enabled);
+    }
+
+    /**
+     * Indicates if we are in debug mode.
+     */
+    public static final boolean isDebugEnabled() {
+        return isDebugEnabled;
+    }
+
+    /**
+     * Used to enable or disable logging, and other debug features. Defaults to BuildConfig.DEBUG.
+     * @param enabled Debug features (like logging) are enabled if true, disabled if false.
+     */
+    public static final void setIsDebugEnabled(boolean enabled) {
+        isDebugEnabled = enabled;
     }
 
     /**
@@ -567,6 +593,39 @@ static void loadDefaultsFromMetadataIfNeeded(Context context) {
         }
     }
 
+    public static String getApplicationSignature(Context context) {
+        if (context == null) {
+            return null;
+        }
+        PackageManager packageManager = context.getPackageManager();
+        if (packageManager == null) {
+            return null;
+        }
+
+        String packageName = context.getPackageName();
+        PackageInfo pInfo;
+        try {
+            pInfo = packageManager.getPackageInfo(packageName, PackageManager.GET_SIGNATURES);
+        } catch (PackageManager.NameNotFoundException e) {
+            return null;
+        }
+
+        Signature[] signatures = pInfo.signatures;
+        if (signatures == null || signatures.length == 0) {
+            return null;
+        }
+
+        MessageDigest md;
+        try {
+            md = MessageDigest.getInstance("SHA-1");
+        } catch (NoSuchAlgorithmException e) {
+            return null;
+        }
+
+        md.update(pInfo.signatures[0].toByteArray());
+        return Base64.encodeToString(md.digest(),  Base64.URL_SAFE | Base64.NO_PADDING);
+    }
+
     /**
      * Gets the Facebook application ID for the current app. This will be null unless explicitly set or unless
      * loadDefaultsFromMetadata has been called.
diff --git a/facebook/src/com/facebook/UiLifecycleHelper.java b/facebook/src/com/facebook/UiLifecycleHelper.java
index 8d5b73024..3ebf61c98 100644
--- a/facebook/src/com/facebook/UiLifecycleHelper.java
+++ b/facebook/src/com/facebook/UiLifecycleHelper.java
@@ -24,7 +24,10 @@
 import android.os.Bundle;
 import android.support.v4.content.LocalBroadcastManager;
 import android.util.Log;
+import com.facebook.internal.LikeActionController;
 import com.facebook.internal.NativeProtocol;
+import com.facebook.internal.PendingCallStore;
+import com.facebook.internal.Utility;
 import com.facebook.widget.FacebookDialog;
 
 import java.util.UUID;
@@ -42,7 +45,7 @@
  * results generated by those dialogs.
  */
 public class UiLifecycleHelper {
-    private static final String DIALOG_CALL_BUNDLE_SAVE_KEY =
+    private static final String DIALOG_CALL_ID_SAVE_KEY =
             "com.facebook.UiLifecycleHelper.pendingFacebookDialogCallKey";
 
     private final static String ACTIVITY_NULL_MESSAGE = "activity cannot be null";
@@ -52,7 +55,9 @@
     private final BroadcastReceiver receiver;
     private final LocalBroadcastManager broadcastManager;
     // Members related to handling FacebookDialog calls
-    private FacebookDialog.PendingCall pendingFacebookDialogCall;
+    private UUID pendingFacebookDialogCallId;
+    private PendingCallStore pendingFacebookDialogCallStore;
+
     private AppEventsLogger appEventsLogger;
 
     /**
@@ -71,10 +76,10 @@ public UiLifecycleHelper(Activity activity, Session.StatusCallback callback) {
         this.callback = callback;
         this.receiver = new ActiveSessionBroadcastReceiver();
         this.broadcastManager = LocalBroadcastManager.getInstance(activity);
+        this.pendingFacebookDialogCallStore = PendingCallStore.getInstance();
+
         // initialize SDK
         Settings.sdkInitialize(activity);
-        // Make sure we've loaded default settings if we haven't already.
-        Settings.loadDefaultsFromMetadataIfNeeded(activity);
     }
 
     /**
@@ -94,7 +99,11 @@ public void onCreate(Bundle savedInstanceState) {
             Session.setActiveSession(session);
         }
         if (savedInstanceState != null) {
-            pendingFacebookDialogCall = savedInstanceState.getParcelable(DIALOG_CALL_BUNDLE_SAVE_KEY);
+            String callIdString = savedInstanceState.getString(DIALOG_CALL_ID_SAVE_KEY);
+            if (callIdString != null) {
+                pendingFacebookDialogCallId = UUID.fromString(callIdString);
+            }
+            pendingFacebookDialogCallStore.restoreFromSavedInstanceState(savedInstanceState);
         }
     }
 
@@ -140,7 +149,7 @@ public void onActivityResult(int requestCode, int resultCode, Intent data) {
      * @param requestCode the request code
      * @param resultCode the result code
      * @param data the result data
-     * @param dialogCallback the callback for handling FacebookDialog results, can be null
+     * @param facebookDialogCallback the callback for handling FacebookDialog results, can be null
      */
     public void onActivityResult(int requestCode, int resultCode, Intent data,
                 FacebookDialog.Callback facebookDialogCallback) {
@@ -149,6 +158,10 @@ public void onActivityResult(int requestCode, int resultCode, Intent data,
             session.onActivityResult(activity, requestCode, resultCode, data);
         }
 
+        if (LikeActionController.handleOnActivityResult(activity, requestCode, resultCode, data)) {
+            return;
+        }
+
         handleFacebookDialogActivityResult(requestCode, resultCode, data, facebookDialogCallback);
     }
 
@@ -159,7 +172,10 @@ public void onActivityResult(int requestCode, int resultCode, Intent data,
      */
     public void onSaveInstanceState(Bundle outState) {
         Session.saveSession(Session.getActiveSession(), outState);
-        outState.putParcelable(DIALOG_CALL_BUNDLE_SAVE_KEY, pendingFacebookDialogCall);
+        if (pendingFacebookDialogCallId != null) {
+            outState.putString(DIALOG_CALL_ID_SAVE_KEY, pendingFacebookDialogCallId.toString());
+        }
+        pendingFacebookDialogCallStore.saveInstanceState(outState);
     }
 
     /**
@@ -198,12 +214,15 @@ public void onDestroy() {
      * @param appCall an PendingCall object containing the call ID
      */
     public void trackPendingDialogCall(FacebookDialog.PendingCall pendingCall) {
-        if (pendingFacebookDialogCall != null) {
+        if (pendingFacebookDialogCallId != null) {
             // If one is already pending, cancel it; we don't allow multiple pending calls.
             Log.i("Facebook", "Tracking new app call while one is still pending; canceling pending call.");
             cancelPendingAppCall(null);
         }
-        pendingFacebookDialogCall = pendingCall;
+        if (pendingCall != null){
+            pendingFacebookDialogCallId = pendingCall.getCallId();
+            pendingFacebookDialogCallStore.trackPendingCall(pendingCall);
+        }
     }
 
     /**
@@ -258,7 +277,12 @@ public void onReceive(Context context, Intent intent) {
 
     private boolean handleFacebookDialogActivityResult(int requestCode, int resultCode, Intent data,
             FacebookDialog.Callback facebookDialogCallback) {
-        if (pendingFacebookDialogCall == null || pendingFacebookDialogCall.getRequestCode() != requestCode) {
+        if (pendingFacebookDialogCallId == null) {
+            return false;
+        }
+        FacebookDialog.PendingCall pendingCall =
+                pendingFacebookDialogCallStore.getPendingCallById(pendingFacebookDialogCallId);
+        if (pendingCall == null || pendingCall.getRequestCode() != requestCode) {
             return false;
         }
 
@@ -272,9 +296,9 @@ private boolean handleFacebookDialogActivityResult(int requestCode, int resultCo
         UUID callId = NativeProtocol.getCallIdFromIntent(data);
 
         // Was this result for the call we are waiting on?
-        if (callId != null && pendingFacebookDialogCall.getCallId().equals(callId)) {
+        if (callId != null && pendingFacebookDialogCallId.equals(callId)) {
             // Yes, we can handle it normally.
-            FacebookDialog.handleActivityResult(activity, pendingFacebookDialogCall, requestCode, data,
+            FacebookDialog.handleActivityResult(activity, pendingCall, requestCode, data,
                     facebookDialogCallback);
         } else {
             // No, send a cancellation error to the pending call and ignore the result, because we
@@ -282,13 +306,23 @@ private boolean handleFacebookDialogActivityResult(int requestCode, int resultCo
             cancelPendingAppCall(facebookDialogCallback);
         }
 
-        pendingFacebookDialogCall = null;
+        stopTrackingPendingAppCall();
         return true;
     }
 
     private void cancelPendingAppCall(FacebookDialog.Callback facebookDialogCallback) {
+        if (pendingFacebookDialogCallId == null) {
+            return;
+        }
+
+        FacebookDialog.PendingCall pendingCall =
+                pendingFacebookDialogCallStore.getPendingCallById(pendingFacebookDialogCallId);
+        if (pendingCall == null) {
+            return;
+        }
+
         if (facebookDialogCallback != null) {
-            Intent pendingIntent = pendingFacebookDialogCall.getRequestIntent();
+            Intent pendingIntent = pendingCall.getRequestIntent();
 
             Intent cancelIntent = new Intent();
             cancelIntent.putExtra(NativeProtocol.EXTRA_PROTOCOL_CALL_ID,
@@ -299,9 +333,15 @@ private void cancelPendingAppCall(FacebookDialog.Callback facebookDialogCallback
                     pendingIntent.getIntExtra(NativeProtocol.EXTRA_PROTOCOL_VERSION, 0));
             cancelIntent.putExtra(NativeProtocol.STATUS_ERROR_TYPE, NativeProtocol.ERROR_UNKNOWN_ERROR);
 
-            FacebookDialog.handleActivityResult(activity, pendingFacebookDialogCall,
-                    pendingFacebookDialogCall.getRequestCode(), cancelIntent, facebookDialogCallback);
+            FacebookDialog.handleActivityResult(activity, pendingCall,
+                    pendingCall.getRequestCode(), cancelIntent, facebookDialogCallback);
         }
-        pendingFacebookDialogCall = null;
+
+        stopTrackingPendingAppCall();
+    }
+
+    private void stopTrackingPendingAppCall() {
+        pendingFacebookDialogCallStore.stopTrackingPendingCall(pendingFacebookDialogCallId);
+        pendingFacebookDialogCallId = null;
     }
 }
diff --git a/facebook/src/com/facebook/internal/AnalyticsEvents.java b/facebook/src/com/facebook/internal/AnalyticsEvents.java
index e57ec0fb7..a7b8038ee 100644
--- a/facebook/src/com/facebook/internal/AnalyticsEvents.java
+++ b/facebook/src/com/facebook/internal/AnalyticsEvents.java
@@ -19,6 +19,7 @@
     public static final String PARAMETER_WEB_LOGIN_E2E                  = "fb_web_login_e2e";
     public static final String PARAMETER_WEB_LOGIN_SWITCHBACK_TIME      = "fb_web_login_switchback_time";
     public static final String PARAMETER_APP_ID                         = "app_id";
+    public static final String PARAMETER_CALL_ID                        = "call_id";
     public static final String PARAMETER_ACTION_ID                      = "action_id";
     public static final String PARAMETER_NATIVE_LOGIN_DIALOG_START_TIME = "fb_native_login_dialog_start_time";
     public static final String PARAMETER_NATIVE_LOGIN_DIALOG_COMPLETE_TIME =
@@ -36,4 +37,22 @@
     public static final String EVENT_NATIVE_DIALOG_TYPE_OG_MESSAGE      = "fb_dialogs_present_message_og";
     public static final String EVENT_NATIVE_DIALOG_TYPE_PHOTO_SHARE     = "fb_dialogs_present_share_photo";
     public static final String EVENT_NATIVE_DIALOG_TYPE_PHOTO_MESSAGE   = "fb_dialogs_present_message_photo";
+    public static final String EVENT_NATIVE_DIALOG_TYPE_LIKE            = "fb_dialogs_present_like";
+
+    public static final String EVENT_LIKE_VIEW_CANNOT_PRESENT_DIALOG    = "fb_like_control_cannot_present_dialog";
+    public static final String EVENT_LIKE_VIEW_DID_LIKE                 = "fb_like_control_did_like";
+    public static final String EVENT_LIKE_VIEW_DID_PRESENT_DIALOG       = "fb_like_control_did_present_dialog";
+    public static final String EVENT_LIKE_VIEW_DID_PRESENT_FALLBACK     = "fb_like_control_did_present_fallback_dialog";
+    public static final String EVENT_LIKE_VIEW_DID_TAP                  = "fb_like_control_did_tap";
+    public static final String EVENT_LIKE_VIEW_DID_UNLIKE               = "fb_like_control_did_unlike";
+    public static final String EVENT_LIKE_VIEW_DID_UNDO_QUICKLY         = "fb_like_control_did_undo_quickly";
+    public static final String EVENT_LIKE_VIEW_DIALOG_DID_SUCCEED       = "fb_like_control_dialog_did_succeed";
+    public static final String EVENT_LIKE_VIEW_ERROR                    = "fb_like_control_error";
+
+    public static final String PARAMETER_LIKE_VIEW_STYLE                = "style";
+    public static final String PARAMETER_LIKE_VIEW_AUXILIARY_POSITION   = "auxiliary_position";
+    public static final String PARAMETER_LIKE_VIEW_HORIZONTAL_ALIGNMENT = "horizontal_alignment";
+    public static final String PARAMETER_LIKE_VIEW_OBJECT_ID            = "object_id";
+    public static final String PARAMETER_LIKE_VIEW_CURRENT_ACTION       = "current_action";
+    public static final String PARAMETER_LIKE_VIEW_ERROR_JSON           = "error";
 }
diff --git a/facebook/src/com/facebook/internal/BundleJSONConverter.java b/facebook/src/com/facebook/internal/BundleJSONConverter.java
new file mode 100644
index 000000000..c674ff3c1
--- /dev/null
+++ b/facebook/src/com/facebook/internal/BundleJSONConverter.java
@@ -0,0 +1,199 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import android.os.Bundle;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.*;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+
+/**
+ * A helper class that can round trip between JSON and Bundle objects that contains the types:
+ *   Boolean, Integer, Long, Double, String
+ * If other types are found, an IllegalArgumentException is thrown.
+ */
+public class BundleJSONConverter {
+    private static final Map<Class<?>, Setter> SETTERS = new HashMap<Class<?>, Setter>();
+
+    static {
+        SETTERS.put(Boolean.class, new Setter() {
+            public void setOnBundle(Bundle bundle, String key, Object value) throws JSONException {
+                bundle.putBoolean(key, (Boolean) value);
+            }
+
+            public void setOnJSON(JSONObject json, String key, Object value)  throws JSONException {
+                json.put(key, value);
+            }
+        });
+        SETTERS.put(Integer.class, new Setter() {
+            public void setOnBundle(Bundle bundle, String key, Object value) throws JSONException {
+                bundle.putInt(key, (Integer) value);
+            }
+
+            public void setOnJSON(JSONObject json, String key, Object value)  throws JSONException {
+                json.put(key, value);
+            }
+        });
+        SETTERS.put(Long.class, new Setter() {
+            public void setOnBundle(Bundle bundle, String key, Object value) throws JSONException {
+                bundle.putLong(key, (Long) value);
+            }
+
+            public void setOnJSON(JSONObject json, String key, Object value)  throws JSONException {
+                json.put(key, value);
+            }
+        });
+        SETTERS.put(Double.class, new Setter() {
+            public void setOnBundle(Bundle bundle, String key, Object value) throws JSONException {
+                bundle.putDouble(key, (Double) value);
+            }
+
+            public void setOnJSON(JSONObject json, String key, Object value)  throws JSONException {
+                json.put(key, value);
+            }
+        });
+        SETTERS.put(String.class, new Setter() {
+            public void setOnBundle(Bundle bundle, String key, Object value) throws JSONException {
+                bundle.putString(key, (String) value);
+            }
+
+            public void setOnJSON(JSONObject json, String key, Object value)  throws JSONException {
+                json.put(key, value);
+            }
+        });
+        SETTERS.put(String[].class, new Setter() {
+            public void setOnBundle(Bundle bundle, String key, Object value) throws JSONException {
+                throw new IllegalArgumentException("Unexpected type from JSON");
+            }
+
+            public void setOnJSON(JSONObject json, String key, Object value)  throws JSONException {
+                JSONArray jsonArray = new JSONArray();
+                for (String stringValue : (String[])value) {
+                    jsonArray.put(stringValue);
+                }
+                json.put(key, jsonArray);
+            }
+        });
+
+        SETTERS.put(JSONArray.class, new Setter() {
+            public void setOnBundle(Bundle bundle, String key, Object value) throws JSONException {
+                JSONArray jsonArray = (JSONArray)value;
+                ArrayList<String> stringArrayList = new ArrayList<String>();
+                // Empty list, can't even figure out the type, assume an ArrayList<String>
+                if (jsonArray.length() == 0) {
+                    bundle.putStringArrayList(key, stringArrayList);
+                    return;
+                }
+
+                // Only strings are supported for now
+                for (int i = 0; i < jsonArray.length(); i++) {
+                    Object current = jsonArray.get(i);
+                    if (current instanceof String) {
+                        stringArrayList.add((String)current);
+                    } else {
+                        throw new IllegalArgumentException("Unexpected type in an array: " + current.getClass());
+                    }
+                }
+                bundle.putStringArrayList(key, stringArrayList);
+            }
+
+            @Override
+            public void setOnJSON(JSONObject json, String key, Object value) throws JSONException {
+                throw new IllegalArgumentException("JSONArray's are not supported in bundles.");
+            }
+        });
+    }
+
+    public interface Setter {
+        public void setOnBundle(Bundle bundle, String key, Object value) throws JSONException;
+        public void setOnJSON(JSONObject json, String key, Object value) throws JSONException;
+    }
+
+    public static JSONObject convertToJSON(Bundle bundle) throws JSONException {
+        JSONObject json = new JSONObject();
+
+        for(String key : bundle.keySet()) {
+            Object value = bundle.get(key);
+            if (value == null) {
+                // Null is not supported.
+                continue;
+            }
+
+            // Special case List<String> as getClass would not work, since List is an interface
+            if (value instanceof List<?>) {
+                JSONArray jsonArray = new JSONArray();
+                @SuppressWarnings("unchecked")
+                List<String> listValue = (List<String>)value;
+                for (String stringValue : listValue) {
+                    jsonArray.put(stringValue);
+                }
+                json.put(key, jsonArray);
+                continue;
+            }
+
+            // Special case Bundle as it's one way, on the return it will be JSONObject
+            if (value instanceof Bundle) {
+                json.put(key, convertToJSON((Bundle)value));
+                continue;
+            }
+
+            Setter setter = SETTERS.get(value.getClass());
+            if (setter == null) {
+                throw new IllegalArgumentException("Unsupported type: " + value.getClass());
+            }
+            setter.setOnJSON(json, key, value);
+        }
+
+        return json;
+    }
+
+    public static Bundle convertToBundle(JSONObject jsonObject) throws JSONException {
+        Bundle bundle = new Bundle();
+        @SuppressWarnings("unchecked")
+        Iterator<String> jsonIterator = jsonObject.keys();
+        while (jsonIterator.hasNext()) {
+            String key = jsonIterator.next();
+            Object value = jsonObject.get(key);
+            if (value == null || value == JSONObject.NULL) {
+                // Null is not supported.
+                continue;
+            }
+
+            // Special case JSONObject as it's one way, on the return it would be Bundle.
+            if (value instanceof JSONObject) {
+                bundle.putBundle(key, convertToBundle((JSONObject)value));
+                continue;
+            }
+
+            Setter setter = SETTERS.get(value.getClass());
+            if (setter == null) {
+                throw new IllegalArgumentException("Unsupported type: " + value.getClass());
+            }
+            setter.setOnBundle(bundle, key, value);
+        }
+
+        return bundle;
+    }
+}
diff --git a/facebook/src/com/facebook/internal/FacebookWebFallbackDialog.java b/facebook/src/com/facebook/internal/FacebookWebFallbackDialog.java
new file mode 100644
index 000000000..5333187dc
--- /dev/null
+++ b/facebook/src/com/facebook/internal/FacebookWebFallbackDialog.java
@@ -0,0 +1,124 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Bundle;
+import com.facebook.FacebookException;
+import com.facebook.android.Util;
+import com.facebook.widget.FacebookDialog;
+import com.facebook.widget.WebDialog;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.EnumSet;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ *
+ * This dialog is used as a fallback when a native FacebookDialog could not be displayed. The primary reason for
+ * this separation is to keep this approach for internal use only until we stabilize the API.
+ */
+public class FacebookWebFallbackDialog extends WebDialog {
+    private static final String TAG = FacebookWebFallbackDialog.class.getName();
+
+    public static boolean presentWebFallback(final Context context,
+                                             String dialogUrl,
+                                             String applicationId,
+                                             final FacebookDialog.PendingCall appCall,
+                                             final FacebookDialog.Callback callback) {
+        if (Utility.isNullOrEmpty(dialogUrl)) {
+            return false;
+        }
+
+        String redirectUrl = String.format("fb%s://bridge/", applicationId);
+
+        // Show the webdialog.
+        FacebookWebFallbackDialog fallbackWebDialog = new FacebookWebFallbackDialog(
+                context, dialogUrl, redirectUrl);
+        fallbackWebDialog.setOnCompleteListener(new WebDialog.OnCompleteListener() {
+            @Override
+            public void onComplete(Bundle values, FacebookException error) {
+                Intent dummyIntent = new Intent();
+                dummyIntent.putExtras(values == null ? new Bundle() : values);
+                FacebookDialog.handleActivityResult(
+                        context,
+                        appCall,
+                        appCall.getRequestCode(),
+                        dummyIntent,
+                        callback);
+            }
+        });
+
+        fallbackWebDialog.show();
+        return true;
+    }
+
+    private FacebookWebFallbackDialog(Context context, String url, String expectedRedirectUrl) {
+        super(context, url);
+
+        setExpectedRedirectUrl(expectedRedirectUrl);
+    }
+
+    @Override
+    protected Bundle parseResponseUri(String url) {
+        Uri responseUri = Uri.parse(url);
+        Bundle queryParams = Utility.parseUrlQueryString(responseUri.getQuery());
+
+        // Convert Bridge args to the format that the Native dialog code understands.
+        String bridgeArgsJSONString = queryParams.getString(ServerProtocol.FALLBACK_DIALOG_PARAM_BRIDGE_ARGS);
+        queryParams.remove(ServerProtocol.FALLBACK_DIALOG_PARAM_BRIDGE_ARGS);
+
+        if (!Utility.isNullOrEmpty(bridgeArgsJSONString)) {
+            Bundle bridgeArgs;
+            try {
+                JSONObject bridgeArgsJSON = new JSONObject(bridgeArgsJSONString);
+                bridgeArgs = BundleJSONConverter.convertToBundle(bridgeArgsJSON);
+                queryParams.putBundle(NativeProtocol.EXTRA_PROTOCOL_BRIDGE_ARGS, bridgeArgs);
+            } catch (JSONException je) {
+                Utility.logd(TAG, "Unable to parse bridge_args JSON", je);
+            }
+        }
+
+        // Convert Method results to the format that the Native dialog code understands.
+        String methodResultsJSONString = queryParams.getString(ServerProtocol.FALLBACK_DIALOG_PARAM_METHOD_RESULTS);
+        queryParams.remove(ServerProtocol.FALLBACK_DIALOG_PARAM_METHOD_RESULTS);
+
+        if (!Utility.isNullOrEmpty(methodResultsJSONString)) {
+            methodResultsJSONString = Utility.isNullOrEmpty(methodResultsJSONString) ? "{}" : methodResultsJSONString;
+            Bundle methodResults;
+            try {
+                JSONObject methodArgsJSON = new JSONObject(methodResultsJSONString);
+                methodResults = BundleJSONConverter.convertToBundle(methodArgsJSON);
+                queryParams.putBundle(NativeProtocol.EXTRA_PROTOCOL_METHOD_RESULTS, methodResults);
+            } catch (JSONException je) {
+                Utility.logd(TAG, "Unable to parse bridge_args JSON", je);
+            }
+        }
+
+        // The web host does not send a numeric version back. Put the latest known version in there so NativeProtocol
+        // can continue parsing the response.
+        queryParams.remove(ServerProtocol.FALLBACK_DIALOG_PARAM_VERSION);
+        queryParams.putInt(NativeProtocol.EXTRA_PROTOCOL_VERSION, NativeProtocol.getLatestKnownVersion());
+
+        return queryParams;
+    }
+}
diff --git a/facebook/src/com/facebook/internal/LikeActionController.java b/facebook/src/com/facebook/internal/LikeActionController.java
new file mode 100644
index 000000000..d16af520d
--- /dev/null
+++ b/facebook/src/com/facebook/internal/LikeActionController.java
@@ -0,0 +1,1404 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import android.app.Activity;
+import android.content.*;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.v4.content.LocalBroadcastManager;
+import android.util.Log;
+import com.facebook.*;
+import com.facebook.widget.FacebookDialog;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.EnumSet;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public class LikeActionController {
+
+    public static final String ACTION_LIKE_ACTION_CONTROLLER_UPDATED = "com.facebook.sdk.LikeActionController.UPDATED";
+    public static final String ACTION_LIKE_ACTION_CONTROLLER_DID_ERROR = "com.facebook.sdk.LikeActionController.DID_ERROR";
+    public static final String ACTION_LIKE_ACTION_CONTROLLER_DID_RESET = "com.facebook.sdk.LikeActionController.DID_RESET";
+
+    public static final String ACTION_OBJECT_ID_KEY = "com.facebook.sdk.LikeActionController.OBJECT_ID";
+
+    public static final String ERROR_INVALID_OBJECT_ID = "Invalid Object Id";
+
+    private static final String TAG = LikeActionController.class.getSimpleName();
+
+    private static final int LIKE_ACTION_CONTROLLER_VERSION = 2;
+    private static final int MAX_CACHE_SIZE = 128;
+    // MAX_OBJECT_SUFFIX basically accommodates for 1000 session-state changes before the async disk-cache-clear
+    // finishes. The value is reasonably arbitrary.
+    private static final int MAX_OBJECT_SUFFIX = 1000;
+
+    private static final String LIKE_ACTION_CONTROLLER_STORE = "com.facebook.LikeActionController.CONTROLLER_STORE_KEY";
+    private static final String LIKE_ACTION_CONTROLLER_STORE_PENDING_OBJECT_ID_KEY = "PENDING_CONTROLLER_KEY";
+    private static final String LIKE_ACTION_CONTROLLER_STORE_OBJECT_SUFFIX_KEY = "OBJECT_SUFFIX";
+
+    private static final String JSON_INT_VERSION_KEY = "com.facebook.internal.LikeActionController.version";
+    private static final String JSON_STRING_OBJECT_ID_KEY = "object_id";
+    private static final String JSON_STRING_LIKE_COUNT_WITH_LIKE_KEY = "like_count_string_with_like";
+    private static final String JSON_STRING_LIKE_COUNT_WITHOUT_LIKE_KEY = "like_count_string_without_like";
+    private static final String JSON_STRING_SOCIAL_SENTENCE_WITH_LIKE_KEY = "social_sentence_with_like";
+    private static final String JSON_STRING_SOCIAL_SENTENCE_WITHOUT_LIKE_KEY = "social_sentence_without_like";
+    private static final String JSON_BOOL_IS_OBJECT_LIKED_KEY = "is_object_liked";
+    private static final String JSON_STRING_UNLIKE_TOKEN_KEY = "unlike_token";
+    private static final String JSON_STRING_PENDING_CALL_ID_KEY = "pending_call_id";
+    private static final String JSON_BUNDLE_PENDING_CALL_ANALYTICS_BUNDLE = "pending_call_analytics_bundle";
+
+    private static final String LIKE_DIALOG_RESPONSE_OBJECT_IS_LIKED_KEY = "object_is_liked";
+    private static final String LIKE_DIALOG_RESPONSE_LIKE_COUNT_STRING_KEY = "like_count_string";
+    private static final String LIKE_DIALOG_RESPONSE_SOCIAL_SENTENCE_KEY = "social_sentence";
+    private static final String LIKE_DIALOG_RESPONSE_UNLIKE_TOKEN_KEY = "unlike_token";
+
+    private static final int ERROR_CODE_OBJECT_ALREADY_LIKED = 3501;
+
+    private static FileLruCache controllerDiskCache;
+    private static final ConcurrentHashMap<String, LikeActionController> cache =
+            new ConcurrentHashMap<String, LikeActionController>();
+    private static WorkQueue mruCacheWorkQueue = new WorkQueue(1); // This MUST be 1 for proper synchronization
+    private static WorkQueue diskIOWorkQueue = new WorkQueue(1); // This MUST be 1 for proper synchronization
+    private static Handler handler;
+    private static String objectIdForPendingController;
+    private static boolean isPendingBroadcastReset;
+    private static boolean isInitialized;
+    private static volatile int objectSuffix;
+
+    private Session session;
+    private Context context;
+    private String objectId;
+    private boolean isObjectLiked;
+    private String likeCountStringWithLike;
+    private String likeCountStringWithoutLike;
+    private String socialSentenceWithLike;
+    private String socialSentenceWithoutLike;
+    private String unlikeToken;
+
+    private String verifiedObjectId;
+    private boolean objectIsPage;
+    private boolean isObjectLikedOnServer;
+
+    private boolean isPendingLikeOrUnlike;
+
+    private UUID pendingCallId;
+
+    private Bundle pendingCallAnalyticsBundle;
+
+    private AppEventsLogger appEventsLogger;
+
+    /**
+     * Called from UiLifecycleHelper to process any pending likes that had resulted in the Like dialog
+     * being displayed
+     *
+     * @param context Hosting context
+     * @param requestCode From the originating call to onActivityResult
+     * @param resultCode From the originating call to onActivityResult
+     * @param data From the originating call to onActivityResult
+     * @return Indication of whether the Intent was handled
+     */
+    public static boolean handleOnActivityResult(Context context,
+                                                 final int requestCode,
+                                                 final int resultCode,
+                                                 final Intent data) {
+        final UUID callId = NativeProtocol.getCallIdFromIntent(data);
+        if (callId == null) {
+            return false;
+        }
+
+        // See if we were waiting on a Like dialog completion.
+        if (Utility.isNullOrEmpty(objectIdForPendingController)) {
+            SharedPreferences sharedPreferences = context.getSharedPreferences(
+                    LIKE_ACTION_CONTROLLER_STORE,
+                    Context.MODE_PRIVATE);
+
+            objectIdForPendingController = sharedPreferences.getString(
+                    LIKE_ACTION_CONTROLLER_STORE_PENDING_OBJECT_ID_KEY,
+                    null);
+        }
+
+        if (Utility.isNullOrEmpty(objectIdForPendingController)) {
+            // Doesn't look like we were waiting on a Like dialog completion
+            return false;
+        }
+
+        getControllerForObjectId(
+                context,
+                objectIdForPendingController,
+                new CreationCallback() {
+                    @Override
+                    public void onComplete(LikeActionController likeActionController) {
+                        likeActionController.onActivityResult(requestCode, resultCode, data, callId);
+                    }
+                });
+
+        return true;
+    }
+
+    /**
+     * Called by the LikeView when an object-id is set on it.
+     * @param context context
+     * @param objectId Object Id
+     * @return A LikeActionController for the specified object id
+     */
+    public static void getControllerForObjectId(
+            Context context,
+            String objectId,
+            CreationCallback callback) {
+        if (!isInitialized) {
+            performFirstInitialize(context);
+        }
+
+        LikeActionController controllerForObject = getControllerFromInMemoryCache(objectId);
+        if (controllerForObject != null) {
+            // Direct object-cache hit
+            invokeCallbackWithController(callback, controllerForObject);
+        } else {
+            diskIOWorkQueue.addActiveWorkItem(new CreateLikeActionControllerWorkItem(context, objectId, callback));
+        }
+    }
+
+    /**
+     * NOTE: This MUST be called ONLY via the CreateLikeActionControllerWorkItem class to ensure that it happens on the
+     * right thread, at the right time.
+     */
+    private static void createControllerForObjectId(
+            Context context,
+            String objectId,
+            CreationCallback callback) {
+        // Check again to see if the controller was created before attempting to deserialize/create one.
+        // Need to check this in the case where multiple LikeViews are looking for a controller for the same object
+        // and all got queued up to create one. We only want the first one to go through with the creation, and the
+        // rest should get the same instance from the object-cache.
+        LikeActionController controllerForObject = getControllerFromInMemoryCache(objectId);
+        if (controllerForObject != null) {
+            // Direct object-cache hit
+            invokeCallbackWithController(callback, controllerForObject);
+            return;
+        }
+
+        // Try deserialize from disk
+        controllerForObject = deserializeFromDiskSynchronously(context, objectId);
+
+        if (controllerForObject == null) {
+            controllerForObject = new LikeActionController(context, Session.getActiveSession(), objectId);
+            serializeToDiskAsync(controllerForObject);
+        }
+
+        // Update object-cache.
+        putControllerInMemoryCache(objectId, controllerForObject);
+
+        // Refresh the controller on the Main thread.
+        final LikeActionController controllerToRefresh = controllerForObject;
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                controllerToRefresh.refreshStatusAsync();
+            }
+        });
+
+        invokeCallbackWithController(callback, controllerToRefresh);
+    }
+
+    private synchronized static void performFirstInitialize(Context context) {
+        if (isInitialized) {
+            return;
+        }
+
+        handler = new Handler(Looper.getMainLooper());
+
+        SharedPreferences sharedPreferences = context.getSharedPreferences(
+                LIKE_ACTION_CONTROLLER_STORE,
+                Context.MODE_PRIVATE);
+
+        objectSuffix = sharedPreferences.getInt(LIKE_ACTION_CONTROLLER_STORE_OBJECT_SUFFIX_KEY, 1);
+        controllerDiskCache = new FileLruCache(context, TAG, new FileLruCache.Limits());
+
+        registerSessionBroadcastReceivers(context);
+
+        isInitialized = true;
+    }
+
+    private static void invokeCallbackWithController(final CreationCallback callback, final LikeActionController controller) {
+        if (callback == null) {
+            return;
+        }
+
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                callback.onComplete(controller);
+            }
+        });
+    }
+
+    //
+    // In-memory mru-caching code
+    //
+
+    private static void registerSessionBroadcastReceivers(Context context) {
+        LocalBroadcastManager broadcastManager = LocalBroadcastManager.getInstance(context);
+
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Session.ACTION_ACTIVE_SESSION_UNSET);
+        filter.addAction(Session.ACTION_ACTIVE_SESSION_CLOSED);
+        filter.addAction(Session.ACTION_ACTIVE_SESSION_OPENED);
+
+        broadcastManager.registerReceiver(new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context receiverContext, Intent intent) {
+                if (isPendingBroadcastReset) {
+                    return;
+                }
+
+                String action = intent.getAction();
+                final boolean shouldClearDisk =
+                        Utility.areObjectsEqual(Session.ACTION_ACTIVE_SESSION_UNSET, action) ||
+                                Utility.areObjectsEqual(Session.ACTION_ACTIVE_SESSION_CLOSED, action);
+
+
+                isPendingBroadcastReset = true;
+                // Delaying sending the broadcast to reset, because we might get many successive calls from Session
+                // (to UNSET, SET & OPEN) and a delay would prevent excessive chatter.
+                final Context broadcastContext = receiverContext;
+                handler.postDelayed(new Runnable() {
+                    @Override
+                    public void run() {
+                        // Bump up the objectSuffix so that we don't have a filename collision between a cache-clear and
+                        // and a cache-read/write.
+                        //
+                        // NOTE: We know that onReceive() was called on the main thread. This means that even this code
+                        // is running on the main thread, and therefore, there aren't synchronization issues with
+                        // incrementing the objectSuffix and clearing the caches here.
+                        if (shouldClearDisk) {
+                            objectSuffix = (objectSuffix + 1) % MAX_OBJECT_SUFFIX;
+                            broadcastContext.getSharedPreferences(LIKE_ACTION_CONTROLLER_STORE, Context.MODE_PRIVATE)
+                                    .edit()
+                                    .putInt(LIKE_ACTION_CONTROLLER_STORE_OBJECT_SUFFIX_KEY, objectSuffix)
+                                    .apply();
+
+                            // Only clearing the actual caches. The MRU index will self-clean with usage.
+                            // Clearing the caches is necessary to prevent leaking like-state across sessions.
+                            cache.clear();
+                            controllerDiskCache.clearCache();
+                        }
+
+                        broadcastAction(broadcastContext, null, ACTION_LIKE_ACTION_CONTROLLER_DID_RESET);
+                        isPendingBroadcastReset = false;
+                    }
+                }, 100);
+            }
+        }, filter);
+    }
+
+    private static void putControllerInMemoryCache(String objectId, LikeActionController controllerForObject) {
+        String cacheKey = getCacheKeyForObjectId(objectId);
+        // Move this object to the front. Also trim cache if necessary
+        mruCacheWorkQueue.addActiveWorkItem(new MRUCacheWorkItem(cacheKey, true));
+
+        cache.put(cacheKey, controllerForObject);
+    }
+
+    private static LikeActionController getControllerFromInMemoryCache(String objectId) {
+        String cacheKey = getCacheKeyForObjectId(objectId);
+
+        LikeActionController controller = cache.get(cacheKey);
+        if (controller != null) {
+            // Move this object to the front
+            mruCacheWorkQueue.addActiveWorkItem(new MRUCacheWorkItem(cacheKey, false));
+        }
+
+        return controller;
+    }
+
+    //
+    // Disk caching code
+    //
+
+    private static void serializeToDiskAsync(LikeActionController controller) {
+        String controllerJson = serializeToJson(controller);
+        String cacheKey = getCacheKeyForObjectId(controller.objectId);
+
+        if (!Utility.isNullOrEmpty(controllerJson) && !Utility.isNullOrEmpty(cacheKey)) {
+            diskIOWorkQueue.addActiveWorkItem(new SerializeToDiskWorkItem(cacheKey, controllerJson));
+        }
+    }
+
+    /**
+     * NOTE: This MUST be called ONLY via the SerializeToDiskWorkItem class to ensure that it happens on the
+     * right thread, at the right time.
+     */
+    private static void serializeToDiskSynchronously(String cacheKey, String controllerJson) {
+        OutputStream outputStream = null;
+        try {
+            outputStream = controllerDiskCache.openPutStream(cacheKey);
+            outputStream.write(controllerJson.getBytes());
+        } catch (IOException e) {
+            Log.e(TAG, "Unable to serialize controller to disk", e);
+        } finally {
+            if (outputStream != null) {
+                Utility.closeQuietly(outputStream);
+            }
+        }
+    }
+
+    /**
+     * NOTE: This MUST be called ONLY via the CreateLikeActionControllerWorkItem class to ensure that it happens on the
+     * right thread, at the right time.
+     */
+    private static LikeActionController deserializeFromDiskSynchronously(
+            Context context,
+            String objectId) {
+        LikeActionController controller = null;
+
+        InputStream inputStream = null;
+        try {
+            String cacheKey = getCacheKeyForObjectId(objectId);
+            inputStream = controllerDiskCache.get(cacheKey);
+            if (inputStream != null) {
+                String controllerJsonString = Utility.readStreamToString(inputStream);
+                if (!Utility.isNullOrEmpty(controllerJsonString)) {
+                    controller = deserializeFromJson(context, controllerJsonString);
+                }
+            }
+        } catch (IOException e) {
+            Log.e(TAG, "Unable to deserialize controller from disk", e);
+            controller = null;
+        } finally {
+            if (inputStream != null) {
+                Utility.closeQuietly(inputStream);
+            }
+        }
+
+        return controller;
+    }
+
+    private static LikeActionController deserializeFromJson(Context context, String controllerJsonString) {
+        LikeActionController controller;
+
+        try {
+            JSONObject controllerJson = new JSONObject(controllerJsonString);
+            int version = controllerJson.optInt(JSON_INT_VERSION_KEY, -1);
+            if (version != LIKE_ACTION_CONTROLLER_VERSION) {
+                // Don't attempt to deserialize a controller that might be serialized differently than expected.
+                return null;
+            }
+
+            controller = new LikeActionController(
+                    context,
+                    Session.getActiveSession(),
+                    controllerJson.getString(JSON_STRING_OBJECT_ID_KEY));
+
+            // Make sure to default to null and not empty string, to keep the logic elsewhere functioning properly.
+            controller.likeCountStringWithLike = controllerJson.optString(JSON_STRING_LIKE_COUNT_WITH_LIKE_KEY, null) ;
+            controller.likeCountStringWithoutLike = controllerJson.optString(JSON_STRING_LIKE_COUNT_WITHOUT_LIKE_KEY, null) ;
+            controller.socialSentenceWithLike = controllerJson.optString(JSON_STRING_SOCIAL_SENTENCE_WITH_LIKE_KEY, null);
+            controller.socialSentenceWithoutLike = controllerJson.optString(JSON_STRING_SOCIAL_SENTENCE_WITHOUT_LIKE_KEY, null);
+            controller.isObjectLiked = controllerJson.optBoolean(JSON_BOOL_IS_OBJECT_LIKED_KEY);
+            controller.unlikeToken = controllerJson.optString(JSON_STRING_UNLIKE_TOKEN_KEY, null);
+            String pendingCallIdString = controllerJson.optString(JSON_STRING_PENDING_CALL_ID_KEY, null);
+            if (!Utility.isNullOrEmpty(pendingCallIdString)) {
+                controller.pendingCallId = UUID.fromString(pendingCallIdString);
+            }
+
+            JSONObject analyticsJSON = controllerJson.optJSONObject(JSON_BUNDLE_PENDING_CALL_ANALYTICS_BUNDLE);
+            if (analyticsJSON != null) {
+                controller.pendingCallAnalyticsBundle = BundleJSONConverter.convertToBundle(analyticsJSON);
+            }
+        } catch (JSONException e) {
+            Log.e(TAG, "Unable to deserialize controller from JSON", e);
+            controller = null;
+        }
+
+        return controller;
+    }
+
+    private static String serializeToJson(LikeActionController controller) {
+        JSONObject controllerJson = new JSONObject();
+        try {
+            controllerJson.put(JSON_INT_VERSION_KEY, LIKE_ACTION_CONTROLLER_VERSION);
+            controllerJson.put(JSON_STRING_OBJECT_ID_KEY, controller.objectId);
+            controllerJson.put(JSON_STRING_LIKE_COUNT_WITH_LIKE_KEY, controller.likeCountStringWithLike);
+            controllerJson.put(JSON_STRING_LIKE_COUNT_WITHOUT_LIKE_KEY, controller.likeCountStringWithoutLike);
+            controllerJson.put(JSON_STRING_SOCIAL_SENTENCE_WITH_LIKE_KEY, controller.socialSentenceWithLike);
+            controllerJson.put(JSON_STRING_SOCIAL_SENTENCE_WITHOUT_LIKE_KEY, controller.socialSentenceWithoutLike);
+            controllerJson.put(JSON_BOOL_IS_OBJECT_LIKED_KEY, controller.isObjectLiked);
+            controllerJson.put(JSON_STRING_UNLIKE_TOKEN_KEY, controller.unlikeToken);
+            if (controller.pendingCallId != null) {
+                controllerJson.put(JSON_STRING_PENDING_CALL_ID_KEY, controller.pendingCallId.toString());
+            }
+            if (controller.pendingCallAnalyticsBundle != null) {
+                JSONObject analyticsJSON = BundleJSONConverter.convertToJSON(controller.pendingCallAnalyticsBundle);
+                if (analyticsJSON != null) {
+                    controllerJson.put(JSON_BUNDLE_PENDING_CALL_ANALYTICS_BUNDLE, analyticsJSON);
+                }
+            }
+        } catch (JSONException e) {
+            Log.e(TAG, "Unable to serialize controller to JSON", e);
+            return null;
+        }
+
+        return controllerJson.toString();
+    }
+
+    private static String getCacheKeyForObjectId(String objectId) {
+        String accessTokenPortion = null;
+        Session activeSession = Session.getActiveSession();
+        if (activeSession != null && activeSession.isOpened()) {
+            accessTokenPortion = activeSession.getAccessToken();
+        }
+        if (accessTokenPortion != null) {
+            // Cache-key collisions are not something to worry about here, since we only store state for
+            // one session. Even in the case where the previous session's serialized files have not been deleted yet,
+            // the objectSuffix will be different due to the session-change, thus making the key different.
+            accessTokenPortion = Utility.md5hash(accessTokenPortion);
+        }
+        return String.format(
+                "%s|%s|com.fb.sdk.like|%d",
+                objectId,
+                Utility.coerceValueIfNullOrEmpty(accessTokenPortion, ""),
+                objectSuffix);
+    }
+
+    //
+    // Broadcast handling code
+    //
+
+    private static void broadcastAction(Context context, LikeActionController controller, String action) {
+        broadcastAction(context, controller, action, null);
+    }
+
+    private static void broadcastAction(Context context, LikeActionController controller, String action, Bundle data) {
+        Intent broadcastIntent = new Intent(action);
+        if (controller != null) {
+            if (data == null) {
+                data = new Bundle();
+            }
+
+            data.putString(ACTION_OBJECT_ID_KEY, controller.getObjectId());
+        }
+
+        if (data != null) {
+            broadcastIntent.putExtras(data);
+        }
+        LocalBroadcastManager.getInstance(context.getApplicationContext()).sendBroadcast(broadcastIntent);
+    }
+
+    /**
+     * Constructor
+     */
+    private LikeActionController(Context context, Session session, String objectId) {
+        this.context = context;
+        this.session = session;
+        this.objectId = objectId;
+
+        appEventsLogger = AppEventsLogger.newLogger(context, session);
+    }
+
+    /**
+     * Gets the the associated object id
+     * @return object id
+     */
+    public String getObjectId() {
+        return objectId;
+    }
+
+    /**
+     * Gets the String representation of the like-count for the associated object
+     * @return String representation of the like-count for the associated object
+     */
+    public String getLikeCountString() {
+        return isObjectLiked ? likeCountStringWithLike : likeCountStringWithoutLike;
+    }
+
+    /**
+     * Gets the String representation of the like-count for the associated object
+     * @return String representation of the like-count for the associated object
+     */
+    public String getSocialSentence() {
+        return isObjectLiked ? socialSentenceWithLike : socialSentenceWithoutLike;
+    }
+
+    /**
+     * Indicates whether the associated object is liked
+     * @return Indication of whether the associated object is liked
+     */
+    public boolean isObjectLiked() {
+        return isObjectLiked;
+    }
+
+    /**
+     * Entry-point to the code that performs the like/unlike action.
+     */
+    public void toggleLike(Activity activity, Bundle analyticsParameters) {
+        appEventsLogger.logSdkEvent(AnalyticsEvents.EVENT_LIKE_VIEW_DID_TAP, null, analyticsParameters);
+
+        boolean shouldLikeObject = !this.isObjectLiked;
+        if (canUseOGPublish(shouldLikeObject)) {
+            // Update UI state optimistically
+            updateState(shouldLikeObject,
+                    this.likeCountStringWithLike,
+                    this.likeCountStringWithoutLike,
+                    this.socialSentenceWithLike,
+                    this.socialSentenceWithoutLike,
+                    this.unlikeToken);
+            if (isPendingLikeOrUnlike) {
+                // If the user toggled the button quickly, and there is still a publish underway, don't fire off
+                // another request. Also log this behavior.
+
+                appEventsLogger.logSdkEvent(AnalyticsEvents.EVENT_LIKE_VIEW_DID_UNDO_QUICKLY, null, analyticsParameters);
+                return;
+            }
+        }
+
+        performLikeOrUnlike(activity, shouldLikeObject, analyticsParameters);
+    }
+
+    private void performLikeOrUnlike(Activity activity, boolean shouldLikeObject, Bundle analyticsParameters) {
+        if (canUseOGPublish(shouldLikeObject)) {
+            if (shouldLikeObject) {
+                publishLikeAsync(activity, analyticsParameters);
+            } else {
+                publishUnlikeAsync(activity, analyticsParameters);
+            }
+        } else {
+            presentLikeDialog(activity, analyticsParameters);
+        }
+    }
+
+    private void updateState(boolean isObjectLiked,
+                             String likeCountStringWithLike,
+                             String likeCountStringWithoutLike,
+                             String socialSentenceWithLike,
+                             String socialSentenceWithoutLike,
+                             String unlikeToken) {
+        // Normalize all empty strings to null, so that we don't have any problems with comparison.
+        likeCountStringWithLike = Utility.coerceValueIfNullOrEmpty(likeCountStringWithLike, null);
+        likeCountStringWithoutLike = Utility.coerceValueIfNullOrEmpty(likeCountStringWithoutLike, null);
+        socialSentenceWithLike = Utility.coerceValueIfNullOrEmpty(socialSentenceWithLike, null);
+        socialSentenceWithoutLike = Utility.coerceValueIfNullOrEmpty(socialSentenceWithoutLike, null);
+        unlikeToken = Utility.coerceValueIfNullOrEmpty(unlikeToken, null);
+
+        boolean stateChanged = isObjectLiked != this.isObjectLiked ||
+                !Utility.areObjectsEqual(likeCountStringWithLike, this.likeCountStringWithLike) ||
+                !Utility.areObjectsEqual(likeCountStringWithoutLike, this.likeCountStringWithoutLike) ||
+                !Utility.areObjectsEqual(socialSentenceWithLike, this.socialSentenceWithLike) ||
+                !Utility.areObjectsEqual(socialSentenceWithoutLike, this.socialSentenceWithoutLike) ||
+                !Utility.areObjectsEqual(unlikeToken, this.unlikeToken);
+
+        if (!stateChanged) {
+            return;
+        }
+
+        this.isObjectLiked = isObjectLiked;
+        this.likeCountStringWithLike = likeCountStringWithLike;
+        this.likeCountStringWithoutLike = likeCountStringWithoutLike;
+        this.socialSentenceWithLike = socialSentenceWithLike;
+        this.socialSentenceWithoutLike = socialSentenceWithoutLike;
+        this.unlikeToken = unlikeToken;
+
+        serializeToDiskAsync(this);
+
+        broadcastAction(context, this, ACTION_LIKE_ACTION_CONTROLLER_UPDATED);
+    }
+
+    private void presentLikeDialog(Activity activity, Bundle analyticsParameters) {
+        LikeDialogBuilder likeDialogBuilder = new LikeDialogBuilder(activity, objectId);
+
+        if (likeDialogBuilder.canPresent()) {
+            trackPendingCall(likeDialogBuilder.build().present(), analyticsParameters);
+            appEventsLogger.logSdkEvent(AnalyticsEvents.EVENT_LIKE_VIEW_DID_PRESENT_DIALOG, null, analyticsParameters);
+        } else {
+            String webFallbackUrl = likeDialogBuilder.getWebFallbackUrl();
+            if (!Utility.isNullOrEmpty(webFallbackUrl)) {
+                boolean webFallbackShown = FacebookWebFallbackDialog.presentWebFallback(
+                        activity,
+                        webFallbackUrl,
+                        likeDialogBuilder.getApplicationId(),
+                        likeDialogBuilder.getAppCall(),
+                        getFacebookDialogCallback(analyticsParameters));
+                if (webFallbackShown) {
+                    appEventsLogger.logSdkEvent(
+                            AnalyticsEvents.EVENT_LIKE_VIEW_DID_PRESENT_FALLBACK, null, analyticsParameters);
+                }
+            }
+        }
+    }
+
+    private boolean onActivityResult(int requestCode, int resultCode, Intent data, UUID callId) {
+        if (pendingCallId == null || !pendingCallId.equals(callId)) {
+            return false;
+        }
+
+        // See if we were waiting for a dialog completion
+        FacebookDialog.PendingCall pendingCall = PendingCallStore.getInstance().getPendingCallById(pendingCallId);
+        if (pendingCall == null) {
+            return false;
+        }
+
+        // Look for results
+        FacebookDialog.handleActivityResult(
+                context,
+                pendingCall,
+                requestCode,
+                data,
+                getFacebookDialogCallback(pendingCallAnalyticsBundle));
+
+        // The handlers from above will run synchronously. So by the time we get here, it should be safe to
+        // stop tracking this call and also serialize the controller to disk
+        stopTrackingPendingCall();
+
+        return true;
+    }
+
+    private FacebookDialog.Callback getFacebookDialogCallback(final Bundle analyticsParameters) {
+        return new FacebookDialog.Callback() {
+            @Override
+            public void onComplete(FacebookDialog.PendingCall pendingCall, Bundle data) {
+                if (!data.containsKey(LIKE_DIALOG_RESPONSE_OBJECT_IS_LIKED_KEY)) {
+                    // This is an empty result that we can't handle. Don't lose like state.
+                    return;
+                }
+
+                boolean isObjectLiked = data.getBoolean(LIKE_DIALOG_RESPONSE_OBJECT_IS_LIKED_KEY);
+                String likeCountString = data.getString(LIKE_DIALOG_RESPONSE_LIKE_COUNT_STRING_KEY);
+                String socialSentence = data.getString(LIKE_DIALOG_RESPONSE_SOCIAL_SENTENCE_KEY);
+                String unlikeToken = data.getString(LIKE_DIALOG_RESPONSE_UNLIKE_TOKEN_KEY);
+
+                Bundle logParams = (analyticsParameters == null) ? new Bundle() : analyticsParameters;
+                logParams.putString(AnalyticsEvents.PARAMETER_CALL_ID, pendingCall.getCallId().toString());
+                appEventsLogger.logSdkEvent(AnalyticsEvents.EVENT_LIKE_VIEW_DIALOG_DID_SUCCEED, null, logParams);
+
+                updateState(
+                        isObjectLiked,
+                        likeCountString,
+                        likeCountString,
+                        socialSentence,
+                        socialSentence,
+                        unlikeToken);
+            }
+
+            @Override
+            public void onError(FacebookDialog.PendingCall pendingCall, Exception error, Bundle data) {
+                Logger.log(LoggingBehavior.REQUESTS, TAG, "Like Dialog failed with error : %s", error);
+
+                Bundle logParams = analyticsParameters == null ? new Bundle() : analyticsParameters;
+                logParams.putString(AnalyticsEvents.PARAMETER_CALL_ID, pendingCall.getCallId().toString());
+
+                // Log the error and AppEvent
+                logAppEventForError("present_dialog", logParams);
+
+                broadcastAction(context, LikeActionController.this, ACTION_LIKE_ACTION_CONTROLLER_DID_ERROR, data);
+            }
+        };
+    }
+
+    private void trackPendingCall(FacebookDialog.PendingCall pendingCall, Bundle analyticsParameters) {
+        PendingCallStore.getInstance().trackPendingCall(pendingCall);
+
+        // Save off the call id for processing the response
+        pendingCallId = pendingCall.getCallId();
+        storeObjectIdForPendingController(objectId);
+
+        // Store off the analytics parameters as well, for completion-logging
+        pendingCallAnalyticsBundle = analyticsParameters;
+
+        // Serialize to disk, in case we get terminated while waiting for the dialog to complete
+        serializeToDiskAsync(this);
+    }
+
+    private void stopTrackingPendingCall() {
+        PendingCallStore.getInstance().stopTrackingPendingCall(pendingCallId);
+
+        pendingCallId = null;
+        pendingCallAnalyticsBundle = null;
+
+        storeObjectIdForPendingController(null);
+    }
+
+    private void storeObjectIdForPendingController(String objectId) {
+        objectIdForPendingController = objectId;
+        context.getSharedPreferences(LIKE_ACTION_CONTROLLER_STORE, Context.MODE_PRIVATE)
+                .edit()
+                .putString(LIKE_ACTION_CONTROLLER_STORE_PENDING_OBJECT_ID_KEY, objectIdForPendingController)
+                .apply();
+    }
+
+    private boolean canUseOGPublish(boolean willPerformLike) {
+        // Verify that the object isn't a Page, that we have permissions and that, if we're unliking, then
+        // we have an unlike token.
+        return !objectIsPage &&
+                verifiedObjectId != null &&
+                session != null &&
+                session.getPermissions() != null &&
+                session.getPermissions().contains("publish_actions") &&
+                (willPerformLike || !Utility.isNullOrEmpty(unlikeToken));
+    }
+
+    private void publishLikeAsync(final Activity activity, final Bundle analyticsParameters) {
+        isPendingLikeOrUnlike = true;
+
+        fetchVerifiedObjectId(new RequestCompletionCallback() {
+            @Override
+            public void onComplete() {
+                if (Utility.isNullOrEmpty(verifiedObjectId)) {
+                    // Could not get a verified id
+                    Bundle errorBundle = new Bundle();
+                    errorBundle.putString(NativeProtocol.STATUS_ERROR_DESCRIPTION, ERROR_INVALID_OBJECT_ID);
+
+                    broadcastAction(context, LikeActionController.this, ACTION_LIKE_ACTION_CONTROLLER_DID_ERROR, errorBundle);
+                    return;
+                }
+
+                // Perform the Like.
+                RequestBatch requestBatch = new RequestBatch();
+                final PublishLikeRequestWrapper likeRequest = new PublishLikeRequestWrapper(verifiedObjectId);
+                likeRequest.addToBatch(requestBatch);
+                requestBatch.addCallback(new RequestBatch.Callback() {
+                    @Override
+                    public void onBatchCompleted(RequestBatch batch) {
+                        isPendingLikeOrUnlike = false;
+
+                        if (likeRequest.error != null) {
+                            // We already updated the UI to show button in the Liked state. Since this failed, let's
+                            // revert back to the Unliked state and show the dialog. We need to do this because the
+                            // dialog-flow expects the button to only be updated once the dialog returns
+
+                            updateState(
+                                    false,
+                                    likeCountStringWithLike,
+                                    likeCountStringWithoutLike,
+                                    socialSentenceWithLike,
+                                    socialSentenceWithoutLike,
+                                    unlikeToken);
+
+                            presentLikeDialog(activity, analyticsParameters);
+                        } else {
+                            unlikeToken = Utility.coerceValueIfNullOrEmpty(likeRequest.unlikeToken, null);
+                            isObjectLikedOnServer = true;
+
+                            appEventsLogger.logSdkEvent(AnalyticsEvents.EVENT_LIKE_VIEW_DID_LIKE, null, analyticsParameters);
+
+                            toggleAgainIfNeeded(activity, analyticsParameters);
+                        }
+                    }
+                });
+
+                requestBatch.executeAsync();
+            }
+        });
+    }
+
+    private void publishUnlikeAsync(final Activity activity, final Bundle analyticsParameters) {
+        isPendingLikeOrUnlike = true;
+
+        // Perform the Unlike.
+        RequestBatch requestBatch = new RequestBatch();
+        final PublishUnlikeRequestWrapper unlikeRequest = new PublishUnlikeRequestWrapper(unlikeToken);
+        unlikeRequest.addToBatch(requestBatch);
+        requestBatch.addCallback(new RequestBatch.Callback() {
+            @Override
+            public void onBatchCompleted(RequestBatch batch) {
+                isPendingLikeOrUnlike = false;
+
+                if (unlikeRequest.error != null) {
+                    // We already updated the UI to show button in the Unliked state. Since this failed, let's
+                    // revert back to the Liked state and show the dialog. We need to do this because the
+                    // dialog-flow expects the button to only be updated once the dialog returns
+
+                    updateState(
+                            true,
+                            likeCountStringWithLike,
+                            likeCountStringWithoutLike,
+                            socialSentenceWithLike,
+                            socialSentenceWithoutLike,
+                            unlikeToken);
+
+                    presentLikeDialog(activity, analyticsParameters);
+                } else {
+                    unlikeToken = null;
+                    isObjectLikedOnServer = false;
+
+                    appEventsLogger.logSdkEvent(AnalyticsEvents.EVENT_LIKE_VIEW_DID_UNLIKE, null, analyticsParameters);
+
+                    toggleAgainIfNeeded(activity, analyticsParameters);
+                }
+            }
+        });
+
+        requestBatch.executeAsync();
+    }
+
+    private void refreshStatusAsync() {
+        if (session == null || session.isClosed() || SessionState.CREATED.equals(session.getState())) {
+            // Only when we know that there is no active session, or if there is, it is not open OR being opened,
+            // should we attempt getting like state from the service. Otherwise, use the access token of the session
+            // to make sure we get the correct like state.
+            refreshStatusViaService();
+            return;
+        }
+
+        fetchVerifiedObjectId(new RequestCompletionCallback() {
+            @Override
+            public void onComplete() {
+                final GetOGObjectLikesRequestWrapper objectLikesRequest =
+                        new GetOGObjectLikesRequestWrapper(verifiedObjectId);
+                final GetEngagementRequestWrapper engagementRequest =
+                        new GetEngagementRequestWrapper(verifiedObjectId);
+
+                RequestBatch requestBatch = new RequestBatch();
+                objectLikesRequest.addToBatch(requestBatch);
+                engagementRequest.addToBatch(requestBatch);
+
+                requestBatch.addCallback(new RequestBatch.Callback() {
+                    @Override
+                    public void onBatchCompleted(RequestBatch batch) {
+                        if (objectLikesRequest.error != null ||
+                                engagementRequest.error != null) {
+                            // Refreshing is best-effort. If the refresh fails, don't lose old state.
+                            Logger.log(
+                                    LoggingBehavior.REQUESTS,
+                                    TAG,
+                                    "Unable to refresh like state for id: '%s'", objectId);
+                            return;
+                        }
+
+                        updateState(
+                                objectLikesRequest.objectIsLiked,
+                                engagementRequest.likeCountStringWithLike,
+                                engagementRequest.likeCountStringWithoutLike,
+                                engagementRequest.socialSentenceStringWithLike,
+                                engagementRequest.socialSentenceStringWithoutLike,
+                                objectLikesRequest.unlikeToken);
+                    }
+                });
+
+                requestBatch.executeAsync();
+            }
+        });
+    }
+
+    private void refreshStatusViaService() {
+        LikeStatusClient likeStatusClient = new LikeStatusClient(
+                context,
+                Settings.getApplicationId(),
+                objectId);
+        if (!likeStatusClient.start()) {
+            return;
+        }
+
+        LikeStatusClient.CompletedListener callback = new LikeStatusClient.CompletedListener() {
+            @Override
+            public void completed(Bundle result) {
+                if (result == null || !result.containsKey(NativeProtocol.EXTRA_OBJECT_IS_LIKED)) {
+                    // Don't lose old state if the service response is incomplete.
+                    return;
+                }
+
+                boolean objectIsLiked = result.getBoolean(NativeProtocol.EXTRA_OBJECT_IS_LIKED);
+                String likeCountWithLike = result.getString(NativeProtocol.EXTRA_LIKE_COUNT_STRING_WITH_LIKE);
+                String likeCountWithoutLike = result.getString(NativeProtocol.EXTRA_LIKE_COUNT_STRING_WITHOUT_LIKE);
+                String socialSentenceWithLike = result.getString(NativeProtocol.EXTRA_SOCIAL_SENTENCE_WITH_LIKE);
+                String socialSentenceWithoutLike = result.getString(NativeProtocol.EXTRA_SOCIAL_SENTENCE_WITHOUT_LIKE);
+                String unlikeToken = result.getString(NativeProtocol.EXTRA_UNLIKE_TOKEN);
+
+                updateState(
+                        objectIsLiked,
+                        likeCountWithLike,
+                        likeCountWithoutLike,
+                        socialSentenceWithLike,
+                        socialSentenceWithoutLike,
+                        unlikeToken);
+            }
+        };
+
+        likeStatusClient.setCompletedListener(callback);
+    }
+
+    private void toggleAgainIfNeeded(Activity activity, Bundle analyticsParameters) {
+        if (isObjectLiked != isObjectLikedOnServer) {
+            performLikeOrUnlike(activity, isObjectLiked, analyticsParameters);
+        }
+    }
+
+    private void fetchVerifiedObjectId(final RequestCompletionCallback completionHandler) {
+        if (!Utility.isNullOrEmpty(verifiedObjectId)) {
+            if (completionHandler != null) {
+                completionHandler.onComplete();
+            }
+
+            return;
+        }
+
+        final GetOGObjectIdRequestWrapper objectIdRequest = new GetOGObjectIdRequestWrapper(objectId);
+        final GetPageIdRequestWrapper pageIdRequest = new GetPageIdRequestWrapper(objectId);
+
+        RequestBatch requestBatch = new RequestBatch();
+        objectIdRequest.addToBatch(requestBatch);
+        pageIdRequest.addToBatch(requestBatch);
+
+        requestBatch.addCallback(new RequestBatch.Callback() {
+            @Override
+            public void onBatchCompleted(RequestBatch batch) {
+                verifiedObjectId = objectIdRequest.verifiedObjectId;
+                if (Utility.isNullOrEmpty(verifiedObjectId)) {
+                    verifiedObjectId = pageIdRequest.verifiedObjectId;
+                    objectIsPage = pageIdRequest.objectIsPage;
+                }
+
+                if (Utility.isNullOrEmpty(verifiedObjectId)) {
+                    Logger.log(LoggingBehavior.DEVELOPER_ERRORS,
+                            TAG,
+                            "Unable to verify the FB id for '%s'. Verify that it is a valid FB object or page", objectId);
+                    logAppEventForError("get_verified_id",
+                            pageIdRequest.error != null ? pageIdRequest.error : objectIdRequest.error);
+                }
+
+                if (completionHandler != null) {
+                    completionHandler.onComplete();
+                }
+            }
+        });
+
+        requestBatch.executeAsync();
+    }
+
+    private void logAppEventForError(String action, Bundle parameters) {
+        Bundle logParams = new Bundle(parameters);
+        logParams.putString(AnalyticsEvents.PARAMETER_LIKE_VIEW_OBJECT_ID, objectId);
+        logParams.putString(AnalyticsEvents.PARAMETER_LIKE_VIEW_CURRENT_ACTION, action);
+
+        appEventsLogger.logSdkEvent(AnalyticsEvents.EVENT_LIKE_VIEW_ERROR, null, logParams);
+    }
+
+    private void logAppEventForError(String action, FacebookRequestError error) {
+        Bundle logParams = new Bundle();
+        if (error != null) {
+            JSONObject requestResult = error.getRequestResult();
+            if (requestResult != null) {
+                logParams.putString(AnalyticsEvents.PARAMETER_LIKE_VIEW_ERROR_JSON, requestResult.toString());
+            }
+        }
+        logAppEventForError(action, logParams);
+    }
+
+    //
+    // Interfaces
+    //
+
+    /**
+     * Used by the call to getControllerForObjectId()
+     */
+    public interface CreationCallback {
+        public void onComplete(LikeActionController likeActionController);
+    }
+
+    /**
+     * Used by all the request wrappers
+     */
+    private interface RequestCompletionCallback {
+        void onComplete();
+    }
+
+    //
+    // Inner classes
+    //
+
+    private class GetOGObjectIdRequestWrapper extends AbstractRequestWrapper {
+        String verifiedObjectId;
+
+        GetOGObjectIdRequestWrapper(String objectId) {
+            super(objectId);
+
+            Bundle objectIdRequestParams = new Bundle();
+            objectIdRequestParams.putString("fields", "og_object.fields(id)");
+            objectIdRequestParams.putString("ids", objectId);
+
+            setRequest(new Request(session, "", objectIdRequestParams, HttpMethod.GET));
+        }
+
+        @Override
+        protected void processError(FacebookRequestError error) {
+            // If this object Id is for a Page, an error will be received for this request
+            // We will then rely on the other request to come through.
+            if (error.getErrorMessage().contains("og_object")) {
+                this.error = null;
+            } else {
+                Logger.log(LoggingBehavior.REQUESTS,
+                        TAG,
+                        "Error getting the FB id for object '%s' : %s", objectId, error);
+            }
+        }
+
+        @Override
+        protected void processSuccess(Response response) {
+            JSONObject results = Utility.tryGetJSONObjectFromResponse(response.getGraphObject(), objectId);
+            if (results != null) {
+                // See if we can get the OG object Id out
+                JSONObject ogObject = results.optJSONObject("og_object");
+                if (ogObject != null) {
+                    verifiedObjectId = ogObject.optString("id");
+                }
+            }
+        }
+    }
+
+    private class GetPageIdRequestWrapper extends AbstractRequestWrapper {
+        String verifiedObjectId;
+        boolean objectIsPage;
+
+        GetPageIdRequestWrapper(String objectId) {
+            super(objectId);
+
+            Bundle pageIdRequestParams = new Bundle();
+            pageIdRequestParams.putString("fields", "id");
+            pageIdRequestParams.putString("ids", objectId);
+
+            setRequest(new Request(session, "", pageIdRequestParams, HttpMethod.GET));
+        }
+
+        @Override
+        protected void processSuccess(Response response) {
+            JSONObject results = Utility.tryGetJSONObjectFromResponse(response.getGraphObject(), objectId);
+            if (results != null) {
+                verifiedObjectId = results.optString("id");
+                objectIsPage = !Utility.isNullOrEmpty(verifiedObjectId);
+            }
+        }
+
+        @Override
+        protected void processError(FacebookRequestError error) {
+            Logger.log(LoggingBehavior.REQUESTS,
+                    TAG,
+                    "Error getting the FB id for object '%s' : %s", objectId, error);
+        }
+    }
+
+    private class PublishLikeRequestWrapper extends AbstractRequestWrapper {
+        String unlikeToken;
+
+        PublishLikeRequestWrapper(String objectId) {
+            super(objectId);
+
+            Bundle likeRequestParams = new Bundle();
+            likeRequestParams.putString("object", objectId);
+
+            setRequest(new Request(session, "me/og.likes", likeRequestParams, HttpMethod.POST));
+        }
+
+        @Override
+        protected void processSuccess(Response response) {
+            unlikeToken = Utility.safeGetStringFromResponse(response.getGraphObject(), "id");
+        }
+
+        @Override
+        protected void processError(FacebookRequestError error) {
+            int errorCode = error.getErrorCode();
+            if (errorCode == ERROR_CODE_OBJECT_ALREADY_LIKED) {
+                // This isn't an error for us. Client was just out of sync with server
+                // This will prevent us from showing the dialog for this.
+
+                // However, there is no unliketoken. So a subsequent unlike WILL show the dialog
+                this.error = null;
+            } else {
+                Logger.log(LoggingBehavior.REQUESTS,
+                        TAG,
+                        "Error liking object '%s' : %s", objectId, error);
+                logAppEventForError("publish_like", error);
+            }
+        }
+    }
+
+    private class PublishUnlikeRequestWrapper extends AbstractRequestWrapper {
+        private String unlikeToken;
+
+        PublishUnlikeRequestWrapper(String unlikeToken) {
+            super(null);
+
+            this.unlikeToken = unlikeToken;
+
+            setRequest(new Request(session, unlikeToken, null, HttpMethod.DELETE));
+        }
+
+        @Override
+        protected void processSuccess(Response response) {
+        }
+
+        @Override
+        protected void processError(FacebookRequestError error) {
+            Logger.log(LoggingBehavior.REQUESTS,
+                    TAG,
+                    "Error unliking object with unlike token '%s' : %s", unlikeToken, error);
+            logAppEventForError("publish_unlike", error);
+        }
+    }
+
+    private class GetOGObjectLikesRequestWrapper extends AbstractRequestWrapper {
+        boolean objectIsLiked;
+        String unlikeToken;
+
+        GetOGObjectLikesRequestWrapper(String objectId) {
+            super(objectId);
+
+            Bundle requestParams = new Bundle();
+            requestParams.putString("fields", "id,application");
+            requestParams.putString("object", objectId);
+
+            setRequest(new Request(session, "me/og.likes", requestParams, HttpMethod.GET));
+        }
+
+        @Override
+        protected void processSuccess(Response response) {
+            JSONArray dataSet = Utility.tryGetJSONArrayFromResponse(response.getGraphObject(), "data");
+            if (dataSet != null) {
+                for (int i = 0; i < dataSet.length(); i++) {
+                    JSONObject data = dataSet.optJSONObject(i);
+                    if (data != null) {
+                        objectIsLiked = true;
+                        JSONObject appData = data.optJSONObject("application");
+                        if (appData != null) {
+                            if (Utility.areObjectsEqual(session.getApplicationId(), appData.optString("id"))) {
+                                unlikeToken = data.optString("id");
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        @Override
+        protected void processError(FacebookRequestError error) {
+            Logger.log(LoggingBehavior.REQUESTS,
+                    TAG,
+                    "Error fetching like status for object '%s' : %s", objectId, error);
+            logAppEventForError("get_og_object_like", error);
+        }
+    }
+
+    private class GetEngagementRequestWrapper extends AbstractRequestWrapper {
+        String likeCountStringWithLike;
+        String likeCountStringWithoutLike;
+        String socialSentenceStringWithLike;
+        String socialSentenceStringWithoutLike;
+
+        GetEngagementRequestWrapper(String objectId) {
+            super(objectId);
+
+            Bundle requestParams = new Bundle();
+            requestParams.putString(
+                    "fields",
+                    "engagement.fields(" +
+                            "count_string_with_like," +
+                            "count_string_without_like," +
+                            "social_sentence_with_like," +
+                            "social_sentence_without_like)");
+
+            setRequest(new Request(session, objectId, requestParams, HttpMethod.GET));
+        }
+
+        @Override
+        protected void processSuccess(Response response) {
+            JSONObject engagementResults = Utility.tryGetJSONObjectFromResponse(response.getGraphObject(), "engagement");
+            if (engagementResults != null) {
+                likeCountStringWithLike = engagementResults.optString("count_string_with_like");
+                likeCountStringWithoutLike = engagementResults.optString("count_string_without_like");
+                socialSentenceStringWithLike = engagementResults.optString("social_sentence_with_like");
+                socialSentenceStringWithoutLike = engagementResults.optString("social_sentence_without_like");
+            }
+        }
+
+        @Override
+        protected void processError(FacebookRequestError error) {
+            Logger.log(LoggingBehavior.REQUESTS,
+                    TAG,
+                    "Error fetching engagement for object '%s' : %s", objectId, error);
+            logAppEventForError("get_engagement", error);
+        }
+    }
+
+    private abstract class AbstractRequestWrapper {
+        private Request request;
+        protected String objectId;
+
+        FacebookRequestError error;
+
+        protected AbstractRequestWrapper(String objectId) {
+            this.objectId = objectId;
+        }
+
+        void addToBatch(RequestBatch batch) {
+            batch.add(request);
+        }
+
+        protected void setRequest(Request request) {
+            this.request = request;
+            // Make sure that our requests are hitting the latest version of the API known to this sdk.
+            request.setVersion(ServerProtocol.GRAPH_API_VERSION);
+            request.setCallback(new Request.Callback() {
+                @Override
+                public void onCompleted(Response response) {
+                    error = response.getError();
+                    if (error != null) {
+                        processError(error);
+                    } else {
+                        processSuccess(response);
+                    }
+                }
+            });
+        }
+
+        protected void processError(FacebookRequestError error) {
+            Logger.log(LoggingBehavior.REQUESTS,
+                    TAG,
+                    "Error running request for object '%s' : %s", objectId, error);
+        }
+
+        protected abstract void processSuccess(Response response);
+    }
+
+    private enum LikeDialogFeature implements FacebookDialog.DialogFeature {
+
+        LIKE_DIALOG(NativeProtocol.PROTOCOL_VERSION_20140701);
+
+        private int minVersion;
+
+        private LikeDialogFeature(int minVersion) {
+            this.minVersion = minVersion;
+        }
+
+        public String getAction() {
+            return NativeProtocol.ACTION_LIKE_DIALOG;
+        }
+
+        public int getMinVersion() {
+            return minVersion;
+        }
+    }
+
+    private static class LikeDialogBuilder extends FacebookDialog.Builder<LikeDialogBuilder> {
+        private String objectId;
+
+        public LikeDialogBuilder(Activity activity, String objectId) {
+            super(activity);
+
+            this.objectId = objectId;
+        }
+
+        @Override
+        protected EnumSet<? extends FacebookDialog.DialogFeature> getDialogFeatures() {
+            return EnumSet.of(LikeDialogFeature.LIKE_DIALOG);
+        }
+
+        @Override
+        protected Bundle getMethodArguments() {
+            Bundle methodArgs = new Bundle();
+
+            methodArgs.putString(NativeProtocol.METHOD_ARGS_OBJECT_ID, objectId);
+
+            return methodArgs;
+        }
+
+        public FacebookDialog.PendingCall getAppCall() {
+            return appCall;
+        }
+
+        public String getApplicationId() {
+            return applicationId;
+        }
+
+        public String getWebFallbackUrl() {
+            return getWebFallbackUrlInternal();
+        }
+    }
+
+    // Performs cache re-ordering/trimming to keep most-recently-used items up front
+    // ** NOTE ** It is expected that only _ONE_ MRUCacheWorkItem is ever running. This is enforced by
+    // setting the concurrency of the WorkQueue to 1. Changing the concurrency will most likely lead to errors.
+    private static class MRUCacheWorkItem implements Runnable {
+        private static ArrayList<String> mruCachedItems = new ArrayList<String>();
+        private String cacheItem;
+        private boolean shouldTrim;
+
+        MRUCacheWorkItem(String cacheItem, boolean shouldTrim) {
+            this.cacheItem = cacheItem;
+            this.shouldTrim = shouldTrim;
+        }
+
+        @Override
+        public void run() {
+            if (cacheItem != null) {
+                mruCachedItems.remove(cacheItem);
+                mruCachedItems.add(0, cacheItem);
+            }
+            if (shouldTrim && mruCachedItems.size() >= MAX_CACHE_SIZE) {
+                int targetSize = MAX_CACHE_SIZE / 2; // Optimize for fewer trim-passes.
+                while (targetSize < mruCachedItems.size()) {
+                    String cacheKey = mruCachedItems.remove(mruCachedItems.size() - 1);
+
+                    // Here is where we actually remove from the cache of LikeActionControllers.
+                    cache.remove(cacheKey);
+                }
+            }
+        }
+    }
+
+    private static class SerializeToDiskWorkItem implements Runnable {
+        private String cacheKey;
+        private String controllerJson;
+
+        SerializeToDiskWorkItem(String cacheKey, String controllerJson) {
+            this.cacheKey = cacheKey;
+            this.controllerJson = controllerJson;
+        }
+
+        @Override
+        public void run() {
+            serializeToDiskSynchronously(cacheKey, controllerJson);
+        }
+    }
+
+    private static class CreateLikeActionControllerWorkItem implements Runnable {
+        private Context context;
+        private String objectId;
+        private CreationCallback callback;
+
+        CreateLikeActionControllerWorkItem(Context context, String objectId, CreationCallback callback) {
+            this.context = context;
+            this.objectId = objectId;
+            this.callback = callback;
+        }
+
+        @Override
+        public void run() {
+            createControllerForObjectId(context, objectId, callback);
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/internal/LikeBoxCountView.java b/facebook/src/com/facebook/internal/LikeBoxCountView.java
new file mode 100644
index 000000000..5d9d001a9
--- /dev/null
+++ b/facebook/src/com/facebook/internal/LikeBoxCountView.java
@@ -0,0 +1,223 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import android.content.Context;
+import android.graphics.*;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+import android.widget.TextView;
+import com.facebook.android.R;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public class LikeBoxCountView extends FrameLayout {
+
+    public enum LikeBoxCountViewCaretPosition {
+        LEFT,
+        TOP,
+        RIGHT,
+        BOTTOM
+    }
+
+    private TextView likeCountLabel;
+    private LikeBoxCountViewCaretPosition caretPosition = LikeBoxCountViewCaretPosition.LEFT;
+
+    private float caretHeight;
+    private float caretWidth;
+    private float borderRadius;
+    private Paint borderPaint;
+    private int textPadding;
+    private int additionalTextPadding;
+
+    /**
+     * Constructor
+     *
+     * @param context Context for this View
+     */
+    public LikeBoxCountView(Context context) {
+        super(context);
+        initialize(context);
+    }
+
+    /**
+     * Sets the text for this view
+     * @param text
+     */
+    public void setText(String text) {
+        likeCountLabel.setText(text);
+    }
+
+    /**
+     * Sets the caret's position. This will trigger a layout of the view.
+     * @param caretPosition
+     */
+    public void setCaretPosition(LikeBoxCountViewCaretPosition caretPosition) {
+        this.caretPosition = caretPosition;
+
+        // Since the presence of a caret will move that edge closer to the text, let's add
+        // some padding (equal to caretHeight) in that same direction
+        switch (caretPosition) {
+            case LEFT:
+                setAdditionalTextPadding(additionalTextPadding, 0, 0, 0);
+                break;
+            case TOP:
+                setAdditionalTextPadding(0, additionalTextPadding, 0, 0);
+                break;
+            case RIGHT:
+                setAdditionalTextPadding(0, 0, additionalTextPadding, 0);
+                break;
+            case BOTTOM:
+                setAdditionalTextPadding(0, 0, 0, additionalTextPadding);
+                break;
+        }
+
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+
+        int top = getPaddingTop(), left = getPaddingLeft();
+        int right = getWidth() - getPaddingRight(), bottom = getHeight() - getPaddingBottom();
+
+        switch (caretPosition) {
+            case BOTTOM:
+                bottom -= caretHeight;
+                break;
+            case LEFT:
+                left += caretHeight;
+                break;
+            case TOP:
+                top += caretHeight;
+                break;
+            case RIGHT:
+                right -= caretHeight;
+                break;
+        }
+
+        drawBorder(canvas, left, top, right, bottom);
+    }
+
+    private void initialize(Context context) {
+        setWillNotDraw(false); // Required for the onDraw() method to be called on a FrameLayout
+        caretHeight = getResources().getDimension(R.dimen.com_facebook_likeboxcountview_caret_height);
+        caretWidth = getResources().getDimension(R.dimen.com_facebook_likeboxcountview_caret_width);
+        borderRadius = getResources().getDimension(R.dimen.com_facebook_likeboxcountview_border_radius);
+
+        borderPaint = new Paint();
+        borderPaint.setColor(getResources().getColor(R.color.com_facebook_likeboxcountview_border_color));
+        borderPaint.setStrokeWidth(getResources().getDimension(R.dimen.com_facebook_likeboxcountview_border_width));
+        borderPaint.setStyle(Paint.Style.STROKE);
+
+        initializeLikeCountLabel(context);
+
+        addView(likeCountLabel);
+
+        setCaretPosition(this.caretPosition);
+    }
+
+    private void initializeLikeCountLabel(Context context) {
+        likeCountLabel = new TextView(context);
+        LayoutParams likeCountLabelLayoutParams = new LayoutParams(
+                ViewGroup.LayoutParams.MATCH_PARENT,
+                ViewGroup.LayoutParams.MATCH_PARENT);
+        likeCountLabel.setLayoutParams(likeCountLabelLayoutParams);
+        likeCountLabel.setGravity(Gravity.CENTER);
+        likeCountLabel.setTextSize(
+                TypedValue.COMPLEX_UNIT_PX,
+                getResources().getDimension(R.dimen.com_facebook_likeboxcountview_text_size));
+        likeCountLabel.setTextColor(getResources().getColor(R.color.com_facebook_likeboxcountview_text_color));
+        textPadding = getResources().getDimensionPixelSize(R.dimen.com_facebook_likeboxcountview_text_padding);
+
+        // Calculate the additional text padding that will be applied in the direction of the caret.
+        additionalTextPadding = getResources().getDimensionPixelSize(R.dimen.com_facebook_likeboxcountview_caret_height);
+    }
+
+    private void setAdditionalTextPadding(int left, int top, int right, int bottom) {
+        likeCountLabel.setPadding(
+                textPadding + left,
+                textPadding + top,
+                textPadding + right,
+                textPadding + bottom);
+    }
+
+    private void drawBorder(Canvas canvas, float left, float top, float right, float bottom) {
+        Path borderPath = new Path();
+
+        float ovalSize = 2.0f * borderRadius;
+
+        // Top left corner
+        borderPath.addArc(new RectF(left, top, left + ovalSize, top + ovalSize), -180, 90);
+
+        // Top caret
+        if (caretPosition == LikeBoxCountViewCaretPosition.TOP) {
+            borderPath.lineTo(left + (right - left - caretWidth) / 2, top);
+            borderPath.lineTo(left + (right - left) / 2, top - caretHeight);
+            borderPath.lineTo(left + (right - left + caretWidth) / 2, top);
+        }
+
+        // Move to top right corner
+        borderPath.lineTo(right - borderRadius, top);
+
+        // Top right corner
+        borderPath.addArc(new RectF(right - ovalSize, top, right, top + ovalSize), -90, 90);
+
+        // Right caret
+        if (caretPosition == LikeBoxCountViewCaretPosition.RIGHT) {
+            borderPath.lineTo(right, top + (bottom - top - caretWidth) / 2);
+            borderPath.lineTo(right + caretHeight, top + (bottom - top) / 2);
+            borderPath.lineTo(right, top + (bottom - top + caretWidth) / 2);
+        }
+
+        // Move to bottom right corner
+        borderPath.lineTo(right, bottom - borderRadius);
+
+        // Bottom right corner
+        borderPath.addArc(new RectF(right - ovalSize, bottom - ovalSize, right, bottom), 0, 90);
+
+        // Bottom caret
+        if (caretPosition == LikeBoxCountViewCaretPosition.BOTTOM) {
+            borderPath.lineTo(left + (right - left + caretWidth) / 2, bottom);
+            borderPath.lineTo(left + (right - left) / 2, bottom + caretHeight);
+            borderPath.lineTo(left + (right - left - caretWidth) / 2, bottom);
+        }
+
+        // Move to bottom left corner
+        borderPath.lineTo(left + borderRadius, bottom);
+
+        // Bottom left corner
+        borderPath.addArc(new RectF(left, bottom - ovalSize, left + ovalSize, bottom), 90, 90);
+
+        // Left caret
+        if (caretPosition == LikeBoxCountViewCaretPosition.LEFT) {
+            borderPath.lineTo(left, top + (bottom - top + caretWidth) / 2);
+            borderPath.lineTo(left - caretHeight, top + (bottom - top) / 2);
+            borderPath.lineTo(left, top + (bottom - top - caretWidth) / 2);
+        }
+
+        // Move back to the beginning
+        borderPath.lineTo(left, top + borderRadius);
+
+        canvas.drawPath(borderPath, borderPaint);
+    }
+}
diff --git a/facebook/src/com/facebook/internal/LikeButton.java b/facebook/src/com/facebook/internal/LikeButton.java
new file mode 100644
index 000000000..99039f708
--- /dev/null
+++ b/facebook/src/com/facebook/internal/LikeButton.java
@@ -0,0 +1,87 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import android.content.Context;
+import android.graphics.Typeface;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.widget.Button;
+import com.facebook.android.R;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public class LikeButton extends Button {
+
+    private boolean isLiked;
+
+    /**
+     * Create the LikeButton .
+     *
+     * @see android.view.View#View(android.content.Context)
+     */
+    public LikeButton(Context context, boolean isLiked) {
+        super(context);
+
+        this.isLiked = isLiked;
+
+        initialize();
+    }
+
+    public void setLikeState(boolean isLiked) {
+        if (isLiked != this.isLiked) {
+            this.isLiked = isLiked;
+            updateForLikeStatus();
+        }
+    }
+
+    private void initialize() {
+        // apparently there's no method of setting a default style in xml,
+        // so in case the users do not explicitly specify a style, we need
+        // to use sensible defaults.
+        this.setGravity(Gravity.CENTER_VERTICAL);
+        this.setTextColor(getResources().getColor(R.color.com_facebook_likebutton_text_color));
+        this.setTextSize(TypedValue.COMPLEX_UNIT_PX,
+                getResources().getDimension(R.dimen.com_facebook_likebutton_text_size));
+        this.setTypeface(Typeface.DEFAULT_BOLD);
+
+        this.setCompoundDrawablePadding(
+                getResources().getDimensionPixelSize(R.dimen.com_facebook_likebutton_compound_drawable_padding));
+        this.setPadding(
+                getResources().getDimensionPixelSize(R.dimen.com_facebook_likebutton_padding_left),
+                getResources().getDimensionPixelSize(R.dimen.com_facebook_likebutton_padding_top),
+                getResources().getDimensionPixelSize(R.dimen.com_facebook_likebutton_padding_right),
+                getResources().getDimensionPixelSize(R.dimen.com_facebook_likebutton_padding_bottom));
+
+        updateForLikeStatus();
+    }
+
+    private void updateForLikeStatus() {
+        if (isLiked) {
+            this.setBackgroundResource(R.drawable.com_facebook_button_like_selected);
+            this.setCompoundDrawablesWithIntrinsicBounds(R.drawable.com_facebook_button_like_icon_selected, 0, 0, 0);
+            this.setText(getResources().getString(R.string.com_facebook_like_button_liked));
+        } else {
+            this.setBackgroundResource(R.drawable.com_facebook_button_like);
+            this.setCompoundDrawablesWithIntrinsicBounds(R.drawable.com_facebook_button_like_icon, 0, 0, 0);
+            this.setText(getResources().getString(R.string.com_facebook_like_button_not_liked));
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/internal/LikeStatusClient.java b/facebook/src/com/facebook/internal/LikeStatusClient.java
new file mode 100644
index 000000000..98a4113e9
--- /dev/null
+++ b/facebook/src/com/facebook/internal/LikeStatusClient.java
@@ -0,0 +1,48 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+
+import android.content.Context;
+import android.os.Bundle;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+
+/**
+ * This class executes service calls to fetch like-state of objects from the Facebook Application, if available.
+ */
+final class LikeStatusClient extends PlatformServiceClient {
+    private String objectId;
+
+    LikeStatusClient(Context context, String applicationId, String objectId) {
+        super(context, NativeProtocol.MESSAGE_GET_LIKE_STATUS_REQUEST, NativeProtocol.MESSAGE_GET_LIKE_STATUS_REPLY,
+                NativeProtocol.PROTOCOL_VERSION_20141001, applicationId);
+
+        this.objectId = objectId;
+    }
+
+    @Override
+    protected void populateRequestBundle(Bundle data) {
+        // Only thing we need to pass in is the object id.
+        data.putString(NativeProtocol.EXTRA_OBJECT_ID, objectId);
+    }
+}
+
diff --git a/facebook/src/com/facebook/internal/NativeProtocol.java b/facebook/src/com/facebook/internal/NativeProtocol.java
index a2cf01912..50ca6f88a 100644
--- a/facebook/src/com/facebook/internal/NativeProtocol.java
+++ b/facebook/src/com/facebook/internal/NativeProtocol.java
@@ -61,6 +61,7 @@
     public static final int PROTOCOL_VERSION_20140204 = 20140204;
     public static final int PROTOCOL_VERSION_20140324 = 20140324;
     public static final int PROTOCOL_VERSION_20140701 = 20140701;
+    public static final int PROTOCOL_VERSION_20141001 = 20141001;
 
     public static final String EXTRA_PROTOCOL_VERSION = "com.facebook.platform.protocol.PROTOCOL_VERSION";
     public static final String EXTRA_PROTOCOL_ACTION = "com.facebook.platform.protocol.PROTOCOL_ACTION";
@@ -81,12 +82,14 @@
     public static final String BRIDGE_ARG_ERROR_BUNDLE = "error";
 
     // Messages supported by PlatformService:
-    public static final int MESSAGE_GET_ACCESS_TOKEN_REQUEST = 0x10000;
-    public static final int MESSAGE_GET_ACCESS_TOKEN_REPLY   = 0x10001;
-    static final int MESSAGE_GET_PROTOCOL_VERSIONS_REQUEST = 0x10002;
-    static final int MESSAGE_GET_PROTOCOL_VERSIONS_REPLY   = 0x10003;
-    public static final int MESSAGE_GET_INSTALL_DATA_REQUEST = 0x10004;
-    public static final int MESSAGE_GET_INSTALL_DATA_REPLY   = 0x10005;
+    public static final int MESSAGE_GET_ACCESS_TOKEN_REQUEST    = 0x10000;
+    public static final int MESSAGE_GET_ACCESS_TOKEN_REPLY      = 0x10001;
+    static final int MESSAGE_GET_PROTOCOL_VERSIONS_REQUEST      = 0x10002;
+    static final int MESSAGE_GET_PROTOCOL_VERSIONS_REPLY        = 0x10003;
+    public static final int MESSAGE_GET_INSTALL_DATA_REQUEST    = 0x10004;
+    public static final int MESSAGE_GET_INSTALL_DATA_REPLY      = 0x10005;
+    public static final int MESSAGE_GET_LIKE_STATUS_REQUEST     = 0x10006;
+    public static final int MESSAGE_GET_LIKE_STATUS_REPLY       = 0x10007;
 
     // MESSAGE_ERROR_REPLY data keys:
     // See STATUS_*
@@ -99,6 +102,18 @@
     // EXTRA_EXPIRES_SECONDS_SINCE_EPOCH
     // EXTRA_PERMISSIONS
 
+    // MESSAGE_GET_LIKE_STATUS_REQUEST data keys:
+    // EXTRA_APPLICATION_ID
+    // EXTRA_OBJECT_ID
+
+    // MESSAGE_GET_LIKE_STATUS_REPLY data keys:
+    // EXTRA_OBJECT_IS_LIKED
+    // EXTRA_LIKE_COUNT_STRING_WITH_LIKE
+    // EXTRA_LIKE_COUNT_STRING_WITHOUT_LIKE
+    // EXTRA_SOCIAL_SENTENCE_WITH_LIKE
+    // EXTRA_SOCIAL_SENTENCE_WITHOUT_LIKE
+    // EXTRA_UNLIKE_TOKEN
+
     // MESSAGE_GET_PROTOCOL_VERSIONS_REPLY data keys:
     static final String EXTRA_PROTOCOL_VERSIONS = "com.facebook.platform.extra.PROTOCOL_VERSIONS";
 
@@ -109,6 +124,8 @@
             "com.facebook.platform.action.request.OGACTIONPUBLISH_DIALOG";
     public static final String ACTION_OGMESSAGEPUBLISH_DIALOG =
             "com.facebook.platform.action.request.OGMESSAGEPUBLISH_DIALOG";
+    public static final String ACTION_LIKE_DIALOG =
+            "com.facebook.platform.action.request.LIKE_DIALOG";
 
     // Values of EXTRA_PROTOCOL_ACTION values returned by PlatformActivity:
     public static final String ACTION_FEED_DIALOG_REPLY =
@@ -119,6 +136,8 @@
             "com.facebook.platform.action.reply.OGACTIONPUBLISH_DIALOG";
     public static final String ACTION_OGMESSAGEPUBLISH_DIALOG_REPLY =
             "com.facebook.platform.action.reply.OGMESSAGEPUBLISH_DIALOG";
+    public static final String ACTION_LIKE_DIALOG_REPLY =
+            "com.facebook.platform.action.reply.LIKE_DIALOG";
 
     // Extras supported for ACTION_LOGIN_DIALOG:
     public static final String EXTRA_PERMISSIONS = "com.facebook.platform.extra.PERMISSIONS";
@@ -164,6 +183,17 @@
     public static final String METHOD_ARGS_ACTION_TYPE = "ACTION_TYPE";
     public static final String METHOD_ARGS_PREVIEW_PROPERTY_NAME = "PREVIEW_PROPERTY_NAME";
 
+    // Extras supported for MESSAGE_GET_LIKE_STATUS_REQUEST:
+    public static final String EXTRA_OBJECT_ID = "com.facebook.platform.extra.OBJECT_ID";
+
+    // Extras supported in MESSAGE_GET_LIKE_STATUS_REPLY:
+    public static final String EXTRA_OBJECT_IS_LIKED = "com.facebook.platform.extra.OBJECT_IS_LIKED";
+    public static final String EXTRA_LIKE_COUNT_STRING_WITH_LIKE = "com.facebook.platform.extra.LIKE_COUNT_STRING_WITH_LIKE";
+    public static final String EXTRA_LIKE_COUNT_STRING_WITHOUT_LIKE = "com.facebook.platform.extra.LIKE_COUNT_STRING_WITHOUT_LIKE";
+    public static final String EXTRA_SOCIAL_SENTENCE_WITH_LIKE = "com.facebook.platform.extra.SOCIAL_SENTENCE_WITH_LIKE";
+    public static final String EXTRA_SOCIAL_SENTENCE_WITHOUT_LIKE = "com.facebook.platform.extra.SOCIAL_SENTENCE_WITHOUT_LIKE";
+    public static final String EXTRA_UNLIKE_TOKEN = "com.facebook.platform.extra.UNLIKE_TOKEN";
+
     // OG objects will have this key to set to true if they should be created as part of OG Action publish
     public static final String OPEN_GRAPH_CREATE_OBJECT_KEY = "fbsdk:create_object";
     // Determines whether an image is user generated
@@ -171,6 +201,9 @@
     // url key for images
     public static final String IMAGE_URL_KEY = "url";
 
+    // Method args supported for ACTION_LIKE_DIALOG
+    public static final String METHOD_ARGS_OBJECT_ID = "object_id";
+
     // Keys for status data in MESSAGE_ERROR_REPLY from PlatformService and for error
     // extras returned by PlatformActivity's setResult() in case of errors:
     public static final String STATUS_ERROR_TYPE = "com.facebook.platform.status.ERROR_TYPE";
@@ -296,6 +329,7 @@ protected String getPackage() {
         // Add individual actions and the list they should try
         map.put(ACTION_OGACTIONPUBLISH_DIALOG, facebookAppInfoList);
         map.put(ACTION_FEED_DIALOG, facebookAppInfoList);
+        map.put(ACTION_LIKE_DIALOG, facebookAppInfoList);
         map.put(ACTION_MESSAGE_DIALOG, messengerAppInfoList);
         map.put(ACTION_OGMESSAGEPUBLISH_DIALOG, messengerAppInfoList);
 
@@ -387,9 +421,14 @@ public static Intent createTokenRefreshIntent(Context context) {
         return null;
     }
 
+    public static final int getLatestKnownVersion() {
+        return KNOWN_PROTOCOL_VERSIONS.get(0);
+    }
+
     // Note: be sure this stays sorted in descending order; add new versions at the beginning
     private static final List<Integer> KNOWN_PROTOCOL_VERSIONS =
             Arrays.asList(
+                    PROTOCOL_VERSION_20141001,
                     PROTOCOL_VERSION_20140701,
                     PROTOCOL_VERSION_20140324,
                     PROTOCOL_VERSION_20140204,
@@ -449,7 +488,7 @@ public static Intent createPlatformActivityIntent(
             bridgeArguments.putString(BRIDGE_ARG_APP_NAME_STRING, applicationName);
             intent.putExtra(EXTRA_PROTOCOL_BRIDGE_ARGS, bridgeArguments);
 
-            Bundle methodArguments = extras == null ? new Bundle() : extras;
+            Bundle methodArguments = (extras == null) ? new Bundle() : extras;
             intent.putExtra(EXTRA_PROTOCOL_METHOD_ARGS, methodArguments);
         } else {
             // This is the older flat intent
@@ -479,6 +518,9 @@ public static int getProtocolVersionFromIntent(Intent intent) {
     }
 
     public static UUID getCallIdFromIntent(Intent intent) {
+        if (intent == null) {
+            return null;
+        }
         int version = getProtocolVersionFromIntent(intent);
         String callIdString = null;
         if (isVersionCompatibleWithBucketedIntent(version)) {
@@ -528,27 +570,30 @@ public static boolean isErrorResult(Intent resultIntent) {
         }
     }
 
-    public static Exception getErrorFromResult(Intent resultIntent) {
+    public static Bundle getErrorDataFromResultIntent(Intent resultIntent) {
         if (!isErrorResult(resultIntent)) {
             return null;
         }
 
         Bundle bridgeArgs = getBridgeArgumentsFromIntent(resultIntent);
         if (bridgeArgs != null) {
-            Bundle errorBundle = bridgeArgs.getBundle(BRIDGE_ARG_ERROR_BUNDLE);
-            if (errorBundle != null) {
-                return getErrorFromResult(errorBundle);
-            }
+            return bridgeArgs.getBundle(BRIDGE_ARG_ERROR_BUNDLE);
+
+
         }
 
-        return getErrorFromResult(resultIntent.getExtras());
+        return resultIntent.getExtras();
     }
 
-    public static Exception getErrorFromResult(Bundle errorBundle) {
+    public static Exception getExceptionFromErrorData(Bundle errorData) {
+        if (errorData == null) {
+            return null;
+        }
+
         // TODO This is not going to work for JS dialogs, where the keys are not STATUS_ERROR_TYPE etc.
         // TODO However, it should keep existing dialogs functional
-        String type = errorBundle.getString(STATUS_ERROR_TYPE);
-        String description = errorBundle.getString(STATUS_ERROR_DESCRIPTION);
+        String type = errorData.getString(STATUS_ERROR_TYPE);
+        String description = errorData.getString(STATUS_ERROR_DESCRIPTION);
 
         if (type != null && type.equalsIgnoreCase(ERROR_USER_CANCELED)) {
             return new FacebookOperationCanceledException(description);
@@ -560,23 +605,23 @@ public static Exception getErrorFromResult(Bundle errorBundle) {
 
     public static int getLatestAvailableProtocolVersionForService(Context context, final int minimumVersion) {
         // Services are currently always against the Facebook App
-        return getLatestAvailableProtocolVersionForAppInfoList(context, facebookAppInfoList, minimumVersion);
+        return getLatestAvailableProtocolVersionForAppInfoList(context, facebookAppInfoList, new int[] {minimumVersion});
     }
 
-    public static int getLatestAvailableProtocolVersionForAction(Context context, String action, final int minimumVersion) {
+    public static int getLatestAvailableProtocolVersionForAction(Context context, String action, int[] versionSpec) {
         List<NativeAppInfo> appInfoList = actionToAppInfoMap.get(action);
-        return getLatestAvailableProtocolVersionForAppInfoList(context, appInfoList, minimumVersion);
+        return getLatestAvailableProtocolVersionForAppInfoList(context, appInfoList, versionSpec);
     }
 
     private static int getLatestAvailableProtocolVersionForAppInfoList(Context context, List<NativeAppInfo> appInfoList,
-            final int minimumVersion) {
+            int[] versionSpec) {
         if (appInfoList == null) {
             return NO_PROTOCOL_AVAILABLE;
         }
 
         // Could potentially cache the NativeAppInfo to latestProtocolVersion
         for (NativeAppInfo appInfo : appInfoList) {
-            int protocolVersion = getLatestAvailableProtocolVersionForAppInfo(context, appInfo, minimumVersion);
+            int protocolVersion = getLatestAvailableProtocolVersionForAppInfo(context, appInfo, versionSpec);
             if (protocolVersion != NO_PROTOCOL_AVAILABLE) {
                 return protocolVersion;
             }
@@ -585,8 +630,10 @@ private static int getLatestAvailableProtocolVersionForAppInfoList(Context conte
         return NO_PROTOCOL_AVAILABLE;
     }
 
-    private static int getLatestAvailableProtocolVersionForAppInfo(Context context, NativeAppInfo appInfo,
-            final int minimumVersion) {
+    private static int getLatestAvailableProtocolVersionForAppInfo(
+            Context context,
+            NativeAppInfo appInfo,
+            int[] versionSpec) {
         ContentResolver contentResolver = context.getContentResolver();
 
         String [] projection = new String[]{ PLATFORM_PROVIDER_VERSION_COLUMN };
@@ -598,19 +645,41 @@ private static int getLatestAvailableProtocolVersionForAppInfo(Context context,
                 return NO_PROTOCOL_AVAILABLE;
             }
 
-            Set<Integer> versions = new HashSet<Integer>();
+            TreeSet<Integer> fbAppVersions = new TreeSet<Integer>();
             while (c.moveToNext()) {
                 int version = c.getInt(c.getColumnIndex(PLATFORM_PROVIDER_VERSION_COLUMN));
-                versions.add(version);
+                fbAppVersions.add(version);
             }
 
-            for (Integer knownVersion : KNOWN_PROTOCOL_VERSIONS) {
-                if (knownVersion < minimumVersion) {
+            // Remember that these ranges are sorted in ascending order and can be unbounded. So we are starting
+            // from the end of the version-spec array and working backwards, to try get the newest possible version
+            int versionSpecIndex = versionSpec.length - 1;
+            Iterator<Integer> fbAppVersionsIterator = fbAppVersions.descendingIterator();
+            int latestAllowedVersion = getLatestKnownVersion();
+            while (fbAppVersionsIterator.hasNext()) {
+                int fbAppVersion = fbAppVersionsIterator.next();
+
+                // If there is a newer version in the versionSpec, throw it away, we don't have it
+                while (versionSpecIndex >= 0 && versionSpec[versionSpecIndex] > fbAppVersion) {
+                    versionSpecIndex--;
+                }
+
+                if (versionSpecIndex < 0) {
+                    // There was no fb app version that fell into any range in the versionSpec - or - the
+                    // versionSpec was empty, which means that this action is not supported.
                     return NO_PROTOCOL_AVAILABLE;
                 }
 
-                if (versions.contains(knownVersion)) {
-                    return knownVersion;
+                // If we are here, we know we are within a range specified in the versionSpec. We should see if it is
+                // a disabled or enabled range.
+
+                if (versionSpec[versionSpecIndex] == fbAppVersion) {
+                    // if the versionSpecIndex is even, it is enabled; if odd, disabled
+                    return (
+                            versionSpecIndex % 2 == 0 ?
+                                    Math.min(fbAppVersion, latestAllowedVersion) :
+                                    NO_PROTOCOL_AVAILABLE
+                    );
                 }
             }
         } finally {
diff --git a/facebook/src/com/facebook/internal/PendingCallStore.java b/facebook/src/com/facebook/internal/PendingCallStore.java
new file mode 100644
index 000000000..dca839a5c
--- /dev/null
+++ b/facebook/src/com/facebook/internal/PendingCallStore.java
@@ -0,0 +1,85 @@
+package com.facebook.internal;
+
+import android.content.Context;
+import android.os.Bundle;
+import com.facebook.widget.FacebookDialog;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public class PendingCallStore {
+    private static final String CALL_ID_ARRAY_KEY = "com.facebook.internal.PendingCallStore.callIdArrayKey";
+    private static final String CALL_KEY_PREFIX = "com.facebook.internal.PendingCallStore.";
+
+    private static PendingCallStore mInstance;
+
+    private Map<String, FacebookDialog.PendingCall> pendingCallMap = new HashMap<String, FacebookDialog.PendingCall>();
+
+    public static PendingCallStore getInstance() {
+        if (mInstance == null) {
+            createInstance();
+        }
+
+        return mInstance;
+    }
+
+    private synchronized static void createInstance() {
+        if (mInstance == null) {
+            mInstance = new PendingCallStore();
+        }
+    }
+
+    public void trackPendingCall(FacebookDialog.PendingCall pendingCall) {
+        if (pendingCall != null) {
+            pendingCallMap.put(pendingCall.getCallId().toString(), pendingCall);
+        }
+    }
+
+    public void stopTrackingPendingCall(UUID callId) {
+        if (callId != null) {
+            pendingCallMap.remove(callId.toString());
+        }
+    }
+
+    public FacebookDialog.PendingCall getPendingCallById(UUID callId) {
+        if (callId == null) {
+            return null;
+        }
+        return pendingCallMap.get(callId.toString());
+    }
+
+    public void saveInstanceState(Bundle outState) {
+        ArrayList<String> callIds = new ArrayList<String>(pendingCallMap.keySet());
+        outState.putStringArrayList(CALL_ID_ARRAY_KEY, callIds);
+
+        for(FacebookDialog.PendingCall pendingCall : pendingCallMap.values()) {
+            String stateKey = getSavedStateKeyForPendingCallId(pendingCall.getCallId().toString());
+            outState.putParcelable(stateKey, pendingCall);
+        }
+    }
+
+    public void restoreFromSavedInstanceState(Bundle savedInstanceState) {
+        ArrayList<String> callIds = savedInstanceState.getStringArrayList(CALL_ID_ARRAY_KEY);
+        if (callIds != null) {
+            for (String callId : callIds) {
+                String stateKey = getSavedStateKeyForPendingCallId(callId);
+                FacebookDialog.PendingCall pendingCall = savedInstanceState.getParcelable(stateKey);
+
+                if (pendingCall != null) {
+                    pendingCallMap.put(pendingCall.getCallId().toString(), pendingCall);
+                }
+            }
+        }
+    }
+
+    private String getSavedStateKeyForPendingCallId(String pendingCallId) {
+        return CALL_KEY_PREFIX + pendingCallId;
+    }
+}
diff --git a/facebook/src/com/facebook/internal/ServerProtocol.java b/facebook/src/com/facebook/internal/ServerProtocol.java
index bc9beecfa..46931353d 100644
--- a/facebook/src/com/facebook/internal/ServerProtocol.java
+++ b/facebook/src/com/facebook/internal/ServerProtocol.java
@@ -16,9 +16,16 @@
 
 package com.facebook.internal;
 
+import android.content.Context;
+import android.os.Bundle;
+import android.util.Log;
+import com.facebook.LoggingBehavior;
 import com.facebook.Settings;
+import org.json.JSONException;
+import org.json.JSONObject;
 
 import java.util.Collection;
+import java.util.EnumSet;
 
 /**
  * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
@@ -26,6 +33,8 @@
  * any time.
  */
 public final class ServerProtocol {
+    private static final String TAG = ServerProtocol.class.getName();
+
     private static final String DIALOG_AUTHORITY_FORMAT = "m.%s";
     public static final String DIALOG_PATH = "dialog/";
     public static final String DIALOG_PARAM_ACCESS_TOKEN = "access_token";
@@ -44,6 +53,14 @@
     public static final String DIALOG_RESPONSE_TYPE_TOKEN = "token";
     public static final String DIALOG_RETURN_SCOPES_TRUE = "true";
 
+    public static final String FALLBACK_DIALOG_PARAM_APP_ID = "app_id";
+    public static final String FALLBACK_DIALOG_PARAM_BRIDGE_ARGS = "bridge_args";
+    public static final String FALLBACK_DIALOG_PARAM_KEY_HASH = "android_key_hash";
+    public static final String FALLBACK_DIALOG_PARAM_METHOD_ARGS = "method_args";
+    public static final String FALLBACK_DIALOG_PARAM_METHOD_RESULTS = "method_results";
+    public static final String FALLBACK_DIALOG_PARAM_VERSION = "version";
+    public static final String FALLBACK_DIALOG_DISPLAY_VALUE_TOUCH = "touch";
+
     // URL components
     private static final String GRAPH_VIDEO_URL_FORMAT = "https://graph-video.%s";
     private static final String GRAPH_URL_FORMAT = "https://graph.%s";
@@ -74,4 +91,48 @@ public static final String getAPIVersion() {
         }
         return GRAPH_API_VERSION;
     }
+
+    public static Bundle getQueryParamsForPlatformActivityIntentWebFallback(
+            Context context,
+            String callId,
+            int version,
+            String applicationName,
+            Bundle methodArgs) {
+
+        String keyHash = Settings.getApplicationSignature(context);
+        if (Utility.isNullOrEmpty(keyHash)) {
+            return null;
+        }
+
+        Bundle webParams = new Bundle();
+
+        webParams.putString(FALLBACK_DIALOG_PARAM_KEY_HASH, keyHash);
+        webParams.putString(FALLBACK_DIALOG_PARAM_APP_ID, Settings.getApplicationId());
+        webParams.putInt(FALLBACK_DIALOG_PARAM_VERSION, version);
+        webParams.putString(DIALOG_PARAM_DISPLAY, FALLBACK_DIALOG_DISPLAY_VALUE_TOUCH);
+
+        Bundle bridgeArguments = new Bundle();
+        bridgeArguments.putString(NativeProtocol.BRIDGE_ARG_ACTION_ID_STRING, callId);
+        bridgeArguments.putString(NativeProtocol.BRIDGE_ARG_APP_NAME_STRING, applicationName);
+
+        methodArgs = (methodArgs == null) ? new Bundle() : methodArgs;
+
+        try {
+            JSONObject bridgeArgsJSON = BundleJSONConverter.convertToJSON(bridgeArguments);
+            JSONObject methodArgsJSON = BundleJSONConverter.convertToJSON(methodArgs);
+
+            if (bridgeArgsJSON == null || methodArgsJSON == null) {
+                return null;
+            }
+
+            webParams.putString(FALLBACK_DIALOG_PARAM_BRIDGE_ARGS, bridgeArgsJSON.toString());
+            webParams.putString(FALLBACK_DIALOG_PARAM_METHOD_ARGS, methodArgsJSON.toString());
+        } catch (JSONException je) {
+            webParams = null;
+            Logger.log(LoggingBehavior.DEVELOPER_ERRORS, Log.ERROR, TAG,
+                    "Error creating Url -- " + je);
+        }
+
+        return webParams;
+    }
 }
diff --git a/facebook/src/com/facebook/internal/Utility.java b/facebook/src/com/facebook/internal/Utility.java
index 19a8f4047..91f627b02 100644
--- a/facebook/src/com/facebook/internal/Utility.java
+++ b/facebook/src/com/facebook/internal/Utility.java
@@ -17,9 +17,11 @@
 package com.facebook.internal;
 
 import android.content.Context;
+import android.content.SharedPreferences;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.net.Uri;
+import android.os.AsyncTask;
 import android.os.Bundle;
 import android.os.Parcelable;
 import android.provider.Settings.Secure;
@@ -30,7 +32,6 @@
 import com.facebook.FacebookException;
 import com.facebook.Request;
 import com.facebook.Settings;
-import com.facebook.android.BuildConfig;
 import com.facebook.model.GraphObject;
 import org.json.JSONArray;
 import org.json.JSONException;
@@ -42,6 +43,7 @@
 import java.lang.reflect.Method;
 import java.net.HttpURLConnection;
 import java.net.URLConnection;
+import java.net.URLDecoder;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.*;
@@ -57,17 +59,27 @@
     private static final String HASH_ALGORITHM_MD5 = "MD5";
     private static final String HASH_ALGORITHM_SHA1 = "SHA-1";
     private static final String URL_SCHEME = "https";
-    private static final String SUPPORTS_ATTRIBUTION = "supports_attribution";
-    private static final String SUPPORTS_IMPLICIT_SDK_LOGGING = "supports_implicit_sdk_logging";
-    private static final String NUX_CONTENT = "gdpv4_nux_content";
-    private static final String NUX_ENABLED = "gdpv4_nux_enabled";
+    private static final String APP_SETTINGS_PREFS_STORE = "com.facebook.internal.preferences.APP_SETTINGS";
+    private static final String APP_SETTINGS_PREFS_KEY_FORMAT = "com.facebook.internal.APP_SETTINGS.%s";
+    private static final String APP_SETTING_SUPPORTS_ATTRIBUTION = "supports_attribution";
+    private static final String APP_SETTING_SUPPORTS_IMPLICIT_SDK_LOGGING = "supports_implicit_sdk_logging";
+    private static final String APP_SETTING_NUX_CONTENT = "gdpv4_nux_content";
+    private static final String APP_SETTING_NUX_ENABLED = "gdpv4_nux_enabled";
+    private static final String APP_SETTING_DIALOG_CONFIGS = "android_dialog_configs";
     private static final String EXTRA_APP_EVENTS_INFO_FORMAT_VERSION = "a1";
-
-    private static final String [] APP_SETTING_FIELDS = new String[] {
-            SUPPORTS_ATTRIBUTION,
-            SUPPORTS_IMPLICIT_SDK_LOGGING,
-            NUX_CONTENT,
-            NUX_ENABLED
+    private static final String DIALOG_CONFIG_DIALOG_NAME_FEATURE_NAME_SEPARATOR = "\\|";
+    private static final String DIALOG_CONFIG_NAME_KEY = "name";
+    private static final String DIALOG_CONFIG_VERSIONS_KEY = "versions";
+    private static final String DIALOG_CONFIG_URL_KEY = "url";
+
+    private final static String UTF8 = "UTF-8";
+
+    private static final String[] APP_SETTING_FIELDS = new String[] {
+            APP_SETTING_SUPPORTS_ATTRIBUTION,
+            APP_SETTING_SUPPORTS_IMPLICIT_SDK_LOGGING,
+            APP_SETTING_NUX_CONTENT,
+            APP_SETTING_NUX_ENABLED,
+            APP_SETTING_DIALOG_CONFIGS
     };
     private static final String APPLICATION_FIELDS = "fields";
 
@@ -77,20 +89,25 @@
     private static Map<String, FetchedAppSettings> fetchedAppSettings =
             new ConcurrentHashMap<String, FetchedAppSettings>();
 
-  public static class FetchedAppSettings {
+    private static AsyncTask<Void, Void, GraphObject> initialAppSettingsLoadTask;
+
+    public static class FetchedAppSettings {
         private boolean supportsAttribution;
         private boolean supportsImplicitLogging;
         private String nuxContent;
         private boolean nuxEnabled;
+        private Map<String, Map<String, DialogFeatureConfig>> dialogConfigMap;
 
         private FetchedAppSettings(boolean supportsAttribution,
                                    boolean supportsImplicitLogging,
                                    String nuxContent,
-                                   boolean nuxEnabled) {
+                                   boolean nuxEnabled,
+                                   Map<String, Map<String, DialogFeatureConfig>> dialogConfigMap) {
             this.supportsAttribution = supportsAttribution;
             this.supportsImplicitLogging = supportsImplicitLogging;
             this.nuxContent = nuxContent;
             this.nuxEnabled = nuxEnabled;
+            this.dialogConfigMap = dialogConfigMap;
         }
 
         public boolean supportsAttribution() {
@@ -108,6 +125,185 @@ public String getNuxContent() {
         public boolean getNuxEnabled() {
             return nuxEnabled;
         }
+
+        public Map<String, Map<String, DialogFeatureConfig>> getDialogConfigurations() {
+            return dialogConfigMap;
+        }
+    }
+
+    public static class DialogFeatureConfig {
+        private static DialogFeatureConfig parseDialogConfig(JSONObject dialogConfigJSON) {
+            String dialogNameWithFeature = dialogConfigJSON.optString(DIALOG_CONFIG_NAME_KEY);
+            if (Utility.isNullOrEmpty(dialogNameWithFeature)) {
+                return null;
+            }
+
+            String[] components = dialogNameWithFeature.split(DIALOG_CONFIG_DIALOG_NAME_FEATURE_NAME_SEPARATOR);
+            if (components.length != 2) {
+                // We expect the format to be dialogName|FeatureName, where both components are non-empty.
+                return null;
+            }
+
+            String dialogName = components[0];
+            String featureName = components[1];
+            if (isNullOrEmpty(dialogName) || isNullOrEmpty(featureName)) {
+                return null;
+            }
+
+            String urlString = dialogConfigJSON.optString(DIALOG_CONFIG_URL_KEY);
+            Uri fallbackUri = null;
+            if (!Utility.isNullOrEmpty(urlString)) {
+                fallbackUri = Uri.parse(urlString);
+            }
+
+            JSONArray versionsJSON = dialogConfigJSON.optJSONArray(DIALOG_CONFIG_VERSIONS_KEY);
+
+            int[] featureVersionSpec = parseVersionSpec(versionsJSON);
+
+            return new DialogFeatureConfig(dialogName, featureName, fallbackUri, featureVersionSpec);
+        }
+
+        private static int[] parseVersionSpec(JSONArray versionsJSON) {
+            // Null signifies no overrides to the min-version as specified by the SDK.
+            // An empty array would basically turn off the dialog (i.e no supported versions), so DON'T default to that.
+            int[] versionSpec = null;
+            if (versionsJSON != null) {
+                int numVersions = versionsJSON.length();
+                versionSpec = new int[numVersions];
+                for (int i = 0; i < numVersions; i++) {
+                    // See if the version was stored directly as an Integer
+                    int version = versionsJSON.optInt(i, NativeProtocol.NO_PROTOCOL_AVAILABLE);
+                    if (version == NativeProtocol.NO_PROTOCOL_AVAILABLE) {
+                        // If not, then see if it was stored as a string that can be parsed out.
+                        // If even that fails, then we will leave it as NO_PROTOCOL_AVAILABLE
+                        String versionString = versionsJSON.optString(i);
+                        if (!isNullOrEmpty(versionString)) {
+                            try {
+                                version = Integer.parseInt(versionString);
+                            } catch (NumberFormatException nfe) {
+                                logd(LOG_TAG, nfe);
+                                version = NativeProtocol.NO_PROTOCOL_AVAILABLE;
+                            }
+                        }
+                    }
+
+                    versionSpec[i] = version;
+                }
+            }
+
+            return versionSpec;
+        }
+
+        private String dialogName;
+        private String featureName;
+        private Uri fallbackUrl;
+        private int[] featureVersionSpec;
+
+        private DialogFeatureConfig(String dialogName, String featureName, Uri fallbackUrl, int[] featureVersionSpec) {
+            this.dialogName = dialogName;
+            this.featureName = featureName;
+            this.fallbackUrl = fallbackUrl;
+            this.featureVersionSpec = featureVersionSpec;
+        }
+
+        public String getDialogName() {
+            return dialogName;
+        }
+
+        public String getFeatureName() {
+            return featureName;
+        }
+
+        public Uri getFallbackUrl() {
+            return fallbackUrl;
+        }
+
+        public int[] getVersionSpec() {
+            return featureVersionSpec;
+        }
+    }
+
+    /**
+     * Each array represents a set of closed or open Range, like so:
+     * [0,10,50,60] - Ranges are {0-9}, {50-59}
+     * [20] - Ranges are {20-}
+     * [30,40,100] - Ranges are {30-39}, {100-}
+     *
+     * All Ranges in the array have a closed lower bound. Only the last Range in each array may be open.
+     * It is assumed that the passed in arrays are sorted with ascending order.
+     * It is assumed that no two elements in a given are equal (i.e. no 0-length ranges)
+     *
+     * The method returns an intersect of the two passed in Range-sets
+     * @param range1
+     * @param range2
+     * @return
+     */
+    public static int[] intersectRanges(int[] range1, int[] range2) {
+        if (range1 == null) {
+            return range2;
+        } else if (range2 == null) {
+            return range1;
+        }
+
+        int[] outputRange = new int[range1.length + range2.length];
+        int outputIndex = 0;
+        int index1 = 0, lower1, upper1;
+        int index2 = 0, lower2, upper2;
+        while (index1 < range1.length && index2 < range2.length) {
+            int newRangeLower = Integer.MIN_VALUE, newRangeUpper = Integer.MAX_VALUE;
+            lower1 = range1[index1];
+            upper1 = Integer.MAX_VALUE;
+
+            lower2 = range2[index2];
+            upper2 = Integer.MAX_VALUE;
+
+            if (index1 < range1.length - 1) {
+                upper1 = range1[index1 + 1];
+            }
+            if (index2 < range2.length - 1) {
+                upper2 = range2[index2 + 1];
+            }
+
+            if (lower1 < lower2) {
+                if (upper1 > lower2) {
+                    newRangeLower = lower2;
+                    if (upper1 > upper2) {
+                        newRangeUpper = upper2;
+                        index2 += 2;
+                    } else {
+                        newRangeUpper = upper1;
+                        index1 += 2;
+                    }
+                } else {
+                    index1 += 2;
+                }
+            } else {
+                if (upper2 > lower1) {
+                    newRangeLower = lower1;
+                    if (upper2 > upper1) {
+                        newRangeUpper = upper1;
+                        index1 += 2;
+                    } else {
+                        newRangeUpper = upper2;
+                        index2 += 2;
+                    }
+                } else {
+                    index2 += 2;
+                }
+            }
+
+            if (newRangeLower != Integer.MIN_VALUE) {
+                outputRange[outputIndex ++] = newRangeLower;
+                if (newRangeUpper != Integer.MAX_VALUE) {
+                    outputRange[outputIndex ++] = newRangeUpper;
+                } else {
+                    // If we reach an unbounded/open range, then we know we're done.
+                    break;
+                }
+            }
+        }
+
+        return Arrays.copyOf(outputRange, outputIndex);
     }
 
     // Returns true iff all items in subset are in superset, treating null and
@@ -135,6 +331,23 @@ public static boolean isNullOrEmpty(String s) {
         return (s == null) || (s.length() == 0);
     }
 
+    /**
+     * Use this when you want to normalize empty and null strings
+     * This way, Utility.areObjectsEqual can used for comparison, where a null string is to be treated the same as
+     * an empty string.
+     *
+     * @param s
+     * @param valueIfNullOrEmpty
+     * @return
+     */
+    public static String coerceValueIfNullOrEmpty(String s, String valueIfNullOrEmpty) {
+        if (isNullOrEmpty(s)) {
+            return valueIfNullOrEmpty;
+        }
+
+        return s;
+    }
+
     public static <T> Collection<T> unmodifiableCollection(T... ts) {
         return Collections.unmodifiableCollection(Arrays.asList(ts));
     }
@@ -198,6 +411,32 @@ public static Uri buildUri(String authority, String path, Bundle parameters) {
         return builder.build();
     }
 
+    public static Bundle parseUrlQueryString(String queryString) {
+        Bundle params = new Bundle();
+        if (!isNullOrEmpty(queryString)) {
+            String array[] = queryString.split("&");
+            for (String parameter : array) {
+                String keyValuePair[] = parameter.split("=");
+
+                try {
+                    if (keyValuePair.length == 2) {
+                        params.putString(
+                                URLDecoder.decode(keyValuePair[0], UTF8),
+                                URLDecoder.decode(keyValuePair[1], UTF8));
+                    } else if (keyValuePair.length == 1) {
+                        params.putString(
+                                URLDecoder.decode(keyValuePair[0], UTF8),
+                                "");
+                    }
+                } catch (UnsupportedEncodingException e) {
+                    // shouldn't happen
+                    logd(LOG_TAG, e);
+                }
+            }
+        }
+        return params;
+    }
+
     public static void putObjectInBundle(Bundle bundle, String key, Object value) {
         if (value instanceof String) {
             bundle.putString(key, (String) value);
@@ -222,7 +461,7 @@ public static void closeQuietly(Closeable closeable) {
 
     public static void disconnectQuietly(URLConnection connection) {
         if (connection instanceof HttpURLConnection) {
-            ((HttpURLConnection)connection).disconnect();
+            ((HttpURLConnection) connection).disconnect();
         }
     }
 
@@ -352,17 +591,23 @@ public static void clearFacebookCookies(Context context) {
     }
 
     public static void logd(String tag, Exception e) {
-        if (Settings.isLoggingEnabled() && tag != null && e != null) {
+        if (Settings.isDebugEnabled() && tag != null && e != null) {
             Log.d(tag, e.getClass().getSimpleName() + ": " + e.getMessage());
         }
     }
 
     public static void logd(String tag, String msg) {
-        if (Settings.isLoggingEnabled() && tag != null && msg != null) {
+        if (Settings.isDebugEnabled() && tag != null && msg != null) {
             Log.d(tag, msg);
         }
     }
 
+    public static void logd(String tag, String msg, Throwable t) {
+        if (Settings.isDebugEnabled() && !isNullOrEmpty(tag)) {
+            Log.d(tag, msg, t);
+        }
+    }
+
     public static <T> boolean areObjectsEqual(T a, T b) {
         if (a == null) {
             return b == null;
@@ -370,34 +615,140 @@ public static void logd(String tag, String msg) {
         return a.equals(b);
     }
 
+    public static void loadAppSettingsAsync(final Context context, final String applicationId) {
+        if (Utility.isNullOrEmpty(applicationId) ||
+                fetchedAppSettings.containsKey(applicationId) ||
+                initialAppSettingsLoadTask != null) {
+            return;
+        }
+
+        final String settingsKey = String.format(APP_SETTINGS_PREFS_KEY_FORMAT, applicationId);
+
+        initialAppSettingsLoadTask = new AsyncTask<Void, Void, GraphObject>() {
+            @Override
+            protected GraphObject doInBackground(Void... params) {
+                return getAppSettingsQueryResponse(applicationId);
+            }
+
+            @Override
+            protected void onPostExecute(GraphObject result) {
+                if (result != null) {
+                    JSONObject resultJSON = result.getInnerJSONObject();
+                    parseAppSettingsFromJSON(applicationId, resultJSON);
+
+                    SharedPreferences sharedPrefs = context.getSharedPreferences(
+                            APP_SETTINGS_PREFS_STORE,
+                            Context.MODE_PRIVATE);
+                    sharedPrefs.edit().putString(settingsKey, resultJSON.toString()).apply();
+                }
+
+                initialAppSettingsLoadTask = null;
+            }
+        };
+        initialAppSettingsLoadTask.execute((Void[])null);
+
+        // Also see if we had a cached copy and use that immediately.
+        SharedPreferences sharedPrefs = context.getSharedPreferences(
+                APP_SETTINGS_PREFS_STORE,
+                Context.MODE_PRIVATE);
+        String settingsJSONString = sharedPrefs.getString(settingsKey, null);
+        if (!isNullOrEmpty(settingsJSONString)) {
+            JSONObject settingsJSON = null;
+            try {
+                settingsJSON = new JSONObject(settingsJSONString);
+            } catch (JSONException je) {
+                logd(LOG_TAG, je);
+            }
+            if (settingsJSON != null) {
+                parseAppSettingsFromJSON(applicationId, settingsJSON);
+            }
+        }
+    }
+
     // Note that this method makes a synchronous Graph API call, so should not be called from the main thread.
     public static FetchedAppSettings queryAppSettings(final String applicationId, final boolean forceRequery) {
-
         // Cache the last app checked results.
         if (!forceRequery && fetchedAppSettings.containsKey(applicationId)) {
             return fetchedAppSettings.get(applicationId);
         }
 
+        GraphObject response = getAppSettingsQueryResponse(applicationId);
+        if (response == null) {
+            return null;
+        }
+
+        return parseAppSettingsFromJSON(applicationId, response.getInnerJSONObject());
+    }
+
+    private static FetchedAppSettings parseAppSettingsFromJSON(String applicationId, JSONObject settingsJSON) {
+        FetchedAppSettings result = new FetchedAppSettings(
+                settingsJSON.optBoolean(APP_SETTING_SUPPORTS_ATTRIBUTION, false),
+                settingsJSON.optBoolean(APP_SETTING_SUPPORTS_IMPLICIT_SDK_LOGGING, false),
+                settingsJSON.optString(APP_SETTING_NUX_CONTENT, ""),
+                settingsJSON.optBoolean(APP_SETTING_NUX_ENABLED, false),
+                parseDialogConfigurations(settingsJSON.optJSONObject(APP_SETTING_DIALOG_CONFIGS))
+        );
+
+        fetchedAppSettings.put(applicationId, result);
+
+        return result;
+    }
+
+    // Note that this method makes a synchronous Graph API call, so should not be called from the main thread.
+    private static GraphObject getAppSettingsQueryResponse(String applicationId) {
         Bundle appSettingsParams = new Bundle();
         appSettingsParams.putString(APPLICATION_FIELDS, TextUtils.join(",", APP_SETTING_FIELDS));
 
         Request request = Request.newGraphPathRequest(null, applicationId, null);
+        request.setSkipClientToken(true);
         request.setParameters(appSettingsParams);
 
-        GraphObject supportResponse = request.executeAndWait().getGraphObject();
-        FetchedAppSettings result = new FetchedAppSettings(
-                safeGetBooleanFromResponse(supportResponse, SUPPORTS_ATTRIBUTION),
-                safeGetBooleanFromResponse(supportResponse, SUPPORTS_IMPLICIT_SDK_LOGGING),
-                safeGetStringFromResponse(supportResponse, NUX_CONTENT),
-                safeGetBooleanFromResponse(supportResponse, NUX_ENABLED)
-                );
+        GraphObject response = request.executeAndWait().getGraphObject();
+        return response;
+    }
 
-        fetchedAppSettings.put(applicationId, result);
+    public static DialogFeatureConfig getDialogFeatureConfig(String applicationId, String actionName, String featureName) {
+        if (Utility.isNullOrEmpty(actionName) || Utility.isNullOrEmpty(featureName)) {
+            return null;
+        }
 
-        return result;
+        FetchedAppSettings settings = fetchedAppSettings.get(applicationId);
+        if (settings != null) {
+            Map<String, DialogFeatureConfig> featureMap = settings.getDialogConfigurations().get(actionName);
+            if (featureMap != null) {
+                return featureMap.get(featureName);
+            }
+        }
+        return null;
     }
 
-    private static boolean safeGetBooleanFromResponse(GraphObject response, String propertyName) {
+    private static Map<String, Map<String, DialogFeatureConfig>> parseDialogConfigurations(JSONObject dialogConfigResponse) {
+        HashMap<String, Map<String, DialogFeatureConfig>> dialogConfigMap = new HashMap<String, Map<String, DialogFeatureConfig>>();
+
+        if (dialogConfigResponse != null) {
+            JSONArray dialogConfigData = dialogConfigResponse.optJSONArray("data");
+            if (dialogConfigData != null) {
+                for (int i = 0; i < dialogConfigData.length(); i++) {
+                    DialogFeatureConfig dialogConfig = DialogFeatureConfig.parseDialogConfig(dialogConfigData.optJSONObject(i));
+                    if (dialogConfig == null) {
+                        continue;
+                    }
+
+                    String dialogName = dialogConfig.getDialogName();
+                    Map<String, DialogFeatureConfig> featureMap = dialogConfigMap.get(dialogName);
+                    if (featureMap == null) {
+                        featureMap = new HashMap<String, DialogFeatureConfig>();
+                        dialogConfigMap.put(dialogName, featureMap);
+                    }
+                    featureMap.put(dialogConfig.getFeatureName(), dialogConfig);
+                }
+            }
+        }
+
+        return dialogConfigMap;
+    }
+
+    public static boolean safeGetBooleanFromResponse(GraphObject response, String propertyName) {
         Object result = false;
         if (response != null) {
             result = response.getProperty(propertyName);
@@ -408,7 +759,7 @@ private static boolean safeGetBooleanFromResponse(GraphObject response, String p
         return (Boolean) result;
     }
 
-    private static String safeGetStringFromResponse(GraphObject response, String propertyName) {
+    public static String safeGetStringFromResponse(GraphObject response, String propertyName) {
         Object result = "";
         if (response != null) {
             result = response.getProperty(propertyName);
@@ -419,6 +770,28 @@ private static String safeGetStringFromResponse(GraphObject response, String pro
         return (String) result;
     }
 
+    public static JSONObject tryGetJSONObjectFromResponse(GraphObject response, String propertyKey) {
+        if (response == null) {
+            return null;
+        }
+        Object property = response.getProperty(propertyKey);
+        if (!(property instanceof JSONObject)) {
+            return null;
+        }
+        return (JSONObject) property;
+    }
+
+    public static JSONArray tryGetJSONArrayFromResponse(GraphObject response, String propertyKey) {
+        if (response == null) {
+            return null;
+        }
+        Object property = response.getProperty(propertyKey);
+        if (!(property instanceof JSONArray)) {
+            return null;
+        }
+        return (JSONArray) property;
+    }
+
     public static void clearCaches(Context context) {
         ImageDownloader.clearCache(context);
     }
@@ -461,7 +834,7 @@ public static String getHashedDeviceAndAppID(Context context, String application
     }
 
     public static void setAppEventAttributionParameters(GraphObject params,
-            AttributionIdentifiers attributionIdentifiers, String hashedDeviceAndAppId, boolean limitEventUsage) {
+                                                        AttributionIdentifiers attributionIdentifiers, String hashedDeviceAndAppId, boolean limitEventUsage) {
         // Send attributionID if it exists, otherwise send a hashed device+appid specific value as the advertiser_id.
         if (attributionIdentifiers != null && attributionIdentifiers.getAttributionId() != null) {
             params.setProperty("attribution", attributionIdentifiers.getAttributionId());
@@ -478,28 +851,28 @@ public static void setAppEventAttributionParameters(GraphObject params,
     }
 
     public static void setAppEventExtendedDeviceInfoParameters(GraphObject params, Context appContext) {
-      JSONArray extraInfoArray = new JSONArray();
-      extraInfoArray.put(EXTRA_APP_EVENTS_INFO_FORMAT_VERSION);
+        JSONArray extraInfoArray = new JSONArray();
+        extraInfoArray.put(EXTRA_APP_EVENTS_INFO_FORMAT_VERSION);
 
-      // Application Manifest info:
-      String pkgName = appContext.getPackageName();
-      int versionCode = -1;
-      String versionName = "";
+        // Application Manifest info:
+        String pkgName = appContext.getPackageName();
+        int versionCode = -1;
+        String versionName = "";
 
-      try {
-        PackageInfo pi = appContext.getPackageManager().getPackageInfo(pkgName, 0);
-        versionCode = pi.versionCode;
-        versionName = pi.versionName;
-      } catch (PackageManager.NameNotFoundException e) {
-        // Swallow
-      }
+        try {
+            PackageInfo pi = appContext.getPackageManager().getPackageInfo(pkgName, 0);
+            versionCode = pi.versionCode;
+            versionName = pi.versionName;
+        } catch (PackageManager.NameNotFoundException e) {
+            // Swallow
+        }
 
-      // Application Manifest info:
-      extraInfoArray.put(pkgName);
-      extraInfoArray.put(versionCode);
-      extraInfoArray.put(versionName);
+        // Application Manifest info:
+        extraInfoArray.put(pkgName);
+        extraInfoArray.put(versionCode);
+        extraInfoArray.put(versionName);
 
-      params.setProperty("extinfo", extraInfoArray.toString());
+        params.setProperty("extinfo", extraInfoArray.toString());
     }
 
     public static Method getMethodQuietly(Class<?> clazz, String methodName, Class<?>... parameterTypes) {
@@ -529,16 +902,16 @@ public static Object invokeMethodQuietly(Object receiver, Method method, Object.
         }
     }
 
-  /**
-   * Returns the name of the current activity if the context is an activity, otherwise return "unknown"
-   */
-  public static String getActivityName(Context context) {
-    if (context == null) {
-      return "null";
-    } else if (context == context.getApplicationContext()) {
-      return "unknown";
-    } else {
-      return context.getClass().getSimpleName();
+    /**
+     * Returns the name of the current activity if the context is an activity, otherwise return "unknown"
+     */
+    public static String getActivityName(Context context) {
+        if (context == null) {
+            return "null";
+        } else if (context == context.getApplicationContext()) {
+            return "unknown";
+        } else {
+            return context.getClass().getSimpleName();
+        }
     }
-  }
 }
diff --git a/facebook/src/com/facebook/widget/FacebookDialog.java b/facebook/src/com/facebook/widget/FacebookDialog.java
index 226e1206a..44ef2ceec 100644
--- a/facebook/src/com/facebook/widget/FacebookDialog.java
+++ b/facebook/src/com/facebook/widget/FacebookDialog.java
@@ -20,15 +20,13 @@
 import android.content.Context;
 import android.content.Intent;
 import android.graphics.Bitmap;
+import android.net.Uri;
 import android.os.Bundle;
 import android.os.Parcel;
 import android.os.Parcelable;
 import android.support.v4.app.Fragment;
 import com.facebook.*;
-import com.facebook.internal.AnalyticsEvents;
-import com.facebook.internal.NativeProtocol;
-import com.facebook.internal.Utility;
-import com.facebook.internal.Validate;
+import com.facebook.internal.*;
 import com.facebook.model.GraphObject;
 import com.facebook.model.GraphObjectList;
 import com.facebook.model.OpenGraphAction;
@@ -80,9 +78,30 @@
         void onError(PendingCall pendingCall, Exception error, Bundle data);
     }
 
-    private interface DialogFeature {
+    /**
+     * Provides an interface for describing a specific feature provided by a FacebookDialog.
+     * This is public primarily to allow its use elsewhere in the Android SDK; developers are discouraged from
+     * constructing their own DialogFeature implementations internal API may change.
+     */
+    public interface DialogFeature {
+        /**
+         * This method is for internal use only.
+         */
         String getAction();
+
+        /**
+         * This method is for internal use only.
+         */
         int getMinVersion();
+
+        /**
+         * This method is for internal use only.
+         *
+         * For all Enums that implement this interface, the name() method is already present. It returns the String
+         * representation of the Enum value, verbatim.
+         *
+         */
+        String name();
     }
 
     /**
@@ -343,12 +362,13 @@ public static boolean handleActivityResult(Context context, PendingCall appCall,
 
         if (callback != null) {
             if (NativeProtocol.isErrorResult(data)) {
-                Exception error = NativeProtocol.getErrorFromResult(data);
+                Bundle errorData = NativeProtocol.getErrorDataFromResultIntent(data);
+                Exception error = NativeProtocol.getExceptionFromErrorData(errorData);
 
-                // TODO  - data.getExtras() doesn't work for the bucketed protocol.
-                callback.onError(appCall, error, data.getExtras());
+                callback.onError(appCall, error, errorData);
             } else {
-                callback.onComplete(appCall, NativeProtocol.getSuccessResultsFromIntent(data));
+                Bundle successResults = NativeProtocol.getSuccessResultsFromIntent(data);
+                callback.onComplete(appCall, successResults);
             }
         }
 
@@ -416,12 +436,20 @@ public static boolean canPresentOpenGraphMessageDialog(Context context, OpenGrap
     }
 
     private static boolean handleCanPresent(Context context, Iterable<? extends DialogFeature> features) {
-        return getProtocolVersionForNativeDialog(context, getActionForFeatures(features), getMinVersionForFeatures(features))
-                != NativeProtocol.NO_PROTOCOL_AVAILABLE;
+        String actionName = getActionForFeatures(features);
+        String applicationId = Settings.getApplicationId();
+        if (Utility.isNullOrEmpty(applicationId)) {
+            applicationId = Utility.getMetadataApplicationId(context);
+        }
+        return getProtocolVersionForNativeDialog(
+                context,
+                actionName,
+                getVersionSpecForFeatures(applicationId, actionName, features)
+        ) != NativeProtocol.NO_PROTOCOL_AVAILABLE;
     }
 
-    private static int getProtocolVersionForNativeDialog(Context context, String action, int requiredVersion) {
-        return NativeProtocol.getLatestAvailableProtocolVersionForAction(context, action, requiredVersion);
+    private static int getProtocolVersionForNativeDialog(Context context, String action, int[] versionSpec) {
+        return NativeProtocol.getLatestAvailableProtocolVersionForAction(context, action, versionSpec);
     }
 
     private static NativeAppCallAttachmentStore getAttachmentStore() {
@@ -431,13 +459,27 @@ private static NativeAppCallAttachmentStore getAttachmentStore() {
         return attachmentStore;
     }
 
-    private static int getMinVersionForFeatures(Iterable<? extends DialogFeature> features) {
-        int minVersion = Integer.MIN_VALUE;
+    private static int[] getVersionSpecForFeatures(
+            String applicationId,
+            String actionName,
+            Iterable<? extends DialogFeature> features) {
+        int[] intersectedRange = null; // Null is treated as a fully open Range. So it is safe to compare against.
         for (DialogFeature feature : features) {
-            // Minimum version to support all features is the maximum of each feature's minimum version.
-            minVersion = Math.max(minVersion, feature.getMinVersion());
+            int[] featureVersionSpec = getVersionSpecForFeature(applicationId, actionName, feature);
+            intersectedRange = Utility.intersectRanges(intersectedRange, featureVersionSpec);
+        }
+
+        return intersectedRange;
+    }
+
+    private static int[] getVersionSpecForFeature(String applicationId, String actionName, DialogFeature feature) {
+        // Return the value from DialogFeatureConfig if available. Otherwise, just default to the min-version
+        Utility.DialogFeatureConfig config = Utility.getDialogFeatureConfig(applicationId, actionName, feature.name());
+        if (config != null) {
+            return config.getVersionSpec();
+        } else {
+            return new int[]{feature.getMinVersion()};
         }
-        return minVersion;
     }
 
     private static String getActionForFeatures(Iterable<? extends DialogFeature> features) {
@@ -479,6 +521,8 @@ static private String getEventName(String action, boolean hasPhotos) {
             eventName = AnalyticsEvents.EVENT_NATIVE_DIALOG_TYPE_OG_SHARE;
         } else if (action.equals(NativeProtocol.ACTION_OGMESSAGEPUBLISH_DIALOG)) {
             eventName = AnalyticsEvents.EVENT_NATIVE_DIALOG_TYPE_OG_MESSAGE;
+        } else if (action.equals(NativeProtocol.ACTION_LIKE_DIALOG)) {
+            eventName = AnalyticsEvents.EVENT_NATIVE_DIALOG_TYPE_LIKE;
         } else {
             throw new FacebookException("An unspecified action was presented");
         }
@@ -568,7 +612,7 @@ public FacebookDialog build() {
 
             String action = getActionForFeatures(getDialogFeatures());
             int protocolVersion = getProtocolVersionForNativeDialog(activity, action,
-                    getMinVersionForFeatures(getDialogFeatures()));
+                    getVersionSpecForFeatures(applicationId, action, getDialogFeatures()));
 
             Bundle extras = null;
             if (NativeProtocol.isVersionCompatibleWithBucketedIntent(protocolVersion)) {
@@ -600,6 +644,54 @@ public FacebookDialog build() {
             return new FacebookDialog(activity, fragment, appCall, getOnPresentCallback());
         }
 
+        /**
+         * This is public primarily to allow its use elsewhere in the Android SDK; developers are discouraged from
+         * consuming this method as the internal API may change.
+         */
+        protected String getWebFallbackUrlInternal() {
+            Iterable<? extends DialogFeature> features = getDialogFeatures();
+            String featureName = null;
+            String action = null;
+            for (DialogFeature feature : features) {
+                // All actions in a set of DialogFeatures should have the same fallback url
+                // So we can break after assigning the first one
+                featureName = feature.name();
+                action = feature.getAction();
+                break;
+            }
+
+            Utility.DialogFeatureConfig config = Utility.getDialogFeatureConfig(applicationId, action, featureName);
+            Uri fallbackUrl;
+            if (config == null || (fallbackUrl = config.getFallbackUrl()) == null) {
+                return null;
+            }
+
+            // Since we're talking to the server here, let's use the latest version we know about.
+            // We know we are going to be communicating over a bucketed protocol.
+            Bundle methodArguments = getMethodArguments();
+            int protocolVersion = NativeProtocol.getLatestKnownVersion();
+            Bundle webParams = ServerProtocol.getQueryParamsForPlatformActivityIntentWebFallback(
+                    activity,
+                    appCall.getCallId().toString(),
+                    protocolVersion,
+                    applicationName,
+                    methodArguments);
+            if (webParams == null) {
+                // Could not create the query parameters
+                return null;
+            }
+
+            // Now form the Uri
+            if (fallbackUrl.isRelative()) {
+                fallbackUrl = Utility.buildUri(
+                        ServerProtocol.getDialogAuthority(),
+                        fallbackUrl.toString(),
+                        webParams);
+            }
+
+            return fallbackUrl.toString();
+        }
+
         /**
          * Determines whether the native dialog can be presented (i.e., whether the required version of the
          * Facebook application is installed on the device, and whether the installed version supports all of
@@ -664,7 +756,10 @@ public void onPresent(Context context) throws Exception {
             return new ArrayList<String>(imageAttachments.keySet());
         }
 
-        protected abstract Bundle setBundleExtras(Bundle extras);
+        protected Bundle setBundleExtras(Bundle extras) {
+            // Default implementation.
+            return extras;
+        }
 
         protected abstract Bundle getMethodArguments();
 
@@ -674,7 +769,7 @@ protected void putExtra(Bundle extras, String key, String value) {
             }
         }
 
-        abstract EnumSet<? extends DialogFeature> getDialogFeatures();
+        protected abstract EnumSet<? extends DialogFeature> getDialogFeatures();
 
         protected CONCRETE addImageAttachment(String imageName, Bitmap bitmap) {
             imageAttachments.put(imageName, bitmap);
@@ -889,7 +984,7 @@ public ShareDialogBuilder(Activity activity) {
         }
 
         @Override
-        EnumSet<? extends DialogFeature> getDialogFeatures() {
+        protected EnumSet<? extends DialogFeature> getDialogFeatures() {
             return EnumSet.of(ShareDialogFeature.SHARE_DIALOG);
         }
     }
@@ -1032,7 +1127,7 @@ public PhotoShareDialogBuilder(Activity activity) {
         }
 
         @Override
-        EnumSet<? extends DialogFeature> getDialogFeatures() {
+        protected EnumSet<? extends DialogFeature> getDialogFeatures() {
             return EnumSet.of(ShareDialogFeature.SHARE_DIALOG, ShareDialogFeature.PHOTOS);
         }
 
@@ -1059,7 +1154,7 @@ public PhotoMessageDialogBuilder(Activity activity) {
         }
 
         @Override
-        EnumSet<? extends DialogFeature> getDialogFeatures() {
+        protected EnumSet<? extends DialogFeature> getDialogFeatures() {
             return EnumSet.of(MessageDialogFeature.MESSAGE_DIALOG, MessageDialogFeature.PHOTOS);
         }
 
@@ -1067,6 +1162,28 @@ public PhotoMessageDialogBuilder(Activity activity) {
         int getMaximumNumberOfPhotos() {
             return MAXIMUM_PHOTO_COUNT;
         }
+
+        /**
+         * setPlace is not supported for the photo message dialog, setting this method will have no effect.
+         *
+         * @param place will be ignored
+         * @return this instance of the builder
+         */
+        @Override
+        public PhotoMessageDialogBuilder setPlace(String place) {
+            return this;
+        }
+
+        /**
+         * setFriends is not supported for the photo message dialog, setting this method will have no effect.
+         *
+         * @param friends will be ignored
+         * @return this instance of the builder
+         */
+        @Override
+        public PhotoMessageDialogBuilder setFriends(List<String> friends) {
+            return this;
+        }
     }
 
     /**
@@ -1088,9 +1205,31 @@ public MessageDialogBuilder(Activity activity) {
         }
 
         @Override
-        EnumSet<? extends DialogFeature> getDialogFeatures() {
+        protected EnumSet<? extends DialogFeature> getDialogFeatures() {
             return EnumSet.of(MessageDialogFeature.MESSAGE_DIALOG);
         }
+
+        /**
+         * setPlace is not supported for the message dialog, setting this method will have no effect.
+         *
+         * @param place will be ignored
+         * @return this instance of the builder
+         */
+        @Override
+        public MessageDialogBuilder setPlace(String place) {
+            return this;
+        }
+
+        /**
+         * setFriends is not supported for the message dialog, setting this method will have no effect.
+         *
+         * @param friends will be ignored
+         * @return this instance of the builder
+         */
+        @Override
+        public MessageDialogBuilder setFriends(List<String> friends) {
+            return this;
+        }
     }
 
     private static abstract class OpenGraphDialogBuilderBase<CONCRETE extends OpenGraphDialogBuilderBase<?>>
@@ -1597,7 +1736,7 @@ public OpenGraphActionDialogBuilder(Activity activity, OpenGraphAction action, S
         }
 
         @Override
-        EnumSet<? extends DialogFeature> getDialogFeatures() {
+        protected EnumSet<? extends DialogFeature> getDialogFeatures() {
             return EnumSet.of(OpenGraphActionDialogFeature.OG_ACTION_DIALOG);
         }
     }
@@ -1627,7 +1766,7 @@ public OpenGraphMessageDialogBuilder(Activity activity, OpenGraphAction action,
         }
 
         @Override
-        EnumSet<? extends DialogFeature> getDialogFeatures() {
+        protected EnumSet<? extends DialogFeature> getDialogFeatures() {
             return EnumSet.of(OpenGraphMessageDialogFeature.OG_MESSAGE_DIALOG);
         }
     }
diff --git a/facebook/src/com/facebook/widget/LikeView.java b/facebook/src/com/facebook/widget/LikeView.java
new file mode 100644
index 000000000..8b1b8280e
--- /dev/null
+++ b/facebook/src/com/facebook/widget/LikeView.java
@@ -0,0 +1,693 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.TypedArray;
+import android.graphics.Color;
+import android.os.Bundle;
+import android.support.v4.content.LocalBroadcastManager;
+import android.util.AttributeSet;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.view.View;
+import android.widget.FrameLayout;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+import com.facebook.android.R;
+import com.facebook.internal.*;
+
+/**
+ * This class provides the UI for displaying the Facebook Like button and its associated components.
+ */
+public class LikeView extends FrameLayout {
+
+    // ***
+    // Keep all the enum values in sync with attrs.xml
+    // ***
+
+    /**
+     * Encapsulates the valid values for the facebook:style attribute for a LikeView
+     */
+    public enum Style {
+        /**
+         * Setting the attribute to this value will display the button and a sentence near it that describes the
+         * social sentence for the associated object.
+         *
+         * This is the default value
+         */
+        STANDARD("standard", 0),
+
+        /**
+         * Setting the attribute to this value will display the button by itself, with no other components
+         */
+        BUTTON("button", 1),
+
+        /**
+         * Setting the attribute to this value will display the button and a box near it with the number of likes
+         * for the associated object
+         */
+        BOX_COUNT("box_count", 2);
+
+        static Style DEFAULT = STANDARD;
+
+        static Style fromInt(int enumValue) {
+            for (Style style : values()) {
+                if (style.getValue() == enumValue) {
+                    return style;
+                }
+            }
+
+            return null;
+        }
+
+        private String stringValue;
+        private int intValue;
+        private Style(String stringValue, int value) {
+            this.stringValue = stringValue;
+            this.intValue = value;
+        }
+
+        @Override
+        public String toString() {
+            return stringValue;
+        }
+
+        private int getValue() {
+            return intValue;
+        }
+    }
+
+    /**
+     * Encapsulates the valid values for the facebook:horizontal_alignment attribute for a LikeView.
+     */
+    public enum HorizontalAlignment {
+        /**
+         * Setting the attribute to this value will center the button and auxiliary view in the parent view.
+         *
+         * This is the default value
+         */
+        CENTER("center", 0),
+
+        /**
+         * Setting the attribute to this value will left-justify the button and auxiliary view in the parent view.
+         */
+        LEFT("left", 1),
+
+        /**
+         * Setting the attribute to this value will right-justify the button and auxiliary view in the parent view.
+         * If the facebook:auxiliary_view_position is set to INLINE, then the auxiliary view will be on the
+         * left of the button
+         */
+        RIGHT("right", 2);
+
+        static HorizontalAlignment DEFAULT = CENTER;
+
+        static HorizontalAlignment fromInt(int enumValue) {
+            for (HorizontalAlignment horizontalAlignment : values()) {
+                if (horizontalAlignment.getValue() == enumValue) {
+                    return horizontalAlignment;
+                }
+            }
+
+            return null;
+        }
+
+        private String stringValue;
+        private int intValue;
+        private HorizontalAlignment(String stringValue, int value) {
+            this.stringValue = stringValue;
+            this.intValue = value;
+        }
+
+        @Override
+        public String toString() {
+            return stringValue;
+        }
+
+        private int getValue() {
+            return intValue;
+        }
+    }
+
+    /**
+     * Encapsulates the valid values for the facebook:auxiliary_view_position attribute for a LikeView.
+     */
+    public enum AuxiliaryViewPosition {
+        /**
+         * Setting the attribute to this value will put the social-sentence or box-count below the like button.
+         * If the facebook:style is set to BUTTON, then this has no effect.
+         *
+         * This is the default value
+         */
+        BOTTOM("bottom", 0),
+
+        /**
+         * Setting the attribute to this value will put the social-sentence or box-count inline with the like button.
+         * The auxiliary view will be to the left of the button if the facebook:horizontal_alignment is set to RIGHT.
+         * In all other cases, it will be to the right of the button.
+         * If the facebook:style is set to BUTTON, then this has no effect.
+         */
+        INLINE("inline", 1),
+
+        /**
+         * Setting the attribute to this value will put the social-sentence or box-count above the like button.
+         * If the facebook:style is set to BUTTON, then this has no effect.
+         */
+        TOP("top", 2);
+
+        static AuxiliaryViewPosition DEFAULT = BOTTOM;
+
+        static AuxiliaryViewPosition fromInt(int enumValue) {
+            for (AuxiliaryViewPosition auxViewPosition : values()) {
+                if (auxViewPosition.getValue() == enumValue) {
+                    return auxViewPosition;
+                }
+            }
+
+            return null;
+        }
+
+        private String stringValue;
+        private int intValue;
+        private AuxiliaryViewPosition(String stringValue, int value) {
+            this.stringValue = stringValue;
+            this.intValue = value;
+        }
+
+        @Override
+        public String toString() {
+            return stringValue;
+        }
+
+        private int getValue() {
+            return intValue;
+        }
+    }
+
+    private static final int NO_FOREGROUND_COLOR = -1;
+
+    private String objectId;
+    private LinearLayout containerView;
+    private LikeButton likeButton;
+    private LikeBoxCountView likeBoxCountView;
+    private TextView socialSentenceView;
+    private LikeActionController likeActionController;
+    private OnErrorListener onErrorListener;
+    private BroadcastReceiver broadcastReceiver;
+    private LikeActionControllerCreationCallback creationCallback;
+
+    private Style likeViewStyle = Style.DEFAULT;
+    private HorizontalAlignment horizontalAlignment = HorizontalAlignment.DEFAULT;
+    private AuxiliaryViewPosition auxiliaryViewPosition = AuxiliaryViewPosition.DEFAULT;
+    private int foregroundColor = NO_FOREGROUND_COLOR;
+
+    private int edgePadding;
+    private int internalPadding;
+
+    /**
+     * If your app does not use UiLifeCycleHelper, then you must call this method in the calling activity's
+     * onActivityResult method, to process any pending like actions, where tapping the button had resulted in
+     * the Like dialog being shown in the Facebook application.
+     *
+     * @param context Hosting context
+     * @param requestCode From the originating call to onActivityResult
+     * @param resultCode From the originating call to onActivityResult
+     * @param data From the originating call to onActivityResult
+     * @return Indication of whether the Intent was handled
+     */
+    public static boolean handleOnActivityResult(Context context,
+                                                 int requestCode,
+                                                 int resultCode,
+                                                 Intent data) {
+        return LikeActionController.handleOnActivityResult(context, requestCode, resultCode, data);
+    }
+
+    /**
+     * Constructor
+     *
+     * @param context Context for this View
+     */
+    public LikeView(Context context) {
+        super(context);
+        initialize(context);
+    }
+
+    /**
+     * Constructor
+     *
+     * @param context Context for this View
+     * @param attrs   AttributeSet for this View.
+     */
+    public LikeView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        parseAttributes(attrs);
+        initialize(context);
+    }
+
+    /**
+     * Sets the associated object for this LikeView. Can be changed during runtime.
+     * @param objectId Object Id
+     */
+    public void setObjectId(String objectId) {
+        objectId = Utility.coerceValueIfNullOrEmpty(objectId, null);
+        if (!Utility.areObjectsEqual(objectId, this.objectId)) {
+            setObjectIdForced(objectId);
+
+            updateLikeStateAndLayout();
+        }
+    }
+
+    /**
+     * Sets the facebook:style for this LikeView. Can be changed during runtime.
+     * @param likeViewStyle Should be either LikeView.STANDARD, LikeView.BUTTON or LikeView.BOX_COUNT
+     */
+    public void setLikeViewStyle(Style likeViewStyle) {
+        likeViewStyle = likeViewStyle != null ? likeViewStyle : Style.DEFAULT;
+        if (this.likeViewStyle != likeViewStyle) {
+            this.likeViewStyle = likeViewStyle;
+
+            updateLayout();
+        }
+    }
+
+    /**
+     * Sets the facebook:auxiliary_view_position for this LikeView. Can be changed during runtime.
+     * @param auxiliaryViewPosition Should be either LikeView.TOP, LikeView.INLINE or LikeView.BOTTOM
+     */
+    public void setAuxiliaryViewPosition(AuxiliaryViewPosition auxiliaryViewPosition) {
+        auxiliaryViewPosition = auxiliaryViewPosition != null ? auxiliaryViewPosition : AuxiliaryViewPosition.DEFAULT;
+        if (this.auxiliaryViewPosition != auxiliaryViewPosition) {
+            this.auxiliaryViewPosition = auxiliaryViewPosition;
+
+            updateLayout();
+        }
+    }
+
+    /**
+     * Sets the facebook:horizontal_alignment for this LikeView. Can be changed during runtime.
+     * @param horizontalAlignment Should be either LikeView.LEFT, LikeView.CENTER or LikeView.RIGHT
+     */
+    public void setHorizontalAlignment(HorizontalAlignment horizontalAlignment) {
+        horizontalAlignment = horizontalAlignment != null ? horizontalAlignment : HorizontalAlignment.DEFAULT;
+        if (this.horizontalAlignment != horizontalAlignment) {
+            this.horizontalAlignment = horizontalAlignment;
+
+            updateLayout();
+        }
+    }
+
+    /**
+     * Sets the facebook:foreground_color for this LikeView. Can be changed during runtime.
+     * The color is only used for the social sentence text.
+     * @param foregroundColor And valid android.graphics.Color value.
+     */
+    public void setForegroundColor(int foregroundColor) {
+        if (this.foregroundColor != foregroundColor) {
+            socialSentenceView.setTextColor(foregroundColor);
+        }
+    }
+
+    /**
+     * Sets an OnErrorListener for this instance of LoginButton to call into when
+     * certain exceptions occur.
+     *
+     * @param onErrorListener The listener object to set
+     */
+    public void setOnErrorListener(OnErrorListener onErrorListener) {
+        this.onErrorListener = onErrorListener;
+    }
+
+    /**
+     * Returns the current OnErrorListener for this instance of LoginButton.
+     *
+     * @return The OnErrorListener
+     */
+    public OnErrorListener getOnErrorListener() {
+        return onErrorListener;
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        // Disassociate from the object
+        setObjectId(null);
+
+        super.onDetachedFromWindow();
+    }
+
+    private void parseAttributes(AttributeSet attrs) {
+        if (attrs == null || getContext() == null) {
+            return;
+        }
+
+        TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.com_facebook_like_view);
+        if (a == null) {
+            return;
+        }
+
+        objectId = Utility.coerceValueIfNullOrEmpty(a.getString(R.styleable.com_facebook_like_view_object_id), null);
+        likeViewStyle = Style.fromInt(
+                a.getInt(R.styleable.com_facebook_like_view_style,
+                        Style.DEFAULT.getValue()));
+        if (likeViewStyle == null) {
+            throw new IllegalArgumentException("Unsupported value for LikeView 'style'");
+        }
+
+        auxiliaryViewPosition = AuxiliaryViewPosition.fromInt(
+                a.getInt(R.styleable.com_facebook_like_view_auxiliary_view_position,
+                        AuxiliaryViewPosition.DEFAULT.getValue()));
+        if (auxiliaryViewPosition == null) {
+            throw new IllegalArgumentException("Unsupported value for LikeView 'auxiliary_view_position'");
+        }
+
+        horizontalAlignment = HorizontalAlignment.fromInt(
+                a.getInt(R.styleable.com_facebook_like_view_horizontal_alignment,
+                        HorizontalAlignment.DEFAULT.getValue()));
+        if (horizontalAlignment == null) {
+            throw new IllegalArgumentException("Unsupported value for LikeView 'horizontal_alignment'");
+        }
+
+        foregroundColor = a.getColor(R.styleable.com_facebook_like_view_foreground_color, NO_FOREGROUND_COLOR);
+
+        a.recycle();
+    }
+
+    // If attributes were present, parseAttributes MUST be called before initialize() to ensure proper behavior
+    private void initialize(Context context) {
+        edgePadding = getResources().getDimensionPixelSize(R.dimen.com_facebook_likeview_edge_padding);
+        internalPadding = getResources().getDimensionPixelSize(R.dimen.com_facebook_likeview_internal_padding);
+        if (foregroundColor == NO_FOREGROUND_COLOR) {
+            foregroundColor = getResources().getColor(R.color.com_facebook_likeview_text_color);
+        }
+
+        setBackgroundColor(Color.TRANSPARENT);
+
+        containerView = new LinearLayout(context);
+        LayoutParams containerViewLayoutParams = new LayoutParams(
+                LayoutParams.WRAP_CONTENT,
+                LayoutParams.WRAP_CONTENT);
+        containerView.setLayoutParams(containerViewLayoutParams);
+
+        initializeLikeButton(context);
+        initializeSocialSentenceView(context);
+        initializeLikeCountView(context);
+
+        containerView.addView(likeButton);
+        containerView.addView(socialSentenceView);
+        containerView.addView(likeBoxCountView);
+
+        addView(containerView);
+
+        setObjectIdForced(this.objectId);
+        updateLikeStateAndLayout();
+    }
+
+    private void initializeLikeButton(Context context) {
+        likeButton = new LikeButton(
+                context,
+                likeActionController != null ? likeActionController.isObjectLiked() : false);
+        likeButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                toggleLike();
+            }
+        });
+
+        LinearLayout.LayoutParams buttonLayout = new LinearLayout.LayoutParams(
+                LayoutParams.WRAP_CONTENT,
+                LayoutParams.WRAP_CONTENT);
+
+        likeButton.setLayoutParams(buttonLayout);
+    }
+
+    private void initializeSocialSentenceView(Context context) {
+        socialSentenceView = new TextView(context);
+        socialSentenceView.setTextSize(
+                TypedValue.COMPLEX_UNIT_PX,
+                getResources().getDimension(R.dimen.com_facebook_likeview_text_size));
+        socialSentenceView.setMaxLines(2);
+        socialSentenceView.setTextColor(foregroundColor);
+        socialSentenceView.setGravity(Gravity.CENTER);
+
+        LinearLayout.LayoutParams socialSentenceViewLayout = new LinearLayout.LayoutParams(
+                LayoutParams.WRAP_CONTENT,
+                LayoutParams.MATCH_PARENT);
+        socialSentenceView.setLayoutParams(socialSentenceViewLayout);
+    }
+
+    private void initializeLikeCountView(Context context) {
+        likeBoxCountView = new LikeBoxCountView(context);
+
+        LinearLayout.LayoutParams likeCountViewLayout = new LinearLayout.LayoutParams(
+                LayoutParams.MATCH_PARENT,
+                LayoutParams.MATCH_PARENT);
+        likeBoxCountView.setLayoutParams(likeCountViewLayout);
+    }
+
+    private void toggleLike() {
+        if (likeActionController != null) {
+            Activity activity = (Activity)getContext();
+            likeActionController.toggleLike(activity, getAnalyticsParameters());
+        }
+    }
+
+    private Bundle getAnalyticsParameters() {
+        Bundle params = new Bundle();
+        params.putString(AnalyticsEvents.PARAMETER_LIKE_VIEW_STYLE, likeViewStyle.toString());
+        params.putString(AnalyticsEvents.PARAMETER_LIKE_VIEW_AUXILIARY_POSITION, auxiliaryViewPosition.toString());
+        params.putString(AnalyticsEvents.PARAMETER_LIKE_VIEW_HORIZONTAL_ALIGNMENT, horizontalAlignment.toString());
+        params.putString(AnalyticsEvents.PARAMETER_LIKE_VIEW_OBJECT_ID, Utility.coerceValueIfNullOrEmpty(objectId, ""));
+        return params;
+    }
+
+    private void setObjectIdForced(String newObjectId) {
+        tearDownObjectAssociations();
+
+        objectId = newObjectId;
+        if (Utility.isNullOrEmpty(newObjectId)) {
+            return;
+        }
+
+        creationCallback = new LikeActionControllerCreationCallback();
+        LikeActionController.getControllerForObjectId(
+                getContext(),
+                newObjectId,
+                creationCallback);
+    }
+
+    private void associateWithLikeActionController(LikeActionController likeActionController) {
+        this.likeActionController = likeActionController;
+
+        this.broadcastReceiver = new LikeControllerBroadcastReceiver();
+        LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(getContext());
+
+        // add the broadcast receiver
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(LikeActionController.ACTION_LIKE_ACTION_CONTROLLER_UPDATED);
+        filter.addAction(LikeActionController.ACTION_LIKE_ACTION_CONTROLLER_DID_ERROR);
+        filter.addAction(LikeActionController.ACTION_LIKE_ACTION_CONTROLLER_DID_RESET);
+
+        localBroadcastManager.registerReceiver(broadcastReceiver, filter);
+    }
+
+    private void tearDownObjectAssociations() {
+        if (broadcastReceiver != null) {
+            LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(getContext());
+            localBroadcastManager.unregisterReceiver(broadcastReceiver);
+
+            broadcastReceiver = null;
+        }
+
+        // If we were already waiting on a controller to be given back, make sure we aren't waiting anymore.
+        // Otherwise when that controller is given back to the callback, it will go and register a broadcast receiver
+        // for it.
+        if (creationCallback != null) {
+            creationCallback.cancel();
+
+            creationCallback = null;
+        }
+
+        likeActionController = null;
+    }
+
+    private void updateLikeStateAndLayout() {
+        if (likeActionController == null) {
+            likeButton.setLikeState(false);
+            socialSentenceView.setText(null);
+            likeBoxCountView.setText(null);
+        } else {
+            likeButton.setLikeState(likeActionController.isObjectLiked());
+            socialSentenceView.setText(likeActionController.getSocialSentence());
+            likeBoxCountView.setText(likeActionController.getLikeCountString());
+        }
+
+        updateLayout();
+    }
+
+    private void updateLayout() {
+        // Make sure the container is horizontally aligned according to specifications.
+        LayoutParams containerViewLayoutParams = (LayoutParams)containerView.getLayoutParams();
+        LinearLayout.LayoutParams buttonLayoutParams = (LinearLayout.LayoutParams)likeButton.getLayoutParams();
+        int viewGravity =
+                horizontalAlignment == HorizontalAlignment.LEFT ? Gravity.LEFT :
+                        horizontalAlignment == HorizontalAlignment.CENTER ? Gravity.CENTER_HORIZONTAL : Gravity.RIGHT;
+
+        containerViewLayoutParams.gravity = viewGravity | Gravity.TOP;
+        buttonLayoutParams.gravity = viewGravity;
+
+        // Choose the right auxiliary view to make visible.
+        socialSentenceView.setVisibility(GONE);
+        likeBoxCountView.setVisibility(GONE);
+
+        View auxView;
+        if (likeViewStyle == Style.STANDARD &&
+                likeActionController != null &&
+                !Utility.isNullOrEmpty(likeActionController.getSocialSentence())) {
+            auxView = socialSentenceView;
+        } else if (likeViewStyle == Style.BOX_COUNT &&
+                likeActionController != null &&
+                !Utility.isNullOrEmpty(likeActionController.getLikeCountString())) {
+            updateBoxCountCaretPosition();
+            auxView = likeBoxCountView;
+        } else {
+            // No more work to be done.
+            return;
+        }
+        auxView.setVisibility(VISIBLE);
+
+        // Now position the auxiliary view properly
+        LinearLayout.LayoutParams auxViewLayoutParams = (LinearLayout.LayoutParams)auxView.getLayoutParams();
+        auxViewLayoutParams.gravity = viewGravity;
+
+        containerView.setOrientation(
+                auxiliaryViewPosition == AuxiliaryViewPosition.INLINE ?
+                        LinearLayout.HORIZONTAL :
+                        LinearLayout.VERTICAL);
+
+        if (auxiliaryViewPosition == AuxiliaryViewPosition.TOP ||
+                (auxiliaryViewPosition == AuxiliaryViewPosition.INLINE &&
+                        horizontalAlignment == HorizontalAlignment.RIGHT)) {
+            // Button comes after the auxiliary view. Make sure it is at the end
+            containerView.removeView(likeButton);
+            containerView.addView(likeButton);
+        } else {
+            // In all other cases, the button comes first
+            containerView.removeView(auxView);
+            containerView.addView(auxView);
+        }
+
+        switch (auxiliaryViewPosition) {
+            case TOP:
+                auxView.setPadding(edgePadding, edgePadding, edgePadding, internalPadding);
+                break;
+            case BOTTOM:
+                auxView.setPadding(edgePadding, internalPadding, edgePadding, edgePadding);
+                break;
+            case INLINE:
+                if (horizontalAlignment == HorizontalAlignment.RIGHT) {
+                    auxView.setPadding(edgePadding, edgePadding, internalPadding, edgePadding);
+                } else {
+                    auxView.setPadding(internalPadding, edgePadding, edgePadding, edgePadding);
+                }
+                break;
+        }
+    }
+
+    private void updateBoxCountCaretPosition() {
+        switch (auxiliaryViewPosition) {
+            case TOP:
+                likeBoxCountView.setCaretPosition(LikeBoxCountView.LikeBoxCountViewCaretPosition.BOTTOM);
+                break;
+            case BOTTOM:
+                likeBoxCountView.setCaretPosition(LikeBoxCountView.LikeBoxCountViewCaretPosition.TOP);
+                break;
+            case INLINE:
+                likeBoxCountView.setCaretPosition(
+                        horizontalAlignment == HorizontalAlignment.RIGHT ?
+                                LikeBoxCountView.LikeBoxCountViewCaretPosition.RIGHT :
+                                LikeBoxCountView.LikeBoxCountViewCaretPosition.LEFT);
+                break;
+        }
+    }
+
+    /**
+     * Callback interface that will be called when a network or other error is encountered
+     * while logging in.
+     */
+    public interface OnErrorListener {
+        /**
+         * Called when a network or other error is encountered.
+         * @param errorBundle     a FacebookException representing the error that was encountered.
+         */
+        void onError(Bundle errorBundle);
+    }
+
+    private class LikeControllerBroadcastReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String intentAction = intent.getAction();
+            Bundle extras = intent.getExtras();
+            boolean shouldRespond = true;
+            if (extras != null) {
+                // See if an Id was set in the broadcast Intent. If it was, treat it as a filter.
+                String broadcastObjectId = extras.getString(LikeActionController.ACTION_OBJECT_ID_KEY);
+                shouldRespond = Utility.isNullOrEmpty(broadcastObjectId) ||
+                        Utility.areObjectsEqual(objectId, broadcastObjectId);
+            }
+
+            if (!shouldRespond) {
+                return;
+            }
+
+            if (LikeActionController.ACTION_LIKE_ACTION_CONTROLLER_UPDATED.equals(intentAction)) {
+                updateLikeStateAndLayout();
+            } else if (LikeActionController.ACTION_LIKE_ACTION_CONTROLLER_DID_ERROR.equals(intentAction)) {
+                if (onErrorListener != null) {
+                    onErrorListener.onError(extras);
+                }
+            } else if (LikeActionController.ACTION_LIKE_ACTION_CONTROLLER_DID_RESET.equals(intentAction)) {
+                // This will recreate the controller and associated objects
+                setObjectIdForced(objectId);
+                updateLikeStateAndLayout();
+            }
+        }
+    }
+
+    private class LikeActionControllerCreationCallback implements LikeActionController.CreationCallback {
+        private boolean isCancelled;
+
+        public void cancel() {
+            isCancelled = true;
+        }
+
+        @Override
+        public void onComplete(LikeActionController likeActionController) {
+            if (isCancelled) {
+                return;
+            }
+
+            associateWithLikeActionController(likeActionController);
+            updateLikeStateAndLayout();
+
+            LikeView.this.creationCallback = null;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/widget/WebDialog.java b/facebook/src/com/facebook/widget/WebDialog.java
index 9150f50a5..bdfb3811c 100644
--- a/facebook/src/com/facebook/widget/WebDialog.java
+++ b/facebook/src/com/facebook/widget/WebDialog.java
@@ -38,7 +38,6 @@
 import android.widget.LinearLayout;
 import com.facebook.*;
 import com.facebook.android.R;
-import com.facebook.android.Util;
 import com.facebook.internal.Logger;
 import com.facebook.internal.ServerProtocol;
 import com.facebook.internal.Utility;
@@ -52,6 +51,7 @@
 public class WebDialog extends Dialog {
     private static final String LOG_TAG = Logger.LOG_TAG_BASE + "WebDialog";
     private static final String DISPLAY_TOUCH = "touch";
+    private static final int API_EC_DIALOG_CANCEL = 4201;
     static final String REDIRECT_URI = "fbconnect://success";
     static final String CANCEL_URI = "fbconnect://cancel";
     static final boolean DISABLE_SSL_CHECK_FOR_TESTING = false;
@@ -73,6 +73,7 @@
     public static final int DEFAULT_THEME = android.R.style.Theme_Translucent_NoTitleBar;
 
     private String url;
+    private String expectedRedirectUrl = REDIRECT_URI;
     private OnCompleteListener onCompleteListener;
     private WebView webView;
     private ProgressDialog spinner;
@@ -80,6 +81,7 @@
     private FrameLayout contentFrameLayout;
     private boolean listenerCalled = false;
     private boolean isDetached = false;
+    private boolean isDismissed = false;
 
     /**
      * Interface that implements a listener to be called when the user's interaction with the
@@ -169,6 +171,19 @@ public OnCompleteListener getOnCompleteListener() {
 
     @Override
     public void dismiss() {
+        if (isDismissed) {
+            // Some paths may cause dismiss() to be called recursively. Break the loop here.
+            return;
+        }
+        isDismissed = true;
+
+        // If dismiss() was called without sending a result to the listener, let's default to a "cancel" result.
+        // This will be the case when the user taps the OS-back-button, or the cross-image, or outside the loading
+        // interstitial.
+        if (!listenerCalled) {
+            sendCancelToListener();
+        }
+
         if (webView != null) {
             webView.stopLoading();
         }
@@ -196,21 +211,13 @@ public void onAttachedToWindow() {
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
-        setOnCancelListener(new OnCancelListener() {
-            @Override
-            public void onCancel(DialogInterface dialogInterface) {
-                sendCancelToListener();
-            }
-        });
-
         spinner = new ProgressDialog(getContext());
         spinner.requestWindowFeature(Window.FEATURE_NO_TITLE);
         spinner.setMessage(getContext().getString(R.string.com_facebook_loading));
         spinner.setOnCancelListener(new OnCancelListener() {
             @Override
             public void onCancel(DialogInterface dialogInterface) {
-                sendCancelToListener();
-                WebDialog.this.dismiss();
+                dismiss();
             }
         });
 
@@ -246,6 +253,27 @@ public void onCancel(DialogInterface dialogInterface) {
         setContentView(contentFrameLayout);
     }
 
+    protected void setExpectedRedirectUrl(String expectedRedirectUrl) {
+        this.expectedRedirectUrl = expectedRedirectUrl;
+    }
+
+    protected Bundle parseResponseUri(String urlString) {
+        Uri u = Uri.parse(urlString);
+
+        Bundle b = Utility.parseUrlQueryString(u.getQuery());
+        b.putAll(Utility.parseUrlQueryString(u.getFragment()));
+
+        return b;
+    }
+
+    protected boolean isListenerCalled() {
+        return listenerCalled;
+    }
+
+    protected WebView getWebView() {
+        return webView;
+    }
+
     private void calculateSize() {
         WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
         Display display = wm.getDefaultDisplay();
@@ -292,14 +320,16 @@ private int getScaledSize(int screenSize, float density, int noPaddingSize, int
         return (int) (screenSize * scaleFactor);
     }
 
-    private void sendSuccessToListener(Bundle values) {
+    protected void sendSuccessToListener(Bundle values) {
         if (onCompleteListener != null && !listenerCalled) {
             listenerCalled = true;
             onCompleteListener.onComplete(values, null);
+
+            dismiss();
         }
     }
 
-    private void sendErrorToListener(Throwable error) {
+    protected void sendErrorToListener(Throwable error) {
         if (onCompleteListener != null && !listenerCalled) {
             listenerCalled = true;
             FacebookException facebookException = null;
@@ -309,10 +339,12 @@ private void sendErrorToListener(Throwable error) {
                 facebookException = new FacebookException(error);
             }
             onCompleteListener.onComplete(null, facebookException);
+
+            dismiss();
         }
     }
 
-    private void sendCancelToListener() {
+    protected void sendCancelToListener() {
         sendErrorToListener(new FacebookOperationCanceledException());
     }
 
@@ -322,8 +354,7 @@ private void createCrossImage() {
         crossImageView.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
-                sendCancelToListener();
-                WebDialog.this.dismiss();
+                dismiss();
             }
         });
         Drawable crossDrawable = getContext().getResources().getDrawable(R.drawable.com_facebook_close);
@@ -337,7 +368,18 @@ public void onClick(View v) {
     @SuppressLint("SetJavaScriptEnabled")
     private void setUpWebView(int margin) {
         LinearLayout webViewContainer = new LinearLayout(getContext());
-        webView = new WebView(getContext());
+        webView = new WebView(getContext()) {
+            /* Prevent NPE on Motorola 2.2 devices
+             * See https://groups.google.com/forum/?fromgroups=#!topic/android-developers/ktbwY2gtLKQ
+             */
+            @Override
+            public void onWindowFocusChanged(boolean hasWindowFocus) {
+                try {
+                    super.onWindowFocusChanged(hasWindowFocus);
+                } catch (NullPointerException e) {
+                }
+            }
+        };
         webView.setVerticalScrollBarEnabled(false);
         webView.setHorizontalScrollBarEnabled(false);
         webView.setWebViewClient(new DialogWebViewClient());
@@ -360,8 +402,8 @@ private void setUpWebView(int margin) {
         @SuppressWarnings("deprecation")
         public boolean shouldOverrideUrlLoading(WebView view, String url) {
             Utility.logd(LOG_TAG, "Redirect URL: " + url);
-            if (url.startsWith(WebDialog.REDIRECT_URI)) {
-                Bundle values = Util.parseUrl(url);
+            if (url.startsWith(WebDialog.this.expectedRedirectUrl)) {
+                Bundle values = parseResponseUri(url);
 
                 String error = values.getString("error");
                 if (error == null) {
@@ -388,16 +430,15 @@ public boolean shouldOverrideUrlLoading(WebView view, String url) {
                 } else if (error != null && (error.equals("access_denied") ||
                         error.equals("OAuthAccessDeniedException"))) {
                     sendCancelToListener();
+                } else if (errorCode == API_EC_DIALOG_CANCEL) {
+                    sendCancelToListener();
                 } else {
                     FacebookRequestError requestError = new FacebookRequestError(errorCode, error, errorMessage);
                     sendErrorToListener(new FacebookServiceException(requestError, errorMessage));
                 }
-
-                WebDialog.this.dismiss();
                 return true;
             } else if (url.startsWith(WebDialog.CANCEL_URI)) {
                 sendCancelToListener();
-                WebDialog.this.dismiss();
                 return true;
             } else if (url.contains(DISPLAY_TOUCH)) {
                 return false;
@@ -413,7 +454,6 @@ public void onReceivedError(WebView view, int errorCode,
                 String description, String failingUrl) {
             super.onReceivedError(view, errorCode, description, failingUrl);
             sendErrorToListener(new FacebookDialogException(description, errorCode, failingUrl));
-            WebDialog.this.dismiss();
         }
 
         @Override
@@ -423,9 +463,8 @@ public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError e
             } else {
                 super.onReceivedSslError(view, handler, error);
 
-                sendErrorToListener(new FacebookDialogException(null, ERROR_FAILED_SSL_HANDSHAKE, null));
                 handler.cancel();
-                WebDialog.this.dismiss();
+                sendErrorToListener(new FacebookDialogException(null, ERROR_FAILED_SSL_HANDSHAKE, null));
             }
         }
 
@@ -574,7 +613,7 @@ private void finishInit(Context context, String action, Bundle parameters) {
     }
 
     /**
-     * Provides a builder that allows construction of an arbitary Facebook web dialog.
+     * Provides a builder that allows construction of an arbitrary Facebook web dialog.
      */
     public static class Builder extends BuilderBase<Builder> {
         /**
diff --git a/facebook/tests/src/com/facebook/AppEventsLoggerTests.java b/facebook/tests/src/com/facebook/AppEventsLoggerTests.java
index c8fef2457..360b0d668 100644
--- a/facebook/tests/src/com/facebook/AppEventsLoggerTests.java
+++ b/facebook/tests/src/com/facebook/AppEventsLoggerTests.java
@@ -18,6 +18,7 @@
 
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.os.Bundle;
 import android.support.v4.content.LocalBroadcastManager;
 
 import java.io.FileInputStream;
@@ -54,6 +55,15 @@ public void run() {
             logger1.logEvent("an_event");
             logger2.logEvent("another_event");
 
+            // test illegal event name and event key, should not crash in non-debug environment.
+            logger1.logEvent("$illegal_event_name");
+            Bundle params = new Bundle();
+            params.putString("illegal%key", "good_value");
+            logger1.logEvent("legal_event_name", params);
+            char[] val = {'b', 'a', 'd'};
+            params.putCharArray("legal_key", val);
+            logger1.logEvent("legal_event",params);
+
             logger1.flush();
 
             waitForBroadcastReceiver.waitForExpectedCalls();
@@ -98,8 +108,6 @@ public void run() {
 
             assertTrue(obj instanceof HashMap);
 
-            logger1.flush();
-
             logger1.logEvent("another_event");
 
             waitForBroadcastReceiver.incrementExpectCount();
diff --git a/facebook/tests/src/com/facebook/FacebookActivityTestCase.java b/facebook/tests/src/com/facebook/FacebookActivityTestCase.java
index bd199bf5d..5ce31fc91 100644
--- a/facebook/tests/src/com/facebook/FacebookActivityTestCase.java
+++ b/facebook/tests/src/com/facebook/FacebookActivityTestCase.java
@@ -236,7 +236,7 @@ protected void setUp() throws Exception {
         super.setUp();
 
         // Make sure the logging is turned on.
-        Settings.setIsLoggingEnabled(true);
+        Settings.setIsDebugEnabled(true);
 
         // Make sure we have read application ID and secret.
         readApplicationIdAndSecret();
diff --git a/facebook/tests/src/com/facebook/WaitForBroadcastReceiver.java b/facebook/tests/src/com/facebook/WaitForBroadcastReceiver.java
index 412917b8b..5d9b998c9 100644
--- a/facebook/tests/src/com/facebook/WaitForBroadcastReceiver.java
+++ b/facebook/tests/src/com/facebook/WaitForBroadcastReceiver.java
@@ -21,6 +21,7 @@
 import android.content.Intent;
 import android.os.ConditionVariable;
 import android.os.Looper;
+
 import junit.framework.Assert;
 
 import java.util.ArrayList;
@@ -74,11 +75,14 @@ public static void waitForExpectedCalls(WaitForBroadcastReceiver... receivers) {
 
     @Override
     public void onReceive(Context context, Intent intent) {
+        receivedIntents.add(intent);
+
         if (++actualCount == expectCount) {
             condition.open();
         }
-        receivedIntents.add(intent);
-        Assert.assertTrue("expecting " + expectCount + "broadcasts, but received " + actualCount,                actualCount <= expectCount);
+
+        Assert.assertTrue("expecting " + expectCount + "broadcasts, but received " + actualCount,
+                actualCount <= expectCount);
         Assert.assertEquals("BroadcastReceiver should receive on main UI thread",
                 Thread.currentThread(), Looper.getMainLooper().getThread());
     }
diff --git a/facebook/tests/src/com/facebook/internal/BundleJSONConverterTests.java b/facebook/tests/src/com/facebook/internal/BundleJSONConverterTests.java
new file mode 100644
index 000000000..8d8971f57
--- /dev/null
+++ b/facebook/tests/src/com/facebook/internal/BundleJSONConverterTests.java
@@ -0,0 +1,147 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package com.facebook.internal;
+
+import android.os.Bundle;
+import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.FacebookTestCase;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class BundleJSONConverterTests extends FacebookTestCase {
+
+    @SmallTest
+    public void testSimpleValues() throws JSONException {
+        ArrayList<String> arrayList = new ArrayList<String>();
+        arrayList.add("1st");
+        arrayList.add("2nd");
+        arrayList.add("third");
+
+        Bundle innerBundle1 = new Bundle();
+        innerBundle1.putInt("inner", 1);
+
+        Bundle innerBundle2 = new Bundle();
+        innerBundle2.putString("inner", "2");
+        innerBundle2.putStringArray("deep list", new String[] {"7", "8"});
+
+        innerBundle1.putBundle("nested bundle", innerBundle2);
+
+
+        Bundle b = new Bundle();
+        b.putBoolean("boolValue", true);
+        b.putInt("intValue", 7);
+        b.putLong("longValue", 5000000000l);
+        b.putDouble("doubleValue", 3.14);
+        b.putString("stringValue", "hello world");
+        b.putStringArray("stringArrayValue", new String[] {"first", "second"});
+        b.putStringArrayList("stringArrayListValue", arrayList);
+        b.putBundle("nested", innerBundle1);
+
+
+        JSONObject json = BundleJSONConverter.convertToJSON(b);
+        assertNotNull(json);
+
+        assertEquals(true, json.getBoolean("boolValue"));
+        assertEquals(7, json.getInt("intValue"));
+        assertEquals(5000000000l, json.getLong("longValue"));
+        assertEquals(3.14, json.getDouble("doubleValue"));
+        assertEquals("hello world", json.getString("stringValue"));
+
+        JSONArray jsonArray = json.getJSONArray("stringArrayValue");
+        assertEquals(2, jsonArray.length());
+        assertEquals("first", jsonArray.getString(0));
+        assertEquals("second", jsonArray.getString(1));
+
+        jsonArray = json.getJSONArray("stringArrayListValue");
+        assertEquals(3, jsonArray.length());
+        assertEquals("1st", jsonArray.getString(0));
+        assertEquals("2nd", jsonArray.getString(1));
+        assertEquals("third", jsonArray.getString(2));
+
+        JSONObject innerJson = json.getJSONObject("nested");
+        assertEquals(1, innerJson.getInt("inner"));
+        innerJson = innerJson.getJSONObject("nested bundle");
+        assertEquals("2", innerJson.getString("inner"));
+
+        jsonArray = innerJson.getJSONArray("deep list");
+        assertEquals(2, jsonArray.length());
+        assertEquals("7", jsonArray.getString(0));
+        assertEquals("8", jsonArray.getString(1));
+
+        Bundle finalBundle = BundleJSONConverter.convertToBundle(json);
+        assertNotNull(finalBundle);
+
+        assertEquals(true, finalBundle.getBoolean("boolValue"));
+        assertEquals(7, finalBundle.getInt("intValue"));
+        assertEquals(5000000000l, finalBundle.getLong("longValue"));
+        assertEquals(3.14, finalBundle.getDouble("doubleValue"));
+        assertEquals("hello world", finalBundle.getString("stringValue"));
+
+        List<String> stringList = finalBundle.getStringArrayList("stringArrayValue");
+        assertEquals(2, stringList.size());
+        assertEquals("first", stringList.get(0));
+        assertEquals("second", stringList.get(1));
+
+        stringList = finalBundle.getStringArrayList("stringArrayListValue");
+        assertEquals(3, stringList.size());
+        assertEquals("1st", stringList.get(0));
+        assertEquals("2nd", stringList.get(1));
+        assertEquals("third", stringList.get(2));
+
+        Bundle finalInnerBundle = finalBundle.getBundle("nested");
+        assertEquals(1, finalInnerBundle.getInt("inner"));
+        finalBundle = finalInnerBundle.getBundle("nested bundle");
+        assertEquals("2", finalBundle.getString("inner"));
+
+        stringList = finalBundle.getStringArrayList("deep list");
+        assertEquals(2, stringList.size());
+        assertEquals("7", stringList.get(0));
+        assertEquals("8", stringList.get(1));
+    }
+
+    @SmallTest
+    public void testUnsupportedValues() throws JSONException {
+        Bundle b = new Bundle();
+        b.putShort("shortValue", (short)7);
+
+        boolean exceptionCaught = false;
+        try {
+            BundleJSONConverter.convertToJSON(b);
+        } catch (IllegalArgumentException a) {
+            exceptionCaught = true;
+        }
+        assertTrue(exceptionCaught);
+
+        JSONArray jsonArray = new JSONArray();
+        jsonArray.put(10);
+        JSONObject json = new JSONObject();
+        json.put("arrayValue", jsonArray);
+
+        exceptionCaught = false;
+        try {
+            BundleJSONConverter.convertToBundle(json);
+        } catch (IllegalArgumentException a) {
+            exceptionCaught = true;
+        }
+        assertTrue(exceptionCaught);
+    }
+}
diff --git a/facebook/tests/src/com/facebook/internal/UtilityIntersectRangeTests.java b/facebook/tests/src/com/facebook/internal/UtilityIntersectRangeTests.java
new file mode 100644
index 000000000..16584d54b
--- /dev/null
+++ b/facebook/tests/src/com/facebook/internal/UtilityIntersectRangeTests.java
@@ -0,0 +1,97 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.SmallTest;
+
+import java.util.Arrays;
+
+public class UtilityIntersectRangeTests extends AndroidTestCase {
+
+    @SmallTest
+    public void testIntersectRangesBothEmpty() {
+        int[] range1 = new int[0];
+        int[] range2 = new int[0];
+        int[] intersectRange = Utility.intersectRanges(range1, range2);
+        assertTrue(Arrays.equals(intersectRange, new int[]{}));
+    }
+
+    @SmallTest
+    public void testIntersectRangesOneEmpty() {
+        int[] range1 = new int[0];
+        int[] range2 = new int[]{1, 10};
+        int[] intersectRange = Utility.intersectRanges(range1, range2);
+        assertTrue(Arrays.equals(intersectRange, new int[]{}));
+    }
+
+    @SmallTest
+    public void testIntersectRangesBothSameAndClosed() {
+        int[] range1 = new int[]{20, 30};
+        int[] range2 = new int[]{20, 30};
+        int[] intersectRange = Utility.intersectRanges(range1, range2);
+        assertTrue(Arrays.equals(intersectRange, new int[]{20, 30}));
+    }
+
+    @SmallTest
+    public void testIntersectRangesNoIntersect() {
+        int[] range1 = new int[]{20, 30};
+        int[] range2 = new int[]{30, 50};
+        int[] intersectRange = Utility.intersectRanges(range1, range2);
+        assertTrue(Arrays.equals(intersectRange, new int[]{}));
+    }
+
+    @SmallTest
+    public void testIntersectRangesSubsets() {
+        int[] range1 = new int[]{20, 100};
+        int[] range2 = new int[]{30, 40, 50, 60, 99, 100};
+        int[] intersectRange = Utility.intersectRanges(range1, range2);
+        assertTrue(Arrays.equals(intersectRange, new int[]{30, 40, 50, 60, 99, 100}));
+    }
+
+    @SmallTest
+    public void testIntersectRangesOverlap() {
+        int[] range1 = new int[]{20, 40, 60, 80};
+        int[] range2 = new int[]{10, 30, 50, 70};
+        int[] intersectRange = Utility.intersectRanges(range1, range2);
+        assertTrue(Arrays.equals(intersectRange, new int[]{20, 30, 60, 70}));
+    }
+
+    @SmallTest
+    public void testIntersectRangesDifferentLengthsClosed() {
+        int[] range1 = new int[]{20, 40, 60, 80};
+        int[] range2 = new int[]{10, 30, 50, 70, 90, 110};
+        int[] intersectRange = Utility.intersectRanges(range1, range2);
+        assertTrue(Arrays.equals(intersectRange, new int[]{20, 30, 60, 70}));
+    }
+
+    @SmallTest
+    public void testIntersectRangesDifferentLengthsOneOpen() {
+        int[] range1 = new int[]{10, 30, 50, 70, 90, 110};
+        int[] range2 = new int[]{20, 40, 60};
+        int[] intersectRange = Utility.intersectRanges(range1, range2);
+        assertTrue(Arrays.equals(intersectRange, new int[]{20, 30, 60, 70, 90, 110}));
+    }
+
+    @SmallTest
+    public void testIntersectRangesDifferentLengthsBothOpen() {
+        int[] range1 = new int[]{10, 30, 50};
+        int[] range2 = new int[]{20, 40, 60};
+        int[] intersectRange = Utility.intersectRanges(range1, range2);
+        assertTrue(Arrays.equals(intersectRange, new int[]{20, 30, 60}));
+    }
+}
diff --git a/samples/RPSSample/src/com/facebook/samples/rps/MainActivity.java b/samples/RPSSample/src/com/facebook/samples/rps/MainActivity.java
index b26dd6489..f40594da7 100644
--- a/samples/RPSSample/src/com/facebook/samples/rps/MainActivity.java
+++ b/samples/RPSSample/src/com/facebook/samples/rps/MainActivity.java
@@ -29,9 +29,6 @@
 import bolts.AppLinks;
 import com.facebook.*;
 
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
 import static com.facebook.samples.rps.RpsGameUtils.INVALID_CHOICE;
 
 public class MainActivity extends FragmentActivity {
@@ -202,7 +199,7 @@ private boolean handleNativeLink() {
     }
 
     private int getAppLinkGesture(Intent intent) {
-      Uri targetURI = AppLinks.getTargetUrl(intent);
+      Uri targetURI = AppLinks.getTargetUrlFromInboundIntent(this, intent);
       if (targetURI == null) {
         return INVALID_CHOICE;
       }
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/PickerActivity.java b/samples/Scrumptious/src/com/facebook/scrumptious/PickerActivity.java
index 3522da5b2..e795698e4 100644
--- a/samples/Scrumptious/src/com/facebook/scrumptious/PickerActivity.java
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/PickerActivity.java
@@ -147,8 +147,12 @@ protected void onStart() {
                         locationListener = new LocationListener() {
                             @Override
                             public void onLocationChanged(Location location) {
-                                float distance = location.distanceTo(placePickerFragment.getLocation());
-                                if (distance >= LOCATION_CHANGE_THRESHOLD) {
+                                boolean updateLocation = true;
+                                Location prevLocation = placePickerFragment.getLocation();
+                                if (prevLocation != null) {
+                                    updateLocation = location.distanceTo(prevLocation) >= LOCATION_CHANGE_THRESHOLD;
+                                }
+                                if (updateLocation) {
                                     placePickerFragment.setLocation(location);
                                     placePickerFragment.loadData(true);
                                 }
diff --git a/settings.gradle b/settings.gradle
index 09b84aeee..e12211bd7 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -21,4 +21,7 @@ project(':Scrumptious').projectDir = new File('samples/Scrumptious')
 include 'SwitchUserSample'
 project(':SwitchUserSample').projectDir = new File('samples/SwitchUserSample')
 
+if (file('internal/internal-settings.gradle').exists()) {
+  apply from: 'internal/internal-settings.gradle'
+}
 
