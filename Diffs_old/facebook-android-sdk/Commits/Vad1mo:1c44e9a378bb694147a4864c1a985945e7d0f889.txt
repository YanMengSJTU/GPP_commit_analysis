diff --git a/.gitignore b/.gitignore
index afd03db53..d67742076 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,18 +2,16 @@
 *.DS_Store
 *.class
 *java#
-*.classpath
-*.project
 *.settings
-facebook/local.properties
-facebook/bin/
-facebook/gen/
-examples/Hackbook/bin/
-examples/Hackbook/gen/
-examples/Hackbook/local.properties
-examples/stream/bin/
-examples/simple/bin/
-examples/stream/gen/
-examples/simple/gen/
-tests/bin
-tests/gen
+local.properties
+.arc/
+bin/
+gen/
+out/
+facebook/doc/
+facebook/lint.xml
+facebook/tests/lint.xml
+facebook/tests/assets/config.json
+.idea/workspace.xml
+.idea/dictionaries/
+.idea/inspectionProfiles/
diff --git a/.idea/.name b/.idea/.name
new file mode 100644
index 000000000..20f69a2ae
--- /dev/null
+++ b/.idea/.name
@@ -0,0 +1 @@
+android-sdk
\ No newline at end of file
diff --git a/.idea/ant.xml b/.idea/ant.xml
new file mode 100644
index 000000000..2581ca3fe
--- /dev/null
+++ b/.idea/ant.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="AntConfiguration">
+    <defaultAnt bundledAnt="true" />
+  </component>
+</project>
+
diff --git a/.idea/codeStyleSettings.xml b/.idea/codeStyleSettings.xml
new file mode 100644
index 000000000..3bf548318
--- /dev/null
+++ b/.idea/codeStyleSettings.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectCodeStyleSettingsManager">
+    <option name="PER_PROJECT_SETTINGS">
+      <value>
+        <XML>
+          <option name="XML_LEGACY_SETTINGS_IMPORTED" value="true" />
+        </XML>
+        <codeStyleSettings language="JAVA">
+          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="CALL_PARAMETERS_WRAP" value="1" />
+          <option name="METHOD_PARAMETERS_WRAP" value="1" />
+          <option name="METHOD_CALL_CHAIN_WRAP" value="1" />
+        </codeStyleSettings>
+      </value>
+    </option>
+    <option name="USE_PER_PROJECT_SETTINGS" value="true" />
+  </component>
+</project>
+
diff --git a/.idea/compiler.xml b/.idea/compiler.xml
new file mode 100644
index 000000000..02e121244
--- /dev/null
+++ b/.idea/compiler.xml
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="CompilerConfiguration">
+    <option name="DEFAULT_COMPILER" value="Eclipse" />
+    <excludeFromCompile>
+      <directory url="file://$PROJECT_DIR$/facebook/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/GraphApiSample/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/examples/Hackbook/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/facebook/TestApp/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/facebook/tests/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/testtest/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/SessionLoginSample/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/FriendPickerSample/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/PlacePickerSample/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/BooleanOGSample/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/ProfilePictureSample/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/Scrumptious/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/SwitchUserSample/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/HelloFacebookSample/gen" includeSubdirectories="true" />
+      <directory url="file://$PROJECT_DIR$/samples/Hackbook/gen" includeSubdirectories="true" />
+    </excludeFromCompile>
+    <resourceExtensions />
+    <wildcardResourcePatterns>
+      <entry name="?*.properties" />
+      <entry name="?*.xml" />
+      <entry name="?*.gif" />
+      <entry name="?*.png" />
+      <entry name="?*.jpeg" />
+      <entry name="?*.jpg" />
+      <entry name="?*.html" />
+      <entry name="?*.dtd" />
+      <entry name="?*.tld" />
+      <entry name="?*.ftl" />
+    </wildcardResourcePatterns>
+    <annotationProcessing enabled="false" useClasspath="true" />
+  </component>
+</project>
+
diff --git a/.idea/copyright/profiles_settings.xml b/.idea/copyright/profiles_settings.xml
new file mode 100644
index 000000000..3572571ad
--- /dev/null
+++ b/.idea/copyright/profiles_settings.xml
@@ -0,0 +1,5 @@
+<component name="CopyrightManager">
+  <settings default="">
+    <module2copyright />
+  </settings>
+</component>
\ No newline at end of file
diff --git a/.idea/encodings.xml b/.idea/encodings.xml
new file mode 100644
index 000000000..e206d70d8
--- /dev/null
+++ b/.idea/encodings.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Encoding" useUTFGuessing="true" native2AsciiForPropertiesFiles="false" />
+</project>
+
diff --git a/.idea/libraries/android_support_v4.xml b/.idea/libraries/android_support_v4.xml
new file mode 100644
index 000000000..7abf0b359
--- /dev/null
+++ b/.idea/libraries/android_support_v4.xml
@@ -0,0 +1,19 @@
+<component name="libraryTable">
+  <library name="android-support-v4">
+    <CLASSES>
+      <root url="jar://$PROJECT_DIR$/libs/android-support-v4.jar!/" />
+    </CLASSES>
+    <JAVADOC />
+    <SOURCES>
+      <root url="file://$PROJECT_DIR$/../android-sdk-macosx/extras/android/support/v4/src/eclair" />
+      <root url="file://$PROJECT_DIR$/../android-sdk-macosx/extras/android/support/v4/src/froyo" />
+      <root url="file://$PROJECT_DIR$/../android-sdk-macosx/extras/android/support/v4/src/gingerbread" />
+      <root url="file://$PROJECT_DIR$/../android-sdk-macosx/extras/android/support/v4/src/honeycomb" />
+      <root url="file://$PROJECT_DIR$/../android-sdk-macosx/extras/android/support/v4/src/honeycomb_mr2" />
+      <root url="file://$PROJECT_DIR$/../android-sdk-macosx/extras/android/support/v4/src/ics" />
+      <root url="file://$PROJECT_DIR$/../android-sdk-macosx/extras/android/support/v4/src/ics-mr1" />
+      <root url="file://$PROJECT_DIR$/../android-sdk-macosx/extras/android/support/v4/src/java" />
+      <root url="file://$PROJECT_DIR$/../android-sdk-macosx/extras/android/support/v4/src/jellybean" />
+    </SOURCES>
+  </library>
+</component>
\ No newline at end of file
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
index 000000000..95a5c34d4
--- /dev/null
+++ b/.idea/misc.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="EntryPointsManager">
+    <entry_points version="2.0" />
+  </component>
+  <component name="JavadocGenerationManager">
+    <option name="OUTPUT_DIRECTORY" value="$USER_HOME$/tmp/javadoc.out" />
+    <option name="OPTION_SCOPE" value="protected" />
+    <option name="OPTION_HIERARCHY" value="true" />
+    <option name="OPTION_NAVIGATOR" value="true" />
+    <option name="OPTION_INDEX" value="true" />
+    <option name="OPTION_SEPARATE_INDEX" value="true" />
+    <option name="OPTION_DOCUMENT_TAG_USE" value="false" />
+    <option name="OPTION_DOCUMENT_TAG_AUTHOR" value="false" />
+    <option name="OPTION_DOCUMENT_TAG_VERSION" value="false" />
+    <option name="OPTION_DOCUMENT_TAG_DEPRECATED" value="true" />
+    <option name="OPTION_DEPRECATED_LIST" value="true" />
+    <option name="OTHER_OPTIONS" />
+    <option name="HEAP_SIZE" />
+    <option name="LOCALE" />
+    <option name="OPEN_IN_BROWSER" value="true" />
+    <option name="OPTION_INCLUDE_LIBS" value="false" />
+  </component>
+  <component name="ProjectResources">
+    <default-html-doctype>http://www.w3.org/1999/xhtml</default-html-doctype>
+  </component>
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_6" assert-keyword="true" jdk-15="true" project-jdk-name="Android 2.2 Platform" project-jdk-type="Android SDK">
+    <output url="file://$PROJECT_DIR$/out" />
+  </component>
+</project>
+
diff --git a/.idea/modules.xml b/.idea/modules.xml
new file mode 100644
index 000000000..d6163f7ac
--- /dev/null
+++ b/.idea/modules.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/samples/BooleanOGSample/BooleanOGSample.iml" filepath="$PROJECT_DIR$/samples/BooleanOGSample/BooleanOGSample.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/FriendPickerSample/FriendPickerSample.iml" filepath="$PROJECT_DIR$/samples/FriendPickerSample/FriendPickerSample.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/GraphApiSample/GraphApiSample.iml" filepath="$PROJECT_DIR$/samples/GraphApiSample/GraphApiSample.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/Hackbook/Hackbook.iml" filepath="$PROJECT_DIR$/samples/Hackbook/Hackbook.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/HelloFacebookSample/HelloFacebookSample.iml" filepath="$PROJECT_DIR$/samples/HelloFacebookSample/HelloFacebookSample.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/PlacePickerSample/PlacePickerSample.iml" filepath="$PROJECT_DIR$/samples/PlacePickerSample/PlacePickerSample.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/ProfilePictureSample/ProfilePictureSample.iml" filepath="$PROJECT_DIR$/samples/ProfilePictureSample/ProfilePictureSample.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/Scrumptious/Scrumptious.iml" filepath="$PROJECT_DIR$/samples/Scrumptious/Scrumptious.iml" />
+      <module fileurl="file://$PROJECT_DIR$/facebook/TestApp/SdkTestApp.iml" filepath="$PROJECT_DIR$/facebook/TestApp/SdkTestApp.iml" />
+      <module fileurl="file://$PROJECT_DIR$/facebook/tests/SdkTests.iml" filepath="$PROJECT_DIR$/facebook/tests/SdkTests.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/SessionLoginSample/SessionLoginSample.iml" filepath="$PROJECT_DIR$/samples/SessionLoginSample/SessionLoginSample.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/SwitchUserSample/SwitchUserSample.iml" filepath="$PROJECT_DIR$/samples/SwitchUserSample/SwitchUserSample.iml" />
+      <module fileurl="file://$PROJECT_DIR$/facebook/android-sdk.iml" filepath="$PROJECT_DIR$/facebook/android-sdk.iml" />
+    </modules>
+  </component>
+</project>
+
diff --git a/.idea/scopes/scope_settings.xml b/.idea/scopes/scope_settings.xml
new file mode 100644
index 000000000..922003b84
--- /dev/null
+++ b/.idea/scopes/scope_settings.xml
@@ -0,0 +1,5 @@
+<component name="DependencyValidationManager">
+  <state>
+    <option name="SKIP_IMPORT_STATEMENTS" value="false" />
+  </state>
+</component>
\ No newline at end of file
diff --git a/.idea/uiDesigner.xml b/.idea/uiDesigner.xml
new file mode 100644
index 000000000..3b0002030
--- /dev/null
+++ b/.idea/uiDesigner.xml
@@ -0,0 +1,125 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Palette2">
+    <group name="Swing">
+      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />
+      </item>
+      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />
+      </item>
+      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.png" removable="false" auto-create-binding="false" can-attach-label="true">
+        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />
+        <initial-values>
+          <property name="text" value="Button" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="RadioButton" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="CheckBox" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="Label" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
+          <preferred-size width="200" height="200" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
+          <preferred-size width="200" height="200" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />
+      </item>
+      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">
+          <preferred-size width="-1" height="20" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />
+      </item>
+      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />
+      </item>
+    </group>
+  </component>
+</project>
+
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
index 000000000..9d32e507a
--- /dev/null
+++ b/.idea/vcs.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="" vcs="" />
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+  </component>
+</project>
+
diff --git a/CONTRIBUTING.mdown b/CONTRIBUTING.mdown
new file mode 100644
index 000000000..ec5ea367e
--- /dev/null
+++ b/CONTRIBUTING.mdown
@@ -0,0 +1,15 @@
+Facebook welcomes contributions to our SDKs.
+
+All contributors must sign a CLA (contributor license agreement) here:
+
+  https://developers.facebook.com/opensource/cla
+
+To contribute on behalf of your employer, sign the company CLA
+To contribute on behalf of yourself, sign the individual CLA
+
+All contributions:
+
+1/ MUST be be licensed using the Apache License, Version 2.0  
+2/ authors MAY retain copyright by adding their copyright notice to the appropriate flies 
+
+More information on the Apache License can be found here: http://www.apache.org/foundation/license-faq.html
diff --git a/LICENSE.txt b/LICENSE.txt
new file mode 100644
index 000000000..261eeb9e9
--- /dev/null
+++ b/LICENSE.txt
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/NOTICE.txt b/NOTICE.txt
new file mode 100644
index 000000000..8a7b5c546
--- /dev/null
+++ b/NOTICE.txt
@@ -0,0 +1,61 @@
+THE FOLLOWING SETS FORTH ATTRIBUTION NOTICES FOR THIRD PARTY SOFTWARE THAT MAY BE CONTAINED IN PORTIONS OF THE FACEBOOK PRODUCT.
+
+-----
+
+The following software may be included in this product: Android. This software contains the following license and notice below:
+
+Apache License
+Version 2.0, January 2004
+http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+1. Definitions.
+
+"License" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.
+
+"Licensor" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.
+
+"Legal Entity" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, "control" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.
+
+"You" (or "Your") shall mean an individual or Legal Entity exercising permissions granted by this License.
+
+"Source" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.
+
+"Object" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.
+
+"Work" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).
+
+"Derivative Works" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.
+
+"Contribution" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, "submitted" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as "Not a Contribution."
+
+"Contributor" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.
+
+2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.
+
+3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.
+
+4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:
+
+(a) You must give any other recipients of the Work or Derivative Works a copy of this License; and
+
+(b) You must cause any modified files to carry prominent notices stating that You changed the files; and
+
+(c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and
+
+(d) If the Work includes a "NOTICE" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.
+
+You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.
+
+5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.
+
+6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.
+
+7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.
+
+8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.
+
+9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.
+
+END OF TERMS AND CONDITIONS
diff --git a/README.md b/README.md
deleted file mode 100644
index fcfc937a5..000000000
--- a/README.md
+++ /dev/null
@@ -1,24 +0,0 @@
-This open source Java library allows you to integrate Facebook into your Android application. Except as otherwise noted, the Facebook Android SDK is licensed under the Apache License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0.html)
-
-Getting Started
-===============
-
-See our [Android SDK Getting Started Guide](https://developers.facebook.com/docs/mobile/android/build/)
-
-Sample Applications
-===============
-
-This library includes three sample applications to guide you in development.
-
-* __simple__: A bare-bones app that demonstrates authorization, making API calls, and invoking a dialog.
-
-* __stream__: This slightly beefier application lets you view your news feed.
-
-* __Hackbook__: This includes Single Sign On implementation (SSO), sample API calls, and advanced features like Get new Permissions, Run sample FQL Query and Graph API Explorer. Check out [Hackbook for Android](https://developers.facebook.com/docs/mobile/android/hackbook/)
-
-
-Report Issues/Bugs
-===============
-[Bugs](https://developers.facebook.com/bugs)
-
-[Questions](http://facebook.stackoverflow.com/questions/tagged/android)
diff --git a/README.mdown b/README.mdown
new file mode 100644
index 000000000..7e4bb9b02
--- /dev/null
+++ b/README.mdown
@@ -0,0 +1,32 @@
+Facebook SDK for Android
+========================
+
+This open-source library allows you to integrate Facebook into your Android app.
+
+Learn more about about the provided samples, documentation, integrating the SDK into your app, accessing source code, and more at https://developers.facebook.com/android-beta
+
+TRY IT OUT
+
+1. Test your install; build and run the project at facebook-android-sdk-3.0.b/samples/HelloFacebookSample (To avoid test signing issues, run this on a device that does not have Facebook for Android installed, or debug the signed sample binaries provided in facebook-android-sdk-3.0.b/bin)
+
+2. Check-out the tutorials available online at https://developers.facebook.com/docs/getting-started/facebook-sdk-for-android/3.0/
+
+3. Start coding! Visit https://developers.facebook.com/android-beta for tutorials and reference documentation.
+
+LICENSE
+
+Except as otherwise noted, the Facebook SDK for Android is licensed under the Apache License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0.html).
+
+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the specific language governing permissions and limitations under the License.
+
+DEVELOPER TERMS
+
+- By enabling Facebook integrations, including through this SDK, you can share information with Facebook, including information about people’s use of your app. Facebook will use information received in accordance with our Data Use Policy (https://www.facebook.com/about/privacy/), including to provide you with insights about the effectiveness of your ads and the use of your app.  These integrations also enable us and our partners to serve ads on and off Facebook.
+
+- You may limit your sharing of information with us by updating the Insights control in the developer tool (https://developers.facebook.com/apps/<app_id>/advanced).
+
+- If you use a Facebook integration, including to share information with us, you agree and confirm that you have provided appropriate and sufficiently prominent notice to and obtained the appropriate consent from your users regarding such collection, use, and disclosure (including, at a minimum, through your privacy policy). You further agree that you will not share information with us about children under the age of 13.
+
+- You agree to comply with all applicable laws and regulations and also agree to our Terms (https://www.facebook.com/policies/), including our Platform Policies (https://developers.facebook.com/policy/) and Advertising Guidelines, as applicable (https://www.facebook.com/ad_guidelines.php).
+
+By using the Facebook SDK for Android you agree to these terms.
diff --git a/examples/Hackbook/res/drawable/login_button.xml b/examples/Hackbook/res/drawable/login_button.xml
deleted file mode 100644
index 73dc6c3ab..000000000
--- a/examples/Hackbook/res/drawable/login_button.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<selector xmlns:android="http://schemas.android.com/apk/res/android">
-	<item android:state_pressed="true" android:drawable="@drawable/login_down" />
-	<item android:drawable="@drawable/login" /> <!-- default -->
-</selector>
\ No newline at end of file
diff --git a/examples/Hackbook/res/drawable/logout_button.xml b/examples/Hackbook/res/drawable/logout_button.xml
deleted file mode 100644
index 58f57656b..000000000
--- a/examples/Hackbook/res/drawable/logout_button.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<selector xmlns:android="http://schemas.android.com/apk/res/android">
-    <item android:state_pressed="true" android:drawable="@drawable/logout_down" />
-    <item android:drawable="@drawable/logout" /> <!-- default -->
-</selector>
\ No newline at end of file
diff --git a/examples/Hackbook/res/layout/connection_item.xml b/examples/Hackbook/res/layout/connection_item.xml
deleted file mode 100644
index e556c0685..000000000
--- a/examples/Hackbook/res/layout/connection_item.xml
+++ /dev/null
@@ -1,11 +0,0 @@
-<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="fill_parent"
-    android:layout_height="?android:attr/listPreferredItemHeight">
-    <TextView
-        android:id="@+id/connection_name"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:textSize="26sp"
-        android:textColor="@color/lite_blue"
-        android:paddingLeft="5dp" />
-</RelativeLayout>
diff --git a/examples/Hackbook/res/layout/fields_item.xml b/examples/Hackbook/res/layout/fields_item.xml
deleted file mode 100644
index c072d7bd2..000000000
--- a/examples/Hackbook/res/layout/fields_item.xml
+++ /dev/null
@@ -1,14 +0,0 @@
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:orientation="vertical"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
-    android:background="@color/black">
-    <CheckBox
-        android:id="@+id/fields_checkbox"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content" />
-    <TextView
-        android:id="@+id/fields_info"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content" />
-</LinearLayout>
diff --git a/examples/Hackbook/res/layout/friends_list.xml b/examples/Hackbook/res/layout/friends_list.xml
deleted file mode 100644
index 82e565181..000000000
--- a/examples/Hackbook/res/layout/friends_list.xml
+++ /dev/null
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:orientation="vertical"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
-    android:background="@color/black">
-    <ListView
-        android:id="@+id/friends_list"
-        android:layout_width="fill_parent"
-        android:layout_height="fill_parent" />
- </LinearLayout>
diff --git a/examples/Hackbook/res/layout/main_list_item.xml b/examples/Hackbook/res/layout/main_list_item.xml
deleted file mode 100644
index 2ac0fac97..000000000
--- a/examples/Hackbook/res/layout/main_list_item.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-<TextView xmlns:android="http://schemas.android.com/apk/res/android"
-    android:id="@+id/main_api_item"
-    android:padding="10dip"
-    android:layout_width="fill_parent"
-    android:layout_height="wrap_content"
-    android:layout_alignParentRight="true"
-    android:layout_alignParentTop="true"
-    android:gravity="center_vertical"
-    android:textSize="20sp" />
diff --git a/examples/Hackbook/res/layout/permission_item.xml b/examples/Hackbook/res/layout/permission_item.xml
deleted file mode 100644
index 57eb43a8b..000000000
--- a/examples/Hackbook/res/layout/permission_item.xml
+++ /dev/null
@@ -1,8 +0,0 @@
-<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="fill_parent"
-    android:layout_height="?android:attr/listPreferredItemHeight">
-    <CheckBox
-        android:id="@+id/permission_checkbox"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content" />
-</RelativeLayout>
diff --git a/examples/Hackbook/res/layout/places_list.xml b/examples/Hackbook/res/layout/places_list.xml
deleted file mode 100644
index f63bb2884..000000000
--- a/examples/Hackbook/res/layout/places_list.xml
+++ /dev/null
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:orientation="vertical"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
-    android:background="@color/black">
-    <ListView
-        android:id="@+id/places_list"
-        android:layout_width="fill_parent"
-        android:layout_height="fill_parent" />
- </LinearLayout>
diff --git a/examples/Hackbook/res/layout/splash.xml b/examples/Hackbook/res/layout/splash.xml
deleted file mode 100644
index 211860639..000000000
--- a/examples/Hackbook/res/layout/splash.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<ImageView android:id="@+id/imageView1" xmlns:android="http://schemas.android.com/apk/res/android"
-    android:src="@drawable/splash"
-    android:scaleType="fitXY"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent" />
diff --git a/examples/Hackbook/res/values/colors.xml b/examples/Hackbook/res/values/colors.xml
deleted file mode 100644
index cb999e5cc..000000000
--- a/examples/Hackbook/res/values/colors.xml
+++ /dev/null
@@ -1,10 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <color name="white">#ffffff</color>
-    <color name="black">#000000</color>
-    <color name="green">#23cf34</color>
-    <color name="orange">#E47833</color>
-    <color name="lite_blue">#4E78A0</color>
-    <color name="blue">#0000FF</color>
-    <color name="grey">#FF909090</color>
-</resources>
\ No newline at end of file
diff --git a/examples/Hackbook/src/com/facebook/android/BaseDialogListener.java b/examples/Hackbook/src/com/facebook/android/BaseDialogListener.java
deleted file mode 100644
index dbd5b3360..000000000
--- a/examples/Hackbook/src/com/facebook/android/BaseDialogListener.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package com.facebook.android;
-
-import com.facebook.android.Facebook.DialogListener;
-
-/**
- * Skeleton base class for RequestListeners, providing default error handling.
- * Applications should handle these error conditions.
- */
-public abstract class BaseDialogListener implements DialogListener {
-
-    @Override
-    public void onFacebookError(FacebookError e) {
-        e.printStackTrace();
-    }
-
-    @Override
-    public void onError(DialogError e) {
-        e.printStackTrace();
-    }
-
-    @Override
-    public void onCancel() {
-    }
-
-}
\ No newline at end of file
diff --git a/examples/simple/AndroidManifest.xml b/examples/simple/AndroidManifest.xml
deleted file mode 100644
index f647de1aa..000000000
--- a/examples/simple/AndroidManifest.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-	package="com.facebook.android" 
-	android:versionCode="1"
-	android:versionName="1.0">
-	<application android:icon="@drawable/icon" 
-	    android:label="@string/app_name"
-		android:debuggable="true">
-		<activity android:name=".Example" 
-		    android:label="@string/app_name"
-		    android:configChanges="keyboardHidden">
-			<intent-filter>
-				<action android:name="android.intent.action.MAIN" />
-				<category android:name="android.intent.category.LAUNCHER" />
-			</intent-filter>
-		</activity>
-	</application>
-	<uses-permission android:name="android.permission.INTERNET"></uses-permission>
-	<uses-sdk android:minSdkVersion="3"/>
-</manifest> 
\ No newline at end of file
diff --git a/examples/simple/default.properties b/examples/simple/default.properties
deleted file mode 100644
index 0f4dfe443..000000000
--- a/examples/simple/default.properties
+++ /dev/null
@@ -1,14 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-# 
-# This file must be checked in Version Control Systems.
-# 
-# To customize properties used by the Ant build system use,
-# "build.properties", and override values to adapt the script to your
-# project structure.
-
-# Indicates whether an apk should be generated for each density.
-split.density=false
-android.library.reference.1=../../facebook/
-# Project target.
-target=android-3
diff --git a/examples/simple/res/drawable/login.png b/examples/simple/res/drawable/login.png
deleted file mode 100644
index 95c8dc156..000000000
Binary files a/examples/simple/res/drawable/login.png and /dev/null differ
diff --git a/examples/simple/res/drawable/login_button.xml b/examples/simple/res/drawable/login_button.xml
deleted file mode 100644
index 73dc6c3ab..000000000
--- a/examples/simple/res/drawable/login_button.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<selector xmlns:android="http://schemas.android.com/apk/res/android">
-	<item android:state_pressed="true" android:drawable="@drawable/login_down" />
-	<item android:drawable="@drawable/login" /> <!-- default -->
-</selector>
\ No newline at end of file
diff --git a/examples/simple/res/drawable/login_down.png b/examples/simple/res/drawable/login_down.png
deleted file mode 100644
index 10d216b3f..000000000
Binary files a/examples/simple/res/drawable/login_down.png and /dev/null differ
diff --git a/examples/simple/res/drawable/logout.png b/examples/simple/res/drawable/logout.png
deleted file mode 100644
index 290272aa0..000000000
Binary files a/examples/simple/res/drawable/logout.png and /dev/null differ
diff --git a/examples/simple/res/drawable/logout_button.xml b/examples/simple/res/drawable/logout_button.xml
deleted file mode 100644
index 58f57656b..000000000
--- a/examples/simple/res/drawable/logout_button.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<selector xmlns:android="http://schemas.android.com/apk/res/android">
-    <item android:state_pressed="true" android:drawable="@drawable/logout_down" />
-    <item android:drawable="@drawable/logout" /> <!-- default -->
-</selector>
\ No newline at end of file
diff --git a/examples/simple/res/drawable/logout_down.png b/examples/simple/res/drawable/logout_down.png
deleted file mode 100644
index 1ab14b9dc..000000000
Binary files a/examples/simple/res/drawable/logout_down.png and /dev/null differ
diff --git a/examples/simple/res/layout/main.xml b/examples/simple/res/layout/main.xml
deleted file mode 100644
index b73286a71..000000000
--- a/examples/simple/res/layout/main.xml
+++ /dev/null
@@ -1,65 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-	android:orientation="vertical" android:layout_width="fill_parent"
-	android:layout_height="fill_parent" android:background="@drawable/white"
-	android:gravity="center_horizontal">
-
-    <com.facebook.android.LoginButton
-        android:id="@+id/login"
-        android:src="@drawable/login_button"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content" 
-        android:layout_margin="30dp"
-        />
-
-	<TextView android:id="@+id/txt" 
-        android:text="@string/hello"
-        android:textColor="@drawable/black"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-		/>
-		
-	<Button android:id="@+id/uploadButton"
-        android:text="@string/upload"
-        android:visibility="invisible"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content" 
-        android:paddingRight="20dp" 
-        android:paddingLeft="20dp"
-        android:layout_margin="20dp" 
-        />
-        
-	<Button android:id="@+id/requestButton"
-        android:text="@string/request"
-        android:visibility="invisible"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content" 
-        android:paddingRight="20dp" 
-        android:paddingLeft="20dp"
-        android:layout_margin="20dp" 
-        />
-
-
-	<Button android:id="@+id/postButton" 
-        android:text="@string/post"
-        android:visibility="invisible"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content" 
-        android:paddingRight="20dp" 
-        android:paddingLeft="20dp"
-        android:layout_margin="20dp" 
-		/>
-		
-    <Button android:id="@+id/deletePostButton" 
-        android:text="@string/delete"
-        android:visibility="invisible"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content" 
-        android:paddingRight="20dp" 
-        android:paddingLeft="20dp"
-        android:layout_margin="20dp" 
-        />
-
-
-
-</LinearLayout>
\ No newline at end of file
diff --git a/examples/simple/res/values/colors.xml b/examples/simple/res/values/colors.xml
deleted file mode 100644
index 2aa7e8e36..000000000
--- a/examples/simple/res/values/colors.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <drawable name="white">#ffffff</drawable>
-    <drawable name="black">#000000</drawable>
-</resources>
\ No newline at end of file
diff --git a/examples/simple/res/values/strings.xml b/examples/simple/res/values/strings.xml
deleted file mode 100644
index ced6f8b47..000000000
--- a/examples/simple/res/values/strings.xml
+++ /dev/null
@@ -1,10 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <string name="app_name">Facebook SDK Example</string>
-    <string name="request">Request!</string>
-    <string name="hello">Hello World!</string>
-    <string name="upload">Upload Photo</string><string name="post">Wall Post!</string>
-    <string name="delete">Delete Post</string>
-
-
-</resources>
diff --git a/examples/simple/src/com/facebook/android/BaseDialogListener.java b/examples/simple/src/com/facebook/android/BaseDialogListener.java
deleted file mode 100644
index 6b4b9453d..000000000
--- a/examples/simple/src/com/facebook/android/BaseDialogListener.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package com.facebook.android;
-
-import com.facebook.android.Facebook.DialogListener;
-
-/**
- * Skeleton base class for RequestListeners, providing default error 
- * handling. Applications should handle these error conditions.
- *
- */
-public abstract class BaseDialogListener implements DialogListener {
-
-    public void onFacebookError(FacebookError e) {
-        e.printStackTrace();
-    }
-
-    public void onError(DialogError e) {
-        e.printStackTrace();        
-    }
-
-    public void onCancel() {        
-    }
-    
-}
diff --git a/examples/simple/src/com/facebook/android/BaseRequestListener.java b/examples/simple/src/com/facebook/android/BaseRequestListener.java
deleted file mode 100644
index bd0f80f99..000000000
--- a/examples/simple/src/com/facebook/android/BaseRequestListener.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package com.facebook.android;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.net.MalformedURLException;
-
-import android.util.Log;
-
-import com.facebook.android.AsyncFacebookRunner.RequestListener;
-
-/**
- * Skeleton base class for RequestListeners, providing default error 
- * handling. Applications should handle these error conditions.
- *
- */
-public abstract class BaseRequestListener implements RequestListener {
-
-    public void onFacebookError(FacebookError e, final Object state) {
-        Log.e("Facebook", e.getMessage());
-        e.printStackTrace();
-    }
-
-    public void onFileNotFoundException(FileNotFoundException e,
-                                        final Object state) {
-        Log.e("Facebook", e.getMessage());
-        e.printStackTrace();
-    }
-
-    public void onIOException(IOException e, final Object state) {
-        Log.e("Facebook", e.getMessage());
-        e.printStackTrace();
-    }
-
-    public void onMalformedURLException(MalformedURLException e,
-                                        final Object state) {
-        Log.e("Facebook", e.getMessage());
-        e.printStackTrace();
-    }
-    
-}
diff --git a/examples/simple/src/com/facebook/android/Example.java b/examples/simple/src/com/facebook/android/Example.java
deleted file mode 100644
index 54db7d58e..000000000
--- a/examples/simple/src/com/facebook/android/Example.java
+++ /dev/null
@@ -1,281 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.MalformedURLException;
-import java.net.URL;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.widget.Button;
-import android.widget.TextView;
-
-import com.facebook.android.SessionEvents.AuthListener;
-import com.facebook.android.SessionEvents.LogoutListener;
-
-
-public class Example extends Activity {
-
-    // Your Facebook Application ID must be set before running this example
-    // See http://www.facebook.com/developers/createapp.php
-    public static final String APP_ID = "175729095772478";
-
-    private LoginButton mLoginButton;
-    private TextView mText;
-    private Button mRequestButton;
-    private Button mPostButton;
-    private Button mDeleteButton;
-    private Button mUploadButton;
-
-    private Facebook mFacebook;
-    private AsyncFacebookRunner mAsyncRunner;
-
-    /** Called when the activity is first created. */
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        if (APP_ID == null) {
-            Util.showAlert(this, "Warning", "Facebook Applicaton ID must be " +
-                    "specified before running this example: see Example.java");
-        }
-
-        setContentView(R.layout.main);
-        mLoginButton = (LoginButton) findViewById(R.id.login);
-        mText = (TextView) Example.this.findViewById(R.id.txt);
-        mRequestButton = (Button) findViewById(R.id.requestButton);
-        mPostButton = (Button) findViewById(R.id.postButton);
-        mDeleteButton = (Button) findViewById(R.id.deletePostButton);
-        mUploadButton = (Button) findViewById(R.id.uploadButton);
-
-       	mFacebook = new Facebook(APP_ID);
-       	mAsyncRunner = new AsyncFacebookRunner(mFacebook);
-
-        SessionStore.restore(mFacebook, this);
-        SessionEvents.addAuthListener(new SampleAuthListener());
-        SessionEvents.addLogoutListener(new SampleLogoutListener());
-        mLoginButton.init(this, mFacebook);
-
-        mRequestButton.setOnClickListener(new OnClickListener() {
-            public void onClick(View v) {
-            	mAsyncRunner.request("me", new SampleRequestListener());
-            }
-        });
-        mRequestButton.setVisibility(mFacebook.isSessionValid() ?
-                View.VISIBLE :
-                View.INVISIBLE);
-
-        mUploadButton.setOnClickListener(new OnClickListener() {
-            public void onClick(View v) {
-                Bundle params = new Bundle();
-                params.putString("method", "photos.upload");
-
-                URL uploadFileUrl = null;
-                try {
-                    uploadFileUrl = new URL(
-                        "http://www.facebook.com/images/devsite/iphone_connect_btn.jpg");
-                } catch (MalformedURLException e) {
-                	e.printStackTrace();
-                }
-                try {
-                    HttpURLConnection conn= (HttpURLConnection)uploadFileUrl.openConnection();
-                    conn.setDoInput(true);
-                    conn.connect();
-                    int length = conn.getContentLength();
-
-                    byte[] imgData =new byte[length];
-                    InputStream is = conn.getInputStream();
-                    is.read(imgData);
-                    params.putByteArray("picture", imgData);
-
-                } catch  (IOException e) {
-                    e.printStackTrace();
-                }
-
-                mAsyncRunner.request(null, params, "POST",
-                        new SampleUploadListener(), null);
-            }
-        });
-        mUploadButton.setVisibility(mFacebook.isSessionValid() ?
-                View.VISIBLE :
-                View.INVISIBLE);
-
-        mPostButton.setOnClickListener(new OnClickListener() {
-            public void onClick(View v) {
-                mFacebook.dialog(Example.this, "feed",
-                        new SampleDialogListener());
-            }
-        });
-        mPostButton.setVisibility(mFacebook.isSessionValid() ?
-                View.VISIBLE :
-                View.INVISIBLE);
-    }
-
-    @Override
-    protected void onActivityResult(int requestCode, int resultCode,
-                                    Intent data) {
-        mFacebook.authorizeCallback(requestCode, resultCode, data);
-    }
-
-    public class SampleAuthListener implements AuthListener {
-
-        public void onAuthSucceed() {
-            mText.setText("You have logged in! ");
-            mRequestButton.setVisibility(View.VISIBLE);
-            mUploadButton.setVisibility(View.VISIBLE);
-            mPostButton.setVisibility(View.VISIBLE);
-        }
-
-        public void onAuthFail(String error) {
-            mText.setText("Login Failed: " + error);
-        }
-    }
-
-    public class SampleLogoutListener implements LogoutListener {
-        public void onLogoutBegin() {
-            mText.setText("Logging out...");
-        }
-
-        public void onLogoutFinish() {
-            mText.setText("You have logged out! ");
-            mRequestButton.setVisibility(View.INVISIBLE);
-            mUploadButton.setVisibility(View.INVISIBLE);
-            mPostButton.setVisibility(View.INVISIBLE);
-        }
-    }
-
-    public class SampleRequestListener extends BaseRequestListener {
-
-        public void onComplete(final String response, final Object state) {
-            try {
-                // process the response here: executed in background thread
-                Log.d("Facebook-Example", "Response: " + response.toString());
-                JSONObject json = Util.parseJson(response);
-                final String name = json.getString("name");
-
-                // then post the processed result back to the UI thread
-                // if we do not do this, an runtime exception will be generated
-                // e.g. "CalledFromWrongThreadException: Only the original
-                // thread that created a view hierarchy can touch its views."
-                Example.this.runOnUiThread(new Runnable() {
-                    public void run() {
-                        mText.setText("Hello there, " + name + "!");
-                    }
-                });
-            } catch (JSONException e) {
-                Log.w("Facebook-Example", "JSON Error in response");
-            } catch (FacebookError e) {
-                Log.w("Facebook-Example", "Facebook Error: " + e.getMessage());
-            }
-        }
-    }
-
-    public class SampleUploadListener extends BaseRequestListener {
-
-        public void onComplete(final String response, final Object state) {
-            try {
-                // process the response here: (executed in background thread)
-                Log.d("Facebook-Example", "Response: " + response.toString());
-                JSONObject json = Util.parseJson(response);
-                final String src = json.getString("src");
-
-                // then post the processed result back to the UI thread
-                // if we do not do this, an runtime exception will be generated
-                // e.g. "CalledFromWrongThreadException: Only the original
-                // thread that created a view hierarchy can touch its views."
-                Example.this.runOnUiThread(new Runnable() {
-                    public void run() {
-                        mText.setText("Hello there, photo has been uploaded at \n" + src);
-                    }
-                });
-            } catch (JSONException e) {
-                Log.w("Facebook-Example", "JSON Error in response");
-            } catch (FacebookError e) {
-                Log.w("Facebook-Example", "Facebook Error: " + e.getMessage());
-            }
-        }
-    }
-    public class WallPostRequestListener extends BaseRequestListener {
-
-        public void onComplete(final String response, final Object state) {
-            Log.d("Facebook-Example", "Got response: " + response);
-            String message = "<empty>";
-            try {
-                JSONObject json = Util.parseJson(response);
-                message = json.getString("message");
-            } catch (JSONException e) {
-                Log.w("Facebook-Example", "JSON Error in response");
-            } catch (FacebookError e) {
-                Log.w("Facebook-Example", "Facebook Error: " + e.getMessage());
-            }
-            final String text = "Your Wall Post: " + message;
-            Example.this.runOnUiThread(new Runnable() {
-                public void run() {
-                    mText.setText(text);
-                }
-            });
-        }
-    }
-
-    public class WallPostDeleteListener extends BaseRequestListener {
-
-        public void onComplete(final String response, final Object state) {
-            if (response.equals("true")) {
-                Log.d("Facebook-Example", "Successfully deleted wall post");
-                Example.this.runOnUiThread(new Runnable() {
-                    public void run() {
-                        mDeleteButton.setVisibility(View.INVISIBLE);
-                        mText.setText("Deleted Wall Post");
-                    }
-                });
-            } else {
-                Log.d("Facebook-Example", "Could not delete wall post");
-            }
-        }
-    }
-
-    public class SampleDialogListener extends BaseDialogListener {
-
-        public void onComplete(Bundle values) {
-            final String postId = values.getString("post_id");
-            if (postId != null) {
-                Log.d("Facebook-Example", "Dialog Success! post_id=" + postId);
-                mAsyncRunner.request(postId, new WallPostRequestListener());
-                mDeleteButton.setOnClickListener(new OnClickListener() {
-                    public void onClick(View v) {
-                        mAsyncRunner.request(postId, new Bundle(), "DELETE",
-                                new WallPostDeleteListener(), null);
-                    }
-                });
-                mDeleteButton.setVisibility(View.VISIBLE);
-            } else {
-                Log.d("Facebook-Example", "No wall post made");
-            }
-        }
-    }
-
-}
diff --git a/examples/simple/src/com/facebook/android/LoginButton.java b/examples/simple/src/com/facebook/android/LoginButton.java
deleted file mode 100644
index bd758f413..000000000
--- a/examples/simple/src/com/facebook/android/LoginButton.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android;
-
-import com.facebook.android.BaseRequestListener;
-import com.facebook.android.SessionEvents.AuthListener;
-import com.facebook.android.SessionEvents.LogoutListener;
-import com.facebook.android.Facebook.DialogListener;
-
-import android.app.Activity;
-import android.content.Context;
-import android.graphics.Color;
-import android.os.Bundle;
-import android.os.Handler;
-import android.util.AttributeSet;
-import android.view.View;
-import android.widget.ImageButton;
-
-public class LoginButton extends ImageButton {
-    
-    private Facebook mFb;
-    private Handler mHandler;
-    private SessionListener mSessionListener = new SessionListener();
-    private String[] mPermissions;
-    private Activity mActivity;
-    
-    public LoginButton(Context context) {
-        super(context);
-    }
-    
-    public LoginButton(Context context, AttributeSet attrs) {
-        super(context, attrs);
-    }
-    
-    public LoginButton(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-    }
-    
-    public void init(final Activity activity, final Facebook fb) {
-    	init(activity, fb, new String[] {});
-    }
-    
-    public void init(final Activity activity, final Facebook fb,
-                     final String[] permissions) {
-        mActivity = activity;
-        mFb = fb;
-        mPermissions = permissions;
-        mHandler = new Handler();
-        
-        setBackgroundColor(Color.TRANSPARENT);
-        setAdjustViewBounds(true);
-        setImageResource(fb.isSessionValid() ?
-                         R.drawable.logout_button : 
-                         R.drawable.login_button);
-        drawableStateChanged();
-        
-        SessionEvents.addAuthListener(mSessionListener);
-        SessionEvents.addLogoutListener(mSessionListener);
-        setOnClickListener(new ButtonOnClickListener());
-    }
-    
-    private final class ButtonOnClickListener implements OnClickListener {
-        
-        public void onClick(View arg0) {
-            if (mFb.isSessionValid()) {
-                SessionEvents.onLogoutBegin();
-                AsyncFacebookRunner asyncRunner = new AsyncFacebookRunner(mFb);
-                asyncRunner.logout(getContext(), new LogoutRequestListener());
-            } else {
-                mFb.authorize(mActivity, mPermissions,
-                              new LoginDialogListener());
-            }
-        }
-    }
-
-    private final class LoginDialogListener implements DialogListener {
-        public void onComplete(Bundle values) {
-            SessionEvents.onLoginSuccess();
-        }
-
-        public void onFacebookError(FacebookError error) {
-            SessionEvents.onLoginError(error.getMessage());
-        }
-        
-        public void onError(DialogError error) {
-            SessionEvents.onLoginError(error.getMessage());
-        }
-
-        public void onCancel() {
-            SessionEvents.onLoginError("Action Canceled");
-        }
-    }
-    
-    private class LogoutRequestListener extends BaseRequestListener {
-        public void onComplete(String response, final Object state) {
-            // callback should be run in the original thread, 
-            // not the background thread
-            mHandler.post(new Runnable() {
-                public void run() {
-                    SessionEvents.onLogoutFinish();
-                }
-            });
-        }
-    }
-    
-    private class SessionListener implements AuthListener, LogoutListener {
-        
-        public void onAuthSucceed() {
-            setImageResource(R.drawable.logout_button);
-            SessionStore.save(mFb, getContext());
-        }
-
-        public void onAuthFail(String error) {
-        }
-        
-        public void onLogoutBegin() {           
-        }
-        
-        public void onLogoutFinish() {
-            SessionStore.clear(getContext());
-            setImageResource(R.drawable.login_button);
-        }
-    }
-    
-}
diff --git a/examples/simple/src/com/facebook/android/SessionEvents.java b/examples/simple/src/com/facebook/android/SessionEvents.java
deleted file mode 100644
index 1351f88e1..000000000
--- a/examples/simple/src/com/facebook/android/SessionEvents.java
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android;
-
-import java.util.LinkedList;
-
-public class SessionEvents {
-
-    private static LinkedList<AuthListener> mAuthListeners = 
-        new LinkedList<AuthListener>();
-    private static LinkedList<LogoutListener> mLogoutListeners = 
-        new LinkedList<LogoutListener>();
-
-    /**
-     * Associate the given listener with this Facebook object. The listener's
-     * callback interface will be invoked when authentication events occur.
-     * 
-     * @param listener
-     *            The callback object for notifying the application when auth
-     *            events happen.
-     */
-    public static void addAuthListener(AuthListener listener) {
-        mAuthListeners.add(listener);
-    }
-
-    /**
-     * Remove the given listener from the list of those that will be notified
-     * when authentication events occur.
-     * 
-     * @param listener
-     *            The callback object for notifying the application when auth
-     *            events happen.
-     */
-    public static void removeAuthListener(AuthListener listener) {
-        mAuthListeners.remove(listener);
-    }
-
-    /**
-     * Associate the given listener with this Facebook object. The listener's
-     * callback interface will be invoked when logout occurs.
-     * 
-     * @param listener
-     *            The callback object for notifying the application when log out
-     *            starts and finishes.
-     */
-    public static void addLogoutListener(LogoutListener listener) {
-        mLogoutListeners.add(listener);
-    }
-
-    /**
-     * Remove the given listener from the list of those that will be notified
-     * when logout occurs.
-     * 
-     * @param listener
-     *            The callback object for notifying the application when log out
-     *            starts and finishes.
-     */
-    public static void removeLogoutListener(LogoutListener listener) {
-        mLogoutListeners.remove(listener);
-    }
-    
-    public static void onLoginSuccess() {
-        for (AuthListener listener : mAuthListeners) {
-            listener.onAuthSucceed();
-        }
-    }
-    
-    public static void onLoginError(String error) {
-        for (AuthListener listener : mAuthListeners) {
-            listener.onAuthFail(error);
-        }
-    }
-    
-    public static void onLogoutBegin() {
-        for (LogoutListener l : mLogoutListeners) {
-            l.onLogoutBegin();
-        }
-    }
-    
-    public static void onLogoutFinish() {
-        for (LogoutListener l : mLogoutListeners) {
-            l.onLogoutFinish();
-        }   
-    }
-    
-    /**
-     * Callback interface for authorization events.
-     *
-     */
-    public static interface AuthListener {
-
-        /**
-         * Called when a auth flow completes successfully and a valid OAuth 
-         * Token was received.
-         * 
-         * Executed by the thread that initiated the authentication.
-         * 
-         * API requests can now be made.
-         */
-        public void onAuthSucceed();
-
-        /**
-         * Called when a login completes unsuccessfully with an error. 
-         *  
-         * Executed by the thread that initiated the authentication.
-         */
-        public void onAuthFail(String error);
-    }
-    
-    /**
-     * Callback interface for logout events.
-     *
-     */ 
-    public static interface LogoutListener {
-        /**
-         * Called when logout begins, before session is invalidated.  
-         * Last chance to make an API call.  
-         * 
-         * Executed by the thread that initiated the logout.
-         */
-        public void onLogoutBegin();
-
-        /**
-         * Called when the session information has been cleared.
-         * UI should be updated to reflect logged-out state.
-         * 
-         * Executed by the thread that initiated the logout.
-         */
-        public void onLogoutFinish();
-    }
-    
-}
diff --git a/examples/simple/src/com/facebook/android/SessionStore.java b/examples/simple/src/com/facebook/android/SessionStore.java
deleted file mode 100644
index d65df66b9..000000000
--- a/examples/simple/src/com/facebook/android/SessionStore.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android;
-
-import com.facebook.android.Facebook;
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.content.SharedPreferences.Editor;
-
-public class SessionStore {
-    
-    private static final String TOKEN = "access_token";
-    private static final String EXPIRES = "expires_in";
-    private static final String KEY = "facebook-session";
-    
-    public static boolean save(Facebook session, Context context) {
-        Editor editor =
-            context.getSharedPreferences(KEY, Context.MODE_PRIVATE).edit();
-        editor.putString(TOKEN, session.getAccessToken());
-        editor.putLong(EXPIRES, session.getAccessExpires());
-        return editor.commit();
-    }
-
-    public static boolean restore(Facebook session, Context context) {
-        SharedPreferences savedSession =
-            context.getSharedPreferences(KEY, Context.MODE_PRIVATE);
-        session.setAccessToken(savedSession.getString(TOKEN, null));
-        session.setAccessExpires(savedSession.getLong(EXPIRES, 0));
-        return session.isSessionValid();
-    }
-
-    public static void clear(Context context) {
-        Editor editor = 
-            context.getSharedPreferences(KEY, Context.MODE_PRIVATE).edit();
-        editor.clear();
-        editor.commit();
-    }
-    
-}
diff --git a/examples/stream/AndroidManifest.xml b/examples/stream/AndroidManifest.xml
deleted file mode 100644
index 0f2493301..000000000
--- a/examples/stream/AndroidManifest.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-      android:versionCode="1"
-      android:versionName="1.0" package="com.facebook.stream">
-    <application android:icon="@drawable/icon" android:label="@string/app_name">
-        <activity android:name=".App"
-                  android:label="@string/app_name"
-                  android:screenOrientation="portrait"
-                  android:configChanges="keyboardHidden|orientation">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
-
-	<uses-permission android:name="android.permission.INTERNET" />
-	<uses-sdk android:minSdkVersion="3" />
-</manifest> 
\ No newline at end of file
diff --git a/examples/stream/assets/like_icon.png b/examples/stream/assets/like_icon.png
deleted file mode 100644
index 79ea76ec5..000000000
Binary files a/examples/stream/assets/like_icon.png and /dev/null differ
diff --git a/examples/stream/assets/login.css b/examples/stream/assets/login.css
deleted file mode 100644
index d1e3f2fc2..000000000
--- a/examples/stream/assets/login.css
+++ /dev/null
@@ -1,14 +0,0 @@
-#main {
-  width: 200px;
-  margin: 50% auto 0 auto;
-  text-align: center;
-}
-
-#welcome {
-  margin-bottom: 10px;
-}
-
-#login_button {
-  width: 91px;
-  margin: auto;
-}
\ No newline at end of file
diff --git a/examples/stream/assets/login.html b/examples/stream/assets/login.html
deleted file mode 100644
index 35e536994..000000000
--- a/examples/stream/assets/login.html
+++ /dev/null
@@ -1,13 +0,0 @@
-<html>
-<head>
-  <link rel="stylesheet" href="file:///android_asset/login.css" type="text/css"/>
-</head>
-<body>
-  <div id="main">
-    <div id="welcome">Welcome to Stream</div>
-    <div id="login_button">
-      <a onclick="app.login()"><img src="file:///android_asset/login_button.png" width="90" height="31"/></a>
-    </div>
-  </div>
-</body>
-</html>
\ No newline at end of file
diff --git a/examples/stream/assets/login_button.png b/examples/stream/assets/login_button.png
deleted file mode 100644
index 77bc30c27..000000000
Binary files a/examples/stream/assets/login_button.png and /dev/null differ
diff --git a/examples/stream/assets/stream.css b/examples/stream/assets/stream.css
deleted file mode 100644
index cb0d676f0..000000000
--- a/examples/stream/assets/stream.css
+++ /dev/null
@@ -1,118 +0,0 @@
-a {
-  color: #00f;
-}
-
-a:visited {
-  color: #00f;
-}
-
-.hidden {
-  display: none;
-}
-
-.clear {
-  clear: both
-}
-
-#header {
-  float: right;
-}
-
-input {
-  width: 80%;
-  height: 28px;
-  border: #666 solid 1px;
-  margin: 1px 3px 0 0;
-  float: left;
-}
-
-#status_box {
-  margin: 5px 0;
-}
-
-#status_input {
-  color: #666;
-  float: left;
-}
-
-.profile_pic_container {
-  float: left;
-  margin: 0 5px;
-}
-
-.profile_pic {
-  width: 30px;
-  height: 30px;
-}
-
-.attachment {
-  margin-top: 3px;
-}
-
-.title {
-  margin-bottom: 3px;
-}
-
-.caption {
-  margin-bottom: 3px;
-  color: #666;
-}
-
-.description {
-  color: #666;  
-} 
-
-.picture {
-  float: left;
-  margin-right: 5px;
-}
-
-.post {
-  padding: 10px 0;
-  border-bottom: #ccc solid 1px;
-}
-
-.action_links {
-  margin: 5px 0;
-}
-
-.action_link {
-  margin-right: 5px;
-  float: left;
-}
-
-
-.comment {
-  padding: 5px 0;
-  margin-bottom: 2px;
-  background-color: #eee;
-  min-height: 30px;
-}
-
-.comments {
-  margin-top: 5px;
-}
-
-.comment_box {
-  display: none;
-}
-
-.timestamp {
-  color: #666;
-}
-
-.like_icon {
-  float: left;
-  top: 3px;
-  position: relative;
-  margin-right: 5px;
-}
-
-.like_icon img {
-  width: 16px;
-  height: 14px;
-}
-
-.num_likes {
-  padding-left: 5px;
-}
\ No newline at end of file
diff --git a/examples/stream/assets/stream.js b/examples/stream/assets/stream.js
deleted file mode 100644
index 23c4809f4..000000000
--- a/examples/stream/assets/stream.js
+++ /dev/null
@@ -1,88 +0,0 @@
-function $(id) {
-  return document.getElementById(id);
-}
-
-function show(id) {
-  $(id).style.display = "block";
-}
-
-function hide(id) {
-  $(id).style.display = "none";
-}
-
-function onStatusBoxFocus(elt) {
-  elt.value = '';
-  elt.style.color = "#000";
-  show('status_submit');
-}
-
-function updateStatus() {
-  var message = $('status_input').value;
-  if (message == "") {
-    return;
-  }
-  $('status_input').disabled = true;
-  $('status_submit').disabled = true;
-  app.updateStatus(message);
-}
-
-function onStatusUpdated(html) {
-  $('status_input').disabled = false;
-  $('status_submit').disabled = false;
-  $('posts').innerHTML = html + $('posts').innerHTML;
-}
-
-function like(post_id) {
-  doLike(post_id, true);
- 
-}
-
-function unlike(post_id) {
-  doLike(post_id, false);
-}
-
-function doLike(post_id, val) {
-  var ids = getLikeLinkIds(post_id, val);
-  $(ids[0]).disabled = true;
-  app.like(post_id, val);
-}
-
-// called when the api request has succeeded
-function onLike(post_id, val) {
-  var ids = getLikeLinkIds(post_id, val);
-  $(ids[0]).disabled = false;
-  hide(ids[0]);
-  show(ids[1]);
-}
-
-function getLikeLinkIds(post_id, val) {
-  if (val) {
-    var prefix1 = 'like';
-    var prefix2 = 'unlike';
-  } else {
-    var prefix1 = 'unlike';
-    var prefix2 = 'like';
-  }
-  return [prefix1 + post_id, prefix2 + post_id];
-}
-  
-
-function comment(post_id) {
-  show("comment_box" + post_id);
-  $("comment_box_input" + post_id).focus();
-}
-
-function postComment(post_id) {
-  var message = $("comment_box_input" + post_id).value;
-  if (message == "") {
-    return;
-  }
-  $("comment_box" + post_id).disabled = true;
-  app.postComment(post_id, message);
-}
-
-function onComment(post_id, html) {
-  $("comments" + post_id).innerHTML += html;
-  $("comment_box" + post_id).disabled = false;
-  $("comment_box_input" + post_id).value = "";
-}
\ No newline at end of file
diff --git a/examples/stream/default.properties b/examples/stream/default.properties
deleted file mode 100644
index 0f4dfe443..000000000
--- a/examples/stream/default.properties
+++ /dev/null
@@ -1,14 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-# 
-# This file must be checked in Version Control Systems.
-# 
-# To customize properties used by the Ant build system use,
-# "build.properties", and override values to adapt the script to your
-# project structure.
-
-# Indicates whether an apk should be generated for each density.
-split.density=false
-android.library.reference.1=../../facebook/
-# Project target.
-target=android-3
diff --git a/examples/stream/res/drawable-mdpi/icon.png b/examples/stream/res/drawable-mdpi/icon.png
deleted file mode 100644
index a07c69fa5..000000000
Binary files a/examples/stream/res/drawable-mdpi/icon.png and /dev/null differ
diff --git a/examples/stream/res/values/strings.xml b/examples/stream/res/values/strings.xml
deleted file mode 100644
index a33b88605..000000000
--- a/examples/stream/res/values/strings.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <string name="app_name">stream</string>
-</resources>
\ No newline at end of file
diff --git a/examples/stream/src/com/facebook/stream/App.java b/examples/stream/src/com/facebook/stream/App.java
deleted file mode 100644
index 4efca7aa6..000000000
--- a/examples/stream/src/com/facebook/stream/App.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import android.app.Activity;
-import android.app.AlertDialog.Builder;
-import android.content.Intent;
-import android.os.Bundle;
-import com.facebook.android.Facebook;
-
-/**
- * This class implements the application's main Activity.
- * 
- * @author yariv
- */
-public class App extends Activity {
-
-    // This is a demo application ID just to get this demo up and running
-    // If you modify this to work for your own app, you must use your
-    // own Facebook Application ID.
-    // See http://www.facebook.com/developers/createapp.php
-    public static final String FB_APP_ID = "126642314059639";
-
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        if (FB_APP_ID == null) {
-            Builder alertBuilder = new Builder(this);
-            alertBuilder.setTitle("Warning");
-            alertBuilder.setMessage("A Facebook Applicaton ID must be " +
-                    "specified before running this example: see App.java");
-            alertBuilder.create().show();
-        }
-        
-        // Initialize the dispatcher
-        Dispatcher dispatcher = new Dispatcher(this);
-        dispatcher.addHandler("login", LoginHandler.class);
-        dispatcher.addHandler("stream", StreamHandler.class);
-        dispatcher.addHandler("logout", LogoutHandler.class);
-
-        // If a session already exists, render the stream page
-        // immediately. Otherwise, render the login page.
-        Session session = Session.restore(this);
-        if (session != null) {
-            dispatcher.runHandler("stream");
-        } else {
-            dispatcher.runHandler("login");
-        }
-    }
-
-    protected void onActivityResult(int requestCode, int resultCode,
-                                    Intent data) {
-        Facebook fb = Session.wakeupForAuthCallback();
-        fb.authorizeCallback(requestCode, resultCode, data);
-    }
-}
diff --git a/examples/stream/src/com/facebook/stream/AsyncRequestListener.java b/examples/stream/src/com/facebook/stream/AsyncRequestListener.java
deleted file mode 100644
index 94d5eb4f4..000000000
--- a/examples/stream/src/com/facebook/stream/AsyncRequestListener.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.net.MalformedURLException;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import android.util.Log;
-
-import com.facebook.android.FacebookError;
-import com.facebook.android.Util;
-import com.facebook.android.AsyncFacebookRunner.RequestListener;
-
-abstract class AsyncRequestListener implements RequestListener {
-
-    public void onComplete(String response, final Object state) {
-        try {
-            JSONObject obj = Util.parseJson(response);
-            onComplete(obj, state);
-        } catch (JSONException e) {
-            e.printStackTrace();
-            Log.e("facebook-stream", "JSON Error:" + e.getMessage());
-        } catch (FacebookError e) {
-            Log.e("facebook-stream", "Facebook Error:" + e.getMessage());
-        }
-
-    }
-
-    public abstract void onComplete(JSONObject obj, final Object state);
-
-    public void onFacebookError(FacebookError e, final Object state) {
-        Log.e("stream", "Facebook Error:" + e.getMessage());
-    }
-
-    public void onFileNotFoundException(FileNotFoundException e,
-                                        final Object state) {
-        Log.e("stream", "Resource not found:" + e.getMessage());      
-    }
-
-    public void onIOException(IOException e, final Object state) {
-        Log.e("stream", "Network Error:" + e.getMessage());      
-    }
-
-    public void onMalformedURLException(MalformedURLException e,
-                                        final Object state) {
-        Log.e("stream", "Invalid URL:" + e.getMessage());            
-    }
-
-}
\ No newline at end of file
diff --git a/examples/stream/src/com/facebook/stream/Dispatcher.java b/examples/stream/src/com/facebook/stream/Dispatcher.java
deleted file mode 100644
index 462734079..000000000
--- a/examples/stream/src/com/facebook/stream/Dispatcher.java
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import java.util.HashMap;
-
-import android.app.Activity;
-import android.webkit.WebView;
-import android.webkit.WebViewClient;
-import android.widget.LinearLayout;
-import android.widget.LinearLayout.LayoutParams;
-
-/**
- * Handles the rendering of the WebView instance and the
- * mapping of app:// urls to their appropriate Handlers.  
- * 
- * @author yariv
- */
-public class Dispatcher {
-
-    // The WebView instance
-    private WebView webView;
-
-    // The app's main Activity
-    private Activity activity;
-
-    // Contains the webView object
-    LinearLayout layout;
-
-    // Has the webView been rendered?
-    boolean isWebViewShown;
-
-    // Holds mappings between handler names to their classes
-    // (e.g. "login" -> LoginHandler.class)
-    HashMap<String, Class> handlers;
-
-    public Dispatcher(Activity activity) {
-        this.activity = activity;
-        handlers = new HashMap<String, Class>();
-        layout = new LinearLayout(activity);
-        activity.addContentView(
-                layout, new LayoutParams(
-                        LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));
-        isWebViewShown = false;
-        showWebView();
-    }
-
-    /**
-     * Adds a handler name to handler class mapping. This should be called
-     * for each handler when the application starts up.
-     * 
-     * @param name
-     * @param clazz
-     */
-    public void addHandler(String name, Class clazz) {
-        this.handlers.put(name, clazz);
-    }
-
-    /**
-     * Executes the handler associated with the given name. For example,
-     * dispatcher.runHandler("login") would render the Login page in the
-     * WebView instance.
-     * 
-     * @param name
-     */
-    public void runHandler(String name) {
-        Class clazz = handlers.get(name);
-        if (clazz != null) {
-            try {
-                Handler handler = (Handler)clazz.newInstance();
-                handler.setDispatcher(this);
-                handler.go();
-            } catch (IllegalAccessException e) {
-                e.printStackTrace();
-            } catch (InstantiationException e) {
-                e.printStackTrace();
-            }
-        }
-    }
-
-    /**
-     * Show the app's WebView instance.
-     */
-    public void showWebView() {
-        if (isWebViewShown) {
-            return;
-        }
-        webView = new WebView(activity);
-        webView.setWebViewClient(new AppWebViewClient());
-        webView.getSettings().setJavaScriptEnabled(true);
-        layout.addView(webView,
-                new LayoutParams(
-                        LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));
-        isWebViewShown = true;
-    }
-
-    /**
-     * Hide the app's WebView instance. This should be called if the
-     * WebView instance is visible and the app wants to open another
-     * WebView instance (e.g. for a Facebook dialog). Android doesn't
-     * seem to be able to handle more than one WebView instance per
-     * application.
-     */
-    public void hideWebView() {
-        layout.removeView(webView);
-        isWebViewShown = false;
-    }
-
-    /**
-     * Returns true if the WebView instance is visible.
-     */
-    public boolean isWebViewShown() {
-        return isWebViewShown;
-    }
-
-    /**
-     * Loads the html string into the WebView instance.
-     * 
-     * @param html
-     */
-    public void loadData(String html) {
-        webView.loadDataWithBaseURL(
-                "http://nada", html, "text/html", "utf8", "");
-    }
-
-    /**
-     * Loads a file from the assets directory into the
-     * WebView instance.
-     * 
-     * @param file
-     */
-    public void loadFile(String file) {
-        webView.loadUrl(getAbsoluteUrl(file));
-    }
-
-    /**
-     * Returns the absolute URL for a local file.
-     * 
-     * @param file
-     */
-    public static String getAbsoluteUrl(String file) {
-        return "file:///android_asset/" + file;
-    }
-
-    /**
-     * Returns the Dispatcher's WebView instance.
-     */
-    public WebView getWebView() {
-        return webView;
-    }
-
-    /**
-     * Returns the Dispatcher's Activity
-     */
-    public Activity getActivity() {
-        return activity;
-    }
-
-
-    /**
-     * Enables the mapping of app:// urls to Handlers.
-     * 
-     * @author yariv
-     */
-    private class AppWebViewClient extends WebViewClient {
-
-        @Override
-        public boolean shouldOverrideUrlLoading(WebView view, String url) {
-            if (url.startsWith("app://")) {
-                String handlerName = url.substring(6);
-                runHandler(handlerName);
-                return true;	
-            }
-            return false;
-        }        
-    }
-
-}
diff --git a/examples/stream/src/com/facebook/stream/FileIO.java b/examples/stream/src/com/facebook/stream/FileIO.java
deleted file mode 100644
index 8ea21b80c..000000000
--- a/examples/stream/src/com/facebook/stream/FileIO.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import java.io.BufferedReader;
-import java.io.BufferedWriter;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.InputStreamReader;
-
-import android.app.Activity;
-
-/**
- * Helpers for doing basic file IO.
- * 
- * @author yariv
- *
- */
-public class FileIO {
-
-    /**
-     * Write the data to the file indicate by fileName. The file is created
-     * if it doesn't exist.
-     * 
-     * @param activity
-     * @param data
-     * @param fileName
-     * @throws IOException
-     */
-    public static void write(
-            Activity activity, String data, String fileName)
-            throws IOException {
-        FileOutputStream fo = activity.openFileOutput(fileName, 0);
-        BufferedWriter bf = new BufferedWriter(new FileWriter(fo.getFD()));
-        bf.write(data);
-        bf.flush();
-        bf.close();
-    }
-
-    /**
-     * Read the contents of the file indicated by fileName
-     * 
-     * @param activity
-     * @param fileName
-     * @return the contents
-     * @throws IOException
-     */
-    public static String read(Activity activity, String fileName) 
-            throws IOException {
-        FileInputStream is = activity.openFileInput(fileName);
-        BufferedReader br = new BufferedReader(new InputStreamReader(is));
-        StringBuilder sb = new StringBuilder();
-        while (br.ready()) {
-            String line = br.readLine();
-            sb.append(line);
-        }
-        String data = sb.toString();
-        return data;
-    }
-}
diff --git a/examples/stream/src/com/facebook/stream/Handler.java b/examples/stream/src/com/facebook/stream/Handler.java
deleted file mode 100644
index 1c682c653..000000000
--- a/examples/stream/src/com/facebook/stream/Handler.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import android.app.Activity;
-import android.webkit.WebView;
-
-/**
- * An abstract superclass for handlers. Handlers are similar to
- * controllers in traditional web apps. Each page has a handler
- * that is responsible for rendering the page.
- * 
- * @author yariv
- */
-public abstract class Handler {
-
-    // The app's dispatcher.
-    protected Dispatcher dispatcher;
-
-    /**
-     * The dispatcher calls this method when the Handler
-     * is expected to render its page.
-     */
-    public abstract void go();
-
-    /**
-     * A setter for the dispatcher.
-     * 
-     * @param dispatcher
-     */
-    public void setDispatcher(Dispatcher dispatcher) {
-        this.dispatcher = dispatcher;
-    }
-
-    /**
-     * Returns the dispatcher.
-     */
-    public Dispatcher getDispatcher() {
-        return dispatcher;
-    }
-
-
-    /**
-     * Returns the dispatcher's WebView
-     */
-    public WebView getWebView() {
-        return dispatcher.getWebView();
-    }
-
-    /**
-     * Returns the dispatcher's Activity
-     */
-    public Activity getActivity() {
-        return dispatcher.getActivity();
-    }
-}
diff --git a/examples/stream/src/com/facebook/stream/LoginHandler.java b/examples/stream/src/com/facebook/stream/LoginHandler.java
deleted file mode 100644
index 0e2ef34ae..000000000
--- a/examples/stream/src/com/facebook/stream/LoginHandler.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import org.json.JSONObject;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.util.Log;
-
-import com.facebook.android.AsyncFacebookRunner;
-import com.facebook.android.DialogError;
-import com.facebook.android.Facebook;
-import com.facebook.android.FacebookError;
-import com.facebook.android.Facebook.DialogListener;
-
-/**
- * A handler for the login page.
- * 
- * @author yariv
- */
-public class LoginHandler extends Handler {
-
-    // The permissions that the app should request from the user
-    // when the user authorizes the app.
-    private static String[] PERMISSIONS = 
-        new String[] { "offline_access", "read_stream", "publish_stream" };
-
-    /**
-     * Render the Login page.
-     */
-    public void go() {
-        dispatcher.getWebView().addJavascriptInterface(
-                new JsHandler(), "app");
-        dispatcher.loadFile("login.html");
-    }
-
-    /**
-     * Contains functions that are exported to the Javascript context
-     * in Login.html
-     * 
-     * @author yariv
-     */
-    private class JsHandler {
-
-        /**
-         * Opens the Facebook login dialog.
-         */
-        public void login() {
-            final Activity activity = LoginHandler.this.getActivity();
-            activity.runOnUiThread(new Runnable() {
-                public void run() {
-                    // We need to temporarily remove the app's WebView
-                    // instance because Android apparently doesn't support
-                    // multiple WebView instances in the same app.
-                    dispatcher.hideWebView();
-                    final Facebook fb = new Facebook(App.FB_APP_ID);
-                    Session.waitForAuthCallback(fb);
-                    fb.authorize(getActivity(), PERMISSIONS,
-                                 new AppLoginListener(fb));
-                }
-            });
-        }
-
-        private class AppLoginListener implements DialogListener {
-
-            private Facebook fb;
-
-            public AppLoginListener(Facebook fb) {
-                this.fb = fb;
-            }
-
-            public void onCancel() {
-                Log.d("app", "login canceled");
-            }
-
-            public void onComplete(Bundle values) {
-                /**
-                 * We request the user's info so we can cache it locally and
-                 * use it to render the new html snippets
-                 * when the user updates her status or comments on a post. 
-                 */
-                new AsyncFacebookRunner(fb).request("/me", 
-                        new AsyncRequestListener() {
-                    public void onComplete(JSONObject obj, final Object state) {
-                        // save the session data
-                        String uid = obj.optString("id");
-                        String name = obj.optString("name");
-                        new Session(fb, uid, name).save(getActivity());
-
-                        // render the Stream page in the UI thread
-                        getActivity().runOnUiThread(new Runnable() {
-                            public void run() {
-                                dispatcher.showWebView();
-                                dispatcher.runHandler("stream");
-                            }
-                        });
-                    }
-                }, null);
-            }
-
-            public void onError(DialogError e) {
-                Log.d("app", "dialog error: " + e);               
-            }
-
-            public void onFacebookError(FacebookError e) {
-                Log.d("app", "facebook error: " + e);
-            }
-        }
-    }
-
-}
diff --git a/examples/stream/src/com/facebook/stream/LogoutHandler.java b/examples/stream/src/com/facebook/stream/LogoutHandler.java
deleted file mode 100644
index dc3f94ef7..000000000
--- a/examples/stream/src/com/facebook/stream/LogoutHandler.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.net.MalformedURLException;
-
-import android.util.Log;
-
-import com.facebook.android.AsyncFacebookRunner;
-import com.facebook.android.Facebook;
-import com.facebook.android.FacebookError;
-import com.facebook.android.AsyncFacebookRunner.RequestListener;
-
-/**
- * A handler for the logout link. This handler doesn't render
- * its own page. After logging out it redirects the user
- * to the login handler.
- * 
- * @author yariv
- */
-public class LogoutHandler extends Handler {
-
-    /**
-     * Called by the dispatcher when the user clicks 'logout'.
-     */
-    public void go() {
-        Facebook fb = Session.restore(getActivity()).getFb();
-
-        // clear the local session data
-        Session.clearSavedSession(getActivity());
-        new AsyncFacebookRunner(fb).logout(getActivity(), 
-                new RequestListener() {
-
-            public void onComplete(String response, final Object state) {
-                dispatcher.runHandler("login");
-            }
-
-            public void onFileNotFoundException(FileNotFoundException error,
-                                                final Object state) {
-                Log.e("app", error.toString());
-                dispatcher.runHandler("login");
-            }
-
-            public void onIOException(IOException error, final Object state) {
-                Log.e("app", error.toString());
-                dispatcher.runHandler("login");            
-            }
-
-            public void onMalformedURLException(MalformedURLException error,
-                                                final Object state) {
-                Log.e("app", error.toString());
-                dispatcher.runHandler("login");
-            }
-
-            public void onFacebookError(FacebookError error,
-                                        final Object state) {
-                Log.e("app", error.toString());
-                dispatcher.runHandler("login");
-            }
-        });
-    }
-}
diff --git a/examples/stream/src/com/facebook/stream/Session.java b/examples/stream/src/com/facebook/stream/Session.java
deleted file mode 100644
index f1af9ae74..000000000
--- a/examples/stream/src/com/facebook/stream/Session.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.content.SharedPreferences.Editor;
-
-import com.facebook.android.Facebook;
-
-/**
- * A utility class for storing and retrieving Facebook session data.
- * 
- * @author yariv
- */
-public class Session {
-
-    private static final String TOKEN = "access_token";
-    private static final String EXPIRES = "expires_in";
-    private static final String KEY = "facebook-session";
-    private static final String UID = "uid";
-    private static final String NAME = "name";
-    private static final String APP_ID = "app_id";
-
-    private static Session singleton;
-    private static Facebook fbLoggingIn;
-
-    // The Facebook object
-    private Facebook fb;
-
-    // The user id of the logged in user
-    private String uid;
-
-    // The user name of the logged in user
-    private String name;
-
-    /**
-     * Constructor
-     * 
-     * @param fb
-     * @param uid
-     * @param name
-     */
-    public Session(Facebook fb, String uid, String name) {
-        this.fb = fb;
-        this.uid = uid;
-        this.name = name;
-    }
-
-    /**
-     * Returns the Facebook object
-     */
-    public Facebook getFb() {
-        return fb;
-    }
-
-    /**
-     * Returns the session user's id
-     */
-    public String getUid() {
-        return uid;
-    }
-
-    /**
-     * Returns the session user's name 
-     */
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * Stores the session data on disk.
-     * 
-     * @param context
-     * @return
-     */
-    public boolean save(Context context) {
-
-        Editor editor =
-            context.getSharedPreferences(KEY, Context.MODE_PRIVATE).edit();
-        editor.putString(TOKEN, fb.getAccessToken());
-        editor.putLong(EXPIRES, fb.getAccessExpires());
-        editor.putString(UID, uid);
-        editor.putString(NAME, name);
-        editor.putString(APP_ID, fb.getAppId());
-        if (editor.commit()) {
-            singleton = this;
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Loads the session data from disk.
-     * 
-     * @param context
-     * @return
-     */
-    public static Session restore(Context context) {
-        if (singleton != null) {
-            if (singleton.getFb().isSessionValid()) {
-                return singleton;
-            } else {
-                return null;
-            }
-        }
-
-        SharedPreferences prefs =
-            context.getSharedPreferences(KEY, Context.MODE_PRIVATE);
-        
-        String appId = prefs.getString(APP_ID, null);
-        
-        if (appId == null) {
-        	return null;
-        }
-        
-        Facebook fb = new Facebook(appId);
-        fb.setAccessToken(prefs.getString(TOKEN, null));
-        fb.setAccessExpires(prefs.getLong(EXPIRES, 0));
-        String uid = prefs.getString(UID, null);
-        String name = prefs.getString(NAME, null);
-        if (!fb.isSessionValid() || uid == null || name == null) {
-            return null;
-        }
-
-        Session session = new Session(fb, uid, name);
-        singleton = session;
-        return session;
-    }
-
-    /**
-     * Clears the saved session data.
-     * 
-     * @param context
-     */
-    public static void clearSavedSession(Context context) {
-        Editor editor = 
-            context.getSharedPreferences(KEY, Context.MODE_PRIVATE).edit();
-        editor.clear();
-        editor.commit();
-        singleton = null;
-    }
-
-    /**
-     * Freezes a Facebook object while it's waiting for an auth callback.
-     */
-    public static void waitForAuthCallback(Facebook fb) {
-        fbLoggingIn = fb;
-    }
-
-    /**
-     * Returns a Facebook object that's been waiting for an auth callback.
-     */
-    public static Facebook wakeupForAuthCallback() {
-        Facebook fb = fbLoggingIn;
-        fbLoggingIn = null;
-        return fb;
-    }
-
-}
diff --git a/examples/stream/src/com/facebook/stream/StreamHandler.java b/examples/stream/src/com/facebook/stream/StreamHandler.java
deleted file mode 100644
index b97c84f78..000000000
--- a/examples/stream/src/com/facebook/stream/StreamHandler.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.net.MalformedURLException;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import android.util.Log;
-
-import com.facebook.android.AsyncFacebookRunner;
-import com.facebook.android.Facebook;
-import com.facebook.android.FacebookError;
-import com.facebook.android.Util;
-import com.facebook.android.AsyncFacebookRunner.RequestListener;
-
-/**
- * A handler for the stream page. It's responsible for
- * fetching the stream data from the API and storing it
- * in a local file based cache. It uses the helper class
- * StreamRenderer to render the stream.
- *  
- * @author yariv
- */
-public class StreamHandler extends Handler {
-
-    private static final String CACHE_FILE = "cache.txt";
-
-    /**
-     * Called by the dispatcher to render the stream page.
-     */
-    public void go() {
-        dispatcher.getWebView().addJavascriptInterface(
-                new StreamJsHandler(this), "app");
-
-        // first try to load the cached data
-        try {
-            String cached = FileIO.read(getActivity(), CACHE_FILE);
-            if (cached != null) {
-                JSONObject obj = new JSONObject(cached);
-                dispatcher.loadData(StreamRenderer.render(obj));
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
-        } catch (JSONException e) {
-            e.printStackTrace();
-        }
-
-        Facebook fb = Session.restore(getActivity()).getFb();
-        new AsyncFacebookRunner(fb).request("me/home", 
-                new StreamRequestListener());
-    }
-
-    public class StreamRequestListener implements RequestListener {
-
-        public void onComplete(String response, final Object state) {
-            try {
-                JSONObject obj = Util.parseJson(response);
-                // try to cache the result
-                try {
-                    FileIO.write(getActivity(), response, CACHE_FILE);
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-
-                // Convert the result into an HTML string and then load it
-                // into the WebView in the UI thread.
-                final String html = StreamRenderer.render(obj);
-                getActivity().runOnUiThread(new Runnable() {
-                    public void run() {
-                        dispatcher.loadData(html);
-                    }
-                });
-
-            } catch (JSONException e) {
-                Log.e("stream", "JSON Error:" + e.getMessage());
-            } catch (FacebookError e) {
-                Log.e("stream", "Facebook Error:" + e.getMessage());
-            }
-        }
-
-        public void onFacebookError(FacebookError e, final Object state) {
-            Log.e("stream", "Facebook Error:" + e.getMessage());
-        }
-
-        public void onFileNotFoundException(FileNotFoundException e,
-                                            final Object state) {
-            Log.e("stream", "Resource not found:" + e.getMessage());      
-        }
-
-        public void onIOException(IOException e, final Object state) {
-            Log.e("stream", "Network Error:" + e.getMessage());      
-        }
-
-        public void onMalformedURLException(MalformedURLException e,
-                                            final Object state) {
-            Log.e("stream", "Invalid URL:" + e.getMessage());            
-        }
-
-    }
-}
diff --git a/examples/stream/src/com/facebook/stream/StreamJsHandler.java b/examples/stream/src/com/facebook/stream/StreamJsHandler.java
deleted file mode 100644
index a1f633edf..000000000
--- a/examples/stream/src/com/facebook/stream/StreamJsHandler.java
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import java.text.SimpleDateFormat;
-import java.util.Date;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import android.os.Bundle;
-import com.facebook.android.AsyncFacebookRunner;
-import com.facebook.android.Facebook;
-
-/**
- * Implements functions that can be called from Javascript in the
- * stream page.
- * 
- * @author yariv
- */
-class StreamJsHandler {
-
-    // The handler for the Stream page
-    private final StreamHandler streamHandler;
-
-    /**
-     * @param streamHandler
-     */
-    StreamJsHandler(StreamHandler streamHandler) {
-        this.streamHandler = streamHandler;
-    }
-
-    /**
-     * Returns the Facebook object.
-     */
-    private AsyncFacebookRunner getFb() {
-        Facebook fb = Session.restore(streamHandler.getActivity()).getFb();
-        return new AsyncFacebookRunner(fb);
-    }
-
-    /**
-     * Update the status and render the resulting status at the
-     * top of the stream.
-     *  
-     * @param message
-     */
-    public void updateStatus(final String message) {
-        AsyncFacebookRunner fb = getFb();
-        Bundle params = new Bundle();
-        params.putString("message", message);
-        fb.request("me/feed", params, "POST", new AsyncRequestListener() {
-
-            public void onComplete(JSONObject obj, final Object state) {
-                String html;
-                try {
-                    html = renderStatus(obj, message);
-                    html = html.replace("'", "\\\'");
-                    callJs("onStatusUpdated('" + html + "');");
-                } catch (JSONException e) {
-                    // TODO Auto-generated catch block
-                    e.printStackTrace();
-                }
-            }
-        }, null);
-    }
-
-    /**
-     * Renders the html for the new status.
-     * 
-     * @param response
-     * @param message
-     * @return
-     * @throws JSONException
-     */
-    private String renderStatus(JSONObject response, String message)
-            throws JSONException {
-
-        String postId = response.getString("id");
-        JSONObject post = new JSONObject();
-        post.put("id", postId);
-        post.put("message", message);
-
-        JSONObject from = createAuthorObj();
-        post.put("from", from);
-
-        JSONArray actions = new JSONArray();
-        JSONObject like = new JSONObject();
-        like.put("name", "Like");
-        actions.put(like);
-
-        JSONObject comment = new JSONObject();
-        comment.put("name", "Comment");
-        actions.put(comment);
-
-        post.put("actions", actions);
-
-        SimpleDateFormat format = StreamRenderer.getDateFormat();
-        String timestamp = format.format(new Date());
-        post.put("created_time", timestamp);
-
-        String html = StreamRenderer.renderSinglePost(post);
-        return html;
-    }
-
-    /**
-     * Like or unlike a post
-     * 
-     * @param post_id
-     * @param val if the action should be a like (true) or an unlike (false)
-     */
-    public void like(final String post_id, final boolean val) {
-        Bundle params = new Bundle();
-        if (!val) {
-            params.putString("method", "delete");
-        }
-        getFb().request(post_id + "/likes", new Bundle(), "POST",
-                new AsyncRequestListener() {
-
-            public void onComplete(JSONObject response, final Object state) {
-                callJs("javascript:onLike('" + post_id + "'," + val + ")");
-            }
-        }, null);
-    }
-
-
-    public void postComment(final String post_id, final String message) {
-        Bundle params = new Bundle();
-        params.putString("message", message);
-
-        getFb().request(post_id + "/comments", params, "POST",
-                new AsyncRequestListener() {
-
-            public void onComplete(JSONObject response, final Object state) {
-
-                try {
-                    String html = renderComment(response, message);
-                    html = html.replace("'", "\\'");
-                    callJs("onComment('" + post_id + "','" + html + "');");
-                } catch (JSONException e) {
-                    e.printStackTrace();
-                }
-
-            }
-        }, null);
-    }
-
-    /**
-     * Renders the html string for a new comment.
-     * 
-     * @param response
-     * @param message
-     * @return
-     * @throws JSONException
-     */
-    private String renderComment(JSONObject response, String message)
-            throws JSONException {
-
-        JSONObject comment = new JSONObject();
-        String commentId = response.getString("id");
-        comment.put("id", commentId);
-        comment.put("from", createAuthorObj());
-        comment.put("message", message);
-
-        String html = StreamRenderer.renderSingleComment(comment);
-        return html;
-    }
-
-    /**
-     * Executes javascript code inside WebKit.
-     * 
-     * @param js
-     */
-    private void callJs(String js) {
-        streamHandler.getWebView().loadUrl("javascript:" + js);
-    }
-
-    /**
-     * Creates a JSONObject for the post or comment author.
-     *  
-     * @return
-     * @throws JSONException
-     */
-    private JSONObject createAuthorObj() throws JSONException {
-        Session session = Session.restore(streamHandler.getActivity());
-        JSONObject from = new JSONObject();
-        from.put("id", session.getUid());
-        from.put("name", session.getName());
-        return from;
-    }
-}
\ No newline at end of file
diff --git a/examples/stream/src/com/facebook/stream/StreamRenderer.java b/examples/stream/src/com/facebook/stream/StreamRenderer.java
deleted file mode 100644
index b7a470416..000000000
--- a/examples/stream/src/com/facebook/stream/StreamRenderer.java
+++ /dev/null
@@ -1,538 +0,0 @@
-/*
- * Copyright 2010 Facebook, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.stream;
-
-import java.text.ParsePosition;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.HashSet;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import android.util.Log;
-
-/**
- * Contains logic for converting a JSONObject obtained from
- * querying /me/home to a HTML string that can be rendered
- * in WebKit.
- * 
- * @author yariv
- */
-class StreamRenderer {
-
-    private StringBuilder sb;
-
-    /**
-     * The main function for rendering the stream JSONObject.
-     * 
-     * @param data
-     * @return
-     */
-    public static String render(JSONObject data) {
-        StreamRenderer renderer = new StreamRenderer();
-        return renderer.doRender(data);
-    }
-
-    /**
-     * Renders the HTML for a single post.
-     * 
-     * @param post
-     * @return
-     * @throws JSONException
-     */
-    public static String renderSinglePost(JSONObject post)
-            throws JSONException {
-
-        StreamRenderer renderer = new StreamRenderer();
-        renderer.renderPost(post);
-        return renderer.getResult();
-    }
-
-    /**
-     * Renders the HTML for a single comment.
-     * 
-     * @param comment
-     * @return
-     */
-    public static String renderSingleComment(JSONObject comment) {
-        StreamRenderer renderer = new StreamRenderer();
-        renderer.renderComment(comment);
-        return renderer.getResult();
-    }
-
-
-    private StreamRenderer() {
-        this.sb = new StringBuilder();
-    }
-
-    /**
-     * Returns a SimpleDateFormat object we use for
-     * parsing and rendering timestamps.
-     * 
-     * @return
-     */
-    public static SimpleDateFormat getDateFormat() {
-        return new SimpleDateFormat("yyyy-MM-dd'T'hh:mm:ssZ");
-    }
-
-    /**
-     * Returns the result html.
-     * 
-     * @return
-     */
-    private String getResult() {
-        return sb.toString();
-    }
-
-    private String doRender(JSONObject data) {
-
-        try {
-            JSONArray posts = data.getJSONArray("data");
-            String[] chunks = {
-                "<html><head>",
-                "<link rel=\"stylesheet\" " +
-                "href=\"file:///android_asset/stream.css\" type=\"text/css\">",
-                "<script src=\"file:///android_asset/stream.js\"></script>",
-                "</head>",
-                "<body>",
-                "<div id=\"header\">"
-            };
-            append(chunks);
-            renderLink("app://logout", "logout");
-
-            renderStatusBox();
-
-            append("<div id=\"posts\">");
-            for (int i = 0; i < posts.length(); i++) {
-                renderPost(posts.getJSONObject(i));
-            }
-            append("</div></body></html>");
-            return getResult();
-        } catch (JSONException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-            return "";
-        }
-    }
-
-    /**
-     * Renders the "what's on your mind?" box and the Share button.
-     */
-    private void renderStatusBox() {
-        String[] chunks = new String[] {
-            "</div><div class=\"clear\"></div>",
-            "<div id=\"status_box\">",
-            "<input id=\"status_input\" value=\" What's on your mind?\"",
-            " onfocus=\"onStatusBoxFocus(this);\"/>",
-            "<button id=\"status_submit\" class=\"hidden\" " +
-            "onclick=\"updateStatus();\">Share</button>",
-            "<div class=\"clear\"></div>",
-            "</div>"
-        };
-        append(chunks);
-    }
-
-    /**
-     * Renders a single post
-     * 
-     * @param post
-     * @throws JSONException
-     */
-    private void renderPost(JSONObject post) throws JSONException {
-        append("<div class=\"post\">");
-        renderFrom(post);
-        renderTo(post);
-        renderMessage(post);
-        renderAttachment(post);
-        renderActionLinks(post);
-        renderLikes(post);
-        renderComments(post);
-        renderCommentBox(post);
-        append("</div>");
-    }
-
-
-    /**
-     * Renders the author's name
-     * 
-     * @param post
-     * @throws JSONException
-     */
-    private void renderFrom(JSONObject post) throws JSONException {
-        JSONObject from = post.getJSONObject("from");
-        String fromName = from.getString("name");
-        String fromId = from.getString("id");
-        renderAuthor(fromId, fromName);
-    }
-
-    /**
-     * If it's a wall post on a friend's fall, renders
-     * the recipient's name preceded by a '>'.
-     * 
-     * @param post
-     * @throws JSONException
-     */
-    private void renderTo(JSONObject post) throws JSONException {
-        JSONObject to = post.optJSONObject("to");
-        if (to != null) {
-            JSONObject toData = to.getJSONArray("data").getJSONObject(0);
-            String toName = toData.getString("name");
-            String toId = toData.getString("id");
-            append(" > ");
-            renderProfileLink(toId, toName);
-        }
-    }
-
-    /**
-     * Renders a link to a user.
-     * 
-     * @param id
-     * @param name
-     */
-    private void renderProfileLink(String id, String name) {
-        renderLink(getProfileUrl(id), name);
-    }
-
-    private String getProfileUrl(String id) {
-        return "http://touch.facebook.com/#/profile.php?id=" + id;
-    }
-
-    /**
-     * Renders the author pic and name.
-     * 
-     * @param id
-     * @param name
-     */
-    private void renderAuthor(String id, String name) {
-        String[] chunks = {
-            "<div class=\"profile_pic_container\">",
-            "<a href=\"", getProfileUrl(id),
-            "\"><img class=\"profile_pic\" src=\"http://graph.facebook.com/",
-            id, "/picture\"/></a>",
-            "</div>"
-        };
-        append(chunks);
-        renderProfileLink(id, name);
-    }
-
-    /**
-     * Renders the post message.
-     * 
-     * @param post
-     */
-    private void renderMessage(JSONObject post) {
-        String message = post.optString("message");
-        String[] chunks = {
-            "&nbsp;<span class=\"msg\">", message, "</span>",
-            "<div class=\"clear\"></div>"
-        };
-        append(chunks);
-    }
-
-    /**
-     * Renders the attachment.
-     * 
-     * @param post
-     */
-    private void renderAttachment(JSONObject post) {
-        String name = post.optString("name");
-        String link = post.optString("link");
-        String picture = post.optString("picture");
-        String source = post.optString("source"); // for videos
-        String caption = post.optString("caption");
-        String description = post.optString("description");
-
-        String[] fields = new String[] {
-                name, link, picture, source, caption, description
-        };
-        boolean hasAttachment = false;
-        for (String field : fields) {
-            if (field.length() != 0) {
-                hasAttachment = true;
-                break;
-            }
-        }
-
-        if (!hasAttachment) {
-            return;
-        }
-
-        append("<div class=\"attachment\">");
-        if (name != "") {
-            append("<div class=\"title\">");
-            if (link != null) {
-                renderLink(link, name);
-            } else {
-                append(name);
-            }
-            append("</div>");
-        }
-        if (caption != "") {
-            append("<div class=\"caption\">" + caption + "</div>");
-        }
-
-        if (picture != "") {
-            append("<div class=\"picture\">");
-            String img = "<img src=\"" + picture + "\"/>";
-            if (link != "") {
-                renderLink(link, img);
-            } else {
-                append(img);
-            }
-            append("</div>");
-        }
-
-        if (description != "") {
-            append("<div class=\"description\">" + description + "</div>");
-        }
-        append("<div class=\"clear\"></div></div>");
-    }
-
-    /**
-     * Renders an anchor tag
-     *  
-     * @param href
-     * @param text
-     */
-    private void renderLink(String href, String text) {
-        append(new String[] {
-            "<a href=\"",
-            href,
-            "\">",
-            text,
-            "</a>"
-        });
-    }
-
-    /**
-     * Renders the posts' action links.
-     * 
-     * @param post
-     */
-    private void renderActionLinks(JSONObject post) {
-        HashSet<String> actions = getActions(post);
-        append("<div class=\"action_links\">");
-        append("<div class=\"action_link\">");
-        renderTimeStamp(post);
-        append("</div>");
-        String post_id = post.optString("id");
-        if (actions.contains("Comment")) {
-            renderActionLink(post_id, "Comment", "comment");
-        }
-        boolean canLike = actions.contains("Like");
-        renderActionLink(post_id, "Like", "like", canLike);
-        renderActionLink(post_id, "Unlike", "unlike", !canLike);
-
-        append("<div class=\"clear\"></div></div>");
-    }
-
-    /**
-     * Renders a single visible action link.
-     *  
-     * @param post_id
-     * @param title
-     * @param func
-     */
-    private void renderActionLink(String post_id, String title, String func) { 
-        renderActionLink(post_id, title, func, true);
-    }
-
-    /**
-     * Renders an action link with optional visibility.
-     * 
-     * @param post_id
-     * @param title
-     * @param func
-     * @param visible
-     */
-    private void renderActionLink(String post_id, String title, String func, 
-            boolean visible) {
-        String extraClass = visible ? "" : "hidden";
-        String[] chunks = new String[] {
-            "<div id=\"", func, post_id, "\" class=\"action_link ", 
-            extraClass, "\">", "<a href=\"#\" onclick=\"",func, "('",
-            post_id, "'); return false;\">", title, "</a></div>"
-        };
-        append(chunks);
-    }
-
-    /**
-     * Renders the post's timestamp.
-     * 
-     * @param post
-     */
-    private void renderTimeStamp(JSONObject post) {
-        String dateStr = post.optString("created_time");
-        SimpleDateFormat formatter = getDateFormat();
-        ParsePosition pos = new ParsePosition(0);
-        long then  = formatter.parse(dateStr, pos).getTime();
-        long now = new Date().getTime();
-
-        long seconds = (now - then)/1000;
-        long minutes = seconds/60;
-        long hours = minutes/60;
-        long days = hours/24;
-
-        String friendly = null;
-        long num = 0;
-        if (days > 0) {
-            num = days;
-            friendly = days + " day";
-        } else if (hours > 0) {
-            num = hours;
-            friendly = hours + " hour";
-        } else if (minutes > 0) {
-            num = minutes;
-            friendly = minutes + " minute";
-        } else {
-            num = seconds;
-            friendly = seconds + " second";
-        }
-        if (num > 1) {
-            friendly += "s";
-        }
-        String[] chunks = new String[] {
-            "<div class=\"timestamp\">",
-            friendly,
-            " ago",
-            "</div>"
-        };
-        append(chunks);
-    }
-
-    /**
-     * Returns the available actions for the post.
-     * 
-     * @param post
-     * @return
-     */
-    private HashSet<String> getActions(JSONObject post) {
-        HashSet<String> actionsSet = new HashSet<String>();
-        JSONArray actions = post.optJSONArray("actions");
-        if (actions != null) {
-            for (int j = 0; j < actions.length(); j++) {
-                JSONObject action = actions.optJSONObject(j);
-                String actionName = action.optString("name");
-                actionsSet.add(actionName);
-            }
-        }
-        return actionsSet;
-    }
-
-    /**
-     * Renders the 'x people like this' text,
-     * 
-     * @param post
-     */
-    private void renderLikes(JSONObject post) {
-        int numLikes = post.optInt("likes", 0);
-        if (numLikes > 0) {
-            String desc = numLikes == 1 ?
-                "person likes this" :
-                "people like this";
-            String[] chunks = new String[] {
-                "<div class=\"like_icon\">",
-                "<img src=\"file:///android_asset/like_icon.png\"/>",
-                "</div>",
-                "<div class=\"num_likes\">",
-                new Integer(numLikes).toString(),
-                " ",
-                desc,
-                "</div>"
-            };
-            append(chunks);
-        }
-    }
-
-    /**
-     * Renders the post's comments.
-     * 
-     * @param post
-     * @throws JSONException
-     */
-    private void renderComments(JSONObject post) throws JSONException {
-        append("<div class=\"comments\" id=\"comments" + post.optString("id")
-                + "\">");
-        JSONObject comments = post.optJSONObject("comments");
-        if (comments != null) {
-            JSONArray data = comments.optJSONArray("data");
-            if (data != null) {
-                for (int j = 0; j < data.length(); j++) {
-                    JSONObject comment = data.getJSONObject(j);
-                    renderComment(comment);
-                }
-            }
-        }
-        append("</div>");
-    }
-
-    /**
-     * Renders an individual comment.
-     * 
-     * @param comment
-     */
-    private void renderComment(JSONObject comment) {
-        JSONObject from = comment.optJSONObject("from");
-        if (from == null) {
-            Log.w("StreamRenderer",
-                    "Comment missing from field: " + comment.toString());
-        } else {
-            String authorId = from.optString("id");
-            String authorName = from.optString("name");
-            renderAuthor(authorId, authorName);
-        }
-        String message = comment.optString("message");
-        append("<div class=\"comment\">");
-        String[] chunks = {
-            "&nbsp;",
-            message,
-            "</div>"
-        };	
-        append(chunks);
-    }
-
-
-    /**
-     * Renders the new comment input box.
-     * 
-     * @param post
-     */
-    private void renderCommentBox(JSONObject post) {
-        String id = post.optString("id");
-        String[] chunks = new String[] {
-            "<div class=\"comment_box\" id=\"comment_box", id, "\">",
-            "<input id=\"comment_box_input", id, "\"/>",
-            "<button onclick=\"postComment('", id , "');\">Post</button>",
-            "<div class=\"clear\"></div>",
-            "</div>"
-        };
-        append(chunks);
-    }
-
-
-    private void append(String str) {
-        sb.append(str);
-    }
-
-    private void append(String[] chunks) {
-        for (String chunk : chunks) {
-            sb.append(chunk);
-        }
-    }
-}
\ No newline at end of file
diff --git a/facebook/.classpath b/facebook/.classpath
new file mode 100644
index 000000000..c5c5afd01
--- /dev/null
+++ b/facebook/.classpath
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="lib" path="libs/android-support-v4.jar"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/facebook/.project b/facebook/.project
new file mode 100644
index 000000000..d0551a112
--- /dev/null
+++ b/facebook/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>FacebookSDK</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/facebook/AndroidManifest.xml b/facebook/AndroidManifest.xml
index c79b191b3..c9cce4fb7 100644
--- a/facebook/AndroidManifest.xml
+++ b/facebook/AndroidManifest.xml
@@ -19,4 +19,5 @@
       package="com.facebook.android">
     <uses-sdk android:minSdkVersion="3"/>
     <application/>
+    <uses-sdk android:minSdkVersion="8" />
 </manifest>
diff --git a/facebook/TestApp/AndroidManifest.xml b/facebook/TestApp/AndroidManifest.xml
new file mode 100644
index 000000000..cccc2923d
--- /dev/null
+++ b/facebook/TestApp/AndroidManifest.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+      package="com.facebook.sdk"
+      android:versionCode="1"
+      android:versionName="1.0">
+    <application android:label="@string/app_name" android:icon="@drawable/ic_launcher">
+        <activity android:name="StatusActivity"
+                  android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+</manifest>
diff --git a/facebook/TestApp/SdkTestApp.eml b/facebook/TestApp/SdkTestApp.eml
new file mode 100644
index 000000000..4104d1ffc
--- /dev/null
+++ b/facebook/TestApp/SdkTestApp.eml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<component>
+	<exclude-output/>
+	<contentEntry url="file://$MODULE_DIR$"/>
+</component>
diff --git a/facebook/TestApp/SdkTestApp.iml b/facebook/TestApp/SdkTestApp.iml
new file mode 100644
index 000000000..1e6d309b6
--- /dev/null
+++ b/facebook/TestApp/SdkTestApp.iml
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="EclipseModuleManager">
+    <conelement value="com.android.ide.eclipse.adt.LIBRARIES" />
+    <src_description expected_position="0">
+      <src_folder value="file://$MODULE_DIR$/src" expected_position="0" />
+      <src_folder value="file://$MODULE_DIR$/gen" expected_position="1" />
+    </src_description>
+  </component>
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="true" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/bin/classes" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+  </component>
+</module>
+
diff --git a/facebook/TestApp/ant.properties b/facebook/TestApp/ant.properties
new file mode 100644
index 000000000..b0971e891
--- /dev/null
+++ b/facebook/TestApp/ant.properties
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff --git a/facebook/TestApp/build.xml b/facebook/TestApp/build.xml
new file mode 100644
index 000000000..ea49a3fca
--- /dev/null
+++ b/facebook/TestApp/build.xml
@@ -0,0 +1,83 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="FacebookSdk" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties" />
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties" />
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties" />
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through an env var"
+            unless="sdk.dir"
+    />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true" />
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml" />
+
+</project>
diff --git a/examples/Hackbook/proguard-project.txt b/facebook/TestApp/proguard-project.txt
similarity index 100%
rename from examples/Hackbook/proguard-project.txt
rename to facebook/TestApp/proguard-project.txt
diff --git a/facebook/TestApp/project.properties b/facebook/TestApp/project.properties
new file mode 100644
index 000000000..b0620672e
--- /dev/null
+++ b/facebook/TestApp/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+
diff --git a/examples/stream/res/drawable-hdpi/icon.png b/facebook/TestApp/res/drawable-hdpi/ic_launcher.png
similarity index 100%
rename from examples/stream/res/drawable-hdpi/icon.png
rename to facebook/TestApp/res/drawable-hdpi/ic_launcher.png
diff --git a/examples/stream/res/drawable-ldpi/icon.png b/facebook/TestApp/res/drawable-ldpi/ic_launcher.png
similarity index 100%
rename from examples/stream/res/drawable-ldpi/icon.png
rename to facebook/TestApp/res/drawable-ldpi/ic_launcher.png
diff --git a/examples/simple/res/drawable/icon.png b/facebook/TestApp/res/drawable-mdpi/ic_launcher.png
similarity index 100%
rename from examples/simple/res/drawable/icon.png
rename to facebook/TestApp/res/drawable-mdpi/ic_launcher.png
diff --git a/facebook/TestApp/res/layout/main.xml b/facebook/TestApp/res/layout/main.xml
new file mode 100644
index 000000000..da713e268
--- /dev/null
+++ b/facebook/TestApp/res/layout/main.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    >
+<TextView
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:text="SDK Unit Tests"
+    />
+</LinearLayout>
+
diff --git a/facebook/TestApp/res/values/strings.xml b/facebook/TestApp/res/values/strings.xml
new file mode 100644
index 000000000..b2e26a0c0
--- /dev/null
+++ b/facebook/TestApp/res/values/strings.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<resources>
+    <string name="app_name">StatusActivity</string>
+</resources>
diff --git a/facebook/TestApp/src/com/facebook/sdk/StatusActivity.java b/facebook/TestApp/src/com/facebook/sdk/StatusActivity.java
new file mode 100644
index 000000000..d0930d9ad
--- /dev/null
+++ b/facebook/TestApp/src/com/facebook/sdk/StatusActivity.java
@@ -0,0 +1,31 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.sdk;
+
+import android.app.Activity;
+import android.os.Bundle;
+
+public class StatusActivity extends Activity
+{
+    /** Called when the activity is first created. */
+    @Override
+    public void onCreate(Bundle savedInstanceState)
+    {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+    }
+}
diff --git a/facebook/android-sdk.eml b/facebook/android-sdk.eml
new file mode 100644
index 000000000..4104d1ffc
--- /dev/null
+++ b/facebook/android-sdk.eml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<component>
+	<exclude-output/>
+	<contentEntry url="file://$MODULE_DIR$"/>
+</component>
diff --git a/facebook/android-sdk.iml b/facebook/android-sdk.iml
new file mode 100644
index 000000000..52b1b195c
--- /dev/null
+++ b/facebook/android-sdk.iml
@@ -0,0 +1,55 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="EclipseModuleManager">
+    <conelement value="com.android.ide.eclipse.adt.LIBRARIES" />
+    <src_description expected_position="0">
+      <src_folder value="file://$MODULE_DIR$/src" expected_position="0" />
+      <src_folder value="file://$MODULE_DIR$/gen" expected_position="1" />
+    </src_description>
+  </component>
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="true" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/bin/classes" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/res" isTestSource="false" />
+    </content>
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/facebook/ant.properties b/facebook/ant.properties
new file mode 100644
index 000000000..b206ddecc
--- /dev/null
+++ b/facebook/ant.properties
@@ -0,0 +1,2 @@
+jar.libs.dir=../lib
+java.compilerargs=-Xlint -Werror
\ No newline at end of file
diff --git a/facebook/libs b/facebook/libs
new file mode 120000
index 000000000..d4bda9b46
--- /dev/null
+++ b/facebook/libs
@@ -0,0 +1 @@
+../libs
\ No newline at end of file
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_grey_focused.9.png b/facebook/res/drawable-hdpi/com_facebook_button_grey_focused.9.png
new file mode 100644
index 000000000..2e6f66dbc
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_button_grey_focused.9.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_grey_normal.9.png b/facebook/res/drawable-hdpi/com_facebook_button_grey_normal.9.png
new file mode 100644
index 000000000..6098f0b0e
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_button_grey_normal.9.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_button_grey_pressed.9.png b/facebook/res/drawable-hdpi/com_facebook_button_grey_pressed.9.png
new file mode 100644
index 000000000..23b9757d1
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_button_grey_pressed.9.png differ
diff --git a/facebook/res/drawable-hdpi/close.png b/facebook/res/drawable-hdpi/com_facebook_close.png
similarity index 51%
rename from facebook/res/drawable-hdpi/close.png
rename to facebook/res/drawable-hdpi/com_facebook_close.png
index d44c33575..d925cb7b2 100644
Binary files a/facebook/res/drawable-hdpi/close.png and b/facebook/res/drawable-hdpi/com_facebook_close.png differ
diff --git a/facebook/res/drawable-hdpi/facebook_icon.png b/facebook/res/drawable-hdpi/com_facebook_icon.png
similarity index 100%
rename from facebook/res/drawable-hdpi/facebook_icon.png
rename to facebook/res/drawable-hdpi/com_facebook_icon.png
diff --git a/facebook/res/drawable-hdpi/com_facebook_loginbutton_blue_focused.png b/facebook/res/drawable-hdpi/com_facebook_loginbutton_blue_focused.png
new file mode 100644
index 000000000..7badb08d7
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_loginbutton_blue_focused.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_loginbutton_blue_normal.png b/facebook/res/drawable-hdpi/com_facebook_loginbutton_blue_normal.png
new file mode 100644
index 000000000..7f71a8a6d
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_loginbutton_blue_normal.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_loginbutton_blue_pressed.png b/facebook/res/drawable-hdpi/com_facebook_loginbutton_blue_pressed.png
new file mode 100644
index 000000000..7badb08d7
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_loginbutton_blue_pressed.png differ
diff --git a/facebook/res/drawable-hdpi/com_facebook_logo.png b/facebook/res/drawable-hdpi/com_facebook_logo.png
new file mode 100644
index 000000000..26ab7945f
Binary files /dev/null and b/facebook/res/drawable-hdpi/com_facebook_logo.png differ
diff --git a/facebook/res/drawable-ldpi/close.png b/facebook/res/drawable-ldpi/com_facebook_close.png
similarity index 100%
rename from facebook/res/drawable-ldpi/close.png
rename to facebook/res/drawable-ldpi/com_facebook_close.png
diff --git a/facebook/res/drawable-ldpi/facebook_icon.png b/facebook/res/drawable-ldpi/com_facebook_icon.png
similarity index 100%
rename from facebook/res/drawable-ldpi/facebook_icon.png
rename to facebook/res/drawable-ldpi/com_facebook_icon.png
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_grey_focused.9.png b/facebook/res/drawable-xhdpi/com_facebook_button_grey_focused.9.png
new file mode 100644
index 000000000..bfd883f92
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_button_grey_focused.9.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_grey_normal.9.png b/facebook/res/drawable-xhdpi/com_facebook_button_grey_normal.9.png
new file mode 100644
index 000000000..aa9895432
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_button_grey_normal.9.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_button_grey_pressed.9.png b/facebook/res/drawable-xhdpi/com_facebook_button_grey_pressed.9.png
new file mode 100644
index 000000000..92f2ad12a
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_button_grey_pressed.9.png differ
diff --git a/facebook/res/drawable-xhdpi/close.png b/facebook/res/drawable-xhdpi/com_facebook_close.png
old mode 100644
new mode 100755
similarity index 100%
rename from facebook/res/drawable-xhdpi/close.png
rename to facebook/res/drawable-xhdpi/com_facebook_close.png
diff --git a/facebook/res/drawable-xhdpi/com_facebook_loginbutton_blue_focused.png b/facebook/res/drawable-xhdpi/com_facebook_loginbutton_blue_focused.png
new file mode 100644
index 000000000..93882b64b
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_loginbutton_blue_focused.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_loginbutton_blue_normal.png b/facebook/res/drawable-xhdpi/com_facebook_loginbutton_blue_normal.png
new file mode 100644
index 000000000..911feeee9
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_loginbutton_blue_normal.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_loginbutton_blue_pressed.png b/facebook/res/drawable-xhdpi/com_facebook_loginbutton_blue_pressed.png
new file mode 100644
index 000000000..93882b64b
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_loginbutton_blue_pressed.png differ
diff --git a/facebook/res/drawable-xhdpi/com_facebook_logo.png b/facebook/res/drawable-xhdpi/com_facebook_logo.png
new file mode 100644
index 000000000..24d7fc56b
Binary files /dev/null and b/facebook/res/drawable-xhdpi/com_facebook_logo.png differ
diff --git a/facebook/res/drawable/com_facebook_button_check.xml b/facebook/res/drawable/com_facebook_button_check.xml
new file mode 100644
index 000000000..a201c2634
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_button_check.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+  <item android:state_checked="true" android:drawable="@drawable/com_facebook_button_check_on" />
+  <item android:drawable="@drawable/com_facebook_button_check_off" />
+</selector>
diff --git a/facebook/res/drawable/com_facebook_button_check_off.png b/facebook/res/drawable/com_facebook_button_check_off.png
new file mode 100644
index 000000000..e9737df5c
Binary files /dev/null and b/facebook/res/drawable/com_facebook_button_check_off.png differ
diff --git a/facebook/res/drawable/com_facebook_button_check_on.png b/facebook/res/drawable/com_facebook_button_check_on.png
new file mode 100644
index 000000000..d793151e6
Binary files /dev/null and b/facebook/res/drawable/com_facebook_button_check_on.png differ
diff --git a/facebook/res/drawable/com_facebook_button_grey_focused.9.png b/facebook/res/drawable/com_facebook_button_grey_focused.9.png
new file mode 100644
index 000000000..56f603571
Binary files /dev/null and b/facebook/res/drawable/com_facebook_button_grey_focused.9.png differ
diff --git a/facebook/res/drawable/com_facebook_button_grey_normal.9.png b/facebook/res/drawable/com_facebook_button_grey_normal.9.png
new file mode 100644
index 000000000..dff3b7d73
Binary files /dev/null and b/facebook/res/drawable/com_facebook_button_grey_normal.9.png differ
diff --git a/facebook/res/drawable/com_facebook_button_grey_pressed.9.png b/facebook/res/drawable/com_facebook_button_grey_pressed.9.png
new file mode 100644
index 000000000..46648efcd
Binary files /dev/null and b/facebook/res/drawable/com_facebook_button_grey_pressed.9.png differ
diff --git a/facebook/res/drawable/close.png b/facebook/res/drawable/com_facebook_close.png
old mode 100644
new mode 100755
similarity index 60%
rename from facebook/res/drawable/close.png
rename to facebook/res/drawable/com_facebook_close.png
index ed8b374b1..ad0147460
Binary files a/facebook/res/drawable/close.png and b/facebook/res/drawable/com_facebook_close.png differ
diff --git a/facebook/res/drawable/facebook_icon.png b/facebook/res/drawable/com_facebook_icon.png
similarity index 100%
rename from facebook/res/drawable/facebook_icon.png
rename to facebook/res/drawable/com_facebook_icon.png
diff --git a/facebook/res/drawable/com_facebook_list_divider.9.png b/facebook/res/drawable/com_facebook_list_divider.9.png
new file mode 100644
index 000000000..7d4c46c47
Binary files /dev/null and b/facebook/res/drawable/com_facebook_list_divider.9.png differ
diff --git a/facebook/res/drawable/com_facebook_list_section_header_background.9.png b/facebook/res/drawable/com_facebook_list_section_header_background.9.png
new file mode 100644
index 000000000..1763c4a64
Binary files /dev/null and b/facebook/res/drawable/com_facebook_list_section_header_background.9.png differ
diff --git a/facebook/res/drawable/com_facebook_loginbutton_blue.xml b/facebook/res/drawable/com_facebook_loginbutton_blue.xml
new file mode 100644
index 000000000..8dba4d0ac
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_loginbutton_blue.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<selector xmlns:android="http://schemas.android.com/apk/res/android" >
+    <item android:state_pressed="true" 
+          android:drawable="@drawable/com_facebook_loginbutton_blue_pressed" />
+    <item android:state_focused="true" 
+          android:drawable="@drawable/com_facebook_loginbutton_blue_focused" />
+    <item android:drawable="@drawable/com_facebook_loginbutton_blue_normal" />
+</selector>
diff --git a/facebook/res/drawable/com_facebook_loginbutton_blue_focused.png b/facebook/res/drawable/com_facebook_loginbutton_blue_focused.png
new file mode 100644
index 000000000..218b6e5d1
Binary files /dev/null and b/facebook/res/drawable/com_facebook_loginbutton_blue_focused.png differ
diff --git a/facebook/res/drawable/com_facebook_loginbutton_blue_normal.png b/facebook/res/drawable/com_facebook_loginbutton_blue_normal.png
new file mode 100644
index 000000000..121741085
Binary files /dev/null and b/facebook/res/drawable/com_facebook_loginbutton_blue_normal.png differ
diff --git a/facebook/res/drawable/com_facebook_loginbutton_blue_pressed.png b/facebook/res/drawable/com_facebook_loginbutton_blue_pressed.png
new file mode 100644
index 000000000..218b6e5d1
Binary files /dev/null and b/facebook/res/drawable/com_facebook_loginbutton_blue_pressed.png differ
diff --git a/facebook/res/drawable/com_facebook_loginbutton_silver.xml b/facebook/res/drawable/com_facebook_loginbutton_silver.xml
new file mode 100644
index 000000000..4ecb0c8c7
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_loginbutton_silver.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<selector xmlns:android="http://schemas.android.com/apk/res/android" >
+    <item android:state_pressed="true" 
+          android:drawable="@drawable/com_facebook_button_grey_pressed" />
+    <item android:state_focused="true" 
+          android:drawable="@drawable/com_facebook_button_grey_focused" />
+    <item android:drawable="@drawable/com_facebook_button_grey_normal" />
+</selector>
diff --git a/facebook/res/drawable/com_facebook_logo.png b/facebook/res/drawable/com_facebook_logo.png
new file mode 100644
index 000000000..785acf9ea
Binary files /dev/null and b/facebook/res/drawable/com_facebook_logo.png differ
diff --git a/facebook/res/drawable/com_facebook_picker_item_background.xml b/facebook/res/drawable/com_facebook_picker_item_background.xml
new file mode 100644
index 000000000..005870250
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_picker_item_background.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <!-- Even though these two point to the same resource, have two states so the drawable will invalidate itself when coming out of pressed state. -->
+    <item android:state_focused="true"  android:state_enabled="false" android:state_pressed="true" android:drawable="@drawable/com_facebook_picker_list_selector_disabled" />
+    <item android:state_focused="true"  android:state_enabled="false"                              android:drawable="@drawable/com_facebook_picker_list_selector_disabled" />
+    <item android:state_focused="true"                                android:state_pressed="true" android:drawable="@drawable/com_facebook_picker_list_selector_background_transition" />
+    <item android:state_focused="false"                               android:state_pressed="true" android:drawable="@drawable/com_facebook_picker_list_selector_background_transition" />
+    <item android:state_focused="true"                                                             android:drawable="@drawable/com_facebook_picker_list_focused" />
+    <item                                                                                          android:drawable="@android:color/transparent" />
+</selector>
diff --git a/facebook/res/drawable/com_facebook_picker_list_focused.9.png b/facebook/res/drawable/com_facebook_picker_list_focused.9.png
new file mode 100644
index 000000000..7c0599e3a
Binary files /dev/null and b/facebook/res/drawable/com_facebook_picker_list_focused.9.png differ
diff --git a/facebook/res/drawable/com_facebook_picker_list_longpressed.9.png b/facebook/res/drawable/com_facebook_picker_list_longpressed.9.png
new file mode 100644
index 000000000..3bf8e0362
Binary files /dev/null and b/facebook/res/drawable/com_facebook_picker_list_longpressed.9.png differ
diff --git a/facebook/res/drawable/com_facebook_picker_list_pressed.9.png b/facebook/res/drawable/com_facebook_picker_list_pressed.9.png
new file mode 100644
index 000000000..6e77525d2
Binary files /dev/null and b/facebook/res/drawable/com_facebook_picker_list_pressed.9.png differ
diff --git a/facebook/res/drawable/com_facebook_picker_list_selector.xml b/facebook/res/drawable/com_facebook_picker_list_selector.xml
new file mode 100644
index 000000000..ce9ed5ba8
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_picker_list_selector.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <item android:state_window_focused="false" android:drawable="@android:color/transparent" />
+
+    <item android:state_focused="true"  android:state_enabled="false" android:state_pressed="true" android:drawable="@drawable/com_facebook_picker_list_selector_disabled" />
+    <item android:state_focused="true"  android:state_enabled="false"                              android:drawable="@drawable/com_facebook_picker_list_selector_disabled" />
+    <item android:state_focused="true"                                android:state_pressed="true" android:drawable="@drawable/com_facebook_picker_list_selector_background_transition" />
+    <item android:state_focused="false"                               android:state_pressed="true" android:drawable="@drawable/com_facebook_picker_list_selector_background_transition" />
+    <item android:state_focused="true"                                                             android:drawable="@drawable/com_facebook_picker_list_focused" />
+
+</selector>
diff --git a/facebook/res/drawable/com_facebook_picker_list_selector_background_transition.xml b/facebook/res/drawable/com_facebook_picker_list_selector_background_transition.xml
new file mode 100644
index 000000000..0e4aa8eb8
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_picker_list_selector_background_transition.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2010 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<transition xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:drawable="@drawable/com_facebook_picker_list_pressed"  />
+    <item android:drawable="@drawable/com_facebook_picker_list_longpressed"  />
+</transition>
diff --git a/facebook/res/drawable/com_facebook_picker_list_selector_disabled.9.png b/facebook/res/drawable/com_facebook_picker_list_selector_disabled.9.png
new file mode 100644
index 000000000..42cb6463e
Binary files /dev/null and b/facebook/res/drawable/com_facebook_picker_list_selector_disabled.9.png differ
diff --git a/facebook/res/drawable/com_facebook_picker_top_button.xml b/facebook/res/drawable/com_facebook_picker_top_button.xml
new file mode 100644
index 000000000..4b7a7caa9
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_picker_top_button.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<shape xmlns:android="http://schemas.android.com/apk/res/android">
+    <gradient
+            android:startColor="#3f5b96"
+            android:endColor="#2d4984"
+            android:angle="270"/>
+</shape>
diff --git a/facebook/res/drawable/com_facebook_place_default_icon.png b/facebook/res/drawable/com_facebook_place_default_icon.png
new file mode 100644
index 000000000..97ec3e608
Binary files /dev/null and b/facebook/res/drawable/com_facebook_place_default_icon.png differ
diff --git a/facebook/res/drawable/com_facebook_profile_default_icon.png b/facebook/res/drawable/com_facebook_profile_default_icon.png
new file mode 100644
index 000000000..15864ccdb
Binary files /dev/null and b/facebook/res/drawable/com_facebook_profile_default_icon.png differ
diff --git a/facebook/res/drawable/com_facebook_profile_picture_blank_portrait.png b/facebook/res/drawable/com_facebook_profile_picture_blank_portrait.png
new file mode 100644
index 000000000..107d7f89e
Binary files /dev/null and b/facebook/res/drawable/com_facebook_profile_picture_blank_portrait.png differ
diff --git a/facebook/res/drawable/com_facebook_profile_picture_blank_square.png b/facebook/res/drawable/com_facebook_profile_picture_blank_square.png
new file mode 100644
index 000000000..8b4a76a0e
Binary files /dev/null and b/facebook/res/drawable/com_facebook_profile_picture_blank_square.png differ
diff --git a/facebook/res/drawable/com_facebook_top_background.xml b/facebook/res/drawable/com_facebook_top_background.xml
new file mode 100644
index 000000000..2f598d5f2
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_top_background.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<shape xmlns:android="http://schemas.android.com/apk/res/android">
+  <gradient
+      android:startColor="#FF5975b0"
+      android:endColor="#FF47639e"
+      android:angle="270"/>
+</shape>
diff --git a/facebook/res/drawable/com_facebook_top_button.xml b/facebook/res/drawable/com_facebook_top_button.xml
new file mode 100644
index 000000000..479e8596d
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_top_button.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_pressed="true"
+          android:drawable="@drawable/com_facebook_picker_top_button" />
+    <item android:state_focused="true"
+          android:drawable="@drawable/com_facebook_picker_top_button" />
+    <item android:state_selected="true"
+          android:drawable="@drawable/com_facebook_picker_top_button" />
+    <item
+            android:drawable="@drawable/com_facebook_top_background" />
+</selector>
diff --git a/facebook/res/drawable/com_facebook_usersettingsfragment_background_gradient.xml b/facebook/res/drawable/com_facebook_usersettingsfragment_background_gradient.xml
new file mode 100644
index 000000000..44c1a3c9a
--- /dev/null
+++ b/facebook/res/drawable/com_facebook_usersettingsfragment_background_gradient.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle">
+    <gradient
+      android:startColor="#5774B5"
+      android:endColor="#2C4988"
+      android:gradientRadius="495"
+      android:type="radial"/>
+</shape>    
diff --git a/facebook/res/layout/com_facebook_friendpickerfragment.xml b/facebook/res/layout/com_facebook_friendpickerfragment.xml
new file mode 100644
index 000000000..76b50c1d5
--- /dev/null
+++ b/facebook/res/layout/com_facebook_friendpickerfragment.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+              android:background="#FFFFFF">
+
+    <include layout="@layout/com_facebook_picker_title_bar_stub"/>
+
+    <ListView
+            android:id="@+id/com_facebook_picker_list_view"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:divider="@drawable/com_facebook_list_divider"
+            android:fastScrollEnabled="true"
+            android:scrollbars="vertical"
+            android:listSelector="@drawable/com_facebook_picker_list_selector"
+            android:cacheColorHint="#FFFFFF"
+            />
+
+    <ProgressBar android:indeterminate="true"
+                 android:layout_width="wrap_content"
+                 android:layout_height="wrap_content"
+                 android:id="@+id/com_facebook_picker_activity_circle"
+                 style="@android:style/Widget.ProgressBar"
+                 android:layout_centerInParent="true"
+                 android:visibility="invisible"
+            />
+</RelativeLayout>
diff --git a/facebook/res/layout/com_facebook_login_activity_layout.xml b/facebook/res/layout/com_facebook_login_activity_layout.xml
new file mode 100644
index 000000000..09b28999f
--- /dev/null
+++ b/facebook/res/layout/com_facebook_login_activity_layout.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent">
+
+    <ProgressBar android:indeterminate="true"
+                 android:layout_width="wrap_content"
+                 android:layout_height="50dip"
+                 android:id="@+id/com_facebook_login_activity_progress_bar"
+                 android:layout_centerInParent="true"
+                 android:visibility="gone"
+                 android:indeterminateOnly="true"
+            />
+</RelativeLayout>
diff --git a/facebook/res/layout/com_facebook_picker_activity_circle_row.xml b/facebook/res/layout/com_facebook_picker_activity_circle_row.xml
new file mode 100644
index 000000000..29e8bc81b
--- /dev/null
+++ b/facebook/res/layout/com_facebook_picker_activity_circle_row.xml
@@ -0,0 +1,32 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<RelativeLayout
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        android:layout_height="50dip"
+        android:layout_width="fill_parent"
+        >
+    <ProgressBar android:indeterminate="true"
+                 android:layout_width="wrap_content"
+                 android:layout_height="50dip"
+                 android:id="@+id/com_facebook_picker_row_activity_circle"
+                 style="@android:style/Widget.ProgressBar.Small"
+                 android:layout_centerInParent="true"
+                 android:visibility="visible"
+                 android:indeterminateOnly="true"
+            />
+</RelativeLayout>
diff --git a/facebook/res/layout/com_facebook_picker_checkbox.xml b/facebook/res/layout/com_facebook_picker_checkbox.xml
new file mode 100644
index 000000000..8adf7b3d7
--- /dev/null
+++ b/facebook/res/layout/com_facebook_picker_checkbox.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<CheckBox
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/com_facebook_picker_checkbox"
+    android:layout_width="23dip"
+    android:layout_height="23dip"
+    android:focusable="false"
+    android:clickable="false"
+    android:button="@drawable/com_facebook_button_check" />
diff --git a/facebook/res/layout/com_facebook_picker_image.xml b/facebook/res/layout/com_facebook_picker_image.xml
new file mode 100644
index 000000000..7793e3b3e
--- /dev/null
+++ b/facebook/res/layout/com_facebook_picker_image.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<ImageView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/com_facebook_picker_image"
+    android:layout_width="50dip"
+    android:layout_height="50dip"
+    android:layout_gravity="center_vertical"
+    android:src="@drawable/com_facebook_profile_default_icon" />
diff --git a/facebook/res/layout/com_facebook_picker_list_row.xml b/facebook/res/layout/com_facebook_picker_list_row.xml
new file mode 100644
index 000000000..8f439bfe0
--- /dev/null
+++ b/facebook/res/layout/com_facebook_picker_list_row.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        android:layout_height="wrap_content"
+        android:layout_width="fill_parent"
+        >
+    <ViewStub
+            android:id="@+id/com_facebook_picker_profile_pic_stub"
+            android:inflatedId="@+id/com_facebook_picker_image"
+            android:layout="@layout/com_facebook_picker_image"
+            android:layout_width="50dip"
+            android:layout_height="50dip" />
+    <TextView
+            android:id="@+id/com_facebook_picker_title"
+            android:layout_width="100dip"
+            android:layout_height="50dip"
+            android:layout_weight="1.0"
+            android:paddingLeft="5dip"
+            android:textStyle="bold"
+            android:textColor="#000000"
+            android:singleLine="true"
+            android:ellipsize="end"
+            android:textSize="18sp"
+            android:gravity="left|center_vertical"/>
+    <ViewStub
+            android:id="@+id/com_facebook_picker_checkbox_stub"
+            android:inflatedId="@+id/com_facebook_picker_checkbox"
+            android:layout="@layout/com_facebook_picker_checkbox"
+            android:layout_width="23dip"
+            android:layout_height="23dip"
+            android:layout_marginRight="10dip"/>
+</LinearLayout>
diff --git a/facebook/res/layout/com_facebook_picker_list_section_header.xml b/facebook/res/layout/com_facebook_picker_list_section_header.xml
new file mode 100644
index 000000000..cfb18beb9
--- /dev/null
+++ b/facebook/res/layout/com_facebook_picker_list_section_header.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<TextView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/com_facebook_picker_list_section_header"
+    android:layout_width="fill_parent"
+    android:layout_height="wrap_content"
+    android:textStyle="bold"
+    android:background="@drawable/com_facebook_list_section_header_background"
+    android:orientation="horizontal"
+    android:gravity="left|center_vertical"
+    android:textColor="#68768a"
+    android:textSize="17sp"
+    android:paddingLeft="8dip"
+    android:paddingBottom="0px"
+    android:shadowDx="1"
+    android:shadowDy="1"
+    android:shadowRadius="1"
+    android:shadowColor="#BFFFFFFF" />
diff --git a/facebook/res/layout/com_facebook_picker_search_box.xml b/facebook/res/layout/com_facebook_picker_search_box.xml
new file mode 100644
index 000000000..786668e78
--- /dev/null
+++ b/facebook/res/layout/com_facebook_picker_search_box.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<EditText xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="wrap_content"
+              android:layout_height="fill_parent">
+</EditText>
diff --git a/facebook/res/layout/com_facebook_picker_title_bar.xml b/facebook/res/layout/com_facebook_picker_title_bar.xml
new file mode 100644
index 000000000..bcd3141f7
--- /dev/null
+++ b/facebook/res/layout/com_facebook_picker_title_bar.xml
@@ -0,0 +1,63 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+                android:id="@+id/com_facebook_picker_top_bar"
+                android:layout_width="fill_parent"
+                android:layout_height="48dp"
+                android:background="@drawable/com_facebook_top_background"
+                android:gravity="right">
+    <Button
+            android:id="@+id/com_facebook_picker_done_button"
+            android:layout_width="wrap_content"
+            android:minWidth="55dp"
+            android:layout_height="48dp"
+            android:background="@drawable/com_facebook_top_button"
+            android:paddingLeft="5dip"
+            android:paddingRight="5dip"
+            android:textColor="#ffffff"
+            android:textSize="14sp"
+            android:shadowColor="#66000000"
+            android:shadowDx="1"
+            android:shadowDy="1"
+            android:shadowRadius="1"
+            android:layout_alignParentRight="true"
+            />
+    <LinearLayout
+            android:id="@+id/com_facebook_picker_divider"
+            android:layout_width="1dp"
+            android:layout_height="fill_parent"
+            android:background="#40000000"
+            android:layout_alignLeft="@id/com_facebook_picker_done_button"/>
+    <TextView
+            android:id="@+id/com_facebook_picker_title"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:textSize="22sp"
+            android:textColor="#FFFFFF"
+            android:gravity="left|center_vertical"
+            android:ellipsize="end"
+            android:singleLine="true"
+            android:scaleType="center"
+            android:shadowColor="#66000000"
+            android:shadowDx="1"
+            android:shadowDy="1"
+            android:shadowRadius="1"
+            android:layout_marginLeft="10dip"
+            android:layout_marginRight="10dip"
+            android:layout_toLeftOf="@id/com_facebook_picker_divider"/>
+</RelativeLayout>
diff --git a/facebook/res/layout/com_facebook_picker_title_bar_stub.xml b/facebook/res/layout/com_facebook_picker_title_bar_stub.xml
new file mode 100644
index 000000000..fac0bde28
--- /dev/null
+++ b/facebook/res/layout/com_facebook_picker_title_bar_stub.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<merge xmlns:android="http://schemas.android.com/apk/res/android">
+    <ViewStub android:id="@+id/com_facebook_picker_title_bar_stub"
+              android:inflatedId="@+id/com_facebook_picker_title_bar"
+              android:layout="@layout/com_facebook_picker_title_bar"
+              android:layout_height="48dip"
+              android:layout_width="fill_parent"/>
+
+</merge>
diff --git a/facebook/res/layout/com_facebook_placepickerfragment.xml b/facebook/res/layout/com_facebook_placepickerfragment.xml
new file mode 100644
index 000000000..8928b85d3
--- /dev/null
+++ b/facebook/res/layout/com_facebook_placepickerfragment.xml
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+              android:background="#FFFFFF"
+              android:descendantFocusability="beforeDescendants"
+              android:focusableInTouchMode="true">
+
+    <include layout="@layout/com_facebook_picker_title_bar_stub"/>
+
+    <ViewStub android:id="@+id/com_facebook_placepickerfragment_search_box_stub"
+              android:inflatedId="@+id/search_box"
+              android:layout="@layout/com_facebook_picker_search_box"
+              android:layout_height="wrap_content"
+              android:layout_width="fill_parent"/>
+
+    <ListView
+            android:id="@+id/com_facebook_picker_list_view"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:layout_alignParentTop="true"
+            android:divider="@drawable/com_facebook_list_divider"
+            android:fastScrollEnabled="true"
+            android:scrollbars="vertical"
+            android:listSelector="@drawable/com_facebook_picker_list_selector"
+            android:cacheColorHint="#FFFFFF"
+            />
+
+    <ProgressBar android:indeterminate="true"
+                 android:layout_width="wrap_content"
+                 android:layout_height="wrap_content"
+                 android:id="@+id/com_facebook_picker_activity_circle"
+                 style="@android:style/Widget.ProgressBar"
+                 android:layout_centerInParent="true"
+                 android:visibility="invisible"
+            />
+</RelativeLayout>
diff --git a/facebook/res/layout/com_facebook_placepickerfragment_list_row.xml b/facebook/res/layout/com_facebook_placepickerfragment_list_row.xml
new file mode 100644
index 000000000..4341923c8
--- /dev/null
+++ b/facebook/res/layout/com_facebook_placepickerfragment_list_row.xml
@@ -0,0 +1,70 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        android:layout_height="wrap_content"
+        android:layout_width="fill_parent">
+    <ViewStub
+            android:id="@+id/com_facebook_picker_profile_pic_stub"
+            android:inflatedId="@+id/com_facebook_picker_image"
+            android:layout="@layout/com_facebook_picker_image"
+            android:layout_width="50dip"
+            android:layout_height="50dip" />
+    <LinearLayout
+            android:orientation="vertical"
+            android:focusable="false"
+            android:layout_width="0dip"
+            android:layout_height="wrap_content"
+            android:layout_marginRight="16dp"
+            android:layout_gravity="center_vertical"
+            android:layout_weight="1">
+        <TextView
+                android:id="@+id/com_facebook_picker_title"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:layout_weight="1.0"
+                android:paddingLeft="5dip"
+                android:ellipsize="end"
+                android:singleLine="true"
+                android:typeface="sans"
+                android:textColor="#000000"
+                android:lines="1"
+                android:textSize="16sp"
+                android:gravity="left|center_vertical"/>
+        <TextView
+                android:id="@+id/picker_subtitle"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:layout_weight="1.0"
+                android:paddingLeft="5dip"
+                android:ellipsize="end"
+                android:singleLine="true"
+                android:textColor="#666666"
+                android:lines="1"
+                android:typeface="sans"
+                android:textSize="12sp"
+                android:gravity="left|center_vertical"/>
+    </LinearLayout>
+    <!--ViewStub
+            android:id="@+id/checkbox_stub"
+            android:inflatedId="@+id/picker_checkbox"
+            android:layout="@layout/checkbox_layout"
+            android:layout_width="23dip"
+            android:layout_height="23dip"
+            android:layout_marginRight="10dip"/-->
+</LinearLayout>
diff --git a/facebook/res/layout/com_facebook_usersettingsfragment.xml b/facebook/res/layout/com_facebook_usersettingsfragment.xml
new file mode 100644
index 000000000..c36a74543
--- /dev/null
+++ b/facebook/res/layout/com_facebook_usersettingsfragment.xml
@@ -0,0 +1,59 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<ScrollView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:loginView="http://schemas.android.com/apk/res-auto"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:background="@drawable/com_facebook_usersettingsfragment_background_gradient" >
+    <LinearLayout
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent"
+        android:orientation="vertical">
+
+        <ImageView
+            android:id="@+id/com_facebook_usersettingsfragment_logo_image"
+            android:layout_width="193dp"
+            android:layout_height="44dp"
+            android:layout_gravity="center_horizontal"
+            android:src="@drawable/com_facebook_logo"
+            android:layout_marginTop="35dp"
+            android:contentDescription="@string/com_facebook_logo_content_description"/>
+
+        <TextView
+            android:id="@+id/com_facebook_usersettingsfragment_profile_name"
+            android:layout_width="fill_parent"
+            android:layout_height="100dp"
+            android:lines="1"
+            android:textSize="16sp"
+            android:textStyle="bold"
+            android:layout_marginTop="35dp"
+            android:gravity="center"/>
+    
+        <com.facebook.widget.LoginButton
+            android:id="@+id/com_facebook_usersettingsfragment_login_button"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:layout_marginTop="35dp"
+            android:layout_marginBottom="35dp"
+            loginView:login_text="@string/com_facebook_usersettingsfragment_log_in_button"
+            style="@style/com_facebook_loginview_silver_style" />
+    
+    </LinearLayout>
+</ScrollView>
diff --git a/facebook/res/values-es/strings.xml b/facebook/res/values-es/strings.xml
new file mode 100644
index 000000000..23b2b9fc5
--- /dev/null
+++ b/facebook/res/values-es/strings.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<resources>
+    <string name="com_facebook_dialogloginactivity_ok_button">Aceptar</string>
+    <string name="com_facebook_loginview_log_out_button">Cerrar Sesión</string>
+    <string name="com_facebook_loginview_log_in_button">Iniciar Sesión</string>
+    <string name="com_facebook_loginview_logged_in_as">Sesión iniciada como: %1$s</string>
+    <string name="com_facebook_loginview_logged_in_using_facebook">Sesión iniciada con Facebook</string>
+    <string name="com_facebook_loginview_log_out_action">Cerrar sesión</string>
+    <string name="com_facebook_loginview_cancel_action">Cancelar</string>
+    <string name="com_facebook_logo_content_description">Logo de Facebook</string>
+    <string name="com_facebook_usersettingsfragment_log_in_button">Iniciar Sesión&#8230;</string>
+    <string name="com_facebook_usersettingsfragment_logged_in">Sesión iniciada</string>
+    <string name="com_facebook_usersettingsfragment_not_logged_in">No has iniciado sesión</string>
+    <string name="com_facebook_placepicker_subtitle_format">%1$s • %2$,d estuvieron aquí</string>
+    <string name="com_facebook_placepicker_subtitle_catetory_only_format">%1$s</string>
+    <string name="com_facebook_placepicker_subtitle_were_here_only_format">es:%1$,d estuvieron aquí</string>
+    <string name="com_facebook_picker_done_button_text">Aceptar</string>
+    <string name="com_facebook_choose_friends">Elige Amigos</string>
+    <string name="com_facebook_nearby">Cercano</string>
+    <string name="com_facebook_loading">Cargando</string>
+    <string name="com_facebook_internet_permission_error_title">Error de AndroidManifest</string>
+    <string name="com_facebook_internet_permission_error_message">WebView inicio de sesión requiere permiso INTERNET</string>
+    <string name="com_facebook_requesterror_web_login">Por favor, iniciar sesión a través https://www.facebook.com o https://m.facebook.com para volver a activar la aplicación para conectar con Facebook.</string>
+    <string name="com_facebook_requesterror_relogin">La aplicación no se conecta con Facebook, inicie sesión y volver a conectar esta aplicación.</string>
+    <string name="com_facebook_requesterror_password_changed">Su contraseña de Facebook ha cambiado, por favor vuelva a conectar la aplicación con Facebook.</string>
+    <string name="com_facebook_requesterror_reconnect">Se produjo un error al conectar con Facebook, por favor vuelva a conectar la aplicación con Facebook.</string>
+    <string name="com_facebook_requesterror_permissions">Una conexión de aplicación con Facebook falló debido a permisos insuficientes, por favor, conceda los permisos de aplicaciones para realizar la operación.</string>
+</resources>
diff --git a/facebook/res/values-he/strings.xml b/facebook/res/values-he/strings.xml
new file mode 100644
index 000000000..8b1c7ae44
--- /dev/null
+++ b/facebook/res/values-he/strings.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<resources>
+    <string name="com_facebook_loginview_log_out_button">התנתק</string>
+    <string name="com_facebook_loginview_log_in_button">התחבר</string>
+    <string name="com_facebook_loginview_logged_in_as">מחובר בשם: %1$s</string>
+    <string name="com_facebook_loginview_logged_in_using_facebook">מחובר באמצעות פייסבוק</string>
+    <string name="com_facebook_loginview_log_out_action">התנתק</string>
+    <string name="com_facebook_loginview_cancel_action">בטל</string>
+    <string name="com_facebook_logo_content_description">פייסבוק לוגו</string>
+    <string name="com_facebook_usersettingsfragment_log_in_button">התחבר&#8230;</string>
+    <string name="com_facebook_usersettingsfragment_logged_in">מחובר</string>
+    <string name="com_facebook_usersettingsfragment_not_logged_in">לא מחובר</string>
+    <string name="com_facebook_placepicker_subtitle_format">%1$s • %2$,d היו פה</string>
+    <string name="com_facebook_placepicker_subtitle_catetory_only_format">%1$s</string>
+    <string name="com_facebook_placepicker_subtitle_were_here_only_format">%1$,d היו פה</string>
+    <string name="com_facebook_picker_done_button_text">בצע</string>
+    <string name="com_facebook_choose_friends">בחר חברים</string>
+    <string name="com_facebook_nearby">קרוב אליי</string>
+    <string name="com_facebook_loading">..מעלה</string>
+    <string name="com_facebook_internet_permission_error_title">AndroidManifest שגיאת</string>
+    <string name="com_facebook_internet_permission_error_message">ההתחברות לתצוגת אתר דורשת אישור אינטרנט</string>
+    <string name="com_facebook_requesterror_web_login">.כדי לאפשר מחדש לאפליקציה להתחבר עם פייסבוק https://www.facebook.com או https://m.facebook.com אנא היכנס דרך</string>
+    <string name="com_facebook_requesterror_relogin">.האפליקציה אינה מחוברת לפייסבוק, אנא היכנס וחבר מחדש את האפליקציה</string>
+    <string name="com_facebook_requesterror_password_changed">.הסיסמה שלך בפייסבוק השתנתה, אנא חבר מחדש את האפליקציה עם פייסבוק</string>
+    <string name="com_facebook_requesterror_reconnect">.ארעה שגיאה בעת החיבור עם פייסבוק, חבר בבקשה מחדש את האפליקציה עם פייסבוק</string>
+    <string name="com_facebook_requesterror_permissions">.חיבור האפליקציה עם פייסבוק נכשל בשל הרשאות לא מספקות, אנא הענק הרשאות לאפליקציה בכדי שהפעולה תוכל להתבצע</string>
+    <string name="com_facebook_dialogloginactivity_ok_button">אישור</string>
+</resources>
\ No newline at end of file
diff --git a/facebook/res/values-iw/strings.xml b/facebook/res/values-iw/strings.xml
new file mode 100644
index 000000000..8b1c7ae44
--- /dev/null
+++ b/facebook/res/values-iw/strings.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<resources>
+    <string name="com_facebook_loginview_log_out_button">התנתק</string>
+    <string name="com_facebook_loginview_log_in_button">התחבר</string>
+    <string name="com_facebook_loginview_logged_in_as">מחובר בשם: %1$s</string>
+    <string name="com_facebook_loginview_logged_in_using_facebook">מחובר באמצעות פייסבוק</string>
+    <string name="com_facebook_loginview_log_out_action">התנתק</string>
+    <string name="com_facebook_loginview_cancel_action">בטל</string>
+    <string name="com_facebook_logo_content_description">פייסבוק לוגו</string>
+    <string name="com_facebook_usersettingsfragment_log_in_button">התחבר&#8230;</string>
+    <string name="com_facebook_usersettingsfragment_logged_in">מחובר</string>
+    <string name="com_facebook_usersettingsfragment_not_logged_in">לא מחובר</string>
+    <string name="com_facebook_placepicker_subtitle_format">%1$s • %2$,d היו פה</string>
+    <string name="com_facebook_placepicker_subtitle_catetory_only_format">%1$s</string>
+    <string name="com_facebook_placepicker_subtitle_were_here_only_format">%1$,d היו פה</string>
+    <string name="com_facebook_picker_done_button_text">בצע</string>
+    <string name="com_facebook_choose_friends">בחר חברים</string>
+    <string name="com_facebook_nearby">קרוב אליי</string>
+    <string name="com_facebook_loading">..מעלה</string>
+    <string name="com_facebook_internet_permission_error_title">AndroidManifest שגיאת</string>
+    <string name="com_facebook_internet_permission_error_message">ההתחברות לתצוגת אתר דורשת אישור אינטרנט</string>
+    <string name="com_facebook_requesterror_web_login">.כדי לאפשר מחדש לאפליקציה להתחבר עם פייסבוק https://www.facebook.com או https://m.facebook.com אנא היכנס דרך</string>
+    <string name="com_facebook_requesterror_relogin">.האפליקציה אינה מחוברת לפייסבוק, אנא היכנס וחבר מחדש את האפליקציה</string>
+    <string name="com_facebook_requesterror_password_changed">.הסיסמה שלך בפייסבוק השתנתה, אנא חבר מחדש את האפליקציה עם פייסבוק</string>
+    <string name="com_facebook_requesterror_reconnect">.ארעה שגיאה בעת החיבור עם פייסבוק, חבר בבקשה מחדש את האפליקציה עם פייסבוק</string>
+    <string name="com_facebook_requesterror_permissions">.חיבור האפליקציה עם פייסבוק נכשל בשל הרשאות לא מספקות, אנא הענק הרשאות לאפליקציה בכדי שהפעולה תוכל להתבצע</string>
+    <string name="com_facebook_dialogloginactivity_ok_button">אישור</string>
+</resources>
\ No newline at end of file
diff --git a/facebook/res/values/attrs.xml b/facebook/res/values/attrs.xml
new file mode 100644
index 000000000..6f9f6d11e
--- /dev/null
+++ b/facebook/res/values/attrs.xml
@@ -0,0 +1,52 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<resources>
+    <declare-styleable name="com_facebook_picker_fragment">
+        <attr name="show_pictures" format="boolean"/>
+        <attr name="extra_fields" format="string"/>
+        <attr name="show_title_bar" format="boolean" />
+        <attr name="title_text" format="string" />
+        <attr name="done_button_text" format="string" />
+        <attr name="title_bar_background" format="reference" />
+        <attr name="done_button_background" format="reference" />
+    </declare-styleable>
+    <declare-styleable name="com_facebook_friend_picker_fragment">
+        <attr name="multi_select" format="boolean"/>
+    </declare-styleable>
+    <declare-styleable name="com_facebook_place_picker_fragment">
+        <attr name="radius_in_meters" format="integer"/>
+        <attr name="results_limit" format="integer"/>
+        <attr name="search_text" format="string"/>
+        <attr name="show_search_box" format="boolean" />
+    </declare-styleable>
+    <declare-styleable name="com_facebook_login_view">
+        <attr name="confirm_logout" format="boolean"/>
+        <attr name="fetch_user_info" format="boolean"/>
+        <attr name="login_text" format="string"/>
+        <attr name="logout_text" format="string"/>
+    </declare-styleable>
+    <declare-styleable name="com_facebook_profile_picture_view">
+        <attr name="preset_size">
+            <!-- Keep in sync with constants in ProfilePictureView -->
+            <enum name="small" value="-2" />
+            <enum name="normal" value="-3" />
+            <enum name="large" value="-4" />
+        </attr>
+        <attr name="is_cropped" format="boolean" />
+    </declare-styleable>
+</resources>
diff --git a/facebook/res/values/strings.xml b/facebook/res/values/strings.xml
new file mode 100644
index 000000000..ffef00c0f
--- /dev/null
+++ b/facebook/res/values/strings.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<resources>
+    <string name="com_facebook_dialogloginactivity_ok_button">OK</string>
+    <string name="com_facebook_loginview_log_out_button">Log Out</string>
+    <string name="com_facebook_loginview_log_in_button">Log In</string>
+    <string name="com_facebook_loginview_logged_in_as">Logged in as: %1$s</string>
+    <string name="com_facebook_loginview_logged_in_using_facebook">Logged in using Facebook</string>
+    <string name="com_facebook_loginview_log_out_action">Log Out</string>
+    <string name="com_facebook_loginview_cancel_action">Cancel</string>
+    <string name="com_facebook_logo_content_description">Facebook Logo</string>
+    <string name="com_facebook_usersettingsfragment_log_in_button">Log In&#8230;</string>
+    <string name="com_facebook_usersettingsfragment_logged_in">Logged In</string>
+    <string name="com_facebook_usersettingsfragment_not_logged_in">Not Logged In</string>
+    <string name="com_facebook_placepicker_subtitle_format">%1$s • %2$,d were here</string>
+    <string name="com_facebook_placepicker_subtitle_catetory_only_format">%1$s</string>
+    <string name="com_facebook_placepicker_subtitle_were_here_only_format">%1$,d were here</string>
+    <string name="com_facebook_picker_done_button_text">Done</string>
+    <string name="com_facebook_choose_friends">Choose Friends</string>
+    <string name="com_facebook_nearby">Nearby</string>
+    <string name="com_facebook_loading">Loading...</string>
+    <string name="com_facebook_internet_permission_error_title">AndroidManifest Error</string>
+    <string name="com_facebook_internet_permission_error_message">WebView login requires INTERNET permission</string>
+    <string name="com_facebook_requesterror_web_login">Please log in via https://www.facebook.com or https://m.facebook.com to re-enable the app to connect with Facebook.</string>
+    <string name="com_facebook_requesterror_relogin">The app is not connected with Facebook, please log in and reconnect this app.</string>
+    <string name="com_facebook_requesterror_password_changed">Your password on Facebook has changed, please reconnect the app with Facebook.</string>
+    <string name="com_facebook_requesterror_reconnect">An error occurred when connecting with Facebook, please reconnect the app with Facebook.</string>
+    <string name="com_facebook_requesterror_permissions">An app connection with Facebook failed due to insufficient permissions, please grant the app permissions to perform the operation.</string>
+</resources>
diff --git a/facebook/res/values/styles.xml b/facebook/res/values/styles.xml
new file mode 100644
index 000000000..ee5e1e11d
--- /dev/null
+++ b/facebook/res/values/styles.xml
@@ -0,0 +1,59 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android">
+    <color name="com_facebook_blue">#3B5998</color>
+    
+    <color name="com_facebook_usersettingsfragment_connected_text_color">#FFFFFF</color>
+    <color name="com_facebook_usersettingsfragment_connected_shadow_color">#000000</color>
+    <color name="com_facebook_usersettingsfragment_not_connected_text_color">#A6AED7</color>
+    <dimen name="com_facebook_usersettingsfragment_profile_picture_width">64dp</dimen>
+    <dimen name="com_facebook_usersettingsfragment_profile_picture_height">64dp</dimen>
+    
+    <dimen name="com_facebook_loginview_padding_left">42dp</dimen>
+    <dimen name="com_facebook_loginview_padding_right">0dp</dimen>
+    <dimen name="com_facebook_loginview_padding_top">0dp</dimen>
+    <dimen name="com_facebook_loginview_padding_bottom">0dp</dimen>
+    <dimen name="com_facebook_loginview_width">205dp</dimen>
+    <dimen name="com_facebook_loginview_height">44dp</dimen>
+    <color name="com_facebook_loginview_text_color">#FFFFFF</color>
+    <dimen name="com_facebook_loginview_text_size">16.0sp</dimen>
+
+    <dimen name="com_facebook_profilepictureview_preset_size_small">50dp</dimen>
+    <dimen name="com_facebook_profilepictureview_preset_size_normal">100dp</dimen>
+    <dimen name="com_facebook_profilepictureview_preset_size_large">180dp</dimen>
+
+    <style name="com_facebook_loginview_default_style" parent="@android:style/Widget.Button">
+        <item name="android:width">@dimen/com_facebook_loginview_width</item>
+        <item name="android:height">@dimen/com_facebook_loginview_height</item>
+        <item name="android:background">@drawable/com_facebook_loginbutton_blue</item>
+        <item name="android:textColor">@color/com_facebook_loginview_text_color</item>
+        <item name="android:textSize">@dimen/com_facebook_loginview_text_size</item>
+        <item name="android:paddingLeft">@dimen/com_facebook_loginview_padding_left</item>
+        <item name="android:gravity">center</item>
+    </style>
+    
+    <style name="com_facebook_loginview_silver_style" parent="@android:style/Widget.Button">
+        <item name="android:width">205dp</item>
+        <item name="android:height">44dp</item>
+        <item name="android:background">@drawable/com_facebook_loginbutton_silver</item>
+        <item name="android:textSize">18sp</item>
+        <item name="android:textStyle">bold</item>
+        <item name="android:textColor">#4B5164</item>
+        <item name="android:gravity">center</item>
+    </style>
+</resources>
diff --git a/facebook/src/com/facebook/AccessToken.java b/facebook/src/com/facebook/AccessToken.java
new file mode 100644
index 000000000..28cbeb481
--- /dev/null
+++ b/facebook/src/com/facebook/AccessToken.java
@@ -0,0 +1,359 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.annotation.SuppressLint;
+import android.content.Intent;
+import android.os.Bundle;
+import android.text.TextUtils;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+
+import java.io.InvalidObjectException;
+import java.io.ObjectInputStream;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+
+/**
+ * This class represents an access token returned by the Facebook Login service, along with associated
+ * metadata such as its expiration date and permissions. In general, the {@link Session} class will
+ * abstract away the need to worry about the details of an access token, but there are situations
+ * (such as handling native links, importing previously-obtained access tokens, etc.) where it is
+ * useful to deal with access tokens directly. Factory methods are provided to construct access tokens.
+ * <p/>
+ * For more information on access tokens, see
+ * https://developers.facebook.com/docs/concepts/login/access-tokens-and-types/.
+ */
+public final class AccessToken implements Serializable {
+    private static final long serialVersionUID = 1L;
+    static final String ACCESS_TOKEN_KEY = "access_token";
+    static final String EXPIRES_IN_KEY = "expires_in";
+    private static final Date MIN_DATE = new Date(Long.MIN_VALUE);
+    private static final Date MAX_DATE = new Date(Long.MAX_VALUE);
+    private static final Date DEFAULT_EXPIRATION_TIME = MAX_DATE;
+    private static final Date DEFAULT_LAST_REFRESH_TIME = new Date();
+    private static final AccessTokenSource DEFAULT_ACCESS_TOKEN_SOURCE = AccessTokenSource.FACEBOOK_APPLICATION_WEB;
+    private static final Date ALREADY_EXPIRED_EXPIRATION_TIME = MIN_DATE;
+
+    private final Date expires;
+    private final List<String> permissions;
+    private final String token;
+    private final AccessTokenSource source;
+    private final Date lastRefresh;
+
+    AccessToken(String token, Date expires, List<String> permissions, AccessTokenSource source, Date lastRefresh) {
+        if (permissions == null) {
+            permissions = Collections.emptyList();
+        }
+
+        this.expires = expires;
+        this.permissions = Collections.unmodifiableList(permissions);
+        this.token = token;
+        this.source = source;
+        this.lastRefresh = lastRefresh;
+    }
+
+    /**
+     * Gets the string representing the access token.
+     *
+     * @return the string representing the access token
+     */
+    public String getToken() {
+        return this.token;
+    }
+
+    /**
+     * Gets the date at which the access token expires.
+     *
+     * @return the expiration date of the token
+     */
+    public Date getExpires() {
+        return this.expires;
+    }
+
+    /**
+     * Gets the list of permissions associated with this access token. Note that the most up-to-date
+     * list of permissions is maintained by the Facebook service, so this list may be outdated if
+     * permissions have been added or removed since the time the AccessToken object was created. For
+     * more information on permissions, see https://developers.facebook.com/docs/reference/login/#permissions.
+     *
+     * @return a read-only list of strings representing the permissions granted via this access token
+     */
+    public List<String> getPermissions() {
+        return this.permissions;
+    }
+
+    /**
+     * Gets the {@link AccessTokenSource} indicating how this access token was obtained.
+     *
+     * @return the enum indicating how the access token was obtained
+     */
+    public AccessTokenSource getSource() {
+        return source;
+    }
+
+    /**
+     * Gets the date at which the token was last refreshed. Since tokens expire, the Facebook SDK
+     * will attempt to renew them periodically.
+     *
+     * @return the date at which this token was last refreshed
+     */
+    public Date getLastRefresh() {
+        return this.lastRefresh;
+    }
+
+    /**
+     * Creates a new AccessToken using the supplied information from a previously-obtained access
+     * token (for instance, from an already-cached access token obtained prior to integration with the
+     * Facebook SDK).
+     *
+     * @param accessToken       the access token string obtained from Facebook
+     * @param expirationTime    the expiration date associated with the token; if null, an infinite expiration time is
+     *                          assumed (but will become correct when the token is refreshed)
+     * @param lastRefreshTime   the last time the token was refreshed (or when it was first obtained); if null,
+     *                          the current time is used.
+     * @param accessTokenSource an enum indicating how the token was originally obtained (in most cases,
+     *                          this will be either AccessTokenSource.FACEBOOK_APPLICATION or
+     *                          AccessTokenSource.WEB_VIEW); if null, FACEBOOK_APPLICATION is assumed.
+     * @param permissions       the permissions that were requested when the token was obtained (or when
+     *                          it was last reauthorized); may be null if permission set is unknown
+     * @return a new AccessToken
+     */
+    public static AccessToken createFromExistingAccessToken(String accessToken, Date expirationTime,
+            Date lastRefreshTime, AccessTokenSource accessTokenSource, List<String> permissions) {
+        if (expirationTime == null) {
+            expirationTime = DEFAULT_EXPIRATION_TIME;
+        }
+        if (lastRefreshTime == null) {
+            lastRefreshTime = DEFAULT_LAST_REFRESH_TIME;
+        }
+        if (accessTokenSource == null) {
+            accessTokenSource = DEFAULT_ACCESS_TOKEN_SOURCE;
+        }
+
+        return new AccessToken(accessToken, expirationTime, permissions, accessTokenSource, lastRefreshTime);
+    }
+
+    /**
+     * Creates a new AccessToken using the information contained in an Intent populated by the Facebook
+     * application in order to launch a native link. For more information on native linking, please see
+     * https://developers.facebook.com/docs/mobile/android/deep_linking/.
+     *
+     * @param intent the Intent that was used to start an Activity; must not be null
+     * @return a new AccessToken, or null if the Intent did not contain enough data to create one
+     */
+    public static AccessToken createFromNativeLinkingIntent(Intent intent) {
+        Validate.notNull(intent, "intent");
+
+        if (intent.getExtras() == null) {
+            return null;
+        }
+
+        return createFromBundle(null, intent.getExtras(), AccessTokenSource.FACEBOOK_APPLICATION_WEB, new Date());
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+
+        builder.append("{AccessToken");
+        builder.append(" token:").append(tokenToString());
+        appendPermissions(builder);
+        builder.append("}");
+
+        return builder.toString();
+    }
+
+    static AccessToken createEmptyToken(List<String> permissions) {
+        return new AccessToken("", ALREADY_EXPIRED_EXPIRATION_TIME, permissions, AccessTokenSource.NONE,
+                DEFAULT_LAST_REFRESH_TIME);
+    }
+
+    static AccessToken createFromString(String token, List<String> permissions, AccessTokenSource source) {
+        return new AccessToken(token, DEFAULT_EXPIRATION_TIME, permissions, source, DEFAULT_LAST_REFRESH_TIME);
+    }
+
+    static AccessToken createFromNativeLogin(Bundle bundle, AccessTokenSource source) {
+        Date expires = getBundleLongAsDate(
+                bundle, NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, new Date(0));
+        ArrayList<String> permissions = bundle.getStringArrayList(NativeProtocol.EXTRA_PERMISSIONS);
+        String token = bundle.getString(NativeProtocol.EXTRA_ACCESS_TOKEN);
+
+        return createNew(permissions, token, expires, source);
+    }
+
+    static AccessToken createFromWebBundle(List<String> requestedPermissions, Bundle bundle, AccessTokenSource source) {
+        Date expires = getBundleLongAsDate(bundle, EXPIRES_IN_KEY, new Date());
+        String token = bundle.getString(ACCESS_TOKEN_KEY);
+
+        return createNew(requestedPermissions, token, expires, source);
+    }
+
+    @SuppressLint("FieldGetter")
+    static AccessToken createFromRefresh(AccessToken current, Bundle bundle) {
+        // Only tokens obtained via SSO support refresh. Token refresh returns the expiration date in
+        // seconds from the epoch rather than seconds from now.
+        assert (current.source == AccessTokenSource.FACEBOOK_APPLICATION_WEB ||
+                current.source == AccessTokenSource.FACEBOOK_APPLICATION_NATIVE ||
+                current.source == AccessTokenSource.FACEBOOK_APPLICATION_SERVICE);
+
+        Date expires = getBundleLongAsDate(bundle, EXPIRES_IN_KEY, new Date(0));
+        String token = bundle.getString(ACCESS_TOKEN_KEY);
+
+        return createNew(current.getPermissions(), token, expires, current.source);
+    }
+
+    static AccessToken createFromTokenWithRefreshedPermissions(AccessToken token, List<String> permissions) {
+        return new AccessToken(token.token, token.expires, permissions, token.source, token.lastRefresh);
+    }
+
+    private static AccessToken createNew(
+            List<String> requestedPermissions, String accessToken, Date expires, AccessTokenSource source) {
+        if (Utility.isNullOrEmpty(accessToken) || (expires == null)) {
+            return createEmptyToken(requestedPermissions);
+        } else {
+            return new AccessToken(accessToken, expires, requestedPermissions, source, new Date());
+        }
+    }
+
+    static AccessToken createFromCache(Bundle bundle) {
+        // Copy the list so we can guarantee immutable
+        List<String> originalPermissions = bundle.getStringArrayList(TokenCachingStrategy.PERMISSIONS_KEY);
+        List<String> permissions;
+        if (originalPermissions == null) {
+            permissions = Collections.emptyList();
+        } else {
+            permissions = Collections.unmodifiableList(new ArrayList<String>(originalPermissions));
+        }
+
+        return new AccessToken(bundle.getString(TokenCachingStrategy.TOKEN_KEY), TokenCachingStrategy.getDate(bundle,
+                TokenCachingStrategy.EXPIRATION_DATE_KEY), permissions, TokenCachingStrategy.getSource(bundle),
+                TokenCachingStrategy.getDate(bundle, TokenCachingStrategy.LAST_REFRESH_DATE_KEY));
+    }
+
+    Bundle toCacheBundle() {
+        Bundle bundle = new Bundle();
+
+        bundle.putString(TokenCachingStrategy.TOKEN_KEY, this.token);
+        TokenCachingStrategy.putDate(bundle, TokenCachingStrategy.EXPIRATION_DATE_KEY, expires);
+        bundle.putStringArrayList(TokenCachingStrategy.PERMISSIONS_KEY, new ArrayList<String>(permissions));
+        bundle.putSerializable(TokenCachingStrategy.TOKEN_SOURCE_KEY, source);
+        TokenCachingStrategy.putDate(bundle, TokenCachingStrategy.LAST_REFRESH_DATE_KEY, lastRefresh);
+
+        return bundle;
+    }
+
+    boolean isInvalid() {
+        return Utility.isNullOrEmpty(this.token) || new Date().after(this.expires);
+    }
+
+    private static AccessToken createFromBundle(List<String> requestedPermissions, Bundle bundle,
+            AccessTokenSource source,
+            Date expirationBase) {
+        String token = bundle.getString(ACCESS_TOKEN_KEY);
+        Date expires = getBundleLongAsDate(bundle, EXPIRES_IN_KEY, expirationBase);
+
+        if (Utility.isNullOrEmpty(token) || (expires == null)) {
+            return null;
+        }
+
+        return new AccessToken(token, expires, requestedPermissions, source, new Date());
+    }
+
+    private String tokenToString() {
+        if (this.token == null) {
+            return "null";
+        } else if (Settings.isLoggingBehaviorEnabled(LoggingBehavior.INCLUDE_ACCESS_TOKENS)) {
+            return this.token;
+        } else {
+            return "ACCESS_TOKEN_REMOVED";
+        }
+    }
+
+    private void appendPermissions(StringBuilder builder) {
+        builder.append(" permissions:");
+        if (this.permissions == null) {
+            builder.append("null");
+        } else {
+            builder.append("[");
+            builder.append(TextUtils.join(", ", permissions));
+            builder.append("]");
+        }
+    }
+
+    private static class SerializationProxyV1 implements Serializable {
+        private static final long serialVersionUID = -2488473066578201069L;
+        private final Date expires;
+        private final List<String> permissions;
+        private final String token;
+        private final AccessTokenSource source;
+        private final Date lastRefresh;
+
+        private SerializationProxyV1(String token, Date expires,
+                List<String> permissions, AccessTokenSource source, Date lastRefresh) {
+            this.expires = expires;
+            this.permissions = permissions;
+            this.token = token;
+            this.source = source;
+            this.lastRefresh = lastRefresh;
+        }
+
+        private Object readResolve() {
+            return new AccessToken(token, expires, permissions, source, lastRefresh);
+        }
+    }
+
+    private Object writeReplace() {
+        return new SerializationProxyV1(token, expires, permissions, source, lastRefresh);
+    }
+
+    // have a readObject that throws to prevent spoofing
+    private void readObject(ObjectInputStream stream) throws InvalidObjectException {
+        throw new InvalidObjectException("Cannot readObject, serialization proxy required");
+    }
+
+
+    private static Date getBundleLongAsDate(Bundle bundle, String key, Date dateBase) {
+        if (bundle == null) {
+            return null;
+        }
+
+        long secondsFromBase = Long.MIN_VALUE;
+
+        Object secondsObject = bundle.get(key);
+        if (secondsObject instanceof Long) {
+            secondsFromBase = (Long) secondsObject;
+        } else if (secondsObject instanceof String) {
+            try {
+                secondsFromBase = Long.parseLong((String) secondsObject);
+            } catch (NumberFormatException e) {
+                return null;
+            }
+        } else {
+            return null;
+        }
+
+        if (secondsFromBase == 0) {
+            return new Date(Long.MAX_VALUE);
+        } else {
+            return new Date(dateBase.getTime() + (secondsFromBase * 1000L));
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/AccessTokenSource.java b/facebook/src/com/facebook/AccessTokenSource.java
new file mode 100644
index 000000000..8d231f1b1
--- /dev/null
+++ b/facebook/src/com/facebook/AccessTokenSource.java
@@ -0,0 +1,63 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Indicates where a Facebook access token was obtained from.
+ */
+public enum AccessTokenSource {
+    /**
+     * Indicates an access token has not been obtained, or is otherwise invalid.
+     */
+    NONE(false),
+    /**
+     * Indicates an access token was obtained by the user logging in through the
+     * Facebook app for Android using the web login dialog.
+     */
+    FACEBOOK_APPLICATION_WEB(true),
+    /**
+     * Indicates an access token was obtained by the user logging in through the
+     * Facebook app for Android using the native login dialog.
+     */
+    FACEBOOK_APPLICATION_NATIVE(true),
+    /**
+     * Indicates an access token was obtained by asking the Facebook app for the
+     * current token based on permissions the user has already granted to the app.
+     * No dialog was shown to the user in this case.
+     */
+    FACEBOOK_APPLICATION_SERVICE(true),
+    /**
+     * Indicates an access token was obtained by the user logging in through the
+     * Web-based dialog.
+     */
+    WEB_VIEW(false),
+    /**
+     * Indicates an access token is for a test user rather than an actual
+     * Facebook user.
+     */
+    TEST_USER(true);
+
+    private final boolean canExtendToken;
+
+    AccessTokenSource(boolean canExtendToken) {
+        this.canExtendToken = canExtendToken;
+    }
+
+    boolean canExtendToken() {
+        return canExtendToken;
+    }
+}
diff --git a/facebook/src/com/facebook/AuthorizationClient.java b/facebook/src/com/facebook/AuthorizationClient.java
new file mode 100644
index 000000000..f1f4348f9
--- /dev/null
+++ b/facebook/src/com/facebook/AuthorizationClient.java
@@ -0,0 +1,806 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.Manifest;
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+import android.text.TextUtils;
+import android.webkit.CookieSyncManager;
+import com.facebook.android.R;
+import com.facebook.internal.ServerProtocol;
+import com.facebook.internal.Utility;
+import com.facebook.model.GraphMultiResult;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphObjectList;
+import com.facebook.model.GraphUser;
+import com.facebook.widget.WebDialog;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+
+class AuthorizationClient implements Serializable {
+    private static final long serialVersionUID = 1L;
+
+    List<AuthHandler> handlersToTry;
+    AuthHandler currentHandler;
+    transient Context context;
+    transient StartActivityDelegate startActivityDelegate;
+    transient OnCompletedListener onCompletedListener;
+    transient BackgroundProcessingListener backgroundProcessingListener;
+    transient boolean checkedInternetPermission;
+    AuthorizationRequest pendingRequest;
+
+    interface OnCompletedListener {
+        void onCompleted(Result result);
+    }
+
+    interface BackgroundProcessingListener {
+        void onBackgroundProcessingStarted();
+
+        void onBackgroundProcessingStopped();
+    }
+
+    interface StartActivityDelegate {
+        public void startActivityForResult(Intent intent, int requestCode);
+
+        public Activity getActivityContext();
+    }
+
+    void setContext(final Context context) {
+        this.context = context;
+        // We rely on individual requests to tell us how to start an activity.
+        startActivityDelegate = null;
+    }
+
+    void setContext(final Activity activity) {
+        this.context = activity;
+
+        // If we are used in the context of an activity, we will always use that activity to
+        // call startActivityForResult.
+        startActivityDelegate = new StartActivityDelegate() {
+            @Override
+            public void startActivityForResult(Intent intent, int requestCode) {
+                activity.startActivityForResult(intent, requestCode);
+            }
+
+            @Override
+            public Activity getActivityContext() {
+                return activity;
+            }
+        };
+    }
+
+    void startOrContinueAuth(AuthorizationRequest request) {
+        if (getInProgress()) {
+            continueAuth();
+        } else {
+            authorize(request);
+        }
+    }
+
+    void authorize(AuthorizationRequest request) {
+        if (request == null) {
+            return;
+        }
+
+        if (pendingRequest != null) {
+            throw new FacebookException("Attempted to authorize while a request is pending.");
+        }
+
+        if (request.needsNewTokenValidation() && !checkInternetPermission()) {
+            // We're going to need INTERNET permission later and don't have it, so fail early.
+            return;
+        }
+        pendingRequest = request;
+        handlersToTry = getHandlerTypes(request);
+        tryNextHandler();
+    }
+
+    void continueAuth() {
+        if (pendingRequest == null || currentHandler == null) {
+            throw new FacebookException("Attempted to continue authorization without a pending request.");
+        }
+
+        if (currentHandler.needsRestart()) {
+            currentHandler.cancel();
+            tryCurrentHandler();
+        }
+    }
+
+    boolean getInProgress() {
+        return pendingRequest != null && currentHandler != null;
+    }
+
+    void cancelCurrentHandler() {
+        if (currentHandler != null) {
+            currentHandler.cancel();
+        }
+    }
+
+    boolean onActivityResult(int requestCode, int resultCode, Intent data) {
+        if (requestCode == pendingRequest.getRequestCode()) {
+            return currentHandler.onActivityResult(requestCode, resultCode, data);
+        }
+        return false;
+    }
+
+    private List<AuthHandler> getHandlerTypes(AuthorizationRequest request) {
+        ArrayList<AuthHandler> handlers = new ArrayList<AuthHandler>();
+
+        final SessionLoginBehavior behavior = request.getLoginBehavior();
+        if (behavior.allowsKatanaAuth()) {
+            if (!request.isLegacy()) {
+                handlers.add(new GetTokenAuthHandler());
+                handlers.add(new KatanaLoginDialogAuthHandler());
+            }
+            handlers.add(new KatanaProxyAuthHandler());
+        }
+
+        if (behavior.allowsWebViewAuth()) {
+            handlers.add(new WebViewAuthHandler());
+        }
+
+        return handlers;
+    }
+
+    boolean checkInternetPermission() {
+        if (checkedInternetPermission) {
+            return true;
+        }
+
+        int permissionCheck = checkPermission(Manifest.permission.INTERNET);
+        if (permissionCheck != PackageManager.PERMISSION_GRANTED) {
+            String errorType = context.getString(R.string.com_facebook_internet_permission_error_title);
+            String errorDescription = context.getString(R.string.com_facebook_internet_permission_error_message);
+            complete(Result.createErrorResult(errorType, errorDescription));
+
+            return false;
+        }
+
+        checkedInternetPermission = true;
+        return true;
+    }
+
+    void tryNextHandler() {
+        while (handlersToTry != null && !handlersToTry.isEmpty()) {
+            currentHandler = handlersToTry.remove(0);
+
+            boolean started = tryCurrentHandler();
+
+            if (started) {
+                return;
+            }
+        }
+
+        if (pendingRequest != null) {
+            // We went through all handlers without successfully attempting an auth.
+            completeWithFailure();
+        }
+    }
+
+    private void completeWithFailure() {
+        complete(Result.createErrorResult("Login attempt failed.", null));
+    }
+
+    boolean tryCurrentHandler() {
+        if (currentHandler.needsInternetPermission() && !checkInternetPermission()) {
+            return false;
+        }
+        return currentHandler.tryAuthorize(pendingRequest);
+    }
+
+    void completeAndValidate(Result outcome) {
+        // Do we need to validate a successful result (as in the case of a reauth)?
+        if (outcome.token != null && pendingRequest.needsNewTokenValidation()) {
+            validateSameFbidAndFinish(outcome);
+        } else {
+            // We're done, just notify the listener.
+            complete(outcome);
+        }
+    }
+
+    void complete(Result outcome) {
+        handlersToTry = null;
+        currentHandler = null;
+        pendingRequest = null;
+
+        notifyOnCompleteListener(outcome);
+    }
+
+    OnCompletedListener getOnCompletedListener() {
+        return onCompletedListener;
+    }
+
+    void setOnCompletedListener(OnCompletedListener onCompletedListener) {
+        this.onCompletedListener = onCompletedListener;
+    }
+
+    BackgroundProcessingListener getBackgroundProcessingListener() {
+        return backgroundProcessingListener;
+    }
+
+    void setBackgroundProcessingListener(BackgroundProcessingListener backgroundProcessingListener) {
+        this.backgroundProcessingListener = backgroundProcessingListener;
+    }
+
+    StartActivityDelegate getStartActivityDelegate() {
+        if (startActivityDelegate != null) {
+            return startActivityDelegate;
+        } else if (pendingRequest != null) {
+            // Wrap the request's delegate in our own.
+            return new StartActivityDelegate() {
+                @Override
+                public void startActivityForResult(Intent intent, int requestCode) {
+                    pendingRequest.getStartActivityDelegate().startActivityForResult(intent, requestCode);
+                }
+
+                @Override
+                public Activity getActivityContext() {
+                    return pendingRequest.getStartActivityDelegate().getActivityContext();
+                }
+            };
+        }
+        return null;
+    }
+
+    int checkPermission(String permission) {
+        return context.checkCallingOrSelfPermission(permission);
+    }
+
+    void validateSameFbidAndFinish(Result pendingResult) {
+        if (pendingResult.token == null) {
+            throw new FacebookException("Can't validate without a token");
+        }
+
+        RequestBatch batch = createReauthValidationBatch(pendingResult);
+
+        notifyBackgroundProcessingStart();
+
+        batch.executeAsync();
+    }
+
+    RequestBatch createReauthValidationBatch(final Result pendingResult) {
+        // We need to ensure that the token we got represents the same fbid as the old one. We issue
+        // a "me" request using the current token, a "me" request using the new token, and a "me/permissions"
+        // request using the current token to get the permissions of the user.
+
+        final ArrayList<String> fbids = new ArrayList<String>();
+        final ArrayList<String> tokenPermissions = new ArrayList<String>();
+        final String newToken = pendingResult.token.getToken();
+
+        Request.Callback meCallback = new Request.Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                try {
+                    GraphUser user = response.getGraphObjectAs(GraphUser.class);
+                    if (user != null) {
+                        fbids.add(user.getId());
+                    }
+                } catch (Exception ex) {
+                }
+            }
+        };
+
+        String validateSameFbidAsToken = pendingRequest.getPreviousAccessToken();
+        Request requestCurrentTokenMe = createGetProfileIdRequest(validateSameFbidAsToken);
+        requestCurrentTokenMe.setCallback(meCallback);
+
+        Request requestNewTokenMe = createGetProfileIdRequest(newToken);
+        requestNewTokenMe.setCallback(meCallback);
+
+        Request requestCurrentTokenPermissions = createGetPermissionsRequest(validateSameFbidAsToken);
+        requestCurrentTokenPermissions.setCallback(new Request.Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                try {
+                    GraphMultiResult result = response.getGraphObjectAs(GraphMultiResult.class);
+                    if (result != null) {
+                        GraphObjectList<GraphObject> data = result.getData();
+                        if (data != null && data.size() == 1) {
+                            GraphObject permissions = data.get(0);
+
+                            // The keys are the permission names.
+                            tokenPermissions.addAll(permissions.asMap().keySet());
+                        }
+                    }
+                } catch (Exception ex) {
+                }
+            }
+        });
+
+        RequestBatch batch = new RequestBatch(requestCurrentTokenMe, requestNewTokenMe,
+                requestCurrentTokenPermissions);
+        batch.setBatchApplicationId(pendingRequest.getApplicationId());
+        batch.addCallback(new RequestBatch.Callback() {
+            @Override
+            public void onBatchCompleted(RequestBatch batch) {
+                try {
+                    Result result = null;
+                    if (fbids.size() == 2 && fbids.get(0) != null && fbids.get(1) != null &&
+                            fbids.get(0).equals(fbids.get(1))) {
+                        // Modify the token to have the right permission set.
+                        AccessToken tokenWithPermissions = AccessToken
+                                .createFromTokenWithRefreshedPermissions(pendingResult.token,
+                                        tokenPermissions);
+                        result = Result.createTokenResult(tokenWithPermissions);
+                    } else {
+                        result = Result
+                                .createErrorResult("User logged in as different Facebook user.", null);
+                    }
+                    complete(result);
+                } catch (Exception ex) {
+                    complete(Result.createErrorResult("Caught exception", ex.getMessage()));
+                } finally {
+                    notifyBackgroundProcessingStop();
+                }
+            }
+        });
+
+        return batch;
+    }
+
+    Request createGetPermissionsRequest(String accessToken) {
+        Bundle parameters = new Bundle();
+        parameters.putString("fields", "id");
+        parameters.putString("access_token", accessToken);
+        return new Request(null, "me/permissions", parameters, HttpMethod.GET, null);
+    }
+
+    Request createGetProfileIdRequest(String accessToken) {
+        Bundle parameters = new Bundle();
+        parameters.putString("fields", "id");
+        parameters.putString("access_token", accessToken);
+        return new Request(null, "me", parameters, HttpMethod.GET, null);
+    }
+
+    private void notifyOnCompleteListener(Result outcome) {
+        if (onCompletedListener != null) {
+            onCompletedListener.onCompleted(outcome);
+        }
+    }
+
+    private void notifyBackgroundProcessingStart() {
+        if (backgroundProcessingListener != null) {
+            backgroundProcessingListener.onBackgroundProcessingStarted();
+        }
+    }
+
+    private void notifyBackgroundProcessingStop() {
+        if (backgroundProcessingListener != null) {
+            backgroundProcessingListener.onBackgroundProcessingStopped();
+        }
+    }
+
+    abstract class AuthHandler implements Serializable {
+        private static final long serialVersionUID = 1L;
+
+        abstract boolean tryAuthorize(AuthorizationRequest request);
+
+        boolean onActivityResult(int requestCode, int resultCode, Intent data) {
+            return false;
+        }
+
+        boolean needsRestart() {
+            return false;
+        }
+
+        boolean needsInternetPermission() {
+            return false;
+        }
+
+        void cancel() {
+        }
+    }
+
+    class WebViewAuthHandler extends AuthHandler {
+        private static final long serialVersionUID = 1L;
+        private transient WebDialog loginDialog;
+
+        @Override
+        boolean needsRestart() {
+            // Because we are presenting WebView UI within the current context, we need to explicitly
+            // restart the process if the context goes away and is recreated.
+            return true;
+        }
+
+        @Override
+        boolean needsInternetPermission() {
+            return true;
+        }
+
+        @Override
+        void cancel() {
+            if (loginDialog != null) {
+                loginDialog.dismiss();
+                loginDialog = null;
+            }
+        }
+
+        @Override
+        boolean tryAuthorize(final AuthorizationRequest request) {
+            String applicationId = request.getApplicationId();
+            Bundle parameters = new Bundle();
+            if (!Utility.isNullOrEmpty(request.getPermissions())) {
+                parameters.putString(ServerProtocol.DIALOG_PARAM_SCOPE, TextUtils.join(",", request.getPermissions()));
+            }
+
+            // The call to clear cookies will create the first instance of CookieSyncManager if necessary
+            Utility.clearFacebookCookies(context);
+
+            WebDialog.OnCompleteListener listener = new WebDialog.OnCompleteListener() {
+                @Override
+                public void onComplete(Bundle values, FacebookException error) {
+                    onWebDialogComplete(request, values, error);
+                }
+            };
+
+            WebDialog.Builder builder =
+                    new AuthDialogBuilder(getStartActivityDelegate().getActivityContext(), applicationId, parameters)
+                            .setOnCompleteListener(listener);
+            loginDialog = builder.build();
+            loginDialog.show();
+
+            return true;
+        }
+
+        void onWebDialogComplete(AuthorizationRequest request, Bundle values,
+                FacebookException error) {
+            Result outcome;
+            if (values != null) {
+                // Ensure any cookies set by the dialog are saved
+                // This is to work around a bug where CookieManager may fail to instantiate if CookieSyncManager
+                // has never been created.
+                CookieSyncManager syncManager = CookieSyncManager.createInstance(context);
+                syncManager.sync();
+
+                AccessToken token = AccessToken
+                        .createFromWebBundle(request.getPermissions(), values, AccessTokenSource.WEB_VIEW);
+                outcome = Result.createTokenResult(token);
+
+            } else {
+                if (error instanceof FacebookOperationCanceledException) {
+                    outcome = Result.createCancelResult("User canceled log in.");
+                } else {
+                    outcome = Result.createErrorResult(error.getMessage(), null);
+                }
+            }
+            completeAndValidate(outcome);
+        }
+    }
+
+    class GetTokenAuthHandler extends AuthHandler {
+        private static final long serialVersionUID = 1L;
+        private transient GetTokenClient getTokenClient;
+
+        @Override
+        void cancel() {
+            if (getTokenClient != null) {
+                getTokenClient.cancel();
+                getTokenClient = null;
+            }
+        }
+
+        boolean tryAuthorize(final AuthorizationRequest request) {
+            getTokenClient = new GetTokenClient(context, request.getApplicationId());
+            if (!getTokenClient.start()) {
+                return false;
+            }
+
+            notifyBackgroundProcessingStart();
+
+            GetTokenClient.CompletedListener callback = new GetTokenClient.CompletedListener() {
+                @Override
+                public void completed(Bundle result) {
+                    getTokenCompleted(request, result);
+                }
+            };
+
+            getTokenClient.setCompletedListener(callback);
+            return true;
+        }
+
+        void getTokenCompleted(AuthorizationRequest request, Bundle result) {
+            getTokenClient = null;
+
+            notifyBackgroundProcessingStop();
+
+            if (result != null) {
+                ArrayList<String> currentPermissions = result.getStringArrayList(NativeProtocol.EXTRA_PERMISSIONS);
+                List<String> permissions = request.getPermissions();
+                if ((currentPermissions != null) &&
+                        ((permissions == null) || currentPermissions.containsAll(permissions))) {
+                    // We got all the permissions we needed, so we can complete the auth now.
+                    AccessToken token = AccessToken
+                            .createFromNativeLogin(result, AccessTokenSource.FACEBOOK_APPLICATION_SERVICE);
+                    Result outcome = Result.createTokenResult(token);
+                    completeAndValidate(outcome);
+                    return;
+                }
+
+                // We didn't get all the permissions we wanted, so update the request with just the permissions
+                // we still need.
+                ArrayList<String> newPermissions = new ArrayList<String>();
+                for (String permission : permissions) {
+                    if (!currentPermissions.contains(permission)) {
+                        newPermissions.add(permission);
+                    }
+                }
+                request.setPermissions(newPermissions);
+            }
+
+            tryNextHandler();
+        }
+    }
+
+    abstract class KatanaAuthHandler extends AuthHandler {
+        private static final long serialVersionUID = 1L;
+
+        protected boolean tryIntent(Intent intent, int requestCode) {
+            if (intent == null) {
+                return false;
+            }
+
+            try {
+                getStartActivityDelegate().startActivityForResult(intent, requestCode);
+            } catch (ActivityNotFoundException e) {
+                return false;
+            }
+
+            return true;
+        }
+    }
+
+    class KatanaLoginDialogAuthHandler extends KatanaAuthHandler {
+        private static final long serialVersionUID = 1L;
+
+        @Override
+        boolean tryAuthorize(AuthorizationRequest request) {
+            Intent intent = NativeProtocol.createLoginDialog20121101Intent(context, request.getApplicationId(),
+                    new ArrayList<String>(request.getPermissions()),
+                    request.getDefaultAudience().getNativeProtocolAudience());
+
+            return tryIntent(intent, request.getRequestCode());
+        }
+
+        @Override
+        boolean onActivityResult(int requestCode, int resultCode, Intent data) {
+            if (NativeProtocol.isServiceDisabledResult20121101(data)) {
+                tryNextHandler();
+            } else {
+                // Handle stuff
+                Result outcome = null;
+
+                if (resultCode == Activity.RESULT_CANCELED) {
+                    outcome = Result.createCancelResult(
+                            data.getStringExtra(NativeProtocol.STATUS_ERROR_DESCRIPTION));
+                } else if (resultCode != Activity.RESULT_OK) {
+                    outcome = Result
+                            .createErrorResult("Unexpected resultCode from authorization.", null);
+                } else {
+                    outcome = handleResultOk(data);
+                }
+
+                if (outcome != null) {
+                    completeAndValidate(outcome);
+                } else {
+                    tryNextHandler();
+                }
+            }
+            return true;
+        }
+
+        private Result handleResultOk(Intent data) {
+            Bundle extras = data.getExtras();
+            String errorType = extras.getString(NativeProtocol.STATUS_ERROR_TYPE);
+            if (errorType == null) {
+                return Result.createTokenResult(
+                        AccessToken.createFromNativeLogin(extras, AccessTokenSource.FACEBOOK_APPLICATION_NATIVE));
+            } else if (NativeProtocol.ERROR_SERVICE_DISABLED.equals(errorType)) {
+                return null;
+            } else if (NativeProtocol.ERROR_USER_CANCELED.equals(errorType)) {
+                return Result.createCancelResult(null);
+            } else {
+                return Result.createErrorResult(errorType, extras.getString("error_description"));
+            }
+        }
+    }
+
+    class KatanaProxyAuthHandler extends KatanaAuthHandler {
+        private static final long serialVersionUID = 1L;
+
+        @Override
+        boolean tryAuthorize(AuthorizationRequest request) {
+            Intent intent = NativeProtocol.createProxyAuthIntent(context,
+                    request.getApplicationId(), request.getPermissions());
+
+            return tryIntent(intent, request.getRequestCode());
+        }
+
+        @Override
+        boolean onActivityResult(int requestCode, int resultCode, Intent data) {
+            // Handle stuff
+            Result outcome = null;
+
+            if (resultCode == Activity.RESULT_CANCELED) {
+                outcome = Result.createCancelResult(data.getStringExtra("error"));
+            } else if (resultCode != Activity.RESULT_OK) {
+                outcome = Result.createErrorResult("Unexpected resultCode from authorization.", null);
+            } else {
+                outcome = handleResultOk(data);
+            }
+
+            if (outcome != null) {
+                completeAndValidate(outcome);
+            } else {
+                tryNextHandler();
+            }
+            return true;
+        }
+
+        private Result handleResultOk(Intent data) {
+            Bundle extras = data.getExtras();
+            String error = extras.getString("error");
+            if (error == null) {
+                error = extras.getString("error_type");
+            }
+
+            if (error == null) {
+                AccessToken token = AccessToken.createFromWebBundle(pendingRequest.getPermissions(), extras,
+                        AccessTokenSource.FACEBOOK_APPLICATION_WEB);
+                return Result.createTokenResult(token);
+            } else if (ServerProtocol.errorsProxyAuthDisabled.contains(error)) {
+                return null;
+            } else if (ServerProtocol.errorsUserCanceled.contains(error)) {
+                return Result.createCancelResult(null);
+            } else {
+                return Result.createErrorResult(error, extras.getString("error_description"));
+            }
+        }
+    }
+
+    static class AuthDialogBuilder extends WebDialog.Builder {
+        private static final String OAUTH_DIALOG = "oauth";
+        static final String REDIRECT_URI = "fbconnect://success";
+
+        public AuthDialogBuilder(Context context, String applicationId, Bundle parameters) {
+            super(context, applicationId, OAUTH_DIALOG, parameters);
+        }
+
+        @Override
+        public WebDialog build() {
+            Bundle parameters = getParameters();
+            parameters.putString(ServerProtocol.DIALOG_PARAM_REDIRECT_URI, REDIRECT_URI);
+            parameters.putString(ServerProtocol.DIALOG_PARAM_CLIENT_ID, getApplicationId());
+
+            return new WebDialog(getContext(), OAUTH_DIALOG, parameters, getTheme(), getListener());
+        }
+    }
+
+    static class AuthorizationRequest implements Serializable {
+        private static final long serialVersionUID = 1L;
+
+        private transient final StartActivityDelegate startActivityDelegate;
+        private SessionLoginBehavior loginBehavior;
+        private int requestCode;
+        private boolean isLegacy = false;
+        private List<String> permissions;
+        private SessionDefaultAudience defaultAudience;
+        private String applicationId;
+        private String previousAccessToken;
+
+        AuthorizationRequest(SessionLoginBehavior loginBehavior, int requestCode, boolean isLegacy,
+                List<String> permissions, SessionDefaultAudience defaultAudience, String applicationId,
+                String validateSameFbidAsToken, StartActivityDelegate startActivityDelegate) {
+            this.loginBehavior = loginBehavior;
+            this.requestCode = requestCode;
+            this.isLegacy = isLegacy;
+            this.permissions = permissions;
+            this.defaultAudience = defaultAudience;
+            this.applicationId = applicationId;
+            this.previousAccessToken = validateSameFbidAsToken;
+            this.startActivityDelegate = startActivityDelegate;
+
+        }
+
+        StartActivityDelegate getStartActivityDelegate() {
+            return startActivityDelegate;
+        }
+
+        List<String> getPermissions() {
+            return permissions;
+        }
+
+        void setPermissions(List<String> permissions) {
+            this.permissions = permissions;
+        }
+
+        SessionLoginBehavior getLoginBehavior() {
+            return loginBehavior;
+        }
+
+        int getRequestCode() {
+            return requestCode;
+        }
+
+        SessionDefaultAudience getDefaultAudience() {
+            return defaultAudience;
+        }
+
+        String getApplicationId() {
+            return applicationId;
+        }
+
+        boolean isLegacy() {
+            return isLegacy;
+        }
+
+        void setIsLegacy(boolean isLegacy) {
+            this.isLegacy = isLegacy;
+        }
+
+        String getPreviousAccessToken() {
+            return previousAccessToken;
+        }
+
+        boolean needsNewTokenValidation() {
+            return previousAccessToken != null && !isLegacy;
+        }
+    }
+
+
+    static class Result implements Serializable {
+        private static final long serialVersionUID = 1L;
+
+        enum Code {
+            SUCCESS,
+            CANCEL,
+            ERROR
+        }
+
+        final Code code;
+        final AccessToken token;
+        final String errorMessage;
+
+        private Result(Code code, AccessToken token, String errorMessage) {
+            this.token = token;
+            this.errorMessage = errorMessage;
+            this.code = code;
+        }
+
+        static Result createTokenResult(AccessToken token) {
+            return new Result(Code.SUCCESS, token, null);
+        }
+
+        static Result createCancelResult(String message) {
+            return new Result(Code.CANCEL, null, message);
+        }
+
+        static Result createErrorResult(String errorType, String errorDescription) {
+            String message = errorType;
+            if (errorDescription != null) {
+                message += ": " + errorDescription;
+            }
+            return new Result(Code.ERROR, null, message);
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookAuthorizationException.java b/facebook/src/com/facebook/FacebookAuthorizationException.java
new file mode 100644
index 000000000..b8273e500
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookAuthorizationException.java
@@ -0,0 +1,65 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * An Exception indicating that a Session failed to open or obtain new permissions.
+ */
+public class FacebookAuthorizationException extends FacebookException {
+    static final long serialVersionUID = 1;
+
+    /**
+     * Constructs a FacebookAuthorizationException with no additional
+     * information.
+     */
+    public FacebookAuthorizationException() {
+        super();
+    }
+
+    /**
+     * Constructs a FacebookAuthorizationException with a message.
+     * 
+     * @param message
+     *            A String to be returned from getMessage.
+     */
+    public FacebookAuthorizationException(String message) {
+        super(message);
+    }
+
+    /**
+     * Constructs a FacebookAuthorizationException with a message and inner
+     * error.
+     * 
+     * @param message
+     *            A String to be returned from getMessage.
+     * @param throwable
+     *            A Throwable to be returned from getCause.
+     */
+    public FacebookAuthorizationException(String message, Throwable throwable) {
+        super(message, throwable);
+    }
+
+    /**
+     * Constructs a FacebookAuthorizationException with an inner error.
+     * 
+     * @param throwable
+     *            A Throwable to be returned from getCause.
+     */
+    public FacebookAuthorizationException(Throwable throwable) {
+        super(throwable);
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookDialogException.java b/facebook/src/com/facebook/FacebookDialogException.java
new file mode 100644
index 000000000..0285837ad
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookDialogException.java
@@ -0,0 +1,53 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Represents an error condition relating to displaying a Facebook Web dialog.
+ */
+public class FacebookDialogException extends FacebookException {
+    static final long serialVersionUID = 1;
+    private int errorCode;
+    private String failingUrl;
+
+    /**
+     * Constructs a new FacebookException.
+     */
+    public FacebookDialogException(String message, int errorCode, String failingUrl) {
+        super(message);
+        this.errorCode = errorCode;
+        this.failingUrl = failingUrl;
+    }
+
+    /**
+     * Gets the error code received by the WebView. See:
+     * http://developer.android.com/reference/android/webkit/WebViewClient.html
+     *
+     * @return the error code
+     */
+    public int getErrorCode() {
+        return errorCode;
+    }
+
+    /**
+     * Gets the URL that the dialog was trying to load.
+     * @return the URL
+     */
+    public String getFailingUrl() {
+        return failingUrl;
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookException.java b/facebook/src/com/facebook/FacebookException.java
new file mode 100644
index 000000000..3525dbe47
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookException.java
@@ -0,0 +1,63 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Represents an error condition specific to the Facebook SDK for Android.
+ */
+public class FacebookException extends RuntimeException {
+    static final long serialVersionUID = 1;
+
+    /**
+     * Constructs a new FacebookException.
+     */
+    public FacebookException() {
+        super();
+    }
+
+    /**
+     * Constructs a new FacebookException.
+     * 
+     * @param message
+     *            the detail message of this exception
+     */
+    public FacebookException(String message) {
+        super(message);
+    }
+
+    /**
+     * Constructs a new FacebookException.
+     * 
+     * @param message
+     *            the detail message of this exception
+     * @param throwable
+     *            the cause of this exception
+     */
+    public FacebookException(String message, Throwable throwable) {
+        super(message, throwable);
+    }
+
+    /**
+     * Constructs a new FacebookException.
+     * 
+     * @param throwable
+     *            the cause of this exception
+     */
+    public FacebookException(Throwable throwable) {
+        super(throwable);
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookGraphObjectException.java b/facebook/src/com/facebook/FacebookGraphObjectException.java
new file mode 100644
index 000000000..a03828a9f
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookGraphObjectException.java
@@ -0,0 +1,63 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Represents an error specific to the {@link com.facebook.model.GraphObject GraphObject} class.
+ */
+public class FacebookGraphObjectException extends FacebookException {
+    static final long serialVersionUID = 1;
+
+    /**
+     * Constructs a new FacebookGraphObjectException.
+     */
+    public FacebookGraphObjectException() {
+        super();
+    }
+
+    /**
+     * Constructs a new FacebookGraphObjectException.
+     * 
+     * @param message
+     *            the detail message of this exception
+     */
+    public FacebookGraphObjectException(String message) {
+        super(message);
+    }
+
+    /**
+     * Constructs a new FacebookGraphObjectException.
+     * 
+     * @param message
+     *            the detail message of this exception
+     * @param throwable
+     *            the cause of this exception
+     */
+    public FacebookGraphObjectException(String message, Throwable throwable) {
+        super(message, throwable);
+    }
+
+    /**
+     * Constructs a new FacebookGraphObjectException.
+     * 
+     * @param throwable
+     *            the cause of this exception
+     */
+    public FacebookGraphObjectException(Throwable throwable) {
+        super(throwable);
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookOperationCanceledException.java b/facebook/src/com/facebook/FacebookOperationCanceledException.java
new file mode 100644
index 000000000..ed6d998db
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookOperationCanceledException.java
@@ -0,0 +1,59 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * An Exception indicating that an operation was canceled before it completed.
+ */
+public class FacebookOperationCanceledException extends FacebookException {
+    static final long serialVersionUID = 1;
+
+    /**
+     * Constructs a FacebookOperationCanceledException with no additional information.
+     */
+    public FacebookOperationCanceledException() {
+        super();
+    }
+
+    /**
+     * Constructs a FacebookOperationCanceledException with a message.
+     *
+     * @param message A String to be returned from getMessage.
+     */
+    public FacebookOperationCanceledException(String message) {
+        super(message);
+    }
+
+    /**
+     * Constructs a FacebookOperationCanceledException with a message and inner error.
+     *
+     * @param message   A String to be returned from getMessage.
+     * @param throwable A Throwable to be returned from getCause.
+     */
+    public FacebookOperationCanceledException(String message, Throwable throwable) {
+        super(message, throwable);
+    }
+
+    /**
+     * Constructs a FacebookOperationCanceledException with an inner error.
+     *
+     * @param throwable A Throwable to be returned from getCause.
+     */
+    public FacebookOperationCanceledException(Throwable throwable) {
+        super(throwable);
+    }
+}
diff --git a/facebook/src/com/facebook/FacebookRequestError.java b/facebook/src/com/facebook/FacebookRequestError.java
new file mode 100644
index 000000000..f4946c583
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookRequestError.java
@@ -0,0 +1,451 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import com.facebook.android.R;
+import com.facebook.internal.Utility;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.net.HttpURLConnection;
+
+/**
+ * This class represents an error that occurred during a Facebook request.
+ * <p/>
+ * In general, one would call {@link #getCategory()} to determine the type
+ * of error that occurred, and act accordingly. The app can also call
+ * {@link #getUserActionMessageId()} in order to get the resource id for a
+ * string that can be displayed to the user. For more information on error
+ * handling, see <a href="https://developers.facebook.com/docs/reference/api/errors/">
+ * https://developers.facebook.com/docs/reference/api/errors/</a>
+ */
+public final class FacebookRequestError {
+
+    /** Represents an invalid or unknown error code from the server. */
+    public static final int INVALID_ERROR_CODE = -1;
+
+    /**
+     * Indicates that there was no valid HTTP status code returned, indicating
+     * that either the error occurred locally, before the request was sent, or
+     * that something went wrong with the HTTP connection. Check the exception
+     * from {@link #getException()};
+     */
+    public static final int INVALID_HTTP_STATUS_CODE = -1;
+
+    private static final int INVALID_MESSAGE_ID = 0;
+
+    private static final String CODE_KEY = "code";
+    private static final String BODY_KEY = "body";
+    private static final String ERROR_KEY = "error";
+    private static final String ERROR_TYPE_FIELD_KEY = "type";
+    private static final String ERROR_CODE_FIELD_KEY = "code";
+    private static final String ERROR_MESSAGE_FIELD_KEY = "message";
+    private static final String ERROR_CODE_KEY = "error_code";
+    private static final String ERROR_SUB_CODE_KEY = "error_subcode";
+    private static final String ERROR_MSG_KEY = "error_msg";
+    private static final String ERROR_REASON_KEY = "error_reason";
+
+    private static class Range {
+        private final int start, end;
+
+        private Range(int start, int end) {
+            this.start = start;
+            this.end = end;
+        }
+
+        boolean contains(int value) {
+            return start <= value && value <= end;
+        }
+    }
+
+    private static final int EC_UNKNOWN_ERROR = 1;
+    private static final int EC_SERVICE_UNAVAILABLE = 2;
+    private static final int EC_APP_TOO_MANY_CALLS = 4;
+    private static final int EC_USER_TOO_MANY_CALLS = 17;
+    private static final int EC_PERMISSION_DENIED = 10;
+    private static final int EC_INVALID_SESSION = 102;
+    private static final int EC_INVALID_TOKEN = 190;
+    private static final Range EC_RANGE_PERMISSION = new Range(200, 299);
+    private static final int EC_APP_NOT_INSTALLED = 458;
+    private static final int EC_USER_CHECKPOINTED = 459;
+    private static final int EC_PASSWORD_CHANGED = 460;
+    private static final int EC_UNCONFIRMED_USER = 464;
+
+    private static final Range HTTP_RANGE_SUCCESS = new Range(200, 299);
+    private static final Range HTTP_RANGE_CLIENT_ERROR = new Range(400, 499);
+    private static final Range HTTP_RANGE_SERVER_ERROR = new Range(500, 599);
+
+    private final int userActionMessageId;
+    private final boolean shouldNotifyUser;
+    private final Category category;
+    private final int requestStatusCode;
+    private final int errorCode;
+    private final int subErrorCode;
+    private final String errorType;
+    private final String errorMessage;
+    private final JSONObject requestResult;
+    private final JSONObject requestResultBody;
+    private final Object batchRequestResult;
+    private final HttpURLConnection connection;
+    private final FacebookException exception;
+
+    private FacebookRequestError(int requestStatusCode, int errorCode,
+            int subErrorCode, String errorType, String errorMessage, JSONObject requestResultBody,
+            JSONObject requestResult, Object batchRequestResult, HttpURLConnection connection,
+            FacebookException exception) {
+        this.requestStatusCode = requestStatusCode;
+        this.errorCode = errorCode;
+        this.subErrorCode = subErrorCode;
+        this.errorType = errorType;
+        this.errorMessage = errorMessage;
+        this.requestResultBody = requestResultBody;
+        this.requestResult = requestResult;
+        this.batchRequestResult = batchRequestResult;
+        this.connection = connection;
+
+        boolean isLocalException = false;
+        if (exception != null) {
+            this.exception = exception;
+            isLocalException =  true;
+        } else {
+            this.exception = new FacebookServiceException(this, errorMessage);
+        }
+
+        // Initializes the error categories based on the documented error codes as outlined here
+        // https://developers.facebook.com/docs/reference/api/errors/
+        Category errorCategory = null;
+        int messageId = INVALID_MESSAGE_ID;
+        boolean shouldNotify = false;
+        if (isLocalException) {
+            errorCategory = Category.CLIENT;
+            messageId = INVALID_MESSAGE_ID;
+        } else {
+            if (errorCode == EC_UNKNOWN_ERROR || errorCode == EC_SERVICE_UNAVAILABLE) {
+                errorCategory = Category.SERVER;
+            } else if (errorCode == EC_APP_TOO_MANY_CALLS || errorCode == EC_USER_TOO_MANY_CALLS) {
+                errorCategory = Category.THROTTLING;
+            } else if (errorCode == EC_PERMISSION_DENIED || EC_RANGE_PERMISSION.contains(errorCode)) {
+                errorCategory = Category.PERMISSION;
+                messageId = R.string.com_facebook_requesterror_permissions;
+            } else if (errorCode == EC_INVALID_SESSION || errorCode == EC_INVALID_TOKEN) {
+                if (subErrorCode == EC_USER_CHECKPOINTED || subErrorCode == EC_UNCONFIRMED_USER) {
+                    errorCategory = Category.AUTHENTICATION_RETRY;
+                    messageId = R.string.com_facebook_requesterror_web_login;
+                    shouldNotify = true;
+                } else {
+                    errorCategory = Category.AUTHENTICATION_REOPEN_SESSION;
+
+                    if (subErrorCode == EC_APP_NOT_INSTALLED) {
+                        messageId = R.string.com_facebook_requesterror_relogin;
+                    } else if (subErrorCode == EC_PASSWORD_CHANGED) {
+                        messageId = R.string.com_facebook_requesterror_password_changed;
+                    } else {
+                        messageId = R.string.com_facebook_requesterror_reconnect;
+                    }
+                }
+            }
+
+            if (errorCategory == null) {
+                if (HTTP_RANGE_CLIENT_ERROR.contains(requestStatusCode)) {
+                    errorCategory = Category.BAD_REQUEST;
+                } else if (HTTP_RANGE_SERVER_ERROR.contains(requestStatusCode)) {
+                    errorCategory = Category.SERVER;
+                } else {
+                    errorCategory = Category.OTHER;
+                }
+            }
+        }
+
+        this.category = errorCategory;
+        this.userActionMessageId = messageId;
+        this.shouldNotifyUser = shouldNotify;
+    }
+
+    private FacebookRequestError(int requestStatusCode, int errorCode,
+            int subErrorCode, String errorType, String errorMessage, JSONObject requestResultBody,
+            JSONObject requestResult, Object batchRequestResult, HttpURLConnection connection) {
+        this(requestStatusCode, errorCode, subErrorCode, errorType, errorMessage,
+                requestResultBody, requestResult, batchRequestResult, connection, null);
+    }
+
+    FacebookRequestError(HttpURLConnection connection, Exception exception) {
+        this(INVALID_HTTP_STATUS_CODE, INVALID_ERROR_CODE, INVALID_ERROR_CODE,
+                null, null, null, null, null, connection,
+                (exception instanceof FacebookException) ?
+                        (FacebookException) exception : new FacebookException(exception));
+    }
+
+    public FacebookRequestError(int errorCode, String errorType, String errorMessage) {
+        this(INVALID_HTTP_STATUS_CODE, errorCode, INVALID_ERROR_CODE, errorType, errorMessage,
+                null, null, null, null, null);
+    }
+
+    /**
+     * Returns the resource id for a user-friendly message for the application to
+     * present to the user.
+     *
+     * @return a user-friendly message to present to the user
+     */
+    public int getUserActionMessageId() {
+        return userActionMessageId;
+    }
+
+    /**
+     * Returns whether direct user action is required to successfully continue with the Facebook
+     * operation. If user action is required, apps can also call {@link #getUserActionMessageId()}
+     * in order to get a resource id for a message to show the user.
+     *
+     * @return whether direct user action is required
+     */
+    public boolean shouldNotifyUser() {
+        return shouldNotifyUser;
+    }
+
+    /**
+     * Returns the category in which the error belongs. Applications can use the category
+     * to determine how best to handle the errors (e.g. exponential backoff for retries if
+     * being throttled).
+     *
+     * @return the category in which the error belong
+     */
+    public Category getCategory() {
+        return category;
+    }
+
+    /**
+     * Returns the HTTP status code for this particular request.
+     *
+     * @return the HTTP status code for the request
+     */
+    public int getRequestStatusCode() {
+        return requestStatusCode;
+    }
+
+    /**
+     * Returns the error code returned from Facebook.
+     *
+     * @return the error code returned from Facebook
+     */
+    public int getErrorCode() {
+        return errorCode;
+    }
+
+    /**
+     * Returns the sub-error code returned from Facebook.
+     *
+     * @return the sub-error code returned from Facebook
+     */
+    public int getSubErrorCode() {
+        return subErrorCode;
+    }
+
+    /**
+     * Returns the type of error as a raw string. This is generally less useful
+     * than using the {@link #getCategory()} method, but can provide further details
+     * on the error.
+     *
+     * @return the type of error as a raw string
+     */
+    public String getErrorType() {
+        return errorType;
+    }
+
+    /**
+     * Returns the error message returned from Facebook.
+     *
+     * @return the error message returned from Facebook
+     */
+    public String getErrorMessage() {
+        if (errorMessage != null) {
+            return errorMessage;
+        } else {
+            return exception.getLocalizedMessage();
+        }
+    }
+
+    /**
+     * Returns the body portion of the response corresponding to the request from Facebook.
+     *
+     * @return the body of the response for the request
+     */
+    public JSONObject getRequestResultBody() {
+        return requestResultBody;
+    }
+
+    /**
+     * Returns the full JSON response for the corresponding request. In a non-batch request,
+     * this would be the raw response in the form of a JSON object. In a batch request, this
+     * result will contain the body of the response as well as the HTTP headers that pertain
+     * to the specific request (in the form of a "headers" JSONArray).
+     *
+     * @return the full JSON response for the request
+     */
+    public JSONObject getRequestResult() {
+        return requestResult;
+    }
+
+    /**
+     * Returns the full JSON response for the batch request. If the request was not a batch
+     * request, then the result from this method is the same as {@link #getRequestResult()}.
+     * In case of a batch request, the result will be a JSONArray where the elements
+     * correspond to the requests in the batch. Callers should check the return type against
+     * either JSONObject or JSONArray and cast accordingly.
+     *
+     * @return the full JSON response for the batch
+     */
+    public Object getBatchRequestResult() {
+        return batchRequestResult;
+    }
+
+    /**
+     * Returns the HTTP connection that was used to make the request.
+     *
+     * @return the HTTP connection used to make the request
+     */
+    public HttpURLConnection getConnection() {
+        return connection;
+    }
+
+    /**
+     * Returns the exception associated with this request, if any.
+     *
+     * @return the exception associated with this request
+     */
+    public FacebookException getException() {
+        return exception;
+    }
+
+    @Override
+    public String toString() {
+        return new StringBuilder("{HttpStatus: ")
+                .append(requestStatusCode)
+                .append(", errorCode: ")
+                .append(errorCode)
+                .append(", errorType: ")
+                .append(errorType)
+                .append(", errorMessage: ")
+                .append(errorMessage)
+                .append("}")
+                .toString();
+    }
+
+    static FacebookRequestError checkResponseAndCreateError(JSONObject singleResult,
+            Object batchResult, HttpURLConnection connection) {
+        try {
+            if (singleResult.has(CODE_KEY)) {
+                int responseCode = singleResult.getInt(CODE_KEY);
+                Object body = Utility.getStringPropertyAsJSON(singleResult, BODY_KEY,
+                        Response.NON_JSON_RESPONSE_PROPERTY);
+
+                if (body != null && body instanceof JSONObject) {
+                    JSONObject jsonBody = (JSONObject) body;
+                    // Does this response represent an error from the service? We might get either an "error"
+                    // with several sub-properties, or else one or more top-level fields containing error info.
+                    String errorType = null;
+                    String errorMessage = null;
+                    int errorCode = INVALID_ERROR_CODE;
+                    int errorSubCode = INVALID_ERROR_CODE;
+
+                    boolean hasError = false;
+                    if (jsonBody.has(ERROR_KEY)) {
+                        // We assume the error object is correctly formatted.
+                        JSONObject error = (JSONObject) Utility.getStringPropertyAsJSON(jsonBody, ERROR_KEY, null);
+
+                        errorType = error.optString(ERROR_TYPE_FIELD_KEY, null);
+                        errorMessage = error.optString(ERROR_MESSAGE_FIELD_KEY, null);
+                        errorCode = error.optInt(ERROR_CODE_FIELD_KEY, INVALID_ERROR_CODE);
+                        errorSubCode = error.optInt(ERROR_SUB_CODE_KEY, INVALID_ERROR_CODE);
+                        hasError = true;
+                    } else if (jsonBody.has(ERROR_CODE_KEY) || jsonBody.has(ERROR_MSG_KEY)
+                            || jsonBody.has(ERROR_REASON_KEY)) {
+                        errorType = jsonBody.optString(ERROR_REASON_KEY, null);
+                        errorMessage = jsonBody.optString(ERROR_MSG_KEY, null);
+                        errorCode = jsonBody.optInt(ERROR_CODE_KEY, INVALID_ERROR_CODE);
+                        errorSubCode = jsonBody.optInt(ERROR_SUB_CODE_KEY, INVALID_ERROR_CODE);
+                        hasError = true;
+                    }
+
+                    if (hasError) {
+                        return new FacebookRequestError(responseCode, errorCode, errorSubCode,
+                                errorType, errorMessage, jsonBody, singleResult, batchResult, connection);
+                    }
+                }
+
+                // If we didn't get error details, but we did get a failure response code, report it.
+                if (!HTTP_RANGE_SUCCESS.contains(responseCode)) {
+                    return new FacebookRequestError(responseCode, INVALID_ERROR_CODE,
+                            INVALID_ERROR_CODE, null, null,
+                            singleResult.has(BODY_KEY) ?
+                                    (JSONObject) Utility.getStringPropertyAsJSON(
+                                            singleResult, BODY_KEY, Response.NON_JSON_RESPONSE_PROPERTY) : null,
+                            singleResult, batchResult, connection);
+                }
+            }
+        } catch (JSONException e) {
+            // defer the throwing of a JSONException to the graph object proxy
+        }
+        return null;
+    }
+
+    /**
+     * An enum that represents the Facebook SDK classification for the error that occurred.
+     */
+    public enum Category {
+        /**
+         * Indicates that the error is authentication related, and that the app should retry
+         * the request after some user action.
+         */
+        AUTHENTICATION_RETRY,
+
+        /**
+         * Indicates that the error is authentication related, and that the app should close
+         * the session and reopen it.
+         */
+        AUTHENTICATION_REOPEN_SESSION,
+
+        /** Indicates that the error is permission related. */
+        PERMISSION,
+
+        /**
+         * Indicates that the error implies the server had an unexpected failure or may be
+         * temporarily unavailable.
+         */
+        SERVER,
+
+        /** Indicates that the error results from the server throttling the client. */
+        THROTTLING,
+
+        /**
+         * Indicates that the error is Facebook-related but cannot be categorized at this time,
+         * and is likely newer than the current version of the SDK.
+         */
+        OTHER,
+
+        /**
+         * Indicates that the error is an application error resulting in a bad or malformed
+         * request to the server.
+         */
+        BAD_REQUEST,
+
+        /**
+         * Indicates that this is a client-side error. Examples of this can include, but are
+         * not limited to, JSON parsing errors or {@link java.io.IOException}s.
+         */
+        CLIENT
+    };
+
+}
diff --git a/facebook/src/com/facebook/FacebookSdkVersion.java b/facebook/src/com/facebook/FacebookSdkVersion.java
new file mode 100644
index 000000000..f315c7c52
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookSdkVersion.java
@@ -0,0 +1,22 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+final class FacebookSdkVersion {
+    public static final String BUILD = "3.0.0";
+    public static final String MIGRATION_BUNDLE = "fbsdk:20121026";
+}
diff --git a/facebook/src/com/facebook/FacebookServiceException.java b/facebook/src/com/facebook/FacebookServiceException.java
new file mode 100644
index 000000000..d8a342941
--- /dev/null
+++ b/facebook/src/com/facebook/FacebookServiceException.java
@@ -0,0 +1,63 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Represents an error returned from the Facebook service in response to a request.
+ */
+public class FacebookServiceException extends FacebookException {
+
+    private final FacebookRequestError error;
+
+    private static final long serialVersionUID = 1;
+
+    /**
+     * Constructs a new FacebookServiceException.
+     *
+     * @param error the error from the request
+     */
+    public FacebookServiceException(FacebookRequestError error, String errorMessage) {
+        super(errorMessage);
+        this.error = error;
+    }
+
+    /**
+     * Returns an object that encapsulates complete information representing the error returned by Facebook.
+     *
+     * @return complete information representing the error.
+     */
+    public final FacebookRequestError getRequestError() {
+        return error;
+    }
+
+    @Override
+    public final String toString() {
+        return new StringBuilder()
+                .append("{FacebookServiceException: ")
+                .append("httpResponseCode: ")
+                .append(error.getRequestStatusCode())
+                .append(", facebookErrorCode: ")
+                .append(error.getErrorCode())
+                .append(", facebookErrorType: ")
+                .append(error.getErrorType())
+                .append(", message: ")
+                .append(error.getErrorMessage())
+                .append("}")
+                .toString();
+    }
+
+}
diff --git a/facebook/src/com/facebook/GetTokenClient.java b/facebook/src/com/facebook/GetTokenClient.java
new file mode 100644
index 000000000..6a284a77e
--- /dev/null
+++ b/facebook/src/com/facebook/GetTokenClient.java
@@ -0,0 +1,128 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.*;
+
+final class GetTokenClient implements ServiceConnection {
+    final Context context;
+    final String applicationId;
+    final Handler handler;
+    CompletedListener listener;
+    boolean running;
+    Messenger sender;
+
+    GetTokenClient(Context context, String applicationId) {
+        Context applicationContext = context.getApplicationContext();
+
+        this.context = (applicationContext != null) ? applicationContext : context;
+        this.applicationId = applicationId;
+
+        handler = new Handler() {
+            @Override
+            public void handleMessage(Message message) {
+                GetTokenClient.this.handleMessage(message);
+            }
+        };
+    }
+
+    void setCompletedListener(CompletedListener listener) {
+        this.listener = listener;
+    }
+
+    boolean start() {
+        Intent intent = new Intent(NativeProtocol.INTENT_ACTION_PLATFORM_SERVICE);
+        intent.addCategory(Intent.CATEGORY_DEFAULT);
+        intent = NativeProtocol.validateKatanaServiceIntent(context, intent);
+
+        if (intent == null) {
+            callback(null);
+            return false;
+        } else {
+            running = true;
+            context.bindService(intent, this, Context.BIND_AUTO_CREATE);
+            return true;
+        }
+    }
+
+    void cancel() {
+        running = false;
+    }
+
+    @Override
+    public void onServiceConnected(ComponentName name, IBinder service) {
+        sender = new Messenger(service);
+        getToken();
+    }
+
+    @Override
+    public void onServiceDisconnected(ComponentName name) {
+        sender = null;
+        context.unbindService(this);
+        callback(null);
+    }
+
+    private void getToken() {
+        Bundle data = new Bundle();
+        data.putString(NativeProtocol.EXTRA_APPLICATION_ID, applicationId);
+
+        Message request = Message.obtain(null, NativeProtocol.MESSAGE_GET_ACCESS_TOKEN_REQUEST);
+        request.arg1 = NativeProtocol.PROTOCOL_VERSION_20121101;
+        request.setData(data);
+        request.replyTo = new Messenger(handler);
+
+        try {
+            sender.send(request);
+        } catch (RemoteException e) {
+            callback(null);
+        }
+    }
+
+    private void handleMessage(Message message) {
+        if (message.what == NativeProtocol.MESSAGE_GET_ACCESS_TOKEN_REPLY) {
+            Bundle extras = message.getData();
+            String errorType = extras.getString(NativeProtocol.STATUS_ERROR_TYPE);
+            if (errorType != null) {
+                callback(null);
+            } else {
+                callback(extras);
+            }
+            context.unbindService(this);
+        }
+    }
+
+    private void callback(Bundle result) {
+        if (!running) {
+            return;
+        }
+        running = false;
+
+        CompletedListener callback = listener;
+        if (callback != null) {
+            callback.completed(result);
+        }
+    }
+
+    interface CompletedListener {
+        void completed(Bundle result);
+    }
+}
diff --git a/facebook/src/com/facebook/HttpMethod.java b/facebook/src/com/facebook/HttpMethod.java
new file mode 100644
index 000000000..83936b091
--- /dev/null
+++ b/facebook/src/com/facebook/HttpMethod.java
@@ -0,0 +1,37 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Enumeration of HTTP methods supported by Request
+ */
+public enum HttpMethod {
+    /**
+     * Use HTTP method "GET" for the request
+     */
+    GET,
+
+    /**
+     * Use HTTP method "POST" for the request
+     */
+    POST,
+
+    /**
+     * Use HTTP method "DELETE" for the request
+     */
+    DELETE,
+}
diff --git a/facebook/src/com/facebook/LegacyHelper.java b/facebook/src/com/facebook/LegacyHelper.java
new file mode 100644
index 000000000..afcda0b26
--- /dev/null
+++ b/facebook/src/com/facebook/LegacyHelper.java
@@ -0,0 +1,31 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.os.Bundle;
+
+/**
+ * LegacyHelper is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the methods in this class is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public class LegacyHelper {
+    @Deprecated
+    public static void extendTokenCompleted(Session session, Bundle bundle) {
+        session.extendTokenCompleted(bundle);
+    }
+}
diff --git a/facebook/src/com/facebook/LoggingBehavior.java b/facebook/src/com/facebook/LoggingBehavior.java
new file mode 100644
index 000000000..621bf64f8
--- /dev/null
+++ b/facebook/src/com/facebook/LoggingBehavior.java
@@ -0,0 +1,41 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Specifies different categories of logging messages that can be generated.
+ *
+ * @see Settings#addLoggingBehavior(LoggingBehavior)
+ */
+public enum LoggingBehavior {
+    /**
+     * Indicates that HTTP requests and a summary of responses should be logged.
+     */
+    REQUESTS,
+    /**
+     * Indicates that access tokens should be logged as part of the request logging; normally they are not.
+     */
+    INCLUDE_ACCESS_TOKENS,
+    /**
+     * Indicates that the entire raw HTTP response for each request should be logged.
+     */
+    INCLUDE_RAW_RESPONSES,
+    /**
+     * Indicates that cache operations should be logged.
+     */
+    CACHE
+}
diff --git a/facebook/src/com/facebook/LoginActivity.java b/facebook/src/com/facebook/LoginActivity.java
new file mode 100644
index 000000000..2b45eeb08
--- /dev/null
+++ b/facebook/src/com/facebook/LoginActivity.java
@@ -0,0 +1,142 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.os.Bundle;
+import android.view.View;
+import com.facebook.android.R;
+
+/**
+ * This Activity is a necessary part of the overall Facebook login process
+ * but is not meant to be used directly. Add this activity to your
+ * AndroidManifest.xml to ensure proper handling of Facebook login.
+ * <pre>
+ * {@code
+ * <activity android:name="com.facebook.LoginActivity"
+ *           android:theme="@android:style/Theme.Translucent.NoTitleBar"
+ *           android:label="@string/app_name" />
+ * }
+ * </pre>
+ * Do not start this activity directly.
+ */
+public class LoginActivity extends Activity {
+    static final String RESULT_KEY = "com.facebook.LoginActivity:Result";
+
+    private static final String NULL_CALLING_PKG_ERROR_MSG =
+            "Cannot call LoginActivity with a null calling package. " +
+                    "This can occur if the launchMode of the caller is singleInstance.";
+    private static final String SAVED_CALLING_PKG_KEY = "callingPackage";
+    private static final String SAVED_AUTH_CLIENT = "authorizationClient";
+    private static final String EXTRA_REQUEST = "request";
+
+    private String callingPackage;
+    private AuthorizationClient authorizationClient;
+    private AuthorizationClient.AuthorizationRequest request;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.com_facebook_login_activity_layout);
+
+        if (savedInstanceState != null) {
+            callingPackage = savedInstanceState.getString(SAVED_CALLING_PKG_KEY);
+            authorizationClient = (AuthorizationClient) savedInstanceState.getSerializable(SAVED_AUTH_CLIENT);
+        } else {
+            callingPackage = getCallingPackage();
+            authorizationClient = new AuthorizationClient();
+            request = (AuthorizationClient.AuthorizationRequest) getIntent().getSerializableExtra(EXTRA_REQUEST);
+        }
+
+        authorizationClient.setContext(this);
+        authorizationClient.setOnCompletedListener(new AuthorizationClient.OnCompletedListener() {
+            @Override
+            public void onCompleted(AuthorizationClient.Result outcome) {
+                onAuthClientCompleted(outcome);
+            }
+        });
+        authorizationClient.setBackgroundProcessingListener(new AuthorizationClient.BackgroundProcessingListener() {
+            @Override
+            public void onBackgroundProcessingStarted() {
+                findViewById(R.id.com_facebook_login_activity_progress_bar).setVisibility(View.VISIBLE);
+            }
+
+            @Override
+            public void onBackgroundProcessingStopped() {
+                findViewById(R.id.com_facebook_login_activity_progress_bar).setVisibility(View.GONE);
+            }
+        });
+    }
+
+    private void onAuthClientCompleted(AuthorizationClient.Result outcome) {
+        request = null;
+
+        int resultCode = (outcome.code == AuthorizationClient.Result.Code.CANCEL) ?
+                RESULT_CANCELED : RESULT_OK;
+
+        Bundle bundle = new Bundle();
+        bundle.putSerializable(RESULT_KEY, outcome);
+
+        Intent resultIntent = new Intent();
+        resultIntent.putExtras(bundle);
+        setResult(resultCode, resultIntent);
+
+        finish();
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+
+        // If the calling package is null, this generally means that the callee was started
+        // with a launchMode of singleInstance. Unfortunately, Android does not allow a result
+        // to be set when the callee is a singleInstance, so we throw an exception here.
+        if (callingPackage == null) {
+            throw new FacebookException(NULL_CALLING_PKG_ERROR_MSG);
+        }
+
+        authorizationClient.startOrContinueAuth(request);
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+
+        authorizationClient.cancelCurrentHandler();
+        findViewById(R.id.com_facebook_login_activity_progress_bar).setVisibility(View.GONE);
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        outState.putString(SAVED_CALLING_PKG_KEY, callingPackage);
+        outState.putSerializable(SAVED_AUTH_CLIENT, authorizationClient);
+    }
+
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        authorizationClient.onActivityResult(requestCode, resultCode, data);
+    }
+
+    static Bundle populateIntentExtras(AuthorizationClient.AuthorizationRequest request) {
+        Bundle extras = new Bundle();
+        extras.putSerializable(EXTRA_REQUEST, request);
+        return extras;
+    }
+}
diff --git a/facebook/src/com/facebook/NativeProtocol.java b/facebook/src/com/facebook/NativeProtocol.java
new file mode 100644
index 000000000..c416b37f0
--- /dev/null
+++ b/facebook/src/com/facebook/NativeProtocol.java
@@ -0,0 +1,254 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.content.pm.Signature;
+import android.os.Bundle;
+import android.text.TextUtils;
+import com.facebook.internal.Utility;
+
+import java.util.ArrayList;
+import java.util.List;
+
+final class NativeProtocol {
+    static final String KATANA_PACKAGE = "com.facebook.katana";
+    static final String KATANA_PROXY_AUTH_ACTIVITY = "com.facebook.katana.ProxyAuth";
+    static final String KATANA_TOKEN_REFRESH_ACTIVITY = "com.facebook.katana.platform.TokenRefreshService";
+    static final String KATANA_SIGNATURE =
+            "30820268308201d102044a9c4610300d06092a864886f70d0101040500307a310"
+                    + "b3009060355040613025553310b30090603550408130243413112301006035504"
+                    + "07130950616c6f20416c746f31183016060355040a130f46616365626f6f6b204"
+                    + "d6f62696c653111300f060355040b130846616365626f6f6b311d301b06035504"
+                    + "03131446616365626f6f6b20436f72706f726174696f6e3020170d30393038333"
+                    + "13231353231365a180f32303530303932353231353231365a307a310b30090603"
+                    + "55040613025553310b30090603550408130243413112301006035504071309506"
+                    + "16c6f20416c746f31183016060355040a130f46616365626f6f6b204d6f62696c"
+                    + "653111300f060355040b130846616365626f6f6b311d301b06035504031314466"
+                    + "16365626f6f6b20436f72706f726174696f6e30819f300d06092a864886f70d01"
+                    + "0101050003818d0030818902818100c207d51df8eb8c97d93ba0c8c1002c928fa"
+                    + "b00dc1b42fca5e66e99cc3023ed2d214d822bc59e8e35ddcf5f44c7ae8ade50d7"
+                    + "e0c434f500e6c131f4a2834f987fc46406115de2018ebbb0d5a3c261bd97581cc"
+                    + "fef76afc7135a6d59e8855ecd7eacc8f8737e794c60a761c536b72b11fac8e603"
+                    + "f5da1a2d54aa103b8a13c0dbc10203010001300d06092a864886f70d010104050"
+                    + "0038181005ee9be8bcbb250648d3b741290a82a1c9dc2e76a0af2f2228f1d9f9c"
+                    + "4007529c446a70175c5a900d5141812866db46be6559e2141616483998211f4a6"
+                    + "73149fb2232a10d247663b26a9031e15f84bc1c74d141ff98a02d76f85b2c8ab2"
+                    + "571b6469b232d8e768a7f7ca04f7abe4a775615916c07940656b58717457b42bd"
+                    + "928a2";
+    private static final String BASIC_INFO = "basic_info";
+    public static final String KATANA_PROXY_AUTH_PERMISSIONS_KEY = "scope";
+    public static final String KATANA_PROXY_AUTH_APP_ID_KEY = "client_id";
+
+    static final boolean validateSignature(Context context, String packageName) {
+        PackageInfo packageInfo = null;
+        try {
+            packageInfo = context.getPackageManager().getPackageInfo(packageName,
+                    PackageManager.GET_SIGNATURES);
+        } catch (PackageManager.NameNotFoundException e) {
+            return false;
+        }
+
+        for (Signature signature : packageInfo.signatures) {
+            if (signature.toCharsString().equals(KATANA_SIGNATURE)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    static Intent validateKatanaActivityIntent(Context context, Intent intent) {
+        if (intent == null) {
+            return null;
+        }
+
+        ResolveInfo resolveInfo = context.getPackageManager().resolveActivity(intent, 0);
+        if (resolveInfo == null) {
+            return null;
+        }
+
+        if (!validateSignature(context, resolveInfo.activityInfo.packageName)) {
+            return null;
+        }
+
+        return intent;
+    }
+
+    static Intent validateKatanaServiceIntent(Context context, Intent intent) {
+        if (intent == null) {
+            return null;
+        }
+
+        ResolveInfo resolveInfo = context.getPackageManager().resolveService(intent, 0);
+        if (resolveInfo == null) {
+            return null;
+        }
+
+        if (!validateSignature(context, resolveInfo.serviceInfo.packageName)) {
+            return null;
+        }
+
+        return intent;
+    }
+
+    static Intent createProxyAuthIntent(Context context, String applicationId, List<String> permissions) {
+        Intent intent = new Intent()
+                .setClassName(KATANA_PACKAGE, KATANA_PROXY_AUTH_ACTIVITY)
+                .putExtra(KATANA_PROXY_AUTH_APP_ID_KEY, applicationId);
+
+        if (!Utility.isNullOrEmpty(permissions)) {
+            intent.putExtra(KATANA_PROXY_AUTH_PERMISSIONS_KEY, TextUtils.join(",", permissions));
+        }
+
+        return validateKatanaActivityIntent(context, intent);
+    }
+
+    static Intent createTokenRefreshIntent(Context context) {
+        Intent intent = new Intent();
+        intent.setClassName(KATANA_PACKAGE, KATANA_TOKEN_REFRESH_ACTIVITY);
+
+        return validateKatanaServiceIntent(context, intent);
+    }
+
+    // ---------------------------------------------------------------------------------------------
+    // Native Protocol updated 2012-11
+
+    static final String INTENT_ACTION_PLATFORM_ACTIVITY = "com.facebook.platform.PLATFORM_ACTIVITY";
+    static final String INTENT_ACTION_PLATFORM_SERVICE = "com.facebook.platform.PLATFORM_SERVICE";
+
+    static final int PROTOCOL_VERSION_20121101 = 20121101;
+    static final String EXTRA_PROTOCOL_VERSION = "com.facebook.platform.protocol.PROTOCOL_VERSION";
+    static final String EXTRA_PROTOCOL_ACTION = "com.facebook.platform.protocol.PROTOCOL_ACTION";
+
+    // Messages supported by PlatformService:
+    static final int MESSAGE_GET_ACCESS_TOKEN_REQUEST = 0x10000;
+    static final int MESSAGE_GET_ACCESS_TOKEN_REPLY   = 0x10001;
+
+    // MESSAGE_ERROR_REPLY data keys:
+    // See STATUS_*
+
+    // MESSAGE_GET_ACCESS_TOKEN_REQUEST data keys:
+    // EXTRA_APPLICATION_ID
+
+    // MESSAGE_GET_ACCESS_TOKEN_REPLY data keys:
+    // EXTRA_ACCESS_TOKEN
+    // EXTRA_EXPIRES_SECONDS_SINCE_EPOCH
+    // EXTRA_PERMISSIONS
+
+    // Values of EXTRA_PROTOCOL_ACTION supported by PlatformActivity:
+    static final String ACTION_LOGIN_DIALOG = "com.facebook.platform.action.request.LOGIN_DIALOG";
+
+    // Values of EXTRA_PROTOCOL_ACTION values returned by PlatformActivity:
+    static final String ACTION_LOGIN_DIALOG_REPLY =
+            "com.facebook.platform.action.reply.LOGIN_DIALOG";
+
+    // Extras supported for ACTION_LOGIN_DIALOG:
+    static final String EXTRA_PERMISSIONS = "com.facebook.platform.extra.PERMISSIONS";
+    static final String EXTRA_WRITE_PRIVACY = "com.facebook.platform.extra.WRITE_PRIVACY";
+    static final String EXTRA_APPLICATION_ID = "com.facebook.platform.extra.APPLICATION_ID";
+
+    // Extras returned by setResult() for ACTION_LOGIN_DIALOG
+    static final String EXTRA_ACCESS_TOKEN = "com.facebook.platform.extra.ACCESS_TOKEN";
+    static final String EXTRA_EXPIRES_SECONDS_SINCE_EPOCH =
+            "com.facebook.platform.extra.EXPIRES_SECONDS_SINCE_EPOCH";
+    // EXTRA_PERMISSIONS
+
+    // Keys for status data in MESSAGE_ERROR_REPLY from PlatformService and for error
+    // extras returned by PlatformActivity's setResult() in case of errors:
+    static final String STATUS_ERROR_TYPE = "com.facebook.platform.status.ERROR_TYPE";
+    static final String STATUS_ERROR_DESCRIPTION =
+            "com.facebook.platform.status.ERROR_DESCRIPTION";
+    static final String STATUS_ERROR_CODE = "com.facebook.platform.status.ERROR_CODE";
+    static final String STATUS_ERROR_SUBCODE = "com.facebook.platform.status.ERROR_SUBCODE";
+    static final String STATUS_ERROR_JSON = "com.facebook.platform.status.ERROR_JSON";
+
+    // Expected values for ERROR_KEY_TYPE.  Clients should tolerate other values:
+    static final String ERROR_UNKNOWN_ERROR = "UnknownError";
+    static final String ERROR_PROTOCOL_ERROR = "ProtocolError";
+    static final String ERROR_USER_CANCELED = "UserCanceled";
+    static final String ERROR_APPLICATION_ERROR = "ApplicationError";
+    static final String ERROR_NETWORK_ERROR = "NetworkError";
+    static final String ERROR_PERMISSION_DENIED = "PermissionDenied";
+    static final String ERROR_SERVICE_DISABLED = "ServiceDisabled";
+
+    static final String AUDIENCE_ME = "SELF";
+    static final String AUDIENCE_FRIENDS = "ALL_FRIENDS";
+    static final String AUDIENCE_EVERYONE = "EVERYONE";
+
+    static Intent createLoginDialog20121101Intent(Context context, String applicationId, ArrayList<String> permissions,
+            String audience) {
+        Intent intent = new Intent()
+                    .setAction(INTENT_ACTION_PLATFORM_ACTIVITY)
+                    .addCategory(Intent.CATEGORY_DEFAULT)
+                    .putExtra(EXTRA_PROTOCOL_VERSION, PROTOCOL_VERSION_20121101)
+                    .putExtra(EXTRA_PROTOCOL_ACTION, ACTION_LOGIN_DIALOG)
+                    .putExtra(EXTRA_APPLICATION_ID, applicationId)
+                    .putStringArrayListExtra(EXTRA_PERMISSIONS, ensureDefaultPermissions(permissions))
+                    .putExtra(EXTRA_WRITE_PRIVACY, ensureDefaultAudience(audience));
+        return validateKatanaActivityIntent(context, intent);
+    }
+
+    private static String ensureDefaultAudience(String audience) {
+        if (Utility.isNullOrEmpty(audience)) {
+            return AUDIENCE_ME;
+        } else {
+            return audience;
+        }
+    }
+
+    private static ArrayList<String> ensureDefaultPermissions(ArrayList<String> permissions) {
+        ArrayList<String> updated;
+
+        // Return if we are doing publish, or if basic_info is already included
+        if (Utility.isNullOrEmpty(permissions)) {
+            updated = new ArrayList<String>();
+        } else {
+            for (String permission : permissions) {
+                if (Session.isPublishPermission(permission) || BASIC_INFO.equals(permission)) {
+                    return permissions;
+                }
+            }
+            updated = new ArrayList<String>(permissions);
+        }
+
+        updated.add(BASIC_INFO);
+        return updated;
+    }
+
+    static boolean isServiceDisabledResult20121101(Intent data) {
+        int protocolVersion = data.getIntExtra(EXTRA_PROTOCOL_VERSION, 0);
+        String errorType = data.getStringExtra(STATUS_ERROR_TYPE);
+
+        return ((PROTOCOL_VERSION_20121101 == protocolVersion) && ERROR_SERVICE_DISABLED.equals(errorType));
+    }
+
+    static AccessTokenSource getAccessTokenSourceFromNative(Bundle extras) {
+        long expected = PROTOCOL_VERSION_20121101;
+        long actual = extras.getInt(EXTRA_PROTOCOL_VERSION, 0);
+
+        if (expected == actual) {
+            return AccessTokenSource.FACEBOOK_APPLICATION_NATIVE;
+        } else {
+            return AccessTokenSource.FACEBOOK_APPLICATION_WEB;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/NonCachingTokenCachingStrategy.java b/facebook/src/com/facebook/NonCachingTokenCachingStrategy.java
new file mode 100644
index 000000000..f055d5e92
--- /dev/null
+++ b/facebook/src/com/facebook/NonCachingTokenCachingStrategy.java
@@ -0,0 +1,39 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.os.Bundle;
+
+/**
+ * Implements a trivial {@link TokenCachingStrategy} that does not actually cache any tokens.
+ * It is intended for use when an access token may be used on a temporary basis but should not be
+ * cached for future use (for instance, when handling a deep link).
+ */
+public class NonCachingTokenCachingStrategy extends TokenCachingStrategy {
+    @Override
+    public Bundle load() {
+        return null;
+    }
+
+    @Override
+    public void save(Bundle bundle) {
+    }
+
+    @Override
+    public void clear() {
+    }
+}
diff --git a/facebook/src/com/facebook/Request.java b/facebook/src/com/facebook/Request.java
new file mode 100644
index 000000000..837ce4a65
--- /dev/null
+++ b/facebook/src/com/facebook/Request.java
@@ -0,0 +1,1823 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.graphics.Bitmap;
+import android.location.Location;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.ParcelFileDescriptor;
+import android.text.TextUtils;
+import android.util.Pair;
+import com.facebook.internal.ServerProtocol;
+import com.facebook.model.*;
+import com.facebook.internal.Logger;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.*;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLEncoder;
+import java.text.SimpleDateFormat;
+import java.util.*;
+import java.util.Map.Entry;
+
+/**
+ * A single request to be sent to the Facebook Platform through either the <a
+ * href="https://developers.facebook.com/docs/reference/api/">Graph API</a> or <a
+ * href="https://developers.facebook.com/docs/reference/rest/">REST API</a>. The Request class provides functionality
+ * relating to serializing and deserializing requests and responses, making calls in batches (with a single round-trip
+ * to the service) and making calls asynchronously.
+ *
+ * The particular service endpoint that a request targets is determined by either a graph path (see the
+ * {@link #setGraphPath(String) setGraphPath} method) or a REST method name (see the {@link #setRestMethod(String)
+ * setRestMethod} method); a single request may not target both.
+ *
+ * A Request can be executed either anonymously or representing an authenticated user. In the former case, no Session
+ * needs to be specified, while in the latter, a Session that is in an opened state must be provided. If requests are
+ * executed in a batch, a Facebook application ID must be associated with the batch, either by supplying a Session for
+ * at least one of the requests in the batch (the first one found in the batch will be used) or by calling the
+ * {@link #setDefaultBatchApplicationId(String) setDefaultBatchApplicationId} method.
+ *
+ * After completion of a request, its Session, if any, will be checked to determine if its Facebook access token needs
+ * to be extended; if so, a request to extend it will be issued in the background.
+ */
+public class Request {
+    /**
+     * The maximum number of requests that can be submitted in a single batch. This limit is enforced on the service
+     * side by the Facebook platform, not by the Request class.
+     */
+    public static final int MAXIMUM_BATCH_SIZE = 50;
+
+    private static final String ME = "me";
+    private static final String MY_FRIENDS = "me/friends";
+    private static final String MY_PHOTOS = "me/photos";
+    private static final String MY_VIDEOS = "me/videos";
+    private static final String SEARCH = "search";
+    private static final String MY_FEED = "me/feed";
+
+    private static final String USER_AGENT_BASE = "FBAndroidSDK";
+    private static final String USER_AGENT_HEADER = "User-Agent";
+    private static final String CONTENT_TYPE_HEADER = "Content-Type";
+
+    // Parameter names/values
+    private static final String PICTURE_PARAM = "picture";
+    private static final String FORMAT_PARAM = "format";
+    private static final String FORMAT_JSON = "json";
+    private static final String SDK_PARAM = "sdk";
+    private static final String SDK_ANDROID = "android";
+    private static final String ACCESS_TOKEN_PARAM = "access_token";
+    private static final String BATCH_ENTRY_NAME_PARAM = "name";
+    private static final String BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM = "omit_response_on_success";
+    private static final String BATCH_ENTRY_DEPENDS_ON_PARAM = "depends_on";
+    private static final String BATCH_APP_ID_PARAM = "batch_app_id";
+    private static final String BATCH_RELATIVE_URL_PARAM = "relative_url";
+    private static final String BATCH_BODY_PARAM = "body";
+    private static final String BATCH_METHOD_PARAM = "method";
+    private static final String BATCH_PARAM = "batch";
+    private static final String ATTACHMENT_FILENAME_PREFIX = "file";
+    private static final String ATTACHED_FILES_PARAM = "attached_files";
+    private static final String MIGRATION_BUNDLE_PARAM = "migration_bundle";
+    private static final String ISO_8601_FORMAT_STRING = "yyyy-MM-dd'T'HH:mm:ssZ";
+
+    private static final String MIME_BOUNDARY = "3i2ndDfv2rTHiSisAbouNdArYfORhtTPEefj3q2f";
+
+    private static String defaultBatchApplicationId;
+
+    private Session session;
+    private HttpMethod httpMethod;
+    private String graphPath;
+    private GraphObject graphObject;
+    private String restMethod;
+    private String batchEntryName;
+    private String batchEntryDependsOn;
+    private boolean batchEntryOmitResultOnSuccess = true;
+    private Bundle parameters;
+    private Callback callback;
+    private String overriddenURL;
+
+    /**
+     * Constructs a request without a session, graph path, or any other parameters.
+     */
+    public Request() {
+        this(null, null, null, null, null);
+    }
+
+    /**
+     * Constructs a request with a Session to retrieve a particular graph path. A Session need not be provided, in which
+     * case the request is sent without an access token and thus is not executed in the context of any particular user.
+     * Only certain graph requests can be expected to succeed in this case. If a Session is provided, it must be in an
+     * opened state or the request will fail.
+     *
+     * @param session
+     *            the Session to use, or null
+     * @param graphPath
+     *            the graph path to retrieve
+     */
+    public Request(Session session, String graphPath) {
+        this(session, graphPath, null, null, null);
+    }
+
+    /**
+     * Constructs a request with a specific Session, graph path, parameters, and HTTP method. A Session need not be
+     * provided, in which case the request is sent without an access token and thus is not executed in the context of
+     * any particular user. Only certain graph requests can be expected to succeed in this case. If a Session is
+     * provided, it must be in an opened state or the request will fail.
+     *
+     * Depending on the httpMethod parameter, the object at the graph path may be retrieved, created, or deleted.
+     *
+     * @param session
+     *            the Session to use, or null
+     * @param graphPath
+     *            the graph path to retrieve, create, or delete
+     * @param parameters
+     *            additional parameters to pass along with the Graph API request; parameters must be Strings, Numbers,
+     *            Bitmaps, Dates, or Byte arrays.
+     * @param httpMethod
+     *            the {@link HttpMethod} to use for the request, or null for default (HttpMethod.GET)
+     */
+    public Request(Session session, String graphPath, Bundle parameters, HttpMethod httpMethod) {
+        this(session, graphPath, parameters, httpMethod, null);
+    }
+
+    /**
+     * Constructs a request with a specific Session, graph path, parameters, and HTTP method. A Session need not be
+     * provided, in which case the request is sent without an access token and thus is not executed in the context of
+     * any particular user. Only certain graph requests can be expected to succeed in this case. If a Session is
+     * provided, it must be in an opened state or the request will fail.
+     *
+     * Depending on the httpMethod parameter, the object at the graph path may be retrieved, created, or deleted.
+     *
+     * @param session
+     *            the Session to use, or null
+     * @param graphPath
+     *            the graph path to retrieve, create, or delete
+     * @param parameters
+     *            additional parameters to pass along with the Graph API request; parameters must be Strings, Numbers,
+     *            Bitmaps, Dates, or Byte arrays.
+     * @param httpMethod
+     *            the {@link HttpMethod} to use for the request, or null for default (HttpMethod.GET)
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     */
+    public Request(Session session, String graphPath, Bundle parameters, HttpMethod httpMethod, Callback callback) {
+        this.session = session;
+        this.graphPath = graphPath;
+        this.callback = callback;
+
+        setHttpMethod(httpMethod);
+
+        if (parameters != null) {
+            this.parameters = new Bundle(parameters);
+        } else {
+            this.parameters = new Bundle();
+        }
+
+        if (!this.parameters.containsKey(MIGRATION_BUNDLE_PARAM)) {
+            this.parameters.putString(MIGRATION_BUNDLE_PARAM, FacebookSdkVersion.MIGRATION_BUNDLE);
+        }
+    }
+
+    Request(Session session, URL overriddenURL) {
+        this.session = session;
+        this.overriddenURL = overriddenURL.toString();
+
+        setHttpMethod(HttpMethod.GET);
+
+        this.parameters = new Bundle();
+    }
+
+    /**
+     * Creates a new Request configured to post a GraphObject to a particular graph path, to either create or update the
+     * object at that path.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param graphPath
+     *            the graph path to retrieve, create, or delete
+     * @param graphObject
+     *            the GraphObject to create or update
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newPostRequest(Session session, String graphPath, GraphObject graphObject, Callback callback) {
+        Request request = new Request(session, graphPath, null, HttpMethod.POST , callback);
+        request.setGraphObject(graphObject);
+        return request;
+    }
+
+    /**
+     * Creates a new Request configured to make a call to the Facebook REST API.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param restMethod
+     *            the method in the Facebook REST API to execute
+     * @param parameters
+     *            additional parameters to pass along with the Graph API request; parameters must be Strings, Numbers,
+     *            Bitmaps, Dates, or Byte arrays.
+     * @param httpMethod
+     *            the HTTP method to use for the request; must be one of GET, POST, or DELETE
+     * @return a Request that is ready to execute
+     */
+    public static Request newRestRequest(Session session, String restMethod, Bundle parameters, HttpMethod httpMethod) {
+        Request request = new Request(session, null, parameters, httpMethod);
+        request.setRestMethod(restMethod);
+        return request;
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a user's own profile.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newMeRequest(Session session, final GraphUserCallback callback) {
+        Callback wrapper = new Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                if (callback != null) {
+                    callback.onCompleted(response.getGraphObjectAs(GraphUser.class), response);
+                }
+            }
+        };
+        return new Request(session, ME, null, null, wrapper);
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a user's friend list.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newMyFriendsRequest(Session session, final GraphUserListCallback callback) {
+        Callback wrapper = new Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                if (callback != null) {
+                    callback.onCompleted(typedListFromResponse(response, GraphUser.class), response);
+                }
+            }
+        };
+        return new Request(session, MY_FRIENDS, null, null, wrapper);
+    }
+
+    /**
+     * Creates a new Request configured to upload a photo to the user's default photo album.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param image
+     *            the image to upload
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newUploadPhotoRequest(Session session, Bitmap image, Callback callback) {
+        Bundle parameters = new Bundle(1);
+        parameters.putParcelable(PICTURE_PARAM, image);
+
+        return new Request(session, MY_PHOTOS, parameters, HttpMethod.POST, callback);
+    }
+
+    /**
+     * Creates a new Request configured to upload a photo to the user's default photo album. The photo
+     * will be read from the specified stream.
+     *
+     * @param session  the Session to use, or null; if non-null, the session must be in an opened state
+     * @param file     the file containing the photo to upload
+     * @param callback a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newUploadPhotoRequest(Session session, File file,
+            Callback callback) throws FileNotFoundException {
+        ParcelFileDescriptor descriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
+        Bundle parameters = new Bundle(1);
+        parameters.putParcelable(PICTURE_PARAM, descriptor);
+
+        return new Request(session, MY_PHOTOS, parameters, HttpMethod.POST, callback);
+    }
+
+    /**
+     * Creates a new Request configured to upload a photo to the user's default photo album. The photo
+     * will be read from the specified file descriptor.
+     *
+     * @param session  the Session to use, or null; if non-null, the session must be in an opened state
+     * @param file     the file to upload
+     * @param callback a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newUploadVideoRequest(Session session, File file,
+            Callback callback) throws FileNotFoundException {
+        ParcelFileDescriptor descriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
+        Bundle parameters = new Bundle(1);
+        parameters.putParcelable(file.getName(), descriptor);
+
+        return new Request(session, MY_VIDEOS, parameters, HttpMethod.POST, callback);
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a particular graph path.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param graphPath
+     *            the graph path to retrieve
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newGraphPathRequest(Session session, String graphPath, Callback callback) {
+        return new Request(session, graphPath, null, null, callback);
+    }
+
+    /**
+     * Creates a new Request that is configured to perform a search for places near a specified location via the Graph
+     * API. At least one of location or searchText must be specified.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param location
+     *            the location around which to search; only the latitude and longitude components of the location are
+     *            meaningful
+     * @param radiusInMeters
+     *            the radius around the location to search, specified in meters; this is ignored if
+     *            no location is specified
+     * @param resultsLimit
+     *            the maximum number of results to return
+     * @param searchText
+     *            optional text to search for as part of the name or type of an object
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     *
+     * @throws FacebookException If neither location nor searchText is specified
+     */
+    public static Request newPlacesSearchRequest(Session session, Location location, int radiusInMeters,
+            int resultsLimit, String searchText, final GraphPlaceListCallback callback) {
+        if (location == null && Utility.isNullOrEmpty(searchText)) {
+            throw new FacebookException("Either location or searchText must be specified.");
+        }
+
+        Bundle parameters = new Bundle(5);
+        parameters.putString("type", "place");
+        parameters.putInt("limit", resultsLimit);
+        if (location != null) {
+            parameters.putString("center",
+                    String.format(Locale.US, "%f,%f", location.getLatitude(), location.getLongitude()));
+            parameters.putInt("distance", radiusInMeters);
+        }
+        if (!Utility.isNullOrEmpty(searchText)) {
+            parameters.putString("q", searchText);
+        }
+
+        Callback wrapper = new Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                if (callback != null) {
+                    callback.onCompleted(typedListFromResponse(response, GraphPlace.class), response);
+                }
+            }
+        };
+
+        return new Request(session, SEARCH, parameters, HttpMethod.GET, wrapper);
+    }
+
+    /**
+     * Creates a new Request configured to post a status update to a user's feed.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param message
+     *            the text of the status update
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newStatusUpdateRequest(Session session, String message, Callback callback) {
+        Bundle parameters = new Bundle();
+        parameters.putString("message", message);
+
+        return new Request(session, MY_FEED, parameters, HttpMethod.POST, callback);
+    }
+
+    /**
+     * Returns the GraphObject, if any, associated with this request.
+     *
+     * @return the GraphObject associated with this requeset, or null if there is none
+     */
+    public final GraphObject getGraphObject() {
+        return this.graphObject;
+    }
+
+    /**
+     * Sets the GraphObject associated with this request. This is meaningful only for POST requests.
+     *
+     * @param graphObject
+     *            the GraphObject to upload along with this request
+     */
+    public final void setGraphObject(GraphObject graphObject) {
+        this.graphObject = graphObject;
+    }
+
+    /**
+     * Returns the graph path of this request, if any.
+     *
+     * @return the graph path of this request, or null if there is none
+     */
+    public final String getGraphPath() {
+        return this.graphPath;
+    }
+
+    /**
+     * Sets the graph path of this request. A graph path may not be set if a REST method has been specified.
+     *
+     * @param graphPath
+     *            the graph path for this request
+     */
+    public final void setGraphPath(String graphPath) {
+        this.graphPath = graphPath;
+    }
+
+    /**
+     * Returns the {@link HttpMethod} to use for this request.
+     *
+     * @return the HttpMethod
+     */
+    public final HttpMethod getHttpMethod() {
+        return this.httpMethod;
+    }
+
+    /**
+     * Sets the {@link HttpMethod} to use for this request.
+     *
+     * @param httpMethod
+     *            the HttpMethod, or null for the default (HttpMethod.GET).
+     */
+    public final void setHttpMethod(HttpMethod httpMethod) {
+        if (overriddenURL != null && httpMethod != HttpMethod.GET) {
+            throw new FacebookException("Can't change HTTP method on request with overridden URL.");
+            }
+        this.httpMethod = (httpMethod != null) ? httpMethod : HttpMethod.GET;
+    }
+
+    /**
+     * Returns the parameters for this request.
+     *
+     * @return the parameters
+     */
+    public final Bundle getParameters() {
+        return this.parameters;
+    }
+
+    /**
+     * Sets the parameters for this request.
+     *
+     * @param parameters
+     *            the parameters
+     */
+    public final void setParameters(Bundle parameters) {
+        this.parameters = parameters;
+    }
+
+    /**
+     * Returns the REST method to call for this request.
+     *
+     * @return the REST method
+     */
+    public final String getRestMethod() {
+        return this.restMethod;
+    }
+
+    /**
+     * Sets the REST method to call for this request. A REST method may not be set if a graph path has been specified.
+     *
+     * @param restMethod
+     *            the REST method to call
+     */
+    public final void setRestMethod(String restMethod) {
+        this.restMethod = restMethod;
+    }
+
+    /**
+     * Returns the Session associated with this request.
+     *
+     * @return the Session associated with this request, or null if none has been specified
+     */
+    public final Session getSession() {
+        return this.session;
+    }
+
+    /**
+     * Sets the Session to use for this request. The Session does not need to be opened at the time it is specified, but
+     * it must be opened by the time the request is executed.
+     *
+     * @param session
+     *            the Session to use for this request
+     */
+    public final void setSession(Session session) {
+        this.session = session;
+    }
+
+    /**
+     * Returns the name of this request's entry in a batched request.
+     *
+     * @return the name of this request's batch entry, or null if none has been specified
+     */
+    public final String getBatchEntryName() {
+        return this.batchEntryName;
+    }
+
+    /**
+     * Sets the name of this request's entry in a batched request. This value is only used if this request is submitted
+     * as part of a batched request. It can be used to specified dependencies between requests. See <a
+     * href="https://developers.facebook.com/docs/reference/api/batch/">Batch Requests</a> in the Graph API
+     * documentation for more details.
+     *
+     * @param batchEntryName
+     *            the name of this request's entry in a batched request, which must be unique within a particular batch
+     *            of requests
+     */
+    public final void setBatchEntryName(String batchEntryName) {
+        this.batchEntryName = batchEntryName;
+    }
+
+    /**
+     * Returns the name of the request that this request entry explicitly depends on in a batched request.
+     *
+     * @return the name of this request's dependency, or null if none has been specified
+     */
+    public final String getBatchEntryDependsOn() {
+        return this.batchEntryDependsOn;
+    }
+
+    /**
+     * Sets the name of the request entry that this request explicitly depends on in a batched request. This value is
+     * only used if this request is submitted as part of a batched request. It can be used to specified dependencies
+     * between requests. See <a href="https://developers.facebook.com/docs/reference/api/batch/">Batch Requests</a> in
+     * the Graph API documentation for more details.
+     *
+     * @param batchEntryDependsOn
+     *            the name of the request entry that this entry depends on in a batched request
+     */
+    public final void setBatchEntryDependsOn(String batchEntryDependsOn) {
+        this.batchEntryDependsOn = batchEntryDependsOn;
+    }
+
+
+    /**
+     * Returns whether or not this batch entry will return a response if it is successful. Only applies if another
+     * request entry in the batch specifies this entry as a dependency.
+     *
+     * @return the name of this request's dependency, or null if none has been specified
+     */
+    public final boolean getBatchEntryOmitResultOnSuccess() {
+        return this.batchEntryOmitResultOnSuccess;
+    }
+
+    /**
+     * Sets whether or not this batch entry will return a response if it is successful. Only applies if another
+     * request entry in the batch specifies this entry as a dependency. See
+     * <a href="https://developers.facebook.com/docs/reference/api/batch/">Batch Requests</a> in the Graph API
+     * documentation for more details.
+     *
+     * @param batchEntryOmitResultOnSuccess
+     *            the name of the request entry that this entry depends on in a batched request
+     */
+    public final void setBatchEntryOmitResultOnSuccess(boolean batchEntryOmitResultOnSuccess) {
+        this.batchEntryOmitResultOnSuccess = batchEntryOmitResultOnSuccess;
+    }
+
+    /**
+     * Gets the default Facebook application ID that will be used to submit batched requests if none of those requests
+     * specifies a Session. Batched requests require an application ID, so either at least one request in a batch must
+     * specify a Session or the application ID must be specified explicitly.
+     *
+     * @return the Facebook application ID to use for batched requests if none can be determined
+     */
+    public static final String getDefaultBatchApplicationId() {
+        return Request.defaultBatchApplicationId;
+    }
+
+    /**
+     * Sets the default application ID that will be used to submit batched requests if none of those requests specifies
+     * a Session. Batched requests require an application ID, so either at least one request in a batch must specify a
+     * Session or the application ID must be specified explicitly.
+     *
+     * @param applicationId
+     *            the Facebook application ID to use for batched requests if none can be determined
+     */
+    public static final void setDefaultBatchApplicationId(String applicationId) {
+        Request.defaultBatchApplicationId = applicationId;
+    }
+
+    /**
+     * Returns the callback which will be called when the request finishes.
+     *
+     * @return the callback
+     */
+    public final Callback getCallback() {
+        return callback;
+    }
+
+    /**
+     * Sets the callback which will be called when the request finishes.
+     *
+     * @param callback
+     *            the callback
+     */
+    public final void setCallback(Callback callback) {
+        this.callback = callback;
+    }
+
+    /**
+     * Starts a new Request configured to post a GraphObject to a particular graph path, to either create or update the
+     * object at that path.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param graphPath
+     *            the graph path to retrieve, create, or delete
+     * @param graphObject
+     *            the GraphObject to create or update
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executePostRequestAsync(Session session, String graphPath, GraphObject graphObject,
+            Callback callback) {
+        return newPostRequest(session, graphPath, graphObject, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to make a call to the Facebook REST API.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param restMethod
+     *            the method in the Facebook REST API to execute
+     * @param parameters
+     *            additional parameters to pass along with the Graph API request; parameters must be Strings, Numbers,
+     *            Bitmaps, Dates, or Byte arrays.
+     * @param httpMethod
+     *            the HTTP method to use for the request; must be one of GET, POST, or DELETE
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeRestRequestAsync(Session session, String restMethod, Bundle parameters,
+            HttpMethod httpMethod) {
+        return newRestRequest(session, restMethod, parameters, httpMethod).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a user's own profile.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeMeRequestAsync(Session session, GraphUserCallback callback) {
+        return newMeRequest(session, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a user's friend list.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeMyFriendsRequestAsync(Session session, GraphUserListCallback callback) {
+        return newMyFriendsRequest(session, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to upload a photo to the user's default photo album.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param image
+     *            the image to upload
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeUploadPhotoRequestAsync(Session session, Bitmap image, Callback callback) {
+        return newUploadPhotoRequest(session, image, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to upload a photo to the user's default photo album. The photo
+     * will be read from the specified stream.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session  the Session to use, or null; if non-null, the session must be in an opened state
+     * @param file     the file containing the photo to upload
+     * @param callback a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeUploadPhotoRequestAsync(Session session, File file,
+            Callback callback) throws FileNotFoundException {
+        return newUploadPhotoRequest(session, file, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a particular graph path.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param graphPath
+     *            the graph path to retrieve
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeGraphPathRequestAsync(Session session, String graphPath, Callback callback) {
+        return newGraphPathRequest(session, graphPath, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request that is configured to perform a search for places near a specified location via the Graph
+     * API.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param location
+     *            the location around which to search; only the latitude and longitude components of the location are
+     *            meaningful
+     * @param radiusInMeters
+     *            the radius around the location to search, specified in meters
+     * @param resultsLimit
+     *            the maximum number of results to return
+     * @param searchText
+     *            optional text to search for as part of the name or type of an object
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     *
+     * @throws FacebookException If neither location nor searchText is specified
+     */
+    public static RequestAsyncTask executePlacesSearchRequestAsync(Session session, Location location, int radiusInMeters,
+            int resultsLimit, String searchText, GraphPlaceListCallback callback) {
+        return newPlacesSearchRequest(session, location, radiusInMeters, resultsLimit, searchText, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to post a status update to a user's feed.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param message
+     *            the text of the status update
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeStatusUpdateRequestAsync(Session session, String message, Callback callback) {
+        return newStatusUpdateRequest(session, message, callback).executeAsync();
+    }
+
+    /**
+     * Executes this request and returns the response.
+     * <p/>
+     * This should only be called if you have transitioned off the UI thread.
+     *
+     * @return the Response object representing the results of the request
+     *
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     * @throws IllegalArgumentException
+     */
+    public final Response executeAndWait() {
+        return Request.executeAndWait(this);
+    }
+
+    /**
+     * Executes this request and returns the response.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @return a RequestAsyncTask that is executing the request
+     *
+     * @throws IllegalArgumentException
+     */
+    public final RequestAsyncTask executeAsync() {
+        return Request.executeBatchAsync(this);
+    }
+
+    /**
+     * Serializes one or more requests but does not execute them. The resulting HttpURLConnection can be executed
+     * explicitly by the caller.
+     *
+     * @param requests
+     *            one or more Requests to serialize
+     * @return an HttpURLConnection which is ready to execute
+     *
+     * @throws FacebookException
+     *            If any of the requests in the batch are badly constructed or if there are problems
+     *            contacting the service
+     * @throws IllegalArgumentException if the passed in array is zero-length
+     * @throws NullPointerException if the passed in array or any of its contents are null
+     */
+    public static HttpURLConnection toHttpConnection(Request... requests) {
+        return toHttpConnection(Arrays.asList(requests));
+    }
+
+    /**
+     * Serializes one or more requests but does not execute them. The resulting HttpURLConnection can be executed
+     * explicitly by the caller.
+     *
+     * @param requests
+     *            one or more Requests to serialize
+     * @return an HttpURLConnection which is ready to execute
+     *
+     * @throws FacebookException
+     *            If any of the requests in the batch are badly constructed or if there are problems
+     *            contacting the service
+     * @throws IllegalArgumentException if the passed in collection is empty
+     * @throws NullPointerException if the passed in collection or any of its contents are null
+     */
+    public static HttpURLConnection toHttpConnection(Collection<Request> requests) {
+        Validate.notEmptyAndContainsNoNulls(requests, "requests");
+
+        return toHttpConnection(new RequestBatch(requests));
+    }
+
+
+    /**
+     * Serializes one or more requests but does not execute them. The resulting HttpURLConnection can be executed
+     * explicitly by the caller.
+     *
+     * @param requests
+     *            a RequestBatch to serialize
+     * @return an HttpURLConnection which is ready to execute
+     *
+     * @throws FacebookException
+     *            If any of the requests in the batch are badly constructed or if there are problems
+     *            contacting the service
+     * @throws IllegalArgumentException
+     */
+    public static HttpURLConnection toHttpConnection(RequestBatch requests) {
+
+        for (Request request : requests) {
+            request.validate();
+        }
+
+        URL url = null;
+        try {
+            if (requests.size() == 1) {
+                // Single request case.
+                Request request = requests.get(0);
+                // In the non-batch case, the URL we use really is the same one returned by getUrlForSingleRequest.
+                url = new URL(request.getUrlForSingleRequest());
+            } else {
+                // Batch case -- URL is just the graph API base, individual request URLs are serialized
+                // as relative_url parameters within each batch entry.
+                url = new URL(ServerProtocol.GRAPH_URL);
+            }
+        } catch (MalformedURLException e) {
+            throw new FacebookException("could not construct URL for request", e);
+        }
+
+        HttpURLConnection connection;
+        try {
+            connection = createConnection(url);
+
+            serializeToUrlConnection(requests, connection);
+        } catch (IOException e) {
+            throw new FacebookException("could not construct request body", e);
+        } catch (JSONException e) {
+            throw new FacebookException("could not construct request body", e);
+        }
+
+        return connection;
+    }
+
+    /**
+     * Executes a single request on the current thread and returns the response.
+     * <p/>
+     * This should only be used if you have transitioned off the UI thread.
+     *
+     * @param request
+     *            the Request to execute
+     *
+     * @return the Response object representing the results of the request
+     *
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     */
+    public static Response executeAndWait(Request request) {
+        List<Response> responses = executeBatchAndWait(request);
+
+        if (responses == null || responses.size() != 1) {
+            throw new FacebookException("invalid state: expected a single response");
+        }
+
+        return responses.get(0);
+    }
+
+    /**
+     * Executes requests on the current thread as a single batch and returns the responses.
+     * <p/>
+     * This should only be used if you have transitioned off the UI thread.
+     *
+     * @param requests
+     *            the Requests to execute
+     *
+     * @return a list of Response objects representing the results of the requests; responses are returned in the same
+     *         order as the requests were specified.
+     *
+     * @throws NullPointerException
+     *            In case of a null request
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     */
+    public static List<Response> executeBatchAndWait(Request... requests) {
+        Validate.notNull(requests, "requests");
+
+        return executeBatchAndWait(Arrays.asList(requests));
+    }
+
+    /**
+     * Executes requests as a single batch on the current thread and returns the responses.
+     * <p/>
+     * This should only be used if you have transitioned off the UI thread.
+     *
+     * @param requests
+     *            the Requests to execute
+     *
+     * @return a list of Response objects representing the results of the requests; responses are returned in the same
+     *         order as the requests were specified.
+     *
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     */
+    public static List<Response> executeBatchAndWait(Collection<Request> requests) {
+        return executeBatchAndWait(new RequestBatch(requests));
+    }
+
+    /**
+     * Executes requests on the current thread as a single batch and returns the responses.
+     * <p/>
+     * This should only be used if you have transitioned off the UI thread.
+     *
+     * @param requests
+     *            the batch of Requests to execute
+     *
+     * @return a list of Response objects representing the results of the requests; responses are returned in the same
+     *         order as the requests were specified.
+     *
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     * @throws IllegalArgumentException if the passed in RequestBatch is empty
+     * @throws NullPointerException if the passed in RequestBatch or any of its contents are null
+     */
+    public static List<Response> executeBatchAndWait(RequestBatch requests) {
+        Validate.notEmptyAndContainsNoNulls(requests, "requests");
+
+        HttpURLConnection connection = null;
+        try {
+            connection = toHttpConnection(requests);
+        } catch (Exception ex) {
+            List<Response> responses = Response.constructErrorResponses(requests.getRequests(), null, new FacebookException(ex));
+            runCallbacks(requests, responses);
+            return responses;
+        }
+
+        List<Response> responses = executeConnectionAndWait(connection, requests);
+        return responses;
+    }
+
+    /**
+     * Executes requests as a single batch asynchronously. This function will return immediately, and the requests will
+     * be processed on a separate thread. In order to process results of a request, or determine whether a request
+     * succeeded or failed, a callback must be specified (see the {@link #setCallback(Callback) setCallback} method).
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param requests
+     *            the Requests to execute
+     * @return a RequestAsyncTask that is executing the request
+     *
+     * @throws NullPointerException
+     *            If a null request is passed in
+     */
+    public static RequestAsyncTask executeBatchAsync(Request... requests) {
+        Validate.notNull(requests, "requests");
+
+        return executeBatchAsync(Arrays.asList(requests));
+    }
+
+    /**
+     * Executes requests as a single batch asynchronously. This function will return immediately, and the requests will
+     * be processed on a separate thread. In order to process results of a request, or determine whether a request
+     * succeeded or failed, a callback must be specified (see the {@link #setCallback(Callback) setCallback} method).
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param requests
+     *            the Requests to execute
+     * @return a RequestAsyncTask that is executing the request
+     *
+     * @throws IllegalArgumentException if the passed in collection is empty
+     * @throws NullPointerException if the passed in collection or any of its contents are null
+     */
+    public static RequestAsyncTask executeBatchAsync(Collection<Request> requests) {
+        return executeBatchAsync(new RequestBatch(requests));
+    }
+
+    /**
+     * Executes requests as a single batch asynchronously. This function will return immediately, and the requests will
+     * be processed on a separate thread. In order to process results of a request, or determine whether a request
+     * succeeded or failed, a callback must be specified (see the {@link #setCallback(Callback) setCallback} method).
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param requests
+     *            the RequestBatch to execute
+     * @return a RequestAsyncTask that is executing the request
+     *
+     * @throws IllegalArgumentException if the passed in RequestBatch is empty
+     * @throws NullPointerException if the passed in RequestBatch or any of its contents are null
+     */
+    public static RequestAsyncTask executeBatchAsync(RequestBatch requests) {
+        Validate.notEmptyAndContainsNoNulls(requests, "requests");
+
+        RequestAsyncTask asyncTask = new RequestAsyncTask(requests);
+        asyncTask.executeOnSettingsExecutor();
+        return asyncTask;
+    }
+
+    /**
+     * Executes requests that have already been serialized into an HttpURLConnection. No validation is done that the
+     * contents of the connection actually reflect the serialized requests, so it is the caller's responsibility to
+     * ensure that it will correctly generate the desired responses.
+     * <p/>
+     * This should only be called if you have transitioned off the UI thread.
+     *
+     * @param connection
+     *            the HttpURLConnection that the requests were serialized into
+     * @param requests
+     *            the requests represented by the HttpURLConnection
+     * @return a list of Responses corresponding to the requests
+     *
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     */
+    public static List<Response> executeConnectionAndWait(HttpURLConnection connection, Collection<Request> requests) {
+        return executeConnectionAndWait(connection, new RequestBatch(requests));
+    }
+
+    /**
+     * Executes requests that have already been serialized into an HttpURLConnection. No validation is done that the
+     * contents of the connection actually reflect the serialized requests, so it is the caller's responsibility to
+     * ensure that it will correctly generate the desired responses.
+     * <p/>
+     * This should only be called if you have transitioned off the UI thread.
+     *
+     * @param connection
+     *            the HttpURLConnection that the requests were serialized into
+     * @param requests
+     *            the RequestBatch represented by the HttpURLConnection
+     * @return a list of Responses corresponding to the requests
+     *
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     */
+    public static List<Response> executeConnectionAndWait(HttpURLConnection connection, RequestBatch requests) {
+        List<Response> responses = Response.fromHttpConnection(connection, requests);
+
+        Utility.disconnectQuietly(connection);
+
+        int numRequests = requests.size();
+        if (numRequests != responses.size()) {
+            throw new FacebookException(String.format("Received %d responses while expecting %d", responses.size(),
+                    numRequests));
+        }
+
+        runCallbacks(requests, responses);
+
+        // See if any of these sessions needs its token to be extended. We do this after issuing the request so as to
+        // reduce network contention.
+        HashSet<Session> sessions = new HashSet<Session>();
+        for (Request request : requests) {
+            if (request.session != null) {
+                sessions.add(request.session);
+            }
+        }
+        for (Session session : sessions) {
+            session.extendAccessTokenIfNeeded();
+        }
+
+        return responses;
+    }
+
+    /**
+     * Asynchronously executes requests that have already been serialized into an HttpURLConnection. No validation is
+     * done that the contents of the connection actually reflect the serialized requests, so it is the caller's
+     * responsibility to ensure that it will correctly generate the desired responses. This function will return
+     * immediately, and the requests will be processed on a separate thread. In order to process results of a request,
+     * or determine whether a request succeeded or failed, a callback must be specified (see the
+     * {@link #setCallback(Callback) setCallback} method).
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param connection
+     *            the HttpURLConnection that the requests were serialized into
+     * @param requests
+     *            the requests represented by the HttpURLConnection
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeConnectionAsync(HttpURLConnection connection, RequestBatch requests) {
+        return executeConnectionAsync(null, connection, requests);
+    }
+
+    /**
+     * Asynchronously executes requests that have already been serialized into an HttpURLConnection. No validation is
+     * done that the contents of the connection actually reflect the serialized requests, so it is the caller's
+     * responsibility to ensure that it will correctly generate the desired responses. This function will return
+     * immediately, and the requests will be processed on a separate thread. In order to process results of a request,
+     * or determine whether a request succeeded or failed, a callback must be specified (see the
+     * {@link #setCallback(Callback) setCallback} method)
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param callbackHandler
+     *            a Handler that will be used to post calls to the callback for each request; if null, a Handler will be
+     *            instantiated on the calling thread
+     * @param connection
+     *            the HttpURLConnection that the requests were serialized into
+     * @param requests
+     *            the requests represented by the HttpURLConnection
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeConnectionAsync(Handler callbackHandler, HttpURLConnection connection,
+            RequestBatch requests) {
+        Validate.notNull(connection, "connection");
+
+        RequestAsyncTask asyncTask = new RequestAsyncTask(connection, requests);
+        requests.setCallbackHandler(callbackHandler);
+        asyncTask.executeOnSettingsExecutor();
+        return asyncTask;
+    }
+
+    /**
+     * Returns a string representation of this Request, useful for debugging.
+     *
+     * @return the debugging information
+     */
+    @Override
+    public String toString() {
+        return new StringBuilder().append("{Request: ").append(" session: ").append(session).append(", graphPath: ")
+                .append(graphPath).append(", graphObject: ").append(graphObject).append(", restMethod: ")
+                .append(restMethod).append(", httpMethod: ").append(httpMethod).append(", parameters: ")
+                .append(parameters).append("}").toString();
+    }
+
+    static void runCallbacks(final RequestBatch requests, List<Response> responses) {
+        int numRequests = requests.size();
+
+        // Compile the list of callbacks to call and then run them either on this thread or via the Handler we received
+        final ArrayList<Pair<Callback, Response>> callbacks = new ArrayList<Pair<Callback, Response>>();
+        for (int i = 0; i < numRequests; ++i) {
+            Request request = requests.get(i);
+            if (request.callback != null) {
+                callbacks.add(new Pair<Callback, Response>(request.callback, responses.get(i)));
+            }
+        }
+
+        if (callbacks.size() > 0) {
+            Runnable runnable = new Runnable() {
+                public void run() {
+                    for (Pair<Callback, Response> pair : callbacks) {
+                        pair.first.onCompleted(pair.second);
+                    }
+
+                    List<RequestBatch.Callback> batchCallbacks = requests.getCallbacks();
+                    for (RequestBatch.Callback batchCallback : batchCallbacks) {
+                        batchCallback.onBatchCompleted(requests);
+                    }
+                }
+            };
+
+            Handler callbackHandler = requests.getCallbackHandler();
+            if (callbackHandler == null) {
+                // Run on this thread.
+                runnable.run();
+            } else {
+                // Post to the handler.
+                callbackHandler.post(runnable);
+            }
+        }
+    }
+
+    static HttpURLConnection createConnection(URL url) throws IOException {
+        HttpURLConnection connection;
+        connection = (HttpURLConnection) url.openConnection();
+
+        connection.setRequestProperty(USER_AGENT_HEADER, getUserAgent());
+        connection.setRequestProperty(CONTENT_TYPE_HEADER, getMimeContentType());
+
+        connection.setChunkedStreamingMode(0);
+        return connection;
+    }
+
+
+    private void addCommonParameters() {
+        if (this.session != null) {
+            if (!this.session.isOpened()) {
+                throw new FacebookException("Session provided to a Request in un-opened state.");
+            } else if (!this.parameters.containsKey(ACCESS_TOKEN_PARAM)) {
+                String accessToken = this.session.getAccessToken();
+                Logger.registerAccessToken(accessToken);
+                this.parameters.putString(ACCESS_TOKEN_PARAM, accessToken);
+            }
+        }
+        this.parameters.putString(SDK_PARAM, SDK_ANDROID);
+        this.parameters.putString(FORMAT_PARAM, FORMAT_JSON);
+    }
+
+    private String appendParametersToBaseUrl(String baseUrl) {
+        Uri.Builder uriBuilder = new Uri.Builder().encodedPath(baseUrl);
+
+        Set<String> keys = this.parameters.keySet();
+        for (String key : keys) {
+            Object value = this.parameters.get(key);
+
+            if (value == null) {
+                value = "";
+            }
+
+            if (isSupportedParameterType(value)) {
+                value = parameterToString(value);
+            } else {
+                if (httpMethod == HttpMethod.GET) {
+                    throw new IllegalArgumentException(String.format("Unsupported parameter type for GET request: %s",
+                                    value.getClass().getSimpleName()));
+                }
+                continue;
+            }
+
+            uriBuilder.appendQueryParameter(key, value.toString());
+        }
+
+        return uriBuilder.toString();
+    }
+
+    final String getUrlForBatchedRequest() {
+        if (overriddenURL != null) {
+            throw new FacebookException("Can't override URL for a batch request");
+        }
+
+        String baseUrl;
+        if (this.restMethod != null) {
+            baseUrl = ServerProtocol.BATCHED_REST_METHOD_URL_BASE + this.restMethod;
+        } else {
+            baseUrl = this.graphPath;
+        }
+
+        addCommonParameters();
+        return appendParametersToBaseUrl(baseUrl);
+    }
+
+    final String getUrlForSingleRequest() {
+        if (overriddenURL != null) {
+            return overriddenURL.toString();
+        }
+
+        String baseUrl;
+        if (this.restMethod != null) {
+            baseUrl = ServerProtocol.REST_URL_BASE + this.restMethod;
+        } else {
+            baseUrl = ServerProtocol.GRAPH_URL_BASE + this.graphPath;
+        }
+
+        addCommonParameters();
+        return appendParametersToBaseUrl(baseUrl);
+    }
+
+
+    private void serializeToBatch(JSONArray batch, Bundle attachments) throws JSONException, IOException {
+        JSONObject batchEntry = new JSONObject();
+
+        if (this.batchEntryName != null) {
+            batchEntry.put(BATCH_ENTRY_NAME_PARAM, this.batchEntryName);
+            batchEntry.put(BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM, this.batchEntryOmitResultOnSuccess);
+        }
+        if (this.batchEntryDependsOn != null) {
+            batchEntry.put(BATCH_ENTRY_DEPENDS_ON_PARAM, this.batchEntryDependsOn);
+        }
+
+        String relativeURL = getUrlForBatchedRequest();
+        batchEntry.put(BATCH_RELATIVE_URL_PARAM, relativeURL);
+        batchEntry.put(BATCH_METHOD_PARAM, httpMethod);
+        if (this.session != null) {
+            String accessToken = this.session.getAccessToken();
+            Logger.registerAccessToken(accessToken);
+        }
+
+        // Find all of our attachments. Remember their names and put them in the attachment map.
+        ArrayList<String> attachmentNames = new ArrayList<String>();
+        Set<String> keys = this.parameters.keySet();
+        for (String key : keys) {
+            Object value = this.parameters.get(key);
+            if (isSupportedAttachmentType(value)) {
+                // Make the name unique across this entire batch.
+                String name = String.format("%s%d", ATTACHMENT_FILENAME_PREFIX, attachments.size());
+                attachmentNames.add(name);
+                Utility.putObjectInBundle(attachments, name, value);
+            }
+        }
+
+        if (!attachmentNames.isEmpty()) {
+            String attachmentNamesString = TextUtils.join(",", attachmentNames);
+            batchEntry.put(ATTACHED_FILES_PARAM, attachmentNamesString);
+        }
+
+        if (this.graphObject != null) {
+            // Serialize the graph object into the "body" parameter.
+            final ArrayList<String> keysAndValues = new ArrayList<String>();
+            processGraphObject(this.graphObject, relativeURL, new KeyValueSerializer() {
+                @Override
+                public void writeString(String key, String value) throws IOException {
+                    keysAndValues.add(String.format("%s=%s", key, URLEncoder.encode(value, "UTF-8")));
+                }
+            });
+            String bodyValue = TextUtils.join("&", keysAndValues);
+            batchEntry.put(BATCH_BODY_PARAM, bodyValue);
+        }
+
+        batch.put(batchEntry);
+    }
+
+    private void validate() {
+        if (graphPath != null && restMethod != null) {
+            throw new IllegalArgumentException("Only one of a graph path or REST method may be specified per request.");
+        }
+    }
+
+    final static void serializeToUrlConnection(RequestBatch requests, HttpURLConnection connection)
+    throws IOException, JSONException {
+        Logger logger = new Logger(LoggingBehavior.REQUESTS, "Request");
+
+        int numRequests = requests.size();
+
+        HttpMethod connectionHttpMethod = (numRequests == 1) ? requests.get(0).httpMethod : HttpMethod.POST;
+        connection.setRequestMethod(connectionHttpMethod.name());
+
+        URL url = connection.getURL();
+        logger.append("Request:\n");
+        logger.appendKeyValue("Id", requests.getId());
+        logger.appendKeyValue("URL", url);
+        logger.appendKeyValue("Method", connection.getRequestMethod());
+        logger.appendKeyValue("User-Agent", connection.getRequestProperty("User-Agent"));
+        logger.appendKeyValue("Content-Type", connection.getRequestProperty("Content-Type"));
+
+        connection.setConnectTimeout(requests.getTimeout());
+        connection.setReadTimeout(requests.getTimeout());
+
+        // If we have a single non-POST request, don't try to serialize anything or HttpURLConnection will
+        // turn it into a POST.
+        boolean isPost = (connectionHttpMethod == HttpMethod.POST);
+        if (!isPost) {
+            logger.log();
+            return;
+        }
+
+        connection.setDoOutput(true);
+
+        BufferedOutputStream outputStream = new BufferedOutputStream(connection.getOutputStream());
+        try {
+            Serializer serializer = new Serializer(outputStream, logger);
+
+            if (numRequests == 1) {
+                Request request = requests.get(0);
+
+                logger.append("  Parameters:\n");
+                serializeParameters(request.parameters, serializer);
+
+                logger.append("  Attachments:\n");
+                serializeAttachments(request.parameters, serializer);
+
+                if (request.graphObject != null) {
+                    processGraphObject(request.graphObject, url.getPath(), serializer);
+                }
+            } else {
+                String batchAppID = getBatchAppId(requests);
+                if (Utility.isNullOrEmpty(batchAppID)) {
+                    throw new FacebookException("At least one request in a batch must have an open Session, or a "
+                            + "default app ID must be specified.");
+                }
+
+                serializer.writeString(BATCH_APP_ID_PARAM, batchAppID);
+
+                // We write out all the requests as JSON, remembering which file attachments they have, then
+                // write out the attachments.
+                Bundle attachments = new Bundle();
+                serializeRequestsAsJSON(serializer, requests, attachments);
+
+                logger.append("  Attachments:\n");
+                serializeAttachments(attachments, serializer);
+            }
+        } finally {
+            outputStream.close();
+        }
+
+        logger.log();
+    }
+
+    private static void processGraphObject(GraphObject graphObject, String path, KeyValueSerializer serializer)
+            throws IOException {
+        // In general, graph objects are passed by reference (ID/URL). But if this is an OG Action,
+        // we need to pass the entire values of the contents of the 'image' property, as they
+        // contain important metadata beyond just a URL. We don't have a 100% foolproof way of knowing
+        // if we are posting an OG Action, given that batched requests can have parameter substitution,
+        // but passing the OG Action type as a substituted parameter is unlikely.
+        // It looks like an OG Action if it's posted to me/namespace:action[?other=stuff].
+        boolean isOGAction = false;
+        if (path.startsWith("me/") || path.startsWith("/me/")) {
+            int colonLocation = path.indexOf(":");
+            int questionMarkLocation = path.indexOf("?");
+            isOGAction = colonLocation > 3 && (questionMarkLocation == -1 || colonLocation < questionMarkLocation);
+        }
+
+        Set<Entry<String, Object>> entries = graphObject.asMap().entrySet();
+        for (Entry<String, Object> entry : entries) {
+            boolean passByValue = isOGAction && entry.getKey().equalsIgnoreCase("image");
+            processGraphObjectProperty(entry.getKey(), entry.getValue(), serializer, passByValue);
+        }
+    }
+
+    private static void processGraphObjectProperty(String key, Object value, KeyValueSerializer serializer,
+            boolean passByValue) throws IOException {
+        Class<?> valueClass = value.getClass();
+        if (GraphObject.class.isAssignableFrom(valueClass)) {
+            value = ((GraphObject) value).getInnerJSONObject();
+            valueClass = value.getClass();
+        } else if (GraphObjectList.class.isAssignableFrom(valueClass)) {
+            value = ((GraphObjectList<?>) value).getInnerJSONArray();
+            valueClass = value.getClass();
+        }
+
+        if (JSONObject.class.isAssignableFrom(valueClass)) {
+            JSONObject jsonObject = (JSONObject) value;
+            if (passByValue) {
+                // We need to pass all properties of this object in key[propertyName] format.
+                @SuppressWarnings("unchecked")
+                Iterator<String> keys = jsonObject.keys();
+                while (keys.hasNext()) {
+                    String propertyName = keys.next();
+                    String subKey = String.format("%s[%s]", key, propertyName);
+                    processGraphObjectProperty(subKey, jsonObject.opt(propertyName), serializer, passByValue);
+                }
+            } else {
+                // Normal case is passing objects by reference, so just pass the ID or URL, if any, as the value
+                // for "key"
+                if (jsonObject.has("id")) {
+                    processGraphObjectProperty(key, jsonObject.optString("id"), serializer, passByValue);
+                } else if (jsonObject.has("url")) {
+                    processGraphObjectProperty(key, jsonObject.optString("url"), serializer, passByValue);
+                }
+            }
+        } else if (JSONArray.class.isAssignableFrom(valueClass)) {
+            JSONArray jsonArray = (JSONArray) value;
+            int length = jsonArray.length();
+            for (int i = 0; i < length; ++i) {
+                String subKey = String.format("%s[%d]", key, i);
+                processGraphObjectProperty(subKey, jsonArray.opt(i), serializer, passByValue);
+            }
+        } else if (String.class.isAssignableFrom(valueClass) ||
+                Number.class.isAssignableFrom(valueClass) ||
+                Boolean.class.isAssignableFrom(valueClass)) {
+            serializer.writeString(key, value.toString());
+        } else if (Date.class.isAssignableFrom(valueClass)) {
+            Date date = (Date) value;
+            // The "Events Timezone" platform migration affects what date/time formats Facebook accepts and returns.
+            // Apps created after 8/1/12 (or apps that have explicitly enabled the migration) should send/receive
+            // dates in ISO-8601 format. Pre-migration apps can send as Unix timestamps. Since the future is ISO-8601,
+            // that is what we support here. Apps that need pre-migration behavior can explicitly send these as
+            // integer timestamps rather than Dates.
+            final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat(ISO_8601_FORMAT_STRING, Locale.US);
+            serializer.writeString(key, iso8601DateFormat.format(date));
+        }
+    }
+
+    private static void serializeParameters(Bundle bundle, Serializer serializer) throws IOException {
+        Set<String> keys = bundle.keySet();
+
+        for (String key : keys) {
+            Object value = bundle.get(key);
+            if (isSupportedParameterType(value)) {
+                serializer.writeObject(key, value);
+            }
+        }
+    }
+
+    private static void serializeAttachments(Bundle bundle, Serializer serializer) throws IOException {
+        Set<String> keys = bundle.keySet();
+
+        for (String key : keys) {
+            Object value = bundle.get(key);
+            if (isSupportedAttachmentType(value)) {
+                serializer.writeObject(key, value);
+            }
+        }
+    }
+
+    private static void serializeRequestsAsJSON(Serializer serializer, Collection<Request> requests, Bundle attachments)
+            throws JSONException, IOException {
+        JSONArray batch = new JSONArray();
+        for (Request request : requests) {
+            request.serializeToBatch(batch, attachments);
+        }
+
+        String batchAsString = batch.toString();
+        serializer.writeString(BATCH_PARAM, batchAsString);
+    }
+
+    private static String getMimeContentType() {
+        return String.format("multipart/form-data; boundary=%s", MIME_BOUNDARY);
+    }
+
+    private static volatile String userAgent;
+
+    private static String getUserAgent() {
+        if (userAgent == null) {
+            userAgent = String.format("%s.%s", USER_AGENT_BASE, FacebookSdkVersion.BUILD);
+        }
+
+        return userAgent;
+    }
+
+    private static String getBatchAppId(RequestBatch batch) {
+        if (!Utility.isNullOrEmpty(batch.getBatchApplicationId())) {
+            return batch.getBatchApplicationId();
+        }
+
+        for (Request request : batch) {
+            Session session = request.session;
+            if (session != null) {
+                return session.getApplicationId();
+            }
+        }
+        return Request.defaultBatchApplicationId;
+    }
+
+    private static <T extends GraphObject> List<T> typedListFromResponse(Response response, Class<T> clazz) {
+        GraphMultiResult multiResult = response.getGraphObjectAs(GraphMultiResult.class);
+        if (multiResult == null) {
+            return null;
+        }
+
+        GraphObjectList<GraphObject> data = multiResult.getData();
+        if (data == null) {
+            return null;
+        }
+
+        return data.castToListOf(clazz);
+    }
+
+    private static boolean isSupportedAttachmentType(Object value) {
+        return value instanceof Bitmap || value instanceof byte[] || value instanceof ParcelFileDescriptor;
+    }
+
+    private static boolean isSupportedParameterType(Object value) {
+        return value instanceof String || value instanceof Boolean || value instanceof Number ||
+                value instanceof Date;
+    }
+
+    private static String parameterToString(Object value) {
+        if (value instanceof String) {
+            return (String) value;
+        } else if (value instanceof Boolean || value instanceof Number) {
+            return value.toString();
+        } else if (value instanceof Date) {
+            final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat(ISO_8601_FORMAT_STRING, Locale.US);
+            return iso8601DateFormat.format(value);
+        }
+        throw new IllegalArgumentException("Unsupported parameter type.");
+    }
+
+    private interface KeyValueSerializer {
+        void writeString(String key, String value) throws IOException;
+    }
+
+    private static class Serializer implements KeyValueSerializer {
+        private final BufferedOutputStream outputStream;
+        private final Logger logger;
+        private boolean firstWrite = true;
+
+        public Serializer(BufferedOutputStream outputStream, Logger logger) {
+            this.outputStream = outputStream;
+            this.logger = logger;
+        }
+
+        public void writeObject(String key, Object value) throws IOException {
+            if (isSupportedParameterType(value)) {
+                writeString(key, parameterToString(value));
+            } else if (value instanceof Bitmap) {
+                writeBitmap(key, (Bitmap) value);
+            } else if (value instanceof byte[]) {
+                writeBytes(key, (byte[]) value);
+            } else if (value instanceof ParcelFileDescriptor) {
+                writeFile(key, (ParcelFileDescriptor) value);
+            } else {
+                throw new IllegalArgumentException("value is not a supported type: String, Bitmap, byte[]");
+            }
+        }
+
+        public void writeString(String key, String value) throws IOException {
+            writeContentDisposition(key, null, null);
+            writeLine("%s", value);
+            writeRecordBoundary();
+            if (logger != null) {
+                logger.appendKeyValue("    " + key, value);
+            }
+        }
+
+        public void writeBitmap(String key, Bitmap bitmap) throws IOException {
+            writeContentDisposition(key, key, "image/png");
+            // Note: quality parameter is ignored for PNG
+            bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream);
+            writeLine("");
+            writeRecordBoundary();
+            logger.appendKeyValue("    " + key, "<Image>");
+        }
+
+        public void writeBytes(String key, byte[] bytes) throws IOException {
+            writeContentDisposition(key, key, "content/unknown");
+            this.outputStream.write(bytes);
+            writeLine("");
+            writeRecordBoundary();
+            logger.appendKeyValue("    " + key, String.format("<Data: %d>", bytes.length));
+        }
+
+        public void writeFile(String key, ParcelFileDescriptor descriptor) throws IOException {
+            writeContentDisposition(key, key, "content/unknown");
+
+            ParcelFileDescriptor.AutoCloseInputStream inputStream = null;
+            BufferedInputStream bufferedInputStream = null;
+            int totalBytes = 0;
+            try {
+                inputStream = new ParcelFileDescriptor.AutoCloseInputStream(descriptor);
+                bufferedInputStream = new BufferedInputStream(inputStream);
+
+                byte[] buffer = new byte[8192];
+                int bytesRead;
+                while ((bytesRead = bufferedInputStream.read(buffer)) != -1) {
+                    this.outputStream.write(buffer, 0, bytesRead);
+                    totalBytes += bytesRead;
+                }
+            } finally {
+                if (bufferedInputStream != null) {
+                    bufferedInputStream.close();
+                }
+                if (inputStream != null) {
+                    inputStream.close();
+                }
+            }
+            writeLine("");
+            writeRecordBoundary();
+            logger.appendKeyValue("    " + key, String.format("<Data: %d>", totalBytes));
+        }
+
+        public void writeRecordBoundary() throws IOException {
+            writeLine("--%s", MIME_BOUNDARY);
+        }
+
+        public void writeContentDisposition(String name, String filename, String contentType) throws IOException {
+            write("Content-Disposition: form-data; name=\"%s\"", name);
+            if (filename != null) {
+                write("; filename=\"%s\"", filename);
+            }
+            writeLine(""); // newline after Content-Disposition
+            if (contentType != null) {
+                writeLine("%s: %s", CONTENT_TYPE_HEADER, contentType);
+            }
+            writeLine(""); // blank line before content
+        }
+
+        public void write(String format, Object... args) throws IOException {
+            if (firstWrite) {
+                // Prepend all of our output with a boundary string.
+                this.outputStream.write("--".getBytes());
+                this.outputStream.write(MIME_BOUNDARY.getBytes());
+                this.outputStream.write("\r\n".getBytes());
+                firstWrite = false;
+            }
+            this.outputStream.write(String.format(format, args).getBytes());
+        }
+
+        public void writeLine(String format, Object... args) throws IOException {
+            write(format, args);
+            write("\r\n");
+        }
+
+    }
+
+    /**
+     * Specifies the interface that consumers of the Request class can implement in order to be notified when a
+     * particular request completes, either successfully or with an error.
+     */
+    public interface Callback {
+        /**
+         * The method that will be called when a request completes.
+         *
+         * @param response
+         *            the Response of this request, which may include error information if the request was unsuccessful
+         */
+        void onCompleted(Response response);
+    }
+
+    /**
+     * Specifies the interface that consumers of
+     * {@link Request#executeMeRequestAsync(Session, com.facebook.Request.GraphUserCallback)}
+     * can use to be notified when the request completes, either successfully or with an error.
+     */
+    public interface GraphUserCallback {
+        /**
+         * The method that will be called when the request completes.
+         *
+         * @param user     the GraphObject representing the returned user, or null
+         * @param response the Response of this request, which may include error information if the request was unsuccessful
+         */
+        void onCompleted(GraphUser user, Response response);
+    }
+
+    /**
+     * Specifies the interface that consumers of
+     * {@link Request#executeMyFriendsRequestAsync(Session, com.facebook.Request.GraphUserListCallback)}
+     * can use to be notified when the request completes, either successfully or with an error.
+     */
+    public interface GraphUserListCallback {
+        /**
+         * The method that will be called when the request completes.
+         *
+         * @param users    the list of GraphObjects representing the returned friends, or null
+         * @param response the Response of this request, which may include error information if the request was unsuccessful
+         */
+        void onCompleted(List<GraphUser> users, Response response);
+    }
+
+    /**
+     * Specifies the interface that consumers of
+     * {@link Request#executePlacesSearchRequestAsync(Session, android.location.Location, int, int, String, com.facebook.Request.GraphPlaceListCallback)}
+     * can use to be notified when the request completes, either successfully or with an error.
+     */
+    public interface GraphPlaceListCallback {
+        /**
+         * The method that will be called when the request completes.
+         *
+         * @param places   the list of GraphObjects representing the returned places, or null
+         * @param response the Response of this request, which may include error information if the request was unsuccessful
+         */
+        void onCompleted(List<GraphPlace> places, Response response);
+    }
+}
diff --git a/facebook/src/com/facebook/RequestAsyncTask.java b/facebook/src/com/facebook/RequestAsyncTask.java
new file mode 100644
index 000000000..359836db0
--- /dev/null
+++ b/facebook/src/com/facebook/RequestAsyncTask.java
@@ -0,0 +1,189 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.annotation.TargetApi;
+import android.os.AsyncTask;
+import android.os.Handler;
+import android.util.Log;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.net.HttpURLConnection;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.Executor;
+
+/**
+ * Defines an AsyncTask suitable for executing a Request in the background. May be subclassed
+ * by applications having unique threading model needs.
+ */
+@TargetApi(3)
+public class RequestAsyncTask extends AsyncTask<Void, Void, List<Response>> {
+    private static final String TAG = RequestAsyncTask.class.getCanonicalName();
+    private static Method executeOnExecutorMethod;
+
+    private final HttpURLConnection connection;
+    private final RequestBatch requests;
+
+    private Exception exception;
+
+    static {
+        for (Method method : AsyncTask.class.getMethods()) {
+            if ("executeOnExecutor".equals(method.getName())) {
+                Class<?>[] parameters = method.getParameterTypes();
+                if ((parameters.length == 2) && (parameters[0] == Executor.class) && parameters[1].isArray()) {
+                    executeOnExecutorMethod = method;
+                    break;
+                }
+            }
+        }
+    }
+
+    /**
+     * Constructor. Serialization of the requests will be done in the background, so any serialization-
+     * related errors will be returned via the Response.getException() method.
+     *
+     * @param requests the requests to execute
+     */
+    public RequestAsyncTask(Request... requests) {
+        this(null, new RequestBatch(requests));
+    }
+
+    /**
+     * Constructor. Serialization of the requests will be done in the background, so any serialization-
+     * related errors will be returned via the Response.getException() method.
+     *
+     * @param requests the requests to execute
+     */
+    public RequestAsyncTask(Collection<Request> requests) {
+        this(null, new RequestBatch(requests));
+    }
+
+    /**
+     * Constructor. Serialization of the requests will be done in the background, so any serialization-
+     * related errors will be returned via the Response.getException() method.
+     *
+     * @param requests the requests to execute
+     */
+    public RequestAsyncTask(RequestBatch requests) {
+        this(null, requests);
+    }
+
+    /**
+     * Constructor that allows specification of an HTTP connection to use for executing
+     * the requests. No validation is done that the contents of the connection actually
+     * reflect the serialized requests, so it is the caller's responsibility to ensure
+     * that it will correctly generate the desired responses.
+     *
+     * @param connection the HTTP connection to use to execute the requests
+     * @param requests   the requests to execute
+     */
+    public RequestAsyncTask(HttpURLConnection connection, Request... requests) {
+        this(connection, new RequestBatch(requests));
+    }
+
+    /**
+     * Constructor that allows specification of an HTTP connection to use for executing
+     * the requests. No validation is done that the contents of the connection actually
+     * reflect the serialized requests, so it is the caller's responsibility to ensure
+     * that it will correctly generate the desired responses.
+     *
+     * @param connection the HTTP connection to use to execute the requests
+     * @param requests   the requests to execute
+     */
+    public RequestAsyncTask(HttpURLConnection connection, Collection<Request> requests) {
+        this(connection, new RequestBatch(requests));
+    }
+
+    /**
+     * Constructor that allows specification of an HTTP connection to use for executing
+     * the requests. No validation is done that the contents of the connection actually
+     * reflect the serialized requests, so it is the caller's responsibility to ensure
+     * that it will correctly generate the desired responses.
+     *
+     * @param connection the HTTP connection to use to execute the requests
+     * @param requests   the requests to execute
+     */
+    public RequestAsyncTask(HttpURLConnection connection, RequestBatch requests) {
+        this.requests = requests;
+        this.connection = connection;
+    }
+
+    protected final Exception getException() {
+        return exception;
+    }
+
+    protected final RequestBatch getRequests() {
+        return requests;
+    }
+
+    @Override
+    public String toString() {
+        return new StringBuilder().append("{RequestAsyncTask: ").append(" connection: ").append(connection)
+                .append(", requests: ").append(requests).append("}").toString();
+    }
+
+    @Override
+    protected void onPreExecute() {
+        super.onPreExecute();
+
+        if (requests.getCallbackHandler() == null) {
+            // We want any callbacks to go to a handler on this thread unless a handler has already been specified.
+            requests.setCallbackHandler(new Handler());
+        }
+    }
+
+    @Override
+    protected void onPostExecute(List<Response> result) {
+        super.onPostExecute(result);
+
+        if (exception != null) {
+            Log.d(TAG, String.format("onPostExecute: exception encountered during request: %s", exception.getMessage()));
+        }
+    }
+
+    @Override
+    protected List<Response> doInBackground(Void... params) {
+        try {
+            if (connection == null) {
+                return requests.executeAndWait();
+            } else {
+                return Request.executeConnectionAndWait(connection, requests);
+            }
+        } catch (Exception e) {
+            exception = e;
+            return null;
+        }
+    }
+
+    RequestAsyncTask executeOnSettingsExecutor() {
+        try {
+            if (executeOnExecutorMethod != null) {
+                executeOnExecutorMethod.invoke(this, Settings.getExecutor(), null);
+                return this;
+            }
+        } catch (InvocationTargetException e) {
+            // fall-through
+        } catch (IllegalAccessException e) {
+            // fall-through
+        }
+
+        this.execute();
+        return this;
+    }
+}
diff --git a/facebook/src/com/facebook/RequestBatch.java b/facebook/src/com/facebook/RequestBatch.java
new file mode 100644
index 000000000..de3f5517a
--- /dev/null
+++ b/facebook/src/com/facebook/RequestBatch.java
@@ -0,0 +1,227 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.os.Handler;
+
+import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * RequestBatch contains a list of Request objects that can be sent to Facebook in a single round-trip.
+ */
+public class RequestBatch extends AbstractList<Request> {
+    private static AtomicInteger idGenerator = new AtomicInteger();
+
+    private Handler callbackHandler;
+    private List<Request> requests = new ArrayList<Request>();
+    private int timeoutInMilliseconds = 0;
+    private final String id = Integer.valueOf(idGenerator.incrementAndGet()).toString();
+    private List<Callback> callbacks = new ArrayList<Callback>();
+    private String batchApplicationId;
+
+    /**
+     * Constructor. Creates an empty batch.
+     */
+    public RequestBatch() {
+        this.requests = new ArrayList<Request>();
+    }
+
+    /**
+     * Constructor.
+     * @param requests the requests to add to the batch
+     */
+    public RequestBatch(Collection<Request> requests) {
+        this.requests = new ArrayList<Request>(requests);
+    }
+
+    /**
+     * Constructor.
+     * @param requests the requests to add to the batch
+     */
+    public RequestBatch(Request... requests) {
+        this.requests = Arrays.asList(requests);
+    }
+
+    /**
+     * Constructor.
+     * @param requests the requests to add to the batch
+     */
+    public RequestBatch(RequestBatch requests) {
+        this.requests = new ArrayList<Request>(requests);
+        this.callbackHandler = requests.callbackHandler;
+        this.timeoutInMilliseconds = requests.timeoutInMilliseconds;
+        this.callbacks = new ArrayList<Callback>(requests.callbacks);
+    }
+
+    /**
+     * Gets the timeout to wait for responses from the server before a timeout error occurs.
+     * @return the timeout, in milliseconds; 0 (the default) means do not timeout
+     */
+    public int getTimeout() {
+        return timeoutInMilliseconds;
+    }
+
+    /**
+     * Sets the timeout to wait for responses from the server before a timeout error occurs.
+     * @param timeoutInMilliseconds the timeout, in milliseconds; 0 means do not timeout
+     */
+    public void setTimeout(int timeoutInMilliseconds) {
+        if (timeoutInMilliseconds < 0) {
+            throw new IllegalArgumentException("Argument timeoutInMilliseconds must be >= 0.");
+        }
+        this.timeoutInMilliseconds = timeoutInMilliseconds;
+    }
+
+    /**
+     * Adds a batch-level callback which will be called when the entire batch has finished executing.
+     *
+     * @param callback the callback
+     */
+    public void addCallback(Callback callback) {
+        if (!callbacks.contains(callback)) {
+            callbacks.add(callback);
+        }
+    }
+
+    /**
+     * Removes a batch-level callback.
+     *
+     * @param callback the callback
+     */
+    public void removeCallback(Callback callback) {
+        callbacks.remove(callback);
+    }
+
+    @Override
+    public final boolean add(Request request) {
+        return requests.add(request);
+    }
+
+    @Override
+    public final void add(int location, Request request) {
+        requests.add(location, request);
+    }
+
+    @Override
+    public final void clear() {
+        requests.clear();
+    }
+
+    @Override
+    public final Request get(int i) {
+        return requests.get(i);
+    }
+
+    @Override
+    public final Request remove(int location) {
+        return requests.remove(location);
+    }
+
+    @Override
+    public final Request set(int location, Request request) {
+        return requests.set(location, request);
+    }
+
+    @Override
+    public final int size() {
+        return requests.size();
+    }
+
+    final String getId() {
+        return id;
+    }
+
+    final Handler getCallbackHandler() {
+        return callbackHandler;
+    }
+
+    final void setCallbackHandler(Handler callbackHandler) {
+        this.callbackHandler = callbackHandler;
+    }
+
+    final List<Request> getRequests() {
+        return requests;
+    }
+
+    final List<Callback> getCallbacks() {
+        return callbacks;
+    }
+
+    final String getBatchApplicationId() {
+        return batchApplicationId;
+    }
+
+    final void setBatchApplicationId(String batchApplicationId) {
+        this.batchApplicationId = batchApplicationId;
+    }
+
+    /**
+     * Executes this batch on the current thread and returns the responses.
+     * <p/>
+     * This should only be used if you have transitioned off the UI thread.
+     *
+     * @return a list of Response objects representing the results of the requests; responses are returned in the same
+     *         order as the requests were specified.
+     *
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     * @throws IllegalArgumentException if the passed in RequestBatch is empty
+     * @throws NullPointerException if the passed in RequestBatch or any of its contents are null
+     */
+    public final List<Response> executeAndWait() {
+        return executeAndWaitImpl();
+    }
+
+    /**
+     * Executes this batch asynchronously. This function will return immediately, and the batch will
+     * be processed on a separate thread. In order to process results of a request, or determine
+     * whether a request succeeded or failed, a callback must be specified (see
+     * {@link Request#setCallback(com.facebook.Request.Callback)})
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @return a RequestAsyncTask that is executing the request
+     *
+     * @throws IllegalArgumentException if this batch is empty
+     * @throws NullPointerException if any of the contents of this batch are null
+     */
+    public final RequestAsyncTask executeAsync() {
+        return executeAsyncImpl();
+    }
+
+    /**
+     * Specifies the interface that consumers of the RequestBatch class can implement in order to be notified when the
+     * entire batch completes execution. It will be called after all per-Request callbacks are called.
+     */
+    public interface Callback {
+        /**
+         * The method that will be called when a batch completes.
+         *
+         * @param batch     the RequestBatch containing the Requests which were executed
+         */
+        void onBatchCompleted(RequestBatch batch);
+    }
+
+    List<Response> executeAndWaitImpl() {
+        return Request.executeBatchAndWait(this);
+    }
+
+    RequestAsyncTask executeAsyncImpl() {
+        return Request.executeBatchAsync(this);
+    }
+}
diff --git a/facebook/src/com/facebook/Response.java b/facebook/src/com/facebook/Response.java
new file mode 100644
index 000000000..dd13cf592
--- /dev/null
+++ b/facebook/src/com/facebook/Response.java
@@ -0,0 +1,461 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.Context;
+import com.facebook.internal.*;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphObjectList;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.json.JSONTokener;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Encapsulates the response, successful or otherwise, of a call to the Facebook platform.
+ */
+public class Response {
+    private final HttpURLConnection connection;
+    private final GraphObject graphObject;
+    private final GraphObjectList<GraphObject> graphObjectList;
+    private final boolean isFromCache;
+    private final FacebookRequestError error;
+    private final Request request;
+
+    /**
+     * Property name of non-JSON results in the GraphObject. Certain calls to Facebook result in a non-JSON response
+     * (e.g., the string literal "true" or "false"). To present a consistent way of accessing results, these are
+     * represented as a GraphObject with a single string property with this name.
+     */
+    public static final String NON_JSON_RESPONSE_PROPERTY = "FACEBOOK_NON_JSON_RESULT";
+
+    private static final int INVALID_SESSION_FACEBOOK_ERROR_CODE = 190;
+
+    private static final String CODE_KEY = "code";
+    private static final String BODY_KEY = "body";
+
+    private static final String RESPONSE_LOG_TAG = "Response";
+
+    private static final String RESPONSE_CACHE_TAG = "ResponseCache";
+    private static FileLruCache responseCache;
+
+    Response(Request request, HttpURLConnection connection, GraphObject graphObject, boolean isFromCache) {
+        this.request = request;
+        this.connection = connection;
+        this.graphObject = graphObject;
+        this.graphObjectList = null;
+        this.isFromCache = isFromCache;
+        this.error = null;
+    }
+
+    Response(Request request, HttpURLConnection connection, GraphObjectList<GraphObject> graphObjects,
+            boolean isFromCache) {
+        this.request = request;
+        this.connection = connection;
+        this.graphObject = null;
+        this.graphObjectList = graphObjects;
+        this.isFromCache = isFromCache;
+        this.error = null;
+    }
+
+    Response(Request request, HttpURLConnection connection, FacebookRequestError error) {
+        this.request = request;
+        this.connection = connection;
+        this.graphObject = null;
+        this.graphObjectList = null;
+        this.isFromCache = false;
+        this.error = error;
+    }
+
+    /**
+     * Returns information about any errors that may have occurred during the request.
+     *
+     * @return the error from the server, or null if there was no server error
+     */
+    public final FacebookRequestError getError() {
+        return error;
+    }
+
+    /**
+     * The single graph object returned for this request, if any.
+     *
+     * @return the graph object returned, or null if none was returned (or if the result was a list)
+     */
+    public final GraphObject getGraphObject() {
+        return graphObject;
+    }
+
+    /**
+     * The single graph object returned for this request, if any, cast into a particular type of GraphObject.
+     *
+     * @param graphObjectClass the GraphObject-derived interface to cast the graph object into
+     * @return the graph object returned, or null if none was returned (or if the result was a list)
+     * @throws FacebookException If the passed in Class is not a valid GraphObject interface
+     */
+    public final <T extends GraphObject> T getGraphObjectAs(Class<T> graphObjectClass) {
+        if (graphObject == null) {
+            return null;
+        }
+        if (graphObjectClass == null) {
+            throw new NullPointerException("Must pass in a valid interface that extends GraphObject");
+        }
+        return graphObject.cast(graphObjectClass);
+    }
+
+    /**
+     * The list of graph objects returned for this request, if any.
+     *
+     * @return the list of graph objects returned, or null if none was returned (or if the result was not a list)
+     */
+    public final GraphObjectList<GraphObject> getGraphObjectList() {
+        return graphObjectList;
+    }
+
+    /**
+     * The list of graph objects returned for this request, if any, cast into a particular type of GraphObject.
+     *
+     * @param graphObjectClass the GraphObject-derived interface to cast the graph objects into
+     * @return the list of graph objects returned, or null if none was returned (or if the result was not a list)
+     * @throws FacebookException If the passed in Class is not a valid GraphObject interface
+     */
+    public final <T extends GraphObject> GraphObjectList<T> getGraphObjectListAs(Class<T> graphObjectClass) {
+        if (graphObjectList == null) {
+            return null;
+        }
+        return graphObjectList.castToListOf(graphObjectClass);
+    }
+
+    /**
+     * Returns the HttpURLConnection that this response was generated from. If the response was retrieved
+     * from the cache, this will be null.
+     *
+     * @return the connection, or null
+     */
+    public final HttpURLConnection getConnection() {
+        return connection;
+    }
+
+    /**
+     * Returns the request that this response is for.
+     *
+     * @return the request that this response is for
+     */
+    public Request getRequest() {
+        return request;
+    }
+
+    /**
+     * Indicates whether paging is being done forward or backward.
+     */
+    public enum PagingDirection {
+        /**
+         * Indicates that paging is being performed in the forward direction.
+         */
+        NEXT,
+        /**
+         * Indicates that paging is being performed in the backward direction.
+         */
+        PREVIOUS
+    }
+
+    /**
+     * If a Response contains results that contain paging information, returns a new
+     * Request that will retrieve the next page of results, in whichever direction
+     * is desired. If no paging information is available, returns null.
+     *
+     * @param direction enum indicating whether to page forward or backward
+     * @return a Request that will retrieve the next page of results in the desired
+     *         direction, or null if no paging information is available
+     */
+    public Request getRequestForPagedResults(PagingDirection direction) {
+        String link = null;
+        if (graphObject != null) {
+            PagedResults pagedResults = graphObject.cast(PagedResults.class);
+            PagingInfo pagingInfo = pagedResults.getPaging();
+            if (pagingInfo != null) {
+                if (direction == PagingDirection.NEXT) {
+                    link = pagingInfo.getNext();
+                } else {
+                    link = pagingInfo.getPrevious();
+                }
+            }
+        }
+        if (Utility.isNullOrEmpty(link)) {
+            return null;
+        }
+
+        if (link != null && link.equals(request.getUrlForSingleRequest())) {
+            // We got the same "next" link as we just tried to retrieve. This could happen if cached
+            // data is invalid. All we can do in this case is pretend we have finished.
+            return null;
+        }
+
+        Request pagingRequest;
+        try {
+            pagingRequest = new Request(request.getSession(), new URL(link));
+        } catch (MalformedURLException e) {
+            return null;
+        }
+
+        return pagingRequest;
+    }
+
+    /**
+     * Provides a debugging string for this response.
+     */
+    @Override
+    public String toString() {
+        String responseCode;
+        try {
+            responseCode = String.format("%d", (connection != null) ? connection.getResponseCode() : 200);
+        } catch (IOException e) {
+            responseCode = "unknown";
+        }
+
+        return new StringBuilder().append("{Response: ").append(" responseCode: ").append(responseCode)
+                .append(", graphObject: ").append(graphObject).append(", error: ").append(error)
+                .append(", isFromCache:").append(isFromCache).append("}")
+                .toString();
+    }
+
+    /**
+     * Indicates whether the response was retrieved from a local cache or from the server.
+     *
+     * @return true if the response was cached locally, false if it was retrieved from the server
+     */
+    public final boolean getIsFromCache() {
+        return isFromCache;
+    }
+
+    static FileLruCache getResponseCache() {
+        if (responseCache == null) {
+            Context applicationContext = Session.getStaticContext();
+            if (applicationContext != null) {
+                responseCache = new FileLruCache(applicationContext, RESPONSE_CACHE_TAG, new FileLruCache.Limits());
+            }
+        }
+
+        return responseCache;
+    }
+
+    @SuppressWarnings("resource")
+    static List<Response> fromHttpConnection(HttpURLConnection connection, RequestBatch requests) {
+        InputStream stream = null;
+
+        FileLruCache cache = null;
+        String cacheKey = null;
+        if (requests instanceof CacheableRequestBatch) {
+            CacheableRequestBatch cacheableRequestBatch = (CacheableRequestBatch) requests;
+            cache = getResponseCache();
+            cacheKey = cacheableRequestBatch.getCacheKeyOverride();
+            if (Utility.isNullOrEmpty(cacheKey)) {
+                if (requests.size() == 1) {
+                    // Default for single requests is to use the URL.
+                    cacheKey = requests.get(0).getUrlForSingleRequest();
+                } else {
+                    Logger.log(LoggingBehavior.REQUESTS, RESPONSE_CACHE_TAG,
+                            "Not using cache for cacheable request because no key was specified");
+                }
+            }
+
+            // Try loading from cache.  If that fails, load from the network.
+            if (!cacheableRequestBatch.getForceRoundTrip() && cache != null && !Utility.isNullOrEmpty(cacheKey)) {
+                try {
+                    stream = cache.get(cacheKey);
+                    if (stream != null) {
+                        return createResponsesFromStream(stream, null, requests, true);
+                    }
+                } catch (FacebookException exception) { // retry via roundtrip below
+                } catch (JSONException exception) {
+                } catch (IOException exception) {
+                } finally {
+                    Utility.closeQuietly(stream);
+                }
+            }
+        }
+
+        // Load from the network, and cache the result if not an error.
+        try {
+            if (connection.getResponseCode() >= 400) {
+                stream = connection.getErrorStream();
+            } else {
+                stream = connection.getInputStream();
+                if ((cache != null) && (cacheKey != null) && (stream != null)) {
+                    InputStream interceptStream = cache.interceptAndPut(cacheKey, stream);
+                    if (interceptStream != null) {
+                        stream = interceptStream;
+                    }
+                }
+            }
+
+            return createResponsesFromStream(stream, connection, requests, false);
+        } catch (FacebookException facebookException) {
+            Logger.log(LoggingBehavior.REQUESTS, RESPONSE_LOG_TAG, "Response <Error>: %s", facebookException);
+            return constructErrorResponses(requests, connection, facebookException);
+        } catch (JSONException exception) {
+            Logger.log(LoggingBehavior.REQUESTS, RESPONSE_LOG_TAG, "Response <Error>: %s", exception);
+            return constructErrorResponses(requests, connection, new FacebookException(exception));
+        } catch (IOException exception) {
+            Logger.log(LoggingBehavior.REQUESTS, RESPONSE_LOG_TAG, "Response <Error>: %s", exception);
+            return constructErrorResponses(requests, connection, new FacebookException(exception));
+        } finally {
+            Utility.closeQuietly(stream);
+        }
+    }
+
+    static List<Response> createResponsesFromStream(InputStream stream, HttpURLConnection connection,
+            RequestBatch requests, boolean isFromCache) throws FacebookException, JSONException, IOException {
+
+        String responseString = Utility.readStreamToString(stream);
+        Logger.log(LoggingBehavior.INCLUDE_RAW_RESPONSES, RESPONSE_LOG_TAG,
+                "Response (raw)\n  Size: %d\n  Response:\n%s\n", responseString.length(),
+                responseString);
+
+        JSONTokener tokener = new JSONTokener(responseString);
+        Object resultObject = tokener.nextValue();
+
+        List<Response> responses = createResponsesFromObject(connection, requests, resultObject, isFromCache);
+        Logger.log(LoggingBehavior.REQUESTS, RESPONSE_LOG_TAG, "Response\n  Id: %s\n  Size: %d\n  Responses:\n%s\n",
+                requests.getId(), responseString.length(), responses);
+
+        return responses;
+    }
+
+    private static List<Response> createResponsesFromObject(HttpURLConnection connection, List<Request> requests,
+            Object object, boolean isFromCache) throws FacebookException, JSONException {
+        assert (connection != null) || isFromCache;
+
+        int numRequests = requests.size();
+        List<Response> responses = new ArrayList<Response>(numRequests);
+        Object originalResult = object;
+
+        if (numRequests == 1) {
+            Request request = requests.get(0);
+            try {
+                // Single request case -- the entire response is the result, wrap it as "body" so we can handle it
+                // the same as we do in the batched case. We get the response code from the actual HTTP response,
+                // as opposed to the batched case where it is returned as a "code" element.
+                JSONObject jsonObject = new JSONObject();
+                jsonObject.put(BODY_KEY, object);
+                int responseCode = (connection != null) ? connection.getResponseCode() : 200;
+                jsonObject.put(CODE_KEY, responseCode);
+
+                JSONArray jsonArray = new JSONArray();
+                jsonArray.put(jsonObject);
+
+                // Pretend we got an array of 1 back.
+                object = jsonArray;
+            } catch (JSONException e) {
+                responses.add(new Response(request, connection, new FacebookRequestError(connection, e)));
+            } catch (IOException e) {
+                responses.add(new Response(request, connection, new FacebookRequestError(connection, e)));
+            }
+        }
+
+        if (!(object instanceof JSONArray) || ((JSONArray) object).length() != numRequests) {
+            FacebookException exception = new FacebookException("Unexpected number of results");
+            throw exception;
+        }
+
+        JSONArray jsonArray = (JSONArray) object;
+
+        for (int i = 0; i < jsonArray.length(); ++i) {
+            Request request = requests.get(i);
+            try {
+                Object obj = jsonArray.get(i);
+                responses.add(createResponseFromObject(request, connection, obj, isFromCache, originalResult));
+            } catch (JSONException e) {
+                responses.add(new Response(request, connection, new FacebookRequestError(connection, e)));
+            } catch (FacebookException e) {
+                responses.add(new Response(request, connection, new FacebookRequestError(connection, e)));
+            }
+        }
+
+        return responses;
+    }
+
+    private static Response createResponseFromObject(Request request, HttpURLConnection connection, Object object,
+            boolean isFromCache, Object originalResult) throws JSONException {
+        if (object instanceof JSONObject) {
+            JSONObject jsonObject = (JSONObject) object;
+
+            FacebookRequestError error =
+                    FacebookRequestError.checkResponseAndCreateError(jsonObject, originalResult, connection);
+            if (error != null) {
+                if (error.getErrorCode() == INVALID_SESSION_FACEBOOK_ERROR_CODE) {
+                    Session session = request.getSession();
+                    if (session != null) {
+                        session.closeAndClearTokenInformation();
+                    }
+                }
+                return new Response(request, connection, error);
+            }
+
+            Object body = Utility.getStringPropertyAsJSON(jsonObject, BODY_KEY, NON_JSON_RESPONSE_PROPERTY);
+
+            if (body instanceof JSONObject) {
+                GraphObject graphObject = GraphObject.Factory.create((JSONObject) body);
+                return new Response(request, connection, graphObject, isFromCache);
+            } else if (body instanceof JSONArray) {
+                GraphObjectList<GraphObject> graphObjectList = GraphObject.Factory.createList(
+                        (JSONArray) body, GraphObject.class);
+                return new Response(request, connection, graphObjectList, isFromCache);
+            }
+            // We didn't get a body we understand how to handle, so pretend we got nothing.
+            object = JSONObject.NULL;
+        }
+
+        if (object == JSONObject.NULL) {
+            return new Response(request, connection, (GraphObject)null, isFromCache);
+        } else {
+            throw new FacebookException("Got unexpected object type in response, class: "
+                    + object.getClass().getSimpleName());
+        }
+    }
+
+    static List<Response> constructErrorResponses(List<Request> requests, HttpURLConnection connection,
+            FacebookException error) {
+        int count = requests.size();
+        List<Response> responses = new ArrayList<Response>(count);
+        for (int i = 0; i < count; ++i) {
+            Response response = new Response(requests.get(i), connection, new FacebookRequestError(connection, error));
+            responses.add(response);
+        }
+        return responses;
+    }
+
+    interface PagingInfo extends GraphObject {
+        String getNext();
+
+        String getPrevious();
+    }
+
+    interface PagedResults extends GraphObject {
+        GraphObjectList<GraphObject> getData();
+
+        PagingInfo getPaging();
+    }
+
+}
diff --git a/facebook/src/com/facebook/Session.java b/facebook/src/com/facebook/Session.java
new file mode 100644
index 000000000..694ccf3fb
--- /dev/null
+++ b/facebook/src/com/facebook/Session.java
@@ -0,0 +1,1887 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.app.Activity;
+import android.content.*;
+import android.content.pm.ResolveInfo;
+import android.os.*;
+import android.support.v4.app.Fragment;
+import android.support.v4.content.LocalBroadcastManager;
+import android.util.Log;
+import com.facebook.internal.SessionAuthorizationType;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+
+import java.io.*;
+import java.lang.ref.WeakReference;
+import java.util.*;
+
+/**
+ * <p>
+ * Session is used to authenticate a user and manage the user's session with
+ * Facebook.
+ * </p>
+ * <p>
+ * Sessions must be opened before they can be used to make a Request. When a
+ * Session is created, it attempts to initialize itself from a TokenCachingStrategy.
+ * Closing the session can optionally clear this cache.  The Session lifecycle
+ * uses {@link SessionState SessionState} to indicate its state.
+ * </p>
+ * <p>
+ * Instances of Session provide state change notification via a callback
+ * interface, {@link Session.StatusCallback StatusCallback}.
+ * </p>
+ */
+public class Session implements Serializable {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * The logging tag used by Session.
+     */
+    public static final String TAG = Session.class.getCanonicalName();
+
+    /**
+     * The default activity code used for authorization.
+     *
+     * @see #openForRead(OpenRequest)
+     *      open
+     */
+    public static final int DEFAULT_AUTHORIZE_ACTIVITY_CODE = 0xface;
+
+    /**
+     * If Session authorization fails and provides a web view error code, the
+     * web view error code is stored in the Bundle returned from
+     * {@link #getAuthorizationBundle getAuthorizationBundle} under this key.
+     */
+    public static final String WEB_VIEW_ERROR_CODE_KEY = "com.facebook.sdk.WebViewErrorCode";
+
+    /**
+     * If Session authorization fails and provides a failing url, the failing
+     * url is stored in the Bundle returned from {@link #getAuthorizationBundle
+     * getAuthorizationBundle} under this key.
+     */
+    public static final String WEB_VIEW_FAILING_URL_KEY = "com.facebook.sdk.FailingUrl";
+
+    /**
+     * The action used to indicate that the active session has been set. This should
+     * be used as an action in an IntentFilter and BroadcastReceiver registered with
+     * the {@link android.support.v4.content.LocalBroadcastManager}.
+     */
+    public static final String ACTION_ACTIVE_SESSION_SET = "com.facebook.sdk.ACTIVE_SESSION_SET";
+
+    /**
+     * The action used to indicate that the active session has been set to null. This should
+     * be used as an action in an IntentFilter and BroadcastReceiver registered with
+     * the {@link android.support.v4.content.LocalBroadcastManager}.
+     */
+    public static final String ACTION_ACTIVE_SESSION_UNSET = "com.facebook.sdk.ACTIVE_SESSION_UNSET";
+
+    /**
+     * The action used to indicate that the active session has been opened. This should
+     * be used as an action in an IntentFilter and BroadcastReceiver registered with
+     * the {@link android.support.v4.content.LocalBroadcastManager}.
+     */
+    public static final String ACTION_ACTIVE_SESSION_OPENED = "com.facebook.sdk.ACTIVE_SESSION_OPENED";
+
+    /**
+     * The action used to indicate that the active session has been closed. This should
+     * be used as an action in an IntentFilter and BroadcastReceiver registered with
+     * the {@link android.support.v4.content.LocalBroadcastManager}.
+     */
+    public static final String ACTION_ACTIVE_SESSION_CLOSED = "com.facebook.sdk.ACTIVE_SESSION_CLOSED";
+
+    /**
+     * Session takes application id as a constructor parameter. If this is null,
+     * Session will attempt to load the application id from
+     * application/meta-data using this String as the key.
+     */
+    public static final String APPLICATION_ID_PROPERTY = "com.facebook.sdk.ApplicationId";
+
+    private static final Object STATIC_LOCK = new Object();
+    private static Session activeSession;
+    private static volatile Context staticContext;
+
+    // Token extension constants
+    private static final int TOKEN_EXTEND_THRESHOLD_SECONDS = 24 * 60 * 60; // 1
+    // day
+    private static final int TOKEN_EXTEND_RETRY_SECONDS = 60 * 60; // 1 hour
+
+    private static final String SESSION_BUNDLE_SAVE_KEY = "com.facebook.sdk.Session.saveSessionKey";
+    private static final String AUTH_BUNDLE_SAVE_KEY = "com.facebook.sdk.Session.authBundleKey";
+    private static final String PUBLISH_PERMISSION_PREFIX = "publish";
+    private static final String MANAGE_PERMISSION_PREFIX = "manage";
+
+    @SuppressWarnings("serial")
+    private static final Set<String> OTHER_PUBLISH_PERMISSIONS = new HashSet<String>() {{
+        add("ads_management");
+        add("create_event");
+        add("rsvp_event");
+    }};
+
+    private String applicationId;
+    private SessionState state;
+    private AccessToken tokenInfo;
+    private Date lastAttemptedTokenExtendDate = new Date(0);
+
+    private AuthorizationRequest pendingRequest;
+    private AuthorizationClient authorizationClient;
+
+    // The following are not serialized with the Session object
+    private volatile Bundle authorizationBundle;
+    private final List<StatusCallback> callbacks;
+    private Handler handler;
+    private AutoPublishAsyncTask autoPublishAsyncTask;
+    // This is the object that synchronizes access to state and tokenInfo
+    private final Object lock = new Object();
+    private TokenCachingStrategy tokenCachingStrategy;
+    private volatile TokenRefreshRequest currentTokenRefreshRequest;
+
+    /**
+     * Serialization proxy for the Session class. This is version 1 of
+     * serialization. Future serializations may differ in format. This
+     * class should not be modified. If serializations formats change,
+     * create a new class SerializationProxyVx.
+     */
+    private static class SerializationProxyV1 implements Serializable {
+        private static final long serialVersionUID = 7663436173185080063L;
+        private final String applicationId;
+        private final SessionState state;
+        private final AccessToken tokenInfo;
+        private final Date lastAttemptedTokenExtendDate;
+        private final boolean shouldAutoPublish;
+        private final AuthorizationRequest pendingRequest;
+
+        SerializationProxyV1(String applicationId, SessionState state,
+                AccessToken tokenInfo, Date lastAttemptedTokenExtendDate,
+                boolean shouldAutoPublish, AuthorizationRequest pendingRequest) {
+            this.applicationId = applicationId;
+            this.state = state;
+            this.tokenInfo = tokenInfo;
+            this.lastAttemptedTokenExtendDate = lastAttemptedTokenExtendDate;
+            this.shouldAutoPublish = shouldAutoPublish;
+            this.pendingRequest = pendingRequest;
+        }
+
+        private Object readResolve() {
+            return new Session(applicationId, state, tokenInfo,
+                    lastAttemptedTokenExtendDate, shouldAutoPublish, pendingRequest);
+        }
+    }
+
+    /**
+     * Used by version 1 of the serialization proxy, do not modify.
+     */
+    private Session(String applicationId, SessionState state,
+            AccessToken tokenInfo, Date lastAttemptedTokenExtendDate,
+            boolean shouldAutoPublish, AuthorizationRequest pendingRequest) {
+        this.applicationId = applicationId;
+        this.state = state;
+        this.tokenInfo = tokenInfo;
+        this.lastAttemptedTokenExtendDate = lastAttemptedTokenExtendDate;
+        this.pendingRequest = pendingRequest;
+        handler = new Handler(Looper.getMainLooper());
+        currentTokenRefreshRequest = null;
+        tokenCachingStrategy = null;
+        callbacks = new ArrayList<StatusCallback>();
+    }
+
+    /**
+     * Initializes a new Session with the specified context.
+     *
+     * @param currentContext The Activity or Service creating this Session.
+     */
+    public Session(Context currentContext) {
+        this(currentContext, null, null, true);
+    }
+
+    Session(Context context, String applicationId, TokenCachingStrategy tokenCachingStrategy) {
+        this(context, applicationId, tokenCachingStrategy, true);
+    }
+
+    Session(Context context, String applicationId, TokenCachingStrategy tokenCachingStrategy,
+            boolean loadTokenFromCache) {
+        // if the application ID passed in is null, try to get it from the
+        // meta-data in the manifest.
+        if ((context != null) && (applicationId == null)) {
+            applicationId = Utility.getMetadataApplicationId(context);
+        }
+
+        Validate.notNull(applicationId, "applicationId");
+
+        initializeStaticContext(context);
+
+        if (tokenCachingStrategy == null) {
+            tokenCachingStrategy = new SharedPreferencesTokenCachingStrategy(staticContext);
+        }
+
+        this.applicationId = applicationId;
+        this.tokenCachingStrategy = tokenCachingStrategy;
+        this.state = SessionState.CREATED;
+        this.pendingRequest = null;
+        this.callbacks = new ArrayList<StatusCallback>();
+        this.handler = new Handler(Looper.getMainLooper());
+
+        Bundle tokenState = loadTokenFromCache ? tokenCachingStrategy.load() : null;
+        if (TokenCachingStrategy.hasTokenInformation(tokenState)) {
+            Date cachedExpirationDate = TokenCachingStrategy
+                    .getDate(tokenState, TokenCachingStrategy.EXPIRATION_DATE_KEY);
+            Date now = new Date();
+
+            if ((cachedExpirationDate == null) || cachedExpirationDate.before(now)) {
+                // If expired or we require new permissions, clear out the
+                // current token cache.
+                tokenCachingStrategy.clear();
+                this.tokenInfo = AccessToken.createEmptyToken(Collections.<String>emptyList());
+            } else {
+                // Otherwise we have a valid token, so use it.
+                this.tokenInfo = AccessToken.createFromCache(tokenState);
+                this.state = SessionState.CREATED_TOKEN_LOADED;
+            }
+        } else {
+            this.tokenInfo = AccessToken.createEmptyToken(Collections.<String>emptyList());
+        }
+    }
+
+    /**
+     * Returns a Bundle containing data that was returned from Facebook during
+     * authorization.
+     *
+     * @return a Bundle containing data that was returned from Facebook during
+     *         authorization.
+     */
+    public final Bundle getAuthorizationBundle() {
+        synchronized (this.lock) {
+            return this.authorizationBundle;
+        }
+    }
+
+    /**
+     * Returns a boolean indicating whether the session is opened.
+     *
+     * @return a boolean indicating whether the session is opened.
+     */
+    public final boolean isOpened() {
+        synchronized (this.lock) {
+            return this.state.isOpened();
+        }
+    }
+
+    public final boolean isClosed() {
+        synchronized (this.lock) {
+            return this.state.isClosed();
+        }
+    }
+
+    /**
+     * Returns the current state of the Session.
+     * See {@link SessionState} for details.
+     *
+     * @return the current state of the Session.
+     */
+    public final SessionState getState() {
+        synchronized (this.lock) {
+            return this.state;
+        }
+    }
+
+    /**
+     * Returns the application id associated with this Session.
+     *
+     * @return the application id associated with this Session.
+     */
+    public final String getApplicationId() {
+        return this.applicationId;
+    }
+
+    /**
+     * Returns the access token String.
+     *
+     * @return the access token String, or null if there is no access token
+     */
+    public final String getAccessToken() {
+        synchronized (this.lock) {
+            return (this.tokenInfo == null) ? null : this.tokenInfo.getToken();
+        }
+    }
+
+    /**
+     * <p>
+     * Returns the Date at which the current token will expire.
+     * </p>
+     * <p>
+     * Note that Session automatically attempts to extend the lifetime of Tokens
+     * as needed when Facebook requests are made.
+     * </p>
+     *
+     * @return the Date at which the current token will expire, or null if there is no access token
+     */
+    public final Date getExpirationDate() {
+        synchronized (this.lock) {
+            return (this.tokenInfo == null) ? null : this.tokenInfo.getExpires();
+        }
+    }
+
+    /**
+     * <p>
+     * Returns the list of permissions associated with the session.
+     * </p>
+     * <p>
+     * If there is a valid token, this represents the permissions granted by
+     * that token. This can change during calls to
+     * {@link #requestNewReadPermissions}
+     * or {@link #requestNewPublishPermissions}.
+     * </p>
+     *
+     * @return the list of permissions associated with the session, or null if there is no access token
+     */
+    public final List<String> getPermissions() {
+        synchronized (this.lock) {
+            return (this.tokenInfo == null) ? null : this.tokenInfo.getPermissions();
+        }
+    }
+
+    /**
+     * <p>
+     * Logs a user in to Facebook.
+     * </p>
+     * <p>
+     * A session may not be used with {@link Request Request} and other classes
+     * in the SDK until it is open. If, prior to calling open, the session is in
+     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
+     * state, and the requested permissions are a subset of the previously authorized
+     * permissions, then the Session becomes usable immediately with no user interaction.
+     * </p>
+     * <p>
+     * The permissions associated with the openRequest passed to this method must
+     * be read permissions only (or null/empty). It is not allowed to pass publish
+     * permissions to this method and will result in an exception being thrown.
+     * </p>
+     * <p>
+     * Any open method must be called at most once, and cannot be called after the
+     * Session is closed. Calling the method at an invalid time will result in
+     * UnsuportedOperationException.
+     * </p>
+     *
+     * @param openRequest the open request, can be null only if the Session is in the
+     *                    {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED} state
+     * @throws FacebookException if any publish or manage permissions are requested
+     */
+    public final void openForRead(OpenRequest openRequest) {
+        open(openRequest, SessionAuthorizationType.READ);
+    }
+
+    /**
+     * <p>
+     * Logs a user in to Facebook.
+     * </p>
+     * <p>
+     * A session may not be used with {@link Request Request} and other classes
+     * in the SDK until it is open. If, prior to calling open, the session is in
+     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
+     * state, and the requested permissions are a subset of the previously authorized
+     * permissions, then the Session becomes usable immediately with no user interaction.
+     * </p>
+     * <p>
+     * The permissions associated with the openRequest passed to this method must
+     * be publish or manage permissions only and must be non-empty. Any read permissions
+     * will result in a warning, and may fail during server-side authorization.
+     * </p>
+     * <p>
+     * Any open method must be called at most once, and cannot be called after the
+     * Session is closed. Calling the method at an invalid time will result in
+     * UnsuportedOperationException.
+     * </p>
+     *
+     * @param openRequest the open request, can be null only if the Session is in the
+     *                    {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED} state
+     * @throws FacebookException if the passed in request is null or has no permissions set.
+     */
+    public final void openForPublish(OpenRequest openRequest) {
+        open(openRequest, SessionAuthorizationType.PUBLISH);
+    }
+
+    /**
+     * Opens a session based on an existing Facebook access token. This method should be used
+     * only in instances where an application has previously obtained an access token and wishes
+     * to import it into the Session/TokenCachingStrategy-based session-management system. An
+     * example would be an application which previously did not use the Facebook SDK for Android
+     * and implemented its own session-management scheme, but wishes to implement an upgrade path
+     * for existing users so they do not need to log in again when upgrading to a version of
+     * the app that uses the SDK.
+     * <p/>
+     * No validation is done that the token, token source, or permissions are actually valid.
+     * It is the caller's responsibility to ensure that these accurately reflect the state of
+     * the token that has been passed in, or calls to the Facebook API may fail.
+     *
+     * @param accessToken the access token obtained from Facebook
+     * @param callback    a callback that will be called when the session status changes; may be null
+     */
+    public final void open(AccessToken accessToken, StatusCallback callback) {
+        synchronized (this.lock) {
+            if (pendingRequest != null) {
+                throw new UnsupportedOperationException(
+                        "Session: an attempt was made to open a session that has a pending request.");
+            }
+
+            if (state != SessionState.CREATED && state != SessionState.CREATED_TOKEN_LOADED) {
+                throw new UnsupportedOperationException(
+                        "Session: an attempt was made to open an already opened session.");
+            }
+
+            if (callback != null) {
+                addCallback(callback);
+            }
+
+            this.tokenInfo = accessToken;
+
+            if (this.tokenCachingStrategy != null) {
+                this.tokenCachingStrategy.save(accessToken.toCacheBundle());
+            }
+
+            final SessionState oldState = state;
+            state = SessionState.OPENED;
+            this.postStateChange(oldState, state, null);
+        }
+
+        autoPublishAsync();
+    }
+
+    /**
+     * <p>
+     * Issues a request to add new read permissions to the Session.
+     * </p>
+     * <p>
+     * If successful, this will update the set of permissions on this session to
+     * match the newPermissions. If this fails, the Session remains unchanged.
+     * </p>
+     * <p>
+     * The permissions associated with the newPermissionsRequest passed to this method must
+     * be read permissions only (or null/empty). It is not allowed to pass publish
+     * permissions to this method and will result in an exception being thrown.
+     * </p>
+     *
+     * @param newPermissionsRequest the new permissions request
+     */
+    public final void requestNewReadPermissions(NewPermissionsRequest newPermissionsRequest) {
+        requestNewPermissions(newPermissionsRequest, SessionAuthorizationType.READ);
+    }
+
+    /**
+     * <p>
+     * Issues a request to add new publish or manage permissions to the Session.
+     * </p>
+     * <p>
+     * If successful, this will update the set of permissions on this session to
+     * match the newPermissions. If this fails, the Session remains unchanged.
+     * </p>
+     * <p>
+     * The permissions associated with the newPermissionsRequest passed to this method must
+     * be publish or manage permissions only and must be non-empty. Any read permissions
+     * will result in a warning, and may fail during server-side authorization.
+     * </p>
+     *
+     * @param newPermissionsRequest the new permissions request
+     */
+    public final void requestNewPublishPermissions(NewPermissionsRequest newPermissionsRequest) {
+        requestNewPermissions(newPermissionsRequest, SessionAuthorizationType.PUBLISH);
+    }
+
+    /**
+     * Provides an implementation for {@link Activity#onActivityResult
+     * onActivityResult} that updates the Session based on information returned
+     * during the authorization flow. The Activity that calls open or
+     * requestNewPermissions should forward the resulting onActivityResult call here to
+     * update the Session state based on the contents of the resultCode and
+     * data.
+     *
+     * @param currentActivity The Activity that is forwarding the onActivityResult call.
+     * @param requestCode     The requestCode parameter from the forwarded call. When this
+     *                        onActivityResult occurs as part of Facebook authorization
+     *                        flow, this value is the activityCode passed to open or
+     *                        authorize.
+     * @param resultCode      An int containing the resultCode parameter from the forwarded
+     *                        call.
+     * @param data            The Intent passed as the data parameter from the forwarded
+     *                        call.
+     * @return A boolean indicating whether the requestCode matched a pending
+     *         authorization request for this Session.
+     */
+    public final boolean onActivityResult(Activity currentActivity, int requestCode, int resultCode, Intent data) {
+        Validate.notNull(currentActivity, "currentActivity");
+
+        initializeStaticContext(currentActivity);
+
+        synchronized (lock) {
+            if (pendingRequest == null || (requestCode != pendingRequest.getRequestCode())) {
+                return false;
+            }
+        }
+
+        AccessToken newToken = null;
+        Exception exception = null;
+
+        if (data != null) {
+            AuthorizationClient.Result result = (AuthorizationClient.Result) data.getSerializableExtra(
+                    LoginActivity.RESULT_KEY);
+            if (result != null) {
+                // This came from LoginActivity.
+                handleAuthorizationResult(resultCode, result);
+                return true;
+            } else if (authorizationClient != null) {
+                // Delegate to the auth client.
+                authorizationClient.onActivityResult(requestCode, resultCode, data);
+                return true;
+            }
+        } else if (resultCode == Activity.RESULT_CANCELED) {
+            exception = new FacebookOperationCanceledException("User canceled operation.");
+        }
+
+        finishAuthOrReauth(newToken, exception);
+        return true;
+    }
+
+    /**
+     * Closes the local in-memory Session object, but does not clear the
+     * persisted token cache.
+     */
+    @SuppressWarnings("incomplete-switch")
+    public final void close() {
+        synchronized (this.lock) {
+            final SessionState oldState = this.state;
+
+            switch (this.state) {
+                case CREATED:
+                case OPENING:
+                    this.state = SessionState.CLOSED_LOGIN_FAILED;
+                    postStateChange(oldState, this.state, new FacebookException(
+                            "Log in attempt aborted."));
+                    break;
+
+                case CREATED_TOKEN_LOADED:
+                case OPENED:
+                case OPENED_TOKEN_UPDATED:
+                    this.state = SessionState.CLOSED;
+                    postStateChange(oldState, this.state, null);
+                    break;
+            }
+        }
+    }
+
+    /**
+     * Closes the local in-memory Session object and clears any persisted token
+     * cache related to the Session.
+     */
+    public final void closeAndClearTokenInformation() {
+        if (this.tokenCachingStrategy != null) {
+            this.tokenCachingStrategy.clear();
+        }
+        Utility.clearFacebookCookies(staticContext);
+        close();
+    }
+
+    /**
+     * Adds a callback that will be called when the state of this Session changes.
+     *
+     * @param callback the callback
+     */
+    public final void addCallback(StatusCallback callback) {
+        synchronized (callbacks) {
+            if (callback != null && !callbacks.contains(callback)) {
+                callbacks.add(callback);
+            }
+        }
+    }
+
+    /**
+     * Removes a StatusCallback from this Session.
+     *
+     * @param callback the callback
+     */
+    public final void removeCallback(StatusCallback callback) {
+        synchronized (callbacks) {
+            callbacks.remove(callback);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return new StringBuilder().append("{Session").append(" state:").append(this.state).append(", token:")
+                .append((this.tokenInfo == null) ? "null" : this.tokenInfo).append(", appId:")
+                .append((this.applicationId == null) ? "null" : this.applicationId).append("}").toString();
+    }
+
+    void extendTokenCompleted(Bundle bundle) {
+        synchronized (this.lock) {
+            final SessionState oldState = this.state;
+
+            switch (this.state) {
+                case OPENED:
+                    this.state = SessionState.OPENED_TOKEN_UPDATED;
+                    postStateChange(oldState, this.state, null);
+                    break;
+                case OPENED_TOKEN_UPDATED:
+                    break;
+                default:
+                    // Silently ignore attempts to refresh token if we are not open
+                    Log.d(TAG, "refreshToken ignored in state " + this.state);
+                    return;
+            }
+            this.tokenInfo = AccessToken.createFromRefresh(this.tokenInfo, bundle);
+            if (this.tokenCachingStrategy != null) {
+                this.tokenCachingStrategy.save(this.tokenInfo.toCacheBundle());
+            }
+        }
+    }
+
+    private Object writeReplace() {
+        return new SerializationProxyV1(applicationId, state, tokenInfo,
+                lastAttemptedTokenExtendDate, false, pendingRequest);
+    }
+
+    // have a readObject that throws to prevent spoofing
+    private void readObject(ObjectInputStream stream) throws InvalidObjectException {
+        throw new InvalidObjectException("Cannot readObject, serialization proxy required");
+    }
+
+    /**
+     * Save the Session object into the supplied Bundle.
+     *
+     * @param session the Session to save
+     * @param bundle  the Bundle to save the Session to
+     */
+    public static final void saveSession(Session session, Bundle bundle) {
+        if (bundle != null && session != null && !bundle.containsKey(SESSION_BUNDLE_SAVE_KEY)) {
+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+            try {
+                new ObjectOutputStream(outputStream).writeObject(session);
+            } catch (IOException e) {
+                throw new FacebookException("Unable to save session.", e);
+            }
+            bundle.putByteArray(SESSION_BUNDLE_SAVE_KEY, outputStream.toByteArray());
+            bundle.putBundle(AUTH_BUNDLE_SAVE_KEY, session.authorizationBundle);
+        }
+    }
+
+    /**
+     * Restores the saved session from a Bundle, if any. Returns the restored Session or
+     * null if it could not be restored.
+     *
+     * @param context         the Activity or Service creating the Session, must not be null
+     * @param cachingStrategy the TokenCachingStrategy to use to load and store the token. If this is
+     *                        null, a default token cachingStrategy that stores data in
+     *                        SharedPreferences will be used
+     * @param callback        the callback to notify for Session state changes, can be null
+     * @param bundle          the bundle to restore the Session from
+     * @return the restored Session, or null
+     */
+    public static final Session restoreSession(
+            Context context, TokenCachingStrategy cachingStrategy, StatusCallback callback, Bundle bundle) {
+        if (bundle == null) {
+            return null;
+        }
+        byte[] data = bundle.getByteArray(SESSION_BUNDLE_SAVE_KEY);
+        if (data != null) {
+            ByteArrayInputStream is = new ByteArrayInputStream(data);
+            try {
+                Session session = (Session) (new ObjectInputStream(is)).readObject();
+                initializeStaticContext(context);
+                if (cachingStrategy != null) {
+                    session.tokenCachingStrategy = cachingStrategy;
+                } else {
+                    session.tokenCachingStrategy = new SharedPreferencesTokenCachingStrategy(context);
+                }
+                if (callback != null) {
+                    session.addCallback(callback);
+                }
+                session.authorizationBundle = bundle.getBundle(AUTH_BUNDLE_SAVE_KEY);
+                return session;
+            } catch (ClassNotFoundException e) {
+                Log.w(TAG, "Unable to restore session", e);
+            } catch (IOException e) {
+                Log.w(TAG, "Unable to restore session.", e);
+            }
+        }
+        return null;
+    }
+
+
+    /**
+     * Returns the current active Session, or null if there is none.
+     *
+     * @return the current active Session, or null if there is none.
+     */
+    public static final Session getActiveSession() {
+        synchronized (Session.STATIC_LOCK) {
+            return Session.activeSession;
+        }
+    }
+
+    /**
+     * <p>
+     * Sets the current active Session.
+     * </p>
+     * <p>
+     * The active Session is used implicitly by predefined Request factory
+     * methods as well as optionally by UI controls in the sdk.
+     * </p>
+     * <p>
+     * It is legal to set this to null, or to a Session that is not yet open.
+     * </p>
+     *
+     * @param session A Session to use as the active Session, or null to indicate
+     *                that there is no active Session.
+     */
+    public static final void setActiveSession(Session session) {
+        synchronized (Session.STATIC_LOCK) {
+            if (session != Session.activeSession) {
+                Session oldSession = Session.activeSession;
+
+                if (oldSession != null) {
+                    oldSession.close();
+                }
+
+                Session.activeSession = session;
+
+                if (oldSession != null) {
+                    postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_UNSET);
+                }
+
+                if (session != null) {
+                    postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_SET);
+
+                    if (session.isOpened()) {
+                        postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Create a new Session, and if a token cache is available, open the
+     * Session and make it active without any user interaction.
+     *
+     * @param context The Context creating this session
+     * @return The new session or null if one could not be created
+     */
+    public static Session openActiveSessionFromCache(Context context) {
+        return openActiveSession(context, false, null);
+    }
+
+    /**
+     * If allowLoginUI is true, this will create a new Session, make it active, and
+     * open it. If the default token cache is not available, then this will request
+     * basic permissions. If the default token cache is available and cached tokens
+     * are loaded, this will use the cached token and associated permissions.
+     * <p/>
+     * If allowedLoginUI is false, this will only create the active session and open
+     * it if it requires no user interaction (i.e. the token cache is available and
+     * there are cached tokens).
+     *
+     * @param activity     The Activity that is opening the new Session.
+     * @param allowLoginUI if false, only sets the active session and opens it if it
+     *                     does not require user interaction
+     * @param callback     The {@link StatusCallback SessionStatusCallback} to
+     *                     notify regarding Session state changes. May be null.
+     * @return The new Session or null if one could not be created
+     */
+    public static Session openActiveSession(Activity activity, boolean allowLoginUI,
+            StatusCallback callback) {
+        return openActiveSession(activity, allowLoginUI, new OpenRequest(activity).setCallback(callback));
+    }
+
+    /**
+     * If allowLoginUI is true, this will create a new Session, make it active, and
+     * open it. If the default token cache is not available, then this will request
+     * basic permissions. If the default token cache is available and cached tokens
+     * are loaded, this will use the cached token and associated permissions.
+     * <p/>
+     * If allowedLoginUI is false, this will only create the active session and open
+     * it if it requires no user interaction (i.e. the token cache is available and
+     * there are cached tokens).
+     *
+     * @param context      The Activity or Service creating this Session
+     * @param fragment     The Fragment that is opening the new Session.
+     * @param allowLoginUI if false, only sets the active session and opens it if it
+     *                     does not require user interaction
+     * @param callback     The {@link StatusCallback SessionStatusCallback} to
+     *                     notify regarding Session state changes.
+     * @return The new Session or null if one could not be created
+     */
+    public static Session openActiveSession(Context context, Fragment fragment,
+            boolean allowLoginUI, StatusCallback callback) {
+        return openActiveSession(context, allowLoginUI, new OpenRequest(fragment).setCallback(callback));
+    }
+
+    /**
+     * Opens a session based on an existing Facebook access token, and also makes this session
+     * the currently active session. This method should be used
+     * only in instances where an application has previously obtained an access token and wishes
+     * to import it into the Session/TokenCachingStrategy-based session-management system. A primary
+     * example would be an application which previously did not use the Facebook SDK for Android
+     * and implemented its own session-management scheme, but wishes to implement an upgrade path
+     * for existing users so they do not need to log in again when upgrading to a version of
+     * the app that uses the SDK. In general, this method will be called only once, when the app
+     * detects that it has been upgraded -- after that, the usual Session lifecycle methods
+     * should be used to manage the session and its associated token.
+     * <p/>
+     * No validation is done that the token, token source, or permissions are actually valid.
+     * It is the caller's responsibility to ensure that these accurately reflect the state of
+     * the token that has been passed in, or calls to the Facebook API may fail.
+     *
+     * @param context     the Context to use for creation the session
+     * @param accessToken the access token obtained from Facebook
+     * @param callback    a callback that will be called when the session status changes; may be null
+     * @return The new Session or null if one could not be created
+     */
+    public static Session openActiveSessionWithAccessToken(Context context, AccessToken accessToken,
+            StatusCallback callback) {
+        Session session = new Session(context, null, null, false);
+
+        setActiveSession(session);
+        session.open(accessToken, callback);
+
+        return session;
+    }
+
+    private static Session openActiveSession(Context context, boolean allowLoginUI, OpenRequest openRequest) {
+        Session session = new Builder(context).build();
+        if (SessionState.CREATED_TOKEN_LOADED.equals(session.getState()) || allowLoginUI) {
+            setActiveSession(session);
+            session.openForRead(openRequest);
+            return session;
+        }
+        return null;
+    }
+
+    static Context getStaticContext() {
+        return staticContext;
+    }
+
+    static void initializeStaticContext(Context currentContext) {
+        if ((currentContext != null) && (staticContext == null)) {
+            Context applicationContext = currentContext.getApplicationContext();
+            staticContext = (applicationContext != null) ? applicationContext : currentContext;
+        }
+    }
+
+    void authorize(AuthorizationRequest request) {
+        boolean started = false;
+
+        request.setApplicationId(applicationId);
+
+        autoPublishAsync();
+
+        started = tryLoginActivity(request);
+
+        if (!started && request.isLegacy) {
+            started = tryLegacyAuth(request);
+        }
+
+        if (!started) {
+            synchronized (this.lock) {
+                final SessionState oldState = this.state;
+
+                switch (this.state) {
+                    case CLOSED:
+                    case CLOSED_LOGIN_FAILED:
+                        return;
+
+                    default:
+                        this.state = SessionState.CLOSED_LOGIN_FAILED;
+                        postStateChange(oldState, this.state, new FacebookException("Log in attempt failed."));
+                }
+            }
+        }
+    }
+
+    private void open(OpenRequest openRequest, SessionAuthorizationType authType) {
+        validatePermissions(openRequest, authType);
+        validateLoginBehavior(openRequest);
+
+        SessionState newState;
+        synchronized (this.lock) {
+            if (pendingRequest != null) {
+                postStateChange(state, state, new UnsupportedOperationException(
+                        "Session: an attempt was made to open a session that has a pending request."));
+                return;
+            }
+            final SessionState oldState = this.state;
+
+            switch (this.state) {
+                case CREATED:
+                    this.state = newState = SessionState.OPENING;
+                    if (openRequest == null) {
+                        throw new IllegalArgumentException("openRequest cannot be null when opening a new Session");
+                    }
+                    pendingRequest = openRequest;
+                    break;
+                case CREATED_TOKEN_LOADED:
+                    if (openRequest != null && !Utility.isNullOrEmpty(openRequest.getPermissions())) {
+                        if (!Utility.isSubset(openRequest.getPermissions(), getPermissions())) {
+                            pendingRequest = openRequest;
+                        }
+                    }
+                    if (pendingRequest == null) {
+                        this.state = newState = SessionState.OPENED;
+                    } else {
+                        this.state = newState = SessionState.OPENING;
+                    }
+                    break;
+                default:
+                    throw new UnsupportedOperationException(
+                            "Session: an attempt was made to open an already opened session.");
+            }
+            if (openRequest != null) {
+                addCallback(openRequest.getCallback());
+            }
+            this.postStateChange(oldState, newState, null);
+        }
+
+        if (newState == SessionState.OPENING) {
+            authorize(openRequest);
+        }
+    }
+
+    private void requestNewPermissions(NewPermissionsRequest newPermissionsRequest, SessionAuthorizationType authType) {
+        validatePermissions(newPermissionsRequest, authType);
+        validateLoginBehavior(newPermissionsRequest);
+
+        if (newPermissionsRequest != null) {
+            synchronized (this.lock) {
+                if (pendingRequest != null) {
+                    throw new UnsupportedOperationException(
+                            "Session: an attempt was made to request new permissions for a session that has a pending request.");
+                }
+                switch (this.state) {
+                    case OPENED:
+                    case OPENED_TOKEN_UPDATED:
+                        pendingRequest = newPermissionsRequest;
+                        break;
+                    default:
+                        throw new UnsupportedOperationException(
+                                "Session: an attempt was made to request new permissions for a session that is not currently open.");
+                }
+            }
+
+            newPermissionsRequest.setValidateSameFbidAsToken(getAccessToken());
+            authorize(newPermissionsRequest);
+        }
+    }
+
+    private void validateLoginBehavior(AuthorizationRequest request) {
+        if (request != null && !request.isLegacy) {
+            Intent intent = new Intent();
+            intent.setClass(getStaticContext(), LoginActivity.class);
+            if (!resolveIntent(intent)) {
+                throw new FacebookException(String.format(
+                        "Cannot use SessionLoginBehavior %s when %s is not declared as an activity in AndroidManifest.xml",
+                        request.getLoginBehavior(), LoginActivity.class.getName()));
+            }
+        }
+    }
+
+    private void validatePermissions(AuthorizationRequest request, SessionAuthorizationType authType) {
+        if (request == null || Utility.isNullOrEmpty(request.getPermissions())) {
+            if (SessionAuthorizationType.PUBLISH.equals(authType)) {
+                throw new FacebookException("Cannot request publish or manage authorization with no permissions.");
+            }
+            return; // nothing to check
+        }
+        for (String permission : request.getPermissions()) {
+            if (isPublishPermission(permission)) {
+                if (SessionAuthorizationType.READ.equals(authType)) {
+                    throw new FacebookException(
+                            String.format(
+                                    "Cannot pass a publish or manage permission (%s) to a request for read authorization",
+                                    permission));
+                }
+            } else {
+                if (SessionAuthorizationType.PUBLISH.equals(authType)) {
+                    Log.w(TAG,
+                            String.format(
+                                    "Should not pass a read permission (%s) to a request for publish or manage authorization",
+                                    permission));
+                }
+            }
+        }
+    }
+
+    static boolean isPublishPermission(String permission) {
+        return permission != null &&
+                (permission.startsWith(PUBLISH_PERMISSION_PREFIX) ||
+                        permission.startsWith(MANAGE_PERMISSION_PREFIX) ||
+                        OTHER_PUBLISH_PERMISSIONS.contains(permission));
+
+    }
+
+    private void handleAuthorizationResult(int resultCode, AuthorizationClient.Result result) {
+        AccessToken newToken = null;
+        Exception exception = null;
+        if (resultCode == Activity.RESULT_OK) {
+            if (result.code == AuthorizationClient.Result.Code.SUCCESS) {
+                newToken = result.token;
+            } else {
+                exception = new FacebookAuthorizationException(result.errorMessage);
+            }
+        } else if (resultCode == Activity.RESULT_CANCELED) {
+            exception = new FacebookOperationCanceledException(result.errorMessage);
+        }
+
+        authorizationClient = null;
+        finishAuthOrReauth(newToken, exception);
+    }
+
+    private boolean tryLoginActivity(AuthorizationRequest request) {
+        Intent intent = getLoginActivityIntent(request);
+
+        if (!resolveIntent(intent)) {
+            return false;
+        }
+
+        try {
+            request.getStartActivityDelegate().startActivityForResult(intent, request.getRequestCode());
+        } catch (ActivityNotFoundException e) {
+            return false;
+        }
+
+        return true;
+    }
+
+    private boolean resolveIntent(Intent intent) {
+        ResolveInfo resolveInfo = getStaticContext().getPackageManager().resolveActivity(intent, 0);
+        if (resolveInfo == null) {
+            return false;
+        }
+        return true;
+    }
+
+    private Intent getLoginActivityIntent(AuthorizationRequest request) {
+        Intent intent = new Intent();
+        intent.setClass(getStaticContext(), LoginActivity.class);
+        intent.setAction(request.getLoginBehavior().toString());
+
+        // Let LoginActivity populate extras appropriately
+        AuthorizationClient.AuthorizationRequest authClientRequest = request.getAuthorizationClientRequest();
+        Bundle extras = LoginActivity.populateIntentExtras(authClientRequest);
+        intent.putExtras(extras);
+
+        return intent;
+    }
+
+    private boolean tryLegacyAuth(final AuthorizationRequest request) {
+        authorizationClient = new AuthorizationClient();
+        authorizationClient.setOnCompletedListener(new AuthorizationClient.OnCompletedListener() {
+            @Override
+            public void onCompleted(AuthorizationClient.Result result) {
+                handleAuthorizationResult(Activity.RESULT_OK, result);
+            }
+        });
+        authorizationClient.setContext(getStaticContext());
+        authorizationClient.startOrContinueAuth(request.getAuthorizationClientRequest());
+
+        return true;
+    }
+
+    @SuppressWarnings("incomplete-switch")
+    void finishAuthOrReauth(AccessToken newToken, Exception exception) {
+        // If the token we came up with is expired/invalid, then auth failed.
+        if ((newToken != null) && newToken.isInvalid()) {
+            newToken = null;
+            exception = new FacebookException("Invalid access token.");
+        }
+
+        synchronized (this.lock) {
+            switch (this.state) {
+                case OPENING:
+                    // This means we are authorizing for the first time in this Session.
+                    finishAuthorization(newToken, exception);
+                    break;
+
+                case OPENED:
+                case OPENED_TOKEN_UPDATED:
+                    // This means we are reauthorizing.
+                    finishReauthorization(newToken, exception);
+
+                    break;
+            }
+        }
+    }
+
+    private void finishAuthorization(AccessToken newToken, Exception exception) {
+        final SessionState oldState = state;
+        if (newToken != null) {
+            tokenInfo = newToken;
+            saveTokenToCache(newToken);
+
+            state = SessionState.OPENED;
+        } else if (exception != null) {
+            state = SessionState.CLOSED_LOGIN_FAILED;
+        }
+        pendingRequest = null;
+        postStateChange(oldState, state, exception);
+    }
+
+    private void finishReauthorization(final AccessToken newToken, Exception exception) {
+        final SessionState oldState = state;
+
+        if (newToken != null) {
+            tokenInfo = newToken;
+            saveTokenToCache(newToken);
+
+            state = SessionState.OPENED_TOKEN_UPDATED;
+        }
+
+        pendingRequest = null;
+        postStateChange(oldState, state, exception);
+    }
+
+    private void saveTokenToCache(AccessToken newToken) {
+        if (newToken != null && tokenCachingStrategy != null) {
+            tokenCachingStrategy.save(newToken.toCacheBundle());
+        }
+    }
+
+    void postStateChange(final SessionState oldState, final SessionState newState, final Exception exception) {
+        if (oldState == newState && exception == null) {
+            return;
+        }
+
+        if (newState.isClosed()) {
+            this.tokenInfo = AccessToken.createEmptyToken(Collections.<String>emptyList());
+        }
+
+        synchronized (callbacks) {
+            // Need to schedule the callbacks inside the same queue to preserve ordering.
+            // Otherwise these callbacks could have been added to the queue before the SessionTracker
+            // gets the ACTIVE_SESSION_SET action.
+            Runnable runCallbacks = new Runnable() {
+                public void run() {
+                    for (final StatusCallback callback : callbacks) {
+                        Runnable closure = new Runnable() {
+                            public void run() {
+                                // This can be called inside a synchronized block.
+                                callback.call(Session.this, newState, exception);
+                            }
+                        };
+
+                        runWithHandlerOrExecutor(handler, closure);
+                    }
+                }
+            };
+            runWithHandlerOrExecutor(handler, runCallbacks);
+        }
+
+        if (this == Session.activeSession) {
+            if (oldState.isOpened() != newState.isOpened()) {
+                if (newState.isOpened()) {
+                    postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
+                } else {
+                    postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_CLOSED);
+                }
+            }
+        }
+    }
+
+    static void postActiveSessionAction(String action) {
+        final Intent intent = new Intent(action);
+
+        LocalBroadcastManager.getInstance(getStaticContext()).sendBroadcast(intent);
+    }
+
+    private static void runWithHandlerOrExecutor(Handler handler, Runnable runnable) {
+        if (handler != null) {
+            handler.post(runnable);
+        } else {
+            Settings.getExecutor().execute(runnable);
+        }
+    }
+
+    void extendAccessTokenIfNeeded() {
+        if (shouldExtendAccessToken()) {
+            extendAccessToken();
+        }
+    }
+
+    void extendAccessToken() {
+        TokenRefreshRequest newTokenRefreshRequest = null;
+        synchronized (this.lock) {
+            if (currentTokenRefreshRequest == null) {
+                newTokenRefreshRequest = new TokenRefreshRequest();
+                currentTokenRefreshRequest = newTokenRefreshRequest;
+            }
+        }
+
+        if (newTokenRefreshRequest != null) {
+            newTokenRefreshRequest.bind();
+        }
+    }
+
+    boolean shouldExtendAccessToken() {
+        if (currentTokenRefreshRequest != null) {
+            return false;
+        }
+
+        boolean result = false;
+
+        Date now = new Date();
+
+        if (state.isOpened() && tokenInfo.getSource().canExtendToken()
+                && now.getTime() - lastAttemptedTokenExtendDate.getTime() > TOKEN_EXTEND_RETRY_SECONDS * 1000
+                && now.getTime() - tokenInfo.getLastRefresh().getTime() > TOKEN_EXTEND_THRESHOLD_SECONDS * 1000) {
+            result = true;
+        }
+
+        return result;
+    }
+
+    AccessToken getTokenInfo() {
+        return tokenInfo;
+    }
+
+    void setTokenInfo(AccessToken tokenInfo) {
+        this.tokenInfo = tokenInfo;
+    }
+
+    Date getLastAttemptedTokenExtendDate() {
+        return lastAttemptedTokenExtendDate;
+    }
+
+    void setLastAttemptedTokenExtendDate(Date lastAttemptedTokenExtendDate) {
+        this.lastAttemptedTokenExtendDate = lastAttemptedTokenExtendDate;
+    }
+
+    void setCurrentTokenRefreshRequest(TokenRefreshRequest request) {
+        this.currentTokenRefreshRequest = request;
+    }
+
+    class TokenRefreshRequest implements ServiceConnection {
+
+        final Messenger messageReceiver = new Messenger(
+                new TokenRefreshRequestHandler(Session.this, this));
+
+        Messenger messageSender = null;
+
+        public void bind() {
+            Intent intent = NativeProtocol.createTokenRefreshIntent(getStaticContext());
+            if (intent != null
+                    && staticContext.bindService(intent, new TokenRefreshRequest(), Context.BIND_AUTO_CREATE)) {
+                setLastAttemptedTokenExtendDate(new Date());
+            } else {
+                cleanup();
+            }
+        }
+
+        @Override
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            messageSender = new Messenger(service);
+            refreshToken();
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName arg) {
+            cleanup();
+
+            // We returned an error so there's no point in
+            // keeping the binding open.
+            staticContext.unbindService(TokenRefreshRequest.this);
+        }
+
+        private void cleanup() {
+            if (currentTokenRefreshRequest == this) {
+                currentTokenRefreshRequest = null;
+            }
+        }
+
+        private void refreshToken() {
+            Bundle requestData = new Bundle();
+            requestData.putString(AccessToken.ACCESS_TOKEN_KEY, getTokenInfo().getToken());
+
+            Message request = Message.obtain();
+            request.setData(requestData);
+            request.replyTo = messageReceiver;
+
+            try {
+                messageSender.send(request);
+            } catch (RemoteException e) {
+                cleanup();
+            }
+        }
+
+    }
+
+    // Creating a static Handler class to reduce the possibility of a memory leak.
+    // Handler objects for the same thread all share a common Looper object, which they post messages
+    // to and read from. As messages contain target Handler, as long as there are messages with target
+    // handler in the message queue, the handler cannot be garbage collected. If handler is not static,
+    // the instance of the containing class also cannot be garbage collected even if it is destroyed.
+    static class TokenRefreshRequestHandler extends Handler {
+
+        private WeakReference<Session> sessionWeakReference;
+        private WeakReference<TokenRefreshRequest> refreshRequestWeakReference;
+
+        TokenRefreshRequestHandler(Session session, TokenRefreshRequest refreshRequest) {
+            super(Looper.getMainLooper());
+            sessionWeakReference = new WeakReference<Session>(session);
+            refreshRequestWeakReference = new WeakReference<TokenRefreshRequest>(refreshRequest);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            String token = msg.getData().getString(AccessToken.ACCESS_TOKEN_KEY);
+            Session session = sessionWeakReference.get();
+
+            if (session != null && token != null) {
+                session.extendTokenCompleted(msg.getData());
+            }
+
+            TokenRefreshRequest request = refreshRequestWeakReference.get();
+            if (request != null) {
+                // The refreshToken function should be called rarely,
+                // so there is no point in keeping the binding open.
+                staticContext.unbindService(request);
+                request.cleanup();
+            }
+        }
+    }
+
+    /**
+     * Provides asynchronous notification of Session state changes.
+     *
+     * @see Session#open open
+     */
+    public interface StatusCallback {
+        public void call(Session session, SessionState state, Exception exception);
+    }
+
+    @Override
+    public int hashCode() {
+        return 0;
+    }
+
+    @Override
+    public boolean equals(Object otherObj) {
+        if (!(otherObj instanceof Session)) {
+            return false;
+        }
+        Session other = (Session) otherObj;
+
+        return areEqual(other.applicationId, applicationId) &&
+                areEqual(other.authorizationBundle, authorizationBundle) &&
+                areEqual(other.state, state) &&
+                areEqual(other.getExpirationDate(), getExpirationDate());
+    }
+
+    private static boolean areEqual(Object a, Object b) {
+        if (a == null) {
+            return b == null;
+        } else {
+            return a.equals(b);
+        }
+    }
+
+    /**
+     * Builder class used to create a Session.
+     */
+    public static final class Builder {
+        private final Context context;
+        private String applicationId;
+        private TokenCachingStrategy tokenCachingStrategy;
+
+        /**
+         * Constructs a new Builder associated with the context.
+         *
+         * @param context the Activity or Service starting the Session
+         */
+        public Builder(Context context) {
+            this.context = context;
+        }
+
+        /**
+         * Sets the application id for the Session.
+         *
+         * @param applicationId the application id
+         * @return the Builder instance
+         */
+        public Builder setApplicationId(final String applicationId) {
+            this.applicationId = applicationId;
+            return this;
+        }
+
+        /**
+         * Sets the TokenCachingStrategy for the Session.
+         *
+         * @param tokenCachingStrategy the token cache to use
+         * @return the Builder instance
+         */
+        public Builder setTokenCachingStrategy(final TokenCachingStrategy tokenCachingStrategy) {
+            this.tokenCachingStrategy = tokenCachingStrategy;
+            return this;
+        }
+
+        /**
+         * Build the Session.
+         *
+         * @return a new Session
+         */
+        public Session build() {
+            return new Session(context, applicationId, tokenCachingStrategy);
+        }
+    }
+
+    interface StartActivityDelegate {
+        public void startActivityForResult(Intent intent, int requestCode);
+
+        public Activity getActivityContext();
+    }
+
+    private void autoPublishAsync() {
+        AutoPublishAsyncTask asyncTask = null;
+        synchronized (this) {
+            if (autoPublishAsyncTask == null && Settings.getShouldAutoPublishInstall()) {
+                // copy the application id to guarantee thread safety against our container.
+                String applicationId = Session.this.applicationId;
+
+                // skip publish if we don't have an application id.
+                if (applicationId != null) {
+                    asyncTask = autoPublishAsyncTask = new AutoPublishAsyncTask(applicationId, staticContext);
+                }
+            }
+        }
+
+        if (asyncTask != null) {
+            asyncTask.execute();
+        }
+    }
+
+    /**
+     * Async implementation to allow auto publishing to not block the ui thread.
+     */
+    private class AutoPublishAsyncTask extends AsyncTask<Void, Void, Void> {
+        private final String mApplicationId;
+        private final Context mApplicationContext;
+
+        public AutoPublishAsyncTask(String applicationId, Context context) {
+            mApplicationId = applicationId;
+            mApplicationContext = context.getApplicationContext();
+        }
+
+        @Override
+        protected Void doInBackground(Void... voids) {
+            try {
+                Settings.publishInstallAndWait(mApplicationContext, mApplicationId);
+            } catch (Exception e) {
+                Utility.logd("Facebook-publish", e.getMessage());
+            }
+            return null;
+        }
+
+        @Override
+        protected void onPostExecute(Void result) {
+            // always clear out the publisher to allow other invocations.
+            synchronized (Session.this) {
+                autoPublishAsyncTask = null;
+            }
+        }
+    }
+
+    /**
+     * Base class for authorization requests {@link OpenRequest} and {@link NewPermissionsRequest}.
+     */
+    public static class AuthorizationRequest implements Serializable {
+
+        private static final long serialVersionUID = 1L;
+
+        private final StartActivityDelegate startActivityDelegate;
+        private SessionLoginBehavior loginBehavior = SessionLoginBehavior.SSO_WITH_FALLBACK;
+        private int requestCode = DEFAULT_AUTHORIZE_ACTIVITY_CODE;
+        private StatusCallback statusCallback;
+        private boolean isLegacy = false;
+        private List<String> permissions = Collections.emptyList();
+        private SessionDefaultAudience defaultAudience = SessionDefaultAudience.FRIENDS;
+        private String applicationId;
+        private String validateSameFbidAsToken;
+
+        AuthorizationRequest(final Activity activity) {
+            startActivityDelegate = new StartActivityDelegate() {
+                @Override
+                public void startActivityForResult(Intent intent, int requestCode) {
+                    activity.startActivityForResult(intent, requestCode);
+                }
+
+                @Override
+                public Activity getActivityContext() {
+                    return activity;
+                }
+            };
+        }
+
+        AuthorizationRequest(final Fragment fragment) {
+            startActivityDelegate = new StartActivityDelegate() {
+                @Override
+                public void startActivityForResult(Intent intent, int requestCode) {
+                    fragment.startActivityForResult(intent, requestCode);
+                }
+
+                @Override
+                public Activity getActivityContext() {
+                    return fragment.getActivity();
+                }
+            };
+        }
+
+        /**
+         * Constructor to be used for V1 serialization only, DO NOT CHANGE.
+         */
+        private AuthorizationRequest(SessionLoginBehavior loginBehavior, int requestCode,
+                List<String> permissions, String defaultAudience, boolean isLegacy, String applicationId,
+                String validateSameFbidAsToken) {
+            startActivityDelegate = new StartActivityDelegate() {
+                @Override
+                public void startActivityForResult(Intent intent, int requestCode) {
+                    throw new UnsupportedOperationException(
+                            "Cannot create an AuthorizationRequest without a valid Activity or Fragment");
+                }
+
+                @Override
+                public Activity getActivityContext() {
+                    throw new UnsupportedOperationException(
+                            "Cannot create an AuthorizationRequest without a valid Activity or Fragment");
+                }
+            };
+            this.loginBehavior = loginBehavior;
+            this.requestCode = requestCode;
+            this.permissions = permissions;
+            this.defaultAudience = SessionDefaultAudience.valueOf(defaultAudience);
+            this.isLegacy = isLegacy;
+            this.applicationId = applicationId;
+            this.validateSameFbidAsToken = validateSameFbidAsToken;
+        }
+
+        /**
+         * Used for backwards compatibility with Facebook.java only, DO NOT USE.
+         *
+         * @param isLegacy
+         */
+        public void setIsLegacy(boolean isLegacy) {
+            this.isLegacy = isLegacy;
+        }
+
+        boolean isLegacy() {
+            return isLegacy;
+        }
+
+        AuthorizationRequest setCallback(StatusCallback statusCallback) {
+            this.statusCallback = statusCallback;
+            return this;
+        }
+
+        StatusCallback getCallback() {
+            return statusCallback;
+        }
+
+        AuthorizationRequest setLoginBehavior(SessionLoginBehavior loginBehavior) {
+            if (loginBehavior != null) {
+                this.loginBehavior = loginBehavior;
+            }
+            return this;
+        }
+
+        SessionLoginBehavior getLoginBehavior() {
+            return loginBehavior;
+        }
+
+        AuthorizationRequest setRequestCode(int requestCode) {
+            if (requestCode >= 0) {
+                this.requestCode = requestCode;
+            }
+            return this;
+        }
+
+        int getRequestCode() {
+            return requestCode;
+        }
+
+        AuthorizationRequest setPermissions(List<String> permissions) {
+            if (permissions != null) {
+                this.permissions = permissions;
+            }
+            return this;
+        }
+
+        List<String> getPermissions() {
+            return permissions;
+        }
+
+        AuthorizationRequest setDefaultAudience(SessionDefaultAudience defaultAudience) {
+            if (defaultAudience != null) {
+                this.defaultAudience = defaultAudience;
+            }
+            return this;
+        }
+
+        SessionDefaultAudience getDefaultAudience() {
+            return defaultAudience;
+        }
+
+        StartActivityDelegate getStartActivityDelegate() {
+            return startActivityDelegate;
+        }
+
+        String getApplicationId() {
+            return applicationId;
+        }
+
+        void setApplicationId(String applicationId) {
+            this.applicationId = applicationId;
+        }
+
+        String getValidateSameFbidAsToken() {
+            return validateSameFbidAsToken;
+        }
+
+        void setValidateSameFbidAsToken(String validateSameFbidAsToken) {
+            this.validateSameFbidAsToken = validateSameFbidAsToken;
+        }
+
+        AuthorizationClient.AuthorizationRequest getAuthorizationClientRequest() {
+            AuthorizationClient.StartActivityDelegate delegate = new AuthorizationClient.StartActivityDelegate() {
+                @Override
+                public void startActivityForResult(Intent intent, int requestCode) {
+                    startActivityDelegate.startActivityForResult(intent, requestCode);
+                }
+
+                @Override
+                public Activity getActivityContext() {
+                    return startActivityDelegate.getActivityContext();
+                }
+            };
+            return new AuthorizationClient.AuthorizationRequest(loginBehavior, requestCode, isLegacy,
+                    permissions, defaultAudience, applicationId, validateSameFbidAsToken, delegate);
+        }
+
+        // package private so subclasses can use it
+        Object writeReplace() {
+            return new AuthRequestSerializationProxyV1(
+                    loginBehavior, requestCode, permissions, defaultAudience.name(), isLegacy, applicationId, validateSameFbidAsToken);
+        }
+
+        // have a readObject that throws to prevent spoofing
+        // package private so subclasses can use it
+        void readObject(ObjectInputStream stream) throws InvalidObjectException {
+            throw new InvalidObjectException("Cannot readObject, serialization proxy required");
+        }
+
+        private static class AuthRequestSerializationProxyV1 implements Serializable {
+            private static final long serialVersionUID = -8748347685113614927L;
+            private final SessionLoginBehavior loginBehavior;
+            private final int requestCode;
+            private boolean isLegacy;
+            private final List<String> permissions;
+            private final String defaultAudience;
+            private final String applicationId;
+            private final String validateSameFbidAsToken;
+
+            private AuthRequestSerializationProxyV1(SessionLoginBehavior loginBehavior,
+                    int requestCode, List<String> permissions, String defaultAudience, boolean isLegacy,
+                    String applicationId, String validateSameFbidAsToken) {
+                this.loginBehavior = loginBehavior;
+                this.requestCode = requestCode;
+                this.permissions = permissions;
+                this.defaultAudience = defaultAudience;
+                this.isLegacy = isLegacy;
+                this.applicationId = applicationId;
+                this.validateSameFbidAsToken = validateSameFbidAsToken;
+            }
+
+            private Object readResolve() {
+                return new AuthorizationRequest(loginBehavior, requestCode, permissions, defaultAudience, isLegacy,
+                        applicationId, validateSameFbidAsToken);
+            }
+        }
+    }
+
+    /**
+     * A request used to open a Session.
+     */
+    public static final class OpenRequest extends AuthorizationRequest {
+        private static final long serialVersionUID = 1L;
+
+        /**
+         * Constructs an OpenRequest.
+         *
+         * @param activity the Activity to use to open the Session
+         */
+        public OpenRequest(Activity activity) {
+            super(activity);
+        }
+
+        /**
+         * Constructs an OpenRequest.
+         *
+         * @param fragment the Fragment to use to open the Session
+         */
+        public OpenRequest(Fragment fragment) {
+            super(fragment);
+        }
+
+        /**
+         * Sets the StatusCallback for the OpenRequest.
+         *
+         * @param statusCallback The {@link StatusCallback SessionStatusCallback} to
+         *                       notify regarding Session state changes.
+         * @return the OpenRequest object to allow for chaining
+         */
+        public final OpenRequest setCallback(StatusCallback statusCallback) {
+            super.setCallback(statusCallback);
+            return this;
+        }
+
+        /**
+         * Sets the login behavior for the OpenRequest.
+         *
+         * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
+         *                      specifies what behaviors should be attempted during
+         *                      authorization.
+         * @return the OpenRequest object to allow for chaining
+         */
+        public final OpenRequest setLoginBehavior(SessionLoginBehavior loginBehavior) {
+            super.setLoginBehavior(loginBehavior);
+            return this;
+        }
+
+        /**
+         * Sets the request code for the OpenRequest.
+         *
+         * @param requestCode An integer that identifies this request. This integer will be used
+         *                    as the request code in {@link Activity#onActivityResult
+         *                    onActivityResult}. This integer should be >= 0. If a value < 0 is
+         *                    passed in, then a default value will be used.
+         * @return the OpenRequest object to allow for chaining
+         */
+        public final OpenRequest setRequestCode(int requestCode) {
+            super.setRequestCode(requestCode);
+            return this;
+        }
+
+        /**
+         * Sets the permissions for the OpenRequest.
+         *
+         * @param permissions A List&lt;String&gt; representing the permissions to request
+         *                    during the authentication flow. A null or empty List
+         *                    represents basic permissions.
+         * @return the OpenRequest object to allow for chaining
+         */
+        public final OpenRequest setPermissions(List<String> permissions) {
+            super.setPermissions(permissions);
+            return this;
+        }
+
+        /**
+         * Sets the defaultAudience for the OpenRequest.
+         * <p/>
+         * This is only used during Native login using a sufficiently recent facebook app.
+         *
+         * @param defaultAudience A SessionDefaultAudience representing the default audience setting to request.
+         * @return the OpenRequest object to allow for chaining
+         */
+        public final OpenRequest setDefaultAudience(SessionDefaultAudience defaultAudience) {
+            super.setDefaultAudience(defaultAudience);
+            return this;
+        }
+    }
+
+    /**
+     * A request to be used to request new permissions for a Session.
+     */
+    public static final class NewPermissionsRequest extends AuthorizationRequest {
+        private static final long serialVersionUID = 1L;
+
+        /**
+         * Constructs a NewPermissionsRequest.
+         *
+         * @param activity    the Activity used to issue the request
+         * @param permissions additional permissions to request
+         */
+        public NewPermissionsRequest(Activity activity, List<String> permissions) {
+            super(activity);
+            setPermissions(permissions);
+        }
+
+        /**
+         * Constructs a NewPermissionsRequest.
+         *
+         * @param fragment    the Fragment used to issue the request
+         * @param permissions additional permissions to request
+         */
+        public NewPermissionsRequest(Fragment fragment, List<String> permissions) {
+            super(fragment);
+            setPermissions(permissions);
+        }
+
+        /**
+         * Sets the StatusCallback for the NewPermissionsRequest.
+         *
+         * @param statusCallback The {@link StatusCallback SessionStatusCallback} to
+         *                       notify regarding Session state changes.
+         * @return the NewPermissionsRequest object to allow for chaining
+         */
+        public final NewPermissionsRequest setCallback(StatusCallback statusCallback) {
+            super.setCallback(statusCallback);
+            return this;
+        }
+
+        /**
+         * Sets the login behavior for the NewPermissionsRequest.
+         *
+         * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
+         *                      specifies what behaviors should be attempted during
+         *                      authorization.
+         * @return the NewPermissionsRequest object to allow for chaining
+         */
+        public final NewPermissionsRequest setLoginBehavior(SessionLoginBehavior loginBehavior) {
+            super.setLoginBehavior(loginBehavior);
+            return this;
+        }
+
+        /**
+         * Sets the request code for the NewPermissionsRequest.
+         *
+         * @param requestCode An integer that identifies this request. This integer will be used
+         *                    as the request code in {@link Activity#onActivityResult
+         *                    onActivityResult}. This integer should be >= 0. If a value < 0 is
+         *                    passed in, then a default value will be used.
+         * @return the NewPermissionsRequest object to allow for chaining
+         */
+        public final NewPermissionsRequest setRequestCode(int requestCode) {
+            super.setRequestCode(requestCode);
+            return this;
+        }
+
+        /**
+         * Sets the defaultAudience for the OpenRequest.
+         *
+         * @param defaultAudience A SessionDefaultAudience representing the default audience setting to request.
+         * @return the NewPermissionsRequest object to allow for chaining
+         */
+        public final NewPermissionsRequest setDefaultAudience(SessionDefaultAudience defaultAudience) {
+            super.setDefaultAudience(defaultAudience);
+            return this;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/SessionDefaultAudience.java b/facebook/src/com/facebook/SessionDefaultAudience.java
new file mode 100644
index 000000000..eaac2b369
--- /dev/null
+++ b/facebook/src/com/facebook/SessionDefaultAudience.java
@@ -0,0 +1,55 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Certain operations such as publishing a status or publishing a photo require an audience. When the user
+ * grants an application permission to perform a publish operation, a default audience is selected as the
+ * publication ceiling for the application. This enumerated value allows the application to select which
+ * audience to ask the user to grant publish permission for.
+ */
+public enum SessionDefaultAudience {
+    /**
+     * Represents an invalid default audience value, can be used when only reading.
+     */
+    NONE(null),
+
+    /**
+     * Indicates only the user is able to see posts made by the application.
+     */
+    ONLY_ME(NativeProtocol.AUDIENCE_ME),
+
+    /**
+     * Indicates that the user's friends are able to see posts made by the application.
+     */
+    FRIENDS(NativeProtocol.AUDIENCE_FRIENDS),
+
+    /**
+     * Indicates that all Facebook users are able to see posts made by the application.
+     */
+    EVERYONE(NativeProtocol.AUDIENCE_EVERYONE);
+
+    private final String nativeProtocolAudience;
+
+    private SessionDefaultAudience(String protocol) {
+        nativeProtocolAudience = protocol;
+    }
+
+    String getNativeProtocolAudience() {
+        return nativeProtocolAudience;
+    }
+}
diff --git a/facebook/src/com/facebook/SessionLoginBehavior.java b/facebook/src/com/facebook/SessionLoginBehavior.java
new file mode 100644
index 000000000..cc300dbd2
--- /dev/null
+++ b/facebook/src/com/facebook/SessionLoginBehavior.java
@@ -0,0 +1,59 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * Specifies the behaviors to try during
+ * {@link Session#openForRead(com.facebook.Session.OpenRequest) openForRead},
+ * {@link Session#openForPublish(com.facebook.Session.OpenRequest) openForPublish},
+ * {@link Session#requestNewReadPermissions(com.facebook.Session.NewPermissionsRequest) requestNewReadPermissions}, or
+ * {@link Session#requestNewPublishPermissions(com.facebook.Session.NewPermissionsRequest) requestNewPublishPermissions}.
+ */
+public enum SessionLoginBehavior {
+    /**
+     * Specifies that Session should attempt Single Sign On (SSO), and if that
+     * does not work fall back to dialog auth. This is the default behavior.
+     */
+    SSO_WITH_FALLBACK(true, true),
+
+    /**
+     * Specifies that Session should only attempt SSO. If SSO fails, then the
+     * open or new permissions call fails.
+     */
+    SSO_ONLY(true, false),
+
+    /**
+     * Specifies that SSO should not be attempted, and to only use dialog auth.
+     */
+    SUPPRESS_SSO(false, true);
+
+    private final boolean allowsKatanaAuth;
+    private final boolean allowsWebViewAuth;
+
+    private SessionLoginBehavior(boolean allowsKatanaAuth, boolean allowsWebViewAuth) {
+        this.allowsKatanaAuth = allowsKatanaAuth;
+        this.allowsWebViewAuth = allowsWebViewAuth;
+    }
+
+    boolean allowsKatanaAuth() {
+        return allowsKatanaAuth;
+    }
+
+    boolean allowsWebViewAuth() {
+        return allowsWebViewAuth;
+    }
+}
diff --git a/facebook/src/com/facebook/SessionState.java b/facebook/src/com/facebook/SessionState.java
new file mode 100644
index 000000000..45250624f
--- /dev/null
+++ b/facebook/src/com/facebook/SessionState.java
@@ -0,0 +1,117 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+/**
+ * <p>
+ * Identifies the state of a Session.
+ * </p>
+ * <p>
+ * Session objects implement a state machine that controls their lifecycle. This
+ * enum represents the states of the state machine.
+ * </p>
+ */
+public enum SessionState {
+    /**
+     * Indicates that the Session has not yet been opened and has no cached
+     * token. Opening a Session in this state will involve user interaction.
+     */
+    CREATED(Category.CREATED_CATEGORY),
+
+    /**
+     * <p>
+     * Indicates that the Session has not yet been opened and has a cached
+     * token. Opening a Session in this state will not involve user interaction.
+     * </p>
+     * <p>
+     * If you are using Session from an Android Service, you must provide a
+     * TokenCachingStrategy implementation that contains a valid token to the Session
+     * constructor. The resulting Session will be created in this state, and you
+     * can then safely call open, passing null for the Activity.
+     * </p>
+     */
+    CREATED_TOKEN_LOADED(Category.CREATED_CATEGORY),
+
+    /**
+     * Indicates that the Session is in the process of opening.
+     */
+    OPENING(Category.CREATED_CATEGORY),
+
+    /**
+     * Indicates that the Session is opened. In this state, the Session may be
+     * used with a {@link Request}.
+     */
+    OPENED(Category.OPENED_CATEGORY),
+
+    /**
+     * <p>
+     * Indicates that the Session is opened and that the token has changed. In
+     * this state, the Session may be used with {@link Request}.
+     * </p>
+     * <p>
+     * Every time the token is updated, {@link Session.StatusCallback
+     * StatusCallback} is called with this value.
+     * </p>
+     */
+    OPENED_TOKEN_UPDATED(Category.OPENED_CATEGORY),
+
+    /**
+     * Indicates that the Session is closed, and that it was not closed
+     * normally. Typically this means that the open call failed, and the
+     * Exception parameter to {@link Session.StatusCallback StatusCallback} will
+     * be non-null.
+     */
+    CLOSED_LOGIN_FAILED(Category.CLOSED_CATEGORY),
+
+    /**
+     * Indicates that the Session was closed normally.
+     */
+    CLOSED(Category.CLOSED_CATEGORY);
+
+    private final Category category;
+
+    SessionState(Category category) {
+        this.category = category;
+    }
+
+    /**
+     * Returns a boolean indicating whether the state represents a successfully
+     * opened state in which the Session can be used with a {@link Request}.
+     * 
+     * @return a boolean indicating whether the state represents a successfully
+     *         opened state in which the Session can be used with a
+     *         {@link Request}.
+     */
+    public boolean isOpened() {
+        return this.category == Category.OPENED_CATEGORY;
+    }
+
+    /**
+     * Returns a boolean indicating whether the state represents a closed
+     * Session that can no longer be used with a {@link Request}.
+     * 
+     * @return a boolean indicating whether the state represents a closed
+     * Session that can no longer be used with a {@link Request}.
+     */
+    public boolean isClosed() {
+        return this.category == Category.CLOSED_CATEGORY;
+    }
+
+    private enum Category {
+        CREATED_CATEGORY, OPENED_CATEGORY, CLOSED_CATEGORY
+    }
+}
diff --git a/facebook/src/com/facebook/Settings.java b/facebook/src/com/facebook/Settings.java
new file mode 100644
index 000000000..f0a8f7ed0
--- /dev/null
+++ b/facebook/src/com/facebook/Settings.java
@@ -0,0 +1,306 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import com.facebook.android.BuildConfig;
+import com.facebook.internal.Utility;
+import com.facebook.model.GraphObject;
+import com.facebook.internal.Validate;
+import org.json.JSONException;
+
+import java.lang.reflect.Field;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Allows some customization of sdk behavior.
+ */
+public final class Settings {
+    private static final HashSet<LoggingBehavior> loggingBehaviors = new HashSet<LoggingBehavior>();
+    private static volatile Executor executor;
+    private static volatile boolean shouldAutoPublishInstall;
+
+    private static final int DEFAULT_CORE_POOL_SIZE = 5;
+    private static final int DEFAULT_MAXIMUM_POOL_SIZE = 128;
+    private static final int DEFAULT_KEEP_ALIVE = 1;
+    private static final Object LOCK = new Object();
+
+    private static final Uri ATTRIBUTION_ID_CONTENT_URI =
+            Uri.parse("content://com.facebook.katana.provider.AttributionIdProvider");
+    private static final String ATTRIBUTION_ID_COLUMN_NAME = "aid";
+
+    private static final String ATTRIBUTION_PREFERENCES = "com.facebook.sdk.attributionTracking";
+    private static final String PUBLISH_ACTIVITY_PATH = "%s/activities";
+    private static final String MOBILE_INSTALL_EVENT = "MOBILE_APP_INSTALL";
+    private static final String SUPPORTS_ATTRIBUTION = "supports_attribution";
+    private static final String APPLICATION_FIELDS = "fields";
+    private static final String ANALYTICS_EVENT = "event";
+    private static final String ATTRIBUTION_KEY = "attribution";
+
+    private static final BlockingQueue<Runnable> DEFAULT_WORK_QUEUE = new LinkedBlockingQueue<Runnable>(10);
+
+    private static final ThreadFactory DEFAULT_THREAD_FACTORY = new ThreadFactory() {
+        private final AtomicInteger counter = new AtomicInteger(0);
+
+        public Thread newThread(Runnable runnable) {
+            return new Thread(runnable, "FacebookSdk #" + counter.incrementAndGet());
+        }
+    };
+
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Returns the types of extended logging that are currently enabled.
+     *
+     * @return a set containing enabled logging behaviors
+     */
+    public static final Set<LoggingBehavior> getLoggingBehaviors() {
+        synchronized (loggingBehaviors) {
+            return Collections.unmodifiableSet(new HashSet<LoggingBehavior>(loggingBehaviors));
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Enables a particular extended logging in the sdk.
+     *
+     * @param behavior
+     *          The LoggingBehavior to enable
+     */
+    public static final void addLoggingBehavior(LoggingBehavior behavior) {
+        synchronized (loggingBehaviors) {
+            loggingBehaviors.add(behavior);
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Disables a particular extended logging behavior in the sdk.
+     *
+     * @param behavior
+     *          The LoggingBehavior to disable
+     */
+    public static final void removeLoggingBehavior(LoggingBehavior behavior) {
+        synchronized (loggingBehaviors) {
+            loggingBehaviors.remove(behavior);
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Disables all extended logging behaviors.
+     */
+    public static final void clearLoggingBehaviors() {
+        synchronized (loggingBehaviors) {
+            loggingBehaviors.clear();
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Checks if a particular extended logging behavior is enabled.
+     *
+     * @param behavior
+     *          The LoggingBehavior to check
+     * @return whether behavior is enabled
+     */
+    public static final boolean isLoggingBehaviorEnabled(LoggingBehavior behavior) {
+        synchronized (loggingBehaviors) {
+            return BuildConfig.DEBUG && loggingBehaviors.contains(behavior);
+        }
+    }
+
+    /**
+     * Returns the Executor used by the SDK for non-AsyncTask background work.
+     *
+     * By default this uses AsyncTask Executor via reflection if the API level is high enough.
+     * Otherwise this creates a new Executor with defaults similar to those used in AsyncTask.
+     *
+     * @return an Executor used by the SDK.  This will never be null.
+     */
+    public static Executor getExecutor() {
+        synchronized (LOCK) {
+            if (Settings.executor == null) {
+                Executor executor = getAsyncTaskExecutor();
+                if (executor == null) {
+                    executor = new ThreadPoolExecutor(DEFAULT_CORE_POOL_SIZE, DEFAULT_MAXIMUM_POOL_SIZE,
+                            DEFAULT_KEEP_ALIVE, TimeUnit.SECONDS, DEFAULT_WORK_QUEUE, DEFAULT_THREAD_FACTORY);
+                }
+                Settings.executor = executor;
+            }
+        }
+        return Settings.executor;
+    }
+
+    /**
+     * Sets the Executor used by the SDK for non-AsyncTask background work.
+     *
+     * @param executor
+     *          the Executor to use; must not be null.
+     */
+    public static void setExecutor(Executor executor) {
+        Validate.notNull(executor, "executor");
+        synchronized (LOCK) {
+            Settings.executor = executor;
+        }
+    }
+
+    private static Executor getAsyncTaskExecutor() {
+        Field executorField = null;
+        try {
+            executorField = AsyncTask.class.getField("THREAD_POOL_EXECUTOR");
+        } catch (NoSuchFieldException e) {
+            return null;
+        }
+
+        if (executorField == null) {
+            return null;
+        }
+
+        Object executorObject = null;
+        try {
+            executorObject = executorField.get(null);
+        } catch (IllegalAccessException e) {
+            return null;
+        }
+
+        if (executorObject == null) {
+            return null;
+        }
+
+        if (!(executorObject instanceof Executor)) {
+            return null;
+        }
+
+        return (Executor) executorObject;
+    }
+
+    public static void publishInstallAsync(final Context context, final String applicationId) {
+        // grab the application context ahead of time, since we will return to the caller immediately.
+        final Context applicationContext = context.getApplicationContext();
+        Settings.getExecutor().execute(new Runnable() {
+            @Override
+            public void run() {
+                Settings.publishInstallAndWait(applicationContext, applicationId);
+            }
+        });
+    }
+
+    /**
+     * Sets whether opening a Session should automatically publish install attribution to the Facebook graph.
+     *
+     * @param shouldAutoPublishInstall true to automatically publish, false to not
+     */
+    public static void setShouldAutoPublishInstall(boolean shouldAutoPublishInstall) {
+        Settings.shouldAutoPublishInstall = shouldAutoPublishInstall;
+    }
+
+    /**
+     * Gets whether opening a Session should automatically publish install attribution to the Facebook graph.
+     *
+     * @return true to automatically publish, false to not
+     */
+    public static boolean getShouldAutoPublishInstall() {
+        return shouldAutoPublishInstall;
+    }
+
+    /**
+     * Manually publish install attribution to the Facebook graph.  Internally handles tracking repeat calls to prevent
+     * multiple installs being published to the graph.
+     * @param context the current Context
+     * @return returns false on error.  Applications should retry until true is returned.  Safe to call again after
+     * true is returned.
+     */
+    public static boolean publishInstallAndWait(final Context context, final String applicationId) {
+        try {
+            if (applicationId == null) {
+                return false;
+            }
+            String attributionId = Settings.getAttributionId(context.getContentResolver());
+            SharedPreferences preferences = context.getSharedPreferences(ATTRIBUTION_PREFERENCES, Context.MODE_PRIVATE);
+            String pingKey = applicationId+"ping";
+            long lastPing = preferences.getLong(pingKey, 0);
+            if (lastPing == 0 && attributionId != null) {
+                Bundle supportsAttributionParams = new Bundle();
+                supportsAttributionParams.putString(APPLICATION_FIELDS, SUPPORTS_ATTRIBUTION);
+                Request pingRequest = Request.newGraphPathRequest(null, applicationId, null);
+                pingRequest.setParameters(supportsAttributionParams);
+
+                GraphObject supportResponse = pingRequest.executeAndWait().getGraphObject();
+                Object doesSupportAttribution = supportResponse.getProperty(SUPPORTS_ATTRIBUTION);
+
+                if (!(doesSupportAttribution instanceof Boolean)) {
+                    throw new JSONException(String.format(
+                            "%s contains %s instead of a Boolean", SUPPORTS_ATTRIBUTION, doesSupportAttribution));
+                }
+
+                if ((Boolean)doesSupportAttribution) {
+                    GraphObject publishParams = GraphObject.Factory.create();
+                    publishParams.setProperty(ANALYTICS_EVENT, MOBILE_INSTALL_EVENT);
+                    publishParams.setProperty(ATTRIBUTION_KEY, attributionId);
+
+                    String publishUrl = String.format(PUBLISH_ACTIVITY_PATH, applicationId);
+
+                    Request publishRequest = Request.newPostRequest(null, publishUrl, publishParams, null);
+                    publishRequest.executeAndWait();
+
+                    // denote success since no error threw from the post.
+                    SharedPreferences.Editor editor = preferences.edit();
+                    lastPing = System.currentTimeMillis();
+                    editor.putLong(pingKey, lastPing);
+                    editor.commit();
+                }
+            }
+            return lastPing != 0;
+        } catch (Exception e) {
+            // if there was an error, fall through to the failure case.
+            Utility.logd("Facebook-publish", e.getMessage());
+        }
+        return false;
+    }
+
+    public static String getAttributionId(ContentResolver contentResolver) {
+        String [] projection = {ATTRIBUTION_ID_COLUMN_NAME};
+        Cursor c = contentResolver.query(ATTRIBUTION_ID_CONTENT_URI, projection, null, null, null);
+        if (c == null || !c.moveToFirst()) {
+            return null;
+        }
+        String attributionId = c.getString(c.getColumnIndex(ATTRIBUTION_ID_COLUMN_NAME));
+        c.close();
+        return attributionId;
+    }
+}
diff --git a/facebook/src/com/facebook/SharedPreferencesTokenCachingStrategy.java b/facebook/src/com/facebook/SharedPreferencesTokenCachingStrategy.java
new file mode 100644
index 000000000..9a1683528
--- /dev/null
+++ b/facebook/src/com/facebook/SharedPreferencesTokenCachingStrategy.java
@@ -0,0 +1,403 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+import android.util.Log;
+import com.facebook.internal.Logger;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+/*
+ * <p>
+ * An implementation of {@link TokenCachingStrategy TokenCachingStrategy} that uses Android SharedPreferences
+ * to persist information.
+ * </p>
+ * <p>
+ * The data to be cached is passed in via a Bundle. Only non-null key-value-pairs where
+ * the value is one of the following types (or an array of the same) are persisted:
+ * boolean, byte, int, long, float, double, char. In addition, String and List<String>
+ * are also supported.
+ * </p>
+ */
+public class SharedPreferencesTokenCachingStrategy extends TokenCachingStrategy {
+
+    private static final String DEFAULT_CACHE_KEY = "com.facebook.SharedPreferencesTokenCachingStrategy.DEFAULT_KEY";
+    private static final String TAG = SharedPreferencesTokenCachingStrategy.class.getSimpleName();
+
+    private static final String JSON_VALUE_TYPE = "valueType";
+    private static final String JSON_VALUE = "value";
+    private static final String JSON_VALUE_ENUM_TYPE = "enumType";
+
+    private static final String TYPE_BOOLEAN = "bool";
+    private static final String TYPE_BOOLEAN_ARRAY = "bool[]";
+    private static final String TYPE_BYTE = "byte";
+    private static final String TYPE_BYTE_ARRAY = "byte[]";
+    private static final String TYPE_SHORT = "short";
+    private static final String TYPE_SHORT_ARRAY = "short[]";
+    private static final String TYPE_INTEGER = "int";
+    private static final String TYPE_INTEGER_ARRAY = "int[]";
+    private static final String TYPE_LONG = "long";
+    private static final String TYPE_LONG_ARRAY = "long[]";
+    private static final String TYPE_FLOAT = "float";
+    private static final String TYPE_FLOAT_ARRAY = "float[]";
+    private static final String TYPE_DOUBLE = "double";
+    private static final String TYPE_DOUBLE_ARRAY = "double[]";
+    private static final String TYPE_CHAR = "char";
+    private static final String TYPE_CHAR_ARRAY = "char[]";
+    private static final String TYPE_STRING = "string";
+    private static final String TYPE_STRING_LIST = "stringList";
+    private static final String TYPE_ENUM = "enum";
+
+    private String cacheKey;
+    private SharedPreferences cache;
+
+    /**
+     * Creates a default {@link SharedPreferencesTokenCachingStrategy SharedPreferencesTokenCachingStrategy}
+     * instance that provides access to a single set of token information.
+     *
+     * @param context
+     *              The Context object to use to get the SharedPreferences object.
+     *
+     * @throws NullPointerException if the passed in Context is null
+     */
+    public SharedPreferencesTokenCachingStrategy(Context context) {
+        this(context, null);
+    }
+
+    /**
+     * Creates a {@link SharedPreferencesTokenCachingStrategy SharedPreferencesTokenCachingStrategy} instance
+     * that is distinct for the passed in cacheKey.
+     *
+     * @param context
+     *              The Context object to use to get the SharedPreferences object.
+     *
+     * @param cacheKey
+     *              Identifies a distinct set of token information.
+     *
+     * @throws NullPointerException if the passed in Context is null
+     */
+    public SharedPreferencesTokenCachingStrategy(Context context, String cacheKey) {
+        Validate.notNull(context, "context");
+
+        this.cacheKey = Utility.isNullOrEmpty(cacheKey) ? DEFAULT_CACHE_KEY : cacheKey;
+
+        // If the application context is available, use that. However, if it isn't
+        // available (possibly because of a context that was created manually), use
+        // the passed in context directly.
+        Context applicationContext = context.getApplicationContext();
+        context = applicationContext != null ? applicationContext : context;
+
+        this.cache = context.getSharedPreferences(
+                this.cacheKey,
+                Context.MODE_PRIVATE);
+    }
+
+    /**
+     * Returns a Bundle that contains the information stored in this cache
+     *
+     * @return A Bundle with the information contained in this cache
+     */
+    public Bundle load() {
+        Bundle settings = new Bundle();
+
+        Map<String, ?> allCachedEntries = cache.getAll();
+
+        for (String key : allCachedEntries.keySet()) {
+            try {
+                deserializeKey(key, settings);
+            } catch (JSONException e) {
+                // Error in the cache. So consider it corrupted and return null
+                Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG,
+                        "Error reading cached value for key: '" + key + "' -- " + e);
+                return null;
+            }
+        }
+
+        return settings;
+    }
+
+    /**
+     * Persists all supported data types present in the passed in Bundle, to the
+     * cache
+     *
+     * @param bundle
+     *          The Bundle containing information to be cached
+     */
+    public void save(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+
+        SharedPreferences.Editor editor = cache.edit();
+
+        for (String key : bundle.keySet()) {
+            try {
+                serializeKey(key, bundle, editor);
+            } catch (JSONException e) {
+                // Error in the bundle. Don't store a partial cache.
+                Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, "Error processing value for key: '" + key + "' -- " + e);
+
+                // Bypass the commit and just return. This cancels the entire edit transaction
+                return;
+            }
+        }
+
+        boolean successfulCommit = editor.commit();
+        if (!successfulCommit) {
+            Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, "SharedPreferences.Editor.commit() was not successful");
+        }
+    }
+
+    /**
+     * Clears out all token information stored in this cache.
+     */
+    public void clear() {
+        cache.edit().clear().commit();
+    }
+
+    private void serializeKey(String key, Bundle bundle, SharedPreferences.Editor editor)
+        throws JSONException {
+        Object value = bundle.get(key);
+        if (value == null) {
+            // Cannot serialize null values.
+            return;
+        }
+
+        String supportedType = null;
+        JSONArray jsonArray = null;
+        JSONObject json = new JSONObject();
+
+        if (value instanceof Byte) {
+            supportedType = TYPE_BYTE;
+            json.put(JSON_VALUE, ((Byte)value).intValue());
+        } else if (value instanceof Short) {
+            supportedType = TYPE_SHORT;
+            json.put(JSON_VALUE, ((Short)value).intValue());
+        } else if (value instanceof Integer) {
+            supportedType = TYPE_INTEGER;
+            json.put(JSON_VALUE, ((Integer)value).intValue());
+        } else if (value instanceof Long) {
+            supportedType = TYPE_LONG;
+            json.put(JSON_VALUE, ((Long)value).longValue());
+        } else if (value instanceof Float) {
+            supportedType = TYPE_FLOAT;
+            json.put(JSON_VALUE, ((Float)value).doubleValue());
+        } else if (value instanceof Double) {
+            supportedType = TYPE_DOUBLE;
+            json.put(JSON_VALUE, ((Double)value).doubleValue());
+        } else if (value instanceof Boolean) {
+            supportedType = TYPE_BOOLEAN;
+            json.put(JSON_VALUE, ((Boolean)value).booleanValue());
+        } else if (value instanceof Character) {
+            supportedType = TYPE_CHAR;
+            json.put(JSON_VALUE, value.toString());
+        } else if (value instanceof String) {
+            supportedType = TYPE_STRING;
+            json.put(JSON_VALUE, (String)value);
+        } else if (value instanceof Enum<?>) {
+            supportedType = TYPE_ENUM;
+            json.put(JSON_VALUE, value.toString());
+            json.put(JSON_VALUE_ENUM_TYPE, value.getClass().getName());
+        } else {
+            // Optimistically create a JSONArray. If not an array type, we can null
+            // it out later
+            jsonArray = new JSONArray();
+            if (value instanceof byte[]) {
+                supportedType = TYPE_BYTE_ARRAY;
+                for (byte v : (byte[])value) {
+                    jsonArray.put((int)v);
+                }
+            } else if (value instanceof short[]) {
+                supportedType = TYPE_SHORT_ARRAY;
+                for (short v : (short[])value) {
+                    jsonArray.put((int)v);
+                }
+            } else if (value instanceof int[]) {
+                supportedType = TYPE_INTEGER_ARRAY;
+                for (int v : (int[])value) {
+                    jsonArray.put(v);
+                }
+            } else if (value instanceof long[]) {
+                supportedType = TYPE_LONG_ARRAY;
+                for (long v : (long[])value) {
+                    jsonArray.put(v);
+                }
+            } else if (value instanceof float[]) {
+                supportedType = TYPE_FLOAT_ARRAY;
+                for (float v : (float[])value) {
+                    jsonArray.put((double)v);
+                }
+            } else if (value instanceof double[]) {
+                supportedType = TYPE_DOUBLE_ARRAY;
+                for (double v : (double[])value) {
+                    jsonArray.put(v);
+                }
+            } else if (value instanceof boolean[]) {
+                supportedType = TYPE_BOOLEAN_ARRAY;
+                for (boolean v : (boolean[])value) {
+                    jsonArray.put(v);
+                }
+            } else if (value instanceof char[]) {
+                supportedType = TYPE_CHAR_ARRAY;
+                for (char v : (char[])value) {
+                    jsonArray.put(String.valueOf(v));
+                }
+            } else if (value instanceof List<?>) {
+                supportedType = TYPE_STRING_LIST;
+                @SuppressWarnings("unchecked")
+                List<String> stringList = (List<String>)value;
+                for (String v : stringList) {
+                    jsonArray.put((v == null) ? JSONObject.NULL : v);
+                }
+            } else {
+                // Unsupported type. Clear out the array as a precaution even though
+                // it is redundant with the null supportedType.
+                jsonArray = null;
+            }
+        }
+
+        if (supportedType != null) {
+            json.put(JSON_VALUE_TYPE, supportedType);
+            if (jsonArray != null) {
+                // If we have an array, it has already been converted to JSON. So use
+                // that instead.
+                json.putOpt(JSON_VALUE, jsonArray);
+            }
+
+            String jsonString = json.toString();
+            editor.putString(key, jsonString);
+        }
+    }
+
+    private void deserializeKey(String key, Bundle bundle)
+            throws JSONException {
+        String jsonString = cache.getString(key, "{}");
+        JSONObject json = new JSONObject(jsonString);
+
+        String valueType = json.getString(JSON_VALUE_TYPE);
+
+        if (valueType.equals(TYPE_BOOLEAN)) {
+            bundle.putBoolean(key, json.getBoolean(JSON_VALUE));
+        } else if (valueType.equals(TYPE_BOOLEAN_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            boolean[] array = new boolean[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = jsonArray.getBoolean(i);
+            }
+            bundle.putBooleanArray(key, array);
+        } else if (valueType.equals(TYPE_BYTE)) {
+            bundle.putByte(key, (byte)json.getInt(JSON_VALUE));
+        } else if (valueType.equals(TYPE_BYTE_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            byte[] array = new byte[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = (byte)jsonArray.getInt(i);
+            }
+            bundle.putByteArray(key, array);
+        } else if (valueType.equals(TYPE_SHORT)) {
+            bundle.putShort(key, (short)json.getInt(JSON_VALUE));
+        } else if (valueType.equals(TYPE_SHORT_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            short[] array = new short[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = (short)jsonArray.getInt(i);
+            }
+            bundle.putShortArray(key, array);
+        } else if (valueType.equals(TYPE_INTEGER)) {
+            bundle.putInt(key, json.getInt(JSON_VALUE));
+        } else if (valueType.equals(TYPE_INTEGER_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            int[] array = new int[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = jsonArray.getInt(i);
+            }
+            bundle.putIntArray(key, array);
+        } else if (valueType.equals(TYPE_LONG)) {
+            bundle.putLong(key, json.getLong(JSON_VALUE));
+        } else if (valueType.equals(TYPE_LONG_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            long[] array = new long[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = jsonArray.getLong(i);
+            }
+            bundle.putLongArray(key, array);
+        } else if (valueType.equals(TYPE_FLOAT)) {
+            bundle.putFloat(key, (float)json.getDouble(JSON_VALUE));
+        } else if (valueType.equals(TYPE_FLOAT_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            float[] array = new float[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = (float)jsonArray.getDouble(i);
+            }
+            bundle.putFloatArray(key, array);
+        } else if (valueType.equals(TYPE_DOUBLE)) {
+            bundle.putDouble(key, json.getDouble(JSON_VALUE));
+        } else if (valueType.equals(TYPE_DOUBLE_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            double[] array = new double[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = jsonArray.getDouble(i);
+            }
+            bundle.putDoubleArray(key, array);
+        } else if (valueType.equals(TYPE_CHAR)) {
+            String charString = json.getString(JSON_VALUE);
+            if (charString != null && charString.length() == 1) {
+                bundle.putChar(key, charString.charAt(0));
+            }
+        } else if (valueType.equals(TYPE_CHAR_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            char[] array = new char[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                String charString = jsonArray.getString(i);
+                if (charString != null && charString.length() == 1) {
+                    array[i] = charString.charAt(0);
+                }
+            }
+            bundle.putCharArray(key, array);
+        } else if (valueType.equals(TYPE_STRING)) {
+            bundle.putString(key, json.getString(JSON_VALUE));
+        } else if (valueType.equals(TYPE_STRING_LIST)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            int numStrings = jsonArray.length();
+            ArrayList<String> stringList = new ArrayList<String>(numStrings);
+            for (int i = 0; i < numStrings; i++) {
+                Object jsonStringValue = jsonArray.get(i);
+                stringList.add(i, jsonStringValue == JSONObject.NULL ? null : (String)jsonStringValue);
+            }
+            bundle.putStringArrayList(key, stringList);
+        } else if (valueType.equals(TYPE_ENUM)) {
+            try {
+                String enumType = json.getString(JSON_VALUE_ENUM_TYPE);
+                @SuppressWarnings({ "unchecked", "rawtypes" })
+                Class<? extends Enum> enumClass = (Class<? extends Enum>) Class.forName(enumType);
+                @SuppressWarnings("unchecked")
+                Enum<?> enumValue = Enum.valueOf(enumClass, json.getString(JSON_VALUE));
+                bundle.putSerializable(key, enumValue);
+            } catch (ClassNotFoundException e) {
+            } catch (IllegalArgumentException e) {
+            }
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/TestSession.java b/facebook/src/com/facebook/TestSession.java
new file mode 100644
index 000000000..0c6651812
--- /dev/null
+++ b/facebook/src/com/facebook/TestSession.java
@@ -0,0 +1,516 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.text.TextUtils;
+import android.util.Log;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphObjectList;
+import com.facebook.internal.Logger;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.*;
+
+/**
+ * Implements an subclass of Session that knows about test users for a particular
+ * application. This should never be used from a real application, but may be useful
+ * for writing unit tests, etc.
+ * <p/>
+ * Facebook allows developers to create test accounts for testing their applications'
+ * Facebook integration (see https://developers.facebook.com/docs/test_users/). This class
+ * simplifies use of these accounts for writing unit tests. It is not designed for use in
+ * production application code.
+ * <p/>
+ * The main use case for this class is using {@link #createSessionWithPrivateUser(android.app.Activity, java.util.List)}
+ * or {@link #createSessionWithSharedUser(android.app.Activity, java.util.List)}
+ * to create a session for a test user. Two modes are supported. In "shared" mode, an attempt
+ * is made to find an existing test user that has the required permissions. If no such user is available,
+ * a new one is created with the required permissions. In "private" mode, designed for
+ * scenarios which require a new user in a known clean state, a new test user will always be
+ * created, and it will be automatically deleted when the TestSession is closed. The session
+ * obeys the same lifecycle as a regular Session, meaning it must be opened after creation before
+ * it can be used to make calls to the Facebook API.
+ * <p/>
+ * Prior to creating a TestSession, two static methods must be called to initialize the
+ * application ID and application Secret to be used for managing test users. These methods are
+ * {@link #setTestApplicationId(String)} and {@link #setTestApplicationSecret(String)}.
+ * <p/>
+ * Note that the shared test user functionality depends on a naming convention for the test users.
+ * It is important that any testing of functionality which will mutate the permissions for a
+ * test user NOT use a shared test user, or this scheme will break down. If a shared test user
+ * seems to be in an invalid state, it can be deleted manually via the Web interface at
+ * https://developers.facebook.com/apps/APP_ID/permissions?role=test+users.
+ */
+public class TestSession extends Session {
+    private static final long serialVersionUID = 1L;
+
+    private enum Mode {
+        PRIVATE, SHARED
+    }
+
+    private static final String LOG_TAG = Logger.LOG_TAG_BASE + "TestSession";
+
+    private static Map<String, TestAccount> appTestAccounts;
+    private static String testApplicationSecret;
+    private static String testApplicationId;
+
+    private final String sessionUniqueUserTag;
+    private final List<String> requestedPermissions;
+    private final Mode mode;
+    private String testAccountId;
+
+    private boolean wasAskedToExtendAccessToken;
+
+    TestSession(Activity activity, List<String> permissions, TokenCachingStrategy tokenCachingStrategy,
+            String sessionUniqueUserTag, Mode mode) {
+        super(activity, TestSession.testApplicationId, tokenCachingStrategy);
+
+        Validate.notNull(permissions, "permissions");
+
+        // Validate these as if they were arguments even though they are statics.
+        Validate.notNullOrEmpty(testApplicationId, "testApplicationId");
+        Validate.notNullOrEmpty(testApplicationSecret, "testApplicationSecret");
+
+        this.sessionUniqueUserTag = sessionUniqueUserTag;
+        this.mode = mode;
+        this.requestedPermissions = permissions;
+    }
+
+    /**
+     * Constructs a TestSession which creates a test user on open, and destroys the user on
+     * close; This method should not be used in application code -- but is useful for creating unit tests
+     * that use the Facebook SDK.
+     *
+     * @param activity    the Activity to use for opening the session
+     * @param permissions list of strings containing permissions to request; nil will result in
+     *                    a common set of permissions (email, publish_actions) being requested
+     * @return a new TestSession that is in the CREATED state, ready to be opened
+     */
+    public static TestSession createSessionWithPrivateUser(Activity activity, List<String> permissions) {
+        return createTestSession(activity, permissions, Mode.PRIVATE, null);
+    }
+
+    /**
+     * Constructs a TestSession which uses a shared test user with the right permissions,
+     * creating one if necessary on open (but not deleting it on close, so it can be re-used in later
+     * tests).
+     * <p/>
+     * This method should not be used in application code -- but is useful for creating unit tests
+     * that use the Facebook SDK.
+     *
+     * @param activity    the Activity to use for opening the session
+     * @param permissions list of strings containing permissions to request; nil will result in
+     *                    a common set of permissions (email, publish_actions) being requested
+     * @return a new TestSession that is in the CREATED state, ready to be opened
+     */
+    public static TestSession createSessionWithSharedUser(Activity activity, List<String> permissions) {
+        return createSessionWithSharedUser(activity, permissions, null);
+    }
+
+    /**
+     * Constructs a TestSession which uses a shared test user with the right permissions,
+     * creating one if necessary on open (but not deleting it on close, so it can be re-used in later
+     * tests).
+     * <p/>
+     * This method should not be used in application code -- but is useful for creating unit tests
+     * that use the Facebook SDK.
+     *
+     * @param activity             the Activity to use for opening the session
+     * @param permissions          list of strings containing permissions to request; nil will result in
+     *                             a common set of permissions (email, publish_actions) being requested
+     * @param sessionUniqueUserTag a string which will be used to make this user unique among other
+     *                             users with the same permissions. Useful for tests which require two or more users to interact
+     *                             with each other, and which therefore must have sessions associated with different users.
+     * @return a new TestSession that is in the CREATED state, ready to be opened
+     */
+    public static TestSession createSessionWithSharedUser(Activity activity, List<String> permissions,
+            String sessionUniqueUserTag) {
+        return createTestSession(activity, permissions, Mode.SHARED, sessionUniqueUserTag);
+    }
+
+    /**
+     * Gets the Facebook Application ID for the application under test.
+     *
+     * @return the application ID
+     */
+    public static synchronized String getTestApplicationId() {
+        return testApplicationId;
+    }
+
+    /**
+     * Sets the Facebook Application ID for the application under test. This must be specified
+     * prior to creating a TestSession.
+     *
+     * @param applicationId the application ID
+     */
+    public static synchronized void setTestApplicationId(String applicationId) {
+        if (testApplicationId != null && !testApplicationId.equals(applicationId)) {
+            throw new FacebookException("Can't have more than one test application ID");
+        }
+        testApplicationId = applicationId;
+    }
+
+    /**
+     * Gets the Facebook Application Secret for the application under test.
+     *
+     * @return the application secret
+     */
+    public static synchronized String getTestApplicationSecret() {
+        return testApplicationSecret;
+    }
+
+    /**
+     * Sets the Facebook Application Secret for the application under test. This must be specified
+     * prior to creating a TestSession.
+     *
+     * @param applicationSecret the application secret
+     */
+    public static synchronized void setTestApplicationSecret(String applicationSecret) {
+        if (testApplicationSecret != null && !testApplicationSecret.equals(applicationSecret)) {
+            throw new FacebookException("Can't have more than one test application secret");
+        }
+        testApplicationSecret = applicationSecret;
+    }
+
+    /**
+     * Gets the ID of the test user that this TestSession is authenticated as.
+     *
+     * @return the Facebook user ID of the test user
+     */
+    public final String getTestUserId() {
+        return testAccountId;
+    }
+
+    private static synchronized TestSession createTestSession(Activity activity, List<String> permissions, Mode mode,
+            String sessionUniqueUserTag) {
+        if (Utility.isNullOrEmpty(testApplicationId) || Utility.isNullOrEmpty(testApplicationSecret)) {
+            throw new FacebookException("Must provide app ID and secret");
+        }
+
+        if (Utility.isNullOrEmpty(permissions)) {
+            permissions = Arrays.asList("email", "publish_actions");
+        }
+
+        return new TestSession(activity, permissions, new TestTokenCachingStrategy(), sessionUniqueUserTag,
+                mode);
+    }
+
+    private static synchronized void retrieveTestAccountsForAppIfNeeded() {
+        if (appTestAccounts != null) {
+            return;
+        }
+
+        appTestAccounts = new HashMap<String, TestAccount>();
+
+        // The data we need is split across two different FQL tables. We construct two queries, submit them
+        // together (the second one refers to the first one), then cross-reference the results.
+
+        // Get the test accounts for this app.
+        String testAccountQuery = String.format("SELECT id,access_token FROM test_account WHERE app_id = %s",
+                testApplicationId);
+        // Get the user names for those accounts.
+        String userQuery = "SELECT uid,name FROM user WHERE uid IN (SELECT id FROM #test_accounts)";
+
+        Bundle parameters = new Bundle();
+
+        // Build a JSON string that contains our queries and pass it as the 'q' parameter of the query.
+        JSONObject multiquery;
+        try {
+            multiquery = new JSONObject();
+            multiquery.put("test_accounts", testAccountQuery);
+            multiquery.put("users", userQuery);
+        } catch (JSONException exception) {
+            throw new FacebookException(exception);
+        }
+        parameters.putString("q", multiquery.toString());
+
+        // We need to authenticate as this app.
+        parameters.putString("access_token", getAppAccessToken());
+
+        Request request = new Request(null, "fql", parameters, null);
+        Response response = request.executeAndWait();
+
+        if (response.getError() != null) {
+            throw response.getError().getException();
+        }
+
+        FqlResponse fqlResponse = response.getGraphObjectAs(FqlResponse.class);
+
+        GraphObjectList<FqlResult> fqlResults = fqlResponse.getData();
+        if (fqlResults == null || fqlResults.size() != 2) {
+            throw new FacebookException("Unexpected number of results from FQL query");
+        }
+
+        // We get back two sets of results. The first is from the test_accounts query, the second from the users query.
+        Collection<TestAccount> testAccounts = fqlResults.get(0).getFqlResultSet().castToListOf(TestAccount.class);
+        Collection<UserAccount> userAccounts = fqlResults.get(1).getFqlResultSet().castToListOf(UserAccount.class);
+
+        // Use both sets of results to populate our static array of accounts.
+        populateTestAccounts(testAccounts, userAccounts);
+
+        return;
+    }
+
+    private static synchronized void populateTestAccounts(Collection<TestAccount> testAccounts,
+            Collection<UserAccount> userAccounts) {
+        // We get different sets of data from each of these queries. We want to combine them into a single data
+        // structure. We have added a Name property to the TestAccount interface, even though we don't really get
+        // a name back from the service from that query. We stick the Name from the corresponding UserAccount in it.
+        for (TestAccount testAccount : testAccounts) {
+            storeTestAccount(testAccount);
+        }
+
+        for (UserAccount userAccount : userAccounts) {
+            TestAccount testAccount = appTestAccounts.get(userAccount.getUid());
+            if (testAccount != null) {
+                testAccount.setName(userAccount.getName());
+            }
+        }
+    }
+
+    private static synchronized void storeTestAccount(TestAccount testAccount) {
+        appTestAccounts.put(testAccount.getId(), testAccount);
+    }
+
+    private static synchronized TestAccount findTestAccountMatchingIdentifier(String identifier) {
+        retrieveTestAccountsForAppIfNeeded();
+
+        for (TestAccount testAccount : appTestAccounts.values()) {
+            if (testAccount.getName().contains(identifier)) {
+                return testAccount;
+            }
+        }
+        return null;
+    }
+
+    @Override
+    public final String toString() {
+        String superString = super.toString();
+
+        return new StringBuilder().append("{TestSession").append(" testUserId:").append(testAccountId)
+                .append(" ").append(superString).append("}").toString();
+    }
+
+    @Override
+    void authorize(AuthorizationRequest request) {
+        if (mode == Mode.PRIVATE) {
+            createTestAccountAndFinishAuth();
+        } else {
+            findOrCreateSharedTestAccount();
+        }
+    }
+
+    @Override
+    void postStateChange(final SessionState oldState, final SessionState newState, final Exception error) {
+        // Make sure this doesn't get overwritten.
+        String id = testAccountId;
+
+        super.postStateChange(oldState, newState, error);
+
+        if (newState.isClosed() && id != null && mode == Mode.PRIVATE) {
+            deleteTestAccount(id, getAppAccessToken());
+        }
+    }
+
+    boolean getWasAskedToExtendAccessToken() {
+        return wasAskedToExtendAccessToken;
+    }
+
+    void forceExtendAccessToken(boolean forceExtendAccessToken) {
+        AccessToken currentToken = getTokenInfo();
+        setTokenInfo(
+                new AccessToken(currentToken.getToken(), new Date(), currentToken.getPermissions(),
+                        AccessTokenSource.TEST_USER, new Date(0)));
+        setLastAttemptedTokenExtendDate(new Date(0));
+    }
+
+    @Override
+    boolean shouldExtendAccessToken() {
+        boolean result = super.shouldExtendAccessToken();
+        wasAskedToExtendAccessToken = false;
+        return result;
+    }
+
+    @Override
+    void extendAccessToken() {
+        wasAskedToExtendAccessToken = true;
+        super.extendAccessToken();
+    }
+
+    void fakeTokenRefreshAttempt() {
+        setCurrentTokenRefreshRequest(new TokenRefreshRequest());
+    }
+
+    static final String getAppAccessToken() {
+        return testApplicationId + "|" + testApplicationSecret;
+    }
+
+    private void findOrCreateSharedTestAccount() {
+        TestAccount testAccount = findTestAccountMatchingIdentifier(getSharedTestAccountIdentifier());
+        if (testAccount != null) {
+            finishAuthWithTestAccount(testAccount);
+        } else {
+            createTestAccountAndFinishAuth();
+        }
+    }
+
+    private void finishAuthWithTestAccount(TestAccount testAccount) {
+        testAccountId = testAccount.getId();
+
+        AccessToken accessToken = AccessToken.createFromString(testAccount.getAccessToken(), requestedPermissions,
+                AccessTokenSource.TEST_USER);
+        finishAuthOrReauth(accessToken, null);
+    }
+
+    private TestAccount createTestAccountAndFinishAuth() {
+        Bundle parameters = new Bundle();
+        parameters.putString("installed", "true");
+        parameters.putString("permissions", getPermissionsString());
+        parameters.putString("access_token", getAppAccessToken());
+
+        // If we're in shared mode, we want to rename this user to encode its permissions, so we can find it later
+        // in another shared session. If we're in private mode, don't bother renaming it since we're just going to
+        // delete it at the end of the session.
+        if (mode == Mode.SHARED) {
+            parameters.putString("name", String.format("Shared %s Testuser", getSharedTestAccountIdentifier()));
+        }
+
+        String graphPath = String.format("%s/accounts/test-users", testApplicationId);
+        Request createUserRequest = new Request(null, graphPath, parameters, HttpMethod.POST);
+        Response response = createUserRequest.executeAndWait();
+
+        FacebookRequestError error = response.getError();
+        TestAccount testAccount = response.getGraphObjectAs(TestAccount.class);
+        if (error != null) {
+            finishAuthOrReauth(null, error.getException());
+            return null;
+        } else {
+            assert testAccount != null;
+
+            // If we are in shared mode, store this new account in the dictionary so we can re-use it later.
+            if (mode == Mode.SHARED) {
+                // Remember the new name we gave it, since we didn't get it back in the results of the create request.
+                testAccount.setName(parameters.getString("name"));
+                storeTestAccount(testAccount);
+            }
+
+            finishAuthWithTestAccount(testAccount);
+
+            return testAccount;
+        }
+    }
+
+    private void deleteTestAccount(String testAccountId, String appAccessToken) {
+        Bundle parameters = new Bundle();
+        parameters.putString("access_token", appAccessToken);
+
+        Request request = new Request(null, testAccountId, parameters, HttpMethod.DELETE);
+        Response response = request.executeAndWait();
+
+        FacebookRequestError error = response.getError();
+        GraphObject graphObject = response.getGraphObject();
+        if (error != null) {
+            Log.w(LOG_TAG, String.format("Could not delete test account %s: %s", testAccountId, error.getException().toString()));
+        } else if (graphObject.getProperty(Response.NON_JSON_RESPONSE_PROPERTY) == (Boolean) false) {
+            Log.w(LOG_TAG, String.format("Could not delete test account %s: unknown reason", testAccountId));
+        }
+    }
+
+    private String getPermissionsString() {
+        return TextUtils.join(",", requestedPermissions);
+    }
+
+    private String getSharedTestAccountIdentifier() {
+        // We use long even though hashes are ints to avoid sign issues.
+        long permissionsHash = getPermissionsString().hashCode() & 0xffffffffL;
+        long sessionTagHash = (sessionUniqueUserTag != null) ? sessionUniqueUserTag.hashCode() & 0xffffffffL : 0;
+
+        long combinedHash = permissionsHash ^ sessionTagHash;
+        return validNameStringFromInteger(combinedHash);
+    }
+
+    private String validNameStringFromInteger(long i) {
+        String s = Long.toString(i);
+        StringBuilder result = new StringBuilder("Perm");
+
+        // We know each character is a digit. Convert it into a letter 'a'-'j'. Avoid repeated characters
+        //  that might make Facebook reject the name by converting every other repeated character into one
+        //  10 higher ('k'-'t').
+        char lastChar = 0;
+        for (char c : s.toCharArray()) {
+            if (c == lastChar) {
+                c += 10;
+            }
+            result.append((char) (c + 'a' - '0'));
+            lastChar = c;
+        }
+
+        return result.toString();
+    }
+
+    private interface TestAccount extends GraphObject {
+        String getId();
+
+        String getAccessToken();
+
+        // Note: We don't actually get Name from our FQL query. We fill it in by correlating with UserAccounts.
+        String getName();
+
+        void setName(String name);
+    }
+
+    private interface UserAccount extends GraphObject {
+        String getUid();
+
+        String getName();
+
+        void setName(String name);
+    }
+
+    private interface FqlResult extends GraphObject {
+        GraphObjectList<GraphObject> getFqlResultSet();
+
+    }
+
+    private interface FqlResponse extends GraphObject {
+        GraphObjectList<FqlResult> getData();
+    }
+
+    private static final class TestTokenCachingStrategy extends TokenCachingStrategy {
+        private Bundle bundle;
+
+        @Override
+        public Bundle load() {
+            return bundle;
+        }
+
+        @Override
+        public void save(Bundle value) {
+            bundle = value;
+        }
+
+        @Override
+        public void clear() {
+            bundle = null;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/TokenCachingStrategy.java b/facebook/src/com/facebook/TokenCachingStrategy.java
new file mode 100644
index 000000000..cb3271ac8
--- /dev/null
+++ b/facebook/src/com/facebook/TokenCachingStrategy.java
@@ -0,0 +1,378 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.os.Bundle;
+import com.facebook.internal.Validate;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+/**
+ * <p>
+ * A base class for implementations of a {@link Session Session} token cache.
+ * </p>
+ * <p>
+ * The Session constructor optionally takes a TokenCachingStrategy, from which it will
+ * attempt to load a cached token during construction. Also, whenever the
+ * Session updates its token, it will also save the token and associated state
+ * to the TokenCachingStrategy.
+ * </p>
+ * <p>
+ * This is the only mechanism supported for an Android service to use Session.
+ * The service can create a custom TokenCachingStrategy that returns the Session provided
+ * by an Activity through which the user logged in to Facebook.
+ * </p>
+ */
+public abstract class TokenCachingStrategy {
+    /**
+     * The key used by Session to store the token value in the Bundle during
+     * load and save.
+     */
+    public static final String TOKEN_KEY = "com.facebook.TokenCachingStrategy.Token";
+
+    /**
+     * The key used by Session to store the expiration date value in the Bundle
+     * during load and save.
+     */
+    public static final String EXPIRATION_DATE_KEY = "com.facebook.TokenCachingStrategy.ExpirationDate";
+
+    /**
+     * The key used by Session to store the last refresh date value in the
+     * Bundle during load and save.
+     */
+    public static final String LAST_REFRESH_DATE_KEY = "com.facebook.TokenCachingStrategy.LastRefreshDate";
+
+    /**
+     * The key used by Session to store the user's id value in the Bundle during
+     * load and save.
+     */
+    public static final String USER_FBID_KEY = "com.facebook.TokenCachingStrategy.UserFBID";
+
+    /**
+     * The key used by Session to store an enum indicating the source of the token
+     * in the Bundle during load and save.
+     */
+    public static final String TOKEN_SOURCE_KEY = "com.facebook.TokenCachingStrategy.AccessTokenSource";
+
+    /**
+     * The key used by Session to store the list of permissions granted by the
+     * token in the Bundle during load and save.
+     */
+    public static final String PERMISSIONS_KEY = "com.facebook.TokenCachingStrategy.Permissions";
+
+    private static final long INVALID_BUNDLE_MILLISECONDS = Long.MIN_VALUE;
+    private static final String IS_SSO_KEY = "com.facebook.TokenCachingStrategy.IsSSO";
+
+    /**
+     * Called during Session construction to get the token state. Typically this
+     * is loaded from a persistent store that was previously initialized via
+     * save.  The caller may choose to keep a reference to the returned Bundle
+     * indefinitely.  Therefore the TokenCachingStrategy should not store the returned Bundle
+     * and should return a new Bundle on every call to this method.
+     *
+     * @return A Bundle that represents the token state that was loaded.
+     */
+    public abstract Bundle load();
+
+    /**
+     * Called when a Session updates its token. This is passed a Bundle of
+     * values that should be stored durably for the purpose of being returned
+     * from a later call to load.  Some implementations may choose to store
+     * bundle beyond the scope of this call, so the caller should keep no
+     * references to the bundle to ensure that it is not modified later.
+     * 
+     * @param bundle
+     *            A Bundle that represents the token state to be saved.
+     */
+    public abstract void save(Bundle bundle);
+
+    /**
+     * Called when a Session learns its token is no longer valid or during a
+     * call to {@link Session#closeAndClearTokenInformation
+     * closeAndClearTokenInformation} to clear the durable state associated with
+     * the token.
+     */
+    public abstract void clear();
+
+    /**
+     * Returns a boolean indicating whether a Bundle contains properties that
+     * could be a valid saved token.
+     * 
+     * @param bundle
+     *            A Bundle to check for token information.
+     * @return a boolean indicating whether a Bundle contains properties that
+     *         could be a valid saved token.
+     */
+    public static boolean hasTokenInformation(Bundle bundle) {
+        if (bundle == null) {
+            return false;
+        }
+
+        String token = bundle.getString(TOKEN_KEY);
+        if ((token == null) || (token.length() == 0)) {
+            return false;
+        }
+
+        long expiresMilliseconds = bundle.getLong(EXPIRATION_DATE_KEY, 0L);
+        if (expiresMilliseconds == 0L) {
+            return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * Gets the cached token value from a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the token value was stored.
+     * @return the cached token value, or null.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static String getToken(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return bundle.getString(TOKEN_KEY);
+    }
+
+    /**
+     * Puts the token value into a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the token value should be stored.
+     * @param value
+     *            The String representing the token value, or null.
+     *
+     * @throws NullPointerException if the passed in Bundle or token value are null
+     */
+    public static void putToken(Bundle bundle, String value) {
+        Validate.notNull(bundle, "bundle");
+        Validate.notNull(value, "value");
+        bundle.putString(TOKEN_KEY, value);
+    }
+
+    /**
+     * Gets the cached expiration date from a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the expiration date was stored.
+     * @return the cached expiration date, or null.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static Date getExpirationDate(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return getDate(bundle, EXPIRATION_DATE_KEY);
+    }
+
+    /**
+     * Puts the expiration date into a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the expiration date should be stored.
+     * @param value
+     *            The Date representing the expiration date.
+     *
+     * @throws NullPointerException if the passed in Bundle or date value are null
+     */
+    public static void putExpirationDate(Bundle bundle, Date value) {
+        Validate.notNull(bundle, "bundle");
+        Validate.notNull(value, "value");
+        putDate(bundle, EXPIRATION_DATE_KEY, value);
+    }
+
+    /**
+     * Gets the cached expiration date from a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the expiration date was stored.
+     * @return the long representing the cached expiration date in milliseconds
+     *         since the epoch, or 0.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static long getExpirationMilliseconds(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return bundle.getLong(EXPIRATION_DATE_KEY);
+    }
+
+    /**
+     * Puts the expiration date into a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the expiration date should be stored.
+     * @param value
+     *            The long representing the expiration date in milliseconds
+     *            since the epoch.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static void putExpirationMilliseconds(Bundle bundle, long value) {
+        Validate.notNull(bundle, "bundle");
+        bundle.putLong(EXPIRATION_DATE_KEY, value);
+    }
+
+    /**
+     * Gets the cached list of permissions from a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the list of permissions was stored.
+     * @return the cached list of permissions.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static List<String> getPermissions(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return bundle.getStringArrayList(PERMISSIONS_KEY);
+    }
+
+    /**
+     * Puts the list of permissions into a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the list of permissions should be stored.
+     * @param value
+     *            The List&lt;String&gt; representing the list of permissions,
+     *            or null.
+     *
+     * @throws NullPointerException if the passed in Bundle or permissions list are null
+     */
+    public static void putPermissions(Bundle bundle, List<String> value) {
+        Validate.notNull(bundle, "bundle");
+        Validate.notNull(value, "value");
+
+        ArrayList<String> arrayList;
+        if (value instanceof ArrayList<?>) {
+            arrayList = (ArrayList<String>) value;
+        } else {
+            arrayList = new ArrayList<String>(value);
+        }
+        bundle.putStringArrayList(PERMISSIONS_KEY, arrayList);
+    }
+
+    /**
+     * Gets the cached enum indicating the source of the token from the Bundle.
+     *
+     * @param bundle
+     *            A Bundle in which the enum was stored.
+     * @return enum indicating the source of the token
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static AccessTokenSource getSource(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        if (bundle.containsKey(TokenCachingStrategy.TOKEN_SOURCE_KEY)) {
+            return (AccessTokenSource) bundle.getSerializable(TokenCachingStrategy.TOKEN_SOURCE_KEY);
+        } else {
+            boolean isSSO = bundle.getBoolean(TokenCachingStrategy.IS_SSO_KEY);
+            return isSSO ? AccessTokenSource.FACEBOOK_APPLICATION_WEB : AccessTokenSource.WEB_VIEW;
+        }
+    }
+    /**
+     * Puts the enum indicating the source of the token into a Bundle.
+     *
+     * @param bundle
+     *            A Bundle in which the enum should be stored.
+     * @param value
+     *            enum indicating the source of the token
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static void putSource(Bundle bundle, AccessTokenSource value) {
+        Validate.notNull(bundle, "bundle");
+        bundle.putSerializable(TOKEN_SOURCE_KEY, value);
+    }
+
+    /**
+     * Gets the cached last refresh date from a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the last refresh date was stored.
+     * @return the cached last refresh Date, or null.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static Date getLastRefreshDate(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return getDate(bundle, LAST_REFRESH_DATE_KEY);
+    }
+
+    /**
+     * Puts the last refresh date into a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the last refresh date should be stored.
+     * @param value
+     *            The Date representing the last refresh date, or null.
+     *
+     * @throws NullPointerException if the passed in Bundle or date value are null
+     */
+    public static void putLastRefreshDate(Bundle bundle, Date value) {
+        Validate.notNull(bundle, "bundle");
+        Validate.notNull(value, "value");
+        putDate(bundle, LAST_REFRESH_DATE_KEY, value);
+    }
+
+    /**
+     * Gets the cached last refresh date from a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the last refresh date was stored.
+     * @return the cached last refresh date in milliseconds since the epoch.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static long getLastRefreshMilliseconds(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return bundle.getLong(LAST_REFRESH_DATE_KEY);
+    }
+
+    /**
+     * Puts the last refresh date into a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the last refresh date should be stored.
+     * @param value
+     *            The long representing the last refresh date in milliseconds
+     *            since the epoch.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static void putLastRefreshMilliseconds(Bundle bundle, long value) {
+        Validate.notNull(bundle, "bundle");
+        bundle.putLong(LAST_REFRESH_DATE_KEY, value);
+    }
+
+    static Date getDate(Bundle bundle, String key) {
+        if (bundle == null) {
+            return null;
+        }
+
+        long n = bundle.getLong(key, INVALID_BUNDLE_MILLISECONDS);
+        if (n == INVALID_BUNDLE_MILLISECONDS) {
+            return null;
+        }
+
+        return new Date(n);
+    }
+
+    static void putDate(Bundle bundle, String key, Date date) {
+        bundle.putLong(key, date.getTime());
+    }
+}
diff --git a/facebook/src/com/facebook/UiLifecycleHelper.java b/facebook/src/com/facebook/UiLifecycleHelper.java
new file mode 100644
index 000000000..5d42267f6
--- /dev/null
+++ b/facebook/src/com/facebook/UiLifecycleHelper.java
@@ -0,0 +1,167 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.support.v4.content.LocalBroadcastManager;
+
+/**
+ * This class helps to create, automatically open (if applicable), save, and
+ * restore the Active Session in a way that is similar to Android UI lifecycles.
+ * <p>
+ * When using this class, clients MUST call all the public methods from the
+ * respective methods in either an Activity or Fragment. Failure to call all the
+ * methods can result in improperly initialized or uninitialized Sessions.
+ */
+public class UiLifecycleHelper {
+
+    private final static String ACTIVITY_NULL_MESSAGE = "activity cannot be null";
+
+    private final Activity activity;
+    private final Session.StatusCallback callback;
+    private final BroadcastReceiver receiver;
+    private final LocalBroadcastManager broadcastManager;
+
+    /**
+     * Creates a new UiLifecycleHelper.
+     *
+     * @param activity the Activity associated with the helper. If calling from a Fragment,
+     *                 use {@link android.support.v4.app.Fragment#getActivity()}
+     * @param callback the callback for Session status changes, can be null
+     */
+    public UiLifecycleHelper(Activity activity, Session.StatusCallback callback) {
+        if (activity == null) {
+            throw new IllegalArgumentException(ACTIVITY_NULL_MESSAGE);
+        }
+        this.activity = activity;
+        this.callback = callback;
+        this.receiver = new ActiveSessionBroadcastReceiver();
+        this.broadcastManager = LocalBroadcastManager.getInstance(activity);
+    }
+
+    /**
+     * To be called from an Activity or Fragment's onCreate method.
+     *
+     * @param savedInstanceState the previously saved state
+     */
+    public void onCreate(Bundle savedInstanceState) {
+        Session session = Session.getActiveSession();
+        if (session == null) {
+            if (savedInstanceState != null) {
+                session = Session.restoreSession(activity, null, callback, savedInstanceState);
+            }
+            if (session == null) {
+                session = new Session(activity);
+            }
+            Session.setActiveSession(session);
+        }
+
+        // add the broadcast receiver
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Session.ACTION_ACTIVE_SESSION_SET);
+        filter.addAction(Session.ACTION_ACTIVE_SESSION_UNSET);
+
+        // Add a broadcast receiver to listen to when the active Session
+        // is set or unset, and add/remove our callback as appropriate
+        broadcastManager.registerReceiver(receiver, filter);
+    }
+
+    /**
+     * To be called from an Activity or Fragment's onResume method.
+     */
+    public void onResume() {
+        Session session = Session.getActiveSession();
+        if (session != null) {
+            if (callback != null) {
+                session.addCallback(callback);
+            }
+            if (SessionState.CREATED_TOKEN_LOADED.equals(session.getState())) {
+                session.openForRead(null);
+            }
+        }
+
+    }
+
+    /**
+     * To be called from an Activity or Fragment's onActivityResult method.
+     *
+     * @param requestCode the request code
+     * @param resultCode the result code
+     * @param data the result data
+     */
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        Session session = Session.getActiveSession();
+        if (session != null) {
+            session.onActivityResult(activity, requestCode, resultCode, data);
+        }
+    }
+
+    /**
+     * To be called from an Activity or Fragment's onSaveInstanceState method.
+     *
+     * @param outState the bundle to save state in
+     */
+    public void onSaveInstanceState(Bundle outState) {
+        Session.saveSession(Session.getActiveSession(), outState);
+    }
+
+    /**
+     * To be called from an Activity or Fragment's onPause method.
+     */
+    public void onPause() {
+        if (callback != null) {
+            Session session = Session.getActiveSession();
+            if (session != null) {
+                session.removeCallback(callback);
+            }
+        }
+    }
+
+    /**
+     * To be called from an Activity or Fragment's onDestroy method.
+     */
+    public void onDestroy() {
+        // remove the broadcast receiver
+        broadcastManager.unregisterReceiver(receiver);
+    }
+
+    /**
+     * The BroadcastReceiver implementation that either adds or removes the callback
+     * from the active Session object as it's SET or UNSET.
+     */
+    private class ActiveSessionBroadcastReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (Session.ACTION_ACTIVE_SESSION_SET.equals(intent.getAction())) {
+                Session session = Session.getActiveSession();
+                if (session != null && callback != null) {
+                    session.addCallback(callback);
+                }
+            } else if (Session.ACTION_ACTIVE_SESSION_UNSET.equals(intent.getAction())) {
+                Session session = Session.getActiveSession();
+                if (session != null && callback != null) {
+                    session.removeCallback(callback);
+                }
+            }
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/android/AsyncFacebookRunner.java b/facebook/src/com/facebook/android/AsyncFacebookRunner.java
index be3870a1a..2420fd4b3 100644
--- a/facebook/src/com/facebook/android/AsyncFacebookRunner.java
+++ b/facebook/src/com/facebook/android/AsyncFacebookRunner.java
@@ -1,5 +1,5 @@
-/*
- * Copyright 2010 Facebook, Inc.
+/**
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,13 +16,13 @@
 
 package com.facebook.android;
 
+import android.content.Context;
+import android.os.Bundle;
+
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.net.MalformedURLException;
 
-import android.content.Context;
-import android.os.Bundle;
-
 /**
  * A sample implementation of asynchronous API requests. This class provides
  * the ability to execute API methods and have the call return immediately,
@@ -37,6 +37,8 @@
  * functionality could be built, such as rate-limiting of requests, as per
  * a specific application's needs.
  *
+ * @deprecated
+ *
  * @see RequestListener
  *        The callback interface.
  *
@@ -44,6 +46,7 @@
  *          Yariv Sadan (yariv@fb.com),
  *          Luke Shepard (lshepard@fb.com)
  */
+@Deprecated
 public class AsyncFacebookRunner {
 
     Facebook fb;
@@ -57,10 +60,12 @@ public AsyncFacebookRunner(Facebook fb) {
      * memory, clearing the browser cookies, and calling auth.expireSession
      * through the API. The application will be notified when logout is
      * complete via the callback interface.
-     *
+     * <p/>
      * Note that this method is asynchronous and the callback will be invoked
      * in a background thread; operations that affect the UI will need to be
      * posted to the UI thread or an appropriate handler.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Session} for more info.
      *
      * @param context
      *            The Android context in which the logout should be called: it
@@ -74,13 +79,14 @@ public AsyncFacebookRunner(Facebook fb) {
      *            returns to the callback. This has no effect on the request
      *            itself.
      */
+    @Deprecated
     public void logout(final Context context,
                        final RequestListener listener,
                        final Object state) {
         new Thread() {
             @Override public void run() {
                 try {
-                    String response = fb.logout(context);
+                    String response = fb.logoutImpl(context);
                     if (response.length() == 0 || response.equals("false")){
                         listener.onFacebookError(new FacebookError(
                                 "auth.expireSession failed"), state);
@@ -98,6 +104,7 @@ public void logout(final Context context,
         }.start();
     }
 
+    @Deprecated
     public void logout(final Context context, final RequestListener listener) {
         logout(context, listener, /* state */ null);
     }
@@ -106,19 +113,21 @@ public void logout(final Context context, final RequestListener listener) {
      * Make a request to Facebook's old (pre-graph) API with the given
      * parameters. One of the parameter keys must be "method" and its value
      * should be a valid REST server API method.
-     *
+     * <p/>
      * See http://developers.facebook.com/docs/reference/rest/
-     *
+     * <p/>
      * Note that this method is asynchronous and the callback will be invoked
      * in a background thread; operations that affect the UI will need to be
      * posted to the UI thread or an appropriate handler.
-     *
+     * <p/>
      * Example:
      * <code>
      *  Bundle parameters = new Bundle();
      *  parameters.putString("method", "auth.expireSession", new Listener());
      *  String response = request(parameters);
      * </code>
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
      *
      * @param parameters
      *            Key-value pairs of parameters to the request. Refer to the
@@ -131,24 +140,28 @@ public void logout(final Context context, final RequestListener listener) {
      *            returns to the callback. This has no effect on the request
      *            itself.
      */
+    @Deprecated
     public void request(Bundle parameters,
                         RequestListener listener,
                         final Object state) {
         request(null, parameters, "GET", listener, state);
     }
 
+    @Deprecated
     public void request(Bundle parameters, RequestListener listener) {
         request(null, parameters, "GET", listener, /* state */ null);
     }
 
     /**
      * Make a request to the Facebook Graph API without any parameters.
-     *
+     * <p/>
      * See http://developers.facebook.com/docs/api
-     *
+     * <p/>
      * Note that this method is asynchronous and the callback will be invoked
      * in a background thread; operations that affect the UI will need to be
      * posted to the UI thread or an appropriate handler.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
      *
      * @param graphPath
      *            Path to resource in the Facebook graph, e.g., to fetch data
@@ -162,12 +175,14 @@ public void request(Bundle parameters, RequestListener listener) {
      *            returns to the callback. This has no effect on the request
      *            itself.
      */
+    @Deprecated
     public void request(String graphPath,
                         RequestListener listener,
                         final Object state) {
         request(graphPath, new Bundle(), "GET", listener, state);
     }
 
+    @Deprecated
     public void request(String graphPath, RequestListener listener) {
         request(graphPath, new Bundle(), "GET", listener, /* state */ null);
     }
@@ -175,12 +190,14 @@ public void request(String graphPath, RequestListener listener) {
     /**
      * Make a request to the Facebook Graph API with the given string parameters
      * using an HTTP GET (default method).
-     *
+     * <p/>
      * See http://developers.facebook.com/docs/api
-     *
+     * <p/>
      * Note that this method is asynchronous and the callback will be invoked
      * in a background thread; operations that affect the UI will need to be
      * posted to the UI thread or an appropriate handler.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
      *
      * @param graphPath
      *            Path to resource in the Facebook graph, e.g., to fetch data
@@ -199,6 +216,7 @@ public void request(String graphPath, RequestListener listener) {
      *            returns to the callback. This has no effect on the request
      *            itself.
      */
+    @Deprecated
     public void request(String graphPath,
                         Bundle parameters,
                         RequestListener listener,
@@ -206,6 +224,7 @@ public void request(String graphPath,
         request(graphPath, parameters, "GET", listener, state);
     }
 
+    @Deprecated
     public void request(String graphPath,
                         Bundle parameters,
                         RequestListener listener) {
@@ -216,12 +235,14 @@ public void request(String graphPath,
      * Make a request to the Facebook Graph API with the given HTTP method and
      * string parameters. Note that binary data parameters (e.g. pictures) are
      * not yet supported by this helper function.
-     *
+     * <p/>
      * See http://developers.facebook.com/docs/api
-     *
+     * <p/>
      * Note that this method is asynchronous and the callback will be invoked
      * in a background thread; operations that affect the UI will need to be
      * posted to the UI thread or an appropriate handler.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
      *
      * @param graphPath
      *            Path to resource in the Facebook graph, e.g., to fetch data
@@ -242,6 +263,7 @@ public void request(String graphPath,
      *            returns to the callback. This has no effect on the request
      *            itself.
      */
+    @Deprecated
     public void request(final String graphPath,
                         final Bundle parameters,
                         final String httpMethod,
@@ -250,7 +272,7 @@ public void request(final String graphPath,
         new Thread() {
             @Override public void run() {
                 try {
-                    String resp = fb.request(graphPath, parameters, httpMethod);
+                    String resp = fb.requestImpl(graphPath, parameters, httpMethod);
                     listener.onComplete(resp, state);
                 } catch (FileNotFoundException e) {
                     listener.onFileNotFoundException(e, state);
@@ -265,11 +287,14 @@ public void request(final String graphPath,
 
     /**
      * Callback interface for API requests.
-     *
+     * <p/>
      * Each method includes a 'state' parameter that identifies the calling
      * request. It will be set to the value passed when originally calling the
      * request method, or null if none was passed.
+     * <p/>
+     * This interface is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
      */
+    @Deprecated
     public static interface RequestListener {
 
         /**
diff --git a/facebook/src/com/facebook/android/DialogError.java b/facebook/src/com/facebook/android/DialogError.java
index 51d06c9a1..a99c4e613 100644
--- a/facebook/src/com/facebook/android/DialogError.java
+++ b/facebook/src/com/facebook/android/DialogError.java
@@ -1,5 +1,5 @@
-/*
- * Copyright 2010 Facebook, Inc.
+/**
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,8 +18,18 @@
 
 /**
  * Encapsulation of Dialog Error.
+ * <p/>
+ * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
+ * <p/>
+ * All public members of this class are intentionally deprecated.
+ * New code should instead use
+ * {@link com.facebook.FacebookException}
+ * <p/>
+ * Adding @Deprecated to this class causes warnings in other deprecated classes
+ * that reference this one.  That is the only reason this entire class is not
+ * deprecated.
  *
- * @author ssoneff@facebook.com
+ * @devDocDeprecated
  */
 public class DialogError extends Throwable {
 
@@ -34,17 +44,20 @@
     /** The URL that the dialog was trying to load */
     private String mFailingUrl;
 
+    @Deprecated
     public DialogError(String message, int errorCode, String failingUrl) {
         super(message);
         mErrorCode = errorCode;
         mFailingUrl = failingUrl;
     }
 
-    int getErrorCode() {
+    @Deprecated
+    public int getErrorCode() {
         return mErrorCode;
     }
 
-    String getFailingUrl() {
+    @Deprecated
+    public String getFailingUrl() {
         return mFailingUrl;
     }
 
diff --git a/facebook/src/com/facebook/android/Facebook.java b/facebook/src/com/facebook/android/Facebook.java
index c01b9a8f0..2b439e7d7 100644
--- a/facebook/src/com/facebook/android/Facebook.java
+++ b/facebook/src/com/facebook/android/Facebook.java
@@ -1,5 +1,5 @@
-/*
- * Copyright 2010 Facebook, Inc.
+/**
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,50 +16,63 @@
 
 package com.facebook.android;
 
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.net.MalformedURLException;
-
 import android.Manifest;
 import android.app.Activity;
-import android.content.ActivityNotFoundException;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.ServiceConnection;
+import android.content.*;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
 import android.content.pm.ResolveInfo;
 import android.content.pm.Signature;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.IBinder;
-import android.os.Message;
-import android.os.Messenger;
-import android.os.RemoteException;
-import android.text.TextUtils;
-import android.webkit.CookieSyncManager;
+import android.net.Uri;
+import android.os.*;
+import com.facebook.*;
+import com.facebook.Session.StatusCallback;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.lang.ref.WeakReference;
+import java.net.MalformedURLException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
 
 /**
- * Main Facebook object for interacting with the Facebook developer API.
- * Provides methods to log in and log out a user, make requests using the REST
- * and Graph APIs, and start user interface interactions with the API (such as
- * pop-ups promoting for credentials, permissions, stream posts, etc.)
+ * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
+ * <p/>
+ * All public members of this class are intentionally deprecated.
+ * New code should instead use
+ * {@link Session} to manage session state,
+ * {@link Request} to make API requests, and
+ * {@link com.facebook.widget.WebDialog} to make dialog requests.
+ * <p/>
+ * Adding @Deprecated to this class causes warnings in other deprecated classes
+ * that reference this one.  That is the only reason this entire class is not
+ * deprecated.
  *
- * @author  Jim Brusstar (jimbru@facebook.com),
- *          Yariv Sadan (yariv@facebook.com),
- *          Luke Shepard (lshepard@facebook.com)
+ * @devDocDeprecated
  */
 public class Facebook {
 
     // Strings used in the authorization flow
+    @Deprecated
     public static final String REDIRECT_URI = "fbconnect://success";
+    @Deprecated
     public static final String CANCEL_URI = "fbconnect://cancel";
+    @Deprecated
     public static final String TOKEN = "access_token";
+    @Deprecated
     public static final String EXPIRES = "expires_in";
+    @Deprecated
     public static final String SINGLE_SIGN_ON_DISABLED = "service_disabled";
 
+    @Deprecated
+    public static final Uri ATTRIBUTION_ID_CONTENT_URI =
+        Uri.parse("content://com.facebook.katana.provider.AttributionIdProvider");
+    @Deprecated
+    public static final String ATTRIBUTION_ID_COLUMN_NAME = "aid";
+
+    @Deprecated
     public static final int FORCE_DIALOG_AUTH = -1;
 
     private static final String LOGIN = "oauth";
@@ -68,75 +81,86 @@
     private static final int DEFAULT_AUTH_ACTIVITY_CODE = 32665;
 
     // Facebook server endpoints: may be modified in a subclass for testing
-    protected static String DIALOG_BASE_URL =
-        "https://m.facebook.com/dialog/";
-    protected static String GRAPH_BASE_URL =
-        "https://graph.facebook.com/";
-    protected static String RESTSERVER_URL =
-        "https://api.facebook.com/restserver.php";
-
-    private String mAccessToken = null;
-    private long mLastAccessUpdate = 0;
-    private long mAccessExpires = 0;
+    @Deprecated
+    protected static String DIALOG_BASE_URL = "https://m.facebook.com/dialog/";
+    @Deprecated
+    protected static String GRAPH_BASE_URL = "https://graph.facebook.com/";
+    @Deprecated
+    protected static String RESTSERVER_URL = "https://api.facebook.com/restserver.php";
+
+    private final Object lock = new Object();
+
+    private String accessToken = null;
+    private long accessExpiresMillisecondsAfterEpoch = 0;
+    private long lastAccessUpdateMillisecondsAfterEpoch = 0;
     private String mAppId;
 
-    private Activity mAuthActivity;
-    private String[] mAuthPermissions;
-    private int mAuthActivityCode;
-    private DialogListener mAuthDialogListener;
-    
+    private Activity pendingAuthorizationActivity;
+    private String[] pendingAuthorizationPermissions;
+    private Session pendingOpeningSession;
+
+    private volatile Session session; // must synchronize this.sync to write
+    private boolean sessionInvalidated; // must synchronize this.sync to access
+    private SetterTokenCachingStrategy tokenCache;
+    private volatile Session userSetSession;
+
     // If the last time we extended the access token was more than 24 hours ago
     // we try to refresh the access token again.
     final private long REFRESH_TOKEN_BARRIER = 24L * 60L * 60L * 1000L;
 
     /**
      * Constructor for Facebook object.
-     *
+     * 
      * @param appId
-     *          Your Facebook application ID. Found at
-     *          www.facebook.com/developers/apps.php.
+     *            Your Facebook application ID. Found at
+     *            www.facebook.com/developers/apps.php.
      */
+    @Deprecated
     public Facebook(String appId) {
         if (appId == null) {
-            throw new IllegalArgumentException(
-                    "You must specify your application ID when instantiating " +
-                    "a Facebook object. See README for details.");
+            throw new IllegalArgumentException("You must specify your application ID when instantiating "
+                    + "a Facebook object. See README for details.");
         }
         mAppId = appId;
     }
 
     /**
      * Default authorize method. Grants only basic permissions.
-     *
+     * <p/>
      * See authorize() below for @params.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
      */
+    @Deprecated
     public void authorize(Activity activity, final DialogListener listener) {
-        authorize(activity, new String[] {}, DEFAULT_AUTH_ACTIVITY_CODE,
+        authorize(activity, new String[]{}, DEFAULT_AUTH_ACTIVITY_CODE, SessionLoginBehavior.SSO_WITH_FALLBACK,
                 listener);
     }
 
     /**
      * Authorize method that grants custom permissions.
-     *
+     * <p/>
      * See authorize() below for @params.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
      */
-    public void authorize(Activity activity, String[] permissions,
-            final DialogListener listener) {
-        authorize(activity, permissions, DEFAULT_AUTH_ACTIVITY_CODE, listener);
+    @Deprecated
+    public void authorize(Activity activity, String[] permissions, final DialogListener listener) {
+        authorize(activity, permissions, DEFAULT_AUTH_ACTIVITY_CODE, SessionLoginBehavior.SSO_WITH_FALLBACK, listener);
     }
 
     /**
      * Full authorize method.
-     *
+     * <p/>
      * Starts either an Activity or a dialog which prompts the user to log in to
      * Facebook and grant the requested permissions to the given application.
-     *
+     * <p/>
      * This method will, when possible, use Facebook's single sign-on for
      * Android to obtain an access token. This involves proxying a call through
      * the Facebook for Android stand-alone application, which will handle the
      * authentication flow, and return an OAuth access token for making API
      * calls.
-     *
+     * <p/>
      * Because this process will not be available for all users, if single
      * sign-on is not possible, this method will automatically fall back to the
      * OAuth 2.0 User-Agent flow. In this flow, the user credentials are handled
@@ -144,30 +168,30 @@ public void authorize(Activity activity, String[] permissions,
      * such, the dialog makes a network request and renders HTML content rather
      * than a native UI. The access token is retrieved from a redirect to a
      * special URL that the WebView handles.
-     *
+     * <p/>
      * Note that User credentials could be handled natively using the OAuth 2.0
      * Username and Password Flow, but this is not supported by this SDK.
-     *
+     * <p/>
      * See http://developers.facebook.com/docs/authentication/ and
      * http://wiki.oauth.net/OAuth-2 for more details.
-     *
+     * <p/>
      * Note that this method is asynchronous and the callback will be invoked in
      * the original calling thread (not in a background thread).
-     *
+     * <p/>
      * Also note that requests may be made to the API without calling authorize
      * first, in which case only public information is returned.
-     *
+     * <p/>
      * IMPORTANT: Note that single sign-on authentication will not function
      * correctly if you do not include a call to the authorizeCallback() method
      * in your onActivityResult() function! Please see below for more
      * information. single sign-on may be disabled by passing FORCE_DIALOG_AUTH
      * as the activityCode parameter in your call to authorize().
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
      *
      * @param activity
      *            The Android activity in which we want to display the
      *            authorization dialog.
-     * @param applicationId
-     *            The Facebook application identifier e.g. "350685531728"
      * @param permissions
      *            A list of permissions required for this application: e.g.
      *            "read_stream", "publish_stream", "offline_access", etc. see
@@ -183,133 +207,190 @@ public void authorize(Activity activity, String[] permissions,
      *            parameter. Otherwise just omit this parameter and Facebook
      *            will use a suitable default. See
      *            http://developer.android.com/reference/android/
-     *              app/Activity.html for more information.
+     *            app/Activity.html for more information.
      * @param listener
      *            Callback interface for notifying the calling application when
      *            the authentication dialog has completed, failed, or been
      *            canceled.
      */
-    public void authorize(Activity activity, String[] permissions,
-            int activityCode, final DialogListener listener) {
-
-        boolean singleSignOnStarted = false;
-
-        mAuthDialogListener = listener;
+    @Deprecated
+    public void authorize(Activity activity, String[] permissions, int activityCode, final DialogListener listener) {
+        SessionLoginBehavior behavior = (activityCode >= 0) ? SessionLoginBehavior.SSO_WITH_FALLBACK
+                : SessionLoginBehavior.SUPPRESS_SSO;
 
-        // Prefer single sign-on, where available.
-        if (activityCode >= 0) {
-            singleSignOnStarted = startSingleSignOn(activity, mAppId,
-                    permissions, activityCode);
-        }
-        // Otherwise fall back to traditional dialog.
-        if (!singleSignOnStarted) {
-            startDialogAuth(activity, permissions);
-        }
+        authorize(activity, permissions, activityCode, behavior, listener);
     }
 
     /**
-     * Internal method to handle single sign-on backend for authorize().
-     *
+     * Full authorize method.
+     * 
+     * Starts either an Activity or a dialog which prompts the user to log in to
+     * Facebook and grant the requested permissions to the given application.
+     * 
+     * This method will, when possible, use Facebook's single sign-on for
+     * Android to obtain an access token. This involves proxying a call through
+     * the Facebook for Android stand-alone application, which will handle the
+     * authentication flow, and return an OAuth access token for making API
+     * calls.
+     * 
+     * Because this process will not be available for all users, if single
+     * sign-on is not possible, this method will automatically fall back to the
+     * OAuth 2.0 User-Agent flow. In this flow, the user credentials are handled
+     * by Facebook in an embedded WebView, not by the client application. As
+     * such, the dialog makes a network request and renders HTML content rather
+     * than a native UI. The access token is retrieved from a redirect to a
+     * special URL that the WebView handles.
+     * 
+     * Note that User credentials could be handled natively using the OAuth 2.0
+     * Username and Password Flow, but this is not supported by this SDK.
+     * 
+     * See http://developers.facebook.com/docs/authentication/ and
+     * http://wiki.oauth.net/OAuth-2 for more details.
+     * 
+     * Note that this method is asynchronous and the callback will be invoked in
+     * the original calling thread (not in a background thread).
+     * 
+     * Also note that requests may be made to the API without calling authorize
+     * first, in which case only public information is returned.
+     * 
+     * IMPORTANT: Note that single sign-on authentication will not function
+     * correctly if you do not include a call to the authorizeCallback() method
+     * in your onActivityResult() function! Please see below for more
+     * information. single sign-on may be disabled by passing FORCE_DIALOG_AUTH
+     * as the activityCode parameter in your call to authorize().
+     * 
      * @param activity
-     *            The Android Activity that will parent the ProxyAuth Activity.
-     * @param applicationId
-     *            The Facebook application identifier.
+     *            The Android activity in which we want to display the
+     *            authorization dialog.
      * @param permissions
-     *            A list of permissions required for this application. If you do
-     *            not require any permissions, pass an empty String array.
+     *            A list of permissions required for this application: e.g.
+     *            "read_stream", "publish_stream", "offline_access", etc. see
+     *            http://developers.facebook.com/docs/authentication/permissions
+     *            This parameter should not be null -- if you do not require any
+     *            permissions, then pass in an empty String array.
      * @param activityCode
-     *            Activity code to uniquely identify the result Intent in the
-     *            callback.
+     *            Single sign-on requires an activity result to be called back
+     *            to the client application -- if you are waiting on other
+     *            activities to return data, pass a custom activity code here to
+     *            avoid collisions. If you would like to force the use of legacy
+     *            dialog-based authorization, pass FORCE_DIALOG_AUTH for this
+     *            parameter. Otherwise just omit this parameter and Facebook
+     *            will use a suitable default. See
+     *            http://developer.android.com/reference/android/
+     *            app/Activity.html for more information.
+     * @param behavior
+     *            The {@link SessionLoginBehavior SessionLoginBehavior} that
+     *            specifies what behaviors should be attempted during
+     *            authorization.
+     * @param listener
+     *            Callback interface for notifying the calling application when
+     *            the authentication dialog has completed, failed, or been
+     *            canceled.
      */
-    private boolean startSingleSignOn(Activity activity, String applicationId,
-            String[] permissions, int activityCode) {
-        boolean didSucceed = true;
-        Intent intent = new Intent();
+    private void authorize(Activity activity, String[] permissions, int activityCode,
+                          SessionLoginBehavior behavior, final DialogListener listener) {
+        checkUserSession("authorize");
+        pendingOpeningSession = new Session.Builder(activity).
+                setApplicationId(mAppId).
+                setTokenCachingStrategy(getTokenCache()).
+                build();
+        pendingAuthorizationActivity = activity;
+        pendingAuthorizationPermissions = (permissions != null) ? permissions : new String[0];
+
+        StatusCallback callback = new StatusCallback() {
+            @Override
+            public void call(Session callbackSession, SessionState state, Exception exception) {
+                // Invoke user-callback.
+                onSessionCallback(callbackSession, state, exception, listener);
+            }
+        };
+
+        Session.OpenRequest openRequest = new Session.OpenRequest(activity).
+                setCallback(callback).
+                setLoginBehavior(behavior).
+                setRequestCode(activityCode).
+                setPermissions(Arrays.asList(permissions));
+        openSession(pendingOpeningSession, openRequest, pendingAuthorizationPermissions.length > 0);
+    }
 
-        intent.setClassName("com.facebook.katana",
-                "com.facebook.katana.ProxyAuth");
-        intent.putExtra("client_id", applicationId);
-        if (permissions.length > 0) {
-            intent.putExtra("scope", TextUtils.join(",", permissions));
+    private void openSession(Session session, Session.OpenRequest openRequest, boolean isPublish) {
+        openRequest.setIsLegacy(true);
+        if (isPublish) {
+            session.openForPublish(openRequest);
+        } else {
+            session.openForRead(openRequest);
         }
+    }
 
-        // Verify that the application whose package name is
-        // com.facebook.katana.ProxyAuth
-        // has the expected FB app signature.
-        if (!validateActivityIntent(activity, intent)) {
-            return false;
-        }
+    @SuppressWarnings("deprecation")
+    private void onSessionCallback(Session callbackSession, SessionState state, Exception exception,
+            DialogListener listener) {
+        Bundle extras = callbackSession.getAuthorizationBundle();
 
-        mAuthActivity = activity;
-        mAuthPermissions = permissions;
-        mAuthActivityCode = activityCode;
-        try {
-            activity.startActivityForResult(intent, activityCode);
-        } catch (ActivityNotFoundException e) {
-            didSucceed = false;
-        }
+        if (state == SessionState.OPENED) {
+            Session sessionToClose = null;
 
-        return didSucceed;
-    }
+            synchronized (Facebook.this.lock) {
+                if (callbackSession != Facebook.this.session) {
+                    sessionToClose = Facebook.this.session;
+                    Facebook.this.session = callbackSession;
+                    Facebook.this.sessionInvalidated = false;
+                }
+            }
 
-    /**
-     * Helper to validate an activity intent by resolving and checking the
-     * provider's package signature.
-     *
-     * @param context
-     * @param intent
-     * @return true if the service intent resolution happens successfully and the
-     * 	signatures match.
-     */
-    private boolean validateActivityIntent(Context context, Intent intent) {
-        ResolveInfo resolveInfo =
-            context.getPackageManager().resolveActivity(intent, 0);
-        if (resolveInfo == null) {
-            return false;
-        }
+            if (sessionToClose != null) {
+                sessionToClose.close();
+            }
 
-        return validateAppSignatureForPackage(
-            context,
-            resolveInfo.activityInfo.packageName);
+            listener.onComplete(extras);
+        } else if (exception != null) {
+            if (exception instanceof FacebookOperationCanceledException) {
+                listener.onCancel();
+            } else if ((exception instanceof FacebookAuthorizationException) && (extras != null)
+                    && extras.containsKey(Session.WEB_VIEW_ERROR_CODE_KEY)
+                    && extras.containsKey(Session.WEB_VIEW_FAILING_URL_KEY)) {
+                DialogError error = new DialogError(exception.getMessage(),
+                        extras.getInt(Session.WEB_VIEW_ERROR_CODE_KEY),
+                        extras.getString(Session.WEB_VIEW_FAILING_URL_KEY));
+                listener.onError(error);
+            } else {
+                FacebookError error = new FacebookError(exception.getMessage());
+                listener.onFacebookError(error);
+            }
+        }
     }
 
-
     /**
      * Helper to validate a service intent by resolving and checking the
      * provider's package signature.
-     *
+     * 
      * @param context
      * @param intent
-     * @return true if the service intent resolution happens successfully and the
-     * 	signatures match.
+     * @return true if the service intent resolution happens successfully and
+     *         the signatures match.
      */
     private boolean validateServiceIntent(Context context, Intent intent) {
-        ResolveInfo resolveInfo =
-            context.getPackageManager().resolveService(intent, 0);
+        ResolveInfo resolveInfo = context.getPackageManager().resolveService(intent, 0);
         if (resolveInfo == null) {
             return false;
         }
 
-        return validateAppSignatureForPackage(
-            context,
-            resolveInfo.serviceInfo.packageName);
+        return validateAppSignatureForPackage(context, resolveInfo.serviceInfo.packageName);
     }
 
     /**
      * Query the signature for the application that would be invoked by the
      * given intent and verify that it matches the FB application's signature.
-     *
+     * 
      * @param context
      * @param packageName
      * @return true if the app's signature matches the expected signature.
      */
-    private boolean validateAppSignatureForPackage(Context context,
-        String packageName) {
+    private boolean validateAppSignatureForPackage(Context context, String packageName) {
 
         PackageInfo packageInfo;
         try {
-            packageInfo = context.getPackageManager().getPackageInfo(
-                    packageName, PackageManager.GET_SIGNATURES);
+            packageInfo = context.getPackageManager().getPackageInfo(packageName, PackageManager.GET_SIGNATURES);
         } catch (NameNotFoundException e) {
             return false;
         }
@@ -323,138 +404,30 @@ private boolean validateAppSignatureForPackage(Context context,
     }
 
     /**
-     * Internal method to handle dialog-based authentication backend for
-     * authorize().
-     *
-     * @param activity
-     *            The Android Activity that will parent the auth dialog.
-     * @param applicationId
-     *            The Facebook application identifier.
-     * @param permissions
-     *            A list of permissions required for this application. If you do
-     *            not require any permissions, pass an empty String array.
-     */
-	private void startDialogAuth(Activity activity, String[] permissions) {
-        Bundle params = new Bundle();
-        if (permissions.length > 0) {
-            params.putString("scope", TextUtils.join(",", permissions));
-        }
-        CookieSyncManager.createInstance(activity);
-        dialog(activity, LOGIN, params, new DialogListener() {
-
-            public void onComplete(Bundle values) {
-                // ensure any cookies set by the dialog are saved
-                CookieSyncManager.getInstance().sync();
-                setAccessToken(values.getString(TOKEN));
-                setAccessExpiresIn(values.getString(EXPIRES));
-                if (isSessionValid()) {
-                    Util.logd("Facebook-authorize", "Login Success! access_token="
-                            + getAccessToken() + " expires="
-                            + getAccessExpires());
-                    mAuthDialogListener.onComplete(values);
-                } else {
-                    mAuthDialogListener.onFacebookError(new FacebookError(
-                                    "Failed to receive access token."));
-                }
-            }
-
-            public void onError(DialogError error) {
-                Util.logd("Facebook-authorize", "Login failed: " + error);
-                mAuthDialogListener.onError(error);
-            }
-
-            public void onFacebookError(FacebookError error) {
-                Util.logd("Facebook-authorize", "Login failed: " + error);
-                mAuthDialogListener.onFacebookError(error);
-            }
-
-            public void onCancel() {
-                Util.logd("Facebook-authorize", "Login canceled");
-                mAuthDialogListener.onCancel();
-            }
-        });
-    }
-
-    /**
-     * IMPORTANT: This method must be invoked at the top of the calling
+     * IMPORTANT: If you are using the deprecated authorize() method,
+     * this method must be invoked at the top of the calling
      * activity's onActivityResult() function or Facebook authentication will
      * not function properly!
-     *
+     * <p/>
      * If your calling activity does not currently implement onActivityResult(),
      * you must implement it and include a call to this method if you intend to
      * use the authorize() method in this SDK.
-     *
+     * <p/>
      * For more information, see
      * http://developer.android.com/reference/android/app/
-     *   Activity.html#onActivityResult(int, int, android.content.Intent)
+     * Activity.html#onActivityResult(int, int, android.content.Intent)
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
      */
+    @Deprecated
     public void authorizeCallback(int requestCode, int resultCode, Intent data) {
-        if (requestCode == mAuthActivityCode) {
-
-            // Successfully redirected.
-            if (resultCode == Activity.RESULT_OK) {
-
-                // Check OAuth 2.0/2.10 error code.
-                String error = data.getStringExtra("error");
-                if (error == null) {
-                    error = data.getStringExtra("error_type");
-                }
-
-                // A Facebook error occurred.
-                if (error != null) {
-                    if (error.equals(SINGLE_SIGN_ON_DISABLED)
-                            || error.equals("AndroidAuthKillSwitchException")) {
-                        Util.logd("Facebook-authorize", "Hosted auth currently "
-                            + "disabled. Retrying dialog auth...");
-                        startDialogAuth(mAuthActivity, mAuthPermissions);
-                    } else if (error.equals("access_denied")
-                            || error.equals("OAuthAccessDeniedException")) {
-                        Util.logd("Facebook-authorize", "Login canceled by user.");
-                        mAuthDialogListener.onCancel();
-                    } else {
-                        String description = data.getStringExtra("error_description");
-                        if (description != null) {
-                            error = error + ":" + description;
-                        }
-                        Util.logd("Facebook-authorize", "Login failed: " + error);
-                        mAuthDialogListener.onFacebookError(
-                          new FacebookError(error));
-                    }
-
-                // No errors.
-                } else {
-                    setAccessToken(data.getStringExtra(TOKEN));
-                    setAccessExpiresIn(data.getStringExtra(EXPIRES));
-                    if (isSessionValid()) {
-                        Util.logd("Facebook-authorize",
-                                "Login Success! access_token="
-                                        + getAccessToken() + " expires="
-                                        + getAccessExpires());
-                        mAuthDialogListener.onComplete(data.getExtras());
-                    } else {
-                        mAuthDialogListener.onFacebookError(new FacebookError(
-                                        "Failed to receive access token."));
-                    }
-                }
-
-            // An error occurred before we could be redirected.
-            } else if (resultCode == Activity.RESULT_CANCELED) {
-
-                // An Android error occured.
-                if (data != null) {
-                    Util.logd("Facebook-authorize",
-                            "Login failed: " + data.getStringExtra("error"));
-                    mAuthDialogListener.onError(
-                            new DialogError(
-                                    data.getStringExtra("error"),
-                                    data.getIntExtra("error_code", -1),
-                                    data.getStringExtra("failing_url")));
-
-                // User pressed the 'back' button.
-                } else {
-                    Util.logd("Facebook-authorize", "Login canceled by user.");
-                    mAuthDialogListener.onCancel();
-                }
+        checkUserSession("authorizeCallback");
+        Session pending = this.pendingOpeningSession;
+        if (pending != null) {
+            if (pending.onActivityResult(this.pendingAuthorizationActivity, requestCode, resultCode, data)) {
+                this.pendingOpeningSession = null;
+                this.pendingAuthorizationActivity = null;
+                this.pendingAuthorizationPermissions = null;
             }
         }
     }
@@ -467,7 +440,9 @@ public void authorizeCallback(int requestCode, int resultCode, Intent data) {
      * will automatically replace the old token with a new one. Note that this
      * method is asynchronous and the callback will be invoked in the original
      * calling thread (not in a background thread).
-     * 
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
+     *
      * @param context
      *            The Android Context that will be used to bind to the Facebook
      *            RefreshToken Service
@@ -478,11 +453,12 @@ public void authorizeCallback(int requestCode, int resultCode, Intent data) {
      *            Bundle under Facebook.ACCESS_TOKEN key.
      * @return true if the binding to the RefreshToken Service was created
      */
+    @Deprecated
     public boolean extendAccessToken(Context context, ServiceListener serviceListener) {
+        checkUserSession("extendAccessToken");
         Intent intent = new Intent();
 
-        intent.setClassName("com.facebook.katana",
-                "com.facebook.katana.platform.TokenRefreshService");
+        intent.setClassName("com.facebook.katana", "com.facebook.katana.platform.TokenRefreshService");
 
         // Verify that the application whose package name is
         // com.facebook.katana
@@ -491,82 +467,57 @@ public boolean extendAccessToken(Context context, ServiceListener serviceListene
             return false;
         }
 
-        return context.bindService(intent,
-                new TokenRefreshServiceConnection(context, serviceListener),
+        return context.bindService(intent, new TokenRefreshServiceConnection(context, serviceListener),
                 Context.BIND_AUTO_CREATE);
     }
-    
+
     /**
-    * Calls extendAccessToken if shouldExtendAccessToken returns true.
-    * 
-    * @return the same value as extendAccessToken if the the token requires
-    *           refreshing, true otherwise
-    */
+     * Calls extendAccessToken if shouldExtendAccessToken returns true.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
+     *
+     * @return the same value as extendAccessToken if the the token requires
+     *         refreshing, true otherwise
+     */
+    @Deprecated
     public boolean extendAccessTokenIfNeeded(Context context, ServiceListener serviceListener) {
+        checkUserSession("extendAccessTokenIfNeeded");
         if (shouldExtendAccessToken()) {
             return extendAccessToken(context, serviceListener);
         }
         return true;
     }
-    
+
     /**
-     * Check if the access token requires refreshing. 
-     * 
-     * @return true if the last time a new token was obtained was over 24 hours ago.
+     * Check if the access token requires refreshing.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
+     *
+     * @return true if the last time a new token was obtained was over 24 hours
+     *         ago.
      */
+    @Deprecated
     public boolean shouldExtendAccessToken() {
-        return isSessionValid() &&
-                (System.currentTimeMillis() - mLastAccessUpdate >= REFRESH_TOKEN_BARRIER);
+        checkUserSession("shouldExtendAccessToken");
+        return isSessionValid()
+                && (System.currentTimeMillis() - lastAccessUpdateMillisecondsAfterEpoch >= REFRESH_TOKEN_BARRIER);
     }
-    
+
     /**
      * Handles connection to the token refresh service (this service is a part
      * of Facebook App).
      */
     private class TokenRefreshServiceConnection implements ServiceConnection {
 
-        final Messenger messageReceiver = new Messenger(new Handler() {
-            @Override
-            public void handleMessage(Message msg) {
-                String token = msg.getData().getString(TOKEN);
-                long expiresAt = msg.getData().getLong(EXPIRES) * 1000L;
-
-                // To avoid confusion we should return the expiration time in
-                // the same format as the getAccessExpires() function - that
-                // is in milliseconds.
-                Bundle resultBundle = (Bundle) msg.getData().clone();
-                resultBundle.putLong(EXPIRES, expiresAt);
-
-                if (token != null) {
-                    setAccessToken(token);
-                    setAccessExpires(expiresAt);
-                    if (serviceListener != null) {
-                        serviceListener.onComplete(resultBundle);
-                    }
-                } else if (serviceListener != null) { // extract errors only if client wants them
-                    String error = msg.getData().getString("error");
-                    if (msg.getData().containsKey("error_code")) {
-                        int errorCode = msg.getData().getInt("error_code");
-                        serviceListener.onFacebookError(new FacebookError(error, null, errorCode));
-                    } else {
-                        serviceListener.onError(new Error(error != null ? error
-                                : "Unknown service error"));
-                    }
-                }
-
-                // The refreshToken function should be called rarely,
-                // so there is no point in keeping the binding open.
-                applicationsContext.unbindService(TokenRefreshServiceConnection.this);
-            }
-        });
+        final Messenger messageReceiver = new Messenger(
+                new TokenRefreshConnectionHandler(Facebook.this, this));
 
         final ServiceListener serviceListener;
         final Context applicationsContext;
 
         Messenger messageSender = null;
 
-        public TokenRefreshServiceConnection(Context applicationsContext,
-                ServiceListener serviceListener) {
+        public TokenRefreshServiceConnection(Context applicationsContext, ServiceListener serviceListener) {
             this.applicationsContext = applicationsContext;
             this.serviceListener = serviceListener;
         }
@@ -587,7 +538,7 @@ public void onServiceDisconnected(ComponentName arg) {
 
         private void refreshToken() {
             Bundle requestData = new Bundle();
-            requestData.putString(TOKEN, mAccessToken);
+            requestData.putString(TOKEN, accessToken);
 
             Message request = Message.obtain();
             request.setData(requestData);
@@ -599,15 +550,85 @@ private void refreshToken() {
                 serviceListener.onError(new Error("Service connection error"));
             }
         }
-    };    
-    
+    }
+
+    // Creating a static Handler class to reduce the possibility of a memory leak.
+    // Handler objects for the same thread all share a common Looper object, which they post messages
+    // to and read from. As messages contain target Handler, as long as there are messages with target
+    // handler in the message queue, the handler cannot be garbage collected. If handler is not static,
+    // the instance of the containing class also cannot be garbage collected even if it is destroyed.
+    private static class TokenRefreshConnectionHandler extends Handler {
+        WeakReference<Facebook> facebookWeakReference;
+        WeakReference<TokenRefreshServiceConnection> connectionWeakReference;
+
+        TokenRefreshConnectionHandler(Facebook facebook, TokenRefreshServiceConnection connection) {
+            super();
+            facebookWeakReference = new WeakReference<Facebook>(facebook);
+            connectionWeakReference = new WeakReference<TokenRefreshServiceConnection>(connection);
+        }
+
+        @Override
+        @SuppressWarnings("deprecation")
+        public void handleMessage(Message msg) {
+            Facebook facebook = facebookWeakReference.get();
+            TokenRefreshServiceConnection connection = connectionWeakReference.get();
+            if (facebook == null || connection == null) {
+                return;
+            }
+
+            String token = msg.getData().getString(TOKEN);
+            // Legacy functions in Facebook class (and ServiceListener implementors) expect expires_in in
+            // milliseconds from epoch
+            long expiresAtMsecFromEpoch = msg.getData().getLong(EXPIRES) * 1000L;
+
+            if (token != null) {
+                facebook.setAccessToken(token);
+                facebook.setAccessExpires(expiresAtMsecFromEpoch);
+
+                Session refreshSession = facebook.session;
+                if (refreshSession != null) {
+                    // Session.internalRefreshToken expects the original bundle with expires_in in seconds from
+                    // epoch.
+                    LegacyHelper.extendTokenCompleted(refreshSession, msg.getData());
+                }
+
+                if (connection.serviceListener != null) {
+                    // To avoid confusion we should return the expiration time in
+                    // the same format as the getAccessExpires() function - that
+                    // is in milliseconds.
+                    Bundle resultBundle = (Bundle) msg.getData().clone();
+                    resultBundle.putLong(EXPIRES, expiresAtMsecFromEpoch);
+
+                    connection.serviceListener.onComplete(resultBundle);
+                }
+            } else if (connection.serviceListener != null) { // extract errors only if
+                // client wants them
+                String error = msg.getData().getString("error");
+                if (msg.getData().containsKey("error_code")) {
+                    int errorCode = msg.getData().getInt("error_code");
+                    connection.serviceListener.onFacebookError(new FacebookError(error, null, errorCode));
+                } else {
+                    connection.serviceListener.onError(new Error(error != null ? error : "Unknown service error"));
+                }
+            }
+
+            if (connection != null) {
+                // The refreshToken function should be called rarely,
+                // so there is no point in keeping the binding open.
+                connection.applicationsContext.unbindService(connection);
+            }
+        }
+    }
+
     /**
      * Invalidate the current user session by removing the access token in
      * memory, clearing the browser cookie, and calling auth.expireSession
      * through the API.
-     *
+     * <p/>
      * Note that this method blocks waiting for a network response, so do not
      * call it in a UI thread.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
      *
      * @param context
      *            The Android context in which the logout should be called: it
@@ -616,16 +637,36 @@ private void refreshToken() {
      * @throws IOException
      * @throws MalformedURLException
      * @return JSON string representation of the auth.expireSession response
-     *            ("true" if successful)
+     *         ("true" if successful)
      */
-    public String logout(Context context)
-            throws MalformedURLException, IOException {
-        Util.clearCookies(context);
+    @Deprecated
+    public String logout(Context context) throws MalformedURLException, IOException {
+        return logoutImpl(context);
+    }
+
+    String logoutImpl(Context context) throws MalformedURLException, IOException  {
+        checkUserSession("logout");
         Bundle b = new Bundle();
         b.putString("method", "auth.expireSession");
         String response = request(b);
-        setAccessToken(null);
-        setAccessExpires(0);
+
+        long currentTimeMillis = System.currentTimeMillis();
+        Session sessionToClose = null;
+
+        synchronized (this.lock) {
+            sessionToClose = session;
+
+            session = null;
+            accessToken = null;
+            accessExpiresMillisecondsAfterEpoch = 0;
+            lastAccessUpdateMillisecondsAfterEpoch = currentTimeMillis;
+            sessionInvalidated = false;
+        }
+
+        if (sessionToClose != null) {
+            sessionToClose.closeAndClearTokenInformation();
+        }
+
         return response;
     }
 
@@ -633,47 +674,50 @@ public String logout(Context context)
      * Make a request to Facebook's old (pre-graph) API with the given
      * parameters. One of the parameter keys must be "method" and its value
      * should be a valid REST server API method.
-     *
+     * <p/>
      * See http://developers.facebook.com/docs/reference/rest/
-     *
+     * <p/>
      * Note that this method blocks waiting for a network response, so do not
      * call it in a UI thread.
-     *
-     * Example:
-     * <code>
+     * <p/>
+     * Example: <code>
      *  Bundle parameters = new Bundle();
      *  parameters.putString("method", "auth.expireSession");
      *  String response = request(parameters);
      * </code>
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Request} for more info.
      *
      * @param parameters
      *            Key-value pairs of parameters to the request. Refer to the
      *            documentation: one of the parameters must be "method".
      * @throws IOException
-     *            if a network error occurs
+     *             if a network error occurs
      * @throws MalformedURLException
-     *            if accessing an invalid endpoint
+     *             if accessing an invalid endpoint
      * @throws IllegalArgumentException
-     *            if one of the parameters is not "method"
+     *             if one of the parameters is not "method"
      * @return JSON string representation of the response
      */
-    public String request(Bundle parameters)
-            throws MalformedURLException, IOException {
+    @Deprecated
+    public String request(Bundle parameters) throws MalformedURLException, IOException {
         if (!parameters.containsKey("method")) {
             throw new IllegalArgumentException("API method must be specified. "
                     + "(parameters must contain key \"method\" and value). See"
                     + " http://developers.facebook.com/docs/reference/rest/");
         }
-        return request(null, parameters, "GET");
+        return requestImpl(null, parameters, "GET");
     }
 
     /**
      * Make a request to the Facebook Graph API without any parameters.
-     *
+     * <p/>
      * See http://developers.facebook.com/docs/api
-     *
+     * <p/>
      * Note that this method blocks waiting for a network response, so do not
      * call it in a UI thread.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Request} for more info.
      *
      * @param graphPath
      *            Path to resource in the Facebook graph, e.g., to fetch data
@@ -683,19 +727,21 @@ public String request(Bundle parameters)
      * @throws MalformedURLException
      * @return JSON string representation of the response
      */
-    public String request(String graphPath)
-            throws MalformedURLException, IOException {
-        return request(graphPath, new Bundle(), "GET");
+    @Deprecated
+    public String request(String graphPath) throws MalformedURLException, IOException {
+        return requestImpl(graphPath, new Bundle(), "GET");
     }
 
     /**
      * Make a request to the Facebook Graph API with the given string parameters
      * using an HTTP GET (default method).
-     *
+     * <p/>
      * See http://developers.facebook.com/docs/api
-     *
+     * <p/>
      * Note that this method blocks waiting for a network response, so do not
      * call it in a UI thread.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Request} for more info.
      *
      * @param graphPath
      *            Path to resource in the Facebook graph, e.g., to fetch data
@@ -710,20 +756,22 @@ public String request(String graphPath)
      * @throws MalformedURLException
      * @return JSON string representation of the response
      */
-    public String request(String graphPath, Bundle parameters)
-            throws MalformedURLException, IOException {
-        return request(graphPath, parameters, "GET");
+    @Deprecated
+    public String request(String graphPath, Bundle parameters) throws MalformedURLException, IOException {
+        return requestImpl(graphPath, parameters, "GET");
     }
 
     /**
      * Synchronously make a request to the Facebook Graph API with the given
-     * HTTP method and string parameters. Note that binary data parameters
-     * (e.g. pictures) are not yet supported by this helper function.
-     *
+     * HTTP method and string parameters. Note that binary data parameters (e.g.
+     * pictures) are not yet supported by this helper function.
+     * <p/>
      * See http://developers.facebook.com/docs/api
-     *
+     * <p/>
      * Note that this method blocks waiting for a network response, so do not
      * call it in a UI thread.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Request} for more info.
      *
      * @param graphPath
      *            Path to resource in the Facebook graph, e.g., to fetch data
@@ -740,23 +788,32 @@ public String request(String graphPath, Bundle parameters)
      * @throws MalformedURLException
      * @return JSON string representation of the response
      */
-    public String request(String graphPath, Bundle params, String httpMethod)
-            throws FileNotFoundException, MalformedURLException, IOException {
+    @Deprecated
+    public String request(String graphPath, Bundle params, String httpMethod) throws FileNotFoundException,
+            MalformedURLException, IOException {
+        return requestImpl(graphPath, params, httpMethod);
+    }
+
+    // Internal call to avoid deprecated warnings.
+    @SuppressWarnings("deprecation")
+    String requestImpl(String graphPath, Bundle params, String httpMethod) throws FileNotFoundException,
+            MalformedURLException, IOException {
         params.putString("format", "json");
         if (isSessionValid()) {
             params.putString(TOKEN, getAccessToken());
         }
-        String url = (graphPath != null) ? GRAPH_BASE_URL + graphPath
-                                         : RESTSERVER_URL;
+        String url = (graphPath != null) ? GRAPH_BASE_URL + graphPath : RESTSERVER_URL;
         return Util.openUrl(url, httpMethod, params);
     }
 
     /**
      * Generate a UI dialog for the request action in the given Android context.
-     *
+     * <p/>
      * Note that this method is asynchronous and the callback will be invoked in
      * the original calling thread (not in a background thread).
      *
+     * This method is deprecated. See {@link com.facebook.widget.WebDialog}.
+     *
      * @param context
      *            The Android context in which we will generate this dialog.
      * @param action
@@ -766,18 +823,20 @@ public String request(String graphPath, Bundle params, String httpMethod)
      *            Callback interface to notify the application when the dialog
      *            has completed.
      */
-    public void dialog(Context context, String action,
-            DialogListener listener) {
+    @Deprecated
+    public void dialog(Context context, String action, DialogListener listener) {
         dialog(context, action, new Bundle(), listener);
     }
 
     /**
      * Generate a UI dialog for the request action in the given Android context
      * with the provided parameters.
-     *
+     * <p/>
      * Note that this method is asynchronous and the callback will be invoked in
      * the original calling thread (not in a background thread).
      *
+     * This method is deprecated. See {@link com.facebook.widget.WebDialog}.
+     * 
      * @param context
      *            The Android context in which we will generate this dialog.
      * @param action
@@ -788,10 +847,8 @@ public void dialog(Context context, String action,
      *            Callback interface to notify the application when the dialog
      *            has completed.
      */
-    public void dialog(Context context, String action, Bundle parameters,
-            final DialogListener listener) {
-
-        String endpoint = DIALOG_BASE_URL + action;
+    @Deprecated
+    public void dialog(Context context, String action, Bundle parameters, final DialogListener listener) {
         parameters.putString("display", "touch");
         parameters.putString("redirect_uri", REDIRECT_URI);
 
@@ -800,29 +857,127 @@ public void dialog(Context context, String action, Bundle parameters,
             parameters.putString("client_id", mAppId);
         } else {
             parameters.putString("app_id", mAppId);
+            // We do not want to add an access token when displaying the auth dialog.
             if (isSessionValid()) {
                 parameters.putString(TOKEN, getAccessToken());
             }
         }
 
-
-        String url = endpoint + "?" + Util.encodeUrl(parameters);
-        if (context.checkCallingOrSelfPermission(Manifest.permission.INTERNET)
-                != PackageManager.PERMISSION_GRANTED) {
-            Util.showAlert(context, "Error",
-                    "Application requires permission to access the Internet");
+        if (context.checkCallingOrSelfPermission(Manifest.permission.INTERNET) != PackageManager.PERMISSION_GRANTED) {
+            Util.showAlert(context, "Error", "Application requires permission to access the Internet");
         } else {
-            new FbDialog(context, url, listener).show();
+            new FbDialog(context, action, parameters, listener).show();
         }
     }
 
     /**
+     * Returns whether the current access token is valid
+     *
      * @return boolean - whether this object has an non-expired session token
      */
+    @Deprecated
     public boolean isSessionValid() {
-        return (getAccessToken() != null) &&
-                ((getAccessExpires() == 0) ||
-                        (System.currentTimeMillis() < getAccessExpires()));
+        return (getAccessToken() != null)
+                && ((getAccessExpires() == 0) || (System.currentTimeMillis() < getAccessExpires()));
+    }
+
+    /**
+     * Allows the user to set a Session for the Facebook class to use.
+     * If a Session is set here, then one should not use the authorize, logout,
+     * or extendAccessToken methods which alter the Session object since that may
+     * result in undefined behavior. Using those methods after setting the
+     * session here will result in exceptions being thrown.
+     *
+     * @param session the Session object to use, cannot be null
+     */
+    @Deprecated
+    public void setSession(Session session) {
+        if (session == null) {
+            throw new IllegalArgumentException("session cannot be null");
+        }
+        synchronized (this.lock) {
+            this.userSetSession = session;
+        }
+    }
+
+    private void checkUserSession(String methodName) {
+        if (userSetSession != null) {
+            throw new UnsupportedOperationException(
+                    String.format("Cannot call %s after setSession has been called.", methodName));
+        }
+    }
+
+    /**
+     * Get the underlying Session object to use with 3.0 api.
+     * 
+     * @return Session - underlying session
+     */
+    @Deprecated
+    public final Session getSession() {
+        while (true) {
+            String cachedToken = null;
+            Session oldSession = null;
+
+            synchronized (this.lock) {
+                if (userSetSession != null) {
+                    return userSetSession;
+                }
+                if ((session != null) || !sessionInvalidated) {
+                    return session;
+                }
+
+                cachedToken = accessToken;
+                oldSession = session;
+            }
+
+            if (cachedToken == null) {
+                return null;
+            }
+
+            // At this point we do not have a valid session, but mAccessToken is
+            // non-null.
+            // So we can try building a session based on that.
+            List<String> permissions;
+            if (oldSession != null) {
+                permissions = oldSession.getPermissions();
+            } else if (pendingAuthorizationPermissions != null) {
+                permissions = Arrays.asList(pendingAuthorizationPermissions);
+            } else {
+                permissions = Collections.<String>emptyList();
+            }
+
+            Session newSession = new Session.Builder(pendingAuthorizationActivity).
+                    setApplicationId(mAppId).
+                    setTokenCachingStrategy(getTokenCache()).
+                    build();
+            if (newSession.getState() != SessionState.CREATED_TOKEN_LOADED) {
+                return null;
+            }
+            Session.OpenRequest openRequest =
+                    new Session.OpenRequest(pendingAuthorizationActivity).setPermissions(permissions);
+            openSession(newSession, openRequest, !permissions.isEmpty());
+
+            Session invalidatedSession = null;
+            Session returnSession = null;
+
+            synchronized (this.lock) {
+                if (sessionInvalidated || (session == null)) {
+                    invalidatedSession = session;
+                    returnSession = session = newSession;
+                    sessionInvalidated = false;
+                }
+            }
+
+            if (invalidatedSession != null) {
+                invalidatedSession.close();
+            }
+
+            if (returnSession != null) {
+                return returnSession;
+            }
+            // Else token state changed between the synchronized blocks, so
+            // retry..
+        }
     }
 
     /**
@@ -831,8 +986,14 @@ public boolean isSessionValid() {
      *
      * @return String - access token
      */
+    @Deprecated
     public String getAccessToken() {
-        return mAccessToken;
+        Session s = getSession();
+        if (s != null) {
+            return s.getAccessToken();
+        } else {
+            return null;
+        }
     }
 
     /**
@@ -841,65 +1002,267 @@ public String getAccessToken() {
      *
      * @return long - session expiration time
      */
+    @Deprecated
     public long getAccessExpires() {
-        return mAccessExpires;
+        Session s = getSession();
+        if (s != null) {
+            return s.getExpirationDate().getTime();
+        } else {
+            return accessExpiresMillisecondsAfterEpoch;
+        }
+    }
+
+    /**
+     * Retrieve the last time the token was updated (in milliseconds since
+     * the Unix epoch), or 0 if the token has not been set.
+     *
+     * @return long - timestamp of the last token update.
+     */
+    @Deprecated
+    public long getLastAccessUpdate() {
+        return lastAccessUpdateMillisecondsAfterEpoch;
+    }
+
+    /**
+     * Restore the token, expiration time, and last update time from cached values.
+     * These should be values obtained from getAccessToken(), getAccessExpires, and
+     * getLastAccessUpdate() respectively.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
+     *
+     * @param accessToken - access token
+     * @param accessExpires - access token expiration time
+     * @param lastAccessUpdate - timestamp of the last token update
+     */
+    @Deprecated
+    public void setTokenFromCache(String accessToken, long accessExpires, long lastAccessUpdate) {
+        checkUserSession("setTokenFromCache");
+        synchronized (this.lock) {
+            this.accessToken = accessToken;
+            accessExpiresMillisecondsAfterEpoch = accessExpires;
+            lastAccessUpdateMillisecondsAfterEpoch = lastAccessUpdate;
+        }
     }
 
     /**
      * Set the OAuth 2.0 access token for API access.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
      *
-     * @param token - access token
+     * @param token
+     *            - access token
      */
+    @Deprecated
     public void setAccessToken(String token) {
-        mAccessToken = token;
-        mLastAccessUpdate = System.currentTimeMillis();
+        checkUserSession("setAccessToken");
+        synchronized (this.lock) {
+            accessToken = token;
+            lastAccessUpdateMillisecondsAfterEpoch = System.currentTimeMillis();
+            sessionInvalidated = true;
+        }
     }
 
     /**
      * Set the current session's expiration time (in milliseconds since Unix
      * epoch), or 0 if the session doesn't expire.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
      *
-     * @param time - timestamp in milliseconds
+     * @param timestampInMsec
+     *            - timestamp in milliseconds
      */
-    public void setAccessExpires(long time) {
-        mAccessExpires = time;
+    @Deprecated
+    public void setAccessExpires(long timestampInMsec) {
+        checkUserSession("setAccessExpires");
+        synchronized (this.lock) {
+            accessExpiresMillisecondsAfterEpoch = timestampInMsec;
+            lastAccessUpdateMillisecondsAfterEpoch = System.currentTimeMillis();
+            sessionInvalidated = true;
+        }
     }
 
     /**
      * Set the current session's duration (in seconds since Unix epoch), or "0"
      * if session doesn't expire.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
      *
-     * @param expiresIn
+     * @param expiresInSecsFromNow
      *            - duration in seconds (or 0 if the session doesn't expire)
      */
-    public void setAccessExpiresIn(String expiresIn) {
-        if (expiresIn != null) {
-            long expires = expiresIn.equals("0")
-                    ? 0
-                    : System.currentTimeMillis() + Long.parseLong(expiresIn) * 1000L;
+    @Deprecated
+    public void setAccessExpiresIn(String expiresInSecsFromNow) {
+        checkUserSession("setAccessExpiresIn");
+        if (expiresInSecsFromNow != null) {
+            long expires = expiresInSecsFromNow.equals("0") ? 0 : System.currentTimeMillis()
+                    + Long.parseLong(expiresInSecsFromNow) * 1000L;
             setAccessExpires(expires);
         }
     }
 
+    /**
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
+     *
+     * @return the String representing application ID
+     */
+    @Deprecated
     public String getAppId() {
         return mAppId;
     }
 
+    /**
+     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
+     *
+     * @param appId the String representing the application ID
+     */
+    @Deprecated
     public void setAppId(String appId) {
-        mAppId = appId;
+        checkUserSession("setAppId");
+        synchronized (this.lock) {
+            mAppId = appId;
+            sessionInvalidated = true;
+        }
+    }
+
+    private TokenCachingStrategy getTokenCache() {
+        // Intentionally not volatile/synchronized--it is okay if we race to
+        // create more than one of these.
+        if (tokenCache == null) {
+            tokenCache = new SetterTokenCachingStrategy();
+        }
+        return tokenCache;
+    }
+
+    private static String[] stringArray(List<String> list) {
+        String[] array = new String[list.size()];
+
+        if (list != null) {
+            for (int i = 0; i < array.length; i++) {
+                array[i] = list.get(i);
+            }
+        }
+
+        return array;
+    }
+
+    private static List<String> stringList(String[] array) {
+        if (array != null) {
+            return Arrays.asList(array);
+        } else {
+            return Collections.emptyList();
+        }
+    }
+
+    private class SetterTokenCachingStrategy extends TokenCachingStrategy {
+
+        @Override
+        public Bundle load() {
+            Bundle bundle = new Bundle();
+
+            if (accessToken != null) {
+                TokenCachingStrategy.putToken(bundle, accessToken);
+                TokenCachingStrategy.putExpirationMilliseconds(bundle, accessExpiresMillisecondsAfterEpoch);
+                TokenCachingStrategy.putPermissions(bundle, stringList(pendingAuthorizationPermissions));
+                TokenCachingStrategy.putSource(bundle, AccessTokenSource.WEB_VIEW);
+                TokenCachingStrategy.putLastRefreshMilliseconds(bundle, lastAccessUpdateMillisecondsAfterEpoch);
+            }
+
+            return bundle;
+        }
+
+        @Override
+        public void save(Bundle bundle) {
+            accessToken = TokenCachingStrategy.getToken(bundle);
+            accessExpiresMillisecondsAfterEpoch = TokenCachingStrategy.getExpirationMilliseconds(bundle);
+            pendingAuthorizationPermissions = stringArray(TokenCachingStrategy.getPermissions(bundle));
+            lastAccessUpdateMillisecondsAfterEpoch = TokenCachingStrategy.getLastRefreshMilliseconds(bundle);
+        }
+
+        @Override
+        public void clear() {
+            accessToken = null;
+        }
+    }
+
+    /**
+     * Get Attribution ID for app install conversion tracking.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Settings} for more info.
+     *
+     * @param contentResolver
+     * @return Attribution ID that will be used for conversion tracking. It will be null only if
+     *         the user has not installed or logged in to the Facebook app.
+     */
+    @Deprecated
+    public static String getAttributionId(ContentResolver contentResolver) {
+        return Settings.getAttributionId(contentResolver);
+    }
+
+    /**
+     * Get the auto install publish setting.  If true, an install event will be published during authorize(), unless
+     * it has occurred previously or the app does not have install attribution enabled on the application's developer
+     * config page.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Settings} for more info.
+     *
+     * @return a Boolean indicating whether installation of the app should be auto-published.
+     */
+    @Deprecated
+    public boolean getShouldAutoPublishInstall() {
+        return Settings.getShouldAutoPublishInstall();
+    }
+
+    /**
+     * Sets whether auto publishing of installs will occur.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Settings} for more info.
+     *
+     * @param value a Boolean indicating whether installation of the app should be auto-published.
+     */
+    @Deprecated
+    public void setShouldAutoPublishInstall(boolean value) {
+        Settings.setShouldAutoPublishInstall(value);
+    }
+
+    /**
+     * Manually publish install attribution to the Facebook graph.  Internally handles tracking repeat calls to prevent
+     * multiple installs being published to the graph.
+     * <p/>
+     * This method is deprecated.  See {@link Facebook} and {@link Settings} for more info.
+     *
+     * @param context the current Android context
+     * @return Always false.  Earlier versions of the API returned true if it was no longer necessary to call.
+     * Apps should ignore this value, but for compatibility we will return false to ensure repeat calls (and the
+     * underlying code will prevent duplicate network traffic).
+     */
+    @Deprecated
+    public boolean publishInstall(final Context context) {
+        Settings.publishInstallAsync(context, mAppId);
+        return false;
     }
 
     /**
      * Callback interface for dialog requests.
+     * <p/>
+     * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
+     * <p/>
+     * All public members of this class are intentionally deprecated.
+     * New code should instead use
+     * {@link com.facebook.widget.WebDialog}
+     * <p/>
+     * Adding @Deprecated to this class causes warnings in other deprecated classes
+     * that reference this one.  That is the only reason this entire class is not
+     * deprecated.
      *
+     * @devDocDeprecated
      */
     public static interface DialogListener {
 
         /**
          * Called when a dialog completes.
-         *
+         * 
          * Executed by the thread that initiated the dialog.
-         *
+         * 
          * @param values
          *            Key-value string pairs extracted from the response.
          */
@@ -907,32 +1270,44 @@ public void setAppId(String appId) {
 
         /**
          * Called when a Facebook responds to a dialog with an error.
-         *
+         * 
          * Executed by the thread that initiated the dialog.
-         *
+         * 
          */
         public void onFacebookError(FacebookError e);
 
         /**
          * Called when a dialog has an error.
-         *
+         * 
          * Executed by the thread that initiated the dialog.
-         *
+         * 
          */
         public void onError(DialogError e);
 
         /**
          * Called when a dialog is canceled by the user.
-         *
+         * 
          * Executed by the thread that initiated the dialog.
-         *
+         * 
          */
         public void onCancel();
 
     }
-    
+
     /**
      * Callback interface for service requests.
+     * <p/>
+     * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
+     * <p/>
+     * All public members of this class are intentionally deprecated.
+     * New code should instead use
+     * {@link Session} to manage session state.
+     * <p/>
+     * Adding @Deprecated to this class causes warnings in other deprecated classes
+     * that reference this one.  That is the only reason this entire class is not
+     * deprecated.
+     *
+     * @devDocDeprecated
      */
     public static interface ServiceListener {
 
@@ -956,6 +1331,7 @@ public void setAppId(String appId) {
 
     }
 
+    @Deprecated
     public static final String FB_APP_SIGNATURE =
         "30820268308201d102044a9c4610300d06092a864886f70d0101040500307a310"
         + "b3009060355040613025553310b30090603550408130243413112301006035504"
diff --git a/facebook/src/com/facebook/android/FacebookError.java b/facebook/src/com/facebook/android/FacebookError.java
index e2d7b2c85..eddad2da0 100644
--- a/facebook/src/com/facebook/android/FacebookError.java
+++ b/facebook/src/com/facebook/android/FacebookError.java
@@ -1,5 +1,5 @@
-/*
- * Copyright 2010 Facebook, Inc.
+/**
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,8 +19,18 @@
 /**
  * Encapsulation of a Facebook Error: a Facebook request that could not be
  * fulfilled.
+ * <p/>
+ * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
+ * <p/>
+ * All public members of this class are intentionally deprecated.
+ * New code should instead use
+ * {@link com.facebook.FacebookException}
+ * <p/>
+ * Adding @Deprecated to this class causes warnings in other deprecated classes
+ * that reference this one.  That is the only reason this entire class is not
+ * deprecated.
  *
- * @author ssoneff@facebook.com
+ * @devDocDeprecated
  */
 public class FacebookError extends RuntimeException {
 
@@ -29,20 +39,24 @@
     private int mErrorCode = 0;
     private String mErrorType = "none";
 
+    @Deprecated
     public FacebookError(String message) {
         super(message);
     }
 
+    @Deprecated
     public FacebookError(String message, String type, int code) {
         super(message);
         mErrorType = type;
         mErrorCode = code;
     }
 
+    @Deprecated
     public int getErrorCode() {
         return mErrorCode;
     }
 
+    @Deprecated
     public String getErrorType() {
         return mErrorType;
     }
diff --git a/facebook/src/com/facebook/android/FbDialog.java b/facebook/src/com/facebook/android/FbDialog.java
index 423ce9cde..603e69280 100644
--- a/facebook/src/com/facebook/android/FbDialog.java
+++ b/facebook/src/com/facebook/android/FbDialog.java
@@ -1,5 +1,5 @@
-/*
- * Copyright 2010 Facebook, Inc.
+/**
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,181 +16,68 @@
 
 package com.facebook.android;
 
-import android.app.Dialog;
-import android.app.ProgressDialog;
 import android.content.Context;
-import android.content.Intent;
-import android.graphics.Bitmap;
-import android.graphics.Color;
-import android.graphics.drawable.Drawable;
-import android.net.Uri;
 import android.os.Bundle;
-import android.util.Log;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.ViewGroup.LayoutParams;
-import android.view.Window;
-import android.webkit.WebView;
-import android.webkit.WebViewClient;
-import android.widget.FrameLayout;
-import android.widget.ImageView;
-import android.widget.LinearLayout;
-
+import com.facebook.*;
 import com.facebook.android.Facebook.DialogListener;
+import com.facebook.widget.WebDialog;
 
-public class FbDialog extends Dialog {
-
-    static final int FB_BLUE = 0xFF6D84B4;
-    static final float[] DIMENSIONS_DIFF_LANDSCAPE = {20, 60};
-    static final float[] DIMENSIONS_DIFF_PORTRAIT = {40, 60};
-    static final FrameLayout.LayoutParams FILL =
-        new FrameLayout.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,
-                         ViewGroup.LayoutParams.FILL_PARENT);
-    static final int MARGIN = 4;
-    static final int PADDING = 2;
-    static final String DISPLAY_STRING = "touch";
-    static final String FB_ICON = "icon.png";
-
-    private String mUrl;
+/**
+ * This class is deprecated. See {@link com.facebook.widget.WebDialog}.
+ */
+@Deprecated
+public class FbDialog extends WebDialog {
     private DialogListener mListener;
-    private ProgressDialog mSpinner;
-    private ImageView mCrossImage;
-    private WebView mWebView;
-    private FrameLayout mContent;
 
     public FbDialog(Context context, String url, DialogListener listener) {
-        super(context, android.R.style.Theme_Translucent_NoTitleBar);
-        mUrl = url;
-        mListener = listener;
+        this(context, url, listener, DEFAULT_THEME);
     }
 
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        mSpinner = new ProgressDialog(getContext());
-        mSpinner.requestWindowFeature(Window.FEATURE_NO_TITLE);
-        mSpinner.setMessage("Loading...");
-        
-        requestWindowFeature(Window.FEATURE_NO_TITLE);
-        mContent = new FrameLayout(getContext());
+    public FbDialog(Context context, String url, DialogListener listener, int theme) {
+        super(context, url, theme);
+        setDialogListener(listener);
+    }
 
-        /* Create the 'x' image, but don't add to the mContent layout yet
-         * at this point, we only need to know its drawable width and height 
-         * to place the webview
-         */
-        createCrossImage();
-        
-        /* Now we know 'x' drawable width and height, 
-         * layout the webivew and add it the mContent layout
-         */
-        int crossWidth = mCrossImage.getDrawable().getIntrinsicWidth();
-        setUpWebView(crossWidth / 2);
-        
-        /* Finally add the 'x' image to the mContent layout and
-         * add mContent to the Dialog view
-         */
-        mContent.addView(mCrossImage, new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));
-        addContentView(mContent, new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));
+    public FbDialog(Context context, String action, Bundle parameters, DialogListener listener) {
+        super(context, action, parameters, DEFAULT_THEME, null);
+        setDialogListener(listener);
     }
-    
-    private void createCrossImage() {
-        mCrossImage = new ImageView(getContext());
-        // Dismiss the dialog when user click on the 'x'
-        mCrossImage.setOnClickListener(new View.OnClickListener() {
+
+    public FbDialog(Context context, String action, Bundle parameters, DialogListener listener,
+            int theme) {
+        super(context, action, parameters, theme, null);
+        setDialogListener(listener);
+    }
+
+    private void setDialogListener(DialogListener listener) {
+        this.mListener = listener;
+        setOnCompleteListener(new OnCompleteListener() {
             @Override
-            public void onClick(View v) {
-                mListener.onCancel();
-                FbDialog.this.dismiss();
+            public void onComplete(Bundle values, FacebookException error) {
+                callDialogListener(values, error);
             }
         });
-        Drawable crossDrawable = getContext().getResources().getDrawable(R.drawable.close);
-        mCrossImage.setImageDrawable(crossDrawable);
-        /* 'x' should not be visible while webview is loading
-         * make it visible only after webview has fully loaded
-        */
-        mCrossImage.setVisibility(View.INVISIBLE);
-    }
-
-    private void setUpWebView(int margin) {
-        LinearLayout webViewContainer = new LinearLayout(getContext());
-        mWebView = new WebView(getContext());
-        mWebView.setVerticalScrollBarEnabled(false);
-        mWebView.setHorizontalScrollBarEnabled(false);
-        mWebView.setWebViewClient(new FbDialog.FbWebViewClient());
-        mWebView.getSettings().setJavaScriptEnabled(true);
-        mWebView.loadUrl(mUrl);
-        mWebView.setLayoutParams(FILL);
-        mWebView.setVisibility(View.INVISIBLE);
-        
-        webViewContainer.setPadding(margin, margin, margin, margin);
-        webViewContainer.addView(mWebView);
-        mContent.addView(webViewContainer);
     }
 
-    private class FbWebViewClient extends WebViewClient {
-
-        @Override
-        public boolean shouldOverrideUrlLoading(WebView view, String url) {
-            Util.logd("Facebook-WebView", "Redirect URL: " + url);
-            if (url.startsWith(Facebook.REDIRECT_URI)) {
-                Bundle values = Util.parseUrl(url);
-
-                String error = values.getString("error");
-                if (error == null) {
-                    error = values.getString("error_type");
-                }
-
-                if (error == null) {
-                    mListener.onComplete(values);
-                } else if (error.equals("access_denied") ||
-                           error.equals("OAuthAccessDeniedException")) {
-                    mListener.onCancel();
-                } else {
-                    mListener.onFacebookError(new FacebookError(error));
-                }
+    private void callDialogListener(Bundle values, FacebookException error) {
+        if (mListener == null) {
+            return;
+        }
 
-                FbDialog.this.dismiss();
-                return true;
-            } else if (url.startsWith(Facebook.CANCEL_URI)) {
+        if (values != null) {
+            mListener.onComplete(values);
+        } else {
+            if (error instanceof FacebookDialogException) {
+                FacebookDialogException facebookDialogException = (FacebookDialogException) error;
+                DialogError dialogError = new DialogError(facebookDialogException.getMessage(),
+                        facebookDialogException.getErrorCode(), facebookDialogException.getFailingUrl());
+                mListener.onError(dialogError);
+            } else if (error instanceof FacebookOperationCanceledException) {
                 mListener.onCancel();
-                FbDialog.this.dismiss();
-                return true;
-            } else if (url.contains(DISPLAY_STRING)) {
-                return false;
+            } else {
+                FacebookError facebookError = new FacebookError(error.getMessage());
+                mListener.onFacebookError(facebookError);
             }
-            // launch non-dialog URLs in a full browser
-            getContext().startActivity(
-                    new Intent(Intent.ACTION_VIEW, Uri.parse(url)));
-            return true;
-        }
-
-        @Override
-        public void onReceivedError(WebView view, int errorCode,
-                String description, String failingUrl) {
-            super.onReceivedError(view, errorCode, description, failingUrl);
-            mListener.onError(
-                    new DialogError(description, errorCode, failingUrl));
-            FbDialog.this.dismiss();
-        }
-
-        @Override
-        public void onPageStarted(WebView view, String url, Bitmap favicon) {
-            Util.logd("Facebook-WebView", "Webview loading URL: " + url);
-            super.onPageStarted(view, url, favicon);
-            mSpinner.show();
-        }
-
-        @Override
-        public void onPageFinished(WebView view, String url) {
-            super.onPageFinished(view, url);
-            mSpinner.dismiss();
-            /* 
-             * Once webview is fully loaded, set the mContent background to be transparent
-             * and make visible the 'x' image. 
-             */
-            mContent.setBackgroundColor(Color.TRANSPARENT);
-            mWebView.setVisibility(View.VISIBLE);
-            mCrossImage.setVisibility(View.VISIBLE);
         }
     }
 }
diff --git a/facebook/src/com/facebook/android/Util.java b/facebook/src/com/facebook/android/Util.java
index e1119347d..231c1e78c 100644
--- a/facebook/src/com/facebook/android/Util.java
+++ b/facebook/src/com/facebook/android/Util.java
@@ -1,5 +1,5 @@
-/*
- * Copyright 2010 Facebook, Inc.
+/**
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,386 +16,294 @@
 
 package com.facebook.android;
 
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.BufferedReader;
-import java.io.ByteArrayInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.net.HttpURLConnection;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.net.URLDecoder;
-import java.net.URLEncoder;
-
-import org.apache.http.client.HttpClient;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import roboguice.util.Ln;
-
 import android.app.AlertDialog.Builder;
 import android.content.Context;
-import android.content.res.AssetFileDescriptor;
-import android.net.Uri;
 import android.os.Bundle;
-import android.os.Message;
-import android.os.Parcelable;
-import android.util.Log;
-import android.webkit.CookieManager;
-import android.webkit.CookieSyncManager;
+import com.facebook.internal.Utility;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.*;
+import java.net.*;
 
 /**
  * Utility class supporting the Facebook Object.
- * 
- * @author ssoneff@facebook.com
- * 
+ * <p/>
+ * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
+ * <p/>
+ * All public members of this class are intentionally deprecated.
+ * New code should instead use
+ * {@link com.facebook.Request}
+ * <p/>
+ * Adding @Deprecated to this class causes warnings in other deprecated classes
+ * that reference this one.  That is the only reason this entire class is not
+ * deprecated.
+ *
+ * @devDocDeprecated
  */
 public final class Util {
-	public static final String TAG = Util.class.getSimpleName();
-	
-
-	/**
-	 * Set this to true to enable log output. Remember to turn this back off
-	 * before releasing. Sending sensitive data to log is a security risk.
-	 */
-	private static boolean ENABLE_LOG = false;
-
-	public static UploadContext handler;
-
-	/**
-	 * Generate the multi-part post body providing the parameters and boundary
-	 * string
-	 * 
-	 * @param parameters
-	 *            the parameters need to be posted
-	 * @param boundary
-	 *            the random string as boundary
-	 * @return a string of the post body
-	 */
-	public static String encodePostBody(Bundle parameters, String boundary) {
-		if (parameters == null)
-			return "";
-		StringBuilder sb = new StringBuilder();
-
-		for (String key : parameters.keySet()) {
-			Object parameter = parameters.get(key);
-			if (!(parameter instanceof String)) {
-				continue;
-			}
-
-			sb.append("Content-Disposition: form-data; name=\"" + key + "\"\r\n\r\n" + (String) parameter);
-			sb.append("\r\n" + "--" + boundary + "\r\n");
-		}
-
-		return sb.toString();
-	}
-
-	public static String encodeUrl(Bundle parameters) {
-		if (parameters == null) {
-			return "";
-		}
-
-		StringBuilder sb = new StringBuilder();
-		boolean first = true;
-		for (String key : parameters.keySet()) {
-			Object parameter = parameters.get(key);
-			if (!(parameter instanceof String)) {
-				continue;
-			}
-
-			if (first)
-				first = false;
-			else
-				sb.append("&");
-			sb.append(URLEncoder.encode(key) + "=" + URLEncoder.encode(parameters.getString(key)));
-		}
-		return sb.toString();
-	}
-
-	public static Bundle decodeUrl(String s) {
-		Bundle params = new Bundle();
-		if (s != null) {
-			String array[] = s.split("&");
-			for (String parameter : array) {
-				String v[] = parameter.split("=");
-				if (v.length == 2) {
-					params.putString(URLDecoder.decode(v[0]), URLDecoder.decode(v[1]));
-				}
-			}
-		}
-		return params;
-	}
-
-	/**
-	 * Parse a URL query and fragment parameters into a key-value bundle.
-	 * 
-	 * @param url
-	 *            the URL to parse
-	 * @return a dictionary bundle of keys and values
-	 */
-	public static Bundle parseUrl(String url) {
-		// hack to prevent MalformedURLException
-		url = url.replace("fbconnect", "http");
-		try {
-			URL u = new URL(url);
-			Bundle b = decodeUrl(u.getQuery());
-			b.putAll(decodeUrl(u.getRef()));
-			return b;
-		} catch (MalformedURLException e) {
-			return new Bundle();
-		}
-	}
-
-	/**
-	 * Connect to an HTTP URL and return the response as a string.
-	 * 
-	 * Note that the HTTP method override is used on non-GET requests. (i.e.
-	 * requests are made as "POST" with method specified in the body).
-	 * 
-	 * @param url
-	 *            - the resource to open: must be a welformed URL
-	 * @param method
-	 *            - the HTTP method to use ("GET", "POST", etc.)
-	 * @param params
-	 *            - the query parameter for the URL (e.g. access_token=foo)
-	 * @return the URL contents as a String
-	 * @throws MalformedURLException
-	 *             - if the URL format is invalid
-	 * @throws IOException
-	 *             - if a network problem occurs
-	 */
-	public static String openUrl(String url, String method, Bundle params) throws MalformedURLException, IOException {
-		// random string as boundary for multi-part http post
-		String strBoundary = "3i2ndDfv2rTHiSisAbouNdArYfORhtTPEefj3q2f";
-		String endLine = "\r\n";
-
-		OutputStream os;
-
-		if (method.equals("GET")) {
-			url = url + "?" + encodeUrl(params);
-		}
-		Util.logd("Facebook-Util", method + " URL: " + url);
-		HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();
-		conn.setRequestProperty("User-Agent", System.getProperties().getProperty("http.agent") + " FacebookAndroidSDK");
-		if (!method.equals("GET")) {
-			Bundle dataparams = new Bundle();
-			for (String key : params.keySet()) {
-				Object parameter = params.get(key);
-				if (parameter instanceof byte[]) {
-					dataparams.putByteArray(key, (byte[]) parameter);
-				}
-				if (parameter instanceof Parcelable) {
-					dataparams.putParcelable(key, (Parcelable) parameter);
-				}
-			}
-
-			// use method override
-			if (!params.containsKey("method")) {
-				params.putString("method", method);
-			}
-
-			if (params.containsKey("access_token")) {
-				String decoded_token = URLDecoder.decode(params.getString("access_token"));
-				params.putString("access_token", decoded_token);
-			}
-
-			conn.setRequestMethod("POST");
-			conn.setRequestProperty("Content-Type", "multipart/form-data;boundary=" + strBoundary);
-			conn.setDoOutput(true);
-			conn.setDoInput(true);
-			conn.setRequestProperty("Connection", "Keep-Alive");
-			conn.setChunkedStreamingMode(0);
-			conn.connect();
-			os = new BufferedOutputStream(conn.getOutputStream());
-
-			os.write(("--" + strBoundary + endLine).getBytes());
-			os.write((encodePostBody(params, strBoundary)).getBytes());
-			os.write((endLine + "--" + strBoundary + endLine).getBytes());
-
-			if (!dataparams.isEmpty()) {
-
-				for (String key : dataparams.keySet()) {
-					os.write(("Content-Disposition: form-data; filename=\"" + key + "\"" + endLine).getBytes());
-					os.write(("Content-Type: content/unknown" + endLine + endLine).getBytes());
-					writeWithProgress(params.getInt("what"), dataparams.get(key), os);
-					os.write((endLine + "--" + strBoundary + endLine).getBytes());
-					os.flush();
-				}
-			}
-			os.flush();
-			os.close();
-		}
-
-		String response = "";
-		try {
-			response = read(conn.getInputStream());
-		} catch (FileNotFoundException e) {
-			// Error Stream contains JSON that we can parse to a FB error
-			response = read(conn.getErrorStream());
-		}
-		conn.disconnect();
-		conn=null;
-		return response;
-	}
-
-	private static void writeWithProgress(int what, Object dataparam, OutputStream os) throws IOException {
-		if (dataparam instanceof byte[]) {
-			byte[] data = (byte[]) dataparam;
-			writeWithProgress(what, data, os);
-		} else {
-			try{
-			Uri uri = (Uri) dataparam;
-			AssetFileDescriptor fd = handler.getContext().getContentResolver().openAssetFileDescriptor(uri, "r");
-			writeWithProgress(what, (int) fd.getLength(), fd.createInputStream(), os);
-			}catch (NullPointerException npe) {//workaround when sometimes npe
-				Ln.e(npe, "Vars: handler=%s, dataparams", handler, dataparam);
-			}
-		}
-	}
-
-	/**
-	 * If {@link Util#uploadProgress} is not null the registered progress listener will be called.
-	 * 
-	 * @param data
-	 *            to be transfered
-	 * @param os
-	 *            OutputStrem to transfer too
-	 * @throws IOException
-	 */
-	private static void writeWithProgress(int what, byte[] data, OutputStream os) throws IOException {
-		InputStream is = new ByteArrayInputStream(data);
-		writeWithProgress(what, data.length, is, os);
-	}
-
-	private static void writeWithProgress(int what, int size, InputStream is, OutputStream os) throws IOException {
-		BufferedInputStream bis = new BufferedInputStream(is);
-		int bufferSize = 8192;
-		byte[] buffer = new byte[bufferSize]; // 8k
-		int done = 0;
-		int bytesRead = 0;
-		int step = size/10; //steps
-		while ((bytesRead = bis.read(buffer, 0, bufferSize)) > 0) {
-			os.write(buffer, 0, bytesRead);
-			done+=bytesRead;
-			if (handler != null && done > step ) {
-				step += step; 
-				handler.sendMessage(handler.obtainMessage(what,size,done));
-				Log.d(TAG, "Upload Progress of id: " + what + " Size: " + size + " Done: " +done);
-			}
-		}
-		if (handler != null)
-			handler.sendMessage(handler.obtainMessage(what,size,done));
-		bis.close();
-		is.close();
-	}
-
-	private static String read(InputStream in) throws IOException {
-		StringBuilder sb = new StringBuilder();
-		BufferedReader r = new BufferedReader(new InputStreamReader(in), 1000);
-		for (String line = r.readLine(); line != null; line = r.readLine()) {
-			sb.append(line);
-		}
-		in.close();
-		return sb.toString();
-	}
-
-	public static void clearCookies(Context context) {
-		// Edge case: an illegal state exception is thrown if an instance of
-		// CookieSyncManager has not be created. CookieSyncManager is normally
-		// created by a WebKit view, but this might happen if you start the
-		// app, restore saved state, and click logout before running a UI
-		// dialog in a WebView -- in which case the app crashes
-		@SuppressWarnings("unused")
-		CookieSyncManager cookieSyncMngr = CookieSyncManager.createInstance(context);
-		CookieManager cookieManager = CookieManager.getInstance();
-		cookieManager.removeAllCookie();
-	}
-
-	/**
-	 * Parse a server response into a JSON Object. This is a basic
-	 * implementation using org.json.JSONObject representation. More
-	 * sophisticated applications may wish to do their own parsing.
-	 * 
-	 * The parsed JSON is checked for a variety of error fields and
-	 * a FacebookException is thrown if an error condition is set,
-	 * populated with the error message and error type or code if
-	 * available.
-	 * 
-	 * @param response
-	 *            - string representation of the response
-	 * @return the response as a JSON Object
-	 * @throws JSONException
-	 *             - if the response is not valid JSON
-	 * @throws FacebookError
-	 *             - if an error condition is set
-	 */
-	public static JSONObject parseJson(String response) throws JSONException, FacebookError {
-		// Edge case: when sending a POST request to /[post_id]/likes
-		// the return value is 'true' or 'false'. Unfortunately
-		// these values cause the JSONObject constructor to throw
-		// an exception.
-		if (response.equals("false")) {
-			throw new FacebookError("request failed");
-		}
-		if (response.equals("true")) {
-			response = "{value : true}";
-		}
-		JSONObject json = new JSONObject(response);
-
-		// errors set by the server are not consistent
-		// they depend on the method and endpoint
-		if (json.has("error")) {
-			JSONObject error = json.getJSONObject("error");
-			throw new FacebookError(error.getString("message"), error.getString("type"), 0);
-		}
-		if (json.has("error_code") && json.has("error_msg")) {
-			throw new FacebookError(json.getString("error_msg"), "", Integer.parseInt(json.getString("error_code")));
-		}
-		if (json.has("error_code")) {
-			throw new FacebookError("request failed", "", Integer.parseInt(json.getString("error_code")));
-		}
-		if (json.has("error_msg")) {
-			throw new FacebookError(json.getString("error_msg"));
-		}
-		if (json.has("error_reason")) {
-			throw new FacebookError(json.getString("error_reason"));
-		}
-		return json;
-	}
-
-	/**
-	 * Display a simple alert dialog with the given text and title.
-	 * 
-	 * @param context
-	 *            Android context in which the dialog should be displayed
-	 * @param title
-	 *            Alert dialog title
-	 * @param text
-	 *            Alert dialog message
-	 */
-	public static void showAlert(Context context, String title, String text) {
-		Builder alertBuilder = new Builder(context);
-		alertBuilder.setTitle(title);
-		alertBuilder.setMessage(text);
-		alertBuilder.create().show();
-	}
 
-	/**
-	 * A proxy for Log.d api that kills log messages in release build. It
-	 * not recommended to send sensitive information to log output in
-	 * shipping apps.
-	 * 
-	 * @param tag
-	 * @param msg
-	 */
-	public static void logd(String tag, String msg) {
-		if (ENABLE_LOG) {
-			Log.d(tag, msg);
-		}
-	}
+    private final static String UTF8 = "UTF-8";
+
+    /**
+     * Generate the multi-part post body providing the parameters and boundary
+     * string
+     * 
+     * @param parameters the parameters need to be posted
+     * @param boundary the random string as boundary
+     * @return a string of the post body
+     */
+    @Deprecated
+    public static String encodePostBody(Bundle parameters, String boundary) {
+        if (parameters == null) return "";
+        StringBuilder sb = new StringBuilder();
+
+        for (String key : parameters.keySet()) {
+            Object parameter = parameters.get(key);
+            if (!(parameter instanceof String)) {
+                continue;
+            }
+
+            sb.append("Content-Disposition: form-data; name=\"" + key +
+                    "\"\r\n\r\n" + (String)parameter);
+            sb.append("\r\n" + "--" + boundary + "\r\n");
+        }
+
+        return sb.toString();
+    }
+
+    @Deprecated
+    public static String encodeUrl(Bundle parameters) {
+        if (parameters == null) {
+            return "";
+        }
+
+        StringBuilder sb = new StringBuilder();
+        boolean first = true;
+        for (String key : parameters.keySet()) {
+            Object parameter = parameters.get(key);
+            if (!(parameter instanceof String)) {
+                continue;
+            }
+
+            if (first) first = false; else sb.append("&");
+            sb.append(URLEncoder.encode(key) + "=" +
+                      URLEncoder.encode(parameters.getString(key)));
+        }
+        return sb.toString();
+    }
+
+    @Deprecated
+    public static Bundle decodeUrl(String s) {
+        Bundle params = new Bundle();
+        if (s != null) {
+            String array[] = s.split("&");
+            for (String parameter : array) {
+                String v[] = parameter.split("=");
+
+                try {
+                    if (v.length == 2) {
+                        params.putString(URLDecoder.decode(v[0], UTF8),
+                                         URLDecoder.decode(v[1], UTF8));
+                    } else if (v.length == 1) {
+                        params.putString(URLDecoder.decode(v[0], UTF8), "");
+                    }
+                } catch (UnsupportedEncodingException e) {
+                    // shouldn't happen
+                }
+            }
+        }
+        return params;
+    }
+
+    /**
+     * Parse a URL query and fragment parameters into a key-value bundle.
+     *
+     * @param url the URL to parse
+     * @return a dictionary bundle of keys and values
+     */
+    @Deprecated
+    public static Bundle parseUrl(String url) {
+        // hack to prevent MalformedURLException
+        url = url.replace("fbconnect", "http");
+        try {
+            URL u = new URL(url);
+            Bundle b = decodeUrl(u.getQuery());
+            b.putAll(decodeUrl(u.getRef()));
+            return b;
+        } catch (MalformedURLException e) {
+            return new Bundle();
+        }
+    }
+
+    
+    /**
+     * Connect to an HTTP URL and return the response as a string.
+     *
+     * Note that the HTTP method override is used on non-GET requests. (i.e.
+     * requests are made as "POST" with method specified in the body).
+     *
+     * @param url - the resource to open: must be a welformed URL
+     * @param method - the HTTP method to use ("GET", "POST", etc.)
+     * @param params - the query parameter for the URL (e.g. access_token=foo)
+     * @return the URL contents as a String
+     * @throws MalformedURLException - if the URL format is invalid
+     * @throws IOException - if a network problem occurs
+     */
+    @Deprecated
+    public static String openUrl(String url, String method, Bundle params)
+          throws MalformedURLException, IOException {
+        // random string as boundary for multi-part http post
+        String strBoundary = "3i2ndDfv2rTHiSisAbouNdArYfORhtTPEefj3q2f";
+        String endLine = "\r\n";
+
+        OutputStream os;
+
+        if (method.equals("GET")) {
+            url = url + "?" + encodeUrl(params);
+        }
+        Utility.logd("Facebook-Util", method + " URL: " + url);
+        HttpURLConnection conn =
+            (HttpURLConnection) new URL(url).openConnection();
+        conn.setRequestProperty("User-Agent", System.getProperties().
+                getProperty("http.agent") + " FacebookAndroidSDK");
+        if (!method.equals("GET")) {
+            Bundle dataparams = new Bundle();
+            for (String key : params.keySet()) {
+                Object parameter = params.get(key);
+                if (parameter instanceof byte[]) {
+                    dataparams.putByteArray(key, (byte[])parameter);
+                }
+            }
+
+            // use method override
+            if (!params.containsKey("method")) {
+                params.putString("method", method);
+            }
+
+            if (params.containsKey("access_token")) {
+                String decoded_token =
+                    URLDecoder.decode(params.getString("access_token"));
+                params.putString("access_token", decoded_token);
+            }
+
+            conn.setRequestMethod("POST");
+            conn.setRequestProperty(
+                    "Content-Type",
+                    "multipart/form-data;boundary="+strBoundary);
+            conn.setDoOutput(true);
+            conn.setDoInput(true);
+            conn.setRequestProperty("Connection", "Keep-Alive");
+            conn.connect();
+            os = new BufferedOutputStream(conn.getOutputStream());
+
+            os.write(("--" + strBoundary +endLine).getBytes());
+            os.write((encodePostBody(params, strBoundary)).getBytes());
+            os.write((endLine + "--" + strBoundary + endLine).getBytes());
+
+            if (!dataparams.isEmpty()) {
+
+                for (String key: dataparams.keySet()){
+                    os.write(("Content-Disposition: form-data; filename=\"" + key + "\"" + endLine).getBytes());
+                    os.write(("Content-Type: content/unknown" + endLine + endLine).getBytes());
+                    os.write(dataparams.getByteArray(key));
+                    os.write((endLine + "--" + strBoundary + endLine).getBytes());
+
+                }
+            }
+            os.flush();
+        }
+
+        String response = "";
+        try {
+            response = read(conn.getInputStream());
+        } catch (FileNotFoundException e) {
+            // Error Stream contains JSON that we can parse to a FB error
+            response = read(conn.getErrorStream());
+        }
+        return response;
+    }
+
+    @Deprecated
+    private static String read(InputStream in) throws IOException {
+        StringBuilder sb = new StringBuilder();
+        BufferedReader r = new BufferedReader(new InputStreamReader(in), 1000);
+        for (String line = r.readLine(); line != null; line = r.readLine()) {
+            sb.append(line);
+        }
+        in.close();
+        return sb.toString();
+    }
+
+    /**
+     * Parse a server response into a JSON Object. This is a basic
+     * implementation using org.json.JSONObject representation. More
+     * sophisticated applications may wish to do their own parsing.
+     *
+     * The parsed JSON is checked for a variety of error fields and
+     * a FacebookException is thrown if an error condition is set,
+     * populated with the error message and error type or code if
+     * available.
+     *
+     * @param response - string representation of the response
+     * @return the response as a JSON Object
+     * @throws JSONException - if the response is not valid JSON
+     * @throws FacebookError - if an error condition is set
+     */
+    @Deprecated
+    public static JSONObject parseJson(String response)
+          throws JSONException, FacebookError {
+        // Edge case: when sending a POST request to /[post_id]/likes
+        // the return value is 'true' or 'false'. Unfortunately
+        // these values cause the JSONObject constructor to throw
+        // an exception.
+        if (response.equals("false")) {
+            throw new FacebookError("request failed");
+        }
+        if (response.equals("true")) {
+            response = "{value : true}";
+        }
+        JSONObject json = new JSONObject(response);
+
+        // errors set by the server are not consistent
+        // they depend on the method and endpoint
+        if (json.has("error")) {
+            JSONObject error = json.getJSONObject("error");
+            throw new FacebookError(
+                    error.getString("message"), error.getString("type"), 0);
+        }
+        if (json.has("error_code") && json.has("error_msg")) {
+            throw new FacebookError(json.getString("error_msg"), "",
+                    Integer.parseInt(json.getString("error_code")));
+        }
+        if (json.has("error_code")) {
+            throw new FacebookError("request failed", "",
+                    Integer.parseInt(json.getString("error_code")));
+        }
+        if (json.has("error_msg")) {
+            throw new FacebookError(json.getString("error_msg"));
+        }
+        if (json.has("error_reason")) {
+            throw new FacebookError(json.getString("error_reason"));
+        }
+        return json;
+    }
+
+    /**
+     * Display a simple alert dialog with the given text and title.
+     *
+     * @param context
+     *          Android context in which the dialog should be displayed
+     * @param title
+     *          Alert dialog title
+     * @param text
+     *          Alert dialog message
+     */
+    @Deprecated
+    public static void showAlert(Context context, String title, String text) {
+        Builder alertBuilder = new Builder(context);
+        alertBuilder.setTitle(title);
+        alertBuilder.setMessage(text);
+        alertBuilder.create().show();
+    }
 }
diff --git a/facebook/src/com/facebook/internal/CacheableRequestBatch.java b/facebook/src/com/facebook/internal/CacheableRequestBatch.java
new file mode 100644
index 000000000..26a1595c2
--- /dev/null
+++ b/facebook/src/com/facebook/internal/CacheableRequestBatch.java
@@ -0,0 +1,57 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import com.facebook.Request;
+import com.facebook.RequestBatch;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public class CacheableRequestBatch extends RequestBatch {
+    private String cacheKey;
+    private boolean forceRoundTrip;
+
+    public CacheableRequestBatch() {
+    }
+
+    public CacheableRequestBatch(Request... requests) {
+        super(requests);
+    }
+
+    public final String getCacheKeyOverride() {
+        return cacheKey;
+    }
+
+    // If this is set, the provided string will override the default key (the URL) for single requests.
+    // There is no default for multi-request batches, so no caching will be done unless the override is
+    // specified.
+    public final void setCacheKeyOverride(String cacheKey) {
+        this.cacheKey = cacheKey;
+    }
+
+    public final boolean getForceRoundTrip() {
+        return forceRoundTrip;
+    }
+
+    public final void setForceRoundTrip(boolean forceRoundTrip) {
+        this.forceRoundTrip = forceRoundTrip;
+    }
+
+}
diff --git a/facebook/src/com/facebook/internal/FileLruCache.java b/facebook/src/com/facebook/internal/FileLruCache.java
new file mode 100644
index 000000000..1fe81b5e1
--- /dev/null
+++ b/facebook/src/com/facebook/internal/FileLruCache.java
@@ -0,0 +1,606 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import android.content.Context;
+import android.util.Log;
+import com.facebook.LoggingBehavior;
+import com.facebook.Settings;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.json.JSONTokener;
+
+import java.io.*;
+import java.security.InvalidParameterException;
+import java.util.Date;
+import java.util.PriorityQueue;
+import java.util.concurrent.atomic.AtomicLong;
+
+// This class is intended to be thread-safe.
+//
+// There are two classes of files:  buffer files and cache files:
+// - A buffer file is in the process of being written, and there is an open stream on the file.  These files are
+//   named as "bufferN" where N is an incrementing integer.  On startup, we delete all existing files of this form.
+//   Once the stream is closed, we rename the buffer file to a cache file or attempt to delete if this fails.  We
+//   do not otherwise ever attempt to delete these files.
+// - A cache file is a non-changing file that is named by the md5 hash of the cache key.  We monitor the size of
+//   these files in aggregate and remove the oldest one(s) to stay under quota.  This process does not block threads
+//   calling into this class, so theoretically we could go arbitrarily over quota but in practice this should not
+//   happen because deleting files should be much cheaper than downloading new file content.
+//
+// Since there can only ever be one thread accessing a particular buffer file, we do not synchronize access to these.
+// We do assume that file rename is atomic when converting a buffer file to a cache file, and that if multiple files
+// are renamed to a single target that exactly one of them continues to exist.
+//
+// Standard POSIX file semantics guarantee being able to continue to use a file handle even after the
+// corresponding file has been deleted.  Given this and that cache files never change other than deleting in trim(),
+// we only have to ensure that there is at most one trim() process deleting files at any given time.
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public final class FileLruCache {
+    static final String TAG = FileLruCache.class.getSimpleName();
+    private static final String HEADER_CACHEKEY_KEY = "key";
+    private static final String HEADER_CACHE_CONTENT_TAG_KEY = "tag";
+
+    private static final AtomicLong bufferIndex = new AtomicLong();
+
+    private final String tag;
+    private final Limits limits;
+    private final File directory;
+    private boolean isTrimPending;
+    private final Object lock;
+
+    // The value of tag should be a final String that works as a directory name.
+    public FileLruCache(Context context, String tag, Limits limits) {
+        this.tag = tag;
+        this.limits = limits;
+        this.directory = new File(context.getCacheDir(), tag);
+        this.lock = new Object();
+
+        // Ensure the cache dir exists
+        this.directory.mkdirs();
+
+        // Remove any stale partially-written files from a previous run
+        BufferFile.deleteAll(this.directory);
+    }
+
+    // Other code in this class is not necessarily robust to having buffer files deleted concurrently.
+    // If this is ever used for non-test code, we should make sure the synchronization is correct.  See
+    // the threading notes at the top of this class.
+    public void clearForTest() throws IOException {
+        for (File file : this.directory.listFiles()) {
+            file.delete();
+        }
+    }
+
+    // This is not robust to files changing dynamically underneath it and should therefore only be used
+    // for test code.  If we ever need this for product code we need to think through synchronization.
+    // See the threading notes at the top of this class.
+    //
+    // Also, since trim() runs asynchronously now, this blocks until any pending trim has completed.
+    long sizeInBytesForTest() {
+        synchronized (lock) {
+            while (isTrimPending) {
+                try {
+                    lock.wait();
+                } catch (InterruptedException e) {
+                    // intentional no-op
+                }
+            }
+        }
+
+        File[] files = this.directory.listFiles();
+        long total = 0;
+        for (File file : files) {
+            total += file.length();
+        }
+        return total;
+    }
+
+    public InputStream get(String key) throws IOException {
+        return get(key, null);
+    }
+
+    public InputStream get(String key, String contentTag) throws IOException {
+        File file = new File(this.directory, Utility.md5hash(key));
+
+        FileInputStream input = null;
+        try {
+            input = new FileInputStream(file);
+        } catch (IOException e) {
+            return null;
+        }
+
+        BufferedInputStream buffered = new BufferedInputStream(input, Utility.DEFAULT_STREAM_BUFFER_SIZE);
+        boolean success = false;
+
+        try {
+            JSONObject header = StreamHeader.readHeader(buffered);
+            if (header == null) {
+                return null;
+            }
+
+            String foundKey = header.optString(HEADER_CACHEKEY_KEY);
+            if ((foundKey == null) || !foundKey.equals(key)) {
+                return null;
+            }
+
+            String headerContentTag = header.optString(HEADER_CACHE_CONTENT_TAG_KEY, null);
+
+            if ((contentTag == null && headerContentTag != null) ||
+                    (contentTag != null && !contentTag.equals(headerContentTag))) {
+                return null;
+            }
+
+            long accessTime = new Date().getTime();
+            Logger.log(LoggingBehavior.CACHE, TAG, "Setting lastModified to " + Long.valueOf(accessTime) + " for "
+                    + file.getName());
+            file.setLastModified(accessTime);
+
+            success = true;
+            return buffered;
+        } finally {
+            if (!success) {
+                buffered.close();
+            }
+        }
+    }
+
+    OutputStream openPutStream(final String key) throws IOException {
+        return openPutStream(key, null);
+    }
+
+    public OutputStream openPutStream(final String key, String contentTag) throws IOException {
+        final File buffer = BufferFile.newFile(this.directory);
+        buffer.delete();
+        if (!buffer.createNewFile()) {
+            throw new IOException("Could not create file at " + buffer.getAbsolutePath());
+        }
+
+        FileOutputStream file = null;
+        try {
+            file = new FileOutputStream(buffer);
+        } catch (FileNotFoundException e) {
+            Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, "Error creating buffer output stream: " + e);
+            throw new IOException(e.getMessage());
+        }
+
+        StreamCloseCallback renameToTargetCallback = new StreamCloseCallback() {
+            @Override
+            public void onClose() {
+                renameToTargetAndTrim(key, buffer);
+            }
+        };
+
+        CloseCallbackOutputStream cleanup = new CloseCallbackOutputStream(file, renameToTargetCallback);
+        BufferedOutputStream buffered = new BufferedOutputStream(cleanup, Utility.DEFAULT_STREAM_BUFFER_SIZE);
+        boolean success = false;
+
+        try {
+            // Prefix the stream with the actual key, since there could be collisions
+            JSONObject header = new JSONObject();
+            header.put(HEADER_CACHEKEY_KEY, key);
+            if (!Utility.isNullOrEmpty(contentTag)) {
+                header.put(HEADER_CACHE_CONTENT_TAG_KEY, contentTag);
+            }
+
+            StreamHeader.writeHeader(buffered, header);
+
+            success = true;
+            return buffered;
+        } catch (JSONException e) {
+            // JSON is an implementation detail of the cache, so don't let JSON exceptions out.
+            Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, "Error creating JSON header for cache file: " + e);
+            throw new IOException(e.getMessage());
+        } finally {
+            if (!success) {
+                buffered.close();
+            }
+        }
+    }
+
+    private void renameToTargetAndTrim(String key, File buffer) {
+        final File target = new File(directory, Utility.md5hash(key));
+
+        // This is triggered by close().  By the time close() returns, the file should be cached, so this needs to
+        // happen synchronously on this thread.
+        //
+        // However, it does not need to be synchronized, since in the race we will just start an unnecesary trim
+        // operation.  Avoiding the cost of holding the lock across the file operation seems worth this cost.
+        if (!buffer.renameTo(target)) {
+            buffer.delete();
+        }
+
+        postTrim();
+    }
+
+    // Opens an output stream for the key, and creates an input stream wrapper to copy
+    // the contents of input into the new output stream.  The effect is to store a
+    // copy of input, and associate that data with key.
+    public InputStream interceptAndPut(String key, InputStream input) throws IOException {
+        OutputStream output = openPutStream(key);
+        return new CopyingInputStream(input, output);
+    }
+
+    public String toString() {
+        return "{FileLruCache:" + " tag:" + this.tag + " file:" + this.directory.getName() + "}";
+    }
+
+    private void postTrim() {
+        synchronized (lock) {
+            if (!isTrimPending) {
+                isTrimPending = true;
+                Settings.getExecutor().execute(new Runnable() {
+                    @Override
+                    public void run() {
+                        trim();
+                    }
+                });
+            }
+        }
+    }
+
+    private void trim() {
+        try {
+            Logger.log(LoggingBehavior.CACHE, TAG, "trim started");
+            PriorityQueue<ModifiedFile> heap = new PriorityQueue<ModifiedFile>();
+            long size = 0;
+            long count = 0;
+            for (File file : this.directory.listFiles(BufferFile.excludeBufferFiles())) {
+                ModifiedFile modified = new ModifiedFile(file);
+                heap.add(modified);
+                Logger.log(LoggingBehavior.CACHE, TAG, "  trim considering time=" + Long.valueOf(modified.getModified())
+                        + " name=" + modified.getFile().getName());
+
+                size += file.length();
+                count++;
+            }
+
+            while ((size > limits.getByteCount()) || (count > limits.getFileCount())) {
+                File file = heap.remove().getFile();
+                Logger.log(LoggingBehavior.CACHE, TAG, "  trim removing " + file.getName());
+                size -= file.length();
+                count--;
+                file.delete();
+            }
+        } finally {
+            synchronized (lock) {
+                isTrimPending = false;
+                lock.notifyAll();
+            }
+        }
+    }
+
+    private static class BufferFile {
+        private static final String FILE_NAME_PREFIX = "buffer";
+        private static final FilenameFilter filterExcludeBufferFiles = new FilenameFilter() {
+            @Override
+            public boolean accept(File dir, String filename) {
+                return !filename.startsWith(FILE_NAME_PREFIX);
+            }
+        };
+        private static final FilenameFilter filterExcludeNonBufferFiles = new FilenameFilter() {
+            @Override
+            public boolean accept(File dir, String filename) {
+                return filename.startsWith(FILE_NAME_PREFIX);
+            }
+        };
+
+        static void deleteAll(final File root) {
+            for (File file : root.listFiles(excludeNonBufferFiles())) {
+                file.delete();
+            }
+        }
+
+        static FilenameFilter excludeBufferFiles() {
+            return filterExcludeBufferFiles;
+        }
+
+        static FilenameFilter excludeNonBufferFiles() {
+            return filterExcludeNonBufferFiles;
+        }
+
+        static File newFile(final File root) {
+            String name = FILE_NAME_PREFIX + Long.valueOf(bufferIndex.incrementAndGet()).toString();
+            return new File(root, name);
+        }
+    }
+
+    // Treats the first part of a stream as a header, reads/writes it as a JSON blob, and
+    // leaves the stream positioned exactly after the header.
+    //
+    // The format is as follows:
+    //     byte: meaning
+    // ---------------------------------
+    //        0: version number
+    //      1-3: big-endian JSON header blob size
+    // 4-size+4: UTF-8 JSON header blob
+    //      ...: stream data
+    private static final class StreamHeader {
+        private static final int HEADER_VERSION = 0;
+
+        static void writeHeader(OutputStream stream, JSONObject header) throws IOException {
+            String headerString = header.toString();
+            byte[] headerBytes = headerString.getBytes();
+
+            // Write version number and big-endian header size
+            stream.write(HEADER_VERSION);
+            stream.write((headerBytes.length >> 16) & 0xff);
+            stream.write((headerBytes.length >> 8) & 0xff);
+            stream.write((headerBytes.length >> 0) & 0xff);
+
+            stream.write(headerBytes);
+        }
+
+        static JSONObject readHeader(InputStream stream) throws IOException {
+            int version = stream.read();
+            if (version != HEADER_VERSION) {
+                return null;
+            }
+
+            int headerSize = 0;
+            for (int i = 0; i < 3; i++) {
+                int b = stream.read();
+                if (b == -1) {
+                    Logger.log(LoggingBehavior.CACHE, TAG,
+                            "readHeader: stream.read returned -1 while reading header size");
+                    return null;
+                }
+                headerSize <<= 8;
+                headerSize += b & 0xff;
+            }
+
+            byte[] headerBytes = new byte[headerSize];
+            int count = 0;
+            while (count < headerBytes.length) {
+                int readCount = stream.read(headerBytes, count, headerBytes.length - count);
+                if (readCount < 1) {
+                    Logger.log(LoggingBehavior.CACHE, TAG,
+                            "readHeader: stream.read stopped at " + Integer.valueOf(count) + " when expected "
+                                    + headerBytes.length);
+                    return null;
+                }
+                count += readCount;
+            }
+
+            String headerString = new String(headerBytes);
+            JSONObject header = null;
+            JSONTokener tokener = new JSONTokener(headerString);
+            try {
+                Object parsed = tokener.nextValue();
+                if (!(parsed instanceof JSONObject)) {
+                    Logger.log(LoggingBehavior.CACHE, TAG, "readHeader: expected JSONObject, got " + parsed.getClass().getCanonicalName());
+                    return null;
+                }
+                header = (JSONObject) parsed;
+            } catch (JSONException e) {
+                throw new IOException(e.getMessage());
+            }
+
+            return header;
+        }
+    }
+
+    private static class CloseCallbackOutputStream extends OutputStream {
+        final OutputStream innerStream;
+        final StreamCloseCallback callback;
+
+        CloseCallbackOutputStream(OutputStream innerStream, StreamCloseCallback callback) {
+            this.innerStream = innerStream;
+            this.callback = callback;
+        }
+
+        @Override
+        public void close() throws IOException {
+            try {
+                this.innerStream.close();
+            } finally {
+                this.callback.onClose();
+            }
+        }
+
+        @Override
+        public void flush() throws IOException {
+            this.innerStream.flush();
+        }
+
+        @Override
+        public void write(byte[] buffer, int offset, int count) throws IOException {
+            this.innerStream.write(buffer, offset, count);
+        }
+
+        @Override
+        public void write(byte[] buffer) throws IOException {
+            this.innerStream.write(buffer);
+        }
+
+        @Override
+        public void write(int oneByte) throws IOException {
+            this.innerStream.write(oneByte);
+        }
+    }
+
+    private static final class CopyingInputStream extends InputStream {
+        final InputStream input;
+        final OutputStream output;
+
+        CopyingInputStream(final InputStream input, final OutputStream output) {
+            this.input = input;
+            this.output = output;
+        }
+
+        @Override
+        public int available() throws IOException {
+            return input.available();
+        }
+
+        @Override
+        public void close() throws IOException {
+            // According to http://www.cs.cornell.edu/andru/javaspec/11.doc.html:
+            //  "If a finally clause is executed because of abrupt completion of a try block and the finally clause
+            //   itself completes abruptly, then the reason for the abrupt completion of the try block is discarded
+            //   and the new reason for abrupt completion is propagated from there."
+            //
+            // Android does appear to behave like this.
+            try {
+                this.input.close();
+            } finally {
+                this.output.close();
+            }
+        }
+
+        @Override
+        public void mark(int readlimit) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean markSupported() {
+            return false;
+        }
+
+        @Override
+        public int read(byte[] buffer) throws IOException {
+            int count = input.read(buffer);
+            if (count > 0) {
+                output.write(buffer, 0, count);
+            }
+            return count;
+        }
+
+        @Override
+        public int read() throws IOException {
+            int b = input.read();
+            if (b >= 0) {
+                output.write(b);
+            }
+            return b;
+        }
+
+        @Override
+        public int read(byte[] buffer, int offset, int length) throws IOException {
+            int count = input.read(buffer, offset, length);
+            if (count > 0) {
+                output.write(buffer, offset, count);
+            }
+            return count;
+        }
+
+        @Override
+        public synchronized void reset() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public long skip(long byteCount) throws IOException {
+            byte[] buffer = new byte[1024];
+            long total = 0;
+            while (total < byteCount) {
+                int count = read(buffer, 0, (int)Math.min(byteCount - total, buffer.length));
+                if (count < 0) {
+                    return total;
+                }
+                total += count;
+            }
+            return total;
+        }
+    }
+
+    public static final class Limits {
+        private int byteCount;
+        private int fileCount;
+
+        public Limits() {
+            // A Samsung Galaxy Nexus can create 1k files in half a second.  By the time
+            // it gets to 5k files it takes 5 seconds.  10k files took 15 seconds.  This
+            // continues to slow down as files are added.  This assumes all files are in
+            // a single directory.
+            //
+            // Following a git-like strategy where we partition MD5-named files based on
+            // the first 2 characters is slower across the board.
+            this.fileCount = 1024;
+            this.byteCount = 1024 * 1024;
+        }
+
+        int getByteCount() {
+            return byteCount;
+        }
+
+        int getFileCount() {
+            return fileCount;
+        }
+
+        void setByteCount(int n) {
+            if (n < 0) {
+                throw new InvalidParameterException("Cache byte-count limit must be >= 0");
+            }
+            byteCount = n;
+        }
+
+        void setFileCount(int n) {
+            if (n < 0) {
+                throw new InvalidParameterException("Cache file count limit must be >= 0");
+            }
+            fileCount = n;
+        }
+    }
+
+    // Caches the result of lastModified during sort/heap operations
+    private final static class ModifiedFile implements Comparable<ModifiedFile> {
+        private final File file;
+        private final long modified;
+
+        ModifiedFile(File file) {
+            this.file = file;
+            this.modified = file.lastModified();
+        }
+
+        File getFile() {
+            return file;
+        }
+
+        long getModified() {
+            return modified;
+        }
+
+        @Override
+        public int compareTo(ModifiedFile another) {
+            if (getModified() < another.getModified()) {
+                return -1;
+            } else if (getModified() > another.getModified()) {
+                return 1;
+            } else {
+                return getFile().compareTo(another.getFile());
+            }
+        }
+
+        @Override
+        public boolean equals(Object another) {
+            return
+                    (another instanceof ModifiedFile) &&
+                    (compareTo((ModifiedFile)another) == 0);
+        }
+    }
+
+    private interface StreamCloseCallback {
+        void onClose();
+    }
+}
diff --git a/facebook/src/com/facebook/internal/Logger.java b/facebook/src/com/facebook/internal/Logger.java
new file mode 100644
index 000000000..6a232c6c8
--- /dev/null
+++ b/facebook/src/com/facebook/internal/Logger.java
@@ -0,0 +1,138 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import android.util.Log;
+import com.facebook.LoggingBehavior;
+import com.facebook.Settings;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public class Logger {
+    public static final String LOG_TAG_BASE = "FacebookSDK.";
+    private static final HashMap<String, String> stringsToReplace = new HashMap<String, String>();
+
+    private final LoggingBehavior behavior;
+    private final String tag;
+    private StringBuilder contents;
+    private int priority = Log.DEBUG;
+
+    // Note that the mapping of replaced strings is never emptied, so it should be used only for things that
+    // are not expected to be too numerous, such as access tokens.
+    public synchronized static void registerStringToReplace(String original, String replace) {
+        stringsToReplace.put(original, replace);
+    }
+
+    public synchronized static void registerAccessToken(String accessToken) {
+        if (Settings.isLoggingBehaviorEnabled(LoggingBehavior.INCLUDE_ACCESS_TOKENS) == false) {
+            registerStringToReplace(accessToken, "ACCESS_TOKEN_REMOVED");
+        }
+    }
+
+    public static void log(LoggingBehavior behavior, String tag, String string) {
+        log(behavior, Log.DEBUG, tag, string);
+    }
+
+    public static void log(LoggingBehavior behavior, String tag, String format, Object... args) {
+        if (Settings.isLoggingBehaviorEnabled(behavior)) {
+            String string = String.format(format, args);
+            log(behavior, Log.DEBUG, tag, string);
+        }
+    }
+
+    public static void log(LoggingBehavior behavior, int priority, String tag, String string) {
+        if (Settings.isLoggingBehaviorEnabled(behavior)) {
+            string = replaceStrings(string);
+            if (tag.startsWith(LOG_TAG_BASE) == false) {
+                tag = LOG_TAG_BASE + tag;
+            }
+            Log.println(priority, tag, string);
+        }
+    }
+
+    private synchronized static String replaceStrings(String string) {
+        for (Map.Entry<String, String> entry : stringsToReplace.entrySet()) {
+            string = string.replace(entry.getKey(), entry.getValue());
+        }
+        return string;
+    }
+
+    public Logger(LoggingBehavior behavior, String tag) {
+        Validate.notNullOrEmpty(tag, "tag");
+
+        this.behavior = behavior;
+        this.tag = LOG_TAG_BASE + tag;
+        this.contents = new StringBuilder();
+    }
+
+    public int getPriority() {
+        return priority;
+    }
+
+    public void setPriority(int value) {
+        Validate.oneOf(value, "value", Log.ASSERT, Log.DEBUG, Log.ERROR, Log.INFO, Log.VERBOSE, Log.WARN);
+
+        priority = value;
+    }
+
+    public String getContents() {
+        return replaceStrings(contents.toString());
+    }
+
+    // Writes the accumulated contents, then clears contents to start again.
+    public void log() {
+        logString(contents.toString());
+        contents = new StringBuilder();
+    }
+
+    // Immediately logs a string, ignoring any accumulated contents, which are left unchanged.
+    public void logString(String string) {
+        log(behavior, priority, tag, string);
+    }
+
+    public void append(StringBuilder stringBuilder) {
+        if (shouldLog()) {
+            contents.append(stringBuilder);
+        }
+    }
+
+    public void append(String string) {
+        if (shouldLog()) {
+            contents.append(string);
+        }
+    }
+
+    public void append(String format, Object... args) {
+        if (shouldLog()) {
+            contents.append(String.format(format, args));
+        }
+    }
+
+    public void appendKeyValue(String key, Object value) {
+        append("  %s:\t%s\n", key, value);
+    }
+
+    private boolean shouldLog() {
+        return Settings.isLoggingBehaviorEnabled(behavior);
+    }
+}
diff --git a/facebook/src/com/facebook/internal/ServerProtocol.java b/facebook/src/com/facebook/internal/ServerProtocol.java
new file mode 100644
index 000000000..6cb65324d
--- /dev/null
+++ b/facebook/src/com/facebook/internal/ServerProtocol.java
@@ -0,0 +1,48 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import com.facebook.internal.Utility;
+
+import java.util.Collection;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public final class ServerProtocol {
+    static final String FACEBOOK_COM = "facebook.com";
+    public static final String DIALOG_AUTHORITY = "m." + FACEBOOK_COM;
+    public static final String DIALOG_PATH = "dialog/";
+    public static final String DIALOG_PARAM_SCOPE = "scope";
+    public static final String DIALOG_PARAM_CLIENT_ID = "client_id";
+    public static final String DIALOG_PARAM_DISPLAY = "display";
+    public static final String DIALOG_PARAM_REDIRECT_URI = "redirect_uri";
+    public static final String DIALOG_PARAM_TYPE = "type";
+
+    // URL components
+    public static final String GRAPH_URL = "https://graph." + FACEBOOK_COM;
+    public static final String GRAPH_URL_BASE = "https://graph." + FACEBOOK_COM + "/";
+    public static final String REST_URL_BASE = "https://api." + FACEBOOK_COM + "/method/";
+    public static final String BATCHED_REST_METHOD_URL_BASE = "method/";
+
+    public static final Collection<String> errorsProxyAuthDisabled =
+            Utility.unmodifiableCollection("service_disabled", "AndroidAuthKillSwitchException");
+    public static final Collection<String> errorsUserCanceled =
+            Utility.unmodifiableCollection("access_denied", "OAuthAccessDeniedException");
+}
diff --git a/facebook/src/com/facebook/internal/SessionAuthorizationType.java b/facebook/src/com/facebook/internal/SessionAuthorizationType.java
new file mode 100644
index 000000000..6684019a1
--- /dev/null
+++ b/facebook/src/com/facebook/internal/SessionAuthorizationType.java
@@ -0,0 +1,27 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public enum SessionAuthorizationType {
+    READ,
+    PUBLISH
+}
diff --git a/facebook/src/com/facebook/internal/SessionTracker.java b/facebook/src/com/facebook/internal/SessionTracker.java
new file mode 100644
index 000000000..e013de5c5
--- /dev/null
+++ b/facebook/src/com/facebook/internal/SessionTracker.java
@@ -0,0 +1,239 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.support.v4.content.LocalBroadcastManager;
+import com.facebook.Session;
+import com.facebook.SessionState;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public class SessionTracker {
+
+    private Session session;
+    private final Session.StatusCallback callback;
+    private final BroadcastReceiver receiver;
+    private final LocalBroadcastManager broadcastManager;
+    private boolean isTracking = false;
+
+    /**
+     * Constructs a SessionTracker to track the active Session object.
+     * 
+     * @param context the context object.
+     * @param callback the callback to use whenever the active Session's 
+     *                 state changes
+     */
+    public SessionTracker(Context context, Session.StatusCallback callback) {
+        this(context, callback, null);
+    }
+    
+    /**
+     * Constructs a SessionTracker to track the Session object passed in.
+     * If the Session is null, then it will track the active Session instead.
+     * 
+     * @param context the context object.
+     * @param callback the callback to use whenever the Session's state changes
+     * @param session the Session object to track
+     */
+    SessionTracker(Context context, Session.StatusCallback callback, Session session) {
+        this(context, callback, session, true);
+    }
+    
+    /**
+     * Constructs a SessionTracker to track the Session object passed in.
+     * If the Session is null, then it will track the active Session instead.
+     * 
+     * @param context the context object.
+     * @param callback the callback to use whenever the Session's state changes
+     * @param session the Session object to track
+     * @param startTracking whether to start tracking the Session right away
+     */
+    public SessionTracker(Context context, Session.StatusCallback callback, Session session, boolean startTracking) {
+        this.callback = new CallbackWrapper(callback);
+        this.session = session;
+        this.receiver = new ActiveSessionBroadcastReceiver();
+        this.broadcastManager = LocalBroadcastManager.getInstance(context);
+
+        if (startTracking) {
+            startTracking();
+        }
+    }
+
+    /**
+     * Returns the current Session that's being tracked.
+     * 
+     * @return the current Session associated with this tracker
+     */
+    public Session getSession() {
+        return (session == null) ? Session.getActiveSession() : session;
+    }
+
+    /**
+     * Returns the current Session that's being tracked if it's open, 
+     * otherwise returns null.
+     * 
+     * @return the current Session if it's open, otherwise returns null
+     */
+    public Session getOpenSession() {
+        Session openSession = getSession();
+        if (openSession != null && openSession.isOpened()) {
+            return openSession;
+        }
+        return null;
+    }
+
+    /**
+     * Set the Session object to track.
+     * 
+     * @param newSession the new Session object to track
+     */
+    public void setSession(Session newSession) {
+        if (newSession == null) {
+            if (session != null) {
+                // We're current tracking a Session. Remove the callback
+                // and start tracking the active Session.
+                session.removeCallback(callback);
+                session = null;
+                addBroadcastReceiver();
+                if (getSession() != null) {
+                    getSession().addCallback(callback);
+                }
+            }
+        } else {
+            if (session == null) {
+                // We're currently tracking the active Session, but will be
+                // switching to tracking a different Session object.
+                Session activeSession = Session.getActiveSession();
+                if (activeSession != null) {
+                    activeSession.removeCallback(callback);
+                }
+                broadcastManager.unregisterReceiver(receiver);
+            } else {
+                // We're currently tracking a Session, but are now switching 
+                // to a new Session, so we remove the callback from the old 
+                // Session, and add it to the new one.
+                session.removeCallback(callback);
+            }
+            session = newSession;
+            session.addCallback(callback);
+        }
+    }
+
+    /**
+     * Start tracking the Session (either active or the one given). 
+     */
+    public void startTracking() {
+        if (isTracking) {
+            return;
+        }
+        if (this.session == null) {
+            addBroadcastReceiver();
+        }        
+        // if the session is not null, then add the callback to it right away
+        if (getSession() != null) {
+            getSession().addCallback(callback);
+        }
+        isTracking = true;
+    }
+
+    /**
+     * Stop tracking the Session and remove any callbacks attached
+     * to those sessions.
+     */
+    public void stopTracking() {
+        if (!isTracking) {
+            return;
+        }
+        Session session = getSession();
+        if (session != null) {
+            session.removeCallback(callback);
+        }
+        broadcastManager.unregisterReceiver(receiver);
+        isTracking = false;
+    }
+    
+    /**
+     * Returns whether it's currently tracking the Session.
+     * 
+     * @return true if currently tracking the Session
+     */
+    public boolean isTracking() {
+        return isTracking;
+    }
+
+    /**
+     * Returns whether it's currently tracking the active Session.
+     *
+     * @return true if the currently tracked session is the active Session.
+     */
+    public boolean isTrackingActiveSession() {
+        return session == null;
+    }
+    
+    private void addBroadcastReceiver() {
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Session.ACTION_ACTIVE_SESSION_SET);
+        filter.addAction(Session.ACTION_ACTIVE_SESSION_UNSET);
+        
+        // Add a broadcast receiver to listen to when the active Session
+        // is set or unset, and add/remove our callback as appropriate    
+        broadcastManager.registerReceiver(receiver, filter);
+    }
+
+    /**
+     * The BroadcastReceiver implementation that either adds or removes the callback
+     * from the active Session object as it's SET or UNSET.
+     */
+    private class ActiveSessionBroadcastReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (Session.ACTION_ACTIVE_SESSION_SET.equals(intent.getAction())) {
+                Session session = Session.getActiveSession();
+                if (session != null) {
+                    session.addCallback(SessionTracker.this.callback);
+                }
+            }
+        }
+    }
+
+    private class CallbackWrapper implements Session.StatusCallback {
+
+        private final Session.StatusCallback wrapped;
+        public CallbackWrapper(Session.StatusCallback wrapped) {
+            this.wrapped = wrapped;
+        }
+
+        @Override
+        public void call(Session session, SessionState state, Exception exception) {
+            if (wrapped != null && isTracking()) {
+                wrapped.call(session, state, exception);
+            }
+            // if we're not tracking the Active Session, and the current session
+            // is closed, then start tracking the Active Session.
+            if (session == SessionTracker.this.session && state.isClosed()) {
+                setSession(null);
+            }
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/internal/Utility.java b/facebook/src/com/facebook/internal/Utility.java
new file mode 100644
index 000000000..371e5d056
--- /dev/null
+++ b/facebook/src/com/facebook/internal/Utility.java
@@ -0,0 +1,290 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Parcelable;
+import android.text.TextUtils;
+import android.util.Log;
+import android.webkit.CookieManager;
+import android.webkit.CookieSyncManager;
+import com.facebook.FacebookException;
+import com.facebook.Session;
+import com.facebook.android.BuildConfig;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.json.JSONTokener;
+
+import java.io.*;
+import java.net.HttpURLConnection;
+import java.net.URLConnection;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.*;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public final class Utility {
+    static final String LOG_TAG = "FacebookSDK";
+    private static final String HASH_ALGORITHM_MD5 = "MD5";
+    private static final String URL_SCHEME = "https";
+
+    // This is the default used by the buffer streams, but they trace a warning if you do not specify.
+    public static final int DEFAULT_STREAM_BUFFER_SIZE = 8192;
+
+    // Returns true iff all items in subset are in superset, treating null and
+    // empty collections as
+    // the same.
+    public static <T> boolean isSubset(Collection<T> subset, Collection<T> superset) {
+        if ((superset == null) || (superset.size() == 0)) {
+            return ((subset == null) || (subset.size() == 0));
+        }
+
+        HashSet<T> hash = new HashSet<T>(superset);
+        for (T t : subset) {
+            if (!hash.contains(t)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public static <T> boolean isNullOrEmpty(Collection<T> c) {
+        return (c == null) || (c.size() == 0);
+    }
+
+    public static boolean isNullOrEmpty(String s) {
+        return (s == null) || (s.length() == 0);
+    }
+
+    public static <T> Collection<T> unmodifiableCollection(T... ts) {
+        return Collections.unmodifiableCollection(Arrays.asList(ts));
+    }
+
+    public static <T> ArrayList<T> arrayList(T... ts) {
+        ArrayList<T> arrayList = new ArrayList<T>(ts.length);
+        for (T t : ts) {
+            arrayList.add(t);
+        }
+        return arrayList;
+    }
+
+    static String md5hash(String key) {
+        MessageDigest hash = null;
+        try {
+            hash = MessageDigest.getInstance(HASH_ALGORITHM_MD5);
+        } catch (NoSuchAlgorithmException e) {
+            return null;
+        }
+
+        hash.update(key.getBytes());
+        byte[] digest = hash.digest();
+        StringBuilder builder = new StringBuilder();
+        for (int b : digest) {
+            builder.append(Integer.toHexString((b >> 4) & 0xf));
+            builder.append(Integer.toHexString((b >> 0) & 0xf));
+        }
+        return builder.toString();
+    }
+
+    public static Uri buildUri(String authority, String path, Bundle parameters) {
+        Uri.Builder builder = new Uri.Builder();
+        builder.scheme(URL_SCHEME);
+        builder.authority(authority);
+        builder.path(path);
+        for (String key : parameters.keySet()) {
+            Object parameter = parameters.get(key);
+            if (parameter instanceof String) {
+                builder.appendQueryParameter(key, (String) parameter);
+            }
+        }
+        return builder.build();
+    }
+
+    public static void putObjectInBundle(Bundle bundle, String key, Object value) {
+        if (value instanceof String) {
+            bundle.putString(key, (String) value);
+        } else if (value instanceof Parcelable) {
+            bundle.putParcelable(key, (Parcelable) value);
+        } else if (value instanceof byte[]) {
+            bundle.putByteArray(key, (byte[]) value);
+        } else {
+            throw new FacebookException("attempted to add unsupported type to Bundle");
+        }
+    }
+
+    public static void closeQuietly(Closeable closeable) {
+        try {
+            if (closeable != null) {
+                closeable.close();
+            }
+        } catch (IOException ioe) {
+            // ignore
+        }
+    }
+
+    public static void disconnectQuietly(URLConnection connection) {
+        if (connection instanceof HttpURLConnection) {
+            ((HttpURLConnection)connection).disconnect();
+        }
+    }
+
+    public static String getMetadataApplicationId(Context context) {
+        try {
+            ApplicationInfo ai = context.getPackageManager().getApplicationInfo(
+                    context.getPackageName(), PackageManager.GET_META_DATA);
+            if (ai.metaData != null) {
+                return ai.metaData.getString(Session.APPLICATION_ID_PROPERTY);
+            }
+        } catch (PackageManager.NameNotFoundException e) {
+            // if we can't find it in the manifest, just return null
+        }
+
+        return null;
+    }
+
+    static Map<String, Object> convertJSONObjectToHashMap(JSONObject jsonObject) {
+        HashMap<String, Object> map = new HashMap<String, Object>();
+        JSONArray keys = jsonObject.names();
+        for (int i = 0; i < keys.length(); ++i) {
+            String key;
+            try {
+                key = keys.getString(i);
+                Object value = jsonObject.get(key);
+                if (value instanceof JSONObject) {
+                    value = convertJSONObjectToHashMap((JSONObject) value);
+                }
+                map.put(key, value);
+            } catch (JSONException e) {
+            }
+        }
+        return map;
+    }
+
+    // Returns either a JSONObject or JSONArray representation of the 'key' property of 'jsonObject'.
+    public static Object getStringPropertyAsJSON(JSONObject jsonObject, String key, String nonJSONPropertyKey)
+            throws JSONException {
+        Object value = jsonObject.opt(key);
+        if (value != null && value instanceof String) {
+            JSONTokener tokener = new JSONTokener((String) value);
+            value = tokener.nextValue();
+        }
+
+        if (value != null && !(value instanceof JSONObject || value instanceof JSONArray)) {
+            if (nonJSONPropertyKey != null) {
+                // Facebook sometimes gives us back a non-JSON value such as
+                // literal "true" or "false" as a result.
+                // If we got something like that, we present it to the caller as
+                // a GraphObject with a single
+                // property. We only do this if the caller wants that behavior.
+                jsonObject = new JSONObject();
+                jsonObject.putOpt(nonJSONPropertyKey, value);
+                return jsonObject;
+            } else {
+                throw new FacebookException("Got an unexpected non-JSON object.");
+            }
+        }
+
+        return value;
+
+    }
+
+    public static String readStreamToString(InputStream inputStream) throws IOException {
+        BufferedInputStream bufferedInputStream = null;
+        InputStreamReader reader = null;
+        try {
+            bufferedInputStream = new BufferedInputStream(inputStream);
+            reader = new InputStreamReader(bufferedInputStream);
+            StringBuilder stringBuilder = new StringBuilder();
+
+            final int bufferSize = 1024 * 2;
+            char[] buffer = new char[bufferSize];
+            int n = 0;
+            while ((n = reader.read(buffer)) != -1) {
+                stringBuilder.append(buffer, 0, n);
+            }
+
+            return stringBuilder.toString();
+        } finally {
+            closeQuietly(bufferedInputStream);
+            closeQuietly(reader);
+        }
+    }
+
+    public static boolean stringsEqualOrEmpty(String a, String b) {
+        boolean aEmpty = TextUtils.isEmpty(a);
+        boolean bEmpty = TextUtils.isEmpty(b);
+
+        if (aEmpty && bEmpty) {
+            // Both null or empty, they match.
+            return true;
+        }
+        if (!aEmpty && !bEmpty) {
+            // Both non-empty, check equality.
+            return a.equals(b);
+        }
+        // One empty, one non-empty, can't match.
+        return false;
+    }
+
+    private static void clearCookiesForDomain(Context context, String domain) {
+        // This is to work around a bug where CookieManager may fail to instantiate if CookieSyncManager
+        // has never been created.
+        CookieSyncManager syncManager = CookieSyncManager.createInstance(context);
+        syncManager.sync();
+
+        CookieManager cookieManager = CookieManager.getInstance();
+
+        String cookies = cookieManager.getCookie(domain);
+        if (cookies == null) {
+            return;
+        }
+
+        String[] splitCookies = cookies.split(";");
+        for (String cookie : splitCookies) {
+            String[] cookieParts = cookie.split("=");
+            if (cookieParts.length > 0) {
+                String newCookie = cookieParts[0].trim() + "=;expires=Sat, 1 Jan 2000 00:00:01 UTC;";
+                cookieManager.setCookie(domain, newCookie);
+            }
+        }
+        cookieManager.removeExpiredCookie();
+    }
+
+    public static void clearFacebookCookies(Context context) {
+        // setCookie acts differently when trying to expire cookies between builds of Android that are using
+        // Chromium HTTP stack and those that are not. Using both of these domains to ensure it works on both.
+        clearCookiesForDomain(context, "facebook.com");
+        clearCookiesForDomain(context, ".facebook.com");
+        clearCookiesForDomain(context, "https://facebook.com");
+        clearCookiesForDomain(context, "https://.facebook.com");
+    }
+
+    public static void logd(String tag, String msg) {
+        if (BuildConfig.DEBUG) {
+            Log.d(tag, msg);
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/internal/Validate.java b/facebook/src/com/facebook/internal/Validate.java
new file mode 100644
index 000000000..c66dee731
--- /dev/null
+++ b/facebook/src/com/facebook/internal/Validate.java
@@ -0,0 +1,73 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import java.util.Collection;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public final class Validate {
+    public static void notNull(Object arg, String name) {
+        if (arg == null) {
+            throw new NullPointerException("Argument " + name + " cannot be null");
+        }
+    }
+
+    public static <T> void notEmpty(Collection<T> container, String name) {
+        if (container.isEmpty()) {
+            throw new IllegalArgumentException("Container '" + name + "' cannot be empty");
+        }
+    }
+
+    public static <T> void containsNoNulls(Collection<T> container, String name) {
+        Validate.notNull(container, name);
+        for (T item : container) {
+            if (item == null) {
+                throw new NullPointerException("Container '" + name + "' cannot contain null values");
+            }
+        }
+    }
+
+    public static <T> void notEmptyAndContainsNoNulls(Collection<T> container, String name) {
+        Validate.containsNoNulls(container, name);
+        Validate.notEmpty(container, name);
+    }
+
+    public static void notNullOrEmpty(String arg, String name) {
+        if (Utility.isNullOrEmpty(arg)) {
+            throw new IllegalArgumentException("Argument " + name + " cannot be null or empty");
+        }
+    }
+
+    public static void oneOf(Object arg, String name, Object... values) {
+        for (Object value : values) {
+            if (value != null) {
+                if (value.equals(arg)) {
+                    return;
+                }
+            } else {
+                if (arg == null) {
+                    return;
+                }
+            }
+        }
+        throw new IllegalArgumentException("Argument " + name + " was not one of the allowed values");
+    }
+}
diff --git a/facebook/src/com/facebook/internal/package-info.java b/facebook/src/com/facebook/internal/package-info.java
new file mode 100644
index 000000000..4392d0f35
--- /dev/null
+++ b/facebook/src/com/facebook/internal/package-info.java
@@ -0,0 +1,6 @@
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+package com.facebook.internal;
\ No newline at end of file
diff --git a/facebook/src/com/facebook/model/GraphLocation.java b/facebook/src/com/facebook/model/GraphLocation.java
new file mode 100644
index 000000000..7fec04b96
--- /dev/null
+++ b/facebook/src/com/facebook/model/GraphLocation.java
@@ -0,0 +1,130 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.model;
+
+/**
+ * Provides a strongly-typed representation of a Location as defined by the Graph API.
+ *
+ * Note that this interface is intended to be used with GraphObject.Factory
+ * and not implemented directly.
+ */
+public interface GraphLocation extends GraphObject {
+    /**
+     * Returns the street component of the location.
+     * 
+     * @return the street component of the location, or null
+     */
+    public String getStreet();
+
+    /**
+     * Sets the street component of the location.
+     * 
+     * @param street
+     *            the street component of the location, or null
+     */
+    public void setStreet(String street);
+
+    /**
+     * Gets the city component of the location.
+     * 
+     * @return the city component of the location
+     */
+    public String getCity();
+
+    /**
+     * Sets the city component of the location.
+     * 
+     * @param city
+     *            the city component of the location
+     */
+    public void setCity(String city);
+
+    /**
+     * Returns the state component of the location.
+     * 
+     * @return the state component of the location
+     */
+    public String getState();
+
+    /**
+     * Sets the state component of the location.
+     * 
+     * @param state
+     *            the state component of the location
+     */
+    public void setState(String state);
+
+    /**
+     * Returns the country component of the location.
+     * 
+     * @return the country component of the location
+     */
+    public String getCountry();
+
+    /**
+     * Sets the country component of the location
+     * 
+     * @param country
+     *            the country component of the location
+     */
+    public void setCountry(String country);
+
+    /**
+     * Returns the postal code component of the location.
+     * 
+     * @return the postal code component of the location
+     */
+    public String getZip();
+
+    /**
+     * Sets the postal code component of the location.
+     * 
+     * @param zip
+     *            the postal code component of the location
+     */
+    public void setZip(String zip);
+
+    /**
+     * Returns the latitude component of the location.
+     * 
+     * @return the latitude component of the location
+     */
+    public double getLatitude();
+
+    /**
+     * Sets the latitude component of the location.
+     * 
+     * @param latitude
+     *            the latitude component of the location
+     */
+    public void setLatitude(double latitude);
+
+    /**
+     * Returns the longitude component of the location.
+     * 
+     * @return the longitude component of the location
+     */
+    public double getLongitude();
+
+    /**
+     * Sets the longitude component of the location.
+     * 
+     * @param longitude
+     *            the longitude component of the location
+     */
+    public void setLongitude(double longitude);
+}
diff --git a/facebook/src/com/facebook/model/GraphMultiResult.java b/facebook/src/com/facebook/model/GraphMultiResult.java
new file mode 100644
index 000000000..f5d65569f
--- /dev/null
+++ b/facebook/src/com/facebook/model/GraphMultiResult.java
@@ -0,0 +1,32 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.model;
+
+/**
+ * Defines a GraphObject that represents the result of a query that returns multiple GraphObjects
+ * nested under a "data" property.
+ *
+ * Note that this interface is intended to be used with GraphObject.Factory
+ * and not implemented directly.
+ */
+public interface GraphMultiResult extends GraphObject {
+    /**
+     * Provides access to the GraphObjects that make up the result set.
+     * @return a list of GraphObjects
+     */
+    public GraphObjectList<GraphObject> getData();
+}
diff --git a/facebook/src/com/facebook/model/GraphObject.java b/facebook/src/com/facebook/model/GraphObject.java
new file mode 100644
index 000000000..9b78f062a
--- /dev/null
+++ b/facebook/src/com/facebook/model/GraphObject.java
@@ -0,0 +1,745 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.model;
+
+import com.facebook.FacebookGraphObjectException;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.lang.reflect.*;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.*;
+
+/**
+ * GraphObject is the primary interface used by the Facebook SDK for Android to represent objects in the Facebook
+ * Social Graph and the Facebook Open Graph (OG). It is the base interface for all typed access to graph objects
+ * in the SDK. No concrete classes implement GraphObject or its derived interfaces. Rather, they are implemented as
+ * proxies (see the {@link com.facebook.model.GraphObject.Factory Factory} class) that provide strongly-typed property
+ * getters and setters to access the underlying data. Since the primary use case for graph objects is sending and
+ * receiving them over the wire to/from Facebook services, they are represented as JSONObjects. No validation is done
+ * that a graph object is actually of a specific type -- any graph object can be treated as any GraphObject-derived
+ * interface, and the presence or absence of specific properties determines its suitability for use as that
+ * particular type of object.
+ * <br/>
+ */
+public interface GraphObject {
+    /**
+     * Returns a new proxy that treats this graph object as a different GraphObject-derived type.
+     * @param graphObjectClass the type of GraphObject to return
+     * @return a new instance of the GraphObject-derived-type that references the same underlying data
+     */
+    public <T extends GraphObject> T cast(Class<T> graphObjectClass);
+
+    /**
+     * Returns a Java Collections map of names and properties.  Modifying the returned map modifies the
+     * inner JSON representation.
+     * @return a Java Collections map representing the GraphObject state
+     */
+    public Map<String, Object> asMap();
+
+    /**
+     * Gets the underlying JSONObject representation of this graph object.
+     * @return the underlying JSONObject representation of this graph object
+     */
+    public JSONObject getInnerJSONObject();
+
+    /**
+     * Gets a property of the GraphObject
+     * @param propertyName the name of the property to get
+     * @return the value of the named property
+     */
+    public Object getProperty(String propertyName);
+
+    /**
+     * Sets a property of the GraphObject
+     * @param propertyName the name of the property to set
+     * @param propertyValue the value of the named property to set
+     */
+    public void setProperty(String propertyName, Object propertyValue);
+
+    /**
+     * Removes a property of the GraphObject
+     * @param propertyName the name of the property to remove
+     */
+    public void removeProperty(String propertyName);
+
+    /**
+     * Creates proxies that implement GraphObject, GraphObjectList, and their derived types. These proxies allow access
+     * to underlying collections and name/value property bags via strongly-typed property getters and setters.
+     * <p/>
+     * This supports get/set properties that use primitive types, JSON types, Date, other GraphObject types, Iterable,
+     * Collection, List, and GraphObjectList.
+     */
+    final class Factory {
+        private static final HashSet<Class<?>> verifiedGraphObjectClasses = new HashSet<Class<?>>();
+        private static final SimpleDateFormat[] dateFormats = new SimpleDateFormat[] {
+                new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.US),
+                new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.US), new SimpleDateFormat("yyyy-MM-dd", Locale.US), };
+
+        // No objects of this type should exist.
+        private Factory() {
+        }
+
+        /**
+         * Creates a GraphObject proxy that provides typed access to the data in an underlying JSONObject.
+         * @param json the JSONObject containing the data to be exposed
+         * @return a GraphObject that represents the underlying data
+         *
+         * @throws com.facebook.FacebookException
+         *            If the passed in Class is not a valid GraphObject interface
+         */
+        public static GraphObject create(JSONObject json) {
+            return create(json, GraphObject.class);
+        }
+
+        /**
+         * Creates a GraphObject-derived proxy that provides typed access to the data in an underlying JSONObject.
+         * @param json the JSONObject containing the data to be exposed
+         * @param graphObjectClass the GraphObject-derived type to return
+         * @return a graphObjectClass that represents the underlying data
+         *
+         * @throws com.facebook.FacebookException
+         *            If the passed in Class is not a valid GraphObject interface
+         */
+        public static <T extends GraphObject> T create(JSONObject json, Class<T> graphObjectClass) {
+            return createGraphObjectProxy(graphObjectClass, json);
+        }
+
+        /**
+         * Creates a GraphObject proxy that initially contains no data.
+         * @return a GraphObject with no data
+         *
+         * @throws com.facebook.FacebookException
+         *            If the passed in Class is not a valid GraphObject interface
+         */
+        public static GraphObject create() {
+            return create(GraphObject.class);
+        }
+
+        /**
+         * Creates a GraphObject-derived proxy that initially contains no data.
+         * @param graphObjectClass the GraphObject-derived type to return
+         * @return a graphObjectClass with no data
+         *
+         * @throws com.facebook.FacebookException
+         *            If the passed in Class is not a valid GraphObject interface
+         */
+        public static <T extends GraphObject> T create(Class<T> graphObjectClass) {
+            return createGraphObjectProxy(graphObjectClass, new JSONObject());
+        }
+
+        /**
+         * Determines if two GraphObjects represent the same underlying graph object, based on their IDs.
+         * @param a a graph object
+         * @param b another graph object
+         * @return true if both graph objects have an ID and it is the same ID, false otherwise
+         */
+        public static boolean hasSameId(GraphObject a, GraphObject b) {
+            if (a == null || b == null || !a.asMap().containsKey("id") || !b.asMap().containsKey("id")) {
+                return false;
+            }
+            if (a.equals(b)) {
+                return true;
+            }
+            Object idA = a.getProperty("id");
+            Object idB = b.getProperty("id");
+            if (idA == null || idB == null || !(idA instanceof String) || !(idB instanceof String)) {
+                return false;
+            }
+            return idA.equals(idB);
+        }
+
+        /**
+         * Creates a GraphObjectList-derived proxy that provides typed access to the data in an underlying JSONArray.
+         * @param array the JSONArray containing the data to be exposed
+         * @param graphObjectClass the GraphObject-derived type to return
+         * @return a graphObjectClass that represents the underlying data
+         *
+         * @throws com.facebook.FacebookException
+         *            If the passed in Class is not a valid GraphObject interface
+         */
+        public static <T> GraphObjectList<T> createList(JSONArray array, Class<T> graphObjectClass) {
+            return new GraphObjectListImpl<T>(array, graphObjectClass);
+        }
+
+        /**
+         * Creates a GraphObjectList-derived proxy that initially contains no data.
+         * @param graphObjectClass the GraphObject-derived type to return
+         * @return a GraphObjectList with no data
+         *
+         * @throws com.facebook.FacebookException
+         *            If the passed in Class is not a valid GraphObject interface
+         */
+        public static <T> GraphObjectList<T> createList(Class<T> graphObjectClass) {
+            return createList(new JSONArray(), graphObjectClass);
+        }
+
+        private static <T extends GraphObject> T createGraphObjectProxy(Class<T> graphObjectClass, JSONObject state) {
+            verifyCanProxyClass(graphObjectClass);
+
+            Class<?>[] interfaces = new Class[] { graphObjectClass };
+            GraphObjectProxy graphObjectProxy = new GraphObjectProxy(state, graphObjectClass);
+
+            @SuppressWarnings("unchecked")
+            T graphObject = (T) Proxy.newProxyInstance(GraphObject.class.getClassLoader(), interfaces, graphObjectProxy);
+
+            return graphObject;
+        }
+
+        private static Map<String, Object> createGraphObjectProxyForMap(JSONObject state) {
+            Class<?>[] interfaces = new Class[]{Map.class};
+            GraphObjectProxy graphObjectProxy = new GraphObjectProxy(state, Map.class);
+
+            @SuppressWarnings("unchecked")
+            Map<String, Object> graphObject = (Map<String, Object>) Proxy
+                    .newProxyInstance(GraphObject.class.getClassLoader(), interfaces, graphObjectProxy);
+
+            return graphObject;
+        }
+
+        private static synchronized <T extends GraphObject> boolean hasClassBeenVerified(Class<T> graphObjectClass) {
+            return verifiedGraphObjectClasses.contains(graphObjectClass);
+        }
+
+        private static synchronized <T extends GraphObject> void recordClassHasBeenVerified(Class<T> graphObjectClass) {
+            verifiedGraphObjectClasses.add(graphObjectClass);
+        }
+
+        private static <T extends GraphObject> void verifyCanProxyClass(Class<T> graphObjectClass) {
+            if (hasClassBeenVerified(graphObjectClass)) {
+                return;
+            }
+
+            if (!graphObjectClass.isInterface()) {
+                throw new FacebookGraphObjectException("Factory can only wrap interfaces, not class: "
+                        + graphObjectClass.getName());
+            }
+
+            Method[] methods = graphObjectClass.getMethods();
+            for (Method method : methods) {
+                String methodName = method.getName();
+                int parameterCount = method.getParameterTypes().length;
+                Class<?> returnType = method.getReturnType();
+                boolean hasPropertyNameOverride = method.isAnnotationPresent(PropertyName.class);
+
+                if (method.getDeclaringClass().isAssignableFrom(GraphObject.class)) {
+                    // Don't worry about any methods from GraphObject or one of its base classes.
+                    continue;
+                } else if (parameterCount == 1 && returnType == Void.TYPE) {
+                    if (hasPropertyNameOverride) {
+                        // If a property override is present, it MUST be valid. We don't fallback
+                        // to using the method name
+                        if (!Utility.isNullOrEmpty(method.getAnnotation(PropertyName.class).value())) {
+                            continue;
+                        }
+                    } else if (methodName.startsWith("set") && methodName.length() > 3) {
+                        // Looks like a valid setter
+                        continue;
+                    }
+                } else if (parameterCount == 0 && returnType != Void.TYPE) {
+                    if (hasPropertyNameOverride) {
+                        // If a property override is present, it MUST be valid. We don't fallback
+                        // to using the method name
+                        if (!Utility.isNullOrEmpty(method.getAnnotation(PropertyName.class).value())) {
+                            continue;
+                        }
+                    } else if (methodName.startsWith("get") && methodName.length() > 3) {
+                        // Looks like a valid getter
+                        continue;
+                    }
+                }
+
+                throw new FacebookGraphObjectException("Factory can't proxy method: " + method.toString());
+            }
+
+            recordClassHasBeenVerified(graphObjectClass);
+        }
+
+        // If expectedType is a generic type, expectedTypeAsParameterizedType must be provided in order to determine
+        // generic parameter types.
+        static <U> U coerceValueToExpectedType(Object value, Class<U> expectedType,
+                ParameterizedType expectedTypeAsParameterizedType) {
+            if (value == null) {
+                return null;
+            }
+
+            Class<?> valueType = value.getClass();
+            if (expectedType.isAssignableFrom(valueType)) {
+                @SuppressWarnings("unchecked")
+                U result = (U) value;
+                return result;
+            }
+
+            if (expectedType.isPrimitive()) {
+                // If the result is a primitive, let the runtime succeed or fail at unboxing it.
+                @SuppressWarnings("unchecked")
+                U result = (U) value;
+                return result;
+            }
+
+            if (GraphObject.class.isAssignableFrom(expectedType)) {
+                @SuppressWarnings("unchecked")
+                Class<? extends GraphObject> graphObjectClass = (Class<? extends GraphObject>) expectedType;
+
+                // We need a GraphObject, but we don't have one.
+                if (JSONObject.class.isAssignableFrom(valueType)) {
+                    // We can wrap a JSONObject as a GraphObject.
+                    @SuppressWarnings("unchecked")
+                    U result = (U) createGraphObjectProxy(graphObjectClass, (JSONObject) value);
+                    return result;
+                } else if (GraphObject.class.isAssignableFrom(valueType)) {
+                    // We can cast a GraphObject-derived class to another GraphObject-derived class.
+                    @SuppressWarnings("unchecked")
+                    U result = (U) ((GraphObject) value).cast(graphObjectClass);
+                    return result;
+                } else {
+                    throw new FacebookGraphObjectException("Can't create GraphObject from " + valueType.getName());
+                }
+            } else if (Iterable.class.equals(expectedType) || Collection.class.equals(expectedType)
+                    || List.class.equals(expectedType) || GraphObjectList.class.equals(expectedType)) {
+                if (expectedTypeAsParameterizedType == null) {
+                    throw new FacebookGraphObjectException("can't infer generic type of: " + expectedType.toString());
+                }
+
+                Type[] actualTypeArguments = expectedTypeAsParameterizedType.getActualTypeArguments();
+
+                if (actualTypeArguments == null || actualTypeArguments.length != 1
+                        || !(actualTypeArguments[0] instanceof Class<?>)) {
+                    throw new FacebookGraphObjectException(
+                            "Expect collection properties to be of a type with exactly one generic parameter.");
+                }
+                Class<?> collectionGenericArgument = (Class<?>) actualTypeArguments[0];
+
+                if (JSONArray.class.isAssignableFrom(valueType)) {
+                    JSONArray jsonArray = (JSONArray) value;
+                    @SuppressWarnings("unchecked")
+                    U result = (U) createList(jsonArray, collectionGenericArgument);
+                    return result;
+                } else {
+                    throw new FacebookGraphObjectException("Can't create Collection from " + valueType.getName());
+                }
+            } else if (String.class.equals(expectedType)) {
+                if (Double.class.isAssignableFrom(valueType) ||
+                        Float.class.isAssignableFrom(valueType)) {
+                    @SuppressWarnings("unchecked")
+                    U result = (U) String.format("%f", value);
+                    return result;
+                } else if (Number.class.isAssignableFrom(valueType)) {
+                    @SuppressWarnings("unchecked")
+                    U result = (U) String.format("%d", value);
+                    return result;
+                }
+            } else if (Date.class.equals(expectedType)) {
+                if (String.class.isAssignableFrom(valueType)) {
+                    for (SimpleDateFormat format : dateFormats) {
+                        try {
+                            Date date = format.parse((String) value);
+                            if (date != null) {
+                                @SuppressWarnings("unchecked")
+                                U result = (U) date;
+                                return result;
+                            }
+                        } catch (ParseException e) {
+                            // Keep going.
+                        }
+                    }
+                }
+            }
+            throw new FacebookGraphObjectException("Can't convert type" + valueType.getName() + " to "
+                    + expectedType.getName());
+        }
+
+        static String convertCamelCaseToLowercaseWithUnderscores(String string) {
+            string = string.replaceAll("([a-z])([A-Z])", "$1_$2");
+            return string.toLowerCase(Locale.US);
+        }
+
+        private static Object getUnderlyingJSONObject(Object obj) {
+            Class<?> objClass = obj.getClass();
+            if (GraphObject.class.isAssignableFrom(objClass)) {
+                GraphObject graphObject = (GraphObject) obj;
+                return graphObject.getInnerJSONObject();
+            } else if (GraphObjectList.class.isAssignableFrom(objClass)) {
+                GraphObjectList<?> graphObjectList = (GraphObjectList<?>) obj;
+                return graphObjectList.getInnerJSONArray();
+            }
+            return obj;
+        }
+
+        private abstract static class ProxyBase<STATE> implements InvocationHandler {
+            // Pre-loaded Method objects for the methods in java.lang.Object
+            private static final String EQUALS_METHOD = "equals";
+            private static final String TOSTRING_METHOD = "toString";
+
+            protected final STATE state;
+
+            protected ProxyBase(STATE state) {
+                this.state = state;
+            }
+
+            // Declared to return Object just to simplify implementation of proxy helpers.
+            protected final Object throwUnexpectedMethodSignature(Method method) {
+                throw new FacebookGraphObjectException(getClass().getName() + " got an unexpected method signature: "
+                        + method.toString());
+            }
+
+            protected final Object proxyObjectMethods(Object proxy, Method method, Object[] args) throws Throwable {
+                String methodName = method.getName();
+                if (methodName.equals(EQUALS_METHOD)) {
+                    Object other = args[0];
+
+                    if (other == null) {
+                        return false;
+                    }
+
+                    InvocationHandler handler = Proxy.getInvocationHandler(other);
+                    if (!(handler instanceof GraphObjectProxy)) {
+                        return false;
+                    }
+                    GraphObjectProxy otherProxy = (GraphObjectProxy) handler;
+                    return this.state.equals(otherProxy.state);
+                } else if (methodName.equals(TOSTRING_METHOD)) {
+                    return toString();
+                }
+
+                // For others, just defer to the implementation object.
+                return method.invoke(this.state, args);
+            }
+
+        }
+
+        private final static class GraphObjectProxy extends ProxyBase<JSONObject> {
+            private static final String CLEAR_METHOD = "clear";
+            private static final String CONTAINSKEY_METHOD = "containsKey";
+            private static final String CONTAINSVALUE_METHOD = "containsValue";
+            private static final String ENTRYSET_METHOD = "entrySet";
+            private static final String GET_METHOD = "get";
+            private static final String ISEMPTY_METHOD = "isEmpty";
+            private static final String KEYSET_METHOD = "keySet";
+            private static final String PUT_METHOD = "put";
+            private static final String PUTALL_METHOD = "putAll";
+            private static final String REMOVE_METHOD = "remove";
+            private static final String SIZE_METHOD = "size";
+            private static final String VALUES_METHOD = "values";
+            private static final String CAST_METHOD = "cast";
+            private static final String CASTTOMAP_METHOD = "asMap";
+            private static final String GETPROPERTY_METHOD = "getProperty";
+            private static final String SETPROPERTY_METHOD = "setProperty";
+            private static final String REMOVEPROPERTY_METHOD = "removeProperty";
+            private static final String GETINNERJSONOBJECT_METHOD = "getInnerJSONObject";
+
+            private final Class<?> graphObjectClass;
+
+            public GraphObjectProxy(JSONObject state, Class<?> graphObjectClass) {
+                super(state);
+                this.graphObjectClass = graphObjectClass;
+            }
+
+            @Override
+            public String toString() {
+                return String.format("GraphObject{graphObjectClass=%s, state=%s}", graphObjectClass.getSimpleName(), state);
+            }
+
+            @Override
+            public final Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+                Class<?> declaringClass = method.getDeclaringClass();
+
+                if (declaringClass == Object.class) {
+                    return proxyObjectMethods(proxy, method, args);
+                } else if (declaringClass == Map.class) {
+                    return proxyMapMethods(method, args);
+                } else if (declaringClass == GraphObject.class) {
+                    return proxyGraphObjectMethods(proxy, method, args);
+                } else if (GraphObject.class.isAssignableFrom(declaringClass)) {
+                    return proxyGraphObjectGettersAndSetters(method, args);
+                }
+
+                return throwUnexpectedMethodSignature(method);
+            }
+
+            private final Object proxyMapMethods(Method method, Object[] args) {
+                String methodName = method.getName();
+                if (methodName.equals(CLEAR_METHOD)) {
+                    JsonUtil.jsonObjectClear(this.state);
+                    return null;
+                } else if (methodName.equals(CONTAINSKEY_METHOD)) {
+                    return this.state.has((String) args[0]);
+                } else if (methodName.equals(CONTAINSVALUE_METHOD)) {
+                    return JsonUtil.jsonObjectContainsValue(this.state, args[0]);
+                } else if (methodName.equals(ENTRYSET_METHOD)) {
+                    return JsonUtil.jsonObjectEntrySet(this.state);
+                } else if (methodName.equals(GET_METHOD)) {
+                    return this.state.opt((String) args[0]);
+                } else if (methodName.equals(ISEMPTY_METHOD)) {
+                    return this.state.length() == 0;
+                } else if (methodName.equals(KEYSET_METHOD)) {
+                    return JsonUtil.jsonObjectKeySet(this.state);
+                } else if (methodName.equals(PUT_METHOD)) {
+                    return setJSONProperty(args);
+                } else if (methodName.equals(PUTALL_METHOD)) {
+                    Map<String, Object> map = null;
+                    if (args[0] instanceof Map<?, ?>) {
+                        @SuppressWarnings("unchecked")
+                        Map<String, Object> castMap = (Map<String, Object>) args[0];
+                        map = castMap;
+                    } else if (args[0] instanceof GraphObject) {
+                        map = ((GraphObject) args[0]).asMap();
+                    }
+                    JsonUtil.jsonObjectPutAll(this.state, map);
+                    return null;
+                } else if (methodName.equals(REMOVE_METHOD)) {
+                    this.state.remove((String) args[0]);
+                    return null;
+                } else if (methodName.equals(SIZE_METHOD)) {
+                    return this.state.length();
+                } else if (methodName.equals(VALUES_METHOD)) {
+                    return JsonUtil.jsonObjectValues(this.state);
+                }
+
+                return throwUnexpectedMethodSignature(method);
+            }
+
+            private final Object proxyGraphObjectMethods(Object proxy, Method method, Object[] args) {
+                String methodName = method.getName();
+                if (methodName.equals(CAST_METHOD)) {
+                    @SuppressWarnings("unchecked")
+                    Class<? extends GraphObject> graphObjectClass = (Class<? extends GraphObject>) args[0];
+
+                    if (graphObjectClass != null &&
+                            graphObjectClass.isAssignableFrom(this.graphObjectClass)) {
+                        return proxy;
+                    }
+                    return Factory.createGraphObjectProxy(graphObjectClass, this.state);
+                } else if (methodName.equals(GETINNERJSONOBJECT_METHOD)) {
+                    InvocationHandler handler = Proxy.getInvocationHandler(proxy);
+                    GraphObjectProxy otherProxy = (GraphObjectProxy) handler;
+                    return otherProxy.state;
+                } else if (methodName.equals(CASTTOMAP_METHOD)) {
+                    return Factory.createGraphObjectProxyForMap(this.state);
+                } else if (methodName.equals(GETPROPERTY_METHOD)) {
+                    return state.opt((String) args[0]);
+                } else if (methodName.equals(SETPROPERTY_METHOD)) {
+                    return setJSONProperty(args);
+                } else if (methodName.equals(REMOVEPROPERTY_METHOD)) {
+                    this.state.remove((String) args[0]);
+                    return null;
+                }
+
+                return throwUnexpectedMethodSignature(method);
+            }
+
+            private final Object proxyGraphObjectGettersAndSetters(Method method, Object[] args) throws JSONException {
+                String methodName = method.getName();
+                int parameterCount = method.getParameterTypes().length;
+                PropertyName propertyNameOverride = method.getAnnotation(PropertyName.class);
+
+                String key = propertyNameOverride != null ? propertyNameOverride.value() :
+                        convertCamelCaseToLowercaseWithUnderscores(methodName.substring(3));
+
+                // If it's a get or a set on a GraphObject-derived class, we can handle it.
+                if (parameterCount == 0) {
+                    // Has to be a getter. ASSUMPTION: The GraphObject-derived class has been verified
+                    Object value = this.state.opt(key);
+
+                    Class<?> expectedType = method.getReturnType();
+
+                    Type genericReturnType = method.getGenericReturnType();
+                    ParameterizedType parameterizedReturnType = null;
+                    if (genericReturnType instanceof ParameterizedType) {
+                        parameterizedReturnType = (ParameterizedType) genericReturnType;
+                    }
+
+                    value = coerceValueToExpectedType(value, expectedType, parameterizedReturnType);
+
+                    return value;
+                } else if (parameterCount == 1) {
+                    // Has to be a setter. ASSUMPTION: The GraphObject-derived class has been verified
+                    Object value = args[0];
+                    // If this is a wrapped object, store the underlying JSONObject instead, in order to serialize
+                    // correctly.
+                    if (GraphObject.class.isAssignableFrom(value.getClass())) {
+                        value = ((GraphObject) value).getInnerJSONObject();
+                    } else if (GraphObjectList.class.isAssignableFrom(value.getClass())) {
+                        value = ((GraphObjectList<?>) value).getInnerJSONArray();
+                    } else if (Iterable.class.isAssignableFrom(value.getClass())) {
+                        JSONArray jsonArray = new JSONArray();
+                        Iterable<?> iterable = (Iterable<?>) value;
+                        for (Object o : iterable ) {
+                            if (GraphObject.class.isAssignableFrom(o.getClass())) {
+                                jsonArray.put(((GraphObject)o).getInnerJSONObject());
+                            } else {
+                                jsonArray.put(o);
+                            }
+                        }
+                        value = jsonArray;
+                    }
+                    this.state.putOpt(key, value);
+                    return null;
+                }
+
+                return throwUnexpectedMethodSignature(method);
+            }
+
+            private Object setJSONProperty(Object[] args) {
+                String name = (String) args[0];
+                Object property = args[1];
+                Object value = getUnderlyingJSONObject(property);
+                try {
+                    state.putOpt(name, value);
+                } catch (JSONException e) {
+                    throw new IllegalArgumentException(e);
+                }
+                return null;
+            }
+        }
+
+        private final static class GraphObjectListImpl<T> extends AbstractList<T> implements GraphObjectList<T> {
+            private final JSONArray state;
+            private final Class<?> itemType;
+
+            public GraphObjectListImpl(JSONArray state, Class<?> itemType) {
+                Validate.notNull(state, "state");
+                Validate.notNull(itemType, "itemType");
+
+                this.state = state;
+                this.itemType = itemType;
+            }
+
+            @Override
+            public String toString() {
+                return String.format("GraphObjectList{itemType=%s, state=%s}", itemType.getSimpleName(), state);
+            }
+
+            @Override
+            public void add(int location, T object) {
+                // We only support adding at the end of the list, due to JSONArray restrictions.
+                if (location < 0) {
+                    throw new IndexOutOfBoundsException();
+                } else if (location < size()) {
+                    throw new UnsupportedOperationException("Only adding items at the end of the list is supported.");
+                }
+
+                put(location, object);
+            }
+
+            @Override
+            public T set(int location, T object) {
+                checkIndex(location);
+
+                T result = get(location);
+                put(location, object);
+                return result;
+            }
+
+            @Override
+            public int hashCode() {
+                return state.hashCode();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (this == obj)
+                    return true;
+                if (getClass() != obj.getClass()) {
+                    return false;
+                }
+                @SuppressWarnings("unchecked")
+                GraphObjectListImpl<T> other = (GraphObjectListImpl<T>) obj;
+                return state.equals(other.state);
+            }
+
+            @SuppressWarnings("unchecked")
+            @Override
+            public T get(int location) {
+                checkIndex(location);
+
+                Object value = state.opt(location);
+
+                // Class<?> expectedType = method.getReturnType();
+                // Type genericType = method.getGenericReturnType();
+                T result = (T) coerceValueToExpectedType(value, itemType, null);
+
+                return result;
+            }
+
+            @Override
+            public int size() {
+                return state.length();
+            }
+
+            @Override
+            public final <U extends GraphObject> GraphObjectList<U> castToListOf(Class<U> graphObjectClass) {
+                if (GraphObject.class.isAssignableFrom(itemType)) {
+                    if (graphObjectClass.isAssignableFrom(itemType)) {
+                        @SuppressWarnings("unchecked")
+                        GraphObjectList<U> result = (GraphObjectList<U>)this;
+                        return result;
+                    }
+
+                    return createList(state, graphObjectClass);
+                } else {
+                    throw new FacebookGraphObjectException("Can't cast GraphObjectCollection of non-GraphObject type "
+                            + itemType);
+                }
+            }
+
+            @Override
+            public final JSONArray getInnerJSONArray() {
+                return state;
+            }
+
+            @Override
+            public void clear() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean remove(Object o) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean removeAll(Collection<?> c) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean retainAll(Collection<?> c) {
+                throw new UnsupportedOperationException();
+            }
+
+            private void checkIndex(int index) {
+                if (index < 0 || index >= state.length()) {
+                    throw new IndexOutOfBoundsException();
+                }
+            }
+
+            private void put(int index, T obj) {
+                Object underlyingObject = getUnderlyingJSONObject(obj);
+                try {
+                    state.put(index, underlyingObject);
+                } catch (JSONException e) {
+                    throw new IllegalArgumentException(e);
+                }
+            }
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/model/GraphObjectList.java b/facebook/src/com/facebook/model/GraphObjectList.java
new file mode 100644
index 000000000..311e0dcd9
--- /dev/null
+++ b/facebook/src/com/facebook/model/GraphObjectList.java
@@ -0,0 +1,47 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.model;
+
+import org.json.JSONArray;
+
+import java.util.List;
+
+/**
+ * GraphObjectList is the primary representation of a collection of graph objects in the Facebook SDK for Android.
+ * It is not implemented by any concrete classes, but rather by a proxy (see the {@link com.facebook.model.GraphObject.Factory Factory}
+ * class). A GraphObjectList can actually contain elements of any type, not just graph objects, but its principal
+ * use in the SDK is to contain types derived from GraphObject.
+ * <br/>
+ *
+ * @param <T> the type of elements in the list
+ */
+public interface GraphObjectList<T> extends List<T> {
+    // cast method is only supported if T extends GraphObject
+    /**
+     * If T is derived from GraphObject, returns a new GraphObjectList exposing the same underlying data as a new
+     * GraphObject-derived type.
+     * @param graphObjectClass the GraphObject-derived type to return a list of
+     * @return a list representing the same underlying data, exposed as the new GraphObject-derived type
+     * @throws com.facebook.FacebookGraphObjectException if T does not derive from GraphObject
+     */
+    public <U extends GraphObject> GraphObjectList<U> castToListOf(Class<U> graphObjectClass);
+    /**
+     * Gets the underlying JSONArray representation of the data.
+     * @return the underlying JSONArray representation of the data
+     */
+    public JSONArray getInnerJSONArray();
+}
diff --git a/facebook/src/com/facebook/model/GraphPlace.java b/facebook/src/com/facebook/model/GraphPlace.java
new file mode 100644
index 000000000..c4ef6889d
--- /dev/null
+++ b/facebook/src/com/facebook/model/GraphPlace.java
@@ -0,0 +1,69 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.model;
+
+/**
+ * Provides a strongly-typed representation of a Place as defined by the Graph API.
+ *
+ * Note that this interface is intended to be used with GraphObject.Factory
+ * and not implemented directly.
+ */
+public interface GraphPlace extends GraphObject {
+    /**
+     * Returns the ID of the place.
+     * @return the ID of the place
+     */
+    public String getId();
+    /**
+     * Sets the ID of the place.
+     * @param id the ID of the place
+     */
+    public void setId(String id);
+
+    /**
+     * Returns the name of the place.
+     * @return the name of the place
+     */
+    public String getName();
+    /**
+     * Sets the name of the place.
+     * @param name the name of the place
+     */
+    public void setName(String name);
+
+    /**
+     * Returns the category of the place.
+     * @return the category of the place
+     */
+    public String getCategory();
+    /**
+     * Sets the category of the place.
+     * @param category the category of the place
+     */
+    public void setCategory(String category);
+
+    /**
+     * Returns the location of the place.
+     * @return the location of the place
+     */
+    public GraphLocation getLocation();
+    /**
+     * Sets the location of the place.
+     * @param location the location of the place
+     */
+    public void setLocation(GraphLocation location);
+}
diff --git a/facebook/src/com/facebook/model/GraphUser.java b/facebook/src/com/facebook/model/GraphUser.java
new file mode 100644
index 000000000..cc684d3ae
--- /dev/null
+++ b/facebook/src/com/facebook/model/GraphUser.java
@@ -0,0 +1,124 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.model;
+
+/**
+ * Provides a strongly-typed representation of a User as defined by the Graph API.
+ *
+ * Note that this interface is intended to be used with GraphObject.Factory
+ * and not implemented directly.
+ */
+public interface GraphUser extends GraphObject {
+    /**
+     * Returns the ID of the user.
+     * @return the ID of the user
+     */
+    public String getId();
+    /**
+     * Sets the ID of the user.
+     * @param id the ID of the user
+     */
+    public void setId(String id);
+
+    /**
+     * Returns the name of the user.
+     * @return the name of the user
+     */
+    public String getName();
+    /**
+     * Sets the name of the user.
+     * @param name the name of the user
+     */
+    public void setName(String name);
+
+    /**
+     * Returns the first name of the user.
+     * @return the first name of the user
+     */
+    public String getFirstName();
+    /**
+     * Sets the first name of the user.
+     * @param firstName the first name of the user
+     */
+    public void setFirstName(String firstName);
+
+    /**
+     * Returns the middle name of the user.
+     * @return the middle name of the user
+     */
+    public String getMiddleName();
+    /**
+     * Sets the middle name of the user.
+     * @param middleName the middle name of the user
+     */
+    public void setMiddleName(String middleName);
+
+    /**
+     * Returns the last name of the user.
+     * @return the last name of the user
+     */
+    public String getLastName();
+    /**
+     * Sets the last name of the user.
+     * @param lastName the last name of the user
+     */
+    public void setLastName(String lastName);
+
+    /**
+     * Returns the Facebook URL of the user.
+     * @return the Facebook URL of the user
+     */
+    public String getLink();
+    /**
+     * Sets the Facebook URL of the user.
+     * @param link the Facebook URL of the user
+     */
+    public void setLink(String link);
+
+    /**
+     * Returns the Facebook username of the user.
+     * @return the Facebook username of the user
+     */
+    public String getUsername();
+    /**
+     * Sets the Facebook username of the user.
+     * @param username the Facebook username of the user
+     */
+    public void setUsername(String username);
+
+    /**
+     * Returns the birthday of the user.
+     * @return the birthday of the user
+     */
+    public String getBirthday();
+    /**
+     * Sets the birthday of the user.
+     * @param birthday the birthday of the user
+     */
+    public void setBirthday(String birthday);
+
+    /**
+     * Returns the current city of the user.
+     * @return the current city of the user
+     */
+    public GraphLocation getLocation();
+    /**
+     * Sets the current city of the user.
+     * @param location the current city of the user
+     */
+    public void setLocation(GraphLocation location);
+}
diff --git a/facebook/src/com/facebook/model/JsonUtil.java b/facebook/src/com/facebook/model/JsonUtil.java
new file mode 100644
index 000000000..bd46f6e2a
--- /dev/null
+++ b/facebook/src/com/facebook/model/JsonUtil.java
@@ -0,0 +1,122 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.model;
+
+import android.annotation.SuppressLint;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.*;
+
+class JsonUtil {
+    static void jsonObjectClear(JSONObject jsonObject) {
+        @SuppressWarnings("unchecked")
+        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
+        while (keys.hasNext()) {
+            keys.next();
+            keys.remove();
+        }
+    }
+
+    static boolean jsonObjectContainsValue(JSONObject jsonObject, Object value) {
+        @SuppressWarnings("unchecked")
+        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
+        while (keys.hasNext()) {
+            Object thisValue = jsonObject.opt(keys.next());
+            if (thisValue != null && thisValue.equals(value)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private final static class JSONObjectEntry implements Map.Entry<String, Object> {
+        private final String key;
+        private final Object value;
+
+        JSONObjectEntry(String key, Object value) {
+            this.key = key;
+            this.value = value;
+        }
+
+        @SuppressLint("FieldGetter")
+        @Override
+        public String getKey() {
+            return this.key;
+        }
+
+        @Override
+        public Object getValue() {
+            return this.value;
+        }
+
+        @Override
+        public Object setValue(Object object) {
+            throw new UnsupportedOperationException("JSONObjectEntry is immutable");
+        }
+
+    }
+
+    static Set<Map.Entry<String, Object>> jsonObjectEntrySet(JSONObject jsonObject) {
+        HashSet<Map.Entry<String, Object>> result = new HashSet<Map.Entry<String, Object>>();
+
+        @SuppressWarnings("unchecked")
+        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
+        while (keys.hasNext()) {
+            String key = keys.next();
+            Object value = jsonObject.opt(key);
+            result.add(new JSONObjectEntry(key, value));
+        }
+
+        return result;
+    }
+
+    static Set<String> jsonObjectKeySet(JSONObject jsonObject) {
+        HashSet<String> result = new HashSet<String>();
+
+        @SuppressWarnings("unchecked")
+        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
+        while (keys.hasNext()) {
+            result.add(keys.next());
+        }
+
+        return result;
+    }
+
+    static void jsonObjectPutAll(JSONObject jsonObject, Map<String, Object> map) {
+        Set<Map.Entry<String, Object>> entrySet = map.entrySet();
+        for (Map.Entry<String, Object> entry : entrySet) {
+            try {
+                jsonObject.putOpt(entry.getKey(), entry.getValue());
+            } catch (JSONException e) {
+                throw new IllegalArgumentException(e);
+            }
+        }
+    }
+
+    static Collection<Object> jsonObjectValues(JSONObject jsonObject) {
+        ArrayList<Object> result = new ArrayList<Object>();
+
+        @SuppressWarnings("unchecked")
+        Iterator<String> keys = (Iterator<String>) jsonObject.keys();
+        while (keys.hasNext()) {
+            result.add(jsonObject.opt(keys.next()));
+        }
+
+        return result;
+    }
+}
diff --git a/facebook/src/com/facebook/model/OpenGraphAction.java b/facebook/src/com/facebook/model/OpenGraphAction.java
new file mode 100644
index 000000000..9e007a89d
--- /dev/null
+++ b/facebook/src/com/facebook/model/OpenGraphAction.java
@@ -0,0 +1,213 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.model;
+
+import org.json.JSONObject;
+
+import java.util.Date;
+import java.util.List;
+
+/**
+ * Provides a strongly-typed representation of an Open Graph Action.
+ * For more documentation of OG Actions, see: https://developers.facebook.com/docs/opengraph/actions/
+ *
+ * Note that this interface is intended to be used with GraphObject.Factory
+ * and not implemented directly.
+ */
+public interface OpenGraphAction extends GraphObject {
+    /**
+     * Gets the ID of the action.
+     * @return the ID
+     */
+    public String getId();
+
+    /**
+     * Sets the ID of the action.
+     * @param id the ID
+     */
+    public void setId(String id);
+
+    /**
+     * Gets the start time of the action.
+     * @return the start time
+     */
+    public Date getStartTime();
+
+    /**
+     * Sets the start time of the action.
+     * @param startTime the start time
+     */
+    public void setStartTime(Date startTime);
+
+    /**
+     * Gets the end time of the action.
+     * @return the end time
+     */
+    public Date getEndTime();
+
+    /**
+     * Sets the end time of the action.
+     * @param endTime the end time
+     */
+    public void setEndTime(Date endTime);
+
+    /**
+     * Gets the time the action was published, if any.
+     * @return the publish time
+     */
+    public Date getPublishTime();
+
+    /**
+     * Sets the time the action was published.
+     * @param publishTime the publish time
+     */
+    public void setPublishTime(Date publishTime);
+
+    /**
+     * Gets the time the action was created.
+     * @return the creation time
+     */
+    public Date getCreatedTime();
+
+    /**
+     * Sets the time the action was created.
+     * @param createdTime the creation time
+     */
+    public void setCreatedTime(Date createdTime);
+
+    /**
+     * Gets the time the action expires at.
+     * @return the expiration time
+     */
+    public Date getExpiresTime();
+
+    /**
+     * Sets the time the action expires at.
+     * @param expiresTime the expiration time
+     */
+    public void setExpiresTime(Date expiresTime);
+
+    /**
+     * Gets the unique string which will be passed to the OG Action owner's website
+     * when a user clicks through this action on Facebook.
+     * @return the ref string
+     */
+    public String getRef();
+
+    /**
+     * Sets the unique string which will be passed to the OG Action owner's website
+     * when a user clicks through this action on Facebook.
+     * @param ref the ref string
+     */
+    public void setRef(String ref);
+
+    /**
+     * Gets the message assoicated with the action.
+     * @return the message
+     */
+    public String getMessage();
+
+    /**
+     * Sets the message associated with the action.
+     * @param message the message
+     */
+    public void setMessage(String message);
+
+    /**
+     * Gets the place where the action took place.
+     * @return the place
+     */
+    public GraphPlace getPlace();
+
+    /**
+     * Sets the place where the action took place.
+     * @param place the place
+     */
+    public void setPlace(GraphPlace place);
+
+    /**
+     * Gets the list of profiles that were tagged in the action.
+     * @return the profiles that were tagged in the action
+     */
+    public List<GraphObject> getTags();
+
+    /**
+     * Sets the list of profiles that were tagged in the action.
+     * @param tags the profiles that were tagged in the action
+     */
+    public void setTags(List<? extends GraphObject> tags);
+
+    /**
+     * Gets the images that were associated with the action.
+     * @return the images
+     */
+    public List<JSONObject> getImage();
+
+    /**
+     * Sets the images that were associated with the action.
+     * @param image the images
+     */
+    public void setImage(List<JSONObject> image);
+
+    /**
+     * Gets the from-user associated with the action.
+     * @return the user
+     */
+    public GraphUser getFrom();
+
+    /**
+     * Sets the from-user associated with the action.
+     * @param from the from-user
+     */
+    public void setFrom(GraphUser from);
+
+    /**
+     * Gets the 'likes' that have been performed on this action.
+     * @return the likes
+     */
+    public JSONObject getLikes();
+
+    /**
+     * Sets the 'likes' that have been performed on this action.
+     * @param likes the likes
+     */
+    public void setLikes(JSONObject likes);
+
+    /**
+     * Gets the application that created this action.
+     * @return the application
+     */
+    public GraphObject getApplication();
+
+    /**
+     * Sets the application that created this action.
+     * @param application the application
+     */
+    public void setApplication(GraphObject application);
+
+    /**
+     * Gets the comments that have been made on this action.
+     * @return the comments
+     */
+    public JSONObject getComments();
+
+    /**
+     * Sets the comments that have been made on this action.
+     * @param comments the comments
+     */
+    public void setComments(JSONObject comments);
+}
diff --git a/facebook/src/com/facebook/model/PropertyName.java b/facebook/src/com/facebook/model/PropertyName.java
new file mode 100644
index 000000000..36da6edda
--- /dev/null
+++ b/facebook/src/com/facebook/model/PropertyName.java
@@ -0,0 +1,34 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.model;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * Use this annotation on getters and setters in an interface that derives from
+ * GraphObject, if you wish to override the default property name that is inferred
+ * from the name of the method.
+ *
+ * If this annotation is specified on a method, it must contain a non-empty String
+ * value that represents the name of the property that the method is a getter or setter
+ * for.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+public @interface PropertyName {
+    String value();
+}
\ No newline at end of file
diff --git a/facebook/src/com/facebook/widget/FacebookFragment.java b/facebook/src/com/facebook/widget/FacebookFragment.java
new file mode 100644
index 000000000..1084185c5
--- /dev/null
+++ b/facebook/src/com/facebook/widget/FacebookFragment.java
@@ -0,0 +1,297 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import com.facebook.Session;
+import com.facebook.SessionLoginBehavior;
+import com.facebook.SessionState;
+import com.facebook.internal.SessionAuthorizationType;
+import com.facebook.internal.SessionTracker;
+
+import java.util.Date;
+import java.util.List;
+
+/**
+ * <p>Basic implementation of a Fragment that uses a Session to perform 
+ * Single Sign On (SSO). This class is package private, and is not intended
+ * to be consumed by external applications.</p>
+ * 
+ * <p>The method {@link android.support.v4.app.Fragment#onActivityResult} is
+ * used to manage the session information, so if you override it in a subclass, 
+ * be sure to call {@code super.onActivityResult}.</p>
+ * 
+ * <p>The methods in this class are not thread-safe.</p>
+ */
+class FacebookFragment extends Fragment {
+
+    private SessionTracker sessionTracker;
+
+    @Override
+    public void onActivityCreated(Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+        sessionTracker = new SessionTracker(getActivity(), new DefaultSessionStatusCallback());
+    }
+    
+    /**
+     * Called when the activity that was launched exits. This method manages session
+     * information when a session is opened. If this method is overridden in subclasses,
+     * be sure to call {@code super.onActivityResult(...)} first.
+     */
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        sessionTracker.getSession().onActivityResult(this.getActivity(), requestCode, resultCode, data);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        sessionTracker.stopTracking();
+    }
+
+    /**
+     * Use the supplied Session object instead of the active Session.
+     *
+     * @param newSession the Session object to use
+     */
+    public void setSession(Session newSession) {
+        if (sessionTracker != null) {
+            sessionTracker.setSession(newSession);
+        }
+    }
+
+    // METHOD TO BE OVERRIDDEN
+    
+    /**
+     * Called when the session state changes. Override this method to take action
+     * on session state changes.
+     * 
+     * @param state the new state
+     * @param exception any exceptions that occurred during the state change
+     */
+    protected void onSessionStateChange(SessionState state, Exception exception) {
+    }
+
+    // ACCESSORS (CANNOT BE OVERRIDDEN)
+    
+    /**
+     * Gets the current Session.
+     * 
+     * @return the current Session object.
+     */
+    protected final Session getSession() {
+        if (sessionTracker != null) {
+            return sessionTracker.getSession();
+        }
+        return null;
+    }
+
+    /**
+     * Determines whether the current session is open.
+     * 
+     * @return true if the current session is open
+     */
+    protected final boolean isSessionOpen() {
+        if (sessionTracker != null) {
+            return sessionTracker.getOpenSession() != null;
+        }
+        return false;
+    }
+    
+    /**
+     * Gets the current state of the session or null if no session has been created.
+     * 
+     * @return the current state of the session
+     */
+    protected final SessionState getSessionState() {
+        if (sessionTracker != null) {
+            Session currentSession = sessionTracker.getSession();
+            return (currentSession != null) ? currentSession.getState() : null;
+        }
+        return null;
+    }
+    
+    /**
+     * Gets the access token associated with the current session or null if no 
+     * session has been created.
+     * 
+     * @return the access token
+     */
+    protected final String getAccessToken() {
+        if (sessionTracker != null) {
+            Session currentSession = sessionTracker.getOpenSession();
+            return (currentSession != null) ? currentSession.getAccessToken() : null;
+        }
+        return null;
+    }
+
+    /**
+     * Gets the date at which the current session will expire or null if no session 
+     * has been created.
+     * 
+     * @return the date at which the current session will expire
+     */
+    protected final Date getExpirationDate() {
+        if (sessionTracker != null) {
+            Session currentSession = sessionTracker.getOpenSession();
+            return (currentSession != null) ? currentSession.getExpirationDate() : null;
+        }
+        return null;
+    }
+    
+    /**
+     * Closes the current session.
+     */
+    protected final void closeSession() {
+        if (sessionTracker != null) {
+            Session currentSession = sessionTracker.getOpenSession();
+            if (currentSession != null) {
+                currentSession.close();
+            }
+        }
+    }
+    
+    /**
+     * Closes the current session as well as clearing the token cache.
+     */
+    protected final void closeSessionAndClearTokenInformation() {
+        if (sessionTracker != null) {
+            Session currentSession = sessionTracker.getOpenSession();
+            if (currentSession != null) {
+                currentSession.closeAndClearTokenInformation();
+            }
+        }
+    }
+    
+    /**
+     * Gets the permissions associated with the current session or null if no session 
+     * has been created.
+     * 
+     * @return the permissions associated with the current session
+     */
+    protected final List<String> getSessionPermissions() {
+        if (sessionTracker != null) {
+            Session currentSession = sessionTracker.getSession();
+            return (currentSession != null) ? currentSession.getPermissions() : null;
+        }
+        return null;
+    }
+
+    /**
+     * Opens a new session. This method will use the application id from
+     * the associated meta-data value and an empty list of permissions.
+     */
+    protected final void openSession() {
+        openSessionForRead(null, null);
+    }
+
+    /**
+     * Opens a new session with read permissions. If either applicationID or permissions
+     * is null, this method will default to using the values from the associated
+     * meta-data value and an empty list respectively.
+     *
+     * @param applicationId the applicationID, can be null
+     * @param permissions the permissions list, can be null
+     */
+    protected final void openSessionForRead(String applicationId, List<String> permissions) {
+        openSessionForRead(applicationId, permissions, SessionLoginBehavior.SSO_WITH_FALLBACK,
+                Session.DEFAULT_AUTHORIZE_ACTIVITY_CODE);
+    }
+
+    /**
+     * Opens a new session with read permissions. If either applicationID or permissions
+     * is null, this method will default to using the values from the associated
+     * meta-data value and an empty list respectively.
+     *
+     * @param applicationId the applicationID, can be null
+     * @param permissions the permissions list, can be null
+     * @param behavior the login behavior to use with the session
+     * @param activityCode the activity code to use for the SSO activity
+     */
+    protected final void openSessionForRead(String applicationId, List<String> permissions,
+            SessionLoginBehavior behavior, int activityCode) {
+        openSession(applicationId, permissions, behavior, activityCode, SessionAuthorizationType.READ);
+    }
+
+    /**
+     * Opens a new session with publish permissions. If either applicationID is null,
+     * this method will default to using the value from the associated
+     * meta-data value. The permissions list cannot be null.
+     *
+     * @param applicationId the applicationID, can be null
+     * @param permissions the permissions list, cannot be null
+     */
+    protected final void openSessionForPublish(String applicationId, List<String> permissions) {
+        openSessionForPublish(applicationId, permissions, SessionLoginBehavior.SSO_WITH_FALLBACK,
+                Session.DEFAULT_AUTHORIZE_ACTIVITY_CODE);
+    }
+
+    /**
+     * Opens a new session with publish permissions. If either applicationID is null,
+     * this method will default to using the value from the associated
+     * meta-data value. The permissions list cannot be null.
+     *
+     * @param applicationId the applicationID, can be null
+     * @param permissions the permissions list, cannot be null
+     * @param behavior the login behavior to use with the session
+     * @param activityCode the activity code to use for the SSO activity
+     */
+    protected final void openSessionForPublish(String applicationId, List<String> permissions,
+            SessionLoginBehavior behavior, int activityCode) {
+        openSession(applicationId, permissions, behavior, activityCode, SessionAuthorizationType.PUBLISH);
+    }
+
+    private void openSession(String applicationId, List<String> permissions,
+            SessionLoginBehavior behavior, int activityCode, SessionAuthorizationType authType) {
+        if (sessionTracker != null) {
+            Session currentSession = sessionTracker.getSession();
+            if (currentSession == null || currentSession.getState().isClosed()) {
+                Session session = new Session.Builder(getActivity()).setApplicationId(applicationId).build();
+                Session.setActiveSession(session);
+                currentSession = session;
+            }
+            if (!currentSession.isOpened()) {
+                Session.OpenRequest openRequest = new Session.OpenRequest(this).
+                        setPermissions(permissions).
+                        setLoginBehavior(behavior).
+                        setRequestCode(activityCode);
+                if (SessionAuthorizationType.PUBLISH.equals(authType)) {
+                    currentSession.openForPublish(openRequest);
+                } else {
+                    currentSession.openForRead(openRequest);
+                }
+            }
+        }
+    }
+
+    /**
+     * The default callback implementation for the session.
+     */
+    private class DefaultSessionStatusCallback implements Session.StatusCallback {
+
+        @Override
+        public void call(Session session, 
+                         SessionState state,
+                         Exception exception) {
+            FacebookFragment.this.onSessionStateChange(state, exception);
+        }
+        
+    }
+}
diff --git a/facebook/src/com/facebook/widget/FriendPickerFragment.java b/facebook/src/com/facebook/widget/FriendPickerFragment.java
new file mode 100644
index 000000000..831b3a0c4
--- /dev/null
+++ b/facebook/src/com/facebook/widget/FriendPickerFragment.java
@@ -0,0 +1,257 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.annotation.SuppressLint;
+import android.app.Activity;
+import android.content.res.TypedArray;
+import android.os.Bundle;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import com.facebook.*;
+import com.facebook.android.R;
+import com.facebook.model.GraphUser;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * Provides a Fragment that displays a list of a user's friends and allows one or more of the
+ * friends to be selected.
+ */
+public class FriendPickerFragment extends PickerFragment<GraphUser> {
+    /**
+     * The key for a String parameter in the fragment's Intent bundle to indicate what user's
+     * friends should be shown. The default is to display the currently authenticated user's friends.
+     */
+    public static final String USER_ID_BUNDLE_KEY = "com.facebook.widget.FriendPickerFragment.UserId";
+    /**
+     * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
+     * picker should allow more than one friend to be selected or not.
+     */
+    public static final String MULTI_SELECT_BUNDLE_KEY = "com.facebook.widget.FriendPickerFragment.MultiSelect";
+
+    private static final String ID = "id";
+    private static final String NAME = "name";
+
+    private String userId;
+
+    private boolean multiSelect = true;
+
+    /**
+     * Default constructor. Creates a Fragment with all default properties.
+     */
+    public FriendPickerFragment() {
+        this(null);
+    }
+
+    /**
+     * Constructor.
+     * @param args  a Bundle that optionally contains one or more values containing additional
+     *              configuration information for the Fragment.
+     */
+    @SuppressLint("ValidFragment")
+    public FriendPickerFragment(Bundle args) {
+        super(GraphUser.class, R.layout.com_facebook_friendpickerfragment, args);
+        setFriendPickerSettingsFromBundle(args);
+    }
+
+    /**
+     * Gets the ID of the user whose friends should be displayed. If null, the default is to
+     * show the currently authenticated user's friends.
+     * @return the user ID, or null
+     */
+    public String getUserId() {
+        return userId;
+    }
+
+    /**
+     * Sets the ID of the user whose friends should be displayed. If null, the default is to
+     * show the currently authenticated user's friends.
+     * @param userId     the user ID, or null
+     */
+    public void setUserId(String userId) {
+        this.userId = userId;
+    }
+
+    /**
+     * Gets whether the user can select multiple friends, or only one friend.
+     * @return true if the user can select multiple friends, false if only one friend
+     */
+    public boolean getMultiSelect() {
+        return multiSelect;
+    }
+
+    /**
+     * Sets whether the user can select multiple friends, or only one friend.
+     * @param multiSelect    true if the user can select multiple friends, false if only one friend
+     */
+    public void setMultiSelect(boolean multiSelect) {
+        if (this.multiSelect != multiSelect) {
+            this.multiSelect = multiSelect;
+            setSelectionStrategy(createSelectionStrategy());
+        }
+    }
+
+    /**
+     * Gets the currently-selected list of users.
+     * @return the currently-selected list of users
+     */
+    public List<GraphUser> getSelection() {
+        return getSelectedGraphObjects();
+    }
+
+    @Override
+    public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
+        super.onInflate(activity, attrs, savedInstanceState);
+        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.com_facebook_friend_picker_fragment);
+
+        setMultiSelect(a.getBoolean(R.styleable.com_facebook_friend_picker_fragment_multi_select, multiSelect));
+
+        a.recycle();
+    }
+
+    public void setSettingsFromBundle(Bundle inState) {
+        super.setSettingsFromBundle(inState);
+        setFriendPickerSettingsFromBundle(inState);
+    }
+
+    void saveSettingsToBundle(Bundle outState) {
+        super.saveSettingsToBundle(outState);
+
+        outState.putString(USER_ID_BUNDLE_KEY, userId);
+        outState.putBoolean(MULTI_SELECT_BUNDLE_KEY, multiSelect);
+    }
+
+    @Override
+    PickerFragmentAdapter<GraphUser> createAdapter() {
+        PickerFragmentAdapter<GraphUser> adapter = new PickerFragmentAdapter<GraphUser>(
+                this.getActivity()) {
+
+            @Override
+            protected int getGraphObjectRowLayoutId(GraphUser graphObject) {
+                return R.layout.com_facebook_picker_list_row;
+            }
+
+            @Override
+            protected int getDefaultPicture() {
+                return R.drawable.com_facebook_profile_default_icon;
+            }
+
+        };
+        adapter.setShowCheckbox(true);
+        adapter.setShowPicture(getShowPictures());
+        adapter.setSortFields(Arrays.asList(new String[]{NAME}));
+        adapter.setGroupByField(NAME);
+
+        return adapter;
+    }
+
+    @Override
+    LoadingStrategy createLoadingStrategy() {
+        return new ImmediateLoadingStrategy();
+    }
+
+    @Override
+    SelectionStrategy createSelectionStrategy() {
+        return multiSelect ? new MultiSelectionStrategy() : new SingleSelectionStrategy();
+    }
+
+    @Override
+    Request getRequestForLoadData(Session session) {
+        if (adapter == null) {
+            throw new FacebookException("Can't issue requests until Fragment has been created.");
+        }
+
+        String userToFetch = (userId != null) ? userId : "me";
+        return createRequest(userToFetch, extraFields, session);
+    }
+
+    @Override
+    String getDefaultTitleText() {
+        return getString(R.string.com_facebook_choose_friends);
+    }
+
+    private Request createRequest(String userID, Set<String> extraFields, Session session) {
+        Request request = Request.newGraphPathRequest(session, userID + "/friends", null);
+
+        Set<String> fields = new HashSet<String>(extraFields);
+        String[] requiredFields = new String[]{
+                ID,
+                NAME
+        };
+        fields.addAll(Arrays.asList(requiredFields));
+
+        String pictureField = adapter.getPictureFieldSpecifier();
+        if (pictureField != null) {
+            fields.add(pictureField);
+        }
+
+        Bundle parameters = request.getParameters();
+        parameters.putString("fields", TextUtils.join(",", fields));
+        request.setParameters(parameters);
+
+        return request;
+    }
+
+    private void setFriendPickerSettingsFromBundle(Bundle inState) {
+        // We do this in a separate non-overridable method so it is safe to call from the constructor.
+        if (inState != null) {
+            if (inState.containsKey(USER_ID_BUNDLE_KEY)) {
+                setUserId(inState.getString(USER_ID_BUNDLE_KEY));
+            }
+            setMultiSelect(inState.getBoolean(MULTI_SELECT_BUNDLE_KEY, multiSelect));
+        }
+    }
+
+    private class ImmediateLoadingStrategy extends LoadingStrategy {
+        @Override
+        protected void onLoadFinished(GraphObjectPagingLoader<GraphUser> loader,
+                SimpleGraphObjectCursor<GraphUser> data) {
+            super.onLoadFinished(loader, data);
+
+            // We could be called in this state if we are clearing data or if we are being re-attached
+            // in the middle of a query.
+            if (data == null || loader.isLoading()) {
+                return;
+            }
+
+            if (data.areMoreObjectsAvailable()) {
+                // We got results, but more are available.
+                followNextLink();
+            } else {
+                // We finished loading results.
+                hideActivityCircle();
+
+                // If this was from the cache, schedule a delayed refresh query (unless we got no results
+                // at all, in which case refresh immediately.
+                if (data.isFromCache()) {
+                    loader.refreshOriginalRequest(data.getCount() == 0 ? CACHED_RESULT_REFRESH_DELAY : 0);
+                }
+            }
+        }
+
+        private void followNextLink() {
+            // This may look redundant, but this causes the circle to be alpha-dimmed if we have results.
+            displayActivityCircle();
+
+            loader.followNextLink();
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/widget/GraphObjectAdapter.java b/facebook/src/com/facebook/widget/GraphObjectAdapter.java
new file mode 100644
index 000000000..dbf66809c
--- /dev/null
+++ b/facebook/src/com/facebook/widget/GraphObjectAdapter.java
@@ -0,0 +1,799 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewStub;
+import android.widget.*;
+import com.facebook.*;
+import com.facebook.android.R;
+import com.facebook.model.GraphObject;
+import org.json.JSONObject;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.text.Collator;
+import java.util.*;
+
+class GraphObjectAdapter<T extends GraphObject> extends BaseAdapter implements SectionIndexer {
+    private static final int DISPLAY_SECTIONS_THRESHOLD = 1;
+    private static final int HEADER_VIEW_TYPE = 0;
+    private static final int GRAPH_OBJECT_VIEW_TYPE = 1;
+    private static final int ACTIVITY_CIRCLE_VIEW_TYPE = 2;
+    private static final int MAX_PREFETCHED_PICTURES = 20;
+
+    private static final String ID = "id";
+    private static final String NAME = "name";
+    private static final String PICTURE = "picture";
+
+    private final Map<String, ImageRequest> pendingRequests = new HashMap<String, ImageRequest>();
+    private final LayoutInflater inflater;
+    private List<String> sectionKeys = new ArrayList<String>();
+    private Map<String, ArrayList<T>> graphObjectsBySection = new HashMap<String, ArrayList<T>>();
+    private Map<String, T> graphObjectsById = new HashMap<String, T>();
+    private boolean displaySections;
+    private List<String> sortFields;
+    private String groupByField;
+    private boolean showPicture;
+    private boolean showCheckbox;
+    private Filter<T> filter;
+    private DataNeededListener dataNeededListener;
+    private GraphObjectCursor<T> cursor;
+    private Context context;
+    private Map<String, ImageResponse> prefetchedPictureCache = new HashMap<String, ImageResponse>();
+    private ArrayList<String> prefetchedProfilePictureIds = new ArrayList<String>();
+
+
+    public interface DataNeededListener {
+        public void onDataNeeded();
+    }
+
+    public static class SectionAndItem<T extends GraphObject> {
+        public String sectionKey;
+        public T graphObject;
+
+        public enum Type {
+            GRAPH_OBJECT,
+            SECTION_HEADER,
+            ACTIVITY_CIRCLE
+        }
+
+        public SectionAndItem(String sectionKey, T graphObject) {
+            this.sectionKey = sectionKey;
+            this.graphObject = graphObject;
+        }
+
+        public Type getType() {
+            if (sectionKey == null) {
+                return Type.ACTIVITY_CIRCLE;
+            } else if (graphObject == null) {
+                return Type.SECTION_HEADER;
+            } else {
+                return Type.GRAPH_OBJECT;
+            }
+        }
+    }
+
+    interface Filter<T> {
+        boolean includeItem(T graphObject);
+    }
+
+    public GraphObjectAdapter(Context context) {
+        this.context = context;
+        this.inflater = LayoutInflater.from(context);
+    }
+
+    public List<String> getSortFields() {
+        return sortFields;
+    }
+
+    public void setSortFields(List<String> sortFields) {
+        this.sortFields = sortFields;
+    }
+
+    public String getGroupByField() {
+        return groupByField;
+    }
+
+    public void setGroupByField(String groupByField) {
+        this.groupByField = groupByField;
+    }
+
+    public boolean getShowPicture() {
+        return showPicture;
+    }
+
+    public void setShowPicture(boolean showPicture) {
+        this.showPicture = showPicture;
+    }
+
+    public boolean getShowCheckbox() {
+        return showCheckbox;
+    }
+
+    public void setShowCheckbox(boolean showCheckbox) {
+        this.showCheckbox = showCheckbox;
+    }
+
+    public DataNeededListener getDataNeededListener() {
+        return dataNeededListener;
+    }
+
+    public void setDataNeededListener(DataNeededListener dataNeededListener) {
+        this.dataNeededListener = dataNeededListener;
+    }
+
+    public GraphObjectCursor<T> getCursor() {
+        return cursor;
+    }
+
+    public boolean changeCursor(GraphObjectCursor<T> cursor) {
+        if (this.cursor == cursor) {
+            return false;
+        }
+        if (this.cursor != null) {
+            this.cursor.close();
+        }
+        this.cursor = cursor;
+
+        rebuildAndNotify();
+        return true;
+    }
+
+    public void rebuildAndNotify() {
+        rebuildSections();
+        notifyDataSetChanged();
+    }
+
+    public void prioritizeViewRange(int firstVisibleItem, int lastVisibleItem, int prefetchBuffer) {
+        if (lastVisibleItem < firstVisibleItem) {
+            return;
+        }
+
+        // We want to prioritize requests for items which are visible but do not have pictures
+        // loaded yet. We also want to pre-fetch pictures for items which are not yet visible
+        // but are within a buffer on either side of the visible items, on the assumption that
+        // they will be visible soon. For these latter items, we'll store the images in memory
+        // in the hopes we can immediately populate their image view when needed.
+
+        // Prioritize the requests in reverse order since each call to prioritizeRequest will just
+        // move it to the front of the queue. And we want the earliest ones in the range to be at
+        // the front of the queue, so all else being equal, the list will appear to populate from
+        // the top down.
+        for (int i = lastVisibleItem; i >= 0; i--) {
+            SectionAndItem<T> sectionAndItem = getSectionAndItem(i);
+            if (sectionAndItem.graphObject != null) {
+                String id = getIdOfGraphObject(sectionAndItem.graphObject);
+                ImageRequest request = pendingRequests.get(id);
+                if (request != null) {
+                    ImageDownloader.prioritizeRequest(request);
+                }
+            }
+        }
+
+        // For items which are not visible, but within the buffer on either side, we want to
+        // fetch those items and store them in a small in-memory cache of bitmaps.
+        int start = Math.max(0, firstVisibleItem - prefetchBuffer);
+        int end = Math.min(lastVisibleItem + prefetchBuffer, getCount() - 1);
+        ArrayList<T> graphObjectsToPrefetchPicturesFor = new ArrayList<T>();
+        // Add the IDs before and after the visible range.
+        for (int i = start; i < firstVisibleItem; ++i) {
+            SectionAndItem<T> sectionAndItem = getSectionAndItem(i);
+            if (sectionAndItem.graphObject != null) {
+                graphObjectsToPrefetchPicturesFor.add(sectionAndItem.graphObject);
+            }
+        }
+        for (int i = lastVisibleItem + 1; i <= end; ++i) {
+            SectionAndItem<T> sectionAndItem = getSectionAndItem(i);
+            if (sectionAndItem.graphObject != null) {
+                graphObjectsToPrefetchPicturesFor.add(sectionAndItem.graphObject);
+            }
+        }
+        for (T graphObject : graphObjectsToPrefetchPicturesFor) {
+            URL url = getPictureUrlOfGraphObject(graphObject);
+            final String id = getIdOfGraphObject(graphObject);
+
+            // This URL already have been requested for pre-fetching, but we want to act in an LRU manner, so move
+            // it to the end of the list regardless.
+            boolean alreadyPrefetching = prefetchedProfilePictureIds.remove(id);
+            prefetchedProfilePictureIds.add(id);
+
+            // If we've already requested it for pre-fetching, no need to do so again.
+            if (!alreadyPrefetching) {
+                downloadProfilePicture(id, url, null);
+            }
+        }
+    }
+
+    protected String getSectionKeyOfGraphObject(T graphObject) {
+        String result = null;
+
+        if (groupByField != null) {
+            result = (String) graphObject.getProperty(groupByField);
+            if (result != null && result.length() > 0) {
+                result = result.substring(0, 1).toUpperCase();
+            }
+        }
+
+        return (result != null) ? result : "";
+    }
+
+    protected CharSequence getTitleOfGraphObject(T graphObject) {
+        return (String) graphObject.getProperty(NAME);
+    }
+
+    protected CharSequence getSubTitleOfGraphObject(T graphObject) {
+        return null;
+    }
+
+    protected URL getPictureUrlOfGraphObject(T graphObject) {
+        String url = null;
+        Object o = graphObject.getProperty(PICTURE);
+        if (o instanceof String) {
+            url = (String) o;
+        } else if (o instanceof JSONObject) {
+            ItemPicture itemPicture = GraphObject.Factory.create((JSONObject) o).cast(ItemPicture.class);
+            ItemPictureData data = itemPicture.getData();
+            if (data != null) {
+                url = data.getUrl();
+            }
+        }
+
+        if (url != null) {
+            try {
+                return new URL(url);
+            } catch (MalformedURLException e) {
+            }
+        }
+        return null;
+    }
+
+    protected View getSectionHeaderView(String sectionHeader, View convertView, ViewGroup parent) {
+        TextView result = (TextView) convertView;
+
+        if (result == null) {
+            result = (TextView) inflater.inflate(R.layout.com_facebook_picker_list_section_header, null);
+        }
+
+        result.setText(sectionHeader);
+
+        return result;
+    }
+
+    protected View getGraphObjectView(T graphObject, View convertView, ViewGroup parent) {
+        View result = convertView;
+
+        if (result == null) {
+            result = createGraphObjectView(graphObject, convertView);
+        }
+
+        populateGraphObjectView(result, graphObject);
+        return result;
+    }
+
+    private View getActivityCircleView(View convertView, ViewGroup parent) {
+        View result = convertView;
+
+        if (result == null) {
+            result = inflater.inflate(R.layout.com_facebook_picker_activity_circle_row, null);
+        }
+        ProgressBar activityCircle = (ProgressBar) result.findViewById(R.id.com_facebook_picker_row_activity_circle);
+        activityCircle.setVisibility(View.VISIBLE);
+
+        return result;
+    }
+
+    protected int getGraphObjectRowLayoutId(T graphObject) {
+        return R.layout.com_facebook_picker_list_row;
+    }
+
+    protected int getDefaultPicture() {
+        return R.drawable.com_facebook_profile_default_icon;
+    }
+
+    protected View createGraphObjectView(T graphObject, View convertView) {
+        View result = inflater.inflate(getGraphObjectRowLayoutId(graphObject), null);
+
+        ViewStub checkboxStub = (ViewStub) result.findViewById(R.id.com_facebook_picker_checkbox_stub);
+        if (checkboxStub != null) {
+            if (!getShowCheckbox()) {
+                checkboxStub.setVisibility(View.GONE);
+            } else {
+                CheckBox checkBox = (CheckBox) checkboxStub.inflate();
+                updateCheckboxState(checkBox, false);
+            }
+        }
+
+        ViewStub profilePicStub = (ViewStub) result.findViewById(R.id.com_facebook_picker_profile_pic_stub);
+        if (!getShowPicture()) {
+            profilePicStub.setVisibility(View.GONE);
+        } else {
+            ImageView imageView = (ImageView) profilePicStub.inflate();
+            imageView.setVisibility(View.VISIBLE);
+        }
+
+        return result;
+    }
+
+    protected void populateGraphObjectView(View view, T graphObject) {
+        String id = getIdOfGraphObject(graphObject);
+        view.setTag(id);
+
+        CharSequence title = getTitleOfGraphObject(graphObject);
+        TextView titleView = (TextView) view.findViewById(R.id.com_facebook_picker_title);
+        if (titleView != null) {
+            titleView.setText(title, TextView.BufferType.SPANNABLE);
+        }
+
+        CharSequence subtitle = getSubTitleOfGraphObject(graphObject);
+        TextView subtitleView = (TextView) view.findViewById(R.id.picker_subtitle);
+        if (subtitleView != null) {
+            if (subtitle != null) {
+                subtitleView.setText(subtitle, TextView.BufferType.SPANNABLE);
+                subtitleView.setVisibility(View.VISIBLE);
+            } else {
+                subtitleView.setVisibility(View.GONE);
+            }
+        }
+
+        if (getShowCheckbox()) {
+            CheckBox checkBox = (CheckBox) view.findViewById(R.id.com_facebook_picker_checkbox);
+            updateCheckboxState(checkBox, isGraphObjectSelected(id));
+        }
+
+        if (getShowPicture()) {
+            URL pictureURL = getPictureUrlOfGraphObject(graphObject);
+
+            if (pictureURL != null) {
+                ImageView profilePic = (ImageView) view.findViewById(R.id.com_facebook_picker_image);
+
+                // See if we have already pre-fetched this; if not, download it.
+                if (prefetchedPictureCache.containsKey(id)) {
+                    ImageResponse response = prefetchedPictureCache.get(id);
+                    profilePic.setImageBitmap(response.getBitmap());
+                    profilePic.setTag(response.getRequest().getImageUrl());
+                } else {
+                    downloadProfilePicture(id, pictureURL, profilePic);
+                }
+            }
+        }
+    }
+
+    /**
+     * @throws FacebookException if the GraphObject doesn't have an ID.
+     */
+    String getIdOfGraphObject(T graphObject) {
+        if (graphObject.asMap().containsKey(ID)) {
+            Object obj = graphObject.getProperty(ID);
+            if (obj instanceof String) {
+                return (String) obj;
+            }
+        }
+        throw new FacebookException("Received an object without an ID.");
+    }
+
+    boolean filterIncludesItem(T graphObject) {
+        return filter == null || filter.includeItem(graphObject);
+    }
+
+    Filter<T> getFilter() {
+        return filter;
+    }
+
+    void setFilter(Filter<T> filter) {
+        this.filter = filter;
+    }
+
+    boolean isGraphObjectSelected(String graphObjectId) {
+        return false;
+    }
+
+    void updateCheckboxState(CheckBox checkBox, boolean graphObjectSelected) {
+        // Default is no-op
+    }
+
+    String getPictureFieldSpecifier() {
+        // How big is our image?
+        View view = createGraphObjectView(null, null);
+        ImageView picture = (ImageView) view.findViewById(R.id.com_facebook_picker_image);
+        if (picture == null) {
+            return null;
+        }
+
+        // Note: these dimensions are in pixels, not dips
+        ViewGroup.LayoutParams layoutParams = picture.getLayoutParams();
+        return String.format("picture.height(%d).width(%d)", layoutParams.height, layoutParams.width);
+    }
+
+
+    private boolean shouldShowActivityCircleCell() {
+        // We show the "more data" activity circle cell if we have a listener to request more data,
+        // we are expecting more data, and we have some data already (i.e., not on a fresh query).
+        return (cursor != null) && cursor.areMoreObjectsAvailable() && (dataNeededListener != null) && !isEmpty();
+    }
+
+    private void rebuildSections() {
+        sectionKeys = new ArrayList<String>();
+        graphObjectsBySection = new HashMap<String, ArrayList<T>>();
+        graphObjectsById = new HashMap<String, T>();
+        displaySections = false;
+
+        if (cursor == null || cursor.getCount() == 0) {
+            return;
+        }
+
+        int objectsAdded = 0;
+        cursor.moveToFirst();
+        do {
+            T graphObject = cursor.getGraphObject();
+
+            if (!filterIncludesItem(graphObject)) {
+                continue;
+            }
+
+            objectsAdded++;
+
+            String sectionKeyOfItem = getSectionKeyOfGraphObject(graphObject);
+            if (!graphObjectsBySection.containsKey(sectionKeyOfItem)) {
+                sectionKeys.add(sectionKeyOfItem);
+                graphObjectsBySection.put(sectionKeyOfItem, new ArrayList<T>());
+            }
+            List<T> section = graphObjectsBySection.get(sectionKeyOfItem);
+            section.add(graphObject);
+
+            graphObjectsById.put(getIdOfGraphObject(graphObject), graphObject);
+        } while (cursor.moveToNext());
+
+        if (sortFields != null) {
+            final Collator collator = Collator.getInstance();
+            for (List<T> section : graphObjectsBySection.values()) {
+                Collections.sort(section, new Comparator<GraphObject>() {
+                    @Override
+                    public int compare(GraphObject a, GraphObject b) {
+                        return compareGraphObjects(a, b, sortFields, collator);
+                    }
+                });
+            }
+        }
+
+        Collections.sort(sectionKeys, Collator.getInstance());
+
+        displaySections = sectionKeys.size() > 1 && objectsAdded > DISPLAY_SECTIONS_THRESHOLD;
+    }
+
+    SectionAndItem<T> getSectionAndItem(int position) {
+        if (sectionKeys.size() == 0) {
+            return null;
+        }
+        String sectionKey = null;
+        T graphObject = null;
+
+        if (!displaySections) {
+            sectionKey = sectionKeys.get(0);
+            List<T> section = graphObjectsBySection.get(sectionKey);
+            if (position >= 0 && position < section.size()) {
+                graphObject = graphObjectsBySection.get(sectionKey).get(position);
+            } else {
+                // We are off the end; we must be adding an activity circle to indicate more data is coming.
+                assert dataNeededListener != null && cursor.areMoreObjectsAvailable();
+                // We return null for both to indicate this.
+                return new SectionAndItem<T>(null, null);
+            }
+        } else {
+            // Count through the sections; the "0" position in each section is the header. We decrement
+            // position each time we skip forward a certain number of elements, including the header.
+            for (String key : sectionKeys) {
+                // Decrement if we skip over the header
+                if (position-- == 0) {
+                    sectionKey = key;
+                    break;
+                }
+
+                List<T> section = graphObjectsBySection.get(key);
+                if (position < section.size()) {
+                    // The position is somewhere in this section. Get the corresponding graph object.
+                    sectionKey = key;
+                    graphObject = section.get(position);
+                    break;
+                }
+                // Decrement by as many items as we skipped over
+                position -= section.size();
+            }
+        }
+        if (sectionKey != null) {
+            // Note: graphObject will be null if this represents a section header.
+            return new SectionAndItem<T>(sectionKey, graphObject);
+        } else {
+            throw new IndexOutOfBoundsException("position");
+        }
+    }
+
+    int getPosition(String sectionKey, T graphObject) {
+        int position = 0;
+        boolean found = false;
+
+        // First find the section key and increment position one for each header we will render;
+        // increment by the size of each section prior to the one we want.
+        for (String key : sectionKeys) {
+            if (displaySections) {
+                position++;
+            }
+            if (key.equals(sectionKey)) {
+                found = true;
+                break;
+            } else {
+                position += graphObjectsBySection.get(key).size();
+            }
+        }
+
+        if (!found) {
+            return -1;
+        } else if (graphObject == null) {
+            // null represents the header for a section; we counted this header in position earlier,
+            // so subtract it back out.
+            return position - (displaySections ? 1 : 0);
+        }
+
+        // Now find index of this item within that section.
+        for (T t : graphObjectsBySection.get(sectionKey)) {
+            if (GraphObject.Factory.hasSameId(t, graphObject)) {
+                return position;
+            }
+            position++;
+        }
+        return -1;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        // We'll never populate sectionKeys unless we have at least one object.
+        return sectionKeys.size() == 0;
+    }
+
+    @Override
+    public int getCount() {
+        if (sectionKeys.size() == 0) {
+            return 0;
+        }
+
+        // If we are not displaying sections, we don't display a header; otherwise, we have one header per item in
+        // addition to the actual items.
+        int count = (displaySections) ? sectionKeys.size() : 0;
+        for (List<T> section : graphObjectsBySection.values()) {
+            count += section.size();
+        }
+
+        // If we should show a cell with an activity circle indicating more data is coming, add it to the count.
+        if (shouldShowActivityCircleCell()) {
+            ++count;
+        }
+
+        return count;
+    }
+
+    @Override
+    public boolean areAllItemsEnabled() {
+        return displaySections;
+    }
+
+    @Override
+    public boolean hasStableIds() {
+        return true;
+    }
+
+    @Override
+    public boolean isEnabled(int position) {
+        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
+        return sectionAndItem.getType() == SectionAndItem.Type.GRAPH_OBJECT;
+    }
+
+    @Override
+    public Object getItem(int position) {
+        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
+        return (sectionAndItem.getType() == SectionAndItem.Type.GRAPH_OBJECT) ? sectionAndItem.graphObject : null;
+    }
+
+    @Override
+    public long getItemId(int position) {
+        // We assume IDs that can be converted to longs. If this is not the case for certain types of
+        // GraphObjects, subclasses should override this to return, e.g., position, and override hasStableIds
+        // to return false.
+        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
+        if (sectionAndItem != null && sectionAndItem.graphObject != null) {
+            String id = getIdOfGraphObject(sectionAndItem.graphObject);
+            if (id != null) {
+                return Long.parseLong(id);
+            }
+        }
+        return 0;
+    }
+
+    @Override
+    public int getViewTypeCount() {
+        return 3;
+    }
+
+    @Override
+    public int getItemViewType(int position) {
+        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
+        switch (sectionAndItem.getType()) {
+            case SECTION_HEADER:
+                return HEADER_VIEW_TYPE;
+            case GRAPH_OBJECT:
+                return GRAPH_OBJECT_VIEW_TYPE;
+            case ACTIVITY_CIRCLE:
+                return ACTIVITY_CIRCLE_VIEW_TYPE;
+            default:
+                throw new FacebookException("Unexpected type of section and item.");
+        }
+    }
+
+    @Override
+    public View getView(int position, View convertView, ViewGroup parent) {
+        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
+
+        switch (sectionAndItem.getType()) {
+            case SECTION_HEADER:
+                return getSectionHeaderView(sectionAndItem.sectionKey, convertView, parent);
+            case GRAPH_OBJECT:
+                return getGraphObjectView(sectionAndItem.graphObject, convertView, parent);
+            case ACTIVITY_CIRCLE:
+                // If we get a request for this view, it means we need more data.
+                assert cursor.areMoreObjectsAvailable() && (dataNeededListener != null);
+                dataNeededListener.onDataNeeded();
+                return getActivityCircleView(convertView, parent);
+            default:
+                throw new FacebookException("Unexpected type of section and item.");
+        }
+    }
+
+    @Override
+    public Object[] getSections() {
+        if (displaySections) {
+            return sectionKeys.toArray();
+        } else {
+            return new Object[0];
+        }
+    }
+
+    @Override
+    public int getPositionForSection(int section) {
+        if (displaySections) {
+            section = Math.max(0, Math.min(section, sectionKeys.size() - 1));
+            if (section < sectionKeys.size()) {
+                return getPosition(sectionKeys.get(section), null);
+            }
+        }
+        return 0;
+    }
+
+    @Override
+    public int getSectionForPosition(int position) {
+        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
+        if (sectionAndItem != null &&
+                sectionAndItem.getType() != SectionAndItem.Type.ACTIVITY_CIRCLE) {
+            return Math.max(0, Math.min(sectionKeys.indexOf(sectionAndItem.sectionKey), sectionKeys.size() - 1));
+        }
+        return 0;
+    }
+
+    public List<T> getGraphObjectsById(Collection<String> ids) {
+        Set<String> idSet = new HashSet<String>();
+        idSet.addAll(ids);
+
+        ArrayList<T> result = new ArrayList<T>(idSet.size());
+        for (String id : idSet) {
+            T graphObject = graphObjectsById.get(id);
+            if (graphObject != null) {
+                result.add(graphObject);
+            }
+        }
+
+        return result;
+    }
+
+    private void downloadProfilePicture(final String profileId, URL pictureURL, final ImageView imageView) {
+        if (pictureURL == null) {
+            return;
+        }
+
+        // If we don't have an imageView, we are pre-fetching this image to store in-memory because we
+        // think the user might scroll to its corresponding list row. If we do have an imageView, we
+        // only want to queue a download if the view's tag isn't already set to the URL (which would mean
+        // it's already got the correct picture).
+        boolean prefetching = imageView == null;
+        if (prefetching || !pictureURL.equals(imageView.getTag())) {
+            if (!prefetching) {
+                // Setting the tag to the profile ID indicates that we're currently downloading the
+                // picture for this profile; we'll set it to the actual picture URL when complete.
+                imageView.setTag(profileId);
+                imageView.setImageResource(getDefaultPicture());
+            }
+
+            ImageRequest.Builder builder = new ImageRequest.Builder(context.getApplicationContext(), pictureURL)
+                    .setCallerTag(this)
+                    .setCallback(
+                            new ImageRequest.Callback() {
+                                @Override
+                                public void onCompleted(ImageResponse response) {
+                                    processImageResponse(response, profileId, imageView);
+                                }
+                            });
+
+            ImageRequest newRequest = builder.build();
+            pendingRequests.put(profileId, newRequest);
+
+            ImageDownloader.downloadAsync(newRequest);
+        }
+    }
+
+    private void processImageResponse(ImageResponse response, String graphObjectId, ImageView imageView) {
+        pendingRequests.remove(graphObjectId);
+        if (imageView == null) {
+            // This was a pre-fetch request.
+            if (response.getBitmap() != null) {
+                // Is the cache too big?
+                if (prefetchedPictureCache.size() >= MAX_PREFETCHED_PICTURES) {
+                    // Find the oldest one and remove it.
+                    String oldestId = prefetchedProfilePictureIds.remove(0);
+                    prefetchedPictureCache.remove(oldestId);
+                }
+                prefetchedPictureCache.put(graphObjectId, response);
+            }
+        } else if (imageView != null && graphObjectId.equals(imageView.getTag())) {
+            Exception error = response.getError();
+            Bitmap bitmap = response.getBitmap();
+            if (error == null && bitmap != null) {
+                imageView.setImageBitmap(bitmap);
+                imageView.setTag(response.getRequest().getImageUrl());
+            }
+        }
+    }
+
+    private static int compareGraphObjects(GraphObject a, GraphObject b, Collection<String> sortFields,
+            Collator collator) {
+        for (String sortField : sortFields) {
+            String sa = (String) a.getProperty(sortField);
+            String sb = (String) b.getProperty(sortField);
+
+            if (sa != null && sb != null) {
+                int result = collator.compare(sa, sb);
+                if (result != 0) {
+                    return result;
+                }
+            } else if (!(sa == null && sb == null)) {
+                return (sa == null) ? -1 : 1;
+            }
+        }
+        return 0;
+    }
+
+
+    // Graph object type to navigate the JSON that sometimes comes back instead of a URL string
+    private interface ItemPicture extends GraphObject {
+        ItemPictureData getData();
+    }
+
+    // Graph object type to navigate the JSON that sometimes comes back instead of a URL string
+    private interface ItemPictureData extends GraphObject {
+        String getUrl();
+    }
+}
diff --git a/facebook/src/com/facebook/widget/GraphObjectCursor.java b/facebook/src/com/facebook/widget/GraphObjectCursor.java
new file mode 100644
index 000000000..a86e4a302
--- /dev/null
+++ b/facebook/src/com/facebook/widget/GraphObjectCursor.java
@@ -0,0 +1,55 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import com.facebook.model.GraphObject;
+
+interface GraphObjectCursor<T extends GraphObject> {
+    boolean isFromCache();
+
+    boolean areMoreObjectsAvailable();
+
+    int getCount();
+
+    int getPosition();
+
+    boolean move(int offset);
+
+    boolean moveToPosition(int position);
+
+    boolean moveToFirst();
+
+    boolean moveToLast();
+
+    boolean moveToNext();
+
+    boolean moveToPrevious();
+
+    boolean isFirst();
+
+    boolean isLast();
+
+    boolean isBeforeFirst();
+
+    boolean isAfterLast();
+
+    T getGraphObject();
+
+    void close();
+
+    boolean isClosed();
+}
diff --git a/facebook/src/com/facebook/widget/GraphObjectPagingLoader.java b/facebook/src/com/facebook/widget/GraphObjectPagingLoader.java
new file mode 100644
index 000000000..f36eeb48e
--- /dev/null
+++ b/facebook/src/com/facebook/widget/GraphObjectPagingLoader.java
@@ -0,0 +1,226 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.content.Context;
+import android.os.Handler;
+import android.support.v4.content.Loader;
+import com.facebook.*;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphObjectList;
+import com.facebook.internal.CacheableRequestBatch;
+
+class GraphObjectPagingLoader<T extends GraphObject> extends Loader<SimpleGraphObjectCursor<T>> {
+    private final Class<T> graphObjectClass;
+    private boolean skipRoundtripIfCached;
+    private Request originalRequest;
+    private Request currentRequest;
+    private Request nextRequest;
+    private OnErrorListener onErrorListener;
+    private SimpleGraphObjectCursor<T> cursor;
+    private boolean appendResults = false;
+    private boolean loading = false;
+
+    public interface OnErrorListener {
+        public void onError(FacebookException error, GraphObjectPagingLoader<?> loader);
+    }
+
+    public GraphObjectPagingLoader(Context context, Class<T> graphObjectClass) {
+        super(context);
+
+        this.graphObjectClass = graphObjectClass;
+    }
+
+    public OnErrorListener getOnErrorListener() {
+        return onErrorListener;
+    }
+
+    public void setOnErrorListener(OnErrorListener listener) {
+        this.onErrorListener = listener;
+    }
+
+    public SimpleGraphObjectCursor<T> getCursor() {
+        return cursor;
+    }
+
+    public void clearResults() {
+        nextRequest = null;
+        originalRequest = null;
+        currentRequest = null;
+
+        deliverResult(null);
+    }
+
+    public boolean isLoading() {
+        return loading;
+    }
+
+    public void startLoading(Request request, boolean skipRoundtripIfCached) {
+        originalRequest = request;
+        startLoading(request, skipRoundtripIfCached, 0);
+    }
+
+    public void refreshOriginalRequest(long afterDelay) {
+        if (originalRequest == null) {
+            throw new FacebookException(
+                    "refreshOriginalRequest may not be called until after startLoading has been called.");
+        }
+        startLoading(originalRequest, false, afterDelay);
+    }
+
+    public void followNextLink() {
+        if (nextRequest != null) {
+            appendResults = true;
+            currentRequest = nextRequest;
+
+            currentRequest.setCallback(new Request.Callback() {
+                @Override
+                public void onCompleted(Response response) {
+                    requestCompleted(response);
+                }
+            });
+
+            loading = true;
+            CacheableRequestBatch batch = putRequestIntoBatch(currentRequest, skipRoundtripIfCached);
+            Request.executeBatchAsync(batch);
+        }
+    }
+
+    @Override
+    public void deliverResult(SimpleGraphObjectCursor<T> cursor) {
+        SimpleGraphObjectCursor<T> oldCursor = this.cursor;
+        this.cursor = cursor;
+
+        if (isStarted()) {
+            super.deliverResult(cursor);
+
+            if (oldCursor != null && oldCursor != cursor && !oldCursor.isClosed()) {
+                oldCursor.close();
+            }
+        }
+    }
+
+    @Override
+    protected void onStartLoading() {
+        super.onStartLoading();
+
+        if (cursor != null) {
+            deliverResult(cursor);
+        }
+    }
+
+    private void startLoading(Request request, boolean skipRoundtripIfCached, long afterDelay) {
+        this.skipRoundtripIfCached = skipRoundtripIfCached;
+        appendResults = false;
+        nextRequest = null;
+        currentRequest = request;
+        currentRequest.setCallback(new Request.Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                requestCompleted(response);
+            }
+        });
+
+        // We are considered loading even if we have a delay.
+        loading = true;
+
+        final RequestBatch batch = putRequestIntoBatch(request, skipRoundtripIfCached);
+        Runnable r = new Runnable() {
+            @Override
+            public void run() {
+                Request.executeBatchAsync(batch);
+            }
+        };
+        if (afterDelay == 0) {
+            r.run();
+        } else {
+            Handler handler = new Handler();
+            handler.postDelayed(r, afterDelay);
+        }
+    }
+
+    private CacheableRequestBatch putRequestIntoBatch(Request request, boolean skipRoundtripIfCached) {
+        // We just use the request URL as the cache key.
+        CacheableRequestBatch batch = new CacheableRequestBatch(request);
+        // We use the default cache key (request URL).
+        batch.setForceRoundTrip(!skipRoundtripIfCached);
+        return batch;
+    }
+
+    private void requestCompleted(Response response) {
+        Request request = response.getRequest();
+        if (request != currentRequest) {
+            return;
+        }
+
+        loading = false;
+        currentRequest = null;
+
+        FacebookRequestError requestError = response.getError();
+        FacebookException exception = (requestError == null) ? null : requestError.getException();
+        if (response.getGraphObject() == null && exception == null) {
+            exception = new FacebookException("GraphObjectPagingLoader received neither a result nor an error.");
+        }
+
+        if (exception != null) {
+            nextRequest = null;
+
+            if (onErrorListener != null) {
+                onErrorListener.onError(exception, this);
+            }
+        } else {
+            addResults(response);
+        }
+    }
+
+    private void addResults(Response response) {
+        SimpleGraphObjectCursor<T> cursorToModify = (cursor == null || !appendResults) ? new SimpleGraphObjectCursor<T>() :
+                new SimpleGraphObjectCursor<T>(cursor);
+
+        PagedResults result = response.getGraphObjectAs(PagedResults.class);
+        boolean fromCache = response.getIsFromCache();
+
+        GraphObjectList<T> data = result.getData().castToListOf(graphObjectClass);
+        boolean haveData = data.size() > 0;
+
+        if (haveData) {
+            nextRequest = response.getRequestForPagedResults(Response.PagingDirection.NEXT);
+
+            cursorToModify.addGraphObjects(data, fromCache);
+            cursorToModify.setMoreObjectsAvailable(true);
+        }
+
+        if (!haveData) {
+            cursorToModify.setMoreObjectsAvailable(false);
+            cursorToModify.setFromCache(fromCache);
+
+            nextRequest = null;
+        }
+
+        // Once we get any set of results NOT from the cache, stop trying to get any future ones
+        // from it.
+        if (!fromCache) {
+            skipRoundtripIfCached = false;
+        }
+
+        deliverResult(cursorToModify);
+    }
+
+    interface PagedResults extends GraphObject {
+        GraphObjectList<GraphObject> getData();
+    }
+}
diff --git a/facebook/src/com/facebook/widget/ImageDownloader.java b/facebook/src/com/facebook/widget/ImageDownloader.java
new file mode 100644
index 000000000..4ea4b5494
--- /dev/null
+++ b/facebook/src/com/facebook/widget/ImageDownloader.java
@@ -0,0 +1,343 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.os.Handler;
+import com.facebook.FacebookException;
+import com.facebook.internal.Utility;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.*;
+
+class ImageDownloader {
+    private static final int DOWNLOAD_QUEUE_MAX_CONCURRENT = WorkQueue.DEFAULT_MAX_CONCURRENT;
+    private static final int CACHE_READ_QUEUE_MAX_CONCURRENT = 2;
+    private static final Handler handler = new Handler();
+    private static WorkQueue downloadQueue = new WorkQueue(DOWNLOAD_QUEUE_MAX_CONCURRENT);
+    private static WorkQueue cacheReadQueue = new WorkQueue(CACHE_READ_QUEUE_MAX_CONCURRENT);
+
+    private static final Map<RequestKey, DownloaderContext> pendingRequests = new HashMap<RequestKey, DownloaderContext>();
+
+    /**
+     * Downloads the image specified in the passed in request.
+     * If a callback is specified, it is guaranteed to be invoked on the calling thread.
+     * @param request Request to process
+     */
+    static void downloadAsync(ImageRequest request) {
+        if (request == null) {
+            return;
+        }
+
+        // NOTE: This is the ONLY place where the original request's Url is read. From here on,
+        // we will keep track of the Url separately. This is because we might be dealing with a
+        // redirect response and the Url might change. We can't create our own new ImageRequests
+        // for these changed Urls since the caller might be doing some book-keeping with the request's
+        // object reference. So we keep the old references and just map them to new urls in the downloader
+        RequestKey key = new RequestKey(request.getImageUrl(), request.getCallerTag());
+        synchronized (pendingRequests) {
+            DownloaderContext downloaderContext = pendingRequests.get(key);
+            if (downloaderContext != null) {
+                downloaderContext.request = request;
+                downloaderContext.isCancelled = false;
+                downloaderContext.workItem.moveToFront();
+            } else {
+                enqueueCacheRead(request, key, request.isCachedRedirectAllowed());
+            }
+        }
+    }
+
+    static boolean cancelRequest(ImageRequest request) {
+        boolean cancelled = false;
+        RequestKey key = new RequestKey(request.getImageUrl(), request.getCallerTag());
+        synchronized (pendingRequests) {
+            DownloaderContext downloaderContext = pendingRequests.get(key);
+            if (downloaderContext != null) {
+                // If we were able to find the request in our list of pending requests, then we will
+                // definitely be able to prevent an ImageResponse from being issued. This is regardless
+                // of whether a cache-read or network-download is underway for this request.
+                cancelled = true;
+
+                if (downloaderContext.workItem.cancel()) {
+                    pendingRequests.remove(key);
+                } else {
+                    // May be attempting a cache-read right now. So keep track of the cancellation
+                    // to prevent network calls etc
+                    downloaderContext.isCancelled = true;
+                }
+            }
+        }
+
+        return cancelled;
+    }
+
+    static void prioritizeRequest(ImageRequest request) {
+        RequestKey key = new RequestKey(request.getImageUrl(), request.getCallerTag());
+        synchronized (pendingRequests) {
+            DownloaderContext downloaderContext = pendingRequests.get(key);
+            if (downloaderContext != null) {
+                downloaderContext.workItem.moveToFront();
+            }
+        }
+    }
+
+    private static void enqueueCacheRead(ImageRequest request, RequestKey key, boolean allowCachedRedirects) {
+        enqueueRequest(
+                request,
+                key,
+                cacheReadQueue,
+                new CacheReadWorkItem(request.getContext(), key, allowCachedRedirects));
+    }
+
+    private static void enqueueDownload(ImageRequest request, RequestKey key) {
+        enqueueRequest(
+                request,
+                key,
+                downloadQueue,
+                new DownloadImageWorkItem(request.getContext(), key));
+    }
+
+    private static void enqueueRequest(
+            ImageRequest request,
+            RequestKey key,
+            WorkQueue workQueue,
+            Runnable workItem) {
+        synchronized (pendingRequests) {
+            DownloaderContext downloaderContext = new DownloaderContext();
+            downloaderContext.request = request;
+            pendingRequests.put(key, downloaderContext);
+
+            // The creation of the WorkItem should be done after the pending request has been registered.
+            // This is necessary since the WorkItem might kick off right away and attempt to retrieve
+            // the request's DownloaderContext prior to it being ready for access.
+            //
+            // It is also necessary to hold on to the lock until after the workItem is created, since
+            // calls to cancelRequest or prioritizeRequest might come in and expect a registered
+            // request to have a workItem available as well.
+            downloaderContext.workItem = workQueue.addActiveWorkItem(workItem);
+        }
+    }
+
+    private static void issueResponse(
+            RequestKey key,
+            final Exception error,
+            final Bitmap bitmap,
+            final boolean isCachedRedirect) {
+        // Once the old downloader context is removed, we are thread-safe since this is the
+        // only reference to it
+        DownloaderContext completedRequestContext = removePendingRequest(key);
+        if (completedRequestContext != null && !completedRequestContext.isCancelled) {
+            final ImageRequest request = completedRequestContext.request;
+            final ImageRequest.Callback callback = request.getCallback();
+            if (callback != null) {
+                handler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        ImageResponse response = new ImageResponse(
+                                request,
+                                error,
+                                isCachedRedirect,
+                                bitmap);
+                        callback.onCompleted(response);
+                    }
+                });
+            }
+        }
+    }
+
+    private static void readFromCache(RequestKey key, Context context, boolean allowCachedRedirects) {
+        InputStream cachedStream = null;
+        boolean isCachedRedirect = false;
+        if (allowCachedRedirects) {
+            URL redirectUrl = UrlRedirectCache.getRedirectedUrl(context, key.url);
+            if (redirectUrl != null) {
+                cachedStream = ImageResponseCache.getCachedImageStream(redirectUrl, context);
+                isCachedRedirect = cachedStream != null;
+            }
+        }
+
+        if (!isCachedRedirect) {
+            cachedStream = ImageResponseCache.getCachedImageStream(key.url, context);
+        }
+
+        if (cachedStream != null) {
+            // We were able to find a cached image.
+            Bitmap bitmap = BitmapFactory.decodeStream(cachedStream);
+            Utility.closeQuietly(cachedStream);
+            issueResponse(key, null, bitmap, isCachedRedirect);
+        } else {
+            // Once the old downloader context is removed, we are thread-safe since this is the
+            // only reference to it
+            DownloaderContext downloaderContext = removePendingRequest(key);
+            if (downloaderContext != null && !downloaderContext.isCancelled) {
+                enqueueDownload(downloaderContext.request, key);
+            }
+        }
+    }
+
+    private static void download(RequestKey key, Context context) {
+        HttpURLConnection connection = null;
+        InputStream stream = null;
+        Exception error = null;
+        Bitmap bitmap = null;
+        boolean issueResponse = true;
+
+        try {
+            connection = (HttpURLConnection) key.url.openConnection();
+            connection.setInstanceFollowRedirects(false);
+
+            switch (connection.getResponseCode()) {
+                case HttpURLConnection.HTTP_MOVED_PERM:
+                case HttpURLConnection.HTTP_MOVED_TEMP:
+                    // redirect. So we need to perform further requests
+                    issueResponse = false;
+
+                    String redirectLocation = connection.getHeaderField("location");
+                    if (!Utility.isNullOrEmpty(redirectLocation)) {
+                        URL redirectUrl = new URL(redirectLocation);
+                        UrlRedirectCache.cacheUrlRedirect(context, key.url, redirectUrl);
+
+                        // Once the old downloader context is removed, we are thread-safe since this is the
+                        // only reference to it
+                        DownloaderContext downloaderContext = removePendingRequest(key);
+                        if (downloaderContext != null && !downloaderContext.isCancelled) {
+                            enqueueCacheRead(
+                                    downloaderContext.request,
+                                    new RequestKey(redirectUrl, key.tag),
+                                    false);
+                        }
+                    }
+                    break;
+
+                case HttpURLConnection.HTTP_OK:
+                    // image should be available
+                    stream = ImageResponseCache.interceptAndCacheImageStream(context, connection);
+                    bitmap = BitmapFactory.decodeStream(stream);
+                    break;
+
+                default:
+                    stream = connection.getErrorStream();
+                    InputStreamReader reader = new InputStreamReader(stream);
+                    char[] buffer = new char[128];
+                    int bufferLength;
+                    StringBuilder errorMessageBuilder = new StringBuilder();
+                    while ((bufferLength = reader.read(buffer, 0, buffer.length)) > 0) {
+                        errorMessageBuilder.append(buffer, 0, bufferLength);
+                    }
+                    Utility.closeQuietly(reader);
+
+                    error = new FacebookException(errorMessageBuilder.toString());
+                    break;
+            }
+        } catch (IOException e) {
+            error = e;
+        } finally {
+            Utility.closeQuietly(stream);
+            Utility.disconnectQuietly(connection);
+        }
+
+        if (issueResponse) {
+            issueResponse(key, error, bitmap, false);
+        }
+    }
+
+    private static DownloaderContext removePendingRequest(RequestKey key) {
+        synchronized (pendingRequests) {
+            return pendingRequests.remove(key);
+        }
+    }
+
+    private static class RequestKey {
+        private static final int HASH_SEED = 29; // Some random prime number
+        private static final int HASH_MULTIPLIER = 37; // Some random prime number
+
+        URL url;
+        Object tag;
+
+        RequestKey(URL url, Object tag) {
+            this.url = url;
+            this.tag = tag;
+        }
+
+        @Override
+        public int hashCode() {
+            int result = HASH_SEED;
+
+            result = (result * HASH_MULTIPLIER) + url.hashCode();
+            result = (result * HASH_MULTIPLIER) + tag.hashCode();
+
+            return result;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            boolean isEqual = false;
+
+            if (o != null && o instanceof RequestKey) {
+                RequestKey compareTo = (RequestKey)o;
+                isEqual = compareTo.url == url && compareTo.tag == tag;
+            }
+
+            return isEqual;
+        }
+    }
+
+    private static class DownloaderContext {
+        WorkQueue.WorkItem workItem;
+        ImageRequest request;
+        boolean isCancelled;
+    }
+
+    private static class CacheReadWorkItem implements Runnable {
+        private Context context;
+        private RequestKey key;
+        private boolean allowCachedRedirects;
+
+        CacheReadWorkItem(Context context, RequestKey key, boolean allowCachedRedirects) {
+            this.context = context;
+            this.key = key;
+            this.allowCachedRedirects = allowCachedRedirects;
+        }
+
+        @Override
+        public void run() {
+            readFromCache(key, context, allowCachedRedirects);
+        }
+    }
+
+    private static class DownloadImageWorkItem implements Runnable {
+        private Context context;
+        private RequestKey key;
+
+        DownloadImageWorkItem(Context context, RequestKey key) {
+            this.context = context;
+            this.key = key;
+        }
+
+        @Override
+        public void run() {
+            download(key, context);
+        }
+
+    }
+}
diff --git a/facebook/src/com/facebook/widget/ImageRequest.java b/facebook/src/com/facebook/widget/ImageRequest.java
new file mode 100644
index 000000000..81494109d
--- /dev/null
+++ b/facebook/src/com/facebook/widget/ImageRequest.java
@@ -0,0 +1,145 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.content.Context;
+import android.net.Uri;
+import com.facebook.internal.Validate;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+
+class ImageRequest {
+
+    interface Callback {
+        /**
+         * This method should always be called on the UI thread. ImageDownloader makes
+         * sure to do this when it is responsible for issuing the ImageResponse
+         * @param response
+         */
+        void onCompleted(ImageResponse response);
+    }
+
+    static final int UNSPECIFIED_DIMENSION = 0;
+
+    private static final String PROFILEPIC_URL_FORMAT =
+            "https://graph.facebook.com/%s/picture";
+    private static final String HEIGHT_PARAM = "height";
+    private static final String WIDTH_PARAM = "width";
+    private static final String MIGRATION_PARAM = "migration_overrides";
+    private static final String MIGRATION_VALUE = "{october_2012:true}";
+
+    private Context context;
+    private URL imageUrl;
+    private Callback callback;
+    private boolean allowCachedRedirects;
+    private Object callerTag;
+
+    static URL getProfilePictureUrl(
+            String userId,
+            int width,
+            int height)
+        throws MalformedURLException {
+
+        Validate.notNullOrEmpty(userId, "userId");
+
+        width = Math.max(width, UNSPECIFIED_DIMENSION);
+        height = Math.max(height, UNSPECIFIED_DIMENSION);
+
+        if (width == UNSPECIFIED_DIMENSION && height == UNSPECIFIED_DIMENSION) {
+            throw new IllegalArgumentException("Either width or height must be greater than 0");
+        }
+
+        Uri.Builder builder = new Uri.Builder().encodedPath(String.format(PROFILEPIC_URL_FORMAT, userId));
+
+        if (height != UNSPECIFIED_DIMENSION) {
+            builder.appendQueryParameter(HEIGHT_PARAM, String.valueOf(height));
+        }
+
+        if (width != UNSPECIFIED_DIMENSION) {
+            builder.appendQueryParameter(WIDTH_PARAM, String.valueOf(width));
+        }
+
+        builder.appendQueryParameter(MIGRATION_PARAM, MIGRATION_VALUE);
+
+        return new URL(builder.toString());
+    }
+
+    private ImageRequest(Builder builder) {
+        this.context = builder.context;
+        this.imageUrl = builder.imageUrl;
+        this.callback = builder.callback;
+        this.allowCachedRedirects = builder.allowCachedRedirects;
+        this.callerTag = builder.callerTag == null ? new Object() : builder.callerTag;
+    }
+
+    Context getContext() {
+        return context;
+    }
+
+    URL getImageUrl() {
+        return imageUrl;
+    }
+
+    Callback getCallback() {
+        return callback;
+    }
+
+    boolean isCachedRedirectAllowed() {
+        return allowCachedRedirects;
+    }
+
+    Object getCallerTag() {
+        return callerTag;
+    }
+
+    static class Builder {
+        // Required
+        private Context context;
+        private URL imageUrl;
+
+        // Optional
+        private Callback callback;
+        private boolean allowCachedRedirects;
+        private Object callerTag;
+
+        Builder(Context context, URL imageUrl) {
+            Validate.notNull(imageUrl, "imageUrl");
+            this.context = context;
+            this.imageUrl = imageUrl;
+        }
+
+        Builder setCallback(Callback callback) {
+            this.callback = callback;
+            return this;
+        }
+
+        Builder setCallerTag(Object callerTag) {
+            this.callerTag = callerTag;
+            return this;
+        }
+
+        Builder setAllowCachedRedirects(boolean allowCachedRedirects) {
+            this.allowCachedRedirects = allowCachedRedirects;
+            return this;
+        }
+
+        ImageRequest build() {
+            return new ImageRequest(this);
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/widget/ImageResponse.java b/facebook/src/com/facebook/widget/ImageResponse.java
new file mode 100644
index 000000000..98c52e8b8
--- /dev/null
+++ b/facebook/src/com/facebook/widget/ImageResponse.java
@@ -0,0 +1,50 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.graphics.Bitmap;
+
+class ImageResponse {
+
+    private ImageRequest request;
+    private Exception error;
+    private boolean isCachedRedirect;
+    private Bitmap bitmap;
+
+    ImageResponse(ImageRequest request, Exception error, boolean isCachedRedirect, Bitmap bitmap) {
+        this.request = request;
+        this.error = error;
+        this.bitmap = bitmap;
+        this.isCachedRedirect = isCachedRedirect;
+    }
+
+    ImageRequest getRequest() {
+        return request;
+    }
+
+    Exception getError() {
+        return error;
+    }
+
+    Bitmap getBitmap() {
+        return bitmap;
+    }
+
+    boolean isCachedRedirect() {
+        return isCachedRedirect;
+    }
+}
diff --git a/facebook/src/com/facebook/widget/ImageResponseCache.java b/facebook/src/com/facebook/widget/ImageResponseCache.java
new file mode 100644
index 000000000..05799e53a
--- /dev/null
+++ b/facebook/src/com/facebook/widget/ImageResponseCache.java
@@ -0,0 +1,113 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.content.Context;
+import android.util.Log;
+import com.facebook.internal.Logger;
+import com.facebook.LoggingBehavior;
+import com.facebook.internal.Utility;
+import com.facebook.internal.FileLruCache;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+
+class ImageResponseCache {
+    static final String TAG = ImageResponseCache.class.getSimpleName();
+
+    private volatile static FileLruCache imageCache;
+
+    synchronized static FileLruCache getCache(Context context) throws IOException{
+        if (imageCache == null) {
+            imageCache = new FileLruCache(context.getApplicationContext(), TAG, new FileLruCache.Limits());
+        }
+        return imageCache;
+    }
+
+    // Get stream from cache, or return null if the image is not cached.
+    // Does not throw if there was an error.
+    static InputStream getCachedImageStream(URL url, Context context) {
+        InputStream imageStream = null;
+        if (url != null) {
+            if (isCDNURL(url)) {
+                try {
+                    FileLruCache cache = getCache(context);
+                    imageStream = cache.get(url.toString());
+                } catch (IOException e) {
+                    Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, e.toString());
+                }
+            }
+        }
+
+        return imageStream;
+    }
+
+    static InputStream interceptAndCacheImageStream(Context context, HttpURLConnection connection) throws IOException {
+        InputStream stream = null;
+        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {
+            URL url = connection.getURL();
+            stream = connection.getInputStream(); // Default stream in case caching fails
+            if (isCDNURL(url)) {
+                try {
+                    FileLruCache cache = getCache(context);
+
+                    // Wrap stream with a caching stream
+                    stream = cache.interceptAndPut(
+                            url.toString(),
+                            new BufferedHttpInputStream(stream, connection));
+                } catch (IOException e) {
+                    // Caching is best effort
+                }
+            }
+        }
+        return stream;
+    }
+
+   private static boolean isCDNURL(URL url) {
+        if (url != null) {
+            String uriHost = url.getHost();
+
+            if (uriHost.endsWith("fbcdn.net")) {
+                return true;
+            }
+
+            if (uriHost.startsWith("fbcdn") && uriHost.endsWith("akamaihd.net")) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private static class BufferedHttpInputStream extends BufferedInputStream {
+        HttpURLConnection connection;
+        BufferedHttpInputStream(InputStream stream, HttpURLConnection connection) {
+            super(stream, Utility.DEFAULT_STREAM_BUFFER_SIZE);
+            this.connection = connection;
+        }
+
+        @Override
+        public void close() throws IOException {
+            super.close();
+            Utility.disconnectQuietly(connection);
+        }
+    }
+}
+
diff --git a/facebook/src/com/facebook/widget/LoginButton.java b/facebook/src/com/facebook/widget/LoginButton.java
new file mode 100644
index 000000000..ea65d0a81
--- /dev/null
+++ b/facebook/src/com/facebook/widget/LoginButton.java
@@ -0,0 +1,673 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.res.TypedArray;
+import android.support.v4.app.Fragment;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.view.View;
+import android.widget.Button;
+import com.facebook.*;
+import com.facebook.android.R;
+import com.facebook.model.GraphUser;
+import com.facebook.internal.SessionAuthorizationType;
+import com.facebook.internal.SessionTracker;
+import com.facebook.internal.Utility;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A Log In/Log Out button that maintains session state and logs
+ * in/out for the app.
+ * <p/>
+ * This control will create and use the active session upon construction
+ * if it has the available data (if the app ID is specified in the manifest).
+ * It will also open the active session if it does not require user interaction
+ * (i.e. if the session is in the {@link com.facebook.SessionState#CREATED_TOKEN_LOADED} state.
+ * Developers can override the use of the active session by calling
+ * the {@link #setSession(com.facebook.Session)} method.
+ */
+public class LoginButton extends Button {
+
+    private static final String TAG = LoginButton.class.getName();
+    private String applicationId = null;
+    private SessionTracker sessionTracker;
+    private GraphUser user = null;
+    private Session userInfoSession = null; // the Session used to fetch the current user info
+    private boolean confirmLogout;
+    private boolean fetchUserInfo;
+    private String loginText;
+    private String logoutText;
+    private UserInfoChangedCallback userInfoChangedCallback;
+    private Fragment parentFragment;
+    private LoginButtonProperties properties = new LoginButtonProperties();
+
+    static class LoginButtonProperties {
+        private SessionDefaultAudience defaultAudience = SessionDefaultAudience.FRIENDS;
+        private List<String> permissions = Collections.<String>emptyList();
+        private SessionAuthorizationType authorizationType = null;
+        private OnErrorListener onErrorListener;
+        private SessionLoginBehavior loginBehavior = SessionLoginBehavior.SSO_WITH_FALLBACK;
+        private Session.StatusCallback sessionStatusCallback;
+
+        public void setOnErrorListener(OnErrorListener onErrorListener) {
+            this.onErrorListener = onErrorListener;
+        }
+
+        public OnErrorListener getOnErrorListener() {
+            return onErrorListener;
+        }
+
+        public void setDefaultAudience(SessionDefaultAudience defaultAudience) {
+            this.defaultAudience = defaultAudience;
+        }
+
+        public SessionDefaultAudience getDefaultAudience() {
+            return defaultAudience;
+        }
+
+        public void setReadPermissions(List<String> permissions, Session session) {
+            if (SessionAuthorizationType.PUBLISH.equals(authorizationType)) {
+                throw new UnsupportedOperationException(
+                        "Cannot call setReadPermissions after setPublishPermissions has been called.");
+            }
+            if (validatePermissions(permissions, SessionAuthorizationType.READ, session)) {
+                this.permissions = permissions;
+                authorizationType = SessionAuthorizationType.READ;
+            }
+        }
+
+        public void setPublishPermissions(List<String> permissions, Session session) {
+            if (SessionAuthorizationType.READ.equals(authorizationType)) {
+                throw new UnsupportedOperationException(
+                        "Cannot call setPublishPermissions after setReadPermissions has been called.");
+            }
+            if (validatePermissions(permissions, SessionAuthorizationType.PUBLISH, session)) {
+                this.permissions = permissions;
+                authorizationType = SessionAuthorizationType.PUBLISH;
+            }
+        }
+
+        private boolean validatePermissions(List<String> permissions,
+                SessionAuthorizationType authType, Session currentSession) {
+            if (SessionAuthorizationType.PUBLISH.equals(authType)) {
+                if (Utility.isNullOrEmpty(permissions)) {
+                    throw new IllegalArgumentException("Permissions for publish actions cannot be null or empty.");
+                }
+            }
+            if (currentSession != null && currentSession.isOpened()) {
+                if (!Utility.isSubset(permissions, currentSession.getPermissions())) {
+                    Log.e(TAG, "Cannot set additional permissions when session is already open.");
+                    return false;
+                }
+            }
+            return true;
+        }
+
+        List<String> getPermissions() {
+            return permissions;
+        }
+
+        public void clearPermissions() {
+            permissions = null;
+            authorizationType = null;
+        }
+
+        public void setLoginBehavior(SessionLoginBehavior loginBehavior) {
+            this.loginBehavior = loginBehavior;
+        }
+
+        public SessionLoginBehavior getLoginBehavior() {
+            return loginBehavior;
+        }
+
+        public void setSessionStatusCallback(Session.StatusCallback callback) {
+            this.sessionStatusCallback = callback;
+        }
+
+        public Session.StatusCallback getSessionStatusCallback() {
+            return sessionStatusCallback;
+        }
+    }
+
+    /**
+     * Specifies a callback interface that will be called when the button's notion of the current
+     * user changes (if the fetch_user_info attribute is true for this control).
+     */
+    public interface UserInfoChangedCallback {
+        /**
+         * Called when the current user changes.
+         * @param user  the current user, or null if there is no user
+         */
+        void onUserInfoFetched(GraphUser user);
+    }
+
+    /**
+     * Callback interface that will be called when a network or other error is encountered
+     * while logging in.
+     */
+    public interface OnErrorListener {
+        /**
+         * Called when a network or other error is encountered.
+         * @param error     a FacebookException representing the error that was encountered.
+         */
+        void onError(FacebookException error);
+    }
+
+    /**
+     * Create the LoginButton.
+     *
+     * @see View#View(Context)
+     */
+    public LoginButton(Context context) {
+        super(context);
+        initializeActiveSessionWithCachedToken(context);
+        // since onFinishInflate won't be called, we need to finish initialization ourselves
+        finishInit();
+    }
+
+    /**
+     * Create the LoginButton by inflating from XML
+     *
+     * @see View#View(Context, AttributeSet)
+     */
+    public LoginButton(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        if (attrs.getStyleAttribute() == 0) {
+                // apparently there's no method of setting a default style in xml,
+                // so in case the users do not explicitly specify a style, we need
+                // to use sensible defaults.
+                this.setTextColor(getResources().getColor(R.color.com_facebook_loginview_text_color));
+                this.setTextSize(TypedValue.COMPLEX_UNIT_PX,
+                        getResources().getDimension(R.dimen.com_facebook_loginview_text_size));
+                this.setPadding(getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_left),
+                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_top),
+                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_right),
+                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_bottom));
+                this.setWidth(getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_width));
+                this.setHeight(getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_height));
+                this.setGravity(Gravity.CENTER);
+
+            parseAttributes(attrs);
+            if(isInEditMode()) {
+                // cannot use a drawable in edit mode, so setting the background color instead
+                // of a background resource.
+                this.setBackgroundColor(getResources().getColor(R.color.com_facebook_blue));
+                // hardcoding in edit mode as getResources().getString() doesn't seem to work in IntelliJ
+                loginText = "Log in";
+            } else {
+                this.setBackgroundResource(R.drawable.com_facebook_loginbutton_blue);
+                initializeActiveSessionWithCachedToken(context);
+            }
+        }
+    }
+
+    /**
+     * Create the LoginButton by inflating from XML and applying a style.
+     *
+     * @see View#View(Context, AttributeSet, int)
+     */
+    public LoginButton(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        parseAttributes(attrs);
+        initializeActiveSessionWithCachedToken(context);
+    }
+
+    /**
+     * Sets an OnErrorListener for this instance of LoginButton to call into when
+     * certain exceptions occur.
+     *
+     * @param onErrorListener The listener object to set
+     */
+    public void setOnErrorListener(OnErrorListener onErrorListener) {
+        properties.setOnErrorListener(onErrorListener);
+    }
+
+    /**
+     * Returns the current OnErrorListener for this instance of LoginButton.
+     *
+     * @return The OnErrorListener
+     */
+    public OnErrorListener getOnErrorListener() {
+        return properties.getOnErrorListener();
+    }
+
+    /**
+     * Sets the default audience to use when the session is opened.
+     * This value is only useful when specifying write permissions for the native
+     * login dialog.
+     *
+     * @param defaultAudience the default audience value to use
+     */
+    public void setDefaultAudience(SessionDefaultAudience defaultAudience) {
+        properties.setDefaultAudience(defaultAudience);
+    }
+
+    /**
+     * Gets the default audience to use when the session is opened.
+     * This value is only useful when specifying write permissions for the native
+     * login dialog.
+     *
+     * @return the default audience value to use
+     */
+    public SessionDefaultAudience getDefaultAudience() {
+        return properties.getDefaultAudience();
+    }
+
+    /**
+     * Set the permissions to use when the session is opened. The permissions here
+     * can only be read permissions. If any publish permissions are included, the login
+     * attempt by the user will fail. The LoginButton can only be associated with either
+     * read permissions or publish permissions, but not both. Calling both
+     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
+     * will result in an exception being thrown unless clearPermissions is called in between.
+     * <p/>
+     * This method is only meaningful if called before the session is open. If this is called
+     * after the session is opened, and the list of permissions passed in is not a subset
+     * of the permissions granted during the authorization, it will log an error.
+     * <p/>
+     * Since the session can be automatically opened when the LoginButton is constructed,
+     * it's important to always pass in a consistent set of permissions to this method, or
+     * manage the setting of permissions outside of the LoginButton class altogether
+     * (by managing the session explicitly).
+     *
+     * @param permissions the read permissions to use
+     *
+     * @throws UnsupportedOperationException if setPublishPermissions has been called
+     */
+    public void setReadPermissions(List<String> permissions) {
+        properties.setReadPermissions(permissions, sessionTracker.getSession());
+    }
+
+    /**
+     * Set the permissions to use when the session is opened. The permissions here
+     * should only be publish permissions. If any read permissions are included, the login
+     * attempt by the user may fail. The LoginButton can only be associated with either
+     * read permissions or publish permissions, but not both. Calling both
+     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
+     * will result in an exception being thrown unless clearPermissions is called in between.
+     * <p/>
+     * This method is only meaningful if called before the session is open. If this is called
+     * after the session is opened, and the list of permissions passed in is not a subset
+     * of the permissions granted during the authorization, it will log an error.
+     * <p/>
+     * Since the session can be automatically opened when the LoginButton is constructed,
+     * it's important to always pass in a consistent set of permissions to this method, or
+     * manage the setting of permissions outside of the LoginButton class altogether
+     * (by managing the session explicitly).
+     *
+     * @param permissions the read permissions to use
+     *
+     * @throws UnsupportedOperationException if setReadPermissions has been called
+     * @throws IllegalArgumentException if permissions is null or empty
+     */
+    public void setPublishPermissions(List<String> permissions) {
+        properties.setPublishPermissions(permissions, sessionTracker.getSession());
+    }
+
+
+    /**
+     * Clears the permissions currently associated with this LoginButton.
+     */
+    public void clearPermissions() {
+        properties.clearPermissions();
+    }
+
+    /**
+     * Sets the login behavior for the session that will be opened. If null is specified,
+     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
+     * will be used.
+     *
+     * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
+     *                      specifies what behaviors should be attempted during
+     *                      authorization.
+     */
+    public void setLoginBehavior(SessionLoginBehavior loginBehavior) {
+        properties.setLoginBehavior(loginBehavior);
+    }
+
+    /**
+     * Gets the login behavior for the session that will be opened. If null is returned,
+     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
+     * will be used.
+     *
+     * @return loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
+     *                      specifies what behaviors should be attempted during
+     *                      authorization.
+     */
+    public SessionLoginBehavior getLoginBehavior() {
+        return properties.getLoginBehavior();
+    }
+
+    /**
+     * Set the application ID to be used to open the session.
+     *
+     * @param applicationId the application ID to use
+     */
+    public void setApplicationId(String applicationId) {
+        this.applicationId = applicationId;
+    }
+
+    /**
+     * Gets the callback interface that will be called when the current user changes.
+     * @return the callback interface
+     */
+    public UserInfoChangedCallback getUserInfoChangedCallback() {
+        return userInfoChangedCallback;
+    }
+
+    /**
+     * Sets the callback interface that will be called when the current user changes.
+     *
+     * @param userInfoChangedCallback   the callback interface
+     */
+    public void setUserInfoChangedCallback(UserInfoChangedCallback userInfoChangedCallback) {
+        this.userInfoChangedCallback = userInfoChangedCallback;
+    }
+
+    /**
+     * Sets the callback interface that will be called whenever the status of the Session
+     * associated with this LoginButton changes. Note that updates will only be sent to the
+     * callback while the LoginButton is actually attached to a window.
+     *
+     * @param callback the callback interface
+     */
+    public void setSessionStatusCallback(Session.StatusCallback callback) {
+        properties.setSessionStatusCallback(callback);
+    }
+
+    /**
+     * Sets the callback interface that will be called whenever the status of the Session
+     * associated with this LoginButton changes.
+
+     * @return the callback interface
+     */
+    public Session.StatusCallback getSessionStatusCallback() {
+        return properties.getSessionStatusCallback();
+    }
+
+    /**
+     * Provides an implementation for {@link Activity#onActivityResult
+     * onActivityResult} that updates the Session based on information returned
+     * during the authorization flow. The Activity containing this view
+     * should forward the resulting onActivityResult call here to
+     * update the Session state based on the contents of the resultCode and
+     * data.
+     *
+     * @param requestCode
+     *            The requestCode parameter from the forwarded call. When this
+     *            onActivityResult occurs as part of Facebook authorization
+     *            flow, this value is the activityCode passed to open or
+     *            authorize.
+     * @param resultCode
+     *            An int containing the resultCode parameter from the forwarded
+     *            call.
+     * @param data
+     *            The Intent passed as the data parameter from the forwarded
+     *            call.
+     * @return A boolean indicating whether the requestCode matched a pending
+     *         authorization request for this Session.
+     * @see Session#onActivityResult(Activity, int, int, Intent)
+     */
+    public boolean onActivityResult(int requestCode, int resultCode, Intent data) {
+        Session session = sessionTracker.getSession();
+        if (session != null) {
+            return session.onActivityResult((Activity)getContext(), requestCode,
+                    resultCode, data);
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Set the Session object to use instead of the active Session. Since a Session
+     * cannot be reused, if the user logs out from this Session, and tries to
+     * log in again, a new Active Session will be used instead.
+     * <p/>
+     * If the passed in session is currently opened, this method will also attempt to
+     * load some user information for display (if needed).
+     *
+     * @param newSession the Session object to use
+     * @throws FacebookException if errors occur during the loading of user information
+     */
+    public void setSession(Session newSession) {
+        sessionTracker.setSession(newSession);
+        fetchUserInfo();
+        setButtonText();
+    }
+
+    @Override
+    public void onFinishInflate() {
+        super.onFinishInflate();
+        finishInit();
+    }
+
+    private void finishInit() {
+        setOnClickListener(new LoginClickListener());
+        setButtonText();
+        if (!isInEditMode()) {
+            sessionTracker = new SessionTracker(getContext(), new LoginButtonCallback(), null, false);
+            fetchUserInfo();
+        }
+    }
+
+    /**
+     * Sets the fragment that contains this control. This allows the LoginButton to be
+     * embedded inside a Fragment, and will allow the fragment to receive the
+     * {@link Fragment#onActivityResult(int, int, android.content.Intent) onActivityResult}
+     * call rather than the Activity.
+     *
+     * @param fragment the fragment that contains this control
+     */
+    public void setFragment(Fragment fragment) {
+        parentFragment = fragment;
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        if (sessionTracker != null && !sessionTracker.isTracking()) {
+            sessionTracker.startTracking();
+            fetchUserInfo();
+            setButtonText();
+        }
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        if (sessionTracker != null) {
+            sessionTracker.stopTracking();
+        }
+    }
+
+    // For testing purposes only
+    List<String> getPermissions() {
+        return properties.getPermissions();
+    }
+
+    void setProperties(LoginButtonProperties properties) {
+        this.properties = properties;
+    }
+
+    private void parseAttributes(AttributeSet attrs) {
+        TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.com_facebook_login_view);
+        confirmLogout = a.getBoolean(R.styleable.com_facebook_login_view_confirm_logout, true);
+        fetchUserInfo = a.getBoolean(R.styleable.com_facebook_login_view_fetch_user_info, true);
+        loginText = a.getString(R.styleable.com_facebook_login_view_login_text);
+        logoutText = a.getString(R.styleable.com_facebook_login_view_logout_text);
+        a.recycle();
+    }
+
+    private void setButtonText() {
+        if (sessionTracker != null && sessionTracker.getOpenSession() != null) {
+            setText((logoutText != null) ? logoutText :
+                    getResources().getString(R.string.com_facebook_loginview_log_out_button));
+        } else {
+            setText((loginText != null) ? loginText :
+                    getResources().getString(R.string.com_facebook_loginview_log_in_button));
+        }
+    }
+
+    private boolean initializeActiveSessionWithCachedToken(Context context) {
+        if (context == null) {
+            return false;
+        }
+
+        Session session = Session.getActiveSession();
+        if (session != null) {
+            return session.isOpened();
+        }
+
+        String applicationId = Utility.getMetadataApplicationId(context);
+        if (applicationId == null) {
+            return false;
+        }
+
+        return Session.openActiveSessionFromCache(context) != null;
+    }
+
+    private void fetchUserInfo() {
+        if (fetchUserInfo) {
+            final Session currentSession = sessionTracker.getOpenSession();
+            if (currentSession != null) {
+                if (currentSession != userInfoSession) {
+                    Request request = Request.newMeRequest(currentSession, new Request.GraphUserCallback() {
+                        @Override
+                        public void onCompleted(GraphUser me,  Response response) {
+                            if (currentSession == sessionTracker.getOpenSession()) {
+                                user = me;
+                                if (userInfoChangedCallback != null) {
+                                    userInfoChangedCallback.onUserInfoFetched(user);
+                                }
+                            }
+                            if (response.getError() != null) {
+                                handleError(response.getError().getException());
+                            }
+                        }
+                    });
+                    Request.executeBatchAsync(request);
+                    userInfoSession = currentSession;
+                }
+            } else {
+                user = null;
+                if (userInfoChangedCallback != null) {
+                    userInfoChangedCallback.onUserInfoFetched(user);
+                }
+            }
+        }
+    }
+
+    private class LoginClickListener implements OnClickListener {
+
+        @Override
+        public void onClick(View v) {
+            Context context = getContext();
+            final Session openSession = sessionTracker.getOpenSession();
+            if (openSession != null) {
+                // If the Session is currently open, it must mean we need to log out
+                if (confirmLogout) {
+                    // Create a confirmation dialog
+                    String logout = getResources().getString(R.string.com_facebook_loginview_log_out_action);
+                    String cancel = getResources().getString(R.string.com_facebook_loginview_cancel_action);
+                    String message;
+                    if (user != null && user.getName() != null) {
+                        message = String.format(getResources().getString(R.string.com_facebook_loginview_logged_in_as), user.getName());
+                    } else {
+                        message = getResources().getString(R.string.com_facebook_loginview_logged_in_using_facebook);
+                    }
+                    AlertDialog.Builder builder = new AlertDialog.Builder(context);
+                    builder.setMessage(message)
+                           .setCancelable(true)
+                           .setPositiveButton(logout, new DialogInterface.OnClickListener() {
+                               public void onClick(DialogInterface dialog, int which) {
+                                   openSession.closeAndClearTokenInformation();
+                               }
+                           })
+                           .setNegativeButton(cancel, null);
+                    builder.create().show();
+                } else {
+                    openSession.closeAndClearTokenInformation();
+                }
+            } else {
+                Session currentSession = sessionTracker.getSession();
+                if (currentSession == null || currentSession.getState().isClosed()) {
+                    sessionTracker.setSession(null);
+                    Session session = new Session.Builder(context).setApplicationId(applicationId).build();
+                    Session.setActiveSession(session);
+                    currentSession = session;
+                }
+                if (!currentSession.isOpened()) {
+                    Session.OpenRequest openRequest = null;
+                    if (parentFragment != null) {
+                        openRequest = new Session.OpenRequest(parentFragment);
+                    } else if (context instanceof Activity) {
+                        openRequest = new Session.OpenRequest((Activity)context);
+                    }
+
+                    if (openRequest != null) {
+                        openRequest.setDefaultAudience(properties.defaultAudience);
+                        openRequest.setPermissions(properties.permissions);
+                        openRequest.setLoginBehavior(properties.loginBehavior);
+
+                        if (SessionAuthorizationType.PUBLISH.equals(properties.authorizationType)) {
+                            currentSession.openForPublish(openRequest);
+                        } else {
+                            currentSession.openForRead(openRequest);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private class LoginButtonCallback implements Session.StatusCallback {
+        @Override
+        public void call(Session session, SessionState state,
+                         Exception exception) {
+            fetchUserInfo();
+            setButtonText();
+            if (exception != null) {
+                handleError(exception);
+            }
+
+            if (properties.sessionStatusCallback != null) {
+                properties.sessionStatusCallback.call(session, state, exception);
+            }
+        }
+    };
+
+    void handleError(Exception exception) {
+        if (properties.onErrorListener != null) {
+            if (exception instanceof FacebookException) {
+                properties.onErrorListener.onError((FacebookException)exception);
+            } else {
+                properties.onErrorListener.onError(new FacebookException(exception));
+            }
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/widget/PickerFragment.java b/facebook/src/com/facebook/widget/PickerFragment.java
new file mode 100644
index 000000000..bea02692f
--- /dev/null
+++ b/facebook/src/com/facebook/widget/PickerFragment.java
@@ -0,0 +1,1040 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.drawable.Drawable;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.LoaderManager;
+import android.support.v4.content.Loader;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewStub;
+import android.view.animation.AlphaAnimation;
+import android.widget.*;
+import com.facebook.*;
+import com.facebook.android.R;
+import com.facebook.model.GraphObject;
+import com.facebook.internal.SessionTracker;
+
+import java.util.*;
+
+/**
+ * Provides functionality common to SDK UI elements that allow the user to pick one or more
+ * graph objects (e.g., places, friends) from a list of possibilities. The UI is exposed as a
+ * Fragment to allow to it to be included in an Activity along with other Fragments. The Fragments
+ * can be configured by passing parameters as part of their Intent bundle, or (for certain
+ * properties) by specifying attributes in their XML layout files.
+ * <br/>
+ * PickerFragments support callbacks that will be called in the event of an error, when the
+ * underlying data has been changed, or when the set of selected graph objects changes.
+ */
+public abstract class PickerFragment<T extends GraphObject> extends Fragment {
+    /**
+     * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
+     * picker should show pictures (if available) for the graph objects.
+     */
+    public static final String SHOW_PICTURES_BUNDLE_KEY = "com.facebook.widget.PickerFragment.ShowPictures";
+    /**
+     * The key for a String parameter in the fragment's Intent bundle to indicate which extra fields
+     * beyond the default fields should be retrieved for any graph objects in the results.
+     */
+    public static final String EXTRA_FIELDS_BUNDLE_KEY = "com.facebook.widget.PickerFragment.ExtraFields";
+    /**
+     * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
+     * picker should display a title bar with a Done button.
+     */
+    public static final String SHOW_TITLE_BAR_BUNDLE_KEY = "com.facebook.widget.PickerFragment.ShowTitleBar";
+    /**
+     * The key for a String parameter in the fragment's Intent bundle to indicate the text to
+     * display in the title bar.
+     */
+    public static final String TITLE_TEXT_BUNDLE_KEY = "com.facebook.widget.PickerFragment.TitleText";
+    /**
+     * The key for a String parameter in the fragment's Intent bundle to indicate the text to
+     * display in the Done btuton.
+     */
+    public static final String DONE_BUTTON_TEXT_BUNDLE_KEY = "com.facebook.widget.PickerFragment.DoneButtonText";
+
+    private static final String SELECTION_BUNDLE_KEY = "com.facebook.android.PickerFragment.Selection";
+    private static final String ACTIVITY_CIRCLE_SHOW_KEY = "com.facebook.android.PickerFragment.ActivityCircleShown";
+    private static final int PROFILE_PICTURE_PREFETCH_BUFFER = 5;
+
+    private final int layout;
+    private OnErrorListener onErrorListener;
+    private OnDataChangedListener onDataChangedListener;
+    private OnSelectionChangedListener onSelectionChangedListener;
+    private OnDoneButtonClickedListener onDoneButtonClickedListener;
+    private GraphObjectFilter<T> filter;
+    private boolean showPictures = true;
+    private boolean showTitleBar = true;
+    private ListView listView;
+    HashSet<String> extraFields = new HashSet<String>();
+    GraphObjectAdapter<T> adapter;
+    private final Class<T> graphObjectClass;
+    private LoadingStrategy loadingStrategy;
+    private SelectionStrategy selectionStrategy;
+    private ProgressBar activityCircle;
+    private SessionTracker sessionTracker;
+    private String titleText;
+    private String doneButtonText;
+    private TextView titleTextView;
+    private Button doneButton;
+    private Drawable titleBarBackground;
+    private Drawable doneButtonBackground;
+
+    PickerFragment(Class<T> graphObjectClass, int layout, Bundle args) {
+        this.graphObjectClass = graphObjectClass;
+        this.layout = layout;
+
+        setPickerFragmentSettingsFromBundle(args);
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        adapter = createAdapter();
+        adapter.setFilter(new GraphObjectAdapter.Filter<T>() {
+            @Override
+            public boolean includeItem(T graphObject) {
+                return filterIncludesItem(graphObject);
+            }
+        });
+    }
+
+    @Override
+    public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
+        super.onInflate(activity, attrs, savedInstanceState);
+        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.com_facebook_picker_fragment);
+
+        setShowPictures(a.getBoolean(R.styleable.com_facebook_picker_fragment_show_pictures, showPictures));
+        String extraFieldsString = a.getString(R.styleable.com_facebook_picker_fragment_extra_fields);
+        if (extraFieldsString != null) {
+            String[] strings = extraFieldsString.split(",");
+            setExtraFields(Arrays.asList(strings));
+        }
+
+        showTitleBar = a.getBoolean(R.styleable.com_facebook_picker_fragment_show_title_bar, showTitleBar);
+        titleText = a.getString(R.styleable.com_facebook_picker_fragment_title_text);
+        doneButtonText = a.getString(R.styleable.com_facebook_picker_fragment_done_button_text);
+        titleBarBackground = a.getDrawable(R.styleable.com_facebook_picker_fragment_title_bar_background);
+        doneButtonBackground = a.getDrawable(R.styleable.com_facebook_picker_fragment_done_button_background);
+
+        a.recycle();
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        ViewGroup view = (ViewGroup) inflater.inflate(layout, container, false);
+
+        listView = (ListView) view.findViewById(R.id.com_facebook_picker_list_view);
+        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+            @Override
+            public void onItemClick(AdapterView<?> parent, View v, int position, long id) {
+                onListItemClick((ListView) parent, v, position);
+            }
+        });
+        listView.setOnLongClickListener(new View.OnLongClickListener() {
+            @Override
+            public boolean onLongClick(View v) {
+                // We don't actually do anything differently on long-clicks, but setting the listener
+                // enables the selector transition that we have for visual consistency with the
+                // Facebook app's pickers.
+                return false;
+            }
+        });
+        listView.setOnScrollListener(onScrollListener);
+        listView.setAdapter(adapter);
+
+        activityCircle = (ProgressBar) view.findViewById(R.id.com_facebook_picker_activity_circle);
+
+        return view;
+    }
+
+    @Override
+    public void onActivityCreated(final Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+
+        sessionTracker = new SessionTracker(getActivity(), new Session.StatusCallback() {
+            @Override
+            public void call(Session session, SessionState state, Exception exception) {
+                if (!session.isOpened()) {
+                    // When a session is closed, we want to clear out our data so it is not visible to subsequent users
+                    clearResults();
+                }
+            }
+        });
+
+        setSettingsFromBundle(savedInstanceState);
+
+        loadingStrategy = createLoadingStrategy();
+        loadingStrategy.attach(adapter);
+
+        selectionStrategy = createSelectionStrategy();
+        selectionStrategy.readSelectionFromBundle(savedInstanceState, SELECTION_BUNDLE_KEY);
+
+        // Should we display a title bar? (We need to do this after we've retrieved our bundle settings.)
+        if (showTitleBar) {
+            inflateTitleBar((ViewGroup) getView());
+        }
+
+        if (activityCircle != null && savedInstanceState != null) {
+            boolean shown = savedInstanceState.getBoolean(ACTIVITY_CIRCLE_SHOW_KEY, false);
+            if (shown) {
+                displayActivityCircle();
+            } else {
+                // Should be hidden already, but just to be sure.
+                hideActivityCircle();
+            }
+        }
+    }
+
+    @Override
+    public void onDetach() {
+        super.onDetach();
+
+        listView.setOnScrollListener(null);
+        listView.setAdapter(null);
+
+        loadingStrategy.detach();
+        sessionTracker.stopTracking();
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        saveSettingsToBundle(outState);
+        selectionStrategy.saveSelectionToBundle(outState, SELECTION_BUNDLE_KEY);
+        if (activityCircle != null) {
+            outState.putBoolean(ACTIVITY_CIRCLE_SHOW_KEY, activityCircle.getVisibility() == View.VISIBLE);
+        }
+    }
+
+    @Override
+    public void setArguments(Bundle args) {
+        super.setArguments(args);
+        setSettingsFromBundle(args);
+    }
+
+    /**
+     * Gets the current OnDataChangedListener for this fragment, which will be called whenever
+     * the underlying data being displaying in the picker has changed.
+     *
+     * @return the OnDataChangedListener, or null if there is none
+     */
+    public OnDataChangedListener getOnDataChangedListener() {
+        return onDataChangedListener;
+    }
+
+    /**
+     * Sets the current OnDataChangedListener for this fragment, which will be called whenever
+     * the underlying data being displaying in the picker has changed.
+     *
+     * @param onDataChangedListener the OnDataChangedListener, or null if there is none
+     */
+    public void setOnDataChangedListener(OnDataChangedListener onDataChangedListener) {
+        this.onDataChangedListener = onDataChangedListener;
+    }
+
+    /**
+     * Gets the current OnSelectionChangedListener for this fragment, which will be called
+     * whenever the user selects or unselects a graph object in the list.
+     *
+     * @return the OnSelectionChangedListener, or null if there is none
+     */
+    public OnSelectionChangedListener getOnSelectionChangedListener() {
+        return onSelectionChangedListener;
+    }
+
+    /**
+     * Sets the current OnSelectionChangedListener for this fragment, which will be called
+     * whenever the user selects or unselects a graph object in the list.
+     *
+     * @param onSelectionChangedListener the OnSelectionChangedListener, or null if there is none
+     */
+    public void setOnSelectionChangedListener(
+            OnSelectionChangedListener onSelectionChangedListener) {
+        this.onSelectionChangedListener = onSelectionChangedListener;
+    }
+
+    /**
+     * Gets the current OnDoneButtonClickedListener for this fragment, which will be called
+     * when the user clicks the Done button.
+     *
+     * @return the OnDoneButtonClickedListener, or null if there is none
+     */
+    public OnDoneButtonClickedListener getOnDoneButtonClickedListener() {
+        return onDoneButtonClickedListener;
+    }
+
+    /**
+     * Sets the current OnDoneButtonClickedListener for this fragment, which will be called
+     * when the user clicks the Done button. This will only be possible if the title bar is
+     * being shown in this fragment.
+     *
+     * @param onDoneButtonClickedListener the OnDoneButtonClickedListener, or null if there is none
+     */
+    public void setOnDoneButtonClickedListener(OnDoneButtonClickedListener onDoneButtonClickedListener) {
+        this.onDoneButtonClickedListener = onDoneButtonClickedListener;
+    }
+
+    /**
+     * Gets the current OnErrorListener for this fragment, which will be called in the event
+     * of network or other errors encountered while populating the graph objects in the list.
+     *
+     * @return the OnErrorListener, or null if there is none
+     */
+    public OnErrorListener getOnErrorListener() {
+        return onErrorListener;
+    }
+
+    /**
+     * Sets the current OnErrorListener for this fragment, which will be called in the event
+     * of network or other errors encountered while populating the graph objects in the list.
+     *
+     * @param onErrorListener the OnErrorListener, or null if there is none
+     */
+    public void setOnErrorListener(OnErrorListener onErrorListener) {
+        this.onErrorListener = onErrorListener;
+    }
+
+    /**
+     * Gets the current filter for this fragment, which will be called for each graph object
+     * returned from the service to determine if it should be displayed in the list.
+     * If no filter is specified, all retrieved graph objects will be displayed.
+     *
+     * @return the GraphObjectFilter, or null if there is none
+     */
+    public GraphObjectFilter<T> getFilter() {
+        return filter;
+    }
+
+    /**
+     * Sets the current filter for this fragment, which will be called for each graph object
+     * returned from the service to determine if it should be displayed in the list.
+     * If no filter is specified, all retrieved graph objects will be displayed.
+     *
+     * @param filter the GraphObjectFilter, or null if there is none
+     */
+    public void setFilter(GraphObjectFilter<T> filter) {
+        this.filter = filter;
+    }
+
+    /**
+     * Gets the Session to use for any Facebook requests this fragment will make.
+     *
+     * @return the Session that will be used for any Facebook requests, or null if there is none
+     */
+    public Session getSession() {
+        return sessionTracker.getSession();
+    }
+
+    /**
+     * Sets the Session to use for any Facebook requests this fragment will make. If the
+     * parameter is null, the fragment will use the current active session, if any.
+     *
+     * @param session the Session to use for Facebook requests, or null to use the active session
+     */
+    public void setSession(Session session) {
+        sessionTracker.setSession(session);
+    }
+
+    /**
+     * Gets whether to display pictures, if available, for displayed graph objects.
+     *
+     * @return true if pictures should be displayed, false if not
+     */
+    public boolean getShowPictures() {
+        return showPictures;
+    }
+
+    /**
+     * Sets whether to display pictures, if available, for displayed graph objects.
+     *
+     * @param showPictures true if pictures should be displayed, false if not
+     */
+    public void setShowPictures(boolean showPictures) {
+        this.showPictures = showPictures;
+    }
+
+    /**
+     * Gets the extra fields to request for the retrieved graph objects.
+     *
+     * @return the extra fields to request
+     */
+    public Set<String> getExtraFields() {
+        return new HashSet<String>(extraFields);
+    }
+
+    /**
+     * Sets the extra fields to request for the retrieved graph objects.
+     *
+     * @param fields the extra fields to request
+     */
+    public void setExtraFields(Collection<String> fields) {
+        extraFields = new HashSet<String>();
+        if (fields != null) {
+            extraFields.addAll(fields);
+        }
+    }
+
+    /**
+     * Sets whether to show a title bar with a Done button. This must be
+     * called prior to the Fragment going through its creation lifecycle to have an effect.
+     *
+     * @param showTitleBar true if a title bar should be displayed, false if not
+     */
+    public void setShowTitleBar(boolean showTitleBar) {
+        this.showTitleBar = showTitleBar;
+    }
+
+    /**
+     * Gets whether to show a title bar with a Done button. The default is true.
+     *
+     * @return true if a title bar will be shown, false if not.
+     */
+    public boolean getShowTitleBar() {
+        return showTitleBar;
+    }
+
+    /**
+     * Sets the text to show in the title bar, if a title bar is to be shown. This must be
+     * called prior to the Fragment going through its creation lifecycle to have an effect, or
+     * the default will be used.
+     *
+     * @param titleText the text to show in the title bar
+     */
+    public void setTitleText(String titleText) {
+        this.titleText = titleText;
+    }
+
+    /**
+     * Gets the text to show in the title bar, if a title bar is to be shown.
+     *
+     * @return the text to show in the title bar
+     */
+    public String getTitleText() {
+        if (titleText == null) {
+            titleText = getDefaultTitleText();
+        }
+        return titleText;
+    }
+
+    /**
+     * Sets the text to show in the Done button, if a title bar is to be shown. This must be
+     * called prior to the Fragment going through its creation lifecycle to have an effect, or
+     * the default will be used.
+     *
+     * @param doneButtonText the text to show in the Done button
+     */
+    public void setDoneButtonText(String doneButtonText) {
+        this.doneButtonText = doneButtonText;
+    }
+
+    /**
+     * Gets the text to show in the Done button, if a title bar is to be shown.
+     *
+     * @return the text to show in the Done button
+     */
+    public String getDoneButtonText() {
+        if (doneButtonText == null) {
+            doneButtonText = getDefaultDoneButtonText();
+        }
+        return doneButtonText;
+    }
+
+    /**
+     * Causes the picker to load data from the service and display it to the user.
+     *
+     * @param forceReload if true, data will be loaded even if there is already data being displayed (or loading);
+     *                    if false, data will not be re-loaded if it is already displayed (or loading)
+     */
+    public void loadData(boolean forceReload) {
+        if (!forceReload && loadingStrategy.isDataPresentOrLoading()) {
+            return;
+        }
+        loadDataSkippingRoundTripIfCached();
+    }
+
+    /**
+     * Updates the properties of the PickerFragment based on the contents of the supplied Bundle;
+     * calling Activities may use this to pass additional configuration information to the
+     * PickerFragment beyond what is specified in its XML layout.
+     *
+     * @param inState a Bundle containing keys corresponding to properties of the PickerFragment
+     */
+    public void setSettingsFromBundle(Bundle inState) {
+        setPickerFragmentSettingsFromBundle(inState);
+    }
+
+    boolean filterIncludesItem(T graphObject) {
+        if (filter != null) {
+            return filter.includeItem(graphObject);
+        }
+        return true;
+    }
+
+    List<T> getSelectedGraphObjects() {
+        return adapter.getGraphObjectsById(selectionStrategy.getSelectedIds());
+    }
+
+    void saveSettingsToBundle(Bundle outState) {
+        outState.putBoolean(SHOW_PICTURES_BUNDLE_KEY, showPictures);
+        if (!extraFields.isEmpty()) {
+            outState.putString(EXTRA_FIELDS_BUNDLE_KEY, TextUtils.join(",", extraFields));
+        }
+        outState.putBoolean(SHOW_TITLE_BAR_BUNDLE_KEY, showTitleBar);
+        outState.putString(TITLE_TEXT_BUNDLE_KEY, titleText);
+        outState.putString(DONE_BUTTON_TEXT_BUNDLE_KEY, doneButtonText);
+    }
+
+    abstract Request getRequestForLoadData(Session session);
+
+    abstract PickerFragmentAdapter<T> createAdapter();
+
+    abstract LoadingStrategy createLoadingStrategy();
+
+    abstract SelectionStrategy createSelectionStrategy();
+
+    void onLoadingData() {
+    }
+
+    String getDefaultTitleText() {
+        return null;
+    }
+
+    String getDefaultDoneButtonText() {
+        return getString(R.string.com_facebook_picker_done_button_text);
+    }
+
+    void displayActivityCircle() {
+        if (activityCircle != null) {
+            layoutActivityCircle();
+            activityCircle.setVisibility(View.VISIBLE);
+        }
+    }
+
+    void layoutActivityCircle() {
+        // If we've got no data, make the activity circle full-opacity. Otherwise we'll dim it to avoid
+        //  cluttering the UI.
+        float alpha = (!adapter.isEmpty()) ? .25f : 1.0f;
+        setAlpha(activityCircle, alpha);
+    }
+
+    void hideActivityCircle() {
+        if (activityCircle != null) {
+            // We use an animation to dim the activity circle; need to clear this or it will remain visible.
+            activityCircle.clearAnimation();
+            activityCircle.setVisibility(View.INVISIBLE);
+        }
+    }
+
+    void setSelectionStrategy(SelectionStrategy selectionStrategy) {
+        if (selectionStrategy != this.selectionStrategy) {
+            this.selectionStrategy = selectionStrategy;
+            if (adapter != null) {
+                // Adapter should cause a re-render.
+                adapter.notifyDataSetChanged();
+            }
+        }
+    }
+
+    private static void setAlpha(View view, float alpha) {
+        // Set the alpha appropriately (setAlpha is API >= 11, this technique works on all API levels).
+        AlphaAnimation alphaAnimation = new AlphaAnimation(alpha, alpha);
+        alphaAnimation.setDuration(0);
+        alphaAnimation.setFillAfter(true);
+        view.startAnimation(alphaAnimation);
+    }
+
+
+    private void setPickerFragmentSettingsFromBundle(Bundle inState) {
+        // We do this in a separate non-overridable method so it is safe to call from the constructor.
+        if (inState != null) {
+            showPictures = inState.getBoolean(SHOW_PICTURES_BUNDLE_KEY, showPictures);
+            String extraFieldsString = inState.getString(EXTRA_FIELDS_BUNDLE_KEY);
+            if (extraFieldsString != null) {
+                String[] strings = extraFieldsString.split(",");
+                setExtraFields(Arrays.asList(strings));
+            }
+            showTitleBar = inState.getBoolean(SHOW_TITLE_BAR_BUNDLE_KEY, showTitleBar);
+            String titleTextString = inState.getString(TITLE_TEXT_BUNDLE_KEY);
+            if (titleTextString != null) {
+                titleText = titleTextString;
+                if (titleTextView != null) {
+                    titleTextView.setText(titleText);
+                }
+            }
+            String doneButtonTextString = inState.getString(DONE_BUTTON_TEXT_BUNDLE_KEY);
+            if (doneButtonTextString != null) {
+                doneButtonText = doneButtonTextString;
+                if (doneButton != null) {
+                    doneButton.setText(doneButtonText);
+                }
+            }
+        }
+    }
+
+    private void inflateTitleBar(ViewGroup view) {
+        ViewStub stub = (ViewStub) view.findViewById(R.id.com_facebook_picker_title_bar_stub);
+        if (stub != null) {
+            View titleBar = stub.inflate();
+
+            final RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
+                    RelativeLayout.LayoutParams.FILL_PARENT,
+                    RelativeLayout.LayoutParams.FILL_PARENT);
+            layoutParams.addRule(RelativeLayout.BELOW, R.id.com_facebook_picker_title_bar);
+            listView.setLayoutParams(layoutParams);
+
+            if (titleBarBackground != null) {
+                titleBar.setBackgroundDrawable(titleBarBackground);
+            }
+
+            doneButton = (Button) view.findViewById(R.id.com_facebook_picker_done_button);
+            if (doneButton != null) {
+                doneButton.setOnClickListener(new View.OnClickListener() {
+                    @Override
+                    public void onClick(View v) {
+                        if (onDoneButtonClickedListener != null) {
+                            onDoneButtonClickedListener.onDoneButtonClicked(PickerFragment.this);
+                        }
+                    }
+                });
+
+                if (getDoneButtonText() != null) {
+                    doneButton.setText(getDoneButtonText());
+                }
+
+                if (doneButtonBackground != null) {
+                    doneButton.setBackgroundDrawable(doneButtonBackground);
+                }
+            }
+
+            titleTextView = (TextView) view.findViewById(R.id.com_facebook_picker_title);
+            if (titleTextView != null) {
+                if (getTitleText() != null) {
+                    titleTextView.setText(getTitleText());
+                }
+            }
+        }
+    }
+
+    private void onListItemClick(ListView listView, View v, int position) {
+        @SuppressWarnings("unchecked")
+        T graphObject = (T) listView.getItemAtPosition(position);
+        String id = adapter.getIdOfGraphObject(graphObject);
+        selectionStrategy.toggleSelection(id);
+        adapter.notifyDataSetChanged();
+
+        if (onSelectionChangedListener != null) {
+            onSelectionChangedListener.onSelectionChanged(PickerFragment.this);
+        }
+    }
+
+    private void loadDataSkippingRoundTripIfCached() {
+        clearResults();
+
+        Request request = getRequestForLoadData(getSession());
+        if (request != null) {
+            onLoadingData();
+            loadingStrategy.startLoading(request);
+        }
+    }
+
+    private void clearResults() {
+        if (adapter != null) {
+            boolean wasSelection = !selectionStrategy.isEmpty();
+            boolean wasData = !adapter.isEmpty();
+
+            loadingStrategy.clearResults();
+            selectionStrategy.clear();
+            adapter.notifyDataSetChanged();
+
+            // Tell anyone who cares the data and selection has changed, if they have.
+            if (wasData && onDataChangedListener != null) {
+                onDataChangedListener.onDataChanged(PickerFragment.this);
+            }
+            if (wasSelection && onSelectionChangedListener != null) {
+                onSelectionChangedListener.onSelectionChanged(PickerFragment.this);
+            }
+        }
+    }
+
+    void updateAdapter(SimpleGraphObjectCursor<T> data) {
+        if (adapter != null) {
+            // As we fetch additional results and add them to the table, we do not
+            // want the items displayed jumping around seemingly at random, frustrating the user's
+            // attempts at scrolling, etc. Since results may be added anywhere in
+            // the table, we choose to try to keep the first visible row in a fixed
+            // position (from the user's perspective). We try to keep it positioned at
+            // the same offset from the top of the screen so adding new items seems
+            // smoother, as opposed to having it "snap" to a multiple of row height
+
+            // We use the second row, to give context above and below it and avoid
+            // cases where the first row is only barely visible, thus providing little context.
+            // The exception is where the very first row is visible, in which case we use that.
+            View view = listView.getChildAt(1);
+            int anchorPosition = listView.getFirstVisiblePosition();
+            if (anchorPosition > 0) {
+                anchorPosition++;
+            }
+            GraphObjectAdapter.SectionAndItem<T> anchorItem = adapter.getSectionAndItem(anchorPosition);
+            final int top = (view != null &&
+                    anchorItem.getType() != GraphObjectAdapter.SectionAndItem.Type.ACTIVITY_CIRCLE) ?
+                    view.getTop() : 0;
+
+            // Now actually add the results.
+            boolean dataChanged = adapter.changeCursor(data);
+
+            if (view != null && anchorItem != null) {
+                // Put the item back in the same spot it was.
+                final int newPositionOfItem = adapter.getPosition(anchorItem.sectionKey, anchorItem.graphObject);
+                if (newPositionOfItem != -1) {
+                    listView.setSelectionFromTop(newPositionOfItem, top);
+                }
+            }
+
+            if (dataChanged && onDataChangedListener != null) {
+                onDataChangedListener.onDataChanged(PickerFragment.this);
+            }
+        }
+    }
+
+    private void reprioritizeDownloads() {
+        int lastVisibleItem = listView.getLastVisiblePosition();
+        if (lastVisibleItem >= 0) {
+            int firstVisibleItem = listView.getFirstVisiblePosition();
+            adapter.prioritizeViewRange(firstVisibleItem, lastVisibleItem, PROFILE_PICTURE_PREFETCH_BUFFER);
+        }
+    }
+
+    private ListView.OnScrollListener onScrollListener = new ListView.OnScrollListener() {
+        @Override
+        public void onScrollStateChanged(AbsListView view, int scrollState) {
+        }
+
+        @Override
+        public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
+            reprioritizeDownloads();
+        }
+    };
+
+    /**
+     * Callback interface that will be called when a network or other error is encountered
+     * while retrieving graph objects.
+     */
+    public interface OnErrorListener {
+        /**
+         * Called when a network or other error is encountered.
+         *
+         * @param error a FacebookException representing the error that was encountered.
+         */
+        void onError(PickerFragment<?> fragment, FacebookException error);
+    }
+
+    /**
+     * Callback interface that will be called when the underlying data being displayed in the
+     * picker has been updated.
+     */
+    public interface OnDataChangedListener {
+        /**
+         * Called when the set of data being displayed in the picker has changed.
+         */
+        void onDataChanged(PickerFragment<?> fragment);
+    }
+
+    /**
+     * Callback interface that will be called when the user selects or unselects graph objects
+     * in the picker.
+     */
+    public interface OnSelectionChangedListener {
+        /**
+         * Called when the user selects or unselects graph objects in the picker.
+         */
+        void onSelectionChanged(PickerFragment<?> fragment);
+    }
+
+    /**
+     * Callback interface that will be called when the user clicks the Done button on the
+     * title bar.
+     */
+    public interface OnDoneButtonClickedListener {
+        /**
+         * Called when the user clicks the Done button.
+         */
+        void onDoneButtonClicked(PickerFragment<?> fragment);
+    }
+
+    /**
+     * Callback interface that will be called to determine if a graph object should be displayed.
+     *
+     * @param <T>
+     */
+    public interface GraphObjectFilter<T> {
+        /**
+         * Called to determine if a graph object should be displayed.
+         *
+         * @param graphObject the graph object
+         * @return true to display the graph object, false to hide it
+         */
+        boolean includeItem(T graphObject);
+    }
+
+    abstract class LoadingStrategy {
+        protected final static int CACHED_RESULT_REFRESH_DELAY = 2 * 1000;
+
+        protected GraphObjectPagingLoader<T> loader;
+        protected GraphObjectAdapter<T> adapter;
+
+        public void attach(GraphObjectAdapter<T> adapter) {
+            loader = (GraphObjectPagingLoader<T>) getLoaderManager().initLoader(0, null,
+                    new LoaderManager.LoaderCallbacks<SimpleGraphObjectCursor<T>>() {
+                        @Override
+                        public Loader<SimpleGraphObjectCursor<T>> onCreateLoader(int id, Bundle args) {
+                            return LoadingStrategy.this.onCreateLoader();
+                        }
+
+                        @Override
+                        public void onLoadFinished(Loader<SimpleGraphObjectCursor<T>> loader,
+                                SimpleGraphObjectCursor<T> data) {
+                            if (loader != LoadingStrategy.this.loader) {
+                                throw new FacebookException("Received callback for unknown loader.");
+                            }
+                            LoadingStrategy.this.onLoadFinished((GraphObjectPagingLoader<T>) loader, data);
+                        }
+
+                        @Override
+                        public void onLoaderReset(Loader<SimpleGraphObjectCursor<T>> loader) {
+                            if (loader != LoadingStrategy.this.loader) {
+                                throw new FacebookException("Received callback for unknown loader.");
+                            }
+                            LoadingStrategy.this.onLoadReset((GraphObjectPagingLoader<T>) loader);
+                        }
+                    });
+
+            loader.setOnErrorListener(new GraphObjectPagingLoader.OnErrorListener() {
+                @Override
+                public void onError(FacebookException error, GraphObjectPagingLoader<?> loader) {
+                    hideActivityCircle();
+                    if (onErrorListener != null) {
+                        onErrorListener.onError(PickerFragment.this, error);
+                    }
+                }
+            });
+
+            this.adapter = adapter;
+            // Tell the adapter about any data we might already have.
+            this.adapter.changeCursor(loader.getCursor());
+        }
+
+        public void detach() {
+            adapter.setDataNeededListener(null);
+            loader.setOnErrorListener(null);
+
+            loader = null;
+            adapter = null;
+        }
+
+        public void clearResults() {
+            if (loader != null) {
+                loader.clearResults();
+            }
+        }
+
+        public void startLoading(Request request) {
+            if (loader != null) {
+                loader.startLoading(request, true);
+                onStartLoading(loader, request);
+            }
+        }
+
+        public boolean isDataPresentOrLoading() {
+            return !adapter.isEmpty() || loader.isLoading();
+        }
+
+        protected GraphObjectPagingLoader<T> onCreateLoader() {
+            return new GraphObjectPagingLoader<T>(getActivity(), graphObjectClass);
+        }
+
+        protected void onStartLoading(GraphObjectPagingLoader<T> loader, Request request) {
+            displayActivityCircle();
+        }
+
+        protected void onLoadReset(GraphObjectPagingLoader<T> loader) {
+            adapter.changeCursor(null);
+        }
+
+        protected void onLoadFinished(GraphObjectPagingLoader<T> loader, SimpleGraphObjectCursor<T> data) {
+            updateAdapter(data);
+        }
+    }
+
+    abstract class SelectionStrategy {
+        abstract boolean isSelected(String id);
+
+        abstract void toggleSelection(String id);
+
+        abstract Collection<String> getSelectedIds();
+
+        abstract void clear();
+
+        abstract boolean isEmpty();
+
+        abstract boolean shouldShowCheckBoxIfUnselected();
+
+        abstract void saveSelectionToBundle(Bundle outBundle, String key);
+
+        abstract void readSelectionFromBundle(Bundle inBundle, String key);
+    }
+
+    class SingleSelectionStrategy extends SelectionStrategy {
+        private String selectedId;
+
+        public Collection<String> getSelectedIds() {
+            return Arrays.asList(new String[]{selectedId});
+        }
+
+        @Override
+        boolean isSelected(String id) {
+            return selectedId != null && id != null && selectedId.equals(id);
+        }
+
+        @Override
+        void toggleSelection(String id) {
+            if (selectedId != null && selectedId.equals(id)) {
+                selectedId = null;
+            } else {
+                selectedId = id;
+            }
+        }
+
+        @Override
+        void saveSelectionToBundle(Bundle outBundle, String key) {
+            if (!TextUtils.isEmpty(selectedId)) {
+                outBundle.putString(key, selectedId);
+            }
+        }
+
+        @Override
+        void readSelectionFromBundle(Bundle inBundle, String key) {
+            if (inBundle != null) {
+                selectedId = inBundle.getString(key);
+            }
+        }
+
+        @Override
+        public void clear() {
+            selectedId = null;
+        }
+
+        @Override
+        boolean isEmpty() {
+            return selectedId == null;
+        }
+
+        @Override
+        boolean shouldShowCheckBoxIfUnselected() {
+            return false;
+        }
+    }
+
+    class MultiSelectionStrategy extends SelectionStrategy {
+        private Set<String> selectedIds = new HashSet<String>();
+
+        public Collection<String> getSelectedIds() {
+            return selectedIds;
+        }
+
+        @Override
+        boolean isSelected(String id) {
+            return id != null && selectedIds.contains(id);
+        }
+
+        @Override
+        void toggleSelection(String id) {
+            if (id != null) {
+                if (selectedIds.contains(id)) {
+                    selectedIds.remove(id);
+                } else {
+                    selectedIds.add(id);
+                }
+            }
+        }
+
+        @Override
+        void saveSelectionToBundle(Bundle outBundle, String key) {
+            if (!selectedIds.isEmpty()) {
+                String ids = TextUtils.join(",", selectedIds);
+                outBundle.putString(key, ids);
+            }
+        }
+
+        @Override
+        void readSelectionFromBundle(Bundle inBundle, String key) {
+            if (inBundle != null) {
+                String ids = inBundle.getString(key);
+                if (ids != null) {
+                    String[] splitIds = TextUtils.split(ids, ",");
+                    selectedIds.clear();
+                    Collections.addAll(selectedIds, splitIds);
+                }
+            }
+        }
+
+        @Override
+        public void clear() {
+            selectedIds.clear();
+        }
+
+        @Override
+        boolean isEmpty() {
+            return selectedIds.isEmpty();
+        }
+
+        @Override
+        boolean shouldShowCheckBoxIfUnselected() {
+            return true;
+        }
+    }
+
+    abstract class PickerFragmentAdapter<U extends GraphObject> extends GraphObjectAdapter<T> {
+        public PickerFragmentAdapter(Context context) {
+            super(context);
+        }
+
+        @Override
+        boolean isGraphObjectSelected(String graphObjectId) {
+            return selectionStrategy.isSelected(graphObjectId);
+        }
+
+        @Override
+        void updateCheckboxState(CheckBox checkBox, boolean graphObjectSelected) {
+            checkBox.setChecked(graphObjectSelected);
+            int visible = (graphObjectSelected || selectionStrategy
+                    .shouldShowCheckBoxIfUnselected()) ? View.VISIBLE : View.GONE;
+            checkBox.setVisibility(visible);
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/widget/PlacePickerFragment.java b/facebook/src/com/facebook/widget/PlacePickerFragment.java
new file mode 100644
index 000000000..b08208c7f
--- /dev/null
+++ b/facebook/src/com/facebook/widget/PlacePickerFragment.java
@@ -0,0 +1,530 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.location.Location;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.text.Editable;
+import android.text.TextUtils;
+import android.text.TextWatcher;
+import android.util.AttributeSet;
+import android.view.ViewGroup;
+import android.view.ViewStub;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.EditText;
+import android.widget.ListView;
+import android.widget.RelativeLayout;
+import com.facebook.*;
+import com.facebook.android.R;
+import com.facebook.model.GraphPlace;
+import com.facebook.internal.Logger;
+import com.facebook.internal.Utility;
+
+import java.util.*;
+
+public class PlacePickerFragment extends PickerFragment<GraphPlace> {
+    /**
+     * The key for an int parameter in the fragment's Intent bundle to indicate the radius in meters around
+     * the center point to search. The default is 1000 meters.
+     */
+    public static final String RADIUS_IN_METERS_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.RadiusInMeters";
+    /**
+     * The key for an int parameter in the fragment's Intent bundle to indicate what how many results to
+     * return at a time. The default is 100 results.
+     */
+    public static final String RESULTS_LIMIT_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.ResultsLimit";
+    /**
+     * The key for a String parameter in the fragment's Intent bundle to indicate what search text should
+     * be sent to the service. The default is to have no search text.
+     */
+    public static final String SEARCH_TEXT_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.SearchText";
+    /**
+     * The key for a Location parameter in the fragment's Intent bundle to indicate what geographical
+     * location should be the center of the search.
+     */
+    public static final String LOCATION_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.Location";
+    /**
+     * The key for a boolean parameter in the fragment's Intent bundle to indicate that the fragment
+     * should display a search box and automatically update the search text as it changes.
+     */
+    public static final String SHOW_SEARCH_BOX_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.ShowSearchBox";
+
+    /**
+     * The default radius around the center point to search.
+     */
+    public static final int DEFAULT_RADIUS_IN_METERS = 1000;
+    /**
+     * The default number of results to retrieve.
+     */
+    public static final int DEFAULT_RESULTS_LIMIT = 100;
+
+    private static final int searchTextTimerDelayInMilliseconds = 2 * 1000;
+
+    private static final String ID = "id";
+    private static final String NAME = "name";
+    private static final String LOCATION = "location";
+    private static final String CATEGORY = "category";
+    private static final String WERE_HERE_COUNT = "were_here_count";
+    private static final String TAG = "PlacePickerFragment";
+
+    private Location location;
+    private int radiusInMeters = DEFAULT_RADIUS_IN_METERS;
+    private int resultsLimit = DEFAULT_RESULTS_LIMIT;
+    private String searchText;
+    private Timer searchTextTimer;
+    private boolean hasSearchTextChangedSinceLastQuery;
+    private boolean showSearchBox = true;
+    private EditText searchBox;
+
+    /**
+     * Default constructor. Creates a Fragment with all default properties.
+     */
+    public PlacePickerFragment() {
+        this(null);
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param args a Bundle that optionally contains one or more values containing additional
+     *             configuration information for the Fragment.
+     */
+    public PlacePickerFragment(Bundle args) {
+        super(GraphPlace.class, R.layout.com_facebook_placepickerfragment, args);
+        setPlacePickerSettingsFromBundle(args);
+    }
+
+    /**
+     * Gets the location to search around. Either the location or the search text (or both) must be specified.
+     *
+     * @return the Location to search around
+     */
+    public Location getLocation() {
+        return location;
+    }
+
+    /**
+     * Sets the location to search around. Either the location or the search text (or both) must be specified.
+     *
+     * @param location the Location to search around
+     */
+    public void setLocation(Location location) {
+        this.location = location;
+    }
+
+    /**
+     * Gets the radius in meters around the location to search.
+     *
+     * @return the radius in meters
+     */
+    public int getRadiusInMeters() {
+        return radiusInMeters;
+    }
+
+    /**
+     * Sets the radius in meters around the location to search.
+     *
+     * @param radiusInMeters the radius in meters
+     */
+    public void setRadiusInMeters(int radiusInMeters) {
+        this.radiusInMeters = radiusInMeters;
+    }
+
+    /**
+     * Gets the number of results to retrieve.
+     *
+     * @return the number of results to retrieve
+     */
+    public int getResultsLimit() {
+        return resultsLimit;
+    }
+
+    /**
+     * Sets the number of results to retrieve.
+     *
+     * @param resultsLimit the number of results to retrieve
+     */
+    public void setResultsLimit(int resultsLimit) {
+        this.resultsLimit = resultsLimit;
+    }
+
+    /**
+     * Gets the search text (e.g., category, name) to search for. Either the location or the search
+     * text (or both) must be specified.
+     *
+     * @return the search text
+     */
+    public String getSearchText() {
+        return searchText;
+    }
+
+    /**
+     * Sets the search text (e.g., category, name) to search for. Either the location or the search
+     * text (or both) must be specified. If a search box is displayed, this will update its contents
+     * to the specified text.
+     *
+     * @param searchText the search text
+     */
+    public void setSearchText(String searchText) {
+        if (TextUtils.isEmpty(searchText)) {
+            searchText = null;
+        }
+        this.searchText = searchText;
+        if (this.searchBox != null) {
+            this.searchBox.setText(searchText);
+        }
+    }
+
+    /**
+     * Sets the search text and reloads the data in the control. This is used to provide search-box
+     * functionality where the user may be typing or editing text rapidly. It uses a timer to avoid repeated
+     * requerying, preferring to wait until the user pauses typing to refresh the data. Note that this
+     * method will NOT update the text in the search box, if any, as it is intended to be called as a result
+     * of changes to the search box (and is public to enable applications to provide their own search box
+     * UI instead of the default one).
+     *
+     * @param searchText                 the search text
+     * @param forceReloadEventIfSameText if true, will reload even if the search text has not changed; if false,
+     *                                   identical search text will not force a reload
+     */
+    public void onSearchBoxTextChanged(String searchText, boolean forceReloadEventIfSameText) {
+        if (!forceReloadEventIfSameText && Utility.stringsEqualOrEmpty(this.searchText, searchText)) {
+            return;
+        }
+
+        if (TextUtils.isEmpty(searchText)) {
+            searchText = null;
+        }
+        this.searchText = searchText;
+
+        // If search text is being set in response to user input, it is wasteful to send a new request
+        // with every keystroke. Send a request the first time the search text is set, then set up a 2-second timer
+        // and send whatever changes the user has made since then. (If nothing has changed
+        // in 2 seconds, we reset so the next change will cause an immediate re-query.)
+        hasSearchTextChangedSinceLastQuery = true;
+        if (searchTextTimer == null) {
+            searchTextTimer = createSearchTextTimer();
+        }
+    }
+
+    /**
+     * Gets the currently-selected place.
+     *
+     * @return the currently-selected place, or null if there is none
+     */
+    public GraphPlace getSelection() {
+        Collection<GraphPlace> selection = getSelectedGraphObjects();
+        return (selection != null && selection.size() > 0) ? selection.iterator().next() : null;
+    }
+
+    public void setSettingsFromBundle(Bundle inState) {
+        super.setSettingsFromBundle(inState);
+        setPlacePickerSettingsFromBundle(inState);
+    }
+
+    @Override
+    public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
+        super.onInflate(activity, attrs, savedInstanceState);
+        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.com_facebook_place_picker_fragment);
+
+        setRadiusInMeters(a.getInt(R.styleable.com_facebook_place_picker_fragment_radius_in_meters, radiusInMeters));
+        setResultsLimit(a.getInt(R.styleable.com_facebook_place_picker_fragment_results_limit, resultsLimit));
+        if (a.hasValue(R.styleable.com_facebook_place_picker_fragment_results_limit)) {
+            setSearchText(a.getString(R.styleable.com_facebook_place_picker_fragment_search_text));
+        }
+        showSearchBox = a.getBoolean(R.styleable.com_facebook_place_picker_fragment_show_search_box, showSearchBox);
+
+        a.recycle();
+    }
+
+    @Override
+    public void onActivityCreated(final Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+
+        ViewGroup view = (ViewGroup) getView();
+        if (showSearchBox) {
+            ViewStub stub = (ViewStub) view.findViewById(R.id.com_facebook_placepickerfragment_search_box_stub);
+            if (stub != null) {
+                searchBox = (EditText) stub.inflate();
+
+                // Put the list under the search box
+                RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
+                        RelativeLayout.LayoutParams.FILL_PARENT,
+                        RelativeLayout.LayoutParams.FILL_PARENT);
+                layoutParams.addRule(RelativeLayout.BELOW, R.id.search_box);
+
+                ListView listView = (ListView) view.findViewById(R.id.com_facebook_picker_list_view);
+                listView.setLayoutParams(layoutParams);
+
+                // If we need to, put the search box under the title bar.
+                if (view.findViewById(R.id.com_facebook_picker_title_bar) != null) {
+                    layoutParams = new RelativeLayout.LayoutParams(
+                            RelativeLayout.LayoutParams.FILL_PARENT,
+                            RelativeLayout.LayoutParams.WRAP_CONTENT);
+                    layoutParams.addRule(RelativeLayout.BELOW, R.id.com_facebook_picker_title_bar);
+
+                    searchBox.setLayoutParams(layoutParams);
+                }
+
+                searchBox.addTextChangedListener(new SearchTextWatcher());
+                if (!TextUtils.isEmpty(searchText)) {
+                    searchBox.setText(searchText);
+                }
+            }
+        }
+    }
+
+    @Override
+    public void onAttach(Activity activity) {
+        super.onAttach(activity);
+
+        if (searchBox != null) {
+            InputMethodManager imm = (InputMethodManager)getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);
+            imm.showSoftInput(searchBox, InputMethodManager.SHOW_IMPLICIT);
+        }
+    }
+
+    @Override
+    public void onDetach() {
+        super.onDetach();
+
+        if (searchBox != null) {
+            InputMethodManager imm = (InputMethodManager)getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);
+            imm.hideSoftInputFromWindow(searchBox.getWindowToken(), 0);
+        }
+    }
+
+    void saveSettingsToBundle(Bundle outState) {
+        super.saveSettingsToBundle(outState);
+
+        outState.putInt(RADIUS_IN_METERS_BUNDLE_KEY, radiusInMeters);
+        outState.putInt(RESULTS_LIMIT_BUNDLE_KEY, resultsLimit);
+        outState.putString(SEARCH_TEXT_BUNDLE_KEY, searchText);
+        outState.putParcelable(LOCATION_BUNDLE_KEY, location);
+        outState.putBoolean(SHOW_SEARCH_BOX_BUNDLE_KEY, showSearchBox);
+    }
+
+    @Override
+    void onLoadingData() {
+        hasSearchTextChangedSinceLastQuery = false;
+    }
+
+    @Override
+    Request getRequestForLoadData(Session session) {
+        return createRequest(location, radiusInMeters, resultsLimit, searchText, extraFields, session);
+    }
+
+    @Override
+    String getDefaultTitleText() {
+        return getString(R.string.com_facebook_nearby);
+    }
+
+    @Override
+    PickerFragmentAdapter<GraphPlace> createAdapter() {
+        PickerFragmentAdapter<GraphPlace> adapter = new PickerFragmentAdapter<GraphPlace>(
+                this.getActivity()) {
+            @Override
+            protected CharSequence getSubTitleOfGraphObject(GraphPlace graphObject) {
+                String category = graphObject.getCategory();
+                Integer wereHereCount = (Integer) graphObject.getProperty(WERE_HERE_COUNT);
+
+                String result = null;
+                if (category != null && wereHereCount != null) {
+                    result = getString(R.string.com_facebook_placepicker_subtitle_format, category, wereHereCount);
+                } else if (category == null && wereHereCount != null) {
+                    result = getString(R.string.com_facebook_placepicker_subtitle_were_here_only_format, wereHereCount);
+                } else if (category != null && wereHereCount == null) {
+                    result = getString(R.string.com_facebook_placepicker_subtitle_catetory_only_format, category);
+                }
+                return result;
+            }
+
+            @Override
+            protected int getGraphObjectRowLayoutId(GraphPlace graphObject) {
+                return R.layout.com_facebook_placepickerfragment_list_row;
+            }
+
+            @Override
+            protected int getDefaultPicture() {
+                return R.drawable.com_facebook_place_default_icon;
+            }
+
+        };
+        adapter.setShowCheckbox(false);
+        adapter.setShowPicture(getShowPictures());
+        return adapter;
+    }
+
+    @Override
+    LoadingStrategy createLoadingStrategy() {
+        return new AsNeededLoadingStrategy();
+    }
+
+    @Override
+    SelectionStrategy createSelectionStrategy() {
+        return new SingleSelectionStrategy();
+    }
+
+    private Request createRequest(Location location, int radiusInMeters, int resultsLimit, String searchText,
+            Set<String> extraFields,
+            Session session) {
+        Request request = Request.newPlacesSearchRequest(session, location, radiusInMeters, resultsLimit, searchText,
+                null);
+
+        Set<String> fields = new HashSet<String>(extraFields);
+        String[] requiredFields = new String[]{
+                ID,
+                NAME,
+                LOCATION,
+                CATEGORY,
+                WERE_HERE_COUNT
+        };
+        fields.addAll(Arrays.asList(requiredFields));
+
+        String pictureField = adapter.getPictureFieldSpecifier();
+        if (pictureField != null) {
+            fields.add(pictureField);
+        }
+
+        Bundle parameters = request.getParameters();
+        parameters.putString("fields", TextUtils.join(",", fields));
+        request.setParameters(parameters);
+
+        return request;
+    }
+
+    private void setPlacePickerSettingsFromBundle(Bundle inState) {
+        // We do this in a separate non-overridable method so it is safe to call from the constructor.
+        if (inState != null) {
+            setRadiusInMeters(inState.getInt(RADIUS_IN_METERS_BUNDLE_KEY, radiusInMeters));
+            setResultsLimit(inState.getInt(RESULTS_LIMIT_BUNDLE_KEY, resultsLimit));
+            if (inState.containsKey(SEARCH_TEXT_BUNDLE_KEY)) {
+                setSearchText(inState.getString(SEARCH_TEXT_BUNDLE_KEY));
+            }
+            if (inState.containsKey(LOCATION_BUNDLE_KEY)) {
+                Location location = inState.getParcelable(LOCATION_BUNDLE_KEY);
+                setLocation(location);
+            }
+            showSearchBox = inState.getBoolean(SHOW_SEARCH_BOX_BUNDLE_KEY, showSearchBox);
+        }
+    }
+
+    private Timer createSearchTextTimer() {
+        Timer timer = new Timer();
+        timer.schedule(new TimerTask() {
+            @Override
+            public void run() {
+                onSearchTextTimerTriggered();
+            }
+        }, 0, searchTextTimerDelayInMilliseconds);
+
+        return timer;
+    }
+
+    private void onSearchTextTimerTriggered() {
+        if (hasSearchTextChangedSinceLastQuery) {
+            Handler handler = new Handler(Looper.getMainLooper());
+            handler.post(new Runnable() {
+                @Override
+                public void run() {
+                    FacebookException error = null;
+                    try {
+                        loadData(true);
+                    } catch (FacebookException fe) {
+                        error = fe;
+                    } catch (Exception e) {
+                        error = new FacebookException(e);
+                    } finally {
+                        if (error != null) {
+                            OnErrorListener onErrorListener = getOnErrorListener();
+                            if (onErrorListener != null) {
+                                onErrorListener.onError(PlacePickerFragment.this, error);
+                            } else {
+                                Logger.log(LoggingBehavior.REQUESTS, TAG, "Error loading data : %s", error);
+                            }
+                        }
+                    }
+                }
+            });
+        } else {
+            // Nothing has changed in 2 seconds. Invalidate and forget about this timer.
+            // Next time the user types, we will fire a query immediately again.
+            searchTextTimer.cancel();
+            searchTextTimer = null;
+        }
+    }
+
+    private class AsNeededLoadingStrategy extends LoadingStrategy {
+        @Override
+        public void attach(GraphObjectAdapter<GraphPlace> adapter) {
+            super.attach(adapter);
+
+            this.adapter.setDataNeededListener(new GraphObjectAdapter.DataNeededListener() {
+                @Override
+                public void onDataNeeded() {
+                    // Do nothing if we are currently loading data . We will get notified again when that load finishes if the adapter still
+                    // needs more data. Otherwise, follow the next link.
+                    if (!loader.isLoading()) {
+                        loader.followNextLink();
+                    }
+                }
+            });
+        }
+
+        @Override
+        protected void onLoadFinished(GraphObjectPagingLoader<GraphPlace> loader,
+                SimpleGraphObjectCursor<GraphPlace> data) {
+            super.onLoadFinished(loader, data);
+
+            // We could be called in this state if we are clearing data or if we are being re-attached
+            // in the middle of a query.
+            if (data == null || loader.isLoading()) {
+                return;
+            }
+
+            hideActivityCircle();
+
+            if (data.isFromCache()) {
+                // Only the first page can be cached, since all subsequent pages will be round-tripped. Force
+                // a refresh of the first page before we allow paging to begin. If the first page produced
+                // no data, launch the refresh immediately, otherwise schedule it for later.
+                loader.refreshOriginalRequest(data.areMoreObjectsAvailable() ? CACHED_RESULT_REFRESH_DELAY : 0);
+            }
+        }
+    }
+
+    private class SearchTextWatcher implements TextWatcher {
+
+        @Override
+        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+        }
+
+        @Override
+        public void onTextChanged(CharSequence s, int start, int before, int count) {
+            onSearchBoxTextChanged(s.toString(), false);
+        }
+
+        @Override
+        public void afterTextChanged(Editable s) {
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/widget/ProfilePictureView.java b/facebook/src/com/facebook/widget/ProfilePictureView.java
new file mode 100644
index 000000000..d599f5d7b
--- /dev/null
+++ b/facebook/src/com/facebook/widget/ProfilePictureView.java
@@ -0,0 +1,520 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.os.Bundle;
+import android.os.Parcelable;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import com.facebook.FacebookException;
+import com.facebook.LoggingBehavior;
+import com.facebook.android.R;
+import com.facebook.internal.Logger;
+import com.facebook.internal.Utility;
+
+import java.net.MalformedURLException;
+
+/**
+ * View that displays the profile photo of a supplied profile ID, while conforming
+ * to user specified dimensions.
+ */
+public class ProfilePictureView extends FrameLayout {
+
+    /**
+     * Callback interface that will be called when a network or other error is encountered
+     * while retrieving profile pictures.
+     */
+    public interface OnErrorListener {
+        /**
+         * Called when a network or other error is encountered.
+         * @param error     a FacebookException representing the error that was encountered.
+         */
+        void onError(FacebookException error);
+    }
+
+    /**
+     * Tag used when logging calls are made by ProfilePictureView
+     */
+    public static final String TAG = ProfilePictureView.class.getSimpleName();
+
+    /**
+     * Indicates that the specific size of the View will be set via layout params.
+     * ProfilePictureView will default to NORMAL X NORMAL, if the layout params set on
+     * this instance do not have a fixed size.
+     * Used in calls to setPresetSize() and getPresetSize().
+     * Corresponds with the preset_size Xml attribute that can be set on ProfilePictureView.
+     */
+    public static final int CUSTOM = -1;
+
+    /**
+     * Indicates that the profile image should fit in a SMALL X SMALL space, regardless
+     * of whether the cropped or un-cropped version is chosen.
+     * Used in calls to setPresetSize() and getPresetSize().
+     * Corresponds with the preset_size Xml attribute that can be set on ProfilePictureView.
+     */
+    public static final int SMALL = -2;
+
+    /**
+     * Indicates that the profile image should fit in a NORMAL X NORMAL space, regardless
+     * of whether the cropped or un-cropped version is chosen.
+     * Used in calls to setPresetSize() and getPresetSize().
+     * Corresponds with the preset_size Xml attribute that can be set on ProfilePictureView.
+     */
+    public static final int NORMAL = -3;
+
+    /**
+     * Indicates that the profile image should fit in a LARGE X LARGE space, regardless
+     * of whether the cropped or un-cropped version is chosen.
+     * Used in calls to setPresetSize() and getPresetSize().
+     * Corresponds with the preset_size Xml attribute that can be set on ProfilePictureView.
+     */
+    public static final int LARGE = -4;
+
+    private static final int MIN_SIZE = 1;
+    private static final boolean IS_CROPPED_DEFAULT_VALUE = true;
+    private static final String SUPER_STATE_KEY = "ProfilePictureView_superState";
+    private static final String PROFILE_ID_KEY = "ProfilePictureView_profileId";
+    private static final String PRESET_SIZE_KEY = "ProfilePictureView_presetSize";
+    private static final String IS_CROPPED_KEY = "ProfilePictureView_isCropped";
+    private static final String BITMAP_KEY = "ProfilePictureView_bitmap";
+    private static final String BITMAP_WIDTH_KEY = "ProfilePictureView_width";
+    private static final String BITMAP_HEIGHT_KEY = "ProfilePictureView_height";
+    private static final String PENDING_REFRESH_KEY = "ProfilePictureView_refresh";
+
+    private String profileId;
+    private int queryHeight = ImageRequest.UNSPECIFIED_DIMENSION;
+    private int queryWidth = ImageRequest.UNSPECIFIED_DIMENSION;
+    private boolean isCropped = IS_CROPPED_DEFAULT_VALUE;
+    private Bitmap imageContents;
+    private ImageView image;
+    private int presetSizeType = CUSTOM;
+    private ImageRequest lastRequest;
+    private OnErrorListener onErrorListener;
+
+    /**
+     * Constructor
+     *
+     * @param context Context for this View
+     */
+    public ProfilePictureView(Context context) {
+        super(context);
+        initialize(context);
+    }
+
+    /**
+     * Constructor
+     *
+     * @param context Context for this View
+     * @param attrs   AttributeSet for this View.
+     *                The attribute 'preset_size' is processed here
+     */
+    public ProfilePictureView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        initialize(context);
+        parseAttributes(attrs);
+    }
+
+    /**
+     * Constructor
+     *
+     * @param context  Context for this View
+     * @param attrs    AttributeSet for this View.
+     *                 The attribute 'preset_size' is processed here
+     * @param defStyle Default style for this View
+     */
+    public ProfilePictureView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        initialize(context);
+        parseAttributes(attrs);
+    }
+
+    /**
+     * Gets the current preset size type
+     *
+     * @return The current preset size type, if set; CUSTOM if not
+     */
+    public final int getPresetSize() {
+        return presetSizeType;
+    }
+
+    /**
+     * Apply a preset size to this profile photo
+     *
+     * @param sizeType The size type to apply: SMALL, NORMAL or LARGE
+     */
+    public final void setPresetSize(int sizeType) {
+        switch (sizeType) {
+            case SMALL:
+            case NORMAL:
+            case LARGE:
+            case CUSTOM:
+                this.presetSizeType = sizeType;
+                break;
+
+            default:
+                throw new IllegalArgumentException("Must use a predefined preset size");
+        }
+
+        requestLayout();
+    }
+
+    /**
+     * Indicates whether the cropped version of the profile photo has been chosen
+     *
+     * @return True if the cropped version is chosen, false if not.
+     */
+    public final boolean isCropped() {
+        return isCropped;
+    }
+
+    /**
+     * Sets the profile photo to be the cropped version, or the original version
+     *
+     * @param showCroppedVersion True to select the cropped version
+     *                           False to select the standard version
+     */
+    public final void setCropped(boolean showCroppedVersion) {
+        isCropped = showCroppedVersion;
+        // No need to force the refresh since we will catch the change in required dimensions
+        refreshImage(false);
+    }
+
+    /**
+     * Returns the profile Id for the current profile photo
+     *
+     * @return The profile Id
+     */
+    public final String getProfileId() {
+        return profileId;
+    }
+
+    /**
+     * Sets the profile Id for this profile photo
+     *
+     * @param profileId The profileId
+     *               NULL/Empty String will show the blank profile photo
+     */
+    public final void setProfileId(String profileId) {
+        boolean force = false;
+        if (Utility.isNullOrEmpty(this.profileId) || !this.profileId.equalsIgnoreCase(profileId)) {
+            // Clear out the old profilePicture before requesting for the new one.
+            setBlankProfilePicture();
+            force = true;
+        }
+
+        this.profileId = profileId;
+        refreshImage(force);
+    }
+
+    /**
+     * Returns the current OnErrorListener for this instance of ProfilePictureView
+     *
+     * @return The OnErrorListener
+     */
+    public final OnErrorListener getOnErrorListener() {
+        return onErrorListener;
+    }
+
+    /**
+     * Sets an OnErrorListener for this instance of ProfilePictureView to call into when
+     * certain exceptions occur.
+     *
+     * @param onErrorListener The listener object to set
+     */
+    public final void setOnErrorListener(OnErrorListener onErrorListener) {
+        this.onErrorListener = onErrorListener;
+    }
+
+    /**
+     * Overriding onMeasure to handle the case where WRAP_CONTENT might be
+     * specified in the layout. Since we don't know the dimensions of the profile
+     * photo, we need to handle this case specifically.
+     * <p/>
+     * The approach is to default to a NORMAL sized amount of space in the case that
+     * a preset size is not specified. This logic is applied to both width and height
+     */
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        ViewGroup.LayoutParams params = getLayoutParams();
+        boolean customMeasure = false;
+        int newHeight = MeasureSpec.getSize(heightMeasureSpec);
+        int newWidth = MeasureSpec.getSize(widthMeasureSpec);
+        if (MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY &&
+                params.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
+            newHeight = getPresetSizeInPixels(true); // Default to a preset size
+            heightMeasureSpec = MeasureSpec.makeMeasureSpec(newHeight, MeasureSpec.EXACTLY);
+            customMeasure = true;
+        }
+
+        if (MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY &&
+                params.width == ViewGroup.LayoutParams.WRAP_CONTENT) {
+            newWidth = getPresetSizeInPixels(true); // Default to a preset size
+            widthMeasureSpec = MeasureSpec.makeMeasureSpec(newWidth, MeasureSpec.EXACTLY);
+            customMeasure = true;
+        }
+
+        if (customMeasure) {
+            // Since we are providing custom dimensions, we need to handle the measure
+            // phase from here
+            setMeasuredDimension(newWidth, newHeight);
+            measureChildren(widthMeasureSpec, heightMeasureSpec);
+        } else {
+            // Rely on FrameLayout to do the right thing
+            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+        }
+    }
+
+    /**
+     * In addition to calling super.Layout(), we also attempt to get a new image that
+     * is properly size for the layout dimensions
+     */
+    @Override
+    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+        super.onLayout(changed, left, top, right, bottom);
+
+        // See if the image needs redrawing
+        refreshImage(false);
+    }
+
+    /**
+     * Some of the current state is returned as a Bundle to allow quick restoration
+     * of the ProfilePictureView object in scenarios like orientation changes.
+     * @return a Parcelable containing the current state
+     */
+    @Override
+    protected Parcelable onSaveInstanceState() {
+        Parcelable superState = super.onSaveInstanceState();
+        Bundle instanceState = new Bundle();
+        instanceState.putParcelable(SUPER_STATE_KEY, superState);
+        instanceState.putString(PROFILE_ID_KEY, profileId);
+        instanceState.putInt(PRESET_SIZE_KEY, presetSizeType);
+        instanceState.putBoolean(IS_CROPPED_KEY, isCropped);
+        instanceState.putParcelable(BITMAP_KEY, imageContents);
+        instanceState.putInt(BITMAP_WIDTH_KEY, queryWidth);
+        instanceState.putInt(BITMAP_HEIGHT_KEY, queryHeight);
+        instanceState.putBoolean(PENDING_REFRESH_KEY, lastRequest != null);
+
+        return instanceState;
+    }
+
+    /**
+     * If the passed in state is a Bundle, an attempt is made to restore from it.
+     * @param state a Parcelable containing the current state
+     */
+    @Override
+    protected void onRestoreInstanceState(Parcelable state) {
+        if (state.getClass() != Bundle.class) {
+            super.onRestoreInstanceState(state);
+        } else {
+            Bundle instanceState = (Bundle)state;
+            super.onRestoreInstanceState(instanceState.getParcelable(SUPER_STATE_KEY));
+
+            profileId = instanceState.getString(PROFILE_ID_KEY);
+            presetSizeType = instanceState.getInt(PRESET_SIZE_KEY);
+            isCropped = instanceState.getBoolean(IS_CROPPED_KEY);
+            queryWidth = instanceState.getInt(BITMAP_WIDTH_KEY);
+            queryHeight = instanceState.getInt(BITMAP_HEIGHT_KEY);
+
+            setImageBitmap((Bitmap)instanceState.getParcelable(BITMAP_KEY));
+
+            if (instanceState.getBoolean(PENDING_REFRESH_KEY)) {
+                refreshImage(true);
+            }
+        }
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+
+        // Null out lastRequest. This way, when the response is returned, we can ascertain
+        // that the view is detached and hence should not attempt to update its contents.
+        lastRequest = null;
+    }
+
+    private void initialize(Context context) {
+        // We only want our ImageView in here. Nothing else is permitted
+        removeAllViews();
+
+        image = new ImageView(context);
+
+        LayoutParams imageLayout = new LayoutParams(
+                LayoutParams.MATCH_PARENT,
+                LayoutParams.MATCH_PARENT);
+
+        image.setLayoutParams(imageLayout);
+
+        // We want to prevent up-scaling the image, but still have it fit within
+        // the layout bounds as best as possible.
+        image.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
+        addView(image);
+    }
+
+    private void parseAttributes(AttributeSet attrs) {
+        TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.com_facebook_profile_picture_view);
+        setPresetSize(a.getInt(R.styleable.com_facebook_profile_picture_view_preset_size, CUSTOM));
+        isCropped = a.getBoolean(R.styleable.com_facebook_profile_picture_view_is_cropped, IS_CROPPED_DEFAULT_VALUE);
+        a.recycle();
+    }
+
+    private void refreshImage(boolean force) {
+        boolean changed = updateImageQueryParameters();
+        // Note: do not use Utility.isNullOrEmpty here as this will cause the Eclipse
+        // Graphical Layout editor to fail in some cases
+        if (profileId == null || profileId.length() == 0 ||
+                ((queryWidth == ImageRequest.UNSPECIFIED_DIMENSION) &&
+                        (queryHeight == ImageRequest.UNSPECIFIED_DIMENSION))) {
+            setBlankProfilePicture();
+        } else if (changed || force) {
+            sendImageRequest(true);
+        }
+    }
+
+    private void setBlankProfilePicture() {
+        int blankImageResource = isCropped() ?
+                R.drawable.com_facebook_profile_picture_blank_square :
+                R.drawable.com_facebook_profile_picture_blank_portrait;
+        setImageBitmap( BitmapFactory.decodeResource(getResources(), blankImageResource));
+    }
+
+    private void setImageBitmap(Bitmap imageBitmap) {
+        if (image != null && imageBitmap != null) {
+            imageContents = imageBitmap; // Hold for save-restore cycles
+            image.setImageBitmap(imageBitmap);
+        }
+    }
+
+    private void sendImageRequest(boolean allowCachedResponse) {
+        try {
+            ImageRequest.Builder requestBuilder = new ImageRequest.Builder(
+                    getContext(),
+                    ImageRequest.getProfilePictureUrl(profileId, queryWidth,  queryHeight));
+
+            ImageRequest request = requestBuilder.setAllowCachedRedirects(allowCachedResponse)
+                    .setCallerTag(this)
+                    .setCallback(
+                    new ImageRequest.Callback() {
+                        @Override
+                        public void onCompleted(ImageResponse response) {
+                            processResponse(response);
+                        }
+                    })
+                    .build();
+
+            // Make sure to cancel the old request before sending the new one to prevent
+            // accidental cancellation of the new request. This could happen if the URL and
+            // caller tag stayed the same.
+            if (lastRequest != null) {
+                ImageDownloader.cancelRequest(lastRequest);
+            }
+            lastRequest = request;
+
+            ImageDownloader.downloadAsync(request);
+        } catch (MalformedURLException e) {
+            Logger.log(LoggingBehavior.REQUESTS, Log.ERROR, TAG, e.toString());
+        }
+    }
+
+    private void processResponse(ImageResponse response) {
+        // First check if the response is for the right request. We may have:
+        // 1. Sent a new request, thus super-ceding this one.
+        // 2. Detached this view, in which case the response should be discarded.
+        if (response.getRequest() == lastRequest) {
+            lastRequest = null;
+            Bitmap responseImage = response.getBitmap();
+            Exception error = response.getError();
+            if (error != null) {
+                OnErrorListener listener = onErrorListener;
+                if (listener != null) {
+                    listener.onError(new FacebookException(
+                            "Error in downloading profile picture for profileId: " + getProfileId(), error));
+                } else {
+                    Logger.log(LoggingBehavior.REQUESTS, Log.ERROR, TAG, error.toString());
+                }
+            } else if (responseImage != null) {
+                setImageBitmap(responseImage);
+
+                if (response.isCachedRedirect()) {
+                    sendImageRequest(false);
+                }
+            }
+        }
+    }
+
+    private boolean updateImageQueryParameters() {
+        int newHeightPx = getHeight();
+        int newWidthPx = getWidth();
+        if (newWidthPx < MIN_SIZE || newHeightPx < MIN_SIZE) {
+            // Not enough space laid out for this View yet. Or something else is awry.
+            return false;
+        }
+
+        int presetSize = getPresetSizeInPixels(false);
+        if (presetSize != ImageRequest.UNSPECIFIED_DIMENSION) {
+            newWidthPx = presetSize;
+            newHeightPx = presetSize;
+        }
+
+        // The cropped version is square
+        // If full version is desired, then only one dimension is required.
+        if (newWidthPx <= newHeightPx) {
+            newHeightPx = isCropped() ? newWidthPx : ImageRequest.UNSPECIFIED_DIMENSION;
+        } else {
+            newWidthPx = isCropped() ? newHeightPx : ImageRequest.UNSPECIFIED_DIMENSION;
+        }
+
+        boolean changed = (newWidthPx != queryWidth) || (newHeightPx != queryHeight);
+
+        queryWidth = newWidthPx;
+        queryHeight = newHeightPx;
+
+        return changed;
+    }
+
+    private int getPresetSizeInPixels(boolean forcePreset) {
+        int dimensionId;
+        switch (presetSizeType) {
+            case SMALL:
+                dimensionId = R.dimen.com_facebook_profilepictureview_preset_size_small;
+                break;
+            case NORMAL:
+                dimensionId = R.dimen.com_facebook_profilepictureview_preset_size_normal;
+                break;
+            case LARGE:
+                dimensionId = R.dimen.com_facebook_profilepictureview_preset_size_large;
+                break;
+            case CUSTOM:
+                if (!forcePreset) {
+                    return ImageRequest.UNSPECIFIED_DIMENSION;
+                } else {
+                    dimensionId = R.dimen.com_facebook_profilepictureview_preset_size_normal;
+                    break;
+                }
+            default:
+                return ImageRequest.UNSPECIFIED_DIMENSION;
+        }
+
+        return getResources().getDimensionPixelSize(dimensionId);
+    }
+}
diff --git a/facebook/src/com/facebook/widget/SimpleGraphObjectCursor.java b/facebook/src/com/facebook/widget/SimpleGraphObjectCursor.java
new file mode 100644
index 000000000..08c46b4ba
--- /dev/null
+++ b/facebook/src/com/facebook/widget/SimpleGraphObjectCursor.java
@@ -0,0 +1,162 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.database.CursorIndexOutOfBoundsException;
+import com.facebook.model.GraphObject;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+class SimpleGraphObjectCursor<T extends GraphObject> implements GraphObjectCursor<T> {
+    private int pos = -1;
+    private boolean closed = false;
+    private ArrayList<T> graphObjects = new ArrayList<T>();
+    private boolean moreObjectsAvailable = false;
+    private boolean fromCache = false;
+
+    SimpleGraphObjectCursor() {
+    }
+
+    SimpleGraphObjectCursor(SimpleGraphObjectCursor<T> other) {
+        pos = other.pos;
+        closed = other.closed;
+        graphObjects = new ArrayList<T>();
+        graphObjects.addAll(other.graphObjects);
+        fromCache = other.fromCache;
+
+        // We do not copy observers.
+    }
+
+    public void addGraphObjects(Collection<T> graphObjects, boolean fromCache) {
+        this.graphObjects.addAll(graphObjects);
+        // We consider this cached if ANY results were from the cache.
+        this.fromCache |= fromCache;
+    }
+
+    public boolean isFromCache() {
+        return fromCache;
+    }
+
+    public void setFromCache(boolean fromCache) {
+        this.fromCache = fromCache;
+    }
+
+    public boolean areMoreObjectsAvailable() {
+        return moreObjectsAvailable;
+    }
+
+    public void setMoreObjectsAvailable(boolean moreObjectsAvailable) {
+        this.moreObjectsAvailable = moreObjectsAvailable;
+    }
+
+    @Override
+    public int getCount() {
+        return graphObjects.size();
+    }
+
+    @Override
+    public int getPosition() {
+        return pos;
+    }
+
+    @Override
+    public boolean move(int offset) {
+        return moveToPosition(pos + offset);
+    }
+
+    @Override
+    public boolean moveToPosition(int position) {
+        final int count = getCount();
+        if (position >= count) {
+            pos = count;
+            return false;
+        }
+
+        if (position < 0) {
+            pos = -1;
+            return false;
+        }
+
+        pos = position;
+        return true;
+    }
+
+    @Override
+    public boolean moveToFirst() {
+        return moveToPosition(0);
+    }
+
+    @Override
+    public boolean moveToLast() {
+        return moveToPosition(getCount() - 1);
+    }
+
+    @Override
+    public boolean moveToNext() {
+        return moveToPosition(pos + 1);
+    }
+
+    @Override
+    public boolean moveToPrevious() {
+        return moveToPosition(pos - 1);
+    }
+
+    @Override
+    public boolean isFirst() {
+        return (pos == 0) && (getCount() != 0);
+    }
+
+    @Override
+    public boolean isLast() {
+        final int count = getCount();
+        return (pos == (count - 1)) && (count != 0);
+    }
+
+    @Override
+    public boolean isBeforeFirst() {
+        return (getCount() == 0) || (pos == -1);
+    }
+
+    @Override
+    public boolean isAfterLast() {
+        final int count = getCount();
+        return (count == 0) || (pos == count);
+    }
+
+    @Override
+    public T getGraphObject() {
+        if (pos < 0) {
+            throw new CursorIndexOutOfBoundsException("Before first object.");
+        }
+        if (pos >= graphObjects.size()) {
+            throw new CursorIndexOutOfBoundsException("After last object.");
+        }
+        return graphObjects.get(pos);
+    }
+
+    @Override
+    public void close() {
+        closed = true;
+    }
+
+    @Override
+    public boolean isClosed() {
+        return closed;
+    }
+
+}
diff --git a/facebook/src/com/facebook/widget/UrlRedirectCache.java b/facebook/src/com/facebook/widget/UrlRedirectCache.java
new file mode 100644
index 000000000..278e3e4e1
--- /dev/null
+++ b/facebook/src/com/facebook/widget/UrlRedirectCache.java
@@ -0,0 +1,101 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.content.Context;
+import com.facebook.internal.FileLruCache;
+import com.facebook.internal.Utility;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+
+class UrlRedirectCache {
+    static final String TAG = UrlRedirectCache.class.getSimpleName();
+    private static final String REDIRECT_CONTENT_TAG = TAG + "_Redirect";
+
+    private volatile static FileLruCache urlRedirectCache;
+
+    synchronized static FileLruCache getCache(Context context) throws IOException{
+        if (urlRedirectCache == null) {
+            urlRedirectCache = new FileLruCache(context.getApplicationContext(), TAG, new FileLruCache.Limits());
+        }
+        return urlRedirectCache;
+    }
+
+    static URL getRedirectedUrl(Context context, URL url) {
+        if (url == null) {
+            return null;
+        }
+
+        String urlString = url.toString();
+        URL finalUrl = null;
+        InputStreamReader reader = null;
+        try {
+            InputStream stream;
+            FileLruCache cache = getCache(context);
+            boolean redirectExists = false;
+            while ((stream = cache.get(urlString, REDIRECT_CONTENT_TAG)) != null) {
+                redirectExists = true;
+
+                // Get the redirected url
+                reader = new InputStreamReader(stream);
+                char[] buffer = new char[128];
+                int bufferLength;
+                StringBuilder urlBuilder = new StringBuilder();
+                while ((bufferLength = reader.read(buffer, 0, buffer.length)) > 0) {
+                    urlBuilder.append(buffer, 0, bufferLength);
+                }
+                Utility.closeQuietly(reader);
+
+                // Iterate to the next url in the redirection
+                urlString = urlBuilder.toString();
+            }
+
+            if (redirectExists) {
+                finalUrl = new URL(urlString);
+            }
+        } catch (MalformedURLException e) {
+            // caching is best effort, so ignore the exception
+        } catch (IOException ioe) {
+        } finally {
+            Utility.closeQuietly(reader);
+        }
+
+        return finalUrl;
+    }
+
+    static void cacheUrlRedirect(Context context, URL fromUrl, URL toUrl) {
+        if (fromUrl == null || toUrl == null) {
+            return;
+        }
+
+        OutputStream redirectStream = null;
+        try {
+            FileLruCache cache = getCache(context);
+            redirectStream = cache.openPutStream(fromUrl.toString(), REDIRECT_CONTENT_TAG);
+            redirectStream.write(toUrl.toString().getBytes());
+        } catch (IOException e) {
+            // Caching is best effort
+        } finally {
+            Utility.closeQuietly(redirectStream);
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/widget/UserSettingsFragment.java b/facebook/src/com/facebook/widget/UserSettingsFragment.java
new file mode 100644
index 000000000..74d7aa5e9
--- /dev/null
+++ b/facebook/src/com/facebook/widget/UserSettingsFragment.java
@@ -0,0 +1,394 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.os.Bundle;
+import android.text.TextUtils;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.TextView;
+import com.facebook.*;
+import com.facebook.android.R;
+import com.facebook.model.GraphUser;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.List;
+
+/**
+ * A Fragment that displays a Login/Logout button as well as the user's
+ * profile picture and name when logged in.
+ * <p/>
+ * This Fragment will create and use the active session upon construction
+ * if it has the available data (if the app ID is specified in the manifest).
+ * It will also open the active session if it does not require user interaction
+ * (i.e. if the session is in the {@link com.facebook.SessionState#CREATED_TOKEN_LOADED} state.
+ * Developers can override the use of the active session by calling
+ * the {@link #setSession(com.facebook.Session)} method.
+ */
+public class UserSettingsFragment extends FacebookFragment {
+
+    private static final String NAME = "name";
+    private static final String ID = "id";
+    private static final String PICTURE = "picture";
+    private static final String FIELDS = "fields";
+    
+    private static final String REQUEST_FIELDS = TextUtils.join(",", new String[] {ID, NAME, PICTURE});
+
+    private LoginButton loginButton;
+    private LoginButton.LoginButtonProperties loginButtonProperties = new LoginButton.LoginButtonProperties();
+    private TextView connectedStateLabel;
+    private GraphUser user;
+    private Session userInfoSession; // the Session used to fetch the current user info
+    private Drawable userProfilePic;
+    private String userProfilePicID;
+    private Session.StatusCallback sessionStatusCallback;
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        View view = inflater.inflate(R.layout.com_facebook_usersettingsfragment, container, false);
+        loginButton = (LoginButton) view.findViewById(R.id.com_facebook_usersettingsfragment_login_button);
+        loginButton.setProperties(loginButtonProperties);
+        loginButton.setFragment(this);
+        Session session = getSession();
+        if (session != null && !session.equals(Session.getActiveSession())) {
+            loginButton.setSession(session);
+        }
+        connectedStateLabel = (TextView) view.findViewById(R.id.com_facebook_usersettingsfragment_profile_name);
+        
+        // if no background is set for some reason, then default to Facebook blue
+        if (view.getBackground() == null) {
+            view.setBackgroundColor(getResources().getColor(R.color.com_facebook_blue));
+        } else {
+            view.getBackground().setDither(true);
+        }
+        return view;
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setRetainInstance(true);
+    }
+
+    /**
+     * @throws com.facebook.FacebookException if errors occur during the loading of user information
+     */
+    @Override
+    public void onResume() {
+        super.onResume();
+        fetchUserInfo();
+        updateUI();
+    }
+
+    /**
+     * Set the Session object to use instead of the active Session. Since a Session
+     * cannot be reused, if the user logs out from this Session, and tries to
+     * log in again, a new Active Session will be used instead.
+     * <p/>
+     * If the passed in session is currently opened, this method will also attempt to
+     * load some user information for display (if needed).
+     *
+     * @param newSession the Session object to use
+     * @throws com.facebook.FacebookException if errors occur during the loading of user information
+     */
+    @Override
+    public void setSession(Session newSession) {
+        super.setSession(newSession);
+        if (loginButton != null) {
+            loginButton.setSession(newSession);
+        }
+        fetchUserInfo();
+        updateUI();
+    }
+
+    /**
+     * Sets the default audience to use when the session is opened.
+     * This value is only useful when specifying write permissions for the native
+     * login dialog.
+     *
+     * @param defaultAudience the default audience value to use
+     */
+    public void setDefaultAudience(SessionDefaultAudience defaultAudience) {
+        loginButtonProperties.setDefaultAudience(defaultAudience);
+    }
+
+    /**
+     * Gets the default audience to use when the session is opened.
+     * This value is only useful when specifying write permissions for the native
+     * login dialog.
+     *
+     * @return the default audience value to use
+     */
+    public SessionDefaultAudience getDefaultAudience() {
+        return loginButtonProperties.getDefaultAudience();
+    }
+
+    /**
+     * Set the permissions to use when the session is opened. The permissions here
+     * can only be read permissions. If any publish permissions are included, the login
+     * attempt by the user will fail. The LoginButton can only be associated with either
+     * read permissions or publish permissions, but not both. Calling both
+     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
+     * will result in an exception being thrown unless clearPermissions is called in between.
+     * <p/>
+     * This method is only meaningful if called before the session is open. If this is called
+     * after the session is opened, and the list of permissions passed in is not a subset
+     * of the permissions granted during the authorization, it will log an error.
+     * <p/>
+     * Since the session can be automatically opened when the UserSettingsFragment is constructed,
+     * it's important to always pass in a consistent set of permissions to this method, or
+     * manage the setting of permissions outside of the LoginButton class altogether
+     * (by managing the session explicitly).
+     *
+     * @param permissions the read permissions to use
+     *
+     * @throws UnsupportedOperationException if setPublishPermissions has been called
+     */
+    public void setReadPermissions(List<String> permissions) {
+        loginButtonProperties.setReadPermissions(permissions, getSession());
+    }
+
+    /**
+     * Set the permissions to use when the session is opened. The permissions here
+     * should only be publish permissions. If any read permissions are included, the login
+     * attempt by the user may fail. The LoginButton can only be associated with either
+     * read permissions or publish permissions, but not both. Calling both
+     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
+     * will result in an exception being thrown unless clearPermissions is called in between.
+     * <p/>
+     * This method is only meaningful if called before the session is open. If this is called
+     * after the session is opened, and the list of permissions passed in is not a subset
+     * of the permissions granted during the authorization, it will log an error.
+     * <p/>
+     * Since the session can be automatically opened when the LoginButton is constructed,
+     * it's important to always pass in a consistent set of permissions to this method, or
+     * manage the setting of permissions outside of the LoginButton class altogether
+     * (by managing the session explicitly).
+     *
+     * @param permissions the read permissions to use
+     *
+     * @throws UnsupportedOperationException if setReadPermissions has been called
+     * @throws IllegalArgumentException if permissions is null or empty
+     */
+    public void setPublishPermissions(List<String> permissions) {
+        loginButtonProperties.setPublishPermissions(permissions, getSession());
+    }
+
+
+    /**
+     * Clears the permissions currently associated with this LoginButton.
+     */
+    public void clearPermissions() {
+        loginButtonProperties.clearPermissions();
+    }
+
+    /**
+     * Sets the login behavior for the session that will be opened. If null is specified,
+     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
+     * will be used.
+     *
+     * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
+     *                      specifies what behaviors should be attempted during
+     *                      authorization.
+     */
+    public void setLoginBehavior(SessionLoginBehavior loginBehavior) {
+        loginButtonProperties.setLoginBehavior(loginBehavior);
+    }
+
+    /**
+     * Gets the login behavior for the session that will be opened. If null is returned,
+     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
+     * will be used.
+     *
+     * @return loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
+     *                      specifies what behaviors should be attempted during
+     *                      authorization.
+     */
+    public SessionLoginBehavior getLoginBehavior() {
+        return loginButtonProperties.getLoginBehavior();
+    }
+
+    /**
+     * Sets an OnErrorListener for this instance of UserSettingsFragment to call into when
+     * certain exceptions occur.
+     *
+     * @param onErrorListener The listener object to set
+     */
+    public void setOnErrorListener(LoginButton.OnErrorListener onErrorListener) {
+        loginButtonProperties.setOnErrorListener(onErrorListener);
+    }
+
+    /**
+     * Returns the current OnErrorListener for this instance of UserSettingsFragment.
+     *
+     * @return The OnErrorListener
+     */
+    public LoginButton.OnErrorListener getOnErrorListener() {
+        return loginButtonProperties.getOnErrorListener();
+    }
+
+    /**
+     * Sets the callback interface that will be called whenever the status of the Session
+     * associated with this LoginButton changes.
+     *
+     * @param callback the callback interface
+     */
+    public void setSessionStatusCallback(Session.StatusCallback callback) {
+        this.sessionStatusCallback = callback;
+    }
+
+    /**
+     * Sets the callback interface that will be called whenever the status of the Session
+     * associated with this LoginButton changes.
+
+     * @return the callback interface
+     */
+    public Session.StatusCallback getSessionStatusCallback() {
+        return sessionStatusCallback;
+    }
+
+    @Override
+    protected void onSessionStateChange(SessionState state, Exception exception) {
+        fetchUserInfo();
+        updateUI();
+
+        if (sessionStatusCallback != null) {
+            sessionStatusCallback.call(getSession(), state, exception);
+        }
+    }
+
+    // For Testing Only
+    List<String> getPermissions() {
+        return loginButtonProperties.getPermissions();
+    }
+    
+    private void fetchUserInfo() {
+        final Session currentSession = getSession();
+        if (currentSession != null && currentSession.isOpened()) {
+            if (currentSession != userInfoSession) {
+                Request request = Request.newMeRequest(currentSession, new Request.GraphUserCallback() {
+                    @Override
+                    public void onCompleted(GraphUser me, Response response) {
+                        if (currentSession == getSession()) {
+                            user = me;
+                            updateUI();
+                        }
+                        if (response.getError() != null) {
+                            loginButton.handleError(response.getError().getException());
+                        }
+                    }
+                });
+                Bundle parameters = new Bundle();
+                parameters.putString(FIELDS, REQUEST_FIELDS);
+                request.setParameters(parameters);
+                Request.executeBatchAsync(request);
+                userInfoSession = currentSession;
+            }
+        } else {
+            user = null;
+        }
+    }
+    
+    private void updateUI() {
+        if (!isAdded()) {
+            return;
+        }
+        if (isSessionOpen()) {
+            connectedStateLabel.setTextColor(getResources().getColor(R.color.com_facebook_usersettingsfragment_connected_text_color));
+            connectedStateLabel.setShadowLayer(1f, 0f, -1f,
+                    getResources().getColor(R.color.com_facebook_usersettingsfragment_connected_shadow_color));
+            
+            if (user != null) {
+                ImageRequest request = getImageRequest();
+                if (request != null) {
+                    URL requestUrl = request.getImageUrl();
+                    // Do we already have the right picture? If so, leave it alone.
+                    if (!requestUrl.equals(connectedStateLabel.getTag())) {
+                        if (user.getId().equals(userProfilePicID)) {
+                            connectedStateLabel.setCompoundDrawables(null, userProfilePic, null, null);
+                            connectedStateLabel.setTag(requestUrl);
+                        } else {
+                            ImageDownloader.downloadAsync(request);
+                        }
+                    }
+                }
+                connectedStateLabel.setText(user.getName());
+            } else {
+                connectedStateLabel.setText(getResources().getString(
+                        R.string.com_facebook_usersettingsfragment_logged_in));
+                Drawable noProfilePic = getResources().getDrawable(R.drawable.com_facebook_profile_default_icon);
+                noProfilePic.setBounds(0, 0,
+                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_width),
+                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_height));
+                connectedStateLabel.setCompoundDrawables(null, noProfilePic, null, null);
+            }
+        } else {
+            int textColor = getResources().getColor(R.color.com_facebook_usersettingsfragment_not_connected_text_color);
+            connectedStateLabel.setTextColor(textColor);
+            connectedStateLabel.setShadowLayer(0f, 0f, 0f, textColor);
+            connectedStateLabel.setText(getResources().getString(
+                    R.string.com_facebook_usersettingsfragment_not_logged_in));
+            connectedStateLabel.setCompoundDrawables(null, null, null, null);
+            connectedStateLabel.setTag(null);
+        }
+    }
+
+    private ImageRequest getImageRequest() {
+        ImageRequest request = null;
+        try {
+            ImageRequest.Builder requestBuilder = new ImageRequest.Builder(
+                    getActivity(),
+                    ImageRequest.getProfilePictureUrl(
+                            user.getId(),
+                            getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_width),
+                            getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_height)));
+
+            request = requestBuilder.setCallerTag(this)
+                    .setCallback(
+                            new ImageRequest.Callback() {
+                                @Override
+                                public void onCompleted(ImageResponse response) {
+                                    processImageResponse(user.getId(), response);
+                                }
+                            })
+                    .build();
+        } catch (MalformedURLException e) {
+        }
+        return request;
+    }
+
+    private void processImageResponse(String id, ImageResponse response) {
+        if (response != null) {
+            Bitmap bitmap = response.getBitmap();
+            if (bitmap != null) {
+                BitmapDrawable drawable = new BitmapDrawable(UserSettingsFragment.this.getResources(), bitmap);
+                drawable.setBounds(0, 0,
+                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_width),
+                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_height));
+                userProfilePic = drawable;
+                userProfilePicID = id;
+                connectedStateLabel.setCompoundDrawables(null, drawable, null, null);
+                connectedStateLabel.setTag(response.getRequest().getImageUrl());
+            }
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/widget/WebDialog.java b/facebook/src/com/facebook/widget/WebDialog.java
new file mode 100644
index 000000000..7aea576c7
--- /dev/null
+++ b/facebook/src/com/facebook/widget/WebDialog.java
@@ -0,0 +1,733 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.annotation.SuppressLint;
+import android.app.Dialog;
+import android.app.ProgressDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.net.http.SslError;
+import android.os.Bundle;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.Window;
+import android.webkit.SslErrorHandler;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import com.facebook.*;
+import com.facebook.android.*;
+import com.facebook.internal.Logger;
+import com.facebook.internal.ServerProtocol;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+
+/**
+ * This class provides a mechanism for displaying Facebook Web dialogs inside a Dialog. Helper
+ * methods are provided to construct commonly-used dialogs, or a caller can specify arbitrary
+ * parameters to call other dialogs.
+ */
+public class WebDialog extends Dialog {
+    private static final String LOG_TAG = Logger.LOG_TAG_BASE + "WebDialog";
+    private static final String DISPLAY_TOUCH = "touch";
+    private static final String USER_AGENT = "user_agent";
+    static final String REDIRECT_URI = "fbconnect://success";
+    static final String CANCEL_URI = "fbconnect://cancel";
+
+    public static final int DEFAULT_THEME = android.R.style.Theme_Translucent_NoTitleBar;
+
+    private String url;
+    private OnCompleteListener onCompleteListener;
+    private WebView webView;
+    private ProgressDialog spinner;
+    private ImageView crossImageView;
+    private FrameLayout contentFrameLayout;
+    private boolean listenerCalled = false;
+    private boolean isDetached = false;
+
+    /**
+     * Interface that implements a listener to be called when the user's interaction with the
+     * dialog completes, whether because the dialog finished successfully, or it was cancelled,
+     * or an error was encountered.
+     */
+    public interface OnCompleteListener {
+        /**
+         * Called when the dialog completes.
+         *
+         * @param values on success, contains the values returned by the dialog
+         * @param error  on an error, contains an exception describing the error
+         */
+        void onComplete(Bundle values, FacebookException error);
+    }
+
+    /**
+     * Constructor which can be used to display a dialog with an already-constructed URL.
+     *
+     * @param context the context to use to display the dialog
+     * @param url     the URL of the Web Dialog to display; no validation is done on this URL, but it should
+     *                be a valid URL pointing to a Facebook Web Dialog
+     */
+    public WebDialog(Context context, String url) {
+        this(context, url, DEFAULT_THEME);
+    }
+
+    /**
+     * Constructor which can be used to display a dialog with an already-constructed URL and a custom theme.
+     *
+     * @param context the context to use to display the dialog
+     * @param url     the URL of the Web Dialog to display; no validation is done on this URL, but it should
+     *                be a valid URL pointing to a Facebook Web Dialog
+     * @param theme   identifier of a theme to pass to the Dialog class
+     */
+    public WebDialog(Context context, String url, int theme) {
+        super(context, theme);
+        this.url = url;
+    }
+
+    /**
+     * Constructor which will construct the URL of the Web dialog based on the specified parameters.
+     *
+     * @param context    the context to use to display the dialog
+     * @param action     the portion of the dialog URL following "dialog/"
+     * @param parameters parameters which will be included as part of the URL
+     * @param theme      identifier of a theme to pass to the Dialog class
+     * @param listener the listener to notify, or null if no notification is desired
+     */
+    public WebDialog(Context context, String action, Bundle parameters, int theme, OnCompleteListener listener) {
+        super(context, theme);
+
+        if (parameters == null) {
+            parameters = new Bundle();
+        }
+        parameters.putString(ServerProtocol.DIALOG_PARAM_DISPLAY, DISPLAY_TOUCH);
+        parameters.putString(ServerProtocol.DIALOG_PARAM_TYPE, USER_AGENT);
+
+        Uri uri = Utility.buildUri(ServerProtocol.DIALOG_AUTHORITY, ServerProtocol.DIALOG_PATH + action, parameters);
+        this.url = uri.toString();
+        onCompleteListener = listener;
+    }
+
+    /**
+     * Sets the listener which will be notified when the dialog finishes.
+     *
+     * @param listener the listener to notify, or null if no notification is desired
+     */
+    public void setOnCompleteListener(OnCompleteListener listener) {
+        onCompleteListener = listener;
+    }
+
+    /**
+     * Gets the listener which will be notified when the dialog finishes.
+     *
+     * @return the listener, or null if none has been specified
+     */
+    public OnCompleteListener getOnCompleteListener() {
+        return onCompleteListener;
+    }
+
+    @Override
+    public void dismiss() {
+        if (webView != null) {
+            webView.stopLoading();
+        }
+        if (!isDetached) {
+            if (spinner.isShowing()) {
+                spinner.dismiss();
+            }
+            super.dismiss();
+        }
+    }
+
+    @Override
+    public void onDetachedFromWindow() {
+        isDetached = true;
+        super.onDetachedFromWindow();
+    }
+
+    @Override
+    public void onAttachedToWindow() {
+        isDetached = false;
+        super.onAttachedToWindow();
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        setOnCancelListener(new OnCancelListener() {
+            @Override
+            public void onCancel(DialogInterface dialogInterface) {
+                sendCancelToListener();
+            }
+        });
+
+        spinner = new ProgressDialog(getContext());
+        spinner.requestWindowFeature(Window.FEATURE_NO_TITLE);
+        spinner.setMessage(getContext().getString(R.string.com_facebook_loading));
+        spinner.setOnCancelListener(new OnCancelListener() {
+            @Override
+            public void onCancel(DialogInterface dialogInterface) {
+                sendCancelToListener();
+                WebDialog.this.dismiss();
+            }
+        });
+
+        requestWindowFeature(Window.FEATURE_NO_TITLE);
+        contentFrameLayout = new FrameLayout(getContext());
+
+        /* Create the 'x' image, but don't add to the contentFrameLayout layout yet
+         * at this point, we only need to know its drawable width and height
+         * to place the webview
+         */
+        createCrossImage();
+
+        /* Now we know 'x' drawable width and height,
+        * layout the webivew and add it the contentFrameLayout layout
+        */
+        int crossWidth = crossImageView.getDrawable().getIntrinsicWidth();
+        setUpWebView(crossWidth / 2);
+
+        /* Finally add the 'x' image to the contentFrameLayout layout and
+        * add contentFrameLayout to the Dialog view
+        */
+        contentFrameLayout.addView(crossImageView, new ViewGroup.LayoutParams(
+                ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
+        addContentView(contentFrameLayout,
+                new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
+    }
+
+    private void sendSuccessToListener(Bundle values) {
+        if (onCompleteListener != null && !listenerCalled) {
+            listenerCalled = true;
+            onCompleteListener.onComplete(values, null);
+        }
+    }
+
+    private void sendErrorToListener(Throwable error) {
+        if (onCompleteListener != null && !listenerCalled) {
+            listenerCalled = true;
+            FacebookException facebookException = null;
+            if (error instanceof FacebookException) {
+                facebookException = (FacebookException) error;
+            } else {
+                facebookException = new FacebookException(error);
+            }
+            onCompleteListener.onComplete(null, facebookException);
+        }
+    }
+
+    private void sendCancelToListener() {
+        sendErrorToListener(new FacebookOperationCanceledException());
+    }
+
+    private void createCrossImage() {
+        crossImageView = new ImageView(getContext());
+        // Dismiss the dialog when user click on the 'x'
+        crossImageView.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                sendCancelToListener();
+                WebDialog.this.dismiss();
+            }
+        });
+        Drawable crossDrawable = getContext().getResources().getDrawable(R.drawable.com_facebook_close);
+        crossImageView.setImageDrawable(crossDrawable);
+        /* 'x' should not be visible while webview is loading
+         * make it visible only after webview has fully loaded
+        */
+        crossImageView.setVisibility(View.INVISIBLE);
+    }
+
+    @SuppressLint("SetJavaScriptEnabled")
+    private void setUpWebView(int margin) {
+        LinearLayout webViewContainer = new LinearLayout(getContext());
+        webView = new WebView(getContext());
+        webView.setVerticalScrollBarEnabled(false);
+        webView.setHorizontalScrollBarEnabled(false);
+        webView.setWebViewClient(new DialogWebViewClient());
+        webView.getSettings().setJavaScriptEnabled(true);
+        webView.loadUrl(url);
+        webView.setLayoutParams(new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
+                ViewGroup.LayoutParams.MATCH_PARENT));
+        webView.setVisibility(View.INVISIBLE);
+        webView.getSettings().setSavePassword(false);
+
+        webViewContainer.setPadding(margin, margin, margin, margin);
+        webViewContainer.addView(webView);
+        contentFrameLayout.addView(webViewContainer);
+    }
+
+    private class DialogWebViewClient extends WebViewClient {
+        @Override
+        @SuppressWarnings("deprecation")
+        public boolean shouldOverrideUrlLoading(WebView view, String url) {
+            Utility.logd(LOG_TAG, "Redirect URL: " + url);
+            if (url.startsWith(WebDialog.REDIRECT_URI)) {
+                Bundle values = Util.parseUrl(url);
+
+                String error = values.getString("error");
+                if (error == null) {
+                    error = values.getString("error_type");
+                }
+
+                String errorMessage = values.getString("error_msg");
+                if (errorMessage == null) {
+                    errorMessage = values.getString("error_description");
+                }
+                String errorCodeString = values.getString("error_code");
+                int errorCode = FacebookRequestError.INVALID_ERROR_CODE;
+                if (!Utility.isNullOrEmpty(errorCodeString)) {
+                    try {
+                        errorCode = Integer.parseInt(errorCodeString);
+                    } catch (NumberFormatException ex) {
+                        errorCode = FacebookRequestError.INVALID_ERROR_CODE;
+                    }
+                }
+
+                if (Utility.isNullOrEmpty(error) && Utility
+                        .isNullOrEmpty(errorMessage) && errorCode == FacebookRequestError.INVALID_ERROR_CODE) {
+                    sendSuccessToListener(values);
+                } else if (error != null && (error.equals("access_denied") ||
+                        error.equals("OAuthAccessDeniedException"))) {
+                    sendCancelToListener();
+                } else {
+                    FacebookRequestError requestError = new FacebookRequestError(errorCode, error, errorMessage);
+                    sendErrorToListener(new FacebookServiceException(requestError, errorMessage));
+                }
+
+                WebDialog.this.dismiss();
+                return true;
+            } else if (url.startsWith(WebDialog.CANCEL_URI)) {
+                sendCancelToListener();
+                WebDialog.this.dismiss();
+                return true;
+            } else if (url.contains(DISPLAY_TOUCH)) {
+                return false;
+            }
+            // launch non-dialog URLs in a full browser
+            getContext().startActivity(
+                    new Intent(Intent.ACTION_VIEW, Uri.parse(url)));
+            return true;
+        }
+
+        @Override
+        public void onReceivedError(WebView view, int errorCode,
+                String description, String failingUrl) {
+            super.onReceivedError(view, errorCode, description, failingUrl);
+            sendErrorToListener(new FacebookDialogException(description, errorCode, failingUrl));
+            WebDialog.this.dismiss();
+        }
+
+        @Override
+        public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {
+            super.onReceivedSslError(view, handler, error);
+
+            sendErrorToListener(new FacebookDialogException(null, ERROR_FAILED_SSL_HANDSHAKE, null));
+            handler.cancel();
+            WebDialog.this.dismiss();
+        }
+
+        @Override
+        public void onPageStarted(WebView view, String url, Bitmap favicon) {
+            Utility.logd(LOG_TAG, "Webview loading URL: " + url);
+            super.onPageStarted(view, url, favicon);
+            if (!isDetached) {
+                spinner.show();
+            }
+        }
+
+        @Override
+        public void onPageFinished(WebView view, String url) {
+            super.onPageFinished(view, url);
+            if (!isDetached) {
+                spinner.dismiss();
+            }
+            /*
+             * Once web view is fully loaded, set the contentFrameLayout background to be transparent
+             * and make visible the 'x' image.
+             */
+            contentFrameLayout.setBackgroundColor(Color.TRANSPARENT);
+            webView.setVisibility(View.VISIBLE);
+            crossImageView.setVisibility(View.VISIBLE);
+        }
+    }
+
+    private static class BuilderBase<CONCRETE extends BuilderBase<?>> {
+        private static final String APP_ID_PARAM = "app_id";
+        public static final String ACCESS_TOKEN = "access_token";
+
+        private Context context;
+        private Session session;
+        private String applicationId;
+        private String action;
+        private int theme = DEFAULT_THEME;
+        private OnCompleteListener listener;
+        private Bundle parameters;
+
+        protected BuilderBase(Context context, Session session, String action, Bundle parameters) {
+            Validate.notNull(session, "session");
+            if (!session.isOpened()) {
+                throw new FacebookException("Attempted to use a Session that was not open.");
+            }
+            this.session = session;
+
+            finishInit(context, action, parameters);
+        }
+
+        protected BuilderBase(Context context, String applicationId, String action, Bundle parameters) {
+            Validate.notNullOrEmpty(applicationId, "applicationId");
+            this.applicationId = applicationId;
+
+            finishInit(context, action, parameters);
+        }
+
+        /**
+         * Sets a theme identifier which will be passed to the underlying Dialog.
+         *
+         * @param theme a theme identifier which will be passed to the Dialog class
+         * @return the builder
+         */
+        public CONCRETE setTheme(int theme) {
+            this.theme = theme;
+            @SuppressWarnings("unchecked")
+            CONCRETE result = (CONCRETE) this;
+            return result;
+        }
+
+        /**
+         * Sets the listener which will be notified when the dialog finishes.
+         *
+         * @param listener the listener to notify, or null if no notification is desired
+         * @return the builder
+         */
+        public CONCRETE setOnCompleteListener(OnCompleteListener listener) {
+            this.listener = listener;
+            @SuppressWarnings("unchecked")
+            CONCRETE result = (CONCRETE) this;
+            return result;
+        }
+
+        /**
+         * Constructs a WebDialog using the parameters provided. The dialog is not shown,
+         * but is ready to be shown by calling Dialog.show().
+         *
+         * @return the WebDialog
+         */
+        public WebDialog build() {
+            if (session != null && session.isOpened()) {
+                parameters.putString(APP_ID_PARAM, session.getApplicationId());
+                parameters.putString(ACCESS_TOKEN, session.getAccessToken());
+            } else {
+                parameters.putString(APP_ID_PARAM, applicationId);
+            }
+
+            if (!parameters.containsKey(ServerProtocol.DIALOG_PARAM_REDIRECT_URI)) {
+                parameters.putString(ServerProtocol.DIALOG_PARAM_REDIRECT_URI, REDIRECT_URI);
+            }
+
+            return new WebDialog(context, action, parameters, theme, listener);
+        }
+
+        protected String getApplicationId() {
+            return applicationId;
+        }
+
+        protected Context getContext() {
+            return context;
+        }
+
+        protected int getTheme() {
+            return theme;
+        }
+
+        protected Bundle getParameters() {
+            return parameters;
+        }
+
+        protected WebDialog.OnCompleteListener getListener() {
+            return listener;
+        }
+
+        private void finishInit(Context context, String action, Bundle parameters) {
+            this.context = context;
+            this.action = action;
+            if (parameters != null) {
+                this.parameters = parameters;
+            } else {
+                this.parameters = new Bundle();
+            }
+        }
+    }
+
+    /**
+     * Provides a builder that allows construction of an arbitary Facebook web dialog.
+     */
+    public static class Builder extends BuilderBase<Builder> {
+        /**
+         * Constructor that builds a dialog for an authenticated user.
+         *
+         * @param context the Context within which the dialog will be shown.
+         * @param session the Session representing an authenticating user to use for
+         *                showing the dialog; must not be null, and must be opened.
+         * @param action the portion of the dialog URL following www.facebook.com/dialog/.
+         *               See https://developers.facebook.com/docs/reference/dialogs/ for details.
+         * @param parameters a Bundle containing parameters to pass as part of the URL.
+         */
+        public Builder(Context context, Session session, String action, Bundle parameters) {
+            super(context, session, action, parameters);
+        }
+
+        /**
+         * Constructor that builds a dialog without an authenticated user.
+         *
+         * @param context the Context within which the dialog will be shown.
+         * @param applicationId the application ID to be included in the dialog URL.
+         * @param action the portion of the dialog URL following www.facebook.com/dialog/.
+         *               See https://developers.facebook.com/docs/reference/dialogs/ for details.
+         * @param parameters a Bundle containing parameters to pass as part of the URL.
+         */
+        public Builder(Context context, String applicationId, String action, Bundle parameters) {
+            super(context, applicationId, action, parameters);
+        }
+    }
+
+    /**
+     * Provides a builder that allows construction of the parameters for showing
+     * the Feed Dialog (https://developers.facebook.com/docs/reference/dialogs/feed/).
+     */
+    public static class FeedDialogBuilder extends BuilderBase<FeedDialogBuilder> {
+        private static final String FEED_DIALOG = "feed";
+        private static final String FROM_PARAM = "from";
+        private static final String TO_PARAM = "to";
+        private static final String LINK_PARAM = "link";
+        private static final String PICTURE_PARAM = "picture";
+        private static final String SOURCE_PARAM = "source";
+        private static final String NAME_PARAM = "name";
+        private static final String CAPTION_PARAM = "caption";
+        private static final String DESCRIPTION_PARAM = "description";
+
+        /**
+         * Constructor.
+         *
+         * @param context the Context within which the dialog will be shown.
+         * @param session the Session representing an authenticating user to use for
+         *                showing the dialog; must not be null, and must be opened.
+         */
+        public FeedDialogBuilder(Context context, Session session) {
+            super(context, session, FEED_DIALOG, null);
+        }
+
+        /**
+         * Constructor.
+         *
+         * @param context    the Context within which the dialog will be shown.
+         * @param parameters a Bundle containing parameters to pass as part of the
+         *                   dialog URL. No validation is done on these parameters; it is
+         *                   the caller's responsibility to ensure they are valid.
+         * @param session    the Session representing an authenticating user to use for
+         *                   showing the dialog; must not be null, and must be opened.
+         */
+        public FeedDialogBuilder(Context context, Session session, Bundle parameters) {
+            super(context, session, FEED_DIALOG, parameters);
+        }
+
+        /**
+         * Sets the ID of the profile that is posting to Facebook. If none is specified,
+         * the default is "me". This profile must be either the authenticated user or a
+         * Page that the user is an administrator of.
+         *
+         * @param id Facebook ID of the profile to post from
+         * @return the builder
+         */
+        public FeedDialogBuilder setFrom(String id) {
+            getParameters().putString(FROM_PARAM, id);
+            return this;
+        }
+
+        /**
+         * Sets the ID of the profile that the story will be published to. If not specified, it
+         * will default to the same profile that the story is being published from.
+         *
+         * @param id Facebook ID of the profile to post to
+         * @return the builder
+         */
+        public FeedDialogBuilder setTo(String id) {
+            getParameters().putString(TO_PARAM, id);
+            return this;
+        }
+
+        /**
+         * Sets the URL of a link to be shared.
+         *
+         * @param link the URL
+         * @return the builder
+         */
+        public FeedDialogBuilder setLink(String link) {
+            getParameters().putString(LINK_PARAM, link);
+            return this;
+        }
+
+        /**
+         * Sets the URL of a picture to be shared.
+         *
+         * @param picture the URL of the picture
+         * @return the builder
+         */
+        public FeedDialogBuilder setPicture(String picture) {
+            getParameters().putString(PICTURE_PARAM, picture);
+            return this;
+        }
+
+        /**
+         * Sets the URL of a media file attached to this post. If this is set, any picture
+         * set via setPicture will be ignored.
+         *
+         * @param source the URL of the media file
+         * @return the builder
+         */
+        public FeedDialogBuilder setSource(String source) {
+            getParameters().putString(SOURCE_PARAM, source);
+            return this;
+        }
+
+        /**
+         * Sets the name of the item being shared.
+         *
+         * @param name the name
+         * @return the builder
+         */
+        public FeedDialogBuilder setName(String name) {
+            getParameters().putString(NAME_PARAM, name);
+            return this;
+        }
+
+        /**
+         * Sets the caption to be displayed.
+         *
+         * @param caption the caption
+         * @return the builder
+         */
+        public FeedDialogBuilder setCaption(String caption) {
+            getParameters().putString(CAPTION_PARAM, caption);
+            return this;
+        }
+
+        /**
+         * Sets the description to be displayed.
+         *
+         * @param description the description
+         * @return the builder
+         */
+        public FeedDialogBuilder setDescription(String description) {
+            getParameters().putString(DESCRIPTION_PARAM, description);
+            return this;
+        }
+    }
+
+    /**
+     * Provides a builder that allows construction of the parameters for showing
+     * the Feed Dialog (https://developers.facebook.com/docs/reference/dialogs/feed/).
+     */
+    public static class RequestsDialogBuilder extends BuilderBase<RequestsDialogBuilder> {
+        private static final String APPREQUESTS_DIALOG = "apprequests";
+        private static final String MESSAGE_PARAM = "message";
+        private static final String TO_PARAM = "to";
+        private static final String DATA_PARAM = "data";
+        private static final String TITLE_PARAM = "title";
+
+        /**
+         * Constructor.
+         *
+         * @param context the Context within which the dialog will be shown.
+         * @param session the Session representing an authenticating user to use for
+         *                showing the dialog; must not be null, and must be opened.
+         */
+        public RequestsDialogBuilder(Context context, Session session) {
+            super(context, session, APPREQUESTS_DIALOG, null);
+        }
+
+        /**
+         * Constructor.
+         *
+         * @param context    the Context within which the dialog will be shown.
+         * @param parameters a Bundle containing parameters to pass as part of the
+         *                   dialog URL. No validation is done on these parameters; it is
+         *                   the caller's responsibility to ensure they are valid.
+         * @param session    the Session representing an authenticating user to use for
+         *                   showing the dialog; must not be null, and must be opened.
+         */
+        public RequestsDialogBuilder(Context context, Session session, Bundle parameters) {
+            super(context, session, APPREQUESTS_DIALOG, parameters);
+        }
+
+        /**
+         * Sets the string users receiving the request will see. The maximum length
+         * is 60 characters.
+         *
+         * @param message the message
+         * @return the builder
+         */
+        public RequestsDialogBuilder setMessage(String message) {
+            getParameters().putString(MESSAGE_PARAM, message);
+            return this;
+        }
+
+        /**
+         * Sets the user ID or user name the request will be sent to. If this is not
+         * specified, a friend selector will be displayed and the user can select up
+         * to 50 friends.
+         *
+         * @param id the id or user name to send the request to
+         * @return the builder
+         */
+        public RequestsDialogBuilder setTo(String id) {
+            getParameters().putString(TO_PARAM, id);
+            return this;
+        }
+
+        /**
+         * Sets optional data which can be used for tracking; maximum length is 255
+         * characters.
+         *
+         * @param data the data
+         * @return the builder
+         */
+        public RequestsDialogBuilder setData(String data) {
+            getParameters().putString(DATA_PARAM, data);
+            return this;
+        }
+
+        /**
+         * Sets an optional title for the dialog; maximum length is 50 characters.
+         *
+         * @param title the title
+         * @return the builder
+         */
+        public RequestsDialogBuilder setTitle(String title) {
+            getParameters().putString(TITLE_PARAM, title);
+            return this;
+        }
+    }
+}
diff --git a/facebook/src/com/facebook/widget/WorkQueue.java b/facebook/src/com/facebook/widget/WorkQueue.java
new file mode 100644
index 000000000..adcee1d71
--- /dev/null
+++ b/facebook/src/com/facebook/widget/WorkQueue.java
@@ -0,0 +1,221 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import com.facebook.Settings;
+
+import java.util.concurrent.Executor;
+
+class WorkQueue {
+    public static final int DEFAULT_MAX_CONCURRENT = 8;
+
+    private final Object workLock = new Object();
+    private WorkNode pendingJobs;
+
+    private final int maxConcurrent;
+    private final Executor executor;
+
+    private WorkNode runningJobs = null;
+    private int runningCount = 0;
+
+    WorkQueue() {
+        this(DEFAULT_MAX_CONCURRENT);
+    }
+
+    WorkQueue(int maxConcurrent) {
+        this(maxConcurrent, Settings.getExecutor());
+    }
+
+    WorkQueue(int maxConcurrent, Executor executor) {
+        this.maxConcurrent = maxConcurrent;
+        this.executor = executor;
+    }
+
+    WorkItem addActiveWorkItem(Runnable callback) {
+        return addActiveWorkItem(callback, true);
+    }
+
+    WorkItem addActiveWorkItem(Runnable callback, boolean addToFront) {
+        WorkNode node = new WorkNode(callback);
+        synchronized (workLock) {
+            pendingJobs = node.addToList(pendingJobs, addToFront);
+        }
+
+        startItem();
+        return node;
+    }
+
+    void validate() {
+        synchronized (workLock) {
+            // Verify that all running items know they are running, and counts match
+            int count = 0;
+
+            if (runningJobs != null) {
+                WorkNode walk = runningJobs;
+                do {
+                    walk.verify(true);
+                    count++;
+                    walk = walk.getNext();
+                } while (walk != runningJobs);
+            }
+
+            assert runningCount == count;
+        }
+    }
+
+    private void startItem() {
+        finishItemAndStartNew(null);
+    }
+
+    private void finishItemAndStartNew(WorkNode finished) {
+        WorkNode ready = null;
+
+        synchronized (workLock) {
+            if (finished != null) {
+                runningJobs = finished.removeFromList(runningJobs);
+                runningCount--;
+            }
+
+            if (runningCount < maxConcurrent) {
+                ready = pendingJobs; // Head of the pendingJobs queue
+                if (ready != null) {
+                    // The Queue reassignments are necessary since 'ready' might have been
+                    // added / removed from the front of either queue, which changes its
+                    // respective head.
+                    pendingJobs = ready.removeFromList(pendingJobs);
+                    runningJobs = ready.addToList(runningJobs, false);
+                    runningCount++;
+
+                    ready.setIsRunning(true);
+                }
+            }
+        }
+
+        if (ready != null) {
+            execute(ready);
+        }
+    }
+
+    private void execute(final WorkNode node) {
+        executor.execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    node.getCallback().run();
+                } finally {
+                    finishItemAndStartNew(node);
+                }
+            }
+        });
+    }
+
+    private class WorkNode implements WorkItem {
+        private final Runnable callback;
+        private WorkNode next;
+        private WorkNode prev;
+        private boolean isRunning;
+
+        WorkNode(Runnable callback) {
+            this.callback = callback;
+        }
+
+        @Override
+        public boolean cancel() {
+            synchronized (workLock) {
+                if (!isRunning()) {
+                    pendingJobs = removeFromList(pendingJobs);
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        @Override
+        public void moveToFront() {
+            synchronized (workLock) {
+                if (!isRunning()) {
+                    pendingJobs = removeFromList(pendingJobs);
+                    pendingJobs = addToList(pendingJobs, true);
+                }
+            }
+        }
+
+        @Override
+        public boolean isRunning() {
+            return isRunning;
+        }
+
+        Runnable getCallback() {
+            return callback;
+        }
+
+        WorkNode getNext() {
+            return next;
+        }
+
+        void setIsRunning(boolean isRunning) {
+            this.isRunning = isRunning;
+        }
+
+        WorkNode addToList(WorkNode list, boolean addToFront) {
+            assert next == null;
+            assert prev == null;
+
+            if (list == null) {
+                list = next = prev = this;
+            } else {
+                next = list;
+                prev = list.prev;
+                next.prev = prev.next = this;
+            }
+
+            return addToFront ? this : list;
+        }
+
+        WorkNode removeFromList(WorkNode list) {
+            assert next != null;
+            assert prev != null;
+
+            if (list == this) {
+                if (next == this) {
+                    list = null;
+                } else {
+                    list = next;
+                }
+            }
+
+            next.prev = prev;
+            prev.next = next;
+            next = prev = null;
+
+            return list;
+        }
+
+        void verify(boolean shouldBeRunning) {
+            assert prev.next == this;
+            assert next.prev == this;
+            assert isRunning() == shouldBeRunning;
+        }
+    }
+
+    interface WorkItem {
+        boolean cancel();
+        boolean isRunning();
+        void moveToFront();
+    }
+}
diff --git a/facebook/tests/.classpath b/facebook/tests/.classpath
new file mode 100644
index 000000000..a4763d1ee
--- /dev/null
+++ b/facebook/tests/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/facebook/tests/.project b/facebook/tests/.project
new file mode 100644
index 000000000..82993b5a8
--- /dev/null
+++ b/facebook/tests/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SDKTests</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/facebook/tests/AndroidManifest.xml b/facebook/tests/AndroidManifest.xml
new file mode 100644
index 000000000..1509af65d
--- /dev/null
+++ b/facebook/tests/AndroidManifest.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- package name must be unique so suffix with "tests" so package loader doesn't ignore us -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.facebook.sdk.tests"
+          android:versionCode="1"
+          android:versionName="1.0">
+    <uses-permission android:name="android.permission.INTERNET"></uses-permission>
+    <uses-sdk android:minSdkVersion="7" android:targetSdkVersion="7"/>
+    <!-- We add an application tag here just so that we can indicate that
+         this package needs to link against the android.test library,
+         which is needed when building test cases. -->
+    <application>
+        <uses-library android:name="android.test.runner"/>
+        <activity android:name="com.facebook.FacebookTestCase$FacebookTestActivity"/>
+        <activity android:name="com.facebook.widget.FriendPickerFragmentTests$TestActivity"/>
+        <activity android:name="com.facebook.widget.PlacePickerFragmentTests$TestActivity"/>
+        <activity android:name="com.facebook.widget.GraphObjectPagingLoaderTests$TestActivity"/>
+        <activity android:name="com.facebook.widget.UserSettingsFragmentTests$TestActivity"/>
+        <activity android:name="com.facebook.LoginActivity" />
+        <activity android:name="com.facebook.FacebookActivityTests$FacebookTestActivity" />
+        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
+    </application>
+    <!--
+    This declares that this application uses the instrumentation test runner targeting
+    the package of com.facebook.sdk.  To run the tests use the command:
+    "adb shell am instrument -w com.facebook.sdk.tests/android.test.InstrumentationTestRunner"
+    -->
+    <instrumentation android:name="android.test.InstrumentationTestRunner"
+                     android:targetPackage="com.facebook.sdk.tests"
+                     android:label="Tests for com.facebook.sdk.tests"/>
+</manifest>
diff --git a/facebook/tests/SdkTests.eml b/facebook/tests/SdkTests.eml
new file mode 100644
index 000000000..3bbc2f8d5
--- /dev/null
+++ b/facebook/tests/SdkTests.eml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<component>
+	<exclude-output/>
+	<contentEntry url="file://$MODULE_DIR$"/>
+	<module name="SdkTestApp" scope="PROVIDED"/>
+</component>
diff --git a/facebook/tests/SdkTests.iml b/facebook/tests/SdkTests.iml
new file mode 100644
index 000000000..0db1700c9
--- /dev/null
+++ b/facebook/tests/SdkTests.iml
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="EclipseModuleManager">
+    <conelement value="com.android.ide.eclipse.adt.LIBRARIES" />
+    <src_description expected_position="1">
+      <src_folder value="file://$MODULE_DIR$/src" expected_position="1" />
+      <src_folder value="file://$MODULE_DIR$/gen" expected_position="2" />
+    </src_description>
+  </component>
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="true" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/bin/classes" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/assets" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" exported="" />
+    <orderEntry type="module" module-name="SdkTestApp" scope="PROVIDED" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/facebook/tests/ant.properties b/facebook/tests/ant.properties
new file mode 100644
index 000000000..928de2ff9
--- /dev/null
+++ b/facebook/tests/ant.properties
@@ -0,0 +1,20 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
+# Removed based on advice at code.google.com/p/android/issues/detail?id=21108#c2
+# and the comment that follows.
+# tested.project.dir=../TestApp
diff --git a/facebook/tests/assets/DarkScreen.mov b/facebook/tests/assets/DarkScreen.mov
new file mode 100644
index 000000000..2e86e5c49
Binary files /dev/null and b/facebook/tests/assets/DarkScreen.mov differ
diff --git a/facebook/tests/build.xml b/facebook/tests/build.xml
new file mode 100644
index 000000000..34c89faa8
--- /dev/null
+++ b/facebook/tests/build.xml
@@ -0,0 +1,101 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="FacebookSdkTests" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties" />
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties" />
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties" />
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through an env var"
+            unless="sdk.dir"
+    />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true" />
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml" />
+
+    <!-- SDK Tools r15 workaround -->
+    <property name="tested.manifest.package" value="com.facebook.sdk.tests" />
+
+    <!-- This seems to have no effect.  The value remains android.test.AndroidTestRunner -->
+    <!-- <property name="test.runner" value="android.test.InstrumentationTestRunner" /> -->
+
+    <target name="run-tests">
+      <echo>Running tests...</echo>
+      <exec executable="${adb}" failonerror="true">
+        <arg line="${adb.device.arg}" />
+        <arg value="shell" />
+        <arg value="am" />
+        <arg value="instrument" />
+        <arg value="-w" />
+        <!-- was <arg value="${tested.manifest.package}/${test.runner}" /> -->
+        <arg value="${tested.manifest.package}/android.test.InstrumentationTestRunner" />
+      </exec>
+    </target>
+</project>
diff --git a/facebook/tests/proguard-project.txt b/facebook/tests/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/facebook/tests/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/facebook/tests/project.properties b/facebook/tests/project.properties
new file mode 100644
index 000000000..705d57d8d
--- /dev/null
+++ b/facebook/tests/project.properties
@@ -0,0 +1,16 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+test.runner=android.test.AndroidTestRunner
+android.library.reference.1=../../facebook
diff --git a/facebook/tests/res/layout/friend_picker_test_layout_1.xml b/facebook/tests/res/layout/friend_picker_test_layout_1.xml
new file mode 100644
index 000000000..34c2c9a48
--- /dev/null
+++ b/facebook/tests/res/layout/friend_picker_test_layout_1.xml
@@ -0,0 +1,32 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              xmlns:app="http://schemas.android.com/apk/res-auto"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent">
+
+    <fragment
+            android:id="@+id/friend_picker_fragment"
+            android:name="com.facebook.widget.FriendPickerFragment"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            app:show_pictures="false"
+            app:multi_select="false"
+            app:extra_fields="middle_name,link"
+            />
+</LinearLayout>
diff --git a/facebook/tests/res/layout/place_picker_test_layout_1.xml b/facebook/tests/res/layout/place_picker_test_layout_1.xml
new file mode 100644
index 000000000..9f2789178
--- /dev/null
+++ b/facebook/tests/res/layout/place_picker_test_layout_1.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              xmlns:app="http://schemas.android.com/apk/res-auto"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent">
+
+    <fragment
+            android:id="@+id/place_picker_fragment"
+            android:name="com.facebook.widget.PlacePickerFragment"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            app:show_pictures="false"
+            app:radius_in_meters="75"
+            app:results_limit="5"
+            app:search_text="coffee"
+            app:extra_fields="checkins,general_info"
+            />
+</LinearLayout>
diff --git a/facebook/tests/res/values/strings.xml b/facebook/tests/res/values/strings.xml
new file mode 100644
index 000000000..fa585a791
--- /dev/null
+++ b/facebook/tests/res/values/strings.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<resources>
+    <string name="app_id">1234567890</string>
+</resources>
diff --git a/facebook/tests/src/com/facebook/AccessTokenTests.java b/facebook/tests/src/com/facebook/AccessTokenTests.java
new file mode 100644
index 000000000..957d433c2
--- /dev/null
+++ b/facebook/tests/src/com/facebook/AccessTokenTests.java
@@ -0,0 +1,279 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.internal.Utility;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+
+public final class AccessTokenTests extends AndroidTestCase {
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testEmptyToken() {
+        List<String> permissions = Utility.arrayList();
+        AccessToken token = AccessToken.createEmptyToken(permissions);
+        TestUtils.assertSamePermissions(permissions, token);
+        assertEquals("", token.getToken());
+        assertTrue(token.isInvalid());
+        assertTrue(token.getExpires().before(new Date()));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testEmptyTokenWithPermissions() {
+        List<String> permissions = Utility.arrayList("stream_publish");
+        AccessToken token = AccessToken.createEmptyToken(permissions);
+        TestUtils.assertSamePermissions(permissions, token);
+        assertEquals("", token.getToken());
+        assertTrue(token.isInvalid());
+        assertTrue(token.getExpires().before(new Date()));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testFromDialog() {
+        List<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
+        String token = "AnImaginaryTokenValue";
+
+        Bundle bundle = new Bundle();
+        bundle.putString("access_token", token);
+        bundle.putString("expires_in", "60");
+
+        AccessToken accessToken = AccessToken.createFromWebBundle(permissions, bundle, AccessTokenSource.WEB_VIEW);
+        TestUtils.assertSamePermissions(permissions, accessToken);
+        assertEquals(token, accessToken.getToken());
+        assertEquals(AccessTokenSource.WEB_VIEW, accessToken.getSource());
+        assertTrue(!accessToken.isInvalid());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testFromSSOWithExpiresString() {
+        List<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
+        String token = "AnImaginaryTokenValue";
+
+        Intent intent = new Intent();
+        intent.putExtra("access_token", token);
+        intent.putExtra("expires_in", "60");
+        intent.putExtra("extra_extra", "Something unrelated");
+
+        AccessToken accessToken = AccessToken
+                .createFromWebBundle(permissions, intent.getExtras(), AccessTokenSource.FACEBOOK_APPLICATION_WEB);
+
+        TestUtils.assertSamePermissions(permissions, accessToken);
+        assertEquals(token, accessToken.getToken());
+        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
+        assertTrue(!accessToken.isInvalid());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testFromSSOWithExpiresLong() {
+        List<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
+        String token = "AnImaginaryTokenValue";
+
+        Intent intent = new Intent();
+        intent.putExtra("access_token", token);
+        intent.putExtra("expires_in", 60L);
+        intent.putExtra("extra_extra", "Something unrelated");
+
+        AccessToken accessToken = AccessToken
+                .createFromWebBundle(permissions, intent.getExtras(), AccessTokenSource.FACEBOOK_APPLICATION_WEB);
+        TestUtils.assertSamePermissions(permissions, accessToken);
+        assertEquals(token, accessToken.getToken());
+        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
+        assertTrue(!accessToken.isInvalid());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testFromNativeLogin() {
+        ArrayList<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
+        String token = "AnImaginaryTokenValue";
+
+        long nowSeconds = new Date().getTime() / 1000;
+        Intent intent = new Intent();
+        intent.putExtra(NativeProtocol.EXTRA_ACCESS_TOKEN, token);
+        intent.putExtra(NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, nowSeconds + 60L);
+        intent.putExtra(NativeProtocol.EXTRA_PERMISSIONS, permissions);
+
+        AccessToken accessToken = AccessToken.createFromNativeLogin(
+                intent.getExtras(), AccessTokenSource.FACEBOOK_APPLICATION_NATIVE);
+        TestUtils.assertSamePermissions(permissions, accessToken);
+        assertEquals(token, accessToken.getToken());
+        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_NATIVE, accessToken.getSource());
+        assertTrue(!accessToken.isInvalid());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCacheRoundtrip() {
+        ArrayList<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
+        String token = "AnImaginaryTokenValue";
+        Date later = TestUtils.nowPlusSeconds(60);
+        Date earlier = TestUtils.nowPlusSeconds(-60);
+
+        Bundle bundle = new Bundle();
+        TokenCachingStrategy.putToken(bundle, token);
+        TokenCachingStrategy.putExpirationDate(bundle, later);
+        TokenCachingStrategy.putSource(bundle, AccessTokenSource.FACEBOOK_APPLICATION_WEB);
+        TokenCachingStrategy.putLastRefreshDate(bundle, earlier);
+        TokenCachingStrategy.putPermissions(bundle, permissions);
+
+        AccessToken accessToken = AccessToken.createFromCache(bundle);
+        TestUtils.assertSamePermissions(permissions, accessToken);
+        assertEquals(token, accessToken.getToken());
+        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
+        assertTrue(!accessToken.isInvalid());
+
+        Bundle cache = accessToken.toCacheBundle();
+        TestUtils.assertEqualContents(bundle, cache);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCachePutGet() {
+        Bundle bundle = new Bundle();
+
+        for (String token : new String[] { "", "A completely random token value" }) {
+            TokenCachingStrategy.putToken(bundle, token);
+            assertEquals(token, TokenCachingStrategy.getToken(bundle));
+        }
+
+        for (Date date : new Date[] { new Date(42), new Date() }) {
+            TokenCachingStrategy.putExpirationDate(bundle, date);
+            assertEquals(date, TokenCachingStrategy.getExpirationDate(bundle));
+
+            TokenCachingStrategy.putLastRefreshDate(bundle, date);
+            assertEquals(date, TokenCachingStrategy.getLastRefreshDate(bundle));
+        }
+
+        for (long milliseconds : new long[] { 0, -1, System.currentTimeMillis() }) {
+            TokenCachingStrategy.putExpirationMilliseconds(bundle, milliseconds);
+            assertEquals(milliseconds, TokenCachingStrategy.getExpirationMilliseconds(bundle));
+
+            TokenCachingStrategy.putLastRefreshMilliseconds(bundle, milliseconds);
+            assertEquals(milliseconds, TokenCachingStrategy.getLastRefreshMilliseconds(bundle));
+        }
+
+        for (AccessTokenSource source : AccessTokenSource.values()) {
+            TokenCachingStrategy.putSource(bundle, source);
+            assertEquals(source, TokenCachingStrategy.getSource(bundle));
+        }
+
+        List<String> normalList = Arrays.asList("", "Another completely random token value");
+        List<String> emptyList = Arrays.asList();
+        ArrayList<String> normalArrayList = new ArrayList<String>(normalList);
+        ArrayList<String> emptyArrayList = new ArrayList<String>();
+        @SuppressWarnings("unchecked")
+        List<List<String>> permissionLists = Arrays
+                .asList(normalList, emptyList, normalArrayList, emptyArrayList);
+        for (List<String> list : permissionLists) {
+            TokenCachingStrategy.putPermissions(bundle, list);
+            TestUtils.assertSamePermissions(list, TokenCachingStrategy.getPermissions(bundle));
+        }
+        normalArrayList.add(null);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testBasicSerialization() throws IOException {
+        AccessToken accessToken = AccessToken.createFromString("a token",
+                Arrays.asList("permission_1", "permission_2"), AccessTokenSource.WEB_VIEW);
+        AccessToken res = TestUtils.serializeAndUnserialize(accessToken);
+        
+        // if one field got serialized most likely all other non transient fields
+        // got serialized correctly.
+        assertEquals(accessToken.getPermissions(), res.getPermissions());
+        assertEquals(accessToken.getToken(), res.getToken());
+        assertEquals(accessToken.getSource(), res.getSource());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testPermissionsAreImmutable() {
+        List<String> permissions = Arrays.asList("go to Jail", "do not pass Go");
+        AccessToken accessToken = new AccessToken("some token", new Date(), permissions,
+                AccessTokenSource.FACEBOOK_APPLICATION_WEB, new Date());
+
+        permissions = accessToken.getPermissions();
+
+        try {
+            permissions.add("can't touch this");
+            fail();
+        } catch (UnsupportedOperationException ex) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreateFromExistingTokenDefaults() {
+        final String token = "A token of my esteem";
+
+        AccessToken accessToken = AccessToken.createFromExistingAccessToken(token, null, null, null, null);
+
+        assertEquals(token, accessToken.getToken());
+        assertEquals(new Date(Long.MAX_VALUE), accessToken.getExpires());
+        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
+        assertEquals(0, accessToken.getPermissions().size());
+        // Allow slight variation for test execution time
+        long delta = accessToken.getLastRefresh().getTime() - new Date().getTime();
+        assertTrue(delta < 1000);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreateFromExistingToken() {
+        final String token = "A token of my esteem";
+        final List<String> permissions = Arrays.asList("walk", "chew gum");
+        final Date expires = new Date(2025, 5, 3);
+        final Date lastRefresh = new Date(2023, 8, 15);
+        final AccessTokenSource source = AccessTokenSource.WEB_VIEW;
+
+        AccessToken accessToken = AccessToken
+                .createFromExistingAccessToken(token, expires, lastRefresh, source, permissions);
+
+        assertEquals(token, accessToken.getToken());
+        assertEquals(expires, accessToken.getExpires());
+        assertEquals(lastRefresh, accessToken.getLastRefresh());
+        assertEquals(source, accessToken.getSource());
+        assertEquals(permissions, accessToken.getPermissions());
+    }
+}
diff --git a/facebook/tests/src/com/facebook/AsyncRequestTests.java b/facebook/tests/src/com/facebook/AsyncRequestTests.java
new file mode 100644
index 000000000..b662f54da
--- /dev/null
+++ b/facebook/tests/src/com/facebook/AsyncRequestTests.java
@@ -0,0 +1,312 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.graphics.Bitmap;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphPlace;
+import com.facebook.model.GraphUser;
+
+import java.net.HttpURLConnection;
+import java.util.Arrays;
+import java.util.List;
+
+public class AsyncRequestTests extends FacebookTestCase {
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanLaunchAsyncRequestFromUiThread() {
+        Request request = Request.newPostRequest(null, "me/feeds", null, null);
+        try {
+            TestRequestAsyncTask task = createAsyncTaskOnUiThread(request);
+            assertNotNull(task);
+        } catch (Throwable throwable) {
+            assertNull(throwable);
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testExecuteWithNullRequestsThrows() throws Exception {
+        try {
+            TestRequestAsyncTask task = new TestRequestAsyncTask((Request[]) null);
+
+            task.executeOnBlockerThread();
+
+            waitAndAssertSuccessOrRethrow(1);
+
+            fail("expected NullPointerException");
+        } catch (NullPointerException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testExecuteBatchWithZeroRequestsThrows() throws Exception {
+        try {
+            TestRequestAsyncTask task = new TestRequestAsyncTask(new Request[] {});
+
+            task.executeOnBlockerThread();
+
+            waitAndAssertSuccessOrRethrow(1);
+
+            fail("expected IllegalArgumentException");
+        } catch (IllegalArgumentException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testExecuteBatchWithNullRequestThrows() throws Exception {
+        try {
+            TestRequestAsyncTask task = new TestRequestAsyncTask(new Request[] { null });
+
+            task.executeOnBlockerThread();
+
+            waitAndAssertSuccessOrRethrow(1);
+
+            fail("expected NullPointerException");
+        } catch (NullPointerException exception) {
+        }
+
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecuteSingleGet() {
+        Request request = new Request(null, "TourEiffel", null, null, new ExpectSuccessCallback() {
+            @Override
+            protected void performAsserts(Response response) {
+                assertNotNull(response);
+                GraphPlace graphPlace = response.getGraphObjectAs(GraphPlace.class);
+                assertEquals("Paris", graphPlace.getLocation().getCity());
+            }
+        });
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(request);
+
+        task.executeOnBlockerThread();
+
+        // Wait on 2 signals: request and task will both signal.
+        waitAndAssertSuccess(2);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecuteSingleGetUsingHttpURLConnection() {
+        Request request = new Request(null, "TourEiffel", null, null, new ExpectSuccessCallback() {
+            @Override
+            protected void performAsserts(Response response) {
+                assertNotNull(response);
+                GraphPlace graphPlace = response.getGraphObjectAs(GraphPlace.class);
+                assertEquals("Paris", graphPlace.getLocation().getCity());
+            }
+        });
+        HttpURLConnection connection = Request.toHttpConnection(request);
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(connection, Arrays.asList(new Request[] { request }));
+
+        task.executeOnBlockerThread();
+
+        // Wait on 2 signals: request and task will both signal.
+        waitAndAssertSuccess(2);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecuteSingleGetFailureCase() {
+        Request request = new Request(null, "-1", null, null, new ExpectFailureCallback());
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(request);
+
+        task.executeOnBlockerThread();
+
+        // Wait on 2 signals: request and task will both signal.
+        waitAndAssertSuccess(2);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testBatchWithoutAppIDIsError() throws Throwable {
+        Request request1 = new Request(null, "TourEiffel", null, null, new ExpectFailureCallback());
+        Request request2 = new Request(null, "SpaceNeedle", null, null, new ExpectFailureCallback());
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(request1, request2);
+
+        task.executeOnBlockerThread();
+
+        // Wait on 3 signals: request1, request2, and task will all signal.
+        waitAndAssertSuccessOrRethrow(3);
+    }
+
+    @LargeTest
+    public void testMixedSuccessAndFailure() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        final int NUM_REQUESTS = 8;
+        Request[] requests = new Request[NUM_REQUESTS];
+        for (int i = 0; i < NUM_REQUESTS; ++i) {
+            boolean shouldSucceed = (i % 2) == 1;
+            if (shouldSucceed) {
+                requests[i] = new Request(session, "me", null, null, new ExpectSuccessCallback());
+            } else {
+                requests[i] = new Request(session, "-1", null, null, new ExpectFailureCallback());
+            }
+        }
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(requests);
+
+        task.executeOnBlockerThread();
+
+        // Note: plus 1, because the overall async task signals as well.
+        waitAndAssertSuccess(NUM_REQUESTS + 1);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testStaticExecuteMeAsync() {
+        final TestSession session = openTestSessionWithSharedUser();
+
+        class MeCallback extends ExpectSuccessCallback implements Request.GraphUserCallback {
+            @Override
+            public void onCompleted(GraphUser me, Response response) {
+                assertNotNull(me);
+                assertEquals(session.getTestUserId(), me.getId());
+                RequestTests.validateMeResponse(session, response);
+                onCompleted(response);
+            }
+        }
+
+        runOnBlockerThread(new Runnable() {
+            @Override
+            public void run() {
+                Request.executeMeRequestAsync(session, new MeCallback());
+            }
+        }, false);
+        waitAndAssertSuccess(1);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testStaticExecuteMyFriendsAsync() {
+        final TestSession session = openTestSessionWithSharedUser();
+
+        class FriendsCallback extends ExpectSuccessCallback implements Request.GraphUserListCallback {
+            @Override
+            public void onCompleted(List<GraphUser> friends, Response response) {
+                assertNotNull(friends);
+                RequestTests.validateMyFriendsResponse(session, response);
+                onCompleted(response);
+            }
+        }
+
+        runOnBlockerThread(new Runnable() {
+            @Override
+            public void run() {
+                Request.executeMyFriendsRequestAsync(session, new FriendsCallback());
+            }
+        }, false);
+        waitAndAssertSuccess(1);
+    }
+
+    @LargeTest
+    public void testBatchUploadPhoto() {
+        TestSession session = openTestSessionWithSharedUserAndPermissions(null, "user_photos");
+
+        final int image1Size = 120;
+        final int image2Size = 150;
+
+        Bitmap bitmap1 = createTestBitmap(image1Size);
+        Bitmap bitmap2 = createTestBitmap(image2Size);
+
+        Request uploadRequest1 = Request.newUploadPhotoRequest(session, bitmap1, null);
+        uploadRequest1.setBatchEntryName("uploadRequest1");
+        Request uploadRequest2 = Request.newUploadPhotoRequest(session, bitmap2, null);
+        uploadRequest2.setBatchEntryName("uploadRequest2");
+        Request getRequest1 = new Request(session, "{result=uploadRequest1:$.id}", null, null,
+                new ExpectSuccessCallback() {
+                    @Override
+                    protected void performAsserts(Response response) {
+                        assertNotNull(response);
+                        GraphObject retrievedPhoto = response.getGraphObject();
+                        assertNotNull(retrievedPhoto);
+                        assertEquals(image1Size, retrievedPhoto.getProperty("width"));
+                    }
+                });
+        Request getRequest2 = new Request(session, "{result=uploadRequest2:$.id}", null, null,
+                new ExpectSuccessCallback() {
+                    @Override
+                    protected void performAsserts(Response response) {
+                        assertNotNull(response);
+                        GraphObject retrievedPhoto = response.getGraphObject();
+                        assertNotNull(retrievedPhoto);
+                        assertEquals(image2Size, retrievedPhoto.getProperty("width"));
+                    }
+                });
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(uploadRequest1, uploadRequest2, getRequest1, getRequest2);
+        task.executeOnBlockerThread();
+
+        // Wait on 3 signals: getRequest1, getRequest2, and task will all signal.
+        waitAndAssertSuccess(3);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testShortTimeoutCausesFailure() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request request = new Request(session, "me/likes", null, null, new ExpectFailureCallback());
+
+        RequestBatch requestBatch = new RequestBatch(request);
+
+        // 1 millisecond timeout should be too short for response from server.
+        requestBatch.setTimeout(1);
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(requestBatch);
+        task.executeOnBlockerThread();
+
+        // Note: plus 1, because the overall async task signals as well.
+        waitAndAssertSuccess(2);
+    }
+
+    @LargeTest
+    public void testLongTimeoutAllowsSuccess() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request request = new Request(session, "me", null, null, new ExpectSuccessCallback());
+
+        RequestBatch requestBatch = new RequestBatch(request);
+
+        // 10 second timeout should be long enough for successful response from server.
+        requestBatch.setTimeout(10000);
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(requestBatch);
+        task.executeOnBlockerThread();
+
+        // Note: plus 1, because the overall async task signals as well.
+        waitAndAssertSuccess(2);
+    }
+}
diff --git a/facebook/tests/src/com/facebook/AuthorizationClientTests.java b/facebook/tests/src/com/facebook/AuthorizationClientTests.java
new file mode 100644
index 000000000..22695f73a
--- /dev/null
+++ b/facebook/tests/src/com/facebook/AuthorizationClientTests.java
@@ -0,0 +1,684 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.model.GraphMultiResult;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphObjectList;
+import com.facebook.model.GraphUser;
+
+import java.io.*;
+import java.util.*;
+
+public class AuthorizationClientTests extends FacebookTestCase {
+    private static final String ACCESS_TOKEN = "An access token";
+    private static final long EXPIRES_IN_DELTA = 3600 * 24 * 60;
+    private static final ArrayList<String> PERMISSIONS = new ArrayList<String>(
+            Arrays.asList("go outside", "come back in"));
+    private static final String ERROR_MESSAGE = "This is bad!";
+
+    class MockAuthorizationClient extends AuthorizationClient {
+        Result result;
+        boolean triedNextHandler = false;
+
+        MockAuthorizationClient() {
+            setContext(getActivity());
+        }
+
+        AuthorizationClient.AuthorizationRequest getRequest() {
+            return pendingRequest;
+        }
+
+        void setRequest(AuthorizationClient.AuthorizationRequest request) {
+            pendingRequest = request;
+        }
+
+        @Override
+        void complete(Result result) {
+            this.result = result;
+        }
+
+        @Override
+        void tryNextHandler() {
+            triedNextHandler = true;
+        }
+    }
+
+    // WebViewAuthHandler tests
+
+    AuthorizationClient.AuthorizationRequest createRequest() {
+        Session.AuthorizationRequest request = new Session.AuthorizationRequest(getActivity());
+        request.setPermissions(PERMISSIONS);
+        return request.getAuthorizationClientRequest();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testWebViewHandlesSuccess() {
+        Bundle bundle = new Bundle();
+        bundle.putString("access_token", ACCESS_TOKEN);
+        bundle.putString("expires_in", String.format("%d", EXPIRES_IN_DELTA));
+        bundle.putString("code", "Something else");
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.WebViewAuthHandler handler = client.new WebViewAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onWebDialogComplete(request, bundle, null);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
+
+        AccessToken token = client.result.token;
+        assertNotNull(token);
+        assertEquals(ACCESS_TOKEN, token.getToken());
+        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
+        assertEquals(PERMISSIONS, token.getPermissions());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testWebViewHandlesCancel() {
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.WebViewAuthHandler handler = client.new WebViewAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onWebDialogComplete(request, null, new FacebookOperationCanceledException());
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.CANCEL, client.result.code);
+        assertNull(client.result.token);
+        assertNotNull(client.result.errorMessage);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testWebViewHandlesError() {
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.WebViewAuthHandler handler = client.new WebViewAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onWebDialogComplete(request, null, new FacebookException(ERROR_MESSAGE));
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.ERROR, client.result.code);
+        assertNull(client.result.token);
+        assertNotNull(client.result.errorMessage);
+        assertEquals(client.result.errorMessage, ERROR_MESSAGE);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testWebViewChecksInternetPermission() {
+        MockAuthorizationClient client = new MockAuthorizationClient() {
+            @Override
+            int checkPermission(String permission) {
+                return PackageManager.PERMISSION_DENIED;
+            }
+        };
+        AuthorizationClient.WebViewAuthHandler handler = client.new WebViewAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onWebDialogComplete(request, null, new FacebookException(ERROR_MESSAGE));
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.ERROR, client.result.code);
+        assertNull(client.result.token);
+        assertNotNull(client.result.errorMessage);
+    }
+
+    // GetTokenAuthHandler tests
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testGetTokenHandlesSuccessWithAllPermissions() {
+        Bundle bundle = new Bundle();
+        bundle.putStringArrayList(NativeProtocol.EXTRA_PERMISSIONS, PERMISSIONS);
+        bundle.putLong(NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, new Date().getTime() / 1000 + EXPIRES_IN_DELTA);
+        bundle.putString(NativeProtocol.EXTRA_ACCESS_TOKEN, ACCESS_TOKEN);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.GetTokenAuthHandler handler = client.new GetTokenAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.getTokenCompleted(request, bundle);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
+
+        AccessToken token = client.result.token;
+        assertNotNull(token);
+        assertEquals(ACCESS_TOKEN, token.getToken());
+        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
+        assertEquals(PERMISSIONS, token.getPermissions());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testGetTokenHandlesSuccessWithSomePermissions() {
+        Bundle bundle = new Bundle();
+        bundle.putStringArrayList(NativeProtocol.EXTRA_PERMISSIONS, new ArrayList<String>(Arrays.asList("go outside")));
+        bundle.putLong(NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, new Date().getTime() / 1000 + EXPIRES_IN_DELTA);
+        bundle.putString(NativeProtocol.EXTRA_ACCESS_TOKEN, ACCESS_TOKEN);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.GetTokenAuthHandler handler = client.new GetTokenAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        assertEquals(PERMISSIONS.size(), request.getPermissions().size());
+
+        client.setRequest(request);
+        handler.getTokenCompleted(request, bundle);
+
+        assertNull(client.result);
+        assertTrue(client.triedNextHandler);
+
+        assertEquals(1, request.getPermissions().size());
+        assertTrue(request.getPermissions().contains("come back in"));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testGetTokenHandlesNoResult() {
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.GetTokenAuthHandler handler = client.new GetTokenAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        assertEquals(PERMISSIONS.size(), request.getPermissions().size());
+
+        client.setRequest(request);
+        handler.getTokenCompleted(request, null);
+
+        assertNull(client.result);
+        assertTrue(client.triedNextHandler);
+
+        assertEquals(PERMISSIONS.size(), request.getPermissions().size());
+    }
+
+    // KatanaLoginDialogAuthHandler tests
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testLoginDialogHandlesSuccess() {
+        Bundle bundle = new Bundle();
+        bundle.putStringArrayList(NativeProtocol.EXTRA_PERMISSIONS, PERMISSIONS);
+        bundle.putLong(NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, new Date().getTime() / 1000 + EXPIRES_IN_DELTA);
+        bundle.putString(NativeProtocol.EXTRA_ACCESS_TOKEN, ACCESS_TOKEN);
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.KatanaLoginDialogAuthHandler handler = client.new KatanaLoginDialogAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onActivityResult(0, Activity.RESULT_OK, intent);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
+
+        AccessToken token = client.result.token;
+        assertNotNull(token);
+        assertEquals(ACCESS_TOKEN, token.getToken());
+        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
+        assertEquals(PERMISSIONS, token.getPermissions());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testLoginDialogHandlesCancel() {
+        Bundle bundle = new Bundle();
+        bundle.putString(NativeProtocol.STATUS_ERROR_DESCRIPTION, ERROR_MESSAGE);
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.KatanaLoginDialogAuthHandler handler = client.new KatanaLoginDialogAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onActivityResult(0, Activity.RESULT_CANCELED, intent);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.CANCEL, client.result.code);
+
+        AccessToken token = client.result.token;
+        assertNull(token);
+        assertNotNull(client.result.errorMessage);
+        assertEquals(ERROR_MESSAGE, client.result.errorMessage);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testLoginDialogHandlesError() {
+        Bundle bundle = new Bundle();
+        bundle.putString(NativeProtocol.STATUS_ERROR_TYPE, ERROR_MESSAGE);
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.KatanaLoginDialogAuthHandler handler = client.new KatanaLoginDialogAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onActivityResult(0, Activity.RESULT_OK, intent);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.ERROR, client.result.code);
+
+        AccessToken token = client.result.token;
+        assertNull(token);
+        assertNotNull(client.result.errorMessage);
+        assertEquals(ERROR_MESSAGE, client.result.errorMessage);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testLoginDialogHandlesDisabled() {
+        Bundle bundle = new Bundle();
+        bundle.putInt(NativeProtocol.EXTRA_PROTOCOL_VERSION, NativeProtocol.PROTOCOL_VERSION_20121101);
+        bundle.putString(NativeProtocol.STATUS_ERROR_TYPE, NativeProtocol.ERROR_SERVICE_DISABLED);
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.KatanaLoginDialogAuthHandler handler = client.new KatanaLoginDialogAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onActivityResult(0, Activity.RESULT_OK, intent);
+
+        assertNull(client.result);
+        assertTrue(client.triedNextHandler);
+    }
+
+    // KatanaProxyAuthHandler tests
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testProxyAuthHandlesSuccess() {
+        Bundle bundle = new Bundle();
+        bundle.putLong(AccessToken.EXPIRES_IN_KEY, EXPIRES_IN_DELTA);
+        bundle.putString(AccessToken.ACCESS_TOKEN_KEY, ACCESS_TOKEN);
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.KatanaProxyAuthHandler handler = client.new KatanaProxyAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onActivityResult(0, Activity.RESULT_OK, intent);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
+
+        AccessToken token = client.result.token;
+        assertNotNull(token);
+        assertEquals(ACCESS_TOKEN, token.getToken());
+        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
+        assertEquals(PERMISSIONS, token.getPermissions());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testProxyAuthHandlesCancel() {
+        Bundle bundle = new Bundle();
+        bundle.putString("error", ERROR_MESSAGE);
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.KatanaProxyAuthHandler handler = client.new KatanaProxyAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onActivityResult(0, Activity.RESULT_CANCELED, intent);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.CANCEL, client.result.code);
+
+        assertNull(client.result.token);
+        assertNotNull(client.result.errorMessage);
+        assertTrue(client.result.errorMessage.contains(ERROR_MESSAGE));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testProxyAuthHandlesCancelErrorMessage() {
+        Bundle bundle = new Bundle();
+        bundle.putString("error", "access_denied");
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.KatanaProxyAuthHandler handler = client.new KatanaProxyAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onActivityResult(0, Activity.RESULT_CANCELED, intent);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.CANCEL, client.result.code);
+
+        assertNull(client.result.token);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testProxyAuthHandlesDisabled() {
+        Bundle bundle = new Bundle();
+        bundle.putString("error", "service_disabled");
+
+        Intent intent = new Intent();
+        intent.putExtras(bundle);
+
+        MockAuthorizationClient client = new MockAuthorizationClient();
+        AuthorizationClient.KatanaProxyAuthHandler handler = client.new KatanaProxyAuthHandler();
+
+        AuthorizationClient.AuthorizationRequest request = createRequest();
+        client.setRequest(request);
+        handler.onActivityResult(0, Activity.RESULT_OK, intent);
+
+        assertNull(client.result);
+        assertTrue(client.triedNextHandler);
+    }
+
+    // Reauthorization validation tests
+
+    class MockValidatingAuthorizationClient extends MockAuthorizationClient {
+        private final HashMap<String, String> mapAccessTokenToFbid = new HashMap<String, String>();
+        private List<String> permissionsToReport = Arrays.asList();
+        private TestBlocker blocker;
+
+        public MockValidatingAuthorizationClient(TestBlocker blocker) {
+            this.blocker = blocker;
+        }
+
+        public void addAccessTokenToFbidMapping(String accessToken, String fbid) {
+            mapAccessTokenToFbid.put(accessToken, fbid);
+        }
+
+        public void addAccessTokenToFbidMapping(AccessToken accessToken, String fbid) {
+            mapAccessTokenToFbid.put(accessToken.getToken(), fbid);
+        }
+
+        public void setPermissionsToReport(List<String> permissionsToReport) {
+            this.permissionsToReport = permissionsToReport;
+        }
+
+        @Override
+        void complete(Result result) {
+            super.complete(result);
+            blocker.signal();
+        }
+
+        @Override
+        Request createGetProfileIdRequest(final String accessToken) {
+            return new MockRequest() {
+                @Override
+                public Response createResponse() {
+                    String fbid = mapAccessTokenToFbid.get(accessToken);
+                    GraphUser user = GraphObject.Factory.create(GraphUser.class);
+                    user.setId(fbid);
+                    return new Response(this, null, user, false);
+                }
+            };
+        }
+
+        @Override
+        Request createGetPermissionsRequest(String accessToken) {
+            final List<String> permissions = permissionsToReport;
+            return new MockRequest() {
+                @Override
+                public Response createResponse() {
+                    GraphObject permissionsObject = GraphObject.Factory.create();
+                    if (permissions != null) {
+                        for (String permission : permissions) {
+                            permissionsObject.setProperty(permission, 1);
+                        }
+                    }
+                    GraphObjectList<GraphObject> data = GraphObject.Factory.createList(GraphObject.class);
+                    data.add(permissionsObject);
+
+                    GraphMultiResult result = GraphObject.Factory.create(GraphMultiResult.class);
+                    result.setProperty("data", data);
+
+                    return new Response(this, null, result, false);
+                }
+            };
+        }
+
+        @Override
+        RequestBatch createReauthValidationBatch(final Result pendingResult) {
+            RequestBatch batch = super.createReauthValidationBatch(pendingResult);
+
+            batch.setCallbackHandler(blocker.getHandler());
+            // Turn it into a MockRequestBatch.
+            return new MockRequestBatch(batch);
+        }
+    }
+
+    static final String USER_1_FBID = "user1";
+    static final String USER_1_ACCESS_TOKEN = "An access token for user 1";
+    static final String USER_2_FBID = "user2";
+    static final String USER_2_ACCESS_TOKEN = "An access token for user 2";
+
+    AuthorizationClient.AuthorizationRequest createNewPermissionRequest(String accessToken) {
+        Session.NewPermissionsRequest request = new Session.NewPermissionsRequest(getActivity(), PERMISSIONS);
+        request.setValidateSameFbidAsToken(accessToken);
+        return request.getAuthorizationClientRequest();
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testReauthorizationWithSameFbidSucceeds() throws Exception {
+        TestBlocker blocker = getTestBlocker();
+
+        MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient(blocker);
+        client.addAccessTokenToFbidMapping(USER_1_ACCESS_TOKEN, USER_1_FBID);
+        client.addAccessTokenToFbidMapping(USER_2_ACCESS_TOKEN, USER_2_FBID);
+        client.setPermissionsToReport(PERMISSIONS);
+
+        AuthorizationClient.AuthorizationRequest request = createNewPermissionRequest(USER_1_ACCESS_TOKEN);
+        client.setRequest(request);
+
+        AccessToken token = AccessToken.createFromExistingAccessToken(USER_1_ACCESS_TOKEN, null, null, null, PERMISSIONS);
+        AuthorizationClient.Result result = AuthorizationClient.Result.createTokenResult(token);
+
+        client.completeAndValidate(result);
+
+        blocker.waitForSignals(1);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
+
+        AccessToken resultToken = client.result.token;
+        assertNotNull(resultToken);
+        assertEquals(USER_1_ACCESS_TOKEN, resultToken.getToken());
+        assertEquals(PERMISSIONS, resultToken.getPermissions());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testReauthorizationWithFewerPermissionsSucceeds() throws Exception {
+        TestBlocker blocker = getTestBlocker();
+
+        MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient(blocker);
+        client.addAccessTokenToFbidMapping(USER_1_ACCESS_TOKEN, USER_1_FBID);
+        client.addAccessTokenToFbidMapping(USER_2_ACCESS_TOKEN, USER_2_FBID);
+        client.setPermissionsToReport(Arrays.asList("go outside"));
+
+        AuthorizationClient.AuthorizationRequest request = createNewPermissionRequest(USER_1_ACCESS_TOKEN);
+        client.setRequest(request);
+
+        AccessToken token = AccessToken.createFromExistingAccessToken(USER_1_ACCESS_TOKEN, null, null, null, PERMISSIONS);
+        AuthorizationClient.Result result = AuthorizationClient.Result.createTokenResult(token);
+
+        client.completeAndValidate(result);
+
+        blocker.waitForSignals(1);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
+
+        AccessToken resultToken = client.result.token;
+        assertNotNull(resultToken);
+        assertEquals(USER_1_ACCESS_TOKEN, resultToken.getToken());
+        assertEquals(Arrays.asList("go outside"), resultToken.getPermissions());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testReauthorizationWithDifferentFbidsFails() throws Exception {
+        TestBlocker blocker = getTestBlocker();
+
+        MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient(blocker);
+        client.addAccessTokenToFbidMapping(USER_1_ACCESS_TOKEN, USER_1_FBID);
+        client.addAccessTokenToFbidMapping(USER_2_ACCESS_TOKEN, USER_2_FBID);
+        client.setPermissionsToReport(PERMISSIONS);
+
+        AuthorizationClient.AuthorizationRequest request = createNewPermissionRequest(USER_1_ACCESS_TOKEN);
+        client.setRequest(request);
+
+        AccessToken token = AccessToken.createFromExistingAccessToken(USER_2_ACCESS_TOKEN, null, null, null, PERMISSIONS);
+        AuthorizationClient.Result result = AuthorizationClient.Result.createTokenResult(token);
+
+        client.completeAndValidate(result);
+
+        blocker.waitForSignals(1);
+
+        assertNotNull(client.result);
+        assertEquals(AuthorizationClient.Result.Code.ERROR, client.result.code);
+
+        assertNull(client.result.token);
+        assertNotNull(client.result.errorMessage);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testLegacyReauthDoesntValidate() throws Exception {
+        TestBlocker blocker = getTestBlocker();
+
+        MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient(blocker);
+        AuthorizationClient.AuthorizationRequest request = createNewPermissionRequest(USER_1_ACCESS_TOKEN);
+        request.setIsLegacy(true);
+        client.setRequest(request);
+
+        AccessToken token = AccessToken.createFromExistingAccessToken(USER_2_ACCESS_TOKEN, null, null, null, PERMISSIONS);
+        AuthorizationClient.Result result = AuthorizationClient.Result.createTokenResult(token);
+
+        client.completeAndValidate(result);
+
+        AccessToken resultToken = client.result.token;
+        assertNotNull(resultToken);
+        assertEquals(USER_2_ACCESS_TOKEN, resultToken.getToken());
+        assertEquals(PERMISSIONS, resultToken.getPermissions());
+    }
+
+    // Serialization tests
+
+    static class DoNothingAuthorizationClient extends AuthorizationClient {
+        // Don't actually do anything.
+        @Override
+        boolean tryCurrentHandler() {
+            return true;
+        }
+    }
+
+    public void testSerialization() throws IOException, ClassNotFoundException {
+        AuthorizationClient client = new DoNothingAuthorizationClient();
+
+        // Call this to set up some state.
+        client.setContext(getActivity());
+        client.setOnCompletedListener(new AuthorizationClient.OnCompletedListener() {
+            @Override
+            public void onCompleted(AuthorizationClient.Result result) {
+            }
+        });
+        client.setBackgroundProcessingListener(new AuthorizationClient.BackgroundProcessingListener() {
+            @Override
+            public void onBackgroundProcessingStarted() {
+            }
+
+            @Override
+            public void onBackgroundProcessingStopped() {
+            }
+        });
+        client.authorize(createRequest());
+
+        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+        ObjectOutputStream outputStream = new ObjectOutputStream(byteArrayOutputStream);
+        outputStream.writeObject(client);
+        outputStream.close();
+
+        byte [] byteArray = byteArrayOutputStream.toByteArray();
+
+        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArray);
+        ObjectInputStream inputStream = new ObjectInputStream(byteArrayInputStream);
+
+        Object obj = inputStream.readObject();
+        assertNotNull(obj);
+        assertTrue(obj instanceof AuthorizationClient);
+
+        AuthorizationClient resultClient = (AuthorizationClient)obj;
+        assertNull(resultClient.startActivityDelegate);
+        assertNull(resultClient.onCompletedListener);
+        assertNull(resultClient.backgroundProcessingListener);
+        assertNull(resultClient.context);
+        assertNotNull(resultClient.currentHandler);
+        assertTrue(resultClient.currentHandler instanceof AuthorizationClient.GetTokenAuthHandler);
+        assertNotNull(resultClient.handlersToTry);
+        assertTrue(resultClient.handlersToTry.size() > 0);
+        assertNotNull(resultClient.pendingRequest);
+        assertEquals(PERMISSIONS, resultClient.pendingRequest.getPermissions());
+    }
+}
diff --git a/facebook/tests/src/com/facebook/BatchRequestTests.java b/facebook/tests/src/com/facebook/BatchRequestTests.java
new file mode 100644
index 000000000..e94c450ac
--- /dev/null
+++ b/facebook/tests/src/com/facebook/BatchRequestTests.java
@@ -0,0 +1,537 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.graphics.Bitmap;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphPlace;
+import com.facebook.model.GraphUser;
+import com.facebook.internal.CacheableRequestBatch;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class BatchRequestTests extends FacebookTestCase {
+    protected void setUp() throws Exception {
+        super.setUp();
+
+        // Tests that need this set should explicitly set it.
+        Request.setDefaultBatchApplicationId(null);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreateEmptyRequestBatch() {
+        CacheableRequestBatch batch = new CacheableRequestBatch();
+
+        Request meRequest = Request.newMeRequest(null, null);
+        assertEquals(0, batch.size());
+        batch.add(meRequest);
+        assertEquals(1, batch.size());
+        assertEquals(meRequest, batch.get(0));
+
+        String key = "The Key";
+        assertNull(batch.getCacheKeyOverride());
+        batch.setCacheKeyOverride(key);
+        assertEquals(key, batch.getCacheKeyOverride());
+
+        assertTrue(!batch.getForceRoundTrip());
+        batch.setForceRoundTrip(true);
+        assertTrue(batch.getForceRoundTrip());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreateNonemptyRequestBatch() {
+        Request meRequest = Request.newMeRequest(null, null);
+
+        RequestBatch batch = new RequestBatch(new Request[] { meRequest, meRequest });
+        assertEquals(2, batch.size());
+        assertEquals(meRequest, batch.get(0));
+        assertEquals(meRequest, batch.get(1));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testBatchWithoutAppIDIsError() {
+        Request request1 = new Request(null, "TourEiffel", null, null, new ExpectFailureCallback());
+        Request request2 = new Request(null, "SpaceNeedle", null, null, new ExpectFailureCallback());
+        Request.executeBatchAndWait(request1, request2);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecuteBatchedGets() throws IOException {
+        setBatchApplicationIdForTestApp();
+
+        Request request1 = new Request(null, "TourEiffel");
+        Request request2 = new Request(null, "SpaceNeedle");
+
+        List<Response> responses = Request.executeBatchAndWait(request1, request2);
+        assertEquals(2, responses.size());
+        assertTrue(responses.get(0).getError() == null);
+        assertTrue(responses.get(1).getError() == null);
+
+        GraphPlace eiffelTower = responses.get(0).getGraphObjectAs(GraphPlace.class);
+        GraphPlace spaceNeedle = responses.get(1).getGraphObjectAs(GraphPlace.class);
+        assertTrue(eiffelTower != null);
+        assertTrue(spaceNeedle != null);
+
+        assertEquals("Paris", eiffelTower.getLocation().getCity());
+        assertEquals("Seattle", spaceNeedle.getLocation().getCity());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testFacebookErrorResponsesCreateErrors() {
+        setBatchApplicationIdForTestApp();
+
+        Request request1 = new Request(null, "somestringthatshouldneverbeavalidfobjectid");
+        Request request2 = new Request(null, "someotherstringthatshouldneverbeavalidfobjectid");
+        List<Response> responses = Request.executeBatchAndWait(request1, request2);
+
+        assertEquals(2, responses.size());
+        assertTrue(responses.get(0).getError() != null);
+        assertTrue(responses.get(1).getError() != null);
+
+        FacebookRequestError error = responses.get(0).getError();
+        assertTrue(error.getException() instanceof FacebookServiceException);
+        assertTrue(error.getErrorType() != null);
+        assertTrue(error.getErrorCode() != FacebookRequestError.INVALID_ERROR_CODE);
+    }
+
+    @LargeTest
+    public void testBatchPostStatusUpdate() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        GraphObject statusUpdate1 = createStatusUpdate();
+        GraphObject statusUpdate2 = createStatusUpdate();
+
+        Request postRequest1 = Request.newPostRequest(session, "me/feed", statusUpdate1, null);
+        postRequest1.setBatchEntryName("postRequest1");
+        Request postRequest2 = Request.newPostRequest(session, "me/feed", statusUpdate2, null);
+        postRequest2.setBatchEntryName("postRequest2");
+        Request getRequest1 = new Request(session, "{result=postRequest1:$.id}");
+        Request getRequest2 = new Request(session, "{result=postRequest2:$.id}");
+
+        List<Response> responses = Request.executeBatchAndWait(postRequest1, postRequest2, getRequest1, getRequest2);
+        assertNotNull(responses);
+        assertEquals(4, responses.size());
+        assertNoErrors(responses);
+
+        GraphObject retrievedStatusUpdate1 = responses.get(2).getGraphObject();
+        GraphObject retrievedStatusUpdate2 = responses.get(3).getGraphObject();
+        assertNotNull(retrievedStatusUpdate1);
+        assertNotNull(retrievedStatusUpdate2);
+
+        assertEquals(statusUpdate1.getProperty("message"), retrievedStatusUpdate1.getProperty("message"));
+        assertEquals(statusUpdate2.getProperty("message"), retrievedStatusUpdate2.getProperty("message"));
+    }
+
+    @LargeTest
+    public void testTwoDifferentAccessTokens() {
+        TestSession session1 = openTestSessionWithSharedUser();
+        TestSession session2 = openTestSessionWithSharedUser(SECOND_TEST_USER_TAG);
+
+        Request request1 = Request.newMeRequest(session1, null);
+        Request request2 = Request.newMeRequest(session2, null);
+
+        List<Response> responses = Request.executeBatchAndWait(request1, request2);
+        assertNotNull(responses);
+        assertEquals(2, responses.size());
+
+        GraphUser user1 = responses.get(0).getGraphObjectAs(GraphUser.class);
+        GraphUser user2 = responses.get(1).getGraphObjectAs(GraphUser.class);
+
+        assertNotNull(user1);
+        assertNotNull(user2);
+
+        assertFalse(user1.getId().equals(user2.getId()));
+        assertEquals(session1.getTestUserId(), user1.getId());
+        assertEquals(session2.getTestUserId(), user2.getId());
+    }
+
+    @LargeTest
+    public void testBatchWithValidSessionAndNoSession() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request request1 = new Request(session, "me");
+        Request request2 = new Request(null, "zuck");
+
+        List<Response> responses = Request.executeBatchAndWait(request1, request2);
+        assertNotNull(responses);
+        assertEquals(2, responses.size());
+
+        GraphUser user1 = responses.get(0).getGraphObjectAs(GraphUser.class);
+        GraphUser user2 = responses.get(1).getGraphObjectAs(GraphUser.class);
+
+        assertNotNull(user1);
+        assertNotNull(user2);
+
+        assertFalse(user1.getId().equals(user2.getId()));
+        assertEquals(session.getTestUserId(), user1.getId());
+        assertEquals("4", user2.getId());
+    }
+
+    @LargeTest
+    public void testBatchWithNoSessionAndValidSession() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request request1 = new Request(null, "zuck");
+        Request request2 = new Request(session, "me");
+
+        List<Response> responses = Request.executeBatchAndWait(request1, request2);
+        assertNotNull(responses);
+        assertEquals(2, responses.size());
+
+        GraphUser user1 = responses.get(0).getGraphObjectAs(GraphUser.class);
+        GraphUser user2 = responses.get(1).getGraphObjectAs(GraphUser.class);
+
+        assertNotNull(user1);
+        assertNotNull(user2);
+
+        assertFalse(user1.getId().equals(user2.getId()));
+        assertEquals("4", user1.getId());
+        assertEquals(session.getTestUserId(), user2.getId());
+    }
+
+    @LargeTest
+    public void testBatchWithTwoSessionlessRequestsAndDefaultAppID() {
+        TestSession session = getTestSessionWithSharedUser(null);
+        String appId = session.getApplicationId();
+        Request.setDefaultBatchApplicationId(appId);
+
+        Request request1 = new Request(null, "zuck");
+        Request request2 = new Request(null, "zuck");
+
+        List<Response> responses = Request.executeBatchAndWait(request1, request2);
+        assertNotNull(responses);
+        assertEquals(2, responses.size());
+
+        GraphUser user1 = responses.get(0).getGraphObjectAs(GraphUser.class);
+        GraphUser user2 = responses.get(1).getGraphObjectAs(GraphUser.class);
+
+        assertNotNull(user1);
+        assertNotNull(user2);
+
+        assertEquals("4", user1.getId());
+        assertEquals("4", user2.getId());
+    }
+
+    @LargeTest
+    public void testMixedSuccessAndFailure() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        final int NUM_REQUESTS = 8;
+        Request[] requests = new Request[NUM_REQUESTS];
+        for (int i = 0; i < NUM_REQUESTS; ++i) {
+            boolean shouldSucceed = (i % 2) == 1;
+            requests[i] = new Request(session, shouldSucceed ? "me" : "-1");
+        }
+
+        List<Response> responses = Request.executeBatchAndWait(requests);
+        assertNotNull(responses);
+        assertEquals(NUM_REQUESTS, responses.size());
+
+        for (int i = 0; i < NUM_REQUESTS; ++i) {
+            boolean shouldSucceed = (i % 2) == 1;
+
+            Response response = responses.get(i);
+            assertNotNull(response);
+            if (shouldSucceed) {
+                assertNull(response.getError());
+                assertNotNull(response.getGraphObject());
+            } else {
+                assertNotNull(response.getError());
+                assertNull(response.getGraphObject());
+            }
+        }
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testClosedSessionDoesntAppendAccessToken() {
+        TestSession session = openTestSessionWithSharedUser();
+        session.close();
+        Request request1 = new Request(session, "me", null, null, new ExpectFailureCallback());
+        Request request2 = new Request(session, "me", null, null, new ExpectFailureCallback());
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(request1, request2);
+        task.executeOnBlockerThread();
+
+        waitAndAssertSuccess(2);
+    }
+
+    @LargeTest
+    public void testBatchUploadPhoto() {
+        TestSession session = openTestSessionWithSharedUserAndPermissions(null, "user_photos");
+
+        final int image1Size = 120;
+        final int image2Size = 150;
+
+        Bitmap bitmap1 = createTestBitmap(image1Size);
+        Bitmap bitmap2 = createTestBitmap(image2Size);
+
+        Request uploadRequest1 = Request.newUploadPhotoRequest(session, bitmap1, null);
+        uploadRequest1.setBatchEntryName("uploadRequest1");
+        Request uploadRequest2 = Request.newUploadPhotoRequest(session, bitmap2, null);
+        uploadRequest2.setBatchEntryName("uploadRequest2");
+        Request getRequest1 = new Request(session, "{result=uploadRequest1:$.id}");
+        Request getRequest2 = new Request(session, "{result=uploadRequest2:$.id}");
+
+        List<Response> responses = Request.executeBatchAndWait(uploadRequest1, uploadRequest2, getRequest1, getRequest2);
+        assertNotNull(responses);
+        assertEquals(4, responses.size());
+        assertNoErrors(responses);
+
+        GraphObject retrievedPhoto1 = responses.get(2).getGraphObject();
+        GraphObject retrievedPhoto2 = responses.get(3).getGraphObject();
+        assertNotNull(retrievedPhoto1);
+        assertNotNull(retrievedPhoto2);
+
+        assertEquals(image1Size, retrievedPhoto1.getProperty("width"));
+        assertEquals(image2Size, retrievedPhoto2.getProperty("width"));
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCallbacksAreCalled() {
+        setBatchApplicationIdForTestApp();
+
+        ArrayList<Request> requests = new ArrayList<Request>();
+        final ArrayList<Boolean> calledBack = new ArrayList<Boolean>();
+
+        final int NUM_REQUESTS = 4;
+        for (int i = 0; i < NUM_REQUESTS; ++i) {
+            Request request = new Request(null, "4");
+
+            request.setCallback(new Request.Callback() {
+                @Override
+                public void onCompleted(Response response) {
+                    calledBack.add(true);
+                }
+            });
+
+            requests.add(request);
+        }
+
+        List<Response> responses = Request.executeBatchAndWait(requests);
+        assertNotNull(responses);
+        assertTrue(calledBack.size() == NUM_REQUESTS);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCacheMyFriendsRequest() throws IOException {
+        Response.getResponseCache().clearForTest();
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request request = Request.newMyFriendsRequest(session, null);
+
+        CacheableRequestBatch batch = new CacheableRequestBatch(request);
+        batch.setCacheKeyOverride("MyFriends");
+
+        // Running the request with empty cache should hit the server.
+        List<Response> responses = Request.executeBatchAndWait(batch);
+        assertNotNull(responses);
+        assertEquals(1, responses.size());
+
+        Response response = responses.get(0);
+        assertNotNull(response);
+        assertNull(response.getError());
+        assertTrue(!response.getIsFromCache());
+
+        // Running again should hit the cache.
+        responses = Request.executeBatchAndWait(batch);
+        assertNotNull(responses);
+        assertEquals(1, responses.size());
+
+        response = responses.get(0);
+        assertNotNull(response);
+        assertNull(response.getError());
+        assertTrue(response.getIsFromCache());
+
+        // Forcing roundtrip should hit the server again.
+        batch.setForceRoundTrip(true);
+        responses = Request.executeBatchAndWait(batch);
+        assertNotNull(responses);
+        assertEquals(1, responses.size());
+
+        response = responses.get(0);
+        assertNotNull(response);
+        assertNull(response.getError());
+        assertTrue(!response.getIsFromCache());
+
+        Response.getResponseCache().clearForTest();
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCacheMeAndMyFriendsRequest() throws IOException {
+        Response.getResponseCache().clearForTest();
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request requestMe = Request.newMeRequest(session, null);
+        Request requestMyFriends = Request.newMyFriendsRequest(session, null);
+
+        CacheableRequestBatch batch = new CacheableRequestBatch(new Request[] { requestMyFriends, requestMe });
+        batch.setCacheKeyOverride("MyFriends");
+
+        // Running the request with empty cache should hit the server.
+        List<Response> responses = Request.executeBatchAndWait(batch);
+        assertNotNull(responses);
+        assertEquals(2, responses.size());
+
+        for (Response response : responses) {
+            assertNotNull(response);
+            assertNull(response.getError());
+            assertTrue(!response.getIsFromCache());
+        }
+
+        // Running again should hit the cache.
+        responses = Request.executeBatchAndWait(batch);
+        assertNotNull(responses);
+        assertEquals(2, responses.size());
+
+        for (Response response : responses) {
+            assertNotNull(response);
+            assertNull(response.getError());
+            assertTrue(response.getIsFromCache());
+        }
+
+        // Forcing roundtrip should hit the server again.
+        batch.setForceRoundTrip(true);
+        responses = Request.executeBatchAndWait(batch);
+        assertNotNull(responses);
+        assertEquals(2, responses.size());
+
+        for (Response response : responses) {
+            assertNotNull(response);
+            assertNull(response.getError());
+            assertTrue(!response.getIsFromCache());
+        }
+
+        Response.getResponseCache().clearForTest();
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExplicitDependencyDefaultsToOmitFirstResponse() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request requestMe = Request.newMeRequest(session, null);
+        requestMe.setBatchEntryName("me_request");
+
+        Request requestMyFriends = Request.newMyFriendsRequest(session, null);
+        requestMyFriends.setBatchEntryDependsOn("me_request");
+
+        List<Response> responses = Request.executeBatchAndWait(requestMe, requestMyFriends);
+
+        Response meResponse = responses.get(0);
+        Response myFriendsResponse = responses.get(1);
+
+        assertNull(meResponse.getGraphObject());
+        assertNotNull(myFriendsResponse.getGraphObject());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExplicitDependencyCanIncludeFirstResponse() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request requestMe = Request.newMeRequest(session, null);
+        requestMe.setBatchEntryName("me_request");
+        requestMe.setBatchEntryOmitResultOnSuccess(false);
+
+        Request requestMyFriends = Request.newMyFriendsRequest(session, null);
+        requestMyFriends.setBatchEntryDependsOn("me_request");
+
+        List<Response> responses = Request.executeBatchAndWait(requestMe, requestMyFriends);
+
+        Response meResponse = responses.get(0);
+        Response myFriendsResponse = responses.get(1);
+
+        assertNotNull(meResponse.getGraphObject());
+        assertNotNull(myFriendsResponse.getGraphObject());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testAddAndRemoveBatchCallbacks() {
+        RequestBatch batch = new RequestBatch();
+
+        RequestBatch.Callback callback1 = new RequestBatch.Callback() {
+            @Override
+            public void onBatchCompleted(RequestBatch batch) {
+            }
+        };
+
+        RequestBatch.Callback callback2 = new RequestBatch.Callback() {
+            @Override
+            public void onBatchCompleted(RequestBatch batch) {
+            }
+        };
+
+        batch.addCallback(callback1);
+        batch.addCallback(callback2);
+
+        assertEquals(2, batch.getCallbacks().size());
+
+        batch.removeCallback(callback1);
+        batch.removeCallback(callback2);
+
+        assertEquals(0, batch.getCallbacks().size());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testBatchCallbackIsCalled() {
+        final AtomicInteger count = new AtomicInteger();
+        Request request1 = Request.newGraphPathRequest(null, "4", new Request.Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                count.incrementAndGet();
+            }
+        });
+        Request request2 = Request.newGraphPathRequest(null, "4", new Request.Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                count.incrementAndGet();
+            }
+        });
+
+        RequestBatch batch = new RequestBatch(request1, request2);
+        batch.addCallback(new RequestBatch.Callback() {
+            @Override
+            public void onBatchCompleted(RequestBatch batch) {
+                count.incrementAndGet();
+            }
+        });
+
+        batch.executeAndWait();
+        assertEquals(3, count.get());
+    }
+}
diff --git a/facebook/tests/src/com/facebook/FacebookActivityTestCase.java b/facebook/tests/src/com/facebook/FacebookActivityTestCase.java
new file mode 100644
index 000000000..a3292c30f
--- /dev/null
+++ b/facebook/tests/src/com/facebook/FacebookActivityTestCase.java
@@ -0,0 +1,680 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.app.Activity;
+import android.content.res.AssetManager;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.os.Bundle;
+import android.os.ConditionVariable;
+import android.os.Handler;
+import android.test.ActivityInstrumentationTestCase2;
+import android.util.Log;
+import com.facebook.model.GraphObject;
+import com.facebook.internal.Utility;
+import junit.framework.AssertionFailedError;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.json.JSONTokener;
+
+import java.io.*;
+import java.net.HttpURLConnection;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+public class FacebookActivityTestCase<T extends Activity> extends ActivityInstrumentationTestCase2<T> {
+    private static final String TAG = FacebookActivityTestCase.class.getSimpleName();
+
+    private static String applicationId;
+    private static String applicationSecret;
+
+    public final static String SECOND_TEST_USER_TAG = "Second";
+    public final static String THIRD_TEST_USER_TAG = "Third";
+
+    private TestBlocker testBlocker;
+
+    protected synchronized TestBlocker getTestBlocker() {
+        if (testBlocker == null) {
+            testBlocker = TestBlocker.createTestBlocker();
+        }
+        return testBlocker;
+    }
+
+    public FacebookActivityTestCase(Class<T> activityClass) {
+        super("", activityClass);
+    }
+
+    // Returns an un-opened TestSession
+    protected TestSession getTestSessionWithSharedUser() {
+        return getTestSessionWithSharedUser(null);
+    }
+
+    // Returns an un-opened TestSession
+    protected TestSession getTestSessionWithSharedUser(String sessionUniqueUserTag) {
+        return getTestSessionWithSharedUserAndPermissions(sessionUniqueUserTag, new ArrayList<String>());
+    }
+
+    protected TestSession getTestSessionWithSharedUserAndPermissions(String sessionUniqueUserTag,
+            List<String> permissions) {
+        return TestSession.createSessionWithSharedUser(getActivity(), permissions, sessionUniqueUserTag);
+    }
+
+    // Returns an un-opened TestSession
+    protected TestSession getTestSessionWithPrivateUser(TestBlocker testBlocker) {
+        return TestSession.createSessionWithPrivateUser(getActivity(), null);
+    }
+
+    protected TestSession openTestSessionWithSharedUser(final TestBlocker blocker) {
+        return openTestSessionWithSharedUser(blocker, null);
+    }
+
+    protected TestSession openTestSessionWithSharedUser(final TestBlocker blocker, String sessionUniqueUserTag) {
+        TestSession session = getTestSessionWithSharedUser();
+        openSession(getActivity(), session, blocker);
+        return session;
+    }
+
+    protected TestSession openTestSessionWithSharedUser() {
+        return openTestSessionWithSharedUser((String) null);
+    }
+
+    protected TestSession openTestSessionWithSharedUser(String sessionUniqueUserTag) {
+        return openTestSessionWithSharedUserAndPermissions(sessionUniqueUserTag, (String[]) null);
+    }
+
+    protected TestSession openTestSessionWithSharedUserAndPermissions(String sessionUniqueUserTag,
+            String... permissions) {
+        List<String> permissionList = (permissions != null) ? Arrays.asList(permissions) : null;
+        return openTestSessionWithSharedUserAndPermissions(sessionUniqueUserTag, permissionList);
+    }
+
+    protected TestSession openTestSessionWithSharedUserAndPermissions(String sessionUniqueUserTag,
+            List<String> permissions) {
+        final TestBlocker blocker = getTestBlocker();
+        TestSession session = getTestSessionWithSharedUserAndPermissions(sessionUniqueUserTag, permissions);
+        openSession(getActivity(), session, blocker);
+        return session;
+    }
+
+    // Turns exceptions from the TestBlocker into JUnit assertions
+    protected void waitAndAssertSuccess(TestBlocker testBlocker, int numSignals) {
+        try {
+            testBlocker.waitForSignalsAndAssertSuccess(numSignals);
+        } catch (AssertionFailedError e) {
+            throw e;
+        } catch (Exception e) {
+            fail("Got exception: " + e.getMessage());
+        }
+    }
+
+    protected void waitAndAssertSuccess(int numSignals) {
+        waitAndAssertSuccess(getTestBlocker(), numSignals);
+    }
+
+    protected void waitAndAssertSuccessOrRethrow(int numSignals) throws Exception {
+        getTestBlocker().waitForSignalsAndAssertSuccess(numSignals);
+    }
+
+    protected void runAndBlockOnUiThread(final int expectedSignals, final Runnable runnable) throws Throwable {
+        final TestBlocker blocker = getTestBlocker();
+        runTestOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                runnable.run();
+                blocker.signal();
+            }
+        });
+        // We wait for the operation to complete; wait for as many other signals as we expect.
+        blocker.waitForSignals(1 + expectedSignals);
+        // Wait for the UI thread to become idle so any UI updates the runnable triggered have a chance
+        // to finish before we return.
+        getInstrumentation().waitForIdleSync();
+    }
+
+    protected synchronized void readApplicationIdAndSecret() {
+        synchronized (FacebookTestCase.class) {
+            if (applicationId != null && applicationSecret != null) {
+                return;
+            }
+
+            AssetManager assets = getInstrumentation().getContext().getResources().getAssets();
+            InputStream stream = null;
+            final String errorMessage = "could not read applicationId and applicationSecret from config.json; ensure "
+                    + "you have run 'configure_unit_tests.sh'. Error: ";
+            try {
+                stream = assets.open("config.json");
+                String string = Utility.readStreamToString(stream);
+
+                JSONTokener tokener = new JSONTokener(string);
+                Object obj = tokener.nextValue();
+                if (!(obj instanceof JSONObject)) {
+                    fail(errorMessage + "could not deserialize a JSONObject");
+                }
+                JSONObject jsonObject = (JSONObject) obj;
+
+                applicationId = jsonObject.optString("applicationId");
+                applicationSecret = jsonObject.optString("applicationSecret");
+
+                if (Utility.isNullOrEmpty(applicationId) || Utility.isNullOrEmpty(applicationSecret)) {
+                    fail(errorMessage + "one or both config values are missing");
+                }
+
+                TestSession.setTestApplicationId(applicationId);
+                TestSession.setTestApplicationSecret(applicationSecret);
+            } catch (IOException e) {
+                fail(errorMessage + e.toString());
+            } catch (JSONException e) {
+                fail(errorMessage + e.toString());
+            } finally {
+                if (stream != null) {
+                    try {
+                        stream.close();
+                    } catch (IOException e) {
+                        fail(errorMessage + e.toString());
+                    }
+                }
+            }
+        }
+    }
+
+    protected void openSession(Activity activity, TestSession session) {
+        final TestBlocker blocker = getTestBlocker();
+        openSession(activity, session, blocker);
+    }
+
+    protected void openSession(Activity activity, TestSession session, final TestBlocker blocker) {
+        Session.OpenRequest openRequest = new Session.OpenRequest(activity).
+                setCallback(new Session.StatusCallback() {
+                    boolean signaled = false;
+
+                    @Override
+                    public void call(Session session, SessionState state, Exception exception) {
+                        if (exception != null) {
+                            Log.w(TAG,
+                                    "openSession: received an error opening session: " + exception.toString());
+                        }
+                        assertTrue(exception == null);
+                        // Only signal once, or we might screw up the count on the blocker.
+                        if (!signaled) {
+                            blocker.signal();
+                            signaled = true;
+                        }
+                    }
+                });
+
+        session.openForRead(openRequest);
+        waitAndAssertSuccess(blocker, 1);
+    }
+
+    protected void setUp() throws Exception {
+        super.setUp();
+
+        // Make sure we have read application ID and secret.
+        readApplicationIdAndSecret();
+
+        // These are useful for debugging unit test failures.
+        Settings.addLoggingBehavior(LoggingBehavior.REQUESTS);
+        Settings.addLoggingBehavior(LoggingBehavior.INCLUDE_ACCESS_TOKENS);
+
+        // We want the UI thread to be in StrictMode to catch any violations.
+        turnOnStrictModeForUiThread();
+    }
+
+    protected void tearDown() throws Exception {
+        super.tearDown();
+
+        if (testBlocker != null) {
+            testBlocker.quit();
+        }
+    }
+
+    protected Bundle getNativeLinkingExtras(String token) {
+        Bundle extras = new Bundle();
+        String extraLaunchUriString = String
+                .format("fbrpc://facebook/nativethirdparty?app_id=%s&package_name=com.facebook.sdk.tests&class_name=com.facebook.FacebookActivityTests$FacebookTestActivity&access_token=%s",
+                        TestSession.getTestApplicationId(), token);
+        extras.putString("extra_launch_uri", extraLaunchUriString);
+        extras.putString("expires_in", "3600");
+        extras.putLong("app_id", Long.parseLong(TestSession.getTestApplicationId()));
+        extras.putString("access_token", token);
+
+        return extras;
+    }
+
+    interface GraphObjectPostResult extends GraphObject {
+        String getId();
+    }
+
+    protected GraphObject getAndAssert(Session session, String id) {
+        Request request = new Request(session, id);
+        Response response = request.executeAndWait();
+        assertNotNull(response);
+
+        assertNull(response.getError());
+
+        GraphObject result = response.getGraphObject();
+        assertNotNull(result);
+
+        return result;
+    }
+
+    protected GraphObject postGetAndAssert(Session session, String path, GraphObject graphObject) {
+        Request request = Request.newPostRequest(session, path, graphObject, null);
+        Response response = request.executeAndWait();
+        assertNotNull(response);
+
+        assertNull(response.getError());
+
+        GraphObjectPostResult result = response.getGraphObjectAs(GraphObjectPostResult.class);
+        assertNotNull(result);
+        assertNotNull(result.getId());
+
+        return getAndAssert(session, result.getId());
+    }
+
+    protected void setBatchApplicationIdForTestApp() {
+        String appId = TestSession.getTestApplicationId();
+        Request.setDefaultBatchApplicationId(appId);
+    }
+
+    protected <U extends GraphObject> U batchCreateAndGet(Session session, String graphPath, GraphObject graphObject,
+            String fields, Class<U> resultClass) {
+        Request create = Request.newPostRequest(session, graphPath, graphObject, new ExpectSuccessCallback());
+        create.setBatchEntryName("create");
+        Request get = Request.newGraphPathRequest(session, "{result=create:$.id}", new ExpectSuccessCallback());
+        if (fields != null) {
+            Bundle parameters = new Bundle();
+            parameters.putString("fields", fields);
+            get.setParameters(parameters);
+        }
+
+        return batchPostAndGet(create, get, resultClass);
+    }
+
+    protected <U extends GraphObject> U batchUpdateAndGet(Session session, String graphPath, GraphObject graphObject,
+            String fields, Class<U> resultClass) {
+        Request update = Request.newPostRequest(session, graphPath, graphObject, new ExpectSuccessCallback());
+        Request get = Request.newGraphPathRequest(session, graphPath, new ExpectSuccessCallback());
+        if (fields != null) {
+            Bundle parameters = new Bundle();
+            parameters.putString("fields", fields);
+            get.setParameters(parameters);
+        }
+
+        return batchPostAndGet(update, get, resultClass);
+    }
+
+    protected <U extends GraphObject> U batchPostAndGet(Request post, Request get, Class<U> resultClass) {
+        List<Response> responses = Request.executeBatchAndWait(post, get);
+        assertEquals(2, responses.size());
+
+        U resultGraphObject = responses.get(1).getGraphObjectAs(resultClass);
+        assertNotNull(resultGraphObject);
+        return resultGraphObject;
+    }
+
+    protected GraphObject createStatusUpdate() {
+        GraphObject statusUpdate = GraphObject.Factory.create();
+        String message = String.format(
+                "Check out my awesome new status update posted at: %s. Some chars for you: +\"[]:,", new Date());
+        statusUpdate.setProperty("message", message);
+        return statusUpdate;
+    }
+
+    protected Bitmap createTestBitmap(int size) {
+        Bitmap image = Bitmap.createBitmap(size, size, Bitmap.Config.RGB_565);
+        image.eraseColor(Color.BLUE);
+        return image;
+    }
+
+    protected void issueFriendRequest(TestSession session, String targetUserId) {
+        String graphPath = "me/friends/" + targetUserId;
+        Request request = Request.newPostRequest(session, graphPath, null, null);
+        Response response = request.executeAndWait();
+        // We will get a 400 error if the users are already friends.
+        FacebookRequestError error = response.getError();
+        assertTrue(error == null || error.getRequestStatusCode() == 400);
+    }
+
+    protected void makeTestUsersFriends(TestSession session1, TestSession session2) {
+        issueFriendRequest(session1, session2.getTestUserId());
+        issueFriendRequest(session2, session1.getTestUserId());
+    }
+
+    protected void assertDateEqualsWithinDelta(Date expected, Date actual, long deltaInMsec) {
+        long delta = Math.abs(expected.getTime() - actual.getTime());
+        assertTrue(delta < deltaInMsec);
+    }
+
+    protected void assertDateDiffersWithinDelta(Date expected, Date actual, long expectedDifference, long deltaInMsec) {
+        long delta = Math.abs(expected.getTime() - actual.getTime()) - expectedDifference;
+        assertTrue(delta < deltaInMsec);
+    }
+
+    protected void assertNoErrors(List<Response> responses) {
+        for (int i = 0; i < responses.size(); ++i) {
+            Response response = responses.get(i);
+            assertNotNull(response);
+            assertNull(response.getError());
+        }
+    }
+
+    protected File createTempFileFromAsset(String assetPath) throws IOException {
+        InputStream inputStream = null;
+        FileOutputStream outStream = null;
+
+        try {
+            AssetManager assets = getInstrumentation().getContext().getResources().getAssets();
+            inputStream = assets.open(assetPath);
+
+            File outputDir = getActivity().getCacheDir(); // context being the Activity pointer
+            File outputFile = File.createTempFile("prefix", assetPath, outputDir);
+            outStream = new FileOutputStream(outputFile);
+
+            final int bufferSize = 1024 * 2;
+            byte[] buffer = new byte[bufferSize];
+            int n = 0;
+            while ((n = inputStream.read(buffer)) != -1) {
+                outStream.write(buffer, 0, n);
+            }
+
+            return outputFile;
+        } finally {
+            Utility.closeQuietly(outStream);
+            Utility.closeQuietly(inputStream);
+        }
+    }
+
+    protected void runOnBlockerThread(final Runnable runnable, boolean waitForCompletion) {
+        Runnable runnableToPost = runnable;
+        final ConditionVariable condition = waitForCompletion ? new ConditionVariable(!waitForCompletion) : null;
+
+        if (waitForCompletion) {
+            runnableToPost = new Runnable() {
+                @Override
+                public void run() {
+                    runnable.run();
+                    condition.open();
+                }
+            };
+        }
+
+        TestBlocker blocker = getTestBlocker();
+        Handler handler = blocker.getHandler();
+        handler.post(runnableToPost);
+
+        if (waitForCompletion) {
+            boolean success = condition.block(10000);
+            assertTrue(success);
+        }
+    }
+
+    protected void closeBlockerAndAssertSuccess() {
+        TestBlocker blocker = getTestBlocker();
+        testBlocker = null;
+
+        blocker.quit();
+
+        boolean joined = false;
+        while (!joined) {
+            try {
+                blocker.join();
+                joined = true;
+            } catch (InterruptedException e) {
+            }
+        }
+
+        try {
+            blocker.assertSuccess();
+        } catch (Exception e) {
+            fail(e.toString());
+        }
+    }
+
+    protected TestRequestAsyncTask createAsyncTaskOnUiThread(final Request... requests) throws Throwable {
+        final ArrayList<TestRequestAsyncTask> result = new ArrayList<TestRequestAsyncTask>();
+        runTestOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                result.add(new TestRequestAsyncTask(requests));
+            }
+        });
+        return result.isEmpty() ? null : result.get(0);
+    }
+
+
+    /*
+     * Classes and helpers related to asynchronous requests.
+     */
+
+    // A subclass of RequestAsyncTask that knows how to interact with TestBlocker to ensure that tests can wait
+    // on and assert success of async tasks.
+    protected class TestRequestAsyncTask extends RequestAsyncTask {
+        private final TestBlocker blocker = FacebookActivityTestCase.this.getTestBlocker();
+
+        public TestRequestAsyncTask(Request... requests) {
+            super(requests);
+        }
+
+        public TestRequestAsyncTask(List<Request> requests) {
+            super(requests);
+        }
+
+        public TestRequestAsyncTask(RequestBatch requests) {
+            super(requests);
+        }
+
+        public TestRequestAsyncTask(HttpURLConnection connection, Request... requests) {
+            super(connection, requests);
+        }
+
+        public TestRequestAsyncTask(HttpURLConnection connection, List<Request> requests) {
+            super(connection, requests);
+        }
+
+        public TestRequestAsyncTask(HttpURLConnection connection, RequestBatch requests) {
+            super(connection, requests);
+        }
+
+        public final TestBlocker getBlocker() {
+            return blocker;
+        }
+
+        public final Exception getThrowable() {
+            return getException();
+        }
+
+        protected void onPostExecute(List<Response> result) {
+            try {
+                super.onPostExecute(result);
+
+                if (getException() != null) {
+                    blocker.setException(getException());
+                }
+            } finally {
+                Log.d("TestRequestAsyncTask", "signaling blocker");
+                blocker.signal();
+            }
+        }
+
+        // In order to be able to block and accumulate exceptions, we want to ensure the async task is really
+        // being started on the blocker's thread, rather than the test's thread. Use this instead of calling
+        // execute directly in unit tests.
+        public void executeOnBlockerThread() {
+            ensureAsyncTaskLoaded();
+
+            Runnable runnable = new Runnable() {
+                public void run() {
+                    execute();
+                }
+            };
+            Handler handler = new Handler(blocker.getLooper());
+            handler.post(runnable);
+        }
+
+        private void ensureAsyncTaskLoaded() {
+            // Work around this issue on earlier frameworks: http://stackoverflow.com/a/7818839/782044
+            try {
+                runAndBlockOnUiThread(0, new Runnable() {
+                    @Override
+                    public void run() {
+                        try {
+                            Class.forName("android.os.AsyncTask");
+                        } catch (ClassNotFoundException e) {
+                        }
+                    }
+                });
+            } catch (Throwable throwable) {
+            }
+        }
+    }
+
+    // Provides an implementation of Request.Callback that will assert either success (no error) or failure (error)
+    // of a request, and allow derived classes to perform additional asserts.
+    protected class TestCallback implements Request.Callback {
+        private final TestBlocker blocker;
+        private final boolean expectSuccess;
+
+        public TestCallback(TestBlocker blocker, boolean expectSuccess) {
+            this.blocker = blocker;
+            this.expectSuccess = expectSuccess;
+        }
+
+        public TestCallback(boolean expectSuccess) {
+            this(FacebookActivityTestCase.this.getTestBlocker(), expectSuccess);
+        }
+
+        @Override
+        public void onCompleted(Response response) {
+            try {
+                // We expect to be called on the right thread.
+                if (Thread.currentThread() != blocker) {
+                    throw new FacebookException("Invalid thread " + Thread.currentThread().getId()
+                            + "; expected to be called on thread " + blocker.getId());
+                }
+
+                // We expect either success or failure.
+                if (expectSuccess && response.getError() != null) {
+                    throw response.getError().getException();
+                } else if (!expectSuccess && response.getError() == null) {
+                    throw new FacebookException("Expected failure case, received no error");
+                }
+
+                // Some tests may want more fine-grained control and assert additional conditions.
+                performAsserts(response);
+            } catch (Exception e) {
+                blocker.setException(e);
+            } finally {
+                // Tell anyone waiting on us that this callback was called.
+                blocker.signal();
+            }
+        }
+
+        protected void performAsserts(Response response) {
+        }
+    }
+
+    // A callback that will assert if the request resulted in an error.
+    protected class ExpectSuccessCallback extends TestCallback {
+        public ExpectSuccessCallback() {
+            super(true);
+        }
+    }
+
+    // A callback that will assert if the request did NOT result in an error.
+    protected class ExpectFailureCallback extends TestCallback {
+        public ExpectFailureCallback() {
+            super(false);
+        }
+    }
+
+    public static abstract class MockRequest extends Request {
+        public abstract Response createResponse();
+    }
+
+    public static class MockRequestBatch extends RequestBatch {
+        public MockRequestBatch(MockRequest... requests) {
+            super(requests);
+        }
+
+        // Caller must ensure that all the requests in the batch are, in fact, MockRequests.
+        public MockRequestBatch(RequestBatch requests) {
+            super(requests);
+        }
+
+        @Override
+        List<Response> executeAndWaitImpl() {
+            List<Request> requests = getRequests();
+
+            List<Response> responses = new ArrayList<Response>();
+            for (Request request : requests) {
+                MockRequest mockRequest = (MockRequest) request;
+                responses.add(mockRequest.createResponse());
+            }
+
+            Request.runCallbacks(this, responses);
+
+            return responses;
+        }
+    }
+
+    private AtomicBoolean strictModeOnForUiThread = new AtomicBoolean();
+
+    protected void turnOnStrictModeForUiThread() {
+        // We only ever need to do this once. If the boolean is true, we know that the next runnable
+        // posted to the UI thread will have strict mode on.
+        if (strictModeOnForUiThread.get() == false) {
+            try {
+                runTestOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        // Double-check whether we really need to still do this on the UI thread.
+                        if (strictModeOnForUiThread.compareAndSet(false, true)) {
+                            turnOnStrictModeForThisThread();
+                        }
+                    }
+                });
+            } catch (Throwable throwable) {
+            }
+        }
+    }
+
+    protected void turnOnStrictModeForThisThread() {
+        // We use reflection, because Instrumentation will complain about any references to StrictMode in API versions < 9
+        // when attempting to run the unit tests. No particular effort has been made to make this efficient, since we
+        // expect to call it just once.
+        try {
+            ClassLoader loader = Thread.currentThread().getContextClassLoader();
+            Class<?> strictModeClass = Class.forName("android.os.StrictMode", true, loader);
+            Class<?> threadPolicyClass = Class.forName("android.os.StrictMode$ThreadPolicy", true, loader);
+            Class<?> threadPolicyBuilderClass = Class.forName("android.os.StrictMode$ThreadPolicy$Builder", true,
+                    loader);
+
+            Object threadPolicyBuilder = threadPolicyBuilderClass.getConstructor().newInstance();
+            threadPolicyBuilder = threadPolicyBuilderClass.getMethod("detectAll").invoke(threadPolicyBuilder);
+            threadPolicyBuilder = threadPolicyBuilderClass.getMethod("penaltyDeath").invoke(threadPolicyBuilder);
+
+            Object threadPolicy = threadPolicyBuilderClass.getMethod("build").invoke(threadPolicyBuilder);
+            strictModeClass.getMethod("setThreadPolicy", threadPolicyClass).invoke(strictModeClass, threadPolicy);
+        } catch (Exception ex) {
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/FacebookActivityTests.java b/facebook/tests/src/com/facebook/FacebookActivityTests.java
new file mode 100644
index 000000000..df7177214
--- /dev/null
+++ b/facebook/tests/src/com/facebook/FacebookActivityTests.java
@@ -0,0 +1,75 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+
+public class FacebookActivityTests extends FacebookActivityTestCase<FacebookActivityTests.FacebookTestActivity> {
+    public FacebookActivityTests() {
+        super(FacebookActivityTests.FacebookTestActivity.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+
+        Session activeSession = Session.getActiveSession();
+        if (activeSession != null) {
+            activeSession.closeAndClearTokenInformation();
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testLaunchingWithEmptyIntent() {
+        Intent intent = new Intent(Intent.ACTION_MAIN);
+        setActivityIntent(intent);
+        FacebookTestActivity activity = getActivity();
+
+        assertNull(Session.getActiveSession());
+        assertFalse(activity.hasNativeLinkIntentForTesting());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testLaunchingWithValidNativeLinkingIntent() {
+        final String token = "A token less unique than most";
+
+        Intent intent = new Intent(Intent.ACTION_MAIN);
+        intent.putExtras(getNativeLinkingExtras(token));
+        setActivityIntent(intent);
+
+        assertNull(Session.getActiveSession());
+
+        FacebookTestActivity activity = getActivity();
+        Session activeSession = Session.getActiveSession();
+        assertNull(activeSession);
+        assertTrue(activity.hasNativeLinkIntentForTesting());
+    }
+
+    public static class FacebookTestActivity extends Activity {
+        public boolean hasNativeLinkIntentForTesting() {
+            return AccessToken.createFromNativeLinkingIntent(getIntent()) != null;
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/FacebookRequestErrorTests.java b/facebook/tests/src/com/facebook/FacebookRequestErrorTests.java
new file mode 100644
index 000000000..34b6c45b8
--- /dev/null
+++ b/facebook/tests/src/com/facebook/FacebookRequestErrorTests.java
@@ -0,0 +1,321 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import com.facebook.sdk.tests.R;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+public class FacebookRequestErrorTests extends FacebookTestCase {
+    public static final String ERROR_SINGLE_RESPONSE =
+            "{\n" +
+            "  \"error\": {\n" +
+            "    \"message\": \"Unknown path components: /unknown\",\n" +
+            "    \"type\": \"OAuthException\",\n" +
+            "    \"code\": 2500\n" +
+            "  }\n" +
+            "}";
+
+    public static final String ERROR_BATCH_RESPONSE =
+            "[\n" +
+            "  {\n" +
+            "    \"headers\": [\n" +
+            "      {\n" +
+            "        \"value\": \"*\",\n" +
+            "        \"name\": \"Access-Control-Allow-Origin\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"no-store\",\n" +
+            "        \"name\": \"Cache-Control\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"close\",\n" +
+            "        \"name\": \"Connection\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"text\\/javascript; charset=UTF-8\",\n" +
+            "        \"name\": \"Content-Type\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"Sat, 01 Jan 2000 00:00:00 GMT\",\n" +
+            "        \"name\": \"Expires\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"no-cache\",\n" +
+            "        \"name\": \"Pragma\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"OAuth \\\"Facebook Platform\\\" \\\"invalid_request\\\" \\\"An active access token must be used to query information about the current user.\\\"\",\n" +
+            "        \"name\": \"WWW-Authenticate\"\n" +
+            "      }\n" +
+            "    ],\n" +
+            "    \"body\": \"{\\\"error\\\":{\\\"message\\\":\\\"An active access token must be used to query information about the current user.\\\",\\\"type\\\":\\\"OAuthException\\\",\\\"code\\\":2500}}\",\n" +
+            "    \"code\": 400\n" +
+            "  },\n" +
+            "  {\n" +
+            "    \"headers\": [\n" +
+            "      {\n" +
+            "        \"value\": \"*\",\n" +
+            "        \"name\": \"Access-Control-Allow-Origin\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"no-store\",\n" +
+            "        \"name\": \"Cache-Control\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"close\",\n" +
+            "        \"name\": \"Connection\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"text\\/javascript; charset=UTF-8\",\n" +
+            "        \"name\": \"Content-Type\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"Sat, 01 Jan 2000 00:00:00 GMT\",\n" +
+            "        \"name\": \"Expires\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"no-cache\",\n" +
+            "        \"name\": \"Pragma\"\n" +
+            "      },\n" +
+            "      {\n" +
+            "        \"value\": \"OAuth \\\"Facebook Platform\\\" \\\"invalid_request\\\" \\\"An active access token must be used to query information about the current user.\\\"\",\n" +
+            "        \"name\": \"WWW-Authenticate\"\n" +
+            "      }\n" +
+            "    ],\n" +
+            "    \"body\": \"{\\\"error\\\":{\\\"message\\\":\\\"An active access token must be used to query information about the current user.\\\",\\\"type\\\":\\\"OAuthException\\\",\\\"code\\\":2500}}\",\n" +
+            "    \"code\": 400\n" +
+            "  }\n" +
+            "]";
+
+
+    public static final String ERROR_SINGLE_RESPONSE_THROTTLE =
+            "{\n" +
+            "  \"error\": {\n" +
+            "    \"message\": \"Application request limit reached\",\n" +
+            "    \"code\": 4\n" +
+            "  }\n" +
+            "}";
+
+    public static final String ERROR_SINGLE_RESPONSE_SERVER =
+            "{\n" +
+            "  \"error\": {\n" +
+            "    \"message\": \"Some Server Error\",\n" +
+            "    \"code\": 2\n" +
+            "  }\n" +
+            "}";
+
+    public static final String ERROR_SINGLE_RESPONSE_PERMISSION =
+            "{\n" +
+            "  \"error\": {\n" +
+            "    \"type\": \"OAuthException\",\n" +
+            "    \"message\": \"(#200) Requires extended permission: publish_actions\",\n" +
+            "    \"code\": 200\n" +
+            "  }\n" +
+            "}";
+
+    public static final String ERROR_SINGLE_RESPONSE_WEB_LOGIN =
+            "{\n" +
+            "  \"error\": {\n" +
+            "    \"message\": \"User need to login\",\n" +
+            "    \"type\": \"OAuthException\",\n" +
+            "    \"code\": 102,\n" +
+            "    \"error_subcode\": 459\n" +
+            "  }\n" +
+            "}";
+
+    public static final String ERROR_SINGLE_RESPONSE_RELOGIN =
+            "{\n" +
+            "  \"error\": {\n" +
+            "    \"message\": \"User need to relogin\",\n" +
+            "    \"type\": \"OAuthException\",\n" +
+            "    \"code\": 102\n" +
+            "  }\n" +
+            "}";
+
+    public static final String ERROR_SINGLE_RESPONSE_RELOGIN_DELETED_APP =
+            "{\n" +
+            "  \"error\": {\n" +
+            "    \"message\": \"User need to relogin\",\n" +
+            "    \"type\": \"OAuthException\",\n" +
+            "    \"code\": 190,\n" +
+            "    \"error_subcode\": 458\n" +
+            "  }\n" +
+            "}";
+
+    public void testClientException() {
+        final String errorMsg = "some error happened";
+        FacebookRequestError error = new FacebookRequestError(null, new FacebookException(errorMsg));
+        assertEquals(errorMsg, error.getErrorMessage());
+        assertEquals(FacebookRequestError.Category.CLIENT, error.getCategory());
+        assertEquals(FacebookRequestError.INVALID_ERROR_CODE, error.getErrorCode());
+        assertEquals(FacebookRequestError.INVALID_HTTP_STATUS_CODE, error.getRequestStatusCode());
+        assertEquals(0, error.getUserActionMessageId());
+    }
+
+    public void testSingleRequestWithoutBody() throws JSONException {
+        JSONObject withStatusCode = new JSONObject();
+        withStatusCode.put("code", 400);
+        FacebookRequestError error =
+                FacebookRequestError.checkResponseAndCreateError(withStatusCode, withStatusCode, null);
+        assertNotNull(error);
+        assertEquals(400, error.getRequestStatusCode());
+        assertEquals(FacebookRequestError.Category.BAD_REQUEST, error.getCategory());
+        assertEquals(0, error.getUserActionMessageId());
+    }
+
+    public void testSingleErrorWithBody() throws JSONException {
+        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE);
+        JSONObject withStatusCodeAndBody = new JSONObject();
+        withStatusCodeAndBody.put("code", 400);
+        withStatusCodeAndBody.put("body", originalResponse);
+        FacebookRequestError error =
+                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+        assertNotNull(error);
+        assertEquals(400, error.getRequestStatusCode());
+        assertEquals("Unknown path components: /unknown", error.getErrorMessage());
+        assertEquals("OAuthException", error.getErrorType());
+        assertEquals(2500, error.getErrorCode());
+        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
+        assertEquals(FacebookRequestError.Category.BAD_REQUEST, error.getCategory());
+        assertEquals(0, error.getUserActionMessageId());
+    }
+
+    public void testBatchRequest() throws JSONException {
+        JSONArray batchResponse = new JSONArray(ERROR_BATCH_RESPONSE);
+        assertEquals(2, batchResponse.length());
+        JSONObject firstResponse = (JSONObject) batchResponse.get(0);
+        FacebookRequestError error =
+                FacebookRequestError.checkResponseAndCreateError(firstResponse, batchResponse, null);
+        assertNotNull(error);
+        assertEquals(400, error.getRequestStatusCode());
+        assertEquals("An active access token must be used to query information about the current user.",
+                error.getErrorMessage());
+        assertEquals("OAuthException", error.getErrorType());
+        assertEquals(2500, error.getErrorCode());
+        assertTrue(error.getBatchRequestResult() instanceof  JSONArray);
+        assertEquals(FacebookRequestError.Category.BAD_REQUEST, error.getCategory());
+        assertEquals(0, error.getUserActionMessageId());
+    }
+
+    public void testSingleThrottledError() throws JSONException {
+        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_THROTTLE);
+        JSONObject withStatusCodeAndBody = new JSONObject();
+        withStatusCodeAndBody.put("code", 403);
+        withStatusCodeAndBody.put("body", originalResponse);
+        FacebookRequestError error =
+                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+        assertNotNull(error);
+        assertEquals(403, error.getRequestStatusCode());
+        assertEquals("Application request limit reached", error.getErrorMessage());
+        assertNull(error.getErrorType());
+        assertEquals(4, error.getErrorCode());
+        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
+        assertEquals(FacebookRequestError.Category.THROTTLING, error.getCategory());
+        assertEquals(0, error.getUserActionMessageId());
+    }
+
+    public void testSingleServerError() throws JSONException {
+        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_SERVER);
+        JSONObject withStatusCodeAndBody = new JSONObject();
+        withStatusCodeAndBody.put("code", 500);
+        withStatusCodeAndBody.put("body", originalResponse);
+        FacebookRequestError error =
+                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+        assertNotNull(error);
+        assertEquals(500, error.getRequestStatusCode());
+        assertEquals("Some Server Error", error.getErrorMessage());
+        assertNull(error.getErrorType());
+        assertEquals(2, error.getErrorCode());
+        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
+        assertEquals(FacebookRequestError.Category.SERVER, error.getCategory());
+        assertEquals(0, error.getUserActionMessageId());
+    }
+
+    public void testSinglePermissionError() throws JSONException {
+        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_PERMISSION);
+        JSONObject withStatusCodeAndBody = new JSONObject();
+        withStatusCodeAndBody.put("code", 400);
+        withStatusCodeAndBody.put("body", originalResponse);
+        FacebookRequestError error =
+                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+        assertNotNull(error);
+        assertEquals(400, error.getRequestStatusCode());
+        assertEquals("(#200) Requires extended permission: publish_actions", error.getErrorMessage());
+        assertEquals("OAuthException", error.getErrorType());
+        assertEquals(200, error.getErrorCode());
+        assertEquals(FacebookRequestError.INVALID_ERROR_CODE, error.getSubErrorCode());
+        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
+        assertEquals(FacebookRequestError.Category.PERMISSION, error.getCategory());
+        assertEquals(R.string.com_facebook_requesterror_permissions, error.getUserActionMessageId());
+    }
+
+    public void testSingleWebLoginError() throws JSONException {
+        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_WEB_LOGIN);
+        JSONObject withStatusCodeAndBody = new JSONObject();
+        withStatusCodeAndBody.put("code", 400);
+        withStatusCodeAndBody.put("body", originalResponse);
+        FacebookRequestError error =
+                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+        assertNotNull(error);
+        assertEquals(400, error.getRequestStatusCode());
+        assertEquals("User need to login", error.getErrorMessage());
+        assertEquals("OAuthException", error.getErrorType());
+        assertEquals(102, error.getErrorCode());
+        assertEquals(459, error.getSubErrorCode());
+        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
+        assertEquals(FacebookRequestError.Category.AUTHENTICATION_RETRY, error.getCategory());
+        assertEquals(R.string.com_facebook_requesterror_web_login, error.getUserActionMessageId());
+    }
+
+    public void testSingleReloginError() throws JSONException {
+        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_RELOGIN);
+        JSONObject withStatusCodeAndBody = new JSONObject();
+        withStatusCodeAndBody.put("code", 400);
+        withStatusCodeAndBody.put("body", originalResponse);
+        FacebookRequestError error =
+                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+        assertNotNull(error);
+        assertEquals(400, error.getRequestStatusCode());
+        assertEquals("User need to relogin", error.getErrorMessage());
+        assertEquals("OAuthException", error.getErrorType());
+        assertEquals(102, error.getErrorCode());
+        assertEquals(FacebookRequestError.INVALID_ERROR_CODE, error.getSubErrorCode());
+        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
+        assertEquals(FacebookRequestError.Category.AUTHENTICATION_REOPEN_SESSION, error.getCategory());
+        assertEquals(R.string.com_facebook_requesterror_reconnect, error.getUserActionMessageId());
+    }
+
+    public void testSingleReloginDeletedAppError() throws JSONException {
+        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_RELOGIN_DELETED_APP);
+        JSONObject withStatusCodeAndBody = new JSONObject();
+        withStatusCodeAndBody.put("code", 400);
+        withStatusCodeAndBody.put("body", originalResponse);
+        FacebookRequestError error =
+                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
+        assertNotNull(error);
+        assertEquals(400, error.getRequestStatusCode());
+        assertEquals("User need to relogin", error.getErrorMessage());
+        assertEquals("OAuthException", error.getErrorType());
+        assertEquals(190, error.getErrorCode());
+        assertEquals(458, error.getSubErrorCode());
+        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
+        assertEquals(FacebookRequestError.Category.AUTHENTICATION_REOPEN_SESSION, error.getCategory());
+        assertEquals(R.string.com_facebook_requesterror_relogin, error.getUserActionMessageId());
+    }
+}
diff --git a/facebook/tests/src/com/facebook/FacebookTestCase.java b/facebook/tests/src/com/facebook/FacebookTestCase.java
new file mode 100644
index 000000000..88e28c4a7
--- /dev/null
+++ b/facebook/tests/src/com/facebook/FacebookTestCase.java
@@ -0,0 +1,31 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.app.Activity;
+
+public class FacebookTestCase extends FacebookActivityTestCase<FacebookTestCase.FacebookTestActivity> {
+    public FacebookTestCase() {
+        super(FacebookTestCase.FacebookTestActivity.class);
+        Settings.addLoggingBehavior(LoggingBehavior.REQUESTS);
+        Settings.addLoggingBehavior(LoggingBehavior.INCLUDE_RAW_RESPONSES);
+    }
+
+    public static class FacebookTestActivity extends Activity {
+    }
+}
+
diff --git a/facebook/tests/src/com/facebook/GraphRequestTests.java b/facebook/tests/src/com/facebook/GraphRequestTests.java
new file mode 100644
index 000000000..0f4212164
--- /dev/null
+++ b/facebook/tests/src/com/facebook/GraphRequestTests.java
@@ -0,0 +1,90 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.test.suitebuilder.annotation.LargeTest;
+import com.facebook.model.GraphObject;
+
+import java.util.Date;
+
+// These tests relate to serialization/de-serialization of graph objects in a variety of scenarios, rather than
+// to the underlying request/batch plumbing.
+public class GraphRequestTests extends FacebookTestCase {
+
+    @LargeTest
+    public void testCommentRoundTrip() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        GraphObject status = createStatusUpdate();
+        GraphObject createdStatus = batchCreateAndGet(session, "me/feed", status, null, GraphObject.class);
+        String statusID = (String) createdStatus.getProperty("id");
+
+        GraphObject comment = GraphObject.Factory.create();
+        final String commentMessage = "It truly is a wonderful status update.";
+        comment.setProperty("message", commentMessage);
+
+        GraphObject createdComment1 = batchCreateAndGet(session, statusID + "/comments", comment, null,
+                GraphObject.class);
+        assertNotNull(createdComment1);
+
+        String comment1ID = (String) createdComment1.getProperty("id");
+        String comment1Message = (String) createdComment1.getProperty("message");
+        assertNotNull(comment1ID);
+        assertNotNull(comment1Message);
+        assertEquals(commentMessage, comment1Message);
+
+        // Try posting the same comment to the same status update. We need to clear its ID first.
+        createdComment1.removeProperty("id");
+        GraphObject createdComment2 = batchCreateAndGet(session, statusID + "/comments", createdComment1, null,
+                GraphObject.class);
+        assertNotNull(createdComment2);
+
+        String comment2ID = (String) createdComment2.getProperty("id");
+        String comment2Message = (String) createdComment2.getProperty("message");
+        assertNotNull(comment2ID);
+        assertFalse(comment1ID.equals(comment2ID));
+        assertNotNull(comment2Message);
+        assertEquals(commentMessage, comment2Message);
+    }
+
+    @LargeTest
+    public void testEventRoundTrip() {
+        TestSession session = openTestSessionWithSharedUserAndPermissions(null, "create_event");
+
+        GraphObject event = GraphObject.Factory.create();
+        // Android emulators tend to not have the right date/time. To avoid issues with posting events in the past
+        // or too far in the future, we use a constant year. This test will break in 2030, angering our robot overlords.
+        Date startTime = new Date(130, 2, 17, 12, 34, 56);
+        event.setProperty("name", "My awesome St. Patrick's Day party on " + startTime.toString());
+        final String eventDescription = "This is a great event. You should all come.";
+        event.setProperty("description", eventDescription);
+        Date endTime = new Date(startTime.getTime() + 3600 * 1000);
+        event.setProperty("start_time", startTime);
+        event.setProperty("end_time", endTime);
+        event.setProperty("location", "My house");
+
+        GraphObject event1 = batchCreateAndGet(session, "me/events", event, null, GraphObject.class);
+        assertNotNull(event1);
+        assertEquals(eventDescription, event1.getProperty("description"));
+
+        event1.removeProperty("id");
+        GraphObject event2 = batchCreateAndGet(session, "me/events", event1, null, GraphObject.class);
+        assertNotNull(event2);
+        assertEquals(eventDescription, event2.getProperty("description"));
+    }
+
+}
diff --git a/facebook/tests/src/com/facebook/RequestTests.java b/facebook/tests/src/com/facebook/RequestTests.java
new file mode 100644
index 000000000..f91eab2cd
--- /dev/null
+++ b/facebook/tests/src/com/facebook/RequestTests.java
@@ -0,0 +1,684 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.graphics.Bitmap;
+import android.location.Location;
+import android.net.Uri;
+import android.os.Bundle;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.model.*;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.URISyntaxException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class RequestTests extends FacebookTestCase {
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreateRequest() {
+        Request request = new Request();
+        assertTrue(request != null);
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreatePostRequest() {
+        GraphObject graphObject = GraphObject.Factory.create();
+        Request request = Request.newPostRequest(null, "me/statuses", graphObject, null);
+        assertTrue(request != null);
+        assertEquals(HttpMethod.POST, request.getHttpMethod());
+        assertEquals("me/statuses", request.getGraphPath());
+        assertEquals(graphObject, request.getGraphObject());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreateMeRequest() {
+        Request request = Request.newMeRequest(null, null);
+        assertTrue(request != null);
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+        assertEquals("me", request.getGraphPath());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreateMyFriendsRequest() {
+        Request request = Request.newMyFriendsRequest(null, null);
+        assertTrue(request != null);
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+        assertEquals("me/friends", request.getGraphPath());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreateUploadPhotoRequest() {
+        Bitmap image = Bitmap.createBitmap(128, 128, Bitmap.Config.ALPHA_8);
+
+        Request request = Request.newUploadPhotoRequest(null, image, null);
+        assertTrue(request != null);
+
+        Bundle parameters = request.getParameters();
+        assertTrue(parameters != null);
+
+        assertTrue(parameters.containsKey("picture"));
+        assertEquals(image, parameters.getParcelable("picture"));
+        assertEquals("me/photos", request.getGraphPath());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreatePlacesSearchRequestWithLocation() {
+        Location location = new Location("");
+        location.setLatitude(47.6204);
+        location.setLongitude(-122.3491);
+
+        Request request = Request.newPlacesSearchRequest(null, location, 1000, 50, null, null);
+
+        assertTrue(request != null);
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+        assertEquals("search", request.getGraphPath());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreatePlacesSearchRequestWithSearchText() {
+        Request request = Request.newPlacesSearchRequest(null, null, 1000, 50, "Starbucks", null);
+
+        assertTrue(request != null);
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+        assertEquals("search", request.getGraphPath());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreatePlacesSearchRequestRequiresLocationOrSearchText() {
+        try {
+            Request request = Request.newPlacesSearchRequest(null, null, 1000, 50, null, null);
+            fail("expected exception");
+        } catch (FacebookException exception) {
+            // Success
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testSetHttpMethodToNilGivesDefault() {
+        Request request = new Request();
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+
+        request.setHttpMethod(null);
+        assertEquals(HttpMethod.GET, request.getHttpMethod());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testExecuteBatchWithNullRequestsThrows() {
+        try {
+            Request.executeBatchAndWait((Request[]) null);
+            fail("expected NullPointerException");
+        } catch (NullPointerException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testExecuteBatchWithZeroRequestsThrows() {
+        try {
+            Request.executeBatchAndWait(new Request[]{});
+            fail("expected IllegalArgumentException");
+        } catch (IllegalArgumentException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testExecuteBatchWithNullRequestThrows() {
+        try {
+            Request.executeBatchAndWait(new Request[]{null});
+            fail("expected NullPointerException");
+        } catch (NullPointerException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testToHttpConnectionWithNullRequestsThrows() {
+        try {
+            Request.toHttpConnection((Request[]) null);
+            fail("expected NullPointerException");
+        } catch (NullPointerException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testToHttpConnectionWithZeroRequestsThrows() {
+        try {
+            Request.toHttpConnection(new Request[]{});
+            fail("expected IllegalArgumentException");
+        } catch (IllegalArgumentException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testToHttpConnectionWithNullRequestThrows() {
+        try {
+            Request.toHttpConnection(new Request[]{null});
+            fail("expected NullPointerException");
+        } catch (NullPointerException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testSingleGetToHttpRequest() throws Exception {
+        Request requestMe = new Request(null, "TourEiffel");
+        HttpURLConnection connection = Request.toHttpConnection(requestMe);
+
+        assertTrue(connection != null);
+
+        assertEquals("GET", connection.getRequestMethod());
+        assertEquals("/TourEiffel", connection.getURL().getPath());
+
+        assertTrue(connection.getRequestProperty("User-Agent").startsWith("FBAndroidSDK"));
+
+        Uri uri = Uri.parse(connection.getURL().toString());
+        assertEquals("android", uri.getQueryParameter("sdk"));
+        assertEquals("json", uri.getQueryParameter("format"));
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecuteSingleGet() {
+        Request request = new Request(null, "TourEiffel");
+        Response response = request.executeAndWait();
+
+        assertTrue(response != null);
+        assertTrue(response.getError() == null);
+        assertTrue(response.getGraphObject() != null);
+
+        GraphPlace graphPlace = response.getGraphObjectAs(GraphPlace.class);
+        assertEquals("Paris", graphPlace.getLocation().getCity());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecuteSingleGetUsingHttpURLConnection() throws IOException {
+        Request request = new Request(null, "TourEiffel");
+        HttpURLConnection connection = Request.toHttpConnection(request);
+
+        List<Response> responses = Request.executeConnectionAndWait(connection, Arrays.asList(new Request[]{request}));
+        assertNotNull(responses);
+        assertEquals(1, responses.size());
+
+        Response response = responses.get(0);
+
+        assertTrue(response != null);
+        assertTrue(response.getError() == null);
+        assertTrue(response.getGraphObject() != null);
+
+        GraphPlace graphPlace = response.getGraphObjectAs(GraphPlace.class);
+        assertEquals("Paris", graphPlace.getLocation().getCity());
+
+        // Make sure calling code can still access HTTP headers and call disconnect themselves.
+        int code = connection.getResponseCode();
+        assertEquals(200, code);
+        assertTrue(connection.getHeaderFields().keySet().contains("Content-Length"));
+        connection.disconnect();
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testFacebookErrorResponseCreatesError() {
+        Request request = new Request(null, "somestringthatshouldneverbeavalidfobjectid");
+        Response response = request.executeAndWait();
+
+        assertTrue(response != null);
+
+        FacebookRequestError error = response.getError();
+        assertNotNull(error);
+        FacebookException exception = error.getException();
+        assertNotNull(exception);
+
+        assertTrue(exception instanceof FacebookServiceException);
+        assertNotNull(error.getErrorType());
+        assertTrue(error.getErrorCode() != FacebookRequestError.INVALID_ERROR_CODE);
+        assertNotNull(error.getRequestResultBody());
+    }
+
+    @LargeTest
+    public void testFacebookSuccessResponseWithErrorCodeCreatesError() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request request = Request.newRestRequest(session, "auth.extendSSOAccessToken", null, null);
+        assertNotNull(request);
+
+        // Because TestSession access tokens were not created via SSO, we expect to get an error from the service,
+        // but with a 200 (success) code.
+        Response response = request.executeAndWait();
+
+        assertTrue(response != null);
+
+        FacebookRequestError error = response.getError();
+        assertNotNull(error);
+
+        assertTrue(error.getException() instanceof FacebookServiceException);
+        assertTrue(error.getErrorCode() != FacebookRequestError.INVALID_ERROR_CODE);
+        assertNotNull(error.getRequestResultBody());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testRequestWithUnopenedSessionFails() {
+        TestSession session = getTestSessionWithSharedUser(null);
+        Request request = new Request(session, "me");
+        Response response = request.executeAndWait();
+
+        assertNotNull(response.getError());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecuteRequestMe() {
+        TestSession session = openTestSessionWithSharedUser();
+        Request request = Request.newMeRequest(session, null);
+        Response response = request.executeAndWait();
+
+        validateMeResponse(session, response);
+    }
+
+    static void validateMeResponse(TestSession session, Response response) {
+        assertNull(response.getError());
+
+        GraphUser me = response.getGraphObjectAs(GraphUser.class);
+        assertNotNull(me);
+        assertEquals(session.getTestUserId(), me.getId());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecuteMyFriendsRequest() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Request request = Request.newMyFriendsRequest(session, null);
+        Response response = request.executeAndWait();
+
+        validateMyFriendsResponse(session, response);
+    }
+
+    static void validateMyFriendsResponse(TestSession session, Response response) {
+        assertNotNull(response);
+
+        assertNull(response.getError());
+
+        GraphMultiResult graphResult = response.getGraphObjectAs(GraphMultiResult.class);
+        assertNotNull(graphResult);
+
+        List<GraphObject> results = graphResult.getData();
+        assertNotNull(results);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecutePlaceRequestWithLocation() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Location location = new Location("");
+        location.setLatitude(47.6204);
+        location.setLongitude(-122.3491);
+
+        Request request = Request.newPlacesSearchRequest(session, location, 5, 5, null, null);
+        Response response = request.executeAndWait();
+        assertNotNull(response);
+
+        assertNull(response.getError());
+
+        GraphMultiResult graphResult = response.getGraphObjectAs(GraphMultiResult.class);
+        assertNotNull(graphResult);
+
+        List<GraphObject> results = graphResult.getData();
+        assertNotNull(results);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecutePlaceRequestWithSearchText() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        // Pass a distance without a location to ensure it is correctly ignored.
+        Request request = Request.newPlacesSearchRequest(session, null, 1000, 5, "Starbucks", null);
+        Response response = request.executeAndWait();
+        assertNotNull(response);
+
+        assertNull(response.getError());
+
+        GraphMultiResult graphResult = response.getGraphObjectAs(GraphMultiResult.class);
+        assertNotNull(graphResult);
+
+        List<GraphObject> results = graphResult.getData();
+        assertNotNull(results);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testExecutePlaceRequestWithLocationAndSearchText() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Location location = new Location("");
+        location.setLatitude(47.6204);
+        location.setLongitude(-122.3491);
+
+        Request request = Request.newPlacesSearchRequest(session, location, 1000, 5, "Starbucks", null);
+        Response response = request.executeAndWait();
+        assertNotNull(response);
+
+        assertNull(response.getError());
+
+        GraphMultiResult graphResult = response.getGraphObjectAs(GraphMultiResult.class);
+        assertNotNull(graphResult);
+
+        List<GraphObject> results = graphResult.getData();
+        assertNotNull(results);
+    }
+
+    @LargeTest
+    public void testExecuteUploadPhoto() {
+        TestSession session = openTestSessionWithSharedUser();
+        Bitmap image = createTestBitmap(128);
+
+        Request request = Request.newUploadPhotoRequest(session, image, null);
+        Response response = request.executeAndWait();
+        assertNotNull(response);
+
+        assertNull(response.getError());
+
+        GraphObject result = response.getGraphObject();
+        assertNotNull(result);
+    }
+
+    @LargeTest
+    public void testExecuteUploadPhotoViaFile() throws IOException {
+        File outputFile = null;
+        FileOutputStream outStream = null;
+
+        try {
+            TestSession session = openTestSessionWithSharedUser();
+            Bitmap image = createTestBitmap(128);
+
+            File outputDir = getActivity().getCacheDir(); // context being the Activity pointer
+            outputFile = File.createTempFile("prefix", "extension", outputDir);
+
+            outStream = new FileOutputStream(outputFile);
+            image.compress(Bitmap.CompressFormat.PNG, 100, outStream);
+            outStream.close();
+            outStream = null;
+
+            Request request = Request.newUploadPhotoRequest(session, outputFile, null);
+            Response response = request.executeAndWait();
+            assertNotNull(response);
+
+            assertNull(response.getError());
+
+            GraphObject result = response.getGraphObject();
+            assertNotNull(result);
+        } finally {
+            if (outStream != null) {
+                outStream.close();
+            }
+            if (outputFile != null) {
+                outputFile.delete();
+            }
+        }
+    }
+
+    @LargeTest
+    public void testUploadVideoFile() throws IOException, URISyntaxException {
+        File tempFile = null;
+        try {
+            TestSession session = openTestSessionWithSharedUser();
+            tempFile = createTempFileFromAsset("DarkScreen.mov");
+
+            Request request = Request.newUploadVideoRequest(session, tempFile, null);
+            Response response = request.executeAndWait();
+            assertNotNull(response);
+
+            assertNull(response.getError());
+
+            GraphObject result = response.getGraphObject();
+            assertNotNull(result);
+        } catch (Exception ex) {
+            return;
+        } finally {
+            if (tempFile != null) {
+                tempFile.delete();
+            }
+        }
+    }
+
+    @LargeTest
+    public void testPostStatusUpdate() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        GraphObject statusUpdate = createStatusUpdate();
+
+        GraphObject retrievedStatusUpdate = postGetAndAssert(session, "me/feed", statusUpdate);
+
+        assertEquals(statusUpdate.getProperty("message"), retrievedStatusUpdate.getProperty("message"));
+    }
+
+    @LargeTest
+    public void testRestMethodGetUser() {
+        TestSession session = openTestSessionWithSharedUser();
+        String testUserId = session.getTestUserId();
+
+        Bundle parameters = new Bundle();
+        parameters.putString("uids", testUserId);
+        parameters.putString("fields", "uid,name");
+
+        Request request = Request.newRestRequest(session, "users.getInfo", parameters, null);
+        Response response = request.executeAndWait();
+        assertNotNull(response);
+
+        GraphObjectList<GraphObject> graphObjects = response.getGraphObjectList();
+        assertNotNull(graphObjects);
+        assertEquals(1, graphObjects.size());
+
+        GraphObject user = graphObjects.get(0);
+        assertNotNull(user);
+        assertEquals(testUserId, user.getProperty("uid").toString());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCallbackIsCalled() {
+        Request request = new Request(null, "4");
+
+        final ArrayList<Boolean> calledBack = new ArrayList<Boolean>();
+        request.setCallback(new Request.Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                calledBack.add(true);
+            }
+        });
+
+        Response response = request.executeAndWait();
+        assertNotNull(response);
+        assertTrue(calledBack.size() == 1);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testBatchTimeoutIsApplied() {
+        Request request = new Request(null, "me");
+        RequestBatch batch = new RequestBatch(request);
+
+        // We assume 1 ms is short enough to fail
+        batch.setTimeout(1);
+
+        List<Response> responses = Request.executeBatchAndWait(batch);
+        assertNotNull(responses);
+        assertTrue(responses.size() == 1);
+        Response response = responses.get(0);
+        assertNotNull(response);
+        assertNotNull(response.getError());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testBatchTimeoutCantBeNegative() {
+        try {
+            RequestBatch batch = new RequestBatch();
+            batch.setTimeout(-1);
+            fail();
+        } catch (IllegalArgumentException ex) {
+        }
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCantSetBothGraphPathAndRestMethod() {
+        Request request = new Request();
+        request.setGraphPath("me");
+        request.setRestMethod("amethod");
+        request.setCallback(new ExpectFailureCallback());
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(request);
+        task.executeOnBlockerThread();
+
+        waitAndAssertSuccess(1);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testClosedSessionDoesntAppendAccessToken() {
+        TestSession session = openTestSessionWithSharedUser();
+        session.close();
+        Request request = new Request(session, "me", null, null, new ExpectFailureCallback());
+
+        TestRequestAsyncTask task = new TestRequestAsyncTask(request);
+        task.executeOnBlockerThread();
+
+        waitAndAssertSuccess(1);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCantUseComplexParameterInGetRequest() {
+        TestSession session = openTestSessionWithSharedUser();
+
+        Bundle parameters = new Bundle();
+        parameters.putShortArray("foo", new short[1]);
+
+        Request request = new Request(session, "me", parameters, HttpMethod.GET, new ExpectFailureCallback());
+        Response response = request.executeAndWait();
+
+        FacebookRequestError error = response.getError();
+        assertNotNull(error);
+        FacebookException exception = error.getException();
+        assertNotNull(exception);
+        assertTrue(exception.getMessage().contains("short[]"));
+    }
+
+    private final Location SEATTLE_LOCATION = new Location("") {
+        {
+            setLatitude(47.6097);
+            setLongitude(-122.3331);
+        }
+    };
+
+    @LargeTest
+    public void testPaging() {
+        TestSession session = openTestSessionWithSharedUser();
+        final List<GraphPlace> returnedPlaces = new ArrayList<GraphPlace>();
+        Request request = Request
+                .newPlacesSearchRequest(session, SEATTLE_LOCATION, 1000, 5, null, new Request.GraphPlaceListCallback() {
+                    @Override
+                    public void onCompleted(List<GraphPlace> places, Response response) {
+                        returnedPlaces.addAll(places);
+                    }
+                });
+        Response response = request.executeAndWait();
+
+        assertNull(response.getError());
+        assertNotNull(response.getGraphObject());
+        assertNotSame(0, returnedPlaces.size());
+
+        returnedPlaces.clear();
+
+        Request nextRequest = response.getRequestForPagedResults(Response.PagingDirection.NEXT);
+        assertNotNull(nextRequest);
+
+        nextRequest.setCallback(request.getCallback());
+        response = nextRequest.executeAndWait();
+
+        assertNull(response.getError());
+        assertNotNull(response.getGraphObject());
+        assertNotSame(0, returnedPlaces.size());
+
+        returnedPlaces.clear();
+
+        Request previousRequest = response.getRequestForPagedResults(Response.PagingDirection.PREVIOUS);
+        assertNotNull(previousRequest);
+
+        previousRequest.setCallback(request.getCallback());
+        response = previousRequest.executeAndWait();
+
+        assertNull(response.getError());
+        assertNotNull(response.getGraphObject());
+        assertNotSame(0, returnedPlaces.size());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testRequestWithClosedSessionThrowsException() {
+        TestSession session = getTestSessionWithSharedUser();
+        assertFalse(session.isOpened());
+
+        Request request = new Request(session, "4");
+        Response response = request.executeAndWait();
+
+        assertNotNull(response.getError());
+    }
+}
diff --git a/facebook/tests/src/com/facebook/SessionTests.java b/facebook/tests/src/com/facebook/SessionTests.java
new file mode 100644
index 000000000..01a794464
--- /dev/null
+++ b/facebook/tests/src/com/facebook/SessionTests.java
@@ -0,0 +1,818 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.support.v4.content.LocalBroadcastManager;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.internal.Utility;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+
+public class SessionTests extends SessionTestsBase {
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        new SharedPreferencesTokenCachingStrategy(getActivity()).clear();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testFailNullArguments() {
+        try {
+            new Session(null);
+
+            // Should not get here
+            assertFalse(true);
+        } catch (NullPointerException e) {
+            // got expected exception
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testActiveSessionChangeRegistration() {
+        final WaitForBroadcastReceiver receiver0 = new WaitForBroadcastReceiver();
+        final WaitForBroadcastReceiver receiver1 = new WaitForBroadcastReceiver();
+        final WaitForBroadcastReceiver receiver2 = new WaitForBroadcastReceiver();
+        final LocalBroadcastManager broadcastManager = LocalBroadcastManager.getInstance(getActivity());
+
+        try {
+            // Register these on the blocker thread so they will send
+            // notifications there as well. The notifications need to be on a
+            // different thread than the progress.
+            Runnable initialize0 = new Runnable() {
+                @Override
+                public void run() {
+                    broadcastManager.registerReceiver(receiver0, getActiveSessionAllFilter());
+
+                    broadcastManager.registerReceiver(receiver1,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_SET));
+                    broadcastManager.registerReceiver(receiver1,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
+                    broadcastManager.registerReceiver(receiver1,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_CLOSED));
+
+                    broadcastManager.registerReceiver(receiver2,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
+                    broadcastManager.registerReceiver(receiver2,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_CLOSED));
+                }
+            };
+            runOnBlockerThread(initialize0, true);
+
+            // Verify all actions show up where they are expected
+            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver1, receiver2);
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
+            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver1, receiver2);
+
+            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver1, receiver2);
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_CLOSED);
+            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver1, receiver2);
+
+            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver1);
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_SET);
+            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver1);
+
+            receiver0.incrementExpectCount();
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_UNSET);
+            receiver0.waitForExpectedCalls();
+
+            // Remove receiver1 and verify actions continue to show up where
+            // expected
+            broadcastManager.unregisterReceiver(receiver1);
+
+            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver2);
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
+            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver2);
+
+            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver2);
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_CLOSED);
+            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver2);
+
+            receiver0.incrementExpectCount();
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_SET);
+            receiver0.waitForExpectedCalls();
+
+            receiver0.incrementExpectCount();
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_UNSET);
+            receiver0.waitForExpectedCalls();
+
+            // Remove receiver0 and register receiver1 multiple times for one
+            // action
+            broadcastManager.unregisterReceiver(receiver0);
+
+            Runnable initialize1 = new Runnable() {
+                @Override
+                public void run() {
+                    broadcastManager.registerReceiver(receiver1,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
+                    broadcastManager.registerReceiver(receiver1,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
+                    broadcastManager.registerReceiver(receiver1,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
+                }
+            };
+            runOnBlockerThread(initialize1, true);
+
+            receiver1.incrementExpectCount(3);
+            receiver2.incrementExpectCount();
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
+            receiver1.waitForExpectedCalls();
+            receiver2.waitForExpectedCalls();
+
+            receiver2.incrementExpectCount();
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_CLOSED);
+            receiver2.waitForExpectedCalls();
+
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_SET);
+            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_UNSET);
+
+            closeBlockerAndAssertSuccess();
+        } finally {
+            broadcastManager.unregisterReceiver(receiver0);
+            broadcastManager.unregisterReceiver(receiver1);
+            broadcastManager.unregisterReceiver(receiver2);
+            Session.setActiveSession(null);
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testSetActiveSession() {
+        Session.setActiveSession(null);
+
+        final WaitForBroadcastReceiver receiverOpened = new WaitForBroadcastReceiver();
+        final WaitForBroadcastReceiver receiverClosed = new WaitForBroadcastReceiver();
+        final WaitForBroadcastReceiver receiverSet = new WaitForBroadcastReceiver();
+        final WaitForBroadcastReceiver receiverUnset = new WaitForBroadcastReceiver();
+        final LocalBroadcastManager broadcastManager = LocalBroadcastManager.getInstance(getActivity());
+
+        try {
+            Runnable initializeOnBlockerThread = new Runnable() {
+                @Override
+                public void run() {
+                    broadcastManager.registerReceiver(receiverOpened,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
+                    broadcastManager.registerReceiver(receiverClosed,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_CLOSED));
+                    broadcastManager.registerReceiver(receiverSet,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_SET));
+                    broadcastManager.registerReceiver(receiverUnset,
+                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_UNSET));
+                }
+            };
+            runOnBlockerThread(initializeOnBlockerThread, true);
+
+            // null -> null should not fire events
+            assertEquals(null, Session.getActiveSession());
+            Session.setActiveSession(null);
+            assertEquals(null, Session.getActiveSession());
+
+            Session session0 = new Session.Builder(getActivity()).
+                    setApplicationId("FakeAppId").
+                    setTokenCachingStrategy(new MockTokenCachingStrategy()).
+                    build();
+            assertEquals(SessionState.CREATED_TOKEN_LOADED, session0.getState());
+
+            // For unopened session, we should only see the Set event.
+            receiverSet.incrementExpectCount();
+            Session.setActiveSession(session0);
+            assertEquals(session0, Session.getActiveSession());
+            receiverSet.waitForExpectedCalls();
+
+            // When we open it, then we should see the Opened event.
+            receiverOpened.incrementExpectCount();
+            session0.openForRead(null);
+            receiverOpened.waitForExpectedCalls();
+
+            // Setting to itself should not fire events
+            Session.setActiveSession(session0);
+            assertEquals(session0, Session.getActiveSession());
+
+            // Setting from one opened session to another should deliver a full
+            // cycle of events
+            WaitForBroadcastReceiver.incrementExpectCounts(receiverClosed, receiverUnset, receiverSet, receiverOpened);
+            Session session1 = new Session.Builder(getActivity()).
+                    setApplicationId("FakeAppId").
+                    setTokenCachingStrategy(new MockTokenCachingStrategy()).
+                    build();
+            assertEquals(SessionState.CREATED_TOKEN_LOADED, session1.getState());
+            session1.openForRead(null);
+            assertEquals(SessionState.OPENED, session1.getState());
+            Session.setActiveSession(session1);
+            WaitForBroadcastReceiver.waitForExpectedCalls(receiverClosed, receiverUnset, receiverSet, receiverOpened);
+            assertEquals(SessionState.CLOSED, session0.getState());
+            assertEquals(session1, Session.getActiveSession());
+
+            closeBlockerAndAssertSuccess();
+        } finally {
+            broadcastManager.unregisterReceiver(receiverOpened);
+            broadcastManager.unregisterReceiver(receiverClosed);
+            broadcastManager.unregisterReceiver(receiverSet);
+            broadcastManager.unregisterReceiver(receiverUnset);
+            Session.setActiveSession(null);
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenSuccess() {
+        ArrayList<String> permissions = new ArrayList<String>();
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+        AccessToken openToken = AccessToken
+                .createFromString("A token of thanks", permissions, AccessTokenSource.TEST_USER);
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        session.addAuthorizeResult(openToken);
+        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        verifySessionHasToken(session, openToken);
+
+        // Verify we get a close callback.
+        session.close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Verify we saved the token to cache.
+        assertTrue(cache.getSavedState() != null);
+        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenForPublishSuccess() {
+        ArrayList<String> permissions = new ArrayList<String>();
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+        AccessToken openToken = AccessToken
+                .createFromString("A token of thanks", permissions, AccessTokenSource.TEST_USER);
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        session.addAuthorizeResult(openToken);
+        session.openForPublish(new Session.OpenRequest(getActivity()).setCallback(statusRecorder).
+                setPermissions(Arrays.asList(new String[]{
+                        "publish_something",
+                        "manage_something",
+                        "ads_management",
+                        "create_event",
+                        "rsvp_event"
+                })));
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        verifySessionHasToken(session, openToken);
+
+        // Verify we get a close callback.
+        session.close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Verify we saved the token to cache.
+        assertTrue(cache.getSavedState() != null);
+        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenForPublishSuccessWithReadPermissions() {
+        ArrayList<String> permissions = new ArrayList<String>();
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+        AccessToken openToken = AccessToken
+                .createFromString("A token of thanks", permissions, AccessTokenSource.TEST_USER);
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        session.addAuthorizeResult(openToken);
+        session.openForPublish(new Session.OpenRequest(getActivity()).setCallback(statusRecorder).
+                setPermissions(Arrays.asList(new String[]{
+                        "publish_something",
+                        "manage_something",
+                        "ads_management",
+                        "create_event",
+                        "rsvp_event",
+                        "read_something"
+                })));
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        verifySessionHasToken(session, openToken);
+
+        // Verify we get a close callback.
+        session.close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Verify we saved the token to cache.
+        assertTrue(cache.getSavedState() != null);
+        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenFromTokenCache() {
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        String token = "A token less unique than most";
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(token, DEFAULT_TIMEOUT_MILLISECONDS);
+        ScriptedSession session = createScriptedSessionOnBlockerThread("app-id", cache);
+
+        // Verify state when we have a token in cache.
+        assertEquals(SessionState.CREATED_TOKEN_LOADED, session.getState());
+
+        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
+
+        // Verify we open with no authorize call.
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        // Verify no token information is saved.
+        assertTrue(cache.getSavedState() == null);
+
+        // Verify we get a close callback.
+        session.close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenActiveFromEmptyTokenCache() {
+        new SharedPreferencesTokenCachingStrategy(getActivity()).clear();
+
+        assertNull(Session.openActiveSessionFromCache(getActivity()));
+    }
+
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenFailure() {
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+        Exception openException = new Exception();
+
+        session.addAuthorizeResult(openException);
+        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+
+        // Verify we get the expected exception and no saved state.
+        statusRecorder.waitForCall(session, SessionState.CLOSED_LOGIN_FAILED, openException);
+        assertTrue(cache.getSavedState() == null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenForReadFailure() {
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+
+        try {
+            session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder).
+                    setPermissions(Arrays.asList(new String[]{"publish_something"})));
+            fail("should not reach here without an exception");
+        } catch (FacebookException e) {
+            assertTrue(e.getMessage().contains("Cannot pass a publish or manage permission"));
+        } finally {
+            stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+            statusRecorder.close();
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testRequestNewReadPermissionsSuccess() {
+        ArrayList<String> permissions = new ArrayList<String>();
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+
+        // Session.open
+        final AccessToken openToken = AccessToken
+                .createFromString("Allows playing outside", permissions, AccessTokenSource.TEST_USER);
+        permissions.add("play_outside");
+
+        session.addAuthorizeResult(openToken, "play_outside");
+        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        verifySessionHasToken(session, openToken);
+        assertTrue(cache.getSavedState() != null);
+        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
+
+        // Successful Session.reauthorize with new permissions
+        final AccessToken reauthorizeToken = AccessToken.createFromString(
+                "Allows playing outside and eating ice cream", permissions, AccessTokenSource.TEST_USER);
+        permissions.add("eat_ice_cream");
+
+        session.addAuthorizeResult(reauthorizeToken, "play_outside", "eat_ice_cream");
+        session.requestNewReadPermissions(new Session.NewPermissionsRequest(getActivity(), permissions));
+        statusRecorder.waitForCall(session, SessionState.OPENED_TOKEN_UPDATED, null);
+
+        verifySessionHasToken(session, reauthorizeToken);
+        assertTrue(cache.getSavedState() != null);
+        assertEquals(reauthorizeToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
+
+        // Failing reauthorization with new permissions
+        final Exception reauthorizeException = new Exception("Don't run with scissors");
+        permissions.add("run_with_scissors");
+
+        session.addAuthorizeResult(reauthorizeException);
+        session.requestNewReadPermissions(new Session.NewPermissionsRequest(getActivity(), permissions));
+        statusRecorder.waitForCall(session, SessionState.OPENED_TOKEN_UPDATED, reauthorizeException);
+
+        // Verify we do not overwrite cache if reauthorize fails
+        assertTrue(cache.getSavedState() != null);
+        assertEquals(reauthorizeToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorders.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testRequestNewPublishPermissionsSuccess() {
+        ArrayList<String> permissions = new ArrayList<String>();
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+
+        // Session.open
+        final AccessToken openToken = AccessToken
+                .createFromString("Allows playing outside", permissions, AccessTokenSource.TEST_USER);
+        permissions.add("play_outside");
+
+        session.addAuthorizeResult(openToken, "play_outside");
+        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        verifySessionHasToken(session, openToken);
+        assertTrue(cache.getSavedState() != null);
+        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
+
+        // Successful Session.reauthorize with new permissions
+        final AccessToken reauthorizeToken = AccessToken.createFromString(
+                "Allows playing outside and publish eating ice cream", permissions, AccessTokenSource.TEST_USER);
+        permissions.add("publish_eat_ice_cream");
+
+        session.addAuthorizeResult(reauthorizeToken, "play_outside", "publish_eat_ice_cream");
+        session.requestNewPublishPermissions(new Session.NewPermissionsRequest(getActivity(), permissions));
+        statusRecorder.waitForCall(session, SessionState.OPENED_TOKEN_UPDATED, null);
+
+        verifySessionHasToken(session, reauthorizeToken);
+        assertTrue(cache.getSavedState() != null);
+        assertEquals(reauthorizeToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
+
+        // Failing reauthorization with publish permissions on a read request
+        permissions.add("publish_run_with_scissors");
+
+        try {
+            session.requestNewReadPermissions(new Session.NewPermissionsRequest(getActivity(), permissions));
+            fail("Should not reach here without an exception");
+        } catch (FacebookException e) {
+            assertTrue(e.getMessage().contains("Cannot pass a publish or manage permission"));
+        } finally {
+            stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+            statusRecorder.close();
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenWithAccessToken() {
+        String token = "This is a fake token.";
+        Date expirationDate = new Date(new Date().getTime() + 3600 * 1000);
+        Date lastRefreshDate = new Date();
+        List<String> permissions = Arrays.asList(new String[]{"email", "publish_stream"});
+
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        AccessToken accessToken = AccessToken.createFromExistingAccessToken(token, expirationDate, lastRefreshDate,
+                AccessTokenSource.FACEBOOK_APPLICATION_WEB, permissions);
+        session.open(accessToken, statusRecorder);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        AccessToken expectedToken = new AccessToken(token, expirationDate, permissions,
+                AccessTokenSource.FACEBOOK_APPLICATION_WEB, lastRefreshDate);
+        verifySessionHasToken(session, expectedToken);
+
+        // Verify we get a close callback.
+        session.close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Verify we saved the token to cache.
+        assertTrue(cache.getSavedState() != null);
+        assertEquals(expectedToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenWithAccessTokenWithDefaults() {
+        String token = "This is a fake token.";
+
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        AccessToken accessToken = AccessToken.createFromExistingAccessToken(token, null, null, null, null);
+        session.open(accessToken, statusRecorder);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        assertEquals(token, session.getAccessToken());
+        assertEquals(new Date(Long.MAX_VALUE), session.getExpirationDate());
+        assertEquals(0, session.getPermissions().size());
+
+        // Verify we get a close callback.
+        session.close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Verify we saved the token to cache.
+        assertTrue(cache.getSavedState() != null);
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testSessionWillExtendTokenIfNeeded() {
+        TestSession session = openTestSessionWithSharedUser();
+        session.forceExtendAccessToken(true);
+
+        Request request = Request.newMeRequest(session, null);
+        request.executeAndWait();
+
+        assertTrue(session.getWasAskedToExtendAccessToken());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testSessionWillNotExtendTokenIfCurrentlyAttempting() {
+        TestSession session = openTestSessionWithSharedUser();
+        session.forceExtendAccessToken(true);
+        session.fakeTokenRefreshAttempt();
+
+        Request request = Request.newMeRequest(session, null);
+        request.executeAndWait();
+        assertFalse(session.getWasAskedToExtendAccessToken());
+    }
+
+
+    @LargeTest
+    public void testBasicSerialization() throws IOException, ClassNotFoundException {
+        // Try to test the happy path, that there are no unserializable fields
+        // in the session.
+        Session session0 = new Session.Builder(getActivity()).setApplicationId("fakeID").build();
+        Session session1 = TestUtils.serializeAndUnserialize(session0);
+
+        // do some basic assertions
+        assertNotNull(session0.getAccessToken());
+        assertEquals(session0, session1);
+
+        Session.AuthorizationRequest authRequest0 =
+                new Session.OpenRequest(getActivity()).
+                        setRequestCode(123).
+                        setLoginBehavior(SessionLoginBehavior.SSO_ONLY);
+        Session.AuthorizationRequest authRequest1 = TestUtils.serializeAndUnserialize(authRequest0);
+
+        assertEquals(authRequest0.getLoginBehavior(), authRequest1.getLoginBehavior());
+        assertEquals(authRequest0.getRequestCode(), authRequest1.getRequestCode());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenSessionWithNativeLinkingIntent() {
+        String token = "A token less unique than most";
+
+        Intent intent = new Intent(Intent.ACTION_MAIN);
+        intent.putExtras(getNativeLinkingExtras(token));
+
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, DEFAULT_TIMEOUT_MILLISECONDS);
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+
+        assertEquals(SessionState.CREATED, session.getState());
+
+        AccessToken accessToken = AccessToken.createFromNativeLinkingIntent(intent);
+        assertNotNull(accessToken);
+        session.open(accessToken, statusRecorder);
+
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        assertEquals(token, session.getAccessToken());
+        // Expiration time should be 3600s after now (allow 5s variation for test execution time)
+        long delta = session.getExpirationDate().getTime() - new Date().getTime();
+        assertTrue(Math.abs(delta - 3600 * 1000) < 5000);
+        assertEquals(0, session.getPermissions().size());
+        assertEquals(Utility.getMetadataApplicationId(getActivity()), session.getApplicationId());
+
+        // Verify we get a close callback.
+        session.close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        assertFalse(cache.getSavedState() == null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpenActiveSessionWithNativeLinkingIntent() {
+        Session activeSession = Session.getActiveSession();
+        if (activeSession != null) {
+            activeSession.closeAndClearTokenInformation();
+        }
+
+        SharedPreferencesTokenCachingStrategy tokenCache = new SharedPreferencesTokenCachingStrategy(getActivity());
+        assertEquals(0, tokenCache.load().size());
+
+        String token = "A token less unique than most";
+
+        Intent intent = new Intent(Intent.ACTION_MAIN);
+        intent.putExtras(getNativeLinkingExtras(token));
+
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+
+        AccessToken accessToken = AccessToken.createFromNativeLinkingIntent(intent);
+        assertNotNull(accessToken);
+        Session session = Session.openActiveSessionWithAccessToken(getActivity(), accessToken, statusRecorder);
+        assertEquals(session, Session.getActiveSession());
+
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        assertNotSame(0, tokenCache.load().size());
+
+        assertEquals(token, session.getAccessToken());
+        // Expiration time should be 3600s after now (allow 5s variation for test execution time)
+        long delta = session.getExpirationDate().getTime() - new Date().getTime();
+        assertTrue(Math.abs(delta - 3600 * 1000) < 5000);
+        assertEquals(0, session.getPermissions().size());
+        assertEquals(Utility.getMetadataApplicationId(getActivity()), session.getApplicationId());
+
+        // Verify we get a close callback.
+        session.close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testOpeningSessionWithPendingRequestResultsInExceptionCallback() {
+        ArrayList<String> permissions = new ArrayList<String>();
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+        AccessToken openToken = AccessToken
+                .createFromString("A token of thanks", permissions, AccessTokenSource.TEST_USER);
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+        session.addPendingAuthorizeResult();
+
+        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
+        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENING, new UnsupportedOperationException());
+
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    static IntentFilter getActiveSessionFilter(String... actions) {
+        IntentFilter filter = new IntentFilter();
+
+        for (String action : actions) {
+            filter.addAction(action);
+        }
+
+        return filter;
+    }
+
+    static IntentFilter getActiveSessionAllFilter() {
+        return getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_CLOSED, Session.ACTION_ACTIVE_SESSION_OPENED,
+                Session.ACTION_ACTIVE_SESSION_SET, Session.ACTION_ACTIVE_SESSION_UNSET);
+    }
+
+    private void verifySessionHasToken(Session session, AccessToken token) {
+        assertEquals(token.getToken(), session.getAccessToken());
+        assertEquals(token.getExpires(), session.getExpirationDate());
+        TestUtils.assertAtLeastExpectedPermissions(token.getPermissions(), session.getPermissions());
+    }
+}
diff --git a/facebook/tests/src/com/facebook/SessionTestsBase.java b/facebook/tests/src/com/facebook/SessionTestsBase.java
new file mode 100644
index 000000000..52d759683
--- /dev/null
+++ b/facebook/tests/src/com/facebook/SessionTestsBase.java
@@ -0,0 +1,316 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.os.ConditionVariable;
+import android.os.Looper;
+import com.facebook.internal.Utility;
+import com.facebook.model.GraphMultiResult;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphObjectList;
+import com.facebook.model.GraphUser;
+
+import java.util.*;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+
+public class SessionTestsBase extends FacebookTestCase {
+    public static final int DEFAULT_TIMEOUT_MILLISECONDS = 10 * 1000;
+    static final int SIMULATED_WORKING_MILLISECONDS = 20;
+    public static final int STRAY_CALLBACK_WAIT_MILLISECONDS = 50;
+
+    public ScriptedSession createScriptedSessionOnBlockerThread(TokenCachingStrategy cachingStrategy) {
+        return createScriptedSessionOnBlockerThread(Utility.getMetadataApplicationId(getActivity()), cachingStrategy);
+    }
+
+    ScriptedSession createScriptedSessionOnBlockerThread(final String applicationId,
+            final TokenCachingStrategy cachingStrategy) {
+        class MutableState {
+            ScriptedSession session;
+        }
+        ;
+        final MutableState mutable = new MutableState();
+
+        runOnBlockerThread(new Runnable() {
+            @Override
+            public void run() {
+                mutable.session = new ScriptedSession(getActivity(), applicationId, cachingStrategy);
+            }
+        }, true);
+
+        return mutable.session;
+    }
+
+    public static void stall(int stallMsec) {
+        try {
+            Thread.sleep(stallMsec);
+        } catch (InterruptedException e) {
+            fail("InterruptedException while stalling");
+        }
+    }
+
+    public class ScriptedSession extends Session {
+        private static final long serialVersionUID = 1L;
+        private final LinkedList<AuthorizeResult> pendingAuthorizations = new LinkedList<AuthorizeResult>();
+        private AuthorizationRequest lastRequest;
+        private AuthorizeResult currentAuthorization = null;
+
+        public ScriptedSession(Context currentContext, String applicationId, TokenCachingStrategy tokenCachingStrategy) {
+            super(currentContext, applicationId, tokenCachingStrategy);
+        }
+
+        public void addAuthorizeResult(String token, List<String> permissions, AccessTokenSource source) {
+            addAuthorizeResult(AccessToken.createFromString(token, permissions, source));
+        }
+
+        public void addAuthorizeResult(AccessToken token) {
+            pendingAuthorizations.add(new AuthorizeResult(token));
+        }
+
+        public void addAuthorizeResult(AccessToken token, List<String> permissions) {
+            pendingAuthorizations.add(new AuthorizeResult(token, permissions));
+        }
+
+        public void addAuthorizeResult(AccessToken token, String... permissions) {
+            pendingAuthorizations.add(new AuthorizeResult(token, Arrays.asList(permissions)));
+        }
+
+        public void addAuthorizeResult(Exception exception) {
+            pendingAuthorizations.add(new AuthorizeResult(exception));
+        }
+
+        public void addPendingAuthorizeResult() {
+            pendingAuthorizations.add(new AuthorizeResult());
+        }
+
+        public AuthorizationRequest getLastRequest() {
+            return lastRequest;
+        }
+
+        public SessionDefaultAudience getLastRequestAudience() {
+            return lastRequest.getDefaultAudience();
+        }
+
+        // Overrides authorize to return the next AuthorizeResult we added.
+        @Override
+        void authorize(final AuthorizationRequest request) {
+            lastRequest = request;
+            getActivity().runOnUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    stall(SIMULATED_WORKING_MILLISECONDS);
+                    currentAuthorization = pendingAuthorizations.poll();
+
+                    if (currentAuthorization == null) {
+                        fail("Missing call to addScriptedAuthorization");
+                    }
+                    if (!currentAuthorization.leaveAsPending) {
+                        finishAuthOrReauth(currentAuthorization.token, currentAuthorization.exception);
+                    }
+                }
+            });
+        }
+
+        private class AuthorizeResult {
+            final AccessToken token;
+            final Exception exception;
+            final List<String> resultingPermissions;
+            final boolean leaveAsPending;
+
+            private AuthorizeResult(AccessToken token, Exception exception, List<String> permissions) {
+                this.token = token;
+                this.exception = exception;
+                this.resultingPermissions = permissions;
+                this.leaveAsPending = false;
+            }
+
+            private AuthorizeResult() {
+                this.token = null;
+                this.exception = null;
+                this.resultingPermissions = null;
+                this.leaveAsPending = true;
+            }
+
+            AuthorizeResult(AccessToken token, List<String> permissions) {
+                this(token, null, permissions);
+            }
+
+            AuthorizeResult(AccessToken token) {
+                this(token, null, null);
+            }
+
+            AuthorizeResult(Exception exception) {
+                this(null, exception, null);
+            }
+        }
+    }
+
+    public static class SessionStatusCallbackRecorder implements Session.StatusCallback {
+        private final BlockingQueue<Call> calls = new LinkedBlockingQueue<Call>();
+        volatile boolean isClosed = false;
+
+        public void waitForCall(Session session, SessionState state, Exception exception) {
+            Call call = null;
+
+            try {
+                call = calls.poll(DEFAULT_TIMEOUT_MILLISECONDS, TimeUnit.MILLISECONDS);
+                if (call == null) {
+                    fail("Did not get a status callback within timeout.");
+                }
+            } catch (InterruptedException e) {
+                fail("InterruptedException while waiting for status callback: " + e);
+            }
+
+            assertEquals(session, call.session);
+            assertEquals(state, call.state);
+            if (exception != null && call.exception != null) {
+                assertEquals(exception.getClass(), call.exception.getClass());
+            } else {
+                // They should both be null if either of them is.
+                assertTrue(exception == call.exception);
+            }
+        }
+
+        public void close() {
+            isClosed = true;
+            assertEquals(0, calls.size());
+        }
+
+        @Override
+        public void call(Session session, SessionState state, Exception exception) {
+            Call call = new Call(session, state, exception);
+            if (!calls.offer(call)) {
+                fail("Test Error: Blocking queue ran out of capacity");
+            }
+            if (isClosed) {
+                fail("Reauthorize callback called after closed");
+            }
+            assertEquals("Callback should run on main UI thread", Thread.currentThread(),
+                    Looper.getMainLooper().getThread());
+        }
+
+        private static class Call {
+            final Session session;
+            final SessionState state;
+            final Exception exception;
+
+            Call(Session session, SessionState state, Exception exception) {
+                this.session = session;
+                this.state = state;
+                this.exception = exception;
+            }
+        }
+
+    }
+
+    public static class MockTokenCachingStrategy extends TokenCachingStrategy {
+        private final String token;
+        private final long expires_in;
+        private Bundle saved;
+
+        MockTokenCachingStrategy() {
+            this("FakeToken", DEFAULT_TIMEOUT_MILLISECONDS);
+        }
+
+        public MockTokenCachingStrategy(String token, long expires_in) {
+            this.token = token;
+            this.expires_in = expires_in;
+            this.saved = null;
+        }
+
+        public Bundle getSavedState() {
+            return saved;
+        }
+
+        @Override
+        public Bundle load() {
+            Bundle bundle = null;
+
+            if (token != null) {
+                bundle = new Bundle();
+
+                TokenCachingStrategy.putToken(bundle, token);
+                TokenCachingStrategy.putExpirationMilliseconds(bundle, System.currentTimeMillis() + expires_in);
+            }
+
+            return bundle;
+        }
+
+        @Override
+        public void save(Bundle bundle) {
+            this.saved = bundle;
+        }
+
+        @Override
+        public void clear() {
+            this.saved = null;
+        }
+    }
+
+    static class WaitForBroadcastReceiver extends BroadcastReceiver {
+        static int idGenerator = 0;
+        final int id = idGenerator++;
+
+        ConditionVariable condition = new ConditionVariable(true);
+        int expectCount;
+        int actualCount;
+
+        public void incrementExpectCount() {
+            incrementExpectCount(1);
+        }
+
+        public void incrementExpectCount(int n) {
+            expectCount += n;
+            if (actualCount < expectCount) {
+                condition.close();
+            }
+        }
+
+        public void waitForExpectedCalls() {
+            if (!condition.block(DEFAULT_TIMEOUT_MILLISECONDS)) {
+                assertTrue(false);
+            }
+        }
+
+        public static void incrementExpectCounts(WaitForBroadcastReceiver... receivers) {
+            for (WaitForBroadcastReceiver receiver : receivers) {
+                receiver.incrementExpectCount();
+            }
+        }
+
+        public static void waitForExpectedCalls(WaitForBroadcastReceiver... receivers) {
+            for (WaitForBroadcastReceiver receiver : receivers) {
+                receiver.waitForExpectedCalls();
+            }
+        }
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (++actualCount == expectCount) {
+                condition.open();
+            }
+            assertTrue(actualCount <= expectCount);
+            assertEquals("BroadcastReceiver should receive on main UI thread",
+                    Thread.currentThread(), Looper.getMainLooper().getThread());
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/SettingsTests.java b/facebook/tests/src/com/facebook/SettingsTests.java
new file mode 100644
index 000000000..554c5a047
--- /dev/null
+++ b/facebook/tests/src/com/facebook/SettingsTests.java
@@ -0,0 +1,74 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.os.ConditionVariable;
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+
+import java.util.concurrent.Executor;
+
+public final class SettingsTests extends AndroidTestCase {
+
+    @SmallTest @MediumTest @LargeTest
+    public void testGetExecutor() {
+        final ConditionVariable condition = new ConditionVariable();
+
+        Settings.getExecutor().execute(new Runnable() {
+            @Override
+            public void run() {
+                condition.open();
+            }
+        });
+
+        boolean success = condition.block(5000);
+        assertTrue(success);
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testSetExecutor() {
+        final ConditionVariable condition = new ConditionVariable();
+
+        final Runnable runnable = new Runnable() {
+            @Override
+            public void run() { }
+        };
+
+        final Executor executor = new Executor() {
+            @Override
+            public void execute(Runnable command) {
+                assertEquals(runnable, command);
+                command.run();
+
+                condition.open();
+            }
+        };
+
+        Executor original = Settings.getExecutor();
+        try {
+            Settings.setExecutor(executor);
+            Settings.getExecutor().execute(runnable);
+
+            boolean success = condition.block(5000);
+            assertTrue(success);
+        } finally {
+            Settings.setExecutor(original);
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/SharedPreferencesTokenCacheTests.java b/facebook/tests/src/com/facebook/SharedPreferencesTokenCacheTests.java
new file mode 100644
index 000000000..6f676ac19
--- /dev/null
+++ b/facebook/tests/src/com/facebook/SharedPreferencesTokenCacheTests.java
@@ -0,0 +1,349 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.os.Bundle;
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.internal.Utility;
+import junit.framework.Assert;
+
+import java.lang.reflect.Array;
+import java.util.*;
+
+
+public final class SharedPreferencesTokenCacheTests extends AndroidTestCase {
+
+    private static final String BOOLEAN_KEY = "booleanKey";
+    private static final String BOOLEAN_ARRAY_KEY = "booleanArrayKey";
+    private static final String BYTE_KEY = "byteKey";
+    private static final String BYTE_ARRAY_KEY = "byteArrayKey";
+    private static final String SHORT_KEY = "shortKey";
+    private static final String SHORT_ARRAY_KEY = "shortArrayKey";
+    private static final String INT_KEY = "intKey";
+    private static final String INT_ARRAY_KEY = "intArrayKey";
+    private static final String LONG_KEY = "longKey";
+    private static final String LONG_ARRAY_KEY = "longArrayKey";
+    private static final String FLOAT_ARRAY_KEY = "floatKey";
+    private static final String FLOAT_KEY = "floatArrayKey";
+    private static final String DOUBLE_KEY = "doubleKey";
+    private static final String DOUBLE_ARRAY_KEY = "doubleArrayKey";
+    private static final String CHAR_KEY = "charKey";
+    private static final String CHAR_ARRAY_KEY = "charArrayKey";
+    private static final String STRING_KEY = "stringKey";
+    private static final String STRING_LIST_KEY = "stringListKey";
+    private static final String SERIALIZABLE_KEY = "serializableKey";
+
+    private static Random random = new Random((new Date()).getTime());
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testAllTypes() {
+        Bundle originalBundle = new Bundle();
+
+        putBoolean(BOOLEAN_KEY, originalBundle);
+        putBooleanArray(BOOLEAN_ARRAY_KEY, originalBundle);
+        putByte(BYTE_KEY, originalBundle);
+        putByteArray(BYTE_ARRAY_KEY, originalBundle);
+        putShort(SHORT_KEY, originalBundle);
+        putShortArray(SHORT_ARRAY_KEY, originalBundle);
+        putInt(INT_KEY, originalBundle);
+        putIntArray(INT_ARRAY_KEY, originalBundle);
+        putLong(LONG_KEY, originalBundle);
+        putLongArray(LONG_ARRAY_KEY, originalBundle);
+        putFloat(FLOAT_KEY, originalBundle);
+        putFloatArray(FLOAT_ARRAY_KEY, originalBundle);
+        putDouble(DOUBLE_KEY, originalBundle);
+        putDoubleArray(DOUBLE_ARRAY_KEY, originalBundle);
+        putChar(CHAR_KEY, originalBundle);
+        putCharArray(CHAR_ARRAY_KEY, originalBundle);
+        putString(STRING_KEY, originalBundle);
+        putStringList(STRING_LIST_KEY, originalBundle);
+        originalBundle.putSerializable(SERIALIZABLE_KEY, AccessTokenSource.FACEBOOK_APPLICATION_WEB);
+
+        ensureApplicationContext();
+
+        SharedPreferencesTokenCachingStrategy cache = new SharedPreferencesTokenCachingStrategy(getContext());
+        cache.save(originalBundle);
+
+        SharedPreferencesTokenCachingStrategy cache2 = new SharedPreferencesTokenCachingStrategy(getContext());
+        Bundle cachedBundle = cache2.load();
+
+        Assert.assertEquals(originalBundle.getBoolean(BOOLEAN_KEY), cachedBundle.getBoolean(BOOLEAN_KEY));
+        assertArrayEquals(originalBundle.getBooleanArray(BOOLEAN_ARRAY_KEY), cachedBundle.getBooleanArray(BOOLEAN_ARRAY_KEY));
+        Assert.assertEquals(originalBundle.getByte(BYTE_KEY), cachedBundle.getByte(BYTE_KEY));
+        assertArrayEquals(originalBundle.getByteArray(BYTE_ARRAY_KEY), cachedBundle.getByteArray(BYTE_ARRAY_KEY));
+        Assert.assertEquals(originalBundle.getShort(SHORT_KEY), cachedBundle.getShort(SHORT_KEY));
+        assertArrayEquals(originalBundle.getShortArray(SHORT_ARRAY_KEY), cachedBundle.getShortArray(SHORT_ARRAY_KEY));
+        Assert.assertEquals(originalBundle.getInt(INT_KEY), cachedBundle.getInt(INT_KEY));
+        assertArrayEquals(originalBundle.getIntArray(INT_ARRAY_KEY), cachedBundle.getIntArray(INT_ARRAY_KEY));
+        Assert.assertEquals(originalBundle.getLong(LONG_KEY), cachedBundle.getLong(LONG_KEY));
+        assertArrayEquals(originalBundle.getLongArray(LONG_ARRAY_KEY), cachedBundle.getLongArray(LONG_ARRAY_KEY));
+        Assert.assertEquals(originalBundle.getFloat(FLOAT_KEY), cachedBundle.getFloat(FLOAT_KEY));
+        assertArrayEquals(originalBundle.getFloatArray(FLOAT_ARRAY_KEY), cachedBundle.getFloatArray(FLOAT_ARRAY_KEY));
+        Assert.assertEquals(originalBundle.getDouble(DOUBLE_KEY), cachedBundle.getDouble(DOUBLE_KEY));
+        assertArrayEquals(originalBundle.getDoubleArray(DOUBLE_ARRAY_KEY), cachedBundle.getDoubleArray(DOUBLE_ARRAY_KEY));
+        Assert.assertEquals(originalBundle.getChar(CHAR_KEY), cachedBundle.getChar(CHAR_KEY));
+        assertArrayEquals(originalBundle.getCharArray(CHAR_ARRAY_KEY), cachedBundle.getCharArray(CHAR_ARRAY_KEY));
+        Assert.assertEquals(originalBundle.getString(STRING_KEY), cachedBundle.getString(STRING_KEY));
+        assertListEquals(originalBundle.getStringArrayList(STRING_LIST_KEY), cachedBundle.getStringArrayList(
+                STRING_LIST_KEY));
+        Assert.assertEquals(originalBundle.getSerializable(SERIALIZABLE_KEY),
+                cachedBundle.getSerializable(SERIALIZABLE_KEY));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMultipleCaches() {
+        Bundle bundle1 = new Bundle(), bundle2 = new Bundle();
+
+        bundle1.putInt(INT_KEY, 10);
+        bundle1.putString(STRING_KEY, "ABC");
+        bundle2.putInt(INT_KEY, 100);
+        bundle2.putString(STRING_KEY, "xyz");
+
+        ensureApplicationContext();
+
+        SharedPreferencesTokenCachingStrategy cache1 = new SharedPreferencesTokenCachingStrategy(getContext());
+        SharedPreferencesTokenCachingStrategy cache2 = new SharedPreferencesTokenCachingStrategy(getContext(), "CustomCache");
+
+        cache1.save(bundle1);
+        cache2.save(bundle2);
+
+        // Get new references to make sure we are getting persisted data.
+        // Reverse the cache references for fun.
+        cache1 = new SharedPreferencesTokenCachingStrategy(getContext(), "CustomCache");
+        cache2 = new SharedPreferencesTokenCachingStrategy(getContext());
+
+        Bundle newBundle1 = cache1.load(), newBundle2 = cache2.load();
+
+        Assert.assertEquals(bundle2.getInt(INT_KEY), newBundle1.getInt(INT_KEY));
+        Assert.assertEquals(bundle2.getString(STRING_KEY), newBundle1.getString(STRING_KEY));
+        Assert.assertEquals(bundle1.getInt(INT_KEY), newBundle2.getInt(INT_KEY));
+        Assert.assertEquals(bundle1.getString(STRING_KEY), newBundle2.getString(STRING_KEY));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCacheRoundtrip() {
+        ArrayList<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
+        String token = "AnImaginaryTokenValue";
+        Date later = TestUtils.nowPlusSeconds(60);
+        Date earlier = TestUtils.nowPlusSeconds(-60);
+
+        SharedPreferencesTokenCachingStrategy cache = new SharedPreferencesTokenCachingStrategy(getContext());
+        cache.clear();
+
+        Bundle bundle = new Bundle();
+        TokenCachingStrategy.putToken(bundle, token);
+        TokenCachingStrategy.putExpirationDate(bundle, later);
+        TokenCachingStrategy.putSource(bundle, AccessTokenSource.FACEBOOK_APPLICATION_NATIVE);
+        TokenCachingStrategy.putLastRefreshDate(bundle, earlier);
+        TokenCachingStrategy.putPermissions(bundle, permissions);
+
+        cache.save(bundle);
+        bundle = cache.load();
+
+        AccessToken accessToken = AccessToken.createFromCache(bundle);
+        TestUtils.assertSamePermissions(permissions, accessToken);
+        assertEquals(token, accessToken.getToken());
+        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_NATIVE, accessToken.getSource());
+        assertTrue(!accessToken.isInvalid());
+
+        Bundle cachedBundle = accessToken.toCacheBundle();
+        TestUtils.assertEqualContents(bundle, cachedBundle);
+    }
+
+    private static void assertArrayEquals(Object a1, Object a2) {
+        Assert.assertNotNull(a1);
+        Assert.assertNotNull(a2);
+        Assert.assertEquals(a1.getClass(), a2.getClass());
+        Assert.assertTrue("Not an array", a1.getClass().isArray());
+
+        int length = Array.getLength(a1);
+        Assert.assertEquals(length, Array.getLength(a2));
+        for (int i = 0; i < length; i++) {
+            Object a1Value = Array.get(a1, i);
+            Object a2Value = Array.get(a2, i);
+
+            Assert.assertEquals(a1Value, a2Value);
+        }
+    }
+
+    private static void assertListEquals(List<?> l1, List<?> l2) {
+        Assert.assertNotNull(l1);
+        Assert.assertNotNull(l2);
+
+        Iterator<?> i1 = l1.iterator(), i2 = l2.iterator();
+        while (i1.hasNext() && i2.hasNext()) {
+            Assert.assertEquals(i1.next(), i2.next());
+        }
+
+        Assert.assertTrue("Lists not of the same length", !i1.hasNext());
+        Assert.assertTrue("Lists not of the same length", !i2.hasNext());
+    }
+
+    private static void putInt(String key, Bundle bundle) {
+        bundle.putInt(key, random.nextInt());
+    }
+
+    private static void putIntArray(String key, Bundle bundle) {
+        int length = random.nextInt(50);
+        int[] array = new int[length];
+        for (int i = 0; i < length; i++) {
+            array[i] = random.nextInt();
+        }
+        bundle.putIntArray(key, array);
+    }
+
+    private static void putShort(String key, Bundle bundle) {
+        bundle.putShort(key, (short)random.nextInt());
+    }
+
+    private static void putShortArray(String key, Bundle bundle) {
+        int length = random.nextInt(50);
+        short[] array = new short[length];
+        for (int i = 0; i < length; i++) {
+            array[i] = (short)random.nextInt();
+        }
+        bundle.putShortArray(key, array);
+    }
+
+    private static void putByte(String key, Bundle bundle) {
+        bundle.putByte(key, (byte)random.nextInt());
+    }
+
+    private static void putByteArray(String key, Bundle bundle) {
+        int length = random.nextInt(50);
+        byte[] array = new byte[length];
+        random.nextBytes(array);
+        bundle.putByteArray(key, array);
+    }
+
+    private static void putBoolean(String key, Bundle bundle) {
+        bundle.putBoolean(key, random.nextBoolean());
+    }
+
+    private static void putBooleanArray(String key, Bundle bundle) {
+        int length = random.nextInt(50);
+        boolean[] array = new boolean[length];
+        for (int i = 0; i < length; i++) {
+            array[i] = random.nextBoolean();
+        }
+        bundle.putBooleanArray(key, array);
+    }
+
+    private static void putLong(String key, Bundle bundle) {
+        bundle.putLong(key, random.nextLong());
+    }
+
+    private static void putLongArray(String key, Bundle bundle) {
+        int length = random.nextInt(50);
+        long[] array = new long[length];
+        for (int i = 0; i < length; i++) {
+            array[i] = random.nextLong();
+        }
+        bundle.putLongArray(key, array);
+    }
+
+    private static void putFloat(String key, Bundle bundle) {
+        bundle.putFloat(key, random.nextFloat());
+    }
+
+    private static void putFloatArray(String key, Bundle bundle) {
+        int length = random.nextInt(50);
+        float[] array = new float[length];
+        for (int i = 0; i < length; i++) {
+            array[i] = random.nextFloat();
+        }
+        bundle.putFloatArray(key, array);
+    }
+
+    private static void putDouble(String key, Bundle bundle) {
+        bundle.putDouble(key, random.nextDouble());
+    }
+
+    private static void putDoubleArray(String key, Bundle bundle) {
+        int length = random.nextInt(50);
+        double[] array = new double[length];
+        for (int i = 0; i < length; i++) {
+            array[i] = random.nextDouble();
+        }
+        bundle.putDoubleArray(key, array);
+    }
+
+    private static void putChar(String key, Bundle bundle) {
+        bundle.putChar(key, getChar());
+    }
+
+    private static void putCharArray(String key, Bundle bundle) {
+        bundle.putCharArray(key, getCharArray());
+    }
+
+    private static void putString(String key, Bundle bundle) {
+        bundle.putString(key, new String(getCharArray()));
+    }
+
+    private static void putStringList(String key, Bundle bundle) {
+        int length = random.nextInt(50);
+        ArrayList<String> stringList = new ArrayList<String>(length);
+        while (0 < length--) {
+            if (length == 0) {
+                stringList.add(null);
+            } else {
+                stringList.add(new String(getCharArray()));
+            }
+        }
+
+        bundle.putStringArrayList(key, stringList);
+    }
+
+    private static char[] getCharArray() {
+        int length = random.nextInt(50);
+        char[] array = new char[length];
+        for (int i = 0; i < length; i++) {
+            array[i] = getChar();
+        }
+
+        return array;
+    }
+
+    private static char getChar() {
+        return (char)random.nextInt(255);
+    }
+
+    private void ensureApplicationContext() {
+        // Since the test case is not running on the UI thread, the applicationContext might
+        // not be ready (i.e. it might be null). Wait for a bit to resolve this.
+        long waitedFor = 0;
+        try {
+            // Don't hold up execution for too long.
+            while (getContext().getApplicationContext() == null && waitedFor <= 2000) {
+                Thread.sleep(50);
+                waitedFor += 50;
+            }
+        }
+        catch (InterruptedException e) {
+        }
+    }
+
+}
diff --git a/facebook/tests/src/com/facebook/TestBlocker.java b/facebook/tests/src/com/facebook/TestBlocker.java
new file mode 100644
index 000000000..cfeb5ac54
--- /dev/null
+++ b/facebook/tests/src/com/facebook/TestBlocker.java
@@ -0,0 +1,115 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.os.Handler;
+import android.os.HandlerThread;
+
+public class TestBlocker extends HandlerThread {
+    private Exception exception;
+    public int signals;
+    private volatile Handler handler;
+
+    private TestBlocker() {
+        super("TestBlocker");
+    }
+
+    public synchronized static TestBlocker createTestBlocker() {
+        TestBlocker blocker = new TestBlocker();
+        blocker.start();
+
+        // Wait until we have a Looper and Handler.
+        synchronized (blocker) {
+            while (blocker.handler == null) {
+                try {
+                    blocker.wait();
+                } catch (InterruptedException e) {
+                }
+            }
+        }
+
+        return blocker;
+    }
+
+    @Override
+    public void run() {
+        try {
+            super.run();
+        } catch (Exception e) {
+            setException(e);
+        }
+        synchronized (this) {
+            notifyAll();
+        }
+    }
+
+    public Handler getHandler() {
+        return handler;
+    }
+
+    public void assertSuccess() throws Exception {
+        Exception e = getException();
+        if (e != null) {
+            throw e;
+        }
+    }
+
+    public synchronized void signal() {
+        ++signals;
+        notifyAll();
+    }
+
+    public void waitForSignals(int numSignals) throws Exception {
+        // Make sure we aren't sitting on an unhandled exception before we even start, because that means our
+        // thread isn't around anymore.
+        assertSuccess();
+
+        setException(null);
+
+        synchronized (this) {
+            while (getException() == null && signals < numSignals) {
+                try {
+                    wait();
+                } catch (InterruptedException e) {
+                }
+            }
+            signals = 0;
+        }
+    }
+
+    public void waitForSignalsAndAssertSuccess(int numSignals) throws Exception {
+        waitForSignals(numSignals);
+        assertSuccess();
+    }
+
+    public synchronized Exception getException() {
+        return exception;
+    }
+
+    public synchronized void setException(Exception e) {
+        exception = e;
+        notifyAll();
+    }
+
+    @Override
+    protected void onLooperPrepared() {
+        synchronized (this) {
+            handler = new Handler(getLooper());
+            notifyAll();
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/TestSessionTests.java b/facebook/tests/src/com/facebook/TestSessionTests.java
new file mode 100644
index 000000000..34c74b9c0
--- /dev/null
+++ b/facebook/tests/src/com/facebook/TestSessionTests.java
@@ -0,0 +1,151 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.os.Bundle;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+import org.json.JSONArray;
+
+// Because TestSession is the component under test here, be careful in calling methods on FacebookTestCase that
+// assume TestSession works correctly.
+public class TestSessionTests extends FacebookTestCase {
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanCreateWithPrivateUser() {
+        TestSession session = TestSession.createSessionWithPrivateUser(getActivity(), null);
+        assertTrue(session != null);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanCreateWithSharedUser() {
+        TestSession session = TestSession.createSessionWithSharedUser(getActivity(), null);
+        assertTrue(session != null);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCanOpenWithSharedUser() throws Throwable {
+        final TestBlocker blocker = getTestBlocker();
+        TestSession session = getTestSessionWithSharedUser();
+
+        Session.OpenRequest openRequest = new Session.OpenRequest(getActivity()).
+                setCallback(
+                        new Session.StatusCallback() {
+                            @Override
+                            public void call(Session session, SessionState state, Exception exception) {
+                                assertTrue(exception == null);
+                                blocker.signal();
+                            }
+                        });
+        session.openForRead(openRequest);
+
+        waitAndAssertSuccess(blocker, 1);
+
+        assertTrue(session.getState().isOpened());
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testSharedUserDoesntCreateUnnecessaryUsers() throws Throwable {
+        TestSession session = getTestSessionWithSharedUser();
+        openSession(getActivity(), session);
+
+        // Note that this test is somewhat brittle in that the count of test users could change for
+        // external reasons while the test is running. For that reason it may not be appropriate for an
+        // automated test suite, and could be run only when testing changes to TestSession.
+        int startingUserCount = countTestUsers();
+
+        session = getTestSessionWithSharedUser();
+        openSession(getActivity(), session);
+
+        int endingUserCount = countTestUsers();
+
+        assertSame(startingUserCount, endingUserCount);
+    }
+
+    // This test is currently unreliable, I believe due to timing/replication issues that cause the
+    // counts to occasionally be off. Taking out of test runs for now until a more robust test can be added.
+    @LargeTest
+    public void failing_testPrivateUserIsDeletedOnSessionClose() throws Throwable {
+        final TestBlocker blocker = getTestBlocker();
+
+        // See comment above regarding test user count.
+        int startingUserCount = countTestUsers();
+
+        TestSession session = getTestSessionWithPrivateUser(blocker);
+        openSession(getActivity(), session);
+
+        int sessionOpenUserCount = countTestUsers();
+
+        assertSame(startingUserCount + 1, sessionOpenUserCount);
+
+        session.close();
+
+        int endingUserCount = countTestUsers();
+
+        assertSame(startingUserCount, endingUserCount);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCannotChangeTestApplicationIdOnceSet() {
+        try {
+            TestSession.setTestApplicationId("hello");
+            TestSession.setTestApplicationId("world");
+            fail("expected exception");
+        } catch (FacebookException e) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCannotChangeTestApplicationSecretOnceSet() {
+        try {
+            TestSession.setTestApplicationSecret("hello");
+            TestSession.setTestApplicationSecret("world");
+            fail("expected exception");
+        } catch (FacebookException e) {
+        }
+    }
+
+    private int countTestUsers() {
+        TestSession session = getTestSessionWithSharedUser(null);
+
+        String appAccessToken = TestSession.getAppAccessToken();
+        assertNotNull(appAccessToken);
+        String applicationId = session.getApplicationId();
+        assertNotNull(applicationId);
+
+        String fqlQuery = String.format("SELECT id FROM test_account WHERE app_id = %s", applicationId);
+        Bundle parameters = new Bundle();
+        parameters.putString("q", fqlQuery);
+        parameters.putString("access_token", appAccessToken);
+
+        Request request = new Request(null, "fql", parameters, null);
+        Response response = request.executeAndWait();
+
+        JSONArray data = (JSONArray) response.getGraphObject().getProperty("data");
+        return data.length();
+    }
+}
diff --git a/facebook/tests/src/com/facebook/TestUtils.java b/facebook/tests/src/com/facebook/TestUtils.java
new file mode 100644
index 000000000..16ee40d39
--- /dev/null
+++ b/facebook/tests/src/com/facebook/TestUtils.java
@@ -0,0 +1,95 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook;
+
+import android.os.Bundle;
+import junit.framework.Assert;
+
+import java.io.*;
+import java.util.Date;
+import java.util.List;
+
+public class TestUtils {
+    public static <T extends Serializable> T serializeAndUnserialize(T t) {
+        try {
+            ByteArrayOutputStream os = new ByteArrayOutputStream();
+            new ObjectOutputStream(os).writeObject(t);
+            ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
+
+            @SuppressWarnings("unchecked")
+            T ret = (T) (new ObjectInputStream(is)).readObject();
+
+            return ret;
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        } catch (ClassNotFoundException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    static Date nowPlusSeconds(long offset) {
+        return new Date(new Date().getTime() + (offset * 1000L));
+    }
+
+    static void assertSamePermissions(List<String> expected, AccessToken actual) {
+        if (expected == null) {
+            Assert.assertEquals(null, actual.getPermissions());
+        } else {
+            for (String p : expected) {
+                Assert.assertTrue(actual.getPermissions().contains(p));
+            }
+            for (String p : actual.getPermissions()) {
+                Assert.assertTrue(expected.contains(p));
+            }
+        }
+    }
+
+    static void assertSamePermissions(List<String> expected, List<String> actual) {
+        if (expected == null) {
+            Assert.assertEquals(null, actual);
+        } else {
+            for (String p : expected) {
+                Assert.assertTrue(actual.contains(p));
+            }
+            for (String p : actual) {
+                Assert.assertTrue(expected.contains(p));
+            }
+        }
+    }
+
+    static void assertAtLeastExpectedPermissions(List<String> expected, List<String> actual) {
+        if (expected != null) {
+            for (String p : expected) {
+                Assert.assertTrue(actual.contains(p));
+            }
+        }
+    }
+
+    static void assertEqualContents(Bundle a, Bundle b) {
+        for (String key : a.keySet()) {
+            if (!b.containsKey(key)) {
+                Assert.fail("bundle does not include key " + key);
+            }
+            Assert.assertEquals(a.get(key), b.get(key));
+        }
+        for (String key : b.keySet()) {
+            if (!a.containsKey(key)) {
+                Assert.fail("bundle does not include key " + key);
+            }
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/internal/FileLruCacheTests.java b/facebook/tests/src/com/facebook/internal/FileLruCacheTests.java
new file mode 100644
index 000000000..52065e514
--- /dev/null
+++ b/facebook/tests/src/com/facebook/internal/FileLruCacheTests.java
@@ -0,0 +1,359 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.Random;
+
+public final class FileLruCacheTests extends AndroidTestCase {
+    private static final Random random = new Random();
+
+    @SmallTest @MediumTest @LargeTest
+    public void testCacheOutputStream() throws IOException {
+        int dataSize = 1024;
+        byte[] data = generateBytes(dataSize);
+        String key = "a";
+
+        // Limit to 2x to allow for extra header data
+        FileLruCache cache = new FileLruCache(getContext(), "testCacheOutputStream", limitCacheSize(2*dataSize));
+
+        put(cache, key, data);
+        checkValue(cache, key, data);
+        cache.clearForTest();
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testCacheInputStream() throws IOException {
+        int dataSize = 1024;
+        byte[] data = generateBytes(dataSize);
+        String key = "a";
+        InputStream stream = new ByteArrayInputStream(data);
+
+        // Limit to 2x to allow for extra header data
+        FileLruCache cache = new FileLruCache(getContext(), "testCacheInputStream", limitCacheSize(2*dataSize));
+        cache.clearForTest();
+
+        InputStream wrapped = cache.interceptAndPut(key, stream);
+        consumeAndClose(wrapped);
+        checkValue(cache, key, data);
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testCacheClear() throws IOException {
+        int dataSize = 1024;
+        byte[] data = generateBytes(dataSize);
+        String key = "a";
+
+        // Limit to 2x to allow for extra header data
+        FileLruCache cache = new FileLruCache(getContext(), "testCacheClear", limitCacheSize(2*dataSize));
+        cache.clearForTest();
+
+        put(cache, key, data);
+        checkValue(cache, key, data);
+
+        cache.clearForTest();
+        assertEquals(false, hasValue(cache, key));
+        assertEquals(0, cache.sizeInBytesForTest());
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testSizeInBytes() throws IOException {
+        int count = 17;
+        int dataSize = 53;
+        int cacheSize = count * dataSize;
+        byte[] data = generateBytes(dataSize);
+
+        // Limit to 2x to allow for extra header data
+        FileLruCache cache = new FileLruCache(getContext(), "testSizeInBytes", limitCacheSize(2*cacheSize));
+        cache.clearForTest();
+
+        for (int i = 0; i < count; i++) {
+            put(cache, i, data);
+
+            // The size reported by sizeInBytes includes a version/size token as well
+            // as a JSON blob that records the name.  Verify that the cache size is larger
+            // than the data content but not more than twice as large.  This guarantees
+            // that sizeInBytes is doing at least approximately the right thing.
+            int totalDataSize = (i + 1) * dataSize;
+            assertTrue(cache.sizeInBytesForTest() > totalDataSize);
+            assertTrue(cache.sizeInBytesForTest() < 2 * totalDataSize);
+        }
+        for (int i = 0; i < count; i++) {
+            String key = Integer.valueOf(i).toString();
+            checkValue(cache, key, data);
+        }
+    }
+
+    @MediumTest @LargeTest
+    public void testCacheSizeLimit() throws IOException {
+        int count = 64;
+        int dataSize = 32;
+        int cacheSize = count * dataSize / 2;
+        byte[] data = generateBytes(dataSize);
+
+        // Here we do not set the limit to 2x to make sure we hit the limit well before we have
+        // added all the data.
+        FileLruCache cache = new FileLruCache(getContext(), "testCacheSizeLimit", limitCacheSize(cacheSize));
+        cache.clearForTest();
+
+        for (int i = 0; i < count; i++) {
+            put(cache, i, data);
+
+            // See comment in testSizeInBytes for why this is not an exact calculation.
+            //
+            // This changes verification such that the final cache size lands somewhere
+            // between half and full quota.
+            int totalDataSize = (i + 1) * dataSize;
+            assertTrue(cache.sizeInBytesForTest() > Math.min(totalDataSize, cacheSize/2));
+            assertTrue(cache.sizeInBytesForTest() < Math.min(2 * totalDataSize, cacheSize));
+        }
+
+        // Verify that some keys exist and others do not
+        boolean hasValueExists = false;
+        boolean hasNoValueExists = false;
+
+        for (int i = 0; i < count; i++) {
+            String key = Integer.valueOf(i).toString();
+            if (hasValue(cache, key)) {
+                hasValueExists = true;
+                checkValue(cache, key, data);
+            } else {
+                hasNoValueExists = true;
+            }
+        }
+
+        assertEquals(true, hasValueExists);
+        assertEquals(true, hasNoValueExists);
+    }
+
+    @MediumTest @LargeTest
+    public void testCacheCountLimit() throws IOException {
+        int count = 64;
+        int dataSize = 32;
+        int cacheCount = count / 2;
+        byte[] data = generateBytes(dataSize);
+
+        // Here we only limit by count, and we allow half of the entries.
+        FileLruCache cache = new FileLruCache(getContext(), "testCacheCountLimit", limitCacheCount(cacheCount));
+        cache.clearForTest();
+
+        for (int i = 0; i < count; i++) {
+            put(cache, i, data);
+        }
+
+        // Verify that some keys exist and others do not
+        boolean hasValueExists = false;
+        boolean hasNoValueExists = false;
+
+        for (int i = 0; i < count; i++) {
+            if (hasValue(cache, i)) {
+                hasValueExists = true;
+                checkValue(cache, i, data);
+            } else {
+                hasNoValueExists = true;
+            }
+        }
+
+        assertEquals(true, hasValueExists);
+        assertEquals(true, hasNoValueExists);
+    }
+
+    @LargeTest
+    public void testCacheLru() throws IOException, InterruptedException {
+        int keepCount = 10;
+        int otherCount = 5;
+        int dataSize = 64;
+        byte[] data = generateBytes(dataSize);
+
+        // Limit by count, and allow all the keep keys plus one other.
+        FileLruCache cache = new FileLruCache(getContext(), "testCacheLru", limitCacheCount(keepCount + 1));
+        cache.clearForTest();
+
+        for (int i = 0; i < keepCount; i++) {
+            put(cache, i, data);
+        }
+
+        // Make sure operations are separated by enough time that the file timestamps are all different.
+        // On the test device, it looks like lastModified has 1-second resolution, so we have to wait at
+        // least a second to guarantee that updated timestamps will come later.
+        Thread.sleep(1000);
+        for (int i = 0; i < otherCount; i++) {
+            put(cache, keepCount + i, data);
+            Thread.sleep(1000);
+
+            // By verifying all the keep keys, they should be LRU and survive while the others do not.
+            for (int keepIndex = 0; keepIndex < keepCount; keepIndex++) {
+                checkValue(cache, keepIndex, data);
+            }
+            Thread.sleep(1000);
+        }
+
+        // All but the last other key should have been pushed out
+        for (int i = 0; i < (otherCount - 1); i++) {
+            String key = Integer.valueOf(keepCount + i).toString();
+            assertEquals(false, hasValue(cache, key));
+        }
+    }
+
+    @LargeTest
+    public void testConcurrentWritesToSameKey() throws IOException, InterruptedException {
+        final int count = 5;
+        final int dataSize = 81;
+        final int threadCount = 31;
+        final int iterationCount = 10;
+        final byte[] data = generateBytes(dataSize);
+
+        final FileLruCache cache = new FileLruCache(
+                getContext(), "testConcurrentWritesToSameKey", limitCacheCount(count+1));
+        cache.clearForTest();
+
+        Runnable run = new Runnable() {
+            @Override
+            public void run() {
+                for (int iterations = 0; iterations < iterationCount; iterations++) {
+                    for (int i = 0; i < count; i++) {
+                        put(cache, i, data);
+                    }
+                }
+            }
+        };
+
+        // Create a bunch of threads to write a set of keys repeatedly
+        Thread[] threads = new Thread[threadCount];
+        for (int i = 0; i < threads.length; i++) {
+            threads[i] = new Thread(run);
+        }
+
+        for (Thread thread : threads) {
+            thread.start();
+        }
+
+        for (Thread thread : threads) {
+            thread.join(10 * 1000, 0);
+        }
+
+        // Verify that the file state ended up consistent in the end
+        for (int i = 0; i < count; i++) {
+            checkValue(cache, i, data);
+        }
+    }
+
+    byte[] generateBytes(int n) {
+        byte[] bytes = new byte[n];
+        random.nextBytes(bytes);
+        return bytes;
+    }
+
+    FileLruCache.Limits limitCacheSize(int n) {
+        FileLruCache.Limits limits = new FileLruCache.Limits();
+        limits.setByteCount(n);
+        return limits;
+    }
+
+    FileLruCache.Limits limitCacheCount(int n) {
+        FileLruCache.Limits limits = new FileLruCache.Limits();
+        limits.setFileCount(n);
+        return limits;
+    }
+
+    void put(FileLruCache cache, int i, byte[] data) {
+        put(cache, Integer.valueOf(i).toString(), data);
+    }
+
+    void put(FileLruCache cache, String key, byte[] data) {
+        try {
+            OutputStream stream = cache.openPutStream(key);
+            assertNotNull(stream);
+
+            stream.write(data);
+            stream.close();
+        } catch (IOException e) {
+            // Fail test and print Exception
+            assertNull(e);
+        }
+    }
+
+    void checkValue(FileLruCache cache, int i, byte[] expected) {
+        checkValue(cache, Integer.valueOf(i).toString(), expected);
+    }
+
+    void checkValue(FileLruCache cache, String key, byte[] expected) {
+        try {
+            InputStream stream = cache.get(key);
+            assertNotNull(stream);
+
+            checkInputStream(expected, stream);
+            stream.close();
+        } catch (IOException e) {
+            // Fail test and print Exception
+            assertNull(e);
+        }
+    }
+
+    boolean hasValue(FileLruCache cache, int i) {
+        return hasValue(cache, Integer.valueOf(i).toString());
+    }
+
+    boolean hasValue(FileLruCache cache, String key) {
+        InputStream stream = null;
+
+        try {
+            stream = cache.get(key);
+        } catch (IOException e) {
+            // Fail test and print Exception
+            assertNull(e);
+        }
+
+        return stream != null;
+    }
+
+    void checkInputStream(byte[] expected, InputStream actual) {
+        try {
+            for (int i = 0; i < expected.length; i++) {
+                int b = actual.read();
+                assertEquals(((int)expected[i]) & 0xff, b);
+            }
+
+            int eof = actual.read();
+            assertEquals(-1, eof);
+        } catch (IOException e) {
+            // Fail test and print Exception
+            assertNull(e);
+        }
+    }
+
+    void consumeAndClose(InputStream stream) {
+        try {
+            byte[] buffer = new byte[1024];
+            while (stream.read(buffer) > -1) {
+                // these bytes intentionally ignored
+            }
+            stream.close();
+        } catch (IOException e) {
+            // Fail test and print Exception
+            assertNull(e);
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/internal/SessionTrackerTests.java b/facebook/tests/src/com/facebook/internal/SessionTrackerTests.java
new file mode 100644
index 000000000..77cbc8158
--- /dev/null
+++ b/facebook/tests/src/com/facebook/internal/SessionTrackerTests.java
@@ -0,0 +1,183 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.*;
+import com.facebook.internal.SessionTracker;
+
+import java.util.Collections;
+
+public class SessionTrackerTests extends SessionTestsBase {
+
+    private static final String TOKEN_STR = "A token of thanks";
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    // Tests the SessionDelegate while tracking the active session
+    public void testDelegateWithActiveSession() throws Exception {
+        Session.setActiveSession(null);
+        final SessionStatusCallbackRecorder statusRecorder =
+                new SessionStatusCallbackRecorder();
+        final MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        final ScriptedSession session =
+                createScriptedSessionOnBlockerThread(cache);
+
+        session.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
+
+        final SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder);
+        Session.setActiveSession(session);
+
+        session.openForRead(new Session.OpenRequest(getActivity()));
+
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+        assertNotNull("Session should be open", tracker.getOpenSession());
+        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
+        tracker.getOpenSession().close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        tracker.stopTracking();
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    // Tests the SessionDelegate while tracking a passed in session from the constructor
+    public void testDelegateWithSessionInConstructor() throws Exception {
+        final SessionStatusCallbackRecorder statusRecorder =
+                new SessionStatusCallbackRecorder();
+        final MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        final ScriptedSession session =
+                createScriptedSessionOnBlockerThread(cache);
+
+        session.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
+
+        SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder, session);
+
+        session.openForRead(new Session.OpenRequest(getActivity()));
+
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+        assertNotNull("Session should be open", tracker.getOpenSession());
+        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
+        tracker.getOpenSession().close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        tracker.stopTracking();
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    // Tests the SessionDelegate while tracking the active session and then a new session
+    public void testDelegateWithActiveSessionThenNewSession() throws Exception {
+        Session.setActiveSession(null);
+        final SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        final MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        final ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+
+        session.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
+
+        SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder);
+        Session.setActiveSession(session);
+
+        session.openForRead(new Session.OpenRequest(getActivity()));
+
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+        assertNotNull("Session should be open", tracker.getOpenSession());
+        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
+        tracker.getOpenSession().close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        final ScriptedSession newSession = createScriptedSessionOnBlockerThread(cache);
+        newSession.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
+
+        tracker.setSession(newSession);
+        assertNull("Session should not be open", tracker.getOpenSession());
+        newSession.openForRead(new Session.OpenRequest(getActivity()));
+
+        statusRecorder.waitForCall(newSession, SessionState.OPENING, null);
+        statusRecorder.waitForCall(newSession, SessionState.OPENED, null);
+        assertNotNull("Session should be open", tracker.getOpenSession());
+        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
+        tracker.getOpenSession().close();
+        statusRecorder.waitForCall(newSession, SessionState.CLOSED, null);
+
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        tracker.stopTracking();
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    // Tests the SessionDelegate while tracking a new session and then an active session
+    public void testDelegateWithSessionThenActiveSession() throws Exception {
+        Session.setActiveSession(null);
+        final SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
+        final MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        final ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
+
+        session.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
+
+        final SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder, session);
+
+        session.openForRead(new Session.OpenRequest(getActivity()));
+
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+        assertNotNull("Session should be open", tracker.getOpenSession());
+        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
+        tracker.getOpenSession().close();
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        final ScriptedSession newSession = createScriptedSessionOnBlockerThread(cache);
+        newSession.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
+
+        // need to run on the blocker thread so that when we register the 
+        // BroadcastReceivers, the handler gets run on the right thread
+        runOnBlockerThread(new Runnable() {
+            public void run() {
+                tracker.setSession(null);
+                Session.setActiveSession(newSession);
+            }
+        }, true);
+
+        assertNull("Session should not be open", tracker.getOpenSession());
+        newSession.openForRead(new Session.OpenRequest(getActivity()));
+
+        statusRecorder.waitForCall(newSession, SessionState.OPENING, null);
+        statusRecorder.waitForCall(newSession, SessionState.OPENED, null);
+        assertNotNull("Session should be open", tracker.getOpenSession());
+        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
+        tracker.getOpenSession().close();
+        statusRecorder.waitForCall(newSession, SessionState.CLOSED, null);
+
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        tracker.stopTracking();
+        statusRecorder.close();
+    }
+}
diff --git a/facebook/tests/src/com/facebook/internal/ValidateTests.java b/facebook/tests/src/com/facebook/internal/ValidateTests.java
new file mode 100644
index 000000000..f04934ef3
--- /dev/null
+++ b/facebook/tests/src/com/facebook/internal/ValidateTests.java
@@ -0,0 +1,105 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.internal;
+
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.internal.Validate;
+
+import java.util.Arrays;
+
+public class ValidateTests extends AndroidTestCase {
+    
+    @SmallTest
+    public void testNotNullOnNonNull() {
+        Validate.notNull("A string", "name");
+    }
+
+    @SmallTest
+    public void testNotNullOnNull() {
+        try {
+            Validate.notNull(null, "name");
+            fail("expected exception");
+        } catch (Exception e) {
+        }
+    }
+
+    @SmallTest
+    public void testNotEmptyOnNonEmpty() {
+        Validate.notEmpty(Arrays.asList(new String[] { "hi" }), "name");
+    }
+
+    @SmallTest
+    public void testNotEmptylOnEmpty() {
+        try {
+            Validate.notEmpty(Arrays.asList(new String[] {}), "name");
+            fail("expected exception");
+        } catch (Exception e) {
+        }
+    }
+
+    @SmallTest
+    public void testNotNullOrEmptyOnNonEmpty() {
+        Validate.notNullOrEmpty("hi", "name");
+    }
+
+    @SmallTest
+    public void testNotNullOrEmptyOnEmpty() {
+        try {
+            Validate.notNullOrEmpty("", "name");
+            fail("expected exception");
+        } catch (Exception e) {
+        }
+    }
+
+    @SmallTest
+    public void testNotNullOrEmptyOnNull() {
+        try {
+            Validate.notNullOrEmpty(null, "name");
+            fail("expected exception");
+        } catch (Exception e) {
+        }
+    }
+
+    @SmallTest
+    public void testOneOfOnValid() {
+        Validate.oneOf("hi", "name", "hi", "there");
+    }
+
+    @SmallTest
+    public void testOneOfOnInvalid() {
+        try {
+            Validate.oneOf("hit", "name", "hi", "there");
+            fail("expected exception");
+        } catch (Exception e) {
+        }
+    }
+
+    @SmallTest
+    public void testOneOfOnValidNull() {
+        Validate.oneOf(null, "name", "hi", "there", null);
+    }
+
+    @SmallTest
+    public void testOneOfOnInvalidNull() {
+        try {
+            Validate.oneOf(null, "name", "hi", "there");
+            fail("expected exception");
+        } catch (Exception e) {
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/model/GraphObjectFactoryTests.java b/facebook/tests/src/com/facebook/model/GraphObjectFactoryTests.java
new file mode 100644
index 000000000..c60208db6
--- /dev/null
+++ b/facebook/tests/src/com/facebook/model/GraphObjectFactoryTests.java
@@ -0,0 +1,1145 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.model;
+
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.FacebookGraphObjectException;
+import junit.framework.Assert;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.*;
+import java.util.Map.Entry;
+
+public final class GraphObjectFactoryTests extends AndroidTestCase {
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCreateEmptyGraphObject() {
+        GraphObject graphObject = GraphObject.Factory.create();
+        assertTrue(graphObject != null);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanTreatAsMap() {
+        GraphObject graphObject = GraphObject.Factory.create();
+
+        graphObject.setProperty("hello", "world");
+        assertEquals("world", (String) graphObject.asMap().get("hello"));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanTreatAsGraphPlace() {
+        GraphPlace graphPlace = GraphObject.Factory.create(GraphPlace.class);
+
+        graphPlace.setName("hello");
+        assertEquals("hello", graphPlace.getName());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanTreatAsGraphUser() {
+        GraphUser graphUser = GraphObject.Factory.create(GraphUser.class);
+
+        graphUser.setFirstName("Michael");
+        assertEquals("Michael", graphUser.getFirstName());
+        assertEquals("Michael", graphUser.getProperty("first_name"));
+        assertEquals("Michael", graphUser.asMap().get("first_name"));
+
+        graphUser.setProperty("last_name", "Scott");
+        assertEquals("Scott", graphUser.getProperty("last_name"));
+        assertEquals("Scott", graphUser.getLastName());
+        assertEquals("Scott", graphUser.asMap().get("last_name"));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanCastBetweenGraphObjectTypes() {
+        GraphObject graphObject = GraphObject.Factory.create();
+
+        graphObject.setProperty("first_name", "Mickey");
+
+        GraphUser graphUser = graphObject.cast(GraphUser.class);
+        assertTrue(graphUser != null);
+        // Should see the name we set earlier as a GraphObject.
+        assertEquals("Mickey", graphUser.getFirstName());
+
+        // Changes to GraphUser should be reflected in GraphObject version.
+        graphUser.setLastName("Mouse");
+        assertEquals("Mouse", graphObject.getProperty("last_name"));
+    }
+
+    interface Base extends GraphObject {
+    }
+
+    interface Derived extends Base {
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCastingToSameTypeGivesSameObject() {
+        Base base = GraphObject.Factory.create(Base.class);
+
+        Base cast = base.cast(Base.class);
+
+        assertTrue(base == cast);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCastingToBaseTypeGivesSameObject() {
+        Derived derived = GraphObject.Factory.create(Derived.class);
+
+        Base cast = derived.cast(Base.class);
+        assertTrue(derived == cast);
+
+        cast = cast.cast(Derived.class);
+        assertTrue(derived == cast);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanSetComplexTypes() {
+        GraphLocation graphLocation = GraphObject.Factory.create(GraphLocation.class);
+        graphLocation.setCity("Seattle");
+
+        GraphPlace graphPlace = GraphObject.Factory.create(GraphPlace.class);
+        graphPlace.setLocation(graphLocation);
+
+        assertEquals(graphLocation, graphPlace.getLocation());
+        assertEquals("Seattle", graphPlace.getLocation().getCity());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanConvertFromJSON() throws JSONException {
+        JSONObject jsonLocation = new JSONObject();
+        jsonLocation.put("city", "Paris");
+        jsonLocation.put("country", "France");
+
+        JSONObject jsonPlace = new JSONObject();
+        jsonPlace.put("location", jsonLocation);
+        jsonPlace.put("name", "Eiffel Tower");
+
+        GraphPlace graphPlace = GraphObject.Factory.create(jsonPlace, GraphPlace.class);
+        GraphLocation graphLocation = graphPlace.getLocation();
+        assertEquals("Paris", graphLocation.getCity());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanConvertFromGraphObject() throws JSONException {
+        GraphObject graphObject = GraphObject.Factory.create();
+        graphObject.setProperty("city", "Paris");
+        graphObject.setProperty("country", "France");
+
+        JSONObject jsonPlace = new JSONObject();
+        jsonPlace.put("location", graphObject);
+        jsonPlace.put("name", "Eiffel Tower");
+
+        GraphPlace graphPlace = GraphObject.Factory.create(jsonPlace, GraphPlace.class);
+        GraphLocation graphLocation = graphPlace.getLocation();
+        assertEquals("Paris", graphLocation.getCity());
+    }
+
+    private abstract class GraphObjectClass implements GraphObject {
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanConvertNumbers() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("double_as_string", 3.14159);
+        jsonObject.put("int_as_string", 42);
+
+        GraphMetric metric = GraphObject.Factory.create(jsonObject, GraphMetric.class);
+        assertEquals("42", metric.getIntAsString());
+        assertNotNull(metric.getDoubleAsString());
+        assertTrue(metric.getDoubleAsString().startsWith("3.14159"));
+    }
+
+    private interface GraphMetric extends GraphObject {
+        String getIntAsString();
+        String getDoubleAsString();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapNonInterface() {
+        try {
+            GraphObject.Factory.create(GraphObjectClass.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface BadNoParameterMethodNameGraphObject extends GraphObject {
+        Object floppityFlee();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadZeroParameterMethodName() {
+        try {
+            GraphObject.Factory.create(BadNoParameterMethodNameGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface BadSingleParameterMethodNameGraphObject extends GraphObject {
+        void floppityFlee(Object obj);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadSingleParameterMethodName() {
+        try {
+            GraphObject.Factory.create(BadSingleParameterMethodNameGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface BadGetterNameGraphObject extends GraphObject {
+        void get();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadGetterName() {
+        try {
+            GraphObject.Factory.create(BadGetterNameGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface BadGetterParamsGraphObject extends GraphObject {
+        Object getFoo(Object obj);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadGetterParams() {
+        try {
+            GraphObject.Factory.create(BadGetterParamsGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface BadGetterReturnTypeGraphObject extends GraphObject {
+        void getFoo();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadGetterReturnType() {
+        try {
+            GraphObject.Factory.create(BadGetterReturnTypeGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface BadSetterNameGraphObject extends GraphObject {
+        void set();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadSetterName() {
+        try {
+            GraphObject.Factory.create(BadSetterNameGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface BadSetterParamsGraphObject extends GraphObject {
+        void setFoo();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadSetterParams() {
+        try {
+            GraphObject.Factory.create(BadSetterParamsGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface BadSetterReturnTypeGraphObject extends GraphObject {
+        Object setFoo(Object obj);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadSetterReturnType() {
+        try {
+            GraphObject.Factory.create(BadSetterReturnTypeGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface BadBaseInterfaceGraphObject extends BadSetterReturnTypeGraphObject {
+        void setBar(Object obj);
+
+        Object getBar();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadBaseInterface() {
+        try {
+            GraphObject.Factory.create(BadBaseInterfaceGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    private interface GoodPropertyOverrideInterfaceGraphObject extends GraphObject {
+        void setDefaultName(String s);
+
+        // No annotation to ensure that the right property is being set.
+        String getAnotherDefaultName();
+
+        @PropertyName("another_default_name")
+        void putSomething(String s);
+
+        @PropertyName("default_name")
+        String retrieveSomething();
+
+        @PropertyName("MixedCase")
+        void setMixedCase(String s);
+
+        @PropertyName("MixedCase")
+        String getMixedCase();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanOverrideGraphPropertyNames() {
+        GoodPropertyOverrideInterfaceGraphObject graphObject =
+                GraphObject.Factory.create(GoodPropertyOverrideInterfaceGraphObject.class);
+
+        String testValue = "flu-blah";
+        graphObject.setDefaultName(testValue);
+        Assert.assertEquals(testValue, graphObject.retrieveSomething());
+
+        testValue = testValue + "1";
+        graphObject.putSomething(testValue);
+        Assert.assertEquals(testValue, graphObject.getAnotherDefaultName());
+
+        testValue = testValue + "2";
+        graphObject.setMixedCase(testValue);
+        Assert.assertEquals(testValue, graphObject.getMixedCase());
+    }
+
+    private interface BadPropertyOverrideInterfaceGraphObject extends GraphObject {
+        @PropertyName("")
+        void setMissingProperty(Object value);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantWrapBadPropertyNameOverrides() {
+        try {
+            GraphObject.Factory.create(BadPropertyOverrideInterfaceGraphObject.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testObjectEquals() {
+        GraphObject graphObject = GraphObject.Factory.create();
+        graphObject.setProperty("aKey", "aValue");
+
+        assertTrue(graphObject.equals(graphObject));
+
+        GraphPlace graphPlace = graphObject.cast(GraphPlace.class);
+        assertTrue(graphObject.equals(graphPlace));
+        assertTrue(graphPlace.equals(graphObject));
+
+        GraphObject aDifferentGraphObject = GraphObject.Factory.create();
+        aDifferentGraphObject.setProperty("aKey", "aDifferentValue");
+        assertFalse(graphObject.equals(aDifferentGraphObject));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testGetProperty() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
+        assertEquals("world", graphObject.getProperty("hello"));
+        assertTrue(graphObject.getProperty("fred") == null);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testSetProperty() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
+
+        graphObject.setProperty("hello", "world");
+        graphObject.setProperty("don't imagine", "purple elephants");
+
+        assertEquals("world", jsonObject.getString("hello"));
+        assertEquals("purple elephants", jsonObject.getString("don't imagine"));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testRemoveProperty() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("whirled", "peas");
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
+
+        graphObject.setProperty("hello", "world");
+        graphObject.setProperty("don't imagine", "purple elephants");
+
+        assertEquals("world", jsonObject.getString("hello"));
+        assertEquals("purple elephants", jsonObject.getString("don't imagine"));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapClear() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
+
+        assertEquals(1, jsonObject.length());
+
+        graphObject.asMap().clear();
+
+        assertEquals(0, jsonObject.length());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapContainsKey() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
+
+        assertTrue(graphObject.asMap().containsKey("hello"));
+        assertFalse(graphObject.asMap().containsKey("hocus"));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapContainsValue() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
+
+        assertTrue(graphObject.asMap().containsValue("world"));
+        assertFalse(graphObject.asMap().containsValue("pocus"));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapEntrySet() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
+
+        Set<Entry<String, Object>> entrySet = graphObject.asMap().entrySet();
+        assertEquals(2, entrySet.size());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapGet() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
+        assertEquals("world", graphObject.asMap().get("hello"));
+        assertTrue(graphObject.getProperty("fred") == null);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapGetReturnsNullForMissingProperty() throws JSONException {
+        GraphUser graphUser = GraphObject.Factory.create(GraphUser.class);
+        assertNull(graphUser.getBirthday());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapIsEmpty() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
+        assertTrue(graphObject.asMap().isEmpty());
+
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+        assertFalse(graphObject.asMap().isEmpty());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapKeySet() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
+
+        Set<String> keySet = graphObject.asMap().keySet();
+        assertEquals(2, keySet.size());
+        assertTrue(keySet.contains("hello"));
+        assertTrue(keySet.contains("hocus"));
+        assertFalse(keySet.contains("world"));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapPut() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
+        graphObject.setProperty("hello", "world");
+        graphObject.setProperty("hocus", "pocus");
+
+        assertEquals("pocus", jsonObject.get("hocus"));
+        assertEquals(2, jsonObject.length());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapPutOfWrapperPutsJSONObject() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
+        graphObject.setProperty("hello", "world");
+        graphObject.setProperty("hocus", "pocus");
+
+        GraphObject parentObject = GraphObject.Factory.create();
+        parentObject.setProperty("key", graphObject);
+
+        JSONObject jsonParent = parentObject.getInnerJSONObject();
+        Object obj = jsonParent.opt("key");
+
+        assertNotNull(obj);
+        assertEquals(jsonObject, obj);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapPutOfWrapperPutsJSONArray() throws JSONException {
+        JSONArray jsonArray = new JSONArray();
+
+        GraphObjectList<String> graphObjectList = GraphObject.Factory
+                .createList(jsonArray, String.class);
+        graphObjectList.add("hello");
+        graphObjectList.add("world");
+
+        GraphObject parentObject = GraphObject.Factory.create();
+        parentObject.setProperty("key", graphObjectList);
+
+        JSONObject jsonParent = parentObject.getInnerJSONObject();
+        Object obj = jsonParent.opt("key");
+
+        assertNotNull(obj);
+        assertEquals(jsonArray, obj);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapPutAll() throws JSONException {
+        HashMap<String, Object> map = new HashMap<String, Object>();
+        map.put("hello", "world");
+        map.put("hocus", "pocus");
+
+        JSONObject jsonObject = new JSONObject();
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
+
+        graphObject.asMap().putAll(map);
+        assertEquals("pocus", jsonObject.get("hocus"));
+        assertEquals(2, jsonObject.length());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapRemove() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
+        graphObject.removeProperty("hello");
+
+        assertEquals(1, jsonObject.length());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapSize() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
+
+        assertEquals(2, graphObject.asMap().size());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMapValues() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
+
+        Collection<Object> values = graphObject.asMap().values();
+
+        assertEquals(2, values.size());
+        assertTrue(values.contains("world"));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testGetInnerJSONObject() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
+
+        assertEquals(jsonObject, graphObject.getInnerJSONObject());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testSettingGraphObjectProxyStoresJSONObject() throws JSONException {
+        GraphPlace graphPlace = GraphObject.Factory.create(GraphPlace.class);
+        GraphLocation graphLocation = GraphObject.Factory.create(GraphLocation.class);
+
+        graphPlace.setLocation(graphLocation);
+
+        assertEquals(graphLocation.getInnerJSONObject(), graphPlace.getInnerJSONObject().get("location"));
+
+    }
+
+    private interface DateGraphObject extends GraphObject {
+        Date getDate1();
+
+        Date getDate2();
+
+        Date getDate3();
+
+        Date getDate4();
+        void setDate4(Date date);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testGetStringsAsDates() {
+        DateGraphObject dates = GraphObject.Factory.create(DateGraphObject.class);
+        dates.setProperty("date1", "2012-07-04");
+        dates.setProperty("date2", "2012-07-04T19:30:50");
+        dates.setProperty("date3", "2012-07-04T19:20:40-0400");
+
+        // Dates without a time zone should be assumed to be in the current timezone.
+        Calendar cal = new GregorianCalendar();
+        cal.set(Calendar.MILLISECOND, 0);
+
+        cal.set(2012, 6, 4, 0, 0, 0);
+        Date expectedDate1 = cal.getTime();
+        Date date1 = dates.getDate1();
+        assertEquals(expectedDate1, date1);
+
+        cal.set(2012, 6, 4, 19, 30, 50);
+        Date expectedDate2 = cal.getTime();
+        Date date2 = dates.getDate2();
+        assertEquals(expectedDate2, date2);
+
+        // Dates with an explicit time zone should take that timezone into account.
+        cal = new GregorianCalendar(TimeZone.getTimeZone("GMT"));
+        cal.set(Calendar.MILLISECOND, 0);
+        cal.set(2012, 6, 4, 23, 20, 40);
+
+        Date expectedDate3 = cal.getTime();
+        Date date3 = dates.getDate3();
+        assertEquals(expectedDate3, date3);
+
+        cal.set(2012, 9, 28, 9, 53, 0);
+        Date expectedDate4 = cal.getTime();
+        dates.setDate4(expectedDate4);
+        Date date4 = dates.getDate4();
+        assertEquals(expectedDate4, date4);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionAdd() throws JSONException {
+        JSONArray array = new JSONArray();
+
+        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
+        collection.add(5);
+
+        assertTrue(array.length() == 1);
+        assertTrue(array.optInt(0) == 5);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionAddAll() throws JSONException {
+        JSONArray array = new JSONArray();
+
+        Collection<Integer> collectionToAdd = Arrays.asList(5, -1);
+
+        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
+        collection.addAll(collectionToAdd);
+
+        assertTrue(array.length() == 2);
+        assertTrue(array.optInt(0) == 5);
+        assertTrue(array.optInt(1) == -1);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionContains() throws JSONException {
+        JSONArray array = new JSONArray();
+        array.put(5);
+
+        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
+        assertTrue(collection.contains(5));
+        assertFalse(collection.contains(6));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionContainsAll() throws JSONException {
+        JSONArray array = new JSONArray();
+        array.put(5);
+        array.put(-1);
+
+        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
+        assertTrue(collection.containsAll(Arrays.asList(5)));
+        assertTrue(collection.containsAll(Arrays.asList(5, -1)));
+        assertFalse(collection.containsAll(Arrays.asList(5, -1, 2)));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionIsEmpty() throws JSONException {
+        JSONArray array = new JSONArray();
+
+        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
+        assertTrue(collection.isEmpty());
+
+        array.put(5);
+        assertFalse(collection.isEmpty());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionIterator() throws JSONException {
+        JSONArray array = new JSONArray();
+        array.put(5);
+        array.put(-1);
+
+        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
+        Iterator<Integer> iter = collection.iterator();
+        assertTrue(iter.hasNext());
+        assertTrue(iter.next() == 5);
+        assertTrue(iter.hasNext());
+        assertTrue(iter.next() == -1);
+        assertFalse(iter.hasNext());
+
+        for (Integer i : collection) {
+            assertNotSame(0, i);
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionIteratorOfGraphObject() throws JSONException {
+        Collection<GraphLocation> collection = GraphObject.Factory.createList(GraphLocation.class);
+
+        GraphLocation seattle = GraphObject.Factory.create(GraphLocation.class);
+        seattle.setCity("Seattle");
+        collection.add(seattle);
+        GraphLocation paris = GraphObject.Factory.create(GraphLocation.class);
+        paris.setCity("Paris");
+        collection.add(paris);
+
+        Iterator<GraphLocation> iter = collection.iterator();
+        assertTrue(iter.hasNext());
+        assertEquals(seattle, iter.next());
+        assertTrue(iter.hasNext());
+        assertEquals(paris, iter.next());
+        assertFalse(iter.hasNext());
+
+        for (GraphLocation location : collection) {
+            assertTrue(location != null);
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionSize() throws JSONException {
+        JSONArray array = new JSONArray();
+
+        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
+        assertEquals(0, collection.size());
+
+        array.put(5);
+        assertEquals(1, collection.size());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionClearThrows() throws JSONException {
+        try {
+            Collection<Integer> collection = GraphObject.Factory.createList(Integer.class);
+            collection.clear();
+            fail("Expected exception");
+        } catch (UnsupportedOperationException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionRemoveThrows() throws JSONException {
+        try {
+            Collection<Integer> collection = GraphObject.Factory.createList(Integer.class);
+            collection.remove(5);
+            fail("Expected exception");
+        } catch (UnsupportedOperationException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionRemoveAllThrows() throws JSONException {
+        try {
+            Collection<Integer> collection = GraphObject.Factory.createList(Integer.class);
+            collection.removeAll(Arrays.asList());
+            fail("Expected exception");
+        } catch (UnsupportedOperationException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionRetainAllThrows() throws JSONException {
+        try {
+            Collection<Integer> collection = GraphObject.Factory.createList(Integer.class);
+            collection.retainAll(Arrays.asList());
+            fail("Expected exception");
+        } catch (UnsupportedOperationException exception) {
+        }
+    }
+
+    private interface Locations extends GraphObject {
+        Collection<GraphLocation> getLocations();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testObjectWrapsJSONCollection() throws JSONException {
+        JSONObject jsonLocation = new JSONObject();
+        jsonLocation.put("city", "Seattle");
+
+        JSONArray jsonArray = new JSONArray();
+        jsonArray.put(jsonLocation);
+
+        JSONObject jsonLocations = new JSONObject();
+        jsonLocations.put("locations", jsonArray);
+
+        Locations locations = GraphObject.Factory.create(jsonLocations, Locations.class);
+        Collection<GraphLocation> locationsGraphObjectCollection = locations.getLocations();
+        assertTrue(locationsGraphObjectCollection != null);
+
+        GraphLocation graphLocation = locationsGraphObjectCollection.iterator().next();
+        assertTrue(graphLocation != null);
+        assertEquals("Seattle", graphLocation.getCity());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testObjectWrapsIterable() throws JSONException {
+        GraphUser user = GraphObject.Factory.create(GraphUser.class);
+        user.setFirstName("Foo");
+        user.setLastName("Bar");
+
+        List<GraphUser> users = new ArrayList<GraphUser>();
+        users.add(user);
+
+        OpenGraphAction action = GraphObject.Factory.create(OpenGraphAction.class);
+        action.setTags(users);
+
+        String json = action.getInnerJSONObject().toString();
+
+        assertTrue("JSON string should contain last_name", json.contains("last_name"));
+
+        Object tags = action.getInnerJSONObject().get("tags");
+        assertNotNull("tags should not be null", tags);
+        assertTrue("tags should be JSONArray", tags instanceof JSONArray);
+
+        List<GraphObject> retrievedUsers = action.getTags();
+        assertEquals("Size should be 1", 1, retrievedUsers.size());
+        GraphUser retrievedUser = retrievedUsers.get(0).cast(GraphUser.class);
+        assertEquals("First name should be Foo", "Foo", retrievedUser.getFirstName());
+        assertEquals("Last name should be Bar", "Bar", retrievedUser.getLastName());
+
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionWrapsJSONObject() throws JSONException {
+        JSONObject jsonLocation = new JSONObject();
+        jsonLocation.put("city", "Seattle");
+
+        JSONArray jsonArray = new JSONArray();
+        jsonArray.put(jsonLocation);
+        Collection<GraphLocation> locationsGraphObjectCollection = GraphObject.Factory
+                .createList(jsonArray,
+                        GraphLocation.class);
+        assertTrue(locationsGraphObjectCollection != null);
+
+        GraphLocation graphLocation = locationsGraphObjectCollection.iterator().next();
+        assertTrue(graphLocation != null);
+        assertEquals("Seattle", graphLocation.getCity());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCannotCastCollectionOfNonGraphObjects() throws JSONException {
+        try {
+            GraphObjectList<Integer> collection = GraphObject.Factory.createList(Integer.class);
+            collection.castToListOf(GraphLocation.class);
+            fail("Expected exception");
+        } catch (FacebookGraphObjectException exception) {
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanCastCollectionOfGraphObjects() throws JSONException {
+        JSONObject jsonSeattle = new JSONObject();
+        jsonSeattle.put("city", "Seattle");
+
+        JSONArray jsonArray = new JSONArray();
+        jsonArray.put(jsonSeattle);
+
+        GraphObjectList<GraphObject> collection = GraphObject.Factory
+                .createList(jsonArray, GraphObject.class);
+
+        GraphObjectList<GraphLocation> locationCollection = collection.castToListOf(GraphLocation.class);
+        assertTrue(locationCollection != null);
+
+        GraphLocation seattle = locationCollection.iterator().next();
+        assertTrue(seattle != null);
+        assertEquals("Seattle", seattle.getCity());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCastingCollectionToSameTypeGivesSameObject() {
+        GraphObjectList<Base> base = GraphObject.Factory.createList(Base.class);
+
+        GraphObjectList<Base> cast = base.castToListOf(Base.class);
+
+        assertTrue(base == cast);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCastingCollectionToBaseTypeGivesSameObject() {
+        GraphObjectList<Derived> derived = GraphObject.Factory.createList(Derived.class);
+
+        GraphObjectList<Base> cast = derived.castToListOf(Base.class);
+
+        assertTrue((GraphObjectList<?>)derived == (GraphObjectList<?>)cast);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanGetInnerJSONArray() throws JSONException {
+        JSONArray jsonArray = new JSONArray();
+
+        GraphObjectList<GraphObject> collection = GraphObject.Factory
+                .createList(jsonArray, GraphObject.class);
+
+        assertEquals(jsonArray, collection.getInnerJSONArray());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanGetRandomAccess() throws JSONException {
+        JSONArray jsonArray = new JSONArray();
+        jsonArray.put("Seattle");
+        jsonArray.put("Menlo Park");
+
+        GraphObjectList<String> collection = GraphObject.Factory
+                .createList(jsonArray, String.class);
+
+        assertEquals("Menlo Park", collection.get(1));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanSetRandomAccess() throws JSONException {
+        JSONArray jsonArray = new JSONArray();
+
+        GraphObjectList<String> collection = GraphObject.Factory
+                .createList(jsonArray, String.class);
+
+        collection.add("Seattle");
+        collection.add("Menlo Park");
+
+        collection.set(1, "Ann Arbor");
+        assertEquals("Ann Arbor", collection.get(1));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCollectionPutOfWrapperPutsJSONObject() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+
+        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
+        graphObject.setProperty("hello", "world");
+        graphObject.setProperty("hocus", "pocus");
+
+        GraphObjectList<GraphObject> parentList = GraphObject.Factory
+                .createList(GraphObject.class);
+        parentList.add(graphObject);
+
+        JSONArray jsonArray = parentList.getInnerJSONArray();
+
+        Object obj = jsonArray.opt(0);
+
+        assertNotNull(obj);
+        assertEquals(jsonObject, obj);
+
+        parentList.set(0, graphObject);
+
+        obj = jsonArray.opt(0);
+
+        assertNotNull(obj);
+        assertEquals(jsonObject, obj);
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCamelCaseToLowercase() {
+        assertEquals("hello_world", GraphObject.Factory
+                .convertCamelCaseToLowercaseWithUnderscores("HelloWorld"));
+        assertEquals("hello_world", GraphObject.Factory
+                .convertCamelCaseToLowercaseWithUnderscores("helloWorld"));
+    }
+
+
+}
diff --git a/facebook/tests/src/com/facebook/model/JsonUtilTests.java b/facebook/tests/src/com/facebook/model/JsonUtilTests.java
new file mode 100644
index 000000000..0c55d30ea
--- /dev/null
+++ b/facebook/tests/src/com/facebook/model/JsonUtilTests.java
@@ -0,0 +1,103 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.model;
+
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map.Entry;
+import java.util.Set;
+
+public final class JsonUtilTests extends AndroidTestCase {
+
+    @SmallTest @MediumTest @LargeTest
+    public void testJsonObjectClear() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        JsonUtil.jsonObjectClear(jsonObject);
+        assertEquals(0, jsonObject.length());
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testJsonObjectContainsValue() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        assertTrue(JsonUtil.jsonObjectContainsValue(jsonObject, "pocus"));
+        assertFalse(JsonUtil.jsonObjectContainsValue(jsonObject, "Fred"));
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testJsonObjectEntrySet() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        Set<Entry<String, Object>> entrySet = JsonUtil.jsonObjectEntrySet(jsonObject);
+        assertEquals(2, entrySet.size());
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testJsonObjectKeySet() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        Set<String> keySet = JsonUtil.jsonObjectKeySet(jsonObject);
+        assertEquals(2, keySet.size());
+        assertTrue(keySet.contains("hello"));
+        assertFalse(keySet.contains("world"));
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testJsonObjectPutAll() throws JSONException {
+        HashMap<String, Object> map = new HashMap<String, Object>();
+        map.put("hello", "world");
+        map.put("hocus", "pocus");
+
+        JSONObject jsonObject = new JSONObject();
+        JsonUtil.jsonObjectPutAll(jsonObject, map);
+
+        assertEquals("pocus", jsonObject.get("hocus"));
+        assertEquals(2, jsonObject.length());
+    }
+
+    @SmallTest @MediumTest @LargeTest
+    public void testJsonObjectValues() throws JSONException {
+        JSONObject jsonObject = new JSONObject();
+        jsonObject.put("hello", "world");
+        jsonObject.put("hocus", "pocus");
+
+        Collection<Object> values = JsonUtil.jsonObjectValues(jsonObject);
+
+        assertEquals(2, values.size());
+        assertTrue(values.contains("world"));
+    }
+}
diff --git a/facebook/tests/src/com/facebook/widget/FragmentTestCase.java b/facebook/tests/src/com/facebook/widget/FragmentTestCase.java
new file mode 100644
index 000000000..e948bc300
--- /dev/null
+++ b/facebook/tests/src/com/facebook/widget/FragmentTestCase.java
@@ -0,0 +1,98 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+import android.widget.LinearLayout;
+import com.facebook.FacebookActivityTestCase;
+
+public class FragmentTestCase<T extends FragmentTestCase.TestFragmentActivity<?>> extends FacebookActivityTestCase<T> {
+    public FragmentTestCase(Class<T> activityClass) {
+        super(activityClass);
+    }
+
+    protected T getTestActivity() {
+        return (T) getActivity();
+    }
+
+    public static class TestFragmentActivity<T extends Fragment> extends FragmentActivity {
+        public static final int FRAGMENT_ID = 0xFACE;
+
+        private Class<T> fragmentClass;
+        private int fragmentId;
+
+        protected TestFragmentActivity(Class<T> fragmentClass) {
+            this.fragmentClass = fragmentClass;
+        }
+
+        @Override
+        protected void onCreate(Bundle savedInstanceState) {
+            super.onCreate(savedInstanceState);
+            if (getAutoCreateUI()) {
+                setContentToFragment(null);
+            }
+        }
+
+        protected boolean getAutoCreateUI() {
+            return true;
+        }
+
+        void setContentToFragment(T fragment) {
+            if (fragment == null) {
+                fragment = createFragment();
+            }
+
+            LinearLayout layout = new LinearLayout(this);
+            layout.setOrientation(LinearLayout.VERTICAL);
+            layout.setLayoutParams(new LinearLayout.LayoutParams(LinearLayout.LayoutParams.FILL_PARENT,
+                    LinearLayout.LayoutParams.FILL_PARENT));
+            layout.setId(FRAGMENT_ID);
+
+            getSupportFragmentManager().beginTransaction()
+                    .add(FRAGMENT_ID, fragment)
+                    .commit();
+
+            fragmentId = FRAGMENT_ID;
+
+            setContentView(layout);
+        }
+
+        void setContentToLayout(int i, int fragmentId) {
+            this.fragmentId = fragmentId;
+            setContentView(i);
+        }
+
+        T createFragment() {
+            try {
+                return fragmentClass.newInstance();
+            } catch (IllegalAccessException e) {
+                fail("could not create fragment");
+            } catch (InstantiationException e) {
+                fail("could not create fragment");
+            }
+            return null;
+        }
+
+        T getFragment() {
+            @SuppressWarnings("unchecked")
+            T fragment = (T) getSupportFragmentManager().findFragmentById(fragmentId);
+            return fragment;
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/widget/FriendPickerFragmentTests.java b/facebook/tests/src/com/facebook/widget/FriendPickerFragmentTests.java
new file mode 100644
index 000000000..b7a24cfba
--- /dev/null
+++ b/facebook/tests/src/com/facebook/widget/FriendPickerFragmentTests.java
@@ -0,0 +1,175 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.os.Bundle;
+import android.test.TouchUtils;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.view.View;
+import android.widget.CheckBox;
+import android.widget.ListView;
+import com.facebook.TestBlocker;
+import com.facebook.TestSession;
+import com.facebook.sdk.tests.R;
+
+import java.util.Arrays;
+import java.util.Collection;
+
+public class FriendPickerFragmentTests extends FragmentTestCase<FriendPickerFragmentTests.TestActivity> {
+    public FriendPickerFragmentTests() {
+        super(TestActivity.class);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCanSetParametersProgrammatically() throws Throwable {
+        TestActivity activity = getActivity();
+        assertNotNull(activity);
+
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                Bundle bundle = new Bundle();
+                // We deliberately set these to non-defaults to ensure they are set correctly.
+                bundle.putString(FriendPickerFragment.USER_ID_BUNDLE_KEY, "4");
+                bundle.putBoolean(FriendPickerFragment.MULTI_SELECT_BUNDLE_KEY, false);
+                bundle.putBoolean(FriendPickerFragment.SHOW_PICTURES_BUNDLE_KEY, false);
+                bundle.putString(FriendPickerFragment.EXTRA_FIELDS_BUNDLE_KEY, "middle_name,link");
+                FriendPickerFragment fragment = new FriendPickerFragment(bundle);
+                getActivity().setContentToFragment(fragment);
+            }
+        });
+
+        // We don't just test the fragment we created directly above, because we want it to go through the
+        // activity lifecycle and ensure the settings are still correct.
+        final FriendPickerFragment fragment = activity.getFragment();
+        assertNotNull(fragment);
+
+        assertEquals("4", fragment.getUserId());
+        assertEquals(false, fragment.getMultiSelect());
+        assertEquals(false, fragment.getShowPictures());
+        Collection<String> extraFields = fragment.getExtraFields();
+        assertTrue(extraFields.contains("middle_name"));
+        assertTrue(extraFields.contains("link"));
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCanSetParametersViaLayout() throws Throwable {
+        TestActivity activity = getActivity();
+        assertNotNull(activity);
+
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                getActivity().setContentToLayout(R.layout.friend_picker_test_layout_1, R.id.friend_picker_fragment);
+            }
+        });
+
+        final FriendPickerFragment fragment = activity.getFragment();
+        assertNotNull(fragment);
+
+        assertEquals(false, fragment.getShowPictures());
+        assertEquals(false, fragment.getMultiSelect());
+        Collection<String> extraFields = fragment.getExtraFields();
+        assertTrue(extraFields.contains("middle_name"));
+        assertTrue(extraFields.contains("link"));
+        // It doesn't make sense to specify user id via layout, so we don't support it.
+    }
+
+    @LargeTest
+    public void testFriendsLoad() throws Throwable {
+        TestActivity activity = getActivity();
+        assertNotNull(activity);
+
+        // We don't auto-create any UI, so do it now. Needs to run on the UI thread.
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                getActivity().setContentToFragment(null);
+            }
+        });
+
+        final FriendPickerFragment fragment = activity.getFragment();
+        assertNotNull(fragment);
+
+        // Ensure our test user has at least one friend.
+        final TestSession session1 = openTestSessionWithSharedUser();
+        TestSession session2 = openTestSessionWithSharedUser(SECOND_TEST_USER_TAG);
+        makeTestUsersFriends(session1, session2);
+
+        // Trigger a data load (on the UI thread).
+        final TestBlocker blocker = getTestBlocker();
+        // We expect to get called twice -- once with results, once to indicate we are done paging.
+        runAndBlockOnUiThread(2, new Runnable() {
+            @Override
+            public void run() {
+                fragment.setSession(session1);
+                fragment.setOnDataChangedListener(new PickerFragment.OnDataChangedListener() {
+                    @Override
+                    public void onDataChanged(PickerFragment<?> fragment) {
+                        blocker.signal();
+                    }
+                });
+                fragment.setExtraFields(Arrays.asList("first_name"));
+                fragment.loadData(true);
+            }
+        });
+
+        // We should have at least one item in the list by now.
+        ListView listView = (ListView) fragment.getView().findViewById(R.id.com_facebook_picker_list_view);
+        assertNotNull(listView);
+        View firstChild = listView.getChildAt(0);
+        assertNotNull(firstChild);
+
+        // Assert our state before we touch anything.
+        CheckBox checkBox = (CheckBox)listView.findViewById(R.id.com_facebook_picker_checkbox);
+        assertNotNull(checkBox);
+        assertFalse(checkBox.isChecked());
+        assertEquals(0, fragment.getSelection().size());
+
+        // Click on the first item in the list view.
+        TouchUtils.clickView(this, firstChild);
+
+        // We should have a selection (it might not be the user we made a friend up above, if the
+        // test user has more than one friend).
+        assertEquals(1, fragment.getSelection().size());
+
+        // We should have gotten the extra field we wanted.
+        assertNotNull(fragment.getSelection().iterator().next().getFirstName());
+
+        // And the checkbox should be checked.
+        assertTrue(checkBox.isChecked());
+
+        // Touch the item again. We should go back to no selection.
+        TouchUtils.clickView(this, firstChild);
+        assertEquals(0, fragment.getSelection().size());
+        assertFalse(checkBox.isChecked());
+    }
+
+    public static class TestActivity extends FragmentTestCase.TestFragmentActivity<FriendPickerFragment> {
+        public TestActivity() {
+            super(FriendPickerFragment.class);
+        }
+
+        @Override
+        protected boolean getAutoCreateUI() {
+            return false;
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/widget/GraphObjectPagingLoaderTests.java b/facebook/tests/src/com/facebook/widget/GraphObjectPagingLoaderTests.java
new file mode 100644
index 000000000..104bd49f1
--- /dev/null
+++ b/facebook/tests/src/com/facebook/widget/GraphObjectPagingLoaderTests.java
@@ -0,0 +1,162 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.location.Location;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.LoaderManager;
+import android.support.v4.content.Loader;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import com.facebook.*;
+import com.facebook.model.GraphPlace;
+
+public class GraphObjectPagingLoaderTests extends FragmentTestCase<GraphObjectPagingLoaderTests.TestActivity> {
+    public GraphObjectPagingLoaderTests() {
+        super(TestActivity.class);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testLoaderLoadsAndFollowsNextLinks() throws Exception {
+        CountingCallback callback = new CountingCallback();
+        final GraphObjectPagingLoader<GraphPlace> loader = (GraphObjectPagingLoader<GraphPlace>)
+                getActivity().getSupportLoaderManager().initLoader(0, null, callback);
+
+        TestSession session = openTestSessionWithSharedUser();
+
+        Location location = new Location("");
+        location.setLatitude(47.6204);
+        location.setLongitude(-122.3491);
+
+        final Request request = Request.newPlacesSearchRequest(session, location, 1000, 5, null, null);
+
+        // Need to run this on blocker thread so callbacks are made there.
+        runOnBlockerThread(new Runnable() {
+            @Override
+            public void run() {
+                loader.startLoading(request, false);
+            }
+        }, false);
+
+        getTestBlocker().waitForSignals(1);
+        assertEquals(1, callback.onLoadFinishedCount);
+        assertEquals(0, callback.onErrorCount);
+        assertEquals(0, callback.onLoadResetCount);
+        // We might not get back the exact number we requested because of privacy or other rules on
+        // the service side.
+        assertNotNull(callback.results);
+        assertTrue(callback.results.getCount() > 0);
+
+        runOnBlockerThread(new Runnable() {
+            @Override
+            public void run() {
+                loader.followNextLink();
+            }
+        }, false);
+        getTestBlocker().waitForSignals(1);
+        assertEquals(2, callback.onLoadFinishedCount);
+        assertEquals(0, callback.onErrorCount);
+        assertEquals(0, callback.onLoadResetCount);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testLoaderFinishesImmediatelyOnNoResults() throws Exception {
+        CountingCallback callback = new CountingCallback();
+        final GraphObjectPagingLoader<GraphPlace> loader = (GraphObjectPagingLoader<GraphPlace>)
+                getActivity().getSupportLoaderManager().initLoader(0, null, callback);
+
+        TestSession session = openTestSessionWithSharedUser();
+
+        // Unlikely to ever be a Place here.
+        Location location = new Location("");
+        location.setLatitude(-1.0);
+        location.setLongitude(-1.0);
+
+        final Request request = Request.newPlacesSearchRequest(session, location, 10, 5, null, null);
+
+        // Need to run this on blocker thread so callbacks are made there.
+        runOnBlockerThread(new Runnable() {
+            @Override
+            public void run() {
+                loader.startLoading(request, false);
+            }
+        }, false);
+
+        getTestBlocker().waitForSignals(1);
+        assertEquals(1, callback.onLoadFinishedCount);
+        assertEquals(0, callback.onErrorCount);
+        assertEquals(0, callback.onLoadResetCount);
+        assertNotNull(callback.results);
+        assertEquals(0, callback.results.getCount());
+    }
+
+    private class CountingCallback implements
+            GraphObjectPagingLoader.OnErrorListener, LoaderManager.LoaderCallbacks<SimpleGraphObjectCursor<GraphPlace>> {
+        public int onLoadFinishedCount;
+        public int onLoadResetCount;
+        public int onErrorCount;
+        public SimpleGraphObjectCursor<GraphPlace> results;
+
+        private TestBlocker testBlocker = getTestBlocker();
+
+        @Override
+        public void onError(FacebookException error, GraphObjectPagingLoader<?> loader) {
+            ++onErrorCount;
+            testBlocker.signal();
+        }
+
+        @Override
+        public Loader<SimpleGraphObjectCursor<GraphPlace>> onCreateLoader(int id, Bundle args) {
+            GraphObjectPagingLoader<GraphPlace> loader = new GraphObjectPagingLoader<GraphPlace>(getActivity(),
+                    GraphPlace.class);
+            loader.setOnErrorListener(this);
+            return loader;
+        }
+
+        @Override
+        public void onLoadFinished(Loader<SimpleGraphObjectCursor<GraphPlace>> loader,
+                SimpleGraphObjectCursor<GraphPlace> data) {
+            results = data;
+            ++onLoadFinishedCount;
+            testBlocker.signal();
+        }
+
+        @Override
+        public void onLoaderReset(Loader<SimpleGraphObjectCursor<GraphPlace>> loader) {
+            ++onLoadResetCount;
+            testBlocker.signal();
+        }
+    }
+
+    public static class DummyFragment extends Fragment  {
+    }
+
+    public static class TestActivity extends FragmentTestCase.TestFragmentActivity<DummyFragment> {
+        public TestActivity() {
+            super(DummyFragment.class);
+        }
+
+        @Override
+        protected boolean getAutoCreateUI() {
+            return false;
+        }
+    }
+
+}
diff --git a/facebook/tests/src/com/facebook/widget/ImageResponseCacheTests.java b/facebook/tests/src/com/facebook/widget/ImageResponseCacheTests.java
new file mode 100644
index 000000000..f1ca93ca8
--- /dev/null
+++ b/facebook/tests/src/com/facebook/widget/ImageResponseCacheTests.java
@@ -0,0 +1,108 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.test.AndroidTestCase;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import com.facebook.internal.Utility;
+import com.facebook.widget.ImageResponseCache;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+public final class ImageResponseCacheTests extends AndroidTestCase {
+
+    @MediumTest @LargeTest
+    public void testImageCaching() throws IOException {
+        // In unit test, since we need verify first access the image is not in cache
+        // we need clear the cache first
+        ImageResponseCache.getCache(safeGetContext()).clearForTest();
+        String imgUrl = "http://sphotos-b.xx.fbcdn.net/hphotos-snc7/300716_163831917043403_1106723719_n.jpg";
+        
+        Bitmap bmp1 = readImage(imgUrl, false);
+        Bitmap bmp2 = readImage(imgUrl, true);
+        compareImages(bmp1, bmp2);
+    }
+    
+    @MediumTest @LargeTest
+    public void testImageNotCaching() throws IOException {
+        
+        String imgUrl = "http://graph.facebook.com/ryanseacrest/picture?type=large";
+        
+        Bitmap bmp1 = readImage(imgUrl, false);
+        Bitmap bmp2 = readImage(imgUrl, false);
+        compareImages(bmp1, bmp2);
+    }
+
+    private Bitmap readImage(String uri, boolean expectedFromCache) {
+        Bitmap bmp = null;
+        InputStream istream = null;
+        try
+        {
+            URL url = new URL(uri);
+            // Check if the cache contains value for this url
+            boolean isInCache = (ImageResponseCache.getCache(safeGetContext()).get(url.toString()) != null);
+            assertTrue(isInCache == expectedFromCache);
+            // Read the image
+            istream = ImageResponseCache.getCachedImageStream(url, safeGetContext());
+            if (istream == null) {
+                HttpURLConnection connection = (HttpURLConnection)url.openConnection();
+                istream = ImageResponseCache.interceptAndCacheImageStream(safeGetContext(), connection);
+            }
+            assertTrue(istream != null);
+            bmp = BitmapFactory.decodeStream(istream);
+            assertTrue(bmp != null);
+        } catch (Exception e) {
+             assertNull(e);
+        } finally {
+            Utility.closeQuietly(istream);
+        }
+        return bmp;
+    }
+    
+    private static void compareImages(Bitmap bmp1, Bitmap bmp2) {
+        assertTrue(bmp1.getHeight() == bmp2.getHeight());
+        assertTrue(bmp1.getWidth() == bmp1.getWidth());
+        ByteBuffer buffer1 = ByteBuffer.allocate(bmp1.getHeight() * bmp1.getRowBytes());
+        bmp1.copyPixelsToBuffer(buffer1);
+
+        ByteBuffer buffer2 = ByteBuffer.allocate(bmp2.getHeight() * bmp2.getRowBytes());
+        bmp2.copyPixelsToBuffer(buffer2);
+
+        assertTrue(Arrays.equals(buffer1.array(), buffer2.array()));
+    }
+
+    private Context safeGetContext() {
+        for (;;) {
+            if ((getContext() != null) && (getContext().getApplicationContext() != null)) {
+                return getContext();
+            }
+            try {
+                Thread.sleep(25);
+            } catch (InterruptedException e) {
+            }
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/widget/LoginButtonTest.java b/facebook/tests/src/com/facebook/widget/LoginButtonTest.java
new file mode 100644
index 000000000..863585575
--- /dev/null
+++ b/facebook/tests/src/com/facebook/widget/LoginButtonTest.java
@@ -0,0 +1,313 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.*;
+import com.facebook.widget.LoginButton;
+import junit.framework.Assert;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+public class LoginButtonTest extends SessionTestsBase {
+
+    static final int STRAY_CALLBACK_WAIT_MILLISECONDS = 50;
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testLoginButton() throws Throwable {
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        final ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
+        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder = new SessionTestsBase.SessionStatusCallbackRecorder();
+
+        session.addAuthorizeResult("A token of thanks", new ArrayList<String>(), AccessTokenSource.TEST_USER);
+        session.addCallback(statusRecorder);
+
+        // Verify state with no token in cache
+        Assert.assertEquals(SessionState.CREATED, session.getState());
+
+        // Add another status recorder to ensure that the callback we hand to LoginButton
+        // also gets called as expected. We expect to get the same order of calls as statusRecorder does.
+        final SessionStatusCallbackRecorder loginButtonStatusRecorder = new SessionStatusCallbackRecorder();
+
+        // Create the button. To get session status updates, we need to actually attach the
+        // button to a window, which must be done on the UI thread.
+        final LoginButton button = new LoginButton(getActivity());
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                getActivity().setContentView(button);
+                button.setSession(session);
+                button.setSessionStatusCallback(loginButtonStatusRecorder);
+                button.performClick();
+            }
+        });
+
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        loginButtonStatusRecorder.waitForCall(session, SessionState.OPENING, null);
+
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+        loginButtonStatusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+        loginButtonStatusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testLoginFail() {
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
+        final Exception openException = new Exception("Open failed!");
+        final AtomicBoolean clicked = new AtomicBoolean(false);
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        final LoginButton button = new LoginButton(getActivity());
+        LoginButton.OnErrorListener listener = new LoginButton.OnErrorListener() {
+            @Override
+            public void onError(FacebookException exception) {
+                synchronized (this) {
+                    assertEquals(exception.getCause().getMessage(), openException.getMessage());
+                    clicked.set(true);
+                    this.notifyAll();
+                }
+            }
+        };
+        button.setOnErrorListener(listener);
+        button.setSession(session);
+        session.addAuthorizeResult(openException);
+
+        button.onAttachedToWindow();
+        button.performClick();
+
+        try {
+            synchronized (listener) {
+                listener.wait(DEFAULT_TIMEOUT_MILLISECONDS);
+            }
+        } catch (InterruptedException e) {
+            fail("Interrupted during open");
+        }
+
+        if (!clicked.get()) {
+            fail("Did not get exception");
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanAddReadPermissions() {
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
+        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder = new SessionTestsBase.SessionStatusCallbackRecorder();
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        final LoginButton button = new LoginButton(getActivity());
+        button.setSession(session);
+        button.setReadPermissions(Arrays.asList(new String[] {"read_permission", "read_another"}));
+        session.addAuthorizeResult("A token of thanks", new ArrayList<String>(), AccessTokenSource.TEST_USER);
+        session.addCallback(statusRecorder);
+
+        button.performClick();
+
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanAddPublishPermissions() {
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
+        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder =
+                new SessionTestsBase.SessionStatusCallbackRecorder();
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        final LoginButton button = new LoginButton(getActivity());
+        button.setSession(session);
+        button.setPublishPermissions(Arrays.asList(new String[] {"publish_permission", "publish_another"}));
+        session.addAuthorizeResult("A token of thanks", new ArrayList<String>(), AccessTokenSource.TEST_USER);
+        session.addCallback(statusRecorder);
+
+        button.performClick();
+
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantAddReadThenPublishPermissions() {
+        final LoginButton button = new LoginButton(getActivity());
+        button.setReadPermissions(Arrays.asList(new String[] {"read_permission", "read_another"}));
+        try {
+            button.setPublishPermissions(Arrays.asList(new String[] {"read_permission", "read_a_third"}));
+            fail("Should not be able to reach here");
+        } catch (Exception e) {
+            assertTrue(e instanceof UnsupportedOperationException);
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantAddPublishThenReadPermissions() {
+        final LoginButton button = new LoginButton(getActivity());
+        button.setPublishPermissions(Arrays.asList(new String[] {"publish_permission", "publish_another"}));
+        try {
+            button.setReadPermissions(Arrays.asList(new String[] {"publish_permission", "publish_a_third"}));
+            fail("Should not be able to reach here");
+        } catch (Exception e) {
+            assertTrue(e instanceof UnsupportedOperationException);
+        }
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanAddReadThenPublishPermissionsWithClear() {
+        final LoginButton button = new LoginButton(getActivity());
+        button.setReadPermissions(Arrays.asList(new String[] {"read_permission", "read_another"}));
+        button.clearPermissions();
+        button.setPublishPermissions(Arrays.asList(new String[] {"publish_permission", "publish_another"}));
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCantAddMorePermissionsToOpenSession() {
+        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
+        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
+        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder =
+                new SessionTestsBase.SessionStatusCallbackRecorder();
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        final LoginButton button = new LoginButton(getActivity());
+        button.setSession(session);
+        session.addAuthorizeResult("A token of thanks",
+                Arrays.asList(new String[] {"read_permission", "read_another"}), AccessTokenSource.TEST_USER);
+        session.addCallback(statusRecorder);
+
+        button.performClick();
+
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        // this should be fine
+        button.setReadPermissions(Arrays.asList(new String[] {"read_permission", "read_another"}));
+
+        button.setReadPermissions(Arrays.asList(new String[] {"read_permission", "read_a_third"}));
+        List<String> permissions = button.getPermissions();
+        assertTrue(permissions.contains("read_permission"));
+        assertTrue(permissions.contains("read_another"));
+        assertFalse(permissions.contains("read_a_third"));
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testCanSetDefaultAudience() {
+        SessionTestsBase.MockTokenCachingStrategy cache = new SessionTestsBase.MockTokenCachingStrategy(null, 0);
+        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
+        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder =
+                new SessionTestsBase.SessionStatusCallbackRecorder();
+
+        // Verify state with no token in cache
+        assertEquals(SessionState.CREATED, session.getState());
+
+        final LoginButton button = new LoginButton(getActivity());
+        button.setSession(session);
+        button.setPublishPermissions(Arrays.asList(new String[] {"publish_permission", "publish_another"}));
+        button.setDefaultAudience(SessionDefaultAudience.FRIENDS);
+        session.addAuthorizeResult("A token of thanks", new ArrayList<String>(), AccessTokenSource.TEST_USER);
+        session.addCallback(statusRecorder);
+
+        button.performClick();
+
+        statusRecorder.waitForCall(session, SessionState.OPENING, null);
+        statusRecorder.waitForCall(session, SessionState.OPENED, null);
+
+        assertNotNull(session.getLastRequest());
+        assertEquals(SessionDefaultAudience.FRIENDS, session.getLastRequestAudience());
+
+        // Verify token information is cleared.
+        session.closeAndClearTokenInformation();
+        assertTrue(cache.getSavedState() == null);
+        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
+
+        // Wait a bit so we can fail if any unexpected calls arrive on the
+        // recorder.
+        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
+        statusRecorder.close();
+    }
+
+}
diff --git a/facebook/tests/src/com/facebook/widget/PlacePickerFragmentTests.java b/facebook/tests/src/com/facebook/widget/PlacePickerFragmentTests.java
new file mode 100644
index 000000000..50655185f
--- /dev/null
+++ b/facebook/tests/src/com/facebook/widget/PlacePickerFragmentTests.java
@@ -0,0 +1,279 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.location.Location;
+import android.os.Bundle;
+import android.test.TouchUtils;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.view.View;
+import android.widget.ListView;
+import com.facebook.*;
+import com.facebook.sdk.tests.R;
+
+import java.util.Collection;
+
+public class PlacePickerFragmentTests extends FragmentTestCase<PlacePickerFragmentTests.TestActivity> {
+    public PlacePickerFragmentTests() {
+        super(TestActivity.class);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCanSetParametersProgrammatically() throws Throwable {
+        TestActivity activity = getActivity();
+        assertNotNull(activity);
+
+        final Location location = new Location("");
+        location.setLatitude(47.6204);
+        location.setLongitude(-122.3491);
+
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                Bundle bundle = new Bundle();
+                // We deliberately set these to non-defaults to ensure they are set correctly.
+                bundle.putBoolean(PlacePickerFragment.SHOW_PICTURES_BUNDLE_KEY, false);
+                bundle.putInt(PlacePickerFragment.RADIUS_IN_METERS_BUNDLE_KEY, 75);
+                bundle.putInt(PlacePickerFragment.RESULTS_LIMIT_BUNDLE_KEY, 5);
+                bundle.putString(PlacePickerFragment.SEARCH_TEXT_BUNDLE_KEY, "coffee");
+                bundle.putParcelable(PlacePickerFragment.LOCATION_BUNDLE_KEY, location);
+                bundle.putString(FriendPickerFragment.EXTRA_FIELDS_BUNDLE_KEY, "checkins,general_info");
+
+                PlacePickerFragment fragment = new PlacePickerFragment(bundle);
+                getActivity().setContentToFragment(fragment);
+            }
+        });
+
+        // We don't just test the fragment we created directly above, because we want it to go through the
+        // activity lifecycle and ensure the settings are still correct.
+        final PlacePickerFragment fragment = activity.getFragment();
+        assertNotNull(fragment);
+
+        assertEquals(false, fragment.getShowPictures());
+        assertEquals(75, fragment.getRadiusInMeters());
+        assertEquals(5, fragment.getResultsLimit());
+        assertEquals("coffee", fragment.getSearchText());
+        assertEquals(location, fragment.getLocation());
+        Collection<String> extraFields = fragment.getExtraFields();
+        assertTrue(extraFields.contains("checkins"));
+        assertTrue(extraFields.contains("general_info"));
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCanSetParametersViaLayout() throws Throwable {
+        TestActivity activity = getActivity();
+        assertNotNull(activity);
+
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                getActivity().setContentToLayout(R.layout.place_picker_test_layout_1, R.id.place_picker_fragment);
+            }
+        });
+
+        final PlacePickerFragment fragment = activity.getFragment();
+        assertNotNull(fragment);
+
+        assertEquals(false, fragment.getShowPictures());
+        assertEquals(75, fragment.getRadiusInMeters());
+        assertEquals(5, fragment.getResultsLimit());
+        assertEquals("coffee", fragment.getSearchText());
+        Collection<String> extraFields = fragment.getExtraFields();
+        assertTrue(extraFields.contains("checkins"));
+        assertTrue(extraFields.contains("general_info"));
+        // It doesn't make sense to specify location via layout, so we don't support it.
+    }
+
+    @LargeTest
+    public void testPlacesLoad() throws Throwable {
+        TestActivity activity = getActivity();
+        assertNotNull(activity);
+
+        // We don't auto-create any UI, so do it now. Needs to run on the UI thread.
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                getActivity().setContentToFragment(null);
+            }
+        });
+        getInstrumentation().waitForIdleSync();
+
+        final PlacePickerFragment fragment = activity.getFragment();
+        assertNotNull(fragment);
+
+        final TestSession session = openTestSessionWithSharedUser();
+
+        // Trigger a data load (on the UI thread).
+        final TestBlocker blocker = getTestBlocker();
+        runAndBlockOnUiThread(1, new Runnable() {
+            @Override
+            public void run() {
+                fragment.setSession(session);
+
+                Location location = new Location("");
+                location.setLatitude(47.6204);
+                location.setLongitude(-122.3491);
+                fragment.setLocation(location);
+
+                fragment.setOnDataChangedListener(new PickerFragment.OnDataChangedListener() {
+                    @Override
+                    public void onDataChanged(PickerFragment<?> fragment) {
+                        blocker.signal();
+                    }
+                });
+                fragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
+                    @Override
+                    public void onError(PickerFragment<?> fragment, FacebookException error) {
+                        fail("Got unexpected error: " + error.toString());
+                    }
+                });
+                fragment.loadData(true);
+            }
+        });
+
+        // We should have at least one item in the list by now.
+        ListView listView = (ListView) fragment.getView().findViewById(R.id.com_facebook_picker_list_view);
+        assertNotNull(listView);
+        View firstChild = listView.getChildAt(0);
+        assertNotNull(firstChild);
+
+        // Assert our state before we touch anything.
+        assertNull(fragment.getSelection());
+
+        // Click on the first item in the list view.
+        TouchUtils.clickView(this, firstChild);
+
+        // We should have a selection.
+        assertNotNull(fragment.getSelection());
+
+        // Touch the item again. We should go back to no selection.
+        TouchUtils.clickView(this, firstChild);
+        assertNull(fragment.getSelection());
+    }
+
+    @LargeTest
+    public void testClearsResultsWhenSessionClosed() throws Throwable {
+        TestActivity activity = getActivity();
+        assertNotNull(activity);
+
+        // We don't auto-create any UI, so do it now. Needs to run on the UI thread.
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                getActivity().setContentToFragment(null);
+            }
+        });
+        getInstrumentation().waitForIdleSync();
+
+        final PlacePickerFragment fragment = activity.getFragment();
+        assertNotNull(fragment);
+
+        final TestSession session = openTestSessionWithSharedUser();
+
+        // Trigger a data load (on the UI thread).
+        // We use multiple test blockers to keep the counts from getting confused if other events
+        // cause our listeners to fire.
+        final TestBlocker blocker1 = TestBlocker.createTestBlocker();
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                fragment.setSession(session);
+
+                Location location = new Location("");
+                location.setLatitude(47.6204);
+                location.setLongitude(-122.3491);
+                fragment.setLocation(location);
+
+                fragment.setOnDataChangedListener(new PickerFragment.OnDataChangedListener() {
+                    @Override
+                    public void onDataChanged(PickerFragment<?> fragment) {
+                        blocker1.signal();
+                    }
+                });
+                fragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
+                    @Override
+                    public void onError(PickerFragment<?> fragment, FacebookException error) {
+                        fail("Got unexpected error: " + error.getMessage());
+                    }
+                });
+                fragment.loadData(true);
+            }
+        });
+        blocker1.waitForSignals(1);
+
+        // We should have at least one item in the list by now.
+        ListView listView = (ListView) fragment.getView().findViewById(R.id.com_facebook_picker_list_view);
+        assertNotNull(listView);
+
+        Thread.sleep(500);
+
+        int lastPosition = listView.getLastVisiblePosition();
+        assertTrue(lastPosition > -1);
+
+        View firstChild = listView.getChildAt(0);
+        assertNotNull(firstChild);
+
+        // Assert our state before we touch anything.
+        assertNull(fragment.getSelection());
+
+        // Click on the first item in the list view.
+        TouchUtils.clickView(this, firstChild);
+
+        // We should have a selection.
+        assertNotNull(fragment.getSelection());
+
+        // To validate the behavior, we need to wait until the session state notifications have been processed.
+        // We run this on the UI thread but don't wait on the blocker until we've closed the session.
+        final TestBlocker blocker2 = TestBlocker.createTestBlocker();
+        runAndBlockOnUiThread(0, new Runnable() {
+            @Override
+            public void run() {
+                session.addCallback(new Session.StatusCallback() {
+                    @Override
+                    public void call(Session session, SessionState state, Exception exception) {
+                        blocker2.signal();
+                    }
+                });
+            }
+        });
+        session.close();
+        // Wait for the notification and for any UI activity to stop.
+        blocker2.waitForSignals(1);
+        getInstrumentation().waitForIdleSync();
+
+        Thread.sleep(500);
+        // The list and the selection should have been cleared.
+        lastPosition = listView.getLastVisiblePosition();
+        assertTrue(lastPosition == -1);
+        assertNull(fragment.getSelection());
+    }
+
+    public static class TestActivity extends FragmentTestCase.TestFragmentActivity<PlacePickerFragment> {
+        public TestActivity() {
+            super(PlacePickerFragment.class);
+        }
+
+        @Override
+        protected boolean getAutoCreateUI() {
+            return false;
+        }
+    }
+
+}
diff --git a/facebook/tests/src/com/facebook/widget/UserSettingsFragmentTests.java b/facebook/tests/src/com/facebook/widget/UserSettingsFragmentTests.java
new file mode 100644
index 000000000..d13215bd0
--- /dev/null
+++ b/facebook/tests/src/com/facebook/widget/UserSettingsFragmentTests.java
@@ -0,0 +1,65 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.os.Bundle;
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import com.facebook.SessionDefaultAudience;
+import com.facebook.SessionLoginBehavior;
+
+import java.util.Arrays;
+import java.util.List;
+
+public class UserSettingsFragmentTests extends FragmentTestCase<UserSettingsFragmentTests.TestActivity> {
+
+    public UserSettingsFragmentTests() {
+        super(TestActivity.class);
+    }
+
+    @MediumTest
+    @LargeTest
+    public void testCanSetParametersViaLayout() throws Throwable {
+        TestActivity activity = getActivity();
+        assertNotNull(activity);
+
+        final UserSettingsFragment fragment = activity.getFragment();
+        assertNotNull(fragment);
+
+        assertEquals(SessionLoginBehavior.SUPPRESS_SSO, fragment.getLoginBehavior());
+        assertEquals(SessionDefaultAudience.EVERYONE, fragment.getDefaultAudience());
+        List<String> permissions = fragment.getPermissions();
+        assertEquals(2, permissions.size());
+        assertEquals("read_1", permissions.get(0));
+    }
+
+    public static class TestActivity extends FragmentTestCase.TestFragmentActivity<UserSettingsFragment> {
+        public TestActivity() {
+            super(UserSettingsFragment.class);
+        }
+
+        @Override
+        public void onCreate(Bundle savedInstanceState) {
+            super.onCreate(savedInstanceState);
+            getSupportFragmentManager().executePendingTransactions();
+            UserSettingsFragment fragment = getFragment();
+            fragment.setLoginBehavior(SessionLoginBehavior.SUPPRESS_SSO);
+            fragment.setReadPermissions(Arrays.asList("read_1", "read_2"));
+            fragment.setDefaultAudience(SessionDefaultAudience.EVERYONE);
+        }
+    }
+}
diff --git a/facebook/tests/src/com/facebook/widget/WorkQueueTests.java b/facebook/tests/src/com/facebook/widget/WorkQueueTests.java
new file mode 100644
index 000000000..0b377d57c
--- /dev/null
+++ b/facebook/tests/src/com/facebook/widget/WorkQueueTests.java
@@ -0,0 +1,345 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.widget;
+
+import android.test.suitebuilder.annotation.LargeTest;
+import android.test.suitebuilder.annotation.MediumTest;
+import android.test.suitebuilder.annotation.SmallTest;
+import com.facebook.FacebookTestCase;
+import com.facebook.widget.WorkQueue;
+
+import java.util.ArrayList;
+import java.util.concurrent.Executor;
+import java.security.SecureRandom;
+
+public class WorkQueueTests extends FacebookTestCase {
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testEmptyValidate() {
+        WorkQueue manager = new WorkQueue();
+        manager.validate();
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testRunSomething() {
+        CountingRunnable run = new CountingRunnable();
+        assertEquals(0, run.getRunCount());
+
+        ScriptableExecutor executor = new ScriptableExecutor();
+        assertEquals(0, executor.getPendingCount());
+
+        WorkQueue manager = new WorkQueue(1, executor);
+
+        addActiveWorkItem(manager, run);
+        assertEquals(1, executor.getPendingCount());
+        assertEquals(0, run.getRunCount());
+
+        executeNext(manager, executor);
+        assertEquals(0, executor.getPendingCount());
+        assertEquals(1, run.getRunCount());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testRunSequence() {
+        final int workTotal = 100;
+
+        CountingRunnable run = new CountingRunnable();
+        ScriptableExecutor executor = new ScriptableExecutor();
+        WorkQueue manager = new WorkQueue(1, executor);
+
+        for (int i = 0; i < workTotal; i++) {
+            addActiveWorkItem(manager, run);
+            assertEquals(1, executor.getPendingCount());
+        }
+
+        for (int i = 0; i < workTotal; i++) {
+            assertEquals(1, executor.getPendingCount());
+            assertEquals(i, run.getRunCount());
+            executeNext(manager, executor);
+        }
+        assertEquals(0, executor.getPendingCount());
+        assertEquals(workTotal, run.getRunCount());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testRunParallel() {
+        final int workTotal = 100;
+
+        CountingRunnable run = new CountingRunnable();
+        ScriptableExecutor executor = new ScriptableExecutor();
+        WorkQueue manager = new WorkQueue(workTotal, executor);
+
+        for (int i = 0; i < workTotal; i++) {
+            assertEquals(i, executor.getPendingCount());
+            addActiveWorkItem(manager, run);
+        }
+
+        for (int i = 0; i < workTotal; i++) {
+            assertEquals(workTotal - i, executor.getPendingCount());
+            assertEquals(i, run.getRunCount());
+            executeNext(manager, executor);
+        }
+        assertEquals(0, executor.getPendingCount());
+        assertEquals(workTotal, run.getRunCount());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testSimpleCancel() {
+        CountingRunnable run = new CountingRunnable();
+        ScriptableExecutor executor = new ScriptableExecutor();
+        WorkQueue manager = new WorkQueue(1, executor);
+
+        addActiveWorkItem(manager, run);
+        WorkQueue.WorkItem work1 = addActiveWorkItem(manager, run);
+        cancelWork(manager, work1);
+
+        assertEquals(1, executor.getPendingCount());
+        executeNext(manager, executor);
+        assertEquals(0, executor.getPendingCount());
+    }
+
+    @SmallTest
+    @MediumTest
+    @LargeTest
+    public void testMoveToFront() {
+        final int firstCount = 8;
+        final int highCount = 17;
+
+        ArrayList<WorkQueue.WorkItem> highWorkItems = new ArrayList<WorkQueue.WorkItem>();
+        CountingRunnable highRun = new CountingRunnable();
+        CountingRunnable firstRun = new CountingRunnable();
+        CountingRunnable lowRun = new CountingRunnable();
+        ScriptableExecutor executor = new ScriptableExecutor();
+        WorkQueue manager = new WorkQueue(firstCount, executor);
+
+        for (int i = 0; i < firstCount; i++) {
+            addActiveWorkItem(manager, firstRun);
+        }
+
+        int lowCount = 0;
+        for (int h = 0; h < highCount; h++) {
+            highWorkItems.add(addActiveWorkItem(manager, highRun));
+            for (int l = 0; l < h; l++) {
+                addActiveWorkItem(manager, lowRun);
+                lowCount++;
+            }
+        }
+
+        assertEquals(firstCount, executor.getPendingCount());
+        for (WorkQueue.WorkItem highItem : highWorkItems) {
+            prioritizeWork(manager, highItem);
+        }
+
+        for (int i = 0; i < firstCount; i++) {
+            assertEquals(i, firstRun.getRunCount());
+            executeNext(manager, executor);
+        }
+
+        for (int i = 0; i < highCount; i++) {
+            assertEquals(i, highRun.getRunCount());
+            executeNext(manager, executor);
+        }
+
+        for (int i = 0; i < lowCount; i++) {
+            assertEquals(i, lowRun.getRunCount());
+            executeNext(manager, executor);
+        }
+
+        assertEquals(firstCount, firstRun.getRunCount());
+        assertEquals(highCount, highRun.getRunCount());
+        assertEquals(lowCount, lowRun.getRunCount());
+    }
+
+    // Test cancelling running work item, completed work item
+
+    @LargeTest
+    public void testThreadStress() {
+        WorkQueue manager = new WorkQueue();
+        ArrayList<StressRunnable> runnables = new ArrayList<StressRunnable>();
+        final int threadCount = 20;
+
+        for (int i = 0; i < threadCount; i++) {
+            runnables.add(new StressRunnable(manager, 20));
+        }
+
+        for (int i = 0; i < threadCount; i++) {
+            manager.addActiveWorkItem(runnables.get(i));
+        }
+
+        for (int i = 0; i < threadCount; i++) {
+            runnables.get(i).waitForDone();
+        }
+    }
+
+    private WorkQueue.WorkItem addActiveWorkItem(WorkQueue manager, Runnable runnable) {
+        manager.validate();
+        WorkQueue.WorkItem workItem = manager.addActiveWorkItem(runnable);
+        manager.validate();
+        return workItem;
+    }
+
+    private void executeNext(WorkQueue manager, ScriptableExecutor executor) {
+        manager.validate();
+        executor.runNext();
+        manager.validate();
+    }
+
+    private void cancelWork(WorkQueue manager, WorkQueue.WorkItem workItem) {
+        manager.validate();
+        workItem.cancel();
+        manager.validate();
+    }
+
+    private void prioritizeWork(WorkQueue manager, WorkQueue.WorkItem workItem) {
+        manager.validate();
+        workItem.moveToFront();
+        manager.validate();
+    }
+
+    static class StressRunnable implements Runnable {
+        static ArrayList<WorkQueue.WorkItem> tracked = new ArrayList<WorkQueue.WorkItem>();
+
+        final WorkQueue manager;
+        final SecureRandom random = new SecureRandom();
+        final int iterationCount;
+        int iterationIndex = 0;
+        boolean isDone = false;
+
+        StressRunnable(WorkQueue manager, int iterationCount) {
+            this.manager = manager;
+            this.iterationCount = iterationCount;
+        }
+
+        @Override
+        public void run() {
+            // Each iteration runs a random action against the WorkQueue.
+            if (iterationIndex++ < iterationCount) {
+                final int sleepWeight = 80;
+                final int trackThisWeight = 10;
+                final int prioritizeTrackedWeight = 6;
+                final int validateWeight = 2;
+                int weight = 0;
+                final int n = random.nextInt(sleepWeight + trackThisWeight + prioritizeTrackedWeight + validateWeight);
+                WorkQueue.WorkItem workItem = manager.addActiveWorkItem(this);
+
+                if (n < (weight += sleepWeight)) {
+                    // Sleep
+                    try {
+                        Thread.sleep(n/4);
+                    } catch (InterruptedException e) {
+                    }
+                } else if (n < (weight += trackThisWeight)) {
+                    // Track this work item to activate later
+                    synchronized (tracked) {
+                        tracked.add(workItem);
+                    }
+                } else if (n < (weight += prioritizeTrackedWeight)) {
+                    // Background all pending items, prioritize tracked items, and clear tracked list
+                    ArrayList<WorkQueue.WorkItem> items = new ArrayList<WorkQueue.WorkItem>();
+
+                    synchronized (tracked) {
+                        items.addAll(tracked);
+                        tracked.clear();
+                    }
+
+                    for (WorkQueue.WorkItem item : items) {
+                        item.moveToFront();
+                    }
+                } else {
+                    // Validate
+                    manager.validate();
+                }
+            } else {
+                // Also have all threads validate once they are done.
+                manager.validate();
+                synchronized (this) {
+                    isDone = true;
+                    this.notifyAll();
+                }
+            }
+        }
+
+        void waitForDone() {
+            synchronized (this) {
+                while (!isDone) {
+                    try {
+                        this.wait();
+                    } catch (InterruptedException e) {
+                    }
+                }
+            }
+        }
+    }
+
+    class ScriptableExecutor implements Executor {
+        private final ArrayList<Runnable> runnables = new ArrayList<Runnable>();
+
+        int getPendingCount() {
+            return runnables.size();
+        }
+
+        void runNext() {
+            assertTrue(runnables.size() > 0);
+            runnables.get(0).run();
+            runnables.remove(0);
+        }
+
+        void runLast() {
+            assertTrue(runnables.size() > 0);
+            int index = runnables.size() - 1;
+            runnables.get(index).run();
+            runnables.remove(index);
+        }
+
+        @Override
+        public void execute(Runnable runnable) {
+            synchronized (this) {
+                runnables.add(runnable);
+            }
+        }
+    }
+
+    class CountingRunnable implements Runnable {
+        volatile int runCount = 0;
+
+        int getRunCount() {
+            return runCount;
+        }
+
+        @Override
+        public void run() {
+            synchronized (this) {
+                runCount++;
+            }
+
+            try {
+                Thread.sleep(1);
+            } catch (InterruptedException e) {
+            }
+        }
+    }
+}
diff --git a/libs/android-support-v4.jar b/libs/android-support-v4.jar
new file mode 100644
index 000000000..feaf44f80
Binary files /dev/null and b/libs/android-support-v4.jar differ
diff --git a/samples/BooleanOGSample/.classpath b/samples/BooleanOGSample/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/BooleanOGSample/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/BooleanOGSample/.project b/samples/BooleanOGSample/.project
new file mode 100644
index 000000000..cd9402a77
--- /dev/null
+++ b/samples/BooleanOGSample/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>BooleanOGSample</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/samples/BooleanOGSample/AndroidManifest.xml b/samples/BooleanOGSample/AndroidManifest.xml
new file mode 100644
index 000000000..d2ac13fc1
--- /dev/null
+++ b/samples/BooleanOGSample/AndroidManifest.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.facebook.samples.booleanog"
+          android:versionCode="1"
+          android:versionName="1.0">
+    <uses-sdk android:minSdkVersion="8" />
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <application android:label="@string/app_name" android:icon="@drawable/icon" >
+        <activity android:name="LogicActivity"
+                  android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+        <activity android:name="com.facebook.LoginActivity"
+                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
+                  android:label="@string/app_name" />
+        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
+    </application>
+</manifest> 
diff --git a/samples/BooleanOGSample/BooleanOGSample.iml b/samples/BooleanOGSample/BooleanOGSample.iml
new file mode 100644
index 000000000..fa41c247b
--- /dev/null
+++ b/samples/BooleanOGSample/BooleanOGSample.iml
@@ -0,0 +1,56 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+    <orderEntry type="module-library">
+      <library>
+        <CLASSES>
+          <root url="file://$MODULE_DIR$/../../libs" />
+        </CLASSES>
+        <JAVADOC />
+        <SOURCES />
+        <jarDirectory url="file://$MODULE_DIR$/../../libs" recursive="false" />
+      </library>
+    </orderEntry>
+  </component>
+</module>
+
diff --git a/samples/BooleanOGSample/ant.properties b/samples/BooleanOGSample/ant.properties
new file mode 100644
index 000000000..939105d52
--- /dev/null
+++ b/samples/BooleanOGSample/ant.properties
@@ -0,0 +1,18 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
+java.compilerargs=-Xlint -Werror
diff --git a/samples/BooleanOGSample/build.xml b/samples/BooleanOGSample/build.xml
new file mode 100644
index 000000000..ce5402793
--- /dev/null
+++ b/samples/BooleanOGSample/build.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="BooleanOGSample" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties"/>
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties"/>
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env"/>
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME"/>
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties"/>
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+            />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true"/>
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml"/>
+
+</project>
diff --git a/samples/BooleanOGSample/proguard-project.txt b/samples/BooleanOGSample/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/BooleanOGSample/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/samples/BooleanOGSample/project.properties b/samples/BooleanOGSample/project.properties
new file mode 100644
index 000000000..cee0509c6
--- /dev/null
+++ b/samples/BooleanOGSample/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+android.library.reference.1=../../facebook
diff --git a/samples/BooleanOGSample/res/drawable-hdpi/icon.png b/samples/BooleanOGSample/res/drawable-hdpi/icon.png
new file mode 100644
index 000000000..5bc5b2cea
Binary files /dev/null and b/samples/BooleanOGSample/res/drawable-hdpi/icon.png differ
diff --git a/samples/BooleanOGSample/res/drawable-mdpi/icon.png b/samples/BooleanOGSample/res/drawable-mdpi/icon.png
new file mode 100644
index 000000000..f621e908c
Binary files /dev/null and b/samples/BooleanOGSample/res/drawable-mdpi/icon.png differ
diff --git a/samples/BooleanOGSample/res/drawable-xhdpi/icon.png b/samples/BooleanOGSample/res/drawable-xhdpi/icon.png
new file mode 100644
index 000000000..1adb6bfa3
Binary files /dev/null and b/samples/BooleanOGSample/res/drawable-xhdpi/icon.png differ
diff --git a/samples/BooleanOGSample/res/drawable/false_content.png b/samples/BooleanOGSample/res/drawable/false_content.png
new file mode 100644
index 000000000..a86d4d296
Binary files /dev/null and b/samples/BooleanOGSample/res/drawable/false_content.png differ
diff --git a/samples/BooleanOGSample/res/drawable/icon.png b/samples/BooleanOGSample/res/drawable/icon.png
new file mode 100644
index 000000000..f621e908c
Binary files /dev/null and b/samples/BooleanOGSample/res/drawable/icon.png differ
diff --git a/samples/BooleanOGSample/res/drawable/true_content.png b/samples/BooleanOGSample/res/drawable/true_content.png
new file mode 100644
index 000000000..ce7694f83
Binary files /dev/null and b/samples/BooleanOGSample/res/drawable/true_content.png differ
diff --git a/samples/BooleanOGSample/res/layout/content_group.xml b/samples/BooleanOGSample/res/layout/content_group.xml
new file mode 100644
index 000000000..151c17e41
--- /dev/null
+++ b/samples/BooleanOGSample/res/layout/content_group.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:id="@+id/content_group"
+              android:layout_height="fill_parent"
+              android:layout_width="fill_parent"
+              android:background="#FFF"
+              android:orientation="vertical">
+
+    <ImageView android:id="@+id/content_image"
+               android:layout_height="fill_parent"
+               android:layout_width="fill_parent"
+               android:layout_weight="1"/>
+
+    <Spinner android:id="@+id/content_spinner"
+             android:layout_height="wrap_content"
+             android:layout_width="fill_parent"
+             android:layout_weight="0"/>
+
+</LinearLayout>
diff --git a/samples/BooleanOGSample/res/layout/friend_activity_row.xml b/samples/BooleanOGSample/res/layout/friend_activity_row.xml
new file mode 100644
index 000000000..895cc334e
--- /dev/null
+++ b/samples/BooleanOGSample/res/layout/friend_activity_row.xml
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+              android:orientation="horizontal"
+              android:background="#fff">
+
+    <TextView android:id="@+id/friend_action_date"
+              android:layout_height="wrap_content"
+              android:layout_width="fill_parent"
+              android:layout_weight="1"
+              android:textSize="12sp"
+              android:textColor="#000"/>
+
+    <TextView android:id="@+id/friend_action_data"
+              android:layout_height="wrap_content"
+              android:layout_width="fill_parent"
+              android:layout_weight="1"
+              android:textSize="12sp"
+              android:textColor="#000"/>
+
+</LinearLayout>
diff --git a/samples/BooleanOGSample/res/layout/friends_group.xml b/samples/BooleanOGSample/res/layout/friends_group.xml
new file mode 100644
index 000000000..ba7276d5c
--- /dev/null
+++ b/samples/BooleanOGSample/res/layout/friends_group.xml
@@ -0,0 +1,61 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:id="@+id/friends_group"
+              android:layout_height="fill_parent"
+              android:layout_width="fill_parent"
+              android:background="#FFF"
+              android:orientation="vertical">
+
+    <TextView android:layout_height="wrap_content"
+              android:layout_width="fill_parent"
+              android:textColor="#000"
+              android:textSize="20sp"
+              android:text="@string/friends_using_rock_the_logic"/>
+
+    <FrameLayout android:id="@+id/friend_picker_fragment"
+                 android:layout_height="fill_parent"
+                 android:layout_width="fill_parent"
+                 android:layout_weight="1"/>
+
+    <TextView android:layout_height="wrap_content"
+              android:layout_width="fill_parent"
+              android:textColor="#000"
+              android:textSize="20sp"
+              android:text="@string/friend_activity"/>
+
+    <FrameLayout android:layout_height="fill_parent"
+                 android:layout_width="fill_parent"
+                 android:layout_weight="1">
+
+        <ListView android:id="@+id/friend_activity_list"
+                  android:layout_height="fill_parent"
+                  android:layout_width="fill_parent"/>
+
+        <ProgressBar android:id="@+id/friend_activity_progress_bar"
+                     android:layout_width="wrap_content"
+                     android:layout_height="wrap_content"
+                     android:layout_gravity="center"
+                     android:indeterminate="true"
+                     style="@android:style/Widget.ProgressBar"
+                     android:layout_centerInParent="true"
+                     android:visibility="gone"/>
+
+    </FrameLayout>
+
+</LinearLayout>
diff --git a/samples/BooleanOGSample/res/layout/logic_group.xml b/samples/BooleanOGSample/res/layout/logic_group.xml
new file mode 100644
index 000000000..27449519a
--- /dev/null
+++ b/samples/BooleanOGSample/res/layout/logic_group.xml
@@ -0,0 +1,85 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:id="@+id/logic_group"
+              android:orientation="vertical"
+              android:layout_height="fill_parent"
+              android:layout_width="fill_parent"
+              android:background="#999">
+
+    <TextView android:layout_height="wrap_content"
+              android:layout_width="fill_parent"
+              android:layout_weight="1"
+              android:textColor="#fff"
+              android:textSize="32sp"
+              android:gravity="center"
+              android:text="@string/rock_the_logic"/>
+
+    <LinearLayout android:orientation="horizontal"
+                  android:layout_height="wrap_content"
+                  android:layout_width="fill_parent"
+                  android:layout_weight="1">
+        <Spinner android:id="@+id/left_spinner"
+                 android:layout_height="wrap_content"
+                 android:layout_width="wrap_content"
+                 android:layout_weight="1"
+                 android:layout_gravity="center"/>
+        <LinearLayout android:orientation="vertical"
+                      android:layout_height="wrap_content"
+                      android:layout_width="wrap_content"
+                      android:layout_weight="1"
+                      android:layout_gravity="center">
+            <Button android:id="@+id/and_button"
+                    android:layout_height="wrap_content"
+                    android:layout_width="fill_parent"
+                    android:layout_gravity="center"
+                    android:text="@string/and_operation"/>
+            <Button android:id="@+id/or_button"
+                    android:layout_height="wrap_content"
+                    android:layout_width="fill_parent"
+                    android:layout_gravity="center"
+                    android:text="@string/or_operation"/>
+        </LinearLayout>
+        <Spinner android:id="@+id/right_spinner"
+                 android:layout_height="wrap_content"
+                 android:layout_width="wrap_content"
+                 android:layout_weight="1"
+                 android:layout_gravity="center"/>
+    </LinearLayout>
+
+    <TextView android:id="@+id/result_text"
+              android:layout_height="wrap_content"
+              android:layout_width="fill_parent"
+              android:layout_weight="1"
+              android:gravity="center"
+              android:background="#fff"
+              android:textColor="#000"
+              android:textSize="24sp"
+              android:text=""/>
+
+    <TextView android:id="@+id/post_result_text"
+              android:layout_height="wrap_content"
+              android:layout_width="fill_parent"
+              android:layout_weight="1"
+              android:gravity="center"
+              android:background="#fff"
+              android:textColor="#000"
+              android:textSize="12sp"
+              android:text=""/>
+
+</LinearLayout>
diff --git a/samples/BooleanOGSample/res/layout/main.xml b/samples/BooleanOGSample/res/layout/main.xml
new file mode 100644
index 000000000..7ca777d60
--- /dev/null
+++ b/samples/BooleanOGSample/res/layout/main.xml
@@ -0,0 +1,63 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:orientation="vertical"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent">
+
+    <FrameLayout android:id="@+id/body_frame"
+                 android:layout_height="0dip"
+                 android:layout_width="fill_parent"
+                 android:layout_weight="1">
+        <include layout="@layout/logic_group"/>
+        <include layout="@layout/friends_group"/>
+        <include layout="@layout/settings_group"/>
+        <include layout="@layout/content_group"/>
+    </FrameLayout>
+
+    <LinearLayout android:orientation="horizontal"
+                  android:layout_width="fill_parent"
+                  android:layout_height="wrap_content">
+        <Button android:id="@+id/logic_button"
+                android:layout_width="wrap_content"
+                android:layout_height="fill_parent"
+                android:layout_weight="1"
+                android:layout_gravity="center"
+                android:text="@string/navigate_logic"/>
+        <Button android:id="@+id/friends_button"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:layout_gravity="center"
+                android:text="@string/navigate_friends"/>
+        <Button android:id="@+id/content_button"
+                android:layout_width="wrap_content"
+                android:layout_height="fill_parent"
+                android:layout_weight="0"
+                android:layout_gravity="center"
+                android:text="@string/navigate_content"/>
+        <Button android:id="@+id/settings_button"
+                android:layout_width="wrap_content"
+                android:layout_height="fill_parent"
+                android:layout_weight="0"
+                android:layout_gravity="center"
+                android:text="@string/navigate_settings"/>
+    </LinearLayout>
+
+</LinearLayout>
+
diff --git a/samples/BooleanOGSample/res/layout/settings_group.xml b/samples/BooleanOGSample/res/layout/settings_group.xml
new file mode 100644
index 000000000..5cee0a29a
--- /dev/null
+++ b/samples/BooleanOGSample/res/layout/settings_group.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:id="@+id/settings_group"
+              android:layout_height="fill_parent"
+              android:layout_width="fill_parent">
+
+    <FrameLayout android:id="@+id/login_fragment"
+                 android:layout_height="fill_parent"
+                 android:layout_width="fill_parent"/>
+
+</LinearLayout>
diff --git a/samples/BooleanOGSample/res/values/strings.xml b/samples/BooleanOGSample/res/values/strings.xml
new file mode 100644
index 000000000..2aef901c1
--- /dev/null
+++ b/samples/BooleanOGSample/res/values/strings.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<resources>
+    <string name="app_name">BooleanOGSample</string>
+    <string name="app_id">369258453126794</string>
+    <string name="navigate_logic">You Rock!</string>
+    <string name="navigate_friends">Rock with Friends</string>
+    <string name="navigate_settings">Settings</string>
+    <string name="navigate_content">Content</string>
+    <string name="rock_the_logic">Rock the Logic</string>
+    <string name="false_value">False</string>
+    <string name="true_value">True</string>
+    <string name="and_operation">AND</string>
+    <string name="or_operation">OR</string>
+    <string name="friends_using_rock_the_logic">Friends using Rock the Logic!</string>
+    <string name="friend_activity">Friend activity</string>
+    <string name="foo">You Rock!</string>
+    <string name="feature_requires_login_title">Social Features Disabled</string>
+    <string name="feature_requires_login_message">
+        There is no open session with Facebook.
+        Use the Settings tab to log in and use the social features of this application.
+    </string>
+    <string name="error_dialog_title">Error</string>
+    <string name="ok_button">OK</string>
+    <string-array name="truth_values">
+        <item>@string/true_value</item>
+        <item>@string/false_value</item>
+    </string-array>
+    <string name="native_link_already_logged_in">
+        You attempted to launch the app from the Facebook app, but are already logged in as a different
+        user. Please log out and try again.
+    </string>
+</resources>
diff --git a/samples/BooleanOGSample/src/com/facebook/samples/booleanog/LogicActivity.java b/samples/BooleanOGSample/src/com/facebook/samples/booleanog/LogicActivity.java
new file mode 100644
index 000000000..bd8b6fbb6
--- /dev/null
+++ b/samples/BooleanOGSample/src/com/facebook/samples/booleanog/LogicActivity.java
@@ -0,0 +1,824 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.booleanog;
+
+import android.app.AlertDialog;
+import android.content.Intent;
+import android.database.MatrixCursor;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+import android.support.v4.app.FragmentTransaction;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.*;
+import com.facebook.*;
+import com.facebook.model.*;
+import com.facebook.widget.FriendPickerFragment;
+import com.facebook.widget.UserSettingsFragment;
+import com.facebook.widget.PickerFragment;
+
+import java.text.SimpleDateFormat;
+import java.util.*;
+
+public class LogicActivity extends FragmentActivity {
+
+    private static final String TAG = "BooleanOpenGraphSample";
+
+    private static final String SAVE_ACTIVE_TAB = TAG + ".SAVE_ACTIVE_TAB";
+    private static final String SAVE_CONTENT_SELECTION = TAG + ".SAVE_CONTENT_SELECTION";
+    private static final String SAVE_LEFT_OPERAND_SELECTION = TAG + ".SAVE_LEFT_OPERAND_SELECTION";
+    private static final String SAVE_RIGHT_OPERAND_SELECTION = TAG + ".SAVE_RIGHT_OPERAND_SELECTION";
+    private static final String SAVE_RESULT_TEXT = TAG + ".SAVE_RESULT_TEXT";
+    private static final String SAVE_POST_RESULT_TEXT = TAG + ".SAVE_POST_RESULT_TEXT";
+    private static final String SAVE_PENDING = TAG + ".SAVE_PENDING";
+    private static final String SAVE_FRIEND_ACTIONS = TAG + ".SAVE_FRIEND_ACTIONS";
+    private static final String PENDING_POST_PATH = "PENDING_POST_PATH";
+    private static final String PENDING_POST_LEFT = "PENDING_POST_LEFT";
+    private static final String PENDING_POST_RIGHT = "PENDING_POST_RIGHT";
+    private static final String PENDING_POST_RESULT = "PENDING_POST_RESULT";
+
+    private static final String AND_ACTION = "fb_sample_boolean_og:and";
+    private static final String OR_ACTION = "fb_sample_boolean_og:or";
+    private static final String POST_AND_ACTION_PATH = "me/" + AND_ACTION;
+    private static final String POST_OR_ACTION_PATH = "me/" + OR_ACTION;
+    private static final String TRUE_GRAPH_OBJECT_URL = "http://samples.ogp.me/369360019783304";
+    private static final String FALSE_GRAPH_OBJECT_URL = "http://samples.ogp.me/369360256449947";
+    private static final String INSTALLED = "installed";
+    private static final List<String> PERMISSIONS = Arrays.asList("publish_actions");
+
+    private static volatile TruthValueGraphObject TRUE_GRAPH_OBJECT;
+    private static volatile TruthValueGraphObject FALSE_GRAPH_OBJECT;
+    private static volatile int TRUE_SPINNER_INDEX = -1;
+    private static volatile int FALSE_SPINNER_INDEX = -1;
+
+    // Main layout
+    private Button logicButton;
+    private Button friendsButton;
+    private Button settingsButton;
+    private Button contentButton;
+    private String activeTab;
+
+    // Logic group
+    private ViewGroup logicGroup;
+    private Spinner leftSpinner;
+    private Spinner rightSpinner;
+    private Button andButton;
+    private Button orButton;
+    private TextView resultText;
+    private TextView postResultText;
+    private Bundle pendingPost;
+
+    // Friends group
+    private ViewGroup friendsGroup;
+    private FriendPickerFragment friendPickerFragment;
+    private RequestAsyncTask pendingRequest;
+    private SimpleCursorAdapter friendActivityAdapter;
+    private ProgressBar friendActivityProgressBar;
+    private ArrayList<ActionRow> friendActionList;
+
+    // Login group
+    private ViewGroup settingsGroup;
+    private UserSettingsFragment userSettingsFragment;
+
+    // Content group
+    private ViewGroup contentGroup;
+    private ImageView contentImage;
+    private Spinner contentSpinner;
+
+    private UiLifecycleHelper uiHelper;
+    private Session.StatusCallback callback = new Session.StatusCallback() {
+        @Override
+        public void call(Session session, SessionState state, Exception exception) {
+            if (exception != null) {
+                pendingPost = null;
+            } else if (state == SessionState.OPENED) {
+                friendPickerFragment.loadData(false);
+            } else if (state == SessionState.OPENED_TOKEN_UPDATED) {
+                sendPendingPost();
+            }
+        }
+    };
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        uiHelper = new UiLifecycleHelper(this, callback);
+        uiHelper.onCreate(savedInstanceState);
+
+        setContentView(R.layout.main);
+
+        // Views
+        logicButton = (Button) findViewById(R.id.logic_button);
+        friendsButton = (Button) findViewById(R.id.friends_button);
+        settingsButton = (Button) findViewById(R.id.settings_button);
+        contentButton = (Button) findViewById(R.id.content_button);
+
+        logicGroup = (ViewGroup) findViewById(R.id.logic_group);
+        leftSpinner = (Spinner) findViewById(R.id.left_spinner);
+        rightSpinner = (Spinner) findViewById(R.id.right_spinner);
+        andButton = (Button) findViewById(R.id.and_button);
+        orButton = (Button) findViewById(R.id.or_button);
+        resultText = (TextView) findViewById(R.id.result_text);
+        postResultText = (TextView) findViewById(R.id.post_result_text);
+
+        friendsGroup = (ViewGroup) findViewById(R.id.friends_group);
+        ListView friendActivityList = (ListView) findViewById(R.id.friend_activity_list);
+        String[] mapColumnNames = {"date", "action"};
+        int[] mapViewIds = {R.id.friend_action_date, R.id.friend_action_data};
+        friendActivityAdapter = new SimpleCursorAdapter(this, R.layout.friend_activity_row, createEmptyCursor(),
+                mapColumnNames, mapViewIds);
+        friendActivityList.setAdapter(friendActivityAdapter);
+        friendActivityProgressBar = (ProgressBar) findViewById(R.id.friend_activity_progress_bar);
+
+        settingsGroup = (ViewGroup) findViewById(R.id.settings_group);
+
+        contentGroup = (ViewGroup) findViewById(R.id.content_group);
+        contentImage = (ImageView) findViewById(R.id.content_image);
+        contentSpinner = (Spinner) findViewById(R.id.content_spinner);
+
+        // Fragments
+        FragmentManager fragmentManager = getSupportFragmentManager();
+        FragmentTransaction transaction = fragmentManager.beginTransaction();
+
+        friendPickerFragment = (FriendPickerFragment) fragmentManager.findFragmentById(R.id.friend_picker_fragment);
+        if (friendPickerFragment == null) {
+            Bundle args = new Bundle();
+            args.putBoolean(FriendPickerFragment.SHOW_TITLE_BAR_BUNDLE_KEY, false);
+            friendPickerFragment = new FriendPickerFragment(args);
+            transaction.add(R.id.friend_picker_fragment, friendPickerFragment);
+        }
+
+        userSettingsFragment = (UserSettingsFragment) fragmentManager.findFragmentById(R.id.login_fragment);
+        if (userSettingsFragment == null) {
+            userSettingsFragment = new UserSettingsFragment();
+            transaction.add(R.id.login_fragment, userSettingsFragment);
+        }
+
+        transaction.commit();
+
+        // Spinners
+        ArrayAdapter<CharSequence> truthAdapter = ArrayAdapter
+                .createFromResource(this, R.array.truth_values, android.R.layout.simple_spinner_item);
+        truthAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
+        leftSpinner.setAdapter(truthAdapter);
+        rightSpinner.setAdapter(truthAdapter);
+        contentSpinner.setAdapter(truthAdapter);
+        leftSpinner.setSelection(0);
+        rightSpinner.setSelection(0);
+
+        // Navigation
+        for (Button button : Arrays.asList(logicButton, friendsButton, settingsButton, contentButton)) {
+            initializeNavigationButton(button);
+        }
+
+        // Logic
+        initializeCalculationButton(andButton);
+        initializeCalculationButton(orButton);
+
+        // Friends
+        friendPickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
+            @Override
+            public void onError(PickerFragment<?> fragment, FacebookException error) {
+                LogicActivity.this.onError(error);
+            }
+        });
+        friendPickerFragment.setUserId("me");
+        friendPickerFragment.setMultiSelect(false);
+        friendPickerFragment.setOnSelectionChangedListener(new PickerFragment.OnSelectionChangedListener() {
+            @Override
+            public void onSelectionChanged(PickerFragment<?> fragment) {
+                LogicActivity.this.onFriendSelectionChanged();
+            }
+        });
+        friendPickerFragment.setExtraFields(Arrays.asList(INSTALLED));
+        friendPickerFragment.setFilter(new PickerFragment.GraphObjectFilter<GraphUser>() {
+            @Override
+            public boolean includeItem(GraphUser graphObject) {
+                Boolean installed = graphObject.cast(GraphUserWithInstalled.class).getInstalled();
+                return (installed != null) && installed.booleanValue();
+            }
+        });
+
+        // Content
+        contentSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
+            @Override
+            public void onItemSelected(AdapterView<?> adapterView, View view, int i, long l) {
+                LogicActivity.this.onContentSelectionChanged();
+            }
+
+            @Override
+            public void onNothingSelected(AdapterView<?> adapterView) {
+                LogicActivity.this.onContentSelectionChanged();
+            }
+        });
+
+        // Restore saved state
+        Button startButton = logicButton;
+
+        if (savedInstanceState != null) {
+            leftSpinner.setSelection(savedInstanceState.getInt(SAVE_LEFT_OPERAND_SELECTION));
+            rightSpinner.setSelection(savedInstanceState.getInt(SAVE_RIGHT_OPERAND_SELECTION));
+            contentSpinner.setSelection(savedInstanceState.getInt(SAVE_CONTENT_SELECTION));
+            resultText.setText(savedInstanceState.getString(SAVE_RESULT_TEXT));
+            postResultText.setText(savedInstanceState.getString(SAVE_POST_RESULT_TEXT));
+            activeTab = savedInstanceState.getString(SAVE_ACTIVE_TAB);
+            pendingPost = savedInstanceState.getBundle(SAVE_PENDING);
+
+            friendActionList = savedInstanceState.getParcelableArrayList(SAVE_FRIEND_ACTIONS);
+            if ((friendActionList != null) && (friendActionList.size() > 0)) {
+                updateCursor(friendActionList);
+            }
+
+            if (getString(R.string.navigate_friends).equals(activeTab)) {
+                startButton = friendsButton;
+            } else if (getString(R.string.navigate_content).equals(activeTab)) {
+                startButton = contentButton;
+            } else if (getString(R.string.navigate_settings).equals(activeTab)) {
+                startButton = settingsButton;
+            }
+        }
+
+        if (!handleNativeLink()) {
+            onNavigateButtonClick(startButton);
+        }
+    }
+
+    // -----------------------------------------------------------------------------------
+    // Activity lifecycle
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        Session session = Session.getActiveSession();
+        if (session != null && session.isOpened()) {
+            friendPickerFragment.loadData(false);
+        }
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        uiHelper.onResume();
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        uiHelper.onSaveInstanceState(outState);
+
+        outState.putInt(SAVE_LEFT_OPERAND_SELECTION, leftSpinner.getSelectedItemPosition());
+        outState.putInt(SAVE_RIGHT_OPERAND_SELECTION, rightSpinner.getSelectedItemPosition());
+        outState.putInt(SAVE_CONTENT_SELECTION, contentSpinner.getSelectedItemPosition());
+        outState.putString(SAVE_RESULT_TEXT, resultText.getText().toString());
+        outState.putString(SAVE_POST_RESULT_TEXT, postResultText.getText().toString());
+        outState.putString(SAVE_ACTIVE_TAB, activeTab);
+        outState.putBundle(SAVE_PENDING, pendingPost);
+        outState.putParcelableArrayList(SAVE_FRIEND_ACTIONS, friendActionList);
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        uiHelper.onPause();
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        uiHelper.onDestroy();
+
+        friendPickerFragment.setOnErrorListener(null);
+        friendPickerFragment.setOnSelectionChangedListener(null);
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        uiHelper.onActivityResult(requestCode, resultCode, data);
+    }
+
+    // -----------------------------------------------------------------------------------
+    // Navigation
+
+    private void initializeNavigationButton(Button button) {
+        button.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                onNavigateButtonClick((Button) view);
+            }
+        });
+    }
+
+    private void onNavigateButtonClick(Button source) {
+        activeTab = source.getText().toString();
+
+        logicGroup.setVisibility(getGroupVisibility(source, logicButton));
+        friendsGroup.setVisibility(getGroupVisibility(source, friendsButton));
+        settingsGroup.setVisibility(getGroupVisibility(source, settingsButton));
+        contentGroup.setVisibility(getGroupVisibility(source, contentButton));
+
+        // Show an error if viewing friends and there is no logged in user.
+        if (source == friendsButton) {
+            Session session = Session.getActiveSession();
+            if ((session == null) || !session.isOpened()) {
+                new AlertDialog.Builder(this)
+                        .setTitle(R.string.feature_requires_login_title)
+                        .setMessage(R.string.feature_requires_login_message)
+                        .setPositiveButton(R.string.ok_button, null)
+                        .show();
+            }
+        }
+    }
+
+    private int getGroupVisibility(Button source, Button groupButton) {
+        if (source == groupButton) {
+            return View.VISIBLE;
+        } else {
+            return View.GONE;
+        }
+    }
+
+    // -----------------------------------------------------------------------------------
+    // Logic group
+
+    private void initializeCalculationButton(Button button) {
+        button.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                onOperationButtonClick(view);
+            }
+        });
+    }
+
+    private void onOperationButtonClick(View view) {
+        if (view == andButton) {
+            onAndButtonClick();
+        } else if (view == orButton) {
+            onOrButtonClick();
+        } else {
+            assert false;
+        }
+    }
+
+    private void onAndButtonClick() {
+        boolean leftOperand = getSpinnerBoolean(leftSpinner);
+        boolean rightOperand = getSpinnerBoolean(rightSpinner);
+        boolean result = leftOperand && rightOperand;
+
+        resultText.setText(getLogicText(getString(R.string.and_operation), leftOperand, rightOperand, result));
+        postAction(POST_AND_ACTION_PATH, leftOperand, rightOperand, result);
+    }
+
+    private void onOrButtonClick() {
+        boolean leftOperand = getSpinnerBoolean(leftSpinner);
+        boolean rightOperand = getSpinnerBoolean(rightSpinner);
+        boolean result = leftOperand || rightOperand;
+
+        resultText.setText(getLogicText(getString(R.string.or_operation), leftOperand, rightOperand, result));
+        postAction(POST_OR_ACTION_PATH, leftOperand, rightOperand, result);
+    }
+
+    private String getLogicText(String op, boolean leftOperand, boolean rightOperand, boolean result) {
+        String trueString = getString(R.string.true_value);
+        String falseString = getString(R.string.false_value);
+        String arg0String = leftOperand ? trueString : falseString;
+        String arg1String = rightOperand ? trueString : falseString;
+        String resultString = result ? trueString : falseString;
+
+        return String.format("%s %s %s = %s", arg0String, op, arg1String, resultString);
+    }
+
+    private void postAction(final String actionPath, final boolean leftOperand, final boolean rightOperand,
+            final boolean result) {
+        Bundle post = new Bundle();
+        post.putString(PENDING_POST_PATH, actionPath);
+        post.putBoolean(PENDING_POST_LEFT, leftOperand);
+        post.putBoolean(PENDING_POST_RIGHT, rightOperand);
+        post.putBoolean(PENDING_POST_RESULT, result);
+        pendingPost = post;
+
+        sendPendingPost();
+    }
+
+    private void sendPendingPost() {
+        if (pendingPost == null) {
+            return;
+        }
+
+        Session session = Session.getActiveSession();
+        if ((session == null) || !session.isOpened()) {
+            postResultText.setText("Not logged in, no post generated.");
+            pendingPost = null;
+            return;
+        }
+
+        List<String> permissions = session.getPermissions();
+        if (!permissions.containsAll(PERMISSIONS)) {
+            Session.NewPermissionsRequest newPermissionsRequest = new Session.NewPermissionsRequest(this, PERMISSIONS);
+            session.requestNewPublishPermissions(newPermissionsRequest);
+            return;
+        }
+
+        postResultText.setText("Posting action...");
+
+        // For demo purposes, result is just a boolean, but operands are Open Graph objects
+        String actionPath = pendingPost.getString(PENDING_POST_PATH);
+        boolean leftOperand = pendingPost.getBoolean(PENDING_POST_LEFT);
+        boolean rightOperand = pendingPost.getBoolean(PENDING_POST_RIGHT);
+        boolean result = pendingPost.getBoolean(PENDING_POST_RESULT);
+
+        LogicAction action = GraphObject.Factory.create(LogicAction.class);
+        action.setResult(result);
+        action.setTruthvalue(getTruthValueObject(leftOperand));
+        action.setAnothertruthvalue(getTruthValueObject(rightOperand));
+
+        Request.Callback callback = new Request.Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                onPostActionResponse(response);
+            }
+        };
+        Request request = new Request(session, actionPath, null, HttpMethod.POST,
+                callback);
+        request.setGraphObject(action);
+        RequestAsyncTask task = new RequestAsyncTask(request);
+
+        task.execute();
+    }
+
+    private void onPostActionResponse(Response response) {
+        PostResponse postResponse = response.getGraphObjectAs(PostResponse.class);
+        if (postResponse != null && postResponse.getId() != null) {
+            postResultText.setText("Post id = " + postResponse.getId());
+        } else if (response.getError() != null) {
+            postResultText.setText(response.getError().getErrorMessage());
+        } else {
+            postResultText.setText("");
+        }
+    }
+
+    private TruthValueGraphObject getTruthValueObject(boolean value) {
+        if (value) {
+            if (TRUE_GRAPH_OBJECT == null) {
+                TruthValueGraphObject object = GraphObject.Factory
+                        .create(TruthValueGraphObject.class);
+                object.setUrl(TRUE_GRAPH_OBJECT_URL);
+                TRUE_GRAPH_OBJECT = object;
+            }
+            return TRUE_GRAPH_OBJECT;
+        } else {
+            if (FALSE_GRAPH_OBJECT == null) {
+                TruthValueGraphObject object = GraphObject.Factory
+                        .create(TruthValueGraphObject.class);
+                object.setUrl(FALSE_GRAPH_OBJECT_URL);
+                FALSE_GRAPH_OBJECT = object;
+            }
+            return FALSE_GRAPH_OBJECT;
+        }
+    }
+
+    // -----------------------------------------------------------------------------------
+    // Friends group
+
+    private void onFriendSelectionChanged() {
+        GraphUser user = chooseOne(friendPickerFragment.getSelection());
+        if (user != null) {
+            onChooseFriend(user.getId());
+        } else {
+            friendActivityAdapter.changeCursor(createEmptyCursor());
+        }
+    }
+
+    private void onChooseFriend(String friendId) {
+        friendActivityProgressBar.setVisibility(View.VISIBLE);
+
+        String andPath = String.format("%s/%s", friendId, AND_ACTION);
+        String orPath = String.format("%s/%s", friendId, OR_ACTION);
+        Request getAnds = new Request(Session.getActiveSession(), andPath, null, HttpMethod.GET);
+        Request getOrs = new Request(Session.getActiveSession(), orPath, null, HttpMethod.GET);
+
+        RequestBatch batch = new RequestBatch(getAnds, getOrs);
+
+        if (pendingRequest != null) {
+            pendingRequest.cancel(true);
+        }
+
+        pendingRequest = new RequestAsyncTask(batch) {
+            @Override
+            protected void onPostExecute(List<Response> result) {
+                if (pendingRequest == this) {
+                    pendingRequest = null;
+
+                    LogicActivity.this.onPostExecute(result);
+                }
+            }
+        };
+
+        pendingRequest.execute();
+    }
+
+    private void onPostExecute(List<Response> result) {
+        friendActivityProgressBar.setVisibility(View.GONE);
+
+        friendActionList = createActionRows(result);
+        updateCursor(friendActionList);
+    }
+
+    private ArrayList<ActionRow> createActionRows(List<Response> result) {
+        ArrayList<ActionRow> publishedItems = new ArrayList<ActionRow>();
+
+        for (Response response : result) {
+            if (response.getError() != null) {
+                continue;
+            }
+
+            GraphMultiResult list = response.getGraphObjectAs(GraphMultiResult.class);
+            List<PublishedLogicAction> listData = list.getData().castToListOf(PublishedLogicAction.class);
+
+            for (PublishedLogicAction action : listData) {
+                publishedItems.add(createActionRow(action));
+            }
+        }
+
+        Collections.sort(publishedItems);
+        return publishedItems;
+    }
+
+    private void updateCursor(Iterable<ActionRow> publishedItems) {
+        MatrixCursor cursor = createEmptyCursor();
+        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault());
+
+        int id = 0;
+        for (ActionRow item : publishedItems) {
+            Object[] row = new Object[3];
+            row[0] = id++;
+            row[1] = dateFormat.format(item.publishDate);
+            row[2] = item.actionText;
+            cursor.addRow(row);
+        }
+
+        friendActivityAdapter.changeCursor(cursor);
+        friendActivityAdapter.notifyDataSetChanged();
+    }
+
+    private MatrixCursor createEmptyCursor() {
+        String[] cursorColumns = {"_ID", "date", "action"};
+        return new MatrixCursor(cursorColumns);
+    }
+
+    private ActionRow createActionRow(PublishedLogicAction action) {
+        String actionText = getActionText(action);
+        Date publishDate = action.getPublishTime();
+
+        return new ActionRow(actionText, publishDate);
+    }
+
+    private String getActionText(PublishedLogicAction action) {
+        LogicAction actionData = action.getData();
+        if (actionData == null) {
+            return "";
+        }
+
+        TruthValueGraphObject left = actionData.getTruthvalue();
+        TruthValueGraphObject right = actionData.getAnothertruthvalue();
+        Boolean actionResult = actionData.getResult();
+
+        String verb = action.getType();
+        if (AND_ACTION.equals(verb)) {
+            verb = getString(R.string.and_operation);
+        } else if (OR_ACTION.equals(verb)) {
+            verb = getString(R.string.or_operation);
+        }
+
+        if ((left == null) || (right == null) || (actionResult == null) || (verb == null)) {
+            return "";
+        }
+
+        return String.format("%s %s %s = %s", left.getTitle(), verb, right.getTitle(), actionResult.toString());
+    }
+
+    // -----------------------------------------------------------------------------------
+    // Content group
+
+    private Boolean getDeepLinkContent(Uri deepLinkUri) {
+        if (deepLinkUri != null) {
+            String deepLink = deepLinkUri.toString();
+
+            if (deepLink.startsWith(TRUE_GRAPH_OBJECT_URL)) {
+                return Boolean.TRUE;
+            } else if (deepLink.startsWith(FALSE_GRAPH_OBJECT_URL)) {
+                return Boolean.FALSE;
+            }
+        }
+
+        return null;
+    }
+
+    private void onContentSelectionChanged() {
+        Boolean spinnerBoolean = getSpinnerBoolean(contentSpinner);
+        if (Boolean.TRUE.equals(spinnerBoolean)) {
+            contentImage.setVisibility(View.VISIBLE);
+            contentImage.setImageResource(R.drawable.true_content);
+        } else if (Boolean.FALSE.equals(spinnerBoolean)) {
+            contentImage.setVisibility(View.VISIBLE);
+            contentImage.setImageResource(R.drawable.false_content);
+        } else {
+            contentImage.setImageResource(View.INVISIBLE);
+        }
+    }
+
+    // -----------------------------------------------------------------------------------
+    // Utility methods
+
+    private boolean handleNativeLink() {
+        Session existingSession = Session.getActiveSession();
+        // If we have a valid existing session, we'll use it; if not, open one using the provided Intent
+        // but do not cache the token (we don't want to use the same user identity the next time the
+        // app is run).
+        if (existingSession == null || !existingSession.isOpened()) {
+            AccessToken accessToken = AccessToken.createFromNativeLinkingIntent(getIntent());
+            if (accessToken != null) {
+                Session newSession = new Session.Builder(this).setTokenCachingStrategy(new NonCachingTokenCachingStrategy())
+                        .build();
+                newSession.open(accessToken, null);
+
+                Session.setActiveSession(newSession);
+            }
+        }
+        // See if we have a deep link in addition.
+        Boolean deepLinkContent = getDeepLinkContent(getIntent().getData());
+        if (deepLinkContent != null) {
+            onNavigateButtonClick(contentButton);
+            contentSpinner.setSelection(getSpinnerPosition(deepLinkContent));
+            return true;
+        }
+
+        return false;
+    }
+
+    private int getSpinnerPosition(Boolean value) {
+        initializeSpinnerIndexes();
+
+        if (Boolean.TRUE.equals(value)) {
+            return TRUE_SPINNER_INDEX;
+        } else if (Boolean.FALSE.equals(value)) {
+            return FALSE_SPINNER_INDEX;
+        } else {
+            return -1;
+        }
+    }
+
+    private Boolean getSpinnerBoolean(Spinner spinner) {
+        initializeSpinnerIndexes();
+
+        int position = spinner.getSelectedItemPosition();
+        if (position == TRUE_SPINNER_INDEX) {
+            return Boolean.TRUE;
+        } else if (position == FALSE_SPINNER_INDEX) {
+            return Boolean.FALSE;
+        } else {
+            return null;
+        }
+    }
+
+    private void initializeSpinnerIndexes() {
+        if ((TRUE_SPINNER_INDEX < 0) || (FALSE_SPINNER_INDEX < 0)) {
+            String[] truthArray = getResources().getStringArray(R.array.truth_values);
+            List<String> truthList = Arrays.asList(truthArray);
+            TRUE_SPINNER_INDEX = truthList.indexOf(getString(R.string.true_value));
+            FALSE_SPINNER_INDEX = truthList.indexOf(getString(R.string.false_value));
+        }
+    }
+
+    private void onError(Exception error) {
+        showErrorMessage(error.getMessage());
+    }
+
+    private void showErrorMessage(String message) {
+        new AlertDialog.Builder(this)
+                .setTitle(R.string.error_dialog_title)
+                .setMessage(message)
+                .setPositiveButton(R.string.ok_button, null)
+                .show();
+    }
+
+    private <T> T chooseOne(List<T> ts) {
+        for (T t : ts) {
+            return t;
+        }
+
+        return null;
+    }
+
+    // -----------------------------------------------------------------------------------
+    // Supporting types
+
+    private interface GraphUserWithInstalled extends GraphUser {
+        Boolean getInstalled();
+    }
+
+    private static class ActionRow implements Comparable<ActionRow>, Parcelable {
+        final String actionText;
+        final Date publishDate;
+
+        ActionRow(String actionText, Date publishDate) {
+            this.actionText = actionText;
+            this.publishDate = publishDate;
+        }
+
+        @Override
+        public int compareTo(ActionRow other) {
+            if (other == null) {
+                return 1;
+            } else {
+                return publishDate.compareTo(other.publishDate);
+            }
+        }
+
+        @Override
+        public int describeContents() {
+            return 0;
+        }
+
+        @Override
+        public void writeToParcel(Parcel parcel, int flags) {
+            parcel.writeString(actionText);
+            parcel.writeLong(publishDate.getTime());
+        }
+
+        @SuppressWarnings("unused")
+        public final Creator<ActionRow> CREATOR = new Creator<ActionRow>() {
+            @Override
+            public ActionRow createFromParcel(Parcel parcel) {
+                String actionText = parcel.readString();
+                Date publishDate = new Date(parcel.readLong());
+                return new ActionRow(actionText, publishDate);
+            }
+
+            @Override
+            public ActionRow[] newArray(int size) {
+                return new ActionRow[size];
+            }
+        };
+    }
+
+    /**
+     * Used to create and consume TruthValue open graph objects.
+     */
+    private interface TruthValueGraphObject extends GraphObject {
+        void setUrl(String url);
+
+        String getTitle();
+    }
+
+    /**
+     * Used to create and consume And an Or open graph actions
+     */
+    private interface LogicAction extends OpenGraphAction {
+        Boolean getResult();
+
+        void setResult(Boolean result);
+
+        TruthValueGraphObject getTruthvalue();
+
+        void setTruthvalue(TruthValueGraphObject truthvalue);
+
+        TruthValueGraphObject getAnothertruthvalue();
+
+        void setAnothertruthvalue(TruthValueGraphObject anothertruthvalue);
+    }
+
+    /**
+     * Used to consume published And and Or open graph actions.
+     */
+    private interface PublishedLogicAction extends OpenGraphAction {
+        LogicAction getData();
+
+        String getType();
+    }
+
+    /**
+     * Used to inspect the response from posting an action
+     */
+    private interface PostResponse extends GraphObject {
+        String getId();
+    }
+}
diff --git a/samples/FriendPickerSample/.classpath b/samples/FriendPickerSample/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/FriendPickerSample/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/FriendPickerSample/.project b/samples/FriendPickerSample/.project
new file mode 100644
index 000000000..c956fc90d
--- /dev/null
+++ b/samples/FriendPickerSample/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>FriendPickerSample</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/samples/FriendPickerSample/AndroidManifest.xml b/samples/FriendPickerSample/AndroidManifest.xml
new file mode 100644
index 000000000..d8f1911cd
--- /dev/null
+++ b/samples/FriendPickerSample/AndroidManifest.xml
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.facebook.samples.friendpicker"
+          android:versionCode="1"
+          android:versionName="1.0">
+    <uses-sdk android:minSdkVersion="8"/>
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+    <application android:label="@string/app_name"
+                 android:icon="@drawable/icon"
+                 android:theme="@android:style/Theme.NoTitleBar"
+                 android:name=".FriendPickerApplication"
+            >
+        <activity android:name="FriendPickerSampleActivity"
+                  android:label="@string/app_name"
+                  android:windowSoftInputMode="adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+        <activity android:name="PickFriendsActivity"
+                  android:label="Pick Friends">
+        </activity>
+        <activity android:name="com.facebook.LoginActivity"
+                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
+                  android:label="@string/app_name" />
+        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
+    </application>
+</manifest>
diff --git a/samples/FriendPickerSample/FriendPickerSample.iml b/samples/FriendPickerSample/FriendPickerSample.iml
new file mode 100644
index 000000000..4aac86509
--- /dev/null
+++ b/samples/FriendPickerSample/FriendPickerSample.iml
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/samples/FriendPickerSample/ant.properties b/samples/FriendPickerSample/ant.properties
new file mode 100644
index 000000000..939105d52
--- /dev/null
+++ b/samples/FriendPickerSample/ant.properties
@@ -0,0 +1,18 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
+java.compilerargs=-Xlint -Werror
diff --git a/samples/FriendPickerSample/build.xml b/samples/FriendPickerSample/build.xml
new file mode 100644
index 000000000..92f485560
--- /dev/null
+++ b/samples/FriendPickerSample/build.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="FriendPickerSample" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties"/>
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties"/>
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env"/>
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME"/>
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties"/>
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+            />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true"/>
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml"/>
+
+</project>
diff --git a/samples/FriendPickerSample/proguard-project.txt b/samples/FriendPickerSample/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/FriendPickerSample/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/samples/FriendPickerSample/project.properties b/samples/FriendPickerSample/project.properties
new file mode 100644
index 000000000..cee0509c6
--- /dev/null
+++ b/samples/FriendPickerSample/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+android.library.reference.1=../../facebook
diff --git a/samples/FriendPickerSample/res/drawable-hdpi/icon.png b/samples/FriendPickerSample/res/drawable-hdpi/icon.png
new file mode 100644
index 000000000..6a930c6c6
Binary files /dev/null and b/samples/FriendPickerSample/res/drawable-hdpi/icon.png differ
diff --git a/samples/FriendPickerSample/res/drawable-mdpi/icon.png b/samples/FriendPickerSample/res/drawable-mdpi/icon.png
new file mode 100644
index 000000000..33b418b7a
Binary files /dev/null and b/samples/FriendPickerSample/res/drawable-mdpi/icon.png differ
diff --git a/samples/FriendPickerSample/res/drawable-xhdpi/icon.png b/samples/FriendPickerSample/res/drawable-xhdpi/icon.png
new file mode 100644
index 000000000..494e37a8d
Binary files /dev/null and b/samples/FriendPickerSample/res/drawable-xhdpi/icon.png differ
diff --git a/samples/FriendPickerSample/res/drawable/icon.png b/samples/FriendPickerSample/res/drawable/icon.png
new file mode 100644
index 000000000..33b418b7a
Binary files /dev/null and b/samples/FriendPickerSample/res/drawable/icon.png differ
diff --git a/samples/FriendPickerSample/res/layout/main.xml b/samples/FriendPickerSample/res/layout/main.xml
new file mode 100644
index 000000000..e767ff16f
--- /dev/null
+++ b/samples/FriendPickerSample/res/layout/main.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:orientation="vertical"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+        >
+    <Button
+            android:id="@+id/pickFriendsButton"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:text="Pick Friends"
+            />
+    <TextView
+            android:id="@+id/resultsTextView"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:textColor="#FFFFFF"
+            />
+
+</LinearLayout>
+
diff --git a/samples/FriendPickerSample/res/layout/pick_friends_activity.xml b/samples/FriendPickerSample/res/layout/pick_friends_activity.xml
new file mode 100644
index 000000000..3dbf01b9a
--- /dev/null
+++ b/samples/FriendPickerSample/res/layout/pick_friends_activity.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:orientation="vertical"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+        >
+    <FrameLayout
+            android:id="@+id/friend_picker_fragment"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            />
+</LinearLayout>
+
diff --git a/samples/FriendPickerSample/res/values/strings.xml b/samples/FriendPickerSample/res/values/strings.xml
new file mode 100644
index 000000000..ebe6e4bcf
--- /dev/null
+++ b/samples/FriendPickerSample/res/values/strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<resources>
+    <string name="app_name">FriendPickerSample</string>
+    <string name="app_id">370546396320150</string>
+    <string name="error_dialog_title">Error</string>
+    <string name="ok_button">OK</string>
+</resources>
diff --git a/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerApplication.java b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerApplication.java
new file mode 100644
index 000000000..d72c593eb
--- /dev/null
+++ b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerApplication.java
@@ -0,0 +1,36 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.friendpicker;
+
+import android.app.Application;
+import com.facebook.model.GraphUser;
+
+import java.util.Collection;
+
+// We use a custom Application class to store our minimal state data (which users have been selected).
+// A real-world application will likely require a more robust data model.
+public class FriendPickerApplication extends Application {
+    private Collection<GraphUser> selectedUsers;
+
+    public Collection<GraphUser> getSelectedUsers() {
+        return selectedUsers;
+    }
+
+    public void setSelectedUsers(Collection<GraphUser> selectedUsers) {
+        this.selectedUsers = selectedUsers;
+    }
+}
diff --git a/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerSampleActivity.java b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerSampleActivity.java
new file mode 100644
index 000000000..42cdfc69e
--- /dev/null
+++ b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/FriendPickerSampleActivity.java
@@ -0,0 +1,106 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.friendpicker;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+import android.text.TextUtils;
+import android.view.View;
+import android.widget.Button;
+import android.widget.TextView;
+import com.facebook.model.GraphUser;
+import com.facebook.Session;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+public class FriendPickerSampleActivity extends FragmentActivity {
+    private static final int PICK_FRIENDS_ACTIVITY = 1;
+    private Button pickFriendsButton;
+    private TextView resultsTextView;
+
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+
+        resultsTextView = (TextView) findViewById(R.id.resultsTextView);
+        pickFriendsButton = (Button) findViewById(R.id.pickFriendsButton);
+        pickFriendsButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View view) {
+                onClickPickFriends();
+            }
+        });
+
+        if (Session.getActiveSession() == null ||
+                Session.getActiveSession().isClosed()) {
+            Session.openActiveSession(this, true, null);
+        }
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+
+        // Update the display every time we are started.
+        displaySelectedFriends(RESULT_OK);
+    }
+
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        switch (requestCode) {
+            case PICK_FRIENDS_ACTIVITY:
+                displaySelectedFriends(resultCode);
+                break;
+            default:
+                Session.getActiveSession().onActivityResult(this, requestCode, resultCode, data);
+                break;
+        }
+    }
+
+    private void displaySelectedFriends(int resultCode) {
+        String results = "";
+        FriendPickerApplication application = (FriendPickerApplication) getApplication();
+
+        Collection<GraphUser> selection = application.getSelectedUsers();
+        if (selection != null && selection.size() > 0) {
+            ArrayList<String> names = new ArrayList<String>();
+            for (GraphUser user : selection) {
+                names.add(user.getName());
+            }
+            results = TextUtils.join(", ", names);
+        } else {
+            results = "<No friends selected>";
+        }
+
+        resultsTextView.setText(results);
+    }
+
+    private void onClickPickFriends() {
+        FriendPickerApplication application = (FriendPickerApplication) getApplication();
+        application.setSelectedUsers(null);
+
+        Intent intent = new Intent(this, PickFriendsActivity.class);
+        // Note: The following line is optional, as multi-select behavior is the default for
+        // FriendPickerFragment. It is here to demonstrate how parameters could be passed to the
+        // friend picker if single-select functionality was desired, or if a different user ID was
+        // desired (for instance, to see friends of a friend).
+        PickFriendsActivity.populateParameters(intent, null, true, true);
+        startActivityForResult(intent, PICK_FRIENDS_ACTIVITY);
+    }
+}
diff --git a/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/PickFriendsActivity.java b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/PickFriendsActivity.java
new file mode 100644
index 000000000..d7232f374
--- /dev/null
+++ b/samples/FriendPickerSample/src/com/facebook/samples/friendpicker/PickFriendsActivity.java
@@ -0,0 +1,104 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.friendpicker;
+
+import android.app.AlertDialog;
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+import com.facebook.FacebookException;
+import com.facebook.widget.FriendPickerFragment;
+import com.facebook.widget.PickerFragment;
+
+// This class provides an example of an Activity that uses FriendPickerFragment to display a list of
+// the user's friends. It takes a programmatic approach to creating the FriendPickerFragment with the
+// desired parameters -- see PickPlaceActivity in the PlacePickerSample project for an example of an
+// Activity creating a fragment (in this case a PlacePickerFragment) via XML layout rather than
+// programmatically.
+public class PickFriendsActivity extends FragmentActivity {
+    FriendPickerFragment friendPickerFragment;
+
+    // A helper to simplify life for callers who want to populate a Bundle with the necessary
+    // parameters. A more sophisticated Activity might define its own set of parameters; our needs
+    // are simple, so we just populate what we want to pass to the FriendPickerFragment.
+    public static void populateParameters(Intent intent, String userId, boolean multiSelect, boolean showTitleBar) {
+        intent.putExtra(FriendPickerFragment.USER_ID_BUNDLE_KEY, userId);
+        intent.putExtra(FriendPickerFragment.MULTI_SELECT_BUNDLE_KEY, multiSelect);
+        intent.putExtra(FriendPickerFragment.SHOW_TITLE_BAR_BUNDLE_KEY, showTitleBar);
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.pick_friends_activity);
+
+        FragmentManager fm = getSupportFragmentManager();
+
+        if (savedInstanceState == null) {
+            // First time through, we create our fragment programmatically.
+            final Bundle args = getIntent().getExtras();
+            friendPickerFragment = new FriendPickerFragment(args);
+            fm.beginTransaction()
+                    .add(R.id.friend_picker_fragment, friendPickerFragment)
+                    .commit();
+        } else {
+            // Subsequent times, our fragment is recreated by the framework and already has saved and
+            // restored its state, so we don't need to specify args again. (In fact, this might be
+            // incorrect if the fragment was modified programmatically since it was created.)
+            friendPickerFragment = (FriendPickerFragment) fm.findFragmentById(R.id.friend_picker_fragment);
+        }
+
+        friendPickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
+            @Override
+            public void onError(PickerFragment<?> fragment, FacebookException error) {
+                PickFriendsActivity.this.onError(error);
+            }
+        });
+
+        friendPickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
+            @Override
+            public void onDoneButtonClicked(PickerFragment<?> fragment) {
+                // We just store our selection in the Application for other activities to look at.
+                FriendPickerApplication application = (FriendPickerApplication) getApplication();
+                application.setSelectedUsers(friendPickerFragment.getSelection());
+
+                setResult(RESULT_OK, null);
+                finish();
+            }
+        });
+    }
+
+    private void onError(Exception error) {
+        new AlertDialog.Builder(this)
+                .setTitle(R.string.error_dialog_title)
+                .setMessage(error.getMessage())
+                .setPositiveButton(R.string.ok_button, null)
+                .show();
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        try {
+            // Load data, unless a query has already taken place.
+            friendPickerFragment.loadData(false);
+        } catch (Exception ex) {
+            onError(ex);
+        }
+    }
+}
diff --git a/samples/GraphApiSample/.classpath b/samples/GraphApiSample/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/GraphApiSample/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/GraphApiSample/.project b/samples/GraphApiSample/.project
new file mode 100644
index 000000000..cb993bbc8
--- /dev/null
+++ b/samples/GraphApiSample/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>GraphApiSample</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/samples/GraphApiSample/AndroidManifest.xml b/samples/GraphApiSample/AndroidManifest.xml
new file mode 100644
index 000000000..3647ce9a0
--- /dev/null
+++ b/samples/GraphApiSample/AndroidManifest.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.samples.graphapi"
+    android:versionCode="1"
+    android:versionName="1.0" >
+
+    <uses-sdk android:minSdkVersion="8" />
+    <uses-permission android:name="android.permission.INTERNET"/>
+
+    <application
+        android:icon="@drawable/icon"
+        android:label="@string/app_name" >
+        <activity
+            android:name=".GraphApiSampleActivity"
+            android:label="@string/app_name"
+            android:windowSoftInputMode="adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+        <activity android:name="com.facebook.LoginActivity"
+                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
+                  android:label="@string/app_name" />
+    </application>
+
+</manifest>
diff --git a/samples/GraphApiSample/GraphApiSample.iml b/samples/GraphApiSample/GraphApiSample.iml
new file mode 100644
index 000000000..8de1db588
--- /dev/null
+++ b/samples/GraphApiSample/GraphApiSample.iml
@@ -0,0 +1,55 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="EclipseModuleManager">
+    <conelement value="com.android.ide.eclipse.adt.LIBRARIES" />
+    <src_description expected_position="0">
+      <src_folder value="file://$MODULE_DIR$/src" expected_position="0" />
+      <src_folder value="file://$MODULE_DIR$/gen" expected_position="1" />
+    </src_description>
+  </component>
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/bin/classes" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/samples/GraphApiSample/ant.properties b/samples/GraphApiSample/ant.properties
new file mode 100644
index 000000000..939105d52
--- /dev/null
+++ b/samples/GraphApiSample/ant.properties
@@ -0,0 +1,18 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
+java.compilerargs=-Xlint -Werror
diff --git a/samples/GraphApiSample/build.xml b/samples/GraphApiSample/build.xml
new file mode 100644
index 000000000..b2456a58c
--- /dev/null
+++ b/samples/GraphApiSample/build.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="GraphApiSample" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties" />
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties" />
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env" />
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME" />
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties" />
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+    />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true" />
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml" />
+
+</project>
diff --git a/samples/GraphApiSample/proguard-project.txt b/samples/GraphApiSample/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/GraphApiSample/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/samples/GraphApiSample/project.properties b/samples/GraphApiSample/project.properties
new file mode 100644
index 000000000..cee0509c6
--- /dev/null
+++ b/samples/GraphApiSample/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+android.library.reference.1=../../facebook
diff --git a/samples/GraphApiSample/res/drawable-hdpi/icon.png b/samples/GraphApiSample/res/drawable-hdpi/icon.png
new file mode 100644
index 000000000..a888af1c6
Binary files /dev/null and b/samples/GraphApiSample/res/drawable-hdpi/icon.png differ
diff --git a/samples/GraphApiSample/res/drawable-mdpi/icon.png b/samples/GraphApiSample/res/drawable-mdpi/icon.png
new file mode 100644
index 000000000..2275c8571
Binary files /dev/null and b/samples/GraphApiSample/res/drawable-mdpi/icon.png differ
diff --git a/samples/GraphApiSample/res/drawable-xhdpi/icon.png b/samples/GraphApiSample/res/drawable-xhdpi/icon.png
new file mode 100644
index 000000000..31201f160
Binary files /dev/null and b/samples/GraphApiSample/res/drawable-xhdpi/icon.png differ
diff --git a/samples/GraphApiSample/res/drawable/icon.png b/samples/GraphApiSample/res/drawable/icon.png
new file mode 100644
index 000000000..2275c8571
Binary files /dev/null and b/samples/GraphApiSample/res/drawable/icon.png differ
diff --git a/samples/GraphApiSample/res/layout/main.xml b/samples/GraphApiSample/res/layout/main.xml
new file mode 100644
index 000000000..3861aebbf
--- /dev/null
+++ b/samples/GraphApiSample/res/layout/main.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:orientation="vertical" >
+
+    <EditText
+        android:id="@+id/editRequests"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:ems="10" >
+
+        <requestFocus />
+    </EditText>
+
+    <Button
+        android:id="@+id/buttonRequest"
+        android:layout_width="122dp"
+        android:layout_height="wrap_content"
+        android:text="@string/request" />
+
+    <TextView
+        android:id="@+id/textViewResults"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:textAppearance="?android:attr/textAppearanceLarge" />
+
+</LinearLayout>
diff --git a/samples/GraphApiSample/res/values/strings.xml b/samples/GraphApiSample/res/values/strings.xml
new file mode 100644
index 000000000..f30f73b1f
--- /dev/null
+++ b/samples/GraphApiSample/res/values/strings.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<resources>
+
+    <string name="hello">Hello World, GraphApiSampleActivity!</string>
+    <string name="app_name">GraphApiSample</string>
+    <string name="request">Request</string>
+    <string name="instructions">Login to create a link to fetch account data</string>
+    <string name="logout">Log out</string>
+    <string name="login_failed_dialog_title">Login failed</string>
+    <string name="ok_button">OK</string>
+
+</resources>
diff --git a/samples/GraphApiSample/src/com/facebook/samples/graphapi/GraphApiSampleActivity.java b/samples/GraphApiSample/src/com/facebook/samples/graphapi/GraphApiSampleActivity.java
new file mode 100644
index 000000000..b3b1c2f44
--- /dev/null
+++ b/samples/GraphApiSample/src/com/facebook/samples/graphapi/GraphApiSampleActivity.java
@@ -0,0 +1,144 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.graphapi;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.Intent;
+import android.os.Bundle;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.TextView;
+import com.facebook.*;
+import com.facebook.Session.StatusCallback;
+import com.facebook.model.GraphObject;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class GraphApiSampleActivity extends Activity {
+    static final String applicationId = "307234779396415";
+    static final String PENDING_REQUEST_BUNDLE_KEY = "com.facebook.samples.graphapi:PendingRequest";
+
+    Button buttonRequest;
+    EditText editRequests;
+    TextView textViewResults;
+    Session session;
+    boolean pendingRequest;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+        this.buttonRequest = (Button) findViewById(R.id.buttonRequest);
+        this.buttonRequest.setOnClickListener(new OnClickListener() {
+            public void onClick(View view) {
+                onClickRequest();
+            }
+        });
+        this.editRequests = (EditText) findViewById(R.id.editRequests);
+        this.textViewResults = (TextView) findViewById(R.id.textViewResults);
+
+        this.session = createSession();
+        Settings.addLoggingBehavior(LoggingBehavior.INCLUDE_ACCESS_TOKENS);
+    }
+
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        if (this.session.onActivityResult(this, requestCode, resultCode, data) &&
+                pendingRequest &&
+                this.session.getState().isOpened()) {
+            sendRequests();
+        }
+    }
+
+    @Override
+    protected void onRestoreInstanceState(Bundle savedInstanceState) {
+        super.onRestoreInstanceState(savedInstanceState);
+
+        pendingRequest = savedInstanceState.getBoolean(PENDING_REQUEST_BUNDLE_KEY, pendingRequest);
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        outState.putBoolean(PENDING_REQUEST_BUNDLE_KEY, pendingRequest);
+    }
+
+    private void onClickRequest() {
+        if (this.session.isOpened()) {
+            sendRequests();
+        } else {
+            StatusCallback callback = new StatusCallback() {
+                public void call(Session session, SessionState state, Exception exception) {
+                    if (exception != null) {
+                        new AlertDialog.Builder(GraphApiSampleActivity.this)
+                                .setTitle(R.string.login_failed_dialog_title)
+                                .setMessage(exception.getMessage())
+                                .setPositiveButton(R.string.ok_button, null)
+                                .show();
+                        GraphApiSampleActivity.this.session = createSession();
+                    }
+                }
+            };
+            pendingRequest = true;
+            this.session.openForRead(new Session.OpenRequest(this).setCallback(callback));
+        }
+    }
+
+    private void sendRequests() {
+        textViewResults.setText("");
+
+        String requestIdsText = editRequests.getText().toString();
+        String[] requestIds = requestIdsText.split(",");
+
+        List<Request> requests = new ArrayList<Request>();
+        for (final String requestId : requestIds) {
+            requests.add(new Request(session, requestId, null, null, new Request.Callback() {
+                public void onCompleted(Response response) {
+                    GraphObject graphObject = response.getGraphObject();
+                    FacebookRequestError error = response.getError();
+                    String s = textViewResults.getText().toString();
+                    if (graphObject != null) {
+                        if (graphObject.getProperty("id") != null) {
+                            s = s + String.format("%s: %s\n", graphObject.getProperty("id"), graphObject.getProperty(
+                                    "name"));
+                        } else {
+                            s = s + String.format("%s: <no such id>\n", requestId);
+                        }
+                    } else if (error != null) {
+                        s = s + String.format("Error: %s", error.getErrorMessage());
+                    }
+                    textViewResults.setText(s);
+                }
+            }));
+        }
+        pendingRequest = false;
+        Request.executeBatchAndWait(requests);
+    }
+
+    private Session createSession() {
+        Session activeSession = Session.getActiveSession();
+        if (activeSession == null || activeSession.getState().isClosed()) {
+            activeSession = new Session.Builder(this).setApplicationId(applicationId).build();
+            Session.setActiveSession(activeSession);
+        }
+        return activeSession;
+    }
+}
diff --git a/samples/Hackbook/.classpath b/samples/Hackbook/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/Hackbook/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/Hackbook/.project b/samples/Hackbook/.project
new file mode 100644
index 000000000..c453fce2f
--- /dev/null
+++ b/samples/Hackbook/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Hackbook</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/examples/Hackbook/AndroidManifest.xml b/samples/Hackbook/AndroidManifest.xml
similarity index 94%
rename from examples/Hackbook/AndroidManifest.xml
rename to samples/Hackbook/AndroidManifest.xml
index bc3ea853b..3d48e43b5 100644
--- a/examples/Hackbook/AndroidManifest.xml
+++ b/samples/Hackbook/AndroidManifest.xml
@@ -21,7 +21,8 @@
         </activity>
         <activity android:name=".Hackbook"
             android:label="@string/app_name"
-            android:configChanges="keyboardHidden|orientation">
+            android:configChanges="keyboardHidden|orientation"
+            android:windowSoftInputMode="adjustResize">
         </activity>
         <activity
             android:name=".GraphExplorer"
diff --git a/samples/Hackbook/Hackbook.eml b/samples/Hackbook/Hackbook.eml
new file mode 100644
index 000000000..4104d1ffc
--- /dev/null
+++ b/samples/Hackbook/Hackbook.eml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<component>
+	<exclude-output/>
+	<contentEntry url="file://$MODULE_DIR$"/>
+</component>
diff --git a/samples/Hackbook/Hackbook.iml b/samples/Hackbook/Hackbook.iml
new file mode 100644
index 000000000..b82318051
--- /dev/null
+++ b/samples/Hackbook/Hackbook.iml
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="EclipseModuleManager">
+    <conelement value="com.android.ide.eclipse.adt.LIBRARIES" />
+    <src_description expected_position="1">
+      <src_folder value="file://$MODULE_DIR$/src" expected_position="0" />
+      <src_folder value="file://$MODULE_DIR$/gen" expected_position="1" />
+    </src_description>
+  </component>
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+  </component>
+</module>
+
diff --git a/examples/Hackbook/README.md b/samples/Hackbook/README.md
similarity index 100%
rename from examples/Hackbook/README.md
rename to samples/Hackbook/README.md
diff --git a/examples/Hackbook/build.xml b/samples/Hackbook/build.xml
similarity index 100%
rename from examples/Hackbook/build.xml
rename to samples/Hackbook/build.xml
diff --git a/examples/Hackbook/default.properties b/samples/Hackbook/default.properties
similarity index 100%
rename from examples/Hackbook/default.properties
rename to samples/Hackbook/default.properties
diff --git a/samples/Hackbook/proguard-project.txt b/samples/Hackbook/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/Hackbook/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/examples/Hackbook/project.properties b/samples/Hackbook/project.properties
similarity index 100%
rename from examples/Hackbook/project.properties
rename to samples/Hackbook/project.properties
index 1998897e5..d97d486bd 100644
--- a/examples/Hackbook/project.properties
+++ b/samples/Hackbook/project.properties
@@ -12,6 +12,6 @@
 
 # Indicates whether an apk should be generated for each density.
 split.density=false
-android.library.reference.1=../../facebook
 # Project target.
 target=android-8
+android.library.reference.1=../../facebook
diff --git a/examples/Hackbook/res/drawable-hdpi/splash.png b/samples/Hackbook/res/drawable-hdpi/splash.png
similarity index 100%
rename from examples/Hackbook/res/drawable-hdpi/splash.png
rename to samples/Hackbook/res/drawable-hdpi/splash.png
diff --git a/examples/Hackbook/res/drawable/icon.png b/samples/Hackbook/res/drawable/icon.png
similarity index 100%
rename from examples/Hackbook/res/drawable/icon.png
rename to samples/Hackbook/res/drawable/icon.png
diff --git a/examples/Hackbook/res/drawable/icon_hack.png b/samples/Hackbook/res/drawable/icon_hack.png
similarity index 100%
rename from examples/Hackbook/res/drawable/icon_hack.png
rename to samples/Hackbook/res/drawable/icon_hack.png
diff --git a/examples/Hackbook/res/drawable/login.png b/samples/Hackbook/res/drawable/login.png
similarity index 100%
rename from examples/Hackbook/res/drawable/login.png
rename to samples/Hackbook/res/drawable/login.png
diff --git a/samples/Hackbook/res/drawable/login_button.xml b/samples/Hackbook/res/drawable/login_button.xml
new file mode 100644
index 000000000..fff9888c6
--- /dev/null
+++ b/samples/Hackbook/res/drawable/login_button.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+	<item android:state_pressed="true" android:drawable="@drawable/login_down" />
+	<item android:drawable="@drawable/login" /> <!-- default -->
+</selector>
diff --git a/examples/Hackbook/res/drawable/login_down.png b/samples/Hackbook/res/drawable/login_down.png
similarity index 100%
rename from examples/Hackbook/res/drawable/login_down.png
rename to samples/Hackbook/res/drawable/login_down.png
diff --git a/examples/Hackbook/res/drawable/logout.png b/samples/Hackbook/res/drawable/logout.png
similarity index 100%
rename from examples/Hackbook/res/drawable/logout.png
rename to samples/Hackbook/res/drawable/logout.png
diff --git a/samples/Hackbook/res/drawable/logout_button.xml b/samples/Hackbook/res/drawable/logout_button.xml
new file mode 100644
index 000000000..0c0c42eb0
--- /dev/null
+++ b/samples/Hackbook/res/drawable/logout_button.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_pressed="true" android:drawable="@drawable/logout_down" />
+    <item android:drawable="@drawable/logout" /> <!-- default -->
+</selector>
diff --git a/examples/Hackbook/res/drawable/logout_down.png b/samples/Hackbook/res/drawable/logout_down.png
similarity index 100%
rename from examples/Hackbook/res/drawable/logout_down.png
rename to samples/Hackbook/res/drawable/logout_down.png
diff --git a/examples/Hackbook/res/drawable/me.png b/samples/Hackbook/res/drawable/me.png
similarity index 100%
rename from examples/Hackbook/res/drawable/me.png
rename to samples/Hackbook/res/drawable/me.png
diff --git a/examples/Hackbook/res/drawable/splash.png b/samples/Hackbook/res/drawable/splash.png
similarity index 100%
rename from examples/Hackbook/res/drawable/splash.png
rename to samples/Hackbook/res/drawable/splash.png
diff --git a/examples/Hackbook/res/drawable/x.png b/samples/Hackbook/res/drawable/x.png
similarity index 100%
rename from examples/Hackbook/res/drawable/x.png
rename to samples/Hackbook/res/drawable/x.png
diff --git a/examples/Hackbook/res/layout-land/main.xml b/samples/Hackbook/res/layout-land/main.xml
similarity index 74%
rename from examples/Hackbook/res/layout-land/main.xml
rename to samples/Hackbook/res/layout-land/main.xml
index 2dc8e244a..a5431efb9 100644
--- a/examples/Hackbook/res/layout-land/main.xml
+++ b/samples/Hackbook/res/layout-land/main.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
diff --git a/examples/Hackbook/res/layout-port/main.xml b/samples/Hackbook/res/layout-port/main.xml
similarity index 74%
rename from examples/Hackbook/res/layout-port/main.xml
rename to samples/Hackbook/res/layout-port/main.xml
index 2dc8e244a..a5431efb9 100644
--- a/examples/Hackbook/res/layout-port/main.xml
+++ b/samples/Hackbook/res/layout-port/main.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
diff --git a/samples/Hackbook/res/layout/connection_item.xml b/samples/Hackbook/res/layout/connection_item.xml
new file mode 100644
index 000000000..2e0942d06
--- /dev/null
+++ b/samples/Hackbook/res/layout/connection_item.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="?android:attr/listPreferredItemHeight">
+    <TextView
+        android:id="@+id/connection_name"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:textSize="26sp"
+        android:textColor="@color/lite_blue"
+        android:paddingLeft="5dp" />
+</RelativeLayout>
diff --git a/examples/Hackbook/res/layout/fields_connections_list.xml b/samples/Hackbook/res/layout/fields_connections_list.xml
similarity index 76%
rename from examples/Hackbook/res/layout/fields_connections_list.xml
rename to samples/Hackbook/res/layout/fields_connections_list.xml
index 06b48f89e..56a30b868 100644
--- a/examples/Hackbook/res/layout/fields_connections_list.xml
+++ b/samples/Hackbook/res/layout/fields_connections_list.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
diff --git a/samples/Hackbook/res/layout/fields_item.xml b/samples/Hackbook/res/layout/fields_item.xml
new file mode 100644
index 000000000..0e6c6da11
--- /dev/null
+++ b/samples/Hackbook/res/layout/fields_item.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:background="@color/black">
+    <CheckBox
+        android:id="@+id/fields_checkbox"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content" />
+    <TextView
+        android:id="@+id/fields_info"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content" />
+</LinearLayout>
diff --git a/examples/Hackbook/res/layout/fql_query.xml b/samples/Hackbook/res/layout/fql_query.xml
similarity index 70%
rename from examples/Hackbook/res/layout/fql_query.xml
rename to samples/Hackbook/res/layout/fql_query.xml
index ddda019b2..925cd85cd 100644
--- a/examples/Hackbook/res/layout/fql_query.xml
+++ b/samples/Hackbook/res/layout/fql_query.xml
@@ -1,3 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout
     android:layout_width="fill_parent"
     android:layout_height="fill_parent"
diff --git a/examples/Hackbook/res/layout/friend_item.xml b/samples/Hackbook/res/layout/friend_item.xml
similarity index 68%
rename from examples/Hackbook/res/layout/friend_item.xml
rename to samples/Hackbook/res/layout/friend_item.xml
index c1c6728ed..08f167dfe 100644
--- a/examples/Hackbook/res/layout/friend_item.xml
+++ b/samples/Hackbook/res/layout/friend_item.xml
@@ -1,3 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="fill_parent"
     android:padding="6dip"
diff --git a/samples/Hackbook/res/layout/friends_list.xml b/samples/Hackbook/res/layout/friends_list.xml
new file mode 100644
index 000000000..c6bd45b2d
--- /dev/null
+++ b/samples/Hackbook/res/layout/friends_list.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:background="@color/black">
+    <ListView
+        android:id="@+id/friends_list"
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent" />
+ </LinearLayout>
diff --git a/examples/Hackbook/res/layout/graph_explorer.xml b/samples/Hackbook/res/layout/graph_explorer.xml
similarity index 87%
rename from examples/Hackbook/res/layout/graph_explorer.xml
rename to samples/Hackbook/res/layout/graph_explorer.xml
index a7ebee4fa..9269d45dc 100644
--- a/examples/Hackbook/res/layout/graph_explorer.xml
+++ b/samples/Hackbook/res/layout/graph_explorer.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
diff --git a/samples/Hackbook/res/layout/main_list_item.xml b/samples/Hackbook/res/layout/main_list_item.xml
new file mode 100644
index 000000000..eefb54494
--- /dev/null
+++ b/samples/Hackbook/res/layout/main_list_item.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<TextView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/main_api_item"
+    android:padding="10dip"
+    android:layout_width="fill_parent"
+    android:layout_height="wrap_content"
+    android:layout_alignParentRight="true"
+    android:layout_alignParentTop="true"
+    android:gravity="center_vertical"
+    android:textSize="20sp" />
diff --git a/samples/Hackbook/res/layout/permission_item.xml b/samples/Hackbook/res/layout/permission_item.xml
new file mode 100644
index 000000000..8acabe5dd
--- /dev/null
+++ b/samples/Hackbook/res/layout/permission_item.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="?android:attr/listPreferredItemHeight">
+    <CheckBox
+        android:id="@+id/permission_checkbox"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content" />
+</RelativeLayout>
diff --git a/examples/Hackbook/res/layout/permissions_list.xml b/samples/Hackbook/res/layout/permissions_list.xml
similarity index 80%
rename from examples/Hackbook/res/layout/permissions_list.xml
rename to samples/Hackbook/res/layout/permissions_list.xml
index f5592c5ae..f8aafe41f 100644
--- a/examples/Hackbook/res/layout/permissions_list.xml
+++ b/samples/Hackbook/res/layout/permissions_list.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
diff --git a/examples/Hackbook/res/layout/place_item.xml b/samples/Hackbook/res/layout/place_item.xml
similarity index 61%
rename from examples/Hackbook/res/layout/place_item.xml
rename to samples/Hackbook/res/layout/place_item.xml
index cbc139e42..ff89942e1 100644
--- a/examples/Hackbook/res/layout/place_item.xml
+++ b/samples/Hackbook/res/layout/place_item.xml
@@ -1,3 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="fill_parent"
     android:padding="6dip"
diff --git a/samples/Hackbook/res/layout/places_list.xml b/samples/Hackbook/res/layout/places_list.xml
new file mode 100644
index 000000000..578774425
--- /dev/null
+++ b/samples/Hackbook/res/layout/places_list.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:background="@color/black">
+    <ListView
+        android:id="@+id/places_list"
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent" />
+ </LinearLayout>
diff --git a/samples/Hackbook/res/layout/splash.xml b/samples/Hackbook/res/layout/splash.xml
new file mode 100644
index 000000000..21f1e2dae
--- /dev/null
+++ b/samples/Hackbook/res/layout/splash.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<ImageView android:id="@+id/imageView1" xmlns:android="http://schemas.android.com/apk/res/android"
+    android:src="@drawable/splash"
+    android:scaleType="fitXY"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent" />
diff --git a/examples/Hackbook/res/layout/token_refresh.xml b/samples/Hackbook/res/layout/token_refresh.xml
similarity index 80%
rename from examples/Hackbook/res/layout/token_refresh.xml
rename to samples/Hackbook/res/layout/token_refresh.xml
index 811cd598a..d3b662e93 100644
--- a/examples/Hackbook/res/layout/token_refresh.xml
+++ b/samples/Hackbook/res/layout/token_refresh.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
diff --git a/examples/Hackbook/res/layout/update_post_response.xml b/samples/Hackbook/res/layout/update_post_response.xml
similarity index 80%
rename from examples/Hackbook/res/layout/update_post_response.xml
rename to samples/Hackbook/res/layout/update_post_response.xml
index 2a0bd90a6..34460d7d7 100644
--- a/examples/Hackbook/res/layout/update_post_response.xml
+++ b/samples/Hackbook/res/layout/update_post_response.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
diff --git a/examples/Hackbook/res/layout/upload_photo_response.xml b/samples/Hackbook/res/layout/upload_photo_response.xml
similarity index 81%
rename from examples/Hackbook/res/layout/upload_photo_response.xml
rename to samples/Hackbook/res/layout/upload_photo_response.xml
index 3b8bd7743..49af55d85 100644
--- a/examples/Hackbook/res/layout/upload_photo_response.xml
+++ b/samples/Hackbook/res/layout/upload_photo_response.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
diff --git a/samples/Hackbook/res/values/colors.xml b/samples/Hackbook/res/values/colors.xml
new file mode 100644
index 000000000..095921db0
--- /dev/null
+++ b/samples/Hackbook/res/values/colors.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<resources>
+    <color name="white">#ffffff</color>
+    <color name="black">#000000</color>
+    <color name="green">#23cf34</color>
+    <color name="orange">#E47833</color>
+    <color name="lite_blue">#4E78A0</color>
+    <color name="blue">#0000FF</color>
+    <color name="grey">#FF909090</color>
+</resources>
diff --git a/examples/Hackbook/res/values/strings.xml b/samples/Hackbook/res/values/strings.xml
similarity index 89%
rename from examples/Hackbook/res/values/strings.xml
rename to samples/Hackbook/res/values/strings.xml
index a2aeda13e..73d278723 100644
--- a/examples/Hackbook/res/values/strings.xml
+++ b/samples/Hackbook/res/values/strings.xml
@@ -1,7 +1,23 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <string name="app_name">Hackbook for Android</string>
-    <string name="app_desc">Checkout out Hackbook for Android to learn how you can make your android apps social using Facebook Platform.</string>
+    <string name="app_desc">Check out Hackbook for Android to learn how you can make your android apps social using Facebook Platform.</string>
     <string name="app_action">I am using the Hackbook for Android</string>
     <string name="request_message">Learn how to make your android apps social.</string>
     <string name="request">Request!</string>
diff --git a/samples/Hackbook/src/com/facebook/android/BaseDialogListener.java b/samples/Hackbook/src/com/facebook/android/BaseDialogListener.java
new file mode 100644
index 000000000..62f039148
--- /dev/null
+++ b/samples/Hackbook/src/com/facebook/android/BaseDialogListener.java
@@ -0,0 +1,41 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.android;
+
+import com.facebook.android.Facebook.DialogListener;
+
+/**
+ * Skeleton base class for RequestListeners, providing default error handling.
+ * Applications should handle these error conditions.
+ */
+public abstract class BaseDialogListener implements DialogListener {
+
+    @Override
+    public void onFacebookError(FacebookError e) {
+        e.printStackTrace();
+    }
+
+    @Override
+    public void onError(DialogError e) {
+        e.printStackTrace();
+    }
+
+    @Override
+    public void onCancel() {
+    }
+
+}
\ No newline at end of file
diff --git a/examples/Hackbook/src/com/facebook/android/BaseRequestListener.java b/samples/Hackbook/src/com/facebook/android/BaseRequestListener.java
similarity index 64%
rename from examples/Hackbook/src/com/facebook/android/BaseRequestListener.java
rename to samples/Hackbook/src/com/facebook/android/BaseRequestListener.java
index 0e7809f07..474470e41 100644
--- a/examples/Hackbook/src/com/facebook/android/BaseRequestListener.java
+++ b/samples/Hackbook/src/com/facebook/android/BaseRequestListener.java
@@ -1,17 +1,33 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android;
 
+import android.util.Log;
+import com.facebook.android.AsyncFacebookRunner.RequestListener;
+
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.net.MalformedURLException;
 
-import android.util.Log;
-
-import com.facebook.android.AsyncFacebookRunner.RequestListener;
-
 /**
  * Skeleton base class for RequestListeners, providing default error handling.
  * Applications should handle these error conditions.
  */
+@SuppressWarnings("deprecation")
 public abstract class BaseRequestListener implements RequestListener {
 
     @Override
diff --git a/examples/Hackbook/src/com/facebook/android/FQLQuery.java b/samples/Hackbook/src/com/facebook/android/FQLQuery.java
similarity index 86%
rename from examples/Hackbook/src/com/facebook/android/FQLQuery.java
rename to samples/Hackbook/src/com/facebook/android/FQLQuery.java
index 1c2e92b3c..33b469b87 100644
--- a/examples/Hackbook/src/com/facebook/android/FQLQuery.java
+++ b/samples/Hackbook/src/com/facebook/android/FQLQuery.java
@@ -1,8 +1,20 @@
-package com.facebook.android;
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
+package com.facebook.android;
 
 import android.app.Activity;
 import android.app.Dialog;
@@ -16,7 +28,11 @@
 import android.widget.Button;
 import android.widget.EditText;
 import android.widget.TextView;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
 
+@SuppressWarnings("deprecation")
 public class FQLQuery extends Dialog {
 
     private EditText mFQLQuery;
diff --git a/examples/Hackbook/src/com/facebook/android/FieldsConnectionsDialog.java b/samples/Hackbook/src/com/facebook/android/FieldsConnectionsDialog.java
similarity index 94%
rename from examples/Hackbook/src/com/facebook/android/FieldsConnectionsDialog.java
rename to samples/Hackbook/src/com/facebook/android/FieldsConnectionsDialog.java
index 9308301d4..ad6b44880 100644
--- a/examples/Hackbook/src/com/facebook/android/FieldsConnectionsDialog.java
+++ b/samples/Hackbook/src/com/facebook/android/FieldsConnectionsDialog.java
@@ -1,13 +1,20 @@
-package com.facebook.android;
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Vector;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
+package com.facebook.android;
 
 import android.app.Dialog;
 import android.os.Bundle;
@@ -17,19 +24,18 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewGroup.LayoutParams;
-import android.widget.AdapterView;
+import android.widget.*;
 import android.widget.AdapterView.OnItemClickListener;
-import android.widget.ArrayAdapter;
-import android.widget.BaseAdapter;
-import android.widget.Button;
-import android.widget.CheckBox;
-import android.widget.CompoundButton;
 import android.widget.CompoundButton.OnCheckedChangeListener;
-import android.widget.ListView;
-import android.widget.TabHost;
 import android.widget.TabHost.TabSpec;
-import android.widget.TextView;
-import android.widget.Toast;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Vector;
 
 public class FieldsConnectionsDialog extends Dialog {
 
diff --git a/examples/Hackbook/src/com/facebook/android/FriendsGetProfilePics.java b/samples/Hackbook/src/com/facebook/android/FriendsGetProfilePics.java
similarity index 83%
rename from examples/Hackbook/src/com/facebook/android/FriendsGetProfilePics.java
rename to samples/Hackbook/src/com/facebook/android/FriendsGetProfilePics.java
index b2bbd046c..6e50a5191 100644
--- a/examples/Hackbook/src/com/facebook/android/FriendsGetProfilePics.java
+++ b/samples/Hackbook/src/com/facebook/android/FriendsGetProfilePics.java
@@ -1,12 +1,28 @@
-package com.facebook.android;
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
-import java.util.Hashtable;
-import java.util.Stack;
+package com.facebook.android;
 
 import android.graphics.Bitmap;
 import android.os.AsyncTask;
 import android.widget.BaseAdapter;
 
+import java.util.Hashtable;
+import java.util.Stack;
+
 /*
  * Fetch friends profile pictures request via AsyncTask
  */
diff --git a/examples/Hackbook/src/com/facebook/android/FriendsList.java b/samples/Hackbook/src/com/facebook/android/FriendsList.java
similarity index 92%
rename from examples/Hackbook/src/com/facebook/android/FriendsList.java
rename to samples/Hackbook/src/com/facebook/android/FriendsList.java
index 3c8d871eb..9ad8db031 100644
--- a/examples/Hackbook/src/com/facebook/android/FriendsList.java
+++ b/samples/Hackbook/src/com/facebook/android/FriendsList.java
@@ -1,8 +1,20 @@
-package com.facebook.android;
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
+package com.facebook.android;
 
 import android.app.Activity;
 import android.app.AlertDialog;
@@ -12,13 +24,11 @@
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.AdapterView;
+import android.widget.*;
 import android.widget.AdapterView.OnItemClickListener;
-import android.widget.BaseAdapter;
-import android.widget.ImageView;
-import android.widget.ListView;
-import android.widget.TextView;
-import android.widget.Toast;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
 
 public class FriendsList extends Activity implements OnItemClickListener {
     private Handler mHandler;
@@ -62,6 +72,7 @@ public void onCreate(Bundle savedInstanceState) {
      * wall.
      */
     @Override
+    @SuppressWarnings("deprecation")
     public void onItemClick(AdapterView<?> arg0, View v, int position, long arg3) {
         try {
             final long friendId;
@@ -161,7 +172,6 @@ public View getView(int position, View convertView, ViewGroup parent) {
             try {
                 jsonObject = jsonArray.getJSONObject(position);
             } catch (JSONException e1) {
-                // TODO Auto-generated catch block
                 e1.printStackTrace();
             }
             View hView = convertView;
diff --git a/examples/Hackbook/src/com/facebook/android/GraphExplorer.java b/samples/Hackbook/src/com/facebook/android/GraphExplorer.java
similarity index 95%
rename from examples/Hackbook/src/com/facebook/android/GraphExplorer.java
rename to samples/Hackbook/src/com/facebook/android/GraphExplorer.java
index 094ab738d..0ca605f5e 100644
--- a/examples/Hackbook/src/com/facebook/android/GraphExplorer.java
+++ b/samples/Hackbook/src/com/facebook/android/GraphExplorer.java
@@ -1,17 +1,25 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android;
 
 /*
  * The me, delete and back_parent buttons are downloaded from http://icongal.com/
  */
 
-import java.util.Iterator;
-import java.util.Vector;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
 import android.app.Activity;
 import android.app.ProgressDialog;
 import android.content.Context;
@@ -25,12 +33,16 @@
 import android.view.View;
 import android.view.View.OnClickListener;
 import android.view.inputmethod.InputMethodManager;
-import android.widget.Button;
-import android.widget.EditText;
-import android.widget.ScrollView;
-import android.widget.TextView;
-import android.widget.Toast;
+import android.widget.*;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.Iterator;
+import java.util.Vector;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
+@SuppressWarnings("deprecation")
 public class GraphExplorer extends Activity {
     private Button mSubmitButton, mViewURLButton;
     private Button mGetPermissionsButton;
diff --git a/examples/Hackbook/src/com/facebook/android/Hackbook.java b/samples/Hackbook/src/com/facebook/android/Hackbook.java
similarity index 98%
rename from examples/Hackbook/src/com/facebook/android/Hackbook.java
rename to samples/Hackbook/src/com/facebook/android/Hackbook.java
index 7b9b4e3d4..816a10aa7 100644
--- a/examples/Hackbook/src/com/facebook/android/Hackbook.java
+++ b/samples/Hackbook/src/com/facebook/android/Hackbook.java
@@ -1,5 +1,5 @@
-/*
- * Copyright 2004 - Present Facebook, Inc.
+/**
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,11 +16,6 @@
 
 package com.facebook.android;
 
-import java.io.IOException;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.app.ProgressDialog;
@@ -33,18 +28,16 @@
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.AdapterView;
+import android.widget.*;
 import android.widget.AdapterView.OnItemClickListener;
-import android.widget.ArrayAdapter;
-import android.widget.BaseAdapter;
-import android.widget.ImageView;
-import android.widget.ListView;
-import android.widget.TextView;
-import android.widget.Toast;
-
 import com.facebook.android.SessionEvents.AuthListener;
 import com.facebook.android.SessionEvents.LogoutListener;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
 
+@SuppressWarnings("deprecation")
 public class Hackbook extends Activity implements OnItemClickListener {
 
     /*
@@ -510,7 +503,8 @@ public void onComplete(final String response, final Object state) {
             try {
                 jsonObject = new JSONObject(response);
 
-                final String picURL = jsonObject.getString("picture");
+                final String picURL = jsonObject.getJSONObject("picture")
+                        .getJSONObject("data").getString("url");
                 final String name = jsonObject.getString("name");
                 Utility.userUID = jsonObject.getString("id");
 
@@ -523,7 +517,6 @@ public void run() {
                 });
 
             } catch (JSONException e) {
-                // TODO Auto-generated catch block
                 e.printStackTrace();
             }
         }
diff --git a/examples/Hackbook/src/com/facebook/android/IntentUriHandler.java b/samples/Hackbook/src/com/facebook/android/IntentUriHandler.java
similarity index 62%
rename from examples/Hackbook/src/com/facebook/android/IntentUriHandler.java
rename to samples/Hackbook/src/com/facebook/android/IntentUriHandler.java
index ac55c2136..6b1601108 100644
--- a/examples/Hackbook/src/com/facebook/android/IntentUriHandler.java
+++ b/samples/Hackbook/src/com/facebook/android/IntentUriHandler.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android;
 
 import android.app.Activity;
diff --git a/examples/Hackbook/src/com/facebook/android/LoginButton.java b/samples/Hackbook/src/com/facebook/android/LoginButton.java
similarity index 98%
rename from examples/Hackbook/src/com/facebook/android/LoginButton.java
rename to samples/Hackbook/src/com/facebook/android/LoginButton.java
index ae9b6bedb..30189b88c 100644
--- a/examples/Hackbook/src/com/facebook/android/LoginButton.java
+++ b/samples/Hackbook/src/com/facebook/android/LoginButton.java
@@ -1,5 +1,5 @@
-/*
- * Copyright 2010 Facebook, Inc.
+/**
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -24,11 +24,11 @@
 import android.util.AttributeSet;
 import android.view.View;
 import android.widget.ImageButton;
-
 import com.facebook.android.Facebook.DialogListener;
 import com.facebook.android.SessionEvents.AuthListener;
 import com.facebook.android.SessionEvents.LogoutListener;
 
+@SuppressWarnings("deprecation")
 public class LoginButton extends ImageButton {
 
     private Facebook mFb;
diff --git a/examples/Hackbook/src/com/facebook/android/PermissionsDialog.java b/samples/Hackbook/src/com/facebook/android/PermissionsDialog.java
similarity index 93%
rename from examples/Hackbook/src/com/facebook/android/PermissionsDialog.java
rename to samples/Hackbook/src/com/facebook/android/PermissionsDialog.java
index fa4edbbd8..4e4d4dc3e 100644
--- a/examples/Hackbook/src/com/facebook/android/PermissionsDialog.java
+++ b/samples/Hackbook/src/com/facebook/android/PermissionsDialog.java
@@ -1,6 +1,20 @@
-package com.facebook.android;
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
-import java.util.Vector;
+package com.facebook.android;
 
 import android.app.Activity;
 import android.app.Dialog;
@@ -11,19 +25,14 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewGroup.LayoutParams;
-import android.widget.BaseAdapter;
-import android.widget.Button;
-import android.widget.CheckBox;
-import android.widget.CompoundButton;
+import android.widget.*;
 import android.widget.CompoundButton.OnCheckedChangeListener;
-import android.widget.ListView;
-import android.widget.TabHost;
 import android.widget.TabHost.TabSpec;
-import android.widget.TextView;
-import android.widget.Toast;
-
 import com.facebook.android.Facebook.DialogListener;
 
+import java.util.Vector;
+
+@SuppressWarnings("deprecation")
 public class PermissionsDialog extends Dialog {
 
     private final static int TAB_HEIGHT = 50;
diff --git a/examples/Hackbook/src/com/facebook/android/Places.java b/samples/Hackbook/src/com/facebook/android/Places.java
similarity index 95%
rename from examples/Hackbook/src/com/facebook/android/Places.java
rename to samples/Hackbook/src/com/facebook/android/Places.java
index 4d5e42a4c..43dbca4bd 100644
--- a/examples/Hackbook/src/com/facebook/android/Places.java
+++ b/samples/Hackbook/src/com/facebook/android/Places.java
@@ -1,8 +1,20 @@
-package com.facebook.android;
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
+package com.facebook.android;
 
 import android.app.Activity;
 import android.app.AlertDialog;
@@ -21,13 +33,13 @@
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.AdapterView;
+import android.widget.*;
 import android.widget.AdapterView.OnItemClickListener;
-import android.widget.BaseAdapter;
-import android.widget.ListView;
-import android.widget.TextView;
-import android.widget.Toast;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
 
+@SuppressWarnings("deprecation")
 public class Places extends Activity implements OnItemClickListener {
     private Handler mHandler;
     private JSONObject location;
@@ -294,7 +306,6 @@ public View getView(int position, View convertView, ViewGroup parent) {
             try {
                 jsonObject = jsonArray.getJSONObject(position);
             } catch (JSONException e1) {
-                // TODO Auto-generated catch block
                 e1.printStackTrace();
             }
             View hView = convertView;
diff --git a/examples/Hackbook/src/com/facebook/android/SessionEvents.java b/samples/Hackbook/src/com/facebook/android/SessionEvents.java
similarity index 99%
rename from examples/Hackbook/src/com/facebook/android/SessionEvents.java
rename to samples/Hackbook/src/com/facebook/android/SessionEvents.java
index f32a11e07..55295f174 100644
--- a/examples/Hackbook/src/com/facebook/android/SessionEvents.java
+++ b/samples/Hackbook/src/com/facebook/android/SessionEvents.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2010 Facebook, Inc.
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
diff --git a/examples/Hackbook/src/com/facebook/android/SessionStore.java b/samples/Hackbook/src/com/facebook/android/SessionStore.java
similarity index 82%
rename from examples/Hackbook/src/com/facebook/android/SessionStore.java
rename to samples/Hackbook/src/com/facebook/android/SessionStore.java
index 1b97a53a6..8e4dcda58 100644
--- a/examples/Hackbook/src/com/facebook/android/SessionStore.java
+++ b/samples/Hackbook/src/com/facebook/android/SessionStore.java
@@ -1,5 +1,5 @@
-/*
- * Copyright 2010 Facebook, Inc.
+/**
+ * Copyright 2010-present Facebook
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,21 +20,23 @@
 import android.content.SharedPreferences;
 import android.content.SharedPreferences.Editor;
 
+@SuppressWarnings("deprecation")
 public class SessionStore {
 
     private static final String TOKEN = "access_token";
     private static final String EXPIRES = "expires_in";
+    private static final String LAST_UPDATE = "last_update";
     private static final String KEY = "facebook-session";
 
     /*
      * Save the access token and expiry date so you don't have to fetch it each
      * time
      */
-
     public static boolean save(Facebook session, Context context) {
         Editor editor = context.getSharedPreferences(KEY, Context.MODE_PRIVATE).edit();
         editor.putString(TOKEN, session.getAccessToken());
         editor.putLong(EXPIRES, session.getAccessExpires());
+        editor.putLong(LAST_UPDATE, session.getLastAccessUpdate());
         return editor.commit();
     }
 
@@ -43,8 +45,10 @@ public static boolean save(Facebook session, Context context) {
      */
     public static boolean restore(Facebook session, Context context) {
         SharedPreferences savedSession = context.getSharedPreferences(KEY, Context.MODE_PRIVATE);
-        session.setAccessToken(savedSession.getString(TOKEN, null));
-        session.setAccessExpires(savedSession.getLong(EXPIRES, 0));
+        session.setTokenFromCache(
+                savedSession.getString(TOKEN, null),
+                savedSession.getLong(EXPIRES, 0),
+                savedSession.getLong(LAST_UPDATE, 0));
         return session.isSessionValid();
     }
 
diff --git a/examples/Hackbook/src/com/facebook/android/SplashActivity.java b/samples/Hackbook/src/com/facebook/android/SplashActivity.java
similarity index 57%
rename from examples/Hackbook/src/com/facebook/android/SplashActivity.java
rename to samples/Hackbook/src/com/facebook/android/SplashActivity.java
index d288acba7..7255c0fce 100644
--- a/examples/Hackbook/src/com/facebook/android/SplashActivity.java
+++ b/samples/Hackbook/src/com/facebook/android/SplashActivity.java
@@ -1,12 +1,28 @@
-package com.facebook.android;
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
-import java.util.Timer;
-import java.util.TimerTask;
+package com.facebook.android;
 
 import android.app.Activity;
 import android.content.Intent;
 import android.os.Bundle;
 
+import java.util.Timer;
+import java.util.TimerTask;
+
 public class SplashActivity extends Activity {
     private long splashDelay = 1500;
 
diff --git a/examples/Hackbook/src/com/facebook/android/TokenRefreshDialog.java b/samples/Hackbook/src/com/facebook/android/TokenRefreshDialog.java
similarity index 84%
rename from examples/Hackbook/src/com/facebook/android/TokenRefreshDialog.java
rename to samples/Hackbook/src/com/facebook/android/TokenRefreshDialog.java
index aeb147b15..5a46dec71 100644
--- a/examples/Hackbook/src/com/facebook/android/TokenRefreshDialog.java
+++ b/samples/Hackbook/src/com/facebook/android/TokenRefreshDialog.java
@@ -1,7 +1,20 @@
-package com.facebook.android;
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
-import java.text.DateFormat;
-import java.util.Date;
+package com.facebook.android;
 
 import android.app.Activity;
 import android.app.Dialog;
@@ -12,6 +25,10 @@
 import android.widget.EditText;
 import android.widget.TextView;
 
+import java.text.DateFormat;
+import java.util.Date;
+
+@SuppressWarnings("deprecation")
 public class TokenRefreshDialog extends Dialog {
 
     private EditText tokenEdit, tokenExpiresEdit;
diff --git a/examples/Hackbook/src/com/facebook/android/UpdateStatusResultDialog.java b/samples/Hackbook/src/com/facebook/android/UpdateStatusResultDialog.java
similarity index 86%
rename from examples/Hackbook/src/com/facebook/android/UpdateStatusResultDialog.java
rename to samples/Hackbook/src/com/facebook/android/UpdateStatusResultDialog.java
index 463b42535..1bb9e6137 100644
--- a/examples/Hackbook/src/com/facebook/android/UpdateStatusResultDialog.java
+++ b/samples/Hackbook/src/com/facebook/android/UpdateStatusResultDialog.java
@@ -1,7 +1,20 @@
-package com.facebook.android;
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
-import org.json.JSONException;
-import org.json.JSONObject;
+package com.facebook.android;
 
 import android.app.Activity;
 import android.app.Dialog;
@@ -12,7 +25,10 @@
 import android.view.ViewGroup.LayoutParams;
 import android.widget.Button;
 import android.widget.TextView;
+import org.json.JSONException;
+import org.json.JSONObject;
 
+@SuppressWarnings("deprecation")
 public class UpdateStatusResultDialog extends Dialog {
 
     private Bundle values;
diff --git a/examples/Hackbook/src/com/facebook/android/UploadPhotoResultDialog.java b/samples/Hackbook/src/com/facebook/android/UploadPhotoResultDialog.java
similarity index 91%
rename from examples/Hackbook/src/com/facebook/android/UploadPhotoResultDialog.java
rename to samples/Hackbook/src/com/facebook/android/UploadPhotoResultDialog.java
index 173aae343..7ec3c5e21 100644
--- a/examples/Hackbook/src/com/facebook/android/UploadPhotoResultDialog.java
+++ b/samples/Hackbook/src/com/facebook/android/UploadPhotoResultDialog.java
@@ -1,7 +1,20 @@
-package com.facebook.android;
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
-import org.json.JSONException;
-import org.json.JSONObject;
+package com.facebook.android;
 
 import android.app.Activity;
 import android.app.Dialog;
@@ -17,7 +30,10 @@
 import android.widget.Button;
 import android.widget.ImageView;
 import android.widget.TextView;
+import org.json.JSONException;
+import org.json.JSONObject;
 
+@SuppressWarnings("deprecation")
 public class UploadPhotoResultDialog extends Dialog {
 
     private String response, photo_id;
diff --git a/examples/Hackbook/src/com/facebook/android/Utility.java b/samples/Hackbook/src/com/facebook/android/Utility.java
similarity index 87%
rename from examples/Hackbook/src/com/facebook/android/Utility.java
rename to samples/Hackbook/src/com/facebook/android/Utility.java
index 8f13d2379..251a77419 100644
--- a/examples/Hackbook/src/com/facebook/android/Utility.java
+++ b/samples/Hackbook/src/com/facebook/android/Utility.java
@@ -1,15 +1,20 @@
-package com.facebook.android;
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
-import java.io.BufferedInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.FilterInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URL;
-import java.net.URLConnection;
-import java.util.Hashtable;
-
-import org.json.JSONObject;
+package com.facebook.android;
 
 import android.app.Application;
 import android.content.Context;
@@ -20,10 +25,17 @@
 import android.net.Uri;
 import android.net.http.AndroidHttpClient;
 import android.provider.MediaStore;
+import org.json.JSONObject;
+
+import java.io.*;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.Hashtable;
 
 public class Utility extends Application {
 
     public static Facebook mFacebook;
+    @SuppressWarnings("deprecation")
     public static AsyncFacebookRunner mAsyncRunner;
     public static JSONObject mFriendsList;
     public static String userUID = null;
@@ -148,6 +160,9 @@ public static int getOrientation(Context context, Uri photoUri) {
         }
 
         cursor.moveToFirst();
-        return cursor.getInt(0);
+        int orientation = cursor.getInt(0);
+        cursor.close();
+
+        return orientation;
     }
 }
diff --git a/samples/HelloFacebookSample/.classpath b/samples/HelloFacebookSample/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/HelloFacebookSample/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/HelloFacebookSample/.project b/samples/HelloFacebookSample/.project
new file mode 100644
index 000000000..cb52d544b
--- /dev/null
+++ b/samples/HelloFacebookSample/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>HelloFacebookSample</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/samples/HelloFacebookSample/AndroidManifest.xml b/samples/HelloFacebookSample/AndroidManifest.xml
new file mode 100644
index 000000000..246d0de24
--- /dev/null
+++ b/samples/HelloFacebookSample/AndroidManifest.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.facebook.samples.hellofacebook"
+          android:versionCode="1"
+          android:versionName="1.0">
+    <uses-sdk android:minSdkVersion="8"/>
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+    <application android:label="@string/app_name"
+                 android:icon="@drawable/icon"
+                 android:theme="@android:style/Theme.NoTitleBar"
+            >
+        <activity android:name=".HelloFacebookSampleActivity"
+                  android:label="@string/app_name"
+                  android:windowSoftInputMode="adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+        <activity android:name="com.facebook.LoginActivity"
+                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
+                  android:label="@string/app_name" />
+        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
+    </application>
+</manifest>
diff --git a/samples/HelloFacebookSample/HelloFacebookSample.iml b/samples/HelloFacebookSample/HelloFacebookSample.iml
new file mode 100644
index 000000000..4aac86509
--- /dev/null
+++ b/samples/HelloFacebookSample/HelloFacebookSample.iml
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/samples/HelloFacebookSample/ant.properties b/samples/HelloFacebookSample/ant.properties
new file mode 100644
index 000000000..939105d52
--- /dev/null
+++ b/samples/HelloFacebookSample/ant.properties
@@ -0,0 +1,18 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
+java.compilerargs=-Xlint -Werror
diff --git a/samples/HelloFacebookSample/build.xml b/samples/HelloFacebookSample/build.xml
new file mode 100644
index 000000000..3c65e4a79
--- /dev/null
+++ b/samples/HelloFacebookSample/build.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="HelloFacebookSample" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties"/>
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties"/>
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env"/>
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME"/>
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties"/>
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+            />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true"/>
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml"/>
+
+</project>
diff --git a/samples/HelloFacebookSample/proguard-project.txt b/samples/HelloFacebookSample/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/HelloFacebookSample/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/samples/HelloFacebookSample/project.properties b/samples/HelloFacebookSample/project.properties
new file mode 100644
index 000000000..cee0509c6
--- /dev/null
+++ b/samples/HelloFacebookSample/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+android.library.reference.1=../../facebook
diff --git a/samples/HelloFacebookSample/res/drawable-hdpi/icon.png b/samples/HelloFacebookSample/res/drawable-hdpi/icon.png
new file mode 100644
index 000000000..e603120e1
Binary files /dev/null and b/samples/HelloFacebookSample/res/drawable-hdpi/icon.png differ
diff --git a/samples/HelloFacebookSample/res/drawable-mdpi/icon.png b/samples/HelloFacebookSample/res/drawable-mdpi/icon.png
new file mode 100644
index 000000000..f2fc84fb6
Binary files /dev/null and b/samples/HelloFacebookSample/res/drawable-mdpi/icon.png differ
diff --git a/samples/HelloFacebookSample/res/drawable-xhdpi/icon.png b/samples/HelloFacebookSample/res/drawable-xhdpi/icon.png
new file mode 100644
index 000000000..143a69f21
Binary files /dev/null and b/samples/HelloFacebookSample/res/drawable-xhdpi/icon.png differ
diff --git a/samples/HelloFacebookSample/res/drawable/icon.png b/samples/HelloFacebookSample/res/drawable/icon.png
new file mode 100644
index 000000000..f2fc84fb6
Binary files /dev/null and b/samples/HelloFacebookSample/res/drawable/icon.png differ
diff --git a/samples/HelloFacebookSample/res/layout/main.xml b/samples/HelloFacebookSample/res/layout/main.xml
new file mode 100644
index 000000000..f326848b2
--- /dev/null
+++ b/samples/HelloFacebookSample/res/layout/main.xml
@@ -0,0 +1,91 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              xmlns:facebook="http://schemas.android.com/apk/res-auto"
+              android:orientation="vertical"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+              android:background="#FFF"
+        >
+    <LinearLayout android:orientation="vertical"
+                  android:layout_width="fill_parent"
+                  android:layout_height="fill_parent"
+                  android:background="#FFF"
+                  android:id="@+id/main_ui_container">
+        <com.facebook.widget.LoginButton
+                android:id="@+id/login_button"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="5dp"
+                facebook:confirm_logout="false"
+                facebook:fetch_user_info="true"
+                />
+        <LinearLayout
+                android:layout_width="150dp"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:gravity="center_horizontal"
+                android:orientation="vertical">
+            <TextView
+                    android:id="@+id/greeting"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_marginLeft="10dp"
+                    android:layout_gravity="center"
+                    android:textColor="#333"
+                    android:textSize="18sp"/>
+            <com.facebook.widget.ProfilePictureView
+                    android:id="@+id/profilePicture"
+                    android:layout_height="wrap_content"
+                    android:layout_width="wrap_content"
+                    android:gravity="center_horizontal"
+                    android:layout_marginBottom="10dp"
+                    facebook:preset_size="normal"/>
+            <Button
+                    android:id="@+id/postStatusUpdateButton"
+                    android:layout_width="fill_parent"
+                    android:layout_height="wrap_content"
+                    android:text="Post Status Update"
+                    />
+            <Button
+                    android:id="@+id/postPhotoButton"
+                    android:layout_width="fill_parent"
+                    android:layout_height="wrap_content"
+                    android:text="Post Photo"
+                    />
+            <Button
+                    android:id="@+id/pickFriendsButton"
+                    android:layout_width="fill_parent"
+                    android:layout_height="wrap_content"
+                    android:text="Pick Some Friends"
+                    />
+            <Button
+                    android:id="@+id/pickPlaceButton"
+                    android:layout_width="fill_parent"
+                    android:layout_height="wrap_content"
+                    android:text="Pick Place"
+                    />
+        </LinearLayout>
+    </LinearLayout>
+    <FrameLayout
+            android:id="@+id/fragment_container"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"/>
+
+</LinearLayout>
+
diff --git a/samples/HelloFacebookSample/res/values/strings.xml b/samples/HelloFacebookSample/res/values/strings.xml
new file mode 100644
index 000000000..c55cdb9d1
--- /dev/null
+++ b/samples/HelloFacebookSample/res/values/strings.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<resources>
+    <string name="app_name">HelloFacebookSample</string>
+    <string name="cancelled">Cancelled</string>
+    <string name="permission_not_granted">Unable to perform selected action because permissions were not granted.</string>
+    <string name="ok">OK</string>
+    <string name="hello_user">Hello %1$s!</string>
+    <string name="success">Success</string>
+    <string name="successfully_posted_post">Successfully posted \'%1$s\'.\nPost ID: %2$s</string>
+    <string name="error">Error</string>
+    <string name="status_update">Updating status for %1$s at %2$s</string>
+    <string name="photo_post">Photo Post</string>
+    <string name="you_picked">You picked:</string>
+    <string name="no_friends_selected">&lt;No friends selected&gt;</string>
+    <string name="no_place_selected">&lt;No place selected&gt;</string>
+    <string name="pick_seattle_place">Pick a Seattle Place</string>
+    <string name="app_id">355198514515820</string>
+</resources>
diff --git a/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookSampleActivity.java b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookSampleActivity.java
new file mode 100644
index 000000000..52be10092
--- /dev/null
+++ b/samples/HelloFacebookSample/src/com/facebook/samples/hellofacebook/HelloFacebookSampleActivity.java
@@ -0,0 +1,437 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.hellofacebook;
+
+import android.app.AlertDialog;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.location.Location;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+import android.text.TextUtils;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.TextView;
+import com.facebook.*;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphPlace;
+import com.facebook.model.GraphUser;
+import com.facebook.widget.*;
+
+import java.util.*;
+
+public class HelloFacebookSampleActivity extends FragmentActivity {
+
+    private static final List<String> PERMISSIONS = Arrays.asList("publish_actions");
+    private static final Location SEATTLE_LOCATION = new Location("") {
+        {
+            setLatitude(47.6097);
+            setLongitude(-122.3331);
+        }
+    };
+
+    private final String PENDING_ACTION_BUNDLE_KEY = "com.facebook.samples.hellofacebook:PendingAction";
+
+    private Button postStatusUpdateButton;
+    private Button postPhotoButton;
+    private Button pickFriendsButton;
+    private Button pickPlaceButton;
+    private LoginButton loginButton;
+    private ProfilePictureView profilePictureView;
+    private TextView greeting;
+    private PendingAction pendingAction = PendingAction.NONE;
+    private ViewGroup controlsContainer;
+    private GraphUser user;
+
+    private enum PendingAction {
+        NONE,
+        POST_PHOTO,
+        POST_STATUS_UPDATE
+    }
+    private UiLifecycleHelper uiHelper;
+
+    private Session.StatusCallback callback = new Session.StatusCallback() {
+        @Override
+        public void call(Session session, SessionState state, Exception exception) {
+            onSessionStateChange(session, state, exception);
+        }
+    };
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        uiHelper = new UiLifecycleHelper(this, callback);
+        uiHelper.onCreate(savedInstanceState);
+
+        if (savedInstanceState != null) {
+            String name = savedInstanceState.getString(PENDING_ACTION_BUNDLE_KEY);
+            pendingAction = PendingAction.valueOf(name);
+        }
+
+        setContentView(R.layout.main);
+
+        loginButton = (LoginButton) findViewById(R.id.login_button);
+        loginButton.setUserInfoChangedCallback(new LoginButton.UserInfoChangedCallback() {
+            @Override
+            public void onUserInfoFetched(GraphUser user) {
+                HelloFacebookSampleActivity.this.user = user;
+                updateUI();
+                // It's possible that we were waiting for this.user to be populated in order to post a
+                // status update.
+                handlePendingAction();
+            }
+        });
+
+        profilePictureView = (ProfilePictureView) findViewById(R.id.profilePicture);
+        greeting = (TextView) findViewById(R.id.greeting);
+
+        postStatusUpdateButton = (Button) findViewById(R.id.postStatusUpdateButton);
+        postStatusUpdateButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View view) {
+                onClickPostStatusUpdate();
+            }
+        });
+
+        postPhotoButton = (Button) findViewById(R.id.postPhotoButton);
+        postPhotoButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View view) {
+                onClickPostPhoto();
+            }
+        });
+
+        pickFriendsButton = (Button) findViewById(R.id.pickFriendsButton);
+        pickFriendsButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View view) {
+                onClickPickFriends();
+            }
+        });
+
+        pickPlaceButton = (Button) findViewById(R.id.pickPlaceButton);
+        pickPlaceButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View view) {
+                onClickPickPlace();
+            }
+        });
+
+        controlsContainer = (ViewGroup) findViewById(R.id.main_ui_container);
+
+        final FragmentManager fm = getSupportFragmentManager();
+        Fragment fragment = fm.findFragmentById(R.id.fragment_container);
+        if (fragment != null) {
+            // If we're being re-created and have a fragment, we need to a) hide the main UI controls and
+            // b) hook up its listeners again.
+            controlsContainer.setVisibility(View.GONE);
+            if (fragment instanceof FriendPickerFragment) {
+                setFriendPickerListeners((FriendPickerFragment) fragment);
+            } else if (fragment instanceof PlacePickerFragment) {
+                setPlacePickerListeners((PlacePickerFragment) fragment);
+            }
+        }
+
+        // Listen for changes in the back stack so we know if a fragment got popped off because the user
+        // clicked the back button.
+        fm.addOnBackStackChangedListener(new FragmentManager.OnBackStackChangedListener() {
+            @Override
+            public void onBackStackChanged() {
+                if (fm.getBackStackEntryCount() == 0) {
+                    // We need to re-show our UI.
+                    controlsContainer.setVisibility(View.VISIBLE);
+                }
+            }
+        });
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        uiHelper.onResume();
+
+        updateUI();
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        uiHelper.onSaveInstanceState(outState);
+
+        outState.putString(PENDING_ACTION_BUNDLE_KEY, pendingAction.name());
+    }
+
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        uiHelper.onActivityResult(requestCode, resultCode, data);
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        uiHelper.onPause();
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        uiHelper.onDestroy();
+    }
+
+    private void onSessionStateChange(Session session, SessionState state, Exception exception) {
+        if (pendingAction != PendingAction.NONE &&
+                (exception instanceof FacebookOperationCanceledException ||
+                exception instanceof FacebookAuthorizationException)) {
+                new AlertDialog.Builder(HelloFacebookSampleActivity.this)
+                    .setTitle(R.string.cancelled)
+                    .setMessage(R.string.permission_not_granted)
+                    .setPositiveButton(R.string.ok, null)
+                    .show();
+            pendingAction = PendingAction.NONE;
+        } else if (state == SessionState.OPENED_TOKEN_UPDATED) {
+            handlePendingAction();
+        }
+        updateUI();
+    }
+
+    private void updateUI() {
+        Session session = Session.getActiveSession();
+        boolean enableButtons = (session != null && session.isOpened());
+
+        postStatusUpdateButton.setEnabled(enableButtons);
+        postPhotoButton.setEnabled(enableButtons);
+        pickFriendsButton.setEnabled(enableButtons);
+        pickPlaceButton.setEnabled(enableButtons);
+
+        if (enableButtons && user != null) {
+            profilePictureView.setProfileId(user.getId());
+            greeting.setText(getString(R.string.hello_user, user.getFirstName()));
+        } else {
+            profilePictureView.setProfileId(null);
+            greeting.setText(null);
+        }
+    }
+
+    @SuppressWarnings("incomplete-switch")
+    private void handlePendingAction() {
+        PendingAction previouslyPendingAction = pendingAction;
+        // These actions may re-set pendingAction if they are still pending, but we assume they
+        // will succeed.
+        pendingAction = PendingAction.NONE;
+
+        switch (previouslyPendingAction) {
+            case POST_PHOTO:
+                postPhoto();
+                break;
+            case POST_STATUS_UPDATE:
+                postStatusUpdate();
+                break;
+        }
+    }
+
+    private interface GraphObjectWithId extends GraphObject {
+        String getId();
+    }
+
+    private void showPublishResult(String message, GraphObject result, FacebookRequestError error) {
+        String title = null;
+        String alertMessage = null;
+        if (error == null) {
+            title = getString(R.string.success);
+            String id = result.cast(GraphObjectWithId.class).getId();
+            alertMessage = getString(R.string.successfully_posted_post, message, id);
+        } else {
+            title = getString(R.string.error);
+            alertMessage = error.getErrorMessage();
+        }
+
+        new AlertDialog.Builder(this)
+                .setTitle(title)
+                .setMessage(alertMessage)
+                .setPositiveButton(R.string.ok, null)
+                .show();
+    }
+
+    private void onClickPostStatusUpdate() {
+        performPublish(PendingAction.POST_STATUS_UPDATE);
+    }
+
+    private void postStatusUpdate() {
+        if (user != null && hasPublishPermission()) {
+            final String message = getString(R.string.status_update, user.getFirstName(), (new Date().toString()));
+            Request request = Request
+                    .newStatusUpdateRequest(Session.getActiveSession(), message, new Request.Callback() {
+                        @Override
+                        public void onCompleted(Response response) {
+                            showPublishResult(message, response.getGraphObject(), response.getError());
+                        }
+                    });
+            request.executeAsync();
+        } else {
+            pendingAction = PendingAction.POST_STATUS_UPDATE;
+        }
+    }
+
+    private void onClickPostPhoto() {
+        performPublish(PendingAction.POST_PHOTO);
+    }
+
+    private void postPhoto() {
+        if (hasPublishPermission()) {
+            Bitmap image = BitmapFactory.decodeResource(this.getResources(), R.drawable.icon);
+            Request request = Request.newUploadPhotoRequest(Session.getActiveSession(), image, new Request.Callback() {
+                @Override
+                public void onCompleted(Response response) {
+                    showPublishResult(getString(R.string.photo_post), response.getGraphObject(), response.getError());
+                }
+            });
+            request.executeAsync();
+        } else {
+            pendingAction = PendingAction.POST_PHOTO;
+        }
+    }
+
+    private void showPickerFragment(PickerFragment<?> fragment) {
+        fragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
+            @Override
+            public void onError(PickerFragment<?> pickerFragment, FacebookException error) {
+                showAlert(getString(R.string.error), error.getMessage());
+            }
+        });
+
+        FragmentManager fm = getSupportFragmentManager();
+        fm.beginTransaction()
+                .replace(R.id.fragment_container, fragment)
+                .addToBackStack(null)
+                .commit();
+
+        controlsContainer.setVisibility(View.GONE);
+
+        // We want the fragment fully created so we can use it immediately.
+        fm.executePendingTransactions();
+
+        fragment.loadData(false);
+    }
+
+    private void onClickPickFriends() {
+        final FriendPickerFragment fragment = new FriendPickerFragment();
+
+        setFriendPickerListeners(fragment);
+
+        showPickerFragment(fragment);
+    }
+
+    private void setFriendPickerListeners(final FriendPickerFragment fragment) {
+        fragment.setOnDoneButtonClickedListener(new FriendPickerFragment.OnDoneButtonClickedListener() {
+            @Override
+            public void onDoneButtonClicked(PickerFragment<?> pickerFragment) {
+                onFriendPickerDone(fragment);
+            }
+        });
+    }
+
+    private void onFriendPickerDone(FriendPickerFragment fragment) {
+        FragmentManager fm = getSupportFragmentManager();
+        fm.popBackStack();
+
+        String results = "";
+
+        Collection<GraphUser> selection = fragment.getSelection();
+        if (selection != null && selection.size() > 0) {
+            ArrayList<String> names = new ArrayList<String>();
+            for (GraphUser user : selection) {
+                names.add(user.getName());
+            }
+            results = TextUtils.join(", ", names);
+        } else {
+            results = getString(R.string.no_friends_selected);
+        }
+
+        showAlert(getString(R.string.you_picked), results);
+    }
+
+    private void onPlacePickerDone(PlacePickerFragment fragment) {
+        FragmentManager fm = getSupportFragmentManager();
+        fm.popBackStack();
+
+        String result = "";
+
+        GraphPlace selection = fragment.getSelection();
+        if (selection != null) {
+            result = selection.getName();
+        } else {
+            result = getString(R.string.no_place_selected);
+        }
+
+        showAlert(getString(R.string.you_picked), result);
+    }
+
+    private void onClickPickPlace() {
+        final PlacePickerFragment fragment = new PlacePickerFragment();
+        fragment.setLocation(SEATTLE_LOCATION);
+        fragment.setTitleText(getString(R.string.pick_seattle_place));
+
+        setPlacePickerListeners(fragment);
+
+        showPickerFragment(fragment);
+    }
+
+    private void setPlacePickerListeners(final PlacePickerFragment fragment) {
+        fragment.setOnDoneButtonClickedListener(new PlacePickerFragment.OnDoneButtonClickedListener() {
+            @Override
+            public void onDoneButtonClicked(PickerFragment<?> pickerFragment) {
+                onPlacePickerDone(fragment);
+            }
+        });
+        fragment.setOnSelectionChangedListener(new PlacePickerFragment.OnSelectionChangedListener() {
+            @Override
+            public void onSelectionChanged(PickerFragment<?> pickerFragment) {
+                if (fragment.getSelection() != null) {
+                    onPlacePickerDone(fragment);
+                }
+            }
+        });
+    }
+
+    private void showAlert(String title, String message) {
+        new AlertDialog.Builder(this)
+                .setTitle(title)
+                .setMessage(message)
+                .setPositiveButton(R.string.ok, null)
+                .show();
+    }
+
+    private boolean hasPublishPermission() {
+        Session session = Session.getActiveSession();
+        return session != null && session.getPermissions().contains("publish_actions");
+    }
+
+    private void performPublish(PendingAction action) {
+        Session session = Session.getActiveSession();
+        if (session != null) {
+            pendingAction = action;
+            if (hasPublishPermission()) {
+                // We can do the action right away.
+                handlePendingAction();
+            } else {
+                // We need to get new permissions, then complete the action when we get called back.
+                session.requestNewPublishPermissions(new Session.NewPermissionsRequest(this, PERMISSIONS));
+            }
+        }
+    }
+}
diff --git a/samples/PlacePickerSample/.classpath b/samples/PlacePickerSample/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/PlacePickerSample/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/PlacePickerSample/.project b/samples/PlacePickerSample/.project
new file mode 100644
index 000000000..73ec9015a
--- /dev/null
+++ b/samples/PlacePickerSample/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>PlacePickerSample</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/samples/PlacePickerSample/AndroidManifest.xml b/samples/PlacePickerSample/AndroidManifest.xml
new file mode 100644
index 000000000..b0697ff65
--- /dev/null
+++ b/samples/PlacePickerSample/AndroidManifest.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.facebook.samples.placepicker"
+          android:versionCode="1"
+          android:versionName="1.0">
+    <uses-sdk android:minSdkVersion="8"/>
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+    <application android:label="@string/app_name"
+                 android:icon="@drawable/icon"
+                 android:theme="@android:style/Theme.Black"
+                 android:name=".PlacePickerApplication"
+            >
+        <activity android:name="PlacePickerSampleActivity"
+                  android:label="@string/app_name"
+                  android:windowSoftInputMode="adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+        <activity android:name="PickPlaceActivity"
+                  android:label="Pick Place">
+        </activity>
+        <activity android:name="com.facebook.LoginActivity"
+                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
+                  android:label="@string/app_name" />
+        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
+    </application>
+</manifest> 
diff --git a/samples/PlacePickerSample/FriendPickerSample.iml b/samples/PlacePickerSample/FriendPickerSample.iml
new file mode 100644
index 000000000..a6817daf5
--- /dev/null
+++ b/samples/PlacePickerSample/FriendPickerSample.iml
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.1 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/samples/PlacePickerSample/PlacePickerSample.iml b/samples/PlacePickerSample/PlacePickerSample.iml
new file mode 100644
index 000000000..13e1c77ae
--- /dev/null
+++ b/samples/PlacePickerSample/PlacePickerSample.iml
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/samples/PlacePickerSample/ant.properties b/samples/PlacePickerSample/ant.properties
new file mode 100644
index 000000000..939105d52
--- /dev/null
+++ b/samples/PlacePickerSample/ant.properties
@@ -0,0 +1,18 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
+java.compilerargs=-Xlint -Werror
diff --git a/samples/PlacePickerSample/build.xml b/samples/PlacePickerSample/build.xml
new file mode 100644
index 000000000..a80f395cd
--- /dev/null
+++ b/samples/PlacePickerSample/build.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="PlacePickerSample" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties"/>
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties"/>
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env"/>
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME"/>
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties"/>
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+            />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true"/>
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml"/>
+
+</project>
diff --git a/samples/PlacePickerSample/proguard-project.txt b/samples/PlacePickerSample/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/PlacePickerSample/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/samples/PlacePickerSample/project.properties b/samples/PlacePickerSample/project.properties
new file mode 100644
index 000000000..cee0509c6
--- /dev/null
+++ b/samples/PlacePickerSample/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+android.library.reference.1=../../facebook
diff --git a/samples/PlacePickerSample/res/drawable-hdpi/icon.png b/samples/PlacePickerSample/res/drawable-hdpi/icon.png
new file mode 100644
index 000000000..4059334b5
Binary files /dev/null and b/samples/PlacePickerSample/res/drawable-hdpi/icon.png differ
diff --git a/samples/PlacePickerSample/res/drawable-mdpi/icon.png b/samples/PlacePickerSample/res/drawable-mdpi/icon.png
new file mode 100644
index 000000000..1fa3834d0
Binary files /dev/null and b/samples/PlacePickerSample/res/drawable-mdpi/icon.png differ
diff --git a/samples/PlacePickerSample/res/drawable-xhdpi/icon.png b/samples/PlacePickerSample/res/drawable-xhdpi/icon.png
new file mode 100644
index 000000000..2b3083d44
Binary files /dev/null and b/samples/PlacePickerSample/res/drawable-xhdpi/icon.png differ
diff --git a/samples/PlacePickerSample/res/drawable/icon.png b/samples/PlacePickerSample/res/drawable/icon.png
new file mode 100644
index 000000000..1fa3834d0
Binary files /dev/null and b/samples/PlacePickerSample/res/drawable/icon.png differ
diff --git a/samples/PlacePickerSample/res/layout/main.xml b/samples/PlacePickerSample/res/layout/main.xml
new file mode 100644
index 000000000..7c4c7f1d0
--- /dev/null
+++ b/samples/PlacePickerSample/res/layout/main.xml
@@ -0,0 +1,56 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:orientation="vertical"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+        >
+    <LinearLayout android:layout_width="fill_parent"
+                  android:layout_height="wrap_content"
+                  android:orientation="horizontal"
+            >
+        <Button
+                android:id="@+id/seattleButton"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="Seattle"
+                android:layout_weight="1"
+                />
+        <Button
+                android:id="@+id/sanFranciscoButton"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="San Francisco"
+                android:layout_weight="1"
+                />
+        <Button
+                android:id="@+id/gpsButton"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="GPS"
+                android:layout_weight="1"
+                />
+    </LinearLayout>
+    <TextView
+            android:id="@+id/resultsTextView"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:textColor="#FFFFFF"
+            />
+</LinearLayout>
+
diff --git a/samples/PlacePickerSample/res/layout/pick_place_activity.xml b/samples/PlacePickerSample/res/layout/pick_place_activity.xml
new file mode 100644
index 000000000..8601f57e4
--- /dev/null
+++ b/samples/PlacePickerSample/res/layout/pick_place_activity.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              xmlns:app="http://schemas.android.com/apk/res-auto"
+              android:orientation="vertical"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+        >
+    <fragment
+            android:id="@+id/place_picker_fragment"
+            android:name="com.facebook.widget.PlacePickerFragment"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            app:show_pictures="true"
+            app:show_title_bar="true"
+            app:show_search_box="true"
+            />
+</LinearLayout>
+
diff --git a/samples/PlacePickerSample/res/values/strings.xml b/samples/PlacePickerSample/res/values/strings.xml
new file mode 100644
index 000000000..2248b47dd
--- /dev/null
+++ b/samples/PlacePickerSample/res/values/strings.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<resources>
+    <string name="app_name">PlacePickerSample</string>
+    <string name="app_id">378281678861098</string>
+    <string name="error_dialog_title">Error</string>
+    <string name="ok_button">OK</string>
+    <string name="no_location">Could not obtain your current location.</string>
+</resources>
diff --git a/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PickPlaceActivity.java b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PickPlaceActivity.java
new file mode 100644
index 000000000..c02da9bdc
--- /dev/null
+++ b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PickPlaceActivity.java
@@ -0,0 +1,110 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.placepicker;
+
+import android.app.AlertDialog;
+import android.content.Intent;
+import android.location.Location;
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+import com.facebook.FacebookException;
+import com.facebook.widget.PickerFragment;
+import com.facebook.widget.PlacePickerFragment;
+
+// This class provides an example of an Activity that uses PlacePickerFragment to display a list of
+// the places. It takes a layout-based approach to creating the PlacePickerFragment with the
+// desired parameters -- see PickFriendActivity in the FriendPickerSample project for an example of an
+// Activity creating a fragment (in this case a FriendPickerFragment) programmatically rather than
+// via XML layout.
+public class PickPlaceActivity extends FragmentActivity {
+    PlacePickerFragment placePickerFragment;
+
+    // A helper to simplify life for callers who want to populate a Bundle with the necessary
+    // parameters. A more sophisticated Activity might define its own set of parameters; our needs
+    // are simple, so we just populate what we want to pass to the PlacePickerFragment.
+    public static void populateParameters(Intent intent, Location location, String searchText) {
+        intent.putExtra(PlacePickerFragment.LOCATION_BUNDLE_KEY, location);
+        intent.putExtra(PlacePickerFragment.SEARCH_TEXT_BUNDLE_KEY, searchText);
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.pick_place_activity);
+
+        FragmentManager fm = getSupportFragmentManager();
+        placePickerFragment = (PlacePickerFragment) fm.findFragmentById(R.id.place_picker_fragment);
+        if (savedInstanceState == null) {
+            // If this is the first time we have created the fragment, update its properties based on
+            // any parameters we received via our Intent.
+            placePickerFragment.setSettingsFromBundle(getIntent().getExtras());
+        }
+
+        placePickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
+            @Override
+            public void onError(PickerFragment<?> fragment, FacebookException error) {
+                PickPlaceActivity.this.onError(error);
+            }
+        });
+
+        // We finish the activity when either the Done button is pressed or when a place is
+        // selected (since only a single place can be selected).
+        placePickerFragment.setOnSelectionChangedListener(new PickerFragment.OnSelectionChangedListener() {
+            @Override
+            public void onSelectionChanged(PickerFragment<?> fragment) {
+                if (placePickerFragment.getSelection() != null) {
+                    finishActivity();
+                }
+            }
+        });
+        placePickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
+            @Override
+            public void onDoneButtonClicked(PickerFragment<?> fragment) {
+                finishActivity();
+            }
+        });
+    }
+
+    private void finishActivity() {
+        // We just store our selection in the Application for other activities to look at.
+        PlacePickerApplication application = (PlacePickerApplication) getApplication();
+        application.setSelectedPlace(placePickerFragment.getSelection());
+
+        setResult(RESULT_OK, null);
+        finish();
+    }
+
+    private void onError(Exception error) {
+        new AlertDialog.Builder(this)
+                .setTitle(R.string.error_dialog_title)
+                .setMessage(error.getMessage())
+                .setPositiveButton(R.string.ok_button, null)
+                .show();
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        try {
+            // Load data, unless a query has already taken place.
+            placePickerFragment.loadData(false);
+        } catch (Exception ex) {
+            onError(ex);
+        }
+    }
+}
diff --git a/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerApplication.java b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerApplication.java
new file mode 100644
index 000000000..344c38732
--- /dev/null
+++ b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerApplication.java
@@ -0,0 +1,35 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.placepicker;
+
+import android.app.Application;
+import com.facebook.model.GraphPlace;
+
+// We use a custom Application class to store our minimal state data (which users have been selected).
+// A real-world application will likely require a more robust data model.
+public class PlacePickerApplication extends Application {
+    public GraphPlace getSelectedPlace() {
+        return selectedPlace;
+    }
+
+    public void setSelectedPlace(GraphPlace selectedPlace) {
+        this.selectedPlace = selectedPlace;
+    }
+
+    private GraphPlace selectedPlace;
+
+}
diff --git a/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerSampleActivity.java b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerSampleActivity.java
new file mode 100644
index 000000000..2be700ed4
--- /dev/null
+++ b/samples/PlacePickerSample/src/com/facebook/samples/placepicker/PlacePickerSampleActivity.java
@@ -0,0 +1,213 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.placepicker;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.Intent;
+import android.location.Criteria;
+import android.location.Location;
+import android.location.LocationListener;
+import android.location.LocationManager;
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+import android.view.View;
+import android.widget.Button;
+import android.widget.TextView;
+import com.facebook.model.GraphLocation;
+import com.facebook.model.GraphPlace;
+import com.facebook.Session;
+
+public class PlacePickerSampleActivity extends FragmentActivity implements LocationListener {
+    private static final int PLACE_ACTIVITY = 1;
+    private static final Location SEATTLE_LOCATION = new Location("") {
+        {
+            setLatitude(47.6097);
+            setLongitude(-122.3331);
+        }
+    };
+    private static final Location SAN_FRANCISCO_LOCATION = new Location("") {
+        {
+            setLatitude(37.7750);
+            setLongitude(-122.4183);
+        }
+    };
+    private static final Location PARIS_LOCATION = new Location("") {
+        {
+            setLatitude(48.857875);
+            setLongitude(2.294635);
+        }
+    };
+
+    private TextView resultsTextView;
+    private LocationManager locationManager;
+    private Location lastKnownLocation;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+
+        resultsTextView = (TextView) findViewById(R.id.resultsTextView);
+        Button button = (Button) findViewById(R.id.seattleButton);
+        button.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View view) {
+                onClickSeattle();
+            }
+        });
+
+        button = (Button) findViewById(R.id.sanFranciscoButton);
+        button.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View view) {
+                onClickSanFrancisco();
+            }
+        });
+
+        button = (Button) findViewById(R.id.gpsButton);
+        button.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View view) {
+                onClickGPS();
+            }
+        });
+
+        if (Session.getActiveSession() == null ||
+                Session.getActiveSession().isClosed()) {
+            Session.openActiveSession(this, true, null);
+        }
+
+        locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+
+        // Update the display every time we are started (this will be "no place selected" on first
+        // run, or possibly details of a place if the activity is being re-created).
+        displaySelectedPlace(RESULT_OK);
+    }
+
+    private void onError(Exception exception) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setTitle("Error").setMessage(exception.getMessage()).setPositiveButton("OK", null);
+        builder.show();
+    }
+
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        switch (requestCode) {
+            case PLACE_ACTIVITY:
+                displaySelectedPlace(resultCode);
+                break;
+            default:
+                Session.getActiveSession().onActivityResult(this, requestCode, resultCode, data);
+                break;
+        }
+    }
+
+    private void displaySelectedPlace(int resultCode) {
+        String results = "";
+        PlacePickerApplication application = (PlacePickerApplication) getApplication();
+
+        GraphPlace selection = application.getSelectedPlace();
+        if (selection != null) {
+            GraphLocation location = selection.getLocation();
+
+            results = String.format("Name: %s\nCategory: %s\nLocation: (%f,%f)\nStreet: %s, %s, %s, %s, %s",
+                    selection.getName(), selection.getCategory(),
+                    location.getLatitude(), location.getLongitude(),
+                    location.getStreet(), location.getCity(), location.getState(), location.getZip(),
+                    location.getCountry());
+        } else {
+            results = "<No place selected>";
+        }
+
+        resultsTextView.setText(results);
+    }
+
+    public void onLocationChanged(Location location) {
+        lastKnownLocation = location;
+    }
+
+    @Override
+    public void onStatusChanged(String provider, int status, Bundle extras) {
+    }
+
+    @Override
+    public void onProviderEnabled(String provider) {
+    }
+
+    @Override
+    public void onProviderDisabled(String provider) {
+    }
+
+    private void startPickPlaceActivity(Location location) {
+        PlacePickerApplication application = (PlacePickerApplication) getApplication();
+        application.setSelectedPlace(null);
+
+        Intent intent = new Intent(this, PickPlaceActivity.class);
+        PickPlaceActivity.populateParameters(intent, location, null);
+
+        startActivityForResult(intent, PLACE_ACTIVITY);
+    }
+
+    private void onClickSeattle() {
+        try {
+            startPickPlaceActivity(SEATTLE_LOCATION);
+        } catch (Exception ex) {
+            onError(ex);
+        }
+    }
+
+    private void onClickSanFrancisco() {
+        try {
+            startPickPlaceActivity(SAN_FRANCISCO_LOCATION);
+        } catch (Exception ex) {
+            onError(ex);
+        }
+    }
+
+    private void onClickGPS() {
+        try {
+            if (lastKnownLocation == null) {
+                Criteria criteria = new Criteria();
+                String bestProvider = locationManager.getBestProvider(criteria, false);
+                if (bestProvider != null) {
+                    lastKnownLocation = locationManager.getLastKnownLocation(bestProvider);
+                }
+            }
+            if (lastKnownLocation == null) {
+                String model = android.os.Build.MODEL;
+                if (model.equals("sdk") || model.equals("google_sdk") || model.contains("x86")) {
+                    // Looks like they are on an emulator, pretend we're in Paris if we don't have a
+                    // location set.
+                    lastKnownLocation = PARIS_LOCATION;
+                } else {
+                    new AlertDialog.Builder(this)
+                            .setTitle(R.string.error_dialog_title)
+                            .setMessage(R.string.no_location)
+                            .setPositiveButton(R.string.ok_button, null)
+                            .show();
+                    return;
+                }
+            }
+            startPickPlaceActivity(lastKnownLocation);
+        } catch (Exception ex) {
+            onError(ex);
+        }
+    }
+
+}
diff --git a/samples/ProfilePictureSample/.classpath b/samples/ProfilePictureSample/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/ProfilePictureSample/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/ProfilePictureSample/.project b/samples/ProfilePictureSample/.project
new file mode 100644
index 000000000..44914352a
--- /dev/null
+++ b/samples/ProfilePictureSample/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>ProfilePictureSample</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/samples/ProfilePictureSample/AndroidManifest.xml b/samples/ProfilePictureSample/AndroidManifest.xml
new file mode 100644
index 000000000..907d05754
--- /dev/null
+++ b/samples/ProfilePictureSample/AndroidManifest.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.facebook.samples.profilepicture"
+          android:versionCode="1"
+          android:versionName="1.0">
+    <uses-sdk android:minSdkVersion="8"/>
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <application android:label="@string/app_name"
+                 android:icon="@drawable/icon" >
+        <activity
+                android:name=".ProfilePictureSampleActivity"
+                android:label="@string/app_name"
+                android:windowSoftInputMode="adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+</manifest> 
diff --git a/samples/ProfilePictureSample/ProfilePictureSample.iml b/samples/ProfilePictureSample/ProfilePictureSample.iml
new file mode 100644
index 000000000..4aac86509
--- /dev/null
+++ b/samples/ProfilePictureSample/ProfilePictureSample.iml
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/samples/ProfilePictureSample/ant.properties b/samples/ProfilePictureSample/ant.properties
new file mode 100644
index 000000000..939105d52
--- /dev/null
+++ b/samples/ProfilePictureSample/ant.properties
@@ -0,0 +1,18 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
+java.compilerargs=-Xlint -Werror
diff --git a/samples/ProfilePictureSample/build.xml b/samples/ProfilePictureSample/build.xml
new file mode 100644
index 000000000..3454adc93
--- /dev/null
+++ b/samples/ProfilePictureSample/build.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="ProfilePictureSample" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties"/>
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties"/>
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env"/>
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME"/>
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties"/>
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+            />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true"/>
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml"/>
+
+</project>
diff --git a/samples/ProfilePictureSample/proguard-project.txt b/samples/ProfilePictureSample/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/ProfilePictureSample/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/samples/ProfilePictureSample/project.properties b/samples/ProfilePictureSample/project.properties
new file mode 100644
index 000000000..cee0509c6
--- /dev/null
+++ b/samples/ProfilePictureSample/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+android.library.reference.1=../../facebook
diff --git a/samples/ProfilePictureSample/res/drawable-hdpi/icon.png b/samples/ProfilePictureSample/res/drawable-hdpi/icon.png
new file mode 100644
index 000000000..1bc72b1bf
Binary files /dev/null and b/samples/ProfilePictureSample/res/drawable-hdpi/icon.png differ
diff --git a/samples/ProfilePictureSample/res/drawable-mdpi/icon.png b/samples/ProfilePictureSample/res/drawable-mdpi/icon.png
new file mode 100644
index 000000000..e0de1a4ba
Binary files /dev/null and b/samples/ProfilePictureSample/res/drawable-mdpi/icon.png differ
diff --git a/samples/ProfilePictureSample/res/drawable-xhdpi/icon.png b/samples/ProfilePictureSample/res/drawable-xhdpi/icon.png
new file mode 100644
index 000000000..1bc4b231d
Binary files /dev/null and b/samples/ProfilePictureSample/res/drawable-xhdpi/icon.png differ
diff --git a/samples/ProfilePictureSample/res/drawable/icon.png b/samples/ProfilePictureSample/res/drawable/icon.png
new file mode 100644
index 000000000..e0de1a4ba
Binary files /dev/null and b/samples/ProfilePictureSample/res/drawable/icon.png differ
diff --git a/samples/ProfilePictureSample/res/layout/activity_profile_picture_sample.xml b/samples/ProfilePictureSample/res/layout/activity_profile_picture_sample.xml
new file mode 100644
index 000000000..87877789a
--- /dev/null
+++ b/samples/ProfilePictureSample/res/layout/activity_profile_picture_sample.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<fragment xmlns:android="http://schemas.android.com/apk/res/android"
+          android:id="@+id/profilePictureSampleFragment"
+          android:layout_width="match_parent"
+          android:layout_height="match_parent"
+          android:name="com.facebook.samples.profilepicture.ProfilePictureSampleFragment"
+        />
diff --git a/samples/ProfilePictureSample/res/layout/fragment_profile_picture_sample.xml b/samples/ProfilePictureSample/res/layout/fragment_profile_picture_sample.xml
new file mode 100644
index 000000000..8735c788a
--- /dev/null
+++ b/samples/ProfilePictureSample/res/layout/fragment_profile_picture_sample.xml
@@ -0,0 +1,152 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+            xmlns:app="http://schemas.android.com/apk/res-auto"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        >
+<LinearLayout
+              android:orientation="vertical"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+        >
+    <TextView
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:text="@string/description"
+            android:layout_marginBottom="15dp"
+            />
+    <LinearLayout
+            android:layout_height="wrap_content"
+            android:layout_width="match_parent"
+            android:layout_marginBottom="15dp"
+            android:orientation="horizontal">
+        <LinearLayout
+                android:id="@+id/presetSizeView"
+                android:layout_height="wrap_content"
+                android:layout_width="0dp"
+                android:layout_weight="1"
+                android:orientation="horizontal"
+                >
+            <Button
+                    android:id="@+id/smallerButton"
+                    android:layout_height="40dp"
+                    android:layout_width="40dp"
+                    android:layout_weight="0"
+                    android:text="@string/smaller_button_text"
+                    android:textSize="18dp"
+                    />
+            <Button
+                    android:id="@+id/largerButton"
+                    android:layout_height="40dp"
+                    android:layout_width="40dp"
+                    android:layout_weight="0"
+                    android:text="@string/larger_button_text"
+                    android:textSize="18dp"
+                    android:enabled="false"
+                    />
+            <TextView
+                    android:id="@+id/sizeLabel"
+                    android:layout_height="40dp"
+                    android:layout_width="0dp"
+                    android:layout_weight="1"
+                    android:paddingLeft="10dp"
+                    android:text="@string/large_image_size"
+                    android:textSize="18dp"
+                    />
+        </LinearLayout>
+        <SeekBar
+                android:id="@+id/customSizeView"
+                android:layout_height="wrap_content"
+                android:layout_width="0dp"
+                android:layout_weight="1"
+                android:orientation="horizontal"
+                android:visibility="gone"
+                />
+        <Button
+                android:id="@+id/sizeToggle"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginLeft="10dp"
+                android:text="@string/custom_size_button_text"
+                />
+    </LinearLayout>
+    <LinearLayout
+            android:orientation="horizontal"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="10dp"
+            android:layout_marginBottom="10dp"
+            >
+        <com.facebook.widget.ProfilePictureView
+                android:id="@+id/profilepic"
+                android:layout_height="wrap_content"
+                android:layout_width="0dp"
+                android:layout_weight="1"
+                app:preset_size="large"
+                app:is_cropped="true"
+                />
+        <LinearLayout
+                android:id="@+id/userbuttoncontainer"
+                android:orientation="vertical"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="right"
+                >
+            <Button
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:text="@string/user_chris_name"
+                    android:tag="chris.lang.92123"
+                    />
+            <Button
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:text="@string/user_michael_name"
+                    android:tag="michael.marucheck"
+                    />
+            <Button
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:text="@string/user_karthik_name"
+                    android:tag="ksubraman"
+                    />
+            <Button
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:text="@string/user_random_name"
+                    />
+
+            <Button
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:text="@string/user_none_name"
+                    android:tag=""
+                    />
+        </LinearLayout>
+    </LinearLayout>
+
+    <CheckBox
+            android:id="@+id/squareCropToggle"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="@string/cropping_label"
+            android:checked="true"
+            />
+</LinearLayout>
+</ScrollView>
diff --git a/samples/ProfilePictureSample/res/values/strings.xml b/samples/ProfilePictureSample/res/values/strings.xml
new file mode 100644
index 000000000..a9b3c10d5
--- /dev/null
+++ b/samples/ProfilePictureSample/res/values/strings.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<resources>
+    <string name="app_name">ProfilePictureSample</string>
+    <string name="description">Sample app demonstrating the use of ProfilePictureView</string>
+    <string name="cropping_label">Show cropped version</string>
+    <string name="crop_original_button_text">Original</string>
+    <string name="crop_square_button_text">Square</string>
+    <string name="user_chris_name">Chris</string>
+    <string name="user_michael_name">Michael</string>
+    <string name="user_karthik_name">Karthik</string>
+    <string name="user_random_name">Random</string>
+    <string name="user_none_name">None</string>
+    <string name="smaller_button_text">-</string>
+    <string name="larger_button_text">+</string>
+    <string name="large_image_size">Large</string>
+    <string name="normal_image_size">Normal</string>
+    <string name="small_image_size">Small</string>
+    <string name="preset_size_button_text">Use preset size</string>
+    <string name="custom_size_button_text">Use custom size</string>
+</resources>
diff --git a/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleActivity.java b/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleActivity.java
new file mode 100644
index 000000000..9b35d3e21
--- /dev/null
+++ b/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleActivity.java
@@ -0,0 +1,28 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.profilepicture;
+
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+
+public class ProfilePictureSampleActivity extends FragmentActivity {
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_profile_picture_sample);
+    }
+}
diff --git a/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleFragment.java b/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleFragment.java
new file mode 100644
index 000000000..1efec3fb5
--- /dev/null
+++ b/samples/ProfilePictureSample/src/com/facebook/samples/profilepicture/ProfilePictureSampleFragment.java
@@ -0,0 +1,314 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.profilepicture;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.*;
+import com.facebook.widget.ProfilePictureView;
+
+import java.util.Date;
+import java.util.Random;
+
+public class ProfilePictureSampleFragment extends Fragment {
+
+    // Keeping the number of custom sizes low to prevent excessive network chatter.
+    private static final int MAX_CUSTOM_SIZES = 6;
+    private static final int DEFAULT_SIZE_INCREMENT = MAX_CUSTOM_SIZES / 2;
+    private static final String PICTURE_SIZE_TYPE_KEY = "PictureSizeType";
+
+    private static final String[] INTERESTING_IDS = {
+        "zuck",
+        // Recent Presidents and nominees
+        "barackobama",
+        "mittromney",
+        "johnmccain",
+        "johnkerry",
+        "georgewbush",
+        "algore",
+        // Places too!
+        "Disneyland",
+        "SpaceNeedle",
+        "TourEiffel",
+        "sydneyoperahouse",
+        // A selection of 1986 Mets
+        "166020963458360",
+        "108084865880237",
+        "140447466087679",
+        "111825495501392",
+        // The cast of Saved by the Bell
+        "108168249210849",
+        "TiffaniThiessen",
+        "108126672542534",
+        "112886105391693",
+        "MarioLopezExtra",
+        "108504145837165",
+        "dennishaskins",
+        // Eighties bands that have been to Moscow
+        "7220821999",
+        "31938132882",
+        "108023262558391",
+        "209263392372",
+        "104132506290482",
+        "9721897972",
+        "5461947317",
+        "57084011597",
+        // Three people that have never been in my kitchen
+        "24408579964",
+        "111980872152571",
+        "112427772106500",
+        // Trusted anchormen
+        "113415525338717",
+        "105628452803615",
+        "105533779480538",
+    };
+
+    private int pictureSizeType = ProfilePictureView.CUSTOM;
+    private String firstUserId;
+    private Random randomGenerator;
+
+    private ProfilePictureView profilePic;
+    private Button smallerButton;
+    private Button largerButton;
+    private TextView sizeLabel;
+    private View presetSizeView;
+    private SeekBar customSizeView;
+    private CheckBox cropToggle;
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {
+        View fragmentView = inflater.inflate(R.layout.fragment_profile_picture_sample, parent, false);
+
+        randomGenerator = new Random((new Date()).getTime());
+
+        profilePic = (ProfilePictureView) fragmentView.findViewById(R.id.profilepic);
+        smallerButton = (Button) fragmentView.findViewById(R.id.smallerButton);
+        largerButton = (Button) fragmentView.findViewById(R.id.largerButton);
+        sizeLabel = (TextView) fragmentView.findViewById(R.id.sizeLabel);
+        presetSizeView = fragmentView.findViewById(R.id.presetSizeView);
+        customSizeView = (SeekBar) fragmentView.findViewById(R.id.customSizeView);
+        cropToggle = (CheckBox) fragmentView.findViewById(R.id.squareCropToggle);
+
+        LinearLayout container = (LinearLayout) fragmentView.findViewById(R.id.userbuttoncontainer);
+        int numChildren = container.getChildCount();
+        for (int i = 0; i < numChildren; i++) {
+            View childView = container.getChildAt(i);
+            Object tag = childView.getTag();
+            if (childView instanceof Button) {
+                setupUserButton((Button)childView);
+                if (i == 0) {
+                    // Initialize the image to the first user
+                    firstUserId = tag.toString();
+                }
+            }
+        }
+
+        cropToggle.setOnCheckedChangeListener(new CheckBox.OnCheckedChangeListener() {
+            @Override
+            public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
+                profilePic.setCropped(checked);
+            }
+        });
+
+        final Button sizeToggle = (Button) fragmentView.findViewById(R.id.sizeToggle);
+        sizeToggle.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                if (pictureSizeType != ProfilePictureView.CUSTOM) {
+                    sizeToggle.setText(R.string.preset_size_button_text);
+                    switchToCustomSize();
+                } else {
+                    sizeToggle.setText(R.string.custom_size_button_text);
+                    switchToPresetSize(ProfilePictureView.LARGE);
+                }
+            }
+        });
+
+        smallerButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                switch(profilePic.getPresetSize()) {
+                    case ProfilePictureView.LARGE:
+                        switchToPresetSize(ProfilePictureView.NORMAL);
+                        break;
+                    case ProfilePictureView.NORMAL:
+                        switchToPresetSize(ProfilePictureView.SMALL);
+                        break;
+                }
+            }
+        });
+
+        largerButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                switch(profilePic.getPresetSize()) {
+                    case ProfilePictureView.NORMAL:
+                        switchToPresetSize(ProfilePictureView.LARGE);
+                        break;
+                    case ProfilePictureView.SMALL:
+                        switchToPresetSize(ProfilePictureView.NORMAL);
+                        break;
+                }
+            }
+        });
+
+        // We will fetch a new image for each change in the SeekBar. So keeping the count low
+        // to prevent too much network chatter. SeekBar reports 0-max, so we will get max+1
+        // notifications of change.
+        customSizeView.setMax(MAX_CUSTOM_SIZES);
+        customSizeView.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
+            @Override
+            public void onProgressChanged(SeekBar seekBar, int i, boolean b) {
+                updateProfilePicForCustomSizeIncrement(i);
+            }
+
+            @Override
+            public void onStartTrackingTouch(SeekBar seekBar) {
+                // NO-OP
+            }
+
+            @Override
+            public void onStopTrackingTouch(SeekBar seekBar) {
+                // NO-OP
+            }
+        });
+
+        restoreState(savedInstanceState);
+
+        return fragmentView;
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        // Store the size type since we will use that to switch the Fragment's UI
+        // between CUSTOM & PRESET modes
+        // Other state (userId & isCropped) will be saved/restored directly by
+        // ProfilePictureView
+        outState.putInt(PICTURE_SIZE_TYPE_KEY, pictureSizeType);
+    }
+
+    private void restoreState(Bundle savedInstanceState) {
+        if (savedInstanceState != null) {
+            // Is we have saved state, restore the Fragment to it.
+            // UserId & isCropped will be restored directly by ProfilePictureView
+            pictureSizeType = savedInstanceState.getInt(
+                    PICTURE_SIZE_TYPE_KEY, ProfilePictureView.LARGE);
+
+            if (pictureSizeType == ProfilePictureView.CUSTOM) {
+                switchToCustomSize();
+            } else {
+                switchToPresetSize(pictureSizeType);
+            }
+        } else {
+            // No saved state. Let's go to a default state
+            switchToPresetSize(ProfilePictureView.LARGE);
+            profilePic.setCropped(cropToggle.isChecked());
+
+            // Setting userId last so that only one network request is sent
+            profilePic.setProfileId(firstUserId);
+        }
+    }
+
+    private void setupUserButton(Button b) {
+        b.setOnClickListener(new Button.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                Object tag = v.getTag();
+                String userId = null;
+                if (tag != null) {
+                    userId = tag.toString();
+                } else {
+                    // Random id.
+                    userId = INTERESTING_IDS[randomGenerator.nextInt(INTERESTING_IDS.length)];
+                }
+                profilePic.setProfileId(userId);
+            }
+        });
+    }
+
+    private void switchToCustomSize() {
+        pictureSizeType = ProfilePictureView.CUSTOM;
+        presetSizeView.setVisibility(View.GONE);
+        customSizeView.setVisibility(View.VISIBLE);
+
+        profilePic.setPresetSize(pictureSizeType);
+
+        customSizeView.setProgress(DEFAULT_SIZE_INCREMENT);
+        updateProfilePicForCustomSizeIncrement(DEFAULT_SIZE_INCREMENT);
+    }
+
+    private void switchToPresetSize(int sizeType) {
+        customSizeView.setVisibility(View.GONE);
+        presetSizeView.setVisibility(View.VISIBLE);
+
+        switch(sizeType) {
+            case ProfilePictureView.SMALL:
+                largerButton.setEnabled(true);
+                smallerButton.setEnabled(false);
+                sizeLabel.setText(R.string.small_image_size);
+                pictureSizeType = sizeType;
+                break;
+            case ProfilePictureView.NORMAL:
+                largerButton.setEnabled(true);
+                smallerButton.setEnabled(true);
+                sizeLabel.setText(R.string.normal_image_size);
+                pictureSizeType = sizeType;
+                break;
+            case ProfilePictureView.LARGE:
+            default:
+                largerButton.setEnabled(false);
+                smallerButton.setEnabled(true);
+                sizeLabel.setText(R.string.large_image_size);
+                pictureSizeType = ProfilePictureView.LARGE;
+                break;
+        }
+
+        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(
+                0,
+                ViewGroup.LayoutParams.WRAP_CONTENT,
+                1
+        );
+
+        profilePic.setLayoutParams(params);
+        profilePic.setPresetSize(pictureSizeType);
+    }
+
+    private void updateProfilePicForCustomSizeIncrement(int i) {
+        if (pictureSizeType != ProfilePictureView.CUSTOM) {
+            return;
+        }
+
+        // This will ensure a minimum size of 51x68 and will scale the image at
+        // a ratio of 3:4 (w:h) as the SeekBar is moved.
+        //
+        // Completely arbitrary
+        //
+        // NOTE: The numbers are in dips.
+        float width = (i * 21) + 51;
+        float height = (i * 28) + 68;
+
+        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(
+                (int)(width * getResources().getDisplayMetrics().density),
+                (int)(height * getResources().getDisplayMetrics().density));
+        profilePic.setLayoutParams(params);
+    }
+}
diff --git a/samples/Scrumptious/.classpath b/samples/Scrumptious/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/Scrumptious/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/Scrumptious/.project b/samples/Scrumptious/.project
new file mode 100644
index 000000000..dfb9212a3
--- /dev/null
+++ b/samples/Scrumptious/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Scrumptious</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/samples/Scrumptious/AndroidManifest.xml b/samples/Scrumptious/AndroidManifest.xml
new file mode 100644
index 000000000..ac9de56bc
--- /dev/null
+++ b/samples/Scrumptious/AndroidManifest.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.facebook.scrumptious"
+          android:versionCode="1"
+          android:versionName="1.0">
+    <uses-sdk android:minSdkVersion="8"/>
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
+    <uses-feature android:name="android.hardware.camera"/>
+    <uses-feature android:name="android.hardware.camera.autofocus"/>
+    <application android:label="@string/app_name"
+                 android:icon="@drawable/icon"
+                 android:name=".ScrumptiousApplication">
+        <activity android:name="MainActivity"
+                  android:label="@string/app_name"
+                  android:windowSoftInputMode="adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+        <activity android:name="PickerActivity"
+                  android:label="@string/app_name" />
+        <activity android:name="com.facebook.LoginActivity"
+                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
+                  android:label="@string/app_name" />
+        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
+    </application>
+</manifest> 
diff --git a/samples/Scrumptious/Scrumptious.iml b/samples/Scrumptious/Scrumptious.iml
new file mode 100644
index 000000000..e7d82c334
--- /dev/null
+++ b/samples/Scrumptious/Scrumptious.iml
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" exported="" />
+    <orderEntry type="library" exported="" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/samples/Scrumptious/ant.properties b/samples/Scrumptious/ant.properties
new file mode 100644
index 000000000..939105d52
--- /dev/null
+++ b/samples/Scrumptious/ant.properties
@@ -0,0 +1,18 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
+java.compilerargs=-Xlint -Werror
diff --git a/samples/Scrumptious/build.xml b/samples/Scrumptious/build.xml
new file mode 100644
index 000000000..7f943468f
--- /dev/null
+++ b/samples/Scrumptious/build.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="Scrumptious" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties"/>
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties"/>
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env"/>
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME"/>
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties"/>
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+            />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true"/>
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml"/>
+
+</project>
diff --git a/samples/Scrumptious/proguard-project.txt b/samples/Scrumptious/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/Scrumptious/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/samples/Scrumptious/project.properties b/samples/Scrumptious/project.properties
new file mode 100644
index 000000000..cee0509c6
--- /dev/null
+++ b/samples/Scrumptious/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+android.library.reference.1=../../facebook
diff --git a/samples/Scrumptious/res/drawable-hdpi/icon.png b/samples/Scrumptious/res/drawable-hdpi/icon.png
new file mode 100644
index 000000000..0320aeb54
Binary files /dev/null and b/samples/Scrumptious/res/drawable-hdpi/icon.png differ
diff --git a/samples/Scrumptious/res/drawable-mdpi/icon.png b/samples/Scrumptious/res/drawable-mdpi/icon.png
new file mode 100644
index 000000000..5c4b0095f
Binary files /dev/null and b/samples/Scrumptious/res/drawable-mdpi/icon.png differ
diff --git a/samples/Scrumptious/res/drawable-xhdpi/icon.png b/samples/Scrumptious/res/drawable-xhdpi/icon.png
new file mode 100644
index 000000000..796e14ec2
Binary files /dev/null and b/samples/Scrumptious/res/drawable-xhdpi/icon.png differ
diff --git a/samples/Scrumptious/res/drawable/action_eating.png b/samples/Scrumptious/res/drawable/action_eating.png
new file mode 100644
index 000000000..7b951edf0
Binary files /dev/null and b/samples/Scrumptious/res/drawable/action_eating.png differ
diff --git a/samples/Scrumptious/res/drawable/action_location.png b/samples/Scrumptious/res/drawable/action_location.png
new file mode 100644
index 000000000..13dfe86ff
Binary files /dev/null and b/samples/Scrumptious/res/drawable/action_location.png differ
diff --git a/samples/Scrumptious/res/drawable/action_people.png b/samples/Scrumptious/res/drawable/action_people.png
new file mode 100644
index 000000000..19546267c
Binary files /dev/null and b/samples/Scrumptious/res/drawable/action_people.png differ
diff --git a/samples/Scrumptious/res/drawable/button_border.xml b/samples/Scrumptious/res/drawable/button_border.xml
new file mode 100644
index 000000000..96c32725f
--- /dev/null
+++ b/samples/Scrumptious/res/drawable/button_border.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+       android:shape="rectangle">
+    <solid android:color="#FFF" />
+    <corners android:radius="10dp" />
+    <padding android:bottom="10dp" android:left="10dp" android:right="10dp" android:top="10dp" />
+    <stroke android:width="1px" android:color="#222" />
+</shape>
diff --git a/samples/Scrumptious/res/drawable/facebook.png b/samples/Scrumptious/res/drawable/facebook.png
new file mode 100755
index 000000000..daf8097b1
Binary files /dev/null and b/samples/Scrumptious/res/drawable/facebook.png differ
diff --git a/samples/Scrumptious/res/drawable/icon.png b/samples/Scrumptious/res/drawable/icon.png
new file mode 100644
index 000000000..5c4b0095f
Binary files /dev/null and b/samples/Scrumptious/res/drawable/icon.png differ
diff --git a/samples/Scrumptious/res/layout/listitem.xml b/samples/Scrumptious/res/layout/listitem.xml
new file mode 100644
index 000000000..2aa461efe
--- /dev/null
+++ b/samples/Scrumptious/res/layout/listitem.xml
@@ -0,0 +1,50 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="fill_parent"
+              android:layout_height="wrap_content"
+              android:layout_gravity="center_horizontal"
+              android:orientation="horizontal">
+
+    <ImageView
+            android:id="@+id/icon"
+            android:src="@drawable/action_eating"
+            android:layout_width="60dp"
+            android:layout_height="60dp" />
+    <LinearLayout
+            android:orientation="vertical"
+            android:layout_gravity="center_vertical"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginLeft="15dp" >
+        <TextView
+                android:id="@+id/text1"
+                android:text="test"
+                android:textColor="#333"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:textSize="18sp" />
+        <TextView
+                android:id="@+id/text2"
+                android:text="test2"
+                android:textColor="#6699CC"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:textSize="14sp" />
+    </LinearLayout>
+</LinearLayout>
diff --git a/samples/Scrumptious/res/layout/main.xml b/samples/Scrumptious/res/layout/main.xml
new file mode 100644
index 000000000..9c93f3521
--- /dev/null
+++ b/samples/Scrumptious/res/layout/main.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        android:orientation="vertical"
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent">
+
+    <fragment android:name="com.facebook.scrumptious.SelectionFragment"
+              android:id="@+id/selectionFragment"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent" />
+    <fragment android:name="com.facebook.scrumptious.SplashFragment"
+              android:id="@+id/splashFragment"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent" />
+    <fragment android:name="com.facebook.widget.UserSettingsFragment"
+              android:id="@+id/userSettingsFragment"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent" />
+</LinearLayout>
+
diff --git a/samples/Scrumptious/res/layout/pickers.xml b/samples/Scrumptious/res/layout/pickers.xml
new file mode 100644
index 000000000..137b5cbbe
--- /dev/null
+++ b/samples/Scrumptious/res/layout/pickers.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:orientation="vertical"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+        >
+    <FrameLayout
+            android:id="@+id/picker_fragment"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            />
+</LinearLayout>
diff --git a/samples/Scrumptious/res/layout/selection.xml b/samples/Scrumptious/res/layout/selection.xml
new file mode 100644
index 000000000..2d849837e
--- /dev/null
+++ b/samples/Scrumptious/res/layout/selection.xml
@@ -0,0 +1,71 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<ScrollView
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:facebook="http://schemas.android.com/apk/res-auto"
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent"
+        android:background="#FFF">
+    <LinearLayout
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent"
+        android:orientation="vertical">
+
+        <LinearLayout
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="20dp"
+            android:gravity="center_horizontal"
+            android:orientation="horizontal" >
+            <com.facebook.widget.ProfilePictureView
+                android:id="@+id/selection_profile_pic"
+                android:layout_height="wrap_content"
+                android:layout_width="wrap_content"
+                android:layout_gravity="center"
+                android:gravity="center_horizontal"
+                facebook:preset_size="small" />
+            <TextView
+                android:id="@+id/selection_user_name"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginLeft="10dp"
+                android:layout_gravity="center"
+                android:textColor="#333"
+                android:textSize="18sp" />
+        </LinearLayout>
+
+        <com.facebook.scrumptious.FullListView
+            android:id="@+id/selection_list"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_margin="20dp"
+            android:background="@drawable/button_border"/>
+
+        <Button
+            android:id="@+id/announce_button"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center"
+            android:textStyle="bold"
+            android:background="@drawable/button_border"
+            android:layout_marginBottom="20dp"
+            android:text="@string/announce"
+            android:gravity="center" />
+
+    </LinearLayout>
+</ScrollView>
diff --git a/samples/Scrumptious/res/layout/splash.xml b/samples/Scrumptious/res/layout/splash.xml
new file mode 100644
index 000000000..a9d43f639
--- /dev/null
+++ b/samples/Scrumptious/res/layout/splash.xml
@@ -0,0 +1,76 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<ScrollView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:background="#303040" >
+
+    <LinearLayout
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent"
+        android:orientation="vertical">
+
+        <LinearLayout
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="30dp"
+            android:gravity="center_horizontal"
+            android:orientation="horizontal" >
+            <ImageView
+                android:id="@+id/splash_icon"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center"
+                android:layout_marginRight="10dp"
+                android:gravity="center"
+                android:src="@drawable/icon" />
+            <TextView
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center"
+                android:gravity="center"
+                android:textColor="#AFDEFE"
+                android:textSize="28sp"
+                android:typeface="serif"
+                android:textStyle="italic"
+                android:text="@string/app_name" />
+        </LinearLayout>
+
+
+        <TextView
+            android:id="@+id/profile_name"
+            android:layout_width="174dp"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="35dp"
+            android:lines="2"
+            android:textSize="17sp"
+            android:text="@string/get_started"
+            android:layout_gravity="center_horizontal"
+            android:gravity="center_horizontal"/>
+
+        <com.facebook.widget.LoginButton
+            android:id="@+id/login_button"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:layout_marginTop="30dp"
+            android:layout_marginBottom="30dp" />
+
+    </LinearLayout>
+</ScrollView>
diff --git a/samples/Scrumptious/res/values/strings.xml b/samples/Scrumptious/res/values/strings.xml
new file mode 100644
index 000000000..bd35bc311
--- /dev/null
+++ b/samples/Scrumptious/res/values/strings.xml
@@ -0,0 +1,72 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<resources>
+    <string name="app_name">Scrumptious</string>
+    <string name="app_id">233936543368280</string>
+    <string name="get_started">To get started, login using Facebook</string>
+    <string name="action_eating">What are you eating?</string>
+    <string name="action_location">Where are you?</string>
+    <string name="action_people">With whom?</string>
+    <string name="action_eating_default">Select a meal</string>
+    <string name="action_location_default">Select a place</string>
+    <string name="action_people_default">Select friends</string>
+    <string name="announce">Announce</string>
+    <string name="login">Login</string>
+    <string name="settings">Settings</string>
+    <string name="select_meal">Select a meal</string>
+    <string name="result_dialog_title">Result</string>
+    <string name="result_dialog_button_text">Thanks!</string>
+    <string name="result_dialog_text">Posted Open Graph action, id: %1$s</string>
+    <string name="progress_dialog_text">Announcing, please wait...</string>
+    <string name="single_user_selected">%1$s</string>
+    <string name="two_users_selected">%1$s and %2$s</string>
+    <string name="multiple_users_selected">%1$s and %2$s others</string>
+    <string name="error_dialog_title">Error</string>
+    <string name="error_dialog_button_text">OK</string>
+    <string name="error_dialog_default_text">No response from server.</string>
+    <string name="no_location_error">Could not obtain your current location</string>
+    <string name="select_picture">Select Picture</string>
+    <string name="error_authentication_retry">An error occurred that requires your attention. %1$s</string>
+    <string name="error_authentication_reopen">An error occurred, please re-login.</string>
+    <string name="error_permission">Please allow us to post on your behalf.</string>
+    <string name="error_server">The server is busy, please retry later.</string>
+    <string name="error_bad_request">An error occurred, please contact the developer with the following message: %1$s</string>
+    <string name="error_unknown">An unknown error occurred, please contact the developer with the following message: %1$s</string>
+
+    <string-array name="food_types">
+        <item>Cheeseburger</item>
+        <item>Pizza</item>
+        <item>Hotdog</item>
+        <item>Italian</item>
+        <item>French</item>
+        <item>Chinese</item>
+        <item>Thai</item>
+        <item>Indian</item>
+    </string-array>
+
+    <string-array name="food_og_urls">
+        <item>http://samples.ogp.me/314483151980285</item> <!-- Cheeseburger -->
+        <item>http://samples.ogp.me/314483221980278</item> <!-- Pizza -->
+        <item>http://samples.ogp.me/314483265313607</item> <!-- Hotdog -->
+        <item>http://samples.ogp.me/314483348646932</item> <!-- Italian -->
+        <item>http://samples.ogp.me/314483375313596</item> <!-- French -->
+        <item>http://samples.ogp.me/314483421980258</item> <!-- Chinese -->
+        <item>http://samples.ogp.me/314483451980255</item> <!-- Thai -->
+        <item>http://samples.ogp.me/314483491980251</item> <!-- Indian -->
+    </string-array>
+</resources>
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/BaseListElement.java b/samples/Scrumptious/src/com/facebook/scrumptious/BaseListElement.java
new file mode 100644
index 000000000..13de99f44
--- /dev/null
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/BaseListElement.java
@@ -0,0 +1,170 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.scrumptious;
+
+import android.content.Intent;
+import android.graphics.drawable.Drawable;
+import android.os.Bundle;
+import android.view.View;
+import android.widget.BaseAdapter;
+import com.facebook.model.OpenGraphAction;
+
+/**
+ * Base class for a list element in the Scrumptious main display, consisting of an
+ * icon to the left, and a two line display to the right.
+ */
+public abstract class BaseListElement {
+
+    private Drawable icon;
+    private String text1;
+    private String text2;
+    private BaseAdapter adapter;
+    private int requestCode;
+
+    /**
+     * Constructs a new list element.
+     *
+     * @param icon the drawable for the icon
+     * @param text1 the first row of text
+     * @param text2 the second row of text
+     * @param requestCode the requestCode to start new Activities with
+     */
+    public BaseListElement(Drawable icon, String text1, String text2, int requestCode) {
+        this.icon = icon;
+        this.text1 = text1;
+        this.text2 = text2;
+        this.requestCode = requestCode;
+    }
+
+    /**
+     * The Adapter associated with this list element (used for notifying that the
+     * underlying dataset has changed).
+     * @param adapter the adapter associated with this element
+     */
+    public void setAdapter(BaseAdapter adapter) {
+        this.adapter = adapter;
+    }
+
+    /**
+     * Returns the icon.
+     *
+     * @return the icon
+     */
+    public Drawable getIcon() {
+        return icon;
+    }
+
+    /**
+     * Returns the first row of text.
+     *
+     * @return the first row of text
+     */
+    public String getText1() {
+        return text1;
+    }
+
+    /**
+     * Returns the second row of text.
+     *
+     * @return the second row of text
+     */
+    public String getText2() {
+        return text2;
+    }
+
+    /**
+     * Returns the requestCode for starting new Activities.
+     *
+     * @return the requestCode
+     */
+    public int getRequestCode() {
+        return requestCode;
+    }
+
+    /**
+     * Sets the first row of text.
+     *
+     * @param text1 text to set on the first row
+     */
+    public void setText1(String text1) {
+        this.text1 = text1;
+        if (adapter != null) {
+            adapter.notifyDataSetChanged();
+        }
+    }
+
+    /**
+     * Sets the second row of text.
+     *
+     * @param text2 text to set on the second row
+     */
+    public void setText2(String text2) {
+        this.text2 = text2;
+        if (adapter != null) {
+            adapter.notifyDataSetChanged();
+        }
+    }
+
+    /**
+     * Returns the OnClickListener associated with this list element. To be
+     * overridden by the subclasses.
+     *
+     * @return the OnClickListener associated with this list element
+     */
+    protected abstract View.OnClickListener getOnClickListener();
+
+    /**
+     * Populate an OpenGraphAction with the results of this list element.
+     *
+     * @param action the action to populate with data
+     */
+    protected abstract void populateOGAction(OpenGraphAction action);
+
+    /**
+     * Callback if the OnClickListener happens to launch a new Activity.
+     *
+     * @param data the data associated with the result
+     */
+    protected void onActivityResult(Intent data) {}
+
+    /**
+     * Save the state of the current element.
+     *
+     * @param bundle the bundle to save to
+     */
+    protected void onSaveInstanceState(Bundle bundle) {}
+
+    /**
+     * Restore the state from the saved bundle. Returns true if the
+     * state was restored.
+     *
+     * @param savedState the bundle to restore from
+     * @return true if state was restored
+     */
+    protected boolean restoreState(Bundle savedState) {
+        return false;
+    }
+
+    /**
+     * Notifies the associated Adapter that the underlying data has changed,
+     * and to re-layout the view.
+     */
+    protected void notifyDataChanged() {
+        adapter.notifyDataSetChanged();
+    }
+
+}
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/FullListView.java b/samples/Scrumptious/src/com/facebook/scrumptious/FullListView.java
new file mode 100644
index 000000000..a210f09fb
--- /dev/null
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/FullListView.java
@@ -0,0 +1,62 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.scrumptious;
+
+import android.content.Context;
+import android.graphics.Rect;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.ListAdapter;
+import android.widget.ListView;
+
+/**
+ * A subclass of ListView that will always show the full list of elements.
+ * This allows a ListView to be embedded inside a ScrollView.
+ */
+public class FullListView extends ListView {
+
+    public FullListView(Context context) {
+        super(context);
+    }
+
+    public FullListView(Context context, AttributeSet attributeSet) {
+        super(context, attributeSet);
+    }
+
+    public FullListView(Context context, AttributeSet attributeSet, int defStyle) {
+        super(context, attributeSet, defStyle);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+        int width = getMeasuredWidth();
+        int height = 0;
+        ListAdapter adapter = getAdapter();
+        int count = adapter.getCount();
+        for (int i = 0; i < count; i++) {
+            View childView = adapter.getView(i, null, this);
+            childView.measure(MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED),
+                    MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));
+            height += childView.getMeasuredHeight();
+        }
+        Rect bgPadding = new Rect();
+        getBackground().getPadding(bgPadding);
+        height += (count - 1) * getDividerHeight() + bgPadding.top + bgPadding.bottom;
+        setMeasuredDimension(width, height);
+    }
+}
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/MainActivity.java b/samples/Scrumptious/src/com/facebook/scrumptious/MainActivity.java
new file mode 100644
index 000000000..a9934df92
--- /dev/null
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/MainActivity.java
@@ -0,0 +1,172 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.scrumptious;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+import android.support.v4.app.FragmentTransaction;
+import android.view.Menu;
+import android.view.MenuItem;
+import com.facebook.Session;
+import com.facebook.SessionState;
+import com.facebook.UiLifecycleHelper;
+
+public class MainActivity extends FragmentActivity {
+
+    private static final int SPLASH = 0;
+    private static final int SELECTION = 1;
+    private static final int SETTINGS = 2;
+    private static final int FRAGMENT_COUNT = SETTINGS +1;
+
+    private Fragment[] fragments = new Fragment[FRAGMENT_COUNT];
+    private MenuItem settings;
+    private boolean isResumed = false;
+    private UiLifecycleHelper uiHelper;
+    private Session.StatusCallback callback = new Session.StatusCallback() {
+        @Override
+        public void call(Session session, SessionState state, Exception exception) {
+            onSessionStateChange(session, state, exception);
+        }
+    };
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        uiHelper = new UiLifecycleHelper(this, callback);
+        uiHelper.onCreate(savedInstanceState);
+
+        setContentView(R.layout.main);
+
+        FragmentManager fm = getSupportFragmentManager();
+        fragments[SPLASH] = fm.findFragmentById(R.id.splashFragment);
+        fragments[SELECTION] = fm.findFragmentById(R.id.selectionFragment);
+        fragments[SETTINGS] = fm.findFragmentById(R.id.userSettingsFragment);
+
+        FragmentTransaction transaction = fm.beginTransaction();
+        for(int i = 0; i < fragments.length; i++) {
+            transaction.hide(fragments[i]);
+        }
+        transaction.commit();
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        uiHelper.onResume();
+        isResumed = true;
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        uiHelper.onPause();
+        isResumed = false;
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        uiHelper.onActivityResult(requestCode, resultCode, data);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        uiHelper.onDestroy();
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        uiHelper.onSaveInstanceState(outState);
+    }
+
+    @Override
+    protected void onResumeFragments() {
+        super.onResumeFragments();
+        Session session = Session.getActiveSession();
+
+        if (session != null && session.isOpened()) {
+            // if the session is already open, try to show the selection fragment
+            showFragment(SELECTION, false);
+        } else {
+            // otherwise present the splash screen and ask the user to login.
+            showFragment(SPLASH, false);
+        }
+    }
+
+    @Override
+    public boolean onPrepareOptionsMenu(Menu menu) {
+        // only add the menu when the selection fragment is showing
+        if (fragments[SELECTION].isVisible()) {
+            if (menu.size() == 0) {
+                settings = menu.add(R.string.settings);
+            }
+            return true;
+        } else {
+            menu.clear();
+            settings = null;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        if (item.equals(settings)) {
+            showFragment(SETTINGS, true);
+            return true;
+        }
+        return false;
+    }
+
+    private void onSessionStateChange(Session session, SessionState state, Exception exception) {
+        if (isResumed) {
+            FragmentManager manager = getSupportFragmentManager();
+            int backStackSize = manager.getBackStackEntryCount();
+            for (int i = 0; i < backStackSize; i++) {
+                manager.popBackStack();
+            }
+            // check for the OPENED state instead of session.isOpened() since for the
+            // OPENED_TOKEN_UPDATED state, the selection fragment should already be showing.
+            if (state.equals(SessionState.OPENED)) {
+                showFragment(SELECTION, false);
+            } else if (state.isClosed()) {
+                showFragment(SPLASH, false);
+            }
+        }
+    }
+
+    private void showFragment(int fragmentIndex, boolean addToBackStack) {
+        FragmentManager fm = getSupportFragmentManager();
+        FragmentTransaction transaction = fm.beginTransaction();
+        for (int i = 0; i < fragments.length; i++) {
+            if (i == fragmentIndex) {
+                transaction.show(fragments[i]);
+            } else {
+                transaction.hide(fragments[i]);
+            }
+        }
+        if (addToBackStack) {
+            transaction.addToBackStack(null);
+        }
+        transaction.commit();
+    }
+}
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/PickerActivity.java b/samples/Scrumptious/src/com/facebook/scrumptious/PickerActivity.java
new file mode 100644
index 000000000..41a81894e
--- /dev/null
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/PickerActivity.java
@@ -0,0 +1,233 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.scrumptious;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.location.Criteria;
+import android.location.Location;
+import android.location.LocationListener;
+import android.location.LocationManager;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Looper;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+import com.facebook.FacebookException;
+import com.facebook.widget.FriendPickerFragment;
+import com.facebook.widget.PickerFragment;
+import com.facebook.widget.PlacePickerFragment;
+
+/**
+ * The PickerActivity enhances the Friend or Place Picker by adding a title
+ * and a Done button. The selection results are saved in the ScrumptiousApplication
+ * instance.
+ */
+public class PickerActivity extends FragmentActivity {
+    public static final Uri FRIEND_PICKER = Uri.parse("picker://friend");
+    public static final Uri PLACE_PICKER = Uri.parse("picker://place");
+
+    private static final int SEARCH_RADIUS_METERS = 1000;
+    private static final int SEARCH_RESULT_LIMIT = 50;
+    private static final String SEARCH_TEXT = "Restaurant";
+    private static final int LOCATION_CHANGE_THRESHOLD = 50; // meters
+
+    private static final Location SAN_FRANCISCO_LOCATION = new Location("") {{
+            setLatitude(37.7750);
+            setLongitude(-122.4183);
+    }};
+
+    private FriendPickerFragment friendPickerFragment;
+    private PlacePickerFragment placePickerFragment;
+    private LocationListener locationListener;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.pickers);
+
+        Bundle args = getIntent().getExtras();
+        FragmentManager manager = getSupportFragmentManager();
+        Fragment fragmentToShow = null;
+        Uri intentUri = getIntent().getData();
+
+        if (FRIEND_PICKER.equals(intentUri)) {
+            if (savedInstanceState == null) {
+                friendPickerFragment = new FriendPickerFragment(args);
+            } else {
+                friendPickerFragment = (FriendPickerFragment) manager.findFragmentById(R.id.picker_fragment);;
+            }
+
+            friendPickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
+                @Override
+                public void onError(PickerFragment<?> fragment, FacebookException error) {
+                    PickerActivity.this.onError(error);
+                }
+            });
+            friendPickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
+                @Override
+                public void onDoneButtonClicked(PickerFragment<?> fragment) {
+                    finishActivity();
+                }
+            });
+            fragmentToShow = friendPickerFragment;
+
+        } else if (PLACE_PICKER.equals(intentUri)) {
+            if (savedInstanceState == null) {
+                placePickerFragment = new PlacePickerFragment(args);
+            } else {
+                placePickerFragment = (PlacePickerFragment) manager.findFragmentById(R.id.picker_fragment);
+            }
+            placePickerFragment.setOnSelectionChangedListener(new PickerFragment.OnSelectionChangedListener() {
+                @Override
+                public void onSelectionChanged(PickerFragment<?> fragment) {
+                    finishActivity(); // call finish since you can only pick one place
+                }
+            });
+            placePickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
+                @Override
+                public void onError(PickerFragment<?> fragment, FacebookException error) {
+                    PickerActivity.this.onError(error);
+                }
+            });
+            placePickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
+                @Override
+                public void onDoneButtonClicked(PickerFragment<?> fragment) {
+                    finishActivity();
+                }
+            });
+            fragmentToShow = placePickerFragment;
+        } else {
+            // Nothing to do, finish
+            setResult(RESULT_CANCELED);
+            finish();
+            return;
+        }
+
+        manager.beginTransaction().replace(R.id.picker_fragment, fragmentToShow).commit();
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        if (FRIEND_PICKER.equals(getIntent().getData())) {
+            try {
+                friendPickerFragment.loadData(false);
+            } catch (Exception ex) {
+                onError(ex);
+            }
+        } else if (PLACE_PICKER.equals(getIntent().getData())) {
+            try {
+                Location location = null;
+                Criteria criteria = new Criteria();
+                LocationManager locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
+                String bestProvider = locationManager.getBestProvider(criteria, false);
+                if (bestProvider != null) {
+                    location = locationManager.getLastKnownLocation(bestProvider);
+                    if (locationManager.isProviderEnabled(bestProvider) && locationListener == null) {
+                        locationListener = new LocationListener() {
+                            @Override
+                            public void onLocationChanged(Location location) {
+                                float distance = location.distanceTo(placePickerFragment.getLocation());
+                                if (distance >= LOCATION_CHANGE_THRESHOLD) {
+                                    placePickerFragment.setLocation(location);
+                                    placePickerFragment.loadData(true);
+                                }
+                            }
+                            @Override
+                            public void onStatusChanged(String s, int i, Bundle bundle) {
+                            }
+                            @Override
+                            public void onProviderEnabled(String s) {
+                            }
+                            @Override
+                            public void onProviderDisabled(String s) {
+                            }
+                        };
+                        locationManager.requestLocationUpdates(bestProvider, 1, LOCATION_CHANGE_THRESHOLD,
+                                locationListener, Looper.getMainLooper());
+                    }
+                }
+                if (location == null) {
+                    String model = Build.MODEL;
+                    if (model.equals("sdk") || model.equals("google_sdk") || model.contains("x86")) {
+                        // this may be the emulator, pretend we're in an exotic place
+                        location = SAN_FRANCISCO_LOCATION;
+                    }
+                }
+                if (location != null) {
+                    placePickerFragment.setLocation(location);
+                    placePickerFragment.setRadiusInMeters(SEARCH_RADIUS_METERS);
+                    placePickerFragment.setSearchText(SEARCH_TEXT);
+                    placePickerFragment.setResultsLimit(SEARCH_RESULT_LIMIT);
+                    placePickerFragment.loadData(false);
+                } else {
+                    onError(getResources().getString(R.string.no_location_error), true);
+                }
+            } catch (Exception ex) {
+                onError(ex);
+            }
+        }
+    }
+
+    @Override
+    protected void onStop() {
+        super.onStop();
+        if (locationListener != null) {
+            LocationManager locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
+            locationManager.removeUpdates(locationListener);
+            locationListener = null;
+        }
+    }
+
+    private void onError(Exception error) {
+        onError(error.getLocalizedMessage(), false);
+    }
+
+    private void onError(String error, final boolean finishActivity) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setTitle(R.string.error_dialog_title).
+                setMessage(error).
+                setPositiveButton(R.string.error_dialog_button_text, new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialogInterface, int i) {
+                        if (finishActivity) {
+                            finishActivity();
+                        }
+                    }
+                });
+        builder.show();
+    }
+
+    private void finishActivity() {
+        ScrumptiousApplication app = (ScrumptiousApplication) getApplication();
+        if (FRIEND_PICKER.equals(getIntent().getData())) {
+            if (friendPickerFragment != null) {
+                app.setSelectedUsers(friendPickerFragment.getSelection());
+            }
+        } else if (PLACE_PICKER.equals(getIntent().getData())) {
+            if (placePickerFragment != null) {
+                app.setSelectedPlace(placePickerFragment.getSelection());
+            }
+        }
+        setResult(RESULT_OK, null);
+        finish();
+    }
+}
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/ScrumptiousApplication.java b/samples/Scrumptious/src/com/facebook/scrumptious/ScrumptiousApplication.java
new file mode 100644
index 000000000..79e5857b0
--- /dev/null
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/ScrumptiousApplication.java
@@ -0,0 +1,48 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.scrumptious;
+
+import android.app.Application;
+import com.facebook.model.GraphPlace;
+import com.facebook.model.GraphUser;
+
+import java.util.List;
+
+/**
+ * Use a custom Application class to pass state data between Activities.
+ */
+public class ScrumptiousApplication extends Application {
+
+    private List<GraphUser> selectedUsers;
+    private GraphPlace selectedPlace;
+
+    public List<GraphUser> getSelectedUsers() {
+        return selectedUsers;
+    }
+
+    public void setSelectedUsers(List<GraphUser> users) {
+        selectedUsers = users;
+    }
+
+    public GraphPlace getSelectedPlace() {
+        return selectedPlace;
+    }
+
+    public void setSelectedPlace(GraphPlace place) {
+        this.selectedPlace = place;
+    }
+}
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/SelectionFragment.java b/samples/Scrumptious/src/com/facebook/scrumptious/SelectionFragment.java
new file mode 100644
index 000000000..2a9b43672
--- /dev/null
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/SelectionFragment.java
@@ -0,0 +1,721 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.scrumptious;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.ProgressDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.*;
+import com.facebook.*;
+import com.facebook.model.*;
+import com.facebook.widget.ProfilePictureView;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Fragment that represents the main selection screen for Scrumptious.
+ */
+public class SelectionFragment extends Fragment {
+
+    private static final String TAG = "SelectionFragment";
+    private static final String POST_ACTION_PATH = "me/fb_sample_scrumps:eat";
+    private static final String PENDING_ANNOUNCE_KEY = "pendingAnnounce";
+    private static final Uri M_FACEBOOK_URL = Uri.parse("http://m.facebook.com");
+
+    private static final int REAUTH_ACTIVITY_CODE = 100;
+    private static final List<String> PERMISSIONS = Arrays.asList("publish_actions");
+
+    private Button announceButton;
+    private ListView listView;
+    private ProgressDialog progressDialog;
+    private List<BaseListElement> listElements;
+    private ProfilePictureView profilePictureView;
+    private TextView userNameView;
+    private boolean pendingAnnounce;
+
+    private UiLifecycleHelper uiHelper;
+    private Session.StatusCallback callback = new Session.StatusCallback() {
+        @Override
+        public void call(final Session session, final SessionState state, final Exception exception) {
+            onSessionStateChange(session, state, exception);
+        }
+    };
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        uiHelper = new UiLifecycleHelper(getActivity(), callback);
+        uiHelper.onCreate(savedInstanceState);
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        uiHelper.onResume();
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        super.onCreateView(inflater, container, savedInstanceState);
+        View view = inflater.inflate(R.layout.selection, container, false);
+
+        profilePictureView = (ProfilePictureView) view.findViewById(R.id.selection_profile_pic);
+        profilePictureView.setCropped(true);
+        userNameView = (TextView) view.findViewById(R.id.selection_user_name);
+        announceButton = (Button) view.findViewById(R.id.announce_button);
+        listView = (ListView) view.findViewById(R.id.selection_list);
+
+        announceButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                handleAnnounce();
+            }
+        });
+        init(savedInstanceState);
+
+        return view;
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        if (requestCode == REAUTH_ACTIVITY_CODE) {
+            uiHelper.onActivityResult(requestCode, resultCode, data);
+        } else if (resultCode == Activity.RESULT_OK && requestCode >= 0 && requestCode < listElements.size()) {
+            listElements.get(requestCode).onActivityResult(data);
+        }
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle bundle) {
+        super.onSaveInstanceState(bundle);
+        for (BaseListElement listElement : listElements) {
+            listElement.onSaveInstanceState(bundle);
+        }
+        bundle.putBoolean(PENDING_ANNOUNCE_KEY, pendingAnnounce);
+        uiHelper.onSaveInstanceState(bundle);
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        uiHelper.onPause();
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        uiHelper.onDestroy();
+    }
+
+    /**
+     * Notifies that the session token has been updated.
+     */
+    private void tokenUpdated() {
+        if (pendingAnnounce) {
+            handleAnnounce();
+        }
+    }
+
+    private void onSessionStateChange(final Session session, SessionState state, Exception exception) {
+        if (session != null && session.isOpened()) {
+            if (state.equals(SessionState.OPENED_TOKEN_UPDATED)) {
+                tokenUpdated();
+            } else {
+                makeMeRequest(session);
+            }
+        }
+    }
+
+    private void makeMeRequest(final Session session) {
+        Request request = Request.newMeRequest(session, new Request.GraphUserCallback() {
+            @Override
+            public void onCompleted(GraphUser user, Response response) {
+                if (session == Session.getActiveSession()) {
+                    if (user != null) {
+                        profilePictureView.setProfileId(user.getId());
+                        userNameView.setText(user.getName());
+                    }
+                }
+                if (response.getError() != null) {
+                    handleError(response.getError());
+                }
+            }
+        });
+        request.executeAsync();
+
+    }
+
+    /**
+     * Resets the view to the initial defaults.
+     */
+    private void init(Bundle savedInstanceState) {
+        announceButton.setEnabled(false);
+
+        listElements = new ArrayList<BaseListElement>();
+
+        listElements.add(new EatListElement(0));
+        listElements.add(new LocationListElement(1));
+        listElements.add(new PeopleListElement(2));
+
+        if (savedInstanceState != null) {
+            for (BaseListElement listElement : listElements) {
+                listElement.restoreState(savedInstanceState);
+            }
+            pendingAnnounce = savedInstanceState.getBoolean(PENDING_ANNOUNCE_KEY, false);
+        }
+
+        listView.setAdapter(new ActionListAdapter(getActivity(), R.id.selection_list, listElements));
+
+        Session session = Session.getActiveSession();
+        if (session != null && session.isOpened()) {
+            makeMeRequest(session);
+        }
+    }
+
+    private void handleAnnounce() {
+        pendingAnnounce = false;
+        Session session = Session.getActiveSession();
+
+        if (session == null || !session.isOpened()) {
+            return;
+        }
+
+        List<String> permissions = session.getPermissions();
+        if (!permissions.containsAll(PERMISSIONS)) {
+            pendingAnnounce = true;
+            requestPublishPermissions(session);
+            return;
+        }
+
+        // Show a progress dialog because sometimes the requests can take a while.
+        progressDialog = ProgressDialog.show(getActivity(), "",
+                getActivity().getResources().getString(R.string.progress_dialog_text), true);
+
+        // Run this in a background thread since some of the populate methods may take
+        // a non-trivial amount of time.
+        AsyncTask<Void, Void, Response> task = new AsyncTask<Void, Void, Response>() {
+
+            @Override
+            protected Response doInBackground(Void... voids) {
+                EatAction eatAction = GraphObject.Factory.create(EatAction.class);
+                for (BaseListElement element : listElements) {
+                    element.populateOGAction(eatAction);
+                }
+                Request request = new Request(Session.getActiveSession(),
+                        POST_ACTION_PATH, null, HttpMethod.POST);
+                request.setGraphObject(eatAction);
+                return request.executeAndWait();
+            }
+
+            @Override
+            protected void onPostExecute(Response response) {
+                onPostActionResponse(response);
+             }
+        };
+
+        task.execute();
+    }
+
+    private void requestPublishPermissions(Session session) {
+        if (session != null) {
+            Session.NewPermissionsRequest newPermissionsRequest = new Session.NewPermissionsRequest(this, PERMISSIONS)
+                    // demonstrate how to set an audience for the publish permissions,
+                    // if none are set, this defaults to FRIENDS
+                    .setDefaultAudience(SessionDefaultAudience.FRIENDS)
+                    .setRequestCode(REAUTH_ACTIVITY_CODE);
+            session.requestNewPublishPermissions(newPermissionsRequest);
+        }
+    }
+
+    private void onPostActionResponse(Response response) {
+        if (progressDialog != null) {
+            progressDialog.dismiss();
+            progressDialog = null;
+        }
+        if (getActivity() == null) {
+            // if the user removes the app from the website, then a request will
+            // have caused the session to close (since the token is no longer valid),
+            // which means the splash fragment will be shown rather than this one,
+            // causing activity to be null. If the activity is null, then we cannot
+            // show any dialogs, so we return.
+            return;
+        }
+
+        PostResponse postResponse = response.getGraphObjectAs(PostResponse.class);
+
+        if (postResponse != null && postResponse.getId() != null) {
+            String dialogBody = String.format(getString(R.string.result_dialog_text), postResponse.getId());
+            new AlertDialog.Builder(getActivity())
+                    .setPositiveButton(R.string.result_dialog_button_text, null)
+                    .setTitle(R.string.result_dialog_title)
+                    .setMessage(dialogBody)
+                    .show();
+            init(null);
+        } else {
+            handleError(response.getError());
+        }
+    }
+
+    private void handleError(FacebookRequestError error) {
+        DialogInterface.OnClickListener listener = null;
+        String dialogBody = null;
+
+        if (error == null) {
+            dialogBody = getString(R.string.error_dialog_default_text);
+        } else {
+            switch (error.getCategory()) {
+                case AUTHENTICATION_RETRY:
+                    // tell the user what happened by getting the message id, and
+                    // retry the operation later
+                    String userAction = (error.shouldNotifyUser()) ? "" :
+                            getString(error.getUserActionMessageId());
+                    dialogBody = getString(R.string.error_authentication_retry, userAction);
+                    listener = new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialogInterface, int i) {
+                            Intent intent = new Intent(Intent.ACTION_VIEW, M_FACEBOOK_URL);
+                            startActivity(intent);
+                        }
+                    };
+                    break;
+
+                case AUTHENTICATION_REOPEN_SESSION:
+                    // close the session and reopen it.
+                    dialogBody = getString(R.string.error_authentication_reopen);
+                    listener = new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialogInterface, int i) {
+                            Session session = Session.getActiveSession();
+                            if (session != null && !session.isClosed()) {
+                                session.closeAndClearTokenInformation();
+                            }
+                        }
+                    };
+                    break;
+
+                case PERMISSION:
+                    // request the publish permission
+                    dialogBody = getString(R.string.error_permission);
+                    listener = new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialogInterface, int i) {
+                            pendingAnnounce = true;
+                            requestPublishPermissions(Session.getActiveSession());
+                        }
+                    };
+                    break;
+
+                case SERVER:
+                case THROTTLING:
+                    // this is usually temporary, don't clear the fields, and
+                    // ask the user to try again
+                    dialogBody = getString(R.string.error_server);
+                    break;
+
+                case BAD_REQUEST:
+                    // this is likely a coding error, ask the user to file a bug
+                    dialogBody = getString(R.string.error_bad_request, error.getErrorMessage());
+                    break;
+
+                case OTHER:
+                case CLIENT:
+                default:
+                    // an unknown issue occurred, this could be a code error, or
+                    // a server side issue, log the issue, and either ask the
+                    // user to retry, or file a bug
+                    dialogBody = getString(R.string.error_unknown, error.getErrorMessage());
+                    break;
+            }
+        }
+
+        new AlertDialog.Builder(getActivity())
+                .setPositiveButton(R.string.error_dialog_button_text, listener)
+                .setTitle(R.string.error_dialog_title)
+                .setMessage(dialogBody)
+                .show();
+    }
+
+    private void startPickerActivity(Uri data, int requestCode) {
+        Intent intent = new Intent();
+        intent.setData(data);
+        intent.setClass(getActivity(), PickerActivity.class);
+        startActivityForResult(intent, requestCode);
+    }
+
+    /**
+     * Interface representing the Meal Open Graph object.
+     */
+    private interface MealGraphObject extends GraphObject {
+        public String getUrl();
+        public void setUrl(String url);
+
+        public String getId();
+        public void setId(String id);
+    }
+
+    /**
+     * Interface representing the Eat action.
+     */
+    private interface EatAction extends OpenGraphAction {
+        public MealGraphObject getMeal();
+        public void setMeal(MealGraphObject meal);
+    }
+
+    /**
+     * Used to inspect the response from posting an action
+     */
+    private interface PostResponse extends GraphObject {
+        String getId();
+    }
+
+    private class EatListElement extends BaseListElement {
+
+        private static final String FOOD_KEY = "food";
+        private static final String FOOD_URL_KEY = "food_url";
+
+        private final String[] foodChoices;
+        private final String[] foodUrls;
+        private String foodChoiceUrl = null;
+        private String foodChoice = null;
+
+        public EatListElement(int requestCode) {
+            super(getActivity().getResources().getDrawable(R.drawable.action_eating),
+                  getActivity().getResources().getString(R.string.action_eating),
+                  getActivity().getResources().getString(R.string.action_eating_default),
+                  requestCode);
+            foodChoices = getActivity().getResources().getStringArray(R.array.food_types);
+            foodUrls = getActivity().getResources().getStringArray(R.array.food_og_urls);
+        }
+
+        @Override
+        protected View.OnClickListener getOnClickListener() {
+            return new View.OnClickListener() {
+                @Override
+                public void onClick(View view) {
+                    showMealOptions();
+                }
+            };
+        }
+
+        @Override
+        protected void populateOGAction(OpenGraphAction action) {
+            if (foodChoiceUrl != null) {
+                EatAction eatAction = action.cast(EatAction.class);
+                MealGraphObject meal = GraphObject.Factory.create(MealGraphObject.class);
+                meal.setUrl(foodChoiceUrl);
+                eatAction.setMeal(meal);
+            }
+        }
+
+        @Override
+        protected void onSaveInstanceState(Bundle bundle) {
+            if (foodChoice != null && foodChoiceUrl != null) {
+                bundle.putString(FOOD_KEY, foodChoice);
+                bundle.putString(FOOD_URL_KEY, foodChoiceUrl);
+            }
+        }
+
+        @Override
+        protected boolean restoreState(Bundle savedState) {
+            String food = savedState.getString(FOOD_KEY);
+            String foodUrl = savedState.getString(FOOD_URL_KEY);
+            if (food != null && foodUrl != null) {
+                foodChoice = food;
+                foodChoiceUrl = foodUrl;
+                setFoodText();
+                return true;
+            }
+            return false;
+        }
+
+        private void showMealOptions() {
+            String title = getActivity().getResources().getString(R.string.select_meal);
+            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
+            builder.setTitle(title).
+                    setCancelable(true).
+                    setItems(foodChoices, new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialogInterface, int i) {
+                            foodChoice = foodChoices[i];
+                            foodChoiceUrl = foodUrls[i];
+                            setFoodText();
+                            notifyDataChanged();
+                        }
+                    });
+            builder.show();
+        }
+
+        private void setFoodText() {
+            if (foodChoice != null && foodChoiceUrl != null) {
+                setText2(foodChoice);
+                announceButton.setEnabled(true);
+            } else {
+                setText2(getActivity().getResources().getString(R.string.action_eating_default));
+                announceButton.setEnabled(false);
+            }
+        }
+    }
+
+    private class PeopleListElement extends BaseListElement {
+
+        private static final String FRIENDS_KEY = "friends";
+
+        private List<GraphUser> selectedUsers;
+
+        public PeopleListElement(int requestCode) {
+            super(getActivity().getResources().getDrawable(R.drawable.action_people),
+                  getActivity().getResources().getString(R.string.action_people),
+                  getActivity().getResources().getString(R.string.action_people_default),
+                  requestCode);
+        }
+
+        @Override
+        protected View.OnClickListener getOnClickListener() {
+            return new View.OnClickListener() {
+                @Override
+                public void onClick(View view) {
+                    startPickerActivity(PickerActivity.FRIEND_PICKER, getRequestCode());
+                }
+            };
+        }
+
+        @Override
+        protected void onActivityResult(Intent data) {
+            selectedUsers = ((ScrumptiousApplication) getActivity().getApplication()).getSelectedUsers();
+            setUsersText();
+            notifyDataChanged();
+        }
+
+        @Override
+        protected void populateOGAction(OpenGraphAction action) {
+            if (selectedUsers != null) {
+                action.setTags(selectedUsers);
+            }
+        }
+
+        @Override
+        protected void onSaveInstanceState(Bundle bundle) {
+            if (selectedUsers != null) {
+                bundle.putByteArray(FRIENDS_KEY, getByteArray(selectedUsers));
+            }
+        }
+
+        @Override
+        protected boolean restoreState(Bundle savedState) {
+            byte[] bytes = savedState.getByteArray(FRIENDS_KEY);
+            if (bytes != null) {
+                selectedUsers = restoreByteArray(bytes);
+                setUsersText();
+                return true;
+            }
+            return false;
+        }
+
+        private void setUsersText() {
+            String text = null;
+            if (selectedUsers != null) {
+                if (selectedUsers.size() == 1) {
+                    text = String.format(getResources().getString(R.string.single_user_selected),
+                            selectedUsers.get(0).getName());
+                } else if (selectedUsers.size() == 2) {
+                    text = String.format(getResources().getString(R.string.two_users_selected),
+                            selectedUsers.get(0).getName(), selectedUsers.get(1).getName());
+                } else if (selectedUsers.size() > 2) {
+                    text = String.format(getResources().getString(R.string.multiple_users_selected),
+                            selectedUsers.get(0).getName(), (selectedUsers.size() - 1));
+                }
+            }
+            if (text == null) {
+                text = getResources().getString(R.string.action_people_default);
+            }
+            setText2(text);
+        }
+
+        private byte[] getByteArray(List<GraphUser> users) {
+            // convert the list of GraphUsers to a list of String where each element is
+            // the JSON representation of the GraphUser so it can be stored in a Bundle
+            List<String> usersAsString = new ArrayList<String>(users.size());
+
+            for (GraphUser user : users) {
+                usersAsString.add(user.getInnerJSONObject().toString());
+            }
+            try {
+                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+                new ObjectOutputStream(outputStream).writeObject(usersAsString);
+                return outputStream.toByteArray();
+            } catch (IOException e) {
+                Log.e(TAG, "Unable to serialize users.", e);
+            }
+            return null;
+        }
+
+        private List<GraphUser> restoreByteArray(byte[] bytes) {
+            try {
+                @SuppressWarnings("unchecked")
+                List<String> usersAsString =
+                        (List<String>) (new ObjectInputStream(new ByteArrayInputStream(bytes))).readObject();
+                if (usersAsString != null) {
+                    List<GraphUser> users = new ArrayList<GraphUser>(usersAsString.size());
+                    for (String user : usersAsString) {
+                        GraphUser graphUser = GraphObject.Factory
+                                .create(new JSONObject(user), GraphUser.class);
+                        users.add(graphUser);
+                    }
+                    return users;
+                }
+            } catch (ClassNotFoundException e) {
+                Log.e(TAG, "Unable to deserialize users.", e);
+            } catch (IOException e) {
+                Log.e(TAG, "Unable to deserialize users.", e);
+            } catch (JSONException e) {
+                Log.e(TAG, "Unable to deserialize users.", e);
+            }
+            return null;
+        }
+    }
+
+    private class LocationListElement extends BaseListElement {
+
+        private static final String PLACE_KEY = "place";
+
+        private GraphPlace selectedPlace = null;
+
+        public LocationListElement(int requestCode) {
+            super(getActivity().getResources().getDrawable(R.drawable.action_location),
+                  getActivity().getResources().getString(R.string.action_location),
+                  getActivity().getResources().getString(R.string.action_location_default),
+                  requestCode);
+        }
+
+        @Override
+        protected View.OnClickListener getOnClickListener() {
+            return new View.OnClickListener() {
+                @Override
+                public void onClick(View view) {
+                    startPickerActivity(PickerActivity.PLACE_PICKER, getRequestCode());
+                }
+            };
+        }
+
+        @Override
+        protected void onActivityResult(Intent data) {
+            selectedPlace = ((ScrumptiousApplication) getActivity().getApplication()).getSelectedPlace();
+            setPlaceText();
+            notifyDataChanged();
+        }
+
+        @Override
+        protected void populateOGAction(OpenGraphAction action) {
+            if (selectedPlace != null) {
+                action.setPlace(selectedPlace);
+            }
+        }
+
+        @Override
+        protected void onSaveInstanceState(Bundle bundle) {
+            if (selectedPlace != null) {
+                bundle.putString(PLACE_KEY, selectedPlace.getInnerJSONObject().toString());
+            }
+        }
+
+        @Override
+        protected boolean restoreState(Bundle savedState) {
+            String place = savedState.getString(PLACE_KEY);
+            if (place != null) {
+                try {
+                    selectedPlace = GraphObject.Factory
+                            .create(new JSONObject(place), GraphPlace.class);
+                    setPlaceText();
+                    return true;
+                } catch (JSONException e) {
+                    Log.e(TAG, "Unable to deserialize place.", e);
+                }
+            }
+            return false;
+        }
+
+        private void setPlaceText() {
+            String text = null;
+            if (selectedPlace != null) {
+                text = selectedPlace.getName();
+            }
+            if (text == null) {
+                text = getResources().getString(R.string.action_location_default);
+            }
+            setText2(text);
+        }
+
+    }
+
+    private class ActionListAdapter extends ArrayAdapter<BaseListElement> {
+        private List<BaseListElement> listElements;
+
+        public ActionListAdapter(Context context, int resourceId, List<BaseListElement> listElements) {
+            super(context, resourceId, listElements);
+            this.listElements = listElements;
+            for (int i = 0; i < listElements.size(); i++) {
+                listElements.get(i).setAdapter(this);
+            }
+        }
+
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+            View view = convertView;
+            if (view == null) {
+                LayoutInflater inflater =
+                        (LayoutInflater) getActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                view = inflater.inflate(R.layout.listitem, null);
+            }
+
+            BaseListElement listElement = listElements.get(position);
+            if (listElement != null) {
+                view.setOnClickListener(listElement.getOnClickListener());
+                ImageView icon = (ImageView) view.findViewById(R.id.icon);
+                TextView text1 = (TextView) view.findViewById(R.id.text1);
+                TextView text2 = (TextView) view.findViewById(R.id.text2);
+                if (icon != null) {
+                    icon.setImageDrawable(listElement.getIcon());
+                }
+                if (text1 != null) {
+                    text1.setText(listElement.getText1());
+                }
+                if (text2 != null) {
+                    text2.setText(listElement.getText2());
+                }
+            }
+            return view;
+        }
+
+    }
+}
diff --git a/samples/Scrumptious/src/com/facebook/scrumptious/SplashFragment.java b/samples/Scrumptious/src/com/facebook/scrumptious/SplashFragment.java
new file mode 100644
index 000000000..d75436d49
--- /dev/null
+++ b/samples/Scrumptious/src/com/facebook/scrumptious/SplashFragment.java
@@ -0,0 +1,31 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.scrumptious;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+public class SplashFragment extends Fragment {
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        View view = inflater.inflate(R.layout.splash, container, false);
+        return view;
+    }
+}
diff --git a/samples/SessionLoginSample/.classpath b/samples/SessionLoginSample/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/SessionLoginSample/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/SessionLoginSample/.project b/samples/SessionLoginSample/.project
new file mode 100644
index 000000000..d8c641423
--- /dev/null
+++ b/samples/SessionLoginSample/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SessionLoginSample</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/samples/SessionLoginSample/AndroidManifest.xml b/samples/SessionLoginSample/AndroidManifest.xml
new file mode 100644
index 000000000..c1272829b
--- /dev/null
+++ b/samples/SessionLoginSample/AndroidManifest.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.samples.sessionlogin"
+    android:versionCode="1"
+    android:versionName="1.0" >
+
+    <uses-sdk android:minSdkVersion="8" />
+    <uses-permission android:name="android.permission.INTERNET"/>
+
+    <application
+        android:icon="@drawable/icon"
+        android:label="@string/app_name" >
+        <activity
+            android:name=".SessionLoginSampleActivity"
+            android:label="@string/app_name"
+            android:windowSoftInputMode="adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+        <activity
+                android:name=".LoginUsingActivityActivity">
+        </activity>
+        <activity
+                android:name=".LoginUsingCustomFragmentActivity">
+        </activity>
+        <activity android:name="com.facebook.LoginActivity"
+                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
+                  android:label="@string/app_name" />
+        <activity android:name=".LoginUsingLoginFragmentActivity"/>
+        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/applicationId" />
+    </application>
+
+</manifest>
diff --git a/samples/SessionLoginSample/SessionLoginSample.iml b/samples/SessionLoginSample/SessionLoginSample.iml
new file mode 100644
index 000000000..4aac86509
--- /dev/null
+++ b/samples/SessionLoginSample/SessionLoginSample.iml
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/samples/SessionLoginSample/ant.properties b/samples/SessionLoginSample/ant.properties
new file mode 100644
index 000000000..939105d52
--- /dev/null
+++ b/samples/SessionLoginSample/ant.properties
@@ -0,0 +1,18 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
+java.compilerargs=-Xlint -Werror
diff --git a/samples/SessionLoginSample/build.xml b/samples/SessionLoginSample/build.xml
new file mode 100644
index 000000000..4f044bbee
--- /dev/null
+++ b/samples/SessionLoginSample/build.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="SessionLoginSample" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties" />
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties" />
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env" />
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME" />
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties" />
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+    />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true" />
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml" />
+
+</project>
diff --git a/samples/SessionLoginSample/proguard-project.txt b/samples/SessionLoginSample/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/SessionLoginSample/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/samples/SessionLoginSample/project.properties b/samples/SessionLoginSample/project.properties
new file mode 100644
index 000000000..cee0509c6
--- /dev/null
+++ b/samples/SessionLoginSample/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+android.library.reference.1=../../facebook
diff --git a/samples/SessionLoginSample/res/drawable-hdpi/icon.png b/samples/SessionLoginSample/res/drawable-hdpi/icon.png
new file mode 100644
index 000000000..78d41ad5f
Binary files /dev/null and b/samples/SessionLoginSample/res/drawable-hdpi/icon.png differ
diff --git a/samples/SessionLoginSample/res/drawable-mdpi/icon.png b/samples/SessionLoginSample/res/drawable-mdpi/icon.png
new file mode 100644
index 000000000..22598aa33
Binary files /dev/null and b/samples/SessionLoginSample/res/drawable-mdpi/icon.png differ
diff --git a/samples/SessionLoginSample/res/drawable-xhdpi/icon.png b/samples/SessionLoginSample/res/drawable-xhdpi/icon.png
new file mode 100644
index 000000000..a2c3cb4b2
Binary files /dev/null and b/samples/SessionLoginSample/res/drawable-xhdpi/icon.png differ
diff --git a/samples/SessionLoginSample/res/drawable/icon.png b/samples/SessionLoginSample/res/drawable/icon.png
new file mode 100644
index 000000000..22598aa33
Binary files /dev/null and b/samples/SessionLoginSample/res/drawable/icon.png differ
diff --git a/samples/SessionLoginSample/res/layout/activity.xml b/samples/SessionLoginSample/res/layout/activity.xml
new file mode 100644
index 000000000..acc8c45c2
--- /dev/null
+++ b/samples/SessionLoginSample/res/layout/activity.xml
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:orientation="vertical" >
+
+    <TextView
+        android:id="@+id/instructionsOrLink"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:text="@string/instructions"
+        android:autoLink="web"
+        android:linksClickable="true"
+        android:textAppearance="?android:attr/textAppearanceMedium" />
+
+    <Button
+        android:id="@+id/buttonLoginLogout"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:text="@string/login" />
+
+</LinearLayout>
diff --git a/samples/SessionLoginSample/res/layout/custom_fragment_activity.xml b/samples/SessionLoginSample/res/layout/custom_fragment_activity.xml
new file mode 100644
index 000000000..c0be0bbd8
--- /dev/null
+++ b/samples/SessionLoginSample/res/layout/custom_fragment_activity.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:orientation="vertical" >
+
+    <fragment android:layout_height="fill_parent"
+              android:layout_width="fill_parent"
+              android:id="@+id/fragment"
+              android:name="com.facebook.samples.sessionlogin.SessionLoginFragment" />
+
+</LinearLayout>
diff --git a/samples/SessionLoginSample/res/layout/fragment.xml b/samples/SessionLoginSample/res/layout/fragment.xml
new file mode 100644
index 000000000..55da93ac9
--- /dev/null
+++ b/samples/SessionLoginSample/res/layout/fragment.xml
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+              android:orientation="vertical">
+
+<TextView
+            android:id="@+id/instructionsOrLink"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:text="@string/instructions"
+            android:autoLink="web"
+            android:linksClickable="true"
+            android:textAppearance="?android:attr/textAppearanceMedium" />
+
+    <Button
+            android:id="@+id/buttonLoginLogout"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:text="@string/login" />
+
+</LinearLayout>
diff --git a/samples/SessionLoginSample/res/layout/login_fragment_activity.xml b/samples/SessionLoginSample/res/layout/login_fragment_activity.xml
new file mode 100644
index 000000000..b7ce7ce30
--- /dev/null
+++ b/samples/SessionLoginSample/res/layout/login_fragment_activity.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent">
+
+    <fragment android:layout_height="fill_parent"
+              android:layout_width="fill_parent"
+              android:id="@+id/login_fragment"
+              android:name="com.facebook.widget.UserSettingsFragment" />
+
+</LinearLayout>
\ No newline at end of file
diff --git a/samples/SessionLoginSample/res/layout/main.xml b/samples/SessionLoginSample/res/layout/main.xml
new file mode 100644
index 000000000..f5237dda5
--- /dev/null
+++ b/samples/SessionLoginSample/res/layout/main.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:orientation="vertical" >
+
+    <Button
+        android:id="@+id/buttonLoginActivity"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:text="@string/login_using_activity" />
+
+    <Button
+            android:id="@+id/buttonLoginCustomFragment"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:text="@string/login_using_custom_fragment" />
+
+    <Button
+            android:id="@+id/buttonLoginFragment"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:text="@string/login_using_usersettingsfragment" />
+
+</LinearLayout>
diff --git a/samples/SessionLoginSample/res/values/strings.xml b/samples/SessionLoginSample/res/values/strings.xml
new file mode 100644
index 000000000..a06061580
--- /dev/null
+++ b/samples/SessionLoginSample/res/values/strings.xml
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<resources>
+
+    <string name="login_using_activity">Login using Activity</string>
+    <string name="login_using_custom_fragment">Login using Custom Fragment</string>
+    <string name="login_using_usersettingsfragment">Login using UserSettingsFragment</string>
+    <string name="hello">Hello World, SessionLoginSampleActivity!</string>
+    <string name="app_name">SessionLoginSample</string>
+    <string name="login">Login</string>
+    <string name="instructions">Login to create a link to fetch account data</string>
+    <string name="logout">Log out</string>
+    <string name="applicationId">380615018626574</string>
+
+</resources>
diff --git a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingActivityActivity.java b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingActivityActivity.java
new file mode 100644
index 000000000..8ac0884f5
--- /dev/null
+++ b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingActivityActivity.java
@@ -0,0 +1,128 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.sessionlogin;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.os.Bundle;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.widget.Button;
+import android.widget.TextView;
+import com.facebook.LoggingBehavior;
+import com.facebook.Session;
+import com.facebook.SessionState;
+import com.facebook.Settings;
+
+public class LoginUsingActivityActivity extends Activity {
+    private static final String URL_PREFIX_FRIENDS = "https://graph.facebook.com/me/friends?access_token=";
+
+    private TextView textInstructionsOrLink;
+    private Button buttonLoginLogout;
+    private Session.StatusCallback statusCallback = new SessionStatusCallback();
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity);
+        buttonLoginLogout = (Button)findViewById(R.id.buttonLoginLogout);
+        textInstructionsOrLink = (TextView)findViewById(R.id.instructionsOrLink);
+
+        Settings.addLoggingBehavior(LoggingBehavior.INCLUDE_ACCESS_TOKENS);
+
+        Session session = Session.getActiveSession();
+        if (session == null) {
+            if (savedInstanceState != null) {
+                session = Session.restoreSession(this, null, statusCallback, savedInstanceState);
+            }
+            if (session == null) {
+                session = new Session(this);
+            }
+            Session.setActiveSession(session);
+            if (session.getState().equals(SessionState.CREATED_TOKEN_LOADED)) {
+                session.openForRead(new Session.OpenRequest(this).setCallback(statusCallback));
+            }
+        }
+
+        updateView();
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        Session.getActiveSession().addCallback(statusCallback);
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+        Session.getActiveSession().removeCallback(statusCallback);
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        Session.getActiveSession().onActivityResult(this, requestCode, resultCode, data);
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        Session session = Session.getActiveSession();
+        Session.saveSession(session, outState);
+    }
+
+    private void updateView() {
+        Session session = Session.getActiveSession();
+        if (session.isOpened()) {
+            textInstructionsOrLink.setText(URL_PREFIX_FRIENDS + session.getAccessToken());
+            buttonLoginLogout.setText(R.string.logout);
+            buttonLoginLogout.setOnClickListener(new OnClickListener() {
+                public void onClick(View view) { onClickLogout(); }
+            });
+        } else {
+            textInstructionsOrLink.setText(R.string.instructions);
+            buttonLoginLogout.setText(R.string.login);
+            buttonLoginLogout.setOnClickListener(new OnClickListener() {
+                public void onClick(View view) { onClickLogin(); }
+            });
+        }
+    }
+
+    private void onClickLogin() {
+        Session session = Session.getActiveSession();
+        if (!session.isOpened() && !session.isClosed()) {
+            session.openForRead(new Session.OpenRequest(this).setCallback(statusCallback));
+        } else {
+            Session.openActiveSession(this, true, statusCallback);
+        }
+    }
+
+    private void onClickLogout() {
+        Session session = Session.getActiveSession();
+        if (!session.isClosed()) {
+            session.closeAndClearTokenInformation();
+        }
+    }
+
+    private class SessionStatusCallback implements Session.StatusCallback {
+        @Override
+        public void call(Session session, SessionState state, Exception exception) {
+            updateView();
+        }
+    }
+}
diff --git a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingCustomFragmentActivity.java b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingCustomFragmentActivity.java
new file mode 100644
index 000000000..4769dda32
--- /dev/null
+++ b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingCustomFragmentActivity.java
@@ -0,0 +1,28 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.sessionlogin;
+
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+
+public class LoginUsingCustomFragmentActivity extends FragmentActivity {
+
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.custom_fragment_activity);
+    }
+}
diff --git a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingLoginFragmentActivity.java b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingLoginFragmentActivity.java
new file mode 100644
index 000000000..ff20bf257
--- /dev/null
+++ b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/LoginUsingLoginFragmentActivity.java
@@ -0,0 +1,52 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.sessionlogin;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+import android.util.Log;
+import com.facebook.Session;
+import com.facebook.SessionState;
+import com.facebook.widget.UserSettingsFragment;
+
+public class LoginUsingLoginFragmentActivity extends FragmentActivity {
+    private UserSettingsFragment userSettingsFragment;
+
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        setContentView(R.layout.login_fragment_activity);
+
+        FragmentManager fragmentManager = getSupportFragmentManager();
+        userSettingsFragment = (UserSettingsFragment) fragmentManager.findFragmentById(R.id.login_fragment);
+        userSettingsFragment.setSessionStatusCallback(new Session.StatusCallback() {
+            @Override
+            public void call(Session session, SessionState state, Exception exception) {
+                Log.d("LoginUsingLoginFragmentActivity", String.format("New session state: %s", state.toString()));
+            }
+        });
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        userSettingsFragment.onActivityResult(requestCode, resultCode, data);
+        super.onActivityResult(requestCode, resultCode, data);
+    }
+
+}
\ No newline at end of file
diff --git a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginFragment.java b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginFragment.java
new file mode 100644
index 000000000..7f2164f7b
--- /dev/null
+++ b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginFragment.java
@@ -0,0 +1,131 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.sessionlogin;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.TextView;
+import com.facebook.LoggingBehavior;
+import com.facebook.Session;
+import com.facebook.SessionState;
+import com.facebook.Settings;
+
+public class SessionLoginFragment extends Fragment {
+    private static final String URL_PREFIX_FRIENDS = "https://graph.facebook.com/me/friends?access_token=";
+
+    private TextView textInstructionsOrLink;
+    private Button buttonLoginLogout;
+    private Session.StatusCallback statusCallback = new SessionStatusCallback();
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        View view = inflater.inflate(R.layout.fragment, container, false);
+
+        buttonLoginLogout = (Button) view.findViewById(R.id.buttonLoginLogout);
+        textInstructionsOrLink = (TextView) view.findViewById(R.id.instructionsOrLink);
+
+        Settings.addLoggingBehavior(LoggingBehavior.INCLUDE_ACCESS_TOKENS);
+
+        Session session = Session.getActiveSession();
+        if (session == null) {
+            if (savedInstanceState != null) {
+                session = Session.restoreSession(getActivity(), null, statusCallback, savedInstanceState);
+            }
+            if (session == null) {
+                session = new Session(getActivity());
+            }
+            Session.setActiveSession(session);
+            if (session.getState().equals(SessionState.CREATED_TOKEN_LOADED)) {
+                session.openForRead(new Session.OpenRequest(this).setCallback(statusCallback));
+            }
+        }
+
+        updateView();
+
+        return view;
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        Session.getActiveSession().addCallback(statusCallback);
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+        Session.getActiveSession().removeCallback(statusCallback);
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        Session.getActiveSession().onActivityResult(getActivity(), requestCode, resultCode, data);
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        Session session = Session.getActiveSession();
+        Session.saveSession(session, outState);
+    }
+
+    private void updateView() {
+        Session session = Session.getActiveSession();
+        if (session.isOpened()) {
+            textInstructionsOrLink.setText(URL_PREFIX_FRIENDS + session.getAccessToken());
+            buttonLoginLogout.setText(R.string.logout);
+            buttonLoginLogout.setOnClickListener(new View.OnClickListener() {
+                public void onClick(View view) { onClickLogout(); }
+            });
+        } else {
+            textInstructionsOrLink.setText(R.string.instructions);
+            buttonLoginLogout.setText(R.string.login);
+            buttonLoginLogout.setOnClickListener(new View.OnClickListener() {
+                public void onClick(View view) { onClickLogin(); }
+            });
+        }
+    }
+
+    private void onClickLogin() {
+        Session session = Session.getActiveSession();
+        if (!session.isOpened() && !session.isClosed()) {
+            session.openForRead(new Session.OpenRequest(this).setCallback(statusCallback));
+        } else {
+            Session.openActiveSession(getActivity(), this, true, statusCallback);
+        }
+    }
+
+    private void onClickLogout() {
+        Session session = Session.getActiveSession();
+        if (!session.isClosed()) {
+            session.closeAndClearTokenInformation();
+        }
+    }
+
+    private class SessionStatusCallback implements Session.StatusCallback {
+        @Override
+        public void call(Session session, SessionState state, Exception exception) {
+            updateView();
+        }
+    }
+}
diff --git a/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginSampleActivity.java b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginSampleActivity.java
new file mode 100644
index 000000000..a6ce9bb97
--- /dev/null
+++ b/samples/SessionLoginSample/src/com/facebook/samples/sessionlogin/SessionLoginSampleActivity.java
@@ -0,0 +1,72 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.sessionlogin;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.os.Bundle;
+import android.view.View;
+import android.widget.Button;
+
+public class SessionLoginSampleActivity extends Activity {
+
+    private Button buttonLoginActivity;
+    private Button buttonCustomFragment;
+    private Button buttonLoginFragment;
+
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        setContentView(R.layout.main);
+
+        // We demonstrate three different ways of managing session login/logout behavior:
+        // 1) LoginUsingActivityActivity implements an Activity that handles all of its own
+        //    session management.
+        // 2) LoginUsingCustomFragmentActivity uses a Fragment that handles session management;
+        //    this Fragment could be composed as part of a more complex Activity, although in this
+        //    case it is the only UI that the Activity displays.
+        // 3) LoginUsingLoginFragmentActivity is similar to LoginUsingCustomFragmentActivity, but
+        //    uses the UserSettingsFragment class provided by the SDK to handle session management. As
+        //    in (2), this Fragment could be composed as part of a more complex Activity in a real app.
+        buttonLoginActivity = (Button) findViewById(R.id.buttonLoginActivity);
+        buttonLoginActivity.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                Intent intent = new Intent(SessionLoginSampleActivity.this, LoginUsingActivityActivity.class);
+                startActivity(intent);
+            }
+        });
+
+        buttonCustomFragment = (Button) findViewById(R.id.buttonLoginCustomFragment);
+        buttonCustomFragment.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                Intent intent = new Intent(SessionLoginSampleActivity.this, LoginUsingCustomFragmentActivity.class);
+                startActivity(intent);
+            }
+        });
+
+        buttonLoginFragment = (Button) findViewById(R.id.buttonLoginFragment);
+        buttonLoginFragment.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                Intent intent = new Intent(SessionLoginSampleActivity.this, LoginUsingLoginFragmentActivity.class);
+                startActivity(intent);
+            }
+        });
+    }
+}
\ No newline at end of file
diff --git a/samples/SwitchUserSample/.classpath b/samples/SwitchUserSample/.classpath
new file mode 100644
index 000000000..655a4a827
--- /dev/null
+++ b/samples/SwitchUserSample/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/samples/SwitchUserSample/.project b/samples/SwitchUserSample/.project
new file mode 100644
index 000000000..2f6fda8c3
--- /dev/null
+++ b/samples/SwitchUserSample/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SwitchUserSample</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/samples/SwitchUserSample/AndroidManifest.xml b/samples/SwitchUserSample/AndroidManifest.xml
new file mode 100644
index 000000000..8107b8d41
--- /dev/null
+++ b/samples/SwitchUserSample/AndroidManifest.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.facebook.samples.switchuser"
+          android:versionCode="1"
+          android:versionName="1.0">
+    <uses-sdk android:minSdkVersion="8"/>
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <application android:label="@string/app_name"
+                 android:icon="@drawable/icon" >
+        <activity android:name=".MainActivity"
+                  android:label="@string/app_name"
+                  android:windowSoftInputMode="adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+        <activity android:name="com.facebook.LoginActivity"
+                  android:theme="@android:style/Theme.Translucent.NoTitleBar"
+                  android:label="@string/app_name" />
+        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
+    </application>
+</manifest> 
diff --git a/samples/SwitchUserSample/SwitchUserSample.iml b/samples/SwitchUserSample/SwitchUserSample.iml
new file mode 100644
index 000000000..4aac86509
--- /dev/null
+++ b/samples/SwitchUserSample/SwitchUserSample.iml
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
+        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
+        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
+        <option name="REGENERATE_R_JAVA" value="true" />
+        <option name="REGENERATE_JAVA_BY_AIDL" value="true" />
+        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
+        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
+        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
+        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
+        <option name="APK_PATH" value="" />
+        <option name="LIBRARY_PROJECT" value="false" />
+        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
+        <option name="GENERATE_UNSIGNED_APK" value="false" />
+        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
+        <option name="PACK_TEST_CODE" value="false" />
+        <option name="RUN_PROGUARD" value="false" />
+        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
+        <resOverlayFolders>
+          <path>/res-overlay</path>
+        </resOverlayFolders>
+        <includeSystemProguardFile>true</includeSystemProguardFile>
+        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
+        <additionalNativeLibs />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module" module-name="android-sdk" />
+    <orderEntry type="library" name="android-support-v4" level="project" />
+  </component>
+</module>
+
diff --git a/samples/SwitchUserSample/ant.properties b/samples/SwitchUserSample/ant.properties
new file mode 100644
index 000000000..939105d52
--- /dev/null
+++ b/samples/SwitchUserSample/ant.properties
@@ -0,0 +1,18 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
+java.compilerargs=-Xlint -Werror
diff --git a/samples/SwitchUserSample/build.xml b/samples/SwitchUserSample/build.xml
new file mode 100644
index 000000000..ee88101d7
--- /dev/null
+++ b/samples/SwitchUserSample/build.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="SwitchUserSample" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties"/>
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties"/>
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env"/>
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME"/>
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties"/>
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+            />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true"/>
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml"/>
+
+</project>
diff --git a/samples/SwitchUserSample/proguard-project.txt b/samples/SwitchUserSample/proguard-project.txt
new file mode 100644
index 000000000..f2fe1559a
--- /dev/null
+++ b/samples/SwitchUserSample/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/samples/SwitchUserSample/project.properties b/samples/SwitchUserSample/project.properties
new file mode 100644
index 000000000..cee0509c6
--- /dev/null
+++ b/samples/SwitchUserSample/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-8
+android.library.reference.1=../../facebook
diff --git a/samples/SwitchUserSample/res/drawable-hdpi/icon.png b/samples/SwitchUserSample/res/drawable-hdpi/icon.png
new file mode 100644
index 000000000..cda826b7f
Binary files /dev/null and b/samples/SwitchUserSample/res/drawable-hdpi/icon.png differ
diff --git a/samples/SwitchUserSample/res/drawable-mdpi/icon.png b/samples/SwitchUserSample/res/drawable-mdpi/icon.png
new file mode 100644
index 000000000..ffd35f432
Binary files /dev/null and b/samples/SwitchUserSample/res/drawable-mdpi/icon.png differ
diff --git a/samples/SwitchUserSample/res/drawable-xhdpi/icon.png b/samples/SwitchUserSample/res/drawable-xhdpi/icon.png
new file mode 100644
index 000000000..be63ade0b
Binary files /dev/null and b/samples/SwitchUserSample/res/drawable-xhdpi/icon.png differ
diff --git a/samples/SwitchUserSample/res/drawable/icon.png b/samples/SwitchUserSample/res/drawable/icon.png
new file mode 100644
index 000000000..ffd35f432
Binary files /dev/null and b/samples/SwitchUserSample/res/drawable/icon.png differ
diff --git a/samples/SwitchUserSample/res/layout/fragment_profile.xml b/samples/SwitchUserSample/res/layout/fragment_profile.xml
new file mode 100644
index 000000000..509a8a215
--- /dev/null
+++ b/samples/SwitchUserSample/res/layout/fragment_profile.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              xmlns:app="http://schemas.android.com/apk/res-auto"
+              android:orientation="vertical"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+        >
+    <TextView
+            android:id="@+id/profileUserName"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginBottom="20dp"
+            android:text="@string/greeting_no_user"
+            android:freezesText="true"
+            />
+    <com.facebook.widget.ProfilePictureView
+            android:id="@+id/profilePic"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            app:preset_size="large"
+            />
+</LinearLayout>
+
diff --git a/samples/SwitchUserSample/res/layout/list_item_user.xml b/samples/SwitchUserSample/res/layout/list_item_user.xml
new file mode 100644
index 000000000..021f8a184
--- /dev/null
+++ b/samples/SwitchUserSample/res/layout/list_item_user.xml
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<LinearLayout
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:app="http://schemas.android.com/apk/res-auto"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal"
+        >
+
+    <com.facebook.widget.ProfilePictureView
+            android:id="@+id/slotPic"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            android:layout_weight="0"
+            android:layout_margin="10dp"
+            app:preset_size="small"
+            />
+
+    <TextView
+            android:id="@+id/slotUserName"
+            android:layout_height="wrap_content"
+            android:layout_width="0dp"
+            android:layout_weight="1"
+            android:layout_gravity="center_vertical"
+            />
+
+    <CheckBox
+            android:id="@+id/currentUserIndicator"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            android:layout_weight="0"
+            android:layout_gravity="center_vertical"
+            android:focusable="false"
+            android:enabled="false"
+            />
+
+</LinearLayout>
diff --git a/samples/SwitchUserSample/res/layout/main.xml b/samples/SwitchUserSample/res/layout/main.xml
new file mode 100644
index 000000000..a223f1d3e
--- /dev/null
+++ b/samples/SwitchUserSample/res/layout/main.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+             android:id="@+id/fragmentContainer"
+             android:layout_width="match_parent"
+             android:layout_height="match_parent"
+        />
diff --git a/samples/SwitchUserSample/res/menu/context_settings.xml b/samples/SwitchUserSample/res/menu/context_settings.xml
new file mode 100644
index 000000000..c1aa76530
--- /dev/null
+++ b/samples/SwitchUserSample/res/menu/context_settings.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<menu xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:id="@+id/menu_item_clear_slot"
+          android:title="@string/menu_item_clear_slot"
+          />
+</menu>
diff --git a/samples/SwitchUserSample/res/menu/options_profile.xml b/samples/SwitchUserSample/res/menu/options_profile.xml
new file mode 100644
index 000000000..2457088f0
--- /dev/null
+++ b/samples/SwitchUserSample/res/menu/options_profile.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<menu xmlns:android="http://schemas.android.com/apk/res/android">
+    <item
+            android:id="@+id/menu_item_switch"
+            android:title="@string/menu_item_switch_user"
+            />
+</menu>
diff --git a/samples/SwitchUserSample/res/values/strings.xml b/samples/SwitchUserSample/res/values/strings.xml
new file mode 100644
index 000000000..4195ef509
--- /dev/null
+++ b/samples/SwitchUserSample/res/values/strings.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<resources>
+    <string name="app_name">SwitchUserSample</string>
+    <string name="empty_slot">Empty Slot</string>
+    <string name="greeting_format">Hello, %s!</string>
+    <string name="greeting_no_user">Please select a user via the options menu</string>
+    <string name="menu_item_switch_user">Select User</string>
+    <string name="menu_item_clear_slot">Clear this slot</string>
+    <string name="app_id">327842977278179</string>
+</resources>
diff --git a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/MainActivity.java b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/MainActivity.java
new file mode 100644
index 000000000..8b4c9d482
--- /dev/null
+++ b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/MainActivity.java
@@ -0,0 +1,251 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.switchuser;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+import android.support.v4.app.FragmentTransaction;
+import android.view.MenuItem;
+import com.facebook.*;
+import com.facebook.model.GraphUser;
+
+public class MainActivity extends FragmentActivity {
+
+    private static final String SHOWING_SETTINGS_KEY = "Showing settings";
+    private static final String TOKEN_CACHE_NAME_KEY = "TokenCacheName";
+
+    private ProfileFragment profileFragment;
+    private SettingsFragment settingsFragment;
+    private boolean isShowingSettings;
+    private Slot currentSlot;
+    private Session currentSession;
+    private Session.StatusCallback sessionStatusCallback;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+
+        restoreFragments(savedInstanceState);
+
+        sessionStatusCallback = new Session.StatusCallback() {
+            @Override
+            public void call(Session session, SessionState state, Exception exception) {
+                onSessionStateChange(session, state, exception);
+            }
+        };
+
+        if (savedInstanceState != null) {
+            if (savedInstanceState.getBoolean(SHOWING_SETTINGS_KEY)) {
+                showSettings();
+            } else {
+                showProfile();
+            }
+
+            SharedPreferencesTokenCachingStrategy restoredCache = new SharedPreferencesTokenCachingStrategy(
+                    this,
+                    savedInstanceState.getString(TOKEN_CACHE_NAME_KEY));
+            currentSession = Session.restoreSession(
+                    this,
+                    restoredCache,
+                    sessionStatusCallback,
+                    savedInstanceState);
+        } else {
+            showProfile();
+        }
+    }
+
+    @Override
+    public void onBackPressed() {
+        if (isShowingSettings()) {
+            // This back is from the settings fragment
+            showProfile();
+        } else {
+            // Allow the user to back out of the app as well.
+            super.onBackPressed();
+        }
+    }
+
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        outState.putBoolean(SHOWING_SETTINGS_KEY, isShowingSettings());
+        if (currentSlot != null) {
+            outState.putString(TOKEN_CACHE_NAME_KEY, currentSlot.getTokenCacheName());
+        }
+
+        FragmentManager manager = getSupportFragmentManager();
+        manager.putFragment(outState, SettingsFragment.TAG, settingsFragment);
+        manager.putFragment(outState, ProfileFragment.TAG, profileFragment);
+
+        Session.saveSession(currentSession, outState);
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+
+        settingsFragment.setSlotChangedListener(new SettingsFragment.OnSlotChangedListener() {
+            @Override
+            public void onSlotChanged(Slot newSlot) {
+                handleSlotChange(newSlot);
+            }
+        });
+
+        profileFragment.setOnOptionsItemSelectedListener(new ProfileFragment.OnOptionsItemSelectedListener() {
+            @Override
+            public boolean onOptionsItemSelected(MenuItem item) {
+                return handleOptionsItemSelected(item);
+            }
+        });
+
+        if (currentSession != null) {
+            currentSession.addCallback(sessionStatusCallback);
+        }
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+
+        settingsFragment.setSlotChangedListener(null);
+        profileFragment.setOnOptionsItemSelectedListener(null);
+
+        if (currentSession != null) {
+            currentSession.removeCallback(sessionStatusCallback);
+        }
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        if (currentSession != null) {
+            currentSession.onActivityResult(this, requestCode, resultCode, data);
+        }
+    }
+
+    private void onSessionStateChange(Session session, SessionState state, Exception exception) {
+        if (session != currentSession) {
+            return;
+        }
+
+        if (state.isOpened()) {
+            // Log in just happened.
+            fetchUserInfo();
+            showProfile();
+        } else if (state.isClosed()) {
+            // Log out just happened. Update the UI.
+            updateFragments(null);
+        }
+    }
+
+    private void restoreFragments(Bundle savedInstanceState) {
+        FragmentManager manager = getSupportFragmentManager();
+        FragmentTransaction transaction = manager.beginTransaction();
+
+        if (savedInstanceState != null) {
+            profileFragment = (ProfileFragment)manager.getFragment(savedInstanceState, ProfileFragment.TAG);
+            settingsFragment = (SettingsFragment)manager.getFragment(savedInstanceState, SettingsFragment.TAG);
+        }
+
+        if (profileFragment == null) {
+            profileFragment = new ProfileFragment();
+            transaction.add(R.id.fragmentContainer, profileFragment, ProfileFragment.TAG);
+        }
+
+        if (settingsFragment == null) {
+            settingsFragment = new SettingsFragment();
+            transaction.add(R.id.fragmentContainer, settingsFragment, SettingsFragment.TAG);
+        }
+
+        transaction.commit();
+    }
+
+    private void showSettings() {
+        isShowingSettings = true;
+
+        FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
+        transaction.hide(profileFragment)
+                .show(settingsFragment)
+                .commit();
+    }
+
+    private boolean isShowingSettings() {
+        return isShowingSettings;
+    }
+
+    private void showProfile() {
+        isShowingSettings = false;
+
+        FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
+        transaction.hide(settingsFragment)
+                .show(profileFragment)
+                .commit();
+    }
+
+    private void fetchUserInfo() {
+        if (currentSession != null && currentSession.isOpened()) {
+            Request request = Request.newMeRequest(currentSession, new Request.GraphUserCallback() {
+                @Override
+                public void onCompleted(GraphUser me, Response response) {
+                    if (response.getRequest().getSession() == currentSession) {
+                        updateFragments(me);
+                    }
+                }
+            });
+            request.executeAsync();
+        }
+    }
+
+    private void handleSlotChange(Slot newSlot) {
+        if (currentSession != null) {
+            currentSession.close();
+            currentSession = null;
+        }
+
+        if (newSlot != null) {
+            currentSlot = newSlot;
+            currentSession = new Session.Builder(this)
+                    .setTokenCachingStrategy(currentSlot.getTokenCache())
+                    .build();
+            currentSession.addCallback(sessionStatusCallback);
+
+            Session.OpenRequest openRequest = new Session.OpenRequest(this);
+            openRequest.setLoginBehavior(newSlot.getLoginBehavior());
+            openRequest.setRequestCode(Session.DEFAULT_AUTHORIZE_ACTIVITY_CODE);
+            currentSession.openForRead(openRequest);
+        }
+    }
+
+    private boolean handleOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+            case R.id.menu_item_switch:
+                showSettings();
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    private void updateFragments(GraphUser user) {
+        settingsFragment.updateViewForUser(user);
+        profileFragment.updateViewForUser(user);
+    }
+}
diff --git a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/ProfileFragment.java b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/ProfileFragment.java
new file mode 100644
index 000000000..885fc93f9
--- /dev/null
+++ b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/ProfileFragment.java
@@ -0,0 +1,103 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.switchuser;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.view.*;
+import android.widget.TextView;
+import com.facebook.model.GraphUser;
+import com.facebook.widget.ProfilePictureView;
+
+public class ProfileFragment extends Fragment {
+
+    public static final String TAG = "ProfileFragment";
+
+    private TextView userNameView;
+    private ProfilePictureView profilePictureView;
+    private OnOptionsItemSelectedListener onOptionsItemSelectedListener;
+
+    private GraphUser pendingUpdateForUser;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setHasOptionsMenu(true);
+    }
+
+    @Override
+    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
+        super.onCreateOptionsMenu(menu, inflater);
+        inflater.inflate(R.menu.options_profile, menu);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        boolean handled = false;
+        OnOptionsItemSelectedListener listener = onOptionsItemSelectedListener;
+        if (listener != null) {
+            handled = listener.onOptionsItemSelected(item);
+        }
+
+        if (!handled) {
+            handled = super.onOptionsItemSelected(item);
+        }
+
+        return handled;
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {
+        View v = inflater.inflate(R.layout.fragment_profile, parent, false);
+
+        userNameView = (TextView)v.findViewById(R.id.profileUserName);
+        profilePictureView = (ProfilePictureView)v.findViewById(R.id.profilePic);
+
+        if (pendingUpdateForUser != null) {
+            updateViewForUser(pendingUpdateForUser);
+            pendingUpdateForUser = null;
+        }
+
+        return v;
+    }
+
+    public void setOnOptionsItemSelectedListener(OnOptionsItemSelectedListener listener) {
+        this.onOptionsItemSelectedListener = listener;
+    }
+
+    public void updateViewForUser(GraphUser user) {
+        if (userNameView == null || profilePictureView == null || !isAdded()) {
+            // Fragment not yet added to the view. So let's store which user was intended
+            // for display.
+            pendingUpdateForUser = user;
+            return;
+        }
+
+        if (user == null) {
+            profilePictureView.setProfileId(null);
+            userNameView.setText(R.string.greeting_no_user);
+        } else {
+            profilePictureView.setProfileId(user.getId());
+            userNameView.setText(
+                    String.format(getString(R.string.greeting_format), user.getFirstName()));
+        }
+    }
+
+    public interface OnOptionsItemSelectedListener {
+        boolean onOptionsItemSelected(MenuItem item);
+    }
+}
diff --git a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/SettingsFragment.java b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/SettingsFragment.java
new file mode 100644
index 000000000..b140e2577
--- /dev/null
+++ b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/SettingsFragment.java
@@ -0,0 +1,283 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.switchuser;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+import android.support.v4.app.ListFragment;
+import android.view.*;
+import android.widget.*;
+import com.facebook.model.GraphUser;
+import com.facebook.widget.ProfilePictureView;
+import com.facebook.SessionLoginBehavior;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+public class SettingsFragment extends ListFragment {
+
+    public static final String TAG = "SettingsFragment";
+
+    private static final String CURRENT_SLOT_KEY = "CurrentSlot";
+
+    private SlotManager slotManager;
+    private OnSlotChangedListener slotChangedListener;
+    private boolean hasPendingNotifySlotChanged;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        slotManager = new SlotManager();
+        slotManager.restore(
+                getActivity(),
+                savedInstanceState != null ?
+                        savedInstanceState.getInt(CURRENT_SLOT_KEY, SlotManager.NO_SLOT) :
+                        SlotManager.NO_SLOT);
+        ArrayList<Slot> slotList = new ArrayList<Slot>(
+                Arrays.asList(slotManager.getAllSlots()));
+
+        setListAdapter(new SlotAdapter(slotList));
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {
+        View view = super.onCreateView(inflater, parent, savedInstanceState);
+        registerForContextMenu(view.findViewById(android.R.id.list));
+
+        return view;
+    }
+
+    @Override
+    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
+        super.onCreateContextMenu(menu, view, menuInfo);
+        getActivity().getMenuInflater().inflate(R.menu.context_settings, menu);
+    }
+
+    @Override
+    public void onListItemClick(ListView l, View view, int position, long id) {
+        slotManager.toggleSlot(position);
+    }
+
+    @Override
+    public boolean onContextItemSelected(MenuItem item) {
+        AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
+        SlotAdapter adapter = (SlotAdapter) getListAdapter();
+        Slot slot = adapter.getItem(info.position);
+
+        switch (item.getItemId()) {
+            case R.id.menu_item_clear_slot:
+                if (slot.getUserId() != null) {
+                    // Clear out data that this app stored in the cache
+                    // Not calling Session.closeAndClearTokenInformation() because we have additional
+                    // data stored in the cache.
+                    slot.clear();
+                    if (slot == slotManager.getSelectedSlot()) {
+                        slotManager.toggleSlot(info.position);
+                    }
+
+                    updateListView();
+                }
+                return true;
+        }
+
+        return super.onContextItemSelected(item);
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        outState.putInt(CURRENT_SLOT_KEY, slotManager.getSelectedSlotNumber());
+    }
+
+    public void setSlotChangedListener(OnSlotChangedListener listener) {
+        slotChangedListener = listener;
+        if (listener != null && hasPendingNotifySlotChanged) {
+            notifySlotChanged();
+            hasPendingNotifySlotChanged = false;
+        }
+    }
+
+    public void updateViewForUser(GraphUser user) {
+        if (slotManager == null) {
+            // Fragment has not had onCreate called yet.
+            return;
+        }
+
+        if (user != null) {
+            Slot s = slotManager.getSelectedSlot();
+            if (s != null) {
+                s.update(user);
+            }
+        } else {
+            // If the user is null, then there isn't an actively selected
+            // user. This can happen if the user cancelled a login. So make sure that
+            // SlotManager is updated properly.
+            slotManager.setSelectedSlotNumber(SlotManager.NO_SLOT);
+        }
+
+        updateListView();
+    }
+
+    private void notifySlotChanged() {
+        OnSlotChangedListener listener = slotChangedListener;
+        if (listener != null) {
+            Slot newSlot = slotManager.getSelectedSlot();
+            listener.onSlotChanged(newSlot);
+        } else {
+            hasPendingNotifySlotChanged = true;
+        }
+    }
+
+    private void updateListView() {
+        SlotAdapter adapter = (SlotAdapter) getListAdapter();
+        adapter.notifyDataSetChanged();
+    }
+
+    public interface OnSlotChangedListener {
+        void onSlotChanged(Slot newSlot);
+    }
+
+    private class SlotAdapter extends ArrayAdapter<Slot> {
+
+        public SlotAdapter(ArrayList<Slot> slots) {
+            super(getActivity(), android.R.layout.simple_list_item_1, slots);
+        }
+
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+            if (null == convertView) {
+                convertView = getActivity().getLayoutInflater()
+                        .inflate(R.layout.list_item_user, null);
+            }
+
+            Slot slot = getItem(position);
+            String userName = slot.getUserName();
+            if (userName == null) {
+                userName = getString(R.string.empty_slot);
+            }
+
+            ProfilePictureView profilePictureView = (ProfilePictureView) convertView.findViewById(
+                    R.id.slotPic);
+            profilePictureView.setCropped(true);
+            profilePictureView.setProfileId(slot.getUserId());
+
+            TextView userNameTextView = (TextView) convertView.findViewById(
+                    R.id.slotUserName);
+            userNameTextView.setText(userName);
+
+            CheckBox currentUserCheckBox = (CheckBox) convertView.findViewById(
+                    R.id.currentUserIndicator);
+            currentUserCheckBox.setChecked(slotManager.getSelectedSlot() == slot);
+
+            return convertView;
+        }
+
+    }
+
+    private class SlotManager {
+        static final int NO_SLOT = -1;
+
+        private final static int MAX_SLOTS = 4;
+
+        private static final String SETTINGS_CURRENT_SLOT_KEY = "CurrentSlot";
+        private static final String SETTINGS_NAME = "UserManagerSettings";
+
+        private SharedPreferences settings;
+        private int selectedSlotNumber = NO_SLOT;
+
+        private Slot[] slots;
+
+        void restore(Context context, int oldSelectedSlot) {
+            if (context == null) {
+                throw new IllegalArgumentException("context cannot be null");
+            }
+
+            Context applicationContext = context.getApplicationContext();
+            applicationContext = (applicationContext == null) ? context : applicationContext;
+
+            slots = new Slot[MAX_SLOTS];
+            for (int i = 0; i < MAX_SLOTS; i++) {
+                SessionLoginBehavior loginBehavior = (i == 0) ?
+                        SessionLoginBehavior.SSO_WITH_FALLBACK :
+                        SessionLoginBehavior.SUPPRESS_SSO;
+                slots[i] = new Slot(applicationContext, i, loginBehavior);
+            }
+
+            // Restore the last known state from when the app ran last.
+            settings = applicationContext.getSharedPreferences(SETTINGS_NAME, Context.MODE_PRIVATE);
+            int savedSlotNumber = settings.getInt(SETTINGS_CURRENT_SLOT_KEY, NO_SLOT);
+            if (savedSlotNumber != NO_SLOT && savedSlotNumber != oldSelectedSlot) {
+                // This will trigger the full flow of creating and opening the right session
+                toggleSlot(savedSlotNumber);
+            } else {
+                // We already knew which slot was selected. So don't notify that a new slot was
+                // selected since that will close out the old session and recreate a new one. And
+                // doing so will have the effect of clearing out state like the profile pic.
+                setSelectedSlotNumber(savedSlotNumber);
+            }
+        }
+
+        void toggleSlot(int slot) {
+            validateSlot(slot);
+
+            if (slot == selectedSlotNumber) {
+                setSelectedSlotNumber(NO_SLOT);
+            } else {
+                setSelectedSlotNumber(slot);
+            }
+
+            notifySlotChanged();
+        }
+
+        Slot getSelectedSlot() {
+            if (selectedSlotNumber == NO_SLOT) {
+                return null;
+            } else {
+                return getSlot(selectedSlotNumber);
+            }
+        }
+
+        int getSelectedSlotNumber() {
+            return selectedSlotNumber;
+        }
+
+        Slot[] getAllSlots() {
+            return slots;
+        }
+
+        Slot getSlot(int slot) {
+            validateSlot(slot);
+
+            return slots[slot];
+        }
+
+        private void setSelectedSlotNumber(int slot) {
+            // Store the selected slot number for when the app is closed and restarted
+            settings.edit().putInt(SETTINGS_CURRENT_SLOT_KEY, slot).commit();
+            selectedSlotNumber = slot;
+        }
+
+        private void validateSlot(int slot) {
+            if (slot <= NO_SLOT || slot >= MAX_SLOTS) {
+                throw new IllegalArgumentException(
+                        String.format("Choose a slot between 0 and %d inclusively", MAX_SLOTS-1));
+            }
+        }
+    }
+}
diff --git a/samples/SwitchUserSample/src/com/facebook/samples/switchuser/Slot.java b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/Slot.java
new file mode 100644
index 000000000..0dee18160
--- /dev/null
+++ b/samples/SwitchUserSample/src/com/facebook/samples/switchuser/Slot.java
@@ -0,0 +1,91 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.facebook.samples.switchuser;
+
+import android.content.Context;
+import android.os.Bundle;
+import com.facebook.*;
+import com.facebook.model.GraphUser;
+
+public class Slot {
+
+    private static final String CACHE_NAME_FORMAT = "TokenCache%d";
+    private static final String CACHE_USER_ID_KEY = "SwitchUserSampleUserId";
+    private static final String CACHE_USER_NAME_KEY = "SwitchUserSampleUserName";
+
+    private String tokenCacheName;
+    private String userName;
+    private String userId;
+    private SharedPreferencesTokenCachingStrategy tokenCache;
+    private SessionLoginBehavior loginBehavior;
+
+    public Slot(Context context, int slotNumber, SessionLoginBehavior loginBehavior) {
+        this.loginBehavior = loginBehavior;
+        this.tokenCacheName = String.format(CACHE_NAME_FORMAT, slotNumber);
+        this.tokenCache = new SharedPreferencesTokenCachingStrategy(
+                context,
+                tokenCacheName);
+
+        restore();
+    }
+
+    public String getTokenCacheName() {
+        return tokenCacheName;
+    }
+
+    public String getUserName() {
+        return userName;
+    }
+
+    public String getUserId() {
+        return userId;
+    }
+
+    public SessionLoginBehavior getLoginBehavior() {
+        return loginBehavior;
+    }
+
+    public SharedPreferencesTokenCachingStrategy getTokenCache() {
+        return tokenCache;
+    }
+
+    public void update(GraphUser user) {
+        if (user == null) {
+            return;
+        }
+
+        userId = user.getId();
+        userName = user.getName();
+
+        Bundle userInfo = tokenCache.load();
+        userInfo.putString(CACHE_USER_ID_KEY, userId);
+        userInfo.putString(CACHE_USER_NAME_KEY, userName);
+
+        tokenCache.save(userInfo);
+    }
+
+    public void clear() {
+        tokenCache.clear();
+        restore();
+    }
+
+    private void restore() {
+        Bundle userInfo = tokenCache.load();
+        userId = userInfo.getString(CACHE_USER_ID_KEY);
+        userName = userInfo.getString(CACHE_USER_NAME_KEY);
+    }
+}
diff --git a/scripts/build_and_test.sh b/scripts/build_and_test.sh
new file mode 100755
index 000000000..a0649b7d5
--- /dev/null
+++ b/scripts/build_and_test.sh
@@ -0,0 +1,51 @@
+#!/bin/sh
+#
+# Copyright 2012 Facebook
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+# 
+#    http://www.apache.org/licenses/LICENSE-2.0
+# 
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+function die() {
+  echo "$@"
+  exit 1
+}
+
+# Find enlistment root
+cd $(dirname $0) >/dev/null
+SDK=$(git rev-parse --show-toplevel) ||
+  die "Could not access git"
+
+# Build all samples
+cd $SDK/samples
+for SAMPLE in *; do
+  if [[ -d $SAMPLE ]]; then
+    cd $SAMPLE
+    ant clean ||
+      die "Error running 'ant clean' on sample $SAMPLE"
+    ant debug ||
+      die "Error running 'ant debug' on sample $SAMPLE"
+    cd ..
+  fi
+done
+
+# Remove any stale test bits, ignore errors here
+adb uninstall com.facebook.sdk.tests 2>/dev/null
+
+# Build and run tests
+cd $SDK/facebook/tests
+ant clean ||
+  die "Error running 'ant clean' on facebook sdk"
+ant debug install ||
+  die "Error running 'ant debug install' on facebook sdk"
+ant run-tests ||
+  die "Error running 'ant run-tests' on facebook sdk"
diff --git a/scripts/configure_unit_tests.sh b/scripts/configure_unit_tests.sh
new file mode 100755
index 000000000..d0e6c9481
--- /dev/null
+++ b/scripts/configure_unit_tests.sh
@@ -0,0 +1,50 @@
+#!/bin/sh
+#
+# Copyright 2012 Facebook
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+# 
+#    http://www.apache.org/licenses/LICENSE-2.0
+# 
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+# this script configures your Android simulator for unit tests
+# Note: On Mac OS X, an easy way to generate a MACHINE_UNIQUE_USER_TAG is with the following:
+#   system_profiler SPHardwareDataType | grep -i "Serial Number (system):" | awk '{print $4}'
+
+cd $(dirname $0)/..
+FB_SDK_ROOT=$(pwd)
+FB_SDK_TESTS=$FB_SDK_ROOT/facebook/tests
+
+if [ "$#" -lt 2 ]; then
+    echo "Usage: $0 APP_ID APP_SECRET [MACHINE_UNIQUE_USER_KEY]"
+    echo "  APP_ID                   your unit-testing Facebook application's App ID"
+    echo "  APP_SECRET               your unit-testing Facebook application's App Secret"
+    echo "  MACHINE_UNIQUE_USER_TAG  optional text used to ensure this machine will use its own set of test users rather than sharing"
+    die 'Arguments do not conform to usage'
+fi
+
+function write_config_json {
+    CONFIG_JSON_FILE="$FB_SDK_TESTS"/assets/config.json
+
+    mkdir -p "$FB_SDK_TESTS"/assets
+
+    # use heredoc syntax to output the json
+    cat > "$CONFIG_JSON_FILE" \
+<<DELIMIT
+{"applicationId":"$1","applicationSecret":"$2","machineUniqueUserTag":"$3"}
+DELIMIT
+# end heredoc
+
+    echo "wrote unit test config file at $CONFIG_JSON_FILE" 
+}
+
+write_config_json $1 $2 $3
+
diff --git a/tests/default.properties b/tests/default.properties
deleted file mode 100644
index 6d3f02d2c..000000000
--- a/tests/default.properties
+++ /dev/null
@@ -1,12 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-# 
-# This file must be checked in Version Control Systems.
-# 
-# To customize properties used by the Ant build system use,
-# "build.properties", and override values to adapt the script to your
-# project structure.
-
-android.library.reference.1=../facebook/
-# Project target.
-target=android-3
diff --git a/tests/res/layout/main.xml b/tests/res/layout/main.xml
index 1d0daf1c5..bc121048b 100644
--- a/tests/res/layout/main.xml
+++ b/tests/res/layout/main.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical" android:layout_width="fill_parent"
     android:layout_height="fill_parent" android:background="@drawable/black"
diff --git a/tests/res/values/colors.xml b/tests/res/values/colors.xml
index 2aa7e8e36..2f916914f 100644
--- a/tests/res/values/colors.xml
+++ b/tests/res/values/colors.xml
@@ -1,5 +1,21 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <drawable name="white">#ffffff</drawable>
     <drawable name="black">#000000</drawable>
-</resources>
\ No newline at end of file
+</resources>
diff --git a/tests/res/values/strings.xml b/tests/res/values/strings.xml
index 1c7c09076..a8fa46759 100644
--- a/tests/res/values/strings.xml
+++ b/tests/res/values/strings.xml
@@ -1,4 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright 2012 Facebook
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
 <resources>
     <string name="hello">Hello World, Tests!</string>
     <string name="login">Test Login</string>
diff --git a/tests/src/com/facebook/android/tests/Tests.java b/tests/src/com/facebook/android/tests/Tests.java
index 3f771e128..4fb93d730 100644
--- a/tests/src/com/facebook/android/tests/Tests.java
+++ b/tests/src/com/facebook/android/tests/Tests.java
@@ -1,3 +1,19 @@
+/**
+ * Copyright 2012 Facebook
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.facebook.android.tests;
 
 import java.io.FileNotFoundException;
