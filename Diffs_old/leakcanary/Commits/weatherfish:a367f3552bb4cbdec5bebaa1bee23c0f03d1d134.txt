diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
new file mode 100755
index 00000000..d15ea400
--- /dev/null
+++ b/.buildscript/deploy_snapshot.sh
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.
+#
+# Adapted from https://coderwall.com/p/9b_lfq and
+# http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
+
+SLUG="square/leakcanary"
+JDK="oraclejdk8"
+BRANCH="master"
+
+set -e
+
+if [ "$TRAVIS_REPO_SLUG" != "$SLUG" ]; then
+  echo "Skipping snapshot deployment: wrong repository. Expected '$SLUG' but was '$TRAVIS_REPO_SLUG'."
+elif [ "$TRAVIS_JDK_VERSION" != "$JDK" ]; then
+  echo "Skipping snapshot deployment: wrong JDK. Expected '$JDK' but was '$TRAVIS_JDK_VERSION'."
+elif [ "$TRAVIS_PULL_REQUEST" != "false" ]; then
+  echo "Skipping snapshot deployment: was pull request."
+elif [ "$TRAVIS_BRANCH" != "$BRANCH" ]; then
+  echo "Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'."
+else
+  echo "Deploying snapshot..."
+  ./gradlew clean uploadArchives
+  echo "Snapshot deployed!"
+fi
diff --git a/CONTRIBUTING.md b/.github/CONTRIBUTING.md
similarity index 100%
rename from CONTRIBUTING.md
rename to .github/CONTRIBUTING.md
diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
new file mode 100644
index 00000000..f655ac04
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE.md
@@ -0,0 +1,29 @@
+Welcome and thank you for reporting an issue!
+
+First, verify that your issue hasn't already been reported by searching over all issues: https://github.com/square/leakcanary/issues?q=is%3Aissue.
+
+What kind of issue is this?
+
+ - Question: This issue tracker is not the place for questions. If you want to ask how to do
+   something, or to understand why something isn't working the way you expect it to, use Stack
+   Overflow: https://stackoverflow.com/questions/tagged/leakcanary.
+
+ - Help me fix a leak?: Please do not file an issue.
+   Instead, read here: https://github.com/square/leakcanary/#how-do-i-fix-a-memory-leak
+ 
+ - OOM error: Please provide a heap dump!
+
+ - Bug report: If you’ve found a bug, spend the time to write a failing test. Bugs with tests get fixed. 
+   Here’s an example: https://gist.github.com/swankjesse/981fcae102f513eb13ed
+   
+ - Feature Request: Start by telling us what problem you’re trying to solve. Don’t send pull requests to implement 
+   new features without first getting our support. Sometimes we leave features out on purpose to keep the project small.
+
+^^^^^ DELETE FROM THIS LINE UP ^^^^^
+
+
+```
+
+REPLACE THIS LINE WITH YOUR STACKTRACE OR OUTPUT FROM LEAKCANARY
+
+```
diff --git a/.travis.yml b/.travis.yml
index e4452455..ad327f32 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -2,16 +2,25 @@ language: android
 
 android:
   components:
-    - build-tools-21.1.2
-    - android-21
-  licenses:
-    - android-sdk-license-5be876d5
+    - tools
+    - platform-tools
+    - build-tools-23.0.2
+    - android-23
 
 jdk:
   - oraclejdk7
+  - oraclejdk8
 
 script:
-  - ./gradlew clean build check
+  - ./gradlew clean build
+
+after_success:
+  - .buildscript/deploy_snapshot.sh
+
+env:
+  global:
+    - secure: "aWyY/jCiG/D7hHAprj0rG3xYafxRYjZM5oNqqbDfjUHvqPp7kS3SOhUd3SJMVuSR4kA5TuZQqMXHr10Jz05gcyowQE2XEnKmu1WkfNWz2TCNerF27O0TkuIgYyZxcOb1M4aMxDJPZgySLmsXQ+iuAly+RSFP/CcSP4WPU9YNsGCQZ1C8KfscCWxKR5n1GoOEboOIxE5BL11F4tYjINX45FcIdBJu5XKJhCqUUvjdwxrZ0BykSYpvgpZ0WwAcXUBHHoqcYnNYAhBi60G00OE2Ml1x5lXiC+5Kwpsi0mXoWMyDT7MIIqB+Fk6XzxEzE7+z2nYmssXpvfHDJe+N+osCxvgWL97dMwx6BLv0S2jaoNgtcBB/DpzJAGeQ3yFulK5npr7RpeKpFN60rj8vYaRK9EfAvTfiHOjA/gkfSLBYOk/hOmE6o363nAKqUss+5FMS9c2vgIatbJiYHWScqlMRPxS3IjLp9Y84jB8JN/T8Mexxsw07OmEtaAU5+di/Nv2ok1MIx25NA0XYsMKXReCkicYoXQcSBIj5fTUI6bD09OLS4hs1EacX0hIfF89TJKs6azu0VLJHWKoW2Uo+qqgVMQPXRkNAzCcrJGeUWep8O/DsoNlT40NZCXP5wJN/aWFK0Rrl5n1zM8VVWBPk/0CAS0VUDZZSnqGXo2vZV6+bYEk="
+    - secure: "gdFVL5AOp5DhnaC2vJ5EYglenG3vOcJuMLQrnQsKzt+p2jb9jdu8Lbx3kr8UdKOXOPPQVwg1U8BILe8RPmkaURYgZLE9nPthEcEVfULRPbj7EDHxOQ0/3uWRbkq+GyxDtX4+tdnDQhEijW+hSIQdWHgUAwvvvxrKLVS37lYaj55VVtITljgsd07YYKMrFNFfH/tgDJdZClaiuXdLfrWzVEZKGHBJfyzGOjLmUSbZzXL/ut32mIqbVsxeDvXXxlBluS68UkG3wI5/gp1jAxBIc+NK+CoZMMb5ww6V1P+iZhA176YXm8WDiUHpEx6cH//rtnIJ+1IywBCG+S60JeVpUEu8N9NK/eVd2en5OSef9xqBYfCYHRKvI/S/DiR9CCbim7rnlVgHMrY580Nv/bnJ5E9Q/sQSD9pzKp0P452qU36FXJ+c519inc1+F5fEUApft0UzAVQFT9sY7qGV0d6x6D3BDyXGE4KMYWx4ydkSSCAI2bsvl/8dLUybU1kKBDivY71VU/bGtJ33LobySiSJA/03vTKHEsBuMowu13pnj7c5tp7QFFv3lRO1XXqT4NS39SySDQUT7UbZofsqHTyqMpiL72q1rII6af+XNskmILuwU/oRwR8+IN9LBE9Nz0uL3zOzv8uhzTZT2rUGEhDm+B51UMvK0ZEJDlpvA9Y2GTQ="
 
 notifications:
   email: false
@@ -20,4 +29,4 @@ sudo: false
 
 cache:
   directories:
-    - $HOME/.gradle
\ No newline at end of file
+    - $HOME/.gradle
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 13227b52..bf3a6544 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,33 +1,49 @@
 # Change Log
 
-## Version 1.3.2-SNAPSHOT
-
-* Added ProGuard configuration for debug library [132](https://github.com/square/leakcanary/issues/132).
-* 2 new ignored Android SDK leaks: [#26](https://github.com/square/leakcanary/issues/26) [#62](https://github.com/square/leakcanary/issues/62).
+## Version 1.4 *(2016-09-11)*
+
+* Fix false negative where GC root is of type android.os.Binder [#482](https://github.com/square/leakcanary/issues/482)
+* Update HAHA to 2.0.3; clear compiler warnings [#563](https://github.com/square/leakcanary/issues/563) 
+* Correct some mistakes in German translation [#516](https://github.com/square/leakcanary/pull/516)
+* Don't loop when storage permission denied [#422](https://github.com/square/leakcanary/issues/422)
+* Remove old references to "__" prefixed resources [#477](https://github.com/square/leakcanary/pull/477)
+* Fix permission crash for DisplayLeakActivity on M [#382](https://github.com/square/leakcanary/issues/382)
+* Fix NPE when thread name not found in heap dump [#417](https://github.com/square/leakcanary/issues/417)
+* Add version info to stacktrace [#473](https://github.com/square/leakcanary/issues/473)
+
+## Version 1.4-beta2 *(2016-03-23)*
+
+* Add reason for ignoring to analysis result [#365](https://github.com/square/leakcanary/issues/365).
+* Lower memory usage when parsing heap dumps on M [#223](https://github.com/square/leakcanary/issues/223).
+* Fix NPE in LeakCanaryInternals.isInServiceProcess() [#449](https://github.com/square/leakcanary/issues/449).
+* New ignored Android SDK leaks [#297](https://github.com/square/leakcanary/issues/297),[#322](https://github.com/square/leakcanary/issues/322).
+* Use leakcanary-android-no-op in test builds [#143](https://github.com/square/leakcanary/issues/143).
+* Fixes to allow LeakCanary to work with ProGuard [#398](https://github.com/square/leakcanary/pull/398).
+* Optimize png assets [#406](https://github.com/square/leakcanary/pull/406).
+* Fix delete button not working on error views [#408](https://github.com/square/leakcanary/pull/408).
+* Add German translation [#437](https://github.com/square/leakcanary/pull/437).
+
+## Version 1.4-beta1 *(2016-01-08)*
+
+* Switched to [HAHA 2.0.2](https://github.com/square/haha/blob/master/CHANGELOG.md#version-202-2015-07-20) with uses Perflib instead of MAT under the hood [#219](https://github.com/square/leakcanary/pull/219). This fixes crashes and improves speed a lot.
+* We can now parse Android M heap dumps [#267](https://github.com/square/leakcanary/issues/267), although there are still memory issues (see [#223](https://github.com/square/leakcanary/issues/223)).
+* Excluded leaks are now reported as well and available in the display leak activity.
+* Added ProGuard configuration for [#132](https://github.com/square/leakcanary/issues/132).
+* Many new ignored Android SDK leaks.
 * Added excluded leaks to text report [#119](https://github.com/square/leakcanary/issues/119).
 * Added LeakCanary SHA to text report [#120](https://github.com/square/leakcanary/issues/120).
+* Added CanaryLog API to replace the logger: [#201](https://github.com/square/leakcanary/issues/201).
+* Renamed all resources to begin with `leak_canary_` instead of `__leak_canary`[#161](https://github.com/square/leakcanary/pull/161)
+* No crash when heap dump fails [#226](https://github.com/square/leakcanary/issues/226).
+* Add retained size to leak reports [#162](https://github.com/square/leakcanary/issues/162).
 
-### Dependencies
-
-```gradle
- dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3.2-SNAPSHOT'
-   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.2-SNAPSHOT'
- }
-```
-
-Snapshots are available in Sonatype's `snapshots` repository:
-
-```
-  repositories {
-    mavenCentral()
-    maven {
-      url 'https://oss.sonatype.org/content/repositories/snapshots/'
-    }
-  }
-```
+### Public API changes
 
-[![Build Status](https://travis-ci.org/square/leakcanary.svg?branch=master)](https://travis-ci.org/square/leakcanary)
+* AnalysisResult.failure is now a `Throwable` instead of an `Exception`. Main goal is to catch and correctly report OOMs while parsing.
+* Added ARRAY_ENTRY to LeakTraceElement.Type for references through array entries.
+* Renamed `ExcludedRefs` fields.
+* Each `ExcludedRef` entry can now be ignored entirely or "kept only if no other path".
+* Added support for ignoring all fields (static and non static) for a given class.
 
 ## Version 1.3.1 *(2015-05-16)*
 
@@ -56,29 +72,8 @@ Snapshots are available in Sonatype's `snapshots` repository:
 * `AndroidExcludedRefs.createAppDefaults()` & `AndroidExcludedRefs.createAndroidDefaults()` return a `ExcludedRef.Builder`.
 * `ExcludedRef` moved from `leakcanary-analyzer` to `leakcanary-watcher`
 
-### Dependencies
-
-```gradle
- dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3.1'
-   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.1'
- }
-```
-
-### Statistics
-
-* 33 commits to the LeakCanary library code and 11 commits to [HAHA](https://github.com/square/haha).
-* 6 contributors: [Pierre-Yves Ricau](https://github.com/square/leakcanary/commits?author=pyricau), [Sergey Shulepov](https://github.com/square/leakcanary/commits?author=pepyakin), [Romain Guy](https://github.com/square/leakcanary/commits?author=romainguy), [liaohuqiu](https://github.com/square/leakcanary/commits?author=liaohuqiu), [Dario Marcato](https://github.com/square/leakcanary/commits?author=dmarcato), [Anders Aagaard](https://github.com/square/leakcanary/commits?author=andaag).
-
 ## Version 1.3 *(2015-05-08)*
 
 Initial release.
 
 ### Dependencies
-
-```gradle
- dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3'
-   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3'
- }
-```
\ No newline at end of file
diff --git a/README.md b/README.md
index 82310b6a..487d779e 100644
--- a/README.md
+++ b/README.md
@@ -1,4 +1,4 @@
-#LeakCanary
+# LeakCanary
 
 A memory leak detection library for Android and Java.
 
@@ -12,8 +12,9 @@ In your `build.gradle`:
 
 ```gradle
  dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3.1'
-   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.1'
+   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.4'
+   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.4'
+   testCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.4'
  }
 ```
 
@@ -24,293 +25,23 @@ public class ExampleApplication extends Application {
 
   @Override public void onCreate() {
     super.onCreate();
-    LeakCanary.install(this);
-  }
-}
-```
-
-**You're good to go!** LeakCanary will automatically show a notification when an activity memory leak is detected in your debug build.
-
-## Why should I use LeakCanary?
-
-Glad you ask! We wrote a [blog post](http://squ.re/leakcanary) to answer precisely that question.
-
-## How do I use it?
-
-Use a `RefWatcher` to watch references that should be GCed:
-
-```java
-RefWatcher refWatcher = {...};
-
-// We expect schrodingerCat to be gone soon (or not), let's watch it.
-refWatcher.watch(schrodingerCat);
-```
-
-`LeakCanary.install()` returns a pre configured `RefWatcher`.
-It also installs an `ActivityRefWatcher` that automatically detects if an activity is leaking after `Activity.onDestroy()` has been called.
-
-```java
-public class ExampleApplication extends Application {
-
-  public static RefWatcher getRefWatcher(Context context) {
-    ExampleApplication application = (ExampleApplication) context.getApplicationContext();
-    return application.refWatcher;
-  }
-
-  private RefWatcher refWatcher;
-
-  @Override public void onCreate() {
-    super.onCreate();
-    refWatcher = LeakCanary.install(this);
-  }
-}
-```
-
-You could use the `RefWatcher` to watch for fragment leaks:
-
-```java
-public abstract class BaseFragment extends Fragment {
-
-  @Override public void onDestroy() {
-    super.onDestroy();
-    RefWatcher refWatcher = ExampleApplication.getRefWatcher(getActivity());
-    refWatcher.watch(this);
-  }
-}
-```
-
-## How does it work?
-
-1. `RefWatcher.watch()` creates a [KeyedWeakReference](https://github.com/square/leakcanary/blob/master/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java) to the watched object.
-2. Later, in a background thread, it checks if the reference has been cleared and if not it triggers a GC.
-3. If the reference is still not cleared, it then dumps the heap into a `.hprof` file stored on the app file system.
-4. `HeapAnalyzerService` is started in a separate process and `HeapAnalyzer` parses the heap dump using [HAHA](https://github.com/square/haha).
-5. `HeapAnalyzer` finds the `KeyedWeakReference` in the heap dump thanks to a unique reference key and locates the leaking reference.
-6. `HeapAnalyzer` computes the *shortest strong reference path to the GC Roots* to determine if there is a leak, and then builds the chain of references causing the leak.
-7. The result is passed back to `DisplayLeakService` in the app process, and the leak notification is shown.
-
-## How do I copy the leak trace?
-
-You can see the leak trace in Logcat:
-
-```
-In com.example.leakcanary:1.0:1 com.example.leakcanary.MainActivity has leaked:
-* GC ROOT thread java.lang.Thread.<Java Local> (named 'AsyncTask #1')
-* references com.example.leakcanary.MainActivity$3.this$0 (anonymous class extends android.os.AsyncTask)
-* leaks com.example.leakcanary.MainActivity instance
-
-* Reference Key: e71f3bf5-d786-4145-8539-584afaecad1d
-* Device: Genymotion generic Google Nexus 6 - 5.1.0 - API 22 - 1440x2560 vbox86p
-* Android Version: 5.1 API: 22
-* Durations: watch=5086ms, gc=110ms, heap dump=435ms, analysis=2086ms
-```
-
-You can also share the leak trace and the heap dump file from the **action bar menu**.
-
-## How do I fix a memory leak?
-
-Once you have the leak trace, figure out which reference in the path should not exist. Then figure out why that reference still exists. Often times it's a registered listener that should have been unregistered, a `close()` method that wasn't called, an anonymous class that holds a reference an outer class. If you cannot figure out an issue in your code, **please do not file an issue**. Instead, create a [Stack Overflow question](http://stackoverflow.com/questions/tagged/leakcanary) (using the *leakcanary* tag).
-
-## My leak is caused by the Android SDK implementation!
-
-There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: [AndroidExcludedRefs.java](https://github.com/square/leakcanary/blob/master/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java).
-
-If you find a new one, please [create an issue](https://github.com/square/leakcanary/issues/new) and follow these steps:
-
-1. Provide the entire leak trace information (reference key, device, etc).
-2. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions [android/platform_frameworks_base](https://github.com/android/platform_frameworks_base).
-3. Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed.
-4. If it's still happening, build a simple repro case
-5. File an issue on [b.android.com](http://b.android.com) with the leak trace and the repro case
-6. Create a PR in LeakCanary to update `AndroidExcludedRefs.java`. Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
-
-This is especially important for **new releases of Android**. You have the opportunity to help detect new memory leaks early on, which benefits the entire Android community. 
-
-## Beyond the leak trace
-
-Sometimes the leak trace isn't enough and you need to dig into the heap dump with [MAT](http://eclipse.org/mat/) or [YourKit](https://www.yourkit.com/). Here's how you can find the leaking instance in the head dump:
-
-1. Look for all instances of `com.squareup.leakcanary.KeyedWeakReference`
-2. For each of these, look at the `key` field.
-3. Find the `KeyedWeakReference` that has a `key` field equal to the reference key reported by LeakCanary.
-4. The `referent` field of that `KeyedWeakReference` is your leaking object.
-5. From then on, the matter is in your hands. A good start is to look at the shortest path to GC Roots (excluding weak references).
-
-## Customizing
-
-### Icon and label
-
-`DisplayLeakActivity` comes with a default icon and label, which you can change by providing `R.drawable.__leak_canary_icon` and `R.string.__leak_canary_display_activity_label` in your app:
-
-```
-res/
-  drawable-hdpi/
-    __leak_canary_icon.png
-  drawable-mdpi/
-    __leak_canary_icon.png
-  drawable-xhdpi/
-    __leak_canary_icon.png
-  drawable-xxhdpi/
-    __leak_canary_icon.png
-  drawable-xxxhdpi/
-    __leak_canary_icon.png
-```
-
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-  <string name="__leak_canary_display_activity_label">MyLeaks</string>
-</resources>
-```
-
-### Stored leak traces
-
-`DisplayLeakActivity` saves up to 7 heap dumps & leak traces in the app directory. You can change that number by providing `R.integer.__leak_canary_max_stored_leaks` in your app:
-
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-  <integer name="__leak_canary_max_stored_leaks">20</integer>
-</resources>
-```
-
-### Uploading to a server
-
-You can change the default behavior to upload the leak trace and heap dump to a server of your choosing.
-
-Create your own `AbstractAnalysisResultService`. The easiest way is to extend `DisplayLeakService` in your debug sources:
-
-```java
-public class LeakUploadService extends DisplayLeakService {
-  @Override protected void afterDefaultHandling(HeapDump heapDump, AnalysisResult result, String leakInfo) {
-    if (!result.leakFound || result.excludedLeak) {
+    if (LeakCanary.isInAnalyzerProcess(this)) {
+      // This process is dedicated to LeakCanary for heap analysis.
+      // You should not init your app in this process.
       return;
     }
-	myServer.uploadLeakBlocking(heapDump.heapDumpFile, leakInfo);
-  }
-}
-```
-
-Make sure the release Application class uses the disabled `RefWatcher`:
-
-```java
-public class ExampleApplication extends Application {
-
-  public static RefWatcher getRefWatcher(Context context) {
-    ExampleApplication application = (ExampleApplication) context.getApplicationContext();
-    return application.refWatcher;
-  }
-
-  private RefWatcher refWatcher;
-
-  @Override public void onCreate() {
-    super.onCreate();
-    refWatcher = installLeakCanary();
-  }
-  
-  protected RefWatcher installLeakCanary() {
-    return RefWatcher.DISABLED;
-  }
-}
-```
-
-Build a custom `RefWatcher` in your debug Application class:
-
-```java
-public class DebugExampleApplication extends ExampleApplication {
-  protected RefWatcher installLeakCanary() {
-    return LeakCanary.install(app, LeakUploadService.class, AndroidExcludedRefs.createAppDefaults().build());
-  }
-}
-```
-
-Don't forget to register the service in your debug manifest:
-
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
-    >
-  <application android:name="com.example.DebugExampleApplication">
-    <service android:name="com.example.LeakUploadService" />
-  </application>
-</manifest>
-```
-
-You can also upload the leak traces to Slack or HipChat, [here's an example](https://gist.github.com/pyricau/06c2c486d24f5f85f7f0).
-
-### Ignoring specific references
-
-You can create your own version of `ExcludedRefs` to ignore specific references that you know are causing leaks but you still want to ignore:
-
-```java
-public class DebugExampleApplication extends ExampleApplication {
-  protected RefWatcher installLeakCanary() {
-    ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults()
-        .instanceField("com.example.ExampleClass", "exampleField")
-        .build();
-    return LeakCanary.install(this, DisplayLeakService.class, excludedRefs);
-  }
-}
-```
-
-### Not watching specific activity classes
-
-`ActivityRefWatcher` is installed by default and watches all activities. You can customize the installation steps to use something different instead:
-
-```java
-public class DebugExampleApplication extends ExampleApplication {
-  protected RefWatcher installLeakCanary() {
-    if(isInAnalyzerProcess(this)) {
-      return RefWatcher.DISABLED;
-    } else {
-      ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults().build();
-      enableDisplayLeakActivity(application);
-      ServiceHeapDumpListener heapDumpListener = new ServiceHeapDumpListener(application, DisplayLeakService.class);
-      final RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);
-      registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() {
-        public void onActivityDestroyed(Activity activity) {
-          if (activity instanceof ThirdPartyActivity) {
-              return;
-          }
-          refWatcher.watch(activity);
-        }
-        // ...
-      });
-      return refWatcher;
-    }
+    LeakCanary.install(this);
+    // Normal app init code...
   }
 }
 ```
 
+**You're good to go!** LeakCanary will automatically show a notification when an activity memory leak is detected in your debug build.
 
-## Snapshots of the development version
-
-See the [CHANGELOG](https://github.com/square/leakcanary/blob/master/CHANGELOG.md).
-
-## Troubleshooting
-
-* if `leakcanary-android` is not in the list of external libraries in Android Studio, but `leakcanary-analyzer` and `leakcanary-watcher` are there: try doing a `Clean Build`. If it's still a problem, try building from the command line.
-* `error: package com.squareup.leakcanary does not exist`: if you have other build types than `debug` and `release`, you need to add a specific dependency for those too (`xxxCompile`).
-
-## Resources
-
-* LeakCanary: Detect all memory leaks! [squ.re/leakcanary](http://squ.re/leakcanary).
-* Wrangling Dalvik series: [Memory management in Android](http://www.raizlabs.com/dev/2014/03/wrangling-dalvik-memory-management-in-android-part-1-of-2/).
-* Uploading leak traces to a [Slack or HipChat channel](https://gist.github.com/pyricau/06c2c486d24f5f85f7f0).
-* Dump the heap on [OutOfMemoryError crashes](https://gist.github.com/pyricau/4726389fd64f3b7c6f32).
-* StackOverflow: [leakcanary tag](http://stackoverflow.com/questions/tagged/leakcanary).
-
-### Translations
-
-* squ.re/leakcanary [in Chinese](http://www.liaohuqiu.net/cn/posts/leak-canary/).
-* squ.re/leakcanary [in Russian](http://habrahabr.ru/post/257633/).
-* `README.md` in Chinese: [中文版说明](http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/).
+Questions? Check out [the FAQ](https://github.com/square/leakcanary/wiki/FAQ)!
 
 ![icon_512.png](assets/icon_512.png)
 
-The name **LeakCanary** is a reference to the expression [canary in a coal mine](http://en.wiktionary.org/wiki/canary_in_a_coal_mine), because LeakCanary is a sentinel used to detect risks by providing advance warning of a danger. Props to [@edenman](https://github.com/edenman) for suggesting it!
-
 ## License
 
     Copyright 2015 Square, Inc.
diff --git a/assets/icon_1024.png b/assets/icon_1024.png
index 5dfdcf84..f15c7586 100644
Binary files a/assets/icon_1024.png and b/assets/icon_1024.png differ
diff --git a/assets/icon_512.png b/assets/icon_512.png
index bb24dbad..0ca6bedf 100644
Binary files a/assets/icon_512.png and b/assets/icon_512.png differ
diff --git a/assets/screenshot.png b/assets/screenshot.png
index f68053b6..8faa278f 100644
Binary files a/assets/screenshot.png and b/assets/screenshot.png differ
diff --git a/assets/source_icon.png b/assets/source_icon.png
index 827e5552..d04aace6 100644
Binary files a/assets/source_icon.png and b/assets/source_icon.png differ
diff --git a/build.gradle b/build.gradle
index 708f8146..d03a1adb 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,31 +1,31 @@
-subprojects {
+buildscript {
+  repositories {
+    mavenCentral()
+  }
+  dependencies {
+    classpath 'com.android.tools.build:gradle:2.1.3'
+  }
+}
 
+subprojects {
   repositories {
     mavenCentral()
 //    maven {
 //      url 'https://oss.sonatype.org/content/repositories/snapshots/'
 //    }
-  }
-
-  buildscript {
-    repositories {
-      mavenCentral()
-    }
-    dependencies {
-      classpath 'com.android.tools.build:gradle:1.2.3'
-    }
+//    mavenLocal()
   }
 }
 
 ext {
   minSdkVersion = 8
-  compileSdkVersion = 21
+  compileSdkVersion = 23
   targetSdkVersion = compileSdkVersion
-  buildToolsVersion = '21.1.2'
+  buildToolsVersion = '23.0.2'
   javaVersion = JavaVersion.VERSION_1_7
 
   GROUP = 'com.squareup.leakcanary'
-  VERSION_NAME = "1.3.2-SNAPSHOT"
+  VERSION_NAME = "1.5-SNAPSHOT"
   POM_PACKAGING = "pom"
   POM_DESCRIPTION= "Leak Canary"
 
diff --git a/gradle/gradle-mvn-push.gradle b/gradle/gradle-mvn-push.gradle
index 01938b95..32763c86 100644
--- a/gradle/gradle-mvn-push.gradle
+++ b/gradle/gradle-mvn-push.gradle
@@ -16,11 +16,11 @@ def getSnapshotRepositoryUrl() {
 }
 
 def getRepositoryUsername() {
-    return hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : ""
+    return hasProperty('SONATYPE_NEXUS_USERNAME') ? SONATYPE_NEXUS_USERNAME : ""
 }
 
 def getRepositoryPassword() {
-    return hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : ""
+    return hasProperty('SONATYPE_NEXUS_PASSWORD') ? SONATYPE_NEXUS_PASSWORD : ""
 }
 
 afterEvaluate { project ->
@@ -93,6 +93,14 @@ afterEvaluate { project ->
         from android.sourceSets.main.java.sourceFiles
     }
 
+    if (JavaVersion.current().isJava8Compatible()) {
+        allprojects {
+            tasks.withType(Javadoc) {
+                options.addStringOption('Xdoclint:none', '-quiet')
+            }
+        }
+    }
+
     artifacts {
         archives androidSourcesJar
         archives androidJavadocsJar
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 58385981..3baa851b 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 80081ab8..c406ddb9 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Wed Feb 04 10:58:17 PST 2015
+#Thu Sep 08 23:35:36 PDT 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
diff --git a/gradlew b/gradlew
index 91a7e269..27309d92 100755
--- a/gradlew
+++ b/gradlew
@@ -6,12 +6,30 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,31 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -90,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
@@ -114,6 +113,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
diff --git a/leakcanary-analyzer/build.gradle b/leakcanary-analyzer/build.gradle
index a64cb553..461f504b 100644
--- a/leakcanary-analyzer/build.gradle
+++ b/leakcanary-analyzer/build.gradle
@@ -14,9 +14,10 @@ repositories {
 }
 
 dependencies {
-  compile 'com.squareup.haha:haha:1.3'
+  compile 'com.squareup.haha:haha:2.0.3'
   compile project(':leakcanary-watcher')
   testCompile 'junit:junit:4.12'
+  testCompile 'org.assertj:assertj-core:1.7.0'
 }
 
 android.libraryVariants.all { variant ->
@@ -30,17 +31,6 @@ android.libraryVariants.all { variant ->
   artifacts.add('archives', task);
 }
 
-
-// See: https://code.google.com/p/android/issues/detail?id=64887#c13
-task copyTestResources(type: Copy) {
-  from "${projectDir}/src/test/resources"
-  into "${buildDir}/classes/test"
-}
-
-afterEvaluate { project ->
-  testDebug.dependsOn copyTestResources
-}
-
 android {
   compileSdkVersion rootProject.ext.compileSdkVersion
   buildToolsVersion rootProject.ext.buildToolsVersion
@@ -48,6 +38,9 @@ android {
     minSdkVersion rootProject.ext.minSdkVersion
     targetSdkVersion rootProject.ext.targetSdkVersion
   }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+  }
 }
 
 task sourceJar(type: Jar) {
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java b/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java
new file mode 100644
index 00000000..227bcb59
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.haha.perflib;
+
+public final class HahaSpy {
+
+  public static Instance allocatingThread(Instance instance) {
+    Snapshot snapshot = instance.mHeap.mSnapshot;
+    int threadSerialNumber;
+    if (instance instanceof RootObj) {
+      threadSerialNumber = ((RootObj) instance).mThread;
+    } else {
+      threadSerialNumber = instance.mStack.mThreadSerialNumber;
+    }
+    ThreadObj thread = snapshot.getThread(threadSerialNumber);
+    return snapshot.findInstance(thread.mId);
+  }
+
+  private HahaSpy() {
+    throw new AssertionError();
+  }
+}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
index d1cf730a..4c8270c1 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
@@ -20,16 +20,17 @@
 public final class AnalysisResult implements Serializable {
 
   public static AnalysisResult noLeak(long analysisDurationMs) {
-    return new AnalysisResult(false, false, null, null, null, analysisDurationMs);
+    return new AnalysisResult(false, false, null, null, null, 0, analysisDurationMs);
   }
 
   public static AnalysisResult leakDetected(boolean excludedLeak, String className,
-      LeakTrace leakTrace, long analysisDurationMs) {
-    return new AnalysisResult(true, excludedLeak, className, leakTrace, null, analysisDurationMs);
+      LeakTrace leakTrace, long retainedHeapSize, long analysisDurationMs) {
+    return new AnalysisResult(true, excludedLeak, className, leakTrace, null, retainedHeapSize,
+        analysisDurationMs);
   }
 
-  public static AnalysisResult failure(Exception exception, long analysisDurationMs) {
-    return new AnalysisResult(false, false, null, null, exception, analysisDurationMs);
+  public static AnalysisResult failure(Throwable failure, long analysisDurationMs) {
+    return new AnalysisResult(false, false, null, null, failure, 0, analysisDurationMs);
   }
 
   /** True if a leak was found in the heap dump. */
@@ -54,18 +55,25 @@ public static AnalysisResult failure(Exception exception, long analysisDurationM
   public final LeakTrace leakTrace;
 
   /** Null unless the analysis failed. */
-  public final Exception failure;
+  public final Throwable failure;
+
+  /**
+   * The number of bytes which would be freed if all references to the leaking object were
+   * released. 0 if {@link #leakFound} is false.
+   */
+  public final long retainedHeapSize;
 
   /** Total time spent analyzing the heap. */
   public final long analysisDurationMs;
 
   private AnalysisResult(boolean leakFound, boolean excludedLeak, String className,
-      LeakTrace leakTrace, Exception failure, long analysisDurationMs) {
+      LeakTrace leakTrace, Throwable failure, long retainedHeapSize, long analysisDurationMs) {
     this.leakFound = leakFound;
     this.excludedLeak = excludedLeak;
     this.className = className;
     this.leakTrace = leakTrace;
     this.failure = failure;
+    this.retainedHeapSize = retainedHeapSize;
     this.analysisDurationMs = analysisDurationMs;
   }
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
new file mode 100644
index 00000000..fe01cd23
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
@@ -0,0 +1,174 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import com.squareup.haha.perflib.ArrayInstance;
+import com.squareup.haha.perflib.ClassInstance;
+import com.squareup.haha.perflib.ClassObj;
+import com.squareup.haha.perflib.Field;
+import com.squareup.haha.perflib.Heap;
+import com.squareup.haha.perflib.Instance;
+import com.squareup.haha.perflib.Type;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import static com.squareup.leakcanary.Preconditions.checkNotNull;
+import static java.util.Arrays.asList;
+
+public final class HahaHelper {
+
+  private static final Set<String> WRAPPER_TYPES = new HashSet<>(
+      asList(Boolean.class.getName(), Character.class.getName(), Float.class.getName(),
+          Double.class.getName(), Byte.class.getName(), Short.class.getName(),
+          Integer.class.getName(), Long.class.getName()));
+
+  static String fieldToString(Map.Entry<Field, Object> entry) {
+    return fieldToString(entry.getKey(), entry.getValue());
+  }
+
+  static String fieldToString(ClassInstance.FieldValue fieldValue) {
+    return fieldToString(fieldValue.getField(), fieldValue.getValue());
+  }
+
+  static String fieldToString(Field field, Object value) {
+    return field.getName() + " = " + value;
+  }
+
+  static String threadName(Instance holder) {
+    List<ClassInstance.FieldValue> values = classInstanceValues(holder);
+    Object nameField = fieldValue(values, "name");
+    if (nameField == null) {
+      // Sometimes we can't find the String at the expected memory address in the heap dump.
+      // See https://github.com/square/leakcanary/issues/417 .
+      return "Thread name not available";
+    }
+    return asString(nameField);
+  }
+
+  static boolean extendsThread(ClassObj clazz) {
+    boolean extendsThread = false;
+    ClassObj parentClass = clazz;
+    while (parentClass.getSuperClassObj() != null) {
+      if (clazz.getClassName().equals(Thread.class.getName())) {
+        extendsThread = true;
+        break;
+      }
+      parentClass = parentClass.getSuperClassObj();
+    }
+    return extendsThread;
+  }
+
+  static String asString(Object stringObject) {
+    Instance instance = (Instance) stringObject;
+    List<ClassInstance.FieldValue> values = classInstanceValues(instance);
+
+    Integer count = fieldValue(values, "count");
+    Object value = fieldValue(values, "value");
+    Integer offset;
+    ArrayInstance charArray;
+    if (isCharArray(value)) {
+      charArray = (ArrayInstance) value;
+      offset = 0;
+      // < API 23
+      // As of Marshmallow, substrings no longer share their parent strings' char arrays
+      // eliminating the need for String.offset
+      // https://android-review.googlesource.com/#/c/83611/
+      if (hasField(values, "offset")) {
+        offset = fieldValue(values, "offset");
+      }
+    } else {
+      // In M preview 2, the underlying char buffer resides in the heap with ID equaling the
+      // String's ID + 16.
+      // https://android-review.googlesource.com/#/c/160380/2/android/src/com/android/tools/idea/
+      // editors/hprof/descriptors/InstanceFieldDescriptorImpl.java
+      // This workaround is only needed for M preview 2, as it has been fixed on the hprof
+      // generation end by reintroducing a virtual "value" variable.
+      // https://android.googlesource.com/platform/art/+/master/runtime/hprof/hprof.cc#1242
+      Heap heap = instance.getHeap();
+      Instance inlineInstance = heap.getInstance(instance.getId() + 16);
+      if (isCharArray(inlineInstance)) {
+        charArray = (ArrayInstance) inlineInstance;
+        offset = 0;
+      } else {
+        throw new UnsupportedOperationException("Could not find char array in " + instance);
+      }
+    }
+    checkNotNull(count, "count");
+    checkNotNull(charArray, "charArray");
+    checkNotNull(offset, "offset");
+
+    if (count == 0) {
+      return "";
+    }
+
+    char[] chars = charArray.asCharArray(offset, count);
+
+    return new String(chars);
+  }
+
+  public static boolean isPrimitiveWrapper(Object value) {
+    if (!(value instanceof ClassInstance)) {
+      return false;
+    }
+    return WRAPPER_TYPES.contains(((ClassInstance) value).getClassObj().getClassName());
+  }
+
+  public static boolean isPrimitiveOrWrapperArray(Object value) {
+    if (!(value instanceof ArrayInstance)) {
+      return false;
+    }
+    ArrayInstance arrayInstance = (ArrayInstance) value;
+    if (arrayInstance.getArrayType() != Type.OBJECT) {
+      return true;
+    }
+    return WRAPPER_TYPES.contains(arrayInstance.getClassObj().getClassName());
+  }
+
+  private static boolean isCharArray(Object value) {
+    return value instanceof ArrayInstance && ((ArrayInstance) value).getArrayType() == Type.CHAR;
+  }
+
+  static List<ClassInstance.FieldValue> classInstanceValues(Instance instance) {
+    ClassInstance classInstance = (ClassInstance) instance;
+    return classInstance.getValues();
+  }
+
+  static <T> T fieldValue(List<ClassInstance.FieldValue> values, String fieldName) {
+    for (ClassInstance.FieldValue fieldValue : values) {
+      if (fieldValue.getField().getName().equals(fieldName)) {
+        //noinspection unchecked
+        return (T) fieldValue.getValue();
+      }
+    }
+    throw new IllegalArgumentException("Field " + fieldName + " does not exists");
+  }
+
+  static boolean hasField(List<ClassInstance.FieldValue> values, String fieldName) {
+    for (ClassInstance.FieldValue fieldValue : values) {
+      if (fieldValue.getField().getName().equals(fieldName)) {
+        //noinspection unchecked
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private HahaHelper() {
+    throw new AssertionError();
+  }
+}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
index b12dcce4..3b1effb6 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
@@ -15,45 +15,39 @@
  */
 package com.squareup.leakcanary;
 
-import android.util.Log;
+import com.squareup.haha.perflib.ArrayInstance;
+import com.squareup.haha.perflib.ClassInstance;
+import com.squareup.haha.perflib.ClassObj;
+import com.squareup.haha.perflib.Field;
+import com.squareup.haha.perflib.HprofParser;
+import com.squareup.haha.perflib.Instance;
+import com.squareup.haha.perflib.RootObj;
+import com.squareup.haha.perflib.RootType;
+import com.squareup.haha.perflib.Snapshot;
+import com.squareup.haha.perflib.Type;
+import com.squareup.haha.perflib.io.HprofBuffer;
+import com.squareup.haha.perflib.io.MemoryMappedFileBuffer;
+import com.squareup.haha.trove.THashMap;
+import com.squareup.haha.trove.TObjectProcedure;
+
 import java.io.File;
-import java.io.FileFilter;
 import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
-import org.eclipse.mat.SnapshotException;
-import org.eclipse.mat.parser.internal.SnapshotFactory;
-import org.eclipse.mat.snapshot.IPathsFromGCRootsComputer;
-import org.eclipse.mat.snapshot.ISnapshot;
-import org.eclipse.mat.snapshot.PathsFromGCRootsTree;
-import org.eclipse.mat.snapshot.model.Field;
-import org.eclipse.mat.snapshot.model.IArray;
-import org.eclipse.mat.snapshot.model.IClass;
-import org.eclipse.mat.snapshot.model.IInstance;
-import org.eclipse.mat.snapshot.model.IObject;
-import org.eclipse.mat.snapshot.model.IObjectArray;
-import org.eclipse.mat.snapshot.model.NamedReference;
-import org.eclipse.mat.snapshot.model.ObjectReference;
-import org.eclipse.mat.snapshot.model.PrettyPrinter;
-import org.eclipse.mat.snapshot.model.ThreadToLocalReference;
-import org.eclipse.mat.util.VoidProgressListener;
 
 import static com.squareup.leakcanary.AnalysisResult.failure;
 import static com.squareup.leakcanary.AnalysisResult.leakDetected;
 import static com.squareup.leakcanary.AnalysisResult.noLeak;
+import static com.squareup.leakcanary.HahaHelper.asString;
+import static com.squareup.leakcanary.HahaHelper.classInstanceValues;
+import static com.squareup.leakcanary.HahaHelper.extendsThread;
+import static com.squareup.leakcanary.HahaHelper.fieldToString;
+import static com.squareup.leakcanary.HahaHelper.fieldValue;
+import static com.squareup.leakcanary.HahaHelper.threadName;
 import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
 import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
 import static com.squareup.leakcanary.LeakTraceElement.Holder.OBJECT;
 import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.INSTANCE_FIELD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.LOCAL;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-import static java.lang.Integer.MAX_VALUE;
-import static java.util.Collections.emptyMap;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
 /**
@@ -62,17 +56,10 @@
 public final class HeapAnalyzer {
 
   private static final String ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$";
-  private static final String TAG = "HeapAnalyzer";
 
-  private final ExcludedRefs baseExcludedRefs;
   private final ExcludedRefs excludedRefs;
 
   public HeapAnalyzer(ExcludedRefs excludedRefs) {
-    this(new ExcludedRefs.Builder().build(), excludedRefs);
-  }
-
-  public HeapAnalyzer(ExcludedRefs baseExcludedRefs, ExcludedRefs excludedRefs) {
-    this.baseExcludedRefs = baseExcludedRefs;
     this.excludedRefs = excludedRefs;
   }
 
@@ -88,303 +75,245 @@ public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
       return failure(exception, since(analysisStartNanoTime));
     }
 
-    ISnapshot snapshot = null;
     try {
-      snapshot = openSnapshot(heapDumpFile);
+      HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
+      HprofParser parser = new HprofParser(buffer);
+      Snapshot snapshot = parser.parse();
+      deduplicateGcRoots(snapshot);
 
-      IObject leakingRef = findLeakingReference(referenceKey, snapshot);
+      Instance leakingRef = findLeakingReference(referenceKey, snapshot);
 
       // False alarm, weak reference was cleared in between key check and heap dump.
       if (leakingRef == null) {
         return noLeak(since(analysisStartNanoTime));
       }
 
-      String className = leakingRef.getClazz().getName();
-
-      AnalysisResult result =
-          findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, className, true);
-
-      if (!result.leakFound) {
-        result = findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, className, false);
-      }
-
-      return result;
-    } catch (Exception e) {
+      return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);
+    } catch (Throwable e) {
       return failure(e, since(analysisStartNanoTime));
-    } finally {
-      cleanup(heapDumpFile, snapshot);
     }
   }
 
-  private AnalysisResult findLeakTrace(long analysisStartNanoTime, ISnapshot snapshot,
-      IObject leakingRef, String className, boolean excludingKnownLeaks) throws SnapshotException {
-
-    ExcludedRefs excludedRefs = excludingKnownLeaks ? this.excludedRefs : baseExcludedRefs;
-
-    PathsFromGCRootsTree gcRootsTree = shortestPathToGcRoots(snapshot, leakingRef, excludedRefs);
-
-    // False alarm, no strong reference path to GC Roots.
-    if (gcRootsTree == null) {
-      return noLeak(since(analysisStartNanoTime));
+  /**
+   * Pruning duplicates reduces memory pressure from hprof bloat added in Marshmallow.
+   */
+  void deduplicateGcRoots(Snapshot snapshot) {
+    // THashMap has a smaller memory footprint than HashMap.
+    final THashMap<String, RootObj> uniqueRootMap = new THashMap<>();
+
+    final List<RootObj> gcRoots = (ArrayList) snapshot.getGCRoots();
+    for (RootObj root : gcRoots) {
+      String key = generateRootKey(root);
+      if (!uniqueRootMap.containsKey(key)) {
+        uniqueRootMap.put(key, root);
+      }
     }
 
-    LeakTrace leakTrace = buildLeakTrace(snapshot, gcRootsTree, excludedRefs);
-
-    return leakDetected(!excludingKnownLeaks, className, leakTrace, since(analysisStartNanoTime));
+    // Repopulate snapshot with unique GC roots.
+    gcRoots.clear();
+    uniqueRootMap.forEach(new TObjectProcedure<String>() {
+      @Override
+      public boolean execute(String key) {
+        return gcRoots.add(uniqueRootMap.get(key));
+      }
+    });
   }
 
-  private ISnapshot openSnapshot(File heapDumpFile) throws SnapshotException {
-    SnapshotFactory factory = new SnapshotFactory();
-    Map<String, String> args = emptyMap();
-    VoidProgressListener listener = new VoidProgressListener();
-    return factory.openSnapshot(heapDumpFile, args, listener);
+  private String generateRootKey(RootObj root) {
+    return String.format("%s@0x%08x", root.getRootType().getName(), root.getId());
   }
 
-  private IObject findLeakingReference(String key, ISnapshot snapshot) throws SnapshotException {
-    Collection<IClass> refClasses =
-        snapshot.getClassesByName(KeyedWeakReference.class.getName(), false);
-
-    if (refClasses.size() != 1) {
-      throw new IllegalStateException(
-          "Expecting one class for " + KeyedWeakReference.class.getName() + " in " + refClasses);
-    }
-
-    IClass refClass = refClasses.iterator().next();
-
-    int[] weakRefInstanceIds = refClass.getObjectIds();
-
-    for (int weakRefInstanceId : weakRefInstanceIds) {
-      IObject weakRef = snapshot.getObject(weakRefInstanceId);
-      String keyCandidate =
-          PrettyPrinter.objectAsString((IObject) weakRef.resolveValue("key"), 100);
+  private Instance findLeakingReference(String key, Snapshot snapshot) {
+    ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());
+    List<String> keysFound = new ArrayList<>();
+    for (Instance instance : refClass.getInstancesList()) {
+      List<ClassInstance.FieldValue> values = classInstanceValues(instance);
+      String keyCandidate = asString(fieldValue(values, "key"));
       if (keyCandidate.equals(key)) {
-        return (IObject) weakRef.resolveValue("referent");
+        return fieldValue(values, "referent");
       }
+      keysFound.add(keyCandidate);
     }
-    throw new IllegalStateException("Could not find weak reference with key " + key);
+    throw new IllegalStateException(
+        "Could not find weak reference with key " + key + " in " + keysFound);
   }
 
-  private PathsFromGCRootsTree shortestPathToGcRoots(ISnapshot snapshot, IObject leakingRef,
-      ExcludedRefs excludedRefs) throws SnapshotException {
-    Map<IClass, Set<String>> excludeMap =
-        buildClassExcludeMap(snapshot, excludedRefs.excludeFieldMap);
+  private AnalysisResult findLeakTrace(long analysisStartNanoTime, Snapshot snapshot,
+      Instance leakingRef) {
 
-    IPathsFromGCRootsComputer pathComputer =
-        snapshot.getPathsFromGCRoots(leakingRef.getObjectId(), excludeMap);
-
-    return shortestValidPath(snapshot, pathComputer, excludedRefs);
-  }
+    ShortestPathFinder pathFinder = new ShortestPathFinder(excludedRefs);
+    ShortestPathFinder.Result result = pathFinder.findPath(snapshot, leakingRef);
 
-  private Map<IClass, Set<String>> buildClassExcludeMap(ISnapshot snapshot,
-      Map<String, Set<String>> excludeMap) throws SnapshotException {
-    Map<IClass, Set<String>> classExcludeMap = new LinkedHashMap<>();
-    for (Map.Entry<String, Set<String>> entry : excludeMap.entrySet()) {
-      Collection<IClass> refClasses = snapshot.getClassesByName(entry.getKey(), false);
-      if (refClasses != null && refClasses.size() == 1) {
-        IClass refClass = refClasses.iterator().next();
-        classExcludeMap.put(refClass, entry.getValue());
-      }
+    // False alarm, no strong reference path to GC Roots.
+    if (result.leakingNode == null) {
+      return noLeak(since(analysisStartNanoTime));
     }
-    return classExcludeMap;
-  }
 
-  private PathsFromGCRootsTree shortestValidPath(ISnapshot snapshot,
-      IPathsFromGCRootsComputer pathComputer, ExcludedRefs excludedRefs) throws SnapshotException {
+    LeakTrace leakTrace = buildLeakTrace(result.leakingNode);
 
-    Map<IClass, Set<String>> excludedStaticFields =
-        buildClassExcludeMap(snapshot, excludedRefs.excludeStaticFieldMap);
+    String className = leakingRef.getClassObj().getClassName();
 
-    int[] shortestPath;
+    // Side effect: computes retained size.
+    snapshot.computeDominators();
 
-    while ((shortestPath = pathComputer.getNextShortestPath()) != null) {
-      PathsFromGCRootsTree tree = pathComputer.getTree(Collections.singletonList(shortestPath));
-      if (validPath(snapshot, tree, excludedStaticFields, excludedRefs)) {
-        return tree;
-      }
-    }
-    // No more strong reference path.
-    return null;
+    Instance leakingInstance = result.leakingNode.instance;
+
+    long retainedSize = leakingInstance.getTotalRetainedSize();
+
+    retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance);
+
+    return leakDetected(result.excludingKnownLeaks, className, leakTrace, retainedSize,
+        since(analysisStartNanoTime));
   }
 
-  private boolean validPath(ISnapshot snapshot, PathsFromGCRootsTree tree,
-      Map<IClass, Set<String>> excludedStaticFields, ExcludedRefs excludedRefs)
-      throws SnapshotException {
-    if (excludedStaticFields.isEmpty() && excludedRefs.excludedThreads.isEmpty()) {
-      return true;
-    }
-    // Note: the first child is the leaking object, the last child is the GC root.
-    IObject held = null;
-    while (tree != null) {
-      IObject holder = snapshot.getObject(tree.getOwnId());
-      // Static field reference
-      if (holder instanceof IClass) {
-        IClass childClass = (IClass) holder;
-        Set<String> childClassExcludedFields = excludedStaticFields.get(childClass);
-        if (childClassExcludedFields != null) {
-          NamedReference ref = findHeldInHolder(held, holder, excludedRefs);
-          if (ref != null && childClassExcludedFields.contains(ref.getName())) {
-            return false;
-          }
+  /**
+   * Bitmaps and bitmap byte arrays are sometimes held by native gc roots, so they aren't included
+   * in the retained size because their root dominator is a native gc root.
+   * To fix this, we check if the leaking instance is a dominator for each bitmap instance and then
+   * add the bitmap size.
+   *
+   * From experience, we've found that bitmap created in code (Bitmap.createBitmap()) are correctly
+   * accounted for, however bitmaps set in layouts are not.
+   */
+  private int computeIgnoredBitmapRetainedSize(Snapshot snapshot, Instance leakingInstance) {
+    int bitmapRetainedSize = 0;
+    ClassObj bitmapClass = snapshot.findClass("android.graphics.Bitmap");
+
+    for (Instance bitmapInstance : bitmapClass.getInstancesList()) {
+      if (isIgnoredDominator(leakingInstance, bitmapInstance)) {
+        ArrayInstance mBufferInstance = fieldValue(classInstanceValues(bitmapInstance), "mBuffer");
+        // Native bitmaps have mBuffer set to null. We sadly can't account for them.
+        if (mBufferInstance == null) {
+          continue;
         }
-      } else if (holder.getClazz().doesExtend(Thread.class.getName())) {
-        if (excludedRefs.excludedThreads.contains(getThreadName(holder))) {
-          return false;
+        long bufferSize = mBufferInstance.getTotalRetainedSize();
+        long bitmapSize = bitmapInstance.getTotalRetainedSize();
+        // Sometimes the size of the buffer isn't accounted for in the bitmap retained size. Since
+        // the buffer is large, it's easy to detect by checking for bitmap size < buffer size.
+        if (bitmapSize < bufferSize) {
+          bitmapSize += bufferSize;
         }
+        bitmapRetainedSize += bitmapSize;
       }
-      held = holder;
-      int[] branchIds = tree.getObjectIds();
-      tree = branchIds.length > 0 ? tree.getBranch(branchIds[0]) : null;
     }
-    return true;
-  }
-
-  private String getThreadName(IObject thread) throws SnapshotException {
-    return PrettyPrinter.objectAsString((IObject) thread.resolveValue("name"), MAX_VALUE);
+    return bitmapRetainedSize;
   }
 
-  private NamedReference findHeldInHolder(IObject held, IObject holder, ExcludedRefs excludedRefs)
-      throws SnapshotException {
-    if (held == null) {
-      return null;
-    }
-    Set<String> excludedFields = excludedRefs.excludeFieldMap.get(holder.getClazz().getName());
-    for (NamedReference holdingRef : holder.getOutboundReferences()) {
-      if (holdingRef.getObjectId() == held.getObjectId() && (excludedFields == null
-          || !excludedFields.contains(holdingRef.getName()))) {
-        return holdingRef;
+  private boolean isIgnoredDominator(Instance dominator, Instance instance) {
+    boolean foundNativeRoot = false;
+    while (true) {
+      Instance immediateDominator = instance.getImmediateDominator();
+      if (immediateDominator instanceof RootObj
+          && ((RootObj) immediateDominator).getRootType() == RootType.UNKNOWN) {
+        // Ignore native roots
+        instance = instance.getNextInstanceToGcRoot();
+        foundNativeRoot = true;
+      } else {
+        instance = immediateDominator;
+      }
+      if (instance == null) {
+        return false;
+      }
+      if (instance == dominator) {
+        return foundNativeRoot;
       }
     }
-    return null;
   }
 
-  private LeakTrace buildLeakTrace(ISnapshot snapshot, PathsFromGCRootsTree tree,
-      ExcludedRefs excludedRefs) throws SnapshotException {
+  private LeakTrace buildLeakTrace(LeakNode leakingNode) {
     List<LeakTraceElement> elements = new ArrayList<>();
     // We iterate from the leak to the GC root
-    IObject held = null;
-    while (tree != null) {
-      IObject holder = snapshot.getObject(tree.getOwnId());
-      elements.add(0, buildLeakElement(held, holder, excludedRefs));
-      held = holder;
-      int[] branchIds = tree.getObjectIds();
-      tree = branchIds.length > 0 ? tree.getBranch(branchIds[0]) : null;
+    LeakNode node = new LeakNode(null, null, leakingNode, null, null);
+    while (node != null) {
+      LeakTraceElement element = buildLeakElement(node);
+      if (element != null) {
+        elements.add(0, element);
+      }
+      node = node.parent;
     }
     return new LeakTrace(elements);
   }
 
-  private LeakTraceElement buildLeakElement(IObject held, IObject holder, ExcludedRefs excludedRefs)
-      throws SnapshotException {
-    LeakTraceElement.Type type = null;
-    String referenceName = null;
-    NamedReference holdingRef = findHeldInHolder(held, holder, excludedRefs);
-    if (holdingRef != null) {
-      referenceName = holdingRef.getName();
-      if (holder instanceof IClass) {
-        type = STATIC_FIELD;
-      } else if (holdingRef instanceof ThreadToLocalReference) {
-        type = LOCAL;
-      } else {
-        type = INSTANCE_FIELD;
-      }
+  private LeakTraceElement buildLeakElement(LeakNode node) {
+    if (node.parent == null) {
+      // Ignore any root node.
+      return null;
     }
+    Instance holder = node.parent.instance;
+
+    if (holder instanceof RootObj) {
+      return null;
+    }
+    LeakTraceElement.Type type = node.referenceType;
+    String referenceName = node.referenceName;
 
     LeakTraceElement.Holder holderType;
     String className;
     String extra = null;
     List<String> fields = new ArrayList<>();
-    if (holder instanceof IClass) {
-      IClass clazz = (IClass) holder;
+    if (holder instanceof ClassObj) {
+      ClassObj classObj = (ClassObj) holder;
       holderType = CLASS;
-      className = clazz.getName();
-      for (Field staticField : clazz.getStaticFields()) {
-        fields.add("static " + fieldToString(staticField));
+      className = classObj.getClassName();
+      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
+        Field field = entry.getKey();
+        Object value = entry.getValue();
+        fields.add("static " + field.getName() + " = " + value);
       }
-    } else if (holder instanceof IArray) {
+    } else if (holder instanceof ArrayInstance) {
+      ArrayInstance arrayInstance = (ArrayInstance) holder;
       holderType = ARRAY;
-      IClass clazz = holder.getClazz();
-      className = clazz.getName();
-      if (holder instanceof IObjectArray) {
-        IObjectArray array = (IObjectArray) holder;
-        int i = 0;
-        ISnapshot snapshot = holder.getSnapshot();
-        for (long address : array.getReferenceArray()) {
-          if (address == 0) {
-            fields.add("[" + i + "] = null");
-          } else {
-            int objectId = snapshot.mapAddressToId(address);
-            IObject object = snapshot.getObject(objectId);
-            fields.add("[" + i + "] = " + object);
-          }
-          i++;
+      className = arrayInstance.getClassObj().getClassName();
+      if (arrayInstance.getArrayType() == Type.OBJECT) {
+        Object[] values = arrayInstance.getValues();
+        for (int i = 0; i < values.length; i++) {
+          fields.add("[" + i + "] = " + values[i]);
         }
       }
     } else {
-      IInstance instance = (IInstance) holder;
-      IClass clazz = holder.getClazz();
-      for (Field staticField : clazz.getStaticFields()) {
-        fields.add("static " + fieldToString(staticField));
+      ClassInstance classInstance = (ClassInstance) holder;
+      ClassObj classObj = holder.getClassObj();
+      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
+        fields.add("static " + fieldToString(entry));
       }
-      for (Field field : instance.getFields()) {
+      for (ClassInstance.FieldValue field : classInstance.getValues()) {
         fields.add(fieldToString(field));
       }
-      className = clazz.getName();
-      if (clazz.doesExtend(Thread.class.getName())) {
+      className = classObj.getClassName();
+
+      if (extendsThread(classObj)) {
         holderType = THREAD;
-        String threadName = getThreadName(holder);
+        String threadName = threadName(holder);
         extra = "(named '" + threadName + "')";
       } else if (className.matches(ANONYMOUS_CLASS_NAME_PATTERN)) {
-        String parentClassName = clazz.getSuperClass().getName();
+        String parentClassName = classObj.getSuperClassObj().getClassName();
         if (Object.class.getName().equals(parentClassName)) {
           holderType = OBJECT;
-          // This is an anonymous class implementing an interface. The API does not give access
-          // to the interfaces implemented by the class. Let's see if it's in the class path and
-          // use that instead.
           try {
-            Class<?> actualClass = Class.forName(clazz.getName());
-            Class<?> implementedInterface = actualClass.getInterfaces()[0];
-            extra = "(anonymous class implements " + implementedInterface.getName() + ")";
+            // This is an anonymous class implementing an interface. The API does not give access
+            // to the interfaces implemented by the class. We check if it's in the class path and
+            // use that instead.
+            Class<?> actualClass = Class.forName(classObj.getClassName());
+            Class<?>[] interfaces = actualClass.getInterfaces();
+            if (interfaces.length > 0) {
+              Class<?> implementedInterface = interfaces[0];
+              extra = "(anonymous implementation of " + implementedInterface.getName() + ")";
+            } else {
+              extra = "(anonymous subclass of java.lang.Object)";
+            }
           } catch (ClassNotFoundException ignored) {
           }
         } else {
           holderType = OBJECT;
           // Makes it easier to figure out which anonymous class we're looking at.
-          extra = "(anonymous class extends " + parentClassName + ")";
+          extra = "(anonymous subclass of " + parentClassName + ")";
         }
       } else {
         holderType = OBJECT;
       }
     }
-    return new LeakTraceElement(referenceName, type, holderType, className, extra, fields);
-  }
-
-  private String fieldToString(Field field) throws SnapshotException {
-    Object value = field.getValue();
-    if (value instanceof ObjectReference) {
-      value = ((ObjectReference) value).getObject();
-    }
-    return field.getName() + " = " + value;
-  }
-
-  private void cleanup(File heapDumpFile, ISnapshot snapshot) {
-    if (snapshot != null) {
-      snapshot.dispose();
-    }
-    final String heapDumpFileName = heapDumpFile.getName();
-    final String prefix =
-        heapDumpFileName.substring(0, heapDumpFile.getName().length() - ".hprof".length());
-    File[] toRemove = heapDumpFile.getParentFile().listFiles(new FileFilter() {
-      @Override public boolean accept(File file) {
-        return !file.isDirectory() && file.getName().startsWith(prefix) && !file.getName()
-            .equals(heapDumpFileName);
-      }
-    });
-    if (toRemove != null) {
-      for (File file : toRemove) {
-        file.delete();
-      }
-    } else {
-      Log.d(TAG, "Could not find HAHA files to cleanup.");
-    }
+    return new LeakTraceElement(referenceName, type, holderType, className, extra, node.exclusion,
+        fields);
   }
 
   private long since(long analysisStartNanoTime) {
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
new file mode 100644
index 00000000..b30df278
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import com.squareup.haha.perflib.Instance;
+
+final class LeakNode {
+  /** May be null. */
+  final Exclusion exclusion;
+  final Instance instance;
+  final LeakNode parent;
+  final String referenceName;
+  final LeakTraceElement.Type referenceType;
+
+  LeakNode(Exclusion exclusion, Instance instance, LeakNode parent,
+      String referenceName, LeakTraceElement.Type referenceType) {
+    this.exclusion = exclusion;
+    this.instance = instance;
+    this.parent = parent;
+    this.referenceName = referenceName;
+    this.referenceType = referenceType;
+  }
+}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
index 7838fcac..89ef31e3 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
@@ -30,7 +30,7 @@
 public final class LeakTraceElement implements Serializable {
 
   public enum Type {
-    INSTANCE_FIELD, STATIC_FIELD, LOCAL
+    INSTANCE_FIELD, STATIC_FIELD, LOCAL, ARRAY_ENTRY
   }
 
   public enum Holder {
@@ -48,16 +48,20 @@
   /** Additional information, may be null. */
   public final String extra;
 
+  /** If not null, there was no path that could exclude this element. */
+  public final Exclusion exclusion;
+
   /** List of all fields (member and static) for that object. */
   public final List<String> fields;
 
   LeakTraceElement(String referenceName, Type type, Holder holder, String className, String extra,
-      List<String> fields) {
+      Exclusion exclusion, List<String> fields) {
     this.referenceName = referenceName;
     this.type = type;
     this.holder = holder;
     this.className = className;
     this.extra = extra;
+    this.exclusion = exclusion;
     this.fields = unmodifiableList(new ArrayList<>(fields));
   }
 
@@ -83,6 +87,11 @@
     if (extra != null) {
       string += " " + extra;
     }
+
+    if (exclusion != null) {
+      string += " , matching exclusion " + exclusion.matching;
+    }
+
     return string;
   }
 
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
new file mode 100644
index 00000000..e9c49d43
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import com.squareup.haha.perflib.ArrayInstance;
+import com.squareup.haha.perflib.ClassInstance;
+import com.squareup.haha.perflib.ClassObj;
+import com.squareup.haha.perflib.Field;
+import com.squareup.haha.perflib.HahaSpy;
+import com.squareup.haha.perflib.Instance;
+import com.squareup.haha.perflib.RootObj;
+import com.squareup.haha.perflib.RootType;
+import com.squareup.haha.perflib.Snapshot;
+import com.squareup.haha.perflib.Type;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.Map;
+import java.util.Queue;
+
+import static com.squareup.leakcanary.HahaHelper.isPrimitiveOrWrapperArray;
+import static com.squareup.leakcanary.HahaHelper.isPrimitiveWrapper;
+import static com.squareup.leakcanary.HahaHelper.threadName;
+import static com.squareup.leakcanary.LeakTraceElement.Type.ARRAY_ENTRY;
+import static com.squareup.leakcanary.LeakTraceElement.Type.INSTANCE_FIELD;
+import static com.squareup.leakcanary.LeakTraceElement.Type.LOCAL;
+import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
+
+/**
+ * Not thread safe.
+ *
+ * Finds the shortest path from a leaking reference to a gc root, ignoring excluded
+ * refs first and then including the ones that are not "always ignorable" as needed if no path is
+ * found.
+ */
+final class ShortestPathFinder {
+
+  private final ExcludedRefs excludedRefs;
+  private final Queue<LeakNode> toVisitQueue;
+  private final Queue<LeakNode> toVisitIfNoPathQueue;
+  private final LinkedHashSet<Instance> toVisitSet;
+  private final LinkedHashSet<Instance> toVisitIfNoPathSet;
+  private final LinkedHashSet<Instance> visitedSet;
+  private boolean canIgnoreStrings;
+
+  ShortestPathFinder(ExcludedRefs excludedRefs) {
+    this.excludedRefs = excludedRefs;
+    toVisitQueue = new LinkedList<>();
+    toVisitIfNoPathQueue = new LinkedList<>();
+    toVisitSet = new LinkedHashSet<>();
+    toVisitIfNoPathSet = new LinkedHashSet<>();
+    visitedSet = new LinkedHashSet<>();
+  }
+
+  static final class Result {
+    final LeakNode leakingNode;
+    final boolean excludingKnownLeaks;
+
+    Result(LeakNode leakingNode, boolean excludingKnownLeaks) {
+      this.leakingNode = leakingNode;
+      this.excludingKnownLeaks = excludingKnownLeaks;
+    }
+  }
+
+  Result findPath(Snapshot snapshot, Instance leakingRef) {
+    clearState();
+    canIgnoreStrings = !isString(leakingRef);
+
+    enqueueGcRoots(snapshot);
+
+    boolean excludingKnownLeaks = false;
+    LeakNode leakingNode = null;
+    while (!toVisitQueue.isEmpty() || !toVisitIfNoPathQueue.isEmpty()) {
+      LeakNode node;
+      if (!toVisitQueue.isEmpty()) {
+        node = toVisitQueue.poll();
+      } else {
+        node = toVisitIfNoPathQueue.poll();
+        if (node.exclusion == null) {
+          throw new IllegalStateException("Expected node to have an exclusion " + node);
+        }
+        excludingKnownLeaks = true;
+      }
+
+      // Termination
+      if (node.instance == leakingRef) {
+        leakingNode = node;
+        break;
+      }
+
+      if (checkSeen(node)) {
+        continue;
+      }
+
+      if (node.instance instanceof RootObj) {
+        visitRootObj(node);
+      } else if (node.instance instanceof ClassObj) {
+        visitClassObj(node);
+      } else if (node.instance instanceof ClassInstance) {
+        visitClassInstance(node);
+      } else if (node.instance instanceof ArrayInstance) {
+        visitArrayInstance(node);
+      } else {
+        throw new IllegalStateException("Unexpected type for " + node.instance);
+      }
+    }
+    return new Result(leakingNode, excludingKnownLeaks);
+  }
+
+  private void clearState() {
+    toVisitQueue.clear();
+    toVisitIfNoPathQueue.clear();
+    toVisitSet.clear();
+    toVisitIfNoPathSet.clear();
+    visitedSet.clear();
+  }
+
+  private void enqueueGcRoots(Snapshot snapshot) {
+    for (RootObj rootObj : snapshot.getGCRoots()) {
+      switch (rootObj.getRootType()) {
+        case JAVA_LOCAL:
+          Instance thread = HahaSpy.allocatingThread(rootObj);
+          String threadName = threadName(thread);
+          Exclusion params = excludedRefs.threadNames.get(threadName);
+          if (params == null || !params.alwaysExclude) {
+            enqueue(params, null, rootObj, null, null);
+          }
+          break;
+        case INTERNED_STRING:
+        case DEBUGGER:
+        case INVALID_TYPE:
+          // An object that is unreachable from any other root, but not a root itself.
+        case UNREACHABLE:
+        case UNKNOWN:
+          // An object that is in a queue, waiting for a finalizer to run.
+        case FINALIZING:
+          break;
+        case SYSTEM_CLASS:
+        case VM_INTERNAL:
+          // A local variable in native code.
+        case NATIVE_LOCAL:
+          // A global variable in native code.
+        case NATIVE_STATIC:
+          // An object that was referenced from an active thread block.
+        case THREAD_BLOCK:
+          // Everything that called the wait() or notify() methods, or that is synchronized.
+        case BUSY_MONITOR:
+        case NATIVE_MONITOR:
+        case REFERENCE_CLEANUP:
+          // Input or output parameters in native code.
+        case NATIVE_STACK:
+        case JAVA_STATIC:
+          enqueue(null, null, rootObj, null, null);
+          break;
+        default:
+          throw new UnsupportedOperationException("Unknown root type:" + rootObj.getRootType());
+      }
+    }
+  }
+
+  private boolean checkSeen(LeakNode node) {
+    return !visitedSet.add(node.instance);
+  }
+
+  private void visitRootObj(LeakNode node) {
+    RootObj rootObj = (RootObj) node.instance;
+    Instance child = rootObj.getReferredInstance();
+
+    if (rootObj.getRootType() == RootType.JAVA_LOCAL) {
+      Instance holder = HahaSpy.allocatingThread(rootObj);
+      // We switch the parent node with the thread instance that holds
+      // the local reference.
+      Exclusion exclusion = null;
+      if (node.exclusion != null) {
+        exclusion = node.exclusion;
+      }
+      LeakNode parent = new LeakNode(null, holder, null, null, null);
+      enqueue(exclusion, parent, child, "<Java Local>", LOCAL);
+    } else {
+      enqueue(null, node, child, null, null);
+    }
+  }
+
+  private void visitClassObj(LeakNode node) {
+    ClassObj classObj = (ClassObj) node.instance;
+    Map<String, Exclusion> ignoredStaticFields =
+        excludedRefs.staticFieldNameByClassName.get(classObj.getClassName());
+    for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
+      Field field = entry.getKey();
+      if (field.getType() != Type.OBJECT) {
+        continue;
+      }
+      String fieldName = field.getName();
+      if (fieldName.equals("$staticOverhead")) {
+        continue;
+      }
+      Instance child = (Instance) entry.getValue();
+      boolean visit = true;
+      if (ignoredStaticFields != null) {
+        Exclusion params = ignoredStaticFields.get(fieldName);
+        if (params != null) {
+          visit = false;
+          if (!params.alwaysExclude) {
+            enqueue(params, node, child, fieldName, STATIC_FIELD);
+          }
+        }
+      }
+      if (visit) {
+        enqueue(null, node, child, fieldName, STATIC_FIELD);
+      }
+    }
+  }
+
+  private void visitClassInstance(LeakNode node) {
+    ClassInstance classInstance = (ClassInstance) node.instance;
+    Map<String, Exclusion> ignoredFields = new LinkedHashMap<>();
+    ClassObj superClassObj = classInstance.getClassObj();
+    Exclusion classExclusion = null;
+    while (superClassObj != null) {
+      Exclusion params = excludedRefs.classNames.get(superClassObj.getClassName());
+      if (params != null) {
+        // true overrides null or false.
+        if (classExclusion == null || !classExclusion.alwaysExclude) {
+          classExclusion = params;
+        }
+      }
+      Map<String, Exclusion> classIgnoredFields =
+          excludedRefs.fieldNameByClassName.get(superClassObj.getClassName());
+      if (classIgnoredFields != null) {
+        ignoredFields.putAll(classIgnoredFields);
+      }
+      superClassObj = superClassObj.getSuperClassObj();
+    }
+
+    if (classExclusion != null && classExclusion.alwaysExclude) {
+      return;
+    }
+
+    for (ClassInstance.FieldValue fieldValue : classInstance.getValues()) {
+      Exclusion fieldExclusion = classExclusion;
+      Field field = fieldValue.getField();
+      if (field.getType() != Type.OBJECT) {
+        continue;
+      }
+      Instance child = (Instance) fieldValue.getValue();
+      String fieldName = field.getName();
+      Exclusion params = ignoredFields.get(fieldName);
+      // If we found a field exclusion and it's stronger than a class exclusion
+      if (params != null && (fieldExclusion == null || (params.alwaysExclude
+          && !fieldExclusion.alwaysExclude))) {
+        fieldExclusion = params;
+      }
+      enqueue(fieldExclusion, node, child, fieldName, INSTANCE_FIELD);
+    }
+  }
+
+  private void visitArrayInstance(LeakNode node) {
+    ArrayInstance arrayInstance = (ArrayInstance) node.instance;
+    Type arrayType = arrayInstance.getArrayType();
+    if (arrayType == Type.OBJECT) {
+      Object[] values = arrayInstance.getValues();
+      for (int i = 0; i < values.length; i++) {
+        Instance child = (Instance) values[i];
+        enqueue(null, node, child, "[" + i + "]", ARRAY_ENTRY);
+      }
+    }
+  }
+
+  private void enqueue(Exclusion exclusion, LeakNode parent, Instance child, String referenceName,
+      LeakTraceElement.Type referenceType) {
+    if (child == null) {
+      return;
+    }
+    if (isPrimitiveOrWrapperArray(child) || isPrimitiveWrapper(child)) {
+      return;
+    }
+    // Whether we want to visit now or later, we should skip if this is already to visit.
+    if (toVisitSet.contains(child)) {
+      return;
+    }
+    boolean visitNow = exclusion == null;
+    if (!visitNow && toVisitIfNoPathSet.contains(child)) {
+      return;
+    }
+    if (canIgnoreStrings && isString(child)) {
+      return;
+    }
+    if (visitedSet.contains(child)) {
+      return;
+    }
+    LeakNode childNode = new LeakNode(exclusion, child, parent, referenceName, referenceType);
+    if (visitNow) {
+      toVisitSet.add(child);
+      toVisitQueue.add(childNode);
+    } else {
+      toVisitIfNoPathSet.add(child);
+      toVisitIfNoPathQueue.add(childNode);
+    }
+  }
+
+  private boolean isString(Instance instance) {
+    return instance.getClassObj() != null && instance.getClassObj()
+        .getClassName()
+        .equals(String.class.getName());
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java
new file mode 100644
index 00000000..ad43d493
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import java.lang.ref.WeakReference;
+import java.util.Collection;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
+import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_MPREVIEW2;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_M_POSTPREVIEW2;
+import static com.squareup.leakcanary.TestUtil.analyze;
+import static java.util.Arrays.asList;
+import static org.hamcrest.core.StringContains.containsString;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+
+@RunWith(Parameterized.class) //
+public class AsyncTaskLeakTest {
+
+  static final String ASYNC_TASK_THREAD = "AsyncTask #1";
+  static final String ASYNC_TASK_CLASS = "android.os.AsyncTask";
+  static final String EXECUTOR_FIELD_1 = "SERIAL_EXECUTOR";
+  static final String EXECUTOR_FIELD_2 = "sDefaultExecutor";
+
+  @Parameterized.Parameters public static Collection<Object[]> data() {
+    return asList(new Object[][] {
+        { ASYNC_TASK }, //
+        { ASYNC_TASK_MPREVIEW2 }, //
+        { ASYNC_TASK_M_POSTPREVIEW2 } //
+    });
+  }
+
+  private final TestUtil.HeapDumpFile heapDumpFile;
+  ExcludedRefs.BuilderWithParams excludedRefs;
+
+  public AsyncTaskLeakTest(TestUtil.HeapDumpFile heapDumpFile) {
+    this.heapDumpFile = heapDumpFile;
+  }
+
+  @Before public void setUp() {
+    excludedRefs = new ExcludedRefs.BuilderWithParams().clazz(WeakReference.class.getName())
+        .alwaysExclude()
+        .clazz("java.lang.ref.FinalizerReference")
+        .alwaysExclude();
+  }
+
+  @Test public void leakFound() {
+    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
+    assertTrue(result.leakFound);
+    assertFalse(result.excludedLeak);
+    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
+    assertEquals(Thread.class.getName(), gcRoot.className);
+    assertEquals(THREAD, gcRoot.holder);
+    assertThat(gcRoot.extra, containsString(ASYNC_TASK_THREAD));
+  }
+
+  @Test public void excludeThread() {
+    excludedRefs.thread(ASYNC_TASK_THREAD);
+    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
+    assertTrue(result.leakFound);
+    assertFalse(result.excludedLeak);
+    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
+    assertEquals(ASYNC_TASK_CLASS, gcRoot.className);
+    assertEquals(STATIC_FIELD, gcRoot.type);
+    assertTrue(gcRoot.referenceName.equals(EXECUTOR_FIELD_1) || gcRoot.referenceName.equals(
+        EXECUTOR_FIELD_2));
+  }
+
+  @Test public void excludeStatic() {
+    excludedRefs.thread(ASYNC_TASK_THREAD).named(ASYNC_TASK_THREAD);
+    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_1).named(EXECUTOR_FIELD_1);
+    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_2).named(EXECUTOR_FIELD_2);
+    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
+    assertTrue(result.leakFound);
+    assertTrue(result.excludedLeak);
+    LeakTrace leakTrace = result.leakTrace;
+    List<LeakTraceElement> elements = leakTrace.elements;
+    Exclusion exclusion = elements.get(0).exclusion;
+
+    List<String> expectedExclusions = asList(ASYNC_TASK_THREAD, EXECUTOR_FIELD_1, EXECUTOR_FIELD_2);
+    assertTrue(expectedExclusions.contains(exclusion.name));
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java
new file mode 100644
index 00000000..ba62c2ad
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java
@@ -0,0 +1,101 @@
+package com.squareup.leakcanary;
+
+import com.squareup.haha.perflib.io.HprofBuffer;
+
+import java.io.UnsupportedEncodingException;
+import java.util.List;
+
+public final class FakeHprofBuffer implements HprofBuffer {
+  private List<Byte> byteList;
+  private List<byte[]> byteArrayList;
+
+  private int[] intsToRead;
+  private int intIndex = -1;
+  private String[] stringsToRead;
+  private int stringIndex = -1;
+
+  public void setIntsToRead(int... ints) {
+    intsToRead = ints;
+    intIndex = 0;
+  }
+
+  public void setStringsToRead(String... strings) {
+    stringsToRead = strings;
+    stringIndex = 0;
+  }
+
+  @Override
+  public byte readByte() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public void read(byte[] bytes) {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public void readSubSequence(byte[] bytes, int start, int length) {
+    if (stringsToRead == null || stringIndex < 0 || stringIndex >= stringsToRead.length) {
+      throw new UnsupportedOperationException("no bytes to read");
+    }
+
+    String s = stringsToRead[stringIndex++];
+    try {
+      System.arraycopy(s.getBytes("UTF-16BE"), start, bytes, 0, length);
+    } catch (UnsupportedEncodingException e) {
+      throw new UnsupportedOperationException(e);
+    }
+  }
+
+  @Override
+  public char readChar() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public short readShort() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public int readInt() {
+    if (intsToRead == null || intIndex < 0 || intIndex >= intsToRead.length) {
+      throw new UnsupportedOperationException("no bytes to read");
+    }
+    return intsToRead[intIndex++];
+  }
+
+  @Override
+  public long readLong() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public float readFloat() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public double readDouble() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public void setPosition(long l) {}
+
+  @Override
+  public long position() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public boolean hasRemaining() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public long remaining() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
new file mode 100644
index 00000000..03178cbe
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
@@ -0,0 +1,146 @@
+package com.squareup.leakcanary;
+
+import com.squareup.haha.perflib.ArrayInstance;
+import com.squareup.haha.perflib.ClassInstance;
+import com.squareup.haha.perflib.ClassObj;
+import com.squareup.haha.perflib.Field;
+import com.squareup.haha.perflib.Snapshot;
+import com.squareup.haha.perflib.Type;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class HahaHelperTest {
+  private static final int STRING_CLASS_ID = 100;
+  private static final int CHAR_ARRAY_CLASS_ID = 101;
+  private static final int STRING_INSTANCE_ID = 102;
+  private static final int VALUE_ARRAY_INSTANCE_ID = 103;
+
+  private static final int VALUE_ARRAY_LENGTH = 6;
+  private static final int COUNT_VALUE = 5;
+  private static final int OFFSET_VALUE = 1;
+
+  private FakeHprofBuffer buffer;
+  private Snapshot snapshot;
+
+  @Before
+  public void setUp() {
+    buffer = new FakeHprofBuffer();
+
+    snapshot = new Snapshot(buffer);
+    // set HPROF identifier size; required for Object instance field lookups
+    // cf. https://java.net/downloads/heap-snapshot/hprof-binary-format.html
+    snapshot.setIdSize(4);
+  }
+
+  @Test
+  public void readStringOffsetFromHeapDumpInstance() {
+    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
+    buffer.setStringsToRead("abcdef");
+
+    addStringClassToSnapshotWithFields(snapshot, new Field[]{
+            new Field(Type.INT, "count"),
+            new Field(Type.INT, "offset"),
+            new Field(Type.OBJECT, "value")
+    });
+
+    ClassInstance stringInstance = createStringInstance();
+    createCharArrayValueInstance();
+
+    String actual = HahaHelper.asString(stringInstance);
+    assertTrue(actual.equals("bcdef"));
+  }
+
+  @Test
+  public void defaultToZeroStringOffsetWhenHeapDumpInstanceIsMissingOffsetValue() {
+    buffer.setIntsToRead(COUNT_VALUE, VALUE_ARRAY_INSTANCE_ID);
+    buffer.setStringsToRead("abcdef");
+
+    addStringClassToSnapshotWithFields(snapshot, new Field[]{
+            new Field(Type.INT, "count"),
+            new Field(Type.OBJECT, "value")
+    });
+
+    ClassInstance stringInstance = createStringInstance();
+    createCharArrayValueInstance();
+
+    String actual = HahaHelper.asString(stringInstance);
+    assertTrue(actual.equals("abcde"));
+  }
+
+  @Test
+  public void defaultToZeroStringOffsetWhenReadingMPreview2HeapDump() {
+    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
+    buffer.setStringsToRead("abcdef");
+
+    addStringClassToSnapshotWithFields(snapshot, new Field[]{
+            new Field(Type.INT, "count"),
+            new Field(Type.INT, "offset"),
+            new Field(Type.OBJECT, "value")
+    });
+
+    ClassInstance stringInstance = createStringInstance();
+    createCharArrayValueInstance_M_Preview2();
+
+    String actual = HahaHelper.asString(stringInstance);
+    assertTrue(actual.equals("abcde"));
+  }
+
+  @Test
+  public void throwExceptionWhenMissingCharArrayValueForStringInMPreview2HeapDump() {
+    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
+    buffer.setStringsToRead("abcdef");
+
+    addStringClassToSnapshotWithFields(snapshot, new Field[]{
+            new Field(Type.INT, "count"),
+            new Field(Type.INT, "offset"),
+            new Field(Type.OBJECT, "value")
+    });
+
+    ClassInstance stringInstance = createStringInstance();
+    createObjectValueInstance_M_Preview2();
+
+    try {
+      HahaHelper.asString(stringInstance);
+      fail("this test should have thrown UnsupportedOperationException");
+    }
+    catch (UnsupportedOperationException uoe) {
+      String message = uoe.getMessage();
+      assertTrue(message.equals("Could not find char array in " + stringInstance));
+    }
+  }
+
+  private void addStringClassToSnapshotWithFields(Snapshot snapshot, Field[] fields) {
+    ClassObj charArrayClass = new ClassObj(0, null, "char[]", 0);
+    snapshot.addClass(CHAR_ARRAY_CLASS_ID, charArrayClass);
+
+    ClassObj stringClass = new ClassObj(0, null, "string", 0);
+    stringClass.setFields(fields);
+    snapshot.addClass(STRING_CLASS_ID, stringClass);
+  }
+
+  private void createCharArrayValueInstance() {
+    ArrayInstance valueArrayInstance = new ArrayInstance(0, null, Type.CHAR, VALUE_ARRAY_LENGTH, 0);
+    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID, valueArrayInstance);
+  }
+
+  private void createCharArrayValueInstance_M_Preview2() {
+    ArrayInstance valueInstance = new ArrayInstance(0, null, Type.CHAR, VALUE_ARRAY_LENGTH, 0);
+    snapshot.addInstance(STRING_INSTANCE_ID + 16, valueInstance);
+  }
+
+  private void createObjectValueInstance_M_Preview2() {
+    ClassInstance valueInstance = new ClassInstance(0, null, 0);
+    snapshot.addInstance(STRING_INSTANCE_ID + 16, valueInstance);
+  }
+
+  private ClassInstance createStringInstance() {
+    ClassInstance stringInstance = new ClassInstance(STRING_INSTANCE_ID, null, 100);
+    stringInstance.setClassId(STRING_CLASS_ID);
+    snapshot.addInstance(0, stringInstance);
+    return stringInstance;
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
index e1f88416..0d5607d8 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
@@ -1,83 +1,61 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
 package com.squareup.leakcanary;
 
-import java.io.File;
+import com.squareup.haha.perflib.RootObj;
+import com.squareup.haha.perflib.Snapshot;
+
+import org.junit.Before;
 import org.junit.Test;
 
-import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-import static org.hamcrest.core.StringContains.containsString;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+import static com.squareup.haha.perflib.RootType.NATIVE_STATIC;
+import static com.squareup.haha.perflib.RootType.SYSTEM_CLASS;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class HeapAnalyzerTest {
+  private static final ExcludedRefs NO_EXCLUDED_REFS = null;
+  private static final List<RootObj> DUP_ROOTS =
+          asList(new RootObj(SYSTEM_CLASS, 6L),
+                  new RootObj(SYSTEM_CLASS, 5L),
+                  new RootObj(SYSTEM_CLASS, 3L),
+                  new RootObj(SYSTEM_CLASS, 5L),
+                  new RootObj(NATIVE_STATIC, 3L));
+
+  private HeapAnalyzer heapAnalyzer;
+
+  @Before
+  public void setUp() {
+    heapAnalyzer = new HeapAnalyzer(NO_EXCLUDED_REFS);
+  }
 
-  static final ExcludedRefs NONE = new ExcludedRefs.Builder().build();
+  @Test
+  public void ensureUniqueRoots() {
+    Snapshot snapshot = createSnapshot(DUP_ROOTS);
 
-  static final String ASYNC_TASK_THREAD = "AsyncTask #1";
-  static final String ASYNC_TASK_CLASS = "android.os.AsyncTask";
-  static final String EXECUTOR_FIELD = "SERIAL_EXECUTOR";
+    heapAnalyzer.deduplicateGcRoots(snapshot);
 
-  @Test public void leakFound() {
-    AnalysisResult result = analyze(new HeapAnalyzer(NONE));
-    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
-    assertTrue(result.leakFound);
-    assertFalse(result.excludedLeak);
-    assertEquals(Thread.class.getName(), gcRoot.className);
-    assertEquals(THREAD, gcRoot.holder);
-    assertThat(gcRoot.extra, containsString(ASYNC_TASK_THREAD));
-  }
+    Collection<RootObj> uniqueRoots = snapshot.getGCRoots();
+    assertThat(uniqueRoots).hasSize(4);
 
-  @Test public void excludeThread() {
-    ExcludedRefs.Builder excludedRefs = new ExcludedRefs.Builder();
-    excludedRefs.thread(ASYNC_TASK_THREAD);
-    AnalysisResult result = analyze(new HeapAnalyzer(excludedRefs.build()));
-    assertTrue(result.leakFound);
-    assertFalse(result.excludedLeak);
-    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
-    assertEquals(ASYNC_TASK_CLASS, gcRoot.className);
-    assertEquals(STATIC_FIELD, gcRoot.type);
-    assertEquals(EXECUTOR_FIELD, gcRoot.referenceName);
-  }
-
-  @Test public void excludeStatic() {
-    ExcludedRefs.Builder excludedRefs = new ExcludedRefs.Builder();
-    excludedRefs.thread(ASYNC_TASK_THREAD);
-    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD);
-    AnalysisResult result = analyze(new HeapAnalyzer(excludedRefs.build()));
-    assertTrue(result.leakFound);
-    assertTrue(result.excludedLeak);
-  }
+    List<Long> rootIds = new ArrayList<>();
+    for (RootObj root : uniqueRoots) {
+      rootIds.add(root.getId());
+    }
+    Collections.sort(rootIds);
 
-  @Test public void excludeStaticForBase() {
-    ExcludedRefs.Builder excludedRefs = new ExcludedRefs.Builder();
-    excludedRefs.thread(ASYNC_TASK_THREAD);
-    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD);
-    AnalysisResult result = analyze(new HeapAnalyzer(excludedRefs.build(), excludedRefs.build()));
-    assertFalse(result.leakFound);
+    // 3 appears twice because even though two RootObjs have the same id, they're different types.
+    assertThat(rootIds).containsExactly(3L, 3L, 5L, 6L);
   }
 
-  private AnalysisResult analyze(HeapAnalyzer heapAnalyzer) {
-    File heapDumpFile = new File(Thread.currentThread()
-        .getContextClassLoader()
-        .getResource("leak_asynctask.hprof")
-        .getPath());
-    return heapAnalyzer.checkForLeak(heapDumpFile, "dc983a12-d029-4003-8890-7dd644c664c5");
+  private Snapshot createSnapshot(List<RootObj> gcRoots) {
+    Snapshot snapshot = new Snapshot(null);
+    for (RootObj root : gcRoots) {
+      snapshot.addRoot(root);
+    }
+    return snapshot;
   }
 }
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java
new file mode 100644
index 00000000..926a0d8d
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java
@@ -0,0 +1,51 @@
+package com.squareup.leakcanary;
+
+import java.lang.ref.WeakReference;
+import java.util.Arrays;
+import java.util.Collection;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_MPREVIEW2;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_M_POSTPREVIEW2;
+import static com.squareup.leakcanary.TestUtil.analyze;
+import static org.junit.Assert.assertEquals;
+
+/**
+ * This test makes sure there is no regression on the retained size calculation.
+ */
+@RunWith(Parameterized.class) //
+public class RetainedSizeTest {
+
+  @Parameterized.Parameters public static Collection<Object[]> data() {
+    return Arrays.asList(new Object[][] {
+        { ASYNC_TASK, 207_407 }, //
+        { ASYNC_TASK_MPREVIEW2, 1_604 }, //
+        { ASYNC_TASK_M_POSTPREVIEW2, 1_870 }, //
+    });
+  }
+
+  private final TestUtil.HeapDumpFile heapDumpFile;
+  private final long expectedRetainedHeapSize;
+  ExcludedRefs.BuilderWithParams excludedRefs;
+
+  public RetainedSizeTest(TestUtil.HeapDumpFile heapDumpFile, long expectedRetainedHeapSize) {
+    this.heapDumpFile = heapDumpFile;
+    this.expectedRetainedHeapSize = expectedRetainedHeapSize;
+  }
+
+  @Before public void setUp() {
+    excludedRefs = new ExcludedRefs.BuilderWithParams().clazz(WeakReference.class.getName())
+        .alwaysExclude()
+        .clazz("java.lang.ref.FinalizerReference")
+        .alwaysExclude();
+  }
+
+  @Test public void leakFound() {
+    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
+    assertEquals(expectedRetainedHeapSize, result.retainedHeapSize);
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
new file mode 100644
index 00000000..55428084
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import java.io.File;
+import java.net.URL;
+
+final class TestUtil {
+
+  enum HeapDumpFile {
+    ASYNC_TASK("leak_asynctask.hprof", "dc983a12-d029-4003-8890-7dd644c664c5"),
+    ASYNC_TASK_MPREVIEW2("leak_asynctask_mpreview2.hprof", "1114018e-e154-435f-9a3d-da63ae9b47fa"),
+    ASYNC_TASK_M_POSTPREVIEW2("leak_asynctask_m_postpreview2.hprof",
+        "25ae1778-7c1d-4ec7-ac50-5cce55424069");
+
+    private final String filename;
+    private final String referenceKey;
+
+    HeapDumpFile(String filename, String referenceKey) {
+      this.filename = filename;
+      this.referenceKey = referenceKey;
+    }
+
+  }
+
+  static File fileFromName(String filename) {
+    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+    URL url = classLoader.getResource(filename);
+    return new File(url.getPath());
+  }
+
+  static AnalysisResult analyze(HeapDumpFile heapDumpFile, ExcludedRefs.BuilderWithParams excludedRefs) {
+    File file = fileFromName(heapDumpFile.filename);
+    String referenceKey = heapDumpFile.referenceKey;
+    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(excludedRefs.build());
+    AnalysisResult result = heapAnalyzer.checkForLeak(file, referenceKey);
+    if (result.failure != null) {
+      result.failure.printStackTrace();
+    }
+    if (result.leakTrace != null) {
+      System.out.println(result.leakTrace);
+    }
+    return result;
+  }
+
+  private TestUtil() {
+    throw new AssertionError();
+  }
+}
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_m_postpreview2.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_m_postpreview2.hprof
new file mode 100644
index 00000000..6945c82d
Binary files /dev/null and b/leakcanary-analyzer/src/test/resources/leak_asynctask_m_postpreview2.hprof differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof
new file mode 100644
index 00000000..548f3a2a
Binary files /dev/null and b/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof differ
diff --git a/leakcanary-android/build.gradle b/leakcanary-android/build.gradle
index 394da675..70516ea7 100644
--- a/leakcanary-android/build.gradle
+++ b/leakcanary-android/build.gradle
@@ -22,6 +22,7 @@ def gitSha() {
 }
 
 android {
+  resourcePrefix 'leak_canary_'
   compileSdkVersion rootProject.ext.compileSdkVersion
   buildToolsVersion rootProject.ext.buildToolsVersion
   defaultConfig {
@@ -31,6 +32,9 @@ android {
     buildConfigField "String", "GIT_SHA", "\"${gitSha()}\""
     consumerProguardFiles 'consumer-proguard-rules.pro'
   }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+  }
 }
 
 task sourceJar(type: Jar) {
diff --git a/leakcanary-android/consumer-proguard-rules.pro b/leakcanary-android/consumer-proguard-rules.pro
index 0a28de9b..48ffcc28 100644
--- a/leakcanary-android/consumer-proguard-rules.pro
+++ b/leakcanary-android/consumer-proguard-rules.pro
@@ -1,2 +1,9 @@
--keep class org.eclipse.mat.** { *; }
+-dontwarn com.squareup.haha.guava.**
+-dontwarn com.squareup.haha.perflib.**
+-dontwarn com.squareup.haha.trove.**
+-dontwarn com.squareup.leakcanary.**
+-keep class com.squareup.haha.** { *; }
 -keep class com.squareup.leakcanary.** { *; }
+
+# Marshmallow removed Notification.setLatestEventInfo()
+-dontwarn android.app.Notification
diff --git a/leakcanary-android/src/main/AndroidManifest.xml b/leakcanary-android/src/main/AndroidManifest.xml
index 05d4ad81..b5393171 100644
--- a/leakcanary-android/src/main/AndroidManifest.xml
+++ b/leakcanary-android/src/main/AndroidManifest.xml
@@ -20,6 +20,7 @@
     >
 
   <!-- To store the heap dumps and leak analysis results. -->
+  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
   <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
 
   <application>
@@ -33,11 +34,11 @@
         android:enabled="false"
         />
     <activity
-        android:theme="@style/__LeakCanary.Base"
+        android:theme="@style/leak_canary_LeakCanary.Base"
         android:name=".internal.DisplayLeakActivity"
         android:enabled="false"
-        android:label="@string/__leak_canary_display_activity_label"
-        android:icon="@drawable/__leak_canary_icon"
+        android:label="@string/leak_canary_display_activity_label"
+        android:icon="@drawable/leak_canary_icon"
         android:taskAffinity="com.squareup.leakcanary"
         >
       <intent-filter>
@@ -45,6 +46,14 @@
         <category android:name="android.intent.category.LAUNCHER"/>
       </intent-filter>
     </activity>
+    <activity
+        android:theme="@style/leak_canary_Theme.Transparent"
+        android:name=".internal.RequestStoragePermissionActivity"
+        android:taskAffinity="com.squareup.leakcanary"
+        android:enabled="false"
+        android:icon="@drawable/leak_canary_icon"
+        android:label="@string/leak_canary_storage_permission_activity_label"
+        />
 
   </application>
 </manifest>
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
index 0a1a7368..dd03f078 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
@@ -15,6 +15,9 @@
  */
 package com.squareup.leakcanary;
 
+import java.lang.ref.PhantomReference;
+import java.lang.ref.SoftReference;
+import java.lang.ref.WeakReference;
 import java.util.EnumSet;
 
 import static android.os.Build.MANUFACTURER;
@@ -25,9 +28,10 @@
 import static android.os.Build.VERSION_CODES.JELLY_BEAN;
 import static android.os.Build.VERSION_CODES.KITKAT;
 import static android.os.Build.VERSION_CODES.LOLLIPOP;
+import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
+import static android.os.Build.VERSION_CODES.M;
 import static com.squareup.leakcanary.AndroidWatchExecutor.LEAK_CANARY_THREAD_NAME;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.LG;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.LOLLIPOP_MR1;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.MOTOROLA;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.NVIDIA;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.SAMSUNG;
@@ -46,228 +50,300 @@
  */
 public enum AndroidExcludedRefs {
 
+  // ######## Android SDK Excluded refs ########
+
   ACTIVITY_CLIENT_RECORD__NEXT_IDLE(SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Android AOSP sometimes keeps a reference to a destroyed activity as a "nextIdle" client
-      // record in the android.app.ActivityThread.mActivities map.
-      // Not sure what's going on there, input welcome.
-      excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle");
+      excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle")
+          .reason("Android AOSP sometimes keeps a reference to a destroyed activity as a"
+              + " nextIdle client record in the android.app.ActivityThread.mActivities map."
+              + " Not sure what's going on there, input welcome.");
     }
   },
 
   SPAN_CONTROLLER(SDK_INT <= KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Editor inserts a special span, which has a reference to the EditText. That span is a
-      // NoCopySpan, which makes sure it gets dropped when creating a new SpannableStringBuilder
-      // from a given CharSequence.
-      // TextView.onSaveInstanceState() does a copy of its mText before saving it in the bundle.
-      // Prior to KitKat, that copy was done using the SpannableString constructor, instead of
-      // SpannableStringBuilder. The SpannableString constructor does not drop NoCopySpan spans.
-      // So we end up with a saved state that holds a reference to the textview and therefore the
-      // entire view hierarchy & activity context.
-      // Fix: https://github.com/android/platform_frameworks_base/commit
-      // /af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b
-
-      // Hack: to fix this, you could override TextView.onSaveInstanceState(), and then use
-      // reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.
-      excluded.instanceField("android.widget.Editor$EasyEditSpanController", "this$0");
-      excluded.instanceField("android.widget.Editor$SpanController", "this$0");
+      String reason =
+          "Editor inserts a special span, which has a reference to the EditText. That span is a"
+              + " NoCopySpan, which makes sure it gets dropped when creating a new"
+              + " SpannableStringBuilder from a given CharSequence."
+              + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
+              + " bundle. Prior to KitKat, that copy was done using the SpannableString"
+              + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
+              + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
+              + " reference to the textview and therefore the entire view hierarchy & activity"
+              + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
+              + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
+              + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
+              + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.";
+      excluded.instanceField("android.widget.Editor$EasyEditSpanController", "this$0")
+          .reason(reason);
+      excluded.instanceField("android.widget.Editor$SpanController", "this$0").reason(reason);
     }
   },
 
   MEDIA_SESSION_LEGACY_HELPER__SINSTANCE(SDK_INT == LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // MediaSessionLegacyHelper is a static singleton that is lazily instantiated and keeps a
-      // reference to the context it's given the first time MediaSessionLegacyHelper.getHelper()
-      // is called.
-      // This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by calling
-      // context.getApplicationContext().
-      // Fix: https://github.com/android/platform_frameworks_base/commit
-      // /9b5257c9c99c4cb541d8e8e78fb04f008b1a9091
-
-      // Hack: to fix this, you could call MediaSessionLegacyHelper.getHelper() early in
-      // Application.onCreate() and pass it the application context.
-      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance");
+      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance")
+          .reason("MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
+              + " keeps a reference to the context it's given the first time"
+              + " MediaSessionLegacyHelper.getHelper() is called."
+              + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
+              + " calling context.getApplicationContext()."
+              + " Fix: https://github.com/android/platform_frameworks_base/commit"
+              + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
+              + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
+              + " in Application.onCreate() and pass it the application context.");
     }
   },
 
-  TEXT_LINE__SCACHED(SDK_INT < LOLLIPOP_MR1) {
+  TEXT_LINE__SCACHED(SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had at least two
-      // bugs that created memory leaks by not correctly clearing the recycled TextLine instances.
-      // The first was fixed in android-5.1.0_r1:
-      // https://github.com/android/platform_frameworks_base/commit
-      // /893d6fe48d37f71e683f722457bea646994a10bf
-
-      // The second was fixed, not released yet:
-      // https://github.com/android/platform_frameworks_base/commit
-      // /b3a9bc038d3a218b1dbdf7b5668e3d6c12be5ee4
-
-      // Hack: to fix this, you could access TextLine.sCached and clear the pool every now and then
-      // (e.g. on activity destroy).
-      excluded.staticField("android.text.TextLine", "sCached");
+      excluded.staticField("android.text.TextLine", "sCached")
+          .reason("TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
+              + " at least two bugs that created memory leaks by not correctly clearing the"
+              + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
+              + " https://github.com/android/platform_frameworks_base/commit"
+              + "/893d6fe48d37f71e683f722457bea646994a10"
+              + " The second was fixed, not released yet:"
+              + " https://github.com/android/platform_frameworks_base/commit"
+              + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
+              + " To fix this, you could access TextLine.sCached and clear the pool every now"
+              + " and then (e.g. on activity destroy).");
     }
   },
 
   BLOCKING_QUEUE(SDK_INT < LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Prior to ART, a thread waiting on a blocking queue will leak the last dequeued object
-      // as a stack local reference.
-      // So when a HandlerThread becomes idle, it keeps a local reference to the last message it
-      // received. That message then gets recycled and can be used again.
-      // As long as all messages are recycled after being used, this won't be a problem, because
-      // there references are cleared when being recycled.
-      // However, dialogs create template Message instances to be copied when a message needs to be
-      // sent. These Message templates holds references to the dialog listeners, which most likely
-      // leads to holding a reference onto the activity in some way. Dialogs never recycle their
-      // template Message, assuming these Message instances will get GCed when the dialog is GCed.
-      // The combination of these two things creates a high potential for memory leaks as soon
-      // as you use dialogs. These memory leaks might be temporary, but some handler threads sleep
-      // for a long time.
-
-      // Hack: to fix this, you could post empty messages to the idle handler threads from time to
-      // time. This won't be easy because you cannot access all handler threads, but a library
-      // that is widely used should consider doing this for its own handler threads.
-      excluded.instanceField("android.os.Message", "obj");
-      excluded.instanceField("android.os.Message", "next");
-      excluded.instanceField("android.os.Message", "target");
-    }
-  },
-
-  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // When we detach a view that receives keyboard input, the InputMethodManager leaks a
-      // reference to it until a new view asks for keyboard input.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=171190
-      // Hack: https://gist.github.com/pyricau/4df64341cc978a7de414
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView");
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView");
+      String reason = "Prior to ART, a thread waiting on a blocking queue will leak the last"
+          + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
+          + " keeps a local reference to the last message it received. That message then gets"
+          + " recycled and can be used again. As long as all messages are recycled after being"
+          + "used, this won't be a problem, because these references are cleared when being"
+          + "recycled. However, dialogs create template Message instances to be copied when a"
+          + "message needs to be sent. These Message templates holds references to the dialog"
+          + "listeners, which most likely leads to holding a reference onto the activity in some"
+          + "way. Dialogs never recycle their template Message, assuming these Message instances"
+          + " will get GCed when the dialog is GCed."
+          + " The combination of these two things creates a high potential for memory leaks as soon"
+          + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
+          + " sleep for a long time."
+          + " To fix this, you could post empty messages to the idle handler threads from time to"
+          + " time. This won't be easy because you cannot access all handler threads, but a library"
+          + "that is widely used should consider doing this for its own handler threads.";
+      excluded.instanceField("android.os.Message", "obj").reason(reason);
+      excluded.instanceField("android.os.Message", "next").reason(reason);
+      excluded.instanceField("android.os.Message", "target").reason(reason);
+    }
+  },
+
+  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= M) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      String reason = "When we detach a view that receives keyboard input, the InputMethodManager"
+          + " leaks a reference to it until a new view asks for keyboard input."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
+          + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414";
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView")
+          .reason(reason);
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView")
+          .reason(reason);
       excluded.instanceField("android.view.inputmethod.InputMethodManager",
-          "mServedInputConnection");
+          "mServedInputConnection").reason(reason);
     }
   },
 
-  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= LOLLIPOP_MR1) {
+  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= M) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // The singleton InputMethodManager is holding a reference to mCurRootView long after the
-      // activity has been destroyed.
-      // Observed on ICS MR1: https://github.com/square/leakcanary/issues/1#issuecomment-100579429
-      // Hack: https://gist.github.com/pyricau/4df64341cc978a7de414
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView");
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView")
+          .reason("The singleton InputMethodManager is holding a reference to mCurRootView long"
+              + " after the activity has been destroyed."
+              + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
+              + "#issuecomment-100579429"
+              + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414");
     }
   },
 
   LAYOUT_TRANSITION(SDK_INT >= ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // LayoutTransition leaks parent ViewGroup through ViewTreeObserver.OnPreDrawListener
-      // When triggered, this leaks stays until the window is destroyed.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=171830
-      excluded.instanceField("android.animation.LayoutTransition$1", "val$parent");
+      excluded.instanceField("android.animation.LayoutTransition$1", "val$parent")
+          .reason("LayoutTransition leaks parent ViewGroup through"
+              + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
+              + " window is destroyed. Tracked here:"
+              + " https://code.google.com/p/android/issues/detail?id=171830");
     }
   },
 
-  SPELL_CHECKER_SESSION(SDK_INT >= JELLY_BEAN || SDK_INT <= LOLLIPOP_MR1) {
+  SPELL_CHECKER_SESSION(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the
-      // SpellCheckerSession is closed before the service is connected.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=172542
-      excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0");
+      excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0")
+          .reason("SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
+              + " SpellCheckerSession is closed before the service is connected."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542");
     }
   },
 
   ACTIVITY_CHOOSE_MODEL(SDK_INT > ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // ActivityChooserModel holds a static reference to the last set ActivityChooserModelPolicy
-      // which can be an activity context.
-      // Tracked here : https://code.google.com/p/android/issues/detail?id=172659
-      // Hack : https://gist.github.com/andaag/b05ab66ed0f06167d6e0
-      excluded.staticField("android.support.v7.internal.widget.ActivityChooserModel",
-          "mActivityChoserModelPolicy");
-      excluded.staticField("android.widget.ActivityChooserModel", "mActivityChoserModelPolicy");
+      String reason = "ActivityChooserModel holds a static reference to the last set"
+          + " ActivityChooserModelPolicy which can be an activity context."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
+          + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0";
+      excluded.instanceField("android.support.v7.internal.widget.ActivityChooserModel",
+          "mActivityChoserModelPolicy").reason(reason);
+      excluded.instanceField("android.widget.ActivityChooserModel", "mActivityChoserModelPolicy")
+          .reason(reason);
     }
   },
 
   SPEECH_RECOGNIZER(SDK_INT < LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner class and
-      // leaked the SpeechRecognizer which leaked an activity context.
-      // Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit
-      // /b37866db469e81aca534ff6186bdafd44352329b
-      excluded.instanceField("android.speech.SpeechRecognizer$InternalListener", "this$0");
+      excluded.instanceField("android.speech.SpeechRecognizer$InternalListener", "this$0")
+          .reason("Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
+              + " class and leaked the SpeechRecognizer which leaked an activity context."
+              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+              + " /b37866db469e81aca534ff6186bdafd44352329b");
     }
   },
 
   ACCOUNT_MANAGER(SDK_INT > ECLAIR && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // AccountManager$AmsTask$Response is a stub and is held in memory by native code, probably
-      // because the reference to the response in the other process hasn't been cleared.
-      // AccountManager$AmsTask is holding on to the activity reference to use for launching a new
-      // sub- Activity.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=173689
-      // Fix: Pass a null activity reference to the AccountManager methods and then deal with the
-      // returned future to to get the result and correctly start an activity when it's available.
-      excluded.instanceField("android.accounts.AccountManager$AmsTask$Response", "this$1");
+      excluded.instanceField("android.accounts.AccountManager$AmsTask$Response", "this$1")
+          .reason("AccountManager$AmsTask$Response is a stub and is held in memory by native code,"
+              + " probably because the reference to the response in the other process hasn't been"
+              + " cleared."
+              + " AccountManager$AmsTask is holding on to the activity reference to use for"
+              + " launching a new sub- Activity."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
+              + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
+              + " with the returned future to to get the result and correctly start an activity"
+              + " when it's available.");
     }
   },
 
   MEDIA_SCANNER_CONNECTION(SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // The static method MediaScannerConnection.scanFile() takes an activity context but the
-      // service might not disconnect after the activity has been destroyed.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=173788
-      // Fix: Create an instance of MediaScannerConnection yourself and pass in the application
-      // context. Call connect() and disconnect() manually.
-      excluded.instanceField("android.media.MediaScannerConnection", "mContext");
+      excluded.instanceField("android.media.MediaScannerConnection", "mContext")
+          .reason("The static method MediaScannerConnection.scanFile() takes an activity context"
+              + " but the service might not disconnect after the activity has been destroyed."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
+              + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
+              + " application context. Call connect() and disconnect() manually.");
     }
   },
 
-  USER_MANAGER__SINSTANCE(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
+  USER_MANAGER__SINSTANCE(SDK_INT >= JELLY_BEAN && SDK_INT <= M) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // UserManager has a static sInstance field that creates an instance and caches it the first
-      // time UserManager.get() is called. This instance is created with the outer context (which
-      // is an activity base context).
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=173789
-      // Introduced by: https://github.com/android/platform_frameworks_base/commit
-      // /27db46850b708070452c0ce49daf5f79503fbde6
-      // Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the
-      // UserManager instance gets cached with a reference to the application context.
-      excluded.instanceField("android.os.UserManager", "mContext");
+      excluded.instanceField("android.os.UserManager", "mContext")
+          .reason("UserManager has a static sInstance field that creates an instance and caches it"
+              + " the first time UserManager.get() is called. This instance is created with the"
+              + " outer context (which is an activity base context)."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
+              + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
+              + "/27db46850b708070452c0ce49daf5f79503fbde6"
+              + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
+              + " UserManager instance gets cached with a reference to the application context.");
     }
   },
 
-  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER(MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+  APP_WIDGET_HOST_CALLBACKS(SDK_INT < LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("android.appwidget.AppWidgetHost$Callbacks", "this$0")
+          .reason("android.appwidget.AppWidgetHost$Callbacks is a stub and is held in memory native"
+              + " code. The reference to the `mContext` was not being cleared, which caused the"
+              + " Callbacks instance to retain this reference"
+              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+              + "/7a96f3c917e0001ee739b65da37b2fadec7d7765");
+    }
+  },
+
+  AUDIO_MANAGER(SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("android.media.AudioManager$1", "this$0")
+          .reason("Prior to Android M, VideoView required audio focus from AudioManager and"
+              + " never abandoned it, which leaks the Activity context through the AudioManager."
+              + " The root of the problem is that AudioManager uses whichever"
+              + " context it receives, which in the case of the VideoView example is an Activity,"
+              + " even though it only needs the application's context. The issue is fixed in"
+              + " Android M, and the AudioManager now uses the application's context."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
+              + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2");
+    }
+  },
+
+  EDITTEXT_BLINK_MESSAGEQUEUE(SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("android.widget.Editor$Blink", "this$0")
+          .reason("The EditText Blink of the Cursor is implemented using a callback and Messages,"
+              + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
+              + " contains a blinking cursor is detached, a message is posted with a delay after the"
+              + " dialog has been closed and as a result leaks the Activity."
+              + " This can be fixed manually by calling TextView.setCursorVisible(false) in the"
+              + " dismiss() method of the dialog."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
+              + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
+              + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/");
+    }
+  },
+
+  CONNECTIVITY_MANAGER__SINSTANCE(SDK_INT <= M) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("android.net.ConnectivityManager", "sInstance")
+          .reason("ConnectivityManager has a sInstance field that is set when the first"
+              + "ConnectivityManager instance is created. ConnectivityManager has a mContext field."
+              + "When calling activity.getSystemService(Context.CONNECTIVITY_SERVICE) , the first"
+              + "ConnectivityManager instance is created with the activity context and stored in"
+              + "sInstance. That activity context then leaks forever."
+              + "Until this is fixed, app developers can prevent this leak by making sure the"
+              + " ConnectivityManager is first created with an App Context. E.g. in some static"
+              + " init do: context.getApplicationContext()"
+              + ".getSystemService(Context.CONNECTIVITY_SERVICE)"
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=198852"
+              + " Introduced here: https://github.com/android/platform_frameworks_base/commit/"
+              + "e0bef71662d81caaaa0d7214fb0bef5d39996a69");
+    }
+  },
+
+  // ######## Manufacturer specific Excluded refs ########
+
+  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER(
+      MOTOROLA.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
       if (MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-        // DevicePolicyManager keeps a reference to the context it has been created with instead of
-        // extracting the application context. In this Motorola build, DevicePolicyManager has an
-        // inner SettingsObserver class that is a content observer, which is held into memory
-        // by a binder transport object.
-        excluded.instanceField("android.app.admin.DevicePolicyManager$SettingsObserver", "this$0");
+        excluded.instanceField("android.app.admin.DevicePolicyManager$SettingsObserver", "this$0")
+            .reason("DevicePolicyManager keeps a reference to the context it has been created with"
+                + " instead of extracting the application context. In this Motorola build,"
+                + " DevicePolicyManager has an inner SettingsObserver class that is a content"
+                + " observer, which is held into memory by a binder transport object.");
       }
     }
   },
 
   SPEN_GESTURE_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // SpenGestureManager has a static mContext field that leaks a reference to the activity.
-      // Yes, a STATIC "mContext" field.
-      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext");
+      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext")
+          .reason("SpenGestureManager has a static mContext field that leaks a reference to the"
+              + " activity. Yes, a STATIC mContext field.");
     }
   },
 
   CLIPBOARD_UI_MANAGER__SINSTANCE(
       SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // ClipboardUIManager is a static singleton that leaks an activity context.
-      excluded.staticField("android.sec.clipboard.ClipboardUIManager", "sInstance");
+      excluded.instanceField("android.sec.clipboard.ClipboardUIManager", "mContext")
+          .reason("ClipboardUIManager is a static singleton that leaks an activity context."
+              + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
+              + " , so that the ClipboardUIManager instance gets cached with a reference to the"
+              + " application context. Example: https://gist.github.com/cypressious/"
+              + "91c4fb1455470d803a602838dfcd5774");
     }
   },
 
   BUBBLE_POPUP_HELPER__SHELPER(
       LG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // A static helper for EditText "bubble popups" leaks a reference to the latest focused view.
-      excluded.staticField("android.widget.BubblePopupHelper", "sHelper");
+      excluded.staticField("android.widget.BubblePopupHelper", "sHelper")
+          .reason("A static helper for EditText bubble popups leaks a reference to the latest"
+              + "focused view.");
     }
   },
 
@@ -282,55 +358,80 @@
 
   MAPPER_CLIENT(NVIDIA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Not sure exactly what ControllerMapper is about, but there is an anonymous Handler in
-      // ControllerMapper.MapperClient.ServiceClient, which leaks ControllerMapper.MapperClient
-      // which leaks the activity context.
-      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient$ServiceClient", "this$0");
+      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient$ServiceClient", "this$0")
+          .reason("Not sure exactly what ControllerMapper is about, but there is an anonymous"
+              + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
+              + " ControllerMapper.MapperClient which leaks the activity context.");
     }
   },
 
-  TEXT_VIEW__MLAST_HOVERED_VIEW(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+  TEXT_VIEW__MLAST_HOVERED_VIEW(
+      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // mLastHoveredView is a static field in TextView that leaks the last hovered view.
-      excluded.staticField("android.widget.TextView", "mLastHoveredView");
+      excluded.staticField("android.widget.TextView", "mLastHoveredView")
+          .reason("mLastHoveredView is a static field in TextView that leaks the last hovered"
+              + " view.");
     }
   },
 
   PERSONA_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // android.app.LoadedApk.mResources has a reference to
-      // android.content.res.Resources.mPersonaManager which has a reference to
-      // android.os.PersonaManager.mContext which is an activity.
-      excluded.instanceField("android.os.PersonaManager", "mContext");
+      excluded.instanceField("android.os.PersonaManager", "mContext")
+          .reason("android.app.LoadedApk.mResources has a reference to"
+              + " android.content.res.Resources.mPersonaManager which has a reference to"
+              + " android.os.PersonaManager.mContext which is an activity.");
     }
   },
 
   RESOURCES__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // In AOSP the Resources class does not have a context.
-      // Here we have ZygoteInit.mResources (static field) holding on to a Resources instance that
-      // has a context that is the activity.
-      // Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184
-      excluded.instanceField("android.content.res.Resources", "mContext");
+      excluded.instanceField("android.content.res.Resources", "mContext")
+          .reason("In AOSP the Resources class does not have a context."
+              + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
+              + " instance that has a context that is the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184");
     }
   },
 
   VIEW_CONFIGURATION__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // In AOSP the ViewConfiguration class does not have a context.
-      // Here we have ViewConfiguration.sConfigurations (static field) holding on to a
-      // ViewConfiguration instance that has a context that is the activity.
-      // Observed here: https://github.com/square/leakcanary/issues/1#issuecomment-100324683
-      excluded.instanceField("android.view.ViewConfiguration", "mContext");
+      excluded.instanceField("android.view.ViewConfiguration", "mContext")
+          .reason("In AOSP the ViewConfiguration class does not have a context."
+              + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
+              + " ViewConfiguration instance that has a context that is the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues"
+              + "/1#issuecomment-100324683");
     }
   },
 
   AUDIO_MANAGER__MCONTEXT_STATIC(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Samsung added a static mContext_static field to AudioManager, holds a reference to the
-      // activity.
-      // Observed here: https://github.com/square/leakcanary/issues/32
-      excluded.staticField("android.media.AudioManager", "mContext_static");
+      excluded.staticField("android.media.AudioManager", "mContext_static")
+          .reason("Samsung added a static mContext_static field to AudioManager, holds a reference"
+              + " to the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues/32");
+    }
+  },
+
+  ACTIVITY_MANAGER_MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.staticField("android.app.ActivityManager", "mContext")
+          .reason("Samsung added a static mContext field to ActivityManager, holds a reference"
+              + " to the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues/177 Fix in comment:"
+              + " https://github.com/square/leakcanary/issues/177#issuecomment-222724283");
+    }
+  },
+
+  // ######## General Excluded refs ########
+
+  SOFT_REFERENCES {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.clazz(WeakReference.class.getName()).alwaysExclude();
+      excluded.clazz(SoftReference.class.getName()).alwaysExclude();
+      excluded.clazz(PhantomReference.class.getName()).alwaysExclude();
+      excluded.clazz("java.lang.ref.Finalizer").alwaysExclude();
+      excluded.clazz("java.lang.ref.FinalizerReference").alwaysExclude();
     }
   },
 
@@ -338,7 +439,7 @@
     @Override void add(ExcludedRefs.Builder excluded) {
       // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
       // reference to the object and it was about to be GCed.
-      excluded.thread("FinalizerWatchdogDaemon");
+      excluded.thread("FinalizerWatchdogDaemon").alwaysExclude();
     }
   },
 
@@ -347,13 +448,13 @@
       // The main thread stack is ever changing so local variables aren't likely to hold references
       // for long. If this is on the shortest path, it's probably that there's a longer path with
       // a real leak.
-      excluded.thread("main");
+      excluded.thread("main").alwaysExclude();
     }
   },
 
   LEAK_CANARY_THREAD {
     @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.thread(LEAK_CANARY_THREAD_NAME);
+      excluded.thread(LEAK_CANARY_THREAD_NAME).alwaysExclude();
     }
   },
 
@@ -364,7 +465,7 @@
       // The main thread message queue is held on by the main Looper, but that might be a longer
       // path. Let's not confuse people with a shorter path that is less meaningful.
       excluded.instanceField("android.view.Choreographer$FrameDisplayEventReceiver",
-          "mMessageQueue");
+          "mMessageQueue").alwaysExclude();
     }
   };
 
@@ -372,8 +473,9 @@
    * This returns the references in the leak path that should be ignored by all on Android.
    */
   public static ExcludedRefs.Builder createAndroidDefaults() {
-    return createBuilder(EnumSet.of(FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
-        EVENT_RECEIVER__MMESSAGE_QUEUE));
+    return createBuilder(
+        EnumSet.of(SOFT_REFERENCES, FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
+            EVENT_RECEIVER__MMESSAGE_QUEUE));
   }
 
   /**
@@ -387,10 +489,11 @@
   }
 
   public static ExcludedRefs.Builder createBuilder(EnumSet<AndroidExcludedRefs> refs) {
-    ExcludedRefs.Builder excluded = new ExcludedRefs.Builder();
+    ExcludedRefs.Builder excluded = ExcludedRefs.builder();
     for (AndroidExcludedRefs ref : refs) {
       if (ref.applies) {
         ref.add(excluded);
+        ((ExcludedRefs.BuilderWithParams) excluded).named(ref.name());
       }
     }
     return excluded;
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
index 53b0ef5c..c46435f3 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
@@ -20,7 +20,6 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.MessageQueue;
-import android.util.Log;
 import android.view.Gravity;
 import android.view.LayoutInflater;
 import android.widget.Toast;
@@ -29,29 +28,42 @@
 import java.io.File;
 import java.io.IOException;
 
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.isExternalStorageWritable;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.storageDirectory;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
 public final class AndroidHeapDumper implements HeapDumper {
 
-  private static final String TAG = "AndroidHeapDumper";
+  private static final String HEAPDUMP_FILE = "suspected_leak_heapdump.hprof";
 
-  private final Context context;
+  final Context context;
+  final LeakDirectoryProvider leakDirectoryProvider;
   private final Handler mainHandler;
 
-  public AndroidHeapDumper(Context context) {
+  public AndroidHeapDumper(Context context, LeakDirectoryProvider leakDirectoryProvider) {
+    this.leakDirectoryProvider = leakDirectoryProvider;
     this.context = context.getApplicationContext();
     mainHandler = new Handler(Looper.getMainLooper());
   }
 
   @Override public File dumpHeap() {
-    if (!isExternalStorageWritable()) {
-      Log.d(TAG, "Could not dump heap, external storage not mounted.");
+    if (!leakDirectoryProvider.isLeakStorageWritable()) {
+      CanaryLog.d("Could not write to leak storage to dump heap.");
+      leakDirectoryProvider.requestWritePermissionNotification();
+      return NO_DUMP;
     }
     File heapDumpFile = getHeapDumpFile();
-    if (heapDumpFile.exists()) {
-      Log.d(TAG, "Could not dump heap, previous analysis still is in progress.");
+    // Atomic way to check for existence & create the file if it doesn't exist.
+    // Prevents several processes in the same app to attempt a heapdump at the same time.
+    boolean fileCreated;
+    try {
+      fileCreated = heapDumpFile.createNewFile();
+    } catch (IOException e) {
+      cleanup();
+      CanaryLog.d(e, "Could not check if heap dump file exists");
+      return NO_DUMP;
+    }
+
+    if (!fileCreated) {
+      CanaryLog.d("Could not dump heap, previous analysis still is in progress.");
       // Heap analysis in progress, let's not put too much pressure on the device.
       return NO_DUMP;
     }
@@ -60,7 +72,7 @@ public AndroidHeapDumper(Context context) {
     showToast(waitingForToast);
 
     if (!waitingForToast.wait(5, SECONDS)) {
-      Log.d(TAG, "Did not dump heap, too much time waiting for Toast.");
+      CanaryLog.d("Did not dump heap, too much time waiting for Toast.");
       return NO_DUMP;
     }
 
@@ -69,9 +81,9 @@ public AndroidHeapDumper(Context context) {
       Debug.dumpHprofData(heapDumpFile.getAbsolutePath());
       cancelToast(toast);
       return heapDumpFile;
-    } catch (IOException e) {
+    } catch (Exception e) {
       cleanup();
-      Log.e(TAG, "Could not perform heap dump", e);
+      CanaryLog.d(e, "Could not perform heap dump");
       // Abort heap dump
       return NO_DUMP;
     }
@@ -84,20 +96,24 @@ public AndroidHeapDumper(Context context) {
   public void cleanup() {
     LeakCanaryInternals.executeOnFileIoThread(new Runnable() {
       @Override public void run() {
-        if (isExternalStorageWritable()) {
-          Log.d(TAG, "Could not attempt cleanup, external storage not mounted.");
+        if (!leakDirectoryProvider.isLeakStorageWritable()) {
+          CanaryLog.d("Could not attempt cleanup, leak storage not writable.");
+          return;
         }
         File heapDumpFile = getHeapDumpFile();
         if (heapDumpFile.exists()) {
-          Log.d(TAG, "Previous analysis did not complete correctly, cleaning: " + heapDumpFile);
-          heapDumpFile.delete();
+          CanaryLog.d("Previous analysis did not complete correctly, cleaning: %s", heapDumpFile);
+          boolean success = heapDumpFile.delete();
+          if (!success) {
+            CanaryLog.d("Could not delete file %s", heapDumpFile.getPath());
+          }
         }
       }
     });
   }
 
-  private File getHeapDumpFile() {
-    return new File(storageDirectory(), "suspected_leak_heapdump.hprof");
+  File getHeapDumpFile() {
+    return new File(leakDirectoryProvider.leakDirectory(), HEAPDUMP_FILE);
   }
 
   private void showToast(final FutureResult<Toast> waitingForToast) {
@@ -107,7 +123,7 @@ private void showToast(final FutureResult<Toast> waitingForToast) {
         toast.setGravity(Gravity.CENTER_VERTICAL, 0, 0);
         toast.setDuration(Toast.LENGTH_LONG);
         LayoutInflater inflater = LayoutInflater.from(context);
-        toast.setView(inflater.inflate(R.layout.__leak_canary_heap_dump_toast, null));
+        toast.setView(inflater.inflate(R.layout.leak_canary_heap_dump_toast, null));
         toast.show();
         // Waiting for Idle to make sure Toast gets rendered.
         Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
index d5d94293..8f8eff4b 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
@@ -23,22 +23,22 @@
 
 /**
  * {@link Executor} suitable for watching Android reference leaks. This executor waits for the main
- * thread to be idle then posts to a serial background thread with a delay of {@link
- * #DELAY_MILLIS} milliseconds.
+ * thread to be idle then posts to a serial background thread with a delay of
+ * {@link R.integer#leak_canary_watch_delay_millis} seconds.
  */
 public final class AndroidWatchExecutor implements Executor {
 
   static final String LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump";
-  private static final int DELAY_MILLIS = 5000;
-
   private final Handler mainHandler;
-  private final Handler backgroundHandler;
+  final Handler backgroundHandler;
+  final long delayMillis;
 
-  public AndroidWatchExecutor() {
+  public AndroidWatchExecutor(int delayMillis) {
     mainHandler = new Handler(Looper.getMainLooper());
     HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);
     handlerThread.start();
     backgroundHandler = new Handler(handlerThread.getLooper());
+    this.delayMillis = delayMillis;
   }
 
   @Override public void execute(final Runnable command) {
@@ -57,11 +57,11 @@ private boolean isOnMainThread() {
     return Looper.getMainLooper().getThread() == Thread.currentThread();
   }
 
-  private void executeDelayedAfterIdleUnsafe(final Runnable runnable) {
+  void executeDelayedAfterIdleUnsafe(final Runnable runnable) {
     // This needs to be called from the main thread.
     Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
       @Override public boolean queueIdle() {
-        backgroundHandler.postDelayed(runnable, DELAY_MILLIS);
+        backgroundHandler.postDelayed(runnable, delayMillis);
         return false;
       }
     });
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
new file mode 100644
index 00000000..b4e288db
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
@@ -0,0 +1,60 @@
+package com.squareup.leakcanary;
+
+import android.util.Log;
+
+public final class CanaryLog {
+
+  private static volatile Logger logger = new DefaultLogger();
+
+  public interface Logger {
+    void d(String message, Object... args);
+
+    void d(Throwable throwable, String message, Object... args);
+  }
+
+  private static class DefaultLogger implements Logger {
+    DefaultLogger() { }
+
+    @Override public void d(String message, Object... args) {
+      String formatted = String.format(message, args);
+      if (formatted.length() < 4000) {
+        Log.d("LeakCanary", formatted);
+      } else {
+        String[] lines = formatted.split("\n");
+        for (String line : lines) {
+          Log.d("LeakCanary", line);
+        }
+      }
+    }
+
+    @Override public void d(Throwable throwable, String message, Object... args) {
+      d(String.format(message, args) + '\n' + Log.getStackTraceString(throwable));
+    }
+  }
+
+  public static void setLogger(Logger logger) {
+    CanaryLog.logger = logger;
+  }
+
+  public static void d(String message, Object... args) {
+    // Local variable to prevent the ref from becoming null after the null check.
+    Logger logger = CanaryLog.logger;
+    if (logger == null) {
+      return;
+    }
+    logger.d(message, args);
+  }
+
+  public static void d(Throwable throwable, String message, Object... args) {
+    // Local variable to prevent the ref from becoming null after the null check.
+    Logger logger = CanaryLog.logger;
+    if (logger == null) {
+      return;
+    }
+    logger.d(throwable, message, args);
+  }
+
+  private CanaryLog() {
+    throw new AssertionError();
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
new file mode 100644
index 00000000..812b6e64
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.os.Environment;
+import com.squareup.leakcanary.internal.RequestStoragePermissionActivity;
+import java.io.File;
+
+import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
+import static android.content.pm.PackageManager.PERMISSION_GRANTED;
+import static android.os.Build.VERSION.SDK_INT;
+import static android.os.Build.VERSION_CODES.M;
+import static android.os.Environment.DIRECTORY_DOWNLOADS;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.showNotification;
+
+public final class DefaultLeakDirectoryProvider implements LeakDirectoryProvider {
+
+  private final Context context;
+
+  public DefaultLeakDirectoryProvider(Context context) {
+    this.context = context.getApplicationContext();
+  }
+
+  @Override public File leakDirectory() {
+    File downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS);
+    File directory = new File(downloadsDirectory, "leakcanary-" + context.getPackageName());
+    boolean success = directory.mkdirs();
+    if (!success && !directory.exists()) {
+      throw new UnsupportedOperationException(
+          "Could not create leak directory " + directory.getPath());
+    }
+    return directory;
+  }
+
+  @Override public void requestWritePermissionNotification() {
+    if (hasStoragePermission()) {
+      return;
+    }
+    PendingIntent pendingIntent = RequestStoragePermissionActivity.createPendingIntent(context);
+    String contentTitle = context.getString(R.string.leak_canary_permission_notification_title);
+    CharSequence packageName = context.getPackageName();
+    String contentText =
+        context.getString(R.string.leak_canary_permission_notification_text, packageName);
+    showNotification(context, contentTitle, contentText, pendingIntent);
+  }
+
+  @TargetApi(M) @Override public void requestPermission(Activity activity) {
+    if (hasStoragePermission()) {
+      return;
+    }
+    String[] permissions = {
+        WRITE_EXTERNAL_STORAGE
+    };
+    activity.requestPermissions(permissions, 42);
+  }
+
+  @Override public boolean isLeakStorageWritable() {
+    if (!hasStoragePermission()) {
+      return false;
+    }
+    String state = Environment.getExternalStorageState();
+    return Environment.MEDIA_MOUNTED.equals(state);
+  }
+
+  @TargetApi(M) private boolean hasStoragePermission() {
+    if (SDK_INT < M) {
+      return true;
+    }
+    return context.checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED;
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
index ce02d8fa..afdc4e94 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
@@ -15,25 +15,24 @@
  */
 package com.squareup.leakcanary;
 
-import android.annotation.TargetApi;
-import android.app.Notification;
-import android.app.NotificationManager;
 import android.app.PendingIntent;
-import android.content.Context;
-import android.util.Log;
+import android.content.res.Resources;
 import com.squareup.leakcanary.internal.DisplayLeakActivity;
 import java.io.File;
 import java.io.FileOutputStream;
+import java.io.FilenameFilter;
 import java.io.IOException;
 import java.io.ObjectOutputStream;
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.Date;
+import java.util.Locale;
 
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.HONEYCOMB;
-import static android.os.Build.VERSION_CODES.JELLY_BEAN;
+import static android.text.format.Formatter.formatShortFileSize;
 import static com.squareup.leakcanary.LeakCanary.leakInfo;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.classSimpleName;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.findNextAvailableHprofFile;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.leakResultFile;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.showNotification;
 
 /**
  * Logs leak analysis results, and then shows a notification which will start {@link
@@ -44,47 +43,61 @@
  */
 public class DisplayLeakService extends AbstractAnalysisResultService {
 
-  @TargetApi(HONEYCOMB) @Override
-  protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
+  @Override protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
     String leakInfo = leakInfo(this, heapDump, result, true);
-    if (leakInfo.length() < 4000) {
-      Log.d("LeakCanary", leakInfo);
-    } else {
-      String[] lines = leakInfo.split("\n");
-      for (String line : lines) {
-        Log.d("LeakCanary", line);
-      }
-    }
+    CanaryLog.d(leakInfo);
 
-    if (result.failure == null && (!result.leakFound || result.excludedLeak)) {
-      afterDefaultHandling(heapDump, result, leakInfo);
-      return;
+    boolean resultSaved = false;
+    boolean shouldSaveResult = result.leakFound || result.failure != null;
+    if (shouldSaveResult) {
+      heapDump = renameHeapdump(heapDump);
+      resultSaved = saveResult(heapDump, result);
     }
 
-    int maxStoredLeaks = getResources().getInteger(R.integer.__leak_canary_max_stored_leaks);
-    File renamedFile = findNextAvailableHprofFile(maxStoredLeaks);
+    PendingIntent pendingIntent;
+    String contentTitle;
+    String contentText;
 
-    if (renamedFile == null) {
-      // No file available.
-      Log.e("LeakCanary",
-          "Leak result dropped because we already store " + maxStoredLeaks + " leak traces.");
-      afterDefaultHandling(heapDump, result, leakInfo);
-      return;
-    }
+    if (!shouldSaveResult) {
+      contentTitle = getString(R.string.leak_canary_no_leak_title);
+      contentText = getString(R.string.leak_canary_no_leak_text);
+      pendingIntent = null;
+    } else if (resultSaved) {
+      pendingIntent = DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);
 
-    heapDump = heapDump.renameFile(renamedFile);
+      if (result.failure == null) {
+        String size = formatShortFileSize(this, result.retainedHeapSize);
+        String className = classSimpleName(result.className);
+        if (result.excludedLeak) {
+          contentTitle = getString(R.string.leak_canary_leak_excluded, className, size);
+        } else {
+          contentTitle = getString(R.string.leak_canary_class_has_leaked, className, size);
+        }
+      } else {
+        contentTitle = getString(R.string.leak_canary_analysis_failed);
+      }
+      contentText = getString(R.string.leak_canary_notification_message);
+    } else {
+      contentTitle = getString(R.string.leak_canary_could_not_save_title);
+      contentText = getString(R.string.leak_canary_could_not_save_text);
+      pendingIntent = null;
+    }
+    showNotification(this, contentTitle, contentText, pendingIntent);
+    afterDefaultHandling(heapDump, result, leakInfo);
+  }
 
-    File resultFile = leakResultFile(renamedFile);
+  private boolean saveResult(HeapDump heapDump, AnalysisResult result) {
+    File resultFile = new File(heapDump.heapDumpFile.getParentFile(),
+        heapDump.heapDumpFile.getName() + ".result");
     FileOutputStream fos = null;
     try {
       fos = new FileOutputStream(resultFile);
       ObjectOutputStream oos = new ObjectOutputStream(fos);
       oos.writeObject(heapDump);
       oos.writeObject(result);
+      return true;
     } catch (IOException e) {
-      Log.e("LeakCanary", "Could not save leak analysis result to disk", e);
-      afterDefaultHandling(heapDump, result, leakInfo);
-      return;
+      CanaryLog.d(e, "Could not save leak analysis result to disk.");
     } finally {
       if (fos != null) {
         try {
@@ -93,45 +106,45 @@ protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
         }
       }
     }
+    return false;
+  }
 
-    PendingIntent pendingIntent =
-        DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);
+  private HeapDump renameHeapdump(HeapDump heapDump) {
+    String fileName =
+        new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'.hprof'", Locale.US).format(new Date());
 
-    String contentTitle;
-    if (result.failure == null) {
-      contentTitle =
-          getString(R.string.__leak_canary_class_has_leaked, classSimpleName(result.className));
-    } else {
-      contentTitle = getString(R.string.__leak_canary_analysis_failed);
+    File newFile = new File(heapDump.heapDumpFile.getParent(), fileName);
+    boolean renamed = heapDump.heapDumpFile.renameTo(newFile);
+    if (!renamed) {
+      CanaryLog.d("Could not rename heap dump file %s to %s", heapDump.heapDumpFile.getPath(),
+          newFile.getPath());
     }
-    String contentText = getString(R.string.__leak_canary_notification_message);
+    heapDump =
+        new HeapDump(newFile, heapDump.referenceKey, heapDump.referenceName, heapDump.excludedRefs,
+            heapDump.watchDurationMs, heapDump.gcDurationMs, heapDump.heapDumpDurationMs);
 
-    NotificationManager notificationManager =
-        (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
+    Resources resources = getResources();
+    int maxStoredHeapDumps =
+        Math.max(resources.getInteger(R.integer.leak_canary_max_stored_leaks), 1);
+    File[] hprofFiles = heapDump.heapDumpFile.getParentFile().listFiles(new FilenameFilter() {
+      @Override public boolean accept(File dir, String filename) {
+        return filename.endsWith(".hprof");
+      }
+    });
 
-    Notification notification;
-    if (SDK_INT < HONEYCOMB) {
-      notification = new Notification();
-      notification.icon = R.drawable.__leak_canary_notification;
-      notification.when = System.currentTimeMillis();
-      notification.flags |= Notification.FLAG_AUTO_CANCEL;
-      notification.setLatestEventInfo(this, contentTitle, contentText, pendingIntent);
-    } else {
-      Notification.Builder builder = new Notification.Builder(this) //
-          .setSmallIcon(R.drawable.__leak_canary_notification)
-          .setWhen(System.currentTimeMillis())
-          .setContentTitle(contentTitle)
-          .setContentText(contentText)
-          .setAutoCancel(true)
-          .setContentIntent(pendingIntent);
-      if (SDK_INT < JELLY_BEAN) {
-        notification = builder.getNotification();
-      } else {
-        notification = builder.build();
+    if (hprofFiles.length > maxStoredHeapDumps) {
+      // Sort with oldest modified first.
+      Arrays.sort(hprofFiles, new Comparator<File>() {
+        @Override public int compare(File lhs, File rhs) {
+          return Long.valueOf(lhs.lastModified()).compareTo(rhs.lastModified());
+        }
+      });
+      boolean deleted = hprofFiles[0].delete();
+      if (!deleted) {
+        CanaryLog.d("Could not delete old hprof file %s", hprofFiles[0].getPath());
       }
     }
-    notificationManager.notify(0xDEAFBEEF, notification);
-    afterDefaultHandling(heapDump, result, leakInfo);
+    return heapDump;
   }
 
   /**
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
index 6c71381d..1081ae34 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -19,11 +19,15 @@
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
+import android.content.res.Resources;
 import android.os.Build;
 import android.util.Log;
 import com.squareup.leakcanary.internal.DisplayLeakActivity;
 import com.squareup.leakcanary.internal.HeapAnalyzerService;
 
+import static android.text.format.Formatter.formatShortFileSize;
+import static com.squareup.leakcanary.BuildConfig.GIT_SHA;
+import static com.squareup.leakcanary.BuildConfig.LIBRARY_VERSION;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.isInServiceProcess;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabled;
 
@@ -61,17 +65,26 @@ public static RefWatcher install(Application application,
    */
   public static RefWatcher androidWatcher(Context context, HeapDump.Listener heapDumpListener,
       ExcludedRefs excludedRefs) {
+    LeakDirectoryProvider leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
     DebuggerControl debuggerControl = new AndroidDebuggerControl();
-    AndroidHeapDumper heapDumper = new AndroidHeapDumper(context);
+    AndroidHeapDumper heapDumper = new AndroidHeapDumper(context, leakDirectoryProvider);
     heapDumper.cleanup();
-    return new RefWatcher(new AndroidWatchExecutor(), debuggerControl, GcTrigger.DEFAULT,
-        heapDumper, heapDumpListener, excludedRefs);
+    Resources resources = context.getResources();
+    int watchDelayMillis = resources.getInteger(R.integer.leak_canary_watch_delay_millis);
+    AndroidWatchExecutor executor = new AndroidWatchExecutor(watchDelayMillis);
+    return new RefWatcher(executor, debuggerControl, GcTrigger.DEFAULT, heapDumper,
+        heapDumpListener, excludedRefs);
   }
 
   public static void enableDisplayLeakActivity(Context context) {
     setEnabled(context, DisplayLeakActivity.class, true);
   }
 
+  public static void setDisplayLeakActivityDirectoryProvider(
+      LeakDirectoryProvider leakDirectoryProvider) {
+    DisplayLeakActivity.setLeakDirectoryProvider(leakDirectoryProvider);
+  }
+
   /** Returns a string representation of the result of a heap analysis. */
   public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult result,
       boolean detailed) {
@@ -89,18 +102,22 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
     String detailedString = "";
     if (result.leakFound) {
       if (result.excludedLeak) {
-        info += "* LEAK CAN BE IGNORED.\n";
+        info += "* EXCLUDED LEAK.\n";
       }
       info += "* " + result.className;
       if (!heapDump.referenceName.equals("")) {
         info += " (" + heapDump.referenceName + ")";
       }
       info += " has leaked:\n" + result.leakTrace.toString() + "\n";
+      info += "* Retaining: " + formatShortFileSize(context, result.retainedHeapSize) + ".\n";
       if (detailed) {
         detailedString = "\n* Details:\n" + result.leakTrace.toDetailedString();
       }
     } else if (result.failure != null) {
-      info += "* FAILURE:\n" + Log.getStackTraceString(result.failure) + "\n";
+      // We duplicate the library version & Sha information because bug reports often only contain
+      // the stacktrace.
+      info += "* FAILURE in " + LIBRARY_VERSION + " " + GIT_SHA + ":" + Log.getStackTraceString(
+          result.failure) + "\n";
     } else {
       info += "* NO LEAK FOUND.\n\n";
     }
@@ -125,9 +142,9 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
         + " API: "
         + Build.VERSION.SDK_INT
         + " LeakCanary: "
-        + BuildConfig.LIBRARY_VERSION
+        + LIBRARY_VERSION
         + " "
-        + BuildConfig.GIT_SHA
+        + GIT_SHA
         + "\n"
         + "* Durations: watch="
         + heapDump.watchDurationMs
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
new file mode 100644
index 00000000..1e7ebf87
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import android.app.Activity;
+import java.io.File;
+
+/**
+ * Provides the directory in which heap dumps and analysis results will be stored.
+ * When using your own implementation, you may also want to call {@link
+ * LeakCanary#setDisplayLeakActivityDirectoryProvider(LeakDirectoryProvider)}.
+ */
+public interface LeakDirectoryProvider {
+
+  /** Returns a path to an existing directory were leaks can be stored. */
+  File leakDirectory();
+
+  void requestWritePermissionNotification();
+
+  void requestPermission(Activity activity);
+
+  /** True if we can currently write to the leak directory. */
+  boolean isLeakStorageWritable();
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
index 4e58471d..4ab1baf2 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
@@ -39,7 +39,10 @@
 import android.widget.ListView;
 import android.widget.TextView;
 import com.squareup.leakcanary.AnalysisResult;
+import com.squareup.leakcanary.CanaryLog;
+import com.squareup.leakcanary.DefaultLeakDirectoryProvider;
 import com.squareup.leakcanary.HeapDump;
+import com.squareup.leakcanary.LeakDirectoryProvider;
 import com.squareup.leakcanary.R;
 import java.io.File;
 import java.io.FileInputStream;
@@ -51,23 +54,29 @@
 import java.util.Comparator;
 import java.util.List;
 import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
 
 import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
 import static android.text.format.DateUtils.FORMAT_SHOW_DATE;
 import static android.text.format.DateUtils.FORMAT_SHOW_TIME;
+import static android.text.format.Formatter.formatShortFileSize;
 import static android.view.View.GONE;
 import static android.view.View.VISIBLE;
+import static com.squareup.leakcanary.BuildConfig.GIT_SHA;
+import static com.squareup.leakcanary.BuildConfig.LIBRARY_VERSION;
 import static com.squareup.leakcanary.LeakCanary.leakInfo;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.detectedLeakDirectory;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.leakResultFile;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.newSingleThreadExecutor;
 
 @SuppressWarnings("ConstantConditions") @TargetApi(Build.VERSION_CODES.HONEYCOMB)
 public final class DisplayLeakActivity extends Activity {
 
-  private static final String TAG = "DisplayLeakActivity";
+  private static LeakDirectoryProvider leakDirectoryProvider = null;
+
   private static final String SHOW_LEAK_EXTRA = "show_latest";
 
+  public static PendingIntent createPendingIntent(Context context) {
+    return createPendingIntent(context, null);
+  }
+
   public static PendingIntent createPendingIntent(Context context, String referenceKey) {
     Intent intent = new Intent(context, DisplayLeakActivity.class);
     intent.putExtra(SHOW_LEAK_EXTRA, referenceKey);
@@ -75,14 +84,25 @@ public static PendingIntent createPendingIntent(Context context, String referenc
     return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);
   }
 
+  public static void setLeakDirectoryProvider(LeakDirectoryProvider leakDirectoryProvider) {
+    DisplayLeakActivity.leakDirectoryProvider = leakDirectoryProvider;
+  }
+
+  private static LeakDirectoryProvider leakDirectoryProvider(Context context) {
+    LeakDirectoryProvider leakDirectoryProvider = DisplayLeakActivity.leakDirectoryProvider;
+    if (leakDirectoryProvider == null) {
+      leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
+    }
+    return leakDirectoryProvider;
+  }
+
   // null until it's been first loaded.
-  private List<Leak> leaks;
-  private String visibleLeakRefKey;
+  List<Leak> leaks;
+  String visibleLeakRefKey;
 
   private ListView listView;
   private TextView failureView;
   private Button actionButton;
-  private int maxStoredLeaks;
 
   @Override protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
@@ -99,13 +119,11 @@ public static PendingIntent createPendingIntent(Context context, String referenc
     //noinspection unchecked
     leaks = (List<Leak>) getLastNonConfigurationInstance();
 
-    setContentView(R.layout.__leak_canary_display_leak);
-
-    listView = (ListView) findViewById(R.id.__leak_canary_display_leak_list);
-    failureView = (TextView) findViewById(R.id.__leak_canary_display_leak_failure);
-    actionButton = (Button) findViewById(R.id.__leak_canary_action);
+    setContentView(R.layout.leak_canary_display_leak);
 
-    maxStoredLeaks = getResources().getInteger(R.integer.__leak_canary_max_stored_leaks);
+    listView = (ListView) findViewById(R.id.leak_canary_display_leak_list);
+    failureView = (TextView) findViewById(R.id.leak_canary_display_leak_failure);
+    actionButton = (Button) findViewById(R.id.leak_canary_action);
 
     updateUi();
   }
@@ -122,7 +140,23 @@ public static PendingIntent createPendingIntent(Context context, String referenc
 
   @Override protected void onResume() {
     super.onResume();
-    LoadLeaks.load(this);
+    LeakDirectoryProvider leakDirectoryProvider = leakDirectoryProvider(this);
+    if (leakDirectoryProvider.isLeakStorageWritable()) {
+      File leakDirectory = leakDirectoryProvider.leakDirectory();
+      LoadLeaks.load(this, leakDirectory);
+    } else {
+      leakDirectoryProvider.requestPermission(this);
+    }
+  }
+
+  @Override public void setTheme(int resid) {
+    // We don't want this to be called with an incompatible theme.
+    // This could happen if you implement runtime switching of themes
+    // using ActivityLifecycleCallbacks.
+    if (resid != R.style.leak_canary_LeakCanary_Base) {
+      return;
+    }
+    super.setTheme(resid);
   }
 
   @Override protected void onDestroy() {
@@ -131,21 +165,24 @@ public static PendingIntent createPendingIntent(Context context, String referenc
   }
 
   @Override public boolean onCreateOptionsMenu(Menu menu) {
-    if (getVisibleLeak() != null) {
-      menu.add(R.string.__leak_canary_share_leak)
+    Leak visibleLeak = getVisibleLeak();
+    if (visibleLeak != null) {
+      menu.add(R.string.leak_canary_share_leak)
           .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
             @Override public boolean onMenuItemClick(MenuItem item) {
               shareLeak();
               return true;
             }
           });
-      menu.add(R.string.__leak_canary_share_heap_dump)
-          .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
-            @Override public boolean onMenuItemClick(MenuItem item) {
-              shareHeapDump();
-              return true;
-            }
-          });
+      if (visibleLeak.heapDump.heapDumpFile.exists()) {
+        menu.add(R.string.leak_canary_share_heap_dump)
+            .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
+              @Override public boolean onMenuItemClick(MenuItem item) {
+                shareHeapDump();
+                return true;
+              }
+            });
+      }
       return true;
     }
     return false;
@@ -168,26 +205,58 @@ public static PendingIntent createPendingIntent(Context context, String referenc
     }
   }
 
-  private void shareLeak() {
+  void shareLeak() {
     Leak visibleLeak = getVisibleLeak();
     String leakInfo = leakInfo(this, visibleLeak.heapDump, visibleLeak.result, true);
     Intent intent = new Intent(Intent.ACTION_SEND);
     intent.setType("text/plain");
     intent.putExtra(Intent.EXTRA_TEXT, leakInfo);
-    startActivity(Intent.createChooser(intent, getString(R.string.__leak_canary_share_with)));
+    startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
   }
 
-  private void shareHeapDump() {
+  void shareHeapDump() {
     Leak visibleLeak = getVisibleLeak();
     File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
     heapDumpFile.setReadable(true, false);
     Intent intent = new Intent(Intent.ACTION_SEND);
     intent.setType("application/octet-stream");
     intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(heapDumpFile));
-    startActivity(Intent.createChooser(intent, getString(R.string.__leak_canary_share_with)));
+    startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
+  }
+
+  void deleteVisibleLeak() {
+    Leak visibleLeak = getVisibleLeak();
+    File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
+    File resultFile = visibleLeak.resultFile;
+    boolean resultDeleted = resultFile.delete();
+    if (!resultDeleted) {
+      CanaryLog.d("Could not delete result file %s", resultFile.getPath());
+    }
+    boolean heapDumpDeleted = heapDumpFile.delete();
+    if (!heapDumpDeleted) {
+      CanaryLog.d("Could not delete heap dump file %s", heapDumpFile.getPath());
+    }
+    visibleLeakRefKey = null;
+    leaks.remove(visibleLeak);
+    updateUi();
   }
 
-  private void updateUi() {
+  void deleteAllLeaks() {
+    File leakDirectory = leakDirectoryProvider(DisplayLeakActivity.this).leakDirectory();
+    File[] files = leakDirectory.listFiles();
+    if (files != null) {
+      for (File file : files) {
+        boolean deleted = file.delete();
+        if (!deleted) {
+          CanaryLog.d("Could not delete file %s", file.getPath());
+        }
+      }
+    }
+    leaks = Collections.emptyList();
+    updateUi();
+  }
+
+  void updateUi() {
     if (leaks == null) {
       setTitle("Loading leaks...");
       return;
@@ -211,14 +280,23 @@ private void updateUi() {
       if (result.failure != null) {
         listView.setVisibility(GONE);
         failureView.setVisibility(VISIBLE);
-        failureView.setText(
-            getString(R.string.__leak_canary_failure_report) + Log.getStackTraceString(
-                result.failure));
-        setTitle(R.string.__leak_canary_analysis_failed);
+        String failureMessage = getString(R.string.leak_canary_failure_report)
+            + LIBRARY_VERSION
+            + " "
+            + GIT_SHA
+            + "\n"
+            + Log.getStackTraceString(result.failure);
+        failureView.setText(failureMessage);
+        setTitle(R.string.leak_canary_analysis_failed);
         invalidateOptionsMenu();
         getActionBar().setDisplayHomeAsUpEnabled(true);
         actionButton.setVisibility(VISIBLE);
-        actionButton.setText(R.string.__leak_canary_delete);
+        actionButton.setText(R.string.leak_canary_delete);
+        actionButton.setOnClickListener(new View.OnClickListener() {
+          @Override public void onClick(View v) {
+            deleteVisibleLeak();
+          }
+        });
         listView.setAdapter(null);
       } else {
         final DisplayLeakAdapter adapter;
@@ -236,23 +314,18 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
           invalidateOptionsMenu();
           getActionBar().setDisplayHomeAsUpEnabled(true);
           actionButton.setVisibility(VISIBLE);
-          actionButton.setText(R.string.__leak_canary_delete);
+          actionButton.setText(R.string.leak_canary_delete);
           actionButton.setOnClickListener(new View.OnClickListener() {
             @Override public void onClick(View v) {
-              Leak visibleLeak = getVisibleLeak();
-              File resultFile = leakResultFile(visibleLeak.heapDump.heapDumpFile);
-              resultFile.delete();
-              visibleLeak.heapDump.heapDumpFile.delete();
-              visibleLeakRefKey = null;
-              leaks.remove(visibleLeak);
-              updateUi();
+              deleteVisibleLeak();
             }
           });
         }
         HeapDump heapDump = visibleLeak.heapDump;
         adapter.update(result.leakTrace, heapDump.referenceKey, heapDump.referenceName);
-        setTitle(
-            getString(R.string.__leak_canary_class_has_leaked, classSimpleName(result.className)));
+        String size = formatShortFileSize(this, result.retainedHeapSize);
+        String className = classSimpleName(result.className);
+        setTitle(getString(R.string.leak_canary_class_has_leaked, className, size));
       }
     } else {
       if (listAdapter instanceof LeakListAdapter) {
@@ -268,19 +341,12 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
           }
         });
         invalidateOptionsMenu();
-        setTitle(getString(R.string.__leak_canary_leak_list_title, getPackageName()));
+        setTitle(getString(R.string.leak_canary_leak_list_title, getPackageName()));
         getActionBar().setDisplayHomeAsUpEnabled(false);
-        actionButton.setText(R.string.__leak_canary_delete_all);
+        actionButton.setText(R.string.leak_canary_delete_all);
         actionButton.setOnClickListener(new View.OnClickListener() {
           @Override public void onClick(View v) {
-            File[] files = detectedLeakDirectory().listFiles();
-            if (files != null) {
-              for (File file : files) {
-                file.delete();
-              }
-            }
-            leaks = Collections.emptyList();
-            updateUi();
+            deleteAllLeaks();
           }
         });
       }
@@ -288,7 +354,7 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
     }
   }
 
-  private Leak getVisibleLeak() {
+  Leak getVisibleLeak() {
     if (leaks == null) {
       return null;
     }
@@ -317,23 +383,23 @@ private Leak getVisibleLeak() {
     @Override public View getView(int position, View convertView, ViewGroup parent) {
       if (convertView == null) {
         convertView = LayoutInflater.from(DisplayLeakActivity.this)
-            .inflate(R.layout.__leak_canary_leak_row, parent, false);
+            .inflate(R.layout.leak_canary_leak_row, parent, false);
       }
-      TextView titleView = (TextView) convertView.findViewById(R.id.__leak_canary_row_text);
-      TextView timeView = (TextView) convertView.findViewById(R.id.__leak_canary_row_time);
+      TextView titleView = (TextView) convertView.findViewById(R.id.leak_canary_row_text);
+      TextView timeView = (TextView) convertView.findViewById(R.id.leak_canary_row_time);
       Leak leak = getItem(position);
 
-      String index;
-      if (position == 0 && leaks.size() == maxStoredLeaks) {
-        index = "MAX. ";
-      } else {
-        index = (leaks.size() - position) + ". ";
-      }
+      String index = (leaks.size() - position) + ". ";
 
       String title;
       if (leak.result.failure == null) {
-        title = index + getString(R.string.__leak_canary_class_has_leaked,
-            classSimpleName(leak.result.className));
+        String className = classSimpleName(leak.result.className);
+        String size = formatShortFileSize(DisplayLeakActivity.this, leak.result.retainedHeapSize);
+        title = getString(R.string.leak_canary_class_has_leaked, className, size);
+        if (leak.result.excludedLeak) {
+          title = getString(R.string.leak_canary_excluded_row, title);
+        }
+        title = index + title;
       } else {
         title = index
             + leak.result.failure.getClass().getSimpleName()
@@ -341,8 +407,9 @@ private Leak getVisibleLeak() {
             + leak.result.failure.getMessage();
       }
       titleView.setText(title);
-      String time = DateUtils.formatDateTime(DisplayLeakActivity.this,
-          leak.heapDump.heapDumpFile.lastModified(), FORMAT_SHOW_TIME | FORMAT_SHOW_DATE);
+      String time =
+          DateUtils.formatDateTime(DisplayLeakActivity.this, leak.resultFile.lastModified(),
+              FORMAT_SHOW_TIME | FORMAT_SHOW_DATE);
       timeView.setText(time);
       return convertView;
     }
@@ -351,10 +418,12 @@ private Leak getVisibleLeak() {
   static class Leak {
     final HeapDump heapDump;
     final AnalysisResult result;
+    final File resultFile;
 
-    Leak(HeapDump heapDump, AnalysisResult result) {
+    Leak(HeapDump heapDump, AnalysisResult result, File resultFile) {
       this.heapDump = heapDump;
       this.result = result;
+      this.resultFile = resultFile;
     }
   }
 
@@ -362,10 +431,10 @@ private Leak getVisibleLeak() {
 
     static final List<LoadLeaks> inFlight = new ArrayList<>();
 
-    static final Executor backgroundExecutor = Executors.newSingleThreadExecutor();
+    static final Executor backgroundExecutor = newSingleThreadExecutor("LoadLeaks");
 
-    static void load(DisplayLeakActivity activity) {
-      LoadLeaks loadLeaks = new LoadLeaks(activity);
+    static void load(DisplayLeakActivity activity, File leakDirectory) {
+      LoadLeaks loadLeaks = new LoadLeaks(activity, leakDirectory);
       inFlight.add(loadLeaks);
       backgroundExecutor.execute(loadLeaks);
     }
@@ -377,13 +446,13 @@ static void forgetActivity() {
       inFlight.clear();
     }
 
-    private DisplayLeakActivity activityOrNull;
+    DisplayLeakActivity activityOrNull;
     private final File leakDirectory;
     private final Handler mainHandler;
 
-    LoadLeaks(DisplayLeakActivity activity) {
+    LoadLeaks(DisplayLeakActivity activity, File leakDirectory) {
       this.activityOrNull = activity;
-      leakDirectory = detectedLeakDirectory();
+      this.leakDirectory = leakDirectory;
       mainHandler = new Handler(Looper.getMainLooper());
     }
 
@@ -391,26 +460,29 @@ static void forgetActivity() {
       final List<Leak> leaks = new ArrayList<>();
       File[] files = leakDirectory.listFiles(new FilenameFilter() {
         @Override public boolean accept(File dir, String filename) {
-          return filename.endsWith(".hprof");
+          return filename.endsWith(".result");
         }
       });
+
       if (files != null) {
-        for (File heapDumpFile : files) {
-          File resultFile = leakResultFile(heapDumpFile);
+        for (File resultFile : files) {
           FileInputStream fis = null;
           try {
             fis = new FileInputStream(resultFile);
             ObjectInputStream ois = new ObjectInputStream(fis);
             HeapDump heapDump = (HeapDump) ois.readObject();
             AnalysisResult result = (AnalysisResult) ois.readObject();
-            leaks.add(new Leak(heapDump, result));
+            leaks.add(new Leak(heapDump, result, resultFile));
           } catch (IOException | ClassNotFoundException e) {
             // Likely a change in the serializable result class.
             // Let's remove the files, we can't read them anymore.
-            heapDumpFile.delete();
-            resultFile.delete();
-            Log.e(TAG, "Could not read result file, deleted result and heap dump:" + heapDumpFile,
-                e);
+            boolean deleted = resultFile.delete();
+            if (deleted) {
+              CanaryLog.d(e, "Could not read result file %s, deleted it.", resultFile);
+            } else {
+              CanaryLog.d(e, "Could not read result file %s, could not delete it either.",
+                  resultFile);
+            }
           } finally {
             if (fis != null) {
               try {
@@ -422,8 +494,8 @@ static void forgetActivity() {
         }
         Collections.sort(leaks, new Comparator<Leak>() {
           @Override public int compare(Leak lhs, Leak rhs) {
-            return Long.valueOf(rhs.heapDump.heapDumpFile.lastModified())
-                .compareTo(lhs.heapDump.heapDumpFile.lastModified());
+            return Long.valueOf(rhs.resultFile.lastModified())
+                .compareTo(lhs.resultFile.lastModified());
           }
         });
       }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
index fa1c73ac..fd23cfbd 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
@@ -22,6 +22,7 @@
 import android.view.ViewGroup;
 import android.widget.BaseAdapter;
 import android.widget.TextView;
+import com.squareup.leakcanary.Exclusion;
 import com.squareup.leakcanary.LeakTrace;
 import com.squareup.leakcanary.LeakTraceElement;
 import com.squareup.leakcanary.R;
@@ -49,16 +50,16 @@
     if (getItemViewType(position) == TOP_ROW) {
       if (convertView == null) {
         convertView =
-            LayoutInflater.from(context).inflate(R.layout.__leak_canary_ref_top_row, parent, false);
+            LayoutInflater.from(context).inflate(R.layout.leak_canary_ref_top_row, parent, false);
       }
-      TextView textView = findById(convertView, R.id.__leak_canary_row_text);
+      TextView textView = findById(convertView, R.id.leak_canary_row_text);
       textView.setText(context.getPackageName());
     } else {
       if (convertView == null) {
         convertView =
-            LayoutInflater.from(context).inflate(R.layout.__leak_canary_ref_row, parent, false);
+            LayoutInflater.from(context).inflate(R.layout.leak_canary_ref_row, parent, false);
       }
-      TextView textView = findById(convertView, R.id.__leak_canary_row_text);
+      TextView textView = findById(convertView, R.id.leak_canary_row_text);
 
       boolean isRoot = position == 1;
       boolean isLeakingInstance = position == getCount() - 1;
@@ -69,7 +70,7 @@
       }
       textView.setText(Html.fromHtml(htmlString));
 
-      DisplayLeakConnectorView connector = findById(convertView, R.id.__leak_canary_row_connector);
+      DisplayLeakConnectorView connector = findById(convertView, R.id.leak_canary_row_connector);
       if (isRoot) {
         connector.setType(DisplayLeakConnectorView.Type.START);
       } else {
@@ -79,7 +80,7 @@
           connector.setType(DisplayLeakConnectorView.Type.NODE);
         }
       }
-      MoreDetailsView moreDetailsView = findById(convertView, R.id.__leak_canary_row_more);
+      MoreDetailsView moreDetailsView = findById(convertView, R.id.leak_canary_row_more);
       moreDetailsView.setOpened(opened[position]);
     }
 
@@ -132,6 +133,23 @@ private String elementToHtmlString(LeakTraceElement element, boolean root, boole
     if (opened && element.extra != null) {
       htmlString += " <font color='#919191'>" + element.extra + "</font>";
     }
+
+    Exclusion exclusion = element.exclusion;
+    if (exclusion != null) {
+      if (opened) {
+        htmlString += "<br/><br/>Excluded by rule";
+        if (exclusion.name != null) {
+          htmlString += " <font color='#ffffff'>" + exclusion.name + "</font>";
+        }
+        htmlString += " matching <font color='#f3cf83'>" + exclusion.matching + "</font>";
+        if (exclusion.reason != null) {
+          htmlString += " because <font color='#f3cf83'>" + exclusion.reason + "</font>";
+        }
+      } else {
+        htmlString += " (excluded)";
+      }
+    }
+
     return htmlString;
   }
 
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
index 56aeccd0..d03dad94 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
@@ -20,12 +20,10 @@
 import android.content.Intent;
 import com.squareup.leakcanary.AbstractAnalysisResultService;
 import com.squareup.leakcanary.AnalysisResult;
-import com.squareup.leakcanary.ExcludedRefs;
+import com.squareup.leakcanary.CanaryLog;
 import com.squareup.leakcanary.HeapAnalyzer;
 import com.squareup.leakcanary.HeapDump;
 
-import static com.squareup.leakcanary.AndroidExcludedRefs.createAndroidDefaults;
-
 /**
  * This service runs in a separate process to avoid slowing down the app process or making it run
  * out of memory.
@@ -48,11 +46,14 @@ public HeapAnalyzerService() {
   }
 
   @Override protected void onHandleIntent(Intent intent) {
+    if (intent == null) {
+      CanaryLog.d("HeapAnalyzerService received a null intent, ignoring.");
+      return;
+    }
     String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);
     HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);
 
-    ExcludedRefs androidExcludedDefault = createAndroidDefaults().build();
-    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(androidExcludedDefault, heapDump.excludedRefs);
+    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(heapDump.excludedRefs);
 
     AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);
     AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
index ac8ecba7..cdb5a055 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
@@ -15,16 +15,21 @@
  */
 package com.squareup.leakcanary.internal;
 
+import android.annotation.TargetApi;
 import android.app.ActivityManager;
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
 import android.app.Service;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.ServiceInfo;
-import android.os.Environment;
-import android.util.Log;
-import java.io.File;
+import com.squareup.leakcanary.CanaryLog;
+import com.squareup.leakcanary.R;
+import java.lang.reflect.Method;
+import java.util.List;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 
@@ -32,57 +37,23 @@
 import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
 import static android.content.pm.PackageManager.DONT_KILL_APP;
 import static android.content.pm.PackageManager.GET_SERVICES;
-import static android.os.Environment.DIRECTORY_DOWNLOADS;
+import static android.os.Build.VERSION.SDK_INT;
+import static android.os.Build.VERSION_CODES.HONEYCOMB;
+import static android.os.Build.VERSION_CODES.JELLY_BEAN;
 
 public final class LeakCanaryInternals {
 
-  // SDK INT for API 22.
-  public static final int LOLLIPOP_MR1 = 22;
   public static final String SAMSUNG = "samsung";
   public static final String MOTOROLA = "motorola";
   public static final String LG = "LGE";
   public static final String NVIDIA = "NVIDIA";
 
-  private static final Executor fileIoExecutor = Executors.newSingleThreadExecutor();
+  private static final Executor fileIoExecutor = newSingleThreadExecutor("File-IO");
 
   public static void executeOnFileIoThread(Runnable runnable) {
     fileIoExecutor.execute(runnable);
   }
 
-  public static File storageDirectory() {
-    File downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS);
-    File leakCanaryDirectory = new File(downloadsDirectory, "leakcanary");
-    leakCanaryDirectory.mkdirs();
-    return leakCanaryDirectory;
-  }
-
-  public static File detectedLeakDirectory() {
-    File directory = new File(storageDirectory(), "detected_leaks");
-    directory.mkdirs();
-    return directory;
-  }
-
-  public static File leakResultFile(File heapdumpFile) {
-    return new File(heapdumpFile.getParentFile(), heapdumpFile.getName() + ".result");
-  }
-
-  public static boolean isExternalStorageWritable() {
-    String state = Environment.getExternalStorageState();
-    return Environment.MEDIA_MOUNTED.equals(state);
-  }
-
-  public static File findNextAvailableHprofFile(int maxFiles) {
-    File directory = detectedLeakDirectory();
-    for (int i = 0; i < maxFiles; i++) {
-      String heapDumpName = "heap_dump_" + i + ".hprof";
-      File file = new File(directory, heapDumpName);
-      if (!file.exists()) {
-        return file;
-      }
-    }
-    return null;
-  }
-
   /** Extracts the class simple name out of a string containing a fully qualified class name. */
   public static String classSimpleName(String className) {
     int separator = className.lastIndexOf('.');
@@ -98,22 +69,27 @@ public static void setEnabled(Context context, final Class<?> componentClass,
     final Context appContext = context.getApplicationContext();
     executeOnFileIoThread(new Runnable() {
       @Override public void run() {
-        ComponentName component = new ComponentName(appContext, componentClass);
-        PackageManager packageManager = appContext.getPackageManager();
-        int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED;
-        // Blocks on IPC.
-        packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);
+        setEnabledBlocking(appContext, componentClass, enabled);
       }
     });
   }
 
+  public static void setEnabledBlocking(Context appContext, Class<?> componentClass,
+      boolean enabled) {
+    ComponentName component = new ComponentName(appContext, componentClass);
+    PackageManager packageManager = appContext.getPackageManager();
+    int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED;
+    // Blocks on IPC.
+    packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);
+  }
+
   public static boolean isInServiceProcess(Context context, Class<? extends Service> serviceClass) {
     PackageManager packageManager = context.getPackageManager();
     PackageInfo packageInfo;
     try {
       packageInfo = packageManager.getPackageInfo(context.getPackageName(), GET_SERVICES);
     } catch (Exception e) {
-      Log.e("AndroidUtils", "Could not get package info for " + context.getPackageName(), e);
+      CanaryLog.d(e, "Could not get package info for %s", context.getPackageName());
       return false;
     }
     String mainProcess = packageInfo.applicationInfo.processName;
@@ -128,8 +104,7 @@ public static boolean isInServiceProcess(Context context, Class<? extends Servic
     }
 
     if (serviceInfo.processName.equals(mainProcess)) {
-      Log.e("AndroidUtils",
-          "Did not expect service " + serviceClass + " to run in main process " + mainProcess);
+      CanaryLog.d("Did not expect service %s to run in main process %s", serviceClass, mainProcess);
       // Technically we are in the service process, but we're not in the service dedicated process.
       return false;
     }
@@ -138,20 +113,65 @@ public static boolean isInServiceProcess(Context context, Class<? extends Servic
     ActivityManager activityManager =
         (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
     ActivityManager.RunningAppProcessInfo myProcess = null;
-    for (ActivityManager.RunningAppProcessInfo process : activityManager.getRunningAppProcesses()) {
-      if (process.pid == myPid) {
-        myProcess = process;
-        break;
+    List<ActivityManager.RunningAppProcessInfo> runningProcesses =
+        activityManager.getRunningAppProcesses();
+    if (runningProcesses != null) {
+      for (ActivityManager.RunningAppProcessInfo process : runningProcesses) {
+        if (process.pid == myPid) {
+          myProcess = process;
+          break;
+        }
       }
     }
     if (myProcess == null) {
-      Log.e("AndroidUtils", "Could not find running process for " + myPid);
+      CanaryLog.d("Could not find running process for %d", myPid);
       return false;
     }
 
     return myProcess.processName.equals(serviceInfo.processName);
   }
 
+  @TargetApi(HONEYCOMB)
+  public static void showNotification(Context context, CharSequence contentTitle,
+      CharSequence contentText, PendingIntent pendingIntent) {
+    NotificationManager notificationManager =
+        (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+
+    Notification notification;
+    if (SDK_INT < HONEYCOMB) {
+      notification = new Notification();
+      notification.icon = R.drawable.leak_canary_notification;
+      notification.when = System.currentTimeMillis();
+      notification.flags |= Notification.FLAG_AUTO_CANCEL;
+      try {
+        Method method =
+            Notification.class.getMethod("setLatestEventInfo", Context.class, CharSequence.class,
+                CharSequence.class, PendingIntent.class);
+        method.invoke(notification, context, contentTitle, contentText, pendingIntent);
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    } else {
+      Notification.Builder builder = new Notification.Builder(context) //
+          .setSmallIcon(R.drawable.leak_canary_notification)
+          .setWhen(System.currentTimeMillis())
+          .setContentTitle(contentTitle)
+          .setContentText(contentText)
+          .setAutoCancel(true)
+          .setContentIntent(pendingIntent);
+      if (SDK_INT < JELLY_BEAN) {
+        notification = builder.getNotification();
+      } else {
+        notification = builder.build();
+      }
+    }
+    notificationManager.notify(0xDEAFBEEF, notification);
+  }
+
+  public static Executor newSingleThreadExecutor(String threadName) {
+    return Executors.newSingleThreadExecutor(new LeakCanarySingleThreadFactory(threadName));
+  }
+
   private LeakCanaryInternals() {
     throw new AssertionError();
   }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java
new file mode 100644
index 00000000..4eb3a3a0
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import java.util.concurrent.ThreadFactory;
+
+/**
+ * This is intended to only be used with a single thread executor.
+ */
+final class LeakCanarySingleThreadFactory implements ThreadFactory {
+
+  private final String threadName;
+
+  LeakCanarySingleThreadFactory(String threadName) {
+    this.threadName = "LeakCanary-" + threadName;
+  }
+
+  @Override public Thread newThread(Runnable runnable) {
+    return new Thread(runnable, threadName);
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java
new file mode 100644
index 00000000..3d8a23f1
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.widget.Toast;
+import com.squareup.leakcanary.R;
+
+import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
+import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
+import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
+import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
+import static android.content.pm.PackageManager.PERMISSION_GRANTED;
+import static android.os.Build.VERSION_CODES.M;
+import static android.widget.Toast.LENGTH_LONG;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabledBlocking;
+
+@TargetApi(M) //
+public class RequestStoragePermissionActivity extends Activity {
+
+  public static PendingIntent createPendingIntent(Context context) {
+    setEnabledBlocking(context, RequestStoragePermissionActivity.class, true);
+    Intent intent = new Intent(context, RequestStoragePermissionActivity.class);
+    intent.setFlags(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TOP);
+    return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);
+  }
+
+  @Override protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+
+    if (savedInstanceState == null) {
+      if (hasStoragePermission()) {
+        finish();
+        return;
+      }
+      String[] permissions = {
+          WRITE_EXTERNAL_STORAGE
+      };
+      requestPermissions(permissions, 42);
+    }
+  }
+
+  @Override public void onRequestPermissionsResult(int requestCode, String[] permissions,
+      int[] grantResults) {
+    if (!hasStoragePermission()) {
+      Toast.makeText(getApplication(), R.string.leak_canary_permission_not_granted, LENGTH_LONG)
+          .show();
+    }
+    finish();
+  }
+
+  private boolean hasStoragePermission() {
+    return checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED;
+  }
+}
diff --git a/leakcanary-android/src/main/res/drawable-hdpi-v11/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi-v11/__leak_canary_notification.png
deleted file mode 100755
index f1049229..00000000
Binary files a/leakcanary-android/src/main/res/drawable-hdpi-v11/__leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png
new file mode 100755
index 00000000..07bb09fc
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_icon.png
deleted file mode 100755
index 7e375c54..00000000
Binary files a/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_notification.png
deleted file mode 100755
index 09c78cc0..00000000
Binary files a/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png
new file mode 100755
index 00000000..74348d82
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png
new file mode 100755
index 00000000..13b33116
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi-v11/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi-v11/__leak_canary_notification.png
deleted file mode 100755
index d29b9f1d..00000000
Binary files a/leakcanary-android/src/main/res/drawable-mdpi-v11/__leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png
new file mode 100755
index 00000000..9738ad81
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_icon.png
deleted file mode 100755
index f354c3f2..00000000
Binary files a/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_notification.png
deleted file mode 100755
index c825fa4a..00000000
Binary files a/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png
new file mode 100755
index 00000000..37f5057f
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png
new file mode 100755
index 00000000..dc92783b
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi-v11/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi-v11/__leak_canary_notification.png
deleted file mode 100755
index d0cdbcd8..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi-v11/__leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png
new file mode 100755
index 00000000..538e0214
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_icon.png
deleted file mode 100755
index a5e85b41..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_notification.png
deleted file mode 100755
index b2978d57..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png
new file mode 100755
index 00000000..56a94f27
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png
new file mode 100755
index 00000000..1e1b977f
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi-v11/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi-v11/__leak_canary_notification.png
deleted file mode 100755
index 0194b4e1..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi-v11/__leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png
new file mode 100755
index 00000000..d3ef4b71
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_icon.png
deleted file mode 100755
index 3d4b76af..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_notification.png
deleted file mode 100755
index 22db2020..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png
new file mode 100755
index 00000000..34b7d41b
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png
new file mode 100755
index 00000000..c652efdd
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/__leak_canary_notification.png
deleted file mode 100755
index 05141619..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/__leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png
new file mode 100755
index 00000000..4713f18d
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_icon.png
deleted file mode 100755
index eb9c0724..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_notification.png
deleted file mode 100755
index 34b76141..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png
new file mode 100755
index 00000000..855d6052
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png
new file mode 100755
index 00000000..bb458f2c
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable/__leak_canary_toast_background.xml b/leakcanary-android/src/main/res/drawable/leak_canary_toast_background.xml
similarity index 100%
rename from leakcanary-android/src/main/res/drawable/__leak_canary_toast_background.xml
rename to leakcanary-android/src/main/res/drawable/leak_canary_toast_background.xml
diff --git a/leakcanary-android/src/main/res/layout/__leak_canary_display_leak.xml b/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
similarity index 89%
rename from leakcanary-android/src/main/res/layout/__leak_canary_display_leak.xml
rename to leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
index d9d312e0..8e56c3d1 100644
--- a/leakcanary-android/src/main/res/layout/__leak_canary_display_leak.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
@@ -21,7 +21,7 @@
     android:background="#3c3c3c"
     >
   <ListView
-      android:id="@+id/__leak_canary_display_leak_list"
+      android:id="@+id/leak_canary_display_leak_list"
       android:layout_width="match_parent"
       android:layout_height="0dp"
       android:layout_weight="1"
@@ -29,7 +29,7 @@
       android:divider="@null"
       />
   <TextView
-      android:id="@+id/__leak_canary_display_leak_failure"
+      android:id="@+id/leak_canary_display_leak_failure"
       android:layout_width="match_parent"
       android:layout_height="0dp"
       android:layout_weight="1"
@@ -37,7 +37,7 @@
       android:visibility="gone"
       />
   <Button
-      android:id="@+id/__leak_canary_action"
+      android:id="@+id/leak_canary_action"
       android:layout_width="match_parent"
       android:layout_height="wrap_content"
       android:visibility="gone"
diff --git a/leakcanary-android/src/main/res/layout/__leak_canary_heap_dump_toast.xml b/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml
similarity index 87%
rename from leakcanary-android/src/main/res/layout/__leak_canary_heap_dump_toast.xml
rename to leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml
index 7bc707c3..d6057ed2 100644
--- a/leakcanary-android/src/main/res/layout/__leak_canary_heap_dump_toast.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml
@@ -18,14 +18,14 @@
     android:layout_width="wrap_content"
     android:layout_height="wrap_content"
     android:orientation="vertical"
-    android:background="@drawable/__leak_canary_toast_background"
+    android:background="@drawable/leak_canary_toast_background"
     android:padding="16dp"
     >
   <ImageView
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
       android:layout_gravity="center_horizontal"
-      android:src="@drawable/__leak_canary_icon"/>
+      android:src="@drawable/leak_canary_icon"/>
 
   <TextView
       android:layout_width="wrap_content"
@@ -33,7 +33,7 @@
       android:layout_gravity="center_horizontal"
       android:textColor="#ffffff"
       android:textSize="18sp"
-      android:text="@string/__leak_canary_toast_heap_dump"
+      android:text="@string/leak_canary_toast_heap_dump"
       />
 
 </LinearLayout>
diff --git a/leakcanary-android/src/main/res/layout/__leak_canary_leak_row.xml b/leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml
similarity index 93%
rename from leakcanary-android/src/main/res/layout/__leak_canary_leak_row.xml
rename to leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml
index 00e291b4..c5c5ac7f 100644
--- a/leakcanary-android/src/main/res/layout/__leak_canary_leak_row.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml
@@ -23,7 +23,7 @@
     >
 
   <TextView
-      android:id="@+id/__leak_canary_row_text"
+      android:id="@+id/leak_canary_row_text"
       android:layout_width="0dp"
       android:layout_weight="1"
       android:layout_height="wrap_content"
@@ -32,7 +32,7 @@
       />
 
   <TextView
-      android:id="@+id/__leak_canary_row_time"
+      android:id="@+id/leak_canary_row_time"
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
       android:layout_gravity="center_vertical"
diff --git a/leakcanary-android/src/main/res/layout/__leak_canary_ref_row.xml b/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
similarity index 81%
rename from leakcanary-android/src/main/res/layout/__leak_canary_ref_row.xml
rename to leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
index 7e8721f7..947af46c 100644
--- a/leakcanary-android/src/main/res/layout/__leak_canary_ref_row.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
@@ -22,15 +22,15 @@
     >
 
   <com.squareup.leakcanary.internal.DisplayLeakConnectorView
-      android:id="@+id/__leak_canary_row_connector"
+      android:id="@+id/leak_canary_row_connector"
       android:layout_width="16dp"
       android:layout_height="match_parent"
-      android:layout_marginLeft="16dp"
-      android:layout_marginRight="16dp"
+      android:layout_marginStart="16dp"
+      android:layout_marginEnd="16dp"
       />
 
   <TextView
-      android:id="@+id/__leak_canary_row_text"
+      android:id="@+id/leak_canary_row_text"
       android:layout_width="0dp"
       android:layout_weight="1"
       android:layout_height="wrap_content"
@@ -38,12 +38,12 @@
       />
 
   <com.squareup.leakcanary.internal.MoreDetailsView
-      android:id="@+id/__leak_canary_row_more"
+      android:id="@+id/leak_canary_row_more"
       android:layout_width="12dp"
       android:layout_height="12dp"
       android:layout_gravity="center_vertical"
-      android:layout_marginLeft="16dp"
-      android:layout_marginRight="16dp"
+      android:layout_marginStart="16dp"
+      android:layout_marginEnd="16dp"
       />
 
-</LinearLayout>
\ No newline at end of file
+</LinearLayout>
diff --git a/leakcanary-android/src/main/res/layout/__leak_canary_ref_top_row.xml b/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
similarity index 95%
rename from leakcanary-android/src/main/res/layout/__leak_canary_ref_top_row.xml
rename to leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
index 4fc704b5..c4803b76 100644
--- a/leakcanary-android/src/main/res/layout/__leak_canary_ref_top_row.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
@@ -16,7 +16,7 @@
   -->
 <TextView
     xmlns:android="http://schemas.android.com/apk/res/android"
-    android:id="@+id/__leak_canary_row_text"
+    android:id="@+id/leak_canary_row_text"
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
     android:layout_margin="16dp"
diff --git a/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
new file mode 100644
index 00000000..6e43e4d3
--- /dev/null
+++ b/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+    <string name="leak_canary_class_has_leaked">%1$s hat %2$s geleaked</string>
+    <string name="leak_canary_leak_excluded">[Ausgeschlossen] %1$s hat %2$s geleaked</string>
+    <string name="leak_canary_analysis_failed">Leak Analyse fehlgeschlagen</string>
+    <string name="leak_canary_leak_list_title">Leaks in %s</string>
+    <string name="leak_canary_notification_message">Für mehr Details hier klicken</string>
+    <string name="leak_canary_share_leak">Info teilen</string>
+    <string name="leak_canary_share_heap_dump">Heap Dump teilen</string>
+    <string name="leak_canary_share_with">Teilen mit…</string>
+    <string name="leak_canary_display_activity_label">Leaks</string>
+    <string name="leak_canary_storage_permission_activity_label">Storage Berechtigung</string>
+    <string name="leak_canary_toast_heap_dump">Sichere den Speicher, die App wird einfrieren. Brrr.</string>
+    <string name="leak_canary_delete">Löschen</string>
+    <string name="leak_canary_failure_report">"Bitte sende diesen Fehler an http://github.com/square/leakcanary\n"</string>
+    <string name="leak_canary_delete_all">Alle löschen</string>
+    <string name="leak_canary_could_not_save_title">Konnte Ergebnis nicht speichern.</string>
+    <string name="leak_canary_could_not_save_text">LeakCanary konnte das Ergebnis der Analyse nicht speichern.</string>
+    <string name="leak_canary_no_leak_title">Kein Leak gefunden</string>
+    <string name="leak_canary_no_leak_text">Der GC war untätig.</string>
+    <string name="leak_canary_excluded_row">[Ausgeschlossen] %s</string>
+    <string name="leak_canary_permission_not_granted">Bitte gewähre die Storage Berechtigung, andernfalls werden Memory Leaks nicht erkannt.</string>
+    <string name="leak_canary_permission_notification_title">Leak erkannt, benötige Berechtigung</string>
+    <string name="leak_canary_permission_notification_text">Hier klicken, um Storage Berechtigung für %s zu aktivieren.</string>
+</resources>
diff --git a/leakcanary-android/src/main/res/values-v21/__leak_canary_themes.xml b/leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml
similarity index 88%
rename from leakcanary-android/src/main/res/values-v21/__leak_canary_themes.xml
rename to leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml
index 0a8dbbfc..409cb66b 100644
--- a/leakcanary-android/src/main/res/values-v21/__leak_canary_themes.xml
+++ b/leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml
@@ -15,6 +15,6 @@
   ~ limitations under the License.
   -->
 <resources>
-  <style name="__LeakCanary.Base" parent="android:Theme.Material">
+  <style name="leak_canary_LeakCanary.Base" parent="android:Theme.Holo">
   </style>
 </resources>
\ No newline at end of file
diff --git a/leakcanary-android/src/main/res/values/__leak_canary_themes.xml b/leakcanary-android/src/main/res/values-v21/leak_canary_themes.xml
similarity index 88%
rename from leakcanary-android/src/main/res/values/__leak_canary_themes.xml
rename to leakcanary-android/src/main/res/values-v21/leak_canary_themes.xml
index 21df5844..0a43b8f9 100644
--- a/leakcanary-android/src/main/res/values/__leak_canary_themes.xml
+++ b/leakcanary-android/src/main/res/values-v21/leak_canary_themes.xml
@@ -15,6 +15,6 @@
   ~ limitations under the License.
   -->
 <resources>
-  <style name="__LeakCanary.Base" parent="android:Theme">
+  <style name="leak_canary_LeakCanary.Base" parent="android:Theme.Material">
   </style>
 </resources>
\ No newline at end of file
diff --git a/leakcanary-android/src/main/res/values/__leak_canary_strings.xml b/leakcanary-android/src/main/res/values/__leak_canary_strings.xml
deleted file mode 100644
index f92e8fd1..00000000
--- a/leakcanary-android/src/main/res/values/__leak_canary_strings.xml
+++ /dev/null
@@ -1,32 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<resources>
-
-  <string name="__leak_canary_class_has_leaked">%s has leaked</string>
-  <string name="__leak_canary_analysis_failed">Leak analysis failed</string>
-  <string name="__leak_canary_leak_list_title">Leaks in %s</string>
-  <string name="__leak_canary_notification_message">Click for more details</string>
-  <string name="__leak_canary_share_leak">Share info</string>
-  <string name="__leak_canary_share_heap_dump">Share heap dump</string>
-  <string name="__leak_canary_share_with">Share with…</string>
-  <string name="__leak_canary_display_activity_label">Leaks</string>
-  <string name="__leak_canary_toast_heap_dump">Dumping memory, app will freeze. Brrrr.</string>
-  <string name="__leak_canary_delete">Delete</string>
-  <string name="__leak_canary_failure_report">"Please report this failure to http://github.com/square/leakcanary\n"</string>
-  <string name="__leak_canary_delete_all">Delete all</string>
-
-</resources>
\ No newline at end of file
diff --git a/leakcanary-android/src/main/res/values-v14/__leak_canary_themes.xml b/leakcanary-android/src/main/res/values/leak_canary_int.xml
similarity index 83%
rename from leakcanary-android/src/main/res/values-v14/__leak_canary_themes.xml
rename to leakcanary-android/src/main/res/values/leak_canary_int.xml
index c59e71e1..b7197372 100644
--- a/leakcanary-android/src/main/res/values-v14/__leak_canary_themes.xml
+++ b/leakcanary-android/src/main/res/values/leak_canary_int.xml
@@ -15,6 +15,6 @@
   ~ limitations under the License.
   -->
 <resources>
-  <style name="__LeakCanary.Base" parent="android:Theme.Holo">
-  </style>
-</resources>
\ No newline at end of file
+  <integer name="leak_canary_max_stored_leaks">7</integer>
+  <integer name="leak_canary_watch_delay_millis">5000</integer>
+</resources>
diff --git a/leakcanary-android/src/main/res/values/__leak_canary_int.xml b/leakcanary-android/src/main/res/values/leak_canary_public.xml
similarity index 67%
rename from leakcanary-android/src/main/res/values/__leak_canary_int.xml
rename to leakcanary-android/src/main/res/values/leak_canary_public.xml
index 8811d1fc..b5f11b97 100644
--- a/leakcanary-android/src/main/res/values/__leak_canary_int.xml
+++ b/leakcanary-android/src/main/res/values/leak_canary_public.xml
@@ -15,5 +15,11 @@
   ~ limitations under the License.
   -->
 <resources>
-  <integer name="__leak_canary_max_stored_leaks">7</integer>
-</resources>
\ No newline at end of file
+
+  <public name="leak_canary_display_activity_label" type="string"/>
+  <public name="leak_canary_heap_dump_toast" type="layout"/>
+  <public name="leak_canary_icon" type="drawable"/>
+  <public name="leak_canary_max_stored_leaks" type="integer"/>
+  <public name="leak_canary_watch_delay_millis" type="integer"/>
+
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_strings.xml b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
new file mode 100644
index 00000000..d9aaee13
--- /dev/null
+++ b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <string name="leak_canary_class_has_leaked">%1$s leaked %2$s</string>
+  <string name="leak_canary_leak_excluded">[Excluded] %1$s leaked %2$s</string>
+  <string name="leak_canary_analysis_failed">Leak analysis failed</string>
+  <string name="leak_canary_leak_list_title">Leaks in %s</string>
+  <string name="leak_canary_notification_message">Click for more details</string>
+  <string name="leak_canary_share_leak">Share info</string>
+  <string name="leak_canary_share_heap_dump">Share heap dump</string>
+  <string name="leak_canary_share_with">Share with…</string>
+  <string name="leak_canary_display_activity_label">Leaks</string>
+  <string name="leak_canary_storage_permission_activity_label">Storage permission</string>
+  <string name="leak_canary_toast_heap_dump">Dumping memory, app will freeze. Brrrr.</string>
+  <string name="leak_canary_delete">Delete</string>
+  <string name="leak_canary_failure_report">"Please report this failure to http://github.com/square/leakcanary\n"</string>
+  <string name="leak_canary_delete_all">Delete all</string>
+  <string name="leak_canary_could_not_save_title">Could not save result.</string>
+  <string name="leak_canary_could_not_save_text">LeakCanary was unable to save the analysis result.</string>
+  <string name="leak_canary_no_leak_title">No leak found</string>
+  <string name="leak_canary_no_leak_text">The GC was being lazy.</string>
+  <string name="leak_canary_excluded_row">[Excluded] %s</string>
+  <string name="leak_canary_permission_not_granted">Please grant external storage permission, otherwise memory leaks will not be detected.</string>
+  <string name="leak_canary_permission_notification_title">Leak detected, need permission</string>
+  <string name="leak_canary_permission_notification_text">Click to enable storage permission for %s.</string>
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_themes.xml b/leakcanary-android/src/main/res/values/leak_canary_themes.xml
new file mode 100644
index 00000000..eebd0333
--- /dev/null
+++ b/leakcanary-android/src/main/res/values/leak_canary_themes.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <style name="leak_canary_LeakCanary.Base" parent="android:Theme">
+  </style>
+
+  <style name="leak_canary_Theme.Transparent" parent="android:Theme">
+    <item name="android:windowIsTranslucent">true</item>
+    <item name="android:windowBackground">@android:color/transparent</item>
+    <item name="android:windowContentOverlay">@null</item>
+    <item name="android:windowNoTitle">true</item>
+    <item name="android:backgroundDimEnabled">false</item>
+  </style>
+</resources>
diff --git a/leakcanary-sample/build.gradle b/leakcanary-sample/build.gradle
index d80081b8..54e0d55c 100644
--- a/leakcanary-sample/build.gradle
+++ b/leakcanary-sample/build.gradle
@@ -26,4 +26,12 @@ android {
   buildTypes {
     debug
   }
+
+  dexOptions {
+    dexInProcess false
+  }
+
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+  }
 }
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
index 942be776..3f8c98ce 100644
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
@@ -26,6 +26,11 @@
 
   @Override public void onCreate() {
     super.onCreate();
+    if (LeakCanary.isInAnalyzerProcess(this)) {
+      // This process is dedicated to LeakCanary for heap analysis.
+      // You should not init your app in this process.
+      return;
+    }
     enabledStrictMode();
     LeakCanary.install(this);
   }
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
index fefe52ff..870f59b1 100644
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
@@ -35,7 +35,7 @@
     });
   }
 
-  private void startAsyncTask() {
+  void startAsyncTask() {
     // This async task is an anonymous class and therefore has a hidden reference to the outer
     // class MainActivity. If the activity gets destroyed before the task finishes (e.g. rotation),
     // the activity instance will leak.
diff --git a/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png
index 099c77d4..65948fa3 100755
Binary files a/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png
index da2453c6..5d826c42 100755
Binary files a/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png
index 35a3ec97..c9c7ec58 100755
Binary files a/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png
index 6b3f35af..cb8a98ab 100755
Binary files a/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png
index 2d77dc1f..3ca3a7f6 100755
Binary files a/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/values/strings.xml b/leakcanary-sample/src/main/res/values/strings.xml
index 1e112cee..9e5bf782 100644
--- a/leakcanary-sample/src/main/res/values/strings.xml
+++ b/leakcanary-sample/src/main/res/values/strings.xml
@@ -20,5 +20,5 @@
   <string name="helper_text">Start the async task, <b>rotate the screen</b> and wait for a bit. A
     wild notification appears.
   </string>
-  <string name="__leak_canary_display_activity_label">Leaks Sample</string>
+  <string name="leak_canary_display_activity_label">Leaks Sample</string>
 </resources>
\ No newline at end of file
diff --git a/leakcanary-watcher/build.gradle b/leakcanary-watcher/build.gradle
index ac0cac77..c7301cab 100644
--- a/leakcanary-watcher/build.gradle
+++ b/leakcanary-watcher/build.gradle
@@ -35,6 +35,12 @@ android {
     minSdkVersion rootProject.ext.minSdkVersion
     targetSdkVersion rootProject.ext.targetSdkVersion
   }
+  dexOptions {
+    javaMaxHeapSize '2048M'
+  }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+  }
 }
 
 task sourceJar(type: Jar) {
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
index 3bc1a45f..ce751576 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
@@ -17,13 +17,10 @@
 
 import java.io.Serializable;
 import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
 import java.util.Map;
-import java.util.Set;
 
 import static com.squareup.leakcanary.Preconditions.checkNotNull;
 import static java.util.Collections.unmodifiableMap;
-import static java.util.Collections.unmodifiableSet;
 
 /**
  * Prevents specific references from being taken into account when computing the shortest strong
@@ -35,75 +32,161 @@
  */
 public final class ExcludedRefs implements Serializable {
 
-  public final Map<String, Set<String>> excludeFieldMap;
-  public final Map<String, Set<String>> excludeStaticFieldMap;
-  public final Set<String> excludedThreads;
+  public static Builder builder() {
+    return new BuilderWithParams();
+  }
+
+  public final Map<String, Map<String, Exclusion>> fieldNameByClassName;
+  public final Map<String, Map<String, Exclusion>> staticFieldNameByClassName;
+  public final Map<String, Exclusion> threadNames;
+  public final Map<String, Exclusion> classNames;
 
-  private ExcludedRefs(Map<String, Set<String>> excludeFieldMap,
-      Map<String, Set<String>> excludeStaticFieldMap, Set<String> excludedThreads) {
-    // Copy + unmodifiable.
-    this.excludeFieldMap = unmodifiableMap(new LinkedHashMap<>(excludeFieldMap));
-    this.excludeStaticFieldMap = unmodifiableMap(new LinkedHashMap<>(excludeStaticFieldMap));
-    this.excludedThreads = unmodifiableSet(new LinkedHashSet<>(excludedThreads));
+  ExcludedRefs(BuilderWithParams builder) {
+    this.fieldNameByClassName = unmodifiableRefStringMap(builder.fieldNameByClassName);
+    this.staticFieldNameByClassName = unmodifiableRefStringMap(builder.staticFieldNameByClassName);
+    this.threadNames = unmodifiableRefMap(builder.threadNames);
+    this.classNames = unmodifiableRefMap(builder.classNames);
+  }
+
+  private Map<String, Map<String, Exclusion>> unmodifiableRefStringMap(
+      Map<String, Map<String, ParamsBuilder>> mapmap) {
+    LinkedHashMap<String, Map<String, Exclusion>> fieldNameByClassName = new LinkedHashMap<>();
+    for (Map.Entry<String, Map<String, ParamsBuilder>> entry : mapmap.entrySet()) {
+      fieldNameByClassName.put(entry.getKey(), unmodifiableRefMap(entry.getValue()));
+    }
+    return unmodifiableMap(fieldNameByClassName);
+  }
+
+  private Map<String, Exclusion> unmodifiableRefMap(Map<String, ParamsBuilder> fieldBuilderMap) {
+    Map<String, Exclusion> fieldMap = new LinkedHashMap<>();
+    for (Map.Entry<String, ParamsBuilder> fieldEntry : fieldBuilderMap.entrySet()) {
+      fieldMap.put(fieldEntry.getKey(), new Exclusion(fieldEntry.getValue()));
+    }
+    return unmodifiableMap(fieldMap);
   }
 
   @Override public String toString() {
     String string = "";
-    for (Map.Entry<String, Set<String>> classes : excludeFieldMap.entrySet()) {
+    for (Map.Entry<String, Map<String, Exclusion>> classes : fieldNameByClassName.entrySet()) {
       String clazz = classes.getKey();
-      for (String field : classes.getValue()) {
-        string += "| Field: " + clazz + "." + field + "\n";
+      for (Map.Entry<String, Exclusion> field : classes.getValue().entrySet()) {
+        String always = field.getValue().alwaysExclude ? " (always)" : "";
+        string += "| Field: " + clazz + "." + field.getKey() + always + "\n";
       }
     }
-    for (Map.Entry<String, Set<String>> classes : excludeStaticFieldMap.entrySet()) {
+    for (Map.Entry<String, Map<String, Exclusion>> classes : staticFieldNameByClassName.entrySet()) {
       String clazz = classes.getKey();
-      for (String field : classes.getValue()) {
-        string += "| Static field: " + clazz + "." + field + "\n";
+      for (Map.Entry<String, Exclusion> field : classes.getValue().entrySet()) {
+        String always = field.getValue().alwaysExclude ? " (always)" : "";
+        string += "| Static field: " + clazz + "." + field.getKey() + always + "\n";
       }
     }
-    for (String thread : excludedThreads) {
-      string += "| Thread:" + thread;
+    for (Map.Entry<String, Exclusion> thread : threadNames.entrySet()) {
+      String always = thread.getValue().alwaysExclude ? " (always)" : "";
+      string += "| Thread:" + thread.getKey() + always + "\n";
+    }
+    for (Map.Entry<String, Exclusion> clazz : classNames.entrySet()) {
+      String always = clazz.getValue().alwaysExclude ? " (always)" : "";
+      string += "| Class:" + clazz.getKey() + always + "\n";
     }
     return string;
   }
 
-  public static final class Builder {
-    private final Map<String, Set<String>> excludeFieldMap = new LinkedHashMap<>();
-    private final Map<String, Set<String>> excludeStaticFieldMap = new LinkedHashMap<>();
-    private final Set<String> excludedThreads = new LinkedHashSet<>();
+  static final class ParamsBuilder {
+    String name;
+    String reason;
+    boolean alwaysExclude;
+    final String matching;
+
+    ParamsBuilder(String matching) {
+      this.matching = matching;
+    }
+  }
+
+  public interface Builder {
+    BuilderWithParams instanceField(String className, String fieldName);
+
+    BuilderWithParams staticField(String className, String fieldName);
+
+    BuilderWithParams thread(String threadName);
+
+    BuilderWithParams clazz(String className);
+
+    ExcludedRefs build();
+  }
+
+  public static final class BuilderWithParams implements Builder {
+
+    private final Map<String, Map<String, ParamsBuilder>> fieldNameByClassName =
+        new LinkedHashMap<>();
+    private final Map<String, Map<String, ParamsBuilder>> staticFieldNameByClassName =
+        new LinkedHashMap<>();
+    private final Map<String, ParamsBuilder> threadNames = new LinkedHashMap<>();
+    private final Map<String, ParamsBuilder> classNames = new LinkedHashMap<>();
+
+    private ParamsBuilder lastParams;
+
+    BuilderWithParams() {
+    }
 
-    public Builder instanceField(String className, String fieldName) {
+    @Override public BuilderWithParams instanceField(String className, String fieldName) {
       checkNotNull(className, "className");
       checkNotNull(fieldName, "fieldName");
-      Set<String> excludedFields = excludeFieldMap.get(className);
+      Map<String, ParamsBuilder> excludedFields = fieldNameByClassName.get(className);
       if (excludedFields == null) {
-        excludedFields = new LinkedHashSet<>();
-        excludeFieldMap.put(className, excludedFields);
+        excludedFields = new LinkedHashMap<>();
+        fieldNameByClassName.put(className, excludedFields);
       }
-      excludedFields.add(fieldName);
+      lastParams = new ParamsBuilder("field " + className + "#" + fieldName);
+      excludedFields.put(fieldName, lastParams);
       return this;
     }
 
-    public Builder staticField(String className, String fieldName) {
+    @Override public BuilderWithParams staticField(String className, String fieldName) {
       checkNotNull(className, "className");
       checkNotNull(fieldName, "fieldName");
-      Set<String> excludedFields = excludeStaticFieldMap.get(className);
+      Map<String, ParamsBuilder> excludedFields = staticFieldNameByClassName.get(className);
       if (excludedFields == null) {
-        excludedFields = new LinkedHashSet<>();
-        excludeStaticFieldMap.put(className, excludedFields);
+        excludedFields = new LinkedHashMap<>();
+        staticFieldNameByClassName.put(className, excludedFields);
       }
-      excludedFields.add(fieldName);
+      lastParams = new ParamsBuilder("static field " + className + "#" + fieldName);
+      excludedFields.put(fieldName, lastParams);
       return this;
     }
 
-    public Builder thread(String threadName) {
+    @Override public BuilderWithParams thread(String threadName) {
       checkNotNull(threadName, "threadName");
-      excludedThreads.add(threadName);
+      lastParams = new ParamsBuilder("any threads named " + threadName);
+      threadNames.put(threadName, lastParams);
+      return this;
+    }
+
+    /** Ignores all fields and static fields of all subclasses of the provided class name. */
+    @Override public BuilderWithParams clazz(String className) {
+      checkNotNull(className, "className");
+      lastParams = new ParamsBuilder("any subclass of " + className);
+      classNames.put(className, lastParams);
+      return this;
+    }
+
+    public BuilderWithParams named(String name) {
+      lastParams.name = name;
+      return this;
+    }
+
+    public BuilderWithParams reason(String reason) {
+      lastParams.reason = reason;
+      return this;
+    }
+
+    public BuilderWithParams alwaysExclude() {
+      lastParams.alwaysExclude = true;
       return this;
     }
 
     public ExcludedRefs build() {
-      return new ExcludedRefs(excludeFieldMap, excludeStaticFieldMap, excludedThreads);
+      return new ExcludedRefs(this);
     }
   }
 }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java
new file mode 100644
index 00000000..4d87d05e
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java
@@ -0,0 +1,17 @@
+package com.squareup.leakcanary;
+
+import java.io.Serializable;
+
+public final class Exclusion implements Serializable {
+  public final String name;
+  public final String reason;
+  public final boolean alwaysExclude;
+  public final String matching;
+
+  Exclusion(ExcludedRefs.ParamsBuilder builder) {
+    this.name = builder.name;
+    this.reason = builder.reason;
+    this.alwaysExclude = builder.alwaysExclude;
+    this.matching = builder.matching;
+  }
+}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
index 2423dc9b..fe88f38e 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
@@ -61,11 +61,4 @@ public HeapDump(File heapDumpFile, String referenceKey, String referenceName,
     this.gcDurationMs = gcDurationMs;
     this.heapDumpDurationMs = heapDumpDurationMs;
   }
-
-  /** Renames the heap dump file and creates a new {@link HeapDump} pointing to it. */
-  public HeapDump renameFile(File newFile) {
-    heapDumpFile.renameTo(newFile);
-    return new HeapDump(newFile, referenceKey, referenceName, excludedRefs, watchDurationMs,
-        gcDurationMs, heapDumpDurationMs);
-  }
 }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
index 7d2b9fc4..5d124535 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
@@ -48,7 +48,7 @@
   }, new HeapDump.Listener() {
     @Override public void analyze(HeapDump heapDump) {
     }
-  }, new ExcludedRefs.Builder().build());
+  }, new ExcludedRefs.BuilderWithParams().build());
 
   private final Executor watchExecutor;
   private final DebuggerControl debuggerControl;
diff --git a/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java b/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
index 421ceea0..15b44def 100644
--- a/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
+++ b/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
@@ -24,7 +24,7 @@
 
 public class RefWatcherTest {
 
-  static final ExcludedRefs NO_REF = new ExcludedRefs.Builder().build();
+  static final ExcludedRefs NO_REF = new ExcludedRefs.BuilderWithParams().build();
 
   static class TestDumper implements HeapDumper {
     boolean called;
@@ -43,7 +43,7 @@
   @SuppressWarnings("FieldCanBeLocal") Object ref;
 
   static class TestExecutor implements Executor {
-    private Runnable command;
+    Runnable command;
 
     @Override public void execute(Runnable command) {
       this.command = command;
