diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 00000000..e4452455
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,23 @@
+language: android
+
+android:
+  components:
+    - build-tools-21.1.2
+    - android-21
+  licenses:
+    - android-sdk-license-5be876d5
+
+jdk:
+  - oraclejdk7
+
+script:
+  - ./gradlew clean build check
+
+notifications:
+  email: false
+
+sudo: false
+
+cache:
+  directories:
+    - $HOME/.gradle
\ No newline at end of file
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 01be9cfd..960268a2 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,95 @@
 # Change Log
 
+## Version 1.4-SNAPSHOT
+
+* Switched to [HAHA 2.0.2](https://github.com/square/haha/blob/master/CHANGELOG.md#version-202-2015-07-20) with uses Perflib instead of MAT under the hood [#219](https://github.com/square/leakcanary/pull/219). This should fix most crashes and improve speed a lot. We can now parse Android M heap dumps, although there are still memory issues (see [#223](https://github.com/square/leakcanary/issues/223)).
+* A status bar notification is displayed when the trace analysis results in an excluded ref leak [#216](https://github.com/square/leakcanary/pull/216).
+* Added ProGuard configuration for debug library [#132](https://github.com/square/leakcanary/issues/132).
+* 2 new ignored Android SDK leaks: [#26](https://github.com/square/leakcanary/issues/26) [#62](https://github.com/square/leakcanary/issues/62).
+* Added excluded leaks to text report [#119](https://github.com/square/leakcanary/issues/119).
+* Added LeakCanary SHA to text report [#120](https://github.com/square/leakcanary/issues/120).
+* Renamed all resources to begin with `leak_canary_` instead of `__leak_canary`[#161](https://github.com/square/leakcanary/pull/161)
+
+### Public API changes
+
+* AnalysisResult.failure is now a `Throwable` instead of an `Exception`. Main goal is to catch and correctly report OOMs while parsing.
+* Added ARRAY_ENTRY to LeakTraceElement.Type for references through array entries.
+* Renamed `ExcludedRefs` fields.
+* Each `ExcludedRef` entry can now be ignored entirely or "kept only if no other path".
+* Added support for ignoring all fields (static and non static) for a given class.
+
+### Dependencies
+
+```gradle
+ dependencies {
+   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.4-SNAPSHOT'
+   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.4-SNAPSHOT'
+ }
+```
+
+Snapshots are available in Sonatype's `snapshots` repository:
+
+```
+  repositories {
+    mavenCentral()
+    maven {
+      url 'https://oss.sonatype.org/content/repositories/snapshots/'
+    }
+  }
+```
+
+[![Build Status](https://travis-ci.org/square/leakcanary.svg?branch=master)](https://travis-ci.org/square/leakcanary)
+
+## Version 1.3.1 *(2015-05-16)*
+
+* Heap dumps and analysis results are now saved on the sd card: [#21](https://github.com/square/leakcanary/issues/21).
+* `ExcludedRef` and `AndroidExcludedRefs` are customizable: [#12](https://github.com/square/leakcanary/issues/12) [#73](https://github.com/square/leakcanary/issues/73).
+* 7 new ignored Android SDK leaks: [#1](https://github.com/square/leakcanary/issues/1) [#4](https://github.com/square/leakcanary/issues/4) [#32](https://github.com/square/leakcanary/issues/32) [#89](https://github.com/square/leakcanary/pull/89) [#82](https://github.com/square/leakcanary/pull/82) [#97](https://github.com/square/leakcanary/pull/97).
+* Fixed 3 crashes in LeakCanary: [#37](https://github.com/square/leakcanary/issues/37) [#46](https://github.com/square/leakcanary/issues/46) [#66](https://github.com/square/leakcanary/issues/66).
+* Fixed StrictMode thread policy violations: [#15](https://github.com/square/leakcanary/issues/15).
+* Updated `minSdkVersion` from `9` to `8`: [#57](https://github.com/square/leakcanary/issues/57).
+* Added LeakCanary version name to `LeakCanary.leakInfo()`: [#49](https://github.com/square/leakcanary/issues/49).
+* `leakcanary-android-no-op` is lighter, it does not depend on `leakcanary-watcher` anymore, only 2 classes now: [#74](https://github.com/square/leakcanary/issues/74).
+* Adding field state details to the text leak trace.
+* A Toast is displayed while the heap dump is in progress to warn that the UI will freeze: [#20](https://github.com/square/leakcanary/issues/49). You can customize the toast by providing your own layout named `__leak_canary_heap_dump_toast.xml` (e.g. you could make it an empty layout).
+* If the analysis fails, the result and heap dump are kept so that it can be reported to LeakCanary: [#102](https://github.com/square/leakcanary/issues/102).
+* Update to HAHA 1.3 to fix a 2 crashes [#3](https://github.com/square/leakcanary/issues/3) [46](https://github.com/square/leakcanary/issues/46)
+
+### Public API changes
+
+* When upgrading from 1.3 to 1.3.1, previously saved heap dumps will not be readable any more, but they won't be removed from the app directory. You should probably uninstall your app.
+* Added `android.permission.WRITE_EXTERNAL_STORAGE` to `leakcanary-android` artifact.
+* `LeakCanary.androidWatcher()` parameter types have changed (+ExcludedRefs).
+* `LeakCanary.leakInfo()` parameter types have changed (+boolean)
+* `ExcludedRef` is now serializable and immutable, instances can be created using `ExcludedRef.Builder`.
+* `ExcludedRef` is available in `HeapDump`
+* `AndroidExcludedRefs` is an enum, you can now pick the leaks you want to ignore in `AndroidExcludedRefs` by creating an `EnumSet` and calling `AndroidExcludedRefs.createBuilder()`.
+* `AndroidExcludedRefs.createAppDefaults()` & `AndroidExcludedRefs.createAndroidDefaults()` return a `ExcludedRef.Builder`.
+* `ExcludedRef` moved from `leakcanary-analyzer` to `leakcanary-watcher`
+
+### Dependencies
+
+```gradle
+ dependencies {
+   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3.1'
+   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.1'
+ }
+```
+
+### Statistics
+
+* 33 commits to the LeakCanary library code and 11 commits to [HAHA](https://github.com/square/haha).
+* 6 contributors: [Pierre-Yves Ricau](https://github.com/square/leakcanary/commits?author=pyricau), [Sergey Shulepov](https://github.com/square/leakcanary/commits?author=pepyakin), [Romain Guy](https://github.com/square/leakcanary/commits?author=romainguy), [liaohuqiu](https://github.com/square/leakcanary/commits?author=liaohuqiu), [Dario Marcato](https://github.com/square/leakcanary/commits?author=dmarcato), [Anders Aagaard](https://github.com/square/leakcanary/commits?author=andaag).
+
 ## Version 1.3 *(2015-05-08)*
 
-Initial release.
\ No newline at end of file
+Initial release.
+
+### Dependencies
+
+```gradle
+ dependencies {
+   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3'
+   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3'
+ }
+```
diff --git a/README.md b/README.md
index 4dd91d93..e5be50c6 100644
--- a/README.md
+++ b/README.md
@@ -12,8 +12,8 @@ In your `build.gradle`:
 
 ```gradle
  dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3'
-   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3'
+   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3.1'
+   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.1'
  }
 ```
 
@@ -81,7 +81,7 @@ public abstract class BaseFragment extends Fragment {
 
 ## How does it work?
 
-1. `RefWatcher.watch()` creates a [KeyedWeakReference](https://github.com/square/leakcanary/blob/master/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java) to the watched object.
+1. `RefWatcher.watch()` creates a [KeyedWeakReference](https://github.com/square/leakcanary/blob/master/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java) to the watched object.
 2. Later, in a background thread, it checks if the reference has been cleared and if not it triggers a GC.
 3. If the reference is still not cleared, it then dumps the heap into a `.hprof` file stored on the app file system.
 4. `HeapAnalyzerService` is started in a separate process and `HeapAnalyzer` parses the heap dump using [HAHA](https://github.com/square/haha).
@@ -107,13 +107,24 @@ In com.example.leakcanary:1.0:1 com.example.leakcanary.MainActivity has leaked:
 
 You can also share the leak trace and the heap dump file from the **action bar menu**.
 
-## My leak is caused by the SDK implementation!
+## How do I fix a memory leak?
 
-There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: [AndroidExcludedRefs.java](https://github.com/square/leakcanary/blob/master/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java). If you find a new one, please [create an issue](https://github.com/square/leakcanary/issues/new) with the leak trace, the reference key, the device and the Android version. It's even better if you provide a link to a heap dump file.
+Once you have the leak trace, figure out which reference in the path should not exist. Then figure out why that reference still exists. Often times it's a registered listener that should have been unregistered, a `close()` method that wasn't called, an anonymous class that holds a reference an outer class. If you cannot figure out an issue in your code, **please do not file an issue**. Instead, create a [Stack Overflow question](http://stackoverflow.com/questions/tagged/leakcanary) (using the *leakcanary* tag).
 
-This is especially important for **new releases of Android**. You have the opportunity to help detect new memory leaks early on, which could benefit the entire Android community. 
+## My leak is caused by the Android SDK implementation!
 
-Snapshots of the development version are available in [Sonatype's `snapshots` repository](https://oss.sonatype.org/content/repositories/snapshots/).
+There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: [AndroidExcludedRefs.java](https://github.com/square/leakcanary/blob/master/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java).
+
+If you find a new one, please [create an issue](https://github.com/square/leakcanary/issues/new) and follow these steps:
+
+1. Provide the entire leak trace information (reference key, device, etc).
+2. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions [android/platform_frameworks_base](https://github.com/android/platform_frameworks_base).
+3. Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed.
+4. If it's still happening, build a simple repro case
+5. File an issue on [b.android.com](http://b.android.com) with the leak trace and the repro case
+6. Create a PR in LeakCanary to update `AndroidExcludedRefs.java`. Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
+
+This is especially important for **new releases of Android**. You have the opportunity to help detect new memory leaks early on, which benefits the entire Android community. 
 
 ## Beyond the leak trace
 
@@ -127,6 +138,47 @@ Sometimes the leak trace isn't enough and you need to dig into the heap dump wit
 
 ## Customizing
 
+### Customizing and using the no-op dependency
+
+The `leakcanary-android-no-op` dependency for release builds only contains the `LeakCanary` and `RefWatcher` class. If you start customizing LeakCanary, you need to make sure that the customization happens only in debug build, since it will likely reference classes that do not exist in the `leakcanary-android-no-op` dependency.
+
+Let's say your release build declares an `ExampleApplication` class in `AndroidManifest.xml`, and your debug build declares a `DebugExampleApplication` that extends `ExampleApplication`.
+
+In your shared sources:
+
+```java
+public class ExampleApplication extends Application {
+
+  public static RefWatcher getRefWatcher(Context context) {
+    ExampleApplication application = (ExampleApplication) context.getApplicationContext();
+    return application.refWatcher;
+  }
+
+  private RefWatcher refWatcher;
+
+  @Override public void onCreate() {
+    super.onCreate();
+    refWatcher = installLeakCanary();
+  }
+
+  protected RefWatcher installLeakCanary() {
+    return RefWatcher.DISABLED;
+  }
+}
+```
+
+In your debug sources:
+
+```java
+public class DebugExampleApplication extends ExampleApplication {
+  protected RefWatcher installLeakCanary() {
+	RefWatcher refWatcher = ? // Build a customized RefWatcher
+    return refWatcher;
+  }
+}
+```
+That way, your release code will contain no reference to LeakCanary other than the two empty classes that exist in the `leakcanary-android-no-op` dependency.
+
 ### Icon and label
 
 `DisplayLeakActivity` comes with a default icon and label, which you can change by providing `R.drawable.__leak_canary_icon` and `R.string.__leak_canary_display_activity_label` in your app:
@@ -167,10 +219,10 @@ res/
 
 You can change the default behavior to upload the leak trace and heap dump to a server of your choosing.
 
-Create your own `AbstractAnalysisResultService`. The easiest way is to extend `DefaultAnalysisResultService` in your debug sources:
+Create your own `AbstractAnalysisResultService`. The easiest way is to extend `DisplayLeakService` in your debug sources:
 
 ```java
-public class LeakUploadService extends DefaultAnalysisResultService {
+public class LeakUploadService extends DisplayLeakService {
   @Override protected void afterDefaultHandling(HeapDump heapDump, AnalysisResult result, String leakInfo) {
     if (!result.leakFound || result.excludedLeak) {
       return;
@@ -180,40 +232,17 @@ public class LeakUploadService extends DefaultAnalysisResultService {
 }
 ```
 
-Make sure the release Application class uses the disabled `RefWatcher`:
-
-```java
-public class ExampleApplication extends Application {
-
-  public static RefWatcher getRefWatcher(Context context) {
-    ExampleApplication application = (ExampleApplication) context.getApplicationContext();
-    return application.refWatcher;
-  }
-
-  private RefWatcher refWatcher;
-
-  @Override public void onCreate() {
-    super.onCreate();
-    refWatcher = installLeakCanary();
-  }
-  
-  protected RefWatcher installLeakCanary() {
-    return RefWatcher.DISABLED;
-  }
-}
-```
-
 Build a custom `RefWatcher` in your debug Application class:
 
 ```java
 public class DebugExampleApplication extends ExampleApplication {
   protected RefWatcher installLeakCanary() {
-    return LeakCanary.install(app, LeakUploadService.class);
+    return LeakCanary.install(app, LeakUploadService.class, AndroidExcludedRefs.createAppDefaults().build());
   }
 }
 ```
 
-Don't forget to register the service in your debug manifest:
+Don't forget to register the service in your debug `AndroidManifest.xml`:
 
 ```xml
 <?xml version="1.0" encoding="utf-8"?>
@@ -226,8 +255,89 @@ Don't forget to register the service in your debug manifest:
 </manifest>
 ```
 
+You can also upload the leak traces to Slack or HipChat, [here's an example](https://gist.github.com/pyricau/06c2c486d24f5f85f7f0).
+
+### Ignoring specific references
+
+You can create your own version of `ExcludedRefs` to ignore specific references that you know are causing leaks but you still want to ignore:
+
+```java
+public class DebugExampleApplication extends ExampleApplication {
+  protected RefWatcher installLeakCanary() {
+    ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults()
+        .instanceField("com.example.ExampleClass", "exampleField")
+        .build();
+    return LeakCanary.install(this, DisplayLeakService.class, excludedRefs);
+  }
+}
+```
+
+### Not watching specific activity classes
+
+`ActivityRefWatcher` is installed by default and watches all activities. You can customize the installation steps to use something different instead:
+
+```java
+public class DebugExampleApplication extends ExampleApplication {
+  protected RefWatcher installLeakCanary() {
+    if (isInAnalyzerProcess(this)) {
+      return RefWatcher.DISABLED;
+    } else {
+      ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults().build();
+      enableDisplayLeakActivity(application);
+      ServiceHeapDumpListener heapDumpListener = new ServiceHeapDumpListener(application, DisplayLeakService.class);
+      final RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);
+      registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() {
+        public void onActivityDestroyed(Activity activity) {
+          if (activity instanceof ThirdPartyActivity) {
+              return;
+          }
+          refWatcher.watch(activity);
+        }
+        // ...
+      });
+      return refWatcher;
+    }
+  }
+}
+```
+
+### ProGuard
+
+If you use Proguard in your debug builds, make sure to keep the HAHA and LeakCanary classes:
+
+```
+# LeakCanary
+-keep class org.eclipse.mat.** { *; }
+-keep class com.squareup.leakcanary.** { *; }
+```
+
+## Snapshots of the development version
+
+See the [CHANGELOG](https://github.com/square/leakcanary/blob/master/CHANGELOG.md).
+
+## Troubleshooting
+
+* if `leakcanary-android` is not in the list of external libraries in Android Studio, but `leakcanary-analyzer` and `leakcanary-watcher` are there: try doing a `Clean Build`. If it's still a problem, try building from the command line.
+* `error: package com.squareup.leakcanary does not exist`: if you have other build types than `debug` and `release`, you need to add a specific dependency for those too (`xxxCompile`).
+
+## Resources
+
+* LeakCanary: Detect all memory leaks! [squ.re/leakcanary](http://squ.re/leakcanary).
+* Wrangling Dalvik series: [Memory management in Android](http://www.raizlabs.com/dev/2014/03/wrangling-dalvik-memory-management-in-android-part-1-of-2/).
+* Uploading leak traces to a [Slack or HipChat channel](https://gist.github.com/pyricau/06c2c486d24f5f85f7f0).
+* Dump the heap on [OutOfMemoryError crashes](https://gist.github.com/pyricau/4726389fd64f3b7c6f32).
+* StackOverflow: [leakcanary tag](http://stackoverflow.com/questions/tagged/leakcanary).
+
+### Translations
+
+* squ.re/leakcanary [in Chinese](http://www.liaohuqiu.net/cn/posts/leak-canary/).
+* squ.re/leakcanary [in Russian](http://habrahabr.ru/post/257633/).
+* `README.md` in Chinese: [中文版说明](http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/).
+
 ![icon_512.png](assets/icon_512.png)
 
+The name **LeakCanary** is a reference to the expression [canary in a coal mine](http://en.wiktionary.org/wiki/canary_in_a_coal_mine), because LeakCanary is a sentinel used to detect risks by providing advance warning of a danger. Props to [@edenman](https://github.com/edenman) for suggesting it!
+
 ## License
 
     Copyright 2015 Square, Inc.
diff --git a/assets/icon_1024.png b/assets/icon_1024.png
new file mode 100644
index 00000000..5dfdcf84
Binary files /dev/null and b/assets/icon_1024.png differ
diff --git a/assets/icon_512.png b/assets/icon_512.png
old mode 100755
new mode 100644
index 44caf54d..bb24dbad
Binary files a/assets/icon_512.png and b/assets/icon_512.png differ
diff --git a/assets/screenshot.png b/assets/screenshot.png
index dab89476..f68053b6 100644
Binary files a/assets/screenshot.png and b/assets/screenshot.png differ
diff --git a/assets/source_icon.png b/assets/source_icon.png
index 0bfbd9ec..827e5552 100644
Binary files a/assets/source_icon.png and b/assets/source_icon.png differ
diff --git a/assets/vector_icon.afdesign b/assets/vector_icon.afdesign
new file mode 100644
index 00000000..a30fcf97
Binary files /dev/null and b/assets/vector_icon.afdesign differ
diff --git a/assets/vector_icon.svg b/assets/vector_icon.svg
new file mode 100644
index 00000000..9a17f0dc
--- /dev/null
+++ b/assets/vector_icon.svg
@@ -0,0 +1,6 @@
+<?xml version="1.0" standalone="no"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg width="100%" height="100%" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421;">
+    <image id="Container" x="33" y="44" width="443px" height="441px" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbsAAAG5CAYAAAAXoZoVAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAcMklEQVR4nO3dT4gkZ/nA8Wd6Zmc3mw1ZXEmCfxJCfgZJMDEHwaiRmEsQEolBAkET0Jw96CEXQQRFDyKePOXgIRhFBFFEzCFBEzRIFj0kIaJBCQZB8mezJG522Z3q38Gttqamqrq6u7q76u3PB4bu6Z3p6V525rvPW2/1bI3H4wCAlO2s+wF0YazYAEu1tbW1te7HsIitvnZi1oD19XkADF3bzvU5iL2KXVPg+vQ4Afivur71LXxrjd08cZv1dgDm0xCymT9v3fFbS+zqIld1c/E2oQNYraZGFf+sbRjXFb2Vxq4cuVnill+f9jkAdKdmSqv98/z9utsL7680eiuJ3bTINUWtTfAEEGBxbaazadfrLuu+xqqit9TYtY1c02Xx+iuvvBJ///vf44033ojXX39939upU6fi/PnzS3suAJvm6NGj8a53vStOnDhx4O2GG26Iyy67bF/UpgVvykS41OgtLXbF0LWJXPn6eDyOLMvixRdfjD/84Q/xzDPPxCuvvLKUxwrAbLa3t+PGG2+MW2+9NT7+8Y/HVVddVRu+ttFbZvCWEru60E2LW/7+yZMn46mnnoo//vGPcerUqc4fHwDduvbaa+NjH/tY3HHHHfH+97//QOzaRm9Zwes8dk2hqwpc8e2FF16IRx55JF588cVOHxMAqzEajeLOO++MBx54IE6cOHEgdnVTX/5+4Xqn0es0dnnoZo3cyy+/HD/84Q/jmWee6eyxALA+hw8fjnvvvTfuu+++OHr0aG30Wmxo6SR6ncWuKXTF4GVZNnn/9ddfj0cffTQef/zxyLKsk8cBQH9cfvnlcf/998fdd98dOzs7MRqN1jLldRK7cuiaJrk8di+88EJ885vfjDfffHPhrw9Av910003xta99LS6//PLK4LU4prdQ8BaOXVXoyteL01yWZfH444/HD37wA6cKAGyQq666Kr7xjW/ENddcsy94xesR1Ts4L16fO3gLxa4pdOXAjcfjuHDhQjzyyCPxi1/8Yu6vCcBwXXLJJfHwww/HRz/60QOhy9+P6D54c8euLnRVy5ZZlsXbb78d3/nOd+JPf/rTXF8PgDSMRqN48MEH47777psErjzpRXQbvLli1yZ0eeTG43GcPXs2Hn744fjb3/4289cCIE33339/fOELX5jEboZjeTPHbjTrJ0wLXR65/G1vby++//3vCx0A+/zkJz+Jp59+el8zql5opGLz48xT2kyxaxO6cvB++tOfxlNPPTXr4wIgcePxeDIMlQelvCX5x5WDN6vWsWuz67IYur29vXjmmWfi0UcfneuBAZC+c+fOxbe+9a14/fXXY29v78B0V3cO9qzT3czLmGVV01yWZfGPf/wjvve9781dYQA2w2uvvRbf/va349y5c5PglaO36HJmq9i13XmZR+/8+fPx3e9+N86ePTvjUwZgE/3lL3+Jxx57rHI5s4vgzbKMObms25Syt7cXe3t78cQTT8Q///nPmZ8sAJvrV7/6Vbz66qv7pru6jSuzmhq7umpWLV1mWRZnz56Nxx57bK4HA8DmOnfuXPz4xz9unOwiKl+acmoBG2NXt3xZdQAxn+x++ctfxhtvvLHI8wVgQz355JPx8ssvVwYvovp3oLZRG7um43TF94uhO336dPz85z9f4GkCsMmyLItHH320cikzD1+VadPdPCeVVz6ALMviZz/7WZw5c2bWuwSAiZMnT8YLL7xQu5xZNe1N03Y3Zu3GlPzy3Llz8cQTTyz2DAEgIn7zm9/UblKJ2H+ud65pupt2zO7A+3U7MZ977rl455135n5iAJD785//HOfOnTvwiirTNqvUqYxdsY5NU13x7dlnn+3sSQKw2c6cORPPP//8zKcf1E13TRtUDrxftwPzwoULcfLkyXmfEwAc8Oyzzx54RZWmE82bHIhduYrTjtVlWRYvvfRSnDp1qsOnCMCmO3ny5NRXVClqOu+u1TE7S5gArNqpU6fipZdeqvxtCAtNduVz66quF79I/sWff/75zp4cAOSee+65A92JmP3k8rkmu/JS5muvvdbFcwKAfV577bXaya5K3e1TN6hM24l54cKFePvttzt4SgCw36lTpxo3pjQcv9t3Q9UGlcovWBe9U6dO1f5yPQBYxOnTpw9siqwLXdNS5iR2bXZhVk13dmECsCz5QDXvKQe5upPKay/L46TYAbAsp0+frvzt5RHVQ1l+e1mb32d34LI42fl1PgAsS/4bdeZZuiyuWJZPPaj7hNr10rfeemumURIA2sjbknemKXjT4je6+IeVx+uK18vn2816jgMAzKrq/O7OjtkVv0j5/brz7QCgK3UDVvH9qo+r0+qYXdOOTABYhmLQyptT8tvbrjI2nlRe9UnlOy4Gz4QHQNfqdl+2+Zxcq5PKpx0QBIBlatpL0mZH5kynHtSdhgAAy9IUtrYNmhq7ui8qdACsUlN7Fj6pvOmLAsCyNZ0C19bUUw+6GB8BoAvzrio2vjZm1W2WLwFYpabuzH3MziuiANB3bU8mzxV/xU/ndw4AXVnkUNpcG1SEDoB1mLc/c+/GXOSLAsAsFu1NqxeCFjUA1qWLMwFaT3ZVr54CAKuySHcWWsYEgCEQOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTO4ABGI/H634IgyZ2AAMwHo8jy7J1P4zBEjuAARG8+YgdwMAI3uzEDqDnqo7XCd5sxA5goASvPbED6LmmnZiC147YAQyc4E0ndgA91vb8OsFrJnYAiRC8emIHkJAsy7zaSgWxA+ixecI1Ho8Fr0TsABIkePuJHUBPLRorwfsfsQNImOD9l9gB9FRXkRI8sQPYCJsePLED2BCbHDyxA+ihZUVpU4MndgAbZhODJ3YAPbTsGG1a8MQOYENtUvDEDqBnVhmgTQme2AFsuE0IntgB9Mw6wpN68MQOgIhIO3hiB8BEqsETO4Ae6UNoUgye2AFwQGrBEzsAKo3H48iybN0PoxNiB9AjfZymUgie2AEw1dCDJ3YAPdHHqa5oyMETOwBaG2rwxA6AmQwxeGIH0BN9X8YsGlrwxA6AuQwpeGIHwNyGEjyxA+iBIS1hlg0heGIHwML6HjyxA+iBIU92uT4HT+wA6Exfgyd2AHQqy7LeTapiB7BmfQtDF/r2K4LEDoCl6FPwxA6ApelL8MQOYM36EINl6kPwxA6ApVt38MQOYI3WPfGs0jqDJ3YArMy6gid2AKzUOoIndgBrtEnLmEWrDp7YAbAWqwye2AGwNqsKntgBrMmmLmGWrSJ4YgfA2i07eGIHsCYmu/2WGbydpdwrAMxB7ADYCMsInmVMgDWwhNms6yVNkx0AvZTHrovomewA6K3xeBx7e3sL34/YAayBZczVEjsAkid2ACRP7ABWzBLm6okdAMkTOwCSJ3YAK2YZc/XEDoDkiR3ACpnq1kPsAEie2AGQPLEDWCHLmOshdgAkT+wASJ7YAayIJcz1ETsAkid2ACRP7ABWxDLm+ogdAMkTO4AVMNWtl9gBkDyxAyB5YgewApYx10vsAEie2AGQPLEDWDJLmOsndgAkT+wASJ7YASyZZcz1EzsAkid2ACRP7ACWyBJmP4gdAMkTO4AlMtn1g9gBkDyxAyB5YgewJJYw+0PsAEie2AGQPLEDWBLLmP0hdgAkT+wASJ7YASyBJcx+ETsAkid2AEtgsusXsQMgeWIH0DFTXf+IHQDJEzsAkid2AB2zjNk/YgdA8sQOoEOmun4SOwCSJ3YAJE/sADpkGbOfxA6A5IkdQEdMdf0ldgAkT+wASJ7YAXTEMmZ/iR0AyRM7gA6Y6vpN7ABIntgBkDyxA+iAZcx+EzsAkid2AAsy1fWf2AGQPLEDWJDJrv/EDoDkiR3AAkx1wyB2ACRP7AAWYLIbBrEDIHliBzAnU91wiB0AyRM7gDmZ7IZD7ABIntgBzMFUNyxiB0DyxA5gDia7YRE7AJIndgAkT+wAZmQJc3jEDoDkiR3AjEx2wyN2ACRP7ABmYKobJrEDIHliBzADk90wiR0AyRM7gJZMdcMldgAtid1wiR0AyRM7gBZMdcMmdgAkT+wAWjDZDZvYAUwhdMMndgAkT+wApjDZDZ/YATQQujSIHQDJEzuABia7NIgdAMkTO4Aaprp0iB1ADbFLh9gBkDyxA6hgqkuL2AGQPLEDqGCyS4vYAZQIXXrEDoDkiR1AickuPWIHUCB0aRI7AJIndgAFJrs0iR3ARUKXLrEDuEjs0iV2ACRP7ADCVJc6sQMIsUud2AEbT+jSJ3YAJE/sgI1nskuf2AEbTeg2g9gBG03sNoPYARtL6DaH2AGQPLEDNpbJbnOIHbCRhG6ziB2wkcRus4gdsHGEbvOIHbBxxG7ziB2wUYRuM4kdsFHEbjOJHbAxhG5ziR2wMcRuc4kdsBGEbrOJHbARxG6ziR2QPKFD7ABIntgByTPZIXZA0oSOCLEDEid2RIgdkLAsy9b9EOgJsQOSZKKjSOyAJIkdRWIHJEfoKBM7IDliR5nYAUkROqqIHZCM8XgsdlQSOyAZQkcdsQOSIHQ0ETsgCWJHE7EDBs8rpTCN2AGDZqKjDbEDBk3saEPsgMGyfElbYgcMkomOWYgdMEhixyzEDhgcy5fMSuyAQTHRMQ+xAwbDa18yL7EDBkPomJfYAYPgOB2LEDug94SORYkd0GuWLumC2AG9ZUMKXRE7oJeEji6JHdBLQkeXxA7oHRtS6JrYAb0idCyD2AG9IXQsi9gBvSB0LJPYAWsndCyb2AFrJXSsgtgBayN0rMrOuh8AsHmcMM6qmeyAlRI61kHsgJUROtbFMiawEo7PsU4mO2DphI51M9kBS2PZkr4w2QFLIXT0ickO6JTI0UcmO6AzQkdfmeyAhYkcfSd2wELstGQIxA6Yi2mOIRE7YCYixxCJHdCKyDFkYgc0EjlSIHasXJZlsbW1FRExuaR/RI6UiB0rNxqNJjv48h+m4tcfIkeKxI612Nra2vcDNb9ejJ/wrY7AkTqxYy3ykNX9gC3+8DX1LUf5PxiQMrFjbaYFL1c19ZXvg/ZMcWwisWOt2gavqGr5UwDrmeBA7OiBeYJXJoD/I25wkNjRC10Er2xaAKveH5qq5wgcJHb0xjKCV1a+7/L7fYzhtMcMTCd29Er5lIRVaxuWZUZQzKB7YkfvFE867ytBgmHxm8rppdHIP02gO36i0FuCB3TFTxN6TfCALvhJQu/1YUckMGxiR+95UWhgUWLHIAgesAixYzAED5iX2DEoggfMQ+wYHMEDZiV2DJLYAbMQOwbLOXhAW35aMGiCB7ThJwWDJ3jANH5KkATBgzR19RtGOvkJMR6P/coT1k7wgDoL/3QQOfrELk1ITxedETuS4hw8SEfely6+p2f+TeX5F80vd3d3DwTPDxvWKf/35z9iMEzlQ2NHjx5d+D4bJ7titOoCdvz48YUfBHTNhAdpGI/HnXSm1TJm0w+N48eP26BCLwkeDN9oNIqdnf8uQi7y/bzQMbutra1J7CIsG9E/ggfDlA9R29vbB76H5/menil25eN1Ef9bxiwGT/ToE7GD4Sg2ZDwex+7ubkQs/n0892SXf+FDhw7FkSNHRI5ecw4eDEfek/F4HIcPH+7kPg/8BKia3qY5duxYZFkmePSa4EH/Fae6LMv27cRc5LDE5Lu/audl8Y7z6+UvtrW1FVdfffXkgRWLDH0jeNBfeTeyLJv05IMf/GDtx88Svrl3Yxajd8stt+yLnNDRZ4IH/VXuyJ133lk7jJVvazLzd33VtHfjjTfGzs7OvhoLHn1m0wr0S3lgyrIsLrvssrjkkksioj5ubb+Xp8auakmzfPvu7m584AMfOPBgBY++ckoC9E+5HzfccMOBASs36/fwzMuYdcfxbr755kmNTXcMgeBBP5Qnurwhd9111+Rj6vaNlP88v14208uFFd8fjUb73r/lllsiIg7ETvDoM8GDfijH7vDhw3HixInGwEV0sIzZtD5anuxGo1EcO3Ysrr/++skDNd0xFIIH61McjPb29ib9+NCHPhQRBye6qgmvaQPL1sUrtefZVX3itLd77rknIv473eUPWvAYAsGD9SlOdFmWxWg0igcffHCygjjtFLj8z5qMLn5Q5Ue1CV3xwVx99dVx880373vQgsdQCB6sVnnpMn+7/fbbY2dnp7Y1uaYJr2zfZFd3MnnVHRe/8Gg0mrz/2c9+Nkaj0b7pLg8e9J3YwWqUQ5f34vDhw3HvvfdWtqZpKXOa1rsxq0JXFbwTJ07ErbfeeuAJmO4YCiedw/IVY1fsxF133XVgiKoL3iym7sactpRZfkCj0SjuuuuuOHLkyIHgmfAYCsGD5akKXZZlcezYsbj99ttbha7NZpWi4mtjbhWuR/F6U+TKoct3Zt5zzz2T3TX5m+AxJIIH3SsvXeZvEREPPfTQvpZU9WWWwBW71njqQd0xvKoHUH679dZb47bbbjvwhCxpMiSCB92pCl3ehM985jNx3XXX1TalzUTXFL+ppx7s++DSMbppwbvnnnvi+uuvPzDhFZ8g9J1NK7C4uokuy7L48Ic/HJ/61Kcae1IVvogOTyov17NqU8r29nZsb2/vu769vR07OzvxxS9+Md797ndXPkHBYwickgDzq9p1WezAlVdeGQ888EBlT+qO3eUrLrMEr3zqwVbp/amnGxTfqh7kJZdcEg899NBkw8re3l5cuHBB9BgUwYPZTQvdkSNH4itf+cq+IanclLrJru6E81y5Z5WTXdU3dfmYXV3sytPdaDSKK664Ir70pS/FpZdeOnmiefAuXLjgtTQZBMGD9so7Li9cuDB5y0P31a9+NXZ3d/c1o9yPcgSrljDLmyqrtHoh6KolzDbLmMW3a6+9Nr785S/HVVdddWDCK056gkefCR40K09yxcjlP+OvuOKK+PrXvx4nTpyobUbdcmbVSmPE9KXMrXJYxhdvyG+vezmX4oSWv50/f37fW/G2/Pq5c+fiRz/6Ubz44osHgrnoAUhYFf8pg/9p04v89ptuuik+//nPx87OTuzs7MShQ4cml8W34m07OzuTfSBVS5s1097+w3JV37DF4FX9nqHiiYDF2FXFrer63t5ePP744/G73/0uxuNx662mxScC6yZ4bLJi4PLL/JBU3YuJfPrTn45PfvKTk9CVg1YVu/zjyhNf1QnnEZPVlwOh2Jn2hOpOMB+NRvtCtb29HVmWxfb29r44lq/n7rzzznjPe94Tv/71r+PNN9+cfEzTQUjRo2/KsVvVv0uRZV2qIlc1zRV//h87dizuv//+uO666/aFrhixqqDVDUER1b8Boen7r3Kyu/gExuUn07SzpmrCq7osr9+eP38+fv/738fTTz8dZ86cqTwmWF6jLT4p0WPdsiw7cNss/y6FiyGoi1x5oitGbnd3N+6444647bbb9gWtagmzPMnVLV/WTXVNOzEjpsSu6olVjal1wSsvX1a95Z979uzZePLJJ+PZZ5+N8+fP5w+41XQnfKxbVfBg6MqBy69PexuNRvGRj3wk7r777srzr8tBqwpeOY7FvR1NG1SqQhfRInZ1T65us0rTlNcUu/x+Tp8+Hb/97W/jr3/9a5w+fbr2pWBm2XIKq2BCY+hq9nBMvcyv7+7uxv/93//F5z73uX2nFIxGowNTXTl2VaErLm222c9RF7qIhthdfBKV013T7sxi7PLrdbErfnz5tdKyLIt//etf8dxzz8VLL70Ur776aozH48a4iR3rZsIjReXJLre1tRWXXnppXHfddfGJT3wirrzyysoXGilPdfn1cuzKf15cuqyLXf44Ll7WRqBxg8rW1tbWeDweb21tVYam+CK5xSBub2/vu738ufnnFx9slmWT9/PYve9974v3vve9kWVZvPnmm/H888/Hv//97/jPf/4Tb7/9dpw5cybeeeedyStmQx+Y8PzHMzWHDh2Ko0ePxtGjR+PYsWNx2WWXxTXXXBM33HBDHDp0qPbFRupiV/fWZnPKvJsVGye7iNmWM8sTXtWUV/V+eSmz/Mv8ipcR//vfc/7Q3nrrrTh9+vTkXI6K59DqLwO6UPXvcJYf/rMszYsKXakaSI4cORLHjx+P3d3dykNJxWNnTS8fWXUMrs2uzGmxm7YppWjqqQfT/kKK013bzys/2PyJ7O3t7bssb2HNL/OvmQf3+PHjcfnll0/uX9wAFtO0EXBa7KpeVaspeMWPaTPRVYR56v/62pxnt5VPd1XLmfn7VUuadX9xTX9J+bl2VedrlF9Dc9qBUwBmV7cBsOqt/HO8OJHl8aqb3KpCV/U6mFN247da3mg12TUFLw9T/mfTJr3yX9CisWsKnegBtFe3hF6MTP4zvnwKQNMSZjl4dUuW5dAVL2seb+t1/NbLmMXglZUjVfXAmv5XUPwL2tvbm1xWnYnfdrorEj2AZlXdqDtOV/czfNpSZtUUV7fjsuo8ulk3pRTNdMyubndmfhwtD115a+rW1lbs7e21Cl1+P/nLj9UFL/+65ejltxeJHUCzqg0q+WXT8bq6ya4ueOX4lT+nvPJXt3w5q5k3qBT/IuqCF1G9caX8wIuvhZmHLo9c+UVEy8ErT3WWMQEWN+/xuvyyKmDTLquWLqeFbpYlzIj5dmNuRfz3lIS2wav7i8oDVjxel7+VJ7umY3Y2qAB0p2ITyIHrdfsuqia8umXKNrsuuwhdxAKTXfEvpSp4VRGqi13dppSqJcy6pczi15nyqjCLPmWAQZvWirbTXdMmlbZvVeEsfr2KxzHXOubUk8qnqXpJsfyyHKaqKa0pblWhm2eDSuGxLvRcAVIxa/CmLWVWxW7abVX3Ufxa5cc5b+giOpjsCg+i8mXBImIy6eVPKP+44kuEFSe7cgyrohlxcKqzMQVgfk2bVPLLWSa8utvaHpvrKnQR3Sxj7juGd/H6gfG3ahorhq94vK9qils0dMIHUK0ucsXrs054VZfFZcqmaa7iMSz8unidTXZFVcfxqp5EHqliDIvBKx77swuTFJT/bXbwPQxLUTdl1U1jVZNa06aTVYYuooNjdmXjwh2WA1QVqbpz5preive9yPKlKAKbpm07Zpnuqm6bthu/+Gd1j62r0EUsIXYR9cHL36+bzOomt2nTXNVzEDKA+bQ5dpdfNgWv7rbi7VVfs8vITe5zWVEYV9xx06RXvK3NRDht96XYAcynqjU1m0Yqp7Sm61X3Ubi+tHX9pcUuV45e06TX9v3y/diMAtCtWTetlC+bPr7mPpd6AHvpscu1mfTa3NZ0e9X9AjC7pumu6s/nCVzhtqXv1FpZ7HJtJr26P2vz523+DICD2jRnWvCabq+4r5VtR1557HLTJr2m29s8ZrEDmM0s7ZkWtKb7WmXkJl9z3VGoil7hz5o+b9r9zv+gADbQtAbNOvkVblv7CaVrj13ZvPEDYHVahm/tkcv1LnZlTfEDoD/6FLey3seujggCrFafYzbNYGMHAG39P8QjHPIeCPK8AAAAAElFTkSuQmCC"/>
+    <path id="Canary Badge" d="M112.189,145.49L254.837,81.3501L396.288,145.49C396.288,145.49 396.862,207.984 396.288,231.803C400.997,350.37 312.745,416.946 254.837,430.897C196.973,416.761 109.794,350.592 112.189,231.803C112.756,203.667 112.189,145.49 112.189,145.49ZM175.089,342.14C175.089,342.14 184.466,327.557 200.474,320.28C204.922,315.034 207.831,307.409 215.292,300.115C219.468,296.033 226.552,291.174 233.166,288.656C239.785,286.137 247.648,284.843 255,285C262.352,285.157 268.152,286.319 277.281,289.599C300.356,298.133 328.246,333.945 334.028,349.404C315.038,361.253 296.986,374.343 277.281,397.842C273.2,395.993 262.831,392.31 245.929,394.232C225.332,398.578 205.605,369.407 206.507,353.455C194.408,348.947 175.089,342.14 175.089,342.14ZM239.502,332.155C236.224,332.127 234.144,330.44 233.732,328.884C233.319,327.329 235.679,323.517 237.026,322.821C244.051,319.192 251.916,319.735 251.916,319.735C251.916,319.735 254.299,332.28 239.502,332.155ZM238.929,221.803L270.281,221.803L270.281,254.418L238.929,254.418L238.929,221.803ZM238.929,136.356L270.281,136.356L270.281,205.834L238.929,205.834L238.929,136.356Z" style="fill:rgb(253,237,0);"/>
+</svg>
diff --git a/library/build.gradle b/build.gradle
similarity index 79%
rename from library/build.gradle
rename to build.gradle
index 7d6edde7..6f0281ca 100644
--- a/library/build.gradle
+++ b/build.gradle
@@ -2,6 +2,10 @@ subprojects {
 
   repositories {
     mavenCentral()
+//    maven {
+//      url 'https://oss.sonatype.org/content/repositories/snapshots/'
+//    }
+//    mavenLocal()
   }
 
   buildscript {
@@ -9,21 +13,20 @@ subprojects {
       mavenCentral()
     }
     dependencies {
-      classpath 'com.android.tools.build:gradle:1.2.2'
+      classpath 'com.android.tools.build:gradle:1.2.3'
     }
   }
 }
 
 ext {
-  androidPlugin = 'com.android.tools.build:gradle:1.2.0'
-  minSdkVersion = 9
+  minSdkVersion = 8
   compileSdkVersion = 21
   targetSdkVersion = compileSdkVersion
   buildToolsVersion = '21.1.2'
   javaVersion = JavaVersion.VERSION_1_7
 
   GROUP = 'com.squareup.leakcanary'
-  VERSION_NAME = "1.3.1-SNAPSHOT"
+  VERSION_NAME = "1.4-SNAPSHOT"
   POM_PACKAGING = "pom"
   POM_DESCRIPTION= "Leak Canary"
 
@@ -38,4 +41,4 @@ ext {
 
   POM_DEVELOPER_ID="square"
   POM_DEVELOPER_NAME="Square, Inc."
-}
\ No newline at end of file
+}
diff --git a/library/checkstyle.xml b/checkstyle.xml
similarity index 100%
rename from library/checkstyle.xml
rename to checkstyle.xml
diff --git a/library/gradle/checkstyle.gradle b/gradle/checkstyle.gradle
similarity index 100%
rename from library/gradle/checkstyle.gradle
rename to gradle/checkstyle.gradle
diff --git a/library/gradle/gradle-mvn-push.gradle b/gradle/gradle-mvn-push.gradle
similarity index 100%
rename from library/gradle/gradle-mvn-push.gradle
rename to gradle/gradle-mvn-push.gradle
diff --git a/library/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
similarity index 100%
rename from library/gradle/wrapper/gradle-wrapper.jar
rename to gradle/wrapper/gradle-wrapper.jar
diff --git a/library/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
similarity index 100%
rename from library/gradle/wrapper/gradle-wrapper.properties
rename to gradle/wrapper/gradle-wrapper.properties
diff --git a/library/gradlew b/gradlew
similarity index 100%
rename from library/gradlew
rename to gradlew
diff --git a/library/leakcanary-analyzer/build.gradle b/leakcanary-analyzer/build.gradle
similarity index 97%
rename from library/leakcanary-analyzer/build.gradle
rename to leakcanary-analyzer/build.gradle
index 0df56e10..c12cab76 100644
--- a/library/leakcanary-analyzer/build.gradle
+++ b/leakcanary-analyzer/build.gradle
@@ -14,7 +14,7 @@ repositories {
 }
 
 dependencies {
-  compile 'com.squareup.haha:haha:1.1'
+  compile 'com.squareup.haha:haha:2.0.2'
   compile project(':leakcanary-watcher')
   testCompile 'junit:junit:4.12'
 }
diff --git a/library/leakcanary-analyzer/gradle.properties b/leakcanary-analyzer/gradle.properties
similarity index 100%
rename from library/leakcanary-analyzer/gradle.properties
rename to leakcanary-analyzer/gradle.properties
diff --git a/library/leakcanary-analyzer/src/main/AndroidManifest.xml b/leakcanary-analyzer/src/main/AndroidManifest.xml
similarity index 100%
rename from library/leakcanary-analyzer/src/main/AndroidManifest.xml
rename to leakcanary-analyzer/src/main/AndroidManifest.xml
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java b/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java
new file mode 100644
index 00000000..227bcb59
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.haha.perflib;
+
+public final class HahaSpy {
+
+  public static Instance allocatingThread(Instance instance) {
+    Snapshot snapshot = instance.mHeap.mSnapshot;
+    int threadSerialNumber;
+    if (instance instanceof RootObj) {
+      threadSerialNumber = ((RootObj) instance).mThread;
+    } else {
+      threadSerialNumber = instance.mStack.mThreadSerialNumber;
+    }
+    ThreadObj thread = snapshot.getThread(threadSerialNumber);
+    return snapshot.findInstance(thread.mId);
+  }
+
+  private HahaSpy() {
+    throw new AssertionError();
+  }
+}
diff --git a/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
similarity index 89%
rename from library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
rename to leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
index d1cf730a..8376943a 100644
--- a/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
@@ -28,8 +28,8 @@ public static AnalysisResult leakDetected(boolean excludedLeak, String className
     return new AnalysisResult(true, excludedLeak, className, leakTrace, null, analysisDurationMs);
   }
 
-  public static AnalysisResult failure(Exception exception, long analysisDurationMs) {
-    return new AnalysisResult(false, false, null, null, exception, analysisDurationMs);
+  public static AnalysisResult failure(Throwable failure, long analysisDurationMs) {
+    return new AnalysisResult(false, false, null, null, failure, analysisDurationMs);
   }
 
   /** True if a leak was found in the heap dump. */
@@ -54,13 +54,13 @@ public static AnalysisResult failure(Exception exception, long analysisDurationM
   public final LeakTrace leakTrace;
 
   /** Null unless the analysis failed. */
-  public final Exception failure;
+  public final Throwable failure;
 
   /** Total time spent analyzing the heap. */
   public final long analysisDurationMs;
 
   private AnalysisResult(boolean leakFound, boolean excludedLeak, String className,
-      LeakTrace leakTrace, Exception failure, long analysisDurationMs) {
+      LeakTrace leakTrace, Throwable failure, long analysisDurationMs) {
     this.leakFound = leakFound;
     this.excludedLeak = excludedLeak;
     this.className = className;
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
new file mode 100644
index 00000000..d281056b
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import com.squareup.haha.perflib.ArrayInstance;
+import com.squareup.haha.perflib.ClassInstance;
+import com.squareup.haha.perflib.ClassObj;
+import com.squareup.haha.perflib.Field;
+import com.squareup.haha.perflib.Heap;
+import com.squareup.haha.perflib.Instance;
+import com.squareup.haha.perflib.Type;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import static com.squareup.leakcanary.Preconditions.checkNotNull;
+import static java.util.Arrays.asList;
+
+public final class HahaHelper {
+
+  private static final Set<String> WRAPPER_TYPES = new HashSet<>(
+      asList(Boolean.class.getName(), Character.class.getName(), Float.class.getName(),
+          Double.class.getName(), Byte.class.getName(), Short.class.getName(),
+          Integer.class.getName(), Long.class.getName()));
+
+  static String fieldToString(Map.Entry<Field, Object> entry) {
+    return fieldToString(entry.getKey(), entry.getValue());
+  }
+
+  static String fieldToString(ClassInstance.FieldValue fieldValue) {
+    return fieldToString(fieldValue.getField(), fieldValue.getValue());
+  }
+
+  static String fieldToString(Field field, Object value) {
+    return field.getName() + " = " + value;
+  }
+
+  static String threadName(Instance holder) {
+    List<ClassInstance.FieldValue> values = classInstanceValues(holder);
+    Object nameField = fieldValue(values, "name");
+    return asString(nameField);
+  }
+
+  static boolean extendsThread(ClassObj clazz) {
+    boolean extendsThread = false;
+    ClassObj parentClass = clazz;
+    while (parentClass.getSuperClassObj() != null) {
+      if (clazz.getClassName().equals(Thread.class.getName())) {
+        extendsThread = true;
+        break;
+      }
+      parentClass = parentClass.getSuperClassObj();
+    }
+    return extendsThread;
+  }
+
+  static String asString(Object stringObject) {
+    Instance instance = (Instance) stringObject;
+    List<ClassInstance.FieldValue> values = classInstanceValues(instance);
+
+    Integer count = fieldValue(values, "count");
+    Object value = fieldValue(values, "value");
+    Integer offset;
+    ArrayInstance charArray;
+    if (isCharArray(value)) {
+      charArray = (ArrayInstance) value;
+      offset = fieldValue(values, "offset");
+    } else {
+      // In M preview 2+, the underlying char buffer resides in the heap with ID equalling the
+      // String's ID + 16.
+      // https://android-review.googlesource.com/#/c/160380/2/android/src/com/android/tools/idea/
+      // editors/hprof/descriptors/InstanceFieldDescriptorImpl.java
+      Heap heap = instance.getHeap();
+      Instance inlineInstance = heap.getInstance(instance.getId() + 16);
+      if (isCharArray(inlineInstance)) {
+        charArray = (ArrayInstance) inlineInstance;
+        offset = 0;
+      } else {
+        throw new UnsupportedOperationException("Could not find char array in " + instance);
+      }
+    }
+    checkNotNull(count, "count");
+    checkNotNull(charArray, "charArray");
+    checkNotNull(offset, "offset");
+
+    if (count == 0) {
+      return "";
+    }
+
+    char[] chars = charArray.asCharArray(offset, count);
+
+    return new String(chars);
+  }
+
+  public static boolean isPrimitiveWrapper(Object value) {
+    if (!(value instanceof ClassInstance)) {
+      return false;
+    }
+    return WRAPPER_TYPES.contains(((ClassInstance) value).getClassObj().getClassName());
+  }
+
+  public static boolean isPrimitiveOrWrapperArray(Object value) {
+    if (!(value instanceof ArrayInstance)) {
+      return false;
+    }
+    ArrayInstance arrayInstance = (ArrayInstance) value;
+    if (arrayInstance.getArrayType() != Type.OBJECT) {
+      return true;
+    }
+    return WRAPPER_TYPES.contains(arrayInstance.getClassObj().getClassName());
+  }
+
+  private static boolean isCharArray(Object value) {
+    return value instanceof ArrayInstance && ((ArrayInstance) value).getArrayType() == Type.CHAR;
+  }
+
+  static List<ClassInstance.FieldValue> classInstanceValues(Instance instance) {
+    ClassInstance classInstance = (ClassInstance) instance;
+    return classInstance.getValues();
+  }
+
+  static <T> T fieldValue(List<ClassInstance.FieldValue> values, String fieldName) {
+    for (ClassInstance.FieldValue fieldValue : values) {
+      if (fieldValue.getField().getName().equals(fieldName)) {
+        //noinspection unchecked
+        return (T) fieldValue.getValue();
+      }
+    }
+    throw new IllegalArgumentException("Field " + fieldName + " does not exists");
+  }
+
+  private HahaHelper() {
+    throw new AssertionError();
+  }
+}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
new file mode 100644
index 00000000..c688bc2c
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
@@ -0,0 +1,219 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import com.squareup.haha.perflib.ArrayInstance;
+import com.squareup.haha.perflib.ClassInstance;
+import com.squareup.haha.perflib.ClassObj;
+import com.squareup.haha.perflib.Field;
+import com.squareup.haha.perflib.HprofParser;
+import com.squareup.haha.perflib.Instance;
+import com.squareup.haha.perflib.RootObj;
+import com.squareup.haha.perflib.Snapshot;
+import com.squareup.haha.perflib.Type;
+import com.squareup.haha.perflib.io.HprofBuffer;
+import com.squareup.haha.perflib.io.MemoryMappedFileBuffer;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+import static com.squareup.leakcanary.AnalysisResult.failure;
+import static com.squareup.leakcanary.AnalysisResult.leakDetected;
+import static com.squareup.leakcanary.AnalysisResult.noLeak;
+import static com.squareup.leakcanary.HahaHelper.asString;
+import static com.squareup.leakcanary.HahaHelper.classInstanceValues;
+import static com.squareup.leakcanary.HahaHelper.extendsThread;
+import static com.squareup.leakcanary.HahaHelper.fieldToString;
+import static com.squareup.leakcanary.HahaHelper.fieldValue;
+import static com.squareup.leakcanary.HahaHelper.threadName;
+import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
+import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
+import static com.squareup.leakcanary.LeakTraceElement.Holder.OBJECT;
+import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+
+/**
+ * Analyzes heap dumps generated by a {@link RefWatcher} to verify if suspected leaks are real.
+ */
+public final class HeapAnalyzer {
+
+  private static final String ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$";
+
+  private final ExcludedRefs excludedRefs;
+
+  public HeapAnalyzer(ExcludedRefs excludedRefs) {
+    this.excludedRefs = excludedRefs;
+  }
+
+  /**
+   * Searches the heap dump for a {@link KeyedWeakReference} instance with the corresponding key,
+   * and then computes the shortest strong reference path from that instance to the GC roots.
+   */
+  public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
+    long analysisStartNanoTime = System.nanoTime();
+
+    if (!heapDumpFile.exists()) {
+      Exception exception = new IllegalArgumentException("File does not exist: " + heapDumpFile);
+      return failure(exception, since(analysisStartNanoTime));
+    }
+
+    try {
+      HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
+      HprofParser parser = new HprofParser(buffer);
+      Snapshot snapshot = parser.parse();
+
+      Instance leakingRef = findLeakingReference(referenceKey, snapshot);
+
+      // False alarm, weak reference was cleared in between key check and heap dump.
+      if (leakingRef == null) {
+        return noLeak(since(analysisStartNanoTime));
+      }
+
+      return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);
+    } catch (Throwable e) {
+      return failure(e, since(analysisStartNanoTime));
+    }
+  }
+
+  private Instance findLeakingReference(String key, Snapshot snapshot) {
+    ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());
+    List<String> keysFound = new ArrayList<>();
+    for (Instance instance : refClass.getInstancesList()) {
+      List<ClassInstance.FieldValue> values = classInstanceValues(instance);
+      String keyCandidate = asString(fieldValue(values, "key"));
+      if (keyCandidate.equals(key)) {
+        return fieldValue(values, "referent");
+      }
+      keysFound.add(keyCandidate);
+    }
+    throw new IllegalStateException(
+        "Could not find weak reference with key " + key + " in " + keysFound);
+  }
+
+  private AnalysisResult findLeakTrace(long analysisStartNanoTime, Snapshot snapshot,
+      Instance leakingRef) {
+
+    ShortestPathFinder pathFinder = new ShortestPathFinder(excludedRefs);
+    ShortestPathFinder.Result result = pathFinder.findPath(snapshot, leakingRef);
+
+    // False alarm, no strong reference path to GC Roots.
+    if (result.leakingNode == null) {
+      return noLeak(since(analysisStartNanoTime));
+    }
+
+    LeakTrace leakTrace = buildLeakTrace(result.leakingNode);
+
+    String className = leakingRef.getClassObj().getClassName();
+
+    return leakDetected(result.excludingKnownLeaks, className, leakTrace,
+        since(analysisStartNanoTime));
+  }
+
+  private LeakTrace buildLeakTrace(LeakNode leakingNode) {
+    List<LeakTraceElement> elements = new ArrayList<>();
+    // We iterate from the leak to the GC root
+    LeakNode node = new LeakNode(null, leakingNode, null, null);
+    while (node != null) {
+      LeakTraceElement element = buildLeakElement(node);
+      if (element != null) {
+        elements.add(0, element);
+      }
+      node = node.parent;
+    }
+    return new LeakTrace(elements);
+  }
+
+  private LeakTraceElement buildLeakElement(LeakNode node) {
+    if (node.parent == null) {
+      // Ignore any root node.
+      return null;
+    }
+    Instance holder = node.parent.instance;
+
+    if (holder instanceof RootObj) {
+      return null;
+    }
+    LeakTraceElement.Type type = node.referenceType;
+    String referenceName = node.referenceName;
+
+    LeakTraceElement.Holder holderType;
+    String className;
+    String extra = null;
+    List<String> fields = new ArrayList<>();
+    if (holder instanceof ClassObj) {
+      ClassObj classObj = (ClassObj) holder;
+      holderType = CLASS;
+      className = classObj.getClassName();
+      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
+        Field field = entry.getKey();
+        Object value = entry.getValue();
+        fields.add("static " + field.getName() + " = " + value);
+      }
+    } else if (holder instanceof ArrayInstance) {
+      ArrayInstance arrayInstance = (ArrayInstance) holder;
+      holderType = ARRAY;
+      className = arrayInstance.getClassObj().getClassName();
+      if (arrayInstance.getArrayType() == Type.OBJECT) {
+        Object[] values = arrayInstance.getValues();
+        for (int i = 0; i < values.length; i++) {
+          fields.add("[" + i + "] = " + values[i]);
+        }
+      }
+    } else {
+      ClassInstance classInstance = (ClassInstance) holder;
+      ClassObj classObj = holder.getClassObj();
+      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
+        fields.add("static " + fieldToString(entry));
+      }
+      for (ClassInstance.FieldValue field : classInstance.getValues()) {
+        fields.add(fieldToString(field));
+      }
+      className = classObj.getClassName();
+
+      if (extendsThread(classObj)) {
+        holderType = THREAD;
+        String threadName = threadName(holder);
+        extra = "(named '" + threadName + "')";
+      } else if (className.matches(ANONYMOUS_CLASS_NAME_PATTERN)) {
+        String parentClassName = classObj.getSuperClassObj().getClassName();
+        if (Object.class.getName().equals(parentClassName)) {
+          holderType = OBJECT;
+          // This is an anonymous class implementing an interface. The API does not give access
+          // to the interfaces implemented by the class. Let's see if it's in the class path and
+          // use that instead.
+          try {
+            Class<?> actualClass = Class.forName(classObj.getClassName());
+            Class<?> implementedInterface = actualClass.getInterfaces()[0];
+            extra = "(anonymous class implements " + implementedInterface.getName() + ")";
+          } catch (ClassNotFoundException ignored) {
+          }
+        } else {
+          holderType = OBJECT;
+          // Makes it easier to figure out which anonymous class we're looking at.
+          extra = "(anonymous class extends " + parentClassName + ")";
+        }
+      } else {
+        holderType = OBJECT;
+      }
+    }
+    return new LeakTraceElement(referenceName, type, holderType, className, extra, fields);
+  }
+
+  private long since(long analysisStartNanoTime) {
+    return NANOSECONDS.toMillis(System.nanoTime() - analysisStartNanoTime);
+  }
+}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
new file mode 100644
index 00000000..69ec8717
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import com.squareup.haha.perflib.Instance;
+
+final class LeakNode {
+  final Instance instance;
+  final LeakNode parent;
+  final String referenceName;
+  final LeakTraceElement.Type referenceType;
+
+  LeakNode(Instance instance, LeakNode parent, String referenceName,
+      LeakTraceElement.Type referenceType) {
+    this.instance = instance;
+    this.parent = parent;
+    this.referenceName = referenceName;
+    this.referenceType = referenceType;
+  }
+}
diff --git a/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
similarity index 85%
rename from library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
rename to leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
index 446ec62e..607db22c 100644
--- a/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
@@ -16,6 +16,7 @@
 package com.squareup.leakcanary;
 
 import java.io.Serializable;
+import java.util.ArrayList;
 import java.util.List;
 
 import static java.util.Collections.unmodifiableList;
@@ -29,7 +30,7 @@
   public final List<LeakTraceElement> elements;
 
   LeakTrace(List<LeakTraceElement> elements) {
-    this.elements = unmodifiableList(elements);
+    this.elements = unmodifiableList(new ArrayList<>(elements));
   }
 
   @Override public String toString() {
@@ -48,4 +49,12 @@
     }
     return sb.toString();
   }
+
+  public String toDetailedString() {
+    String string = "";
+    for (LeakTraceElement element : elements) {
+      string += element.toDetailedString();
+    }
+    return string;
+  }
 }
diff --git a/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
similarity index 72%
rename from library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
rename to leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
index 3c170421..02f85f64 100644
--- a/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
@@ -16,17 +16,21 @@
 package com.squareup.leakcanary;
 
 import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
 
 import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
+import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
 import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
 import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
+import static java.util.Collections.unmodifiableList;
 import static java.util.Locale.US;
 
 /** Represents one reference in the chain of references that holds a leaking object in memory. */
 public final class LeakTraceElement implements Serializable {
 
   public enum Type {
-    INSTANCE_FIELD, STATIC_FIELD, LOCAL
+    INSTANCE_FIELD, STATIC_FIELD, LOCAL, ARRAY_ENTRY
   }
 
   public enum Holder {
@@ -44,12 +48,17 @@
   /** Additional information, may be null. */
   public final String extra;
 
-  LeakTraceElement(String referenceName, Type type, Holder holder, String className, String extra) {
+  /** List of all fields (member and static) for that object. */
+  public final List<String> fields;
+
+  LeakTraceElement(String referenceName, Type type, Holder holder, String className, String extra,
+      List<String> fields) {
     this.referenceName = referenceName;
     this.type = type;
     this.holder = holder;
     this.className = className;
     this.extra = extra;
+    this.fields = unmodifiableList(new ArrayList<>(fields));
   }
 
   @Override public String toString() {
@@ -76,4 +85,20 @@
     }
     return string;
   }
+
+  public String toDetailedString() {
+    String string = "* ";
+    if (holder == ARRAY) {
+      string += "Array of";
+    } else if (holder == CLASS) {
+      string += "Class";
+    } else {
+      string += "Instance of";
+    }
+    string += " " + className + "\n";
+    for (String field : fields) {
+      string += "|   " + field + "\n";
+    }
+    return string;
+  }
 }
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
new file mode 100644
index 00000000..134c5e41
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
@@ -0,0 +1,323 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import com.squareup.haha.perflib.ArrayInstance;
+import com.squareup.haha.perflib.ClassInstance;
+import com.squareup.haha.perflib.ClassObj;
+import com.squareup.haha.perflib.Field;
+import com.squareup.haha.perflib.HahaSpy;
+import com.squareup.haha.perflib.Instance;
+import com.squareup.haha.perflib.RootObj;
+import com.squareup.haha.perflib.RootType;
+import com.squareup.haha.perflib.Snapshot;
+import com.squareup.haha.perflib.Type;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.Map;
+import java.util.Queue;
+
+import static com.squareup.leakcanary.HahaHelper.isPrimitiveOrWrapperArray;
+import static com.squareup.leakcanary.HahaHelper.isPrimitiveWrapper;
+import static com.squareup.leakcanary.HahaHelper.threadName;
+import static com.squareup.leakcanary.LeakTraceElement.Type.ARRAY_ENTRY;
+import static com.squareup.leakcanary.LeakTraceElement.Type.INSTANCE_FIELD;
+import static com.squareup.leakcanary.LeakTraceElement.Type.LOCAL;
+import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
+
+/**
+ * Not thread safe.
+ *
+ * Finds the shortest path from a leaking reference to a gc root, ignoring excluded
+ * refs first and then including the ones that are not "always ignorable" as needed if no path is
+ * found.
+ */
+final class ShortestPathFinder {
+
+  private final ExcludedRefs excludedRefs;
+  private final Queue<LeakNode> toVisitQueue;
+  private final Queue<LeakNode> toVisitIfNoPathQueue;
+  private final LinkedHashSet<Instance> toVisitSet;
+  private final LinkedHashSet<Instance> toVisitIfNoPathSet;
+  private final LinkedHashSet<Instance> visitedSet;
+  private boolean canIgnoreStrings;
+
+  ShortestPathFinder(ExcludedRefs excludedRefs) {
+    this.excludedRefs = excludedRefs;
+    toVisitQueue = new LinkedList<>();
+    toVisitIfNoPathQueue = new LinkedList<>();
+    toVisitSet = new LinkedHashSet<>();
+    toVisitIfNoPathSet = new LinkedHashSet<>();
+    visitedSet = new LinkedHashSet<>();
+  }
+
+  static final class Result {
+    final LeakNode leakingNode;
+    final boolean excludingKnownLeaks;
+
+    Result(LeakNode leakingNode, boolean excludingKnownLeaks) {
+      this.leakingNode = leakingNode;
+      this.excludingKnownLeaks = excludingKnownLeaks;
+    }
+  }
+
+  Result findPath(Snapshot snapshot, Instance leakingRef) {
+    clearState();
+    canIgnoreStrings = !isString(leakingRef);
+
+    enqueueGcRoots(snapshot);
+
+    boolean excludingKnownLeaks = false;
+    LeakNode leakingNode = null;
+    while (!toVisitQueue.isEmpty() || !toVisitIfNoPathQueue.isEmpty()) {
+      LeakNode node;
+      if (!toVisitQueue.isEmpty()) {
+        node = toVisitQueue.poll();
+      } else {
+        node = toVisitIfNoPathQueue.poll();
+        excludingKnownLeaks = true;
+      }
+
+      // Termination
+      if (node.instance == leakingRef) {
+        leakingNode = node;
+        break;
+      }
+
+      if (checkSeen(node)) {
+        continue;
+      }
+
+      if (node.instance instanceof RootObj) {
+        visitRootObj(node);
+      } else if (node.instance instanceof ClassObj) {
+        visitClassObj(node);
+      } else if (node.instance instanceof ClassInstance) {
+        visitClassInstance(node);
+      } else if (node.instance instanceof ArrayInstance) {
+        visitArrayInstance(node);
+      } else {
+        throw new IllegalStateException("Unexpected type for " + node.instance);
+      }
+    }
+    return new Result(leakingNode, excludingKnownLeaks);
+  }
+
+  private void clearState() {
+    toVisitQueue.clear();
+    toVisitIfNoPathQueue.clear();
+    toVisitSet.clear();
+    toVisitIfNoPathSet.clear();
+    visitedSet.clear();
+  }
+
+  private void enqueueGcRoots(Snapshot snapshot) {
+    for (RootObj rootObj : snapshot.getGCRoots()) {
+      switch (rootObj.getRootType()) {
+        case JAVA_LOCAL:
+          Instance thread = HahaSpy.allocatingThread(rootObj);
+          String threadName = threadName(thread);
+          Boolean alwaysIgnore = excludedRefs.threadNames.get(threadName);
+          if (alwaysIgnore == null || !alwaysIgnore) {
+            enqueue(alwaysIgnore == null, null, rootObj, null, null);
+          }
+          break;
+        case INTERNED_STRING:
+        case DEBUGGER:
+        case INVALID_TYPE:
+          // An object that is unreachable from any other root, but not a root itself.
+        case UNREACHABLE:
+        case UNKNOWN:
+          // An object that is in a queue, waiting for a finalizer to run.
+        case FINALIZING:
+          break;
+        case SYSTEM_CLASS:
+        case VM_INTERNAL:
+          // A local variable in native code.
+        case NATIVE_LOCAL:
+          // A global variable in native code.
+        case NATIVE_STATIC:
+          // An object that was referenced from an active thread block.
+        case THREAD_BLOCK:
+          // Everything that called the wait() or notify() methods, or that is synchronized.
+        case BUSY_MONITOR:
+        case NATIVE_MONITOR:
+        case REFERENCE_CLEANUP:
+          // Input or output parameters in native code.
+        case NATIVE_STACK:
+        case JAVA_STATIC:
+          enqueue(true, null, rootObj, null, null);
+          break;
+        default:
+          throw new UnsupportedOperationException("Unknown root type:" + rootObj.getRootType());
+      }
+    }
+  }
+
+  private boolean checkSeen(LeakNode node) {
+    return !visitedSet.add(node.instance);
+  }
+
+  private void visitRootObj(LeakNode node) {
+    RootObj rootObj = (RootObj) node.instance;
+    Instance child = rootObj.getReferredInstance();
+
+    if (rootObj.getRootType() == RootType.JAVA_LOCAL) {
+      Instance holder = HahaSpy.allocatingThread(rootObj);
+      // We switch the parent node with the thread instance that holds
+      // the local reference.
+      LeakNode parent = new LeakNode(holder, null, null, null);
+      enqueue(true, parent, child, "<Java Local>", LOCAL);
+    } else {
+      enqueue(true, node, child, null, null);
+    }
+  }
+
+  private void visitClassObj(LeakNode node) {
+    ClassObj classObj = (ClassObj) node.instance;
+    Map<String, Boolean> ignoredStaticFields =
+        excludedRefs.staticFieldNameByClassName.get(classObj.getClassName());
+    for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
+      Field field = entry.getKey();
+      if (field.getType() != Type.OBJECT) {
+        continue;
+      }
+      String fieldName = field.getName();
+      if (fieldName.equals("$staticOverhead")) {
+        continue;
+      }
+      Instance child = (Instance) entry.getValue();
+      boolean visit = true;
+      if (ignoredStaticFields != null) {
+        Boolean alwaysIgnore = ignoredStaticFields.get(fieldName);
+        if (alwaysIgnore != null) {
+          visit = false;
+          if (!alwaysIgnore) {
+            enqueue(false, node, child, fieldName, STATIC_FIELD);
+          }
+        }
+      }
+      if (visit) {
+        enqueue(true, node, child, fieldName, STATIC_FIELD);
+      }
+    }
+  }
+
+  private void visitClassInstance(LeakNode node) {
+    ClassInstance classInstance = (ClassInstance) node.instance;
+    Map<String, Boolean> ignoredFields = null;
+    ClassObj superClassObj = classInstance.getClassObj();
+    Boolean alwaysIgnoreClassHierarchy = null;
+    while (superClassObj != null) {
+      Boolean alwaysIgnoreClass = excludedRefs.classNames.get(superClassObj.getClassName());
+      if (alwaysIgnoreClass != null) {
+        // true overrides null or false.
+        if (alwaysIgnoreClassHierarchy == null || !alwaysIgnoreClassHierarchy) {
+          alwaysIgnoreClassHierarchy = alwaysIgnoreClass;
+        }
+      }
+      Map<String, Boolean> classIgnoredFields =
+          excludedRefs.fieldNameByClassName.get(superClassObj.getClassName());
+      if (classIgnoredFields != null) {
+        if (ignoredFields == null) {
+          ignoredFields = new LinkedHashMap<>();
+        }
+        ignoredFields.putAll(classIgnoredFields);
+      }
+      superClassObj = superClassObj.getSuperClassObj();
+    }
+
+    if (alwaysIgnoreClassHierarchy != null && alwaysIgnoreClassHierarchy) {
+      return;
+    }
+
+    for (ClassInstance.FieldValue fieldValue : classInstance.getValues()) {
+      Field field = fieldValue.getField();
+      if (field.getType() != Type.OBJECT) {
+        continue;
+      }
+      Instance child = (Instance) fieldValue.getValue();
+      boolean visit = true;
+      boolean visitIfNoPath = false;
+      // We don't even get here if alwaysIgnoreClassHierarchy is false.
+      if (alwaysIgnoreClassHierarchy != null) {
+        visit = false;
+        visitIfNoPath = true;
+      }
+      String fieldName = field.getName();
+      if (ignoredFields != null) {
+        Boolean alwaysIgnore = ignoredFields.get(fieldName);
+        if (alwaysIgnore != null) {
+          visit = false;
+          visitIfNoPath = !alwaysIgnore;
+        }
+      }
+      if (visit || visitIfNoPath) {
+        enqueue(visit, node, child, fieldName, INSTANCE_FIELD);
+      }
+    }
+  }
+
+  private void visitArrayInstance(LeakNode node) {
+    ArrayInstance arrayInstance = (ArrayInstance) node.instance;
+    Type arrayType = arrayInstance.getArrayType();
+    if (arrayType == Type.OBJECT) {
+      Object[] values = arrayInstance.getValues();
+      for (int i = 0; i < values.length; i++) {
+        Instance child = (Instance) values[i];
+        enqueue(true, node, child, "[" + i + "]", ARRAY_ENTRY);
+      }
+    }
+  }
+
+  private void enqueue(boolean visitNow, LeakNode parent, Instance child, String referenceName,
+      LeakTraceElement.Type referenceType) {
+    if (child == null) {
+      return;
+    }
+    if (isPrimitiveOrWrapperArray(child) || isPrimitiveWrapper(child)) {
+      return;
+    }
+    // Whether we want to visit now or later, we should skip if this is already to visit.
+    if (toVisitSet.contains(child)) {
+      return;
+    }
+    if (!visitNow && toVisitIfNoPathSet.contains(child)) {
+      return;
+    }
+    if (canIgnoreStrings && isString(child)) {
+      return;
+    }
+    if (visitedSet.contains(child)) {
+      return;
+    }
+    LeakNode childNode = new LeakNode(child, parent, referenceName, referenceType);
+    if (visitNow) {
+      toVisitSet.add(child);
+      toVisitQueue.add(childNode);
+    } else {
+      toVisitIfNoPathSet.add(child);
+      toVisitIfNoPathQueue.add(childNode);
+    }
+  }
+
+  private boolean isString(Instance instance) {
+    return instance.getClassObj() != null && instance.getClassObj()
+        .getClassName()
+        .equals(String.class.getName());
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java
new file mode 100644
index 00000000..0d427886
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import java.io.File;
+import java.lang.ref.WeakReference;
+import java.net.URL;
+import java.util.Arrays;
+import java.util.Collection;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
+import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
+import static org.hamcrest.core.StringContains.containsString;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+
+@RunWith(Parameterized.class) //
+public class AsyncTaskLeakTest {
+
+  static final String ASYNC_TASK_THREAD = "AsyncTask #1";
+  static final String ASYNC_TASK_CLASS = "android.os.AsyncTask";
+  static final String EXECUTOR_FIELD_1 = "SERIAL_EXECUTOR";
+  static final String EXECUTOR_FIELD_2 = "sDefaultExecutor";
+
+  @Parameterized.Parameters public static Collection<Object[]> data() {
+    return Arrays.asList(new Object[][] {
+        { fileFromName("leak_asynctask.hprof"), "dc983a12-d029-4003-8890-7dd644c664c5" },
+        { fileFromName("leak_asynctask_mpreview2.hprof"), "1114018e-e154-435f-9a3d-da63ae9b47fa" },
+    });
+  }
+
+  private static File fileFromName(String filename) {
+    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+    URL url = classLoader.getResource(filename);
+    return new File(url.getPath());
+  }
+
+  final File heapDumpFile;
+  final String referenceKey;
+
+  ExcludedRefs.Builder excludedRefs;
+
+  public AsyncTaskLeakTest(File heapDumpFile, String referenceKey) {
+    this.heapDumpFile = heapDumpFile;
+    this.referenceKey = referenceKey;
+  }
+
+  @Before public void setUp() {
+    excludedRefs = new ExcludedRefs.Builder().clazz(WeakReference.class.getName(), true)
+        .clazz("java.lang.ref.FinalizerReference", true);
+  }
+
+  @Test public void leakFound() {
+    AnalysisResult result = analyze();
+    assertTrue(result.leakFound);
+    assertFalse(result.excludedLeak);
+    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
+    assertEquals(Thread.class.getName(), gcRoot.className);
+    assertEquals(THREAD, gcRoot.holder);
+    assertThat(gcRoot.extra, containsString(ASYNC_TASK_THREAD));
+  }
+
+  @Test public void excludeThread() {
+    excludedRefs.thread(ASYNC_TASK_THREAD);
+    AnalysisResult result = analyze();
+    assertTrue(result.leakFound);
+    assertFalse(result.excludedLeak);
+    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
+    assertEquals(ASYNC_TASK_CLASS, gcRoot.className);
+    assertEquals(STATIC_FIELD, gcRoot.type);
+    assertTrue(gcRoot.referenceName.equals(EXECUTOR_FIELD_1) || gcRoot.referenceName.equals(
+        EXECUTOR_FIELD_2));
+  }
+
+  @Test public void excludeStatic() {
+    excludedRefs.thread(ASYNC_TASK_THREAD);
+    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_1);
+    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_2);
+    AnalysisResult result = analyze();
+    assertTrue(result.leakFound);
+    assertTrue(result.excludedLeak);
+  }
+
+  private AnalysisResult analyze() {
+    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(excludedRefs.build());
+    AnalysisResult result = heapAnalyzer.checkForLeak(heapDumpFile, referenceKey);
+    if (result.failure != null) {
+      result.failure.printStackTrace();
+    }
+    if (result.leakTrace != null) {
+      System.out.println(result.leakTrace);
+    }
+    return result;
+  }
+
+
+}
diff --git a/library/leakcanary-analyzer/src/test/resources/leak_asynctask.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask.hprof
similarity index 100%
rename from library/leakcanary-analyzer/src/test/resources/leak_asynctask.hprof
rename to leakcanary-analyzer/src/test/resources/leak_asynctask.hprof
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof
new file mode 100644
index 00000000..548f3a2a
Binary files /dev/null and b/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof differ
diff --git a/library/leakcanary-android-no-op/build.gradle b/leakcanary-android-no-op/build.gradle
similarity index 84%
rename from library/leakcanary-android-no-op/build.gradle
rename to leakcanary-android-no-op/build.gradle
index b14f5807..5f3dc025 100644
--- a/library/leakcanary-android-no-op/build.gradle
+++ b/leakcanary-android-no-op/build.gradle
@@ -14,7 +14,6 @@ repositories {
 }
 
 dependencies {
-  compile project(':leakcanary-watcher')
 }
 
 android {
diff --git a/library/leakcanary-android-no-op/gradle.properties b/leakcanary-android-no-op/gradle.properties
similarity index 100%
rename from library/leakcanary-android-no-op/gradle.properties
rename to leakcanary-android-no-op/gradle.properties
diff --git a/library/leakcanary-android-no-op/src/main/AndroidManifest.xml b/leakcanary-android-no-op/src/main/AndroidManifest.xml
similarity index 100%
rename from library/leakcanary-android-no-op/src/main/AndroidManifest.xml
rename to leakcanary-android-no-op/src/main/AndroidManifest.xml
diff --git a/library/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
similarity index 100%
rename from library/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
rename to leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
diff --git a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/RefWatcher.java
new file mode 100644
index 00000000..ca9f6602
--- /dev/null
+++ b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/RefWatcher.java
@@ -0,0 +1,19 @@
+package com.squareup.leakcanary;
+
+/**
+ * No-op implementation of {@link RefWatcher} for release builds. Please use {@link
+ * RefWatcher#DISABLED}.
+ */
+public final class RefWatcher {
+
+  public static final RefWatcher DISABLED = new RefWatcher();
+
+  private RefWatcher() {
+  }
+
+  public void watch(Object watchedReference) {
+  }
+
+  public void watch(Object watchedReference, String referenceName) {
+  }
+}
diff --git a/library/leakcanary-android/build.gradle b/leakcanary-android/build.gradle
similarity index 61%
rename from library/leakcanary-android/build.gradle
rename to leakcanary-android/build.gradle
index bff0b97d..beb07063 100644
--- a/library/leakcanary-android/build.gradle
+++ b/leakcanary-android/build.gradle
@@ -17,12 +17,20 @@ dependencies {
   compile project(':leakcanary-analyzer')
 }
 
+def gitSha() {
+  return 'git rev-parse --short HEAD'.execute().text.trim()
+}
+
 android {
+  resourcePrefix 'leak_canary_'
   compileSdkVersion rootProject.ext.compileSdkVersion
   buildToolsVersion rootProject.ext.buildToolsVersion
   defaultConfig {
     minSdkVersion rootProject.ext.minSdkVersion
     targetSdkVersion rootProject.ext.targetSdkVersion
+    buildConfigField "String", "LIBRARY_VERSION", "\"${rootProject.ext.VERSION_NAME}\""
+    buildConfigField "String", "GIT_SHA", "\"${gitSha()}\""
+    consumerProguardFiles 'consumer-proguard-rules.pro'
   }
 }
 
diff --git a/leakcanary-android/consumer-proguard-rules.pro b/leakcanary-android/consumer-proguard-rules.pro
new file mode 100644
index 00000000..0a28de9b
--- /dev/null
+++ b/leakcanary-android/consumer-proguard-rules.pro
@@ -0,0 +1,2 @@
+-keep class org.eclipse.mat.** { *; }
+-keep class com.squareup.leakcanary.** { *; }
diff --git a/library/leakcanary-android/gradle.properties b/leakcanary-android/gradle.properties
similarity index 100%
rename from library/leakcanary-android/gradle.properties
rename to leakcanary-android/gradle.properties
diff --git a/library/leakcanary-android/src/main/AndroidManifest.xml b/leakcanary-android/src/main/AndroidManifest.xml
similarity index 81%
rename from library/leakcanary-android/src/main/AndroidManifest.xml
rename to leakcanary-android/src/main/AndroidManifest.xml
index f0cdef25..dc0ce58f 100644
--- a/library/leakcanary-android/src/main/AndroidManifest.xml
+++ b/leakcanary-android/src/main/AndroidManifest.xml
@@ -19,6 +19,9 @@
     package="com.squareup.leakcanary"
     >
 
+  <!-- To store the heap dumps and leak analysis results. -->
+  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+
   <application>
     <service
         android:name=".internal.HeapAnalyzerService"
@@ -30,11 +33,11 @@
         android:enabled="false"
         />
     <activity
-        android:theme="@style/__LeakCanary.Base"
+        android:theme="@style/leak_canary_LeakCanary.Base"
         android:name=".internal.DisplayLeakActivity"
         android:enabled="false"
-        android:label="@string/__leak_canary_display_activity_label"
-        android:icon="@drawable/__leak_canary_icon"
+        android:label="@string/leak_canary_display_activity_label"
+        android:icon="@drawable/leak_canary_icon"
         android:taskAffinity="com.squareup.leakcanary"
         >
       <intent-filter>
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
similarity index 100%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
similarity index 100%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java
similarity index 100%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
new file mode 100644
index 00000000..756c383d
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
@@ -0,0 +1,423 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import java.lang.ref.PhantomReference;
+import java.lang.ref.SoftReference;
+import java.lang.ref.WeakReference;
+import java.util.EnumSet;
+
+import static android.os.Build.MANUFACTURER;
+import static android.os.Build.VERSION.SDK_INT;
+import static android.os.Build.VERSION_CODES.ECLAIR;
+import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH;
+import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1;
+import static android.os.Build.VERSION_CODES.JELLY_BEAN;
+import static android.os.Build.VERSION_CODES.KITKAT;
+import static android.os.Build.VERSION_CODES.LOLLIPOP;
+import static com.squareup.leakcanary.AndroidWatchExecutor.LEAK_CANARY_THREAD_NAME;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.LG;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.LOLLIPOP_MR1;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.MOTOROLA;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.NVIDIA;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.SAMSUNG;
+
+/**
+ * This class is a work in progress. You can help by reporting leak traces that seem to be caused
+ * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
+ *
+ * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
+ * manufacturer implementation, they usually share their builds across multiple models, and the
+ * leaks eventually get fixed in newer versions.
+ *
+ * Most app developers should use {@link #createAppDefaults()}. However, you can also pick the
+ * leaks you want to ignore by creating an {@link EnumSet} that matches your needs and calling
+ * {@link #createBuilder(EnumSet)}
+ */
+public enum AndroidExcludedRefs {
+
+  ACTIVITY_CLIENT_RECORD__NEXT_IDLE(SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // Android AOSP sometimes keeps a reference to a destroyed activity as a "nextIdle" client
+      // record in the android.app.ActivityThread.mActivities map.
+      // Not sure what's going on there, input welcome.
+      excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle");
+    }
+  },
+
+  SPAN_CONTROLLER(SDK_INT <= KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // Editor inserts a special span, which has a reference to the EditText. That span is a
+      // NoCopySpan, which makes sure it gets dropped when creating a new SpannableStringBuilder
+      // from a given CharSequence.
+      // TextView.onSaveInstanceState() does a copy of its mText before saving it in the bundle.
+      // Prior to KitKat, that copy was done using the SpannableString constructor, instead of
+      // SpannableStringBuilder. The SpannableString constructor does not drop NoCopySpan spans.
+      // So we end up with a saved state that holds a reference to the textview and therefore the
+      // entire view hierarchy & activity context.
+      // Fix: https://github.com/android/platform_frameworks_base/commit
+      // /af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b
+
+      // Hack: to fix this, you could override TextView.onSaveInstanceState(), and then use
+      // reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.
+      excluded.instanceField("android.widget.Editor$EasyEditSpanController", "this$0");
+      excluded.instanceField("android.widget.Editor$SpanController", "this$0");
+    }
+  },
+
+  MEDIA_SESSION_LEGACY_HELPER__SINSTANCE(SDK_INT == LOLLIPOP) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // MediaSessionLegacyHelper is a static singleton that is lazily instantiated and keeps a
+      // reference to the context it's given the first time MediaSessionLegacyHelper.getHelper()
+      // is called.
+      // This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by calling
+      // context.getApplicationContext().
+      // Fix: https://github.com/android/platform_frameworks_base/commit
+      // /9b5257c9c99c4cb541d8e8e78fb04f008b1a9091
+
+      // Hack: to fix this, you could call MediaSessionLegacyHelper.getHelper() early in
+      // Application.onCreate() and pass it the application context.
+      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance");
+    }
+  },
+
+  TEXT_LINE__SCACHED(SDK_INT < LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had at least two
+      // bugs that created memory leaks by not correctly clearing the recycled TextLine instances.
+      // The first was fixed in android-5.1.0_r1:
+      // https://github.com/android/platform_frameworks_base/commit
+      // /893d6fe48d37f71e683f722457bea646994a10bf
+
+      // The second was fixed, not released yet:
+      // https://github.com/android/platform_frameworks_base/commit
+      // /b3a9bc038d3a218b1dbdf7b5668e3d6c12be5ee4
+
+      // Hack: to fix this, you could access TextLine.sCached and clear the pool every now and then
+      // (e.g. on activity destroy).
+      excluded.staticField("android.text.TextLine", "sCached");
+    }
+  },
+
+  BLOCKING_QUEUE(SDK_INT < LOLLIPOP) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // Prior to ART, a thread waiting on a blocking queue will leak the last dequeued object
+      // as a stack local reference.
+      // So when a HandlerThread becomes idle, it keeps a local reference to the last message it
+      // received. That message then gets recycled and can be used again.
+      // As long as all messages are recycled after being used, this won't be a problem, because
+      // there references are cleared when being recycled.
+      // However, dialogs create template Message instances to be copied when a message needs to be
+      // sent. These Message templates holds references to the dialog listeners, which most likely
+      // leads to holding a reference onto the activity in some way. Dialogs never recycle their
+      // template Message, assuming these Message instances will get GCed when the dialog is GCed.
+      // The combination of these two things creates a high potential for memory leaks as soon
+      // as you use dialogs. These memory leaks might be temporary, but some handler threads sleep
+      // for a long time.
+
+      // Hack: to fix this, you could post empty messages to the idle handler threads from time to
+      // time. This won't be easy because you cannot access all handler threads, but a library
+      // that is widely used should consider doing this for its own handler threads.
+      excluded.instanceField("android.os.Message", "obj");
+      excluded.instanceField("android.os.Message", "next");
+      excluded.instanceField("android.os.Message", "target");
+    }
+  },
+
+  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // When we detach a view that receives keyboard input, the InputMethodManager leaks a
+      // reference to it until a new view asks for keyboard input.
+      // Tracked here: https://code.google.com/p/android/issues/detail?id=171190
+      // Hack: https://gist.github.com/pyricau/4df64341cc978a7de414
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView");
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView");
+      excluded.instanceField("android.view.inputmethod.InputMethodManager",
+          "mServedInputConnection");
+    }
+  },
+
+  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // The singleton InputMethodManager is holding a reference to mCurRootView long after the
+      // activity has been destroyed.
+      // Observed on ICS MR1: https://github.com/square/leakcanary/issues/1#issuecomment-100579429
+      // Hack: https://gist.github.com/pyricau/4df64341cc978a7de414
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView");
+    }
+  },
+
+  LAYOUT_TRANSITION(SDK_INT >= ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // LayoutTransition leaks parent ViewGroup through ViewTreeObserver.OnPreDrawListener
+      // When triggered, this leaks stays until the window is destroyed.
+      // Tracked here: https://code.google.com/p/android/issues/detail?id=171830
+      excluded.instanceField("android.animation.LayoutTransition$1", "val$parent");
+    }
+  },
+
+  SPELL_CHECKER_SESSION(SDK_INT >= JELLY_BEAN || SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the
+      // SpellCheckerSession is closed before the service is connected.
+      // Tracked here: https://code.google.com/p/android/issues/detail?id=172542
+      excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0");
+    }
+  },
+
+  ACTIVITY_CHOOSE_MODEL(SDK_INT > ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // ActivityChooserModel holds a static reference to the last set ActivityChooserModelPolicy
+      // which can be an activity context.
+      // Tracked here : https://code.google.com/p/android/issues/detail?id=172659
+      // Hack : https://gist.github.com/andaag/b05ab66ed0f06167d6e0
+      excluded.staticField("android.support.v7.internal.widget.ActivityChooserModel",
+          "mActivityChoserModelPolicy");
+      excluded.staticField("android.widget.ActivityChooserModel", "mActivityChoserModelPolicy");
+    }
+  },
+
+  SPEECH_RECOGNIZER(SDK_INT < LOLLIPOP) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner class and
+      // leaked the SpeechRecognizer which leaked an activity context.
+      // Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit
+      // /b37866db469e81aca534ff6186bdafd44352329b
+      excluded.instanceField("android.speech.SpeechRecognizer$InternalListener", "this$0");
+    }
+  },
+
+  ACCOUNT_MANAGER(SDK_INT > ECLAIR && SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // AccountManager$AmsTask$Response is a stub and is held in memory by native code, probably
+      // because the reference to the response in the other process hasn't been cleared.
+      // AccountManager$AmsTask is holding on to the activity reference to use for launching a new
+      // sub- Activity.
+      // Tracked here: https://code.google.com/p/android/issues/detail?id=173689
+      // Fix: Pass a null activity reference to the AccountManager methods and then deal with the
+      // returned future to to get the result and correctly start an activity when it's available.
+      excluded.instanceField("android.accounts.AccountManager$AmsTask$Response", "this$1");
+    }
+  },
+
+  MEDIA_SCANNER_CONNECTION(SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // The static method MediaScannerConnection.scanFile() takes an activity context but the
+      // service might not disconnect after the activity has been destroyed.
+      // Tracked here: https://code.google.com/p/android/issues/detail?id=173788
+      // Fix: Create an instance of MediaScannerConnection yourself and pass in the application
+      // context. Call connect() and disconnect() manually.
+      excluded.instanceField("android.media.MediaScannerConnection", "mContext");
+    }
+  },
+
+  USER_MANAGER__SINSTANCE(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // UserManager has a static sInstance field that creates an instance and caches it the first
+      // time UserManager.get() is called. This instance is created with the outer context (which
+      // is an activity base context).
+      // Tracked here: https://code.google.com/p/android/issues/detail?id=173789
+      // Introduced by: https://github.com/android/platform_frameworks_base/commit
+      // /27db46850b708070452c0ce49daf5f79503fbde6
+      // Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the
+      // UserManager instance gets cached with a reference to the application context.
+      excluded.instanceField("android.os.UserManager", "mContext");
+    }
+  },
+
+  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER(MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      if (MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+        // DevicePolicyManager keeps a reference to the context it has been created with instead of
+        // extracting the application context. In this Motorola build, DevicePolicyManager has an
+        // inner SettingsObserver class that is a content observer, which is held into memory
+        // by a binder transport object.
+        excluded.instanceField("android.app.admin.DevicePolicyManager$SettingsObserver", "this$0");
+      }
+    }
+  },
+
+  SPEN_GESTURE_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // SpenGestureManager has a static mContext field that leaks a reference to the activity.
+      // Yes, a STATIC "mContext" field.
+      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext");
+    }
+  },
+
+  CLIPBOARD_UI_MANAGER__SINSTANCE(
+      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // ClipboardUIManager is a static singleton that leaks an activity context.
+      excluded.staticField("android.sec.clipboard.ClipboardUIManager", "sInstance");
+    }
+  },
+
+  BUBBLE_POPUP_HELPER__SHELPER(
+      LG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // A static helper for EditText "bubble popups" leaks a reference to the latest focused view.
+      excluded.staticField("android.widget.BubblePopupHelper", "sHelper");
+    }
+  },
+
+  AW_RESOURCE__SRESOURCES(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // AwResource#setResources() is called with resources that hold a reference to the
+      // activity context (instead of the application context) and doesn't clear it.
+      // Not sure what's going on there, input welcome.
+      excluded.staticField("com.android.org.chromium.android_webview.AwResource", "sResources");
+    }
+  },
+
+  MAPPER_CLIENT(NVIDIA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // Not sure exactly what ControllerMapper is about, but there is an anonymous Handler in
+      // ControllerMapper.MapperClient.ServiceClient, which leaks ControllerMapper.MapperClient
+      // which leaks the activity context.
+      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient$ServiceClient", "this$0");
+    }
+  },
+
+  TEXT_VIEW__MLAST_HOVERED_VIEW(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // mLastHoveredView is a static field in TextView that leaks the last hovered view.
+      excluded.staticField("android.widget.TextView", "mLastHoveredView");
+    }
+  },
+
+  PERSONA_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // android.app.LoadedApk.mResources has a reference to
+      // android.content.res.Resources.mPersonaManager which has a reference to
+      // android.os.PersonaManager.mContext which is an activity.
+      excluded.instanceField("android.os.PersonaManager", "mContext");
+    }
+  },
+
+  RESOURCES__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // In AOSP the Resources class does not have a context.
+      // Here we have ZygoteInit.mResources (static field) holding on to a Resources instance that
+      // has a context that is the activity.
+      // Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184
+      excluded.instanceField("android.content.res.Resources", "mContext");
+    }
+  },
+
+  VIEW_CONFIGURATION__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // In AOSP the ViewConfiguration class does not have a context.
+      // Here we have ViewConfiguration.sConfigurations (static field) holding on to a
+      // ViewConfiguration instance that has a context that is the activity.
+      // Observed here: https://github.com/square/leakcanary/issues/1#issuecomment-100324683
+      excluded.instanceField("android.view.ViewConfiguration", "mContext");
+    }
+  },
+
+  AUDIO_MANAGER__MCONTEXT_STATIC(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // Samsung added a static mContext_static field to AudioManager, holds a reference to the
+      // activity.
+      // Observed here: https://github.com/square/leakcanary/issues/32
+      excluded.staticField("android.media.AudioManager", "mContext_static");
+    }
+  },
+
+  SOFT_REFERENCES {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.clazz(WeakReference.class.getName(), true);
+      excluded.clazz(SoftReference.class.getName(), true);
+      excluded.clazz(PhantomReference.class.getName(), true);
+      excluded.clazz("java.lang.ref.Finalizer", true);
+      excluded.clazz("java.lang.ref.FinalizerReference", true);
+    }
+  },
+
+  FINALIZER_WATCHDOG_DAEMON {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
+      // reference to the object and it was about to be GCed.
+      excluded.thread("FinalizerWatchdogDaemon", true);
+    }
+  },
+
+  MAIN {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // The main thread stack is ever changing so local variables aren't likely to hold references
+      // for long. If this is on the shortest path, it's probably that there's a longer path with
+      // a real leak.
+      excluded.thread("main", true);
+    }
+  },
+
+  LEAK_CANARY_THREAD {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.thread(LEAK_CANARY_THREAD_NAME, true);
+    }
+  },
+
+  EVENT_RECEIVER__MMESSAGE_QUEUE {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
+      // the native peer of the receiver is using them.
+      // The main thread message queue is held on by the main Looper, but that might be a longer
+      // path. Let's not confuse people with a shorter path that is less meaningful.
+      excluded.instanceField("android.view.Choreographer$FrameDisplayEventReceiver",
+          "mMessageQueue", true);
+    }
+  };
+
+  /**
+   * This returns the references in the leak path that should be ignored by all on Android.
+   */
+  public static ExcludedRefs.Builder createAndroidDefaults() {
+    return createBuilder(EnumSet.of(SOFT_REFERENCES, FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
+        EVENT_RECEIVER__MMESSAGE_QUEUE));
+  }
+
+  /**
+   * This returns the references in the leak path that can be ignored for app developers. This
+   * doesn't mean there is no memory leak, to the contrary. However, some leaks are caused by bugs
+   * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
+   * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
+   */
+  public static ExcludedRefs.Builder createAppDefaults() {
+    return createBuilder(EnumSet.allOf(AndroidExcludedRefs.class));
+  }
+
+  public static ExcludedRefs.Builder createBuilder(EnumSet<AndroidExcludedRefs> refs) {
+    ExcludedRefs.Builder excluded = new ExcludedRefs.Builder();
+    for (AndroidExcludedRefs ref : refs) {
+      if (ref.applies) {
+        ref.add(excluded);
+      }
+    }
+    return excluded;
+  }
+
+  final boolean applies;
+
+  AndroidExcludedRefs() {
+    this(true);
+  }
+
+  AndroidExcludedRefs(boolean applies) {
+    this.applies = applies;
+  }
+
+  abstract void add(ExcludedRefs.Builder excluded);
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
new file mode 100644
index 00000000..7ab85f9d
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import android.content.Context;
+import android.os.Debug;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.MessageQueue;
+import android.util.Log;
+import android.view.Gravity;
+import android.view.LayoutInflater;
+import android.widget.Toast;
+import com.squareup.leakcanary.internal.FutureResult;
+import com.squareup.leakcanary.internal.LeakCanaryInternals;
+import java.io.File;
+import java.io.IOException;
+
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.isExternalStorageWritable;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.storageDirectory;
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+public final class AndroidHeapDumper implements HeapDumper {
+
+  private static final String TAG = "AndroidHeapDumper";
+
+  private final Context context;
+  private final Handler mainHandler;
+
+  public AndroidHeapDumper(Context context) {
+    this.context = context.getApplicationContext();
+    mainHandler = new Handler(Looper.getMainLooper());
+  }
+
+  @Override public File dumpHeap() {
+    if (!isExternalStorageWritable()) {
+      Log.d(TAG, "Could not dump heap, external storage not mounted.");
+    }
+    File heapDumpFile = getHeapDumpFile();
+    if (heapDumpFile.exists()) {
+      Log.d(TAG, "Could not dump heap, previous analysis still is in progress.");
+      // Heap analysis in progress, let's not put too much pressure on the device.
+      return NO_DUMP;
+    }
+
+    FutureResult<Toast> waitingForToast = new FutureResult<>();
+    showToast(waitingForToast);
+
+    if (!waitingForToast.wait(5, SECONDS)) {
+      Log.d(TAG, "Did not dump heap, too much time waiting for Toast.");
+      return NO_DUMP;
+    }
+
+    Toast toast = waitingForToast.get();
+    try {
+      Debug.dumpHprofData(heapDumpFile.getAbsolutePath());
+      cancelToast(toast);
+      return heapDumpFile;
+    } catch (IOException e) {
+      cleanup();
+      Log.e(TAG, "Could not perform heap dump", e);
+      // Abort heap dump
+      return NO_DUMP;
+    }
+  }
+
+  /**
+   * Call this on app startup to clean up all heap dump files that had not been handled yet when
+   * the app process was killed.
+   */
+  public void cleanup() {
+    LeakCanaryInternals.executeOnFileIoThread(new Runnable() {
+      @Override public void run() {
+        if (isExternalStorageWritable()) {
+          Log.d(TAG, "Could not attempt cleanup, external storage not mounted.");
+        }
+        File heapDumpFile = getHeapDumpFile();
+        if (heapDumpFile.exists()) {
+          Log.d(TAG, "Previous analysis did not complete correctly, cleaning: " + heapDumpFile);
+          heapDumpFile.delete();
+        }
+      }
+    });
+  }
+
+  private File getHeapDumpFile() {
+    return new File(storageDirectory(), "suspected_leak_heapdump.hprof");
+  }
+
+  private void showToast(final FutureResult<Toast> waitingForToast) {
+    mainHandler.post(new Runnable() {
+      @Override public void run() {
+        final Toast toast = new Toast(context);
+        toast.setGravity(Gravity.CENTER_VERTICAL, 0, 0);
+        toast.setDuration(Toast.LENGTH_LONG);
+        LayoutInflater inflater = LayoutInflater.from(context);
+        toast.setView(inflater.inflate(R.layout.leak_canary_heap_dump_toast, null));
+        toast.show();
+        // Waiting for Idle to make sure Toast gets rendered.
+        Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
+          @Override public boolean queueIdle() {
+            waitingForToast.set(toast);
+            return false;
+          }
+        });
+      }
+    });
+  }
+
+  private void cancelToast(final Toast toast) {
+    mainHandler.post(new Runnable() {
+      @Override public void run() {
+        toast.cancel();
+      }
+    });
+  }
+}
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
similarity index 100%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
similarity index 68%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
index d6ff6117..479b09e0 100644
--- a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
@@ -30,8 +30,10 @@
 import static android.os.Build.VERSION.SDK_INT;
 import static android.os.Build.VERSION_CODES.HONEYCOMB;
 import static android.os.Build.VERSION_CODES.JELLY_BEAN;
-import static com.squareup.leakcanary.LeakCanary.classSimpleName;
 import static com.squareup.leakcanary.LeakCanary.leakInfo;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.classSimpleName;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.findNextAvailableHprofFile;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.leakResultFile;
 
 /**
  * Logs leak analysis results, and then shows a notification which will start {@link
@@ -42,33 +44,32 @@
  */
 public class DisplayLeakService extends AbstractAnalysisResultService {
 
-  private static File findNextAvailableHprofFile(File directory, int maxFiles) {
-    if (!directory.exists()) {
-      directory.mkdir();
-    }
-    for (int i = 0; i < maxFiles; i++) {
-      String heapDumpName = "heap_dump_" + i + ".hprof";
-      File file = new File(directory, heapDumpName);
-      if (!file.exists()) {
-        return file;
+  @Override
+  protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
+    String leakInfo = leakInfo(this, heapDump, result, true);
+    if (leakInfo.length() < 4000) {
+      Log.d("LeakCanary", leakInfo);
+    } else {
+      String[] lines = leakInfo.split("\n");
+      for (String line : lines) {
+        Log.d("LeakCanary", line);
       }
     }
-    return null;
-  }
 
-  @TargetApi(HONEYCOMB) @Override
-  protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
-    String leakInfo = leakInfo(this, heapDump, result);
-    Log.d("LeakCanary", leakInfo);
-
-    if (!result.leakFound || result.excludedLeak) {
+    if (result.failure == null && (!result.leakFound || result.excludedLeak)) {
+      if (result.excludedLeak) {
+        PendingIntent pendingIntent = DisplayLeakActivity.createPendingIntent(this);
+        String contentTitle =
+            getString(R.string.leak_canary_class_leak_ignored, classSimpleName(result.className));
+        String contentText = getString(R.string.leak_canary_notification_leak_ignored_message);
+        notify(contentTitle, contentText, pendingIntent);
+      }
       afterDefaultHandling(heapDump, result, leakInfo);
       return;
     }
 
-    File leakDirectory = DisplayLeakActivity.leakDirectory(this);
-    int maxStoredLeaks = getResources().getInteger(R.integer.__leak_canary_max_stored_leaks);
-    File renamedFile = findNextAvailableHprofFile(leakDirectory, maxStoredLeaks);
+    int maxStoredLeaks = getResources().getInteger(R.integer.leak_canary_max_stored_leaks);
+    File renamedFile = findNextAvailableHprofFile(maxStoredLeaks);
 
     if (renamedFile == null) {
       // No file available.
@@ -80,7 +81,7 @@ protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
 
     heapDump = heapDump.renameFile(renamedFile);
 
-    File resultFile = DisplayLeakActivity.leakResultFile(renamedFile);
+    File resultFile = leakResultFile(renamedFile);
     FileOutputStream fos = null;
     try {
       fos = new FileOutputStream(resultFile);
@@ -103,23 +104,35 @@ protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
     PendingIntent pendingIntent =
         DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);
 
-    String contentTitle =
-        getString(R.string.__leak_canary_class_has_leaked, classSimpleName(result.className));
-    String contentText = getString(R.string.__leak_canary_notification_message);
+    String contentTitle;
+    if (result.failure == null) {
+      contentTitle =
+          getString(R.string.leak_canary_class_has_leaked, classSimpleName(result.className));
+    } else {
+      contentTitle = getString(R.string.leak_canary_analysis_failed);
+    }
+    String contentText = getString(R.string.leak_canary_notification_message);
+
+    notify(contentTitle, contentText, pendingIntent);
+    afterDefaultHandling(heapDump, result, leakInfo);
+  }
 
+  @TargetApi(HONEYCOMB)
+  private void notify(String contentTitle, String contentText,
+      PendingIntent pendingIntent) {
     NotificationManager notificationManager =
         (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
 
     Notification notification;
     if (SDK_INT < HONEYCOMB) {
       notification = new Notification();
-      notification.icon = R.drawable.__leak_canary_notification;
+      notification.icon = R.drawable.leak_canary_notification;
       notification.when = System.currentTimeMillis();
       notification.flags |= Notification.FLAG_AUTO_CANCEL;
       notification.setLatestEventInfo(this, contentTitle, contentText, pendingIntent);
     } else {
       Notification.Builder builder = new Notification.Builder(this) //
-          .setSmallIcon(R.drawable.__leak_canary_notification)
+          .setSmallIcon(R.drawable.leak_canary_notification)
           .setWhen(System.currentTimeMillis())
           .setContentTitle(contentTitle)
           .setContentText(contentText)
@@ -132,7 +145,6 @@ protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
       }
     }
     notificationManager.notify(0xDEAFBEEF, notification);
-    afterDefaultHandling(heapDump, result, leakInfo);
   }
 
   /**
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
similarity index 58%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
index e8affabb..6c71381d 100644
--- a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -15,23 +15,17 @@
  */
 package com.squareup.leakcanary;
 
-import android.app.ActivityManager;
 import android.app.Application;
-import android.app.Service;
-import android.content.ComponentName;
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
-import android.content.pm.ServiceInfo;
 import android.os.Build;
 import android.util.Log;
 import com.squareup.leakcanary.internal.DisplayLeakActivity;
 import com.squareup.leakcanary.internal.HeapAnalyzerService;
 
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
-import static android.content.pm.PackageManager.DONT_KILL_APP;
-import static android.content.pm.PackageManager.GET_SERVICES;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.isInServiceProcess;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabled;
 
 public final class LeakCanary {
 
@@ -40,7 +34,8 @@
    * references (on ICS+).
    */
   public static RefWatcher install(Application application) {
-    return install(application, DisplayLeakService.class);
+    return install(application, DisplayLeakService.class,
+        AndroidExcludedRefs.createAppDefaults().build());
   }
 
   /**
@@ -48,14 +43,15 @@ public static RefWatcher install(Application application) {
    * activity references (on ICS+).
    */
   public static RefWatcher install(Application application,
-      Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
+      Class<? extends AbstractAnalysisResultService> listenerServiceClass,
+      ExcludedRefs excludedRefs) {
     if (isInAnalyzerProcess(application)) {
       return RefWatcher.DISABLED;
     }
     enableDisplayLeakActivity(application);
     HeapDump.Listener heapDumpListener =
         new ServiceHeapDumpListener(application, listenerServiceClass);
-    RefWatcher refWatcher = androidWatcher(application, heapDumpListener);
+    RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);
     ActivityRefWatcher.installOnIcsPlus(application, refWatcher);
     return refWatcher;
   }
@@ -63,12 +59,13 @@ public static RefWatcher install(Application application,
   /**
    * Creates a {@link RefWatcher} with a default configuration suitable for Android.
    */
-  public static RefWatcher androidWatcher(Application app, HeapDump.Listener heapDumpListener) {
+  public static RefWatcher androidWatcher(Context context, HeapDump.Listener heapDumpListener,
+      ExcludedRefs excludedRefs) {
     DebuggerControl debuggerControl = new AndroidDebuggerControl();
-    AndroidHeapDumper heapDumper = new AndroidHeapDumper(app);
+    AndroidHeapDumper heapDumper = new AndroidHeapDumper(context);
     heapDumper.cleanup();
     return new RefWatcher(new AndroidWatchExecutor(), debuggerControl, GcTrigger.DEFAULT,
-        heapDumper, heapDumpListener);
+        heapDumper, heapDumpListener, excludedRefs);
   }
 
   public static void enableDisplayLeakActivity(Context context) {
@@ -76,7 +73,8 @@ public static void enableDisplayLeakActivity(Context context) {
   }
 
   /** Returns a string representation of the result of a heap analysis. */
-  public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult result) {
+  public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult result,
+      boolean detailed) {
     PackageManager packageManager = context.getPackageManager();
     String packageName = context.getPackageName();
     PackageInfo packageInfo;
@@ -88,6 +86,7 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
     String versionName = packageInfo.versionName;
     int versionCode = packageInfo.versionCode;
     String info = "In " + packageName + ":" + versionName + ":" + versionCode + ".\n";
+    String detailedString = "";
     if (result.leakFound) {
       if (result.excludedLeak) {
         info += "* LEAK CAN BE IGNORED.\n";
@@ -97,11 +96,18 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
         info += " (" + heapDump.referenceName + ")";
       }
       info += " has leaked:\n" + result.leakTrace.toString() + "\n";
+      if (detailed) {
+        detailedString = "\n* Details:\n" + result.leakTrace.toDetailedString();
+      }
     } else if (result.failure != null) {
       info += "* FAILURE:\n" + Log.getStackTraceString(result.failure) + "\n";
     } else {
       info += "* NO LEAK FOUND.\n\n";
     }
+    if (detailed) {
+      detailedString += "* Excluded Refs:\n" + heapDump.excludedRefs;
+    }
+
     info += "* Reference Key: "
         + heapDump.referenceKey
         + "\n"
@@ -118,6 +124,10 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
         + Build.VERSION.RELEASE
         + " API: "
         + Build.VERSION.SDK_INT
+        + " LeakCanary: "
+        + BuildConfig.LIBRARY_VERSION
+        + " "
+        + BuildConfig.GIT_SHA
         + "\n"
         + "* Durations: watch="
         + heapDump.watchDurationMs
@@ -128,7 +138,8 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
         + "ms, analysis="
         + result.analysisDurationMs
         + "ms"
-        + "\n";
+        + "\n"
+        + detailedString;
 
     return info;
   }
@@ -141,70 +152,6 @@ public static boolean isInAnalyzerProcess(Context context) {
     return isInServiceProcess(context, HeapAnalyzerService.class);
   }
 
-  private static boolean isInServiceProcess(Context context,
-      Class<? extends Service> serviceClass) {
-    PackageManager packageManager = context.getPackageManager();
-    PackageInfo packageInfo;
-    try {
-      packageInfo = packageManager.getPackageInfo(context.getPackageName(), GET_SERVICES);
-    } catch (Exception e) {
-      Log.e("AndroidUtils", "Could not get package info for " + context.getPackageName(), e);
-      return false;
-    }
-    String mainProcess = packageInfo.applicationInfo.processName;
-
-    ComponentName component = new ComponentName(context, serviceClass);
-    ServiceInfo serviceInfo;
-    try {
-      serviceInfo = packageManager.getServiceInfo(component, 0);
-    } catch (PackageManager.NameNotFoundException ignored) {
-      // Service is disabled.
-      return false;
-    }
-
-    if (serviceInfo.processName.equals(mainProcess)) {
-      Log.e("AndroidUtils",
-          "Did not expect service " + serviceClass + " to run in main process " + mainProcess);
-      // Technically we are in the service process, but we're not in the service dedicated process.
-      return false;
-    }
-
-    int myPid = android.os.Process.myPid();
-    ActivityManager activityManager =
-        (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
-    ActivityManager.RunningAppProcessInfo myProcess = null;
-    for (ActivityManager.RunningAppProcessInfo process : activityManager.getRunningAppProcesses()) {
-      if (process.pid == myPid) {
-        myProcess = process;
-        break;
-      }
-    }
-    if (myProcess == null) {
-      Log.e("AndroidUtils", "Could not find running process for " + myPid);
-      return false;
-    }
-
-    return myProcess.processName.equals(serviceInfo.processName);
-  }
-
-  static void setEnabled(Context context, Class<?> componentClass, boolean enabled) {
-    ComponentName component = new ComponentName(context, componentClass);
-    PackageManager packageManager = context.getPackageManager();
-    int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED;
-    // Blocks on IPC.
-    packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);
-  }
-
-  /** Extracts the class simple name out of a string containing a fully qualified class name. */
-  static String classSimpleName(String className) {
-    int separator = className.lastIndexOf('.');
-    if (separator == -1) {
-      return className;
-    } else {
-      return className.substring(separator + 1);
-    }
-  }
-
   private LeakCanary() {
     throw new AssertionError();
   }
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
similarity index 88%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
index b297f152..2ccb1422 100644
--- a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
@@ -19,6 +19,7 @@
 import com.squareup.leakcanary.internal.HeapAnalyzerService;
 
 import static com.squareup.leakcanary.Preconditions.checkNotNull;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabled;
 
 public final class ServiceHeapDumpListener implements HeapDump.Listener {
 
@@ -27,8 +28,8 @@
 
   public ServiceHeapDumpListener(Context context,
       Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
-    LeakCanary.setEnabled(context, listenerServiceClass, true);
-    LeakCanary.setEnabled(context, HeapAnalyzerService.class, true);
+    setEnabled(context, listenerServiceClass, true);
+    setEnabled(context, HeapAnalyzerService.class, true);
     this.listenerServiceClass = checkNotNull(listenerServiceClass, "listenerServiceClass");
     this.context = checkNotNull(context, "context").getApplicationContext();
   }
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
similarity index 75%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
index 8268dff0..d39a8376 100644
--- a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
@@ -56,7 +56,11 @@
 import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
 import static android.text.format.DateUtils.FORMAT_SHOW_DATE;
 import static android.text.format.DateUtils.FORMAT_SHOW_TIME;
+import static android.view.View.GONE;
+import static android.view.View.VISIBLE;
 import static com.squareup.leakcanary.LeakCanary.leakInfo;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.detectedLeakDirectory;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.leakResultFile;
 
 @SuppressWarnings("ConstantConditions") @TargetApi(Build.VERSION_CODES.HONEYCOMB)
 public final class DisplayLeakActivity extends Activity {
@@ -64,12 +68,8 @@
   private static final String TAG = "DisplayLeakActivity";
   private static final String SHOW_LEAK_EXTRA = "show_latest";
 
-  public static File leakDirectory(Context context) {
-    return new File(context.getFilesDir(), "detected_leaks");
-  }
-
-  public static File leakResultFile(File heapdumpFile) {
-    return new File(heapdumpFile.getParentFile(), heapdumpFile.getName() + ".result");
+  public static PendingIntent createPendingIntent(Context context) {
+    return createPendingIntent(context, null);
   }
 
   public static PendingIntent createPendingIntent(Context context, String referenceKey) {
@@ -84,6 +84,7 @@ public static PendingIntent createPendingIntent(Context context, String referenc
   private String visibleLeakRefKey;
 
   private ListView listView;
+  private TextView failureView;
   private Button actionButton;
   private int maxStoredLeaks;
 
@@ -102,12 +103,13 @@ public static PendingIntent createPendingIntent(Context context, String referenc
     //noinspection unchecked
     leaks = (List<Leak>) getLastNonConfigurationInstance();
 
-    setContentView(R.layout.__leak_canary_display_leak);
+    setContentView(R.layout.leak_canary_display_leak);
 
     listView = (ListView) findViewById(R.id.__leak_canary_display_leak_list);
+    failureView = (TextView) findViewById(R.id.__leak_canary_display_leak_failure);
     actionButton = (Button) findViewById(R.id.__leak_canary_action);
 
-    maxStoredLeaks = getResources().getInteger(R.integer.__leak_canary_max_stored_leaks);
+    maxStoredLeaks = getResources().getInteger(R.integer.leak_canary_max_stored_leaks);
 
     updateUi();
   }
@@ -134,14 +136,14 @@ public static PendingIntent createPendingIntent(Context context, String referenc
 
   @Override public boolean onCreateOptionsMenu(Menu menu) {
     if (getVisibleLeak() != null) {
-      menu.add(R.string.__leak_canary_share_leak)
+      menu.add(R.string.leak_canary_share_leak)
           .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
             @Override public boolean onMenuItemClick(MenuItem item) {
               shareLeak();
               return true;
             }
           });
-      menu.add(R.string.__leak_canary_share_heap_dump)
+      menu.add(R.string.leak_canary_share_heap_dump)
           .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
             @Override public boolean onMenuItemClick(MenuItem item) {
               shareHeapDump();
@@ -172,11 +174,11 @@ public static PendingIntent createPendingIntent(Context context, String referenc
 
   private void shareLeak() {
     Leak visibleLeak = getVisibleLeak();
-    String leakInfo = leakInfo(this, visibleLeak.heapDump, visibleLeak.result);
+    String leakInfo = leakInfo(this, visibleLeak.heapDump, visibleLeak.result, true);
     Intent intent = new Intent(Intent.ACTION_SEND);
     intent.setType("text/plain");
     intent.putExtra(Intent.EXTRA_TEXT, leakInfo);
-    startActivity(Intent.createChooser(intent, getString(R.string.__leak_canary_share_with)));
+    startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
   }
 
   private void shareHeapDump() {
@@ -186,7 +188,7 @@ private void shareHeapDump() {
     Intent intent = new Intent(Intent.ACTION_SEND);
     intent.setType("application/octet-stream");
     intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(heapDumpFile));
-    startActivity(Intent.createChooser(intent, getString(R.string.__leak_canary_share_with)));
+    startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
   }
 
   private void updateUi() {
@@ -204,40 +206,58 @@ private void updateUi() {
     }
 
     ListAdapter listAdapter = listView.getAdapter();
+    // Reset to defaults
+    listView.setVisibility(VISIBLE);
+    failureView.setVisibility(GONE);
+
     if (visibleLeak != null) {
-      final DisplayLeakAdapter adapter;
-      if (listAdapter instanceof DisplayLeakAdapter) {
-        adapter = (DisplayLeakAdapter) listAdapter;
-      } else {
-        adapter = new DisplayLeakAdapter();
-        listView.setAdapter(adapter);
-        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-          @Override
-          public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-            adapter.toggleRow(position);
-          }
-        });
+      AnalysisResult result = visibleLeak.result;
+      if (result.failure != null) {
+        listView.setVisibility(GONE);
+        failureView.setVisibility(VISIBLE);
+        failureView.setText(
+            getString(R.string.leak_canary_failure_report) + Log.getStackTraceString(
+                result.failure));
+        setTitle(R.string.leak_canary_analysis_failed);
         invalidateOptionsMenu();
         getActionBar().setDisplayHomeAsUpEnabled(true);
-        actionButton.setVisibility(View.VISIBLE);
-        actionButton.setText("Remove leak");
-        actionButton.setOnClickListener(new View.OnClickListener() {
-          @Override public void onClick(View v) {
-            Leak visibleLeak = getVisibleLeak();
-            File resultFile = leakResultFile(visibleLeak.heapDump.heapDumpFile);
-            resultFile.delete();
-            visibleLeak.heapDump.heapDumpFile.delete();
-            visibleLeakRefKey = null;
-            leaks.remove(visibleLeak);
-            updateUi();
-          }
-        });
+        actionButton.setVisibility(VISIBLE);
+        actionButton.setText(R.string.leak_canary_delete);
+        listView.setAdapter(null);
+      } else {
+        final DisplayLeakAdapter adapter;
+        if (listAdapter instanceof DisplayLeakAdapter) {
+          adapter = (DisplayLeakAdapter) listAdapter;
+        } else {
+          adapter = new DisplayLeakAdapter();
+          listView.setAdapter(adapter);
+          listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+            @Override
+            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
+              adapter.toggleRow(position);
+            }
+          });
+          invalidateOptionsMenu();
+          getActionBar().setDisplayHomeAsUpEnabled(true);
+          actionButton.setVisibility(VISIBLE);
+          actionButton.setText(R.string.leak_canary_delete);
+          actionButton.setOnClickListener(new View.OnClickListener() {
+            @Override public void onClick(View v) {
+              Leak visibleLeak = getVisibleLeak();
+              File resultFile = leakResultFile(visibleLeak.heapDump.heapDumpFile);
+              resultFile.delete();
+              visibleLeak.heapDump.heapDumpFile.delete();
+              visibleLeakRefKey = null;
+              leaks.remove(visibleLeak);
+              updateUi();
+            }
+          });
+        }
+        HeapDump heapDump = visibleLeak.heapDump;
+        adapter.update(result.leakTrace, heapDump.referenceKey, heapDump.referenceName);
+        setTitle(
+            getString(R.string.leak_canary_class_has_leaked, classSimpleName(result.className)));
       }
-      AnalysisResult result = visibleLeak.result;
-      HeapDump heapDump = visibleLeak.heapDump;
-      adapter.update(result.leakTrace, heapDump.referenceKey, heapDump.referenceName);
-      setTitle(
-          getString(R.string.__leak_canary_class_has_leaked, classSimpleName(result.className)));
     } else {
       if (listAdapter instanceof LeakListAdapter) {
         ((LeakListAdapter) listAdapter).notifyDataSetChanged();
@@ -252,14 +272,14 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
           }
         });
         invalidateOptionsMenu();
-        setTitle(getString(R.string.__leak_canary_leak_list_title, getPackageName()));
+        setTitle(getString(R.string.leak_canary_leak_list_title, getPackageName()));
         getActionBar().setDisplayHomeAsUpEnabled(false);
-        actionButton.setText("Remove all leaks");
+        actionButton.setText(R.string.leak_canary_delete_all);
         actionButton.setOnClickListener(new View.OnClickListener() {
           @Override public void onClick(View v) {
-            File directory = leakDirectory(DisplayLeakActivity.this);
-            if (directory.exists()) {
-              for (File file : directory.listFiles()) {
+            File[] files = detectedLeakDirectory().listFiles();
+            if (files != null) {
+              for (File file : files) {
                 file.delete();
               }
             }
@@ -268,7 +288,7 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
           }
         });
       }
-      actionButton.setVisibility(leaks.size() == 0 ? View.GONE : View.VISIBLE);
+      actionButton.setVisibility(leaks.size() == 0 ? GONE : VISIBLE);
     }
   }
 
@@ -301,7 +321,7 @@ private Leak getVisibleLeak() {
     @Override public View getView(int position, View convertView, ViewGroup parent) {
       if (convertView == null) {
         convertView = LayoutInflater.from(DisplayLeakActivity.this)
-            .inflate(R.layout.__leak_canary_leak_row, parent, false);
+            .inflate(R.layout.leak_canary_leak_row, parent, false);
       }
       TextView titleView = (TextView) convertView.findViewById(R.id.__leak_canary_row_text);
       TextView timeView = (TextView) convertView.findViewById(R.id.__leak_canary_row_time);
@@ -314,8 +334,16 @@ private Leak getVisibleLeak() {
         index = (leaks.size() - position) + ". ";
       }
 
-      String title = index + getString(R.string.__leak_canary_class_has_leaked,
-          classSimpleName(leak.result.className));
+      String title;
+      if (leak.result.failure == null) {
+        title = index + getString(R.string.leak_canary_class_has_leaked,
+            classSimpleName(leak.result.className));
+      } else {
+        title = index
+            + leak.result.failure.getClass().getSimpleName()
+            + " "
+            + leak.result.failure.getMessage();
+      }
       titleView.setText(title);
       String time = DateUtils.formatDateTime(DisplayLeakActivity.this,
           leak.heapDump.heapDumpFile.lastModified(), FORMAT_SHOW_TIME | FORMAT_SHOW_DATE);
@@ -359,7 +387,7 @@ static void forgetActivity() {
 
     LoadLeaks(DisplayLeakActivity activity) {
       this.activityOrNull = activity;
-      leakDirectory = leakDirectory(activity);
+      leakDirectory = detectedLeakDirectory();
       mainHandler = new Handler(Looper.getMainLooper());
     }
 
@@ -371,8 +399,8 @@ static void forgetActivity() {
         }
       });
       if (files != null) {
-        for (File file : files) {
-          File resultFile = leakResultFile(file);
+        for (File heapDumpFile : files) {
+          File resultFile = leakResultFile(heapDumpFile);
           FileInputStream fis = null;
           try {
             fis = new FileInputStream(resultFile);
@@ -383,9 +411,10 @@ static void forgetActivity() {
           } catch (IOException | ClassNotFoundException e) {
             // Likely a change in the serializable result class.
             // Let's remove the files, we can't read them anymore.
-            file.delete();
+            heapDumpFile.delete();
             resultFile.delete();
-            Log.e(TAG, "Could not read result file, deleted result and heap dump:" + file, e);
+            Log.e(TAG, "Could not read result file, deleted result and heap dump:" + heapDumpFile,
+                e);
           } finally {
             if (fis != null) {
               try {
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
similarity index 96%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
index fa1c73ac..cb16c7fe 100644
--- a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
@@ -49,14 +49,14 @@
     if (getItemViewType(position) == TOP_ROW) {
       if (convertView == null) {
         convertView =
-            LayoutInflater.from(context).inflate(R.layout.__leak_canary_ref_top_row, parent, false);
+            LayoutInflater.from(context).inflate(R.layout.leak_canary_ref_top_row, parent, false);
       }
       TextView textView = findById(convertView, R.id.__leak_canary_row_text);
       textView.setText(context.getPackageName());
     } else {
       if (convertView == null) {
         convertView =
-            LayoutInflater.from(context).inflate(R.layout.__leak_canary_ref_row, parent, false);
+            LayoutInflater.from(context).inflate(R.layout.leak_canary_ref_row, parent, false);
       }
       TextView textView = findById(convertView, R.id.__leak_canary_row_text);
 
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
new file mode 100644
index 00000000..e854ac2a
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.util.AttributeSet;
+import android.view.View;
+
+import static android.graphics.Bitmap.Config.ARGB_8888;
+
+public final class DisplayLeakConnectorView extends View {
+
+  private static final Paint iconPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+  private static final Paint rootPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+  private static final Paint leakPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+  private static final Paint clearPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+
+  static {
+    iconPaint.setColor(LeakCanaryUi.LIGHT_GREY);
+    rootPaint.setColor(LeakCanaryUi.ROOT_COLOR);
+    leakPaint.setColor(LeakCanaryUi.LEAK_COLOR);
+    clearPaint.setColor(Color.TRANSPARENT);
+    clearPaint.setXfermode(LeakCanaryUi.CLEAR_XFER_MODE);
+  }
+
+  public enum Type {
+    START, NODE, END
+  }
+
+  private Type type;
+  private Bitmap cache;
+
+  public DisplayLeakConnectorView(Context context, AttributeSet attrs) {
+    super(context, attrs);
+
+    type = Type.NODE;
+  }
+
+  @SuppressWarnings("SuspiciousNameCombination") @Override protected void onDraw(Canvas canvas) {
+    int width = getWidth();
+    int height = getHeight();
+
+    if (cache != null && (cache.getWidth() != width || cache.getHeight() != height)) {
+      cache.recycle();
+      cache = null;
+    }
+
+    if (cache == null) {
+      cache = Bitmap.createBitmap(width, height, ARGB_8888);
+
+      Canvas cacheCanvas = new Canvas(cache);
+
+      float halfWidth = width / 2f;
+      float halfHeight = height / 2f;
+      float thirdWidth = width / 3f;
+
+      float strokeSize = LeakCanaryUi.dpToPixel(4f, getResources());
+
+      iconPaint.setStrokeWidth(strokeSize);
+      rootPaint.setStrokeWidth(strokeSize);
+
+      switch (type) {
+        case NODE:
+          cacheCanvas.drawLine(halfWidth, 0, halfWidth, height, iconPaint);
+          cacheCanvas.drawCircle(halfWidth, halfHeight, halfWidth, iconPaint);
+          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, clearPaint);
+          break;
+        case START:
+          float radiusClear = halfWidth - strokeSize / 2f;
+          cacheCanvas.drawRect(0, 0, width, radiusClear, rootPaint);
+          cacheCanvas.drawCircle(0, radiusClear, radiusClear, clearPaint);
+          cacheCanvas.drawCircle(width, radiusClear, radiusClear, clearPaint);
+          cacheCanvas.drawLine(halfWidth, 0, halfWidth, halfHeight, rootPaint);
+          cacheCanvas.drawLine(halfWidth, halfHeight, halfWidth, height, iconPaint);
+          cacheCanvas.drawCircle(halfWidth, halfHeight, halfWidth, iconPaint);
+          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, clearPaint);
+          break;
+        default:
+          cacheCanvas.drawLine(halfWidth, 0, halfWidth, halfHeight, iconPaint);
+          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, leakPaint);
+          break;
+      }
+    }
+    canvas.drawBitmap(cache, 0, 0, null);
+  }
+
+  public void setType(Type type) {
+    if (type != this.type) {
+      this.type = type;
+      if (cache != null) {
+        cache.recycle();
+        cache = null;
+      }
+      invalidate();
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.java
new file mode 100644
index 00000000..8cd6b27f
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+
+public final class FutureResult<T> {
+
+  private final AtomicReference<T> resultHolder;
+  private final CountDownLatch latch;
+
+  public FutureResult() {
+    resultHolder = new AtomicReference<>();
+    latch = new CountDownLatch(1);
+  }
+
+  public boolean wait(long timeout, TimeUnit unit) {
+    try {
+      return latch.await(timeout, unit);
+    } catch (InterruptedException e) {
+      throw new RuntimeException("Did not expect thread to be interrupted", e);
+    }
+  }
+
+  public T get() {
+    if (latch.getCount() > 0) {
+      throw new IllegalStateException("Call wait() and check its result");
+    }
+    return resultHolder.get();
+  }
+
+  public void set(T result) {
+    resultHolder.set(result);
+    latch.countDown();
+  }
+}
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
similarity index 88%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
index 0f134eff..0bcaf9e0 100644
--- a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
@@ -18,14 +18,12 @@
 import android.app.IntentService;
 import android.content.Context;
 import android.content.Intent;
+import android.util.Log;
 import com.squareup.leakcanary.AbstractAnalysisResultService;
 import com.squareup.leakcanary.AnalysisResult;
 import com.squareup.leakcanary.HeapAnalyzer;
 import com.squareup.leakcanary.HeapDump;
 
-import static com.squareup.leakcanary.AndroidExcludedRefs.createAndroidDefaults;
-import static com.squareup.leakcanary.AndroidExcludedRefs.createAppDefaults;
-
 /**
  * This service runs in a separate process to avoid slowing down the app process or making it run
  * out of memory.
@@ -34,6 +32,7 @@
 
   private static final String LISTENER_CLASS_EXTRA = "listener_class_extra";
   private static final String HEAPDUMP_EXTRA = "heapdump_extra";
+  public static final String TAG = "HeapAnalyzerService";
 
   public static void runAnalysis(Context context, HeapDump heapDump,
       Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
@@ -43,16 +42,20 @@ public static void runAnalysis(Context context, HeapDump heapDump,
     context.startService(intent);
   }
 
-  private final HeapAnalyzer heapAnalyzer;
-
   public HeapAnalyzerService() {
     super(HeapAnalyzerService.class.getSimpleName());
-    heapAnalyzer = new HeapAnalyzer(createAndroidDefaults(), createAppDefaults());
   }
 
   @Override protected void onHandleIntent(Intent intent) {
+    if (intent == null) {
+      Log.d(TAG, "HeapAnalyzerService received a null intent, ignoring.");
+      return;
+    }
     String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);
     HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);
+
+    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(heapDump.excludedRefs);
+
     AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);
     AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);
   }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
new file mode 100644
index 00000000..ac8ecba7
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import android.app.ActivityManager;
+import android.app.Service;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ServiceInfo;
+import android.os.Environment;
+import android.util.Log;
+import java.io.File;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+
+import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
+import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
+import static android.content.pm.PackageManager.DONT_KILL_APP;
+import static android.content.pm.PackageManager.GET_SERVICES;
+import static android.os.Environment.DIRECTORY_DOWNLOADS;
+
+public final class LeakCanaryInternals {
+
+  // SDK INT for API 22.
+  public static final int LOLLIPOP_MR1 = 22;
+  public static final String SAMSUNG = "samsung";
+  public static final String MOTOROLA = "motorola";
+  public static final String LG = "LGE";
+  public static final String NVIDIA = "NVIDIA";
+
+  private static final Executor fileIoExecutor = Executors.newSingleThreadExecutor();
+
+  public static void executeOnFileIoThread(Runnable runnable) {
+    fileIoExecutor.execute(runnable);
+  }
+
+  public static File storageDirectory() {
+    File downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS);
+    File leakCanaryDirectory = new File(downloadsDirectory, "leakcanary");
+    leakCanaryDirectory.mkdirs();
+    return leakCanaryDirectory;
+  }
+
+  public static File detectedLeakDirectory() {
+    File directory = new File(storageDirectory(), "detected_leaks");
+    directory.mkdirs();
+    return directory;
+  }
+
+  public static File leakResultFile(File heapdumpFile) {
+    return new File(heapdumpFile.getParentFile(), heapdumpFile.getName() + ".result");
+  }
+
+  public static boolean isExternalStorageWritable() {
+    String state = Environment.getExternalStorageState();
+    return Environment.MEDIA_MOUNTED.equals(state);
+  }
+
+  public static File findNextAvailableHprofFile(int maxFiles) {
+    File directory = detectedLeakDirectory();
+    for (int i = 0; i < maxFiles; i++) {
+      String heapDumpName = "heap_dump_" + i + ".hprof";
+      File file = new File(directory, heapDumpName);
+      if (!file.exists()) {
+        return file;
+      }
+    }
+    return null;
+  }
+
+  /** Extracts the class simple name out of a string containing a fully qualified class name. */
+  public static String classSimpleName(String className) {
+    int separator = className.lastIndexOf('.');
+    if (separator == -1) {
+      return className;
+    } else {
+      return className.substring(separator + 1);
+    }
+  }
+
+  public static void setEnabled(Context context, final Class<?> componentClass,
+      final boolean enabled) {
+    final Context appContext = context.getApplicationContext();
+    executeOnFileIoThread(new Runnable() {
+      @Override public void run() {
+        ComponentName component = new ComponentName(appContext, componentClass);
+        PackageManager packageManager = appContext.getPackageManager();
+        int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED;
+        // Blocks on IPC.
+        packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);
+      }
+    });
+  }
+
+  public static boolean isInServiceProcess(Context context, Class<? extends Service> serviceClass) {
+    PackageManager packageManager = context.getPackageManager();
+    PackageInfo packageInfo;
+    try {
+      packageInfo = packageManager.getPackageInfo(context.getPackageName(), GET_SERVICES);
+    } catch (Exception e) {
+      Log.e("AndroidUtils", "Could not get package info for " + context.getPackageName(), e);
+      return false;
+    }
+    String mainProcess = packageInfo.applicationInfo.processName;
+
+    ComponentName component = new ComponentName(context, serviceClass);
+    ServiceInfo serviceInfo;
+    try {
+      serviceInfo = packageManager.getServiceInfo(component, 0);
+    } catch (PackageManager.NameNotFoundException ignored) {
+      // Service is disabled.
+      return false;
+    }
+
+    if (serviceInfo.processName.equals(mainProcess)) {
+      Log.e("AndroidUtils",
+          "Did not expect service " + serviceClass + " to run in main process " + mainProcess);
+      // Technically we are in the service process, but we're not in the service dedicated process.
+      return false;
+    }
+
+    int myPid = android.os.Process.myPid();
+    ActivityManager activityManager =
+        (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+    ActivityManager.RunningAppProcessInfo myProcess = null;
+    for (ActivityManager.RunningAppProcessInfo process : activityManager.getRunningAppProcesses()) {
+      if (process.pid == myPid) {
+        myProcess = process;
+        break;
+      }
+    }
+    if (myProcess == null) {
+      Log.e("AndroidUtils", "Could not find running process for " + myPid);
+      return false;
+    }
+
+    return myProcess.processName.equals(serviceInfo.processName);
+  }
+
+  private LeakCanaryInternals() {
+    throw new AssertionError();
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java
new file mode 100644
index 00000000..74fbf986
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import android.content.res.Resources;
+import android.graphics.PorterDuffXfermode;
+import android.util.DisplayMetrics;
+
+import static android.graphics.PorterDuff.Mode.CLEAR;
+
+final class LeakCanaryUi {
+  static final int LIGHT_GREY = 0xFFbababa;
+  static final int ROOT_COLOR = 0xFF84a6c5;
+  static final int LEAK_COLOR = 0xFFb1554e;
+
+  static final PorterDuffXfermode CLEAR_XFER_MODE = new PorterDuffXfermode(CLEAR);
+
+  /**
+   * Converts from device independent pixels (dp or dip) to
+   * device dependent pixels. This method returns the input
+   * multiplied by the display's density. The result is not
+   * rounded nor clamped.
+   *
+   * The value returned by this method is well suited for
+   * drawing with the Canvas API but should not be used to
+   * set layout dimensions.
+   *
+   * @param dp The value in dp to convert to pixels
+   * @param resources An instances of Resources
+   */
+  static float dpToPixel(float dp, Resources resources) {
+    DisplayMetrics metrics = resources.getDisplayMetrics();
+    return metrics.density * dp;
+  }
+
+  private LeakCanaryUi() {
+    throw new AssertionError();
+  }
+}
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
similarity index 74%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
index 556fe147..81bf8a0f 100644
--- a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
@@ -16,27 +16,24 @@
 package com.squareup.leakcanary.internal;
 
 import android.content.Context;
-import android.content.res.Resources;
 import android.graphics.Canvas;
 import android.graphics.Paint;
 import android.util.AttributeSet;
-import android.util.DisplayMetrics;
 import android.view.View;
 
-import static com.squareup.leakcanary.internal.DisplayLeakConnectorView.ROOT_COLOR;
-
 public final class MoreDetailsView extends View {
 
-  private final Paint iconPaint;
+  private static final Paint iconPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+
+  static {
+    iconPaint.setColor(LeakCanaryUi.ROOT_COLOR);
+  }
 
   public MoreDetailsView(Context context, AttributeSet attrs) {
     super(context, attrs);
 
-    float strokeSize = dpToPixel(2, getResources());
-    iconPaint = new Paint();
-    iconPaint.setColor(ROOT_COLOR);
+    float strokeSize = LeakCanaryUi.dpToPixel(2f, getResources());
     iconPaint.setStrokeWidth(strokeSize);
-    iconPaint.setAntiAlias(true);
   }
 
   private boolean opened;
@@ -61,10 +58,4 @@ public void setOpened(boolean opened) {
       invalidate();
     }
   }
-
-  static float dpToPixel(float dp, Resources resources) {
-    DisplayMetrics metrics = resources.getDisplayMetrics();
-    float px = dp * (metrics.densityDpi / 160f);
-    return px;
-  }
 }
diff --git a/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png
new file mode 100755
index 00000000..f1049229
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png
new file mode 100755
index 00000000..7e375c54
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png
new file mode 100755
index 00000000..09c78cc0
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png
new file mode 100755
index 00000000..d29b9f1d
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png
new file mode 100755
index 00000000..f354c3f2
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png
new file mode 100755
index 00000000..c825fa4a
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png
new file mode 100755
index 00000000..d0cdbcd8
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png
new file mode 100755
index 00000000..a5e85b41
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png
new file mode 100755
index 00000000..b2978d57
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png
new file mode 100755
index 00000000..0194b4e1
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png
new file mode 100755
index 00000000..3d4b76af
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png
new file mode 100755
index 00000000..22db2020
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png
new file mode 100755
index 00000000..05141619
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png
new file mode 100755
index 00000000..eb9c0724
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png
new file mode 100755
index 00000000..34b76141
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable/leak_canary_toast_background.xml b/leakcanary-android/src/main/res/drawable/leak_canary_toast_background.xml
new file mode 100644
index 00000000..a90b8c2c
--- /dev/null
+++ b/leakcanary-android/src/main/res/drawable/leak_canary_toast_background.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android">
+  <solid android:color="#cc000000"/>
+  <corners android:radius="16dp"/>
+</shape>
\ No newline at end of file
diff --git a/library/leakcanary-android/src/main/res/layout/__leak_canary_display_leak.xml b/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
similarity index 84%
rename from library/leakcanary-android/src/main/res/layout/__leak_canary_display_leak.xml
rename to leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
index 3a40ce25..d9d312e0 100644
--- a/library/leakcanary-android/src/main/res/layout/__leak_canary_display_leak.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
@@ -28,7 +28,14 @@
       android:dividerHeight="0dp"
       android:divider="@null"
       />
-
+  <TextView
+      android:id="@+id/__leak_canary_display_leak_failure"
+      android:layout_width="match_parent"
+      android:layout_height="0dp"
+      android:layout_weight="1"
+      android:textSize="12sp"
+      android:visibility="gone"
+      />
   <Button
       android:id="@+id/__leak_canary_action"
       android:layout_width="match_parent"
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml b/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml
new file mode 100644
index 00000000..d6057ed2
--- /dev/null
+++ b/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:orientation="vertical"
+    android:background="@drawable/leak_canary_toast_background"
+    android:padding="16dp"
+    >
+  <ImageView
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_gravity="center_horizontal"
+      android:src="@drawable/leak_canary_icon"/>
+
+  <TextView
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_gravity="center_horizontal"
+      android:textColor="#ffffff"
+      android:textSize="18sp"
+      android:text="@string/leak_canary_toast_heap_dump"
+      />
+
+</LinearLayout>
diff --git a/library/leakcanary-android/src/main/res/layout/__leak_canary_leak_row.xml b/leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml
similarity index 100%
rename from library/leakcanary-android/src/main/res/layout/__leak_canary_leak_row.xml
rename to leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml
diff --git a/library/leakcanary-android/src/main/res/layout/__leak_canary_ref_row.xml b/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
similarity index 100%
rename from library/leakcanary-android/src/main/res/layout/__leak_canary_ref_row.xml
rename to leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
diff --git a/library/leakcanary-android/src/main/res/layout/__leak_canary_ref_top_row.xml b/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
similarity index 100%
rename from library/leakcanary-android/src/main/res/layout/__leak_canary_ref_top_row.xml
rename to leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
diff --git a/library/leakcanary-android/src/main/res/values-v14/__leak_canary_themes.xml b/leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml
similarity index 88%
rename from library/leakcanary-android/src/main/res/values-v14/__leak_canary_themes.xml
rename to leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml
index c59e71e1..409cb66b 100644
--- a/library/leakcanary-android/src/main/res/values-v14/__leak_canary_themes.xml
+++ b/leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml
@@ -15,6 +15,6 @@
   ~ limitations under the License.
   -->
 <resources>
-  <style name="__LeakCanary.Base" parent="android:Theme.Holo">
+  <style name="leak_canary_LeakCanary.Base" parent="android:Theme.Holo">
   </style>
 </resources>
\ No newline at end of file
diff --git a/library/leakcanary-android/src/main/res/values-v21/__leak_canary_themes.xml b/leakcanary-android/src/main/res/values-v21/leak_canary_themes.xml
similarity index 88%
rename from library/leakcanary-android/src/main/res/values-v21/__leak_canary_themes.xml
rename to leakcanary-android/src/main/res/values-v21/leak_canary_themes.xml
index 0a8dbbfc..0a43b8f9 100644
--- a/library/leakcanary-android/src/main/res/values-v21/__leak_canary_themes.xml
+++ b/leakcanary-android/src/main/res/values-v21/leak_canary_themes.xml
@@ -15,6 +15,6 @@
   ~ limitations under the License.
   -->
 <resources>
-  <style name="__LeakCanary.Base" parent="android:Theme.Material">
+  <style name="leak_canary_LeakCanary.Base" parent="android:Theme.Material">
   </style>
 </resources>
\ No newline at end of file
diff --git a/library/leakcanary-android/src/main/res/values/__leak_canary_int.xml b/leakcanary-android/src/main/res/values/leak_canary_int.xml
similarity index 90%
rename from library/leakcanary-android/src/main/res/values/__leak_canary_int.xml
rename to leakcanary-android/src/main/res/values/leak_canary_int.xml
index 8811d1fc..3d2c5ac0 100644
--- a/library/leakcanary-android/src/main/res/values/__leak_canary_int.xml
+++ b/leakcanary-android/src/main/res/values/leak_canary_int.xml
@@ -15,5 +15,5 @@
   ~ limitations under the License.
   -->
 <resources>
-  <integer name="__leak_canary_max_stored_leaks">7</integer>
+  <integer name="leak_canary_max_stored_leaks">7</integer>
 </resources>
\ No newline at end of file
diff --git a/leakcanary-android/src/main/res/values/leak_canary_strings.xml b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
new file mode 100644
index 00000000..e0600ff2
--- /dev/null
+++ b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+
+  <string name="leak_canary_class_has_leaked">%s has leaked</string>
+  <string name="leak_canary_class_leak_ignored">Ignored %s leak</string>
+  <string name="leak_canary_analysis_failed">Leak analysis failed</string>
+  <string name="leak_canary_leak_list_title">Leaks in %s</string>
+  <string name="leak_canary_notification_leak_ignored_message">Click to see previous leaks</string>
+  <string name="leak_canary_notification_message">Click for more details</string>
+  <string name="leak_canary_share_leak">Share info</string>
+  <string name="leak_canary_share_heap_dump">Share heap dump</string>
+  <string name="leak_canary_share_with">Share with…</string>
+  <string name="leak_canary_display_activity_label">Leaks</string>
+  <string name="leak_canary_toast_heap_dump">Dumping memory, app will freeze. Brrrr.</string>
+  <string name="leak_canary_delete">Delete</string>
+  <string name="leak_canary_failure_report">"Please report this failure to http://github.com/square/leakcanary\n"</string>
+  <string name="leak_canary_delete_all">Delete all</string>
+
+</resources>
\ No newline at end of file
diff --git a/library/leakcanary-android/src/main/res/values/__leak_canary_themes.xml b/leakcanary-android/src/main/res/values/leak_canary_themes.xml
similarity index 89%
rename from library/leakcanary-android/src/main/res/values/__leak_canary_themes.xml
rename to leakcanary-android/src/main/res/values/leak_canary_themes.xml
index 21df5844..69a56edb 100644
--- a/library/leakcanary-android/src/main/res/values/__leak_canary_themes.xml
+++ b/leakcanary-android/src/main/res/values/leak_canary_themes.xml
@@ -15,6 +15,6 @@
   ~ limitations under the License.
   -->
 <resources>
-  <style name="__LeakCanary.Base" parent="android:Theme">
+  <style name="leak_canary_LeakCanary.Base" parent="android:Theme">
   </style>
 </resources>
\ No newline at end of file
diff --git a/library/leakcanary-sample/build.gradle b/leakcanary-sample/build.gradle
similarity index 88%
rename from library/leakcanary-sample/build.gradle
rename to leakcanary-sample/build.gradle
index 512049b5..d80081b8 100644
--- a/library/leakcanary-sample/build.gradle
+++ b/leakcanary-sample/build.gradle
@@ -1,9 +1,3 @@
-buildscript {
-  dependencies {
-    classpath rootProject.ext.androidPlugin
-  }
-}
-
 apply plugin: 'com.android.application'
 
 dependencies {
diff --git a/library/leakcanary-sample/src/main/AndroidManifest.xml b/leakcanary-sample/src/main/AndroidManifest.xml
similarity index 100%
rename from library/leakcanary-sample/src/main/AndroidManifest.xml
rename to leakcanary-sample/src/main/AndroidManifest.xml
diff --git a/library/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
similarity index 65%
rename from library/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
rename to leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
index 220e05ec..942be776 100644
--- a/library/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
@@ -16,21 +16,27 @@
 package com.example.leakcanary;
 
 import android.app.Application;
-import android.content.Context;
+import android.os.StrictMode;
 import com.squareup.leakcanary.LeakCanary;
-import com.squareup.leakcanary.RefWatcher;
 
-public class ExampleApplication extends Application {
-
-  public static RefWatcher getRefWatcher(Context context) {
-    ExampleApplication application = (ExampleApplication) context.getApplicationContext();
-    return application.refWatcher;
-  }
+import static android.os.Build.VERSION.SDK_INT;
+import static android.os.Build.VERSION_CODES.GINGERBREAD;
 
-  private RefWatcher refWatcher;
+public class ExampleApplication extends Application {
 
   @Override public void onCreate() {
     super.onCreate();
-    refWatcher = LeakCanary.install(this);
+    enabledStrictMode();
+    LeakCanary.install(this);
+  }
+
+  private void enabledStrictMode() {
+    if (SDK_INT >= GINGERBREAD) {
+      StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() //
+          .detectAll() //
+          .penaltyLog() //
+          .penaltyDeath() //
+          .build());
+    }
   }
 }
diff --git a/library/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
similarity index 100%
rename from library/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
rename to leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
diff --git a/library/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png
similarity index 100%
rename from library/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png
rename to leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png
diff --git a/library/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png
similarity index 100%
rename from library/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png
rename to leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png
diff --git a/library/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png
similarity index 100%
rename from library/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png
rename to leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png
diff --git a/library/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png
similarity index 100%
rename from library/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png
rename to leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png
diff --git a/library/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png
similarity index 100%
rename from library/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png
rename to leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png
diff --git a/library/leakcanary-sample/src/main/res/layout/main_activity.xml b/leakcanary-sample/src/main/res/layout/main_activity.xml
similarity index 100%
rename from library/leakcanary-sample/src/main/res/layout/main_activity.xml
rename to leakcanary-sample/src/main/res/layout/main_activity.xml
diff --git a/library/leakcanary-sample/src/main/res/values/strings.xml b/leakcanary-sample/src/main/res/values/strings.xml
similarity index 100%
rename from library/leakcanary-sample/src/main/res/values/strings.xml
rename to leakcanary-sample/src/main/res/values/strings.xml
diff --git a/library/leakcanary-watcher/build.gradle b/leakcanary-watcher/build.gradle
similarity index 100%
rename from library/leakcanary-watcher/build.gradle
rename to leakcanary-watcher/build.gradle
diff --git a/library/leakcanary-watcher/gradle.properties b/leakcanary-watcher/gradle.properties
similarity index 100%
rename from library/leakcanary-watcher/gradle.properties
rename to leakcanary-watcher/gradle.properties
diff --git a/library/leakcanary-watcher/src/main/AndroidManifest.xml b/leakcanary-watcher/src/main/AndroidManifest.xml
similarity index 100%
rename from library/leakcanary-watcher/src/main/AndroidManifest.xml
rename to leakcanary-watcher/src/main/AndroidManifest.xml
diff --git a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/DebuggerControl.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/DebuggerControl.java
similarity index 100%
rename from library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/DebuggerControl.java
rename to leakcanary-watcher/src/main/java/com/squareup/leakcanary/DebuggerControl.java
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
new file mode 100644
index 00000000..9d2dfec4
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import java.io.Serializable;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import static com.squareup.leakcanary.Preconditions.checkNotNull;
+import static java.util.Collections.unmodifiableMap;
+
+/**
+ * Prevents specific references from being taken into account when computing the shortest strong
+ * reference path from a suspected leaking instance to the GC roots.
+ *
+ * This class lets you ignore known memory leaks that you known about. If the shortest path
+ * matches {@link ExcludedRefs}, than the heap analyzer should look for a longer path with nothing
+ * matching in {@link ExcludedRefs}.
+ */
+public final class ExcludedRefs implements Serializable {
+
+  public final Map<String, Map<String, Boolean>> fieldNameByClassName;
+  public final Map<String, Map<String, Boolean>> staticFieldNameByClassName;
+  public final Map<String, Boolean> threadNames;
+  public final Map<String, Boolean> classNames;
+
+  private ExcludedRefs(Map<String, Map<String, Boolean>> fieldNameByClassName,
+      Map<String, Map<String, Boolean>> staticFieldNameByClassName,
+      Map<String, Boolean> threadNames, Map<String, Boolean> classNames) {
+    // Copy + unmodifiable.
+    this.fieldNameByClassName = unmodifiableMap(new LinkedHashMap<>(fieldNameByClassName));
+    this.staticFieldNameByClassName =
+        unmodifiableMap(new LinkedHashMap<>(staticFieldNameByClassName));
+    this.threadNames = unmodifiableMap(new LinkedHashMap<>(threadNames));
+    this.classNames = unmodifiableMap(new LinkedHashMap<>(classNames));
+  }
+
+  @Override public String toString() {
+    String string = "";
+    for (Map.Entry<String, Map<String, Boolean>> classes : fieldNameByClassName.entrySet()) {
+      String clazz = classes.getKey();
+      for (Map.Entry<String, Boolean> field : classes.getValue().entrySet()) {
+        String always = field.getValue() ? " (always)" : "";
+        string += "| Field: " + clazz + "." + field.getKey() + always + "\n";
+      }
+    }
+    for (Map.Entry<String, Map<String, Boolean>> classes : staticFieldNameByClassName.entrySet()) {
+      String clazz = classes.getKey();
+      for (Map.Entry<String, Boolean> field : classes.getValue().entrySet()) {
+        String always = field.getValue() ? " (always)" : "";
+        string += "| Static field: " + clazz + "." + field.getKey() + always + "\n";
+      }
+    }
+    for (Map.Entry<String, Boolean> thread : threadNames.entrySet()) {
+      String always = thread.getValue() ? " (always)" : "";
+      string += "| Thread:" + thread.getKey() + always + "\n";
+    }
+    for (Map.Entry<String, Boolean> clazz : classNames.entrySet()) {
+      String always = clazz.getValue() ? " (always)" : "";
+      string += "| Class:" + clazz.getKey() + always + "\n";
+    }
+    return string;
+  }
+
+  public static final class Builder {
+    private final Map<String, Map<String, Boolean>> fieldNameByClassName = new LinkedHashMap<>();
+    private final Map<String, Map<String, Boolean>> staticFieldNameByClassName =
+        new LinkedHashMap<>();
+    private final Map<String, Boolean> threadNames = new LinkedHashMap<>();
+    private final Map<String, Boolean> classNames = new LinkedHashMap<>();
+
+    public Builder instanceField(String className, String fieldName) {
+      return instanceField(className, fieldName, false);
+    }
+
+    public Builder instanceField(String className, String fieldName, boolean always) {
+      checkNotNull(className, "className");
+      checkNotNull(fieldName, "fieldName");
+      Map<String, Boolean> excludedFields = fieldNameByClassName.get(className);
+      if (excludedFields == null) {
+        excludedFields = new LinkedHashMap<>();
+        fieldNameByClassName.put(className, excludedFields);
+      }
+      excludedFields.put(fieldName, always);
+      return this;
+    }
+
+    public Builder staticField(String className, String fieldName) {
+      return staticField(className, fieldName, false);
+    }
+
+    public Builder staticField(String className, String fieldName, boolean always) {
+      checkNotNull(className, "className");
+      checkNotNull(fieldName, "fieldName");
+      Map<String, Boolean> excludedFields = staticFieldNameByClassName.get(className);
+      if (excludedFields == null) {
+        excludedFields = new LinkedHashMap<>();
+        staticFieldNameByClassName.put(className, excludedFields);
+      }
+      excludedFields.put(fieldName, always);
+      return this;
+    }
+
+    public Builder thread(String threadName) {
+      return thread(threadName, false);
+    }
+
+    public Builder thread(String threadName, boolean always) {
+      checkNotNull(threadName, "threadName");
+      threadNames.put(threadName, always);
+      return this;
+    }
+
+    public Builder clazz(String className) {
+      return thread(className, false);
+    }
+
+    public Builder clazz(String className, boolean always) {
+      checkNotNull(className, "className");
+      classNames.put(className, always);
+      return this;
+    }
+
+    public ExcludedRefs build() {
+      return new ExcludedRefs(fieldNameByClassName, staticFieldNameByClassName, threadNames,
+          classNames);
+    }
+  }
+}
diff --git a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
similarity index 100%
rename from library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
rename to leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
diff --git a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
similarity index 84%
rename from library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
rename to leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
index e2a906d4..2423dc9b 100644
--- a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
@@ -43,16 +43,20 @@
    */
   public final String referenceName;
 
+  /** References that should be ignored when analyzing this heap dump. */
+  public final ExcludedRefs excludedRefs;
+
   /** Time from the request to watch the reference until the GC was triggered. */
   public final long watchDurationMs;
   public final long gcDurationMs;
   public final long heapDumpDurationMs;
 
   public HeapDump(File heapDumpFile, String referenceKey, String referenceName,
-      long watchDurationMs, long gcDurationMs, long heapDumpDurationMs) {
+      ExcludedRefs excludedRefs, long watchDurationMs, long gcDurationMs, long heapDumpDurationMs) {
     this.heapDumpFile = checkNotNull(heapDumpFile, "heapDumpFile");
     this.referenceKey = checkNotNull(referenceKey, "referenceKey");
     this.referenceName = checkNotNull(referenceName, "referenceName");
+    this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
     this.watchDurationMs = watchDurationMs;
     this.gcDurationMs = gcDurationMs;
     this.heapDumpDurationMs = heapDumpDurationMs;
@@ -61,7 +65,7 @@ public HeapDump(File heapDumpFile, String referenceKey, String referenceName,
   /** Renames the heap dump file and creates a new {@link HeapDump} pointing to it. */
   public HeapDump renameFile(File newFile) {
     heapDumpFile.renameTo(newFile);
-    return new HeapDump(newFile, referenceKey, referenceName, watchDurationMs, gcDurationMs,
-        heapDumpDurationMs);
+    return new HeapDump(newFile, referenceKey, referenceName, excludedRefs, watchDurationMs,
+        gcDurationMs, heapDumpDurationMs);
   }
 }
diff --git a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
similarity index 82%
rename from library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
rename to leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
index 1bd3c4c2..715d089a 100644
--- a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
@@ -19,6 +19,11 @@
 
 public interface HeapDumper {
 
-  /** @return a {@link File} referencing the heap dump, or null if the heap could not be dumped. */
+  File NO_DUMP = null;
+
+  /**
+   * @return a {@link File} referencing the heap dump, or {@link #NO_DUMP} if the heap could not be
+   * dumped.
+   */
   File dumpHeap();
 }
\ No newline at end of file
diff --git a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java
similarity index 100%
rename from library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java
rename to leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java
diff --git a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Preconditions.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Preconditions.java
similarity index 100%
rename from library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Preconditions.java
rename to leakcanary-watcher/src/main/java/com/squareup/leakcanary/Preconditions.java
diff --git a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
similarity index 92%
rename from library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
rename to leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
index 6f3ea0d2..7d2b9fc4 100644
--- a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
@@ -48,7 +48,7 @@
   }, new HeapDump.Listener() {
     @Override public void analyze(HeapDump heapDump) {
     }
-  });
+  }, new ExcludedRefs.Builder().build());
 
   private final Executor watchExecutor;
   private final DebuggerControl debuggerControl;
@@ -57,20 +57,23 @@
   private final Set<String> retainedKeys;
   private final ReferenceQueue<Object> queue;
   private final HeapDump.Listener heapdumpListener;
+  private final ExcludedRefs excludedRefs;
 
   public RefWatcher(Executor watchExecutor, DebuggerControl debuggerControl, GcTrigger gcTrigger,
-      HeapDumper heapDumper, HeapDump.Listener heapdumpListener) {
+      HeapDumper heapDumper, HeapDump.Listener heapdumpListener, ExcludedRefs excludedRefs) {
     this.watchExecutor = checkNotNull(watchExecutor, "watchExecutor");
     this.debuggerControl = checkNotNull(debuggerControl, "debuggerControl");
     this.gcTrigger = checkNotNull(gcTrigger, "gcTrigger");
     this.heapDumper = checkNotNull(heapDumper, "heapDumper");
     this.heapdumpListener = checkNotNull(heapdumpListener, "heapdumpListener");
+    this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
     retainedKeys = new CopyOnWriteArraySet<>();
     queue = new ReferenceQueue<>();
   }
 
   /**
    * Identical to {@link #watch(Object, String)} with an empty string reference name.
+   *
    * @see #watch(Object, String)
    */
   public void watch(Object watchedReference) {
@@ -118,14 +121,14 @@ void ensureGone(KeyedWeakReference reference, long watchStartNanoTime) {
 
       File heapDumpFile = heapDumper.dumpHeap();
 
-      if (heapDumpFile == null) {
+      if (heapDumpFile == HeapDumper.NO_DUMP) {
         // Could not dump the heap, abort.
         return;
       }
       long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);
       heapdumpListener.analyze(
-          new HeapDump(heapDumpFile, reference.key, reference.name, watchDurationMs, gcDurationMs,
-              heapDumpDurationMs));
+          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,
+              gcDurationMs, heapDumpDurationMs));
     }
   }
 
diff --git a/library/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java b/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
similarity index 82%
rename from library/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
rename to leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
index f93e8fd3..421ceea0 100644
--- a/library/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
+++ b/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
@@ -19,13 +19,13 @@
 import java.util.concurrent.Executor;
 import org.junit.Test;
 
-import static com.squareup.leakcanary.DebuggerControl.NONE;
-import static com.squareup.leakcanary.GcTrigger.DEFAULT;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 public class RefWatcherTest {
 
+  static final ExcludedRefs NO_REF = new ExcludedRefs.Builder().build();
+
   static class TestDumper implements HeapDumper {
     boolean called;
 
@@ -44,10 +44,11 @@
 
   static class TestExecutor implements Executor {
     private Runnable command;
+
     @Override public void execute(Runnable command) {
       this.command = command;
     }
-  };
+  }
 
   /**
    * In theory, this test doesn't have a 100% chance of success. In practice, {@link
@@ -56,7 +57,7 @@
   @Test public void unreachableObject_noDump() {
     TestDumper dumper = new TestDumper();
     TestExecutor executor = new TestExecutor();
-    RefWatcher refWatcher = new RefWatcher(executor, NONE, DEFAULT, dumper, new TestListener());
+    RefWatcher refWatcher = defaultWatcher(dumper, executor);
     refWatcher.watch(new Object());
     executor.command.run();
     assertFalse(dumper.called);
@@ -65,10 +66,15 @@
   @Test public void retainedObject_triggersDump() {
     TestDumper dumper = new TestDumper();
     TestExecutor executor = new TestExecutor();
-    RefWatcher refWatcher = new RefWatcher(executor, NONE, DEFAULT, dumper, new TestListener());
+    RefWatcher refWatcher = defaultWatcher(dumper, executor);
     ref = new Object();
     refWatcher.watch(ref);
     executor.command.run();
     assertTrue(dumper.called);
   }
+
+  private RefWatcher defaultWatcher(TestDumper dumper, TestExecutor executor) {
+    return new RefWatcher(executor, DebuggerControl.NONE, GcTrigger.DEFAULT, dumper,
+        new TestListener(), NO_REF);
+  }
 }
diff --git a/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ExcludedRefs.java b/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
deleted file mode 100644
index a5b25272..00000000
--- a/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-
-/**
- * Prevents specific references from being taken into account when computing the shortest strong
- * reference path from a suspected leaking instance to the GC roots.
- *
- * This class lets you ignore known memory leaks that you known about. If the shortest path
- * matches {@link ExcludedRefs}, than the {@link HeapAnalyzer} looks for a longer path with nothing
- * matching in {@link ExcludedRefs}.
- */
-public final class ExcludedRefs {
-
-  final Map<String, Set<String>> excludeFieldMap = new LinkedHashMap<>();
-  final Map<String, Set<String>> excludeStaticFieldMap = new LinkedHashMap<>();
-  final Set<String> excludedThreads = new LinkedHashSet<>();
-
-  public void instanceField(String className, String fieldName) {
-    checkNotNull(className, "className");
-    checkNotNull(fieldName, "fieldName");
-    Set<String> excludedFields = excludeFieldMap.get(className);
-    if (excludedFields == null) {
-      excludedFields = new LinkedHashSet<>();
-      excludeFieldMap.put(className, excludedFields);
-    }
-    excludedFields.add(fieldName);
-  }
-
-  public void staticField(String className, String fieldName) {
-    checkNotNull(className, "className");
-    checkNotNull(fieldName, "fieldName");
-    Set<String> excludedFields = excludeStaticFieldMap.get(className);
-    if (excludedFields == null) {
-      excludedFields = new LinkedHashSet<>();
-      excludeStaticFieldMap.put(className, excludedFields);
-    }
-    excludedFields.add(fieldName);
-  }
-
-  public void thread(String threadName) {
-    checkNotNull(threadName, "threadName");
-    excludedThreads.add(threadName);
-  }
-}
diff --git a/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
deleted file mode 100644
index 3e8e775a..00000000
--- a/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ /dev/null
@@ -1,348 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.File;
-import java.io.FileFilter;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import org.eclipse.mat.SnapshotException;
-import org.eclipse.mat.parser.internal.SnapshotFactory;
-import org.eclipse.mat.snapshot.IPathsFromGCRootsComputer;
-import org.eclipse.mat.snapshot.ISnapshot;
-import org.eclipse.mat.snapshot.PathsFromGCRootsTree;
-import org.eclipse.mat.snapshot.model.IArray;
-import org.eclipse.mat.snapshot.model.IClass;
-import org.eclipse.mat.snapshot.model.IObject;
-import org.eclipse.mat.snapshot.model.NamedReference;
-import org.eclipse.mat.snapshot.model.PrettyPrinter;
-import org.eclipse.mat.snapshot.model.ThreadToLocalReference;
-import org.eclipse.mat.util.VoidProgressListener;
-
-import static com.squareup.leakcanary.AnalysisResult.failure;
-import static com.squareup.leakcanary.AnalysisResult.leakDetected;
-import static com.squareup.leakcanary.AnalysisResult.noLeak;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.OBJECT;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.INSTANCE_FIELD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.LOCAL;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-import static java.lang.Integer.MAX_VALUE;
-import static java.util.Collections.emptyMap;
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-
-/**
- * Analyzes heap dumps generated by a {@link RefWatcher} to verify if suspected leaks are real.
- */
-public final class HeapAnalyzer {
-
-  private static final String ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$";
-
-  private final ExcludedRefs baseExcludedRefs;
-  private final ExcludedRefs excludedRefs;
-
-  public HeapAnalyzer(ExcludedRefs excludedRefs) {
-    this(new ExcludedRefs(), excludedRefs);
-  }
-
-  public HeapAnalyzer(ExcludedRefs baseExcludedRefs, ExcludedRefs excludedRefs) {
-    this.baseExcludedRefs = baseExcludedRefs;
-    this.excludedRefs = excludedRefs;
-  }
-
-  /**
-   * Searches the heap dump for a {@link KeyedWeakReference} instance with the corresponding key,
-   * and then computes the shortest strong reference path from that instance to the GC roots.
-   */
-  public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
-    long analysisStartNanoTime = System.nanoTime();
-
-    if (!heapDumpFile.exists()) {
-      Exception exception = new IllegalArgumentException("File does not exist: " + heapDumpFile);
-      return failure(exception, since(analysisStartNanoTime));
-    }
-
-    ISnapshot snapshot = null;
-    try {
-      snapshot = openSnapshot(heapDumpFile);
-
-      IObject leakingRef = findLeakingReference(referenceKey, snapshot);
-
-      // False alarm, weak reference was cleared in between key check and heap dump.
-      if (leakingRef == null) {
-        return noLeak(since(analysisStartNanoTime));
-      }
-
-      String className = leakingRef.getClazz().getName();
-
-      AnalysisResult result =
-          findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, className, true);
-
-      if (!result.leakFound) {
-        result = findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, className, false);
-      }
-
-      return result;
-    } catch (SnapshotException e) {
-      return failure(e, since(analysisStartNanoTime));
-    } finally {
-      cleanup(heapDumpFile, snapshot);
-    }
-  }
-
-  private AnalysisResult findLeakTrace(long analysisStartNanoTime, ISnapshot snapshot,
-      IObject leakingRef, String className, boolean excludingKnownLeaks) throws SnapshotException {
-
-    ExcludedRefs excludedRefs = excludingKnownLeaks ? this.excludedRefs : baseExcludedRefs;
-
-    PathsFromGCRootsTree gcRootsTree = shortestPathToGcRoots(snapshot, leakingRef, excludedRefs);
-
-    // False alarm, no strong reference path to GC Roots.
-    if (gcRootsTree == null) {
-      return noLeak(since(analysisStartNanoTime));
-    }
-
-    LeakTrace leakTrace = buildLeakTrace(snapshot, gcRootsTree, excludedRefs);
-
-    return leakDetected(!excludingKnownLeaks, className, leakTrace, since(analysisStartNanoTime));
-  }
-
-  private ISnapshot openSnapshot(File heapDumpFile) throws SnapshotException {
-    SnapshotFactory factory = new SnapshotFactory();
-    Map<String, String> args = emptyMap();
-    VoidProgressListener listener = new VoidProgressListener();
-    return factory.openSnapshot(heapDumpFile, args, listener);
-  }
-
-  private IObject findLeakingReference(String key, ISnapshot snapshot) throws SnapshotException {
-    Collection<IClass> refClasses =
-        snapshot.getClassesByName(KeyedWeakReference.class.getName(), false);
-
-    if (refClasses.size() != 1) {
-      throw new IllegalStateException(
-          "Expecting one class for " + KeyedWeakReference.class.getName() + " in " + refClasses);
-    }
-
-    IClass refClass = refClasses.iterator().next();
-
-    int[] weakRefInstanceIds = refClass.getObjectIds();
-
-    for (int weakRefInstanceId : weakRefInstanceIds) {
-      IObject weakRef = snapshot.getObject(weakRefInstanceId);
-      String keyCandidate =
-          PrettyPrinter.objectAsString((IObject) weakRef.resolveValue("key"), 100);
-      if (keyCandidate.equals(key)) {
-        return (IObject) weakRef.resolveValue("referent");
-      }
-    }
-    throw new IllegalStateException("Could not find weak reference with key " + key);
-  }
-
-  private PathsFromGCRootsTree shortestPathToGcRoots(ISnapshot snapshot, IObject leakingRef,
-      ExcludedRefs excludedRefs) throws SnapshotException {
-    Map<IClass, Set<String>> excludeMap =
-        buildClassExcludeMap(snapshot, excludedRefs.excludeFieldMap);
-
-    IPathsFromGCRootsComputer pathComputer =
-        snapshot.getPathsFromGCRoots(leakingRef.getObjectId(), excludeMap);
-
-    return shortestValidPath(snapshot, pathComputer, excludedRefs);
-  }
-
-  private Map<IClass, Set<String>> buildClassExcludeMap(ISnapshot snapshot,
-      Map<String, Set<String>> excludeMap) throws SnapshotException {
-    Map<IClass, Set<String>> classExcludeMap = new LinkedHashMap<>();
-    for (Map.Entry<String, Set<String>> entry : excludeMap.entrySet()) {
-      Collection<IClass> refClasses = snapshot.getClassesByName(entry.getKey(), false);
-      if (refClasses != null && refClasses.size() == 1) {
-        IClass refClass = refClasses.iterator().next();
-        classExcludeMap.put(refClass, entry.getValue());
-      }
-    }
-    return classExcludeMap;
-  }
-
-  private PathsFromGCRootsTree shortestValidPath(ISnapshot snapshot,
-      IPathsFromGCRootsComputer pathComputer, ExcludedRefs excludedRefs) throws SnapshotException {
-
-    Map<IClass, Set<String>> excludedStaticFields =
-        buildClassExcludeMap(snapshot, excludedRefs.excludeStaticFieldMap);
-
-    int[] shortestPath;
-
-    while ((shortestPath = pathComputer.getNextShortestPath()) != null) {
-      PathsFromGCRootsTree tree = pathComputer.getTree(Collections.singletonList(shortestPath));
-      if (validPath(snapshot, tree, excludedStaticFields, excludedRefs)) {
-        return tree;
-      }
-    }
-    // No more strong reference path.
-    return null;
-  }
-
-  private boolean validPath(ISnapshot snapshot, PathsFromGCRootsTree tree,
-      Map<IClass, Set<String>> excludedStaticFields, ExcludedRefs excludedRefs)
-      throws SnapshotException {
-    if (excludedStaticFields.isEmpty() && excludedRefs.excludedThreads.isEmpty()) {
-      return true;
-    }
-    // Note: the first child is the leaking object, the last child is the GC root.
-    IObject parent = null;
-    while (tree != null) {
-      IObject child = snapshot.getObject(tree.getOwnId());
-      // Static field reference
-      if (child instanceof IClass) {
-        IClass childClass = (IClass) child;
-        Set<String> childClassExcludedFields = excludedStaticFields.get(childClass);
-        if (childClassExcludedFields != null) {
-          NamedReference ref = findChildInParent(parent, child, excludedRefs);
-          if (ref != null && childClassExcludedFields.contains(ref.getName())) {
-            return false;
-          }
-        }
-      } else if (child.getClazz().doesExtend(Thread.class.getName())) {
-        if (excludedRefs.excludedThreads.contains(getThreadName(child))) {
-          return false;
-        }
-      }
-      parent = child;
-      int[] branchIds = tree.getObjectIds();
-      tree = branchIds.length > 0 ? tree.getBranch(branchIds[0]) : null;
-    }
-    return true;
-  }
-
-  private String getThreadName(IObject thread) throws SnapshotException {
-    return PrettyPrinter.objectAsString((IObject) thread.resolveValue("name"), MAX_VALUE);
-  }
-
-  private NamedReference findChildInParent(IObject parent, IObject child, ExcludedRefs excludedRefs)
-      throws SnapshotException {
-    if (parent == null) {
-      return null;
-    }
-    Set<String> excludedFields = excludedRefs.excludeFieldMap.get(child.getClazz().getName());
-    for (NamedReference childRef : child.getOutboundReferences()) {
-      if (childRef.getObjectId() == parent.getObjectId() && (excludedFields == null
-          || !excludedFields.contains(childRef.getName()))) {
-        return childRef;
-      }
-    }
-    return null;
-  }
-
-  private LeakTrace buildLeakTrace(ISnapshot snapshot, PathsFromGCRootsTree tree,
-      ExcludedRefs excludedRefs) throws SnapshotException {
-    List<LeakTraceElement> elements = new ArrayList<>();
-    IObject parent = null;
-    while (tree != null) {
-      IObject child = snapshot.getObject(tree.getOwnId());
-      elements.add(0, buildLeakElement(parent, child, excludedRefs));
-      parent = child;
-      int[] branchIds = tree.getObjectIds();
-      tree = branchIds.length > 0 ? tree.getBranch(branchIds[0]) : null;
-    }
-    return new LeakTrace(elements);
-  }
-
-  private LeakTraceElement buildLeakElement(IObject parent, IObject child,
-      ExcludedRefs excludedRefs) throws SnapshotException {
-    LeakTraceElement.Type type = null;
-    String referenceName = null;
-    NamedReference childRef = findChildInParent(parent, child, excludedRefs);
-    if (childRef != null) {
-      referenceName = childRef.getName();
-      if (child instanceof IClass) {
-        type = STATIC_FIELD;
-      } else if (childRef instanceof ThreadToLocalReference) {
-        type = LOCAL;
-      } else {
-        type = INSTANCE_FIELD;
-      }
-    }
-
-    LeakTraceElement.Holder holder;
-    String className;
-    String extra = null;
-    if (child instanceof IClass) {
-      IClass clazz = (IClass) child;
-      holder = CLASS;
-      className = clazz.getName();
-    } else if (child instanceof IArray) {
-      holder = ARRAY;
-      IClass clazz = child.getClazz();
-      className = clazz.getName();
-    } else {
-      IClass clazz = child.getClazz();
-      className = clazz.getName();
-      if (clazz.doesExtend(Thread.class.getName())) {
-        holder = THREAD;
-        String threadName = getThreadName(child);
-        extra = "(named '" + threadName + "')";
-      } else if (className.matches(ANONYMOUS_CLASS_NAME_PATTERN)) {
-        String parentClassName = clazz.getSuperClass().getName();
-        if (Object.class.getName().equals(parentClassName)) {
-          holder = OBJECT;
-          // This is an anonymous class implementing an interface. The API does not give access
-          // to the interfaces implemented by the class. Let's see if it's in the class path and
-          // use that instead.
-          try {
-            Class<?> actualClass = Class.forName(clazz.getName());
-            Class<?> implementedInterface = actualClass.getInterfaces()[0];
-            extra = "(anonymous class implements " + implementedInterface.getName() + ")";
-          } catch (ClassNotFoundException ignored) {
-          }
-        } else {
-          holder = OBJECT;
-          // Makes it easier to figure out which anonymous class we're looking at.
-          extra = "(anonymous class extends " + parentClassName + ")";
-        }
-      } else {
-        holder = OBJECT;
-      }
-    }
-    return new LeakTraceElement(referenceName, type, holder, className, extra);
-  }
-
-  private void cleanup(File heapDumpFile, ISnapshot snapshot) {
-    if (snapshot != null) {
-      snapshot.dispose();
-    }
-    final String heapDumpFileName = heapDumpFile.getName();
-    final String prefix =
-        heapDumpFileName.substring(0, heapDumpFile.getName().length() - ".hprof".length());
-    File[] toRemove = heapDumpFile.getParentFile().listFiles(new FileFilter() {
-      @Override public boolean accept(File file) {
-        return !file.isDirectory() && file.getName().startsWith(prefix) && !file.getName()
-            .equals(heapDumpFileName);
-      }
-    });
-    for (File file : toRemove) {
-      file.delete();
-    }
-  }
-
-  private long since(long analysisStartNanoTime) {
-    return NANOSECONDS.toMillis(System.nanoTime() - analysisStartNanoTime);
-  }
-}
diff --git a/library/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java b/library/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
deleted file mode 100644
index 494b8393..00000000
--- a/library/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.File;
-import org.junit.Test;
-
-import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-import static org.hamcrest.core.StringContains.containsString;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-
-public class HeapAnalyzerTest {
-
-  static final ExcludedRefs NONE = new ExcludedRefs();
-
-  static final String ASYNC_TASK_THREAD = "AsyncTask #1";
-  static final String ASYNC_TASK_CLASS = "android.os.AsyncTask";
-  static final String EXECUTOR_FIELD = "SERIAL_EXECUTOR";
-
-  @Test public void leakFound() {
-    AnalysisResult result = analyze(new HeapAnalyzer(NONE));
-    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
-    assertTrue(result.leakFound);
-    assertFalse(result.excludedLeak);
-    assertEquals(Thread.class.getName(), gcRoot.className);
-    assertEquals(THREAD, gcRoot.holder);
-    assertThat(gcRoot.extra, containsString(ASYNC_TASK_THREAD));
-  }
-
-  @Test public void excludeThread() {
-    ExcludedRefs excludedRefs = new ExcludedRefs();
-    excludedRefs.thread(ASYNC_TASK_THREAD);
-    AnalysisResult result = analyze(new HeapAnalyzer(excludedRefs));
-    assertTrue(result.leakFound);
-    assertFalse(result.excludedLeak);
-    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
-    assertEquals(ASYNC_TASK_CLASS, gcRoot.className);
-    assertEquals(STATIC_FIELD, gcRoot.type);
-    assertEquals(EXECUTOR_FIELD, gcRoot.referenceName);
-  }
-
-  @Test public void excludeStatic() {
-    ExcludedRefs excludedRefs = new ExcludedRefs();
-    excludedRefs.thread(ASYNC_TASK_THREAD);
-    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD);
-    AnalysisResult result = analyze(new HeapAnalyzer(excludedRefs));
-    assertTrue(result.leakFound);
-    assertTrue(result.excludedLeak);
-  }
-
-  @Test public void excludeStaticForBase() {
-    ExcludedRefs excludedRefs = new ExcludedRefs();
-    excludedRefs.thread(ASYNC_TASK_THREAD);
-    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD);
-    AnalysisResult result = analyze(new HeapAnalyzer(excludedRefs, excludedRefs));
-    assertFalse(result.leakFound);
-  }
-
-  private AnalysisResult analyze(HeapAnalyzer heapAnalyzer) {
-    File heapDumpFile = new File(Thread.currentThread()
-        .getContextClassLoader()
-        .getResource("leak_asynctask.hprof")
-        .getPath());
-    return heapAnalyzer.checkForLeak(heapDumpFile, "dc983a12-d029-4003-8890-7dd644c664c5");
-  }
-}
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java b/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
deleted file mode 100644
index dc72cd3f..00000000
--- a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
+++ /dev/null
@@ -1,237 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import static android.os.Build.MANUFACTURER;
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH;
-import static android.os.Build.VERSION_CODES.JELLY_BEAN;
-import static android.os.Build.VERSION_CODES.KITKAT;
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
-import static com.squareup.leakcanary.AndroidWatchExecutor.LEAK_CANARY_THREAD_NAME;
-
-/**
- * This class is a work in progress. You can help by reporting leak traces that seem to be caused
- * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
- *
- * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
- * manufacturer implementation, they usually share their builds across multiple models, and the
- * leaks eventually get fixed in newer versions.
- */
-public final class AndroidExcludedRefs {
-
-  private static final String SAMSUNG = "samsung";
-  private static final String MOTOROLA = "motorola";
-  private static final String LG = "LGE";
-  private static final String NVIDIA = "NVIDIA";
-
-  // SDK INT for API 22.
-  private static final int LOLLIPOP_MR1 = 22;
-
-  /**
-   * This returns the references in the leak path that should be ignored by all on Android.
-   */
-  public static ExcludedRefs createAndroidDefaults() {
-    ExcludedRefs excluded = new ExcludedRefs();
-    // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
-    // reference to the object and it was about to be GCed.
-    excluded.thread("FinalizerWatchdogDaemon");
-
-    // The main thread stack is ever changing so local variables aren't likely to hold references
-    // for long. If this is on the shortest path, it's probably that there's a longer path with
-    // a real leak.
-    excluded.thread("main");
-
-    excluded.thread(LEAK_CANARY_THREAD_NAME);
-    return excluded;
-  }
-
-  /**
-   * This returns the references in the leak path that can be ignored for app developers. This
-   * doesn't mean there is no memory leak, to the contrary. However, some leaks are caused by bugs
-   * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
-   * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
-   */
-  public static ExcludedRefs createAppDefaults() {
-    ExcludedRefs excluded = createAndroidDefaults();
-    if (SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-      // Android AOSP sometimes keeps a reference to a destroyed activity as a "nextIdle" client
-      // record in the android.app.ActivityThread.mActivities map.
-      // Not sure what's going on there, input welcome.
-      excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle");
-    }
-
-    if (SDK_INT <= KITKAT) {
-      // Editor inserts a special span, which has a reference to the EditText. That span is a
-      // NoCopySpan, which makes sure it gets dropped when creating a new SpannableStringBuilder
-      // from a given CharSequence.
-      // TextView.onSaveInstanceState() does a copy of its mText before saving it in the bundle.
-      // Prior to KitKat, that copy was done using the SpannableString constructor, instead of
-      // SpannableStringBuilder. The SpannableString constructor does not drop NoCopySpan spans.
-      // So we end up with a saved state that holds a reference to the textview and therefore the
-      // entire view hierarchy & activity context.
-      // Fix: https://github.com/android/platform_frameworks_base/commit
-      // /af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b
-
-      // Hack: to fix this, you could override TextView.onSaveInstanceState(), and then use
-      // reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.
-      excluded.instanceField("android.widget.Editor$EasyEditSpanController", "this$0");
-      excluded.instanceField("android.widget.Editor$SpanController", "this$0");
-    }
-
-    if (SDK_INT == LOLLIPOP) {
-      // MediaSessionLegacyHelper is a static singleton that is lazily instantiated and keeps a
-      // reference to the context it's given the first time MediaSessionLegacyHelper.getHelper()
-      // is called.
-      // This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by calling
-      // context.getApplicationContext().
-      // Fix: https://github.com/android/platform_frameworks_base/commit
-      // /9b5257c9c99c4cb541d8e8e78fb04f008b1a9091
-
-      // Hack: to fix this, you could call MediaSessionLegacyHelper.getHelper() early in
-      // Application.onCreate() and pass it the application context.
-      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance");
-    }
-
-    if (SDK_INT < LOLLIPOP_MR1) {
-      // TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had at least two
-      // bugs that created memory leaks by not correctly clearing the recycled TextLine instances.
-      // The first was fixed in android-5.1.0_r1:
-      // https://github.com/android/platform_frameworks_base/commit
-      // /893d6fe48d37f71e683f722457bea646994a10bf
-
-      // The second was fixed, not released yet:
-      // https://github.com/android/platform_frameworks_base/commit
-      // /b3a9bc038d3a218b1dbdf7b5668e3d6c12be5ee4
-
-      // Hack: to fix this, you could access TextLine.sCached and clear the pool every now and then
-      // (e.g. on activity destroy).
-      excluded.staticField("android.text.TextLine", "sCached");
-    }
-
-    if (SDK_INT < LOLLIPOP) {
-      // Prior to ART, a thread waiting on a blocking queue will leak the last dequeued object
-      // as a stack local reference.
-      // So when a HandlerThread becomes idle, it keeps a local reference to the last message it
-      // received. That message then gets recycled and can be used again.
-      // As long as all messages are recycled after being used, this won't be a problem, because
-      // there references are cleared when being recycled.
-      // However, dialogs create template Message instances to be copied when a message needs to be
-      // sent. These Message templates holds references to the dialog listeners, which most likely
-      // leads to holding a reference onto the activity in some way. Dialogs never recycle their
-      // template Message, assuming these Message instances will get GCed when the dialog is GCed.
-      // The combination of these two things creates a high potential for memory leaks as soon
-      // as you use dialogs. These memory leaks might be temporary, but some handler threads sleep
-      // for a long time.
-
-      // Hack: to fix this, you could post empty messages to the idle handler threads from time to
-      // time. This won't be easy because you cannot access all handler threads, but a library
-      // that is widely used should consider doing this for its own handler threads.
-      excluded.instanceField("android.os.Message", "obj");
-      excluded.instanceField("android.os.Message", "next");
-      excluded.instanceField("android.os.Message", "target");
-    }
-
-    if (SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP_MR1) {
-      // When we detach a view that receives keyboard input, the InputMethodManager leaks a
-      // reference to it until a new view asks for keyboard input.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=171190
-      // Hack: https://gist.github.com/pyricau/4df64341cc978a7de414
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView");
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView");
-      excluded.instanceField("android.view.inputmethod.InputMethodManager",
-          "mServedInputConnection");
-    }
-
-    if (SDK_INT >= LOLLIPOP && SDK_INT <= LOLLIPOP_MR1) {
-      // The singleton InputMethodManager is holding a reference to mCurRootView long after the
-      // activity has been destroyed.
-      // Hack: https://gist.github.com/pyricau/4df64341cc978a7de414
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView");
-    }
-
-    if (SDK_INT >= ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
-      // LayoutTransition leaks parent ViewGroup through ViewTreeObserver.OnPreDrawListener
-      // When triggered, this leaks stays until the window is destroyed.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=171830
-      excluded.instanceField("android.animation.LayoutTransition$1", "val$parent");
-    }
-
-    if (MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-      // DevicePolicyManager keeps a reference to the context it has been created with instead of
-      // extracting the application context. In this Motorola build, DevicePolicyManager has an
-      // inner SettingsObserver class that is a content observer, which is held into memory
-      // by a binder transport object.
-      excluded.instanceField("android.app.admin.DevicePolicyManager$SettingsObserver", "this$0");
-    }
-
-    if (SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-      // SpenGestureManager has a static mContext field that leaks a reference to the activity.
-      // Yes, a STATIC "mContext" field.
-      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext");
-    }
-
-    if (SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-      // ClipboardUIManager is a static singleton that leaks an activity context.
-      excluded.staticField("android.sec.clipboard.ClipboardUIManager", "sInstance");
-    }
-
-    if (LG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-      // A static helper for EditText "bubble popups" leaks a reference to the latest focused view.
-      excluded.staticField("android.widget.BubblePopupHelper", "sHelper");
-    }
-
-    if (SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-      // AwResource#setResources() is called with resources that hold a reference to the
-      // activity context (instead of the application context) and doesn't clear it.
-      // Not sure what's going on there, input welcome.
-      excluded.staticField("com.android.org.chromium.android_webview.AwResource", "sResources");
-    }
-
-    if (NVIDIA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-      // Not sure exactly what ControllerMapper is about, but there is an anonymous Handler in
-      // ControllerMapper.MapperClient.ServiceClient, which leaks ControllerMapper.MapperClient
-      // which leaks the activity context.
-      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient$ServiceClient", "this$0");
-    }
-
-    if (SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-      // mLastHoveredView is a static field in TextView that leaks the last hovered view.
-      excluded.staticField("android.widget.TextView", "mLastHoveredView");
-    }
-
-    if (MOTOROLA.equals(MANUFACTURER) && SDK_INT == JELLY_BEAN) {
-      // android.view.textservice.SpellCheckerSession$SpellCheckerSessionListenerImpl.mHandler is
-      // a GC root, it's an inner class that references SpellCheckerSession which itself references
-      // a SpellChecker through SpellCheckerSession.mSpellCheckerSessionListener.
-      excluded.instanceField("android.view.textservice.SpellCheckerSession",
-          "mSpellCheckerSessionListener");
-    }
-
-    if (SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-      // android.app.LoadedApk.mResources has a reference to
-      // android.content.res.Resources.mPersonaManager which has a reference to
-      // android.os.PersonaManager.mContext which is an activity.
-      excluded.instanceField("android.os.PersonaManager", "mContext");
-    }
-
-    return excluded;
-  }
-
-  private AndroidExcludedRefs() {
-    throw new AssertionError();
-  }
-}
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java b/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
deleted file mode 100644
index f6e7f7d8..00000000
--- a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.content.Context;
-import android.os.Debug;
-import android.util.Log;
-import java.io.File;
-import java.io.IOException;
-
-public final class AndroidHeapDumper implements HeapDumper {
-
-  private final File heapDumpFile;
-
-  public AndroidHeapDumper(Context context) {
-    heapDumpFile = new File(context.getFilesDir(), "suspected_leak_heapdump.hprof");
-  }
-
-  @Override public File dumpHeap() {
-    if (heapDumpFile.exists()) {
-      Log.d("AndroidHeapDumper", "Could not dump heap, previous analysis still is in progress.");
-      // Heap analysis in progress, let's not put to much pressure on the device.
-      return null;
-    }
-    try {
-      Debug.dumpHprofData(heapDumpFile.getAbsolutePath());
-      return heapDumpFile;
-    } catch (IOException e) {
-      cleanup();
-      Log.e("AndroidHeapDumper", "Could not perform heap dump", e);
-      // Abort heap dump
-      return null;
-    }
-  }
-
-  /**
-   * Call this on app startup to clean up all heap dump files that had not been handled yet when
-   * the app process was killed.
-   */
-  public void cleanup() {
-    if (heapDumpFile.exists()) {
-      Log.d("AndroidHeapDumper",
-          "Previous analysis did not complete correctly, cleaning: " + heapDumpFile);
-      heapDumpFile.delete();
-    }
-  }
-}
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java b/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
deleted file mode 100644
index e9e80017..00000000
--- a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.Context;
-import android.content.res.Resources;
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.Paint;
-import android.graphics.PorterDuffXfermode;
-import android.util.AttributeSet;
-import android.util.DisplayMetrics;
-import android.view.View;
-
-import static android.graphics.Bitmap.Config.ARGB_8888;
-import static android.graphics.PorterDuff.Mode.CLEAR;
-import static com.squareup.leakcanary.internal.DisplayLeakConnectorView.Type.NODE;
-import static com.squareup.leakcanary.internal.DisplayLeakConnectorView.Type.START;
-
-public final class DisplayLeakConnectorView extends View {
-
-  static final int LIGHT_GREY = 0xFFbababa;
-  static final int ROOT_COLOR = 0xFF84a6c5;
-  static final int LEAK_COLOR = 0xFFb1554e;
-
-  public enum Type {
-    START, NODE, END
-  }
-
-  private final Paint iconPaint;
-  private final Paint clearPaint;
-  private final Paint rootPaint;
-  private final Paint leakPaint;
-  private final float strokeSize;
-
-  private Type type;
-  private Bitmap cache;
-
-  public DisplayLeakConnectorView(Context context, AttributeSet attrs) {
-    super(context, attrs);
-
-    iconPaint = new Paint();
-    iconPaint.setColor(LIGHT_GREY);
-    strokeSize = dpToPixel(4, getResources());
-    iconPaint.setStrokeWidth(strokeSize);
-    iconPaint.setAntiAlias(true);
-
-    clearPaint = new Paint();
-    clearPaint.setColor(0);
-    clearPaint.setXfermode(new PorterDuffXfermode(CLEAR));
-    clearPaint.setAntiAlias(true);
-
-    rootPaint = new Paint();
-    rootPaint.setColor(ROOT_COLOR);
-    rootPaint.setAntiAlias(true);
-    rootPaint.setStrokeWidth(strokeSize);
-
-    leakPaint = new Paint();
-    leakPaint.setColor(LEAK_COLOR);
-    leakPaint.setAntiAlias(true);
-    type = NODE;
-  }
-
-  @SuppressWarnings("SuspiciousNameCombination") @Override protected void onDraw(Canvas canvas) {
-    int width = getWidth();
-    int height = getHeight();
-
-    if (cache != null && (cache.getWidth() != width || cache.getHeight() != height)) {
-      cache.recycle();
-      cache = null;
-    }
-
-    if (cache == null) {
-      cache = Bitmap.createBitmap(width, height, ARGB_8888);
-
-      Canvas cacheCanvas = new Canvas(cache);
-
-      float halfWidth = width / 2f;
-      float halfHeight = height / 2f;
-      float thirdWidth = width / 3;
-
-      if (type == NODE) {
-        cacheCanvas.drawLine(halfWidth, 0, halfWidth, height, iconPaint);
-        cacheCanvas.drawCircle(halfWidth, halfHeight, halfWidth, iconPaint);
-        cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, clearPaint);
-      } else if (type == START) {
-        float radiusClear = halfWidth - strokeSize / 2;
-        cacheCanvas.drawRect(0, 0, width, radiusClear, rootPaint);
-        cacheCanvas.drawCircle(0, radiusClear, radiusClear, clearPaint);
-        cacheCanvas.drawCircle(width, radiusClear, radiusClear, clearPaint);
-        cacheCanvas.drawLine(halfWidth, 0, halfWidth, halfHeight, rootPaint);
-        cacheCanvas.drawLine(halfWidth, halfHeight, halfWidth, height, iconPaint);
-        cacheCanvas.drawCircle(halfWidth, halfHeight, halfWidth, iconPaint);
-        cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, clearPaint);
-      } else {
-        cacheCanvas.drawLine(halfWidth, 0, halfWidth, halfHeight, iconPaint);
-        cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, leakPaint);
-      }
-    }
-    canvas.drawBitmap(cache, 0, 0, null);
-  }
-
-  public void setType(Type type) {
-    if (type != this.type) {
-      this.type = type;
-      if (cache != null) {
-        cache.recycle();
-        cache = null;
-      }
-      invalidate();
-    }
-  }
-
-  static float dpToPixel(float dp, Resources resources) {
-    DisplayMetrics metrics = resources.getDisplayMetrics();
-    float px = dp * (metrics.densityDpi / 160f);
-    return px;
-  }
-}
diff --git a/library/leakcanary-android/src/main/res/drawable-hdpi-v11/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-hdpi-v11/__leak_canary_notification.png
deleted file mode 100755
index ca53e710..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-hdpi-v11/__leak_canary_notification.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_icon.png b/library/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_icon.png
deleted file mode 100755
index 69911f30..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_icon.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_notification.png
deleted file mode 100755
index 86841e4e..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_notification.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-mdpi-v11/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-mdpi-v11/__leak_canary_notification.png
deleted file mode 100755
index dc71e62b..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-mdpi-v11/__leak_canary_notification.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_icon.png b/library/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_icon.png
deleted file mode 100755
index e6c8e1f2..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_icon.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_notification.png
deleted file mode 100755
index 98a55ee4..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_notification.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-xhdpi-v11/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-xhdpi-v11/__leak_canary_notification.png
deleted file mode 100755
index e8e7421f..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-xhdpi-v11/__leak_canary_notification.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_icon.png b/library/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_icon.png
deleted file mode 100755
index 9d3bb119..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_icon.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_notification.png
deleted file mode 100755
index 594ed22a..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_notification.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-xxhdpi-v11/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-xxhdpi-v11/__leak_canary_notification.png
deleted file mode 100755
index 1aac2c0c..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-xxhdpi-v11/__leak_canary_notification.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_icon.png b/library/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_icon.png
deleted file mode 100755
index 7072b8ec..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_icon.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_notification.png
deleted file mode 100755
index b11f1547..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_notification.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/__leak_canary_notification.png
deleted file mode 100755
index 3aaa2a5b..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/__leak_canary_notification.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_icon.png b/library/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_icon.png
deleted file mode 100755
index c72d0d84..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_icon.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_notification.png
deleted file mode 100755
index 41eae0d3..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_notification.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/values/__leak_canary_strings.xml b/library/leakcanary-android/src/main/res/values/__leak_canary_strings.xml
deleted file mode 100644
index 4113b2b0..00000000
--- a/library/leakcanary-android/src/main/res/values/__leak_canary_strings.xml
+++ /dev/null
@@ -1,27 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<resources>
-
-  <string name="__leak_canary_class_has_leaked">%s has leaked</string>
-  <string name="__leak_canary_leak_list_title">Leaks in %s</string>
-  <string name="__leak_canary_notification_message">Click for more details</string>
-  <string name="__leak_canary_share_leak">Share leak</string>
-  <string name="__leak_canary_share_heap_dump">Share heap dump</string>
-  <string name="__leak_canary_share_with">Share with…</string>
-  <string name="__leak_canary_display_activity_label">Leaks</string>
-
-</resources>
\ No newline at end of file
diff --git a/library/settings.gradle b/settings.gradle
similarity index 100%
rename from library/settings.gradle
rename to settings.gradle
