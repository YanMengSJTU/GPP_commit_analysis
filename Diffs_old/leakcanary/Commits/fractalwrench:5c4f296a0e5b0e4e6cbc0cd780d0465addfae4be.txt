diff --git a/leakcanary-android/build.gradle b/leakcanary-android/build.gradle
index 36d5a35c..f9480eca 100644
--- a/leakcanary-android/build.gradle
+++ b/leakcanary-android/build.gradle
@@ -27,6 +27,7 @@ android {
   lintOptions {
     disable 'GoogleAppIndexingWarning'
     error 'ObsoleteSdkInt'
+    check 'Interoperability'
   }
 }
 
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
index 374ab1cc..6f1ecd0d 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
@@ -17,6 +17,8 @@
 
 import android.content.Context;
 import android.content.Intent;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.content.ContextCompat;
 import com.squareup.leakcanary.internal.ForegroundService;
 
@@ -25,8 +27,10 @@
   private static final String HEAP_DUMP_EXTRA = "heap_dump_extra";
   private static final String RESULT_EXTRA = "result_extra";
 
-  public static void sendResultToListener(Context context, String listenerServiceClassName,
-      HeapDump heapDump, AnalysisResult result) {
+  public static void sendResultToListener(@NonNull Context context,
+                                          @NonNull String listenerServiceClassName,
+                                          @NonNull HeapDump heapDump,
+                                          @NonNull AnalysisResult result) {
     Class<?> listenerServiceClass;
     try {
       listenerServiceClass = Class.forName(listenerServiceClassName);
@@ -44,7 +48,7 @@ public AbstractAnalysisResultService() {
         R.string.leak_canary_notification_reporting);
   }
 
-  @Override protected final void onHandleIntentInForeground(Intent intent) {
+  @Override protected final void onHandleIntentInForeground(@Nullable Intent intent) {
     HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAP_DUMP_EXTRA);
     AnalysisResult result = (AnalysisResult) intent.getSerializableExtra(RESULT_EXTRA);
     try {
@@ -66,5 +70,6 @@ public AbstractAnalysisResultService() {
    * <p>
    * The heap dump file will be deleted immediately after this callback returns.
    */
-  protected abstract void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result);
+  protected abstract void onHeapAnalyzed(@NonNull HeapDump heapDump,
+                                         @NonNull AnalysisResult result);
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
index c293628d..94f6b630 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
@@ -18,6 +18,8 @@
 import android.app.Activity;
 import android.app.Application;
 import android.content.Context;
+import android.support.annotation.NonNull;
+
 import com.squareup.leakcanary.internal.ActivityLifecycleCallbacksAdapter;
 
 /**
@@ -29,11 +31,12 @@
 @Deprecated
 public final class ActivityRefWatcher {
 
-  public static void installOnIcsPlus(Application application, RefWatcher refWatcher) {
+  public static void installOnIcsPlus(@NonNull Application application,
+                                      @NonNull RefWatcher refWatcher) {
     install(application, refWatcher);
   }
 
-  public static void install(Context context, RefWatcher refWatcher) {
+  public static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) {
     Application application = (Application) context.getApplicationContext();
     ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);
 
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
index 8e34064d..5743fed3 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
@@ -15,6 +15,8 @@
  */
 package com.squareup.leakcanary;
 
+import android.support.annotation.NonNull;
+
 import java.lang.ref.PhantomReference;
 import java.lang.ref.SoftReference;
 import java.lang.ref.WeakReference;
@@ -590,7 +592,7 @@
   /**
    * This returns the references in the leak path that should be ignored by all on Android.
    */
-  public static ExcludedRefs.Builder createAndroidDefaults() {
+  @NonNull public static ExcludedRefs.Builder createAndroidDefaults() {
     return createBuilder(
         EnumSet.of(SOFT_REFERENCES, FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
             EVENT_RECEIVER__MMESSAGE_QUEUE));
@@ -602,11 +604,11 @@
    * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
    * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
    */
-  public static ExcludedRefs.Builder createAppDefaults() {
+  @NonNull public static ExcludedRefs.Builder createAppDefaults() {
     return createBuilder(EnumSet.allOf(AndroidExcludedRefs.class));
   }
 
-  public static ExcludedRefs.Builder createBuilder(EnumSet<AndroidExcludedRefs> refs) {
+  @NonNull public static ExcludedRefs.Builder createBuilder(EnumSet<AndroidExcludedRefs> refs) {
     ExcludedRefs.Builder excluded = ExcludedRefs.builder();
     for (AndroidExcludedRefs ref : refs) {
       if (ref.applies) {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
index 78299fdc..33edd7f7 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
@@ -26,6 +26,8 @@
 import android.os.Looper;
 import android.os.MessageQueue;
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.Gravity;
 import android.view.LayoutInflater;
 import android.view.View;
@@ -46,14 +48,16 @@
   private final LeakDirectoryProvider leakDirectoryProvider;
   private final Handler mainHandler;
 
-  public AndroidHeapDumper(Context context, LeakDirectoryProvider leakDirectoryProvider) {
+  public AndroidHeapDumper(@NonNull Context context,
+                           @NonNull LeakDirectoryProvider leakDirectoryProvider) {
     this.leakDirectoryProvider = leakDirectoryProvider;
     this.context = context.getApplicationContext();
     mainHandler = new Handler(Looper.getMainLooper());
   }
 
   @SuppressWarnings("ReferenceEquality") // Explicitly checking for named null.
-  @Override public File dumpHeap() {
+  @Override @Nullable
+  public File dumpHeap() {
     File heapDumpFile = leakDirectoryProvider.newHeapDumpFile();
 
     if (heapDumpFile == RETRY_LATER) {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java
index 1a4060db..c118b28e 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java
@@ -20,6 +20,7 @@
 import android.app.Dialog;
 import android.app.Fragment;
 import android.os.MessageQueue;
+import android.support.annotation.NonNull;
 import android.view.View;
 import java.util.ArrayList;
 import java.util.List;
@@ -66,7 +67,7 @@
     this.inspectorClass = inspectorClass;
   }
 
-  public static List<Class<? extends Reachability.Inspector>> defaultAndroidInspectors() {
+  @NonNull public static List<Class<? extends Reachability.Inspector>> defaultAndroidInspectors() {
     List<Class<? extends Reachability.Inspector>> inspectorClasses = new ArrayList<>();
     for (AndroidReachabilityInspectors enumValue : AndroidReachabilityInspectors.values()) {
       inspectorClasses.add(enumValue.inspectorClass);
@@ -75,7 +76,7 @@
   }
 
   public static class ViewInspector implements Reachability.Inspector {
-    @Override public Reachability expectedReachability(LeakTraceElement element) {
+    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (!element.isInstanceOf(View.class)) {
         return Reachability.UNKNOWN;
       }
@@ -88,7 +89,7 @@
   }
 
   public static class ActivityInspector implements Reachability.Inspector {
-    @Override public Reachability expectedReachability(LeakTraceElement element) {
+    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (!element.isInstanceOf(Activity.class)) {
         return Reachability.UNKNOWN;
       }
@@ -101,7 +102,7 @@
   }
 
   public static class DialogInspector implements Reachability.Inspector {
-    @Override public Reachability expectedReachability(LeakTraceElement element) {
+    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (!element.isInstanceOf(Dialog.class)) {
         return Reachability.UNKNOWN;
       }
@@ -114,7 +115,7 @@
   }
 
   public static class ApplicationInspector implements Reachability.Inspector {
-    @Override public Reachability expectedReachability(LeakTraceElement element) {
+    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (element.isInstanceOf(Application.class)) {
         return Reachability.REACHABLE;
       }
@@ -123,7 +124,7 @@
   }
 
   public static class FragmentInspector implements Reachability.Inspector {
-    @Override public Reachability expectedReachability(LeakTraceElement element) {
+    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (!element.isInstanceOf(Fragment.class)) {
         return Reachability.UNKNOWN;
       }
@@ -136,7 +137,7 @@
   }
 
   public static class SupportFragmentInspector implements Reachability.Inspector {
-    @Override public Reachability expectedReachability(LeakTraceElement element) {
+    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (!element.isInstanceOf("android.support.v4.app.Fragment")) {
         return Reachability.UNKNOWN;
       }
@@ -149,7 +150,7 @@
   }
 
   public static class MessageQueueInspector implements Reachability.Inspector {
-    @Override public Reachability expectedReachability(LeakTraceElement element) {
+    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (!element.isInstanceOf(MessageQueue.class)) {
         return Reachability.UNKNOWN;
       }
@@ -164,7 +165,7 @@
   }
 
   public static class MortarPresenterInspector implements Reachability.Inspector {
-    @Override public Reachability expectedReachability(LeakTraceElement element) {
+    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (!element.isInstanceOf("mortar.Presenter")) {
         return Reachability.UNKNOWN;
       }
@@ -181,7 +182,7 @@
   }
 
   public static class ViewImplInspector implements Reachability.Inspector {
-    @Override public Reachability expectedReachability(LeakTraceElement element) {
+    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (!element.isInstanceOf("android.view.ViewRootImpl")) {
         return Reachability.UNKNOWN;
       }
@@ -194,7 +195,7 @@
   }
 
   public static class MainThreadInspector implements Reachability.Inspector {
-    @Override public Reachability expectedReachability(LeakTraceElement element) {
+    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (!element.isInstanceOf(Thread.class)) {
         return Reachability.UNKNOWN;
       }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
index 2ba0dba6..9799400e 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
@@ -1,6 +1,8 @@
 package com.squareup.leakcanary;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+
 import com.squareup.leakcanary.internal.FragmentRefWatcher;
 import com.squareup.leakcanary.internal.LeakCanaryInternals;
 import java.util.List;
@@ -18,7 +20,7 @@
   private boolean watchActivities = true;
   private boolean watchFragments = true;
 
-  AndroidRefWatcherBuilder(Context context) {
+  AndroidRefWatcherBuilder(@NonNull Context context) {
     this.context = context.getApplicationContext();
   }
 
@@ -26,8 +28,8 @@
    * Sets a custom {@link AbstractAnalysisResultService} to listen to analysis results. This
    * overrides any call to {@link #heapDumpListener(HeapDump.Listener)}.
    */
-  public AndroidRefWatcherBuilder listenerServiceClass(
-      Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
+  @NonNull public AndroidRefWatcherBuilder listenerServiceClass(
+      @NonNull Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
     return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));
   }
 
@@ -36,7 +38,7 @@ public AndroidRefWatcherBuilder listenerServiceClass(
    * tracked object has been garbage collected. This overrides any call to {@link
    * #watchExecutor(WatchExecutor)}.
    */
-  public AndroidRefWatcherBuilder watchDelay(long delay, TimeUnit unit) {
+  @NonNull public AndroidRefWatcherBuilder watchDelay(long delay, @NonNull TimeUnit unit) {
     return watchExecutor(new AndroidWatchExecutor(unit.toMillis(delay)));
   }
 
@@ -44,7 +46,7 @@ public AndroidRefWatcherBuilder watchDelay(long delay, TimeUnit unit) {
    * Whether we should automatically watch activities when calling {@link #buildAndInstall()}.
    * Default is true.
    */
-  public AndroidRefWatcherBuilder watchActivities(boolean watchActivities) {
+  @NonNull public AndroidRefWatcherBuilder watchActivities(boolean watchActivities) {
     this.watchActivities = watchActivities;
     return this;
   }
@@ -54,7 +56,7 @@ public AndroidRefWatcherBuilder watchActivities(boolean watchActivities) {
    * Default is true. When true, LeakCanary watches native fragments on Android O+ and support
    * fragments if the leakcanary-support-fragment dependency is in the classpath.
    */
-  public AndroidRefWatcherBuilder watchFragments(boolean watchFragments) {
+  @NonNull public AndroidRefWatcherBuilder watchFragments(boolean watchFragments) {
     this.watchFragments = watchFragments;
     return this;
   }
@@ -65,7 +67,7 @@ public AndroidRefWatcherBuilder watchFragments(boolean watchFragments) {
    *
    * @throws IllegalArgumentException if maxStoredHeapDumps < 1.
    */
-  public AndroidRefWatcherBuilder maxStoredHeapDumps(int maxStoredHeapDumps) {
+  @NonNull public AndroidRefWatcherBuilder maxStoredHeapDumps(int maxStoredHeapDumps) {
     LeakDirectoryProvider leakDirectoryProvider =
         new DefaultLeakDirectoryProvider(context, maxStoredHeapDumps);
     LeakCanary.setLeakDirectoryProvider(leakDirectoryProvider);
@@ -80,7 +82,7 @@ public AndroidRefWatcherBuilder maxStoredHeapDumps(int maxStoredHeapDumps) {
    *
    * @throws UnsupportedOperationException if called more than once per Android process.
    */
-  public RefWatcher buildAndInstall() {
+  @NonNull public RefWatcher buildAndInstall() {
     if (LeakCanaryInternals.installedRefWatcher != null) {
       throw new UnsupportedOperationException("buildAndInstall() should only be called once.");
     }
@@ -101,29 +103,29 @@ public RefWatcher buildAndInstall() {
     return LeakCanary.isInAnalyzerProcess(context);
   }
 
-  @Override protected HeapDumper defaultHeapDumper() {
+  @Override @NonNull protected HeapDumper defaultHeapDumper() {
     LeakDirectoryProvider leakDirectoryProvider =
         LeakCanaryInternals.getLeakDirectoryProvider(context);
     return new AndroidHeapDumper(context, leakDirectoryProvider);
   }
 
-  @Override protected DebuggerControl defaultDebuggerControl() {
+  @Override @NonNull protected DebuggerControl defaultDebuggerControl() {
     return new AndroidDebuggerControl();
   }
 
-  @Override protected HeapDump.Listener defaultHeapDumpListener() {
+  @Override @NonNull protected HeapDump.Listener defaultHeapDumpListener() {
     return new ServiceHeapDumpListener(context, DisplayLeakService.class);
   }
 
-  @Override protected ExcludedRefs defaultExcludedRefs() {
+  @Override @NonNull protected ExcludedRefs defaultExcludedRefs() {
     return AndroidExcludedRefs.createAppDefaults().build();
   }
 
-  @Override protected WatchExecutor defaultWatchExecutor() {
+  @Override @NonNull protected WatchExecutor defaultWatchExecutor() {
     return new AndroidWatchExecutor(DEFAULT_WATCH_DELAY_MILLIS);
   }
 
-  @Override protected List<Class<? extends Reachability.Inspector>> defaultReachabilityInspectorClasses() {
+  @Override @NonNull protected List<Class<? extends Reachability.Inspector>> defaultReachabilityInspectorClasses() {
     return AndroidReachabilityInspectors.defaultAndroidInspectors();
   }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
index f946770b..ae865dcf 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
@@ -19,6 +19,8 @@
 import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.MessageQueue;
+import android.support.annotation.NonNull;
+
 import java.util.concurrent.TimeUnit;
 
 import static com.squareup.leakcanary.Retryable.Result.RETRY;
@@ -45,7 +47,7 @@ public AndroidWatchExecutor(long initialDelayMillis) {
     maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;
   }
 
-  @Override public void execute(Retryable retryable) {
+  @Override public void execute(@NonNull Retryable retryable) {
     if (Looper.getMainLooper().getThread() == Thread.currentThread()) {
       waitForIdle(retryable, 0);
     } else {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
index 9db42e53..e09c22d3 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
@@ -1,5 +1,7 @@
 package com.squareup.leakcanary;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 
 public final class CanaryLog {
@@ -7,15 +9,15 @@
   private static volatile Logger logger = new DefaultLogger();
 
   public interface Logger {
-    void d(String message, Object... args);
+    void d(@NonNull String message, @NonNull Object... args);
 
-    void d(Throwable throwable, String message, Object... args);
+    void d(@Nullable Throwable throwable, @NonNull String message, @NonNull Object... args);
   }
 
   private static class DefaultLogger implements Logger {
     DefaultLogger() { }
 
-    @Override public void d(String message, Object... args) {
+    @Override public void d(@NonNull String message, @NonNull Object... args) {
       String formatted = String.format(message, args);
       if (formatted.length() < 4000) {
         Log.d("LeakCanary", formatted);
@@ -27,16 +29,18 @@
       }
     }
 
-    @Override public void d(Throwable throwable, String message, Object... args) {
+    @Override public void d(@Nullable Throwable throwable,
+                            @NonNull String message,
+                            @NonNull Object... args) {
       d(String.format(message, args) + '\n' + Log.getStackTraceString(throwable));
     }
   }
 
-  public static void setLogger(Logger logger) {
+  public static void setLogger(@Nullable Logger logger) {
     CanaryLog.logger = logger;
   }
 
-  public static void d(String message, Object... args) {
+  public static void d(@NonNull String message, @NonNull Object... args) {
     // Local variable to prevent the ref from becoming null after the null check.
     Logger logger = CanaryLog.logger;
     if (logger == null) {
@@ -45,7 +49,9 @@ public static void d(String message, Object... args) {
     logger.d(message, args);
   }
 
-  public static void d(Throwable throwable, String message, Object... args) {
+  public static void d(@Nullable Throwable throwable,
+                       @NonNull String message,
+                       @NonNull Object... args) {
     // Local variable to prevent the ref from becoming null after the null check.
     Logger logger = CanaryLog.logger;
     if (logger == null) {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
index 94957554..4679af5a 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
@@ -19,6 +19,9 @@
 import android.app.PendingIntent;
 import android.content.Context;
 import android.os.Environment;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
 import com.squareup.leakcanary.internal.RequestStoragePermissionActivity;
 import java.io.File;
 import java.io.FilenameFilter;
@@ -53,11 +56,11 @@
   private volatile boolean writeExternalStorageGranted;
   private volatile boolean permissionNotificationDisplayed;
 
-  public DefaultLeakDirectoryProvider(Context context) {
+  public DefaultLeakDirectoryProvider(@NonNull Context context) {
     this(context, DEFAULT_MAX_STORED_HEAP_DUMPS);
   }
 
-  public DefaultLeakDirectoryProvider(Context context, int maxStoredHeapDumps) {
+  public DefaultLeakDirectoryProvider(@NonNull Context context, int maxStoredHeapDumps) {
     if (maxStoredHeapDumps < 1) {
       throw new IllegalArgumentException("maxStoredHeapDumps must be at least 1");
     }
@@ -65,7 +68,8 @@ public DefaultLeakDirectoryProvider(Context context, int maxStoredHeapDumps) {
     this.maxStoredHeapDumps = maxStoredHeapDumps;
   }
 
-  @Override public List<File> listFiles(FilenameFilter filter) {
+  @NonNull
+  @Override public List<File> listFiles(@NonNull FilenameFilter filter) {
     if (!hasStoragePermission()) {
       requestWritePermissionNotification();
     }
@@ -83,6 +87,7 @@ public DefaultLeakDirectoryProvider(Context context, int maxStoredHeapDumps) {
     return files;
   }
 
+  @Nullable
   @Override public File newHeapDumpFile() {
     List<File> pendingHeapDumps = listFiles(new FilenameFilter() {
       @Override public boolean accept(File dir, String filename) {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
index cba2fdb3..b3030a78 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
@@ -17,6 +17,8 @@
 
 import android.app.PendingIntent;
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
+
 import com.squareup.leakcanary.internal.DisplayLeakActivity;
 import java.io.File;
 import java.io.FileOutputStream;
@@ -40,7 +42,7 @@
  */
 public class DisplayLeakService extends AbstractAnalysisResultService {
 
-  @Override protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
+  @Override protected final void onHeapAnalyzed(@NonNull HeapDump heapDump, @NonNull AnalysisResult result) {
     String leakInfo = leakInfo(this, heapDump, result, true);
     CanaryLog.d("%s", leakInfo);
 
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
index 30c836dc..8848fce5 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -20,6 +20,7 @@
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.os.Build;
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.squareup.leakcanary.internal.DisplayLeakActivity;
 import com.squareup.leakcanary.internal.HeapAnalyzerService;
@@ -36,7 +37,7 @@
    * Creates a {@link RefWatcher} that works out of the box, and starts watching activity
    * references (on ICS+).
    */
-  public static RefWatcher install(Application application) {
+  @NonNull public static RefWatcher install(@NonNull Application application) {
     return refWatcher(application).listenerServiceClass(DisplayLeakService.class)
         .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
         .buildAndInstall();
@@ -47,7 +48,7 @@ public static RefWatcher install(Application application) {
    * {@link AndroidRefWatcherBuilder#buildAndInstall()}, and {@link RefWatcher#DISABLED} is no
    * {@link RefWatcher} has been installed.
    */
-  public static RefWatcher installedRefWatcher() {
+  @NonNull public static RefWatcher installedRefWatcher() {
     RefWatcher refWatcher = LeakCanaryInternals.installedRefWatcher;
     if (refWatcher == null) {
       return RefWatcher.DISABLED;
@@ -55,7 +56,7 @@ public static RefWatcher installedRefWatcher() {
     return refWatcher;
   }
 
-  public static AndroidRefWatcherBuilder refWatcher(Context context) {
+  @NonNull public static AndroidRefWatcherBuilder refWatcher(@NonNull Context context) {
     return new AndroidRefWatcherBuilder(context);
   }
 
@@ -65,7 +66,7 @@ public static AndroidRefWatcherBuilder refWatcher(Context context) {
    * once a potential leak has been found and the analysis starts. You can call this method to
    * enable {@link DisplayLeakActivity} before any potential leak has been detected.
    */
-  public static void enableDisplayLeakActivity(Context context) {
+  public static void enableDisplayLeakActivity(@NonNull Context context) {
     LeakCanaryInternals.setEnabledBlocking(context, DisplayLeakActivity.class, true);
   }
 
@@ -74,7 +75,7 @@ public static void enableDisplayLeakActivity(Context context) {
    */
   @Deprecated
   public static void setDisplayLeakActivityDirectoryProvider(
-      LeakDirectoryProvider leakDirectoryProvider) {
+      @NonNull LeakDirectoryProvider leakDirectoryProvider) {
     setLeakDirectoryProvider(leakDirectoryProvider);
   }
 
@@ -85,12 +86,14 @@ public static void setDisplayLeakActivityDirectoryProvider(
    * @throws IllegalStateException if a LeakDirectoryProvider has already been set, including
    * if the default has been automatically set when installing the ref watcher.
    */
-  public static void setLeakDirectoryProvider(LeakDirectoryProvider leakDirectoryProvider) {
+  public static void setLeakDirectoryProvider(@NonNull LeakDirectoryProvider leakDirectoryProvider) {
     LeakCanaryInternals.setLeakDirectoryProvider(leakDirectoryProvider);
   }
 
   /** Returns a string representation of the result of a heap analysis. */
-  public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult result,
+  @NonNull public static String leakInfo(@NonNull Context context,
+                                         @NonNull HeapDump heapDump,
+                                         @NonNull AnalysisResult result,
       boolean detailed) {
     PackageManager packageManager = context.getPackageManager();
     String packageName = context.getPackageName();
@@ -171,7 +174,7 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
    * Whether the current process is the process running the {@link HeapAnalyzerService}, which is
    * a different process than the normal app process.
    */
-  public static boolean isInAnalyzerProcess(Context context) {
+  public static boolean isInAnalyzerProcess(@NonNull Context context) {
     Boolean isInAnalyzerProcess = LeakCanaryInternals.isInAnalyzerProcess;
     // This only needs to be computed once per process.
     if (isInAnalyzerProcess == null) {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
index 1dfa218f..43e8b63c 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
@@ -15,6 +15,9 @@
  */
 package com.squareup.leakcanary;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
 import java.io.File;
 import java.io.FilenameFilter;
 import java.util.List;
@@ -27,12 +30,12 @@
  */
 public interface LeakDirectoryProvider {
 
-  List<File> listFiles(FilenameFilter filter);
+  @NonNull List<File> listFiles(@NonNull FilenameFilter filter);
 
   /**
    * @return {@link HeapDumper#RETRY_LATER} if a new heap dump file could not be created.
    */
-  File newHeapDumpFile();
+  @Nullable File newHeapDumpFile();
 
   /**
    * Removes all heap dumps and analysis results, except for heap dumps that haven't been
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
index 5b6d539c..7fde49bb 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
@@ -16,6 +16,8 @@
 package com.squareup.leakcanary;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+
 import com.squareup.leakcanary.internal.HeapAnalyzerService;
 
 import static com.squareup.leakcanary.Preconditions.checkNotNull;
@@ -25,13 +27,13 @@
   private final Context context;
   private final Class<? extends AbstractAnalysisResultService> listenerServiceClass;
 
-  public ServiceHeapDumpListener(final Context context,
-      final Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
+  public ServiceHeapDumpListener(@NonNull final Context context,
+      @NonNull final Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
     this.listenerServiceClass = checkNotNull(listenerServiceClass, "listenerServiceClass");
     this.context = checkNotNull(context, "context").getApplicationContext();
   }
 
-  @Override public void analyze(HeapDump heapDump) {
+  @Override public void analyze(@NonNull HeapDump heapDump) {
     checkNotNull(heapDump, "heapDump");
     HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass);
   }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
index 43a9499d..22f4265a 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
@@ -15,6 +15,8 @@
  */
 package com.squareup.leakcanary;
 
+import com.sun.istack.internal.Nullable;
+
 import java.io.File;
 
 /** Dumps the heap into a file. */
@@ -31,5 +33,5 @@
    * @return a {@link File} referencing the dumped heap, or {@link #RETRY_LATER} if the heap could
    * not be dumped.
    */
-  File dumpHeap();
+  @Nullable File dumpHeap();
 }
\ No newline at end of file
