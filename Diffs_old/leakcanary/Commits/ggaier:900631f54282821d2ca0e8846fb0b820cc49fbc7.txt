diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
index aaf7dd5e..09e55942 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
@@ -44,7 +44,10 @@ public static void install(@NonNull Context context, @NonNull RefWatcher refWatc
 
   private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =
       new ActivityLifecycleCallbacksAdapter() {
-        @Override public void onActivityDestroyed(Activity activity) {
+        @Override
+        public void onActivityDestroyed(Activity activity) {
+          // WB_ANDROID: 2018/12/7
+          // 当 Activity 销毁的时候, 会自动的 Watch Activity.
           refWatcher.watch(activity);
         }
       };
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
index bc72bb11..21f73263 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
@@ -89,6 +89,8 @@
     RefWatcher refWatcher = build();
     if (refWatcher != DISABLED) {
       LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);
+      // WB_ANDROID: 2018/12/7 11:13 AM Leak Canary 的入口, 观察Activity引用, 把 Activity 的引用
+      //存放到一个弱引用队列中, 触发 GC 后, 查看是否
       if (watchActivities) {
         ActivityRefWatcher.install(context, refWatcher);
       }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
index 73653194..03f633da 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
@@ -63,13 +63,19 @@ private void postWaitForIdle(final Retryable retryable, final int failedAttempts
   }
 
   private void waitForIdle(final Retryable retryable, final int failedAttempts) {
+    // WB_ANDROID: 2018/12/7
     // This needs to be called from the main thread.
-    Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
-      @Override public boolean queueIdle() {
-        postToBackgroundWithDelay(retryable, failedAttempts);
-        return false;
-      }
-    });
+    Looper.myQueue()
+        .addIdleHandler(
+            new MessageQueue.IdleHandler() {
+              @Override
+              public boolean queueIdle() {
+                //当MessageQueue 中的没有消息被处理的时候, 会调用该方法.
+                //nativePollOnce() 会根据 CPU 的周期定期查看是否有新消息到来.
+                postToBackgroundWithDelay(retryable, failedAttempts);
+                return false;
+              }
+            });
   }
 
   private void postToBackgroundWithDelay(final Retryable retryable, final int failedAttempts) {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
index 6a776235..0c0f3451 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
@@ -101,7 +101,7 @@ public static boolean isInServiceProcess(Context context, Class<? extends Servic
       return false;
     }
     String mainProcess = packageInfo.applicationInfo.processName;
-
+    //通常是用来获取属于自己应用的 Component
     ComponentName component = new ComponentName(context, serviceClass);
     ServiceInfo serviceInfo;
     try {
@@ -129,6 +129,7 @@ public static boolean isInServiceProcess(Context context, Class<? extends Servic
       CanaryLog.d("Could not get running app processes %d", exception);
       return false;
     }
+    //pid 是唯一的, 每个进程都单独存在的
     if (runningProcesses != null) {
       for (ActivityManager.RunningAppProcessInfo process : runningProcesses) {
         if (process.pid == myPid) {
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
index ff5afad0..f4b66b84 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
@@ -21,28 +21,31 @@
  * RefWatcher} checks the reference queue again, to avoid taking a heap dump if possible.
  */
 public interface GcTrigger {
-  GcTrigger DEFAULT = new GcTrigger() {
-    @Override public void runGc() {
-      // Code taken from AOSP FinalizationTest:
-      // https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
-      // java/lang/ref/FinalizationTester.java
-      // System.gc() does not garbage collect every time. Runtime.gc() is
-      // more likely to perform a gc.
-      Runtime.getRuntime().gc();
-      enqueueReferences();
-      System.runFinalization();
-    }
+  GcTrigger DEFAULT =
+      new GcTrigger() {
+        @Override
+        public void runGc() {
+          // Code taken from AOSP FinalizationTest:
+          // https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
+          // java/lang/ref/FinalizationTester.java
+          // System.gc() does not garbage collect every time. Runtime.gc() is
+          // more likely to perform a gc.
+          // WB_ANDROID: 2018/12/7 10:51 AM 触发 GC.
+          Runtime.getRuntime().gc();
+          enqueueReferences();
+          System.runFinalization();
+        }
 
-    private void enqueueReferences() {
-      // Hack. We don't have a programmatic way to wait for the reference queue daemon to move
-      // references to the appropriate queues.
-      try {
-        Thread.sleep(100);
-      } catch (InterruptedException e) {
-        throw new AssertionError();
-      }
-    }
-  };
+        private void enqueueReferences() {
+          // Hack. We don't have a programmatic way to wait for the reference queue daemon to move
+          // references to the appropriate queues.
+          try {
+            Thread.sleep(100);
+          } catch (InterruptedException e) {
+            throw new AssertionError();
+          }
+        }
+      };
 
   void runGc();
 }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
index c3d27a1c..fb0a63e7 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
@@ -45,6 +45,7 @@
   private final HeapDump.Listener heapdumpListener;
   private final HeapDump.Builder heapDumpBuilder;
   private final Set<String> retainedKeys;
+  //引用被注册的队列.
   private final ReferenceQueue<Object> queue;
 
   RefWatcher(WatchExecutor watchExecutor, DebuggerControl debuggerControl, GcTrigger gcTrigger,
@@ -84,6 +85,7 @@ public void watch(Object watchedReference, String referenceName) {
     final long watchStartNanoTime = System.nanoTime();
     String key = UUID.randomUUID().toString();
     retainedKeys.add(key);
+
     final KeyedWeakReference reference =
         new KeyedWeakReference(watchedReference, key, referenceName, queue);
 
@@ -119,8 +121,10 @@ private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakRefer
     });
   }
 
+
   @SuppressWarnings("ReferenceEquality") // Explicitly checking for named null.
   Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {
+    // WB_ANDROID: 2018/12/7 10:40 AM 触发 GC, 查看是否产生泄露的开始
     long gcStartNanoTime = System.nanoTime();
     long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);
 
@@ -133,6 +137,7 @@ private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakRefer
     if (gone(reference)) {
       return DONE;
     }
+    //触发 GC 后, 然后 GC 会把引用都存放到队列中, 之后移除WeakReference.
     gcTrigger.runGc();
     removeWeaklyReachableReferences();
     if (!gone(reference)) {
@@ -165,6 +170,9 @@ private boolean gone(KeyedWeakReference reference) {
   private void removeWeaklyReachableReferences() {
     // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
     // reachable. This is before finalization or garbage collection has actually happened.
+    // WB_ANDROID: 2018/12/7 11:30 AM ReferenceQueue 是 java 提供的用来记录可以被 GC 的对象的.
+    // 当非强引用的对象可以被 GC 回收的时候, 就会在queue 里存放该引用. 然后根据该引用的 key, 移除掉可以被回收的
+    // 对象, 剩下的就是不可被回收的对象了.
     KeyedWeakReference ref;
     while ((ref = (KeyedWeakReference) queue.poll()) != null) {
       retainedKeys.remove(ref.key);
