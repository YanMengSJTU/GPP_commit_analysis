diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
index b8432c90..604954df 100644
--- a/.github/ISSUE_TEMPLATE.md
+++ b/.github/ISSUE_TEMPLATE.md
@@ -1,16 +1,32 @@
 Welcome and thank you for reporting an issue!
 
-If you don't know how to fix a memory leak in your app, please do not file an issue. Read here: https://github.com/square/leakcanary/#how-do-i-fix-a-memory-leak
+First:
 
-Are you sure this issue isn't already reported? Try the search field in https://github.com/square/leakcanary/issues .
+- Confirm that you are using the latest version of LeakCanary (see https://github.com/square/leakcanary/blob/master/CHANGELOG.md)
+- Verify that your issue hasn't already been reported by searching over all issues: https://github.com/square/leakcanary/issues?q=is%3Aissue.
 
-^^^^^ PLEASE DELETE EVERYTHING ABOVE, INCLUDING THIS LINE ^^^^^
+What kind of issue is this?
 
-LeakCanary Version: 
+ - *Question*: This issue tracker is not the place for questions. If you want to ask how to do
+   something, or to understand why something isn't working the way you expect it to, use Stack
+   Overflow: https://stackoverflow.com/questions/tagged/leakcanary.
+
+ - *Help me fix a leak?*: Please do not file an issue.
+   Instead, read here: https://github.com/square/leakcanary/#how-do-i-fix-a-memory-leak
+ 
+ - *Leak analysis failed*: if it's an OutOfMemoryError, no need to report it. See https://github.com/square/leakcanary/wiki/Future#low-memory-leak-analysis
+
+ - *Bug report*: If you’ve found a bug, spend the time to write a failing test. Bugs with tests get fixed.
+   Here’s an example: https://gist.github.com/swankjesse/981fcae102f513eb13ed
+   
+ - *Feature Request*: Start by telling us what problem you’re trying to solve. Don’t send pull requests to implement
+   new features without first getting our support. Sometimes we leave features out on purpose to keep the project small.
+
+^^^^^ DELETE FROM THIS LINE UP ^^^^^
 
 
 ```
 
-PASTE HERE ANY STACKTRACE OR OUTPUT FROM LEAKCANARY, IN BETWEEN THE TRIPLE BACKQUOTES. REMOVE THIS LINE <====
+{REPLACE THIS LINE WITH YOUR STACKTRACE OR OUTPUT FROM LEAKCANARY}
 
 ```
diff --git a/.travis.yml b/.travis.yml
index ad327f32..ee5ea2c7 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,21 +1,33 @@
 language: android
 
-android:
-  components:
-    - tools
-    - platform-tools
-    - build-tools-23.0.2
-    - android-23
-
 jdk:
-  - oraclejdk7
   - oraclejdk8
 
+before_install:
+  # Install SDK license so Android Gradle plugin can install deps.
+  - mkdir "$ANDROID_HOME/licenses" || true
+  - echo "d56f5187479451eabf01fb78af6dfcb131a6481e" > "$ANDROID_HOME/licenses/android-sdk-license"
+  - echo "24333f8a63b6825ea9c5514f83c2829b004d1fee" >> "$ANDROID_HOME/licenses/android-sdk-license"
+  # Install the rest of tools (e.g., avdmanager)
+  - sdkmanager tools
+  # Install the system image
+  - sdkmanager "system-images;android-16;default;armeabi-v7a"
+  # Create and start emulator for the script. Meant to race the install task.
+  - echo no | avdmanager create avd --force -n test -k "system-images;android-16;default;armeabi-v7a"
+  - $ANDROID_HOME/emulator/emulator -avd test -no-audio -no-window &
+
+install: ./gradlew clean build assembleAndroidTest --stacktrace
+
+before_script:
+  - android-wait-for-emulator
+  # 82 is KEYCODE_MENU
+  - adb shell input keyevent 82
+
 script:
-  - ./gradlew clean build
+  - ./gradlew leakcanary-android-instrumentation:connectedCheck --stacktrace
 
 after_success:
-  - .buildscript/deploy_snapshot.sh
+  - .buildscript/deploy_snapshot.sh || test true
 
 env:
   global:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index cce105ce..09990cb9 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,195 @@
 # Change Log
 
-All changes in 1.4+ are [tracked here](https://github.com/square/leakcanary/pulls?utf8=%E2%9C%93&q=milestone%3A1.4+is%3Apr).
+## Version 2.0 Alpha 1 (2019-04-23)
+
+**Thanks for testing the alpha**, we're counting on you to help us find bugs and suggest improvements!
+
+<img src="https://github.com/square/leakcanary/wiki/assets/logo-2.0-200px.png" />
+
+* New [logo](https://github.com/square/leakcanary/wiki/FAQ#who-made-the-logo), thanks [@flickator](https://github.com/flickator)!
+* Entirely rewritten to **100% Kotlin**
+* Multiple leaks detected in one analysis
+  * The heap is dumped when the app goes in the background, or when a minimum of 5 leaks is reached in the foreground.
+* Leak grouping
+  * Leaks that share similar causes are grouped in the UI.
+  * New screens to see the list of groups and each group.
+  * Improved leaktrace strings to highlight leak causes.
+  * Leaks can be shared to Stack Overflow
+* New library: **LeakSentry**.
+  * Detects when objects are leaking and triggers LeakCanary
+  * Can be used independently in production, for instance to report the number of leaking instances on an OutOfMemoryError crash.
+* New heap parser
+  * Uses **90% less memory and 6 times** faster than the prior heap parser.
+  * Runs in the same process as the app on a low priority thread.
+  * No more dependency on Perflib and TroveJ. New dependency on Okio.
+  * The old parser is still available as `leakcanary-android-perflib` but will be removed after alpha.
+* Labelers can add any string content to leak elements
+* 0 code setup, just add the one debug dependency.
+* Simpler configuration options
+* Updated from support library to Android X
+
+Many thanks to
+[@BraisGabin](https://github.com/BraisGabin),
+[@colinmarsch](https://github.com/colinmarsch),
+[@jrodbx](https://github.com/jrodbx),
+[@flickator](https://github.com/flickator),
+[@JakeWharton](https://github.com/JakeWharton),
+[@pyricau](https://github.com/pyricau),
+[@WhatsEmo](https://github.com/WhatsEmo)
+for the contributions!
+
+For more details, see the [2.0 Milestone](https://github.com/square/leakcanary/milestone/6) and the [full diff](https://github.com/square/leakcanary/compare/v1.6.3...master).
+
+## Version 1.6.3 (2019-01-10)
+
+* [#1163](https://github.com/square/leakcanary/issues/1163) Fixed leaks being incorrectly classified as "no leak" due to missed GC Roots.
+* [#1153](https://github.com/square/leakcanary/issues/1153) `LeakCanary.isInAnalyzerProcess` now correctly returns true in the analyzer process prior to any first leak (could be triggered by starting the leak result activity).
+* [#1158](https://github.com/square/leakcanary/issues/1158) Stopped enabling DisplayLeakActivity when not using DisplayLeakService.
+* [#1135](https://github.com/square/leakcanary/issues/1135) Fixed IndexOutOfBoundsException for leak traces of size 1.
+* [#1163](https://github.com/square/leakcanary/issues/1163) Keep "no leak" heap dumps.
+
+Many thanks to
+[@KMaragh](https://github.com/KMaragh),
+[@pyricau](https://github.com/pyricau),
+[@SebRut](https://github.com/SebRut)
+for the code contributions!
+
+For more details, see the [1.6.3 Milestone](https://github.com/square/leakcanary/milestone/5) and the [full diff](https://github.com/square/leakcanary/compare/v1.6.2...v1.6.3).
+
+
+## Version 1.6.2 (2018-10-16)
+
+* [#1067](https://github.com/square/leakcanary/issues/1067) Fixed TransactionTooLargeException crash (leak analysis would never complete).
+* [#1061](https://github.com/square/leakcanary/pull/1061) Detection of Fragment view leaks after Fragment#onDestroyView().
+* [#1076](https://github.com/square/leakcanary/pull/1076) Added the FOREGROUND_SERVICE permission for Android P.
+* [#1062](https://github.com/square/leakcanary/issues/1062) The LeakCanary toast now always shows correctly. It doesn't show if there is no activity in foreground.
+* [#1115](https://github.com/square/leakcanary/issues/1115) Reenabled the DisplayLeakActivity icon on fresh installs.
+* [#1100](https://github.com/square/leakcanary/pull/1100) Added nullability annotations to improve Kotlin support.
+* Updates to excluded leaks ([commits](https://github.com/square/leakcanary/commits/v1.6.2/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java)).
+* Updates to reachability inspectors ([commits](https://github.com/square/leakcanary/commits/v1.6.2/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java)).
+
+Many thanks to
+[@fractalwrench](https://github.com/fractalwrench),
+[@hzsweers](https://github.com/hzsweers),
+[@Goddchen](https://github.com/Goddchen),
+[@igokoro](https://github.com/igokoro),
+[@IlyaGulya](https://github.com/IlyaGulya),
+[@JakeWharton](https://github.com/JakeWharton),
+[@javmarina](https://github.com/javmarina),
+[@jokermonn](https://github.com/jokermonn),
+[@jrodbx](https://github.com/jrodbx),
+[@Parseus](https://github.com/Parseus),
+[@pyricau](https://github.com/pyricau),
+[@scottkennedy](https://github.com/scottkennedy)
+for the code contributions!
+
+### Public API changes
+
+* Subclasses of `AbstractAnalysisResultService` should now override `onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap)` instead of `onHeapAnalyzed(@NonNull HeapDump heapDump, @NonNull AnalysisResult result)`
+
+For more details, see the [1.6.2 Milestone](https://github.com/square/leakcanary/milestone/4) and the [full diff](https://github.com/square/leakcanary/compare/v1.6.1...v1.6.2).
+
+## Version 1.6.1 (2018-06-21)
+
+* [#727](https://github.com/square/leakcanary/issues/727) Improved leak analysis: LeakCanary now identifies and highlights the potential causes of the leak.
+* [#1011](https://github.com/square/leakcanary/issues/1011) We noticed that computing the retained heap size could take a long time, so it's now optional and off by default.
+* [#633](https://github.com/square/leakcanary/pull/633) Support for detecting leaks in instrumentation tests ([see the wiki](https://github.com/square/leakcanary/wiki/Customizing-LeakCanary#running-leakcanary-in-instrumentation-tests)).
+* [#985](https://github.com/square/leakcanary/pull/985) Ability to convert leak traces into stack traces for easy remote reporting ([see the wiki](https://github.com/square/leakcanary/wiki/Customizing-LeakCanary#uploading-to-a-server)).
+* [#983](https://github.com/square/leakcanary/issues/983) Support for watching destroyed Fragments.
+* [#846](https://github.com/square/leakcanary/issues/846) LeakCanary now uses foreground services and displays a notification when the analysis is in progress. This also fixes crashes when analyzing in background on O+.
+* The LeakCanary icon (to start to DisplayLeakActivity) is now hidden by default, and only enabled after the first leak is found.
+* [#775](https://github.com/square/leakcanary/issues/775) Fixed crash when sharing heap dumps on O+ and added a dependency to the support-core-utils library.
+* [#930](https://github.com/square/leakcanary/pull/930) DisplayLeakActivity has a responsive icon.
+* [#685](https://github.com/square/leakcanary/issues/685) Stopped doing IO on main thread in DisplayLeakActivity (fixes StrictMode errors).
+* [#999](https://github.com/square/leakcanary/pull/999) Updated HAHA to 2.0.4, which uses Trove4j as an external dependency (from jcenter) instead of rebundling it. This is to clarify licences (Apache v2 vs LGPL 2.1).
+* Several bug and crash fixes.
+
+Many thanks to [@AdityaAnand1](https://github.com/AdityaAnand1), [@alhah](https://github.com/alhah), [@christxph](https://github.com/christxph), [@csoon03](https://github.com/csoon03), [@daqi](https://github.com/daqi), [@JakeWharton](https://github.com/JakeWharton), [@jankovd](https://github.com/jankovd), [@jrodbx](https://github.com/jrodbx), [@kurtisnelson](https://github.com/kurtisnelson), [@NightlyNexus](https://github.com/NightlyNexus), [@pyricau](https://github.com/pyricau), [@SalvatoreT](https://github.com/SalvatoreT), [@shmuelr](https://github.com/shmuelr), [@tokou](https://github.com/tokou), [@xueqiushi](https://github.com/xueqiushi)
+ for the code contributions!
+
+Note: we made a 1.6 release but quickly followed up with 1.6.1 due to [#1058](https://github.com/square/leakcanary/issues/1058).
+
+### Public API changes
+
+* The installed ref watcher singleton is now available via `LeakCanary.installedRefWatcher()`
+* `AnalysisResult.leakTraceAsFakeException()` returns an exception that can be used to report and group leak traces to a tool like Bugsnag or Crashlytics.
+* New `InstrumentationLeakDetector` and `FailTestOnLeakRunListener` APIs for detecting leaks in instrumentation tests.
+* New `Reachability.Inspector` and `RefWatcherBuilder.stethoscopeClasses()` API to establish reachability and help identify leak causes.
+* Watching activities can be disabled with `AndroidRefWatcherBuilder.watchActivities(false)`, watching fragments can be disabled with `AndroidRefWatcherBuilder.watchFragments(false)`
+* `LeakCanary.setDisplayLeakActivityDirectoryProvider()` is deprecated and replaced with `LeakCanary.setLeakDirectoryProvider()`
+* New `RefWatcherBuilder.computeRetainedHeapSize()` API to enable the computing of the retained heap size (off by default).
+
+For more details, see the [1.6.1 Milestone](https://github.com/square/leakcanary/milestone/3) and the [full diff](https://github.com/square/leakcanary/compare/v1.5.4...v1.6.1).
+
+## Version 1.5.4 *(2017-09-22)*
+
+* Restore Java 7 compatibility in leakcanary-watcher
+
+## Version 1.5.3 *(2017-09-17)*
+
+* Fix broken 1.5.2 [build](https://github.com/square/leakcanary/issues/815)
+* Convert leakcanary-watcher from Android library to Java library
+* Disable finish animations in RequestStoragePermissionActivity
+* Corrected README sample for Robolectric tests
+
+For more details, see the [full diff](https://github.com/square/leakcanary/compare/v1.5.2...v1.5.3).
+
+## Version 1.5.2 *(2017-08-09)*
+
+* New excluded leaks
+* Move Leakcanary UI into leak analyzer process
+* Ignore computing retained sizes for bitmaps on O+
+* Add notification channel for persistent messages on O+
+* Exclude permission activity from recents menu
+* Updated README and sample for handling Robolectric tests
+
+For more details, see the [full diff](https://github.com/square/leakcanary/compare/v1.5.1...v1.5.2).
+
+## Version 1.5.1 *(2017-04-25)*
+
+* New excluded leaks
+* Fix java.util.MissingFormatArgumentException in DisplayLeakService
+* Separate task affinities for different apps
+* Bump minSdk to 14
+* Fix HahaHelper for O Preview
+  
+For more details, see the [full diff](https://github.com/square/leakcanary/compare/v1.5...v1.5.1).
+
+## Version 1.5 *(2016-09-28)*
+
+* New excluded leaks
+* Added `LeakCanary.isInAnalyzerProcess()` to the no-op jar
+* Fixed several file access issues:
+  * No more cleanup on startup, we rotate the heap dump files on every new heap dump.
+  * LeakCanary now falls back to the app directory until it can write to the external storage.
+* Leak notifications now each use a distinct notification instead of erasing each other.
+* If LeakCanary can't perform a heap dump for any reason (e.g. analysis in progress, debugger attached), it retries later with an exponential backoff.
+* Added confirmation dialog when user deletes all leaks.
+* Replace the two LeakCanary configuration methods with a builder that provides more flexibility, see `LeakCanary.refWatcher()`.
+
+For more details, see the [full diff](https://github.com/square/leakcanary/compare/v1.4...v1.5).
+
+### Public API changes
+
+* New `HeapAnalyzer.findTrackedReferences()` method for headless analysis when you have no context on what leaked.
+* Added `LeakCanary.isInAnalyzerProcess()` to the no-op jar
+* Added `LeakCanary.refWatcher()` which returns an `AndroidRefWatcherBuilder` that extends `RefWatcherBuilder` and lets you fully customize the `RefWatcher` instance.
+* Removed `LeakCanary.install(Application, Class)` and `LeakCanary.androidWatcher(Context, HeapDump.Listener, ExcludedRefs)`.
+* Removed `R.integer.leak_canary_max_stored_leaks` and `R.integer.leak_canary_watch_delay_millis`, those can now be set via `LeakCanary.refWatcher()`.
+* Updated the `LeakDirectoryProvider` API to centralize all file related responsibilities.
+* `RefWatcher` is now constructed with a `WatchExecutor` which executes a `Retryable`, instead of an `Executor` that executes a `Runnable`.
+* `HeapDumper.NO_DUMP` was renamed `HeapDumper.RETRY_LATER`
+
+## Version 1.4 *(2016-09-11)*
+
+* Fix false negative where GC root is of type android.os.Binder [#482](https://github.com/square/leakcanary/issues/482)
+* Update HAHA to 2.0.3; clear compiler warnings [#563](https://github.com/square/leakcanary/issues/563) 
+* Correct some mistakes in German translation [#516](https://github.com/square/leakcanary/pull/516)
+* Don't loop when storage permission denied [#422](https://github.com/square/leakcanary/issues/422)
+* Remove old references to "__" prefixed resources [#477](https://github.com/square/leakcanary/pull/477)
+* Fix permission crash for DisplayLeakActivity on M [#382](https://github.com/square/leakcanary/issues/382)
+* Fix NPE when thread name not found in heap dump [#417](https://github.com/square/leakcanary/issues/417)
+* Add version info to stacktrace [#473](https://github.com/square/leakcanary/issues/473)
 
 ## Version 1.4-beta2 *(2016-03-23)*
 
diff --git a/README-1.6.md b/README-1.6.md
new file mode 100644
index 00000000..aea17551
--- /dev/null
+++ b/README-1.6.md
@@ -0,0 +1,86 @@
+
+# LeakCanary
+
+A memory leak detection library for Android and Java.
+
+*“A small leak will sink a great ship.”* - Benjamin Franklin
+
+<p align="center">
+<img src="https://github.com/square/leakcanary/wiki/assets/screenshot.png"/>
+</p>
+
+## Getting started
+
+In your `build.gradle`:
+
+```groovy
+dependencies {
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.3'
+  releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.3'
+  // Optional, if you use support library fragments:
+  debugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.3'
+}
+```
+
+In your `Application` class:
+
+```java
+public class ExampleApplication extends Application {
+
+  @Override public void onCreate() {
+    super.onCreate();
+    if (LeakCanary.isInAnalyzerProcess(this)) {
+      // This process is dedicated to LeakCanary for heap analysis.
+      // You should not init your app in this process.
+      return;
+    }
+    LeakCanary.install(this);
+    // Normal app init code...
+  }
+}
+```
+
+**You're good to go!** LeakCanary will automatically show a notification when an activity or support fragment memory leak is detected in your debug build.
+
+**What's next?** You could watch a [live investigation](https://www.youtube.com/watch?v=KwArTJHLq5g) then [customize LeakCanary](https://github.com/square/leakcanary/wiki/Customizing-LeakCanary) to your needs.
+
+## FAQ
+
+* [Why should I use LeakCanary?](https://github.com/square/leakcanary/wiki/FAQ#why-should-i-use-leakcanary)
+* [How does it work?](https://github.com/square/leakcanary/wiki/FAQ#how-does-it-work)
+* [How do I fix a memory leak?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-fix-a-memory-leak)
+* [How do I customize LeakCanary to my needs?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-customize-leakcanary-to-my-needs)
+* [Where can I learn more?](https://github.com/square/leakcanary/wiki/FAQ#where-can-i-learn-more)
+* [How do I copy the leak trace?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-copy-the-leak-trace)
+* [Can a leak be caused by the Android SDK?](https://github.com/square/leakcanary/wiki/FAQ#can-a-leak-be-caused-by-the-android-sdk)
+* [How can I dig beyond the leak trace?](https://github.com/square/leakcanary/wiki/FAQ#how-can-i-dig-beyond-the-leak-trace)
+* [How do disable I LeakCanary in tests?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-disable-leakcanary-in-tests)
+* [How do I fix build errors?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-fix-build-errors)
+* [How many methods does LeakCanary add?](https://github.com/square/leakcanary/wiki/FAQ#how-many-methods-does-leakcanary-add)
+* [How do I use the SNAPSHOT version?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-use-the-snapshot-version)
+* [How can I be notified of new releases?](https://github.com/square/leakcanary/wiki/FAQ#how-can-i-be-notified-of-new-releases)
+* [Who's behind LeakCanary?](https://github.com/square/leakcanary/wiki/FAQ#whos-behind-leakcanary)
+* [Why is it called LeakCanary?](https://github.com/square/leakcanary/wiki/FAQ#why-is-it-called-leakcanary)
+* [Who made the logo?](https://github.com/square/leakcanary/wiki/FAQ#who-made-the-logo)
+* [Instant Run can trigger invalid leaks](https://github.com/square/leakcanary/wiki/FAQ#instant-run-can-trigger-invalid-leaks)
+* [I know I have a leak. Why doesn't the notification show?](https://github.com/square/leakcanary/wiki/FAQ#i-know-i-have-a-leak-why-doesnt-the-notification-show)
+
+<p align="center">
+<img src="https://github.com/square/leakcanary/wiki/assets/icon_512.png" width="250"/>
+</p>
+
+## License
+
+    Copyright 2015 Square, Inc.
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
diff --git a/README.md b/README.md
index ce382529..fee7b5a0 100644
--- a/README.md
+++ b/README.md
@@ -1,40 +1,138 @@
 # LeakCanary
 
-A memory leak detection library for Android and Java.
+A memory leak detection library for Android and Kotlin.
 
 *“A small leak will sink a great ship.”* - Benjamin Franklin
 
-![screenshot.png](assets/screenshot.png)
+<p align="center">
+<img src="https://github.com/square/leakcanary/wiki/assets/screenshot-2.0.png"/>
+</p>
 
 ## Getting started
 
-In your `build.gradle`:
+Add LeakCanary to your `build.gradle`:
 
-```gradle
- dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.4-beta2'
-   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.4-beta2'
-   testCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.4-beta2'
- }
+```groovy
+dependencies {
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-1'
+}
 ```
 
-In your `Application` class:
+**You're good to go!** LeakCanary will automatically show a notification when an activity or fragment memory leak is detected in your debug build.
+
+Note: LeakCanary 2 is in alpha. To set up LeakCanary 1.6, go to the [1.6 Readme](https://github.com/square/leakcanary/blob/master/README-1.6.md).
+
+## Presentations
+
+* [LeakCanary, then what? Nuking Nasty Memory Leaks](https://www.youtube.com/watch?v=fhE--eTEW84)
+* [Memory Leak Hunt](https://www.youtube.com/watch?v=KwArTJHLq5g), a live investigation.
 
-```java
-public class ExampleApplication extends Application {
+## Recipes
 
-  @Override public void onCreate() {
-    super.onCreate();
-    LeakCanary.install(this);
+### Watching custom objects
+
+```kotlin
+class MyService : Service {
+
+  // ...
+
+  override fun onDestroy() {
+    super.onDestroy()
+    LeakSentry.refWatcher.watch(this)
   }
+
 }
 ```
 
-**You're good to go!** LeakCanary will automatically show a notification when an activity memory leak is detected in your debug build.
+### Configuring LeakSentry & LeakCanary
+
+LeakSentry is in charge of detecting memory leaks. Its configuration can be updated at any time by replacing `LeakSentry.config`:
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakSentry.config = LeakSentry.config.copy(watchFragmentViews = false)
+  }
+}
+```
+
+LeakCanary is in charge of taking heap dumps and analyzing them. Its configuration can be updated at any time by replacing `LeakCanary.config`:
+
+```
+disableLeakCanaryButton.setOnClickListener {
+  LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
+}
+```
 
-Questions? Check out [the FAQ](https://github.com/square/leakcanary/wiki/FAQ)!
+### Counting retained instances in production
+
+In your `build.gradle`:
+
+```groovy
+dependencies {
+  implementation 'com.squareup.leakcanary:leakcanary-sentry:2.0-alpha-1'
+}
+```
+
+In your leak reporting code:
+```kotlin
+val retainedInstanceCount = LeakSentry.refWatcher.retainedKeys.size
+```
+
+### Alternate setup with the old perflib heap parser
+
+If you want to try LeakCanary 2.0 features with the battle tested perflib heap parser, use a different dependency:
+
+```groovy
+dependencies {
+  // debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-1'
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android-perflib:2.0-alpha-1'
+}
+```
+
+In your **debug** `Application` class:
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    if (LeakCanary.isInAnalyzerProcess(this)) {
+      // This process is dedicated to Perflib for heap analysis.
+      // You should not init your app in this process.
+      return
+    }
+    super.onCreate()
+  }
+}
+```
 
-![icon_512.png](assets/icon_512.png)
+## FAQ
+
+Note: the entries in this FAQ have not been updated for LeakCanary 2 yet.
+
+* [Why should I use LeakCanary?](https://github.com/square/leakcanary/wiki/FAQ#why-should-i-use-leakcanary)
+* [How does it work?](https://github.com/square/leakcanary/wiki/FAQ#how-does-it-work)
+* [How do I fix a memory leak?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-fix-a-memory-leak)
+* [How do I customize LeakCanary to my needs?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-customize-leakcanary-to-my-needs)
+* [Where can I learn more?](https://github.com/square/leakcanary/wiki/FAQ#where-can-i-learn-more)
+* [How do I copy the leak trace?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-copy-the-leak-trace)
+* [Can a leak be caused by the Android SDK?](https://github.com/square/leakcanary/wiki/FAQ#can-a-leak-be-caused-by-the-android-sdk)
+* [How can I dig beyond the leak trace?](https://github.com/square/leakcanary/wiki/FAQ#how-can-i-dig-beyond-the-leak-trace)
+* [How do disable I LeakCanary in tests?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-disable-leakcanary-in-tests)
+* [How do I fix build errors?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-fix-build-errors)
+* [How many methods does LeakCanary add?](https://github.com/square/leakcanary/wiki/FAQ#how-many-methods-does-leakcanary-add)
+* [How do I use the SNAPSHOT version?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-use-the-snapshot-version)
+* [How can I be notified of new releases?](https://github.com/square/leakcanary/wiki/FAQ#how-can-i-be-notified-of-new-releases)
+* [Who's behind LeakCanary?](https://github.com/square/leakcanary/wiki/FAQ#whos-behind-leakcanary)
+* [Why is it called LeakCanary?](https://github.com/square/leakcanary/wiki/FAQ#why-is-it-called-leakcanary)
+* [Who made the logo?](https://github.com/square/leakcanary/wiki/FAQ#who-made-the-logo)
+* [Instant Run can trigger invalid leaks](https://github.com/square/leakcanary/wiki/FAQ#instant-run-can-trigger-invalid-leaks)
+* [I know I have a leak. Why doesn't the notification show?](https://github.com/square/leakcanary/wiki/FAQ#i-know-i-have-a-leak-why-doesnt-the-notification-show)
+
+<p align="center">
+<img src="https://github.com/square/leakcanary/wiki/assets/logo-2.0.png" />
+</p>
 
 ## License
 
diff --git a/assets/icon_1024.png b/assets/icon_1024.png
deleted file mode 100644
index f15c7586..00000000
Binary files a/assets/icon_1024.png and /dev/null differ
diff --git a/assets/icon_512.png b/assets/icon_512.png
deleted file mode 100644
index 0ca6bedf..00000000
Binary files a/assets/icon_512.png and /dev/null differ
diff --git a/assets/screenshot.png b/assets/screenshot.png
deleted file mode 100644
index 8faa278f..00000000
Binary files a/assets/screenshot.png and /dev/null differ
diff --git a/assets/source_icon.png b/assets/source_icon.png
deleted file mode 100644
index d04aace6..00000000
Binary files a/assets/source_icon.png and /dev/null differ
diff --git a/assets/vector_icon.afdesign b/assets/vector_icon.afdesign
deleted file mode 100644
index a30fcf97..00000000
Binary files a/assets/vector_icon.afdesign and /dev/null differ
diff --git a/assets/vector_icon.svg b/assets/vector_icon.svg
deleted file mode 100644
index 9a17f0dc..00000000
--- a/assets/vector_icon.svg
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" standalone="no"?>
-<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
-<svg width="100%" height="100%" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421;">
-    <image id="Container" x="33" y="44" width="443px" height="441px" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbsAAAG5CAYAAAAXoZoVAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAcMklEQVR4nO3dT4gkZ/nA8Wd6Zmc3mw1ZXEmCfxJCfgZJMDEHwaiRmEsQEolBAkET0Jw96CEXQQRFDyKePOXgIRhFBFFEzCFBEzRIFj0kIaJBCQZB8mezJG522Z3q38Gttqamqrq6u7q76u3PB4bu6Z3p6V525rvPW2/1bI3H4wCAlO2s+wF0YazYAEu1tbW1te7HsIitvnZi1oD19XkADF3bzvU5iL2KXVPg+vQ4Afivur71LXxrjd08cZv1dgDm0xCymT9v3fFbS+zqIld1c/E2oQNYraZGFf+sbRjXFb2Vxq4cuVnill+f9jkAdKdmSqv98/z9utsL7680eiuJ3bTINUWtTfAEEGBxbaazadfrLuu+xqqit9TYtY1c02Xx+iuvvBJ///vf44033ojXX39939upU6fi/PnzS3suAJvm6NGj8a53vStOnDhx4O2GG26Iyy67bF/UpgVvykS41OgtLXbF0LWJXPn6eDyOLMvixRdfjD/84Q/xzDPPxCuvvLKUxwrAbLa3t+PGG2+MW2+9NT7+8Y/HVVddVRu+ttFbZvCWEru60E2LW/7+yZMn46mnnoo//vGPcerUqc4fHwDduvbaa+NjH/tY3HHHHfH+97//QOzaRm9Zwes8dk2hqwpc8e2FF16IRx55JF588cVOHxMAqzEajeLOO++MBx54IE6cOHEgdnVTX/5+4Xqn0es0dnnoZo3cyy+/HD/84Q/jmWee6eyxALA+hw8fjnvvvTfuu+++OHr0aG30Wmxo6SR6ncWuKXTF4GVZNnn/9ddfj0cffTQef/zxyLKsk8cBQH9cfvnlcf/998fdd98dOzs7MRqN1jLldRK7cuiaJrk8di+88EJ885vfjDfffHPhrw9Av910003xta99LS6//PLK4LU4prdQ8BaOXVXoyteL01yWZfH444/HD37wA6cKAGyQq666Kr7xjW/ENddcsy94xesR1Ts4L16fO3gLxa4pdOXAjcfjuHDhQjzyyCPxi1/8Yu6vCcBwXXLJJfHwww/HRz/60QOhy9+P6D54c8euLnRVy5ZZlsXbb78d3/nOd+JPf/rTXF8PgDSMRqN48MEH47777psErjzpRXQbvLli1yZ0eeTG43GcPXs2Hn744fjb3/4289cCIE33339/fOELX5jEboZjeTPHbjTrJ0wLXR65/G1vby++//3vCx0A+/zkJz+Jp59+el8zql5opGLz48xT2kyxaxO6cvB++tOfxlNPPTXr4wIgcePxeDIMlQelvCX5x5WDN6vWsWuz67IYur29vXjmmWfi0UcfneuBAZC+c+fOxbe+9a14/fXXY29v78B0V3cO9qzT3czLmGVV01yWZfGPf/wjvve9781dYQA2w2uvvRbf/va349y5c5PglaO36HJmq9i13XmZR+/8+fPx3e9+N86ePTvjUwZgE/3lL3+Jxx57rHI5s4vgzbKMObms25Syt7cXe3t78cQTT8Q///nPmZ8sAJvrV7/6Vbz66qv7pru6jSuzmhq7umpWLV1mWRZnz56Nxx57bK4HA8DmOnfuXPz4xz9unOwiKl+acmoBG2NXt3xZdQAxn+x++ctfxhtvvLHI8wVgQz355JPx8ssvVwYvovp3oLZRG7um43TF94uhO336dPz85z9f4GkCsMmyLItHH320cikzD1+VadPdPCeVVz6ALMviZz/7WZw5c2bWuwSAiZMnT8YLL7xQu5xZNe1N03Y3Zu3GlPzy3Llz8cQTTyz2DAEgIn7zm9/UblKJ2H+ud65pupt2zO7A+3U7MZ977rl455135n5iAJD785//HOfOnTvwiirTNqvUqYxdsY5NU13x7dlnn+3sSQKw2c6cORPPP//8zKcf1E13TRtUDrxftwPzwoULcfLkyXmfEwAc8Oyzzx54RZWmE82bHIhduYrTjtVlWRYvvfRSnDp1qsOnCMCmO3ny5NRXVClqOu+u1TE7S5gArNqpU6fipZdeqvxtCAtNduVz66quF79I/sWff/75zp4cAOSee+65A92JmP3k8rkmu/JS5muvvdbFcwKAfV577bXaya5K3e1TN6hM24l54cKFePvttzt4SgCw36lTpxo3pjQcv9t3Q9UGlcovWBe9U6dO1f5yPQBYxOnTpw9siqwLXdNS5iR2bXZhVk13dmECsCz5QDXvKQe5upPKay/L46TYAbAsp0+frvzt5RHVQ1l+e1mb32d34LI42fl1PgAsS/4bdeZZuiyuWJZPPaj7hNr10rfeemumURIA2sjbknemKXjT4je6+IeVx+uK18vn2816jgMAzKrq/O7OjtkVv0j5/brz7QCgK3UDVvH9qo+r0+qYXdOOTABYhmLQyptT8tvbrjI2nlRe9UnlOy4Gz4QHQNfqdl+2+Zxcq5PKpx0QBIBlatpL0mZH5kynHtSdhgAAy9IUtrYNmhq7ui8qdACsUlN7Fj6pvOmLAsCyNZ0C19bUUw+6GB8BoAvzrio2vjZm1W2WLwFYpabuzH3MziuiANB3bU8mzxV/xU/ndw4AXVnkUNpcG1SEDoB1mLc/c+/GXOSLAsAsFu1NqxeCFjUA1qWLMwFaT3ZVr54CAKuySHcWWsYEgCEQOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTO4ABGI/H634IgyZ2AAMwHo8jy7J1P4zBEjuAARG8+YgdwMAI3uzEDqDnqo7XCd5sxA5goASvPbED6LmmnZiC147YAQyc4E0ndgA91vb8OsFrJnYAiRC8emIHkJAsy7zaSgWxA+ixecI1Ho8Fr0TsABIkePuJHUBPLRorwfsfsQNImOD9l9gB9FRXkRI8sQPYCJsePLED2BCbHDyxA+ihZUVpU4MndgAbZhODJ3YAPbTsGG1a8MQOYENtUvDEDqBnVhmgTQme2AFsuE0IntgB9Mw6wpN68MQOgIhIO3hiB8BEqsETO4Ae6UNoUgye2AFwQGrBEzsAKo3H48iybN0PoxNiB9AjfZymUgie2AEw1dCDJ3YAPdHHqa5oyMETOwBaG2rwxA6AmQwxeGIH0BN9X8YsGlrwxA6AuQwpeGIHwNyGEjyxA+iBIS1hlg0heGIHwML6HjyxA+iBIU92uT4HT+wA6Exfgyd2AHQqy7LeTapiB7BmfQtDF/r2K4LEDoCl6FPwxA6ApelL8MQOYM36EINl6kPwxA6ApVt38MQOYI3WPfGs0jqDJ3YArMy6gid2AKzUOoIndgBrtEnLmEWrDp7YAbAWqwye2AGwNqsKntgBrMmmLmGWrSJ4YgfA2i07eGIHsCYmu/2WGbydpdwrAMxB7ADYCMsInmVMgDWwhNms6yVNkx0AvZTHrovomewA6K3xeBx7e3sL34/YAayBZczVEjsAkid2ACRP7ABWzBLm6okdAMkTOwCSJ3YAK2YZc/XEDoDkiR3ACpnq1kPsAEie2AGQPLEDWCHLmOshdgAkT+wASJ7YAayIJcz1ETsAkid2ACRP7ABWxDLm+ogdAMkTO4AVMNWtl9gBkDyxAyB5YgewApYx10vsAEie2AGQPLEDWDJLmOsndgAkT+wASJ7YASyZZcz1EzsAkid2ACRP7ACWyBJmP4gdAMkTO4AlMtn1g9gBkDyxAyB5YgewJJYw+0PsAEie2AGQPLEDWBLLmP0hdgAkT+wASJ7YASyBJcx+ETsAkid2AEtgsusXsQMgeWIH0DFTXf+IHQDJEzsAkid2AB2zjNk/YgdA8sQOoEOmun4SOwCSJ3YAJE/sADpkGbOfxA6A5IkdQEdMdf0ldgAkT+wASJ7YAXTEMmZ/iR0AyRM7gA6Y6vpN7ABIntgBkDyxA+iAZcx+EzsAkid2AAsy1fWf2AGQPLEDWJDJrv/EDoDkiR3AAkx1wyB2ACRP7AAWYLIbBrEDIHliBzAnU91wiB0AyRM7gDmZ7IZD7ABIntgBzMFUNyxiB0DyxA5gDia7YRE7AJIndgAkT+wAZmQJc3jEDoDkiR3AjEx2wyN2ACRP7ABmYKobJrEDIHliBzADk90wiR0AyRM7gJZMdcMldgAtid1wiR0AyRM7gBZMdcMmdgAkT+wAWjDZDZvYAUwhdMMndgAkT+wApjDZDZ/YATQQujSIHQDJEzuABia7NIgdAMkTO4Aaprp0iB1ADbFLh9gBkDyxA6hgqkuL2AGQPLEDqGCyS4vYAZQIXXrEDoDkiR1AickuPWIHUCB0aRI7AJIndgAFJrs0iR3ARUKXLrEDuEjs0iV2ACRP7ADCVJc6sQMIsUud2AEbT+jSJ3YAJE/sgI1nskuf2AEbTeg2g9gBG03sNoPYARtL6DaH2AGQPLEDNpbJbnOIHbCRhG6ziB2wkcRus4gdsHGEbvOIHbBxxG7ziB2wUYRuM4kdsFHEbjOJHbAxhG5ziR2wMcRuc4kdsBGEbrOJHbARxG6ziR2QPKFD7ABIntgByTPZIXZA0oSOCLEDEid2RIgdkLAsy9b9EOgJsQOSZKKjSOyAJIkdRWIHJEfoKBM7IDliR5nYAUkROqqIHZCM8XgsdlQSOyAZQkcdsQOSIHQ0ETsgCWJHE7EDBs8rpTCN2AGDZqKjDbEDBk3saEPsgMGyfElbYgcMkomOWYgdMEhixyzEDhgcy5fMSuyAQTHRMQ+xAwbDa18yL7EDBkPomJfYAYPgOB2LEDug94SORYkd0GuWLumC2AG9ZUMKXRE7oJeEji6JHdBLQkeXxA7oHRtS6JrYAb0idCyD2AG9IXQsi9gBvSB0LJPYAWsndCyb2AFrJXSsgtgBayN0rMrOuh8AsHmcMM6qmeyAlRI61kHsgJUROtbFMiawEo7PsU4mO2DphI51M9kBS2PZkr4w2QFLIXT0ickO6JTI0UcmO6AzQkdfmeyAhYkcfSd2wELstGQIxA6Yi2mOIRE7YCYixxCJHdCKyDFkYgc0EjlSIHasXJZlsbW1FRExuaR/RI6UiB0rNxqNJjv48h+m4tcfIkeKxI612Nra2vcDNb9ejJ/wrY7AkTqxYy3ykNX9gC3+8DX1LUf5PxiQMrFjbaYFL1c19ZXvg/ZMcWwisWOt2gavqGr5UwDrmeBA7OiBeYJXJoD/I25wkNjRC10Er2xaAKveH5qq5wgcJHb0xjKCV1a+7/L7fYzhtMcMTCd29Er5lIRVaxuWZUZQzKB7YkfvFE867ytBgmHxm8rppdHIP02gO36i0FuCB3TFTxN6TfCALvhJQu/1YUckMGxiR+95UWhgUWLHIAgesAixYzAED5iX2DEoggfMQ+wYHMEDZiV2DJLYAbMQOwbLOXhAW35aMGiCB7ThJwWDJ3jANH5KkATBgzR19RtGOvkJMR6P/coT1k7wgDoL/3QQOfrELk1ITxedETuS4hw8SEfely6+p2f+TeX5F80vd3d3DwTPDxvWKf/35z9iMEzlQ2NHjx5d+D4bJ7titOoCdvz48YUfBHTNhAdpGI/HnXSm1TJm0w+N48eP26BCLwkeDN9oNIqdnf8uQi7y/bzQMbutra1J7CIsG9E/ggfDlA9R29vbB76H5/menil25eN1Ef9bxiwGT/ToE7GD4Sg2ZDwex+7ubkQs/n0892SXf+FDhw7FkSNHRI5ecw4eDEfek/F4HIcPH+7kPg/8BKia3qY5duxYZFkmePSa4EH/Fae6LMv27cRc5LDE5Lu/audl8Y7z6+UvtrW1FVdfffXkgRWLDH0jeNBfeTeyLJv05IMf/GDtx88Svrl3Yxajd8stt+yLnNDRZ4IH/VXuyJ133lk7jJVvazLzd33VtHfjjTfGzs7OvhoLHn1m0wr0S3lgyrIsLrvssrjkkksioj5ubb+Xp8auakmzfPvu7m584AMfOPBgBY++ckoC9E+5HzfccMOBASs36/fwzMuYdcfxbr755kmNTXcMgeBBP5Qnurwhd9111+Rj6vaNlP88v14208uFFd8fjUb73r/lllsiIg7ETvDoM8GDfijH7vDhw3HixInGwEV0sIzZtD5anuxGo1EcO3Ysrr/++skDNd0xFIIH61McjPb29ib9+NCHPhQRBye6qgmvaQPL1sUrtefZVX3itLd77rknIv473eUPWvAYAsGD9SlOdFmWxWg0igcffHCygjjtFLj8z5qMLn5Q5Ue1CV3xwVx99dVx880373vQgsdQCB6sVnnpMn+7/fbbY2dnp7Y1uaYJr2zfZFd3MnnVHRe/8Gg0mrz/2c9+Nkaj0b7pLg8e9J3YwWqUQ5f34vDhw3HvvfdWtqZpKXOa1rsxq0JXFbwTJ07ErbfeeuAJmO4YCiedw/IVY1fsxF133XVgiKoL3iym7sactpRZfkCj0SjuuuuuOHLkyIHgmfAYCsGD5akKXZZlcezYsbj99ttbha7NZpWi4mtjbhWuR/F6U+TKoct3Zt5zzz2T3TX5m+AxJIIH3SsvXeZvEREPPfTQvpZU9WWWwBW71njqQd0xvKoHUH679dZb47bbbjvwhCxpMiSCB92pCl3ehM985jNx3XXX1TalzUTXFL+ppx7s++DSMbppwbvnnnvi+uuvPzDhFZ8g9J1NK7C4uokuy7L48Ic/HJ/61Kcae1IVvogOTyov17NqU8r29nZsb2/vu769vR07OzvxxS9+Md797ndXPkHBYwickgDzq9p1WezAlVdeGQ888EBlT+qO3eUrLrMEr3zqwVbp/amnGxTfqh7kJZdcEg899NBkw8re3l5cuHBB9BgUwYPZTQvdkSNH4itf+cq+IanclLrJru6E81y5Z5WTXdU3dfmYXV3sytPdaDSKK664Ir70pS/FpZdeOnmiefAuXLjgtTQZBMGD9so7Li9cuDB5y0P31a9+NXZ3d/c1o9yPcgSrljDLmyqrtHoh6KolzDbLmMW3a6+9Nr785S/HVVdddWDCK056gkefCR40K09yxcjlP+OvuOKK+PrXvx4nTpyobUbdcmbVSmPE9KXMrXJYxhdvyG+vezmX4oSWv50/f37fW/G2/Pq5c+fiRz/6Ubz44osHgrnoAUhYFf8pg/9p04v89ptuuik+//nPx87OTuzs7MShQ4cml8W34m07OzuTfSBVS5s1097+w3JV37DF4FX9nqHiiYDF2FXFrer63t5ePP744/G73/0uxuNx662mxScC6yZ4bLJi4PLL/JBU3YuJfPrTn45PfvKTk9CVg1YVu/zjyhNf1QnnEZPVlwOh2Jn2hOpOMB+NRvtCtb29HVmWxfb29r44lq/n7rzzznjPe94Tv/71r+PNN9+cfEzTQUjRo2/KsVvVv0uRZV2qIlc1zRV//h87dizuv//+uO666/aFrhixqqDVDUER1b8Boen7r3Kyu/gExuUn07SzpmrCq7osr9+eP38+fv/738fTTz8dZ86cqTwmWF6jLT4p0WPdsiw7cNss/y6FiyGoi1x5oitGbnd3N+6444647bbb9gWtagmzPMnVLV/WTXVNOzEjpsSu6olVjal1wSsvX1a95Z979uzZePLJJ+PZZ5+N8+fP5w+41XQnfKxbVfBg6MqBy69PexuNRvGRj3wk7r777srzr8tBqwpeOY7FvR1NG1SqQhfRInZ1T65us0rTlNcUu/x+Tp8+Hb/97W/jr3/9a5w+fbr2pWBm2XIKq2BCY+hq9nBMvcyv7+7uxv/93//F5z73uX2nFIxGowNTXTl2VaErLm222c9RF7qIhthdfBKV013T7sxi7PLrdbErfnz5tdKyLIt//etf8dxzz8VLL70Ur776aozH48a4iR3rZsIjReXJLre1tRWXXnppXHfddfGJT3wirrzyysoXGilPdfn1cuzKf15cuqyLXf44Ll7WRqBxg8rW1tbWeDweb21tVYam+CK5xSBub2/vu738ufnnFx9slmWT9/PYve9974v3vve9kWVZvPnmm/H888/Hv//97/jPf/4Tb7/9dpw5cybeeeedyStmQx+Y8PzHMzWHDh2Ko0ePxtGjR+PYsWNx2WWXxTXXXBM33HBDHDp0qPbFRupiV/fWZnPKvJsVGye7iNmWM8sTXtWUV/V+eSmz/Mv8ipcR//vfc/7Q3nrrrTh9+vTkXI6K59DqLwO6UPXvcJYf/rMszYsKXakaSI4cORLHjx+P3d3dykNJxWNnTS8fWXUMrs2uzGmxm7YppWjqqQfT/kKK013bzys/2PyJ7O3t7bssb2HNL/OvmQf3+PHjcfnll0/uX9wAFtO0EXBa7KpeVaspeMWPaTPRVYR56v/62pxnt5VPd1XLmfn7VUuadX9xTX9J+bl2VedrlF9Dc9qBUwBmV7cBsOqt/HO8OJHl8aqb3KpCV/U6mFN247da3mg12TUFLw9T/mfTJr3yX9CisWsKnegBtFe3hF6MTP4zvnwKQNMSZjl4dUuW5dAVL2seb+t1/NbLmMXglZUjVfXAmv5XUPwL2tvbm1xWnYnfdrorEj2AZlXdqDtOV/czfNpSZtUUV7fjsuo8ulk3pRTNdMyubndmfhwtD115a+rW1lbs7e21Cl1+P/nLj9UFL/+65ejltxeJHUCzqg0q+WXT8bq6ya4ueOX4lT+nvPJXt3w5q5k3qBT/IuqCF1G9caX8wIuvhZmHLo9c+UVEy8ErT3WWMQEWN+/xuvyyKmDTLquWLqeFbpYlzIj5dmNuRfz3lIS2wav7i8oDVjxel7+VJ7umY3Y2qAB0p2ITyIHrdfsuqia8umXKNrsuuwhdxAKTXfEvpSp4VRGqi13dppSqJcy6pczi15nyqjCLPmWAQZvWirbTXdMmlbZvVeEsfr2KxzHXOubUk8qnqXpJsfyyHKaqKa0pblWhm2eDSuGxLvRcAVIxa/CmLWVWxW7abVX3Ufxa5cc5b+giOpjsCg+i8mXBImIy6eVPKP+44kuEFSe7cgyrohlxcKqzMQVgfk2bVPLLWSa8utvaHpvrKnQR3Sxj7juGd/H6gfG3ahorhq94vK9qils0dMIHUK0ucsXrs054VZfFZcqmaa7iMSz8unidTXZFVcfxqp5EHqliDIvBKx77swuTFJT/bXbwPQxLUTdl1U1jVZNa06aTVYYuooNjdmXjwh2WA1QVqbpz5preive9yPKlKAKbpm07Zpnuqm6bthu/+Gd1j62r0EUsIXYR9cHL36+bzOomt2nTXNVzEDKA+bQ5dpdfNgWv7rbi7VVfs8vITe5zWVEYV9xx06RXvK3NRDht96XYAcynqjU1m0Yqp7Sm61X3Ubi+tHX9pcUuV45e06TX9v3y/diMAtCtWTetlC+bPr7mPpd6AHvpscu1mfTa3NZ0e9X9AjC7pumu6s/nCVzhtqXv1FpZ7HJtJr26P2vz523+DICD2jRnWvCabq+4r5VtR1557HLTJr2m29s8ZrEDmM0s7ZkWtKb7WmXkJl9z3VGoil7hz5o+b9r9zv+gADbQtAbNOvkVblv7CaVrj13ZvPEDYHVahm/tkcv1LnZlTfEDoD/6FLey3seujggCrFafYzbNYGMHAG39P8QjHPIeCPK8AAAAAElFTkSuQmCC"/>
-    <path id="Canary Badge" d="M112.189,145.49L254.837,81.3501L396.288,145.49C396.288,145.49 396.862,207.984 396.288,231.803C400.997,350.37 312.745,416.946 254.837,430.897C196.973,416.761 109.794,350.592 112.189,231.803C112.756,203.667 112.189,145.49 112.189,145.49ZM175.089,342.14C175.089,342.14 184.466,327.557 200.474,320.28C204.922,315.034 207.831,307.409 215.292,300.115C219.468,296.033 226.552,291.174 233.166,288.656C239.785,286.137 247.648,284.843 255,285C262.352,285.157 268.152,286.319 277.281,289.599C300.356,298.133 328.246,333.945 334.028,349.404C315.038,361.253 296.986,374.343 277.281,397.842C273.2,395.993 262.831,392.31 245.929,394.232C225.332,398.578 205.605,369.407 206.507,353.455C194.408,348.947 175.089,342.14 175.089,342.14ZM239.502,332.155C236.224,332.127 234.144,330.44 233.732,328.884C233.319,327.329 235.679,323.517 237.026,322.821C244.051,319.192 251.916,319.735 251.916,319.735C251.916,319.735 254.299,332.28 239.502,332.155ZM238.929,221.803L270.281,221.803L270.281,254.418L238.929,254.418L238.929,221.803ZM238.929,136.356L270.281,136.356L270.281,205.834L238.929,205.834L238.929,136.356Z" style="fill:rgb(253,237,0);"/>
-</svg>
diff --git a/build.gradle b/build.gradle
index bd5ff0cf..84ffa0c4 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,43 +1,101 @@
+apply plugin: 'com.github.ben-manes.versions'
+
 buildscript {
+  ext.versions = [
+      'minSdk'    : 14,
+      'compileSdk': 28,
+      'errorProne': '2.3.1',
+      'kotlin'    : '1.3.21',
+  ]
+  ext.deps = [
+      assertj_core  : 'org.assertj:assertj-core:3.9.1',
+      // We don't need the latest version of AndroidX (there are no bugs that impact what LeakCanary
+      // relies on), we're sticking a bit older because most apps will be using a more recent version
+      // and they'll automatically resolve to higher version without having to necessarily resort to a
+      // resolution strategy.
+      androidx      : [
+          annotation: 'androidx.annotation:annotation:1.0.2',
+          core: 'androidx.core:core:1.0.1',
+          fragment  : 'androidx.fragment:fragment:1.0.0',
+          test      : [
+              core    : 'androidx.test:core:1.1.0',
+              espresso: 'androidx.test.espresso:espresso-core:3.1.1',
+              rules   : 'androidx.test:rules:1.1.1',
+              runner  : 'androidx.test:runner:1.1.1',
+          ]
+      ],
+      haha          : 'com.squareup.haha:haha:2.1',
+      junit         : 'junit:junit:4.12',
+      kotlin        : [
+          gradlePlugin: "org.jetbrains.kotlin:kotlin-gradle-plugin:${versions.kotlin}",
+          stdlib      : "org.jetbrains.kotlin:kotlin-stdlib:${versions.kotlin}"
+      ],
+      mockito       : 'org.mockito:mockito-core:2.7.5',
+      mockito_kotlin: 'com.nhaarman:mockito-kotlin-kt1.1:1.5.0',
+      okio: 'com.squareup.okio:okio:2.2.2',
+      robolectric   : 'org.robolectric:robolectric:4.0-alpha-3',
+  ]
   repositories {
-    mavenCentral()
+    google()
+    maven { url 'https://plugins.gradle.org/m2/' }
+    jcenter()
   }
   dependencies {
-    classpath 'com.android.tools.build:gradle:2.1.0'
+    classpath deps.kotlin.gradlePlugin
+    classpath 'com.android.tools.build:gradle:3.2.0'
+    classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.0.16'
+    classpath 'com.github.ben-manes:gradle-versions-plugin:0.20.0'
   }
 }
 
 subprojects {
+  group = GROUP
+  version = VERSION_NAME
+
   repositories {
-    mavenCentral()
-//    maven {
-//      url 'https://oss.sonatype.org/content/repositories/snapshots/'
-//    }
-//    mavenLocal()
+    google()
+    //    maven {
+    //      url 'https://oss.sonatype.org/content/repositories/snapshots/'
+    //    }
+    //    mavenLocal()
+    jcenter()
+  }
+
+  apply plugin: 'net.ltgt.errorprone'
+
+  tasks.withType(JavaCompile) {
+    options.compilerArgs += [
+        '-Xlint:all',
+        '-Xlint:-serial',
+        '-Xlint:-deprecation',
+        // espresso-core classes say they're compiled with 51.0 but contain 52.0 attributes.
+        // warning: [classfile] MethodParameters attribute introduced in version 52.0 class files is ignored in version 51.0 class files
+        // '-Werror'
+    ]
   }
-}
 
-ext {
-  minSdkVersion = 8
-  compileSdkVersion = 23
-  targetSdkVersion = compileSdkVersion
-  buildToolsVersion = '23.0.2'
-  javaVersion = JavaVersion.VERSION_1_7
-
-  GROUP = 'com.squareup.leakcanary'
-  VERSION_NAME = "1.4-SNAPSHOT"
-  POM_PACKAGING = "pom"
-  POM_DESCRIPTION= "Leak Canary"
-
-  POM_URL="http://github.com/square/leakcanary/"
-  POM_SCM_URL="http://github.com/square/leakcanary/"
-  POM_SCM_CONNECTION="scm:git:https://github.com/square/leakcanary.git"
-  POM_SCM_DEV_CONNECTION="scm:git:git@github.com:square/leakcanary.git"
-
-  POM_LICENCE_NAME="The Apache Software License, Version 2.0"
-  POM_LICENCE_URL="http://www.apache.org/licenses/LICENSE-2.0.txt"
-  POM_LICENCE_DIST="repo"
-
-  POM_DEVELOPER_ID="square"
-  POM_DEVELOPER_NAME="Square, Inc."
+  configurations.all {
+    resolutionStrategy {
+      eachDependency { details ->
+        // Force all the error-prone dependencies to use the same version.
+        if (details.requested.group == 'com.google.errorprone' &&
+            details.requested.name.startsWith('error_prone_')) {
+          details.useVersion versions.errorProne
+        }
+      }
+    }
+  }
+
+  tasks.withType(Test) {
+    testLogging {
+      exceptionFormat 'FULL'
+      showCauses true
+      showExceptions true
+      showStackTraces true
+    }
+  }
+
+  dependencies {
+    errorprone "com.google.errorprone:error_prone_core:${versions.errorProne}"
+  }
 }
diff --git a/checkstyle.xml b/checkstyle.xml
index 7fb7ad32..ce09c3d1 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -72,7 +72,9 @@
     <module name="AvoidStarImport"/>
     <module name="IllegalImport"/>
     <module name="RedundantImport"/>
-    <module name="UnusedImports"/>
+    <module name="UnusedImports">
+      <property name="processJavadoc" value="true"/>
+    </module>
 
 
     <!-- Checks for Size Violations.                    -->
@@ -81,7 +83,7 @@
       <!--property name="max" value="100"/-->
     <!--/module-->
     <!--module name="MethodLength"/-->
-    <module name="ParameterNumber"/>
+    <!--<module name="ParameterNumber"/>-->
 
 
     <!-- Checks for whitespace                               -->
@@ -89,8 +91,8 @@
     <module name="GenericWhitespace"/>
     <module name="EmptyForIteratorPad"/>
     <module name="MethodParamPad"/>
-    <module name="NoWhitespaceAfter"/>
-    <module name="NoWhitespaceBefore"/>
+    <!--<module name="NoWhitespaceAfter"/>-->
+    <!--<module name="NoWhitespaceBefore"/>-->
     <module name="OperatorWrap"/>
     <module name="ParenPad"/>
     <module name="TypecastParenPad"/>
@@ -145,4 +147,4 @@
     <!--module name="TodoComment"/-->
     <module name="UpperEll"/>
   </module>
-</module>
\ No newline at end of file
+</module>
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 00000000..8f8156dc
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,18 @@
+GROUP=com.squareup.leakcanary
+VERSION_NAME=2.0-alpha-2-SNAPSHOT
+
+POM_DESCRIPTION=Leak Canary
+
+POM_URL=http://github.com/square/leakcanary/
+POM_SCM_URL=http://github.com/square/leakcanary/
+POM_SCM_CONNECTION=scm:git:https://github.com/square/leakcanary.git
+POM_SCM_DEV_CONNECTION=scm:git:git@github.com:square/leakcanary.git
+
+POM_LICENCE_NAME=The Apache Software License, Version 2.0
+POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
+POM_LICENCE_DIST=repo
+
+POM_DEVELOPER_ID=square
+POM_DEVELOPER_NAME=Square, Inc.
+
+android.useAndroidX=true
diff --git a/gradle/checkstyle.gradle b/gradle/checkstyle.gradle
index 2e7c512c..afc5281a 100644
--- a/gradle/checkstyle.gradle
+++ b/gradle/checkstyle.gradle
@@ -2,17 +2,22 @@ apply plugin: 'checkstyle'
 
 checkstyle {
   configFile rootProject.file('checkstyle.xml')
+  ignoreFailures false
   showViolations true
 }
 
-android.libraryVariants.all { variant ->
-  def name = variant.buildType.name
+task checkstyle(type: Checkstyle) {
+  configFile rootProject.file('checkstyle.xml')
+  source 'src/main/java'
+  ignoreFailures false
+  showViolations true
+  include '**/*.java'
+
+  classpath = files()
+}
 
-  def checkstyle = project.tasks.create "checkstyle${name.capitalize()}", Checkstyle
-  checkstyle.dependsOn variant.javaCompile
-  checkstyle.source variant.javaCompile.source
-  checkstyle.classpath = project.fileTree(variant.javaCompile.destinationDir)
-  checkstyle.exclude('**/BuildConfig.java')
-  checkstyle.exclude('**/R.java')
-  project.tasks.getByName("check").dependsOn checkstyle
+afterEvaluate {
+  if (project.tasks.getByName("check")) {
+    check.dependsOn('checkstyle')
+  }
 }
\ No newline at end of file
diff --git a/gradle/gradle-mvn-push.gradle b/gradle/gradle-mvn-push.gradle
index 32763c86..ec8721e4 100644
--- a/gradle/gradle-mvn-push.gradle
+++ b/gradle/gradle-mvn-push.gradle
@@ -77,32 +77,61 @@ afterEvaluate { project ->
         sign configurations.archives
     }
 
-    task androidJavadocs(type: Javadoc) {
+    def plugins = project.getPlugins()
+    if (plugins.hasPlugin('com.android.application') || plugins.hasPlugin('com.android.library')) {
+      task androidJavadocs(type: Javadoc) {
         source = android.sourceSets.main.java.srcDirs
-        ext.androidJar = "${android.sdkDirectory}/platforms/${android.compileSdkVersion}/android.jar"
-        classpath += files(ext.androidJar)
-    }
+        // TODO Update to include KT files OR stop publishing javadoc artifacts.
+        exclude "**/*.kt"
+        exclude "**/internal/**"
+        classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+
+        // Append also the classpath and files for release library variants.
+        // This fixes the javadoc warnings.
+        // Copy pasta from https://github.com/novoda/bintray-release/pull/39/files
+        def releaseVariant = project.android.libraryVariants.find { it.name.endsWith("release") }
+
+        classpath += releaseVariant.javaCompile.classpath
+        classpath += releaseVariant.javaCompile.outputs.files
+      }
 
-    task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
+      task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
         classifier = 'javadoc'
         from androidJavadocs.destinationDir
-    }
+      }
 
-    task androidSourcesJar(type: Jar) {
+      task androidSourcesJar(type: Jar) {
         classifier = 'sources'
         from android.sourceSets.main.java.sourceFiles
+      }
+
+      artifacts {
+        archives androidSourcesJar
+        archives androidJavadocsJar
+      }
     }
+    else {
+      task sourcesJar(type: Jar, dependsOn: classes) {
+        classifier = 'sources'
+        from sourceSets.main.allSource
+      }
 
-    if (JavaVersion.current().isJava8Compatible()) {
-        allprojects {
-            tasks.withType(Javadoc) {
-                options.addStringOption('Xdoclint:none', '-quiet')
-            }
-        }
+      task javadocsJar(type: Jar, dependsOn: javadoc) {
+        classifier = 'javadoc'
+        from javadoc.destinationDir
+      }
+
+      artifacts {
+        archives sourcesJar
+        archives javadocsJar
+      }
     }
 
-    artifacts {
-        archives androidSourcesJar
-        archives androidJavadocsJar
+    if (JavaVersion.current().isJava8Compatible()) {
+      allprojects {
+        tasks.withType(Javadoc) {
+          options.addStringOption('Xdoclint:none', '-quiet')
+        }
+      }
     }
 }
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 58385981..0d4a9516 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index b1c865c3..7dc503f1 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Wed Feb 04 10:58:17 PST 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.13-all.zip
diff --git a/gradlew b/gradlew
index 91a7e269..cccdd3d5 100755
--- a/gradlew
+++ b/gradlew
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 ##############################################################################
 ##
@@ -6,20 +6,38 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,31 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -90,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
@@ -114,6 +113,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
@@ -154,11 +154,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+exec "$JAVACMD" "$@"
diff --git a/leakcanary-analyzer-core/build.gradle b/leakcanary-analyzer-core/build.gradle
new file mode 100644
index 00000000..150613b3
--- /dev/null
+++ b/leakcanary-analyzer-core/build.gradle
@@ -0,0 +1,18 @@
+apply plugin: 'java-library'
+apply plugin: 'kotlin'
+
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
+
+dependencies {
+  api project(':leakcanary-watcher')
+
+  implementation deps.androidx.annotation
+  implementation deps.kotlin.stdlib
+
+  testImplementation deps.assertj_core
+  testImplementation deps.junit
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/leakcanary-analyzer-core/gradle.properties b/leakcanary-analyzer-core/gradle.properties
new file mode 100644
index 00000000..f74bb593
--- /dev/null
+++ b/leakcanary-analyzer-core/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-analyzer-core
+POM_NAME=LeakCanary Analyzer Core
+POM_PACKAGING=jar
diff --git a/leakcanary-analyzer-core/src/main/java/leakcanary/AnalysisResult.kt b/leakcanary-analyzer-core/src/main/java/leakcanary/AnalysisResult.kt
new file mode 100644
index 00000000..5ef1b218
--- /dev/null
+++ b/leakcanary-analyzer-core/src/main/java/leakcanary/AnalysisResult.kt
@@ -0,0 +1,178 @@
+package leakcanary
+
+import java.io.Serializable
+import java.util.UUID
+
+/**
+ * Used only for tests. We should delete this and move the stacktrace feature
+ * (once we have grouping)
+ */
+data class AnalysisResult(
+
+  /**
+   * Key associated to the [leaksentry.KeyedWeakReference] used to detect the memory leak.
+   * When analyzing a heap dump, search for all [leaksentry.KeyedWeakReference] instances, then open
+   * the one that has its "key" field set to this value. Its "referent" field contains the
+   * leaking object. Computing the shortest path to GC roots on that leaking object should enable
+   * you to figure out the cause of the leak.
+   */
+  val referenceKey: String,
+
+  /**
+   * User defined name to help identify the leaking instance.
+   */
+  val referenceName: String,
+
+  /** True if a leak was found in the heap dump.  */
+  val leakFound: Boolean,
+  /**
+   * True if [.leakFound] is true and the only path to the leaking reference is
+   * through excluded references. Usually, that means you can safely ignore this report.
+   */
+  val excludedLeak: Boolean,
+  /**
+   * Class name of the object that leaked, null if [.failure] is not null.
+   * The class name format is the same as what would be returned by [Class.getName].
+   */
+  val className: String?,
+  /**
+   * Shortest path to GC roots for the leaking object if [.leakFound] is true, null
+   * otherwise. This can be used as a unique signature for the leak.
+   */
+  val leakTrace: LeakTrace? = null,
+  /** Null unless the analysis failed.  */
+  val failure: Throwable? = null,
+  /**
+   * The number of bytes which would be freed if all references to the leaking object were
+   * released. [.RETAINED_HEAP_SKIPPED] if the retained heap size was not computed. 0 if
+   * [.leakFound] is false.
+   */
+  val retainedHeapSize: Long,
+  /** Total time spent analyzing the heap.  */
+  val analysisDurationMs: Long,
+
+  /** Time from the request to watch the reference until the GC was triggered.  */
+  val watchDurationMs: Long
+
+) : Serializable {
+
+  /**
+   * <p>Creates a new {@link RuntimeException} with a fake stack trace that maps the leak trace.
+   *
+   * <p>Leak traces uniquely identify memory leaks, much like stack traces uniquely identify
+   * exceptions.
+   *
+   * <p>This method enables you to upload leak traces as stack traces to your preferred
+   * exception reporting tool and benefit from the grouping and counting these tools provide out
+   * of the box. This also means you can track all leaks instead of relying on individuals
+   * reporting them when they happen.
+   *
+   * <p>The following example leak trace:
+   * <pre>
+   * * com.foo.WibbleActivity has leaked:
+   * * GC ROOT static com.foo.Bar.qux
+   * * references com.foo.Quz.context
+   * * leaks com.foo.WibbleActivity instance
+   * </pre>
+   *
+   * <p>Will turn into an exception with the following stacktrace:
+   * <pre>
+   * java.lang.RuntimeException: com.foo.WibbleActivity leak from com.foo.Bar (holder=CLASS,
+   * type=STATIC_FIELD)
+   *         at com.foo.Bar.qux(Bar.java:42)
+   *         at com.foo.Quz.context(Quz.java:42)
+   *         at com.foo.WibbleActivity.leaking(WibbleActivity.java:42)
+   * </pre>
+   */
+  fun leakTraceAsFakeException(): RuntimeException {
+    if (!leakFound) {
+      throw UnsupportedOperationException(
+          "leakTraceAsFakeException() can only be called when leakFound is true"
+      )
+    }
+    val firstElement = leakTrace!!.elements[0]
+    val rootSimpleName = classSimpleName(firstElement.className)
+    val leakSimpleName = classSimpleName(className!!)
+
+    val runtimeException = RuntimeException(
+        "$leakSimpleName leak from $rootSimpleName (holder=${firstElement.holder}, type= ${firstElement.reference!!.type})"
+    )
+    val stackTrace = mutableListOf<StackTraceElement>()
+    leakTrace.elements.onEach { element ->
+      val methodName = if (element.reference != null) element.reference.name else "leaking"
+      val file = classSimpleName(element.className) + ".java"
+      stackTrace.add(StackTraceElement(element.className, methodName, file, 42))
+    }
+    runtimeException.stackTrace = stackTrace.toTypedArray()
+    return runtimeException
+  }
+
+  private fun classSimpleName(className: String): String {
+    val separator = className.lastIndexOf('.')
+    return if (separator == -1) className else className.substring(separator + 1)
+  }
+
+  companion object {
+    const val RETAINED_HEAP_SKIPPED: Long = -1
+
+    fun noLeak(
+      className: String,
+      analysisDurationMs: Long
+    ): AnalysisResult {
+      return AnalysisResult(
+          referenceKey = "Fake-${UUID.randomUUID()}",
+          referenceName = "",
+          leakFound = false,
+          excludedLeak = false,
+          className = className,
+          leakTrace = null,
+          failure = null,
+          retainedHeapSize = 0,
+          analysisDurationMs = analysisDurationMs,
+          watchDurationMs = 0
+      )
+    }
+
+    fun leakDetected(
+      referenceKey: String,
+      referenceName: String,
+      excludedLeak: Boolean,
+      className: String,
+      leakTrace: LeakTrace?,
+      retainedHeapSize: Long,
+      analysisDurationMs: Long,
+      watchDurationMs: Long
+    ): AnalysisResult {
+      return AnalysisResult(
+          referenceKey = referenceKey,
+          referenceName = referenceName,
+          leakFound = true,
+          excludedLeak = excludedLeak,
+          className = className,
+          leakTrace = leakTrace,
+          failure = null,
+          retainedHeapSize = retainedHeapSize,
+          analysisDurationMs = analysisDurationMs,
+          watchDurationMs = watchDurationMs
+      )
+    }
+
+    fun failure(
+      failure: Throwable,
+      analysisDurationMs: Long
+    ): AnalysisResult {
+      return AnalysisResult(
+          referenceKey = "Fake-${UUID.randomUUID()}",
+          referenceName = "",
+          leakFound = false,
+          excludedLeak = false,
+          className = null,
+          leakTrace = null,
+          failure = failure,
+          retainedHeapSize = 0,
+          analysisDurationMs = analysisDurationMs,
+          watchDurationMs = 0
+      )
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer-core/src/main/java/leakcanary/AnalyzerProgressListener.kt b/leakcanary-analyzer-core/src/main/java/leakcanary/AnalyzerProgressListener.kt
new file mode 100644
index 00000000..f26e9818
--- /dev/null
+++ b/leakcanary-analyzer-core/src/main/java/leakcanary/AnalyzerProgressListener.kt
@@ -0,0 +1,29 @@
+package leakcanary
+
+interface AnalyzerProgressListener {
+
+  // These steps should be defined in the order in which they occur.
+  enum class Step {
+    READING_HEAP_DUMP_FILE,
+    PARSING_HEAP_DUMP,
+    SCANNING_HEAP_DUMP,
+    FINDING_WATCHED_REFERENCES,
+    DEDUPLICATING_GC_ROOTS,
+    FINDING_LEAKING_REF,
+    FINDING_LEAKING_REFS,
+    FINDING_SHORTEST_PATH,
+    FINDING_SHORTEST_PATHS,
+    BUILDING_LEAK_TRACE,
+    BUILDING_LEAK_TRACES,
+    COMPUTING_DOMINATORS
+  }
+
+  fun onProgressUpdate(step: Step)
+
+  companion object {
+    val NONE = object : AnalyzerProgressListener {
+      override fun onProgressUpdate(step: Step) {
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer-core/src/main/java/leakcanary/ExcludedRefs.kt b/leakcanary-analyzer-core/src/main/java/leakcanary/ExcludedRefs.kt
new file mode 100644
index 00000000..2c5fc1d7
--- /dev/null
+++ b/leakcanary-analyzer-core/src/main/java/leakcanary/ExcludedRefs.kt
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import java.io.Serializable
+import java.util.Collections.unmodifiableMap
+import java.util.LinkedHashMap
+
+/**
+ * Prevents specific references from being taken into account when computing the shortest strong
+ * reference path from a suspected leaking instance to the GC roots.
+ *
+ * This class lets you ignore known memory leaks that you known about. If the shortest path
+ * matches [ExcludedRefs], than the heap analyzer should look for a longer path with nothing
+ * matching in [ExcludedRefs].
+ */
+class ExcludedRefs internal constructor(builder: BuilderWithParams) : Serializable {
+
+  val fieldNameByClassName: Map<String, Map<String, Exclusion>>
+  val staticFieldNameByClassName: Map<String, Map<String, Exclusion>>
+  val threadNames: Map<String, Exclusion>
+  val classNames: Map<String, Exclusion>
+
+  init {
+    this.fieldNameByClassName = unmodifiableRefStringMap(builder.fieldNameByClassName)
+    this.staticFieldNameByClassName = unmodifiableRefStringMap(builder.staticFieldNameByClassName)
+    this.threadNames = unmodifiableRefMap(builder.threadNames)
+    this.classNames = unmodifiableRefMap(builder.classNames)
+  }
+
+  private fun unmodifiableRefStringMap(
+    mapmap: Map<String, Map<String, ParamsBuilder>>
+  ): Map<String, Map<String, Exclusion>> {
+    val fieldNameByClassName = LinkedHashMap<String, Map<String, Exclusion>>()
+    for ((key, value) in mapmap) {
+      fieldNameByClassName[key] = unmodifiableRefMap(value)
+    }
+    return unmodifiableMap(fieldNameByClassName)
+  }
+
+  private fun unmodifiableRefMap(fieldBuilderMap: Map<String, ParamsBuilder>): Map<String, Exclusion> {
+    val fieldMap = LinkedHashMap<String, Exclusion>()
+    for ((key, value) in fieldBuilderMap) {
+      fieldMap[key] = Exclusion(value)
+    }
+    return unmodifiableMap(fieldMap)
+  }
+
+  override fun toString(): String {
+    var string = ""
+    for ((clazz, value) in fieldNameByClassName) {
+      for ((key, value1) in value) {
+        val always = if (value1.alwaysExclude) " (always)" else ""
+        string += "| Field: $clazz.$key$always\n"
+      }
+    }
+    for ((clazz, value) in staticFieldNameByClassName) {
+      for ((key, value1) in value) {
+        val always = if (value1.alwaysExclude) " (always)" else ""
+        string += "| Static field: $clazz.$key$always\n"
+      }
+    }
+    for ((key, value) in threadNames) {
+      val always = if (value.alwaysExclude) " (always)" else ""
+      string += "| Thread:$key$always\n"
+    }
+    for ((key, value) in classNames) {
+      val always = if (value.alwaysExclude) " (always)" else ""
+      string += "| Class:$key$always\n"
+    }
+    return string
+  }
+
+  @Suppress("unused")
+  internal class ParamsBuilder(val matching: String) {
+    var name: String? = null
+    var reason: String? = null
+    var alwaysExclude: Boolean = false
+  }
+
+  interface Builder {
+    fun instanceField(
+      className: String,
+      fieldName: String
+    ): BuilderWithParams
+
+    fun staticField(
+      className: String,
+      fieldName: String
+    ): BuilderWithParams
+
+    fun thread(threadName: String): BuilderWithParams
+
+    fun clazz(className: String): BuilderWithParams
+
+    fun build(): ExcludedRefs
+  }
+
+  class BuilderWithParams internal constructor() : Builder {
+
+    internal val fieldNameByClassName = LinkedHashMap<String, MutableMap<String, ParamsBuilder>>()
+    internal val staticFieldNameByClassName =
+      LinkedHashMap<String, MutableMap<String, ParamsBuilder>>()
+    internal val threadNames = LinkedHashMap<String, ParamsBuilder>()
+    internal val classNames = LinkedHashMap<String, ParamsBuilder>()
+
+    private var lastParams: ParamsBuilder? = null
+
+    override fun instanceField(
+      className: String,
+      fieldName: String
+    ): BuilderWithParams {
+      var excludedFields: MutableMap<String, ParamsBuilder>? = fieldNameByClassName[className]
+      if (excludedFields == null) {
+        excludedFields = LinkedHashMap()
+        fieldNameByClassName[className] = excludedFields
+      }
+      lastParams = ParamsBuilder("field $className#$fieldName")
+      excludedFields[fieldName] = lastParams!!
+      return this
+    }
+
+    override fun staticField(
+      className: String,
+      fieldName: String
+    ): BuilderWithParams {
+      var excludedFields: MutableMap<String, ParamsBuilder>? = staticFieldNameByClassName[className]
+      if (excludedFields == null) {
+        excludedFields = LinkedHashMap()
+        staticFieldNameByClassName[className] = excludedFields
+      }
+      lastParams = ParamsBuilder("static field $className#$fieldName")
+      excludedFields[fieldName] = lastParams!!
+      return this
+    }
+
+    override fun thread(threadName: String): BuilderWithParams {
+      lastParams = ParamsBuilder("any threads named $threadName")
+      threadNames[threadName] = lastParams!!
+      return this
+    }
+
+    /** Ignores all fields and static fields of all subclasses of the provided class name.  */
+    override fun clazz(className: String): BuilderWithParams {
+      lastParams = ParamsBuilder("any subclass of $className")
+      classNames[className] = lastParams!!
+      return this
+    }
+
+    fun named(name: String): BuilderWithParams {
+      lastParams!!.name = name
+      return this
+    }
+
+    fun reason(reason: String): BuilderWithParams {
+      lastParams!!.reason = reason
+      return this
+    }
+
+    fun alwaysExclude(): BuilderWithParams {
+      lastParams!!.alwaysExclude = true
+      return this
+    }
+
+    override fun build(): ExcludedRefs {
+      return ExcludedRefs(this)
+    }
+  }
+
+  companion object {
+
+    fun builder(): Builder {
+      return BuilderWithParams()
+    }
+  }
+}
diff --git a/leakcanary-analyzer-core/src/main/java/leakcanary/Exclusion.kt b/leakcanary-analyzer-core/src/main/java/leakcanary/Exclusion.kt
new file mode 100644
index 00000000..fdd27679
--- /dev/null
+++ b/leakcanary-analyzer-core/src/main/java/leakcanary/Exclusion.kt
@@ -0,0 +1,11 @@
+package leakcanary
+
+import leakcanary.ExcludedRefs.ParamsBuilder
+import java.io.Serializable
+
+class Exclusion internal constructor(builder: ParamsBuilder) : Serializable {
+  val name: String? = builder.name
+  val reason: String? = builder.reason
+  val alwaysExclude: Boolean = builder.alwaysExclude
+  val matching: String = builder.matching
+}
diff --git a/leakcanary-analyzer-core/src/main/java/leakcanary/HeapAnalysis.kt b/leakcanary-analyzer-core/src/main/java/leakcanary/HeapAnalysis.kt
new file mode 100644
index 00000000..713cd639
--- /dev/null
+++ b/leakcanary-analyzer-core/src/main/java/leakcanary/HeapAnalysis.kt
@@ -0,0 +1,116 @@
+package leakcanary
+
+import leakcanary.internal.createSHA1Hash
+import java.io.Serializable
+
+sealed class HeapAnalysis : Serializable {
+  abstract val heapDump: HeapDump
+  abstract val createdAtTimeMillis: Long
+  /** Total time spent analyzing the heap.  */
+  abstract val analysisDurationMillis: Long
+}
+
+data class HeapAnalysisFailure(
+  override val heapDump: HeapDump,
+  override val createdAtTimeMillis: Long,
+  override val analysisDurationMillis: Long,
+  val exception: HeapAnalysisException
+) : HeapAnalysis()
+
+data class HeapAnalysisSuccess(
+  override val heapDump: HeapDump,
+  override val createdAtTimeMillis: Long,
+  override val analysisDurationMillis: Long,
+  val retainedInstances: List<RetainedInstance>
+) : HeapAnalysis()
+
+sealed class RetainedInstance : Serializable {
+  /**
+   * Key associated to the [leakcanary.KeyedWeakReference] used to detect the memory leak.
+   * When analyzing a heap dump manually, search for all [leakcanary.KeyedWeakReference] instances,
+   * then open the one that has its "key" field set to this value. Its "referent" field contains the
+   * retained instance. Computing the shortest path to GC roots on that retained instance should
+   * enable you to figure out the cause of the leak, if any.
+   */
+  abstract val referenceKey: String
+}
+
+data class WeakReferenceMissing(override val referenceKey: String) : RetainedInstance()
+
+sealed class WeakReferenceFound : RetainedInstance() {
+  /**
+   * User defined name to help identify the retained instance.
+   */
+  abstract val referenceName: String
+  /**
+   * Class name of the retained instance.
+   * The class name format is the same as what would be returned by [Class.getName].
+   */
+  abstract val instanceClassName: String
+  /** Time from the request to watch the reference until the GC was triggered.  */
+  abstract val watchDurationMillis: Long
+}
+
+data class WeakReferenceCleared(
+  override val referenceKey: String,
+  override val referenceName: String,
+  override val instanceClassName: String,
+  override val watchDurationMillis: Long
+) : WeakReferenceFound()
+
+data class NoPathToInstance(
+  override val referenceKey: String,
+  override val referenceName: String,
+  override val instanceClassName: String,
+  override val watchDurationMillis: Long
+) : WeakReferenceFound()
+
+data class LeakingInstance(
+  override val referenceKey: String,
+  override val referenceName: String,
+  override val instanceClassName: String,
+  override val watchDurationMillis: Long,
+  /**
+   * True if the only path to the leaking reference is through excluded references. Usually, that
+   * means you can safely ignore this report.
+   */
+  val excludedLeak: Boolean,
+  /**
+   * Shortest path to GC roots for the leaking instance.
+   */
+  val leakTrace: LeakTrace,
+  /**
+   * The number of bytes which would be freed if all references to the leaking object were
+   * released. Null if the retained heap size was not computed.
+   */
+  val retainedHeapSize: Long?
+
+) : WeakReferenceFound() {
+
+  val groupHash = createGroupHash()
+
+  private fun createGroupHash(): String {
+    val uniqueString = if (excludedLeak) {
+      leakTrace.firstElementExclusion.matching
+    } else {
+      leakTrace.leakCauses
+          .joinToString(separator = "") { element ->
+            val referenceName = element.reference!!.groupingName
+            element.className + referenceName
+          }
+    }
+    return uniqueString.createSHA1Hash()
+  }
+}
+
+fun HeapAnalysis.leakingInstances(): List<LeakingInstance> {
+  if (this is HeapAnalysisFailure) {
+    return emptyList()
+  }
+  val success = this as HeapAnalysisSuccess
+  return success.retainedInstances.filter { it is LeakingInstance }
+      .map { it as LeakingInstance }
+}
+
+fun HeapAnalysis.applicationLeaks(): List<LeakingInstance> =
+  leakingInstances().filter { !it.excludedLeak }
\ No newline at end of file
diff --git a/leakcanary-analyzer-core/src/main/java/leakcanary/HeapAnalysisException.kt b/leakcanary-analyzer-core/src/main/java/leakcanary/HeapAnalysisException.kt
new file mode 100644
index 00000000..313fafde
--- /dev/null
+++ b/leakcanary-analyzer-core/src/main/java/leakcanary/HeapAnalysisException.kt
@@ -0,0 +1,13 @@
+package leakcanary
+
+import java.io.PrintWriter
+import java.io.StringWriter
+
+class HeapAnalysisException(cause: Throwable) : RuntimeException(cause) {
+
+  override fun toString(): String {
+    val stringWriter = StringWriter()
+    cause!!.printStackTrace(PrintWriter(stringWriter))
+    return "\n$stringWriter\n"
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer-core/src/main/java/leakcanary/HeapDump.kt b/leakcanary-analyzer-core/src/main/java/leakcanary/HeapDump.kt
new file mode 100644
index 00000000..07be1252
--- /dev/null
+++ b/leakcanary-analyzer-core/src/main/java/leakcanary/HeapDump.kt
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import leakcanary.Reachability.Inspector
+import java.io.File
+import java.io.Serializable
+import java.util.ArrayList
+import java.util.Collections.unmodifiableList
+
+/** Data structure holding information about a heap dump.  */
+// TODO Turn HeapDump into a data class
+class HeapDump internal constructor(builder: Builder) : Serializable {
+
+  /** The heap dump file, which you might want to upload somewhere.  */
+  val heapDumpFile: File
+
+  /** References that should be ignored when analyzing this heap dump.  */
+  val excludedRefs: ExcludedRefs
+
+  val gcDurationMs: Long
+  val heapDumpDurationMs: Long
+  val computeRetainedHeapSize: Boolean
+  val reachabilityInspectorClasses: List<Class<out Inspector>>
+
+  /** Receives a heap dump to analyze.  */
+  interface Listener {
+    fun analyze(heapDump: HeapDump)
+  }
+
+  init {
+    this.heapDumpFile = builder.heapDumpFile
+    this.excludedRefs = builder.excludedRefs
+    this.computeRetainedHeapSize = builder.computeRetainedHeapSize
+    this.gcDurationMs = builder.gcDurationMs
+    this.heapDumpDurationMs = builder.heapDumpDurationMs
+    this.reachabilityInspectorClasses = builder.reachabilityInspectorClasses
+  }
+
+  fun buildUpon(): Builder {
+    return Builder(this)
+  }
+
+  class Builder(
+    internal var heapDumpFile: File
+  ) {
+    internal var excludedRefs: ExcludedRefs = ExcludedRefs.builder()
+        .build()
+    internal var gcDurationMs: Long = 0
+    internal var heapDumpDurationMs: Long = 0
+    internal var computeRetainedHeapSize: Boolean = false
+    internal var reachabilityInspectorClasses: List<Class<out Inspector>> = emptyList()
+
+    internal constructor(heapDump: HeapDump) : this(heapDump.heapDumpFile) {
+      this.heapDumpFile = heapDump.heapDumpFile
+      this.excludedRefs = heapDump.excludedRefs
+      this.computeRetainedHeapSize = heapDump.computeRetainedHeapSize
+      this.gcDurationMs = heapDump.gcDurationMs
+      this.heapDumpDurationMs = heapDump.heapDumpDurationMs
+      this.reachabilityInspectorClasses = heapDump.reachabilityInspectorClasses
+    }
+
+    fun heapDumpFile(heapDumpFile: File): Builder {
+      this.heapDumpFile = heapDumpFile
+      return this
+    }
+
+    fun excludedRefs(excludedRefs: ExcludedRefs): Builder {
+      this.excludedRefs = excludedRefs
+      return this
+    }
+
+    fun gcDurationMs(gcDurationMs: Long): Builder {
+      this.gcDurationMs = gcDurationMs
+      return this
+    }
+
+    fun heapDumpDurationMs(heapDumpDurationMs: Long): Builder {
+      this.heapDumpDurationMs = heapDumpDurationMs
+      return this
+    }
+
+    fun computeRetainedHeapSize(computeRetainedHeapSize: Boolean): Builder {
+      this.computeRetainedHeapSize = computeRetainedHeapSize
+      return this
+    }
+
+    fun reachabilityInspectorClasses(
+      reachabilityInspectorClasses: List<Class<out Inspector>>
+    ): Builder {
+      this.reachabilityInspectorClasses = unmodifiableList<Class<out Inspector>>(
+          ArrayList<Class<out Inspector>>(reachabilityInspectorClasses)
+      )
+      return this
+    }
+
+    fun build(): HeapDump {
+      return HeapDump(this)
+    }
+  }
+
+  companion object {
+    fun builder(heapDumpFile: File): Builder {
+      return Builder(heapDumpFile)
+    }
+  }
+}
diff --git a/leakcanary-analyzer-core/src/main/java/leakcanary/HeapDumpMemoryStore.kt b/leakcanary-analyzer-core/src/main/java/leakcanary/HeapDumpMemoryStore.kt
new file mode 100644
index 00000000..b699ad74
--- /dev/null
+++ b/leakcanary-analyzer-core/src/main/java/leakcanary/HeapDumpMemoryStore.kt
@@ -0,0 +1,16 @@
+package leakcanary
+
+object HeapDumpMemoryStore {
+
+  @Volatile
+  @JvmStatic var retainedKeysForHeapDump: Array<String>? = null
+    private set
+
+  @Volatile
+  @JvmStatic var heapDumpUptimeMillis: Long = 0
+
+  @JvmStatic fun setRetainedKeysForHeapDump(retainedKeys: Set<String>) {
+    retainedKeysForHeapDump = retainedKeys.toTypedArray()
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer-core/src/main/java/leakcanary/LeakReference.kt b/leakcanary-analyzer-core/src/main/java/leakcanary/LeakReference.kt
new file mode 100644
index 00000000..9e64c7d3
--- /dev/null
+++ b/leakcanary-analyzer-core/src/main/java/leakcanary/LeakReference.kt
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import leakcanary.LeakTraceElement.Type
+import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
+import leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
+import leakcanary.LeakTraceElement.Type.LOCAL
+import leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import java.io.Serializable
+
+/**
+ * A single field in a [LeakTraceElement].
+ */
+data class LeakReference(
+  val type: Type,
+  val name: String,
+  val value: String
+) : Serializable {
+
+  val displayName: String
+    get() {
+      return when (type) {
+        ARRAY_ENTRY -> "[$name]"
+        STATIC_FIELD, INSTANCE_FIELD -> name
+        LOCAL -> "<Java Local>"
+      }
+    }
+
+  val groupingName: String
+    get() {
+      return when (type) {
+        // The specific array index in a leak rarely matters, this improves grouping.
+        ARRAY_ENTRY -> "[x]"
+        STATIC_FIELD, INSTANCE_FIELD -> name
+        LOCAL -> "<Java Local>"
+      }
+    }
+
+  override fun toString(): String {
+    return when (type) {
+      ARRAY_ENTRY, INSTANCE_FIELD -> "$displayName = $value"
+      STATIC_FIELD -> "static $displayName = $value"
+      LOCAL -> displayName
+    }
+  }
+}
diff --git a/leakcanary-analyzer-core/src/main/java/leakcanary/LeakTrace.kt b/leakcanary-analyzer-core/src/main/java/leakcanary/LeakTrace.kt
new file mode 100644
index 00000000..e16a60ab
--- /dev/null
+++ b/leakcanary-analyzer-core/src/main/java/leakcanary/LeakTrace.kt
@@ -0,0 +1,41 @@
+package leakcanary
+
+import leakcanary.Reachability.Status.REACHABLE
+import leakcanary.Reachability.Status.UNKNOWN
+import leakcanary.internal.renderToString
+import java.io.Serializable
+
+/**
+ * A chain of references that constitute the shortest strong reference path from a leaking instance
+ * to the GC roots. Fixing the leak usually means breaking one of the references in that chain.
+ */
+data class LeakTrace(
+  val elements: List<LeakTraceElement>,
+  val expectedReachability: List<Reachability>
+) : Serializable {
+
+  val firstElementExclusion
+    get() = elements.first { element ->
+      element.exclusion != null
+    }.exclusion!!
+
+  val leakCauses = elements.filterIndexed { index, _ ->
+    elementMayBeLeakCause(index)
+  }
+
+  override fun toString(): String {
+    return "\n${renderToString()}\n"
+  }
+
+  fun elementMayBeLeakCause(index: Int): Boolean {
+    return when (expectedReachability[index].status) {
+      UNKNOWN -> true
+      REACHABLE -> if (index < elements.lastIndex) {
+        expectedReachability[index + 1].status != REACHABLE
+      } else {
+        true
+      }
+      else -> false
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer-core/src/main/java/leakcanary/LeakTraceElement.kt b/leakcanary-analyzer-core/src/main/java/leakcanary/LeakTraceElement.kt
new file mode 100644
index 00000000..0a5eb3b4
--- /dev/null
+++ b/leakcanary-analyzer-core/src/main/java/leakcanary/LeakTraceElement.kt
@@ -0,0 +1,80 @@
+package leakcanary
+
+import leakcanary.internal.lastSegment
+import java.io.Serializable
+
+data class LeakTraceElement(
+  /**
+   * Information about the reference that points to the next [LeakTraceElement] in the leak
+   * chain. Null if this is the last element in the leak trace, ie the leaking object.
+   */
+  val reference: LeakReference?,
+
+  val holder: Holder,
+
+  /**
+   * Class hierarchy for that object. The first element is [.className]. [Object]
+   * is excluded. There is always at least one element.
+   */
+  val classHierarchy: List<String>,
+
+  /** If not null, there was no path that could exclude this element.  */
+  val exclusion: Exclusion?,
+
+  /** List of all fields (member and static) for that object.  */
+  @Deprecated("This field will be replaced with the parser itself")
+  val fieldReferences: List<LeakReference>,
+
+  /**
+   * Ordered labels that were computed during analysis. A label provides
+   * extra information that helps understand the leak trace element.
+   */
+  val labels: List<String>
+) : Serializable {
+
+  val className: String
+    get() = classHierarchy[0]
+
+  enum class Type {
+    INSTANCE_FIELD,
+    STATIC_FIELD,
+    LOCAL,
+    ARRAY_ENTRY
+  }
+
+  enum class Holder {
+    OBJECT,
+    CLASS,
+    THREAD,
+    ARRAY
+  }
+
+  /**
+   * Returns the string value of the first field reference that has the provided referenceName, or
+   * null if no field reference with that name was found.
+   */
+  fun getFieldReferenceValue(referenceName: String): String? {
+    return fieldReferences.find { fieldReference -> fieldReference.name == referenceName }
+        ?.value
+  }
+
+  /** @see [isInstanceOf][] */
+  fun isInstanceOf(expectedClass: Class<out Any>): Boolean {
+    return isInstanceOf(expectedClass.name)
+  }
+
+  /**
+   * Returns true if this element is an instance of the provided class name, false otherwise.
+   */
+  fun isInstanceOf(expectedClassName: String): Boolean {
+    return classHierarchy.contains(expectedClassName)
+  }
+
+  /**
+   * Returns {@link #className} without the package.
+   */
+  fun getSimpleClassName(): String {
+    return className.lastSegment('.')
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer-core/src/main/java/leakcanary/Reachability.kt b/leakcanary-analyzer-core/src/main/java/leakcanary/Reachability.kt
new file mode 100644
index 00000000..5443129b
--- /dev/null
+++ b/leakcanary-analyzer-core/src/main/java/leakcanary/Reachability.kt
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import leakcanary.Reachability.Inspector
+import leakcanary.Reachability.Status.REACHABLE
+import leakcanary.Reachability.Status.UNKNOWN
+import leakcanary.Reachability.Status.UNREACHABLE
+import java.io.Serializable
+
+/** Result returned by [Inspector.expectedReachability].  */
+class Reachability private constructor(
+  val status: Status,
+  val reason: String
+) : Serializable {
+
+  enum class Status {
+    REACHABLE,
+    UNREACHABLE,
+    UNKNOWN
+  }
+
+  /**
+   * Evaluates whether a [LeakTraceElement] should be reachable or not.
+   *
+   * Implementations should have a public zero argument constructor as instances will be created
+   * via reflection in the LeakCanary analysis process.
+   */
+  interface Inspector {
+
+    fun expectedReachability(element: LeakTraceElement): Reachability
+  }
+
+  companion object {
+
+    private val UNKNOWN_REACHABILITY =
+      Reachability(UNKNOWN, "")
+
+    /** The instance was needed and therefore expected to be reachable.  */
+    fun reachable(reason: String): Reachability {
+      return Reachability(REACHABLE, reason)
+    }
+
+    /** The instance was no longer needed and therefore expected to be unreachable.  */
+    fun unreachable(reason: String): Reachability {
+      return Reachability(UNREACHABLE, reason)
+    }
+
+    /** No decision can be made about the provided instance.  */
+    fun unknown(): Reachability {
+      return UNKNOWN_REACHABILITY
+    }
+  }
+}
diff --git a/leakcanary-analyzer-core/src/main/java/leakcanary/Serializables.kt b/leakcanary-analyzer-core/src/main/java/leakcanary/Serializables.kt
new file mode 100644
index 00000000..9b59556d
--- /dev/null
+++ b/leakcanary-analyzer-core/src/main/java/leakcanary/Serializables.kt
@@ -0,0 +1,68 @@
+package leakcanary
+
+import java.io.ByteArrayInputStream
+import java.io.ByteArrayOutputStream
+import java.io.File
+import java.io.FileInputStream
+import java.io.FileNotFoundException
+import java.io.FileOutputStream
+import java.io.IOException
+import java.io.ObjectInputStream
+import java.io.ObjectOutputStream
+import java.io.Serializable
+
+fun Serializable.save(file: File): Boolean {
+  val fileOutputStream = try {
+    FileOutputStream(file)
+  } catch (e: FileNotFoundException) {
+    return false
+  }
+
+  fileOutputStream.use {
+    return try {
+      val outputStream = ObjectOutputStream(it)
+      outputStream.writeObject(this)
+      true
+    } catch (e: IOException) {
+      CanaryLog.d(e, "Could not save leak analysis result to disk.")
+      false
+    }
+  }
+}
+
+fun Serializable.toByteArray(): ByteArray {
+  val outputStream = ByteArrayOutputStream()
+  ObjectOutputStream(outputStream).writeObject(this)
+  return outputStream.toByteArray()
+}
+
+object Serializables {
+
+  fun <T> fromByteArray(byteArray: ByteArray): T? {
+    val inputStream = ByteArrayInputStream(byteArray)
+    return try {
+      ObjectInputStream(inputStream).readObject() as T
+    } catch (ignored: Throwable) {
+      null
+    }
+  }
+
+  fun <T> load(file: File): T? {
+
+    val fileInputStream = try {
+      FileInputStream(file)
+    } catch (e: FileNotFoundException) {
+      return null
+    }
+
+    fileInputStream.use {
+      return try {
+        val inputStream = ObjectInputStream(it)
+        inputStream.readObject() as T
+      } catch (e: Exception) {
+        CanaryLog.d(e, "Could not read file %s", file)
+        null
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer-core/src/main/java/leakcanary/internal/LeakTraceRenderer.kt b/leakcanary-analyzer-core/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
new file mode 100644
index 00000000..83d0b965
--- /dev/null
+++ b/leakcanary-analyzer-core/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
@@ -0,0 +1,75 @@
+package leakcanary.internal
+
+import leakcanary.LeakTrace
+import leakcanary.LeakTraceElement
+import leakcanary.LeakTraceElement.Holder.ARRAY
+import leakcanary.LeakTraceElement.Holder.THREAD
+import leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import leakcanary.Reachability
+import leakcanary.Reachability.Status.REACHABLE
+import leakcanary.Reachability.Status.UNKNOWN
+import leakcanary.Reachability.Status.UNREACHABLE
+import java.util.Locale
+
+fun LeakTrace.renderToString(): String {
+  var leakInfo = "┬\n"
+  val lastElement = elements.last()
+  val lastReachability = expectedReachability.last()
+  elements.dropLast(1)
+      .forEachIndexed { index, leakTraceElement ->
+        val currentReachability = expectedReachability[index]
+        leakInfo += """
+        #├─ ${leakTraceElement.className}
+        #│    Leaking: ${currentReachability.renderToString()}${if (leakTraceElement.labels.isNotEmpty()) leakTraceElement.labels.joinToString(
+            "\n│    ", prefix = "\n│    "
+        ) else ""}
+        #│    ↓ ${getNextElementString(this, leakTraceElement, index)}
+        #""".trimMargin("#")
+      }
+  leakInfo += """╰→ ${lastElement.className}
+      #$ZERO_WIDTH_SPACE     Leaking: ${lastReachability.renderToString()}
+    """.trimMargin("#")
+
+  return leakInfo
+}
+
+private fun Reachability.renderToString(): String {
+  return when (status) {
+    UNKNOWN -> "UNKNOWN"
+    REACHABLE -> "NO ($reason)"
+    UNREACHABLE -> "YES ($reason)"
+  }
+}
+
+private fun getNextElementString(
+  leakTrace: LeakTrace,
+  element: LeakTraceElement,
+  index: Int
+): String {
+  val maybeLeakCause = leakTrace.elementMayBeLeakCause(index)
+
+  val staticString =
+    if (element.reference != null && element.reference.type == STATIC_FIELD) "static " else ""
+  val holderString =
+    if (element.holder == ARRAY || element.holder == THREAD) {
+      "${element.holder.name.toLowerCase(Locale.US)} "
+    } else ""
+  val simpleClassName = element.getSimpleClassName()
+  val referenceName = if (element.reference != null) ".${element.reference.displayName}" else ""
+  val exclusionString =
+    if (element.exclusion != null) " , matching exclusion ${element.exclusion.matching}" else ""
+  val requiredSpaces =
+    staticString.length + holderString.length + simpleClassName.length + "├─".length
+  val leakString = if (maybeLeakCause) {
+    "\n│$ELEMENT_DEFAULT_NEW_LINE_SPACE" + " ".repeat(
+        requiredSpaces
+    ) + "~".repeat(referenceName.length - 1)
+  } else {
+    ""
+  }
+
+  return staticString + holderString + simpleClassName + referenceName + exclusionString + leakString
+}
+
+private const val ZERO_WIDTH_SPACE = '\u200b'
+private const val ELEMENT_DEFAULT_NEW_LINE_SPACE = "     "
\ No newline at end of file
diff --git a/leakcanary-analyzer-core/src/main/java/leakcanary/internal/Strings.kt b/leakcanary-analyzer-core/src/main/java/leakcanary/internal/Strings.kt
new file mode 100644
index 00000000..a7e5f753
--- /dev/null
+++ b/leakcanary-analyzer-core/src/main/java/leakcanary/internal/Strings.kt
@@ -0,0 +1,43 @@
+package leakcanary.internal
+
+import java.nio.charset.Charset
+import java.security.MessageDigest
+import java.security.NoSuchAlgorithmException
+
+@JvmField
+val UTF_8: Charset = Charset.forName("UTF-8")
+
+fun String.lastSegment(segmentingChar: Char): String {
+  val separator = lastIndexOf(segmentingChar)
+  return if (separator == -1) this else this.substring(separator + 1)
+}
+
+fun String.createSHA1Hash(): String = createHash(this, "SHA-1")
+
+/**
+ * Derived from
+ * [this snippet](http://www.androidsnippets.com/create-a-md5-hash-and-dump-as-a-hex-string).
+ */
+private fun createHash(
+  text: String,
+  algorithm: String
+): String {
+  try {
+    // Create MD5 Hash.
+    val digest = MessageDigest.getInstance(algorithm)
+    digest.update(text.getBytes())
+    val messageDigest = digest.digest()
+
+    // Create Hex String.
+    val hexString = StringBuilder()
+    for (b in messageDigest) {
+      hexString.append(Integer.toHexString(0xff and b.toInt()))
+    }
+    return hexString.toString()
+  } catch (e: NoSuchAlgorithmException) {
+    throw AssertionError("Unable to construct MessageDigest for $algorithm")
+  }
+}
+
+/** Gets the string as an array of UTF-8 bytes. */
+fun String.getBytes(): ByteArray = toByteArray(UTF_8)
diff --git a/leakcanary-analyzer-perflib/build.gradle b/leakcanary-analyzer-perflib/build.gradle
new file mode 100644
index 00000000..b2c0192e
--- /dev/null
+++ b/leakcanary-analyzer-perflib/build.gradle
@@ -0,0 +1,20 @@
+apply plugin: 'java-library'
+apply plugin: 'kotlin'
+
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
+
+dependencies {
+  api project(':leakcanary-analyzer-core')
+  api project(':leakcanary-haha')
+
+  implementation deps.androidx.annotation
+  implementation deps.haha
+  implementation deps.kotlin.stdlib
+
+  testImplementation deps.assertj_core
+  testImplementation deps.junit
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/leakcanary-analyzer-perflib/gradle.properties b/leakcanary-analyzer-perflib/gradle.properties
new file mode 100644
index 00000000..441c3190
--- /dev/null
+++ b/leakcanary-analyzer-perflib/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-perflib-analyzer
+POM_NAME=LeakCanary Perflib Analyzer
+POM_PACKAGING=jar
diff --git a/leakcanary-analyzer-perflib/src/main/java/com/squareup/haha/perflib/HahaSpy.kt b/leakcanary-analyzer-perflib/src/main/java/com/squareup/haha/perflib/HahaSpy.kt
new file mode 100644
index 00000000..78b1f134
--- /dev/null
+++ b/leakcanary-analyzer-perflib/src/main/java/com/squareup/haha/perflib/HahaSpy.kt
@@ -0,0 +1,8 @@
+package com.squareup.haha.perflib
+
+internal fun Instance.allocatingThread(): Instance {
+  val snapshot = mHeap.mSnapshot
+  val threadSerialNumber = if (this is RootObj) mThread else mStack.mThreadSerialNumber
+  val thread = snapshot.getThread(threadSerialNumber)
+  return snapshot.findInstance(thread.mId)
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/HahaHelper.kt b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/HahaHelper.kt
new file mode 100644
index 00000000..d39685bf
--- /dev/null
+++ b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/HahaHelper.kt
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal.perflib
+
+import com.squareup.haha.perflib.ArrayInstance
+import com.squareup.haha.perflib.ClassInstance
+import com.squareup.haha.perflib.ClassObj
+import com.squareup.haha.perflib.Instance
+import com.squareup.haha.perflib.Type
+import java.lang.reflect.InvocationTargetException
+import java.nio.charset.Charset
+import java.util.Arrays.asList
+import java.util.HashSet
+
+internal object HahaHelper {
+
+  private val WRAPPER_TYPES = HashSet(
+      asList(
+          Boolean::class.java.name, Char::class.java.name, Float::class.java.name,
+          Double::class.java.name, Byte::class.java.name, Short::class.java.name,
+          Int::class.java.name, Long::class.java.name
+      )
+  )
+
+  fun threadName(holder: Instance): String {
+    val values = classInstanceValues(holder)
+    val nameField = fieldValue<Any>(values, "name")
+        ?: // Sometimes we can't find the String at the expected memory address in the heap dump.
+        // See https://github.com/square/leakcanary/issues/417 .
+        return "Thread name not available"
+    return asString(nameField)
+  }
+
+  fun extendsThread(clazz: ClassObj): Boolean {
+    var extendsThread = false
+    var parentClass = clazz
+    while (parentClass.superClassObj != null) {
+      if (parentClass.className == Thread::class.java.name) {
+        extendsThread = true
+        break
+      }
+      parentClass = parentClass.superClassObj
+    }
+    return extendsThread
+  }
+
+  /**
+   * This returns a string representation of any object or value passed in.
+   */
+  fun valueAsString(value: Any?): String {
+    val stringValue: String
+    if (value == null) {
+      stringValue = "null"
+    } else if (value is ClassInstance) {
+      val valueClassName = value.classObj.className
+      if (valueClassName == String::class.java.name) {
+        stringValue = '"'.toString() + asString(value) + '"'.toString()
+      } else {
+        stringValue = value.toString()
+      }
+    } else {
+      stringValue = value.toString()
+    }
+    return stringValue
+  }
+
+  fun asStringArray(arrayInstance: ArrayInstance): MutableList<String> {
+    val entries = mutableListOf<String>()
+    for (arrayEntry in arrayInstance.values) {
+      entries.add(asString(arrayEntry))
+    }
+    return entries
+  }
+
+  /** Given a string instance from the heap dump, this returns its actual string value.  */
+  fun asString(stringObject: Any): String {
+    val instance = stringObject as Instance
+    val values = classInstanceValues(instance)
+
+    val count = fieldValue<Int>(values, "count")!!
+    if (count == 0) {
+      return ""
+    }
+
+    val value = fieldValue<Any>(values, "value")!!
+
+    var offset: Int?
+    val array: ArrayInstance
+    if (isCharArray(value)) {
+      array = value as ArrayInstance
+
+      offset = 0
+      // < API 23
+      // As of Marshmallow, substrings no longer share their parent strings' char arrays
+      // eliminating the need for String.offset
+      // https://android-review.googlesource.com/#/c/83611/
+      if (hasField(values, "offset")) {
+        offset = fieldValue<Int>(values, "offset")!!
+      }
+
+      val chars = array.asCharArray(offset, count)
+      return String(chars)
+    } else if (isByteArray(value)) {
+      // In API 26, Strings are now internally represented as byte arrays.
+      array = value as ArrayInstance
+
+      // HACK - remove when HAHA's perflib is updated to https://goo.gl/Oe7ZwO.
+      try {
+        val asRawByteArray = ArrayInstance::class.java.getDeclaredMethod(
+            "asRawByteArray", Int::class.javaPrimitiveType, Int::class.javaPrimitiveType
+        )
+        asRawByteArray.isAccessible = true
+        val rawByteArray = asRawByteArray.invoke(array, 0, count) as ByteArray
+        return String(rawByteArray, Charset.forName("UTF-8"))
+      } catch (e: NoSuchMethodException) {
+        throw RuntimeException(e)
+      } catch (e: IllegalAccessException) {
+        throw RuntimeException(e)
+      } catch (e: InvocationTargetException) {
+        throw RuntimeException(e)
+      }
+
+    } else {
+      throw UnsupportedOperationException("Could not find char array in $instance")
+    }
+  }
+
+  fun isPrimitiveWrapper(value: Any): Boolean {
+    return if (value !is ClassInstance) {
+      false
+    } else WRAPPER_TYPES.contains(
+        value.classObj.className
+    )
+  }
+
+  fun isPrimitiveOrWrapperArray(value: Any): Boolean {
+    if (value !is ArrayInstance) {
+      return false
+    }
+    return if (value.arrayType != Type.OBJECT) {
+      true
+    } else WRAPPER_TYPES.contains(
+        value.classObj.className
+    )
+  }
+
+  private fun isCharArray(value: Any): Boolean {
+    return value is ArrayInstance && value.arrayType == Type.CHAR
+  }
+
+  private fun isByteArray(value: Any): Boolean {
+    return value is ArrayInstance && value.arrayType == Type.BYTE
+  }
+
+  fun classInstanceValues(instance: Instance): List<ClassInstance.FieldValue> {
+    val classInstance = instance as ClassInstance
+    return classInstance.values
+  }
+
+  fun <T> fieldValue(
+    values: List<ClassInstance.FieldValue>,
+    fieldName: String
+  ): T? {
+    for (fieldValue in values) {
+      if (fieldValue.field.name == fieldName) {
+        @Suppress("UNCHECKED_CAST")
+        return fieldValue.value as T
+      }
+    }
+    throw IllegalArgumentException("Field $fieldName does not exists")
+  }
+
+  fun hasField(
+    values: List<ClassInstance.FieldValue>,
+    fieldName: String
+  ): Boolean {
+    for (fieldValue in values) {
+      if (fieldValue.field.name == fieldName) {
+
+        return true
+      }
+    }
+    return false
+  }
+
+  fun <T> staticFieldValue(
+    classObj: ClassObj,
+    fieldName: String
+  ): T {
+    for ((key, value) in classObj.staticFieldValues) {
+      if (key.name == fieldName) {
+        @Suppress("UNCHECKED_CAST")
+        return value as T
+      }
+    }
+    throw IllegalArgumentException("Field $fieldName does not exists")
+  }
+}
diff --git a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/KeyedWeakReferenceMirror.kt b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/KeyedWeakReferenceMirror.kt
new file mode 100644
index 00000000..b68fb355
--- /dev/null
+++ b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/KeyedWeakReferenceMirror.kt
@@ -0,0 +1,47 @@
+package leakcanary.internal.perflib
+
+import com.squareup.haha.perflib.ClassInstance
+import com.squareup.haha.perflib.Instance
+import leakcanary.internal.perflib.HahaHelper.asString
+import leakcanary.internal.perflib.HahaHelper.classInstanceValues
+import leakcanary.internal.perflib.HahaHelper.fieldValue
+
+/**
+ * Represents a [leakcanary.KeyedWeakReference] read from the heap dump.
+ */
+internal sealed class KeyedWeakReferenceMirror(
+  fields: List<ClassInstance.FieldValue>,
+  heapDumpUptimeMillis: Long
+) {
+  val key = asString(fieldValue<Any>(fields, "key")!!)
+  val name = asString(fieldValue<Any>(fields, "name")!!)
+  val className = asString(fieldValue<Any>(fields, "className")!!)
+  val watchDurationMillis = heapDumpUptimeMillis - fieldValue<Long>(fields, "watchUptimeMillis")!!
+
+  companion object {
+    fun fromInstance(
+      weakRef: Instance,
+      heapDumpUptimeMillis: Long
+    ): KeyedWeakReferenceMirror {
+      val values = classInstanceValues(weakRef)
+      val referent = fieldValue<Instance>(values, "referent")
+      return if (referent != null) {
+        HasReferent(values, heapDumpUptimeMillis, referent)
+      } else {
+        Cleared(values, heapDumpUptimeMillis)
+      }
+    }
+
+  }
+}
+
+internal class Cleared(
+  fields: List<ClassInstance.FieldValue>,
+  heapDumpUptimeMillis: Long
+) : KeyedWeakReferenceMirror(fields, heapDumpUptimeMillis)
+
+internal class HasReferent(
+  fields: List<ClassInstance.FieldValue>,
+  heapDumpUptimeMillis: Long,
+  val referent: Instance
+) : KeyedWeakReferenceMirror(fields, heapDumpUptimeMillis)
diff --git a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/LeakNode.kt b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/LeakNode.kt
new file mode 100644
index 00000000..5ce05874
--- /dev/null
+++ b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/LeakNode.kt
@@ -0,0 +1,12 @@
+package leakcanary.internal.perflib
+
+import com.squareup.haha.perflib.Instance
+import leakcanary.Exclusion
+import leakcanary.LeakReference
+
+internal data class LeakNode(
+  val exclusion: Exclusion?,
+  val instance: Instance,
+  val parent: LeakNode?,
+  val leakReference: LeakReference?
+)
\ No newline at end of file
diff --git a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzer.kt b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzer.kt
new file mode 100644
index 00000000..f837144e
--- /dev/null
+++ b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzer.kt
@@ -0,0 +1,644 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal.perflib
+
+import com.android.tools.perflib.captures.MemoryMappedFileBuffer
+import com.squareup.haha.perflib.ArrayInstance
+import com.squareup.haha.perflib.ClassInstance
+import com.squareup.haha.perflib.ClassObj
+import com.squareup.haha.perflib.Instance
+import com.squareup.haha.perflib.RootObj
+import com.squareup.haha.perflib.Snapshot
+import com.squareup.haha.perflib.Type
+import gnu.trove.THashMap
+import gnu.trove.TObjectProcedure
+import leakcanary.AnalysisResult
+import leakcanary.AnalyzerProgressListener
+import leakcanary.AnalyzerProgressListener.Step.BUILDING_LEAK_TRACE
+import leakcanary.AnalyzerProgressListener.Step.BUILDING_LEAK_TRACES
+import leakcanary.AnalyzerProgressListener.Step.COMPUTING_DOMINATORS
+import leakcanary.AnalyzerProgressListener.Step.DEDUPLICATING_GC_ROOTS
+import leakcanary.AnalyzerProgressListener.Step.FINDING_LEAKING_REF
+import leakcanary.AnalyzerProgressListener.Step.FINDING_LEAKING_REFS
+import leakcanary.AnalyzerProgressListener.Step.FINDING_SHORTEST_PATH
+import leakcanary.AnalyzerProgressListener.Step.FINDING_SHORTEST_PATHS
+import leakcanary.AnalyzerProgressListener.Step.PARSING_HEAP_DUMP
+import leakcanary.AnalyzerProgressListener.Step.READING_HEAP_DUMP_FILE
+import leakcanary.AnalyzerProgressListener.Step.SCANNING_HEAP_DUMP
+import leakcanary.HeapAnalysis
+import leakcanary.HeapAnalysisException
+import leakcanary.HeapAnalysisFailure
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.HeapDump
+import leakcanary.HeapDumpMemoryStore
+import leakcanary.KeyedWeakReference
+import leakcanary.LeakReference
+import leakcanary.LeakTrace
+import leakcanary.LeakTraceElement
+import leakcanary.LeakTraceElement.Holder
+import leakcanary.LeakTraceElement.Holder.ARRAY
+import leakcanary.LeakTraceElement.Holder.CLASS
+import leakcanary.LeakTraceElement.Holder.OBJECT
+import leakcanary.LeakTraceElement.Holder.THREAD
+import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
+import leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
+import leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import leakcanary.LeakingInstance
+import leakcanary.NoPathToInstance
+import leakcanary.Reachability
+import leakcanary.Reachability.Inspector
+import leakcanary.Reachability.Status.REACHABLE
+import leakcanary.Reachability.Status.UNKNOWN
+import leakcanary.Reachability.Status.UNREACHABLE
+import leakcanary.RetainedInstance
+import leakcanary.WeakReferenceCleared
+import leakcanary.WeakReferenceMissing
+import leakcanary.internal.perflib.HahaHelper.asString
+import leakcanary.internal.perflib.HahaHelper.asStringArray
+import leakcanary.internal.perflib.HahaHelper.classInstanceValues
+import leakcanary.internal.perflib.HahaHelper.extendsThread
+import leakcanary.internal.perflib.HahaHelper.fieldValue
+import leakcanary.internal.perflib.HahaHelper.staticFieldValue
+import leakcanary.internal.perflib.HahaHelper.threadName
+import leakcanary.internal.perflib.HahaHelper.valueAsString
+import leakcanary.internal.perflib.ShortestPathFinder.Result
+import org.jetbrains.annotations.TestOnly
+import java.util.ArrayList
+import java.util.concurrent.TimeUnit.NANOSECONDS
+
+/**
+ * Analyzes heap dumps to look for leaks.
+ */
+class PerflibHeapAnalyzer @TestOnly internal constructor(
+  private val listener: AnalyzerProgressListener,
+  private val keyedWeakReferenceClassName: String,
+  private val heapDumpMemoryStoreClassName: String
+) {
+
+  constructor(listener: AnalyzerProgressListener) : this(
+      listener, KeyedWeakReference::class.java.name, HeapDumpMemoryStore::class.java.name
+  )
+
+  /**
+   * Searches the heap dump for a [KeyedWeakReference] instance with the corresponding key,
+   * and then computes the shortest strong reference path from that instance to the GC roots.
+   */
+  @TestOnly
+  @Deprecated(
+      "Use {@link #checkForLeaks(File, boolean)} instead. We're keeping this only because\n" +
+          "    our tests currently run with older heapdumps."
+  )
+  internal fun checkForLeak(
+    heapDump: HeapDump,
+    referenceKey: String
+  ): AnalysisResult {
+    val analysisStartNanoTime = System.nanoTime()
+
+    if (!heapDump.heapDumpFile.exists()) {
+      val exception = IllegalArgumentException("File does not exist: $heapDump.heapDumpFile")
+      return AnalysisResult.failure(exception, since(analysisStartNanoTime))
+    }
+
+    var buffer: MemoryMappedFileBuffer? = null
+    try {
+      listener.onProgressUpdate(READING_HEAP_DUMP_FILE)
+      buffer = MemoryMappedFileBuffer(heapDump.heapDumpFile)
+      listener.onProgressUpdate(PARSING_HEAP_DUMP)
+      val snapshot = Snapshot.createSnapshot(buffer)
+      listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS)
+      deduplicateGcRoots(snapshot)
+      listener.onProgressUpdate(FINDING_LEAKING_REF)
+      val leakingRef = findLeakingReference(referenceKey, snapshot) ?: return AnalysisResult.noLeak(
+          "UnknownNoKeyedWeakReference",
+          since(analysisStartNanoTime)
+      )
+      return findLeakTrace(
+          heapDump,
+          referenceKey, "NAME_NOT_SUPPORTED", analysisStartNanoTime, snapshot,
+          leakingRef, 0
+      )
+    } catch (e: Throwable) {
+      return AnalysisResult.failure(e, since(analysisStartNanoTime))
+    } finally {
+      try {
+        buffer?.dispose()
+      } catch (ignored: NoClassDefFoundError) {
+        // DirectBuffer does not exist on older Android versions.
+      }
+    }
+
+  }
+
+  /**
+   * Searches the heap dump for a [KeyedWeakReference] instance with the corresponding key,
+   * and then computes the shortest strong reference path from that instance to the GC roots.
+   */
+  fun checkForLeaks(
+    heapDump: HeapDump
+  ): HeapAnalysis {
+    val analysisStartNanoTime = System.nanoTime()
+
+    if (!heapDump.heapDumpFile.exists()) {
+      val exception = IllegalArgumentException("File does not exist: $heapDump.heapDumpFile")
+      return HeapAnalysisFailure(
+          heapDump, System.currentTimeMillis(), since(analysisStartNanoTime),
+          HeapAnalysisException(exception)
+      )
+    }
+
+    var buffer: MemoryMappedFileBuffer? = null
+    try {
+      listener.onProgressUpdate(READING_HEAP_DUMP_FILE)
+      buffer = MemoryMappedFileBuffer(heapDump.heapDumpFile)
+      listener.onProgressUpdate(SCANNING_HEAP_DUMP)
+      val snapshot = Snapshot.createSnapshot(buffer)
+      listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS)
+      deduplicateGcRoots(snapshot)
+
+      val analysisResults = mutableMapOf<String, RetainedInstance>()
+
+      val (retainedKeys, heapDumpUptimeMillis) = readHeapDumpMemoryStore(snapshot)
+
+      if (retainedKeys.size == 0) {
+        val exception = IllegalStateException("No retained keys found in heap dump")
+        return HeapAnalysisFailure(
+            heapDump, System.currentTimeMillis(), since(analysisStartNanoTime),
+            HeapAnalysisException(exception)
+        )
+      }
+
+      val leakingWeakRefs =
+        findLeakingReferences(snapshot, retainedKeys, analysisResults, heapDumpUptimeMillis)
+
+      val pathResults = findShortestPaths(heapDump, snapshot, leakingWeakRefs)
+
+      buildLeakTraces(heapDump, pathResults, snapshot, leakingWeakRefs, analysisResults)
+
+      addRemainingInstancesWithNoPath(leakingWeakRefs, analysisResults)
+
+      return HeapAnalysisSuccess(
+          heapDump, System.currentTimeMillis(), since(analysisStartNanoTime),
+          analysisResults.values.toList()
+      )
+    } catch (exception: Throwable) {
+      return HeapAnalysisFailure(
+          heapDump, System.currentTimeMillis(), since(analysisStartNanoTime),
+          HeapAnalysisException(exception)
+      )
+    } finally {
+      try {
+        buffer?.dispose()
+      } catch (ignored: NoClassDefFoundError) {
+        // DirectBuffer does not exist on older Android versions.
+      }
+    }
+  }
+
+  private fun readHeapDumpMemoryStore(snapshot: Snapshot): Pair<MutableList<String>, Long> {
+    val heapDumpMemoryStoreClass = snapshot.findClass(heapDumpMemoryStoreClassName)
+    val retainedKeysArray =
+      staticFieldValue<ArrayInstance>(heapDumpMemoryStoreClass, "retainedKeysForHeapDump")
+    val retainedKeys = asStringArray(retainedKeysArray)
+    val heapDumpUptimeMillis =
+      staticFieldValue<Long>(heapDumpMemoryStoreClass, "heapDumpUptimeMillis")
+    return Pair(retainedKeys, heapDumpUptimeMillis)
+  }
+
+  /**
+   * Pruning duplicates reduces memory pressure from hprof bloat added in Marshmallow.
+   */
+  internal fun deduplicateGcRoots(snapshot: Snapshot) {
+    // THashMap has a smaller memory footprint than HashMap.
+    val uniqueRootMap = THashMap<String, RootObj>()
+
+    val gcRoots = snapshot.gcRoots
+    for (root in gcRoots) {
+      val key = generateRootKey(root)
+      if (!uniqueRootMap.containsKey(key)) {
+        uniqueRootMap[key] = root
+      }
+    }
+
+    // Repopulate snapshot with unique GC roots.
+    gcRoots.clear()
+    uniqueRootMap.forEach(TObjectProcedure { key -> gcRoots.add(uniqueRootMap[key]) })
+  }
+
+  private fun generateRootKey(root: RootObj): String {
+    return String.format("%s@0x%08x", root.rootType.getName(), root.id)
+  }
+
+  private fun findLeakingReferences(
+    snapshot: Snapshot,
+    retainedKeys: MutableList<String>,
+    analysisResults: MutableMap<String, RetainedInstance>,
+    heapDumpUptimeMillis: Long
+  ): MutableList<HasReferent> {
+    listener.onProgressUpdate(FINDING_LEAKING_REFS)
+
+    val refClass = snapshot.findClass(keyedWeakReferenceClassName) ?: throw IllegalStateException(
+        "Could not find the "
+            + keyedWeakReferenceClassName
+            + " class in the heap dump."
+    )
+
+    val leakingWeakRefs = mutableListOf<HasReferent>()
+    for (weakRef in refClass.instancesList) {
+      val weakRefMirror = KeyedWeakReferenceMirror.fromInstance(
+          weakRef, heapDumpUptimeMillis
+      )
+
+      val wasRetained = retainedKeys.remove(weakRefMirror.key)
+      if (wasRetained) {
+        if (weakRefMirror is HasReferent) {
+          leakingWeakRefs.add(weakRefMirror)
+        } else {
+          val noLeak = WeakReferenceCleared(
+              weakRefMirror.key, weakRefMirror.name, weakRefMirror.className,
+              weakRefMirror.watchDurationMillis
+          )
+          analysisResults[weakRefMirror.key] = noLeak
+        }
+      }
+    }
+
+    retainedKeys.forEach { referenceKey ->
+      // This could happen if RefWatcher removed weakly reachable references after providing
+      // the set of retained keys
+      val noLeak = WeakReferenceMissing(referenceKey)
+      analysisResults[referenceKey] = noLeak
+    }
+    return leakingWeakRefs
+  }
+
+  private fun findShortestPaths(
+    heapDump: HeapDump,
+    snapshot: Snapshot,
+    leakingWeakRefs: MutableList<HasReferent>
+  ): List<Result> {
+    listener.onProgressUpdate(FINDING_SHORTEST_PATHS)
+    val pathFinder =
+      ShortestPathFinder(heapDump.excludedRefs, ignoreStrings = true)
+    return pathFinder.findPaths(snapshot, leakingWeakRefs)
+  }
+
+  private fun buildLeakTraces(
+    heapDump: HeapDump,
+    pathResults: List<Result>,
+    snapshot: Snapshot,
+    leakingWeakRefs: MutableList<HasReferent>,
+    analysisResults: MutableMap<String, RetainedInstance>
+  ) {
+    if (heapDump.computeRetainedHeapSize && pathResults.isNotEmpty()) {
+      listener.onProgressUpdate(COMPUTING_DOMINATORS)
+      // Computing dominators has the side effect of computing retained size.
+      snapshot.computeDominators()
+    }
+
+    listener.onProgressUpdate(BUILDING_LEAK_TRACES)
+
+    pathResults.forEach { pathResult ->
+      val weakReference = pathResult.weakReference
+      val removed = leakingWeakRefs.remove(weakReference)
+      if (!removed) {
+        throw IllegalStateException(
+            "ShortestPathFinder found an instance we didn't ask it to find: $pathResult"
+        )
+      }
+
+      val leakTrace = buildLeakTrace(heapDump, pathResult.leakingNode)
+
+      val retainedSize = if (heapDump.computeRetainedHeapSize) {
+        pathResult.leakingNode.instance.totalRetainedSize
+      } else {
+        null
+      }
+      val leakDetected = LeakingInstance(
+          weakReference.key, weakReference.name, weakReference.className,
+          weakReference.watchDurationMillis, pathResult.excludingKnownLeaks, leakTrace, retainedSize
+      )
+      analysisResults[weakReference.key] = leakDetected
+    }
+  }
+
+  private fun addRemainingInstancesWithNoPath(
+    leakingWeakRefs: MutableList<HasReferent>,
+    analysisResults: MutableMap<String, RetainedInstance>
+  ) {
+    leakingWeakRefs.forEach { refWithNoPath ->
+      val noLeak = NoPathToInstance(
+          refWithNoPath.key, refWithNoPath.name, refWithNoPath.className,
+          refWithNoPath.watchDurationMillis
+      )
+      analysisResults[refWithNoPath.key] = noLeak
+    }
+  }
+
+  private fun findLeakingReference(
+    key: String,
+    snapshot: Snapshot
+  ): Instance? {
+    val refClass = snapshot.findClass(keyedWeakReferenceClassName) ?: throw IllegalStateException(
+        "Could not find the $keyedWeakReferenceClassName class in the heap dump."
+    )
+    val keysFound = ArrayList<String?>()
+    for (instance in refClass.instancesList) {
+      val values = classInstanceValues(instance)
+      val keyFieldValue = fieldValue<Any>(values, "key")
+      if (keyFieldValue == null) {
+        keysFound.add(null)
+        continue
+      }
+      val keyCandidate = asString(keyFieldValue)
+      if (keyCandidate == key) {
+        return fieldValue<Instance>(values, "referent")
+      }
+      keysFound.add(keyCandidate)
+    }
+    throw IllegalStateException(
+        "Could not find weak reference with key $key in $keysFound"
+    )
+  }
+
+  private fun findLeakTrace(
+    heapDump: HeapDump,
+    referenceKey: String,
+    referenceName: String,
+    analysisStartNanoTime: Long,
+    snapshot: Snapshot,
+    leakingRef: Instance,
+    watchDurationMs: Long
+  ): AnalysisResult {
+
+    listener.onProgressUpdate(FINDING_SHORTEST_PATH)
+    val pathFinder =
+      ShortestPathFinder(heapDump.excludedRefs, ignoreStrings = true)
+    val result = pathFinder.findPath(snapshot, leakingRef)
+
+    val className = leakingRef.classObj.className
+
+    // False alarm, no strong reference path to GC Roots.
+    if (result.leakingNode == null) {
+      return AnalysisResult.noLeak(className, since(analysisStartNanoTime))
+    }
+
+    listener.onProgressUpdate(BUILDING_LEAK_TRACE)
+    val leakTrace = buildLeakTrace(heapDump, result.leakingNode)
+
+    val retainedSize = if (heapDump.computeRetainedHeapSize) {
+      listener.onProgressUpdate(COMPUTING_DOMINATORS)
+      // Side effect: computes retained size.
+      snapshot.computeDominators()
+
+      val leakingInstance = result.leakingNode.instance
+
+      leakingInstance.totalRetainedSize
+    } else {
+      AnalysisResult.RETAINED_HEAP_SKIPPED
+    }
+
+    return AnalysisResult.leakDetected(
+        referenceKey, referenceName,
+        result.excludingKnownLeaks, className, leakTrace,
+        retainedSize,
+        since(analysisStartNanoTime), watchDurationMs
+    )
+  }
+
+  private fun buildLeakTrace(
+    heapDump: HeapDump,
+    leakingNode: LeakNode
+  ): LeakTrace {
+    val elements = ArrayList<LeakTraceElement>()
+    // We iterate from the leak to the GC root
+    val ignored = leakingNode.instance
+    var node: LeakNode? =
+      LeakNode(null, ignored, leakingNode, null)
+    while (node != null) {
+      val element = buildLeakElement(node)
+      if (element != null) {
+        elements.add(0, element)
+      }
+      node = node.parent
+    }
+
+    val expectedReachability = computeExpectedReachability(heapDump, elements)
+
+    return LeakTrace(elements, expectedReachability)
+  }
+
+  private fun computeExpectedReachability(
+    heapDump: HeapDump,
+    elements: List<LeakTraceElement>
+  ): List<Reachability> {
+    var lastReachableElementIndex = 0
+    val lastElementIndex = elements.size - 1
+    var firstUnreachableElementIndex = lastElementIndex
+
+    val expectedReachability = ArrayList<Reachability>()
+
+    val reachabilityInspectors = mutableListOf<Inspector>()
+    for (reachabilityInspectorClass in heapDump.reachabilityInspectorClasses) {
+      try {
+        val defaultConstructor = reachabilityInspectorClass.getDeclaredConstructor()
+        reachabilityInspectors.add(defaultConstructor.newInstance())
+      } catch (e: Exception) {
+        throw RuntimeException(e)
+      }
+    }
+
+    for ((index, element) in elements.withIndex()) {
+      val reachability = inspectElementReachability(reachabilityInspectors, element)
+      expectedReachability.add(reachability)
+      if (reachability.status == REACHABLE) {
+        lastReachableElementIndex = index
+        // Reset firstUnreachableElementIndex so that we never have
+        // firstUnreachableElementIndex < lastReachableElementIndex
+        firstUnreachableElementIndex = lastElementIndex
+      } else if (firstUnreachableElementIndex == lastElementIndex && reachability.status == UNREACHABLE) {
+        firstUnreachableElementIndex = index
+      }
+    }
+
+    if (expectedReachability[0].status == UNKNOWN) {
+      expectedReachability[0] = Reachability.reachable("it's a GC root")
+    }
+
+    if (expectedReachability[lastElementIndex].status == UNKNOWN) {
+      expectedReachability[lastElementIndex] =
+        Reachability.unreachable("RefWatcher was watching this")
+    }
+
+    // First and last are always known.
+    for (i in 1 until lastElementIndex) {
+      val reachability = expectedReachability[i]
+      if (reachability.status == UNKNOWN) {
+        if (i < lastReachableElementIndex) {
+          val nextReachableName = elements[i + 1].getSimpleClassName()
+          expectedReachability[i] =
+            Reachability.reachable("$nextReachableName↓ is not leaking")
+        } else if (i > firstUnreachableElementIndex) {
+          val previousUnreachableName = elements[i - 1].getSimpleClassName()
+          expectedReachability[i] =
+            Reachability.unreachable("$previousUnreachableName↑ is leaking")
+        }
+      }
+    }
+    return expectedReachability
+  }
+
+  private fun inspectElementReachability(
+    reachabilityInspectors: List<Inspector>,
+    element: LeakTraceElement
+  ): Reachability {
+    for (reachabilityInspector in reachabilityInspectors) {
+      val reachability = reachabilityInspector.expectedReachability(element)
+      if (reachability.status != UNKNOWN) {
+        return reachability
+      }
+    }
+    return Reachability.unknown()
+  }
+
+  private fun buildLeakElement(node: LeakNode): LeakTraceElement? {
+    if (node.parent == null) {
+      // Ignore any root node.
+      return null
+    }
+    val holder = node.parent.instance
+
+    if (holder is RootObj) {
+      return null
+    }
+    val holderType: Holder
+    val className: String
+    var extra: String? = null
+    val leakReferences = describeFields(holder)
+
+    className = getClassName(holder)
+
+    val classHierarchy = ArrayList<String>()
+    classHierarchy.add(className)
+    val rootClassName = Any::class.java.name
+    if (holder is ClassInstance) {
+      var classObj = holder.classObj
+
+      do {
+        classObj = classObj.superClassObj
+        if (classObj.className != rootClassName) {
+          classHierarchy.add(classObj.className)
+        }
+      } while (classObj.className != rootClassName)
+    }
+
+    if (holder is ClassObj) {
+      holderType = CLASS
+    } else if (holder is ArrayInstance) {
+      holderType = ARRAY
+    } else {
+      val classObj = holder.classObj
+      if (extendsThread(classObj)) {
+        holderType = THREAD
+        val threadName = threadName(holder)
+        extra = "(named '$threadName')"
+      } else if (className.matches(
+              ANONYMOUS_CLASS_NAME_PATTERN.toRegex()
+          )
+      ) {
+        val parentClassName = classObj.superClassObj.className
+        if (rootClassName == parentClassName) {
+          holderType = OBJECT
+          try {
+            // This is an anonymous class implementing an interface. The API does not give access
+            // to the interfaces implemented by the class. We check if it's in the class path and
+            // use that instead.
+            val actualClass = Class.forName(classObj.className)
+            val interfaces = actualClass.interfaces
+            extra = if (interfaces.isNotEmpty()) {
+              val implementedInterface = interfaces[0]
+              "(anonymous implementation of " + implementedInterface.name + ")"
+            } else {
+              "(anonymous subclass of java.lang.Object)"
+            }
+          } catch (ignored: ClassNotFoundException) {
+          }
+
+        } else {
+          holderType = OBJECT
+          // Makes it easier to figure out which anonymous class we're looking at.
+          extra = "(anonymous subclass of $parentClassName)"
+        }
+      } else {
+        holderType = OBJECT
+      }
+    }
+    val labels = if (extra == null) emptyList<String>() else mutableListOf(extra)
+    return LeakTraceElement(
+        node.leakReference, holderType, classHierarchy, node.exclusion, leakReferences, labels
+    )
+  }
+
+  private fun describeFields(instance: Instance?): List<LeakReference> {
+    val leakReferences = ArrayList<LeakReference>()
+    if (instance is ClassObj) {
+      val classObj = instance as ClassObj?
+      for ((key, value) in classObj!!.staticFieldValues) {
+        val name = key.name
+        val stringValue = valueAsString(value)
+        leakReferences.add(LeakReference(STATIC_FIELD, name, stringValue))
+      }
+    } else if (instance is ArrayInstance) {
+      val arrayInstance = instance as ArrayInstance?
+      if (arrayInstance!!.arrayType == Type.OBJECT) {
+        val values = arrayInstance.values
+        for (i in values.indices) {
+          val name = Integer.toString(i)
+          val stringValue = valueAsString(values[i])
+          leakReferences.add(LeakReference(ARRAY_ENTRY, name, stringValue))
+        }
+      }
+    } else {
+      val classObj = instance!!.classObj
+      for ((key, value) in classObj.staticFieldValues) {
+        val name = key.name
+        val stringValue = valueAsString(value)
+        leakReferences.add(LeakReference(STATIC_FIELD, name, stringValue))
+      }
+      val classInstance = instance as ClassInstance?
+      for (field in classInstance!!.values) {
+        val name = field.field.name
+        val stringValue = valueAsString(field.value)
+        leakReferences.add(LeakReference(INSTANCE_FIELD, name, stringValue))
+      }
+    }
+    return leakReferences
+  }
+
+  private fun getClassName(instance: Instance): String = when (instance) {
+    is ClassObj -> instance.className
+    is ArrayInstance -> instance.classObj.className
+    else -> instance.classObj.className
+  }
+
+  private fun since(analysisStartNanoTime: Long): Long {
+    return NANOSECONDS.toMillis(System.nanoTime() - analysisStartNanoTime)
+  }
+
+  companion object {
+
+    private const val ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$"
+  }
+}
diff --git a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/ShortestPathFinder.kt b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/ShortestPathFinder.kt
new file mode 100644
index 00000000..edd80dad
--- /dev/null
+++ b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/ShortestPathFinder.kt
@@ -0,0 +1,384 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal.perflib
+
+import com.squareup.haha.perflib.ArrayInstance
+import com.squareup.haha.perflib.ClassInstance
+import com.squareup.haha.perflib.ClassObj
+import com.squareup.haha.perflib.Instance
+import com.squareup.haha.perflib.RootObj
+import com.squareup.haha.perflib.RootType
+import com.squareup.haha.perflib.Snapshot
+import com.squareup.haha.perflib.Type
+import com.squareup.haha.perflib.allocatingThread
+import leakcanary.ExcludedRefs
+import leakcanary.Exclusion
+import leakcanary.LeakReference
+import leakcanary.internal.perflib.HahaHelper.isPrimitiveOrWrapperArray
+import leakcanary.internal.perflib.HahaHelper.isPrimitiveWrapper
+import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
+import leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
+import leakcanary.LeakTraceElement.Type.LOCAL
+import leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import java.util.ArrayDeque
+import java.util.Deque
+import java.util.LinkedHashMap
+import java.util.LinkedHashSet
+
+/**
+ * Not thread safe.
+ *
+ * Finds the shortest path from a leaking reference to a gc root, ignoring excluded
+ * refs first and then including the ones that are not "always ignorable" as needed if no path is
+ * found.
+ */
+internal class ShortestPathFinder(
+  private val excludedRefs: ExcludedRefs,
+  private val ignoreStrings: Boolean
+) {
+  private val toVisitQueue: Deque<LeakNode>
+  private val toVisitIfNoPathQueue: Deque<LeakNode>
+  private val toVisitSet: LinkedHashSet<Instance>
+  private val toVisitIfNoPathSet: LinkedHashSet<Instance>
+  private val visitedSet: LinkedHashSet<Instance>
+
+  init {
+    toVisitQueue = ArrayDeque()
+    toVisitIfNoPathQueue = ArrayDeque()
+    toVisitSet = LinkedHashSet()
+    toVisitIfNoPathSet = LinkedHashSet()
+    visitedSet = LinkedHashSet()
+  }
+
+  @Deprecated("Kept for tests which still rely on findPath()")
+  internal class OldResult(
+    val leakingNode: LeakNode?,
+    val excludingKnownLeaks: Boolean
+  )
+
+  internal class Result(
+    val leakingNode: LeakNode,
+    val excludingKnownLeaks: Boolean,
+    val weakReference: HasReferent
+  )
+
+  fun findPaths(
+    snapshot: Snapshot,
+    leakingWeakRefs: List<HasReferent>
+  ): List<Result> {
+    clearState()
+
+    val referentMap = leakingWeakRefs.associateBy { it.referent }
+
+    enqueueGcRoots(snapshot)
+
+    var excludingKnownLeaks = false
+    val results = mutableListOf<Result>()
+    while (!toVisitQueue.isEmpty() || !toVisitIfNoPathQueue.isEmpty()) {
+      val node: LeakNode
+      if (!toVisitQueue.isEmpty()) {
+        node = toVisitQueue.poll()
+      } else {
+        node = toVisitIfNoPathQueue.poll()
+        if (node.exclusion == null) {
+          throw IllegalStateException("Expected node to have an exclusion $node")
+        }
+        excludingKnownLeaks = true
+      }
+
+      if (checkSeen(node)) {
+        continue
+      }
+
+      val weakReference = referentMap[node.instance]
+      if (weakReference != null) {
+        results.add(
+            Result(
+                node, excludingKnownLeaks, weakReference
+            )
+        )
+        // Found all refs, stop searching.
+        if (results.size == leakingWeakRefs.size) {
+          break
+        }
+      }
+      when (node.instance) {
+        is RootObj -> visitRootObj(node)
+        is ClassObj -> visitClassObj(node)
+        is ClassInstance -> visitClassInstance(node)
+        is ArrayInstance -> visitArrayInstance(node)
+        else -> throw IllegalStateException("Unexpected type for ${node.instance}")
+      }
+    }
+    return results
+  }
+
+  fun findPath(
+    snapshot: Snapshot,
+    leakingRef: Instance
+  ): OldResult {
+    clearState()
+
+    enqueueGcRoots(snapshot)
+
+    var excludingKnownLeaks = false
+    var leakingNode: LeakNode? = null
+    while (!toVisitQueue.isEmpty() || !toVisitIfNoPathQueue.isEmpty()) {
+      val node: LeakNode
+      if (!toVisitQueue.isEmpty()) {
+        node = toVisitQueue.poll()
+      } else {
+        node = toVisitIfNoPathQueue.poll()
+        if (node.exclusion == null) {
+          throw IllegalStateException("Expected node to have an exclusion $node")
+        }
+        excludingKnownLeaks = true
+      }
+
+      // Termination
+      if (node.instance === leakingRef) {
+        leakingNode = node
+        break
+      }
+
+      if (checkSeen(node)) {
+        continue
+      }
+
+      when {
+        node.instance is RootObj -> visitRootObj(node)
+        node.instance is ClassObj -> visitClassObj(node)
+        node.instance is ClassInstance -> visitClassInstance(node)
+        node.instance is ArrayInstance -> visitArrayInstance(node)
+        else -> throw IllegalStateException("Unexpected type for " + node.instance!!)
+      }
+    }
+    return OldResult(
+        leakingNode, excludingKnownLeaks
+    )
+  }
+
+  private fun clearState() {
+    toVisitQueue.clear()
+    toVisitIfNoPathQueue.clear()
+    toVisitSet.clear()
+    toVisitIfNoPathSet.clear()
+    visitedSet.clear()
+  }
+
+  private fun enqueueGcRoots(snapshot: Snapshot) {
+    val gcRoots = snapshot.gcRoots as MutableList<RootObj>
+    // Sorting GC roots to get stable shortest path
+    gcRoots.sortWith(compareBy({ it.rootType.type }, {
+      val referredInstance = it.referredInstance
+      if (referredInstance == null) {
+        "null"
+      } else {
+        when (referredInstance) {
+          is ClassObj -> referredInstance.className
+          is ClassInstance -> referredInstance.classObj.className
+          is ArrayInstance -> referredInstance.classObj.className
+          else -> throw IllegalStateException("Unexpected type for $referredInstance")
+        }
+      }
+    }))
+    for (rootObj in gcRoots) {
+      when (rootObj.rootType) {
+        RootType.JAVA_LOCAL -> {
+          val thread = rootObj.allocatingThread()
+          val threadName = HahaHelper.threadName(thread)
+          val params = excludedRefs.threadNames[threadName]
+          if (params == null || !params.alwaysExclude) {
+            enqueue(params, null, rootObj, null)
+          }
+        }
+        // Added at https://android.googlesource.com/platform/tools/base/+/c0f0d528c155cab32e372dac77370569a386245c
+        RootType.THREAD_OBJECT, RootType.INTERNED_STRING, RootType.DEBUGGER, RootType.INVALID_TYPE,
+          // An object that is unreachable from any other root, but not a root itself.
+        RootType.UNREACHABLE, RootType.UNKNOWN,
+          // An object that is in a queue, waiting for a finalizer to run.
+        RootType.FINALIZING -> {
+        }
+        RootType.SYSTEM_CLASS, RootType.VM_INTERNAL,
+          // A local variable in native code.
+        RootType.NATIVE_LOCAL,
+          // A global variable in native code.
+        RootType.NATIVE_STATIC,
+          // An object that was referenced from an active thread block.
+        RootType.THREAD_BLOCK,
+          // Everything that called the wait() or notify() methods, or that is synchronized.
+        RootType.BUSY_MONITOR, RootType.NATIVE_MONITOR, RootType.REFERENCE_CLEANUP,
+          // Input or output parameters in native code.
+        RootType.NATIVE_STACK, RootType.JAVA_STATIC -> enqueue(null, null, rootObj, null)
+        else -> throw UnsupportedOperationException("Unknown root type:" + rootObj.rootType)
+      }
+    }
+  }
+
+  private fun checkSeen(node: LeakNode): Boolean {
+    return !visitedSet.add(node.instance!!)
+  }
+
+  private fun visitRootObj(node: LeakNode) {
+    val rootObj = node.instance as RootObj
+    val child = rootObj.referredInstance
+
+    if (rootObj.rootType == RootType.JAVA_LOCAL) {
+      val holder = rootObj.allocatingThread()
+      // We switch the parent node with the thread instance that holds
+      // the local reference.
+      var exclusion: Exclusion? = null
+      if (node.exclusion != null) {
+        exclusion = node.exclusion
+      }
+      val parent = LeakNode(null, holder, null, null)
+      enqueue(exclusion, parent, child, LeakReference(LOCAL, "", ""))
+    } else {
+      enqueue(null, node, child, null)
+    }
+  }
+
+  private fun visitClassObj(node: LeakNode) {
+    val classObj = node.instance as ClassObj?
+    val ignoredStaticFields = excludedRefs.staticFieldNameByClassName[classObj!!.className]
+    for ((field, value) in classObj.staticFieldValues) {
+      if (field.type != Type.OBJECT) {
+        continue
+      }
+      val fieldName = field.name
+      if (fieldName == "\$staticOverhead") {
+        continue
+      }
+      val child = value as Instance?
+      var visit = true
+      val fieldValue = value?.toString() ?: "null"
+      val leakReference = LeakReference(STATIC_FIELD, fieldName, fieldValue)
+      if (ignoredStaticFields != null) {
+        val params = ignoredStaticFields[fieldName]
+        if (params != null) {
+          visit = false
+          if (!params.alwaysExclude) {
+            enqueue(params, node, child, leakReference)
+          }
+        }
+      }
+      if (visit) {
+        enqueue(null, node, child, leakReference)
+      }
+    }
+  }
+
+  private fun visitClassInstance(node: LeakNode) {
+    val classInstance = node.instance as ClassInstance?
+    val ignoredFields = LinkedHashMap<String, Exclusion>()
+    var superClassObj: ClassObj? = classInstance!!.classObj
+    var classExclusion: Exclusion? = null
+    while (superClassObj != null) {
+      val params = excludedRefs.classNames[superClassObj.className]
+      if (params != null) {
+        // true overrides null or false.
+        if (classExclusion == null || !classExclusion.alwaysExclude) {
+          classExclusion = params
+        }
+      }
+      val classIgnoredFields = excludedRefs.fieldNameByClassName[superClassObj.className]
+      if (classIgnoredFields != null) {
+        ignoredFields.putAll(classIgnoredFields)
+      }
+      superClassObj = superClassObj.superClassObj
+    }
+
+    if (classExclusion != null && classExclusion.alwaysExclude) {
+      return
+    }
+
+    val values = classInstance.values
+    values.sortBy { it.field.name }
+    for (fieldValue in values) {
+      var fieldExclusion = classExclusion
+      val field = fieldValue.field
+      if (field.type != Type.OBJECT) {
+        continue
+      }
+      val child = fieldValue.value as Instance?
+      val fieldName = field.name
+      val params = ignoredFields[fieldName]
+      // If we found a field exclusion and it's stronger than a class exclusion
+      if (params != null && (fieldExclusion == null || params.alwaysExclude && !fieldExclusion.alwaysExclude)) {
+        fieldExclusion = params
+      }
+      val value = if (fieldValue.value == null) "null" else fieldValue.value.toString()
+      enqueue(
+          fieldExclusion, node, child,
+          LeakReference(INSTANCE_FIELD, fieldName, value)
+      )
+    }
+  }
+
+  private fun visitArrayInstance(node: LeakNode) {
+    val arrayInstance = node.instance as ArrayInstance
+    if (arrayInstance.arrayType == Type.OBJECT) {
+      val values = arrayInstance.values
+      for (i in values.indices) {
+        val child = values[i] as Instance?
+        val name = Integer.toString(i)
+        val value = child?.toString() ?: "null"
+        enqueue(null, node, child, LeakReference(ARRAY_ENTRY, name, value))
+      }
+    }
+  }
+
+  private fun enqueue(
+    exclusion: Exclusion?,
+    parent: LeakNode?,
+    child: Instance?,
+    leakReference: LeakReference?
+  ) {
+    if (child == null) {
+      return
+    }
+    if (isPrimitiveOrWrapperArray(child) || isPrimitiveWrapper(child)) {
+      return
+    }
+    if (ignoreStrings && isString(child)) {
+      return
+    }
+    // Whether we want to visit now or later, we should skip if this is already to visit.
+    if (toVisitSet.contains(child)) {
+      return
+    }
+    val visitNow = exclusion == null
+    if (!visitNow && toVisitIfNoPathSet.contains(child)) {
+      return
+    }
+    if (visitedSet.contains(child)) {
+      return
+    }
+    val childNode = LeakNode(exclusion, child, parent, leakReference)
+    if (visitNow) {
+      toVisitSet.add(child)
+      toVisitQueue.add(childNode)
+    } else {
+      toVisitIfNoPathSet.add(child)
+      toVisitIfNoPathQueue.add(childNode)
+    }
+  }
+
+  private fun isString(instance: Instance): Boolean {
+    return instance.classObj != null && instance.classObj
+        .className == String::class.java.name
+  }
+}
diff --git a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/AsyncTaskLeakTest.kt b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/AsyncTaskLeakTest.kt
new file mode 100644
index 00000000..649ba514
--- /dev/null
+++ b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/AsyncTaskLeakTest.kt
@@ -0,0 +1,100 @@
+package leakcanary.internal
+
+import leakcanary.ExcludedRefs
+import leakcanary.ExcludedRefs.BuilderWithParams
+import leakcanary.LeakTraceElement.Holder.THREAD
+import leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import leakcanary.internal.HeapDumpFile.ASYNC_TASK_M
+import leakcanary.internal.HeapDumpFile.ASYNC_TASK_O
+import leakcanary.internal.HeapDumpFile.ASYNC_TASK_PRE_M
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+import java.lang.ref.PhantomReference
+import java.lang.ref.WeakReference
+import java.util.Arrays
+
+@RunWith(Parameterized::class)
+internal class AsyncTaskLeakTest(private val heapDumpFile: HeapDumpFile) {
+
+  private lateinit var excludedRefs: BuilderWithParams
+
+  @Before
+  fun setUp() {
+    excludedRefs = ExcludedRefs.builder()
+        .clazz(WeakReference::class.java.name)
+        .alwaysExclude()
+        .clazz("java.lang.ref.FinalizerReference")
+        .alwaysExclude()
+        .clazz(PhantomReference::class.java.name)
+        .alwaysExclude()
+  }
+
+  @Test
+  fun leakFound() {
+    val result = analyze(heapDumpFile, excludedRefs)
+    assertThat(result.leakFound).isTrue()
+    assertThat(result.excludedLeak).isFalse()
+    val gcRoot = result.leakTrace!!.elements[0]
+    assertThat(Thread::class.java.name).isEqualTo(gcRoot.className)
+    assertThat(THREAD).isEqualTo(gcRoot.holder)
+  }
+
+  @Test
+  fun excludeThread() {
+    excludedRefs.thread(ASYNC_TASK_THREAD)
+    val result = analyze(heapDumpFile, excludedRefs)
+    assertThat(result.leakFound).isTrue()
+    assertThat(result.excludedLeak).isFalse()
+    val gcRoot = result.leakTrace!!.elements[0]
+    assertThat(ASYNC_TASK_CLASS).isEqualTo(gcRoot.className)
+    assertThat(STATIC_FIELD).isEqualTo(gcRoot.reference!!.type)
+    assertThat(
+        gcRoot.reference!!.name == EXECUTOR_FIELD_1 || gcRoot.reference!!.name == EXECUTOR_FIELD_2
+    ).isTrue()
+  }
+
+  @Test
+  fun excludeStatic() {
+    excludedRefs.thread(ASYNC_TASK_THREAD)
+        .named(ASYNC_TASK_THREAD)
+    excludedRefs.staticField(
+        ASYNC_TASK_CLASS,
+        EXECUTOR_FIELD_1
+    )
+        .named(EXECUTOR_FIELD_1)
+    excludedRefs.staticField(
+        ASYNC_TASK_CLASS,
+        EXECUTOR_FIELD_2
+    )
+        .named(EXECUTOR_FIELD_2)
+    val result = analyze(heapDumpFile, excludedRefs)
+    assertThat(result.leakFound).isTrue()
+    assertThat(result.excludedLeak).isTrue()
+    val elements = result.leakTrace!!.elements
+    val exclusion = elements[0].exclusion
+
+    val expectedExclusions = Arrays.asList(
+        ASYNC_TASK_THREAD,
+        EXECUTOR_FIELD_1,
+        EXECUTOR_FIELD_2
+    )
+    assertThat(expectedExclusions.contains(exclusion!!.name)).isTrue()
+  }
+
+  companion object {
+    private const val ASYNC_TASK_THREAD = "AsyncTask #1"
+    private const val ASYNC_TASK_CLASS = "android.os.AsyncTask"
+    private const val EXECUTOR_FIELD_1 = "SERIAL_EXECUTOR"
+    private const val EXECUTOR_FIELD_2 = "sDefaultExecutor"
+    @JvmStatic
+    @Parameterized.Parameters
+    fun data() = listOf(
+        arrayOf(ASYNC_TASK_PRE_M),
+        arrayOf(ASYNC_TASK_M),
+        arrayOf(ASYNC_TASK_O)
+    )
+  }
+}
diff --git a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/FakeDataBuffer.kt b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/FakeDataBuffer.kt
new file mode 100644
index 00000000..4ab531f2
--- /dev/null
+++ b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/FakeDataBuffer.kt
@@ -0,0 +1,94 @@
+package leakcanary.internal
+
+import com.android.tools.perflib.captures.DataBuffer
+import java.io.UnsupportedEncodingException
+
+class FakeDataBuffer(private val stringCharset: String = PRE_O_CHARSET) : DataBuffer {
+
+  private var intsToRead: IntArray? = null
+  private var intIndex = -1
+  private var stringsToRead: Array<out String?>? = null
+  private var stringIndex = -1
+
+  fun setIntsToRead(vararg ints: Int) {
+    intsToRead = ints
+    intIndex = 0
+  }
+
+  fun setStringsToRead(vararg strings: String?) {
+    stringsToRead = strings
+    stringIndex = 0
+  }
+
+  override fun readByte(): Byte {
+    throw UnsupportedOperationException("no bytes to read")
+  }
+
+  override fun dispose() {}
+
+  override fun read(bytes: ByteArray) {
+    throw UnsupportedOperationException("no bytes to read")
+  }
+
+  override fun readSubSequence(
+    bytes: ByteArray,
+    start: Int,
+    length: Int
+  ) {
+    if (stringsToRead == null || stringIndex < 0 || stringIndex >= stringsToRead!!.size) {
+      throw UnsupportedOperationException("no bytes to read")
+    }
+
+    val s = stringsToRead!![stringIndex++]
+    try {
+      System.arraycopy(s!!.toByteArray(charset(stringCharset)), start, bytes, 0, length)
+    } catch (e: UnsupportedEncodingException) {
+      throw UnsupportedOperationException(e)
+    }
+  }
+
+  override fun readChar(): Char {
+    throw UnsupportedOperationException("no bytes to read")
+  }
+
+  override fun readShort(): Short {
+    throw UnsupportedOperationException("no bytes to read")
+  }
+
+  override fun readInt(): Int {
+    if (intsToRead == null || intIndex < 0 || intIndex >= intsToRead!!.size) {
+      throw UnsupportedOperationException("no bytes to read")
+    }
+    return intsToRead!![intIndex++]
+  }
+
+  override fun readLong(): Long {
+    throw UnsupportedOperationException("no bytes to read")
+  }
+
+  override fun readFloat(): Float {
+    throw UnsupportedOperationException("no bytes to read")
+  }
+
+  override fun readDouble(): Double {
+    throw UnsupportedOperationException("no bytes to read")
+  }
+
+  override fun setPosition(l: Long) {}
+
+  override fun position(): Long {
+    throw UnsupportedOperationException("no bytes to read")
+  }
+
+  override fun hasRemaining(): Boolean {
+    throw UnsupportedOperationException("no bytes to read")
+  }
+
+  override fun remaining(): Long {
+    throw UnsupportedOperationException("no bytes to read")
+  }
+
+  companion object {
+    private val PRE_O_CHARSET = "UTF-16BE"
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/HahaHelperTest.kt b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/HahaHelperTest.kt
new file mode 100644
index 00000000..ae80e771
--- /dev/null
+++ b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/HahaHelperTest.kt
@@ -0,0 +1,182 @@
+package leakcanary.internal
+
+import com.android.tools.perflib.captures.DataBuffer
+import com.squareup.haha.perflib.ArrayInstance
+import com.squareup.haha.perflib.ClassInstance
+import com.squareup.haha.perflib.ClassObj
+import com.squareup.haha.perflib.Field
+import com.squareup.haha.perflib.Snapshot
+import com.squareup.haha.perflib.Type
+import leakcanary.internal.perflib.HahaHelper
+import org.junit.Assert.assertTrue
+import org.junit.Assert.fail
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.JUnit4
+
+@RunWith(JUnit4::class)
+class HahaHelperTest {
+
+  private lateinit var buffer: FakeDataBuffer
+  private lateinit var snapshot: Snapshot
+
+  @Before
+  fun setUp() {
+    buffer = FakeDataBuffer()
+    initSnapshot(buffer)
+  }
+
+  private fun initSnapshot(buffer: DataBuffer) {
+    snapshot = Snapshot(buffer)
+    // set HPROF identifier size; required for Object instance field lookups
+    // cf. https://java.net/downloads/heap-snapshot/hprof-binary-format.html
+    snapshot.setIdSize(4)
+  }
+
+  @Test fun readStringOffsetFromHeapDumpInstance_pre_O() {
+    buffer.setIntsToRead(
+        COUNT_VALUE,
+        OFFSET_VALUE,
+        VALUE_ARRAY_INSTANCE_ID
+    )
+    buffer.setStringsToRead("abcdef")
+
+    addStringClassToSnapshotWithFields(
+        snapshot,
+        arrayOf(Field(Type.INT, "count"), Field(Type.INT, "offset"), Field(Type.OBJECT, "value"))
+    )
+
+    val stringInstance = createStringInstance()
+    createCharArrayValueInstance()
+
+    val actual = HahaHelper.asString(stringInstance)
+    assertTrue(actual == "bcdef")
+  }
+
+  @Test fun defaultToZeroStringOffsetWhenHeapDumpInstanceIsMissingOffsetValue_pre_O() {
+    buffer.setIntsToRead(
+        COUNT_VALUE,
+        VALUE_ARRAY_INSTANCE_ID
+    )
+    buffer.setStringsToRead("abcdef")
+
+    addStringClassToSnapshotWithFields(
+        snapshot, arrayOf(Field(Type.INT, "count"), Field(Type.OBJECT, "value"))
+    )
+
+    val stringInstance = createStringInstance()
+    createCharArrayValueInstance()
+
+    val actual = HahaHelper.asString(stringInstance)
+    assertTrue(actual == "abcde")
+  }
+
+  @Test fun readStringAsByteArrayFromHeapDumpInstance_O() {
+    // O uses default charset UTF-8
+    buffer = FakeDataBuffer("UTF-8")
+    initSnapshot(buffer)
+
+    buffer.setIntsToRead(
+        COUNT_VALUE,
+        VALUE_ARRAY_INSTANCE_ID
+    )
+    buffer.setStringsToRead("abcdef")
+
+    addStringClassToSnapshotWithFields_O(
+        snapshot, arrayOf(Field(Type.INT, "count"), Field(Type.OBJECT, "value"))
+    )
+
+    val stringInstance = createStringInstance()
+    createByteArrayValueInstance()
+
+    val actual = HahaHelper.asString(stringInstance)
+    assertTrue(actual == "abcde")
+  }
+
+  @Test fun throwExceptionWhenNotArrayValueForString() {
+    buffer.setIntsToRead(
+        COUNT_VALUE,
+        OFFSET_VALUE,
+        VALUE_ARRAY_INSTANCE_ID
+    )
+    buffer.setStringsToRead("abcdef")
+
+    addStringClassToSnapshotWithFields(
+        snapshot,
+        arrayOf(Field(Type.INT, "count"), Field(Type.INT, "offset"), Field(Type.OBJECT, "value"))
+    )
+
+    val stringInstance = createStringInstance()
+    createObjectValueInstance()
+
+    try {
+      HahaHelper.asString(stringInstance)
+      fail("this test should have thrown UnsupportedOperationException")
+    } catch (uoe: UnsupportedOperationException) {
+      val message = uoe.message
+      assertTrue(message == "Could not find char array in $stringInstance")
+    }
+
+  }
+
+  private fun addStringClassToSnapshotWithFields(
+    snapshot: Snapshot,
+    fields: Array<Field>
+  ) {
+    val charArrayClass = ClassObj(0, null, "char[]", 0)
+    snapshot.addClass(CHAR_ARRAY_CLASS_ID.toLong(), charArrayClass)
+
+    val stringClass = ClassObj(0, null, "string", 0)
+    stringClass.fields = fields
+    snapshot.addClass(STRING_CLASS_ID.toLong(), stringClass)
+  }
+
+  private fun addStringClassToSnapshotWithFields_O(
+    snapshot: Snapshot,
+    fields: Array<Field>
+  ) {
+    val byteArrayClass = ClassObj(0, null, "byte[]", 0)
+    snapshot.addClass(BYTE_ARRAY_CLASS_ID.toLong(), byteArrayClass)
+
+    val stringClass = ClassObj(0, null, "string", 0)
+    stringClass.fields = fields
+    snapshot.addClass(STRING_CLASS_ID.toLong(), stringClass)
+  }
+
+  private fun createCharArrayValueInstance() {
+    val valueArrayInstance = ArrayInstance(0, null, Type.CHAR,
+        VALUE_ARRAY_LENGTH, 0)
+    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID.toLong(), valueArrayInstance)
+  }
+
+  private fun createByteArrayValueInstance() {
+    val valueArrayInstance = ArrayInstance(0, null, Type.BYTE,
+        VALUE_ARRAY_LENGTH, 0)
+    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID.toLong(), valueArrayInstance)
+  }
+
+  private fun createObjectValueInstance() {
+    val valueInstance = ClassInstance(0, null, 0)
+    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID.toLong(), valueInstance)
+  }
+
+  private fun createStringInstance(): ClassInstance {
+    val stringInstance = ClassInstance(
+        STRING_INSTANCE_ID.toLong(), null, 100)
+    stringInstance.setClassId(STRING_CLASS_ID.toLong())
+    snapshot.addInstance(0, stringInstance)
+    return stringInstance
+  }
+
+  companion object {
+    private const val STRING_CLASS_ID = 100
+    private const val CHAR_ARRAY_CLASS_ID = 101
+    private const val STRING_INSTANCE_ID = 102
+    private const val VALUE_ARRAY_INSTANCE_ID = 103
+    private const val BYTE_ARRAY_CLASS_ID = 104
+    private const val VALUE_ARRAY_LENGTH = 6
+    private const val COUNT_VALUE = 5
+    private const val OFFSET_VALUE = 1
+  }
+}
diff --git a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/HeapAnalyzerPerflibHeapDumpTest.kt b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/HeapAnalyzerPerflibHeapDumpTest.kt
new file mode 100644
index 00000000..b63cf766
--- /dev/null
+++ b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/HeapAnalyzerPerflibHeapDumpTest.kt
@@ -0,0 +1,45 @@
+package leakcanary.internal
+
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.LeakingInstance
+import leakcanary.internal.HeapDumpFile.ASYNC_TASK_P
+import leakcanary.internal.HeapDumpFile.GC_ROOT_IN_NON_PRIMARY_HEAP
+import leakcanary.internal.HeapDumpFile.MISSING_THREAD
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Ignore
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.JUnit4
+
+@RunWith(JUnit4::class)
+class HeapAnalyzerPerflibHeapDumpTest {
+
+  @Test @Ignore("Need new heapdump with className in KeyedWeakReference")
+  fun findsExpectedRef() {
+    val retainedInstance = findLeak(ASYNC_TASK_P)!!
+    assertThat(retainedInstance).isInstanceOf(LeakingInstance::class.java)
+    val leak = retainedInstance as LeakingInstance
+    assertThat(leak.excludedLeak).isFalse()
+    assertThat(leak.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
+  }
+
+  @Test @Ignore("Need new heapdump with className in KeyedWeakReference")
+  fun findsSeveralRefs() {
+    val heapAnalysis = findAllLeaks(ASYNC_TASK_P)
+    assertThat(heapAnalysis).isInstanceOf(HeapAnalysisSuccess::class.java)
+    val results = heapAnalysis as HeapAnalysisSuccess
+    assertThat(results.retainedInstances).hasSize(3)
+  }
+
+  @Test
+  fun leakFoundWithGcRootInNonPrimaryHeap() {
+    val result = analyze(GC_ROOT_IN_NON_PRIMARY_HEAP)
+    assertThat(result.leakFound).isTrue()
+  }
+
+  @Test
+  fun heapDumpWithMissingNativeThread() {
+    val result = analyze(MISSING_THREAD)
+    assertThat(result.leakFound).isTrue()
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/PerflibHeapAnalyzerTest.kt b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/PerflibHeapAnalyzerTest.kt
new file mode 100644
index 00000000..62d5a85e
--- /dev/null
+++ b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/PerflibHeapAnalyzerTest.kt
@@ -0,0 +1,56 @@
+package leakcanary.internal
+
+import com.squareup.haha.perflib.RootObj
+import com.squareup.haha.perflib.RootType.NATIVE_STATIC
+import com.squareup.haha.perflib.RootType.SYSTEM_CLASS
+import com.squareup.haha.perflib.Snapshot
+import leakcanary.AnalyzerProgressListener
+import leakcanary.internal.perflib.PerflibHeapAnalyzer
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.JUnit4
+import java.util.Arrays.asList
+
+@RunWith(JUnit4::class)
+class PerflibHeapAnalyzerTest {
+
+  private val heapAnalyzer = PerflibHeapAnalyzer(AnalyzerProgressListener.NONE)
+
+  @Test
+  fun ensureUniqueRoots() {
+    val snapshot = createSnapshot(DUP_ROOTS)
+
+    heapAnalyzer.deduplicateGcRoots(snapshot)
+
+    val uniqueRoots = snapshot.gcRoots
+    assertThat(uniqueRoots).hasSize(4)
+
+    val rootIds = mutableListOf<Long>()
+    uniqueRoots.forEach { root ->
+      rootIds.add(root.id)
+    }
+    rootIds.sort()
+
+    // 3 appears twice because even though two RootObjs have the same id, they're different types.
+    assertThat(rootIds).containsExactly(3L, 3L, 5L, 6L)
+  }
+
+  private fun createSnapshot(gcRoots: List<RootObj>): Snapshot {
+    val snapshot = Snapshot(null)
+    for (root in gcRoots) {
+      snapshot.addRoot(root)
+    }
+    return snapshot
+  }
+
+  companion object {
+    private val DUP_ROOTS = asList<RootObj>(
+        RootObj(SYSTEM_CLASS, 6L),
+        RootObj(SYSTEM_CLASS, 5L),
+        RootObj(SYSTEM_CLASS, 3L),
+        RootObj(SYSTEM_CLASS, 5L),
+        RootObj(NATIVE_STATIC, 3L)
+    )
+  }
+}
diff --git a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/RetainedSizeTest.kt b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/RetainedSizeTest.kt
new file mode 100644
index 00000000..41a6f443
--- /dev/null
+++ b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/RetainedSizeTest.kt
@@ -0,0 +1,35 @@
+package leakcanary.internal
+
+import leakcanary.internal.HeapDumpFile.ASYNC_TASK_M
+import leakcanary.internal.HeapDumpFile.ASYNC_TASK_O
+import leakcanary.internal.HeapDumpFile.ASYNC_TASK_PRE_M
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+
+/**
+ * This test makes sure there is no regression on the retained size calculation.
+ */
+@RunWith(Parameterized::class)
+internal class RetainedSizeTest(
+  val heapDumpFile: HeapDumpFile,
+  val expectedRetainedHeapSize: Long
+) {
+
+  @Test
+  fun leakFound() {
+    val result = analyze(heapDumpFile)
+    assertThat(result.retainedHeapSize).isEqualTo(expectedRetainedHeapSize)
+  }
+
+  companion object {
+    @JvmStatic
+    @Parameterized.Parameters
+    fun data() = listOf(
+        arrayOf(ASYNC_TASK_PRE_M, 33367),
+        arrayOf(ASYNC_TASK_M, 49584),
+        arrayOf(ASYNC_TASK_O, 210978)
+    )
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/TestUtil.kt b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/TestUtil.kt
new file mode 100644
index 00000000..cb3b4c30
--- /dev/null
+++ b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/TestUtil.kt
@@ -0,0 +1,125 @@
+package leakcanary.internal
+
+import leakcanary.AnalysisResult
+import leakcanary.AnalyzerProgressListener
+import leakcanary.ExcludedRefs
+import leakcanary.ExcludedRefs.BuilderWithParams
+import leakcanary.HeapAnalysis
+import leakcanary.HeapAnalysisFailure
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.internal.perflib.PerflibHeapAnalyzer
+import leakcanary.HeapDump
+import leakcanary.LeakingInstance
+import leakcanary.RetainedInstance
+import java.io.File
+import java.lang.ref.PhantomReference
+import java.lang.ref.SoftReference
+import java.lang.ref.WeakReference
+
+internal val NO_EXCLUDED_REFS = ExcludedRefs.builder()
+    .build()
+
+const val OLD_KEYED_WEAK_REFERENCE_CLASS_NAME = "com.squareup.leakcanary.KeyedWeakReference"
+const val OLD_HEAP_DUMP_MEMORY_STORE_CLASS_NAME = "com.squareup.leakcanary.HeapDumpMemoryStore"
+
+internal enum class HeapDumpFile constructor(
+  val filename: String,
+  val referenceKey: String
+) {
+  ASYNC_TASK_PRE_M("leak_asynctask_pre_m.hprof", "dc983a12-d029-4003-8890-7dd644c664c5"), //
+  ASYNC_TASK_M("leak_asynctask_m.hprof", "25ae1778-7c1d-4ec7-ac50-5cce55424069"), //
+  ASYNC_TASK_O("leak_asynctask_o.hprof", "0e8d40d7-8302-4493-93d5-962a4c176089"),
+  ASYNC_TASK_P("leak_asynctask_p.hprof", "440d4252-8089-41bd-98b2-d7d050323279"),
+  GC_ROOT_IN_NON_PRIMARY_HEAP(
+      "gc_root_in_non_primary_heap.hprof",
+      "10a5bc66-e9cb-430c-930a-fc1dc4fc0f85"
+  ),
+  MISSING_THREAD("missing_thread.hprof", "c644e537-9abd-42e5-994d-032fc150feef")
+}
+
+internal fun fileFromName(filename: String): File {
+  val classLoader = Thread.currentThread()
+      .contextClassLoader
+  val url = classLoader.getResource(filename)
+  return File(url.path)
+}
+
+internal fun findLeak(heapDumpFile: HeapDumpFile): RetainedInstance? {
+  val heapAnalysis = findAllLeaks(heapDumpFile)
+  if (heapAnalysis is HeapAnalysisSuccess) {
+    heapAnalysis.retainedInstances.forEach { retainedInstance ->
+      if (retainedInstance.referenceKey == heapDumpFile.referenceKey) {
+        return retainedInstance
+      }
+    }
+  }
+  return null
+}
+
+internal fun findAllLeaks(heapDumpFile: HeapDumpFile): HeapAnalysis {
+  val file = fileFromName(heapDumpFile.filename)
+  val heapAnalyzer = PerflibHeapAnalyzer(
+      AnalyzerProgressListener.NONE,
+      OLD_KEYED_WEAK_REFERENCE_CLASS_NAME,
+      OLD_HEAP_DUMP_MEMORY_STORE_CLASS_NAME
+  )
+  val heapAnalysis =
+    heapAnalyzer.checkForLeaks(
+        HeapDump.builder(file).excludedRefs(defaultExcludedRefs.build()).computeRetainedHeapSize(
+            true
+        ).build()
+    )
+
+  when (heapAnalysis) {
+    is HeapAnalysisFailure -> heapAnalysis.exception.printStackTrace()
+    is HeapAnalysisSuccess -> {
+      heapAnalysis.retainedInstances.forEach { retainedInstance ->
+        if (retainedInstance is LeakingInstance) {
+          println(retainedInstance.leakTrace)
+        }
+      }
+    }
+  }
+  return heapAnalysis
+}
+
+internal fun analyze(
+  heapDumpFile: HeapDumpFile,
+  excludedRefs: BuilderWithParams = defaultExcludedRefs
+): AnalysisResult {
+  val file = fileFromName(heapDumpFile.filename)
+  val referenceKey = heapDumpFile.referenceKey
+  val heapAnalyzer =
+    PerflibHeapAnalyzer(
+        AnalyzerProgressListener.NONE, OLD_KEYED_WEAK_REFERENCE_CLASS_NAME,
+        OLD_HEAP_DUMP_MEMORY_STORE_CLASS_NAME
+    )
+  val heapDump = HeapDump.builder(file)
+      .computeRetainedHeapSize(true)
+      .excludedRefs(
+          excludedRefs.build()
+      )
+      .build()
+  val result = heapAnalyzer.checkForLeak(heapDump, referenceKey)
+  result.failure?.printStackTrace()
+  if (result.leakTrace != null) {
+    System.out.println(result.leakTrace)
+  }
+  return result
+}
+
+private val defaultExcludedRefs = ExcludedRefs.builder()
+    .clazz(WeakReference::class.java.name)
+    .alwaysExclude()
+    .clazz(SoftReference::class.java.name)
+    .alwaysExclude()
+    .clazz(PhantomReference::class.java.name)
+    .alwaysExclude()
+    .clazz("java.lang.ref.Finalizer")
+    .alwaysExclude()
+    .clazz("java.lang.ref.FinalizerReference")
+    .alwaysExclude()
+    .thread("FinalizerWatchdogDaemon")
+    .alwaysExclude()
+    .thread("main")
+    .alwaysExclude()
diff --git a/leakcanary-analyzer-perflib/src/test/resources/gc_root_in_non_primary_heap.hprof b/leakcanary-analyzer-perflib/src/test/resources/gc_root_in_non_primary_heap.hprof
new file mode 100644
index 00000000..7ca6d0bc
Binary files /dev/null and b/leakcanary-analyzer-perflib/src/test/resources/gc_root_in_non_primary_heap.hprof differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_m_postpreview2.hprof b/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_m.hprof
similarity index 100%
rename from leakcanary-analyzer/src/test/resources/leak_asynctask_m_postpreview2.hprof
rename to leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_m.hprof
diff --git a/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_o.hprof b/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_o.hprof
new file mode 100644
index 00000000..1c62d0e5
Binary files /dev/null and b/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_o.hprof differ
diff --git a/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_p.hprof b/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_p.hprof
new file mode 100644
index 00000000..651827f5
Binary files /dev/null and b/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_p.hprof differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask.hprof b/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_pre_m.hprof
similarity index 100%
rename from leakcanary-analyzer/src/test/resources/leak_asynctask.hprof
rename to leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_pre_m.hprof
diff --git a/leakcanary-analyzer-perflib/src/test/resources/missing_thread.hprof b/leakcanary-analyzer-perflib/src/test/resources/missing_thread.hprof
new file mode 100644
index 00000000..4f37b45f
Binary files /dev/null and b/leakcanary-analyzer-perflib/src/test/resources/missing_thread.hprof differ
diff --git a/leakcanary-analyzer/build.gradle b/leakcanary-analyzer/build.gradle
index 461f504b..c121540f 100644
--- a/leakcanary-analyzer/build.gradle
+++ b/leakcanary-analyzer/build.gradle
@@ -1,51 +1,19 @@
-version rootProject.ext.VERSION_NAME
-group rootProject.ext.GROUP
+apply plugin: 'java-library'
+apply plugin: 'kotlin'
 
-buildscript {
-  repositories {
-    mavenCentral()
-  }
-}
-
-apply plugin: 'com.android.library'
-
-repositories {
-  mavenCentral()
-}
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
 
 dependencies {
-  compile 'com.squareup.haha:haha:2.0.3'
-  compile project(':leakcanary-watcher')
-  testCompile 'junit:junit:4.12'
-  testCompile 'org.assertj:assertj-core:1.7.0'
-}
-
-android.libraryVariants.all { variant ->
-  def name = variant.buildType.name
-  if (name.equals(com.android.builder.core.BuilderConstants.DEBUG)) {
-    return; // Skip debug builds.
-  }
-  def task = project.tasks.create "jar${name.capitalize()}", Jar
-  task.dependsOn variant.javaCompile
-  task.from variant.javaCompile.destinationDir
-  artifacts.add('archives', task);
-}
+  api project(':leakcanary-analyzer-core')
+  api project(':leakcanary-haha')
 
-android {
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
-  defaultConfig {
-    minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.targetSdkVersion
-  }
-  lintOptions {
-    disable 'GoogleAppIndexingWarning'
-  }
-}
+  implementation deps.androidx.annotation
+  implementation deps.kotlin.stdlib
 
-task sourceJar(type: Jar) {
-  from 'src/main/java'
+  testImplementation deps.assertj_core
+  testImplementation deps.junit
 }
 
 apply from: rootProject.file('gradle/checkstyle.gradle')
-apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/leakcanary-analyzer/gradle.properties b/leakcanary-analyzer/gradle.properties
index 9ef04082..ed79fc10 100644
--- a/leakcanary-analyzer/gradle.properties
+++ b/leakcanary-analyzer/gradle.properties
@@ -1,3 +1,3 @@
 POM_ARTIFACT_ID=leakcanary-analyzer
 POM_NAME=LeakCanary Analyzer
-POM_PACKAGING=jar
\ No newline at end of file
+POM_PACKAGING=jar
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
deleted file mode 100644
index 4c8270c1..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.Serializable;
-
-public final class AnalysisResult implements Serializable {
-
-  public static AnalysisResult noLeak(long analysisDurationMs) {
-    return new AnalysisResult(false, false, null, null, null, 0, analysisDurationMs);
-  }
-
-  public static AnalysisResult leakDetected(boolean excludedLeak, String className,
-      LeakTrace leakTrace, long retainedHeapSize, long analysisDurationMs) {
-    return new AnalysisResult(true, excludedLeak, className, leakTrace, null, retainedHeapSize,
-        analysisDurationMs);
-  }
-
-  public static AnalysisResult failure(Throwable failure, long analysisDurationMs) {
-    return new AnalysisResult(false, false, null, null, failure, 0, analysisDurationMs);
-  }
-
-  /** True if a leak was found in the heap dump. */
-  public final boolean leakFound;
-
-  /**
-   * True if {@link #leakFound} is true and the only path to the leaking reference is
-   * through excluded references. Usually, that means you can safely ignore this report.
-   */
-  public final boolean excludedLeak;
-
-  /**
-   * Class name of the object that leaked if {@link #leakFound} is true, null otherwise.
-   * The class name format is the same as what would be returned by {@link Class#getName()}.
-   */
-  public final String className;
-
-  /**
-   * Shortest path to GC roots for the leaking object if {@link #leakFound} is true, null
-   * otherwise. This can be used as a unique signature for the leak.
-   */
-  public final LeakTrace leakTrace;
-
-  /** Null unless the analysis failed. */
-  public final Throwable failure;
-
-  /**
-   * The number of bytes which would be freed if all references to the leaking object were
-   * released. 0 if {@link #leakFound} is false.
-   */
-  public final long retainedHeapSize;
-
-  /** Total time spent analyzing the heap. */
-  public final long analysisDurationMs;
-
-  private AnalysisResult(boolean leakFound, boolean excludedLeak, String className,
-      LeakTrace leakTrace, Throwable failure, long retainedHeapSize, long analysisDurationMs) {
-    this.leakFound = leakFound;
-    this.excludedLeak = excludedLeak;
-    this.className = className;
-    this.leakTrace = leakTrace;
-    this.failure = failure;
-    this.retainedHeapSize = retainedHeapSize;
-    this.analysisDurationMs = analysisDurationMs;
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
deleted file mode 100644
index fe01cd23..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.ArrayInstance;
-import com.squareup.haha.perflib.ClassInstance;
-import com.squareup.haha.perflib.ClassObj;
-import com.squareup.haha.perflib.Field;
-import com.squareup.haha.perflib.Heap;
-import com.squareup.haha.perflib.Instance;
-import com.squareup.haha.perflib.Type;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-import static java.util.Arrays.asList;
-
-public final class HahaHelper {
-
-  private static final Set<String> WRAPPER_TYPES = new HashSet<>(
-      asList(Boolean.class.getName(), Character.class.getName(), Float.class.getName(),
-          Double.class.getName(), Byte.class.getName(), Short.class.getName(),
-          Integer.class.getName(), Long.class.getName()));
-
-  static String fieldToString(Map.Entry<Field, Object> entry) {
-    return fieldToString(entry.getKey(), entry.getValue());
-  }
-
-  static String fieldToString(ClassInstance.FieldValue fieldValue) {
-    return fieldToString(fieldValue.getField(), fieldValue.getValue());
-  }
-
-  static String fieldToString(Field field, Object value) {
-    return field.getName() + " = " + value;
-  }
-
-  static String threadName(Instance holder) {
-    List<ClassInstance.FieldValue> values = classInstanceValues(holder);
-    Object nameField = fieldValue(values, "name");
-    if (nameField == null) {
-      // Sometimes we can't find the String at the expected memory address in the heap dump.
-      // See https://github.com/square/leakcanary/issues/417 .
-      return "Thread name not available";
-    }
-    return asString(nameField);
-  }
-
-  static boolean extendsThread(ClassObj clazz) {
-    boolean extendsThread = false;
-    ClassObj parentClass = clazz;
-    while (parentClass.getSuperClassObj() != null) {
-      if (clazz.getClassName().equals(Thread.class.getName())) {
-        extendsThread = true;
-        break;
-      }
-      parentClass = parentClass.getSuperClassObj();
-    }
-    return extendsThread;
-  }
-
-  static String asString(Object stringObject) {
-    Instance instance = (Instance) stringObject;
-    List<ClassInstance.FieldValue> values = classInstanceValues(instance);
-
-    Integer count = fieldValue(values, "count");
-    Object value = fieldValue(values, "value");
-    Integer offset;
-    ArrayInstance charArray;
-    if (isCharArray(value)) {
-      charArray = (ArrayInstance) value;
-      offset = 0;
-      // < API 23
-      // As of Marshmallow, substrings no longer share their parent strings' char arrays
-      // eliminating the need for String.offset
-      // https://android-review.googlesource.com/#/c/83611/
-      if (hasField(values, "offset")) {
-        offset = fieldValue(values, "offset");
-      }
-    } else {
-      // In M preview 2, the underlying char buffer resides in the heap with ID equaling the
-      // String's ID + 16.
-      // https://android-review.googlesource.com/#/c/160380/2/android/src/com/android/tools/idea/
-      // editors/hprof/descriptors/InstanceFieldDescriptorImpl.java
-      // This workaround is only needed for M preview 2, as it has been fixed on the hprof
-      // generation end by reintroducing a virtual "value" variable.
-      // https://android.googlesource.com/platform/art/+/master/runtime/hprof/hprof.cc#1242
-      Heap heap = instance.getHeap();
-      Instance inlineInstance = heap.getInstance(instance.getId() + 16);
-      if (isCharArray(inlineInstance)) {
-        charArray = (ArrayInstance) inlineInstance;
-        offset = 0;
-      } else {
-        throw new UnsupportedOperationException("Could not find char array in " + instance);
-      }
-    }
-    checkNotNull(count, "count");
-    checkNotNull(charArray, "charArray");
-    checkNotNull(offset, "offset");
-
-    if (count == 0) {
-      return "";
-    }
-
-    char[] chars = charArray.asCharArray(offset, count);
-
-    return new String(chars);
-  }
-
-  public static boolean isPrimitiveWrapper(Object value) {
-    if (!(value instanceof ClassInstance)) {
-      return false;
-    }
-    return WRAPPER_TYPES.contains(((ClassInstance) value).getClassObj().getClassName());
-  }
-
-  public static boolean isPrimitiveOrWrapperArray(Object value) {
-    if (!(value instanceof ArrayInstance)) {
-      return false;
-    }
-    ArrayInstance arrayInstance = (ArrayInstance) value;
-    if (arrayInstance.getArrayType() != Type.OBJECT) {
-      return true;
-    }
-    return WRAPPER_TYPES.contains(arrayInstance.getClassObj().getClassName());
-  }
-
-  private static boolean isCharArray(Object value) {
-    return value instanceof ArrayInstance && ((ArrayInstance) value).getArrayType() == Type.CHAR;
-  }
-
-  static List<ClassInstance.FieldValue> classInstanceValues(Instance instance) {
-    ClassInstance classInstance = (ClassInstance) instance;
-    return classInstance.getValues();
-  }
-
-  static <T> T fieldValue(List<ClassInstance.FieldValue> values, String fieldName) {
-    for (ClassInstance.FieldValue fieldValue : values) {
-      if (fieldValue.getField().getName().equals(fieldName)) {
-        //noinspection unchecked
-        return (T) fieldValue.getValue();
-      }
-    }
-    throw new IllegalArgumentException("Field " + fieldName + " does not exists");
-  }
-
-  static boolean hasField(List<ClassInstance.FieldValue> values, String fieldName) {
-    for (ClassInstance.FieldValue fieldValue : values) {
-      if (fieldValue.getField().getName().equals(fieldName)) {
-        //noinspection unchecked
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private HahaHelper() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
deleted file mode 100644
index 3b1effb6..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ /dev/null
@@ -1,322 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.ArrayInstance;
-import com.squareup.haha.perflib.ClassInstance;
-import com.squareup.haha.perflib.ClassObj;
-import com.squareup.haha.perflib.Field;
-import com.squareup.haha.perflib.HprofParser;
-import com.squareup.haha.perflib.Instance;
-import com.squareup.haha.perflib.RootObj;
-import com.squareup.haha.perflib.RootType;
-import com.squareup.haha.perflib.Snapshot;
-import com.squareup.haha.perflib.Type;
-import com.squareup.haha.perflib.io.HprofBuffer;
-import com.squareup.haha.perflib.io.MemoryMappedFileBuffer;
-import com.squareup.haha.trove.THashMap;
-import com.squareup.haha.trove.TObjectProcedure;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-
-import static com.squareup.leakcanary.AnalysisResult.failure;
-import static com.squareup.leakcanary.AnalysisResult.leakDetected;
-import static com.squareup.leakcanary.AnalysisResult.noLeak;
-import static com.squareup.leakcanary.HahaHelper.asString;
-import static com.squareup.leakcanary.HahaHelper.classInstanceValues;
-import static com.squareup.leakcanary.HahaHelper.extendsThread;
-import static com.squareup.leakcanary.HahaHelper.fieldToString;
-import static com.squareup.leakcanary.HahaHelper.fieldValue;
-import static com.squareup.leakcanary.HahaHelper.threadName;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.OBJECT;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-
-/**
- * Analyzes heap dumps generated by a {@link RefWatcher} to verify if suspected leaks are real.
- */
-public final class HeapAnalyzer {
-
-  private static final String ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$";
-
-  private final ExcludedRefs excludedRefs;
-
-  public HeapAnalyzer(ExcludedRefs excludedRefs) {
-    this.excludedRefs = excludedRefs;
-  }
-
-  /**
-   * Searches the heap dump for a {@link KeyedWeakReference} instance with the corresponding key,
-   * and then computes the shortest strong reference path from that instance to the GC roots.
-   */
-  public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
-    long analysisStartNanoTime = System.nanoTime();
-
-    if (!heapDumpFile.exists()) {
-      Exception exception = new IllegalArgumentException("File does not exist: " + heapDumpFile);
-      return failure(exception, since(analysisStartNanoTime));
-    }
-
-    try {
-      HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
-      HprofParser parser = new HprofParser(buffer);
-      Snapshot snapshot = parser.parse();
-      deduplicateGcRoots(snapshot);
-
-      Instance leakingRef = findLeakingReference(referenceKey, snapshot);
-
-      // False alarm, weak reference was cleared in between key check and heap dump.
-      if (leakingRef == null) {
-        return noLeak(since(analysisStartNanoTime));
-      }
-
-      return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);
-    } catch (Throwable e) {
-      return failure(e, since(analysisStartNanoTime));
-    }
-  }
-
-  /**
-   * Pruning duplicates reduces memory pressure from hprof bloat added in Marshmallow.
-   */
-  void deduplicateGcRoots(Snapshot snapshot) {
-    // THashMap has a smaller memory footprint than HashMap.
-    final THashMap<String, RootObj> uniqueRootMap = new THashMap<>();
-
-    final List<RootObj> gcRoots = (ArrayList) snapshot.getGCRoots();
-    for (RootObj root : gcRoots) {
-      String key = generateRootKey(root);
-      if (!uniqueRootMap.containsKey(key)) {
-        uniqueRootMap.put(key, root);
-      }
-    }
-
-    // Repopulate snapshot with unique GC roots.
-    gcRoots.clear();
-    uniqueRootMap.forEach(new TObjectProcedure<String>() {
-      @Override
-      public boolean execute(String key) {
-        return gcRoots.add(uniqueRootMap.get(key));
-      }
-    });
-  }
-
-  private String generateRootKey(RootObj root) {
-    return String.format("%s@0x%08x", root.getRootType().getName(), root.getId());
-  }
-
-  private Instance findLeakingReference(String key, Snapshot snapshot) {
-    ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());
-    List<String> keysFound = new ArrayList<>();
-    for (Instance instance : refClass.getInstancesList()) {
-      List<ClassInstance.FieldValue> values = classInstanceValues(instance);
-      String keyCandidate = asString(fieldValue(values, "key"));
-      if (keyCandidate.equals(key)) {
-        return fieldValue(values, "referent");
-      }
-      keysFound.add(keyCandidate);
-    }
-    throw new IllegalStateException(
-        "Could not find weak reference with key " + key + " in " + keysFound);
-  }
-
-  private AnalysisResult findLeakTrace(long analysisStartNanoTime, Snapshot snapshot,
-      Instance leakingRef) {
-
-    ShortestPathFinder pathFinder = new ShortestPathFinder(excludedRefs);
-    ShortestPathFinder.Result result = pathFinder.findPath(snapshot, leakingRef);
-
-    // False alarm, no strong reference path to GC Roots.
-    if (result.leakingNode == null) {
-      return noLeak(since(analysisStartNanoTime));
-    }
-
-    LeakTrace leakTrace = buildLeakTrace(result.leakingNode);
-
-    String className = leakingRef.getClassObj().getClassName();
-
-    // Side effect: computes retained size.
-    snapshot.computeDominators();
-
-    Instance leakingInstance = result.leakingNode.instance;
-
-    long retainedSize = leakingInstance.getTotalRetainedSize();
-
-    retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance);
-
-    return leakDetected(result.excludingKnownLeaks, className, leakTrace, retainedSize,
-        since(analysisStartNanoTime));
-  }
-
-  /**
-   * Bitmaps and bitmap byte arrays are sometimes held by native gc roots, so they aren't included
-   * in the retained size because their root dominator is a native gc root.
-   * To fix this, we check if the leaking instance is a dominator for each bitmap instance and then
-   * add the bitmap size.
-   *
-   * From experience, we've found that bitmap created in code (Bitmap.createBitmap()) are correctly
-   * accounted for, however bitmaps set in layouts are not.
-   */
-  private int computeIgnoredBitmapRetainedSize(Snapshot snapshot, Instance leakingInstance) {
-    int bitmapRetainedSize = 0;
-    ClassObj bitmapClass = snapshot.findClass("android.graphics.Bitmap");
-
-    for (Instance bitmapInstance : bitmapClass.getInstancesList()) {
-      if (isIgnoredDominator(leakingInstance, bitmapInstance)) {
-        ArrayInstance mBufferInstance = fieldValue(classInstanceValues(bitmapInstance), "mBuffer");
-        // Native bitmaps have mBuffer set to null. We sadly can't account for them.
-        if (mBufferInstance == null) {
-          continue;
-        }
-        long bufferSize = mBufferInstance.getTotalRetainedSize();
-        long bitmapSize = bitmapInstance.getTotalRetainedSize();
-        // Sometimes the size of the buffer isn't accounted for in the bitmap retained size. Since
-        // the buffer is large, it's easy to detect by checking for bitmap size < buffer size.
-        if (bitmapSize < bufferSize) {
-          bitmapSize += bufferSize;
-        }
-        bitmapRetainedSize += bitmapSize;
-      }
-    }
-    return bitmapRetainedSize;
-  }
-
-  private boolean isIgnoredDominator(Instance dominator, Instance instance) {
-    boolean foundNativeRoot = false;
-    while (true) {
-      Instance immediateDominator = instance.getImmediateDominator();
-      if (immediateDominator instanceof RootObj
-          && ((RootObj) immediateDominator).getRootType() == RootType.UNKNOWN) {
-        // Ignore native roots
-        instance = instance.getNextInstanceToGcRoot();
-        foundNativeRoot = true;
-      } else {
-        instance = immediateDominator;
-      }
-      if (instance == null) {
-        return false;
-      }
-      if (instance == dominator) {
-        return foundNativeRoot;
-      }
-    }
-  }
-
-  private LeakTrace buildLeakTrace(LeakNode leakingNode) {
-    List<LeakTraceElement> elements = new ArrayList<>();
-    // We iterate from the leak to the GC root
-    LeakNode node = new LeakNode(null, null, leakingNode, null, null);
-    while (node != null) {
-      LeakTraceElement element = buildLeakElement(node);
-      if (element != null) {
-        elements.add(0, element);
-      }
-      node = node.parent;
-    }
-    return new LeakTrace(elements);
-  }
-
-  private LeakTraceElement buildLeakElement(LeakNode node) {
-    if (node.parent == null) {
-      // Ignore any root node.
-      return null;
-    }
-    Instance holder = node.parent.instance;
-
-    if (holder instanceof RootObj) {
-      return null;
-    }
-    LeakTraceElement.Type type = node.referenceType;
-    String referenceName = node.referenceName;
-
-    LeakTraceElement.Holder holderType;
-    String className;
-    String extra = null;
-    List<String> fields = new ArrayList<>();
-    if (holder instanceof ClassObj) {
-      ClassObj classObj = (ClassObj) holder;
-      holderType = CLASS;
-      className = classObj.getClassName();
-      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-        Field field = entry.getKey();
-        Object value = entry.getValue();
-        fields.add("static " + field.getName() + " = " + value);
-      }
-    } else if (holder instanceof ArrayInstance) {
-      ArrayInstance arrayInstance = (ArrayInstance) holder;
-      holderType = ARRAY;
-      className = arrayInstance.getClassObj().getClassName();
-      if (arrayInstance.getArrayType() == Type.OBJECT) {
-        Object[] values = arrayInstance.getValues();
-        for (int i = 0; i < values.length; i++) {
-          fields.add("[" + i + "] = " + values[i]);
-        }
-      }
-    } else {
-      ClassInstance classInstance = (ClassInstance) holder;
-      ClassObj classObj = holder.getClassObj();
-      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-        fields.add("static " + fieldToString(entry));
-      }
-      for (ClassInstance.FieldValue field : classInstance.getValues()) {
-        fields.add(fieldToString(field));
-      }
-      className = classObj.getClassName();
-
-      if (extendsThread(classObj)) {
-        holderType = THREAD;
-        String threadName = threadName(holder);
-        extra = "(named '" + threadName + "')";
-      } else if (className.matches(ANONYMOUS_CLASS_NAME_PATTERN)) {
-        String parentClassName = classObj.getSuperClassObj().getClassName();
-        if (Object.class.getName().equals(parentClassName)) {
-          holderType = OBJECT;
-          try {
-            // This is an anonymous class implementing an interface. The API does not give access
-            // to the interfaces implemented by the class. We check if it's in the class path and
-            // use that instead.
-            Class<?> actualClass = Class.forName(classObj.getClassName());
-            Class<?>[] interfaces = actualClass.getInterfaces();
-            if (interfaces.length > 0) {
-              Class<?> implementedInterface = interfaces[0];
-              extra = "(anonymous implementation of " + implementedInterface.getName() + ")";
-            } else {
-              extra = "(anonymous subclass of java.lang.Object)";
-            }
-          } catch (ClassNotFoundException ignored) {
-          }
-        } else {
-          holderType = OBJECT;
-          // Makes it easier to figure out which anonymous class we're looking at.
-          extra = "(anonymous subclass of " + parentClassName + ")";
-        }
-      } else {
-        holderType = OBJECT;
-      }
-    }
-    return new LeakTraceElement(referenceName, type, holderType, className, extra, node.exclusion,
-        fields);
-  }
-
-  private long since(long analysisStartNanoTime) {
-    return NANOSECONDS.toMillis(System.nanoTime() - analysisStartNanoTime);
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
deleted file mode 100644
index b30df278..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.Instance;
-
-final class LeakNode {
-  /** May be null. */
-  final Exclusion exclusion;
-  final Instance instance;
-  final LeakNode parent;
-  final String referenceName;
-  final LeakTraceElement.Type referenceType;
-
-  LeakNode(Exclusion exclusion, Instance instance, LeakNode parent,
-      String referenceName, LeakTraceElement.Type referenceType) {
-    this.exclusion = exclusion;
-    this.instance = instance;
-    this.parent = parent;
-    this.referenceName = referenceName;
-    this.referenceType = referenceType;
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
deleted file mode 100644
index 607db22c..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.List;
-
-import static java.util.Collections.unmodifiableList;
-
-/**
- * A chain of references that constitute the shortest strong reference path from a leaking instance
- * to the GC roots. Fixing the leak usually means breaking one of the references in that chain.
- */
-public final class LeakTrace implements Serializable {
-
-  public final List<LeakTraceElement> elements;
-
-  LeakTrace(List<LeakTraceElement> elements) {
-    this.elements = unmodifiableList(new ArrayList<>(elements));
-  }
-
-  @Override public String toString() {
-    StringBuilder sb = new StringBuilder();
-    for (int i = 0; i < elements.size(); i++) {
-      LeakTraceElement element = elements.get(i);
-      sb.append("* ");
-      if (i == 0) {
-        sb.append("GC ROOT ");
-      } else if (i == elements.size() - 1) {
-        sb.append("leaks ");
-      } else {
-        sb.append("references ");
-      }
-      sb.append(element).append("\n");
-    }
-    return sb.toString();
-  }
-
-  public String toDetailedString() {
-    String string = "";
-    for (LeakTraceElement element : elements) {
-      string += element.toDetailedString();
-    }
-    return string;
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
deleted file mode 100644
index 89ef31e3..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.List;
-
-import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-import static java.util.Collections.unmodifiableList;
-import static java.util.Locale.US;
-
-/** Represents one reference in the chain of references that holds a leaking object in memory. */
-public final class LeakTraceElement implements Serializable {
-
-  public enum Type {
-    INSTANCE_FIELD, STATIC_FIELD, LOCAL, ARRAY_ENTRY
-  }
-
-  public enum Holder {
-    OBJECT, CLASS, THREAD, ARRAY
-  }
-
-  /** Null if this is the last element in the leak trace, ie the leaking object. */
-  public final String referenceName;
-
-  /** Null if this is the last element in the leak trace, ie the leaking object. */
-  public final Type type;
-  public final Holder holder;
-  public final String className;
-
-  /** Additional information, may be null. */
-  public final String extra;
-
-  /** If not null, there was no path that could exclude this element. */
-  public final Exclusion exclusion;
-
-  /** List of all fields (member and static) for that object. */
-  public final List<String> fields;
-
-  LeakTraceElement(String referenceName, Type type, Holder holder, String className, String extra,
-      Exclusion exclusion, List<String> fields) {
-    this.referenceName = referenceName;
-    this.type = type;
-    this.holder = holder;
-    this.className = className;
-    this.extra = extra;
-    this.exclusion = exclusion;
-    this.fields = unmodifiableList(new ArrayList<>(fields));
-  }
-
-  @Override public String toString() {
-    String string = "";
-
-    if (type == STATIC_FIELD) {
-      string += "static ";
-    }
-
-    if (holder == ARRAY || holder == THREAD) {
-      string += holder.name().toLowerCase(US) + " ";
-    }
-
-    string += className;
-
-    if (referenceName != null) {
-      string += "." + referenceName;
-    } else {
-      string += " instance";
-    }
-
-    if (extra != null) {
-      string += " " + extra;
-    }
-
-    if (exclusion != null) {
-      string += " , matching exclusion " + exclusion.matching;
-    }
-
-    return string;
-  }
-
-  public String toDetailedString() {
-    String string = "* ";
-    if (holder == ARRAY) {
-      string += "Array of";
-    } else if (holder == CLASS) {
-      string += "Class";
-    } else {
-      string += "Instance of";
-    }
-    string += " " + className + "\n";
-    for (String field : fields) {
-      string += "|   " + field + "\n";
-    }
-    return string;
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
deleted file mode 100644
index db6100ef..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
+++ /dev/null
@@ -1,343 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.ArrayInstance;
-import com.squareup.haha.perflib.ClassInstance;
-import com.squareup.haha.perflib.ClassObj;
-import com.squareup.haha.perflib.Field;
-import com.squareup.haha.perflib.HahaSpy;
-import com.squareup.haha.perflib.Instance;
-import com.squareup.haha.perflib.RootObj;
-import com.squareup.haha.perflib.RootType;
-import com.squareup.haha.perflib.Snapshot;
-import com.squareup.haha.perflib.Type;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.LinkedList;
-import java.util.Map;
-import java.util.Queue;
-
-import static com.squareup.leakcanary.HahaHelper.isPrimitiveOrWrapperArray;
-import static com.squareup.leakcanary.HahaHelper.isPrimitiveWrapper;
-import static com.squareup.leakcanary.HahaHelper.threadName;
-import static com.squareup.leakcanary.LeakTraceElement.Type.ARRAY_ENTRY;
-import static com.squareup.leakcanary.LeakTraceElement.Type.INSTANCE_FIELD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.LOCAL;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-
-/**
- * Not thread safe.
- *
- * Finds the shortest path from a leaking reference to a gc root, ignoring excluded
- * refs first and then including the ones that are not "always ignorable" as needed if no path is
- * found.
- */
-final class ShortestPathFinder {
-
-  private final ExcludedRefs excludedRefs;
-  private final Queue<LeakNode> toVisitQueue;
-  private final Queue<LeakNode> toVisitIfNoPathQueue;
-  private final LinkedHashSet<Instance> toVisitSet;
-  private final LinkedHashSet<Instance> toVisitIfNoPathSet;
-  private final LinkedHashSet<Instance> visitedSet;
-  private boolean canIgnoreStrings;
-
-  ShortestPathFinder(ExcludedRefs excludedRefs) {
-    this.excludedRefs = excludedRefs;
-    toVisitQueue = new LinkedList<>();
-    toVisitIfNoPathQueue = new LinkedList<>();
-    toVisitSet = new LinkedHashSet<>();
-    toVisitIfNoPathSet = new LinkedHashSet<>();
-    visitedSet = new LinkedHashSet<>();
-  }
-
-  static final class Result {
-    final LeakNode leakingNode;
-    final boolean excludingKnownLeaks;
-
-    Result(LeakNode leakingNode, boolean excludingKnownLeaks) {
-      this.leakingNode = leakingNode;
-      this.excludingKnownLeaks = excludingKnownLeaks;
-    }
-  }
-
-  Result findPath(Snapshot snapshot, Instance leakingRef) {
-    clearState();
-    canIgnoreStrings = !isString(leakingRef);
-
-    enqueueGcRoots(snapshot);
-
-    boolean excludingKnownLeaks = false;
-    LeakNode leakingNode = null;
-    while (!toVisitQueue.isEmpty() || !toVisitIfNoPathQueue.isEmpty()) {
-      LeakNode node;
-      if (!toVisitQueue.isEmpty()) {
-        node = toVisitQueue.poll();
-      } else {
-        node = toVisitIfNoPathQueue.poll();
-        if (node.exclusion == null) {
-          throw new IllegalStateException("Expected node to have an exclusion " + node);
-        }
-        excludingKnownLeaks = true;
-      }
-
-      // Termination
-      if (node.instance == leakingRef) {
-        leakingNode = node;
-        break;
-      }
-
-      if (checkSeen(node)) {
-        continue;
-      }
-
-      if (node.instance instanceof RootObj) {
-        visitRootObj(node);
-      } else if (node.instance instanceof ClassObj) {
-        visitClassObj(node);
-      } else if (node.instance instanceof ClassInstance) {
-        visitClassInstance(node);
-      } else if (node.instance instanceof ArrayInstance) {
-        visitArrayInstance(node);
-      } else {
-        throw new IllegalStateException("Unexpected type for " + node.instance);
-      }
-    }
-    return new Result(leakingNode, excludingKnownLeaks);
-  }
-
-  private void clearState() {
-    toVisitQueue.clear();
-    toVisitIfNoPathQueue.clear();
-    toVisitSet.clear();
-    toVisitIfNoPathSet.clear();
-    visitedSet.clear();
-  }
-
-  private void enqueueGcRoots(Snapshot snapshot) {
-    for (RootObj rootObj : snapshot.getGCRoots()) {
-      switch (rootObj.getRootType()) {
-        case JAVA_LOCAL:
-          Instance thread = HahaSpy.allocatingThread(rootObj);
-          String threadName = threadName(thread);
-          Exclusion params = excludedRefs.threadNames.get(threadName);
-          if (params == null || !params.alwaysExclude) {
-            enqueue(params, null, rootObj, null, null);
-          }
-          break;
-        case INTERNED_STRING:
-        case DEBUGGER:
-        case INVALID_TYPE:
-          // An object that is unreachable from any other root, but not a root itself.
-        case UNREACHABLE:
-        case UNKNOWN:
-          // An object that is in a queue, waiting for a finalizer to run.
-        case FINALIZING:
-          break;
-        case SYSTEM_CLASS:
-        case VM_INTERNAL:
-          // A local variable in native code.
-        case NATIVE_LOCAL:
-          // A global variable in native code.
-        case NATIVE_STATIC:
-          // An object that was referenced from an active thread block.
-        case THREAD_BLOCK:
-          // Everything that called the wait() or notify() methods, or that is synchronized.
-        case BUSY_MONITOR:
-        case NATIVE_MONITOR:
-        case REFERENCE_CLEANUP:
-          // Input or output parameters in native code.
-        case NATIVE_STACK:
-        case JAVA_STATIC:
-          enqueue(null, null, rootObj, null, null);
-          break;
-        default:
-          throw new UnsupportedOperationException("Unknown root type:" + rootObj.getRootType());
-      }
-    }
-  }
-
-  private boolean checkSeen(LeakNode node) {
-    return !visitedSet.add(node.instance);
-  }
-
-  private void visitRootObj(LeakNode node) {
-    RootObj rootObj = (RootObj) node.instance;
-    Instance child = rootObj.getReferredInstance();
-
-    Exclusion exclusion = rootSuperClassAlwaysIgnored(child);
-
-    if (exclusion != null && exclusion.alwaysExclude) {
-      return;
-    }
-
-    if (rootObj.getRootType() == RootType.JAVA_LOCAL) {
-      Instance holder = HahaSpy.allocatingThread(rootObj);
-      // We switch the parent node with the thread instance that holds
-      // the local reference.
-      LeakNode parent = new LeakNode(null, holder, null, null, null);
-      if (node.exclusion != null) {
-        exclusion = node.exclusion;
-      }
-      enqueue(exclusion, parent, child, "<Java Local>", LOCAL);
-    } else {
-      enqueue(exclusion, node, child, null, null);
-    }
-  }
-
-  private Exclusion rootSuperClassAlwaysIgnored(Instance child) {
-    if (child == null) {
-      return null;
-    }
-    Exclusion matchingParams = null;
-    ClassObj superClassObj = child.getClassObj();
-    while (superClassObj != null) {
-      Exclusion params = excludedRefs.rootClassNames.get(superClassObj.getClassName());
-      if (params != null) {
-        // true overrides null or false.
-        if (matchingParams == null || !matchingParams.alwaysExclude) {
-          matchingParams = params;
-        }
-      }
-      superClassObj = superClassObj.getSuperClassObj();
-    }
-    return matchingParams;
-  }
-
-  private void visitClassObj(LeakNode node) {
-    ClassObj classObj = (ClassObj) node.instance;
-    Map<String, Exclusion> ignoredStaticFields =
-        excludedRefs.staticFieldNameByClassName.get(classObj.getClassName());
-    for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-      Field field = entry.getKey();
-      if (field.getType() != Type.OBJECT) {
-        continue;
-      }
-      String fieldName = field.getName();
-      if (fieldName.equals("$staticOverhead")) {
-        continue;
-      }
-      Instance child = (Instance) entry.getValue();
-      boolean visit = true;
-      if (ignoredStaticFields != null) {
-        Exclusion params = ignoredStaticFields.get(fieldName);
-        if (params != null) {
-          visit = false;
-          if (!params.alwaysExclude) {
-            enqueue(params, node, child, fieldName, STATIC_FIELD);
-          }
-        }
-      }
-      if (visit) {
-        enqueue(null, node, child, fieldName, STATIC_FIELD);
-      }
-    }
-  }
-
-  private void visitClassInstance(LeakNode node) {
-    ClassInstance classInstance = (ClassInstance) node.instance;
-    Map<String, Exclusion> ignoredFields = new LinkedHashMap<>();
-    ClassObj superClassObj = classInstance.getClassObj();
-    Exclusion classExclusion = null;
-    while (superClassObj != null) {
-      Exclusion params = excludedRefs.classNames.get(superClassObj.getClassName());
-      if (params != null) {
-        // true overrides null or false.
-        if (classExclusion == null || !classExclusion.alwaysExclude) {
-          classExclusion = params;
-        }
-      }
-      Map<String, Exclusion> classIgnoredFields =
-          excludedRefs.fieldNameByClassName.get(superClassObj.getClassName());
-      if (classIgnoredFields != null) {
-        ignoredFields.putAll(classIgnoredFields);
-      }
-      superClassObj = superClassObj.getSuperClassObj();
-    }
-
-    if (classExclusion != null && classExclusion.alwaysExclude) {
-      return;
-    }
-
-    for (ClassInstance.FieldValue fieldValue : classInstance.getValues()) {
-      Exclusion fieldExclusion = classExclusion;
-      Field field = fieldValue.getField();
-      if (field.getType() != Type.OBJECT) {
-        continue;
-      }
-      Instance child = (Instance) fieldValue.getValue();
-      String fieldName = field.getName();
-      Exclusion params = ignoredFields.get(fieldName);
-      // If we found a field exclusion and it's stronger than a class exclusion
-      if (params != null && (fieldExclusion == null || (params.alwaysExclude
-          && !fieldExclusion.alwaysExclude))) {
-        fieldExclusion = params;
-      }
-      enqueue(fieldExclusion, node, child, fieldName, INSTANCE_FIELD);
-    }
-  }
-
-  private void visitArrayInstance(LeakNode node) {
-    ArrayInstance arrayInstance = (ArrayInstance) node.instance;
-    Type arrayType = arrayInstance.getArrayType();
-    if (arrayType == Type.OBJECT) {
-      Object[] values = arrayInstance.getValues();
-      for (int i = 0; i < values.length; i++) {
-        Instance child = (Instance) values[i];
-        enqueue(null, node, child, "[" + i + "]", ARRAY_ENTRY);
-      }
-    }
-  }
-
-  private void enqueue(Exclusion exclusion, LeakNode parent, Instance child, String referenceName,
-      LeakTraceElement.Type referenceType) {
-    if (child == null) {
-      return;
-    }
-    if (isPrimitiveOrWrapperArray(child) || isPrimitiveWrapper(child)) {
-      return;
-    }
-    // Whether we want to visit now or later, we should skip if this is already to visit.
-    if (toVisitSet.contains(child)) {
-      return;
-    }
-    boolean visitNow = exclusion == null;
-    if (!visitNow && toVisitIfNoPathSet.contains(child)) {
-      return;
-    }
-    if (canIgnoreStrings && isString(child)) {
-      return;
-    }
-    if (visitedSet.contains(child)) {
-      return;
-    }
-    LeakNode childNode = new LeakNode(exclusion, child, parent, referenceName, referenceType);
-    if (visitNow) {
-      toVisitSet.add(child);
-      toVisitQueue.add(childNode);
-    } else {
-      toVisitIfNoPathSet.add(child);
-      toVisitIfNoPathQueue.add(childNode);
-    }
-  }
-
-  private boolean isString(Instance instance) {
-    return instance.getClassObj() != null && instance.getClassObj()
-        .getClassName()
-        .equals(String.class.getName());
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
new file mode 100644
index 00000000..bc49a641
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
@@ -0,0 +1,528 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import leakcanary.AnalyzerProgressListener.Step.BUILDING_LEAK_TRACES
+import leakcanary.AnalyzerProgressListener.Step.COMPUTING_DOMINATORS
+import leakcanary.AnalyzerProgressListener.Step.FINDING_LEAKING_REFS
+import leakcanary.AnalyzerProgressListener.Step.FINDING_SHORTEST_PATHS
+import leakcanary.AnalyzerProgressListener.Step.FINDING_WATCHED_REFERENCES
+import leakcanary.AnalyzerProgressListener.Step.READING_HEAP_DUMP_FILE
+import leakcanary.AnalyzerProgressListener.Step.SCANNING_HEAP_DUMP
+import leakcanary.GcRoot.JavaFrame
+import leakcanary.GcRoot.JniGlobal
+import leakcanary.GcRoot.JniLocal
+import leakcanary.GcRoot.JniMonitor
+import leakcanary.GcRoot.MonitorUsed
+import leakcanary.GcRoot.NativeStack
+import leakcanary.GcRoot.ReferenceCleanup
+import leakcanary.GcRoot.StickyClass
+import leakcanary.GcRoot.ThreadBlock
+import leakcanary.HeapValue.BooleanValue
+import leakcanary.HeapValue.ByteValue
+import leakcanary.HeapValue.CharValue
+import leakcanary.HeapValue.DoubleValue
+import leakcanary.HeapValue.FloatValue
+import leakcanary.HeapValue.IntValue
+import leakcanary.HeapValue.LongValue
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.HeapValue.ShortValue
+import leakcanary.HprofParser.RecordCallbacks
+import leakcanary.LeakNode.ChildNode
+import leakcanary.LeakTraceElement.Holder.ARRAY
+import leakcanary.LeakTraceElement.Holder.CLASS
+import leakcanary.LeakTraceElement.Holder.OBJECT
+import leakcanary.LeakTraceElement.Holder.THREAD
+import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
+import leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
+import leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import leakcanary.Reachability.Status.REACHABLE
+import leakcanary.Reachability.Status.UNKNOWN
+import leakcanary.Reachability.Status.UNREACHABLE
+import leakcanary.Record.HeapDumpRecord.GcRootRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.Record.LoadClassRecord
+import leakcanary.Record.StringRecord
+import leakcanary.internal.KeyedWeakReferenceMirror
+import leakcanary.internal.ShortestPathFinder
+import leakcanary.internal.ShortestPathFinder.Result
+import java.util.ArrayList
+import java.util.concurrent.TimeUnit.NANOSECONDS
+
+/**
+ * Analyzes heap dumps to look for leaks.
+ */
+class HeapAnalyzer constructor(
+  private val listener: AnalyzerProgressListener
+) {
+
+  /**
+   * Searches the heap dump for a [KeyedWeakReference] instance with the corresponding key,
+   * and then computes the shortest strong reference path from that instance to the GC roots.
+   */
+  fun checkForLeaks(
+    heapDump: HeapDump,
+    labelers: List<Labeler>
+  ): HeapAnalysis {
+    val analysisStartNanoTime = System.nanoTime()
+
+    if (!heapDump.heapDumpFile.exists()) {
+      val exception = IllegalArgumentException("File does not exist: $heapDump.heapDumpFile")
+      return HeapAnalysisFailure(
+          heapDump, System.currentTimeMillis(), since(analysisStartNanoTime),
+          HeapAnalysisException(exception)
+      )
+    }
+
+    listener.onProgressUpdate(READING_HEAP_DUMP_FILE)
+
+
+    try {
+      HprofParser.open(heapDump.heapDumpFile)
+          .use { parser ->
+            listener.onProgressUpdate(SCANNING_HEAP_DUMP)
+            val (gcRootIds, heapDumpMemoryStoreClassId, keyedWeakReferenceInstances) = scan(parser)
+            val analysisResults = mutableMapOf<String, RetainedInstance>()
+            listener.onProgressUpdate(FINDING_WATCHED_REFERENCES)
+            val (retainedKeys, heapDumpUptimeMillis) = readHeapDumpMemoryStore(
+                parser, heapDumpMemoryStoreClassId
+            )
+
+            if (retainedKeys.isEmpty()) {
+              val exception = IllegalStateException("No retained keys found in heap dump")
+              return HeapAnalysisFailure(
+                  heapDump, System.currentTimeMillis(), since(analysisStartNanoTime),
+                  HeapAnalysisException(exception)
+              )
+            }
+
+            val leakingWeakRefs =
+              findLeakingReferences(
+                  parser, retainedKeys, analysisResults, keyedWeakReferenceInstances,
+                  heapDumpUptimeMillis
+              )
+
+            val pathResults = findShortestPaths(heapDump, parser, leakingWeakRefs, gcRootIds)
+
+            buildLeakTraces(
+                heapDump, labelers, pathResults, parser, leakingWeakRefs, analysisResults
+            )
+
+            addRemainingInstancesWithNoPath(parser, leakingWeakRefs, analysisResults)
+
+            return HeapAnalysisSuccess(
+                heapDump, System.currentTimeMillis(), since(analysisStartNanoTime),
+                analysisResults.values.toList()
+            )
+          }
+    } catch (exception: Throwable) {
+      return HeapAnalysisFailure(
+          heapDump, System.currentTimeMillis(), since(analysisStartNanoTime),
+          HeapAnalysisException(exception)
+      )
+    }
+  }
+
+  private fun scan(parser: HprofParser): Triple<MutableList<Long>, Long, List<InstanceDumpRecord>> {
+    var keyedWeakReferenceStringId = -1L
+    var heapDumpMemoryStoreStringId = -1L
+    var keyedWeakReferenceClassId = -1L
+    var heapDumpMemoryStoreClassId = -1L
+    val keyedWeakReferenceInstances = mutableListOf<InstanceDumpRecord>()
+    val gcRootIds = mutableListOf<Long>()
+    val callbacks = RecordCallbacks()
+        .on(StringRecord::class.java) {
+          if (it.string == KeyedWeakReference::class.java.name) {
+            keyedWeakReferenceStringId = it.id
+          } else if (it.string == HeapDumpMemoryStore::class.java.name) {
+            heapDumpMemoryStoreStringId = it.id
+          }
+        }
+        .on(LoadClassRecord::class.java) {
+          if (it.classNameStringId == keyedWeakReferenceStringId) {
+            keyedWeakReferenceClassId = it.id
+          } else if (it.classNameStringId == heapDumpMemoryStoreStringId) {
+            heapDumpMemoryStoreClassId = it.id
+          }
+        }
+        .on(InstanceDumpRecord::class.java) {
+          if (it.classId == keyedWeakReferenceClassId) {
+            keyedWeakReferenceInstances.add(it)
+          }
+        }
+        .on(GcRootRecord::class.java) {
+          // TODO Why is ThreadObject ignored?
+          // TODO Ignoring VmInternal because we've got 150K of it, but is this the right thing
+          // to do? What's VmInternal exactly? History does not go further than
+          // https://android.googlesource.com/platform/dalvik2/+/refs/heads/master/hit/src/com/android/hit/HprofParser.java#77
+          // We should log to figure out what objects VmInternal points to.
+          when (it.gcRoot) {
+            is JniGlobal,
+            is JniLocal,
+            is JavaFrame,
+            is NativeStack,
+            is StickyClass,
+            is ThreadBlock,
+            is MonitorUsed,
+              // TODO What is this and why do we care about it as a root?
+            is ReferenceCleanup,
+            is JniMonitor
+            -> {
+              gcRootIds.add(it.gcRoot.id)
+            }
+          }
+        }
+    parser.scan(callbacks)
+    return Triple(gcRootIds, heapDumpMemoryStoreClassId, keyedWeakReferenceInstances)
+  }
+
+  private fun readHeapDumpMemoryStore(
+    parser: HprofParser,
+    heapDumpMemoryStoreClassId: Long
+  ): Pair<MutableSet<Long>, Long> {
+    val storeClass = parser.hydrateClassHierarchy(heapDumpMemoryStoreClassId)[0]
+    val retainedKeysForHeapDump = (parser.retrieveRecord(
+        storeClass.staticFieldValue("retainedKeysForHeapDump")
+    ) as ObjectArrayDumpRecord).elementIds.toMutableSet()
+    val heapDumpUptimeMillis =
+      storeClass.staticFieldValue<LongValue>("heapDumpUptimeMillis")
+          .value
+    return retainedKeysForHeapDump to heapDumpUptimeMillis
+  }
+
+  private fun findLeakingReferences(
+    parser: HprofParser,
+    retainedKeys: MutableSet<Long>,
+    analysisResults: MutableMap<String, RetainedInstance>,
+    keyedWeakReferenceInstances: List<InstanceDumpRecord>,
+    heapDumpUptimeMillis: Long
+  ): MutableList<KeyedWeakReferenceMirror> {
+    listener.onProgressUpdate(FINDING_LEAKING_REFS)
+
+    val leakingWeakRefs = mutableListOf<KeyedWeakReferenceMirror>()
+
+    keyedWeakReferenceInstances.forEach { record ->
+      val weakRef =
+        KeyedWeakReferenceMirror.fromInstance(parser.hydrateInstance(record), heapDumpUptimeMillis)
+      val wasRetained = retainedKeys.remove(weakRef.key.value)
+      if (wasRetained) {
+        if (weakRef.hasReferent) {
+          leakingWeakRefs.add(weakRef)
+        } else {
+          val key = parser.retrieveString(weakRef.key)
+          val name = parser.retrieveString(weakRef.name)
+          val className = parser.retrieveString(weakRef.className)
+          val noLeak = WeakReferenceCleared(key, name, className, weakRef.watchDurationMillis)
+          analysisResults[key] = noLeak
+        }
+      }
+    }
+    retainedKeys.forEach { referenceKeyId ->
+      // This could happen if RefWatcher removed weakly reachable references after providing
+      // the set of retained keys
+      val referenceKey = parser.retrieveStringById(referenceKeyId)
+      val noLeak = WeakReferenceMissing(referenceKey)
+      analysisResults[referenceKey] = noLeak
+    }
+    return leakingWeakRefs
+  }
+
+  private fun findShortestPaths(
+    heapDump: HeapDump,
+    parser: HprofParser,
+    leakingWeakRefs: List<KeyedWeakReferenceMirror>,
+    gcRootIds: MutableList<Long>
+  ): List<Result> {
+    listener.onProgressUpdate(FINDING_SHORTEST_PATHS)
+
+    val pathFinder = ShortestPathFinder(heapDump.excludedRefs)
+    return pathFinder.findPaths(parser, leakingWeakRefs, gcRootIds)
+  }
+
+  private fun buildLeakTraces(
+    heapDump: HeapDump,
+    labelers: List<Labeler>,
+    pathResults: List<Result>,
+    parser: HprofParser,
+    leakingWeakRefs: MutableList<KeyedWeakReferenceMirror>,
+    analysisResults: MutableMap<String, RetainedInstance>
+  ) {
+    if (heapDump.computeRetainedHeapSize && pathResults.isNotEmpty()) {
+      listener.onProgressUpdate(COMPUTING_DOMINATORS)
+      // Computing dominators has the side effect of computing retained size.
+      CanaryLog.d("Cannot compute retained heap size because dominators is not implemented yet")
+    }
+
+    listener.onProgressUpdate(BUILDING_LEAK_TRACES)
+
+    pathResults.forEach { pathResult ->
+      val weakReference = pathResult.weakReference
+      val removed = leakingWeakRefs.remove(weakReference)
+      if (!removed) {
+        throw IllegalStateException(
+            "ShortestPathFinder found an instance we didn't ask it to find: $pathResult"
+        )
+      }
+
+      val leakTrace = buildLeakTrace(parser, heapDump, pathResult.leakingNode, labelers)
+
+      // TODO Compute retained heap size
+      val retainedSize = null
+      val key = parser.retrieveString(weakReference.key)
+      val leakDetected = LeakingInstance(
+          key,
+          parser.retrieveString(weakReference.name),
+          parser.retrieveString(weakReference.className),
+          weakReference.watchDurationMillis, pathResult.excludingKnownLeaks, leakTrace, retainedSize
+      )
+      analysisResults[key] = leakDetected
+    }
+  }
+
+  private fun addRemainingInstancesWithNoPath(
+    hprofParser: HprofParser,
+    leakingWeakRefs: List<KeyedWeakReferenceMirror>,
+    analysisResults: MutableMap<String, RetainedInstance>
+  ) {
+    leakingWeakRefs.forEach { refWithNoPath ->
+      val key = hprofParser.retrieveString(refWithNoPath.key)
+      val name = hprofParser.retrieveString(refWithNoPath.name)
+      val className = hprofParser.retrieveString(refWithNoPath.className)
+      val noLeak = NoPathToInstance(key, name, className, refWithNoPath.watchDurationMillis)
+      analysisResults[key] = noLeak
+    }
+  }
+
+  private fun buildLeakTrace(
+    parser: HprofParser,
+    heapDump: HeapDump,
+    leakingNode: LeakNode,
+    labelers: List<Labeler>
+  ): LeakTrace {
+    val elements = ArrayList<LeakTraceElement>()
+    // We iterate from the leak to the GC root
+    val ignored = leakingNode.instance
+    var node: LeakNode? =
+      ChildNode(ignored, null, leakingNode, null)
+    while (node is ChildNode) {
+      val labels = mutableListOf<String>()
+      for (labeler in labelers) {
+        labels.addAll(labeler.computeLabels(parser, node))
+      }
+      elements.add(0, buildLeakElement(parser, node, labels))
+      node = node.parent
+    }
+
+    val expectedReachability = computeExpectedReachability(parser, heapDump, elements)
+
+    return LeakTrace(elements, expectedReachability)
+  }
+
+  private fun computeExpectedReachability(
+    parser: HprofParser,
+    heapDump: HeapDump,
+    elements: List<LeakTraceElement>
+  ): List<Reachability> {
+    var lastReachableElementIndex = 0
+    val lastElementIndex = elements.size - 1
+    var firstUnreachableElementIndex = lastElementIndex
+
+    val expectedReachability = ArrayList<Reachability>()
+
+    val reachabilityInspectors = mutableListOf<Reachability.Inspector>()
+    for (reachabilityInspectorClass in heapDump.reachabilityInspectorClasses) {
+      try {
+        val defaultConstructor = reachabilityInspectorClass.getDeclaredConstructor()
+        reachabilityInspectors.add(defaultConstructor.newInstance())
+      } catch (e: Exception) {
+        throw RuntimeException(e)
+      }
+    }
+
+    for ((index, element) in elements.withIndex()) {
+      val reachability = inspectElementReachability(parser, reachabilityInspectors, element)
+      expectedReachability.add(reachability)
+      if (reachability.status == REACHABLE) {
+        lastReachableElementIndex = index
+        // Reset firstUnreachableElementIndex so that we never have
+        // firstUnreachableElementIndex < lastReachableElementIndex
+        firstUnreachableElementIndex = lastElementIndex
+      } else if (firstUnreachableElementIndex == lastElementIndex && reachability.status == UNREACHABLE) {
+        firstUnreachableElementIndex = index
+      }
+    }
+
+    if (expectedReachability[0].status == UNKNOWN) {
+      expectedReachability[0] = Reachability.reachable("it's a GC root")
+    }
+
+    when (expectedReachability[lastElementIndex].status) {
+      UNKNOWN, REACHABLE -> {
+        expectedReachability[lastElementIndex] =
+          Reachability.unreachable("RefWatcher was watching this")
+        if (lastReachableElementIndex == lastElementIndex) {
+          lastReachableElementIndex--
+        }
+      }
+    }
+
+    if (expectedReachability[lastElementIndex].status == UNKNOWN) {
+      expectedReachability[lastElementIndex] =
+        Reachability.unreachable("RefWatcher was watching this")
+    }
+
+    // First and last are always known.
+    for (i in 1 until lastElementIndex) {
+      val reachability = expectedReachability[i]
+      if (reachability.status == UNKNOWN) {
+        if (i < lastReachableElementIndex) {
+          val nextReachableName = elements[i + 1].getSimpleClassName()
+          expectedReachability[i] = Reachability.reachable("$nextReachableName↓ is not leaking")
+        } else if (i > firstUnreachableElementIndex) {
+          val previousUnreachableName = elements[i - 1].getSimpleClassName()
+          expectedReachability[i] = Reachability.unreachable("$previousUnreachableName↑ is leaking")
+        }
+      }
+    }
+    return expectedReachability
+  }
+
+  private fun inspectElementReachability(
+    parser: HprofParser,
+    reachabilityInspectors: List<Reachability.Inspector>,
+    element: LeakTraceElement
+  ): Reachability {
+    for (reachabilityInspector in reachabilityInspectors) {
+      val reachability = reachabilityInspector.expectedReachability(element)
+      if (reachability.status != UNKNOWN) {
+        return reachability
+      }
+    }
+    return Reachability.unknown()
+  }
+
+  private fun buildLeakElement(
+    parser: HprofParser,
+    node: ChildNode,
+    labels: List<String>
+  ): LeakTraceElement {
+    val objectId = node.parent.instance
+
+    val record = parser.retrieveRecordById(objectId)
+
+    val leakReferences = describeFields(parser, record)
+
+    val classHierarchy = when (record) {
+      is ClassDumpRecord -> listOf(parser.className(record.id))
+      is InstanceDumpRecord -> {
+        val instance = parser.hydrateInstance(record)
+        instance.classHierarchy.map { it.className }
+      }
+      is ObjectArrayDumpRecord -> listOf(parser.className(record.arrayClassId))
+      else -> throw IllegalStateException("Unexpected record type for $record")
+    }
+
+    val holderType = if (record is ClassDumpRecord) {
+      CLASS
+    } else if (record is ObjectArrayDumpRecord) {
+      ARRAY
+    } else {
+      if (classHierarchy.any { it == Thread::class.java.name }) {
+        THREAD
+      } else {
+        OBJECT
+      }
+    }
+    return LeakTraceElement(
+        node.leakReference, holderType, classHierarchy, node.exclusion, leakReferences, labels
+    )
+  }
+
+  private fun describeFields(
+    parser: HprofParser,
+    record: ObjectRecord
+  ): List<LeakReference> {
+    val leakReferences = ArrayList<LeakReference>()
+    when (record) {
+      is ClassDumpRecord -> {
+        // TODO We're loading all classes but reading only one. All this should be removed
+        // it's only used by inspectors which should ask the parser for their needs.
+        val classHierarchy = parser.hydrateClassHierarchy(record.id)
+        val hydratedClass = classHierarchy[0]
+        hydratedClass.staticFieldNames.forEachIndexed { index, fieldName ->
+
+          val heapValue = hydratedClass.record.staticFields[index].value
+          leakReferences.add(
+              LeakReference(STATIC_FIELD, fieldName, heapValueAsString(heapValue))
+          )
+        }
+      }
+      is ObjectArrayDumpRecord -> record.elementIds.forEachIndexed { index, objectId ->
+        val name = Integer.toString(index)
+        leakReferences.add(LeakReference(ARRAY_ENTRY, name, "object $objectId"))
+      }
+      else -> {
+        val instance = parser.hydrateInstance(record as InstanceDumpRecord)
+        instance.classHierarchy[0].staticFieldNames.forEachIndexed { index, fieldName ->
+          val heapValue = instance.classHierarchy[0].record.staticFields[index].value
+          leakReferences.add(
+              LeakReference(
+                  STATIC_FIELD, fieldName,
+                  heapValueAsString(heapValue)
+              )
+          )
+        }
+        instance.fieldValues.forEachIndexed { classIndex, fieldValues ->
+          fieldValues.forEachIndexed { fieldIndex, heapValue ->
+            leakReferences.add(
+                LeakReference(
+                    INSTANCE_FIELD, instance.classHierarchy[classIndex].fieldNames[fieldIndex],
+                    heapValueAsString(heapValue)
+                )
+            )
+          }
+        }
+      }
+    }
+    return leakReferences
+  }
+
+  private fun heapValueAsString(heapValue: HeapValue): String {
+    return when (heapValue) {
+      is ObjectReference -> if (heapValue.value == 0L) "null" else "object ${heapValue.value}"
+      is BooleanValue -> heapValue.value.toString()
+      is CharValue -> heapValue.value.toString()
+      is FloatValue -> heapValue.value.toString()
+      is DoubleValue -> heapValue.value.toString()
+      is ByteValue -> heapValue.value.toString()
+      is ShortValue -> heapValue.value.toString()
+      is IntValue -> heapValue.value.toString()
+      is LongValue -> heapValue.value.toString()
+    }
+  }
+
+  private fun since(analysisStartNanoTime: Long): Long {
+    return NANOSECONDS.toMillis(System.nanoTime() - analysisStartNanoTime)
+  }
+
+  companion object {
+    internal const val ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$"
+    internal val ANONYMOUS_CLASS_NAME_PATTERN_REGEX = ANONYMOUS_CLASS_NAME_PATTERN.toRegex()
+  }
+}
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/Labeler.kt b/leakcanary-analyzer/src/main/java/leakcanary/Labeler.kt
new file mode 100644
index 00000000..855d07b5
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/Labeler.kt
@@ -0,0 +1,68 @@
+package leakcanary
+
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.LeakNode.ChildNode
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+
+interface Labeler {
+
+  /**
+   * Note: this is a bit confusing but for a given node you should really be printing attributes
+   * of node.parent.instance
+   * TODO Make this less confusing.
+   */
+  fun computeLabels(
+    parser: HprofParser,
+    node: ChildNode
+  ): List<String>
+
+  object InstanceDefaultLabeler : Labeler {
+    override fun computeLabels(
+      parser: HprofParser,
+      node: ChildNode
+    ): List<String> {
+      val objectId = node.parent.instance
+      val record = parser.retrieveRecordById(objectId)
+      if (record is InstanceDumpRecord) {
+        val labels = mutableListOf<String>()
+        val instance = parser.hydrateInstance(record)
+        val className = instance.classHierarchy[0].className
+
+        if (instance.classHierarchy.any { it.className == Thread::class.java.name }) {
+          val nameField = instance.fieldValueOrNull<ObjectReference>("name")
+          // Sometimes we can't find the String at the expected memory address in the heap dump.
+          // See https://github.com/square/leakcanary/issues/417
+          val threadName =
+            if (nameField != null) parser.retrieveString(nameField) else "not available"
+          labels.add("Thread name: '$threadName'")
+        } else if (className.matches(HeapAnalyzer.ANONYMOUS_CLASS_NAME_PATTERN_REGEX)) {
+          val parentClassName = instance.classHierarchy[1].className
+          if (parentClassName == "java.lang.Object") {
+            try {
+              // This is an anonymous class implementing an interface. The API does not give access
+              // to the interfaces implemented by the class. We check if it's in the class path and
+              // use that instead.
+              val actualClass = Class.forName(instance.classHierarchy[0].className)
+              val interfaces = actualClass.interfaces
+              labels.add(
+                  if (interfaces.isNotEmpty()) {
+                    val implementedInterface = interfaces[0]
+                    "Anonymous class implementing ${implementedInterface.name}"
+                  } else {
+                    "Anonymous subclass of java.lang.Object"
+                  }
+              )
+            } catch (ignored: ClassNotFoundException) {
+            }
+          } else {
+            // Makes it easier to figure out which anonymous class we're looking at.
+            labels.add("Anonymous subclass of $parentClassName")
+          }
+        }
+        return labels
+      } else {
+        return emptyList()
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
new file mode 100644
index 00000000..3a3d7e99
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
@@ -0,0 +1,16 @@
+package leakcanary
+
+sealed class LeakNode {
+  abstract val instance: Long
+
+  class RootNode(
+    override val instance: Long
+  ) : LeakNode()
+
+  class ChildNode(
+    override val instance: Long,
+    val exclusion: Exclusion?,
+    val parent: LeakNode,
+    val leakReference: LeakReference?
+  ) : LeakNode()
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
new file mode 100644
index 00000000..39105bd4
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
@@ -0,0 +1,34 @@
+package leakcanary.internal
+
+import leakcanary.HeapValue.LongValue
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.HydratedInstance
+
+internal class KeyedWeakReferenceMirror(
+  val key: ObjectReference,
+  val name: ObjectReference,
+  val className: ObjectReference,
+  val watchDurationMillis: Long,
+  val referent: ObjectReference
+) {
+
+  val hasReferent = referent.value != 0L
+
+  companion object {
+    fun fromInstance(
+      weakRef: HydratedInstance,
+      heapDumpUptimeMillis: Long
+    ): KeyedWeakReferenceMirror {
+      return KeyedWeakReferenceMirror(
+          key = weakRef.fieldValue("key"),
+          name = weakRef.fieldValue("name"),
+          className = weakRef.fieldValue("className"),
+          watchDurationMillis = heapDumpUptimeMillis - weakRef.fieldValue<LongValue>(
+              "watchUptimeMillis"
+          ).value,
+          referent = weakRef.fieldValue("referent")
+      )
+    }
+  }
+}
+
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
new file mode 100644
index 00000000..52e5bff8
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
@@ -0,0 +1,296 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import leakcanary.ExcludedRefs
+import leakcanary.Exclusion
+import leakcanary.HeapValue
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.HprofParser
+import leakcanary.LeakNode
+import leakcanary.LeakReference
+import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
+import leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
+import leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import leakcanary.ObjectIdMetadata.EMPTY_INSTANCE
+import leakcanary.ObjectIdMetadata.PRIMITIVE_WRAPPER
+import leakcanary.ObjectIdMetadata.PRIMITIVE_ARRAY_OR_WRAPPER_ARRAY
+import leakcanary.ObjectIdMetadata.STRING
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.LeakNode.ChildNode
+import leakcanary.LeakNode.RootNode
+import java.util.ArrayDeque
+import java.util.Deque
+import java.util.LinkedHashMap
+import java.util.LinkedHashSet
+
+/**
+ * Not thread safe.
+ *
+ * Finds the shortest path from leaking references to a gc root, ignoring excluded
+ * refs first and then including the ones that are not "always ignorable" as needed if no path is
+ * found.
+ *
+ * Skips enqueuing strings as an optimization, so if the leaking reference is a string then it will
+ * never be found.
+ */
+internal class ShortestPathFinder(
+  private val excludedRefs: ExcludedRefs
+) {
+  /**
+   * TODO If this queue grows large we can optimize it by replacing LeakNode with just (long, long)
+   * and rebuild exclusion and leak reference after the analysis
+   */
+  private val toVisitQueue: Deque<LeakNode>
+  private val toVisitIfNoPathQueue: Deque<LeakNode>
+  private val toVisitSet: LinkedHashSet<Long>
+  private val toVisitIfNoPathSet: LinkedHashSet<Long>
+  private val visitedSet: LinkedHashSet<Long>
+
+  init {
+    toVisitQueue = ArrayDeque()
+    toVisitIfNoPathQueue = ArrayDeque()
+    toVisitSet = LinkedHashSet()
+    toVisitIfNoPathSet = LinkedHashSet()
+    visitedSet = LinkedHashSet()
+  }
+
+  internal class Result(
+    val leakingNode: LeakNode,
+    val excludingKnownLeaks: Boolean,
+    val weakReference: KeyedWeakReferenceMirror
+  )
+
+  fun findPaths(
+    parser: HprofParser,
+    leakingWeakRefs: List<KeyedWeakReferenceMirror>,
+    gcRootIds: MutableList<Long>
+  ): List<Result> {
+    clearState()
+    // Referent object id to weak ref mirror
+    val referentMap = leakingWeakRefs.associateBy { it.referent.value }
+
+    enqueueGcRoots(parser, gcRootIds)
+    gcRootIds.clear()
+
+    var excludingKnownLeaks = false
+    val results = mutableListOf<Result>()
+    while (!toVisitQueue.isEmpty() || !toVisitIfNoPathQueue.isEmpty()) {
+      val node: LeakNode
+      if (!toVisitQueue.isEmpty()) {
+        node = toVisitQueue.poll()
+        toVisitSet.remove(node.instance)
+      } else {
+        node = toVisitIfNoPathQueue.poll()
+        toVisitIfNoPathSet.remove(node.instance)
+        if (node is RootNode || (node is ChildNode && node.exclusion == null)) {
+          throw IllegalStateException("Expected node to have an exclusion $node")
+        }
+        excludingKnownLeaks = true
+      }
+
+      if (checkSeen(node)) {
+        continue
+      }
+
+      val weakReference = referentMap[node.instance]
+      if (weakReference != null) {
+        results.add(
+            Result(
+                node, excludingKnownLeaks, weakReference
+            )
+        )
+        // Found all refs, stop searching.
+        if (results.size == leakingWeakRefs.size) {
+          break
+        }
+      }
+
+      when (val record = parser.retrieveRecordById(node.instance)) {
+        is ClassDumpRecord -> visitClassRecord(parser, record, node)
+        is InstanceDumpRecord -> visitInstanceRecord(parser, record, node)
+        is ObjectArrayDumpRecord -> visitObjectArrayRecord(parser, record, node)
+        else -> throw IllegalStateException("Unexpected type for $record")
+      }
+    }
+
+    clearState()
+    return results
+  }
+
+  private fun checkSeen(node: LeakNode): Boolean {
+    val alreadySeen = visitedSet.add(node.instance)
+    return !alreadySeen
+  }
+
+  private fun clearState() {
+    toVisitQueue.clear()
+    toVisitIfNoPathQueue.clear()
+    toVisitSet.clear()
+    toVisitIfNoPathSet.clear()
+    visitedSet.clear()
+  }
+
+  private fun enqueueGcRoots(
+    hprofParser: HprofParser,
+    gcRootIds: List<Long>
+  ) {
+    // TODO sort GC roots based on type and class name (for class / instance / array)
+    // Goal is to get a stable shortest path
+    // TODO Add root type so that for java local we could exclude specific threads.
+    // TODO java local: exclude specific threads,
+    // TODO java local: parent should be set to the allocated thread
+    gcRootIds.forEach {
+      enqueue(hprofParser, RootNode(it))
+    }
+  }
+
+  private fun visitClassRecord(
+    hprofParser: HprofParser,
+    record: ClassDumpRecord,
+    node: LeakNode
+  ) {
+    val className = hprofParser.className(record.id)
+
+    val ignoredStaticFields = excludedRefs.staticFieldNameByClassName[className] ?: emptyMap()
+
+    for (staticField in record.staticFields) {
+      val objectId = (staticField.value as? ObjectReference)?.value ?: continue
+      val fieldName = hprofParser.hprofStringById(staticField.nameStringId)
+      if (fieldName == "\$staticOverhead") {
+        continue
+      }
+
+      val leakReference = LeakReference(STATIC_FIELD, fieldName, "object $objectId")
+
+      val exclusion = ignoredStaticFields[fieldName]
+
+      if (exclusion == null || !exclusion.alwaysExclude) {
+        enqueue(hprofParser, ChildNode(objectId, exclusion, node, leakReference))
+      }
+    }
+  }
+
+  private fun visitInstanceRecord(
+    hprofParser: HprofParser,
+    record: InstanceDumpRecord,
+    parent: LeakNode
+  ) {
+    val instance = hprofParser.hydrateInstance(record)
+
+    val exclusions = instance.classHierarchy.map {
+      excludedRefs.classNames[it.className]
+    }
+
+    if (exclusions.firstOrNull {
+          it != null && it.alwaysExclude
+        } != null) {
+      return
+    }
+
+    val classExclusion = exclusions.firstOrNull { it != null }
+
+    val ignoredFields = LinkedHashMap<String, Exclusion>()
+
+    instance.classHierarchy.forEach {
+      ignoredFields.putAll(excludedRefs.fieldNameByClassName[it.className] ?: emptyMap())
+    }
+
+    val fieldNamesAndValues = mutableListOf<Pair<String, HeapValue>>()
+
+    instance.fieldValues.forEachIndexed { classIndex, classFieldValues ->
+      classFieldValues.forEachIndexed { fieldIndex, fieldValue ->
+        val fieldName = instance.classHierarchy[classIndex].fieldNames[fieldIndex]
+        fieldNamesAndValues.add(fieldName to fieldValue)
+      }
+    }
+
+    fieldNamesAndValues.sortBy { (name, _) -> name }
+
+    fieldNamesAndValues.filter { (_, value) -> value is ObjectReference }
+        .map { (name, reference) -> name to (reference as ObjectReference).value }
+        .forEach { (fieldName, objectId) ->
+          val fieldExclusion = ignoredFields[fieldName]
+
+          val exclusion = if (classExclusion != null && classExclusion.alwaysExclude) {
+            classExclusion
+          } else if (fieldExclusion != null && fieldExclusion.alwaysExclude) {
+            fieldExclusion
+          } else classExclusion ?: fieldExclusion
+          enqueue(
+              hprofParser, ChildNode(
+              objectId,
+              exclusion, parent,
+              LeakReference(INSTANCE_FIELD, fieldName, "object $objectId")
+          )
+          )
+        }
+  }
+
+  private fun visitObjectArrayRecord(
+    hprofParser: HprofParser,
+    record: ObjectArrayDumpRecord,
+    parentNode: LeakNode
+  ) {
+    record.elementIds.forEachIndexed { index, elementId ->
+      val name = Integer.toString(index)
+      val reference = LeakReference(ARRAY_ENTRY, name, "object $elementId")
+      enqueue(hprofParser, ChildNode(elementId, null, parentNode, reference))
+    }
+  }
+
+  private fun enqueue(
+    hprofParser: HprofParser,
+    node: LeakNode
+  ) {
+    if (node.instance == 0L) {
+      return
+    }
+
+    // Whether we want to visit now or later, we should skip if this is already to visit.
+    if (toVisitSet.contains(node.instance)) {
+      return
+    }
+    if (visitedSet.contains(node.instance)) {
+      return
+    }
+
+    val visitNow = node is RootNode || (node is ChildNode && node.exclusion == null)
+    if (!visitNow && toVisitIfNoPathSet.contains(node.instance)) {
+      return
+    }
+
+    val objectIdMetadata = hprofParser.objectIdMetadata(node.instance)
+    if (objectIdMetadata in SKIP_ENQUEUE) {
+      return
+    }
+
+    if (visitNow) {
+      toVisitSet.add(node.instance)
+      toVisitQueue.add(node)
+    } else {
+      toVisitIfNoPathSet.add(node.instance)
+      toVisitIfNoPathQueue.add(node)
+    }
+  }
+
+  companion object {
+    private val SKIP_ENQUEUE =
+      setOf(PRIMITIVE_WRAPPER, PRIMITIVE_ARRAY_OR_WRAPPER_ARRAY, STRING, EMPTY_INSTANCE)
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java
deleted file mode 100644
index ad43d493..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.lang.ref.WeakReference;
-import java.util.Collection;
-import java.util.List;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_MPREVIEW2;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_M_POSTPREVIEW2;
-import static com.squareup.leakcanary.TestUtil.analyze;
-import static java.util.Arrays.asList;
-import static org.hamcrest.core.StringContains.containsString;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-
-@RunWith(Parameterized.class) //
-public class AsyncTaskLeakTest {
-
-  static final String ASYNC_TASK_THREAD = "AsyncTask #1";
-  static final String ASYNC_TASK_CLASS = "android.os.AsyncTask";
-  static final String EXECUTOR_FIELD_1 = "SERIAL_EXECUTOR";
-  static final String EXECUTOR_FIELD_2 = "sDefaultExecutor";
-
-  @Parameterized.Parameters public static Collection<Object[]> data() {
-    return asList(new Object[][] {
-        { ASYNC_TASK }, //
-        { ASYNC_TASK_MPREVIEW2 }, //
-        { ASYNC_TASK_M_POSTPREVIEW2 } //
-    });
-  }
-
-  private final TestUtil.HeapDumpFile heapDumpFile;
-  ExcludedRefs.BuilderWithParams excludedRefs;
-
-  public AsyncTaskLeakTest(TestUtil.HeapDumpFile heapDumpFile) {
-    this.heapDumpFile = heapDumpFile;
-  }
-
-  @Before public void setUp() {
-    excludedRefs = new ExcludedRefs.BuilderWithParams().clazz(WeakReference.class.getName())
-        .alwaysExclude()
-        .clazz("java.lang.ref.FinalizerReference")
-        .alwaysExclude();
-  }
-
-  @Test public void leakFound() {
-    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
-    assertTrue(result.leakFound);
-    assertFalse(result.excludedLeak);
-    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
-    assertEquals(Thread.class.getName(), gcRoot.className);
-    assertEquals(THREAD, gcRoot.holder);
-    assertThat(gcRoot.extra, containsString(ASYNC_TASK_THREAD));
-  }
-
-  @Test public void excludeThread() {
-    excludedRefs.thread(ASYNC_TASK_THREAD);
-    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
-    assertTrue(result.leakFound);
-    assertFalse(result.excludedLeak);
-    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
-    assertEquals(ASYNC_TASK_CLASS, gcRoot.className);
-    assertEquals(STATIC_FIELD, gcRoot.type);
-    assertTrue(gcRoot.referenceName.equals(EXECUTOR_FIELD_1) || gcRoot.referenceName.equals(
-        EXECUTOR_FIELD_2));
-  }
-
-  @Test public void excludeStatic() {
-    excludedRefs.thread(ASYNC_TASK_THREAD).named(ASYNC_TASK_THREAD);
-    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_1).named(EXECUTOR_FIELD_1);
-    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_2).named(EXECUTOR_FIELD_2);
-    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
-    assertTrue(result.leakFound);
-    assertTrue(result.excludedLeak);
-    LeakTrace leakTrace = result.leakTrace;
-    List<LeakTraceElement> elements = leakTrace.elements;
-    Exclusion exclusion = elements.get(0).exclusion;
-
-    List<String> expectedExclusions = asList(ASYNC_TASK_THREAD, EXECUTOR_FIELD_1, EXECUTOR_FIELD_2);
-    assertTrue(expectedExclusions.contains(exclusion.name));
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java
deleted file mode 100644
index ba62c2ad..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java
+++ /dev/null
@@ -1,101 +0,0 @@
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.io.HprofBuffer;
-
-import java.io.UnsupportedEncodingException;
-import java.util.List;
-
-public final class FakeHprofBuffer implements HprofBuffer {
-  private List<Byte> byteList;
-  private List<byte[]> byteArrayList;
-
-  private int[] intsToRead;
-  private int intIndex = -1;
-  private String[] stringsToRead;
-  private int stringIndex = -1;
-
-  public void setIntsToRead(int... ints) {
-    intsToRead = ints;
-    intIndex = 0;
-  }
-
-  public void setStringsToRead(String... strings) {
-    stringsToRead = strings;
-    stringIndex = 0;
-  }
-
-  @Override
-  public byte readByte() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public void read(byte[] bytes) {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public void readSubSequence(byte[] bytes, int start, int length) {
-    if (stringsToRead == null || stringIndex < 0 || stringIndex >= stringsToRead.length) {
-      throw new UnsupportedOperationException("no bytes to read");
-    }
-
-    String s = stringsToRead[stringIndex++];
-    try {
-      System.arraycopy(s.getBytes("UTF-16BE"), start, bytes, 0, length);
-    } catch (UnsupportedEncodingException e) {
-      throw new UnsupportedOperationException(e);
-    }
-  }
-
-  @Override
-  public char readChar() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public short readShort() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public int readInt() {
-    if (intsToRead == null || intIndex < 0 || intIndex >= intsToRead.length) {
-      throw new UnsupportedOperationException("no bytes to read");
-    }
-    return intsToRead[intIndex++];
-  }
-
-  @Override
-  public long readLong() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public float readFloat() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public double readDouble() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public void setPosition(long l) {}
-
-  @Override
-  public long position() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public boolean hasRemaining() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public long remaining() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
deleted file mode 100644
index 03178cbe..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
+++ /dev/null
@@ -1,146 +0,0 @@
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.ArrayInstance;
-import com.squareup.haha.perflib.ClassInstance;
-import com.squareup.haha.perflib.ClassObj;
-import com.squareup.haha.perflib.Field;
-import com.squareup.haha.perflib.Snapshot;
-import com.squareup.haha.perflib.Type;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public class HahaHelperTest {
-  private static final int STRING_CLASS_ID = 100;
-  private static final int CHAR_ARRAY_CLASS_ID = 101;
-  private static final int STRING_INSTANCE_ID = 102;
-  private static final int VALUE_ARRAY_INSTANCE_ID = 103;
-
-  private static final int VALUE_ARRAY_LENGTH = 6;
-  private static final int COUNT_VALUE = 5;
-  private static final int OFFSET_VALUE = 1;
-
-  private FakeHprofBuffer buffer;
-  private Snapshot snapshot;
-
-  @Before
-  public void setUp() {
-    buffer = new FakeHprofBuffer();
-
-    snapshot = new Snapshot(buffer);
-    // set HPROF identifier size; required for Object instance field lookups
-    // cf. https://java.net/downloads/heap-snapshot/hprof-binary-format.html
-    snapshot.setIdSize(4);
-  }
-
-  @Test
-  public void readStringOffsetFromHeapDumpInstance() {
-    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
-    buffer.setStringsToRead("abcdef");
-
-    addStringClassToSnapshotWithFields(snapshot, new Field[]{
-            new Field(Type.INT, "count"),
-            new Field(Type.INT, "offset"),
-            new Field(Type.OBJECT, "value")
-    });
-
-    ClassInstance stringInstance = createStringInstance();
-    createCharArrayValueInstance();
-
-    String actual = HahaHelper.asString(stringInstance);
-    assertTrue(actual.equals("bcdef"));
-  }
-
-  @Test
-  public void defaultToZeroStringOffsetWhenHeapDumpInstanceIsMissingOffsetValue() {
-    buffer.setIntsToRead(COUNT_VALUE, VALUE_ARRAY_INSTANCE_ID);
-    buffer.setStringsToRead("abcdef");
-
-    addStringClassToSnapshotWithFields(snapshot, new Field[]{
-            new Field(Type.INT, "count"),
-            new Field(Type.OBJECT, "value")
-    });
-
-    ClassInstance stringInstance = createStringInstance();
-    createCharArrayValueInstance();
-
-    String actual = HahaHelper.asString(stringInstance);
-    assertTrue(actual.equals("abcde"));
-  }
-
-  @Test
-  public void defaultToZeroStringOffsetWhenReadingMPreview2HeapDump() {
-    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
-    buffer.setStringsToRead("abcdef");
-
-    addStringClassToSnapshotWithFields(snapshot, new Field[]{
-            new Field(Type.INT, "count"),
-            new Field(Type.INT, "offset"),
-            new Field(Type.OBJECT, "value")
-    });
-
-    ClassInstance stringInstance = createStringInstance();
-    createCharArrayValueInstance_M_Preview2();
-
-    String actual = HahaHelper.asString(stringInstance);
-    assertTrue(actual.equals("abcde"));
-  }
-
-  @Test
-  public void throwExceptionWhenMissingCharArrayValueForStringInMPreview2HeapDump() {
-    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
-    buffer.setStringsToRead("abcdef");
-
-    addStringClassToSnapshotWithFields(snapshot, new Field[]{
-            new Field(Type.INT, "count"),
-            new Field(Type.INT, "offset"),
-            new Field(Type.OBJECT, "value")
-    });
-
-    ClassInstance stringInstance = createStringInstance();
-    createObjectValueInstance_M_Preview2();
-
-    try {
-      HahaHelper.asString(stringInstance);
-      fail("this test should have thrown UnsupportedOperationException");
-    }
-    catch (UnsupportedOperationException uoe) {
-      String message = uoe.getMessage();
-      assertTrue(message.equals("Could not find char array in " + stringInstance));
-    }
-  }
-
-  private void addStringClassToSnapshotWithFields(Snapshot snapshot, Field[] fields) {
-    ClassObj charArrayClass = new ClassObj(0, null, "char[]", 0);
-    snapshot.addClass(CHAR_ARRAY_CLASS_ID, charArrayClass);
-
-    ClassObj stringClass = new ClassObj(0, null, "string", 0);
-    stringClass.setFields(fields);
-    snapshot.addClass(STRING_CLASS_ID, stringClass);
-  }
-
-  private void createCharArrayValueInstance() {
-    ArrayInstance valueArrayInstance = new ArrayInstance(0, null, Type.CHAR, VALUE_ARRAY_LENGTH, 0);
-    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID, valueArrayInstance);
-  }
-
-  private void createCharArrayValueInstance_M_Preview2() {
-    ArrayInstance valueInstance = new ArrayInstance(0, null, Type.CHAR, VALUE_ARRAY_LENGTH, 0);
-    snapshot.addInstance(STRING_INSTANCE_ID + 16, valueInstance);
-  }
-
-  private void createObjectValueInstance_M_Preview2() {
-    ClassInstance valueInstance = new ClassInstance(0, null, 0);
-    snapshot.addInstance(STRING_INSTANCE_ID + 16, valueInstance);
-  }
-
-  private ClassInstance createStringInstance() {
-    ClassInstance stringInstance = new ClassInstance(STRING_INSTANCE_ID, null, 100);
-    stringInstance.setClassId(STRING_CLASS_ID);
-    snapshot.addInstance(0, stringInstance);
-    return stringInstance;
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
deleted file mode 100644
index 0d5607d8..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.RootObj;
-import com.squareup.haha.perflib.Snapshot;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-
-import static com.squareup.haha.perflib.RootType.NATIVE_STATIC;
-import static com.squareup.haha.perflib.RootType.SYSTEM_CLASS;
-import static java.util.Arrays.asList;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class HeapAnalyzerTest {
-  private static final ExcludedRefs NO_EXCLUDED_REFS = null;
-  private static final List<RootObj> DUP_ROOTS =
-          asList(new RootObj(SYSTEM_CLASS, 6L),
-                  new RootObj(SYSTEM_CLASS, 5L),
-                  new RootObj(SYSTEM_CLASS, 3L),
-                  new RootObj(SYSTEM_CLASS, 5L),
-                  new RootObj(NATIVE_STATIC, 3L));
-
-  private HeapAnalyzer heapAnalyzer;
-
-  @Before
-  public void setUp() {
-    heapAnalyzer = new HeapAnalyzer(NO_EXCLUDED_REFS);
-  }
-
-  @Test
-  public void ensureUniqueRoots() {
-    Snapshot snapshot = createSnapshot(DUP_ROOTS);
-
-    heapAnalyzer.deduplicateGcRoots(snapshot);
-
-    Collection<RootObj> uniqueRoots = snapshot.getGCRoots();
-    assertThat(uniqueRoots).hasSize(4);
-
-    List<Long> rootIds = new ArrayList<>();
-    for (RootObj root : uniqueRoots) {
-      rootIds.add(root.getId());
-    }
-    Collections.sort(rootIds);
-
-    // 3 appears twice because even though two RootObjs have the same id, they're different types.
-    assertThat(rootIds).containsExactly(3L, 3L, 5L, 6L);
-  }
-
-  private Snapshot createSnapshot(List<RootObj> gcRoots) {
-    Snapshot snapshot = new Snapshot(null);
-    for (RootObj root : gcRoots) {
-      snapshot.addRoot(root);
-    }
-    return snapshot;
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java
deleted file mode 100644
index a414687d..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package com.squareup.leakcanary;
-
-import java.lang.ref.WeakReference;
-import java.util.Arrays;
-import java.util.Collection;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_MPREVIEW2;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_M_POSTPREVIEW2;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER_IGNORED;
-import static com.squareup.leakcanary.TestUtil.analyze;
-import static org.junit.Assert.assertEquals;
-
-/**
- * This test makes sure there is no regression on the retained size calculation.
- */
-@RunWith(Parameterized.class) //
-public class RetainedSizeTest {
-
-  @Parameterized.Parameters public static Collection<Object[]> data() {
-    return Arrays.asList(new Object[][] {
-        { ASYNC_TASK, 207_407 }, //
-        { ASYNC_TASK_MPREVIEW2, 1_604 }, //
-        { ASYNC_TASK_M_POSTPREVIEW2, 1_870 }, //
-        { SERVICE_BINDER, 378 }, //
-        { SERVICE_BINDER_IGNORED, 378 }, //
-    });
-  }
-
-  private final TestUtil.HeapDumpFile heapDumpFile;
-  private final long expectedRetainedHeapSize;
-  ExcludedRefs.BuilderWithParams excludedRefs;
-
-  public RetainedSizeTest(TestUtil.HeapDumpFile heapDumpFile, long expectedRetainedHeapSize) {
-    this.heapDumpFile = heapDumpFile;
-    this.expectedRetainedHeapSize = expectedRetainedHeapSize;
-  }
-
-  @Before public void setUp() {
-    excludedRefs = new ExcludedRefs.BuilderWithParams().clazz(WeakReference.class.getName())
-        .alwaysExclude()
-        .clazz("java.lang.ref.FinalizerReference")
-        .alwaysExclude();
-  }
-
-  @Test public void leakFound() {
-    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
-    assertEquals(expectedRetainedHeapSize, result.retainedHeapSize);
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/ServiceBinderLeakTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/ServiceBinderLeakTest.java
deleted file mode 100644
index a54feeb1..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/ServiceBinderLeakTest.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.lang.ref.WeakReference;
-import org.junit.Before;
-import org.junit.Test;
-
-import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.OBJECT;
-import static com.squareup.leakcanary.LeakTraceElement.Type.INSTANCE_FIELD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER_IGNORED;
-import static com.squareup.leakcanary.TestUtil.analyze;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-/**
- * leak_service_binder_ignored.hprof contains a "normal" leak when binding to a service, where
- * leak_service_binder.hprof contains a leak where a binder is leaked by a static field.
- */
-public class ServiceBinderLeakTest {
-
-  ExcludedRefs.BuilderWithParams excludedRefs;
-
-  @Before public void setUp() {
-    excludedRefs = new ExcludedRefs.BuilderWithParams().clazz(WeakReference.class.getName())
-        .alwaysExclude()
-        .clazz("java.lang.ref.FinalizerReference")
-        .alwaysExclude();
-  }
-
-  @Test public void realBinderLeak() {
-    excludedRefs.rootClass("android.os.Binder").alwaysExclude();
-
-    AnalysisResult result = analyze(SERVICE_BINDER, excludedRefs);
-
-    assertTrue(result.leakFound);
-    assertFalse(result.excludedLeak);
-    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
-    assertEquals(STATIC_FIELD, gcRoot.type);
-    assertEquals("com.example.leakcanary.LeakyService", gcRoot.className);
-    assertEquals(CLASS, gcRoot.holder);
-  }
-
-  @Test public void ignorableBinderLeak() {
-    excludedRefs.rootClass("android.os.Binder");
-
-    AnalysisResult result = analyze(SERVICE_BINDER_IGNORED, excludedRefs);
-
-    assertTrue(result.leakFound);
-    assertTrue(result.excludedLeak);
-    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
-    assertEquals(INSTANCE_FIELD, gcRoot.type);
-    assertEquals("com.example.leakcanary.LeakyService$MyBinder", gcRoot.className);
-    assertEquals(OBJECT, gcRoot.holder);
-  }
-
-  @Test public void alwaysIgnorableBinderLeak() {
-    excludedRefs.rootClass("android.os.Binder").alwaysExclude();
-
-    AnalysisResult result = analyze(SERVICE_BINDER_IGNORED, excludedRefs);
-
-    assertFalse(result.leakFound);
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
deleted file mode 100644
index e3666e5d..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.File;
-import java.net.URL;
-
-final class TestUtil {
-
-  enum HeapDumpFile {
-    ASYNC_TASK("leak_asynctask.hprof", "dc983a12-d029-4003-8890-7dd644c664c5"),
-    ASYNC_TASK_MPREVIEW2("leak_asynctask_mpreview2.hprof", "1114018e-e154-435f-9a3d-da63ae9b47fa"),
-    ASYNC_TASK_M_POSTPREVIEW2("leak_asynctask_m_postpreview2.hprof",
-        "25ae1778-7c1d-4ec7-ac50-5cce55424069"),
-
-    SERVICE_BINDER("leak_service_binder.hprof", "b3abfae6-2c53-42e1-b8c1-96b0558dbeae"),
-    SERVICE_BINDER_IGNORED("leak_service_binder_ignored.hprof",
-        "6e524414-9581-4ce7-8690-e8ddf8b82454"),;
-
-    private final String filename;
-    private final String referenceKey;
-
-    HeapDumpFile(String filename, String referenceKey) {
-      this.filename = filename;
-      this.referenceKey = referenceKey;
-    }
-
-  }
-
-  static File fileFromName(String filename) {
-    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
-    URL url = classLoader.getResource(filename);
-    return new File(url.getPath());
-  }
-
-  static AnalysisResult analyze(HeapDumpFile heapDumpFile, ExcludedRefs.BuilderWithParams excludedRefs) {
-    File file = fileFromName(heapDumpFile.filename);
-    String referenceKey = heapDumpFile.referenceKey;
-    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(excludedRefs.build());
-    AnalysisResult result = heapAnalyzer.checkForLeak(file, referenceKey);
-    if (result.failure != null) {
-      result.failure.printStackTrace();
-    }
-    if (result.leakTrace != null) {
-      System.out.println(result.leakTrace);
-    }
-    return result;
-  }
-
-  private TestUtil() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
new file mode 100644
index 00000000..4593d28e
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
@@ -0,0 +1,65 @@
+package leakcanary.internal
+
+import leakcanary.AnalyzerProgressListener
+import leakcanary.AnalyzerProgressListener.Step
+import leakcanary.CanaryLog
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.HeapDump
+import leakcanary.LeakingInstance
+import leakcanary.HeapAnalyzer
+import leakcanary.internal.HeapDumpFile.MULTIPLE_LEAKS
+import org.junit.Test
+
+class HeapAnalyzerTest {
+
+  @Test
+  fun checkForLeaks() {
+    CanaryLog.logger = object : CanaryLog.Logger {
+      override fun d(
+        message: String,
+        vararg args: Any?
+      ) {
+        println(String.format(message, *args))
+      }
+
+      override fun d(
+        throwable: Throwable?,
+        message: String,
+        vararg args: Any?
+      ) {
+        throwable!!.printStackTrace()
+      }
+
+    }
+    var time = System.nanoTime()
+    val file =
+      fileFromName(MULTIPLE_LEAKS.filename)
+    val heapAnalyzer = HeapAnalyzer(object : AnalyzerProgressListener {
+      override fun onProgressUpdate(step: Step) {
+        val now = System.nanoTime()
+        val elapsed = (now - time) / 1000000
+        time = now
+        println("New step $step, last step done after $elapsed ms")
+      }
+    })
+
+    val heapDump = HeapDump.builder(file)
+        .excludedRefs(defaultExcludedRefs.build())
+        .build()
+    val leaks = heapAnalyzer.checkForLeaks(heapDump, emptyList())
+
+    val now = System.nanoTime()
+    val elapsed = (now - time) / 1000000
+    println("Last step done after $elapsed ms")
+
+    println("result: $leaks")
+
+    require(leaks is HeapAnalysisSuccess)
+    require(leaks.retainedInstances.size == 5)
+    leaks.retainedInstances.forEach {
+      require(it is LeakingInstance) {
+        "$it was expected to be a LeakingInstance"
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
new file mode 100644
index 00000000..41bfc8e6
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
@@ -0,0 +1,36 @@
+package leakcanary.internal
+
+import leakcanary.ExcludedRefs
+import java.io.File
+import java.lang.ref.PhantomReference
+import java.lang.ref.SoftReference
+import java.lang.ref.WeakReference
+
+internal enum class HeapDumpFile constructor(
+  val filename: String
+) {
+  MULTIPLE_LEAKS("multiple_leaks.hprof"),
+}
+
+internal fun fileFromName(filename: String): File {
+  val classLoader = Thread.currentThread()
+      .contextClassLoader
+  val url = classLoader.getResource(filename)
+  return File(url.path)
+}
+
+val defaultExcludedRefs = ExcludedRefs.builder()
+    .clazz(WeakReference::class.java.name)
+    .alwaysExclude()
+    .clazz(SoftReference::class.java.name)
+    .alwaysExclude()
+    .clazz(PhantomReference::class.java.name)
+    .alwaysExclude()
+    .clazz("java.lang.ref.Finalizer")
+    .alwaysExclude()
+    .clazz("java.lang.ref.FinalizerReference")
+    .alwaysExclude()
+    .thread("FinalizerWatchdogDaemon")
+    .alwaysExclude()
+    .thread("main")
+    .alwaysExclude()
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof
deleted file mode 100644
index 548f3a2a..00000000
Binary files a/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof and /dev/null differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_service_binder.hprof b/leakcanary-analyzer/src/test/resources/leak_service_binder.hprof
deleted file mode 100644
index af1dab18..00000000
Binary files a/leakcanary-analyzer/src/test/resources/leak_service_binder.hprof and /dev/null differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_service_binder_ignored.hprof b/leakcanary-analyzer/src/test/resources/leak_service_binder_ignored.hprof
deleted file mode 100644
index cdb867c4..00000000
Binary files a/leakcanary-analyzer/src/test/resources/leak_service_binder_ignored.hprof and /dev/null differ
diff --git a/leakcanary-analyzer/src/test/resources/multiple_leaks.hprof b/leakcanary-analyzer/src/test/resources/multiple_leaks.hprof
new file mode 100644
index 00000000..2ecde1b7
Binary files /dev/null and b/leakcanary-analyzer/src/test/resources/multiple_leaks.hprof differ
diff --git a/leakcanary-android-core/build.gradle b/leakcanary-android-core/build.gradle
new file mode 100644
index 00000000..45727de7
--- /dev/null
+++ b/leakcanary-android-core/build.gradle
@@ -0,0 +1,39 @@
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+
+dependencies {
+  api project(':leakcanary-analyzer-core')
+  api project(':leakcanary-leaksentry')
+  api project(':leakcanary-analyzer')
+
+  implementation deps.androidx.annotation
+  implementation deps.androidx.core
+  implementation deps.kotlin.stdlib
+
+  testImplementation deps.junit
+  testImplementation deps.mockito
+  testImplementation deps.mockito_kotlin
+}
+
+def gitSha() {
+  return 'git rev-parse --short HEAD'.execute().text.trim()
+}
+
+android {
+  resourcePrefix 'leak_canary_'
+  compileSdkVersion versions.compileSdk
+  defaultConfig {
+    minSdkVersion versions.minSdk
+    buildConfigField "String", "LIBRARY_VERSION", "\"${rootProject.ext.VERSION_NAME}\""
+    buildConfigField "String", "GIT_SHA", "\"${gitSha()}\""
+    consumerProguardFiles 'consumer-proguard-rules.pro'
+  }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    error 'ObsoleteSdkInt'
+    check 'Interoperability'
+  }
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android/consumer-proguard-rules.pro b/leakcanary-android-core/consumer-proguard-rules.pro
similarity index 100%
rename from leakcanary-android/consumer-proguard-rules.pro
rename to leakcanary-android-core/consumer-proguard-rules.pro
diff --git a/leakcanary-android-core/gradle.properties b/leakcanary-android-core/gradle.properties
new file mode 100644
index 00000000..f11d5355
--- /dev/null
+++ b/leakcanary-android-core/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-android-core
+POM_NAME=LeakCanary for Android - Core
+POM_PACKAGING=aar
diff --git a/leakcanary-android-core/src/main/AndroidManifest.xml b/leakcanary-android-core/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..f0668164
--- /dev/null
+++ b/leakcanary-android-core/src/main/AndroidManifest.xml
@@ -0,0 +1,77 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.leakcanary.core"
+    >
+
+  <!-- To store the heap dumps and leak analysis results. -->
+  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+  <!-- To allow starting foreground services on Android P+ - https://developer.android.com/preview/behavior-changes#fg-svc -->
+  <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
+
+  <application>
+    <service
+        android:name="leakcanary.internal.AnalysisResultService"
+        android:exported="false"
+        />
+
+    <provider
+        android:name="leakcanary.internal.LeakCanaryFileProvider"
+        android:authorities="com.squareup.leakcanary.fileprovider.${applicationId}"
+        android:exported="false"
+        android:grantUriPermissions="true"
+        >
+      <meta-data
+          android:name="android.support.FILE_PROVIDER_PATHS"
+          android:resource="@xml/leak_canary_file_paths"/>
+    </provider>
+
+    <activity
+        android:name="leakcanary.internal.activity.LeakActivity"
+        android:icon="@mipmap/leak_canary_icon"
+        android:label="@string/leak_canary_display_activity_label"
+        android:taskAffinity="com.squareup.leakcanary.${applicationId}"
+        android:theme="@style/leak_canary_LeakCanary.Base"
+        />
+
+    <activity-alias
+        android:name="leakcanary.internal.activity.LeakLauncherActivity"
+        android:enabled="@bool/leak_canary_add_launcher_icon"
+        android:icon="@mipmap/leak_canary_icon"
+        android:label="@string/leak_canary_display_activity_label"
+        android:targetActivity="leakcanary.internal.activity.LeakActivity"
+        android:taskAffinity="com.squareup.leakcanary.${applicationId}"
+        android:theme="@style/leak_canary_LeakCanary.Base"
+        >
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+        <category android:name="android.intent.category.LAUNCHER"/>
+      </intent-filter>
+    </activity-alias>
+
+    <activity
+        android:name="leakcanary.internal.RequestStoragePermissionActivity"
+        android:excludeFromRecents="true"
+        android:icon="@mipmap/leak_canary_icon"
+        android:label="@string/leak_canary_storage_permission_activity_label"
+        android:taskAffinity="com.squareup.leakcanary.${applicationId}"
+        android:theme="@style/leak_canary_Theme.Transparent"
+        />
+  </application>
+</manifest>
diff --git a/leakcanary-android-core/src/main/ic_launcher-web.png b/leakcanary-android-core/src/main/ic_launcher-web.png
new file mode 100644
index 00000000..15b9d890
Binary files /dev/null and b/leakcanary-android-core/src/main/ic_launcher-web.png differ
diff --git a/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt b/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt
new file mode 100644
index 00000000..ecdccdc5
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt
@@ -0,0 +1,719 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import android.os.Build.MANUFACTURER
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH
+import android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1
+import android.os.Build.VERSION_CODES.JELLY_BEAN
+import android.os.Build.VERSION_CODES.JELLY_BEAN_MR2
+import android.os.Build.VERSION_CODES.KITKAT
+import android.os.Build.VERSION_CODES.LOLLIPOP
+import android.os.Build.VERSION_CODES.LOLLIPOP_MR1
+import android.os.Build.VERSION_CODES.M
+import android.os.Build.VERSION_CODES.N
+import android.os.Build.VERSION_CODES.N_MR1
+import android.os.Build.VERSION_CODES.O
+import android.os.Build.VERSION_CODES.O_MR1
+import android.os.Build.VERSION_CODES.P
+import leakcanary.internal.HeapDumpTrigger
+import leakcanary.internal.LeakCanaryUtils.HUAWEI
+import leakcanary.internal.LeakCanaryUtils.LENOVO
+import leakcanary.internal.LeakCanaryUtils.LG
+import leakcanary.internal.LeakCanaryUtils.MEIZU
+import leakcanary.internal.LeakCanaryUtils.MOTOROLA
+import leakcanary.internal.LeakCanaryUtils.NVIDIA
+import leakcanary.internal.LeakCanaryUtils.SAMSUNG
+import leakcanary.internal.LeakCanaryUtils.VIVO
+import java.lang.ref.PhantomReference
+import java.lang.ref.SoftReference
+import java.lang.ref.WeakReference
+import java.util.EnumSet
+
+/**
+ * This class is a work in progress. You can help by reporting leak traces that seem to be caused
+ * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
+ *
+ * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
+ * manufacturer implementation, they usually share their builds across multiple models, and the
+ * leaks eventually get fixed in newer versions.
+ *
+ * Most app developers should use [.createAppDefaults]. However, you can also pick the
+ * leaks you want to ignore by creating an [EnumSet] that matches your needs and calling
+ * [.createBuilder]
+ */
+// Public API.
+enum class AndroidExcludedRefs constructor(internal val applies: Boolean = true) {
+
+  // ######## Android SDK Excluded refs ########
+
+  ACTIVITY_CLIENT_RECORD__NEXT_IDLE(SDK_INT in KITKAT..LOLLIPOP) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.app.ActivityThread\$ActivityClientRecord", "nextIdle")
+          .reason(
+              "Android AOSP sometimes keeps a reference to a destroyed activity as a"
+                  + " nextIdle client record in the android.app.ActivityThread.mActivities map."
+                  + " Not sure what's going on there, input welcome."
+          )
+    }
+  },
+
+  SPAN_CONTROLLER(SDK_INT <= KITKAT) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      val reason =
+        ("Editor inserts a special span, which has a reference to the EditText. That span is a"
+            + " NoCopySpan, which makes sure it gets dropped when creating a new"
+            + " SpannableStringBuilder from a given CharSequence."
+            + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
+            + " bundle. Prior to KitKat, that copy was done using the SpannableString"
+            + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
+            + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
+            + " reference to the textview and therefore the entire view hierarchy & activity"
+            + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
+            + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
+            + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
+            + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.")
+      excluded.instanceField("android.widget.Editor\$EasyEditSpanController", "this$0")
+          .reason(reason)
+      excluded.instanceField("android.widget.Editor\$SpanController", "this$0")
+          .reason(reason)
+    }
+  },
+
+  MEDIA_SESSION_LEGACY_HELPER__SINSTANCE(SDK_INT == LOLLIPOP) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance")
+          .reason(
+              "MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
+                  + " keeps a reference to the context it's given the first time"
+                  + " MediaSessionLegacyHelper.getHelper() is called."
+                  + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
+                  + " calling context.getApplicationContext()."
+                  + " Fix: https://github.com/android/platform_frameworks_base/commit"
+                  + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
+                  + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
+                  + " in Application.onCreate() and pass it the application context."
+          )
+    }
+  },
+
+  TEXT_LINE__SCACHED(SDK_INT <= LOLLIPOP_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("android.text.TextLine", "sCached")
+          .reason(
+              "TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
+                  + " at least two bugs that created memory leaks by not correctly clearing the"
+                  + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
+                  + " https://github.com/android/platform_frameworks_base/commit"
+                  + "/893d6fe48d37f71e683f722457bea646994a10"
+                  + " The second was fixed, not released yet:"
+                  + " https://github.com/android/platform_frameworks_base/commit"
+                  + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
+                  + " To fix this, you could access TextLine.sCached and clear the pool every now"
+                  + " and then (e.g. on activity destroy)."
+          )
+    }
+  },
+
+  BLOCKING_QUEUE {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      val reason = ("A thread waiting on a blocking queue will leak the last"
+          + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
+          + " keeps a local reference to the last message it received. That message then gets"
+          + " recycled and can be used again. As long as all messages are recycled after being"
+          + " used, this won't be a problem, because these references are cleared when being"
+          + " recycled. However, dialogs create template Message instances to be copied when a"
+          + " message needs to be sent. These Message templates holds references to the dialog"
+          + " listeners, which most likely leads to holding a reference onto the activity in some"
+          + " way. Dialogs never recycle their template Message, assuming these Message instances"
+          + " will get GCed when the dialog is GCed."
+          + " The combination of these two things creates a high potential for memory leaks as soon"
+          + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
+          + " sleep for a long time."
+          + " To fix this, you could post empty messages to the idle handler threads from time to"
+          + " time. This won't be easy because you cannot access all handler threads, but a library"
+          + " that is widely used should consider doing this for its own handler threads. This leaks"
+          + " has been shown to happen in both Dalvik and ART.")
+      excluded.instanceField("android.os.Message", "obj")
+          .reason(reason)
+      excluded.instanceField("android.os.Message", "next")
+          .reason(reason)
+      excluded.instanceField("android.os.Message", "target")
+          .reason(reason)
+    }
+  },
+
+  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT in ICE_CREAM_SANDWICH_MR1..O_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      val reason = ("When we detach a view that receives keyboard input, the InputMethodManager"
+          + " leaks a reference to it until a new view asks for keyboard input."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
+          + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414")
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView")
+          .reason(reason)
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView")
+          .reason(reason)
+      excluded.instanceField(
+          "android.view.inputmethod.InputMethodManager",
+          "mServedInputConnection"
+      )
+          .reason(reason)
+    }
+  },
+
+  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT in ICE_CREAM_SANDWICH_MR1..P) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView")
+          .reason(
+              "The singleton InputMethodManager is holding a reference to mCurRootView long"
+                  + " after the activity has been destroyed."
+                  + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
+                  + "#issuecomment-100579429"
+                  + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414"
+          )
+    }
+  },
+
+  LAYOUT_TRANSITION(SDK_INT in ICE_CREAM_SANDWICH..LOLLIPOP_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.animation.LayoutTransition$1", "val\$parent")
+          .reason(
+              "LayoutTransition leaks parent ViewGroup through"
+                  + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
+                  + " window is destroyed. Tracked here:"
+                  + " https://code.google.com/p/android/issues/detail?id=171830"
+          )
+    }
+  },
+
+  SPELL_CHECKER_SESSION(SDK_INT in JELLY_BEAN..N) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0")
+          .reason(
+              "SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
+                  + " SpellCheckerSession is closed before the service is connected."
+                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542"
+          )
+    }
+  },
+
+  SPELL_CHECKER(SDK_INT == LOLLIPOP_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.widget.SpellChecker$1", "this$0")
+          .reason(
+              "SpellChecker holds on to a detached view that points to a destroyed activity."
+                  + " mSpellRunnable is being enqueued, and that callback should be removed when "
+                  + " closeSession() is called. Maybe closeSession() wasn't called, or maybe it was "
+                  + " called after the view was detached."
+          )
+    }
+  },
+
+  ACTIVITY_CHOOSE_MODEL(SDK_INT in ICE_CREAM_SANDWICH_MR1..LOLLIPOP_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      val reason = ("ActivityChooserModel holds a static reference to the last set"
+          + " ActivityChooserModelPolicy which can be an activity context."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
+          + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0")
+      excluded.instanceField(
+          "android.support.v7.internal.widget.ActivityChooserModel",
+          "mActivityChoserModelPolicy"
+      )
+          .reason(reason)
+      excluded.instanceField("android.widget.ActivityChooserModel", "mActivityChoserModelPolicy")
+          .reason(reason)
+    }
+  },
+
+  SPEECH_RECOGNIZER(SDK_INT < LOLLIPOP) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.speech.SpeechRecognizer\$InternalListener", "this$0")
+          .reason(
+              "Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
+                  + " class and leaked the SpeechRecognizer which leaked an activity context."
+                  + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+                  + " /b37866db469e81aca534ff6186bdafd44352329b"
+          )
+    }
+  },
+
+  ACCOUNT_MANAGER(SDK_INT <= O_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.accounts.AccountManager\$AmsTask\$Response", "this$1")
+          .reason(
+              "AccountManager\$AmsTask\$Response is a stub and is held in memory by native code,"
+                  + " probably because the reference to the response in the other process hasn't been"
+                  + " cleared."
+                  + " AccountManager\$AmsTask is holding on to the activity reference to use for"
+                  + " launching a new sub- Activity."
+                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
+                  + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
+                  + " with the returned future to to get the result and correctly start an activity"
+                  + " when it's available."
+          )
+    }
+  },
+
+  MEDIA_SCANNER_CONNECTION(SDK_INT <= LOLLIPOP_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.media.MediaScannerConnection", "mContext")
+          .reason(
+              "The static method MediaScannerConnection.scanFile() takes an activity context"
+                  + " but the service might not disconnect after the activity has been destroyed."
+                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
+                  + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
+                  + " application context. Call connect() and disconnect() manually."
+          )
+    }
+  },
+
+  USER_MANAGER__SINSTANCE(SDK_INT in JELLY_BEAN_MR2..N_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.os.UserManager", "mContext")
+          .reason(
+              "UserManager has a static sInstance field that creates an instance and caches it"
+                  + " the first time UserManager.get() is called. This instance is created with the"
+                  + " outer context (which is an activity base context)."
+                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
+                  + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
+                  + "/27db46850b708070452c0ce49daf5f79503fbde6"
+                  + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
+                  + " UserManager instance gets cached with a reference to the application context."
+          )
+    }
+  },
+
+  APP_WIDGET_HOST_CALLBACKS(SDK_INT < LOLLIPOP_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.appwidget.AppWidgetHost\$Callbacks", "this$0")
+          .reason(
+              "android.appwidget.AppWidgetHost\$Callbacks is a stub and is held in memory native"
+                  + " code. The reference to the `mContext` was not being cleared, which caused the"
+                  + " Callbacks instance to retain this reference"
+                  + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+                  + "/7a96f3c917e0001ee739b65da37b2fadec7d7765"
+          )
+    }
+  },
+
+  AUDIO_MANAGER(SDK_INT <= LOLLIPOP_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.media.AudioManager$1", "this$0")
+          .reason(
+              "Prior to Android M, VideoView required audio focus from AudioManager and"
+                  + " never abandoned it, which leaks the Activity context through the AudioManager."
+                  + " The root of the problem is that AudioManager uses whichever"
+                  + " context it receives, which in the case of the VideoView example is an Activity,"
+                  + " even though it only needs the application's context. The issue is fixed in"
+                  + " Android M, and the AudioManager now uses the application's context."
+                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
+                  + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2"
+          )
+    }
+  },
+
+  EDITTEXT_BLINK_MESSAGEQUEUE(SDK_INT <= LOLLIPOP_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.widget.Editor\$Blink", "this$0")
+          .reason(
+              "The EditText Blink of the Cursor is implemented using a callback and Messages,"
+                  + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
+                  + " contains a blinking cursor is detached, a message is posted with a delay after the"
+                  + " dialog has been closed and as a result leaks the Activity."
+                  + " This can be fixed manually by calling TextView.setCursorVisible(false) in the"
+                  + " dismiss() method of the dialog."
+                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
+                  + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
+                  + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/"
+          )
+    }
+  },
+
+  CONNECTIVITY_MANAGER__SINSTANCE(SDK_INT <= M) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.net.ConnectivityManager", "sInstance")
+          .reason(
+              "ConnectivityManager has a sInstance field that is set when the first"
+                  + " ConnectivityManager instance is created. ConnectivityManager has a mContext field."
+                  + " When calling activity.getSystemService(Context.CONNECTIVITY_SERVICE) , the first"
+                  + " ConnectivityManager instance is created with the activity context and stored in"
+                  + " sInstance. That activity context then leaks forever."
+                  + " Until this is fixed, app developers can prevent this leak by making sure the"
+                  + " ConnectivityManager is first created with an App Context. E.g. in some static"
+                  + " init do: context.getApplicationContext()"
+                  + ".getSystemService(Context.CONNECTIVITY_SERVICE)"
+                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=198852"
+                  + " Introduced here: https://github.com/android/platform_frameworks_base/commit/"
+                  + "e0bef71662d81caaaa0d7214fb0bef5d39996a69"
+          )
+    }
+  },
+
+  ACCESSIBILITY_NODE_INFO__MORIGINALTEXT(SDK_INT in O..O_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.view.accessibility.AccessibilityNodeInfo", "mOriginalText")
+          .reason(
+              "AccessibilityNodeInfo has a static sPool of AccessibilityNodeInfo. When"
+                  + " AccessibilityNodeInfo instances are released back in the pool,"
+                  + " AccessibilityNodeInfo.clear() does not clear the mOriginalText field, which"
+                  + " causes spans to leak which in turns causes TextView.ChangeWatcher to leak and the"
+                  + " whole view hierarchy. Introduced here: https://android.googlesource.com/platform/"
+                  + "frameworks/base/+/193520e3dff5248ddcf8435203bf99d2ba667219%5E%21/core/java/"
+                  + "android/view/accessibility/AccessibilityNodeInfo.java"
+          )
+    }
+  },
+
+  BACKDROP_FRAME_RENDERER__MDECORVIEW(SDK_INT in N..O) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("com.android.internal.policy.BackdropFrameRenderer", "mDecorView")
+          .reason(
+              "When BackdropFrameRenderer.releaseRenderer() is called, there's an unknown case"
+                  + " where mRenderer becomes null but mChoreographer doesn't and the thread doesn't"
+                  + " stop and ends up leaking mDecorView which itself holds on to a destroyed"
+                  + " activity"
+          )
+    }
+  },
+
+  // ######## Manufacturer specific Excluded refs ########
+
+  INSTRUMENTATION_RECOMMEND_ACTIVITY(MEIZU == MANUFACTURER && SDK_INT in LOLLIPOP..LOLLIPOP_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("android.app.Instrumentation", "mRecommendActivity")
+          .reason(
+              "Instrumentation would leak com.android.internal.app.RecommendActivity (in"
+                  + " framework.jar) in Meizu FlymeOS 4.5 and above, which is based on Android 5.0 and "
+                  + " above"
+          )
+    }
+  },
+
+  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER(
+      MOTOROLA == MANUFACTURER && SDK_INT in KITKAT..LOLLIPOP_MR1
+  ) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      if (MOTOROLA == MANUFACTURER && SDK_INT == KITKAT) {
+        excluded.instanceField("android.app.admin.DevicePolicyManager\$SettingsObserver", "this$0")
+            .reason(
+                "DevicePolicyManager keeps a reference to the context it has been created with"
+                    + " instead of extracting the application context. In this Motorola build,"
+                    + " DevicePolicyManager has an inner SettingsObserver class that is a content"
+                    + " observer, which is held into memory by a binder transport object."
+            )
+      }
+    }
+  },
+
+  SPEN_GESTURE_MANAGER(SAMSUNG == MANUFACTURER && SDK_INT == KITKAT) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext")
+          .reason(
+              "SpenGestureManager has a static mContext field that leaks a reference to the" + " activity. Yes, a STATIC mContext field."
+          )
+    }
+  },
+
+  GESTURE_BOOST_MANAGER(HUAWEI == MANUFACTURER && SDK_INT in N..N_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("android.gestureboost.GestureBoostManager", "mContext")
+          .reason(
+              "GestureBoostManager is a static singleton that leaks an activity context." + " Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756"
+          )
+    }
+  },
+
+  INPUT_METHOD_MANAGER__LAST_SERVED_VIEW(HUAWEI == MANUFACTURER && SDK_INT in M..O_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      val reason =
+        "HUAWEI added a mLastSrvView field to InputMethodManager" + " that leaks a reference to the last served view."
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mLastSrvView")
+          .reason(reason)
+    }
+  },
+
+  CLIPBOARD_UI_MANAGER__SINSTANCE(SAMSUNG == MANUFACTURER && SDK_INT in KITKAT..LOLLIPOP) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.sec.clipboard.ClipboardUIManager", "mContext")
+          .reason(
+              "ClipboardUIManager is a static singleton that leaks an activity context."
+                  + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
+                  + " , so that the ClipboardUIManager instance gets cached with a reference to the"
+                  + " application context. Example: https://gist.github.com/cypressious/"
+                  + "91c4fb1455470d803a602838dfcd5774"
+          )
+    }
+  },
+
+  SEM_CLIPBOARD_MANAGER__MCONTEXT(SAMSUNG == MANUFACTURER && SDK_INT in KITKAT..N) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField(
+          "com.samsung.android.content.clipboard.SemClipboardManager",
+          "mContext"
+      )
+          .reason(
+              "SemClipboardManager is held in memory by an anonymous inner class" + " implementation of android.os.Binder, thereby leaking an activity context."
+          )
+    }
+  },
+
+  SEM_EMERGENCY_MANAGER__MCONTEXT(SAMSUNG == MANUFACTURER && SDK_INT in KITKAT..N) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("com.samsung.android.emergencymode.SemEmergencyManager", "mContext")
+          .reason(
+              "SemEmergencyManager is a static singleton that leaks a DecorContext." + " Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d"
+          )
+    }
+  },
+
+  BUBBLE_POPUP_HELPER__SHELPER(LG == MANUFACTURER && SDK_INT in KITKAT..LOLLIPOP) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("android.widget.BubblePopupHelper", "sHelper")
+          .reason(
+              "A static helper for EditText bubble popups leaks a reference to the latest" + " focused view."
+          )
+    }
+  },
+
+  LGCONTEXT__MCONTEXT(LG == MANUFACTURER && SDK_INT == LOLLIPOP) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("com.lge.systemservice.core.LGContext", "mContext")
+          .reason("LGContext is a static singleton that leaks an activity context.")
+    }
+  },
+
+  AW_RESOURCE__SRESOURCES(SAMSUNG == MANUFACTURER && SDK_INT == KITKAT) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      // AwResource#setResources() is called with resources that hold a reference to the
+      // activity context (instead of the application context) and doesn't clear it.
+      // Not sure what's going on there, input welcome.
+      excluded.staticField("com.android.org.chromium.android_webview.AwResource", "sResources")
+    }
+  },
+
+  MAPPER_CLIENT(NVIDIA == MANUFACTURER && SDK_INT == KITKAT) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient\$ServiceClient", "this$0")
+          .reason(
+              "Not sure exactly what ControllerMapper is about, but there is an anonymous"
+                  + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
+                  + " ControllerMapper.MapperClient which leaks the activity context."
+          )
+    }
+  },
+
+  TEXT_VIEW__MLAST_HOVERED_VIEW(SAMSUNG == MANUFACTURER && SDK_INT in KITKAT..O) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("android.widget.TextView", "mLastHoveredView")
+          .reason(
+              "mLastHoveredView is a static field in TextView that leaks the last hovered" + " view."
+          )
+    }
+  },
+
+  PERSONA_MANAGER(SAMSUNG == MANUFACTURER && SDK_INT == KITKAT) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.os.PersonaManager", "mContext")
+          .reason(
+              "android.app.LoadedApk.mResources has a reference to"
+                  + " android.content.res.Resources.mPersonaManager which has a reference to"
+                  + " android.os.PersonaManager.mContext which is an activity."
+          )
+    }
+  },
+
+  RESOURCES__MCONTEXT(SAMSUNG == MANUFACTURER && SDK_INT == KITKAT) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.content.res.Resources", "mContext")
+          .reason(
+              "In AOSP the Resources class does not have a context."
+                  + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
+                  + " instance that has a context that is the activity."
+                  + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184"
+          )
+    }
+  },
+
+  VIEW_CONFIGURATION__MCONTEXT(
+      SAMSUNG == MANUFACTURER && SDK_INT == KITKAT
+  ) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.view.ViewConfiguration", "mContext")
+          .reason(
+              "In AOSP the ViewConfiguration class does not have a context."
+                  + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
+                  + " ViewConfiguration instance that has a context that is the activity."
+                  + " Observed here: https://github.com/square/leakcanary/issues"
+                  + "/1#issuecomment-100324683"
+          )
+    }
+  },
+
+  SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL(
+      LENOVO == MANUFACTURER && SDK_INT == KITKAT //
+          || VIVO == MANUFACTURER && SDK_INT == LOLLIPOP_MR1
+  ) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("android.hardware.SystemSensorManager", "mAppContextImpl")
+          .reason(
+              "SystemSensorManager stores a reference to context"
+                  + " in a static field in its constructor."
+                  + " Fix: use application context to get SensorManager"
+          )
+    }
+  },
+
+  AUDIO_MANAGER__MCONTEXT_STATIC(
+      SAMSUNG == MANUFACTURER && SDK_INT == KITKAT
+  ) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("android.media.AudioManager", "mContext_static")
+          .reason(
+              "Samsung added a static mContext_static field to AudioManager, holds a reference"
+                  + " to the activity."
+                  + " Observed here: https://github.com/square/leakcanary/issues/32"
+          )
+    }
+  },
+
+  ACTIVITY_MANAGER_MCONTEXT(
+      SAMSUNG == MANUFACTURER && SDK_INT == LOLLIPOP_MR1
+  ) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("android.app.ActivityManager", "mContext")
+          .reason(
+              "Samsung added a static mContext field to ActivityManager, holds a reference"
+                  + " to the activity."
+                  + " Observed here: https://github.com/square/leakcanary/issues/177 Fix in comment:"
+                  + " https://github.com/square/leakcanary/issues/177#issuecomment-222724283"
+          )
+    }
+  },
+
+  // ######## General Excluded refs ########
+
+  SOFT_REFERENCES {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.clazz(WeakReference::class.java.name)
+          .alwaysExclude()
+      excluded.clazz(SoftReference::class.java.name)
+          .alwaysExclude()
+      excluded.clazz(PhantomReference::class.java.name)
+          .alwaysExclude()
+      excluded.clazz("java.lang.ref.Finalizer")
+          .alwaysExclude()
+      excluded.clazz("java.lang.ref.FinalizerReference")
+          .alwaysExclude()
+    }
+  },
+
+  FINALIZER_WATCHDOG_DAEMON {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
+      // reference to the object and it was about to be GCed.
+      excluded.thread("FinalizerWatchdogDaemon")
+          .alwaysExclude()
+    }
+  },
+
+  MAIN {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      // The main thread stack is ever changing so local variables aren't likely to hold references
+      // for long. If this is on the shortest path, it's probably that there's a longer path with
+      // a real leak.
+      excluded.thread("main")
+          .alwaysExclude()
+    }
+  },
+
+  LEAK_CANARY_THREAD {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.thread(HeapDumpTrigger.LEAK_CANARY_THREAD_NAME)
+          .alwaysExclude()
+    }
+  },
+
+  EVENT_RECEIVER__MMESSAGE_QUEUE {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
+      // the native peer of the receiver is using them.
+      // The main thread message queue is held on by the main Looper, but that might be a longer
+      // path. Let's not confuse people with a shorter path that is less meaningful.
+      excluded.instanceField(
+          "android.view.Choreographer\$FrameDisplayEventReceiver",
+          "mMessageQueue"
+      )
+          .alwaysExclude()
+    }
+  },
+
+  VIEWLOCATIONHOLDER_ROOT(SDK_INT == P) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      //  In Android P, ViewLocationHolder has an mRoot field that is not cleared in its clear()
+      // method.
+      // Introduced in https://github.com/aosp-mirror/platform_frameworks_base/commit/86b326012813f09d8f1de7d6d26c986a909de894
+      // Bug report: https://issuetracker.google.com/issues/112792715
+      excluded.instanceField(
+          "android.view.ViewGroup\$ViewLocationHolder",
+          "mRoot"
+      )
+    }
+  };
+
+  internal abstract fun add(excluded: ExcludedRefs.Builder)
+
+  companion object {
+
+    /**
+     * This returns the references in the leak path that should be ignored by all on Android.
+     */
+    fun createAndroidDefaults(): ExcludedRefs.Builder {
+      return createBuilder(
+          EnumSet.of(
+              SOFT_REFERENCES,
+              FINALIZER_WATCHDOG_DAEMON,
+              MAIN,
+              LEAK_CANARY_THREAD,
+              EVENT_RECEIVER__MMESSAGE_QUEUE
+          )
+      )
+    }
+
+    /**
+     * This returns the references in the leak path that can be ignored for app developers. This
+     * doesn't mean there is no memory leak, to the contrary. However, some leaks are caused by bugs
+     * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
+     * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
+     */
+    fun createAppDefaults(): ExcludedRefs.Builder {
+      return createBuilder(
+          EnumSet.allOf(AndroidExcludedRefs::class.java)
+      )
+    }
+
+    fun createBuilder(refs: EnumSet<AndroidExcludedRefs>): ExcludedRefs.Builder {
+      val excluded = ExcludedRefs.builder()
+      for (ref in refs) {
+        if (ref.applies) {
+          ref.add(excluded)
+          (excluded as ExcludedRefs.BuilderWithParams).named(ref.name)
+        }
+      }
+      return excluded
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/AndroidLabelers.kt b/leakcanary-android-core/src/main/java/leakcanary/AndroidLabelers.kt
new file mode 100644
index 00000000..79b0379b
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/AndroidLabelers.kt
@@ -0,0 +1,89 @@
+package leakcanary
+
+import android.app.Application
+import android.content.res.Resources.NotFoundException
+import android.view.View
+import leakcanary.HeapValue.IntValue
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.LeakNode.ChildNode
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import java.util.ArrayList
+
+enum class AndroidLabelers : Labeler {
+
+  FRAGMENT_LABELER {
+    override fun computeLabels(
+      parser: HprofParser,
+      node: ChildNode
+    ): List<String> {
+      val objectId = node.parent.instance
+      val record = parser.retrieveRecordById(objectId)
+      if (record is InstanceDumpRecord) {
+        val className = parser.className(record.classId)
+        if (className == "androidx.fragment.app.Fragment" || className == "android.app.Fragment") {
+          val instance = parser.hydrateInstance(record)
+          val mTag = instance.fieldValueOrNull<HeapValue>("mTag")
+          if (mTag is ObjectReference && !mTag.isNull) {
+            val mTag = parser.retrieveString(mTag)
+            if (mTag.isNotEmpty()) {
+              return listOf("Fragment.mTag=$mTag")
+            }
+          }
+        }
+      }
+      return emptyList()
+    }
+  };
+
+  class ViewLabeler(
+    private val application: Application
+  ) : Labeler {
+    override fun computeLabels(
+      parser: HprofParser,
+      node: ChildNode
+    ): List<String> {
+      val objectId = node.parent.instance
+      val record = parser.retrieveRecordById(objectId)
+      if (record is InstanceDumpRecord) {
+        val instance = parser.hydrateInstance(record)
+        if (instance.isInstanceOf(View::class.java.name)) {
+          val viewLabels = mutableListOf<String>()
+          val mID = instance.fieldValueOrNull<HeapValue>("mID")
+          if (mID is IntValue) {
+            if (mID.value != 0) {
+              try {
+                val name = application.resources.getResourceEntryName(mID.value)
+                viewLabels.add("View.mID=R.id.$name (${mID.value})")
+              } catch (ignored: NotFoundException) {
+                viewLabels.add("View.mID=${mID.value} (name not found)")
+              }
+            } else {
+              viewLabels.add("View.mID=0")
+            }
+          }
+          val mWindowAttachCount = instance.fieldValueOrNull<HeapValue>("mWindowAttachCount")
+          if (mWindowAttachCount is IntValue) {
+            viewLabels.add("View.mWindowAttachCount=${mWindowAttachCount.value}")
+          }
+          return viewLabels
+        }
+      }
+      return emptyList()
+    }
+  }
+
+  companion object {
+    fun defaultAndroidLabelers(application: Application): List<Labeler> {
+      val labelers = ArrayList<Labeler>()
+      labelers.add(Labeler.InstanceDefaultLabeler)
+      labelers.add(
+          ViewLabeler(
+              application
+          )
+      )
+      labelers.addAll(values())
+      return labelers
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/AndroidReachabilityInspectors.kt b/leakcanary-android-core/src/main/java/leakcanary/AndroidReachabilityInspectors.kt
new file mode 100644
index 00000000..506db68f
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/AndroidReachabilityInspectors.kt
@@ -0,0 +1,242 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import android.app.Activity
+import android.app.Application
+import android.app.Dialog
+import android.app.Fragment
+import android.os.MessageQueue
+import android.view.View
+import leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import java.util.ArrayList
+
+/**
+ * A set of default [Reachability.Inspector]s that knows about common AOSP and library
+ * classes.
+ *
+ * These are heuristics based on our experience and knownledge of AOSP and various library
+ * internals. We only make a reachability decision if we're reasonably sure such reachability is
+ * unlikely to be the result of a programmer mistake.
+ *
+ * For example, no matter how many mistakes we make in our code, the value of Activity.mDestroy
+ * will not be influenced by those mistakes.
+ */
+enum class AndroidReachabilityInspectors(private val inspectorClass: Class<out Reachability.Inspector>) {
+
+  VIEW(ViewInspector::class.java),
+
+  ACTIVITY(ActivityInspector::class.java),
+
+  DIALOG(DialogInspector::class.java),
+
+  APPLICATION(ApplicationInspector::class.java),
+
+  CLASSLOADER(ClassloaderInspector::class.java),
+
+  CLASS(ClassInspector::class.java),
+
+  FRAGMENT(FragmentInspector::class.java),
+
+  SUPPORT_FRAGMENT(SupportFragmentInspector::class.java),
+
+  MESSAGE_QUEUE(MessageQueueInspector::class.java),
+
+  MORTAR_PRESENTER(MortarPresenterInspector::class.java),
+
+  MAIN_THEAD(MainThreadInspector::class.java),
+
+  WINDOW(WindowInspector::class.java),
+
+  TOAST_TN(ToastTnInspector::class.java);
+
+  class ViewInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      if (!element.isInstanceOf(View::class.java)) {
+        return Reachability.unknown()
+      }
+
+      val mParent = element.getFieldReferenceValue("mParent") ?: return Reachability.unknown()
+
+      // This skips edge cases like Toast$TN.mNextView holding on to an unattached and uparented
+      // next toast view
+      if (mParent == "null") {
+        return Reachability.unknown()
+      }
+
+      return unreachableWhen(
+          element, View::class.java.name, "mAttachInfo", "null"
+      )
+    }
+  }
+
+  class ActivityInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      return unreachableWhen(
+          element, Activity::class.java.name, "mDestroyed", "true"
+      )
+    }
+  }
+
+  class DialogInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      return unreachableWhen(
+          element, Dialog::class.java.name, "mDecor", "null"
+      )
+    }
+  }
+
+  class ApplicationInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      return if (element.isInstanceOf(Application::class.java)) {
+        Reachability.reachable("Application is a singleton")
+      } else Reachability.unknown()
+    }
+  }
+
+  class ClassloaderInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      return if (element.isInstanceOf(ClassLoader::class.java)) {
+        Reachability.reachable("Classloader always reachable")
+      } else Reachability.unknown()
+    }
+  }
+
+  class ClassInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      val reference = element.reference
+      return if (reference != null && reference.type == STATIC_FIELD) {
+        Reachability.reachable("a class is always reachable")
+      } else Reachability.unknown()
+    }
+  }
+
+  class FragmentInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      return unreachableWhen(
+          element, Fragment::class.java.name, "mFragmentManager", "null"
+      )
+    }
+  }
+
+  class SupportFragmentInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      return unreachableWhen(
+          element, "android.support.v4.app.Fragment", "mFragmentManager", "null"
+      )
+    }
+  }
+
+  class MessageQueueInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      if (!element.isInstanceOf(MessageQueue::class.java)) {
+        return Reachability.unknown()
+      }
+      val mQuitting = element.getFieldReferenceValue("mQuitting")
+      // If the queue is not quitting, maybe it should actually have been, we don't know.
+      // However, if it's quitting, it is very likely that's not a bug.
+      return if ("true" == mQuitting) {
+        Reachability.unreachable("MessageQueue#mQuitting is true")
+      } else Reachability.unknown()
+    }
+  }
+
+  class MortarPresenterInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      if (!element.isInstanceOf("mortar.Presenter")) {
+        return Reachability.unknown()
+      }
+      val view = element.getFieldReferenceValue("view")
+
+      // Bugs in view code tends to cause Mortar presenters to still have a view when they actually
+      // should be a unreachable, so in that case we don't know their reachability status. However,
+      // when the view is null, we're pretty sure they should be unreachable.
+      return if ("null" == view) {
+        Reachability.unreachable("Presenter#view is null")
+      } else Reachability.unknown()
+    }
+  }
+
+  class MainThreadInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      if (!element.isInstanceOf(Thread::class.java)) {
+        return Reachability.unknown()
+      }
+      val name = element.getFieldReferenceValue("name")
+      return if ("main" == name) {
+        Reachability.reachable("the main thread always runs")
+      } else Reachability.unknown()
+    }
+  }
+
+  class WindowInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      return unreachableWhen(
+          element, "android.view.Window", "mDestroyed", "true"
+      )
+    }
+  }
+
+  class ToastTnInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      return if (element.isInstanceOf("android.widget.Toast\$TN")) {
+        Reachability.reachable("Toast.TN (Transient Notification) is always reachable")
+      } else Reachability.unknown()
+    }
+  }
+
+  companion object {
+
+    fun defaultAndroidInspectors(): List<Class<out Reachability.Inspector>> {
+      val inspectorClasses = ArrayList<Class<out Reachability.Inspector>>()
+      for (enumValue in AndroidReachabilityInspectors.values()) {
+        inspectorClasses.add(enumValue.inspectorClass)
+      }
+      return inspectorClasses
+    }
+
+    private fun unreachableWhen(
+      element: LeakTraceElement,
+      className: String,
+      fieldName: String,
+      unreachableValue: String
+    ): Reachability {
+      if (!element.isInstanceOf(className)) {
+        return Reachability.unknown()
+      }
+      val fieldValue = element.getFieldReferenceValue(fieldName) ?: return Reachability.unknown()
+      return if (fieldValue == unreachableValue) {
+        Reachability.unreachable(
+            simpleClassName(className) + "#" + fieldName + " is " + unreachableValue
+        )
+      } else {
+        Reachability.reachable(
+            simpleClassName(className) + "#" + fieldName + " is not " + unreachableValue
+        )
+      }
+    }
+
+    private fun simpleClassName(className: String): String {
+      val separator = className.lastIndexOf('.')
+      return if (separator == -1) {
+        className
+      } else {
+        className.substring(separator + 1)
+      }
+    }
+  }
+
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
new file mode 100644
index 00000000..db887f8f
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -0,0 +1,32 @@
+package leakcanary
+
+import android.content.Context
+import leakcanary.internal.InternalLeakCanary
+
+object LeakCanary {
+
+  data class Config(
+    val dumpHeap: Boolean = true,
+    val excludedRefs: ExcludedRefs = AndroidExcludedRefs.createAppDefaults().build(),
+    val reachabilityInspectorClasses: List<Class<out Reachability.Inspector>> = AndroidReachabilityInspectors.defaultAndroidInspectors(),
+    val labelers: List<Labeler> = AndroidLabelers.defaultAndroidLabelers(
+        InternalLeakCanary.application
+    ),
+    /**
+     * Note: this is currently not implemented in the new heap parser.
+     */
+    val computeRetainedHeapSize: Boolean = false
+  )
+
+  @Volatile
+  var config: Config = Config()
+
+  /**
+   * Whether the current process is the process running
+   * [leakcanary.internal.HeapAnalyzerServiceHeapAnalyzerService], which is a different process than the normal app process.
+   */
+  @Deprecated("This always returns false when using the new parser.")
+  fun isInAnalyzerProcess(context: Context): Boolean =
+    InternalLeakCanary.isInAnalyzerProcess(context)
+
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/AnalysisResultService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/AnalysisResultService.kt
new file mode 100644
index 00000000..278cd944
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/AnalysisResultService.kt
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.app.PendingIntent
+import android.content.Context
+import android.content.Intent
+import android.os.SystemClock
+import androidx.core.content.ContextCompat
+import com.squareup.leakcanary.core.R
+import leakcanary.CanaryLog
+import leakcanary.HeapAnalysis
+import leakcanary.HeapAnalysisFailure
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.HeapDump
+import leakcanary.Serializables
+import leakcanary.internal.activity.screen.HeapAnalysisFailureScreen
+import leakcanary.internal.activity.screen.HeapAnalysisListScreen
+import leakcanary.internal.activity.screen.HeapAnalysisSuccessScreen
+import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.LeakActivity
+import leakcanary.internal.activity.db.LeaksDbHelper
+import leakcanary.internal.activity.screen.GroupListScreen
+import leakcanary.save
+import java.io.File
+import java.text.SimpleDateFormat
+import java.util.Date
+import java.util.Locale
+
+/**
+ * Runs into the main process and handles the result of an analysis
+ */
+class AnalysisResultService : ForegroundService(
+    AnalysisResultService::class.java.name,
+    R.string.leak_canary_notification_reporting
+) {
+
+  override fun onHandleIntentInForeground(intent: Intent?) {
+    if (intent == null) {
+      CanaryLog.d("AnalysisResultService received a null intent, ignoring.")
+      return
+    }
+    if (!intent.hasExtra(HEAP_ANALYSIS_PATH_EXTRA)) {
+      onAnalysisResultFailure(getString(R.string.leak_canary_result_failure_no_disk_space));
+      return
+    }
+    val heapAnalysisFile = File(intent.getStringExtra(HEAP_ANALYSIS_PATH_EXTRA))
+
+    val heapAnalysis = Serializables.load<HeapAnalysis>(heapAnalysisFile)
+    heapAnalysisFile.delete()
+    if (heapAnalysis == null) {
+      onAnalysisResultFailure(getString(R.string.leak_canary_result_failure_no_file))
+      return
+    }
+
+    try {
+      onHeapAnalyzed(heapAnalysis)
+    } finally {
+      heapAnalysis.heapDump.heapDumpFile.delete()
+    }
+  }
+
+  private fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {
+    // TODO better log that include leakcanary version, exclusions, etc.
+    CanaryLog.d("%s", heapAnalysis)
+
+    val movedHeapDump = heapAnalysis.heapDump.buildUpon()
+        .heapDumpFile(renameHeapdump(heapAnalysis.heapDump))
+        .build()
+
+    val updatedHeapAnalysis = when (heapAnalysis) {
+      is HeapAnalysisFailure -> heapAnalysis.copy(heapDump = movedHeapDump)
+      is HeapAnalysisSuccess -> heapAnalysis.copy(heapDump = movedHeapDump)
+    }
+
+    val id = LeaksDbHelper(this)
+        .writableDatabase.use { db ->
+      HeapAnalysisTable.insert(db, updatedHeapAnalysis)
+    }
+
+    // TODO better text and res
+    val contentTitle = "Leak analysis done"
+
+    val screenToShow = when (heapAnalysis) {
+      is HeapAnalysisFailure -> HeapAnalysisFailureScreen(id)
+      is HeapAnalysisSuccess -> HeapAnalysisSuccessScreen(id)
+    }
+
+    val pendingIntent = LeakActivity.createPendingIntent(
+        this, arrayListOf(GroupListScreen(), HeapAnalysisListScreen(), screenToShow)
+    )
+
+    val contentText = getString(R.string.leak_canary_notification_message)
+    showNotification(pendingIntent, contentTitle, contentText)
+  }
+
+  /**
+   * Called when there was an error saving or loading the analysis result. This will be called from
+   * a background intent service thread.
+   */
+  private fun onAnalysisResultFailure(failureMessage: String) {
+    CanaryLog.d(failureMessage)
+    val failureTitle = getString(R.string.leak_canary_result_failure_title)
+    showNotification(null, failureTitle, failureMessage)
+  }
+
+  private fun showNotification(
+    pendingIntent: PendingIntent?,
+    contentTitle: String,
+    contentText: String
+  ) {
+    val notificationId = 0x00F06D
+    LeakCanaryUtils.showNotification(
+        this, contentTitle, contentText, pendingIntent, notificationId
+    )
+  }
+
+  private fun renameHeapdump(heapDump: HeapDump): File {
+    val fileName = SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'.hprof'", Locale.US).format(Date())
+
+    val newFile = File(heapDump.heapDumpFile.parent, fileName)
+    val renamed = heapDump.heapDumpFile.renameTo(newFile)
+    if (!renamed) {
+      CanaryLog.d(
+          "Could not rename heap dump file %s to %s", heapDump.heapDumpFile.path, newFile.path
+      )
+    }
+    return newFile
+  }
+
+  companion object {
+
+    private const val HEAP_ANALYSIS_PATH_EXTRA = "HEAP_ANALYSIS_PATH_EXTRA"
+
+    fun sendResult(
+      context: Context,
+      heapAnalysis: HeapAnalysis
+    ) {
+      val intent = Intent(context, AnalysisResultService::class.java)
+
+      val heapAnalysisFile = File(
+          heapAnalysis.heapDump.heapDumpFile.parentFile,
+          heapAnalysis.heapDump.heapDumpFile.name + ".analysis"
+      )
+
+      val saved = heapAnalysis.save(heapAnalysisFile)
+      if (saved) {
+        intent.putExtra(HEAP_ANALYSIS_PATH_EXTRA, heapAnalysisFile.absolutePath)
+      }
+      ContextCompat.startForegroundService(context, intent)
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidDebuggerControl.kt
similarity index 73%
rename from leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java
rename to leakcanary-android-core/src/main/java/leakcanary/internal/AndroidDebuggerControl.kt
index 7c58b997..0caf07d6 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidDebuggerControl.kt
@@ -13,12 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary;
+package leakcanary.internal
 
-import android.os.Debug;
+import android.os.Debug
 
-public final class AndroidDebuggerControl implements DebuggerControl {
-  @Override public boolean isDebuggerAttached() {
-    return Debug.isDebuggerConnected();
-  }
+internal class AndroidDebuggerControl : DebuggerControl {
+  override val isDebuggerAttached: Boolean
+    get() = Debug.isDebuggerConnected()
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
new file mode 100644
index 00000000..81073e2f
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.animation.Animator
+import android.animation.AnimatorListenerAdapter
+import android.app.Activity
+import android.app.Application
+import android.app.Notification
+import android.app.NotificationManager
+import android.content.Context
+import android.os.Debug
+import android.os.Handler
+import android.os.Looper
+import android.os.SystemClock
+import android.view.Gravity
+import android.view.LayoutInflater
+import android.view.View
+import android.widget.Toast
+import com.squareup.leakcanary.core.R
+import com.squareup.leakcanary.core.R.string
+import leakcanary.CanaryLog
+import java.io.File
+import java.util.concurrent.TimeUnit.SECONDS
+
+internal class AndroidHeapDumper(
+  context: Context,
+  private val leakDirectoryProvider: LeakDirectoryProvider
+) : HeapDumper {
+
+  private val context: Context = context.applicationContext
+  private val mainHandler: Handler = Handler(Looper.getMainLooper())
+
+  private var resumedActivity: Activity? = null
+
+  init {
+    val application = context.applicationContext as Application
+    application.registerActivityLifecycleCallbacks(object : ActivityLifecycleCallbacksAdapter() {
+      override fun onActivityResumed(activity: Activity) {
+        resumedActivity = activity
+      }
+
+      override fun onActivityPaused(activity: Activity) {
+        if (resumedActivity === activity) {
+          resumedActivity = null
+        }
+      }
+    })
+  }
+
+  override// Explicitly checking for named null.
+  fun dumpHeap(): File? {
+    val heapDumpFile = leakDirectoryProvider.newHeapDumpFile()
+
+    if (heapDumpFile === HeapDumper.RETRY_LATER) {
+      return HeapDumper.RETRY_LATER
+    }
+
+    val waitingForToast = FutureResult<Toast?>()
+    showToast(waitingForToast)
+
+    if (!waitingForToast.wait(5, SECONDS)) {
+      CanaryLog.d("Did not dump heap, too much time waiting for Toast.")
+      return HeapDumper.RETRY_LATER
+    }
+
+    val dumpingHeap = context.getString(string.leak_canary_notification_dumping)
+    val builder = Notification.Builder(context)
+        .setContentTitle(dumpingHeap)
+    val notification = LeakCanaryUtils.buildNotification(context, builder)
+    val notificationManager =
+      context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+    val notificationId = SystemClock.uptimeMillis()
+        .toInt()
+    notificationManager.notify(notificationId, notification)
+
+    val toast = waitingForToast.get()
+
+    try {
+      Debug.dumpHprofData(heapDumpFile!!.absolutePath)
+      cancelToast(toast)
+      notificationManager.cancel(notificationId)
+      return heapDumpFile
+    } catch (e: Exception) {
+      CanaryLog.d(e, "Could not dump heap")
+      // Abort heap dump
+      return HeapDumper.RETRY_LATER
+    }
+
+  }
+
+  private fun showToast(waitingForToast: FutureResult<Toast?>) {
+    mainHandler.post(Runnable {
+      val resumedActivity = resumedActivity
+      if (resumedActivity == null) {
+        waitingForToast.set(null)
+        return@Runnable
+      }
+      val toast = Toast(resumedActivity)
+      val iconSize = resumedActivity.resources.getDimensionPixelSize(
+          R.dimen.leak_canary_toast_icon_size
+      )
+      toast.setGravity(Gravity.CENTER_VERTICAL, 0, -iconSize)
+      toast.duration = Toast.LENGTH_LONG
+      val inflater = LayoutInflater.from(resumedActivity)
+      toast.view = inflater.inflate(R.layout.leak_canary_heap_dump_toast, null)
+      toast.show()
+
+      val toastIcon = toast.view.findViewById<View>(R.id.leak_canary_toast_icon)
+      toastIcon.translationY = -iconSize.toFloat()
+      toastIcon
+          .animate()
+          .translationY(0f)
+          .setListener(object : AnimatorListenerAdapter() {
+            override fun onAnimationEnd(animation: Animator) {
+              waitingForToast.set(toast)
+            }
+          })
+    })
+  }
+
+  private fun cancelToast(toast: Toast?) {
+    if (toast == null) {
+      return
+    }
+    mainHandler.post { toast.cancel() }
+  }
+}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/DebuggerControl.java b/leakcanary-android-core/src/main/java/leakcanary/internal/DebuggerControl.kt
similarity index 75%
rename from leakcanary-watcher/src/main/java/com/squareup/leakcanary/DebuggerControl.java
rename to leakcanary-android-core/src/main/java/leakcanary/internal/DebuggerControl.kt
index fdd03be2..00595886 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/DebuggerControl.java
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DebuggerControl.kt
@@ -13,18 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary;
+package leakcanary.internal
 
 /**
  * Gives the opportunity to skip checking if a reference is gone when the debugger is connected.
  * An attached debugger might retain references and create false positives.
  */
-public interface DebuggerControl {
-  DebuggerControl NONE = new DebuggerControl() {
-    @Override public boolean isDebuggerAttached() {
-      return false;
-    }
-  };
+internal interface DebuggerControl {
+
+  val isDebuggerAttached: Boolean
 
-  boolean isDebuggerAttached();
-}
\ No newline at end of file
+  companion object {
+    val NONE: DebuggerControl = object : DebuggerControl {
+      override val isDebuggerAttached: Boolean
+        get() = false
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
new file mode 100644
index 00000000..298ff949
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
@@ -0,0 +1,375 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.content.res.Resources
+import android.text.Html
+import android.text.SpannableStringBuilder
+import android.text.Spanned
+import android.text.format.DateUtils
+import android.view.View
+import android.view.ViewGroup
+import android.widget.BaseAdapter
+import android.widget.TextView
+import androidx.annotation.ColorRes
+import com.squareup.leakcanary.core.R
+import com.squareup.leakcanary.core.R.id
+import com.squareup.leakcanary.core.R.string
+import leakcanary.LeakTrace
+import leakcanary.LeakTraceElement
+import leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import leakcanary.Reachability
+import leakcanary.Reachability.Status.REACHABLE
+import leakcanary.Reachability.Status.UNKNOWN
+import leakcanary.Reachability.Status.UNREACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type
+import leakcanary.internal.DisplayLeakConnectorView.Type.END
+import leakcanary.internal.DisplayLeakConnectorView.Type.END_FIRST_UNREACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.HELP
+import leakcanary.internal.DisplayLeakConnectorView.Type.HELP_LEAK_GROUP
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_FIRST_UNREACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_LAST_REACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_REACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNKNOWN
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNREACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.START
+import leakcanary.internal.DisplayLeakConnectorView.Type.START_LAST_REACHABLE
+import leakcanary.internal.MoreDetailsView.Details.CLOSED
+import leakcanary.internal.MoreDetailsView.Details.NONE
+import leakcanary.internal.MoreDetailsView.Details.OPENED
+import leakcanary.internal.activity.db.LeakingInstanceTable.InstanceProjection
+import leakcanary.internal.navigation.inflate
+
+internal class DisplayLeakAdapter private constructor(
+  resources: Resources,
+  private val leakTrace: LeakTrace,
+  private val referenceName: String,
+  private val instanceProjections: List<InstanceProjection>
+) : BaseAdapter() {
+
+  private val isLeakGroup = instanceProjections.isNotEmpty()
+
+  constructor(
+    resources: Resources,
+    leakTrace: LeakTrace,
+    referenceName: String
+  ) : this(resources, leakTrace, referenceName, emptyList())
+
+  constructor(
+    resources: Resources,
+    leakTrace: LeakTrace,
+    instanceProjections: List<InstanceProjection>
+  ) : this(resources, leakTrace, "", instanceProjections)
+
+  private val opened = BooleanArray(TOP_ROW_COUNT + leakTrace.elements.size)
+
+  private val classNameColorHexString: String
+  private val leakColorHexString: String
+  private val referenceColorHexString: String
+  private val extraColorHexString: String
+  private val helpColorHexString: String
+
+  init {
+    classNameColorHexString = hexStringColor(resources, R.color.leak_canary_class_name)
+    leakColorHexString = hexStringColor(resources, R.color.leak_canary_leak)
+    referenceColorHexString = hexStringColor(resources, R.color.leak_canary_reference)
+    extraColorHexString = hexStringColor(resources, R.color.leak_canary_extra)
+    helpColorHexString = hexStringColor(resources, R.color.leak_canary_help)
+  }
+
+  override fun getView(
+    position: Int,
+    convertView: View?,
+    parent: ViewGroup
+  ): View {
+    return when (getItemViewType(position)) {
+      TOP_ROW -> {
+        val view = convertView ?: parent.inflate(R.layout.leak_canary_ref_top_row)
+        bindTopRow(view)
+        view
+      }
+      CONNECTOR_ROW -> {
+        val view = convertView ?: parent.inflate(R.layout.leak_canary_ref_row)
+        bindConnectorRow(view, position)
+        view
+      }
+      else -> {
+        val view = convertView ?: parent.inflate(R.layout.leak_canary_leak_row)
+        bindLeakInstanceRow(view, position)
+        view
+      }
+    }
+  }
+
+  private fun bindTopRow(view: View) {
+    val textView = view.findViewById<TextView>(id.leak_canary_row_text)
+    textView.text = view.context.packageName
+  }
+
+  private fun bindConnectorRow(
+    view: View,
+    position: Int
+  ) {
+    val titleView = view.findViewById<TextView>(R.id.leak_canary_row_title)
+    val detailView = view.findViewById<TextView>(R.id.leak_canary_row_details)
+    val connector = view.findViewById<DisplayLeakConnectorView>(R.id.leak_canary_row_connector)
+    val moreDetailsView = view.findViewById<MoreDetailsView>(R.id.leak_canary_row_more)
+
+    connector.setType(getConnectorType(position))
+
+    moreDetailsView.setDetails(
+        when {
+          isLeakGroup -> NONE
+          opened[position] -> OPENED
+          else -> CLOSED
+        }
+    )
+
+    if (opened[position]) {
+      detailView.visibility = View.VISIBLE
+    } else {
+      detailView.visibility = View.GONE
+    }
+
+    val resources = view.resources
+    if (position == TOP_ROW_COUNT - 1) {
+      titleView.text = if (isLeakGroup) {
+        Html.fromHtml(
+            """
+              <font color='$helpColorHexString'>
+                <b>Known likely causes of leak group</b>
+              </font>
+            """
+        )
+      } else {
+        Html.fromHtml(
+            """
+              <font color='$helpColorHexString'>
+                <b>${resources.getString(string.leak_canary_help_title)}</b>
+              </font>
+            """
+        )
+      }
+      val detailText = Html.fromHtml(
+          resources.getString(string.leak_canary_help_detail)
+      ) as SpannableStringBuilder
+      SquigglySpan.replaceUnderlineSpans(detailText, resources)
+      detailView.text = detailText
+    } else {
+      val isLast = position == (TOP_ROW_COUNT + leakTrace.elements.size) - 1
+
+      val elementIndex = elementIndex(position)
+      val element = leakTrace.elements[elementIndex]
+
+      val reachability = leakTrace.expectedReachability[elementIndex]
+      val maybeLeakCause = if (isLeakGroup) {
+        true
+      } else leakTrace.elementMayBeLeakCause(elementIndex)
+
+      val htmlTitle = htmlTitle(element, maybeLeakCause, reachability, resources)
+
+      titleView.text = htmlTitle
+
+      if (opened[position]) {
+        val htmlDetail = htmlDetails(isLast, element)
+        detailView.text = htmlDetail
+      }
+    }
+  }
+
+  private fun bindLeakInstanceRow(
+    view: View,
+    position: Int
+  ) {
+    val titleView = view.findViewById<TextView>(id.leak_canary_row_text)
+    val timeView = view.findViewById<TextView>(id.leak_canary_row_time)
+
+    val projection = instanceProjections[position - TOP_ROW_COUNT - leakTrace.elements.size]
+
+    titleView.text =
+      view.resources.getString(string.leak_canary_class_has_leaked, projection.classSimpleName)
+
+    timeView.text = DateUtils.formatDateTime(
+        view.context, projection.createdAtTimeMillis,
+        DateUtils.FORMAT_SHOW_TIME or DateUtils.FORMAT_SHOW_DATE
+    )
+  }
+
+  private fun htmlTitle(
+    element: LeakTraceElement,
+    maybeLeakCause: Boolean,
+    reachability: Reachability,
+    resources: Resources
+  ): Spanned {
+
+    val packageEnd = element.className.lastIndexOf('.')
+    var simpleName = element.getSimpleClassName()
+    simpleName = simpleName.replace("[]", "[ ]")
+    val styledClassName = "<font color='$classNameColorHexString'>$simpleName</font>"
+
+    var htmlString =
+      if (packageEnd != -1) "<font color='$extraColorHexString'>${element.className.substring(
+          0, packageEnd
+      )}</font>.$styledClassName" else styledClassName
+
+    htmlString += "<br>"
+
+    val reachabilityString = when (reachability.status) {
+      UNKNOWN -> "UNKNOWN"
+      REACHABLE -> "NO (${reachability.reason})"
+      UNREACHABLE -> "YES (${reachability.reason})"
+    }
+
+    val indentation = "&nbsp;".repeat(4)
+    htmlString += "$indentation<font color='$extraColorHexString'>Leaking: $reachabilityString</font><br>"
+
+    element.labels.forEach { label ->
+      htmlString += "$indentation<font color='$extraColorHexString'>$label</font><br>"
+    }
+
+    val reference = element.reference
+    if (reference != null) {
+      var referenceName = reference.displayName.replace("<".toRegex(), "&lt;")
+          .replace(">".toRegex(), "&gt;")
+
+      referenceName = if (maybeLeakCause) {
+        "<u><font color='$leakColorHexString'>$referenceName</font></u>"
+      } else {
+        "<font color='$referenceColorHexString'>$referenceName</font>"
+      }
+
+      if (reference.type == STATIC_FIELD) {
+        referenceName = "<i>$referenceName</i>"
+      }
+
+      htmlString +=  "$indentation$styledClassName.${if (maybeLeakCause) "<b>$referenceName</b>" else referenceName}"
+    }
+
+    val exclusion = element.exclusion
+    if (exclusion != null) {
+      htmlString += " (excluded)"
+    }
+    val builder = Html.fromHtml(htmlString) as SpannableStringBuilder
+    if (maybeLeakCause) {
+      SquigglySpan.replaceUnderlineSpans(builder, resources)
+    }
+
+    return builder
+  }
+
+  private fun htmlDetails(
+    isLeakingInstance: Boolean,
+    element: LeakTraceElement
+  ): Spanned {
+    var htmlString = ""
+    val exclusion = element.exclusion
+    if (exclusion != null) {
+      htmlString += "<br/><br/>Excluded by rule"
+      if (exclusion.name != null) {
+        htmlString += " <font color='#ffffff'>" + exclusion.name + "</font>"
+      }
+      htmlString += " matching <font color='#f3cf83'>" + exclusion.matching + "</font>"
+      if (exclusion.reason != null) {
+        htmlString += " because <font color='#f3cf83'>" + exclusion.reason + "</font>"
+      }
+    }
+    if (isLeakingInstance && referenceName != "") {
+      htmlString += " <font color='$extraColorHexString'>$referenceName</font>"
+    }
+
+    return Html.fromHtml(htmlString)
+  }
+
+  private fun getConnectorType(position: Int): Type {
+    if (position == TOP_ROW_COUNT - 1) {
+      return if (isLeakGroup) HELP_LEAK_GROUP else HELP
+    } else if (position == TOP_ROW_COUNT) {
+      if (leakTrace.expectedReachability.size == 1) {
+        return START_LAST_REACHABLE
+      }
+      val nextReachability = leakTrace.expectedReachability[elementIndex(position + 1)]
+      return if (nextReachability.status != Reachability.Status.REACHABLE) {
+        START_LAST_REACHABLE
+      } else START
+    } else {
+      val isLeakingInstance = position == count - 1
+      if (isLeakingInstance) {
+        val previousReachability = leakTrace.expectedReachability[elementIndex(position - 1)]
+        return if (previousReachability.status != Reachability.Status.UNREACHABLE) {
+          END_FIRST_UNREACHABLE
+        } else END
+      } else {
+        val reachability = leakTrace.expectedReachability[elementIndex(position)]
+        when (reachability.status) {
+          Reachability.Status.UNKNOWN -> return NODE_UNKNOWN
+          Reachability.Status.REACHABLE -> {
+            val nextReachability = leakTrace.expectedReachability[elementIndex(position + 1)]
+            return if (nextReachability.status != Reachability.Status.REACHABLE) {
+              NODE_LAST_REACHABLE
+            } else {
+              NODE_REACHABLE
+            }
+          }
+          Reachability.Status.UNREACHABLE -> {
+            val previousReachability = leakTrace.expectedReachability[elementIndex(position - 1)]
+            return if (previousReachability.status != Reachability.Status.UNREACHABLE) {
+              NODE_FIRST_UNREACHABLE
+            } else {
+              NODE_UNREACHABLE
+            }
+          }
+          else -> throw IllegalStateException("Unknown value: " + reachability.status)
+        }
+      }
+    }
+  }
+
+  fun toggleRow(position: Int) {
+    opened[position] = !opened[position]
+    notifyDataSetChanged()
+  }
+
+  override fun getCount() = TOP_ROW_COUNT + leakTrace.elements.size + instanceProjections.size
+
+  override fun getItem(position: Int) = null
+
+  private fun elementIndex(position: Int): Int {
+    return position - TOP_ROW_COUNT
+  }
+
+  override fun getViewTypeCount() = 3
+
+  override fun getItemViewType(position: Int) = when {
+    position == 0 -> TOP_ROW
+    position < TOP_ROW_COUNT + leakTrace.elements.size -> CONNECTOR_ROW
+    else -> LEAK_ROW
+  }
+
+  override fun getItemId(position: Int) = position.toLong()
+
+  companion object {
+
+    private const val TOP_ROW = 0
+    private const val CONNECTOR_ROW = 1
+    private const val LEAK_ROW = 2
+    private const val TOP_ROW_COUNT = 2
+
+    // https://stackoverflow.com/a/6540378/703646
+    private fun hexStringColor(resources: Resources, @ColorRes colorResId: Int): String {
+      return String.format("#%06X", 0xFFFFFF and resources.getColor(colorResId))
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt
new file mode 100644
index 00000000..69358d20
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt
@@ -0,0 +1,254 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.content.Context
+import android.graphics.Bitmap
+import android.graphics.Bitmap.Config.ARGB_8888
+import android.graphics.Canvas
+import android.graphics.Color
+import android.graphics.DashPathEffect
+import android.graphics.Paint
+import android.graphics.PorterDuff.Mode.CLEAR
+import android.graphics.PorterDuffXfermode
+import android.util.AttributeSet
+import android.view.View
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.DisplayLeakConnectorView.Type.END
+import leakcanary.internal.DisplayLeakConnectorView.Type.END_FIRST_UNREACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.HELP
+import leakcanary.internal.DisplayLeakConnectorView.Type.HELP_LEAK_GROUP
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_FIRST_UNREACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_LAST_REACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_REACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNKNOWN
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNREACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.START
+import leakcanary.internal.DisplayLeakConnectorView.Type.START_LAST_REACHABLE
+
+internal class DisplayLeakConnectorView(
+  context: Context,
+  attrs: AttributeSet
+) : View(context, attrs) {
+
+  private val classNamePaint: Paint
+  private val leakGroupRootPaint: Paint
+  private val leakPaint: Paint
+  private val clearPaint: Paint
+  private val referencePaint: Paint
+  private val strokeSize: Float
+  private val circleY: Float
+
+  private var type: Type? = null
+  private var cache: Bitmap? = null
+
+  enum class Type {
+    HELP,
+    HELP_LEAK_GROUP,
+    START,
+    START_LAST_REACHABLE,
+    NODE_UNKNOWN,
+    NODE_FIRST_UNREACHABLE,
+    NODE_UNREACHABLE,
+    NODE_REACHABLE,
+    NODE_LAST_REACHABLE,
+    END,
+    END_FIRST_UNREACHABLE
+  }
+
+  init {
+
+    val resources = resources
+
+    type = NODE_UNKNOWN
+    circleY = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_center_y)
+        .toFloat()
+    strokeSize = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_stroke_size)
+        .toFloat()
+
+    classNamePaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    classNamePaint.color = resources.getColor(R.color.leak_canary_class_name)
+    classNamePaint.strokeWidth = strokeSize
+
+    leakGroupRootPaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    leakGroupRootPaint.color = resources.getColor(R.color.leak_canary_class_name)
+    leakGroupRootPaint.strokeWidth = strokeSize
+    val pathLines = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_leak_dash_line)
+        .toFloat()
+    leakGroupRootPaint.pathEffect = DashPathEffect(floatArrayOf(pathLines, pathLines), 0f)
+
+    leakPaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    leakPaint.color = resources.getColor(R.color.leak_canary_leak)
+    leakPaint.style = Paint.Style.STROKE
+    leakPaint.strokeWidth = strokeSize
+
+    val pathGaps = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_leak_dash_gap)
+        .toFloat()
+    leakPaint.pathEffect = DashPathEffect(floatArrayOf(pathLines, pathGaps), 0f)
+
+    clearPaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    clearPaint.color = Color.TRANSPARENT
+    clearPaint.xfermode = CLEAR_XFER_MODE
+
+    referencePaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    referencePaint.color = resources.getColor(R.color.leak_canary_reference)
+    referencePaint.strokeWidth = strokeSize
+  }
+
+  override fun onDraw(canvas: Canvas) {
+    val width = measuredWidth
+    val height = measuredHeight
+
+    if (cache != null && (cache!!.width != width || cache!!.height != height)) {
+      cache!!.recycle()
+      cache = null
+    }
+
+    if (cache == null) {
+      cache = Bitmap.createBitmap(width, height, ARGB_8888)
+
+      val cacheCanvas = Canvas(cache!!)
+
+      when (type) {
+        NODE_UNKNOWN -> drawItems(cacheCanvas, leakPaint, leakPaint)
+        NODE_UNREACHABLE, NODE_REACHABLE -> drawItems(
+            cacheCanvas, referencePaint, referencePaint
+        )
+        NODE_FIRST_UNREACHABLE -> drawItems(
+            cacheCanvas, leakPaint, referencePaint
+        )
+        NODE_LAST_REACHABLE -> drawItems(
+            cacheCanvas, referencePaint, leakPaint
+        )
+        START -> {
+          drawStartLine(cacheCanvas)
+          drawItems(cacheCanvas, null, referencePaint)
+        }
+        START_LAST_REACHABLE -> {
+          drawStartLine(cacheCanvas)
+          drawItems(cacheCanvas, null, leakPaint)
+        }
+        END -> drawItems(cacheCanvas, referencePaint, null)
+        END_FIRST_UNREACHABLE -> drawItems(
+            cacheCanvas, leakPaint, null
+        )
+        HELP -> drawRoot(cacheCanvas, false)
+        HELP_LEAK_GROUP -> drawRoot(cacheCanvas, true)
+        else -> throw UnsupportedOperationException("Unknown type " + type!!)
+      }
+    }
+    canvas.drawBitmap(cache!!, 0f, 0f, null)
+  }
+
+  private fun drawStartLine(cacheCanvas: Canvas) {
+    val width = measuredWidth
+    val halfWidth = width / 2f
+    cacheCanvas.drawLine(halfWidth, 0f, halfWidth, circleY, classNamePaint)
+  }
+
+  private fun drawRoot(
+    cacheCanvas: Canvas,
+    leakGroup: Boolean
+  ) {
+    val width = measuredWidth
+    val height = measuredHeight
+    val halfWidth = width / 2f
+    val radiusClear = halfWidth - strokeSize / 2f
+    cacheCanvas.drawRect(0f, 0f, width.toFloat(), radiusClear, classNamePaint)
+    cacheCanvas.drawCircle(0f, radiusClear, radiusClear, clearPaint)
+    cacheCanvas.drawCircle(width.toFloat(), radiusClear, radiusClear, clearPaint)
+    cacheCanvas.drawLine(
+        halfWidth, 0f, halfWidth, height.toFloat(),
+        if (leakGroup) leakGroupRootPaint else classNamePaint
+    )
+  }
+
+  private fun drawItems(
+    cacheCanvas: Canvas,
+    arrowHeadPaint: Paint?,
+    nextArrowPaint: Paint?
+  ) {
+    if (arrowHeadPaint != null) {
+      drawArrowHead(cacheCanvas, arrowHeadPaint)
+    }
+    if (nextArrowPaint != null) {
+      drawNextArrowLine(cacheCanvas, nextArrowPaint)
+    }
+    drawInstanceCircle(cacheCanvas)
+  }
+
+  private fun drawArrowHead(
+    cacheCanvas: Canvas,
+    paint: Paint
+  ) {
+    // Circle center is at half height
+    val width = measuredWidth
+    val halfWidth = width / 2f
+    val circleRadius = width / 3f
+// Splitting the arrow head in two makes an isosceles right triangle.
+    // It's hypotenuse is side * sqrt(2)
+    val arrowHeight = halfWidth / 2 * SQRT_TWO
+    val halfStrokeSize = strokeSize / 2
+    val translateY = circleY - arrowHeight - circleRadius * 2 - strokeSize
+
+    val lineYEnd = circleY - circleRadius - strokeSize / 2
+    cacheCanvas.drawLine(halfWidth, 0f, halfWidth, lineYEnd, paint)
+    cacheCanvas.translate(halfWidth, translateY)
+    cacheCanvas.rotate(45f)
+    cacheCanvas.drawLine(
+        0f, halfWidth, halfWidth + halfStrokeSize, halfWidth,
+        paint
+    )
+    cacheCanvas.drawLine(halfWidth, 0f, halfWidth, halfWidth, paint)
+    cacheCanvas.rotate(-45f)
+    cacheCanvas.translate(-halfWidth, -translateY)
+  }
+
+  private fun drawNextArrowLine(
+    cacheCanvas: Canvas,
+    paint: Paint
+  ) {
+    val height = measuredHeight
+    val width = measuredWidth
+    val centerX = width / 2f
+    cacheCanvas.drawLine(centerX, circleY, centerX, height.toFloat(), paint)
+  }
+
+  private fun drawInstanceCircle(cacheCanvas: Canvas) {
+    val width = measuredWidth
+    val circleX = width / 2f
+    val circleRadius = width / 3f
+    cacheCanvas.drawCircle(circleX, circleY, circleRadius, classNamePaint)
+  }
+
+  fun setType(type: Type) {
+    if (type != this.type) {
+      this.type = type
+      if (cache != null) {
+        cache!!.recycle()
+        cache = null
+      }
+      invalidate()
+    }
+  }
+
+  companion object {
+
+    private val SQRT_TWO = Math.sqrt(2.0)
+        .toFloat()
+    private val CLEAR_XFER_MODE = PorterDuffXfermode(CLEAR)
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/ForegroundService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/ForegroundService.kt
new file mode 100644
index 00000000..d27575dc
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/ForegroundService.kt
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.app.IntentService
+import android.app.Notification
+import android.content.Intent
+import android.os.IBinder
+import android.os.SystemClock
+import com.squareup.leakcanary.core.R
+
+abstract class ForegroundService(
+  name: String,
+  private val notificationContentTitleResId: Int
+) : IntentService(name) {
+  private val notificationId: Int = SystemClock.uptimeMillis()
+      .toInt()
+
+  override fun onCreate() {
+    super.onCreate()
+    showForegroundNotification(
+        max = 100, progress = 0, indeterminate = true,
+        contentText = getString(R.string.leak_canary_notification_foreground_text)
+    )
+  }
+
+  protected fun showForegroundNotification(
+    max: Int,
+    progress: Int,
+    indeterminate: Boolean,
+    contentText: String
+  ) {
+    val builder = Notification.Builder(this)
+        .setContentTitle(getString(notificationContentTitleResId))
+        .setContentText(contentText)
+        .setProgress(max, progress, indeterminate)
+    val notification =
+      LeakCanaryUtils.buildNotification(this, builder)
+    startForeground(notificationId, notification)
+  }
+
+  override fun onHandleIntent(intent: Intent?) {
+    onHandleIntentInForeground(intent)
+  }
+
+  protected abstract fun onHandleIntentInForeground(intent: Intent?)
+
+  override fun onDestroy() {
+    super.onDestroy()
+    stopForeground(true)
+  }
+
+  override fun onBind(intent: Intent): IBinder? {
+    return null
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/FutureResult.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/FutureResult.kt
new file mode 100644
index 00000000..500b697f
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/FutureResult.kt
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import java.util.concurrent.CountDownLatch
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.atomic.AtomicReference
+
+internal class FutureResult<T> {
+
+  private val resultHolder: AtomicReference<T> = AtomicReference()
+  private val latch: CountDownLatch = CountDownLatch(1)
+
+  fun wait(
+    timeout: Long,
+    unit: TimeUnit
+  ): Boolean {
+    try {
+      return latch.await(timeout, unit)
+    } catch (e: InterruptedException) {
+      throw RuntimeException("Did not expect thread to be interrupted", e)
+    }
+
+  }
+
+  fun get(): T {
+    if (latch.count > 0) {
+      throw IllegalStateException("Call wait() and check its result")
+    }
+    return resultHolder.get()
+  }
+
+  fun set(result: T) {
+    resultHolder.set(result)
+    latch.countDown()
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzers.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzers.kt
new file mode 100644
index 00000000..ec3b8e0b
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzers.kt
@@ -0,0 +1,22 @@
+package leakcanary.internal
+
+import android.content.Context
+import android.content.Intent
+import androidx.core.content.ContextCompat
+import leakcanary.HeapDump
+
+object HeapAnalyzers {
+
+  const val HEAPDUMP_EXTRA = "HEAPDUMP_EXTRA"
+  private const val ANALYSIS_ACTION = "leakcanary.ANALYSIS_ACTION"
+
+  fun runAnalysis(
+    context: Context,
+    heapDump: HeapDump
+  ) {
+    val intent = Intent(ANALYSIS_ACTION)
+    intent.setPackage(context.packageName)
+    intent.putExtra(HEAPDUMP_EXTRA, heapDump)
+    ContextCompat.startForegroundService(context, intent)
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
new file mode 100644
index 00000000..aa3bfd0f
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -0,0 +1,156 @@
+package leakcanary.internal
+
+import android.app.Application
+import android.os.Handler
+import android.os.SystemClock
+import leakcanary.CanaryLog
+import leakcanary.GcTrigger
+import leakcanary.HeapDump
+import leakcanary.HeapDumpMemoryStore
+import leakcanary.LeakCanary.Config
+import leakcanary.RefWatcher
+
+internal class HeapDumpTrigger(
+  private val application: Application,
+  private val backgroundHandler: Handler,
+  private val debuggerControl: DebuggerControl,
+  private val refWatcher: RefWatcher,
+  private val leakDirectoryProvider: LeakDirectoryProvider,
+  private val gcTrigger: GcTrigger,
+  private val heapDumper: HeapDumper,
+  private val configProvider: () -> Config
+) {
+
+  @Volatile
+  var applicationVisible = false
+
+  fun registerToVisibilityChanges() {
+    application.registerVisibilityListener { applicationVisible ->
+      this.applicationVisible = applicationVisible
+      if (!applicationVisible) {
+        scheduleTick("app became invisible")
+      }
+    }
+  }
+
+  fun onReferenceRetained() {
+    scheduleTick("found new reference retained")
+  }
+
+  private fun tick(reason: String) {
+    CanaryLog.d("Checking retained references because %s", reason)
+    val config = configProvider()
+    // A tick will be rescheduled when this is turned back on.
+    if (!config.dumpHeap) {
+      return
+    }
+
+    val minLeaks = if (applicationVisible) MIN_LEAKS_WHEN_VISIBLE else MIN_LEAKS_WHEN_NOT_VISIBLE
+    var retainedKeys = refWatcher.retainedKeys
+    if (retainedKeys.size < minLeaks) {
+      // No need to scheduleTick, new refs always schedule one.
+      CanaryLog.d(
+          "Found %d retained references, which is less than the min of %d", retainedKeys.size,
+          minLeaks
+      )
+      return
+    }
+
+    if (debuggerControl.isDebuggerAttached) {
+      scheduleTick(
+          "debugger was attached",
+          WAIT_FOR_DEBUG_MILLIS
+      )
+      CanaryLog.d(
+          "Not checking for leaks while the debugger is attached, will retry in %d ms",
+          WAIT_FOR_DEBUG_MILLIS
+      )
+      return
+    }
+
+
+    if (leakDirectoryProvider.hasPendingHeapDump()) {
+      CanaryLog.d(
+          "Leak Analysis in progress, will retry in %d ms",
+          WAIT_FOR_PENDING_ANALYSIS_MILLIS
+      )
+      scheduleTick(
+          "had pending heap dump",
+          WAIT_FOR_PENDING_ANALYSIS_MILLIS
+      )
+      return
+    }
+    val gcStartUptimeMillis = SystemClock.uptimeMillis()
+    gcTrigger.runGc()
+    val gcDurationMillis = SystemClock.uptimeMillis() - gcStartUptimeMillis
+
+
+    retainedKeys = refWatcher.retainedKeys
+    if (retainedKeys.size < minLeaks) {
+      CanaryLog.d(
+          "Found %d retained references after GC, which is less than the min of %d",
+          retainedKeys.size,
+          minLeaks
+      )
+      return
+    }
+
+    HeapDumpMemoryStore.setRetainedKeysForHeapDump(retainedKeys)
+
+    CanaryLog.d(
+        "Found %d retained references, dumping the heap", retainedKeys.size
+    )
+    HeapDumpMemoryStore.heapDumpUptimeMillis = SystemClock.uptimeMillis()
+    val heapDumpFile = heapDumper.dumpHeap()
+    val heapDumpDurationMillis =
+      SystemClock.uptimeMillis() - HeapDumpMemoryStore.heapDumpUptimeMillis
+
+    if (heapDumpFile === HeapDumper.RETRY_LATER) {
+      CanaryLog.d(
+          "Failed to dump heap, will retry in %d ms",
+          WAIT_FOR_HEAP_DUMPER_MILLIS
+      )
+      scheduleTick(
+          "failed to dump heap",
+          WAIT_FOR_HEAP_DUMPER_MILLIS
+      )
+      return
+    }
+    refWatcher.removeRetainedKeys(retainedKeys)
+
+    val heapDump = HeapDump.builder(heapDumpFile!!)
+        .excludedRefs(config.excludedRefs)
+        .gcDurationMs(gcDurationMillis)
+        .heapDumpDurationMs(heapDumpDurationMillis)
+        .computeRetainedHeapSize(config.computeRetainedHeapSize)
+        .reachabilityInspectorClasses(config.reachabilityInspectorClasses)
+        .build()
+
+    HeapAnalyzers.runAnalysis(application, heapDump)
+  }
+
+  private fun scheduleTick(reason: String) {
+    backgroundHandler.post {
+      tick(reason)
+    }
+  }
+
+  private fun scheduleTick(
+    reason: String,
+    delayMillis: Long
+  ) {
+    backgroundHandler.postDelayed({
+      tick(reason)
+    }, delayMillis)
+  }
+
+  companion object {
+    const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
+    const val WAIT_FOR_PENDING_ANALYSIS_MILLIS = 20_000L
+    const val WAIT_FOR_DEBUG_MILLIS = 20_000L
+    const val WAIT_FOR_HEAP_DUMPER_MILLIS = 5_000L
+    const val MIN_LEAKS_WHEN_VISIBLE = 5
+    const val MIN_LEAKS_WHEN_NOT_VISIBLE = 1
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Preconditions.java b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumper.kt
similarity index 60%
rename from leakcanary-watcher/src/main/java/com/squareup/leakcanary/Preconditions.java
rename to leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumper.kt
index f7521e90..e41134a9 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Preconditions.java
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumper.kt
@@ -13,23 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary;
+package leakcanary.internal
 
-final class Preconditions {
+import java.io.File
+
+/** Dumps the heap into a file.  */
+internal interface HeapDumper {
 
   /**
-   * Returns instance unless it's null.
-   *
-   * @throws NullPointerException if instance is null
+   * @return a [File] referencing the dumped heap, or [.RETRY_LATER] if the heap could
+   * not be dumped.
    */
-  static <T> T checkNotNull(T instance, String name) {
-    if (instance == null) {
-      throw new NullPointerException(name + " must not be null");
-    }
-    return instance;
-  }
+  fun dumpHeap(): File?
 
-  private Preconditions() {
-    throw new AssertionError();
+  companion object {
+    val RETRY_LATER: File? = null
   }
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
new file mode 100644
index 00000000..30b668c5
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -0,0 +1,261 @@
+package leakcanary.internal
+
+import android.app.Application
+import android.app.Service
+import android.content.Context
+import android.content.Intent
+import android.content.pm.PackageInfo
+import android.content.pm.PackageManager
+import android.content.pm.ShortcutInfo.Builder
+import android.content.pm.ShortcutManager
+import android.graphics.drawable.Icon
+import android.os.Build
+import android.os.Build.VERSION
+import android.os.Build.VERSION_CODES
+import android.os.Handler
+import android.os.HandlerThread
+import android.text.format.Formatter
+import android.util.Log
+import com.squareup.leakcanary.core.BuildConfig
+import com.squareup.leakcanary.core.R
+import leakcanary.AnalysisResult
+import leakcanary.GcTrigger
+import leakcanary.HeapDump
+import leakcanary.LeakCanary
+import leakcanary.LeakSentry
+import leakcanary.internal.activity.LeakActivity
+
+internal object InternalLeakCanary : LeakSentryListener {
+
+  private const val DYNAMIC_SHORTCUT_ID = "com.squareup.leakcanary.dynamic_shortcut"
+
+  private lateinit var heapDumpTrigger: HeapDumpTrigger
+
+  lateinit var application: Application
+
+  @Volatile private var isInAnalyzerProcess: Boolean? = null
+
+  override fun onLeakSentryInstalled(application: Application) {
+    this.application = application
+    if (isInAnalyzerProcess(application)) {
+      return
+    }
+    val debuggerControl = AndroidDebuggerControl()
+
+    val leakDirectoryProvider =
+      LeakCanaryUtils.getLeakDirectoryProvider(application)
+    val heapDumper = AndroidHeapDumper(application, leakDirectoryProvider)
+
+    val gcTrigger = GcTrigger.Default
+
+    val configProvider = { LeakCanary.config }
+
+    val handlerThread = HandlerThread(HeapDumpTrigger.LEAK_CANARY_THREAD_NAME)
+    handlerThread.start()
+    val backgroundHandler = Handler(handlerThread.looper)
+
+    heapDumpTrigger = HeapDumpTrigger(
+        application, backgroundHandler, debuggerControl, LeakSentry.refWatcher,
+        leakDirectoryProvider, gcTrigger, heapDumper, configProvider
+    )
+    heapDumpTrigger.registerToVisibilityChanges()
+
+    addDynamicShortcut(application)
+  }
+
+  private fun addDynamicShortcut(application: Application) {
+    if (VERSION.SDK_INT < VERSION_CODES.N_MR1) {
+      return
+    }
+    if (!application.resources.getBoolean(R.bool.leak_canary_add_dynamic_shortcut)) {
+      return
+    }
+
+    val shortcutManager = application.getSystemService(ShortcutManager::class.java)!!
+    val dynamicShortcuts = shortcutManager.dynamicShortcuts
+
+    if (dynamicShortcuts.size >= shortcutManager.maxShortcutCountPerActivity) {
+      return
+    }
+
+    val shortcutInstalled =
+      dynamicShortcuts.any { shortcut -> shortcut.id == DYNAMIC_SHORTCUT_ID }
+
+    if (shortcutInstalled) {
+      return
+    }
+
+    val mainIntent = Intent(Intent.ACTION_MAIN, null)
+    mainIntent.addCategory(Intent.CATEGORY_LAUNCHER)
+    mainIntent.setPackage(application.packageName)
+    val activities = application.packageManager.queryIntentActivities(mainIntent, 0)
+
+    // Displayed on long tap on app icon
+    val longLabel: String
+    // Label when dropping shortcut to launcher
+    val shortLabel: String
+
+    val leakActivityLabel = application.getString(R.string.leak_canary_shortcut_label)
+
+    if (activities.isEmpty()) {
+      longLabel = leakActivityLabel
+      shortLabel = leakActivityLabel
+    } else {
+
+      val activity = activities.first()
+
+      val firstLauncherActivityLabel = if (activity.activityInfo.labelRes != 0) {
+        application.getString(activity.activityInfo.labelRes)
+      } else {
+        val applicationInfo = application.applicationInfo
+        if (applicationInfo.labelRes != 0) {
+          application.getString(applicationInfo.labelRes)
+        } else {
+          applicationInfo.nonLocalizedLabel.toString()
+        }
+      }
+      val fullLengthLabel = "$firstLauncherActivityLabel $leakActivityLabel"
+      // short label should be under 10 and long label under 25
+      if (fullLengthLabel.length > 10) {
+        if (fullLengthLabel.length <= 25) {
+          longLabel = fullLengthLabel
+          shortLabel = leakActivityLabel
+        } else {
+          longLabel = leakActivityLabel
+          shortLabel = leakActivityLabel
+        }
+      } else {
+        longLabel = fullLengthLabel
+        shortLabel = fullLengthLabel
+      }
+    }
+
+    val intent = LeakActivity.createIntent(application)
+    intent.action = "Dummy Action because Android is stupid"
+    val shortcut = Builder(application, DYNAMIC_SHORTCUT_ID)
+        .setLongLabel(longLabel)
+        .setShortLabel(shortLabel)
+        .setIcon(Icon.createWithResource(application, R.mipmap.leak_canary_icon))
+        .setIntent(intent)
+        .build()
+    shortcutManager.addDynamicShortcuts(listOf(shortcut))
+  }
+
+  override fun onReferenceRetained() {
+    if (this::heapDumpTrigger.isInitialized) {
+      heapDumpTrigger.onReferenceRetained()
+    }
+  }
+
+  /**
+   * Returns a string representation of the result of a heap analysis.
+   * Context instance needed because [onLeakSentryInstalled] is not called in the leakcanary
+   * process.
+   */
+  @Deprecated("Remove and build better rendering for new data structures.")
+  fun leakInfo(
+    context: Context,
+    heapDump: HeapDump,
+    result: AnalysisResult
+  ): String {
+    val packageManager = context.packageManager
+    val packageName = context.packageName
+    val packageInfo: PackageInfo
+    try {
+      packageInfo = packageManager.getPackageInfo(packageName, 0)
+    } catch (e: PackageManager.NameNotFoundException) {
+      throw RuntimeException(e)
+    }
+
+    val versionName = packageInfo.versionName
+    @Suppress("DEPRECATION")
+    val versionCode = packageInfo.versionCode
+    var info = "In $packageName:$versionName:$versionCode.\n"
+    var detailedString = ""
+    if (result.leakFound) {
+      if (result.excludedLeak) {
+        info += "* EXCLUDED LEAK.\n"
+      }
+      info += "* ${result.className!!}"
+      if (result.referenceName != "") {
+        info += " (${result.referenceName})"
+      }
+      info += " has leaked:\n${result.leakTrace!!.renderToString()}\n"
+      if (result.retainedHeapSize != AnalysisResult.RETAINED_HEAP_SKIPPED) {
+        info += "* Retaining: " + Formatter.formatShortFileSize(
+            context, result.retainedHeapSize
+        ) + ".\n"
+      }
+    } else if (result.failure != null) {
+      // We duplicate the library version & Sha information because bug reports often only contain
+      // the stacktrace.
+      info += "* FAILURE in ${BuildConfig.LIBRARY_VERSION} ${BuildConfig.GIT_SHA}:" + Log.getStackTraceString(
+          result.failure
+      ) + "\n"
+    } else {
+      info += "* NO LEAK FOUND.\n\n"
+    }
+
+    info += ("* Reference Key: "
+        + result.referenceKey
+        + "\n"
+        + "* Device: "
+        + Build.MANUFACTURER
+        + " "
+        + Build.BRAND
+        + " "
+        + Build.MODEL
+        + " "
+        + Build.PRODUCT
+        + "\n"
+        + "* Android Version: "
+        + Build.VERSION.RELEASE
+        + " API: "
+        + Build.VERSION.SDK_INT
+        + " LeakCanary: "
+        + BuildConfig.LIBRARY_VERSION
+        + " "
+        + BuildConfig.GIT_SHA
+        + "\n"
+        + "* Durations: watch="
+        + result.watchDurationMs
+        + "ms, gc="
+        + heapDump.gcDurationMs
+        + "ms, heap dump="
+        + heapDump.heapDumpDurationMs
+        + "ms, analysis="
+        + result.analysisDurationMs
+        + "ms"
+        + "\n"
+        + detailedString)
+
+    return info
+  }
+
+  /**
+   * Whether the current process is the process running the perflib heap analyzer, which is
+   * a different process than the normal app process.
+   *
+   * Note: We can't rely on [Application] being set here as [onLeakSentryInstalled] is called after
+   * [Application.onCreate]
+   */
+  fun isInAnalyzerProcess(context: Context): Boolean {
+    val analyzerServiceClass: Class<out Service>
+    @Suppress("UNCHECKED_CAST")
+    try {
+      analyzerServiceClass =
+        Class.forName("leakcanary.internal.perflib.PerflibHeapAnalyzer") as Class<out Service>
+    } catch (e: Exception) {
+      return false
+    }
+
+    var isInAnalyzerProcess: Boolean? = isInAnalyzerProcess
+    // This only needs to be computed once per process.
+    if (isInAnalyzerProcess == null) {
+      isInAnalyzerProcess =
+        LeakCanaryUtils.isInServiceProcess(context, analyzerServiceClass)
+      this.isInAnalyzerProcess = isInAnalyzerProcess
+    }
+    return isInAnalyzerProcess
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt
new file mode 100644
index 00000000..cade0684
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt
@@ -0,0 +1,9 @@
+package leakcanary.internal
+
+import androidx.core.content.FileProvider
+
+/**
+ * There can only be one [FileProvider] provider registered per app, so we extend that class
+ * just to use a distinct name.
+ */
+internal class LeakCanaryFileProvider : FileProvider()
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanarySingleThreadFactory.kt
similarity index 63%
rename from leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java
rename to leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanarySingleThreadFactory.kt
index 4eb3a3a0..a3c30910 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanarySingleThreadFactory.kt
@@ -13,22 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary.internal;
+package leakcanary.internal
 
-import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadFactory
 
 /**
  * This is intended to only be used with a single thread executor.
  */
-final class LeakCanarySingleThreadFactory implements ThreadFactory {
+internal class LeakCanarySingleThreadFactory(threadName: String) : ThreadFactory {
 
-  private final String threadName;
+  private val threadName: String = "LeakCanary-$threadName"
 
-  LeakCanarySingleThreadFactory(String threadName) {
-    this.threadName = "LeakCanary-" + threadName;
-  }
-
-  @Override public Thread newThread(Runnable runnable) {
-    return new Thread(runnable, threadName);
+  override fun newThread(runnable: Runnable): Thread {
+    return Thread(runnable, threadName)
   }
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryUtils.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryUtils.kt
new file mode 100644
index 00000000..174676ca
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryUtils.kt
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.annotation.SuppressLint
+import android.app.ActivityManager
+import android.app.Notification
+import android.app.NotificationChannel
+import android.app.NotificationManager
+import android.app.PendingIntent
+import android.app.Service
+import android.content.ComponentName
+import android.content.Context
+import android.content.pm.PackageInfo
+import android.content.pm.PackageManager
+import android.content.pm.PackageManager.GET_SERVICES
+import android.content.pm.ServiceInfo
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.JELLY_BEAN
+import android.os.Build.VERSION_CODES.O
+import com.squareup.leakcanary.core.R
+import leakcanary.CanaryLog
+import java.util.concurrent.Executor
+import java.util.concurrent.Executors
+
+internal object LeakCanaryUtils {
+
+  const val SAMSUNG = "samsung"
+  const val MOTOROLA = "motorola"
+  const val LENOVO = "LENOVO"
+  const val LG = "LGE"
+  const val NVIDIA = "NVIDIA"
+  const val MEIZU = "Meizu"
+  const val HUAWEI = "HUAWEI"
+  const val VIVO = "vivo"
+
+  // Lint is wrong about what constitutes a leak. Ironic.
+  @SuppressLint("StaticFieldLeak")
+  @Volatile private var leakDirectoryProvider: LeakDirectoryProvider? = null
+
+  fun getLeakDirectoryProvider(context: Context): LeakDirectoryProvider {
+    var leakDirectoryProvider =
+      leakDirectoryProvider
+    if (leakDirectoryProvider == null) {
+      leakDirectoryProvider = LeakDirectoryProvider(context)
+    }
+    return leakDirectoryProvider
+  }
+
+  private const val NOTIFICATION_CHANNEL_ID = "leakcanary"
+
+  /** Extracts the class simple name out of a string containing a fully qualified class name.  */
+  fun classSimpleName(className: String): String {
+    val separator = className.lastIndexOf('.')
+    return if (separator == -1) {
+      className
+    } else {
+      className.substring(separator + 1)
+    }
+  }
+
+  fun isInServiceProcess(
+    context: Context,
+    serviceClass: Class<out Service>
+  ): Boolean {
+    val packageManager = context.packageManager
+    val packageInfo: PackageInfo
+    try {
+      packageInfo = packageManager.getPackageInfo(context.packageName, GET_SERVICES)
+    } catch (e: Exception) {
+      CanaryLog.d(e, "Could not get package info for %s", context.packageName)
+      return false
+    }
+
+    val mainProcess = packageInfo.applicationInfo.processName
+
+    val component = ComponentName(context, serviceClass)
+    val serviceInfo: ServiceInfo
+    try {
+      serviceInfo =
+        packageManager.getServiceInfo(component, PackageManager.GET_DISABLED_COMPONENTS)
+    } catch (ignored: PackageManager.NameNotFoundException) {
+      // Service is disabled.
+      return false
+    }
+
+    if (serviceInfo.processName == null) {
+      CanaryLog.d("Did not expect service %s to have a null process name", serviceClass)
+      return false
+    } else if (serviceInfo.processName == mainProcess) {
+      CanaryLog.d(
+          "Did not expect service %s to run in main process %s", serviceClass, mainProcess
+      )
+      // Technically we are in the service process, but we're not in the service dedicated process.
+      return false
+    }
+
+    val myPid = android.os.Process.myPid()
+    val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
+    var myProcess: ActivityManager.RunningAppProcessInfo? = null
+    val runningProcesses: List<ActivityManager.RunningAppProcessInfo>?
+    try {
+      runningProcesses = activityManager.runningAppProcesses
+    } catch (exception: SecurityException) {
+      // https://github.com/square/leakcanary/issues/948
+      CanaryLog.d("Could not get running app processes %d", exception)
+      return false
+    }
+
+    if (runningProcesses != null) {
+      for (process in runningProcesses) {
+        if (process.pid == myPid) {
+          myProcess = process
+          break
+        }
+      }
+    }
+    if (myProcess == null) {
+      CanaryLog.d("Could not find running process for %d", myPid)
+      return false
+    }
+
+    return myProcess.processName == serviceInfo.processName
+  }
+
+  fun showNotification(
+    context: Context,
+    contentTitle: CharSequence,
+    contentText: CharSequence,
+    pendingIntent: PendingIntent?,
+    notificationId: Int
+  ) {
+    val builder = Notification.Builder(context)
+        .setContentText(contentText)
+        .setContentTitle(contentTitle)
+        .setAutoCancel(true)
+        .setContentIntent(pendingIntent)
+
+    val notification =
+      buildNotification(context, builder)
+    val notificationManager =
+      context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+    try {
+      notificationManager.notify(notificationId, notification)
+    } catch (ignored: SecurityException) {
+      // https://github.com/square/leakcanary/issues/1197
+    }
+  }
+
+  fun buildNotification(
+    context: Context,
+    builder: Notification.Builder
+  ): Notification {
+    builder.setSmallIcon(R.drawable.leak_canary_notification)
+        .setWhen(System.currentTimeMillis())
+        .setOnlyAlertOnce(true)
+
+    if (SDK_INT >= O) {
+      val notificationManager =
+        context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+      var notificationChannel: NotificationChannel? =
+        notificationManager.getNotificationChannel(
+            NOTIFICATION_CHANNEL_ID
+        )
+      if (notificationChannel == null) {
+        val channelName = context.getString(R.string.leak_canary_notification_channel)
+        notificationChannel = NotificationChannel(
+            NOTIFICATION_CHANNEL_ID, channelName,
+            NotificationManager.IMPORTANCE_DEFAULT
+        )
+        notificationManager.createNotificationChannel(notificationChannel)
+      }
+      builder.setChannelId(
+          NOTIFICATION_CHANNEL_ID
+      )
+    }
+
+    return if (SDK_INT < JELLY_BEAN) {
+      builder.notification
+    } else {
+      builder.build()
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
new file mode 100644
index 00000000..c04135da
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
@@ -0,0 +1,236 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.Manifest.permission.WRITE_EXTERNAL_STORAGE
+import android.annotation.TargetApi
+import android.content.Context
+import android.content.pm.PackageManager.PERMISSION_GRANTED
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.M
+import android.os.Environment
+import android.os.Environment.DIRECTORY_DOWNLOADS
+import com.squareup.leakcanary.core.R.string
+import leakcanary.CanaryLog
+import leakcanary.internal.HeapDumper.Companion.RETRY_LATER
+import java.io.File
+import java.io.FilenameFilter
+import java.util.ArrayList
+import java.util.Arrays
+import java.util.UUID
+
+/**
+ * Provides access to where heap dumps and analysis results will be stored.
+ */
+internal class LeakDirectoryProvider @JvmOverloads constructor(
+  context: Context,
+  private val maxStoredHeapDumps: Int = DEFAULT_MAX_STORED_HEAP_DUMPS
+) {
+
+  private val context: Context
+
+  @Volatile private var writeExternalStorageGranted: Boolean = false
+  @Volatile private var permissionNotificationDisplayed: Boolean = false
+
+  init {
+    if (maxStoredHeapDumps < 1) {
+      throw IllegalArgumentException("maxStoredHeapDumps must be at least 1")
+    }
+    this.context = context.applicationContext
+  }
+
+  fun listFiles(filter: FilenameFilter): MutableList<File> {
+    if (!hasStoragePermission()) {
+      requestWritePermissionNotification()
+    }
+    val files = ArrayList<File>()
+
+    val externalFiles = externalStorageDirectory().listFiles(filter)
+    if (externalFiles != null) {
+      files.addAll(Arrays.asList(*externalFiles))
+    }
+
+    val appFiles = appStorageDirectory().listFiles(filter)
+    if (appFiles != null) {
+      files.addAll(Arrays.asList(*appFiles))
+    }
+    return files
+  }
+
+  fun hasPendingHeapDump(): Boolean {
+    val pendingHeapDumps =
+      listFiles(FilenameFilter { _, filename ->
+        filename.endsWith(
+            PENDING_HEAPDUMP_SUFFIX
+        )
+      })
+    for (file in pendingHeapDumps) {
+      if (System.currentTimeMillis() - file.lastModified() < ANALYSIS_MAX_DURATION_MS) {
+        return true
+      }
+    }
+    return false
+  }
+
+  fun newHeapDumpFile(): File? {
+    val pendingHeapDumps =
+      listFiles(FilenameFilter { _, filename ->
+        filename.endsWith(
+            PENDING_HEAPDUMP_SUFFIX
+        )
+      })
+
+    // If a new heap dump file has been created recently and hasn't been processed yet, we skip.
+    // Otherwise we move forward and assume that the analyzer process crashes. The file will
+    // eventually be removed with heap dump file rotation.
+    for (file in pendingHeapDumps) {
+      if (System.currentTimeMillis() - file.lastModified() < ANALYSIS_MAX_DURATION_MS) {
+        CanaryLog.d(
+            "Could not dump heap, previous analysis still is in progress."
+        )
+        return RETRY_LATER
+      }
+    }
+
+    cleanupOldHeapDumps()
+
+    var storageDirectory = externalStorageDirectory()
+    if (!directoryWritableAfterMkdirs(storageDirectory)) {
+      if (!hasStoragePermission()) {
+        CanaryLog.d("WRITE_EXTERNAL_STORAGE permission not granted")
+        requestWritePermissionNotification()
+      } else {
+        val state = Environment.getExternalStorageState()
+        if (Environment.MEDIA_MOUNTED != state) {
+          CanaryLog.d("External storage not mounted, state: %s", state)
+        } else {
+          CanaryLog.d(
+              "Could not create heap dump directory in external storage: [%s]",
+              storageDirectory.absolutePath
+          )
+        }
+      }
+      // Fallback to app storage.
+      storageDirectory = appStorageDirectory()
+      if (!directoryWritableAfterMkdirs(storageDirectory)) {
+        CanaryLog.d(
+            "Could not create heap dump directory in app storage: [%s]",
+            storageDirectory.absolutePath
+        )
+        return RETRY_LATER
+      }
+    }
+    // If two processes from the same app get to this step at the same time, they could both
+    // create a heap dump. This is an edge case we ignore.
+    return File(storageDirectory, UUID.randomUUID().toString() + PENDING_HEAPDUMP_SUFFIX)
+  }
+
+  fun clearLeakDirectory() {
+    val allFilesExceptPending =
+      listFiles(FilenameFilter { _, filename ->
+        !filename.endsWith(
+            PENDING_HEAPDUMP_SUFFIX
+        )
+      })
+    for (file in allFilesExceptPending) {
+      val deleted = file.delete()
+      if (!deleted) {
+        CanaryLog.d("Could not delete file %s", file.path)
+      }
+    }
+  }
+
+  @TargetApi(M) fun hasStoragePermission(): Boolean {
+    if (SDK_INT < M) {
+      return true
+    }
+    // Once true, this won't change for the life of the process so we can cache it.
+    if (writeExternalStorageGranted) {
+      return true
+    }
+    writeExternalStorageGranted =
+      context.checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED
+    return writeExternalStorageGranted
+  }
+
+  fun requestWritePermissionNotification() {
+    if (permissionNotificationDisplayed) {
+      return
+    }
+    permissionNotificationDisplayed = true
+
+    val pendingIntent = RequestStoragePermissionActivity.createPendingIntent(context)
+    val contentTitle = context.getString(
+        string.leak_canary_permission_notification_title
+    )
+    val packageName = context.packageName
+    val contentText =
+      context.getString(string.leak_canary_permission_notification_text, packageName)
+
+    LeakCanaryUtils.showNotification(
+        context, contentTitle, contentText, pendingIntent, 0x00DABEEF
+    )
+  }
+
+  private fun externalStorageDirectory(): File {
+    val downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS)
+    return File(downloadsDirectory, "leakcanary-" + context.packageName)
+  }
+
+  private fun appStorageDirectory(): File {
+    val appFilesDirectory = context.filesDir
+    return File(appFilesDirectory, "leakcanary")
+  }
+
+  private fun directoryWritableAfterMkdirs(directory: File): Boolean {
+    val success = directory.mkdirs()
+    return (success || directory.exists()) && directory.canWrite()
+  }
+
+  private fun cleanupOldHeapDumps() {
+    val hprofFiles = listFiles(FilenameFilter { _, name ->
+      name.endsWith(
+          HPROF_SUFFIX
+      )
+    })
+    val filesToRemove = hprofFiles.size - maxStoredHeapDumps
+    if (filesToRemove > 0) {
+      CanaryLog.d("Removing %d heap dumps", filesToRemove)
+      // Sort with oldest modified first.
+      hprofFiles.sortWith(Comparator { lhs, rhs ->
+        java.lang.Long.valueOf(lhs.lastModified())
+            .compareTo(rhs.lastModified())
+      })
+      for (i in 0 until filesToRemove) {
+        val deleted = hprofFiles[i].delete()
+        if (!deleted) {
+          CanaryLog.d("Could not delete old hprof file %s", hprofFiles[i].path)
+        }
+      }
+    }
+  }
+
+  companion object {
+
+    private const val DEFAULT_MAX_STORED_HEAP_DUMPS = 7
+
+    private const val HPROF_SUFFIX = ".hprof"
+    private const val PENDING_HEAPDUMP_SUFFIX = "_pending$HPROF_SUFFIX"
+
+    /** 10 minutes  */
+    private const val ANALYSIS_MAX_DURATION_MS = 10 * 60 * 1000
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/MoreDetailsView.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/MoreDetailsView.kt
new file mode 100644
index 00000000..ab13f6ea
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/MoreDetailsView.kt
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.annotation.SuppressLint
+import android.content.Context
+import android.graphics.Canvas
+import android.graphics.Color
+import android.graphics.Paint
+import android.util.AttributeSet
+import android.view.View
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.MoreDetailsView.Details.CLOSED
+import leakcanary.internal.MoreDetailsView.Details.OPENED
+
+internal class MoreDetailsView(
+  context: Context,
+  attrs: AttributeSet
+) : View(context, attrs) {
+
+  enum class Details {
+    OPENED,
+    CLOSED,
+    NONE
+  }
+
+  private val iconPaint: Paint
+
+  private var details = Details.NONE
+
+  init {
+    val resources = resources
+    iconPaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    val strokeSize = resources.getDimensionPixelSize(R.dimen.leak_canary_more_stroke_width)
+        .toFloat()
+    iconPaint.strokeWidth = strokeSize
+
+    // This lint check doesn't work for libraries which have a common prefix.
+    @SuppressLint("CustomViewStyleable") //
+    val a = context.obtainStyledAttributes(attrs, R.styleable.leak_canary_MoreDetailsView)
+    val plusColor =
+      a.getColor(R.styleable.leak_canary_MoreDetailsView_leak_canary_plus_color, Color.BLACK)
+    a.recycle()
+
+    iconPaint.color = plusColor
+  }
+
+  override fun onDraw(canvas: Canvas) {
+    val width = width
+    val height = height
+    val halfHeight = height / 2
+    val halfWidth = width / 2
+
+    if (details == OPENED) {
+      canvas.drawLine(0f, halfHeight.toFloat(), width.toFloat(), halfHeight.toFloat(), iconPaint)
+    } else if (details == CLOSED) {
+      canvas.drawLine(0f, halfHeight.toFloat(), width.toFloat(), halfHeight.toFloat(), iconPaint)
+      canvas.drawLine(halfWidth.toFloat(), 0f, halfWidth.toFloat(), height.toFloat(), iconPaint)
+    }
+  }
+
+  fun setDetails(details: Details) {
+    if (details != this.details) {
+      this.details = details
+      invalidate()
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/RequestStoragePermissionActivity.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/RequestStoragePermissionActivity.kt
new file mode 100644
index 00000000..00272b52
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/RequestStoragePermissionActivity.kt
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.Manifest.permission.WRITE_EXTERNAL_STORAGE
+import android.annotation.TargetApi
+import android.app.Activity
+import android.app.PendingIntent
+import android.app.PendingIntent.FLAG_UPDATE_CURRENT
+import android.content.Context
+import android.content.Intent
+import android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP
+import android.content.Intent.FLAG_ACTIVITY_NEW_TASK
+import android.content.pm.PackageManager.PERMISSION_GRANTED
+import android.os.Build.VERSION_CODES.M
+import android.os.Bundle
+import android.widget.Toast
+import android.widget.Toast.LENGTH_LONG
+import com.squareup.leakcanary.core.R
+
+@TargetApi(M) //
+internal class RequestStoragePermissionActivity : Activity() {
+
+  override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+
+    if (savedInstanceState == null) {
+      if (hasStoragePermission()) {
+        finish()
+        return
+      }
+      val permissions = arrayOf(WRITE_EXTERNAL_STORAGE)
+      requestPermissions(permissions, 42)
+    }
+  }
+
+  override fun onRequestPermissionsResult(
+    requestCode: Int,
+    permissions: Array<String>,
+    grantResults: IntArray
+  ) {
+    if (!hasStoragePermission()) {
+      Toast.makeText(application, R.string.leak_canary_permission_not_granted, LENGTH_LONG)
+          .show()
+    }
+    finish()
+  }
+
+  override fun finish() {
+    // Reset the animation to avoid flickering.
+    overridePendingTransition(0, 0)
+    super.finish()
+  }
+
+  private fun hasStoragePermission(): Boolean {
+    return checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED
+  }
+
+  companion object {
+
+    fun createPendingIntent(context: Context): PendingIntent {
+      val intent = Intent(context, RequestStoragePermissionActivity::class.java)
+      intent.flags = FLAG_ACTIVITY_NEW_TASK or FLAG_ACTIVITY_CLEAR_TOP
+      return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT)
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/RowElementLayout.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/RowElementLayout.kt
new file mode 100644
index 00000000..5d470a4d
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/RowElementLayout.kt
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.content.Context
+import android.util.AttributeSet
+import android.view.View
+import android.view.ViewGroup
+import com.squareup.leakcanary.core.R
+
+internal class RowElementLayout(
+  context: Context,
+  attrs: AttributeSet
+) : ViewGroup(context, attrs) {
+
+  private val connectorWidth: Int
+  private val rowMargins: Int
+  private val moreSize: Int
+  private val minHeight: Int
+  private val titleMarginTop: Int
+  private val moreMarginTop: Int
+
+  private var connector: View? = null
+  private var moreButton: View? = null
+  private var title: View? = null
+  private var details: View? = null
+
+  init {
+    val resources = resources
+    connectorWidth = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_width)
+    rowMargins = resources.getDimensionPixelSize(R.dimen.leak_canary_row_margins)
+    moreSize = resources.getDimensionPixelSize(R.dimen.leak_canary_more_size)
+    minHeight = resources.getDimensionPixelSize(R.dimen.leak_canary_row_min)
+    titleMarginTop = resources.getDimensionPixelSize(R.dimen.leak_canary_row_title_margin_top)
+    moreMarginTop = resources.getDimensionPixelSize(R.dimen.leak_canary_more_margin_top)
+  }
+
+  override fun onFinishInflate() {
+    super.onFinishInflate()
+    connector = findViewById(R.id.leak_canary_row_connector)
+    moreButton = findViewById(R.id.leak_canary_row_more)
+    title = findViewById(R.id.leak_canary_row_title)
+    details = findViewById(R.id.leak_canary_row_details)
+  }
+
+  override fun onMeasure(
+    widthMeasureSpec: Int,
+    heightMeasureSpec: Int
+  ) {
+    val availableWidth = View.MeasureSpec.getSize(widthMeasureSpec)
+    val titleWidth = availableWidth - connectorWidth - moreSize - 4 * rowMargins
+    val titleWidthSpec = View.MeasureSpec.makeMeasureSpec(titleWidth, View.MeasureSpec.AT_MOST)
+    val titleHeightSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)
+    title!!.measure(titleWidthSpec, titleHeightSpec)
+
+    val moreSizeSpec = View.MeasureSpec.makeMeasureSpec(moreSize, View.MeasureSpec.EXACTLY)
+    moreButton!!.measure(moreSizeSpec, moreSizeSpec)
+
+    var totalHeight = titleMarginTop + title!!.measuredHeight
+
+    val detailsWidth = availableWidth - connectorWidth - 3 * rowMargins
+    val detailsWidthSpec = View.MeasureSpec.makeMeasureSpec(detailsWidth, View.MeasureSpec.AT_MOST)
+    val detailsHeightSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)
+    details!!.measure(detailsWidthSpec, detailsHeightSpec)
+    if (details!!.visibility != View.GONE) {
+      totalHeight += details!!.measuredHeight
+    }
+    totalHeight = Math.max(totalHeight, minHeight)
+
+    val connectorWidthSpec =
+      View.MeasureSpec.makeMeasureSpec(connectorWidth, View.MeasureSpec.EXACTLY)
+    val connectorHeightSpec =
+      View.MeasureSpec.makeMeasureSpec(totalHeight, View.MeasureSpec.EXACTLY)
+
+    connector!!.measure(connectorWidthSpec, connectorHeightSpec)
+    setMeasuredDimension(availableWidth, totalHeight)
+  }
+
+  override fun onLayout(
+    changed: Boolean,
+    l: Int,
+    t: Int,
+    r: Int,
+    b: Int
+  ) {
+    val width = measuredWidth
+    val connectorRight = rowMargins + connector!!.measuredWidth
+    connector!!.layout(rowMargins, 0, connectorRight, connector!!.measuredHeight)
+
+    moreButton!!.layout(
+        width - rowMargins - moreSize, moreMarginTop, width - rowMargins,
+        moreMarginTop + moreSize
+    )
+
+    val titleLeft = connectorRight + rowMargins
+    val titleBottom = titleMarginTop + title!!.measuredHeight
+    title!!.layout(titleLeft, titleMarginTop, titleLeft + title!!.measuredWidth, titleBottom)
+
+    if (details!!.visibility != View.GONE) {
+      details!!.layout(
+          titleLeft, titleBottom, width - rowMargins,
+          titleBottom + details!!.measuredHeight
+      )
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt
new file mode 100644
index 00000000..b38b9b01
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.content.res.Resources
+import android.graphics.Canvas
+import android.graphics.Paint
+import android.graphics.Path
+import android.text.SpannableStringBuilder
+import android.text.style.ReplacementSpan
+import android.text.style.UnderlineSpan
+import com.squareup.leakcanary.core.R
+
+/**
+ * Inspired from https://github.com/flavienlaurent/spans and
+ * https://github.com/andyxialm/WavyLineView
+ */
+internal class SquigglySpan(resources: Resources) : ReplacementSpan() {
+
+  private val squigglyPaint: Paint = Paint(Paint.ANTI_ALIAS_FLAG)
+  private val path: Path
+  private val referenceColor: Int
+  private val halfStrokeWidth: Float
+  private val amplitude: Float
+  private val halfWaveHeight: Float
+  private val periodDegrees: Float
+
+  private var width: Int = 0
+
+  init {
+    squigglyPaint.style = Paint.Style.STROKE
+    squigglyPaint.color = resources.getColor(R.color.leak_canary_leak)
+    val strokeWidth =
+      resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_stroke_width)
+          .toFloat()
+    squigglyPaint.strokeWidth = strokeWidth
+
+    halfStrokeWidth = strokeWidth / 2
+    amplitude = resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_amplitude)
+        .toFloat()
+    periodDegrees =
+      resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_period_degrees)
+          .toFloat()
+    path = Path()
+    val waveHeight = 2 * amplitude + strokeWidth
+    halfWaveHeight = waveHeight / 2
+    referenceColor = resources.getColor(R.color.leak_canary_reference)
+  }
+
+  override fun getSize(
+    paint: Paint,
+    text: CharSequence,
+    start: Int,
+    end: Int,
+    fm: Paint.FontMetricsInt?
+  ): Int {
+    width = paint.measureText(text, start, end)
+        .toInt()
+    return width
+  }
+
+  override fun draw(
+    canvas: Canvas,
+    text: CharSequence,
+    start: Int,
+    end: Int,
+    x: Float,
+    top: Int,
+    y: Int,
+    bottom: Int,
+    paint: Paint
+  ) {
+    squigglyHorizontalPath(
+        path,
+        x + halfStrokeWidth,
+        x + width - halfStrokeWidth,
+        bottom - halfWaveHeight,
+        amplitude, periodDegrees
+    )
+    canvas.drawPath(path, squigglyPaint)
+
+    paint.color = referenceColor
+    canvas.drawText(text, start, end, x, y.toFloat(), paint)
+  }
+
+  companion object {
+
+    fun replaceUnderlineSpans(
+      builder: SpannableStringBuilder,
+      resources: Resources
+    ) {
+      val underlineSpans = builder.getSpans(0, builder.length, UnderlineSpan::class.java)
+      for (span in underlineSpans) {
+        val start = builder.getSpanStart(span)
+        val end = builder.getSpanEnd(span)
+        builder.removeSpan(span)
+        builder.setSpan(SquigglySpan(resources), start, end, 0)
+      }
+    }
+
+    private fun squigglyHorizontalPath(
+      path: Path,
+      left: Float,
+      right: Float,
+      centerY: Float,
+      amplitude: Float,
+      periodDegrees: Float
+    ) {
+      path.reset()
+
+      var y: Float
+      path.moveTo(left, centerY)
+      val period = (2 * Math.PI / periodDegrees).toFloat()
+
+      var x = 0f
+      while (x <= right - left) {
+        y = (amplitude * Math.sin((40 + period * x).toDouble()) + centerY).toFloat()
+        path.lineTo(left + x, y)
+        x += 1f
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
new file mode 100644
index 00000000..a3e5f726
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
@@ -0,0 +1,44 @@
+package leakcanary.internal
+
+import android.app.Activity
+import android.app.Application
+import leakcanary.CanaryLog
+
+internal class VisibilityTracker(
+  private val listener: (Boolean) -> Unit
+) :
+    ActivityLifecycleCallbacksAdapter() {
+
+  private var startedActivityCount = 0
+
+  /**
+   * Visible activities are any activity started but not stopped yet. An activity can be paused
+   * yet visible: this will happen when another activity shows on top with a transparent background
+   * and the activity behind won't get touch inputs but still need to render / animate.
+   */
+  private var hasVisibleActivities: Boolean = false
+
+  override fun onActivityStarted(activity: Activity) {
+    startedActivityCount++
+    if (!hasVisibleActivities && startedActivityCount == 1) {
+      hasVisibleActivities = true
+      listener.invoke(true)
+    }
+  }
+
+  override fun onActivityStopped(activity: Activity) {
+    // This could happen if the callbacks were registered after some activities were already
+    // started. In that case we effectively considers those past activities as not visible.
+    if (startedActivityCount > 0) {
+      startedActivityCount--
+    }
+    if (hasVisibleActivities && startedActivityCount == 0 && !activity.isChangingConfigurations) {
+      hasVisibleActivities = false
+      listener.invoke(false)
+    }
+  }
+}
+
+internal fun Application.registerVisibilityListener(listener: (Boolean) -> Unit) {
+  registerActivityLifecycleCallbacks(VisibilityTracker(listener))
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt
new file mode 100644
index 00000000..e2e5c236
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt
@@ -0,0 +1,73 @@
+package leakcanary.internal.activity
+
+import android.app.PendingIntent
+import android.content.Context
+import android.content.Intent
+import android.os.Bundle
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.activity.db.LeaksDbHelper
+import leakcanary.internal.activity.screen.GroupListScreen
+import leakcanary.internal.navigation.NavigatingActivity
+import leakcanary.internal.navigation.Screen
+
+internal class LeakActivity : NavigatingActivity() {
+
+  private lateinit var dbHelper: LeaksDbHelper
+
+  val db get() = dbHelper.writableDatabase!!
+
+  override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+    setContentView(R.layout.leak_canary_leak_activity)
+
+    val dbHelperOrNull = lastNonConfigurationInstance
+    dbHelper = dbHelperOrNull as LeaksDbHelper? ?: LeaksDbHelper(application)
+
+
+    installNavigation(savedInstanceState, findViewById(R.id.main_container))
+  }
+
+  override fun onRetainNonConfigurationInstance(): Any {
+    return dbHelper
+  }
+
+  override fun getLauncherScreen(): Screen {
+    return GroupListScreen()
+  }
+
+  override fun onDestroy() {
+    super.onDestroy()
+    if (!isChangingConfigurations) {
+      dbHelper.close()
+    }
+  }
+
+  override fun setTheme(resid: Int) {
+    // We don't want this to be called with an incompatible theme.
+    // This could happen if you implement runtime switching of themes
+    // using ActivityLifecycleCallbacks.
+    if (resid != R.style.leak_canary_LeakCanary_Base) {
+      return
+    }
+    super.setTheme(resid)
+  }
+
+  companion object {
+    fun createPendingIntent(
+      context: Context,
+      screens: ArrayList<Screen>
+    ): PendingIntent {
+      val intent = Intent(context, LeakActivity::class.java)
+      intent.putExtra("screens", screens)
+      intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
+      return PendingIntent.getActivity(context, 1, intent, PendingIntent.FLAG_UPDATE_CURRENT)
+    }
+
+    fun createIntent(context: Context): Intent {
+      val intent = Intent(context, LeakActivity::class.java)
+      intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
+      return intent
+    }
+  }
+
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
new file mode 100644
index 00000000..0367f167
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
@@ -0,0 +1,69 @@
+package leakcanary.internal.activity
+
+import android.annotation.SuppressLint
+import android.content.ClipData
+import android.content.ClipboardManager
+import android.content.Context
+import android.content.Intent
+import android.net.Uri
+import android.os.AsyncTask
+import android.view.View
+import android.widget.Toast
+import androidx.core.content.FileProvider
+import com.squareup.leakcanary.core.R
+import leakcanary.HeapDump
+import leakcanary.internal.navigation.activity
+
+internal val View.db
+  get() = activity<LeakActivity>().db
+
+internal fun View.share(content: String) {
+  val intent = Intent(Intent.ACTION_SEND)
+  intent.type = "text/plain"
+  intent.putExtra(Intent.EXTRA_TEXT, content)
+  activity.startActivity(
+      Intent.createChooser(intent, resources.getString(R.string.leak_canary_share_with))
+  )
+}
+
+@SuppressLint("SetWorldReadable")
+internal fun View.shareHeapDump(heapDump: HeapDump) {
+  val heapDumpFile = heapDump.heapDumpFile
+  AsyncTask.SERIAL_EXECUTOR.execute {
+    heapDumpFile.setReadable(true, false)
+    val heapDumpUri = FileProvider.getUriForFile(
+        activity,
+        "com.squareup.leakcanary.fileprovider." + activity.packageName,
+        heapDumpFile
+    )
+    activity.runOnUiThread { startShareIntentChooser(heapDumpUri) }
+  }
+}
+
+private fun View.startShareIntentChooser(uri: Uri) {
+  val intent = Intent(Intent.ACTION_SEND)
+  intent.type = "application/octet-stream"
+  intent.putExtra(Intent.EXTRA_STREAM, uri)
+  activity.startActivity(
+      Intent.createChooser(intent, resources.getString(R.string.leak_canary_share_with))
+  )
+}
+
+internal fun View.shareToStackOverflow(content: String) {
+  val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
+  // AsyncTask was needed here due to setPrimaryClip making a disk write which
+  // violated StrictMode if on the main thread
+  AsyncTask.execute {
+    clipboard.primaryClip = ClipData.newPlainText(
+        context.getString(R.string.leak_canary_leak_clipdata_label),
+        "```\n$content```"
+    )
+  }
+  Toast.makeText(context, R.string.leak_canary_leak_copied, Toast.LENGTH_LONG)
+      .show()
+  val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(STACKOVERFLOW_QUESTION_URL));
+  activity.startActivity(browserIntent)
+}
+
+private const val STACKOVERFLOW_QUESTION_URL =
+  "http://stackoverflow.com/questions/ask?guided=false&tags=leakcanary"
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Cursors.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Cursors.kt
new file mode 100644
index 00000000..534bbf02
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Cursors.kt
@@ -0,0 +1,37 @@
+package leakcanary.internal.activity.db
+
+import android.database.Cursor
+import android.database.sqlite.SQLiteDatabase
+
+/**
+ * Similar to the more generic use() for Closable.
+ * Cursor started implementing Closable in API 16.
+ */
+internal inline fun <R> Cursor.use(block: (Cursor) -> R): R {
+  var exception: Throwable? = null
+  try {
+    return block(this)
+  } catch (e: Throwable) {
+    exception = e
+    throw e
+  } finally {
+    when (exception) {
+      null -> close()
+      else -> try {
+        close()
+      } catch (ignoredCloseException: Throwable) {
+      }
+    }
+  }
+}
+
+internal inline fun <T> SQLiteDatabase.inTransaction(block: SQLiteDatabase.() -> T): T {
+  try {
+    beginTransaction()
+    val result = block()
+    setTransactionSuccessful()
+    return result
+  } finally {
+    endTransaction()
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
new file mode 100644
index 00000000..a2289f4b
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
@@ -0,0 +1,158 @@
+package leakcanary.internal.activity.db
+
+import android.content.ContentValues
+import android.content.Context
+import android.database.sqlite.SQLiteDatabase
+import android.os.AsyncTask
+import leakcanary.CanaryLog
+import leakcanary.HeapAnalysis
+import leakcanary.HeapAnalysisFailure
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.HeapDump
+import leakcanary.Serializables
+import leakcanary.internal.LeakCanaryUtils
+import leakcanary.internal.activity.db.LeakingInstanceTable.HeapAnalysisGroupProjection
+import leakcanary.leakingInstances
+import leakcanary.toByteArray
+import org.intellij.lang.annotations.Language
+
+internal object HeapAnalysisTable {
+
+  @Language("RoomSql")
+  const val create = """CREATE TABLE heap_analysis
+        (
+        id INTEGER PRIMARY KEY,
+        created_at_time_millis INTEGER,
+        retained_instance_count INTEGER DEFAULT 0,
+        exception_summary TEXT DEFAULT NULL,
+        object BLOB
+        )"""
+
+  fun insert(
+    db: SQLiteDatabase,
+    heapAnalysis: HeapAnalysis
+  ): Long {
+    val values = ContentValues()
+    values.put("created_at_time_millis", heapAnalysis.createdAtTimeMillis)
+    values.put("object", heapAnalysis.toByteArray())
+    when (heapAnalysis) {
+      is HeapAnalysisSuccess -> {
+        values.put("retained_instance_count", heapAnalysis.retainedInstances.size)
+      }
+      is HeapAnalysisFailure -> {
+        val cause = heapAnalysis.exception.cause!!
+        val exceptionSummary = "${cause.javaClass.simpleName} ${cause.message}"
+        values.put("exception_summary", exceptionSummary)
+      }
+    }
+
+    return db.inTransaction {
+      val heapAnalysisId = db.insertOrThrow("heap_analysis", null, values)
+      heapAnalysis.leakingInstances()
+          .forEach { leakingInstance ->
+            LeakingInstanceTable.insert(
+                db, heapAnalysisId, leakingInstance
+            )
+          }
+      heapAnalysisId
+    }
+  }
+
+  fun <T : HeapAnalysis> retrieve(
+    db: SQLiteDatabase,
+    id: Long
+  ): Pair<T, Map<String, HeapAnalysisGroupProjection>>? {
+    db.inTransaction {
+      val heapAnalysis = db.rawQuery(
+          """
+              SELECT
+              object
+              FROM heap_analysis
+              WHERE id=$id
+              """, null
+      )
+          .use { cursor ->
+            if (cursor.moveToNext()) {
+              val analysis = Serializables.fromByteArray<T>(cursor.getBlob(0))
+              if (analysis == null) {
+                delete(db, id, null)
+              }
+              analysis
+            } else
+              null
+          } ?: return null
+
+      val hashes =
+        LeakingInstanceTable.retrieveAllByHeapAnalysisId(db, id)
+
+      return heapAnalysis to hashes
+    }
+  }
+
+  fun retrieveAll(db: SQLiteDatabase): List<Projection> {
+    return db.rawQuery(
+        """
+          SELECT
+          id
+          , created_at_time_millis
+          , retained_instance_count
+          , exception_summary
+          FROM heap_analysis
+          ORDER BY created_at_time_millis DESC
+          """, null
+    )
+        .use { cursor ->
+          val all = mutableListOf<Projection>()
+          while (cursor.moveToNext()) {
+            val summary = Projection(
+                id = cursor.getLong(0),
+                createdAtTimeMillis = cursor.getLong(1),
+                retainedInstanceCount = cursor.getInt(2),
+                exceptionSummary = cursor.getString(3)
+            )
+            all.add(summary)
+          }
+          all
+        }
+  }
+
+  fun delete(
+    db: SQLiteDatabase,
+    id: Long,
+    heapDump: HeapDump?
+  ) {
+    if (heapDump != null) {
+      AsyncTask.SERIAL_EXECUTOR.execute {
+        val heapDumpDeleted = heapDump.heapDumpFile.delete()
+        if (!heapDumpDeleted) {
+          CanaryLog.d("Could not delete heap dump file %s", heapDump.heapDumpFile.path)
+        }
+      }
+    }
+
+    db.inTransaction {
+      db.delete("heap_analysis", "id=$id", null)
+      LeakingInstanceTable.deleteByHeapAnalysisId(db, id)
+    }
+  }
+
+  fun deleteAll(
+    db: SQLiteDatabase,
+    context: Context
+  ) {
+    val leakDirectoryProvider = LeakCanaryUtils.getLeakDirectoryProvider(context)
+    AsyncTask.SERIAL_EXECUTOR.execute { leakDirectoryProvider.clearLeakDirectory() }
+    db.inTransaction {
+      db.delete("heap_analysis", null, null)
+      LeakingInstanceTable.deleteAll(db)
+    }
+  }
+
+  class Projection(
+    val id: Long,
+    val createdAtTimeMillis: Long,
+    val retainedInstanceCount: Int,
+    val exceptionSummary: String?
+  )
+
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
new file mode 100644
index 00000000..6f331332
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
@@ -0,0 +1,268 @@
+package leakcanary.internal.activity.db
+
+import android.content.ContentValues
+import android.database.sqlite.SQLiteDatabase
+import leakcanary.LeakTrace
+import leakcanary.LeakTraceElement
+import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
+import leakcanary.LeakingInstance
+import leakcanary.Reachability
+import leakcanary.Serializables
+import leakcanary.internal.lastSegment
+import leakcanary.internal.utils.to
+import leakcanary.toByteArray
+import org.intellij.lang.annotations.Language
+
+internal object LeakingInstanceTable {
+
+  @Language("RoomSql")
+  const val create = """
+        CREATE TABLE leaking_instance
+        (
+        id INTEGER PRIMARY KEY,
+        heap_analysis_id REFERENCES heap_analysis(id),
+        group_hash TEXT,
+        group_description TEXT,
+        class_simple_name TEXT,
+        object BLOB
+        )"""
+
+  @Language("RoomSql")
+  const val createGroupHashIndex = """
+        CREATE INDEX leaking_instance_group_hash
+        on leaking_instance (group_hash)
+    """
+
+  fun insert(
+    db: SQLiteDatabase,
+    heapAnalysisId: Long,
+    leakingInstance: LeakingInstance
+  ): Long {
+    val values = ContentValues()
+    values.put("heap_analysis_id", heapAnalysisId)
+    values.put("group_hash", leakingInstance.groupHash)
+    values.put("group_description", leakingInstance.createGroupDescription())
+    values.put("class_simple_name", leakingInstance.instanceClassName.lastSegment('.'))
+    values.put("object", leakingInstance.toByteArray())
+    return db.insertOrThrow("leaking_instance", null, values)
+  }
+
+  fun retrieve(
+    db: SQLiteDatabase,
+    id: Long
+  ): Pair<Long, LeakingInstance>? {
+    return db.rawQuery(
+        """
+          SELECT
+          heap_analysis_id,
+          object
+          FROM leaking_instance
+          WHERE id=$id
+          """, null
+    )
+        .use { cursor ->
+          if (cursor.moveToNext()) {
+            val heapAnalysisId = cursor.getLong(0)
+            val leakingInstance = Serializables.fromByteArray<LeakingInstance>(cursor.getBlob(1))
+            if (leakingInstance == null) {
+              null
+            } else {
+              heapAnalysisId to leakingInstance
+            }
+          } else
+            null
+        }
+  }
+
+  class HeapAnalysisGroupProjection(
+    val hash: String,
+    val description: String,
+    val createdAtTimeMillis: Long,
+    val leakCount: Int,
+    val totalLeakCount: Int
+  )
+
+  fun retrieveAllByHeapAnalysisId(
+    db: SQLiteDatabase,
+    heapAnalysisId: Long
+  ): Map<String, HeapAnalysisGroupProjection> {
+
+    return db.rawQuery(
+        """
+          SELECT
+          group_hash
+          , group_description
+          , MAX(created_at_time_millis) as created_at_time_millis
+          , SUM(CASE WHEN heap_analysis_id=$heapAnalysisId THEN 1 ELSE 0 END) as leak_count
+          , COUNT(*) as total_leak_count
+          FROM leaking_instance l
+          LEFT JOIN heap_analysis h ON l.heap_analysis_id = h.id
+          GROUP BY 1, 2
+          HAVING leak_count > 0
+          ORDER BY leak_count, created_at_time_millis DESC
+          """, null
+    )
+        .use { cursor ->
+          val projectionsByHash = linkedMapOf<String, HeapAnalysisGroupProjection>()
+          while (cursor.moveToNext()) {
+            val hash = cursor.getString(0)
+            val group = HeapAnalysisGroupProjection(
+                hash = hash,
+                description = cursor.getString(1),
+                createdAtTimeMillis = cursor.getLong(2),
+                leakCount = cursor.getInt(3),
+                totalLeakCount = cursor.getInt(4)
+            )
+            projectionsByHash[hash] = group
+          }
+          projectionsByHash
+        }
+  }
+
+  class GroupProjection(
+    val hash: String,
+    val description: String,
+    val createdAtTimeMillis: Long,
+    val leakCount: Int
+  )
+
+  fun retrieveAllGroups(
+    db: SQLiteDatabase
+  ): List<GroupProjection> {
+    return db.rawQuery(
+        """
+          SELECT
+          group_hash
+          , group_description
+          , MAX(created_at_time_millis) as created_at_time_millis
+          , COUNT(*) as leak_count
+          FROM leaking_instance l
+          LEFT JOIN heap_analysis h ON l.heap_analysis_id = h.id
+          GROUP BY 1, 2
+          ORDER BY leak_count, created_at_time_millis DESC
+          """, null
+    )
+        .use { cursor ->
+          val all = mutableListOf<GroupProjection>()
+          while (cursor.moveToNext()) {
+            val group = GroupProjection(
+                hash = cursor.getString(0),
+                description = cursor.getString(1),
+                createdAtTimeMillis = cursor.getLong(2),
+                leakCount = cursor.getInt(3)
+            )
+            all.add(group)
+          }
+          all
+        }
+  }
+
+  class InstanceProjection(
+    val id: Long,
+    val classSimpleName: String,
+    val createdAtTimeMillis: Long
+  )
+
+  fun retrieveGroup(
+    db: SQLiteDatabase,
+    groupHash: String
+  ): Triple<LeakTrace, String, List<InstanceProjection>>? {
+    val pair = db.rawQuery(
+        """
+           SELECT
+            object
+            , group_description
+            FROM leaking_instance
+            WHERE group_hash = ?
+            LIMIT 1
+            """, arrayOf(groupHash)
+    )
+        .use { cursor ->
+          if (cursor.moveToNext()) {
+            // TODO This may crash if we can't deserialize the first entry we find.
+            // We need to either prune early, or have a better deserialization story.
+            val leakingInstance = Serializables.fromByteArray<LeakingInstance>(cursor.getBlob(0))!!
+            val leakTrace = leakingInstance.leakTrace
+
+            val groupLeakTrace = if (leakingInstance.excludedLeak) {
+              val index = leakTrace.elements.indexOfFirst { element -> element.exclusion != null }
+              LeakTrace(
+                  elements = listOf(leakTrace.elements[index]),
+                  expectedReachability = listOf(leakTrace.expectedReachability[index])
+              )
+            } else {
+              val elements = mutableListOf<LeakTraceElement>()
+              val expectedReachability = mutableListOf<Reachability>()
+              for (index in 0 until leakTrace.elements.size) {
+                if (leakTrace.elementMayBeLeakCause(index)) {
+                  var element = leakTrace.elements[index]
+
+                  val reference = element.reference!!
+                  if (reference.type == ARRAY_ENTRY) {
+                    // No array index in groups
+                    element = element.copy(reference = reference.copy(name = "x"))
+                  }
+
+                  elements.add(element)
+                  expectedReachability.add(leakTrace.expectedReachability[index])
+                }
+              }
+              LeakTrace(elements, expectedReachability)
+            }
+            val groupDescription = cursor.getString(1)!!
+            groupLeakTrace to groupDescription
+          } else
+            null
+        } ?: return null
+
+    val projections = db.rawQuery(
+        """
+         SELECT
+          l.id
+          , class_simple_name
+          , h.created_at_time_millis
+          FROM leaking_instance l
+          LEFT JOIN heap_analysis h ON l.heap_analysis_id = h.id
+          WHERE l.group_hash = ?
+          ORDER BY h.created_at_time_millis DESC
+          """, arrayOf(groupHash)
+    )
+        .use { cursor ->
+          val projections = mutableListOf<InstanceProjection>()
+          while (cursor.moveToNext()) {
+            projections.add(
+                InstanceProjection(
+                    id = cursor.getLong(0),
+                    classSimpleName = cursor.getString(1),
+                    createdAtTimeMillis = cursor.getLong(2)
+                )
+            )
+          }
+          projections
+        }
+
+    return pair to projections
+  }
+
+  fun deleteByHeapAnalysisId(
+    db: SQLiteDatabase,
+    heapAnalysisId: Long
+  ) {
+    db.delete("leaking_instance", "heap_analysis_id=$heapAnalysisId", null)
+  }
+
+  fun deleteAll(db: SQLiteDatabase) {
+    db.delete("leaking_instance", null, null)
+  }
+
+  private fun LeakingInstance.createGroupDescription(): String {
+    return if (excludedLeak) {
+      "[Excluded] " + leakTrace.firstElementExclusion.matching
+    } else {
+      val element = leakTrace.leakCauses.first()
+      val referenceName = element.reference!!.groupingName
+      element.getSimpleClassName() + "." + referenceName
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
new file mode 100644
index 00000000..37588cf9
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
@@ -0,0 +1,24 @@
+package leakcanary.internal.activity.db
+
+import android.content.Context
+import android.database.sqlite.SQLiteDatabase
+import android.database.sqlite.SQLiteOpenHelper
+
+internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
+    context, "leaks.db", null, 1
+) {
+
+  override fun onCreate(db: SQLiteDatabase) {
+    db.execSQL(HeapAnalysisTable.create)
+    db.execSQL(LeakingInstanceTable.create)
+    db.execSQL(LeakingInstanceTable.createGroupHashIndex)
+  }
+
+  override fun onUpgrade(
+    db: SQLiteDatabase,
+    oldVersion: Int,
+    newVersion: Int
+  ) {
+    TODO("Upgrade not needed yet")
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt
new file mode 100644
index 00000000..09ddbce6
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt
@@ -0,0 +1,77 @@
+package leakcanary.internal.activity.screen
+
+import android.app.AlertDialog
+import android.graphics.drawable.Drawable
+import android.text.Html
+import android.text.Html.ImageGetter
+import android.text.format.DateUtils
+import android.text.method.LinkMovementMethod
+import android.view.ViewGroup
+import android.widget.ListView
+import android.widget.TextView
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.activity.db
+import leakcanary.internal.activity.db.LeakingInstanceTable
+import leakcanary.internal.activity.ui.SimpleListAdapter
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.goTo
+import leakcanary.internal.navigation.inflate
+import leakcanary.internal.navigation.onCreateOptionsMenu
+
+internal class GroupListScreen : Screen() {
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_list).apply {
+      val projections = LeakingInstanceTable.retrieveAllGroups(db)
+
+      // TODO String res
+      activity.title = "${projections.size} leak groups"
+
+      val listView = findViewById<ListView>(R.id.leak_canary_list)
+
+      listView.adapter =
+        SimpleListAdapter(R.layout.leak_canary_leak_row, projections) { view, position ->
+          val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
+          val timeView = view.findViewById<TextView>(R.id.leak_canary_row_time)
+
+          val projection = projections[position]
+
+          // TODO String res
+          titleView.text = "(${projection.leakCount}) ${projection.description}"
+
+          // TODO String res
+          timeView.text = "Latest: " + DateUtils.formatDateTime(
+              view.context, projection.createdAtTimeMillis,
+              DateUtils.FORMAT_SHOW_TIME or DateUtils.FORMAT_SHOW_DATE
+          )
+        }
+
+      listView.setOnItemClickListener { _, _, position, _ ->
+        goTo(GroupScreen(projections[position].hash))
+      }
+
+      onCreateOptionsMenu { menu ->
+        menu.add("See analysis list")
+            .setOnMenuItemClickListener {
+              goTo(HeapAnalysisListScreen())
+              true
+            }
+
+        menu.add(R.string.leak_canary_about_title)
+            .setOnMenuItemClickListener {
+              val dialog = AlertDialog.Builder(context)
+                  .setIcon(resources.getDrawable(R.drawable.leak_canary_icon))
+                  .setTitle(R.string.leak_canary_about_title)
+                  .setMessage(
+                      Html.fromHtml(resources.getString(R.string.leak_canary_about_message))
+                  )
+                  .setPositiveButton(android.R.string.ok, null)
+                  .show()
+              val messageView = dialog.findViewById<TextView>(android.R.id.message)
+              messageView.movementMethod = LinkMovementMethod.getInstance()
+              true
+            }
+      }
+
+    }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt
new file mode 100644
index 00000000..8bc1d02b
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt
@@ -0,0 +1,45 @@
+package leakcanary.internal.activity.screen
+
+import android.view.ViewGroup
+import android.widget.ListView
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.DisplayLeakAdapter
+import leakcanary.internal.activity.db
+import leakcanary.internal.activity.db.LeakingInstanceTable
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.goTo
+import leakcanary.internal.navigation.inflate
+
+internal class GroupScreen(private val groupHash: String) : Screen() {
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_list).apply {
+
+      val triple = LeakingInstanceTable.retrieveGroup(db, groupHash)
+
+      if (triple == null) {
+        // TODO String res
+        activity.title = "Analysis deleted"
+        return this
+      }
+
+      // TODO add projects to list.
+      val (leakTrace, groupDescription, projections) = triple
+
+      // TODO String res
+      activity.title = "${projections.size} leaks in $groupDescription"
+
+      val listView = findViewById<ListView>(R.id.leak_canary_list)
+
+      val adapter = DisplayLeakAdapter(resources, leakTrace, projections)
+      listView.adapter = adapter
+
+      listView.setOnItemClickListener { _, _, position, _ ->
+        val index = position - (adapter.count - projections.size)
+        if (index >= 0) {
+          goTo(LeakingInstanceScreen(projections[index].id))
+        }
+      }
+
+    }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt
new file mode 100644
index 00000000..b88173af
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt
@@ -0,0 +1,71 @@
+package leakcanary.internal.activity.screen
+
+import android.view.ViewGroup
+import android.widget.TextView
+import com.squareup.leakcanary.core.BuildConfig
+import com.squareup.leakcanary.core.R
+import com.squareup.leakcanary.core.R.string
+import leakcanary.HeapAnalysisFailure
+import leakcanary.internal.activity.db
+import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.share
+import leakcanary.internal.activity.shareHeapDump
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.goBack
+import leakcanary.internal.navigation.inflate
+import leakcanary.internal.navigation.onCreateOptionsMenu
+
+internal class HeapAnalysisFailureScreen(
+  private val analysisId: Long
+) : Screen() {
+
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_heap_analysis_failure_screen).apply {
+      val pair = HeapAnalysisTable.retrieve<HeapAnalysisFailure>(db, analysisId)
+
+      if (pair == null) {
+        activity.title = "Analysis deleted"
+        return this
+      }
+
+      val (heapAnalysis, _) = pair
+
+      activity.title = resources.getString(R.string.leak_canary_analysis_failed)
+
+      val failureTextView = findViewById<TextView>(R.id.leak_canary_failure)
+      val path = heapAnalysis.heapDump.heapDumpFile.absolutePath
+
+      val failureText = """
+          |${resources.getString(string.leak_canary_failure_report)}
+          |LeakCanary ${BuildConfig.LIBRARY_VERSION} ${BuildConfig.GIT_SHA}
+          |${heapAnalysis.exception}
+          |${resources.getString(string.leak_canary_download_dump, path)}
+          """.trimMargin()
+      failureTextView.text = failureText
+
+      onCreateOptionsMenu { menu ->
+        menu.add(R.string.leak_canary_share_leak)
+            .setOnMenuItemClickListener {
+              // TODO Add version information
+              share(heapAnalysis.exception.toString())
+              true
+            }
+        menu.add(R.string.leak_canary_delete)
+            .setOnMenuItemClickListener {
+              HeapAnalysisTable.delete(db, analysisId, heapAnalysis.heapDump)
+              goBack()
+              true
+            }
+        if (heapAnalysis.heapDump.heapDumpFile.exists()) {
+          menu.add(R.string.leak_canary_share_heap_dump)
+              .setOnMenuItemClickListener {
+                shareHeapDump(heapAnalysis.heapDump)
+                true
+              }
+        }
+
+      }
+    }
+
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt
new file mode 100644
index 00000000..1793adb0
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt
@@ -0,0 +1,80 @@
+package leakcanary.internal.activity.screen
+
+import android.annotation.SuppressLint
+import android.app.AlertDialog
+import android.text.format.DateUtils
+import android.view.View
+import android.view.ViewGroup
+import android.widget.BaseAdapter
+import android.widget.ListView
+import android.widget.TextView
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.activity.db
+import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.db.HeapAnalysisTable.Projection
+import leakcanary.internal.activity.ui.SimpleListAdapter
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.goTo
+import leakcanary.internal.navigation.inflate
+import leakcanary.internal.navigation.onCreateOptionsMenu
+
+// TODO Fix
+@SuppressLint("SetTextI18n")
+internal class HeapAnalysisListScreen : Screen() {
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_list).apply {
+      // TODO String res
+      activity.title = "All analyses"
+
+      val listView = findViewById<ListView>(R.id.leak_canary_list)
+
+      onCreateOptionsMenu { menu ->
+        menu.add(R.string.leak_canary_delete_all)
+            .setOnMenuItemClickListener {
+              AlertDialog.Builder(context)
+                  .setIcon(android.R.drawable.ic_dialog_alert)
+                  .setTitle(R.string.leak_canary_delete_all)
+                  .setMessage(R.string.leak_canary_delete_all_leaks_title)
+                  .setPositiveButton(android.R.string.ok) { _, _ ->
+                    HeapAnalysisTable.deleteAll(db, context)
+                    listView.adapter =
+                      SimpleListAdapter(R.layout.leak_canary_leak_row, emptyList<Any>()) { _, _ -> }
+                  }
+                  .setNegativeButton(android.R.string.cancel, null)
+                  .show()
+              true
+            }
+      }
+
+      val projections = HeapAnalysisTable.retrieveAll(db)
+
+      listView.setOnItemClickListener { _, _, position, _ ->
+        val projection = projections[position]
+        val analysisScreen = if (projection.exceptionSummary != null)
+          HeapAnalysisFailureScreen(projection.id)
+        else
+          HeapAnalysisSuccessScreen(projection.id)
+        goTo(analysisScreen)
+      }
+
+      listView.adapter =
+        SimpleListAdapter(R.layout.leak_canary_leak_row, projections) { view, position ->
+          val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
+          val timeView = view.findViewById<TextView>(R.id.leak_canary_row_time)
+          val index = count - position
+
+          val projection = getItem(position)
+
+          timeView.text = DateUtils.formatDateTime(
+              view.context, projection.createdAtTimeMillis,
+              DateUtils.FORMAT_SHOW_TIME or DateUtils.FORMAT_SHOW_DATE
+          )
+
+          titleView.text = "$index. " + (projection.exceptionSummary
+          // TODO Handle singular
+              ?: "${projection.retainedInstanceCount} retained instances")
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
new file mode 100644
index 00000000..e60f255b
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
@@ -0,0 +1,141 @@
+package leakcanary.internal.activity.screen
+
+import android.annotation.SuppressLint
+import android.text.format.DateUtils
+import android.view.ViewGroup
+import android.widget.ListView
+import android.widget.TextView
+import com.squareup.leakcanary.core.R
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.LeakingInstance
+import leakcanary.NoPathToInstance
+import leakcanary.WeakReferenceCleared
+import leakcanary.WeakReferenceMissing
+import leakcanary.internal.activity.db
+import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.shareHeapDump
+import leakcanary.internal.activity.ui.SimpleListAdapter
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.goBack
+import leakcanary.internal.navigation.goTo
+import leakcanary.internal.navigation.inflate
+import leakcanary.internal.navigation.onCreateOptionsMenu
+
+// TODO Remove
+@SuppressLint("SetTextI18n")
+internal class HeapAnalysisSuccessScreen(
+  private val analysisId: Long
+) : Screen() {
+
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_list).apply {
+      val pair = HeapAnalysisTable.retrieve<HeapAnalysisSuccess>(db, analysisId)
+
+      if (pair == null) {
+        // TODO String res
+        activity.title = "Analysis deleted"
+        return this
+      }
+
+      val (heapAnalysis, leakGroupByHash) = pair
+
+      // TODO String res
+      activity.title = "Heap Analysis (${heapAnalysis.retainedInstances.size} retained instances)"
+
+      onCreateOptionsMenu { menu ->
+        menu.add(R.string.leak_canary_delete)
+            .setOnMenuItemClickListener {
+              HeapAnalysisTable.delete(db, analysisId, heapAnalysis.heapDump)
+              goBack()
+              true
+            }
+        if (heapAnalysis.heapDump.heapDumpFile.exists()) {
+          menu.add(R.string.leak_canary_share_heap_dump)
+              .setOnMenuItemClickListener {
+                shareHeapDump(heapAnalysis.heapDump)
+                true
+              }
+          menu.add("Render Heap Dump")
+              .setOnMenuItemClickListener {
+                goTo(RenderHeapDumpScreen(heapAnalysis.heapDump.heapDumpFile))
+                true
+              }
+        }
+      }
+
+      val listView = findViewById<ListView>(R.id.leak_canary_list)
+
+      val retainedInstances = heapAnalysis.retainedInstances
+
+      var weakReferenceClearedCount = 0
+      var noPathToInstanceCount = 0
+      var weakReferenceMissingCount = 0
+      retainedInstances.forEach { retainedInstance ->
+        // if a leak, add to a map of groupSha -> (description, count, total count, time)
+        // => instead of list of shas we can get the list of projections that already exists
+        // TODO If the sha doesn't exist in the map then this is a removed group. Can't happen
+        // right now as we don't allow removing groups
+        when (retainedInstance) {
+          is LeakingInstance -> {
+            if (leakGroupByHash[retainedInstance.groupHash] == null) {
+              TODO("Removing groups is not supported yet, this should not happen yet.")
+            }
+          }
+          is WeakReferenceCleared -> {
+            weakReferenceClearedCount++
+          }
+          is NoPathToInstance -> {
+            noPathToInstanceCount++
+          }
+          is WeakReferenceMissing -> {
+            weakReferenceMissingCount++
+          }
+        }
+      }
+
+      val rowList = mutableListOf<Pair<String, String>>()
+
+      val leakGroups = leakGroupByHash.values.toList()
+
+      rowList.addAll(leakGroups.map { projection ->
+        val titleText =
+          "(${projection.leakCount} / ${projection.totalLeakCount} total) ${projection.description}"
+        val timeText = "Latest: " + DateUtils.formatDateTime(
+            context, projection.createdAtTimeMillis,
+            DateUtils.FORMAT_SHOW_TIME or DateUtils.FORMAT_SHOW_DATE
+        )
+        titleText to timeText
+      })
+
+      if (weakReferenceClearedCount > 0) {
+        rowList.add("$weakReferenceClearedCount already cleared weak references" to "")
+      }
+
+      if (noPathToInstanceCount > 0) {
+        rowList.add("$noPathToInstanceCount non leaking retained instances" to "")
+      }
+
+      if (weakReferenceMissingCount > 0) {
+        rowList.add("$weakReferenceMissingCount garbage collected weak references" to "")
+      }
+
+
+      listView.adapter =
+        SimpleListAdapter(R.layout.leak_canary_leak_row, rowList) { view, position ->
+          val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
+          val timeView = view.findViewById<TextView>(R.id.leak_canary_row_time)
+
+          val (titleText, timeText) = getItem(position)
+
+          titleView.text = titleText
+          timeView.text = timeText
+        }
+
+      listView.setOnItemClickListener { _, _, position, _ ->
+        if (position < leakGroupByHash.size) {
+          goTo(GroupScreen(leakGroups[position].hash))
+        }
+      }
+    }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
new file mode 100644
index 00000000..45e3ba68
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
@@ -0,0 +1,94 @@
+package leakcanary.internal.activity.screen
+
+import android.view.ViewGroup
+import android.widget.ListView
+import com.squareup.leakcanary.core.R
+import com.squareup.leakcanary.core.R.string
+import leakcanary.LeakingInstance
+import leakcanary.internal.DisplayLeakAdapter
+import leakcanary.internal.activity.db
+import leakcanary.internal.activity.screen.LeakingInstanceScreen.InstanceOrId.Id
+import leakcanary.internal.activity.screen.LeakingInstanceScreen.InstanceOrId.Instance
+import leakcanary.internal.activity.db.LeakingInstanceTable
+import leakcanary.internal.activity.share
+import leakcanary.internal.activity.shareToStackOverflow
+import leakcanary.internal.lastSegment
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.goTo
+import leakcanary.internal.navigation.inflate
+import leakcanary.internal.navigation.onCreateOptionsMenu
+import java.io.Serializable
+
+// TODO Store leaktraces in db and pass an id here (needed for grouping)
+internal class LeakingInstanceScreen private constructor(
+  private val instanceOrId: InstanceOrId
+) : Screen() {
+
+  constructor(id: Long) : this(Id(id))
+
+  constructor(
+    heapAnalysisId: Long,
+    instance: LeakingInstance
+  ) : this(Instance(heapAnalysisId, instance))
+
+  sealed class InstanceOrId : Serializable {
+    class Instance(
+      val heapAnalysisId: Long,
+      val instance: LeakingInstance
+    ) : InstanceOrId()
+
+    class Id(val id: Long) : InstanceOrId()
+  }
+
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_list).apply {
+
+      val pair = when (instanceOrId) {
+        is Instance -> instanceOrId.heapAnalysisId to instanceOrId.instance
+        is Id -> LeakingInstanceTable.retrieve(db, instanceOrId.id)
+      }
+
+      if (pair == null) {
+        // TODO String res
+        activity.title = "Analysis deleted"
+        return this
+      }
+
+      val (heapAnalysisId, leakingInstance) = pair
+
+      val classSimpleName = leakingInstance.instanceClassName.lastSegment('.')
+      activity.title = resources.getString(string.leak_canary_class_has_leaked, classSimpleName)
+
+      val listView = findViewById<ListView>(R.id.leak_canary_list)
+
+      val adapter =
+        DisplayLeakAdapter(resources, leakingInstance.leakTrace, leakingInstance.referenceName)
+      listView.adapter = adapter
+
+      listView.setOnItemClickListener { _, _, position, _ ->
+        adapter.toggleRow(position)
+      }
+
+      onCreateOptionsMenu { menu ->
+        // TODO String res
+        menu.add("Go to heap analysis")
+            .setOnMenuItemClickListener {
+              goTo(HeapAnalysisSuccessScreen(heapAnalysisId))
+              true
+            }
+        menu.add(R.string.leak_canary_share_leak)
+            .setOnMenuItemClickListener {
+              // TODO Add version information
+              share(leakingInstance.toString())
+              true
+            }
+        menu.add(R.string.leak_canary_stackoverflow_share)
+            .setOnMenuItemClickListener {
+              // TODO Add version information
+              shareToStackOverflow(leakingInstance.toString())
+              true
+            }
+      }
+    }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
new file mode 100644
index 00000000..cc22ecb4
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
@@ -0,0 +1,148 @@
+package leakcanary.internal.activity.screen
+
+import android.content.Intent
+import android.graphics.Bitmap
+import android.os.AsyncTask
+import android.os.Environment
+import android.os.Environment.DIRECTORY_DOWNLOADS
+import android.view.View
+import android.view.ViewGroup
+import android.view.ViewTreeObserver.OnGlobalLayoutListener
+import android.widget.ImageView
+import android.widget.Toast
+import androidx.core.content.FileProvider
+import com.squareup.leakcanary.core.R
+import leakcanary.CanaryLog
+import leakcanary.internal.LeakCanaryUtils
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.inflate
+import leakcanary.internal.navigation.onCreateOptionsMenu
+import java.io.File
+import java.io.FileOutputStream
+import java.io.IOException
+
+internal class RenderHeapDumpScreen(
+  private val heapDumpFile: File
+) : Screen() {
+
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_heap_render).apply {
+      // TODO String res
+      container.activity.title =
+        "Heap Dump (${humanReadableByteCount(heapDumpFile.length(), false)})"
+
+      val loadingView = findViewById<View>(R.id.leak_canary_loading)
+      val imageView = findViewById<ImageView>(R.id.leak_canary_heap_rendering)
+
+      viewTreeObserver.addOnGlobalLayoutListener(object : OnGlobalLayoutListener {
+        override fun onGlobalLayout() {
+          RenderHeapDumpTask.renderAsync(
+              resources,
+              heapDumpFile, measuredWidth, measuredHeight, 0
+          ) { bitmap ->
+            imageView.setImageBitmap(bitmap)
+            loadingView.visibility = View.GONE
+            imageView.visibility = View.VISIBLE
+          }
+          viewTreeObserver.removeGlobalOnLayoutListener(this)
+        }
+
+      })
+
+      onCreateOptionsMenu { menu ->
+        menu.add("Generate HQ Bitmap")
+            .setOnMenuItemClickListener {
+
+              val leakDirectoryProvider = LeakCanaryUtils.getLeakDirectoryProvider(activity)
+              if (!leakDirectoryProvider.hasStoragePermission()) {
+                // TODO String res
+                Toast.makeText(
+                    context,
+                    "Please grant the external storage permission first, see notification.",
+                    Toast.LENGTH_LONG
+                )
+                    .show()
+                leakDirectoryProvider.requestWritePermissionNotification()
+              } else {
+                // TODO String res
+                Toast.makeText(
+                    context, "Rendering HQ bitmap, this may take a while", Toast.LENGTH_LONG
+                )
+                    .show()
+                RenderHeapDumpTask.renderAsync(
+                    resources,
+                    heapDumpFile, 2048, 0, 4
+                ) { bitmap ->
+
+                  AsyncTask.THREAD_POOL_EXECUTOR.execute {
+
+                    val storageDir =
+                      Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS)
+
+                    val imageFile = File(storageDir, "${heapDumpFile.name}.png")
+                    val saved = savePng(imageFile, bitmap)
+                    if (saved) {
+                      CanaryLog.d("Png saved at $imageFile")
+                      imageFile.setReadable(true, false)
+                      val imageUri = FileProvider.getUriForFile(
+                          activity,
+                          "com.squareup.leakcanary.fileprovider." + activity.packageName,
+                          imageFile
+                      )
+                      activity.runOnUiThread {
+                        val intent = Intent(Intent.ACTION_SEND)
+                        intent.type = "image/png"
+                        intent.putExtra(Intent.EXTRA_STREAM, imageUri)
+                        activity.startActivity(
+                            Intent.createChooser(intent, "Share heap dump bitmap")
+                        )
+                      }
+                    } else {
+                      activity.runOnUiThread {
+                        // TODO String res
+                        Toast.makeText(
+                            context, "Could not save HQ bitmap", Toast.LENGTH_LONG
+                        )
+                            .show()
+                      }
+
+                    }
+                  }
+                }
+              }
+              true
+            }
+
+      }
+    }
+
+  // https://stackoverflow.com/a/3758880
+  fun humanReadableByteCount(
+    bytes: Long,
+    si: Boolean
+  ): String {
+    val unit = if (si) 1000 else 1024
+    if (bytes < unit) return "$bytes B"
+    val exp = (Math.log(bytes.toDouble()) / Math.log(unit.toDouble())).toInt()
+    val pre = (if (si) "kMGTPE" else "KMGTPE")[exp - 1] + if (si) "" else "i"
+    return String.format("%.1f %sB", bytes / Math.pow(unit.toDouble(), exp.toDouble()), pre)
+  }
+
+  fun savePng(
+    imageFile: File,
+    source: Bitmap
+  ): Boolean {
+    var outStream: FileOutputStream? = null
+    return try {
+      outStream = FileOutputStream(imageFile)
+      source.compress(Bitmap.CompressFormat.PNG, 100, outStream)
+      true
+    } catch (e: IOException) {
+      false
+    } finally {
+      outStream?.close()
+    }
+  }
+}
+
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpTask.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpTask.kt
new file mode 100644
index 00000000..385fccb1
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpTask.kt
@@ -0,0 +1,303 @@
+package leakcanary.internal.activity.screen
+
+import android.content.res.Resources
+import android.graphics.Bitmap
+import android.graphics.Bitmap.Config.ARGB_8888
+import android.graphics.Canvas
+import android.graphics.Color
+import android.graphics.Paint
+import android.graphics.Paint.Style.FILL
+import android.graphics.Paint.Style.STROKE
+import android.graphics.Rect
+import android.os.AsyncTask
+import android.os.Handler
+import android.os.Looper
+import com.squareup.leakcanary.core.R
+import leakcanary.HprofParser
+import leakcanary.HprofParser.RecordCallbacks
+import leakcanary.Record
+import leakcanary.Record.HeapDumpEndRecord
+import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import leakcanary.Record.LoadClassRecord
+import leakcanary.Record.StackTraceRecord
+import leakcanary.Record.StringRecord
+import java.io.File
+
+class RenderHeapDumpTask private constructor(
+  private val resources: Resources,
+  private val heapDumpFile: File,
+  private val width: Int,
+  private val height: Int,
+  private val bytesPerPixel: Int,
+  private var resultCallback: ((Bitmap) -> Unit)?
+) {
+
+  private val uiHandler = Handler(Looper.getMainLooper())
+
+  private val runnable = Runnable {
+    val parser = HprofParser.open(heapDumpFile)
+
+    val recordPositions = mutableListOf<Pair<Int, Long>>()
+    var currentRecord: Record? = null
+
+    val otherColor = resources.getColor(R.color.leak_canary_heap_other)
+    val stackTraceColor = resources.getColor(R.color.leak_canary_heap_stack_trace)
+    val hprofStringColor = resources.getColor(R.color.leak_canary_heap_hprof_string)
+    val loadClassColor = resources.getColor(R.color.leak_canary_heap_load_class)
+    val classDumpColor = resources.getColor(R.color.leak_canary_heap_class_dump)
+    val instanceColor = resources.getColor(R.color.leak_canary_heap_instance)
+    val objectArrayColor = resources.getColor(R.color.leak_canary_heap_object_array)
+    val booleanArrayColor = resources.getColor(R.color.leak_canary_heap_boolean_array)
+    val charArrayColor = resources.getColor(R.color.leak_canary_heap_char_array)
+    val floatArrayColor = resources.getColor(R.color.leak_canary_heap_float_array)
+    val doubleArrayColor = resources.getColor(R.color.leak_canary_heap_double_array)
+    val byteArrayColor = resources.getColor(R.color.leak_canary_heap_byte_array)
+    val shortArrayColor = resources.getColor(R.color.leak_canary_heap_short_array)
+    val intArrayColor = resources.getColor(R.color.leak_canary_heap_int_array)
+    val longArrayColor = resources.getColor(R.color.leak_canary_heap_long_array)
+    val colors = mapOf(
+        StringRecord::class to hprofStringColor,
+        LoadClassRecord::class to loadClassColor,
+        ClassDumpRecord::class to classDumpColor,
+        InstanceDumpRecord::class to instanceColor,
+        ObjectArrayDumpRecord::class to objectArrayColor,
+        BooleanArrayDump::class to booleanArrayColor,
+        CharArrayDump::class to charArrayColor,
+        FloatArrayDump::class to floatArrayColor,
+        DoubleArrayDump::class to doubleArrayColor,
+        ByteArrayDump::class to byteArrayColor,
+        ShortArrayDump::class to shortArrayColor,
+        IntArrayDump::class to intArrayColor,
+        LongArrayDump::class to longArrayColor,
+        StackTraceRecord::class to stackTraceColor,
+        HeapDumpEndRecord::class to otherColor
+    )
+
+    val appHeapColor = resources.getColor(R.color.leak_canary_heap_app)
+    val imageHeapColor = resources.getColor(R.color.leak_canary_heap_image)
+    val zygoteHeapColor = resources.getColor(R.color.leak_canary_heap_zygote)
+    val stringColor = resources.getColor(R.color.leak_canary_heap_instance_string)
+
+    val updatePosition: (Record) -> Unit =
+      { newRecord ->
+        val localCurrentRecord = currentRecord
+        when {
+          localCurrentRecord is HeapDumpInfoRecord -> {
+            val colorForHeapInfo =
+              when (parser.hprofStringById(localCurrentRecord.heapNameStringId)) {
+                // The primary heap on which your app allocates memory.
+                "app" -> appHeapColor
+                // The system boot image, containing classes that are preloaded during boot time.
+                // Allocations here are guaranteed to never move or go away.
+                "image" -> imageHeapColor
+                // The copy-on-write heap where an app process is forked from in the Android system.
+                "zygote" -> zygoteHeapColor
+                // JNI heap: The heap that shows where Java Native Interface (JNI) references are allocated and released.
+                // default heap: When no heap is specified by the system
+                else -> otherColor
+              }
+            recordPositions.add(colorForHeapInfo to parser.position)
+            currentRecord = newRecord
+          }
+          localCurrentRecord is InstanceDumpRecord
+              && parser.className(localCurrentRecord.classId) == "java.lang.String"
+              && (newRecord !is InstanceDumpRecord || parser.className(
+              newRecord.classId
+          ) != "java.lang.String")
+          -> {
+            recordPositions.add(stringColor to parser.position)
+            currentRecord = newRecord
+          }
+          currentRecord == null -> {
+            recordPositions.add(otherColor to parser.position)
+            currentRecord = newRecord
+          }
+          currentRecord!!::class != newRecord::class -> {
+            recordPositions.add(colors.getValue(currentRecord!!::class) to parser.position)
+            currentRecord = newRecord
+          }
+        }
+      }
+
+    parser.scan(
+        RecordCallbacks()
+            .on(StringRecord::class.java, updatePosition)
+            .on(LoadClassRecord::class.java, updatePosition)
+            .on(ClassDumpRecord::class.java, updatePosition)
+            .on(InstanceDumpRecord::class.java, updatePosition)
+            .on(ObjectArrayDumpRecord::class.java, updatePosition)
+            .on(PrimitiveArrayDumpRecord::class.java, updatePosition)
+            .on(HeapDumpInfoRecord::class.java, updatePosition)
+            .on(HeapDumpEndRecord::class.java, updatePosition)
+            .on(StackTraceRecord::class.java, updatePosition)
+    )
+
+    val heapLength = parser.position
+    parser.close()
+
+    val width = width
+
+    var height: Int
+    val bytesPerPixel: Double
+
+    if (this.bytesPerPixel > 0) {
+      bytesPerPixel = this.bytesPerPixel.toDouble()
+      height = Math.ceil((heapLength / bytesPerPixel) / width)
+          .toInt()
+    } else {
+      height = this.height
+      bytesPerPixel = heapLength * 1.0 / (width * height)
+    }
+
+    val bitmap: Bitmap =
+      Bitmap.createBitmap(width, height, ARGB_8888)
+
+    val canvas = Canvas(bitmap)
+
+    val legend = mapOf(
+        "Hprof string" to hprofStringColor,
+        "Class name" to loadClassColor,
+        "App heap" to appHeapColor,
+        "Image heap" to imageHeapColor,
+        "Zygote heap" to zygoteHeapColor,
+        "Other heap" to otherColor,
+        "Class content" to classDumpColor,
+        "Instance" to instanceColor,
+        "String" to stringColor,
+        "Object array" to objectArrayColor,
+        "Boolean array" to booleanArrayColor,
+        "Char array" to charArrayColor,
+        "Float array" to floatArrayColor,
+        "Double array" to doubleArrayColor,
+        "Byte array" to byteArrayColor,
+        "Short array" to shortArrayColor,
+        "Int array" to intArrayColor,
+        "Long array" to longArrayColor,
+        "Stack trace" to stackTraceColor,
+        "Heap End" to otherColor
+    )
+
+    val legendTextPaint = Paint(Paint.ANTI_ALIAS_FLAG)
+
+    legendTextPaint.color = Color.WHITE
+    legendTextPaint.style = FILL
+    canvas.drawPaint(legendTextPaint)
+
+    val legendSquareFillPaint = Paint()
+    legendSquareFillPaint.style = FILL
+    val legendSquareStrokePaint = Paint()
+    legendSquareStrokePaint.style = STROKE
+    legendSquareStrokePaint.strokeWidth = 0.8f.dp
+    legendSquareStrokePaint.color = Color.BLACK
+
+    legendTextPaint.color = Color.BLACK
+    legendTextPaint.textSize = 16.dp
+
+    val metrics = legendTextPaint.fontMetrics
+    val textHeight = metrics.descent - metrics.ascent
+
+    val xBounds = Rect()
+    legendTextPaint.getTextBounds("x", 0, 1, xBounds)
+    val squareSize = xBounds.height()
+    val squarePaddingTop = (textHeight - squareSize) / 2
+    val squareToTextPadding = 4.dp
+    val blockToBlockPadding = 8.dp
+
+    var maxTextWidth = 0f
+    for (name in legend.keys) {
+      maxTextWidth = Math.max(maxTextWidth, legendTextPaint.measureText(name))
+    }
+
+    val padding = 8.dp
+    var blockLeft = padding
+    var blockTop = padding
+    val legendWidth = width - 2 * padding
+    for ((name, color) in legend) {
+      if (blockLeft + squareSize + squareToTextPadding + maxTextWidth > legendWidth) {
+        blockLeft = padding
+        blockTop += textHeight
+      }
+
+      legendSquareFillPaint.color = color
+      canvas.drawRect(
+          blockLeft, blockTop + squarePaddingTop, blockLeft + squareSize,
+          blockTop + squarePaddingTop + squareSize,
+          legendSquareFillPaint
+      )
+      canvas.drawRect(
+          blockLeft, blockTop + squarePaddingTop, blockLeft + squareSize,
+          blockTop + squarePaddingTop + squareSize,
+          legendSquareStrokePaint
+      )
+      blockLeft += squareSize + squareToTextPadding
+      canvas.drawText(name, blockLeft, blockTop - metrics.ascent, legendTextPaint)
+      blockLeft += maxTextWidth
+      blockLeft += blockToBlockPadding
+    }
+    val legendHeight = blockTop + textHeight + padding
+    val source = Rect(0, 0, width, legendHeight.toInt())
+    val destination = Rect(0, (height - legendHeight).toInt(), width, height)
+    canvas.drawBitmap(bitmap, source, destination, null)
+    height -= legendHeight.toInt()
+
+    val pixelPaint = Paint()
+    pixelPaint.style = FILL
+
+    var recordIndex = 0
+    for (y in 0 until height) {
+      for (x in 0 until width) {
+        val bitmapPosition = y * width + x
+        val heapPosition = (bitmapPosition * bytesPerPixel).toInt()
+        while (heapPosition > recordPositions[recordIndex].second && recordIndex < recordPositions.lastIndex) {
+          recordIndex++
+        }
+        pixelPaint.color = recordPositions[recordIndex].first
+        canvas.drawPoint(x.toFloat(), y.toFloat(), pixelPaint)
+      }
+    }
+    uiHandler.post {
+      resultCallback?.invoke(bitmap)
+    }
+  }
+
+  private val Int.dp
+    get() = this * resources.displayMetrics.density
+
+  private val Float.dp
+    get() = this * resources.displayMetrics.density
+
+  fun cancel() {
+    resultCallback = null
+  }
+
+  companion object {
+    fun renderAsync(
+      resources: Resources,
+      heapDumpFile: File,
+      width: Int,
+      height: Int,
+      /**
+       * If [bytesPerPixel] > 0 then height will be ignored.
+       */
+      bytesPerPixel: Int,
+      resultCallback: ((Bitmap) -> Unit)?
+    ): RenderHeapDumpTask {
+      val renderTask =
+        RenderHeapDumpTask(resources, heapDumpFile, width, height, bytesPerPixel, resultCallback)
+      AsyncTask.THREAD_POOL_EXECUTOR.execute(renderTask.runnable)
+      return renderTask
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt
new file mode 100644
index 00000000..29264091
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt
@@ -0,0 +1,30 @@
+package leakcanary.internal.activity.ui
+
+import android.view.View
+import android.view.ViewGroup
+import android.widget.BaseAdapter
+import androidx.annotation.LayoutRes
+import leakcanary.internal.navigation.inflate
+
+class SimpleListAdapter<T>(
+  @LayoutRes
+  private val rowResId: Int,
+  private val items: List<T>,
+  private val bindView: SimpleListAdapter<T>.(View, Int) -> Unit
+) : BaseAdapter() {
+  override fun getView(
+    position: Int,
+    convertView: View?,
+    parent: ViewGroup
+  ): View {
+    val view = convertView ?: parent.inflate(rowResId)
+    bindView(view, position)
+    return view
+  }
+
+  override fun getItem(position: Int) = items[position]
+
+  override fun getItemId(position: Int) = position.toLong()
+
+  override fun getCount() = items.size
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/BackstackFrame.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/BackstackFrame.kt
new file mode 100644
index 00000000..59a8ad34
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/BackstackFrame.kt
@@ -0,0 +1,66 @@
+package leakcanary.internal.navigation
+
+import android.os.Parcel
+import android.os.Parcelable
+import android.util.SparseArray
+import android.view.View
+
+internal class BackstackFrame : Parcelable {
+
+  val screen: Screen
+  private val viewState: SparseArray<Parcelable>?
+
+  private constructor(
+    source: Parcel
+  ) {
+    this.screen = source.readSerializable() as Screen
+    @Suppress("UNCHECKED_CAST")
+    this.viewState = source.readSparseArray(javaClass.classLoader) as SparseArray<Parcelable>?
+  }
+
+  constructor(
+    screen: Screen
+  ) {
+    this.screen = screen
+    viewState = null
+  }
+
+  constructor(
+    screen: Screen,
+    view: View
+  ) {
+    this.screen = screen
+    viewState = SparseArray()
+    view.saveHierarchyState(viewState)
+  }
+
+  fun restore(view: View) {
+    if (viewState != null) {
+      view.restoreHierarchyState(viewState)
+    }
+  }
+
+  override fun describeContents() = 0
+
+  @Suppress("UNCHECKED_CAST")
+  override fun writeToParcel(
+    dest: Parcel,
+    flags: Int
+  ) {
+    dest.writeSerializable(screen)
+    dest.writeSparseArray(viewState as SparseArray<Any>?)
+  }
+
+  companion object {
+    @Suppress("UNCHECKED_CAST")
+    @JvmField val CREATOR = object : Parcelable.Creator<BackstackFrame> {
+      override fun createFromParcel(source: Parcel): BackstackFrame {
+        return BackstackFrame(source)
+      }
+
+      override fun newArray(size: Int): Array<BackstackFrame?> {
+        return arrayOfNulls(size)
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/NavigatingActivity.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/NavigatingActivity.kt
new file mode 100644
index 00000000..f53117e1
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/NavigatingActivity.kt
@@ -0,0 +1,147 @@
+package leakcanary.internal.navigation
+
+import android.app.Activity
+import android.content.Intent
+import android.os.Bundle
+import android.os.Parcelable
+import android.view.Menu
+import android.view.MenuItem
+import android.view.View
+import android.view.ViewGroup
+import android.view.animation.AnimationUtils.loadAnimation
+import com.squareup.leakcanary.core.R
+
+/**
+ * A simple backstack navigating activity
+ */
+internal abstract class NavigatingActivity : Activity() {
+
+  private lateinit var backstack: ArrayList<BackstackFrame>
+  private lateinit var currentScreen: Screen
+
+  private lateinit var container: ViewGroup
+  private lateinit var currentView: View
+
+  var onCreateOptionsMenu = NO_MENU
+
+  fun installNavigation(
+    savedInstanceState: Bundle?,
+    container: ViewGroup
+  ) {
+    this.container = container
+
+    if (savedInstanceState == null) {
+      backstack = ArrayList()
+      currentScreen = if (intent.hasExtra("screens")) {
+        @Suppress("UNCHECKED_CAST")
+        val screens = intent.getSerializableExtra("screens") as List<Screen>
+        screens.dropLast(1)
+            .forEach { screen ->
+              backstack.add(BackstackFrame(screen))
+            }
+        screens.last()
+      } else {
+        getLauncherScreen()
+      }
+    } else {
+      currentScreen = savedInstanceState.getSerializable("currentScreen") as Screen
+      @Suppress("UNCHECKED_CAST")
+      backstack = savedInstanceState.getParcelableArrayList<Parcelable>(
+          "backstack"
+      ) as ArrayList<BackstackFrame>
+    }
+    currentView = currentScreen.createView(container)
+    container.addView(currentView)
+    updateActionBar()
+  }
+
+  override fun onNewIntent(intent: Intent) {
+    if (intent.hasExtra("screens")) {
+      @Suppress("UNCHECKED_CAST")
+      val screens = intent.getSerializableExtra("screens") as List<Screen>
+      goTo(intent.getSerializableExtra("screen") as Screen)
+      backstack.clear()
+      screens.dropLast(1)
+          .forEach { screen ->
+            backstack.add(BackstackFrame(screen))
+          }
+    }
+  }
+
+  open fun getLauncherScreen(): Screen {
+    TODO("Launcher activities should override getLauncherScreen()")
+  }
+
+  public override fun onSaveInstanceState(outState: Bundle) {
+    super.onSaveInstanceState(outState)
+    outState.putSerializable("currentScreen", currentScreen)
+    outState.putParcelableArrayList("backstack", backstack)
+  }
+
+  override fun onBackPressed() {
+    if (backstack.size > 0) {
+      goBack()
+      return
+    }
+    super.onBackPressed()
+  }
+
+  fun goTo(screen: Screen) {
+    onCreateOptionsMenu = NO_MENU
+
+    currentView.startAnimation(loadAnimation(this, R.anim.leak_canary_exit_forward))
+    container.removeView(currentView)
+    val backstackFrame = BackstackFrame(currentScreen, currentView)
+    backstack.add(backstackFrame)
+
+    currentScreen = screen
+    currentView = currentScreen.createView(container)
+    currentView.startAnimation(loadAnimation(this, R.anim.leak_canary_enter_forward))
+    container.addView(currentView)
+
+    updateActionBar()
+  }
+
+  fun goBack() {
+    onCreateOptionsMenu = NO_MENU
+
+    currentView.startAnimation(loadAnimation(this, R.anim.leak_canary_exit_backward))
+    container.removeView(currentView)
+
+    val latest = backstack.removeAt(backstack.size - 1)
+    currentScreen = latest.screen
+    currentView = currentScreen.createView(container)
+    currentView.startAnimation(loadAnimation(this, R.anim.leak_canary_enter_backward))
+    container.addView(currentView, 0)
+    latest.restore(currentView)
+
+    updateActionBar()
+  }
+
+  private fun updateActionBar() {
+    invalidateOptionsMenu()
+    val actionBar = actionBar
+        ?: // https://github.com/square/leakcanary/issues/967
+        return
+    actionBar.setDisplayHomeAsUpEnabled(backstack.size > 0)
+  }
+
+  override fun onCreateOptionsMenu(menu: Menu): Boolean {
+    onCreateOptionsMenu.invoke(menu)
+    return true
+  }
+
+  override fun onOptionsItemSelected(item: MenuItem): Boolean =
+    when (item.itemId) {
+      android.R.id.home -> {
+        goBack()
+        true
+      }
+      else -> super.onOptionsItemSelected(item)
+    }
+
+  companion object {
+    val NO_MENU: ((Menu) -> Unit) = {}
+  }
+
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Screen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Screen.kt
new file mode 100644
index 00000000..85c4561f
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Screen.kt
@@ -0,0 +1,14 @@
+package leakcanary.internal.navigation
+
+import android.view.View
+import android.view.ViewGroup
+import java.io.Serializable
+
+/**
+ * Replaces Fragments, MVP, MVC, MVVM, MVMVMVM and everything else in just one tiny class.
+ * A screen is a location to go to, and it can build a view to display.
+ */
+internal abstract class Screen : Serializable {
+
+  abstract fun createView(container: ViewGroup): View
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt
new file mode 100644
index 00000000..d152db06
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt
@@ -0,0 +1,29 @@
+package leakcanary.internal.navigation
+
+import android.app.Activity
+import android.view.LayoutInflater
+import android.view.Menu
+import android.view.View
+import android.view.ViewGroup
+import androidx.annotation.LayoutRes
+
+internal fun ViewGroup.inflate(@LayoutRes layoutResId: Int) = LayoutInflater.from(context)
+    .inflate(layoutResId, this, false)!!
+
+internal val View.activity
+  get() = context as Activity
+
+@Suppress("UNCHECKED_CAST")
+internal fun <T : Activity> View.activity() = context as T
+
+internal fun View.onCreateOptionsMenu(onCreateOptionsMenu: (Menu) -> Unit) {
+  activity<NavigatingActivity>().onCreateOptionsMenu = onCreateOptionsMenu
+}
+
+internal fun View.goTo(screen: Screen) {
+  activity<NavigatingActivity>().goTo(screen)
+}
+
+internal fun View.goBack() {
+  activity<NavigatingActivity>().goBack()
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Tuples.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Tuples.kt
new file mode 100644
index 00000000..6a3164d3
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Tuples.kt
@@ -0,0 +1,3 @@
+package leakcanary.internal.utils
+
+infix fun <A, B, C> Pair<A, B>.to(that: C): Triple<A, B, C> = Triple(first, second, that)
diff --git a/leakcanary-android-core/src/main/res/anim/leak_canary_enter_backward.xml b/leakcanary-android-core/src/main/res/anim/leak_canary_enter_backward.xml
new file mode 100644
index 00000000..d2430eae
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/anim/leak_canary_enter_backward.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<translate
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:fromXDelta="-100%" android:toXDelta="0%"
+    android:fromYDelta="0%" android:toYDelta="0%"
+    android:duration="@android:integer/config_mediumAnimTime"/>
diff --git a/leakcanary-android-core/src/main/res/anim/leak_canary_enter_forward.xml b/leakcanary-android-core/src/main/res/anim/leak_canary_enter_forward.xml
new file mode 100644
index 00000000..1dc5cfc4
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/anim/leak_canary_enter_forward.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<translate
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:fromXDelta="100%" android:toXDelta="0%"
+    android:fromYDelta="0%" android:toYDelta="0%"
+    android:duration="@android:integer/config_mediumAnimTime"/>
diff --git a/leakcanary-android-core/src/main/res/anim/leak_canary_exit_backward.xml b/leakcanary-android-core/src/main/res/anim/leak_canary_exit_backward.xml
new file mode 100644
index 00000000..7dea9fbf
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/anim/leak_canary_exit_backward.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<translate
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:fromXDelta="0%" android:toXDelta="100%"
+    android:fromYDelta="0%" android:toYDelta="0%"
+    android:duration="@android:integer/config_mediumAnimTime"/>
diff --git a/leakcanary-android-core/src/main/res/anim/leak_canary_exit_forward.xml b/leakcanary-android-core/src/main/res/anim/leak_canary_exit_forward.xml
new file mode 100644
index 00000000..b7292341
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/anim/leak_canary_exit_forward.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<translate
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:fromXDelta="0%" android:toXDelta="-100%"
+    android:fromYDelta="0%" android:toYDelta="0%"
+    android:duration="@android:integer/config_mediumAnimTime"/>
diff --git a/leakcanary-android-core/src/main/res/drawable-anydpi-v24/leak_canary_notification.xml b/leakcanary-android-core/src/main/res/drawable-anydpi-v24/leak_canary_notification.xml
new file mode 100644
index 00000000..f5f88aa7
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable-anydpi-v24/leak_canary_notification.xml
@@ -0,0 +1,38 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportWidth="184.32971"
+    android:viewportHeight="184.32971"
+    android:tint="#FFFFFF">
+  <group android:translateX="-0.33514494"
+      android:translateY="-0.33514494">
+    <group>
+      <clip-path android:pathData="M0,0h185v185h-185z M 0,0"/>
+      <path
+          android:pathData="M55.8327 80.944L68.1676 83.3835M59.6321 89.5079L62.4202 75.4109"
+          android:strokeWidth="4.257"
+          android:fillColor="#00000000"
+          android:strokeColor="#151C1F"
+          android:strokeLineCap="round"/>
+      <path
+          android:pathData="M33.0396 88.6436L148.284 41.1702C148.308 41.1931 148.333 41.216 148.357 41.2389C147.773 76.5754 125.2 119.136 72.6948 132.558C66.2444 121.606 47.4716 97.5578 32.6694 89.9372C32.799 89.5158 32.9224 89.0844 33.0396 88.6436Z"
+          android:fillColor="#ffffff"
+          android:fillType="evenOdd"/>
+      <path
+          android:pathData="M81.4818 31.7162L72.8251 55.9266L71.7247 54.5065C66.7399 48.0734 60.8251 42.4184 54.1748 37.7274L69.4736 20.6696L68.6881 39.2884L81.4818 31.7162Z"
+          android:fillColor="#ffffff"/>
+      <path
+          android:pathData="M64.8741 100.079C81.01 89.2721 85.3298 67.4304 74.5226 51.2946C63.7154 35.1587 41.8738 30.8389 25.7379 41.6461C9.60205 52.4532 5.28228 74.2949 16.0894 90.4308C26.8966 106.567 48.7382 110.886 64.8741 100.079ZM43.6335 56.9634C42.5166 57.3298 41.9082 58.5324 42.2747 59.6494C42.6412 60.7663 43.8437 61.3747 44.9607 61.0082L48.0585 59.9918L49.7842 65.2515C50.1507 66.3684 51.3532 66.9768 52.4702 66.6103C53.5871 66.2439 54.1955 65.0413 53.829 63.9244L52.1033 58.6647L56.9078 57.0883C58.0248 56.7218 58.6332 55.5193 58.2667 54.4023C57.9002 53.2853 56.6977 52.677 55.5807 53.0434L50.7762 54.6198L49.3491 50.2704C48.9826 49.1535 47.7801 48.5451 46.6631 48.9116C45.5462 49.278 44.9378 50.4806 45.3043 51.5976L46.7313 55.947L43.6335 56.9634Z"
+          android:fillColor="#ffffff"
+          android:fillType="evenOdd"/>
+      <path
+          android:pathData="M10.1416 71.2627C10.4815 113.278 38.6085 151.594 81.1309 162.988C113.627 171.695 146.704 162.582 170.003 141.637C159.823 142.304 149.364 141.343 138.964 138.556C113.428 131.714 93.0844 115.164 80.8316 93.9338L10.1416 71.2627Z"
+          android:fillColor="#ffffff"
+          android:fillType="evenOdd"/>
+      <path
+          android:pathData="M175.463 56.9136L57.9672 97.0664C57.8158 97.5113 57.6587 97.9458 57.4956 98.3692C71.736 106.994 88.8027 132.282 94.4811 143.653C105.725 141.594 115.73 138.149 124.547 133.665C121.291 132.305 118.248 130.405 115.554 128.011L114.859 127.392C114.033 126.658 113.959 125.394 114.693 124.569C115.427 123.743 116.691 123.669 117.516 124.403L118.212 125.021C121.434 127.886 125.228 129.941 129.286 131.091C130.47 130.405 131.632 129.699 132.769 128.975C130.868 128.149 129.036 127.135 127.302 125.938L126.535 125.409C125.626 124.782 125.398 123.537 126.025 122.627C126.653 121.718 127.898 121.49 128.807 122.117L129.573 122.646C131.83 124.203 134.276 125.407 136.83 126.243C137.942 125.453 139.03 124.644 140.093 123.818C139.482 123.453 138.88 123.067 138.29 122.66L137.524 122.131C136.615 121.504 136.387 120.259 137.014 119.349C137.641 118.44 138.887 118.212 139.796 118.839L140.562 119.368C141.487 120.006 142.444 120.585 143.428 121.104C163.878 103.673 174.394 79.6305 176.271 57.779C176.004 57.4894 175.735 57.2009 175.463 56.9136Z"
+          android:fillColor="#ffffff"
+          android:fillType="evenOdd"/>
+    </group>
+  </group>
+</vector>
diff --git a/leakcanary-android-core/src/main/res/drawable-hdpi/leak_canary_notification.png b/leakcanary-android-core/src/main/res/drawable-hdpi/leak_canary_notification.png
new file mode 100644
index 00000000..b3fe4bcc
Binary files /dev/null and b/leakcanary-android-core/src/main/res/drawable-hdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android-core/src/main/res/drawable-mdpi/leak_canary_notification.png b/leakcanary-android-core/src/main/res/drawable-mdpi/leak_canary_notification.png
new file mode 100644
index 00000000..9843dc04
Binary files /dev/null and b/leakcanary-android-core/src/main/res/drawable-mdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android-core/src/main/res/drawable-xhdpi/leak_canary_notification.png b/leakcanary-android-core/src/main/res/drawable-xhdpi/leak_canary_notification.png
new file mode 100644
index 00000000..18b6aead
Binary files /dev/null and b/leakcanary-android-core/src/main/res/drawable-xhdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android-core/src/main/res/drawable-xxhdpi/leak_canary_notification.png b/leakcanary-android-core/src/main/res/drawable-xxhdpi/leak_canary_notification.png
new file mode 100644
index 00000000..e27d8a18
Binary files /dev/null and b/leakcanary-android-core/src/main/res/drawable-xxhdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_icon.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_icon.xml
new file mode 100644
index 00000000..aa225f7a
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_icon.xml
@@ -0,0 +1,17 @@
+<vector android:height="24dp" android:viewportHeight="185"
+    android:viewportWidth="185" android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
+    <group>
+        <clip-path android:pathData="M0,0h185v185h-185z M 0,0"/>
+        <path android:fillColor="#00000000"
+            android:pathData="M55.8327 80.944L68.1676 83.3835M59.6321 89.5079L62.4202 75.4109"
+            android:strokeColor="#151C1F" android:strokeLineCap="round" android:strokeWidth="4.257"/>
+        <path android:fillColor="#F5BD14" android:fillType="evenOdd" android:pathData="M33.0396 88.6436L148.284 41.1702C148.308 41.1931 148.333 41.216 148.357 41.2389C147.773 76.5754 125.2 119.136 72.6948 132.558C66.2444 121.606 47.4716 97.5578 32.6694 89.9372C32.799 89.5158 32.9224 89.0844 33.0396 88.6436Z"/>
+        <path android:fillColor="#F86932" android:pathData="M81.4818 31.7162L72.8251 55.9266L71.7247 54.5065C66.7399 48.0734 60.8251 42.4184 54.1748 37.7274L69.4736 20.6696L68.6881 39.2884L81.4818 31.7162Z"/>
+        <path android:fillColor="#FFCC32" android:pathData="M45.3062,70.8628m-35.1642,0.0a35.1642,35.1642,0,1,1,70.3284,0.0a35.1642,35.1642,0,1,1,-70.3284,0.0"/>
+        <path android:fillColor="#00000000"
+            android:pathData="M44.2972 58.986L56.2444 55.066M51.8067 64.5881L47.3268 50.9342"
+            android:strokeColor="#151C1F" android:strokeLineCap="round" android:strokeWidth="4.257"/>
+        <path android:fillColor="#FFCC32" android:fillType="evenOdd" android:pathData="M10.1416 71.2627C10.4815 113.278 38.6085 151.594 81.1309 162.988C113.627 171.695 146.704 162.582 170.003 141.637C159.823 142.304 149.364 141.343 138.964 138.556C113.428 131.714 93.0844 115.164 80.8316 93.9338L10.1416 71.2627Z"/>
+        <path android:fillColor="#FFCC32" android:fillType="evenOdd" android:pathData="M175.463 56.9136L57.9672 97.0664C57.8158 97.5113 57.6587 97.9458 57.4956 98.3692C71.736 106.994 88.8027 132.282 94.4811 143.653C105.725 141.594 115.73 138.149 124.547 133.665C121.291 132.305 118.248 130.405 115.554 128.011L114.859 127.392C114.033 126.658 113.959 125.394 114.693 124.569C115.427 123.743 116.691 123.669 117.516 124.403L118.212 125.021C121.434 127.886 125.228 129.941 129.286 131.091C130.47 130.405 131.632 129.699 132.769 128.975C130.868 128.149 129.036 127.135 127.302 125.938L126.535 125.409C125.626 124.782 125.398 123.537 126.025 122.627C126.653 121.718 127.898 121.49 128.807 122.117L129.573 122.646C131.83 124.203 134.276 125.407 136.83 126.243C137.942 125.453 139.03 124.644 140.093 123.818C139.482 123.453 138.88 123.067 138.29 122.66L137.524 122.131C136.615 121.504 136.387 120.259 137.014 119.349C137.641 118.44 138.887 118.212 139.796 118.839L140.562 119.368C141.487 120.006 142.444 120.585 143.428 121.104C163.878 103.673 174.394 79.6305 176.271 57.779C176.004 57.4894 175.735 57.2009 175.463 56.9136Z"/>
+    </group>
+</vector>
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_icon_foreground.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_icon_foreground.xml
new file mode 100644
index 00000000..49b7ea7e
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_icon_foreground.xml
@@ -0,0 +1,23 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="108dp"
+    android:height="108dp"
+    android:viewportWidth="336.36365"
+    android:viewportHeight="336.36365">
+  <group android:translateX="75.681816"
+      android:translateY="75.681816">
+      <group>
+          <clip-path android:pathData="M0,0h185v185h-185z M 0,0"/>
+          <path android:fillColor="#00000000"
+              android:pathData="M55.8327 80.944L68.1676 83.3835M59.6321 89.5079L62.4202 75.4109"
+              android:strokeColor="#151C1F" android:strokeLineCap="round" android:strokeWidth="4.257"/>
+          <path android:fillColor="#F5BD14" android:fillType="evenOdd" android:pathData="M33.0396 88.6436L148.284 41.1702C148.308 41.1931 148.333 41.216 148.357 41.2389C147.773 76.5754 125.2 119.136 72.6948 132.558C66.2444 121.606 47.4716 97.5578 32.6694 89.9372C32.799 89.5158 32.9224 89.0844 33.0396 88.6436Z"/>
+          <path android:fillColor="#F86932" android:pathData="M81.4818 31.7162L72.8251 55.9266L71.7247 54.5065C66.7399 48.0734 60.8251 42.4184 54.1748 37.7274L69.4736 20.6696L68.6881 39.2884L81.4818 31.7162Z"/>
+          <path android:fillColor="#FFCC32" android:pathData="M45.3062,70.8628m-35.1642,0.0a35.1642,35.1642,0,1,1,70.3284,0.0a35.1642,35.1642,0,1,1,-70.3284,0.0"/>
+          <path android:fillColor="#00000000"
+              android:pathData="M44.2972 58.986L56.2444 55.066M51.8067 64.5881L47.3268 50.9342"
+              android:strokeColor="#151C1F" android:strokeLineCap="round" android:strokeWidth="4.257"/>
+          <path android:fillColor="#FFCC32" android:fillType="evenOdd" android:pathData="M10.1416 71.2627C10.4815 113.278 38.6085 151.594 81.1309 162.988C113.627 171.695 146.704 162.582 170.003 141.637C159.823 142.304 149.364 141.343 138.964 138.556C113.428 131.714 93.0844 115.164 80.8316 93.9338L10.1416 71.2627Z"/>
+          <path android:fillColor="#FFCC32" android:fillType="evenOdd" android:pathData="M175.463 56.9136L57.9672 97.0664C57.8158 97.5113 57.6587 97.9458 57.4956 98.3692C71.736 106.994 88.8027 132.282 94.4811 143.653C105.725 141.594 115.73 138.149 124.547 133.665C121.291 132.305 118.248 130.405 115.554 128.011L114.859 127.392C114.033 126.658 113.959 125.394 114.693 124.569C115.427 123.743 116.691 123.669 117.516 124.403L118.212 125.021C121.434 127.886 125.228 129.941 129.286 131.091C130.47 130.405 131.632 129.699 132.769 128.975C130.868 128.149 129.036 127.135 127.302 125.938L126.535 125.409C125.626 124.782 125.398 123.537 126.025 122.627C126.653 121.718 127.898 121.49 128.807 122.117L129.573 122.646C131.83 124.203 134.276 125.407 136.83 126.243C137.942 125.453 139.03 124.644 140.093 123.818C139.482 123.453 138.88 123.067 138.29 122.66L137.524 122.131C136.615 121.504 136.387 120.259 137.014 119.349C137.641 118.44 138.887 118.212 139.796 118.839L140.562 119.368C141.487 120.006 142.444 120.585 143.428 121.104C163.878 103.673 174.394 79.6305 176.271 57.779C176.004 57.4894 175.735 57.2009 175.463 56.9136Z"/>
+      </group>
+  </group>
+</vector>
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_notification.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_notification.xml
new file mode 100644
index 00000000..3fe6f482
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_notification.xml
@@ -0,0 +1,14 @@
+<vector android:height="24dp" android:viewportHeight="185"
+    android:viewportWidth="185" android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
+    <group>
+        <clip-path android:pathData="M0,0h185v185h-185z M 0,0"/>
+        <path android:fillColor="#00000000"
+            android:pathData="M55.8327 80.944L68.1676 83.3835M59.6321 89.5079L62.4202 75.4109"
+            android:strokeColor="#151C1F" android:strokeLineCap="round" android:strokeWidth="4.257"/>
+        <path android:fillColor="#ffffff" android:fillType="evenOdd" android:pathData="M33.0396 88.6436L148.284 41.1702C148.308 41.1931 148.333 41.216 148.357 41.2389C147.773 76.5754 125.2 119.136 72.6948 132.558C66.2444 121.606 47.4716 97.5578 32.6694 89.9372C32.799 89.5158 32.9224 89.0844 33.0396 88.6436Z"/>
+        <path android:fillColor="#ffffff" android:pathData="M81.4818 31.7162L72.8251 55.9266L71.7247 54.5065C66.7399 48.0734 60.8251 42.4184 54.1748 37.7274L69.4736 20.6696L68.6881 39.2884L81.4818 31.7162Z"/>
+        <path android:fillColor="#ffffff" android:fillType="evenOdd" android:pathData="M64.8741 100.079C81.01 89.2721 85.3298 67.4304 74.5226 51.2946C63.7154 35.1587 41.8738 30.8389 25.7379 41.6461C9.60205 52.4532 5.28228 74.2949 16.0894 90.4308C26.8966 106.567 48.7382 110.886 64.8741 100.079ZM43.6335 56.9634C42.5166 57.3298 41.9082 58.5324 42.2747 59.6494C42.6412 60.7663 43.8437 61.3747 44.9607 61.0082L48.0585 59.9918L49.7842 65.2515C50.1507 66.3684 51.3532 66.9768 52.4702 66.6103C53.5871 66.2439 54.1955 65.0413 53.829 63.9244L52.1033 58.6647L56.9078 57.0883C58.0248 56.7218 58.6332 55.5193 58.2667 54.4023C57.9002 53.2853 56.6977 52.677 55.5807 53.0434L50.7762 54.6198L49.3491 50.2704C48.9826 49.1535 47.7801 48.5451 46.6631 48.9116C45.5462 49.278 44.9378 50.4806 45.3043 51.5976L46.7313 55.947L43.6335 56.9634Z"/>
+        <path android:fillColor="#ffffff" android:fillType="evenOdd" android:pathData="M10.1416 71.2627C10.4815 113.278 38.6085 151.594 81.1309 162.988C113.627 171.695 146.704 162.582 170.003 141.637C159.823 142.304 149.364 141.343 138.964 138.556C113.428 131.714 93.0844 115.164 80.8316 93.9338L10.1416 71.2627Z"/>
+        <path android:fillColor="#ffffff" android:fillType="evenOdd" android:pathData="M175.463 56.9136L57.9672 97.0664C57.8158 97.5113 57.6587 97.9458 57.4956 98.3692C71.736 106.994 88.8027 132.282 94.4811 143.653C105.725 141.594 115.73 138.149 124.547 133.665C121.291 132.305 118.248 130.405 115.554 128.011L114.859 127.392C114.033 126.658 113.959 125.394 114.693 124.569C115.427 123.743 116.691 123.669 117.516 124.403L118.212 125.021C121.434 127.886 125.228 129.941 129.286 131.091C130.47 130.405 131.632 129.699 132.769 128.975C130.868 128.149 129.036 127.135 127.302 125.938L126.535 125.409C125.626 124.782 125.398 123.537 126.025 122.627C126.653 121.718 127.898 121.49 128.807 122.117L129.573 122.646C131.83 124.203 134.276 125.407 136.83 126.243C137.942 125.453 139.03 124.644 140.093 123.818C139.482 123.453 138.88 123.067 138.29 122.66L137.524 122.131C136.615 121.504 136.387 120.259 137.014 119.349C137.641 118.44 138.887 118.212 139.796 118.839L140.562 119.368C141.487 120.006 142.444 120.585 143.428 121.104C163.878 103.673 174.394 79.6305 176.271 57.779C176.004 57.4894 175.735 57.2009 175.463 56.9136Z"/>
+    </group>
+</vector>
diff --git a/leakcanary-android/src/main/res/drawable/leak_canary_toast_background.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_toast_background.xml
similarity index 95%
rename from leakcanary-android/src/main/res/drawable/leak_canary_toast_background.xml
rename to leakcanary-android-core/src/main/res/drawable/leak_canary_toast_background.xml
index a90b8c2c..0bf11fb8 100644
--- a/leakcanary-android/src/main/res/drawable/leak_canary_toast_background.xml
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_toast_background.xml
@@ -2,4 +2,4 @@
 <shape xmlns:android="http://schemas.android.com/apk/res/android">
   <solid android:color="#cc000000"/>
   <corners android:radius="16dp"/>
-</shape>
\ No newline at end of file
+</shape>
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_heap_analysis_failure_screen.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_analysis_failure_screen.xml
new file mode 100644
index 00000000..739a7670
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_analysis_failure_screen.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<TextView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/leak_canary_failure"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@color/leak_canary_background_color"
+    android:textSize="12sp"
+    />
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_dump_toast.xml
similarity index 58%
rename from leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml
rename to leakcanary-android-core/src/main/res/layout/leak_canary_heap_dump_toast.xml
index d6057ed2..0f411da0 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_dump_toast.xml
@@ -14,26 +14,43 @@
   ~ See the License for the specific language governing permissions and
   ~ limitations under the License.
   -->
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="wrap_content"
     android:layout_height="wrap_content"
-    android:orientation="vertical"
-    android:background="@drawable/leak_canary_toast_background"
-    android:padding="16dp"
     >
-  <ImageView
+
+  <LinearLayout
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
+      android:background="@drawable/leak_canary_toast_background"
+      android:orientation="vertical"
+      android:layout_marginTop="48dp"
+      android:padding="16dp"
+      >
+  <!-- Holds the stop for the image on top-->
+  <View
+      android:layout_width="@dimen/leak_canary_toast_icon_size"
+      android:layout_height="@dimen/leak_canary_toast_icon_size"
       android:layout_gravity="center_horizontal"
-      android:src="@drawable/leak_canary_icon"/>
+      />
 
   <TextView
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
       android:layout_gravity="center_horizontal"
+      android:text="@string/leak_canary_toast_heap_dump"
       android:textColor="#ffffff"
       android:textSize="18sp"
-      android:text="@string/leak_canary_toast_heap_dump"
+      />
+  </LinearLayout>
+
+  <ImageView
+      android:id="@+id/leak_canary_toast_icon"
+      android:layout_marginTop="@dimen/leak_canary_toast_icon_size"
+      android:layout_width="@dimen/leak_canary_toast_icon_size"
+      android:layout_height="@dimen/leak_canary_toast_icon_size"
+      android:layout_gravity="center_horizontal"
+      android:src="@drawable/leak_canary_icon"
       />
 
-</LinearLayout>
+</FrameLayout>
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_heap_render.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_render.xml
new file mode 100644
index 00000000..7ecde1f6
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_render.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@color/leak_canary_background_color"
+    >
+  <ProgressBar
+      android:id="@+id/leak_canary_loading"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_gravity="center"
+      android:indeterminate="true"
+      style="?android:attr/progressBarStyleLarge"
+      />
+  <ImageView
+      android:id="@+id/leak_canary_heap_rendering"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      />
+
+</FrameLayout>
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_leak_activity.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_leak_activity.xml
new file mode 100644
index 00000000..bab4f43c
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_leak_activity.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/main_container"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    />
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_leak_row.xml
similarity index 100%
rename from leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml
rename to leakcanary-android-core/src/main/res/layout/leak_canary_leak_row.xml
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_list.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_list.xml
new file mode 100644
index 00000000..8d6a1f62
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_list.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@color/leak_canary_background_color"
+    android:orientation="vertical"
+    >
+  <ListView
+      android:id="@+id/leak_canary_list"
+      android:layout_width="match_parent"
+      android:layout_height="match_parent"
+      android:divider="@null"
+      android:dividerHeight="0dp"
+      />
+</FrameLayout>
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_ref_row.xml
similarity index 51%
rename from leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
rename to leakcanary-android-core/src/main/res/layout/leak_canary_ref_row.xml
index 947af46c..34ed2b70 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_ref_row.xml
@@ -14,36 +14,39 @@
   ~ See the License for the specific language governing permissions and
   ~ limitations under the License.
   -->
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+<leakcanary.internal.RowElementLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:lib="http://schemas.android.com/apk/res-auto"
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
-    android:minHeight="48dp"
-    android:orientation="horizontal"
+    android:id="@+id/leak_canary_row_layout"
+    android:clipChildren="false"
     >
 
-  <com.squareup.leakcanary.internal.DisplayLeakConnectorView
+  <leakcanary.internal.DisplayLeakConnectorView
       android:id="@+id/leak_canary_row_connector"
-      android:layout_width="16dp"
-      android:layout_height="match_parent"
-      android:layout_marginStart="16dp"
-      android:layout_marginEnd="16dp"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      />
+
+  <leakcanary.internal.MoreDetailsView
+      android:id="@+id/leak_canary_row_more"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      lib:leak_canary_plus_color="@color/leak_canary_class_name"
       />
 
   <TextView
-      android:id="@+id/leak_canary_row_text"
-      android:layout_width="0dp"
-      android:layout_weight="1"
+      android:id="@+id/leak_canary_row_title"
+      android:layout_width="wrap_content"
       android:layout_height="wrap_content"
-      android:layout_gravity="center_vertical"
       />
 
-  <com.squareup.leakcanary.internal.MoreDetailsView
-      android:id="@+id/leak_canary_row_more"
-      android:layout_width="12dp"
-      android:layout_height="12dp"
-      android:layout_gravity="center_vertical"
-      android:layout_marginStart="16dp"
-      android:layout_marginEnd="16dp"
+  <TextView
+      android:id="@+id/leak_canary_row_details"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:visibility="gone"
       />
 
-</LinearLayout>
+</leakcanary.internal.RowElementLayout>
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_ref_top_row.xml
similarity index 89%
rename from leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
rename to leakcanary-android-core/src/main/res/layout/leak_canary_ref_top_row.xml
index c4803b76..4d70df54 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_ref_top_row.xml
@@ -21,7 +21,7 @@
     android:layout_height="wrap_content"
     android:layout_margin="16dp"
     android:textSize="18sp"
-    android:background="#84a6c5"
+    android:background="@color/leak_canary_class_name"
     android:padding="16dp"
-    android:textColor="#ffffff"
+    android:textColor="@color/leak_canary_background_color"
     />
diff --git a/leakcanary-android-core/src/main/res/mipmap-anydpi-v26/leak_canary_icon.xml b/leakcanary-android-core/src/main/res/mipmap-anydpi-v26/leak_canary_icon.xml
new file mode 100644
index 00000000..c58c886c
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/mipmap-anydpi-v26/leak_canary_icon.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
+  <background android:drawable="@color/leak_canary_icon_background"/>
+  <foreground android:drawable="@drawable/leak_canary_icon_foreground"/>
+</adaptive-icon>
diff --git a/leakcanary-android-core/src/main/res/mipmap-hdpi/leak_canary_icon.png b/leakcanary-android-core/src/main/res/mipmap-hdpi/leak_canary_icon.png
new file mode 100644
index 00000000..9ad0073e
Binary files /dev/null and b/leakcanary-android-core/src/main/res/mipmap-hdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android-core/src/main/res/mipmap-mdpi/leak_canary_icon.png b/leakcanary-android-core/src/main/res/mipmap-mdpi/leak_canary_icon.png
new file mode 100644
index 00000000..2166d069
Binary files /dev/null and b/leakcanary-android-core/src/main/res/mipmap-mdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android-core/src/main/res/mipmap-xhdpi/leak_canary_icon.png b/leakcanary-android-core/src/main/res/mipmap-xhdpi/leak_canary_icon.png
new file mode 100644
index 00000000..6aee0412
Binary files /dev/null and b/leakcanary-android-core/src/main/res/mipmap-xhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android-core/src/main/res/mipmap-xxhdpi/leak_canary_icon.png b/leakcanary-android-core/src/main/res/mipmap-xxhdpi/leak_canary_icon.png
new file mode 100644
index 00000000..e35493b9
Binary files /dev/null and b/leakcanary-android-core/src/main/res/mipmap-xxhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android-core/src/main/res/mipmap-xxxhdpi/leak_canary_icon.png b/leakcanary-android-core/src/main/res/mipmap-xxxhdpi/leak_canary_icon.png
new file mode 100644
index 00000000..a50f8e03
Binary files /dev/null and b/leakcanary-android-core/src/main/res/mipmap-xxxhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
new file mode 100644
index 00000000..9eaca127
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
@@ -0,0 +1,81 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <string name="leak_canary_about_title">About LeakCanary</string>
+  <string name="leak_canary_about_message"><![CDATA[<a href="https://github.com/square/leakcanary">LeakCanary</a>
+  is a memory leak detection library for Android, created by
+  <a href="https://twitter.com/Piwai">Pierre-Yves Ricau</a> and open sourced by Square.<br><br>
+  We welcome contributions from the community, please do not hesitate to
+  <a href="https://github.com/square/leakcanary/issues">report an issue</a> or open a pull request!<br>]]></string>
+  <string name="leak_canary_class_has_leaked">%1$s hat geleaked</string>
+  <string name="leak_canary_class_has_leaked_retaining">%1$s hat %2$s geleaked</string>
+  <string name="leak_canary_class_no_leak">%1$s was never GCed but no leak found</string>
+  <string name="leak_canary_download_dump">You can download the heap dump via \"Menu > Share Heap Dump\" or \"adb pull %1$s\"</string>
+  <string name="leak_canary_leak_excluded">[Ausgeschlossen] %1$s hat geleaked</string>
+  <string name="leak_canary_leak_excluded_retaining">[Ausgeschlossen] %1$s hat %2$s geleaked</string>
+  <string name="leak_canary_analysis_failed">Leak Analyse fehlgeschlagen</string>
+  <string name="leak_canary_leak_list_title">Leaks in %s</string>
+  <string name="leak_canary_notification_analysing">Analyisere Heap Dump</string>
+  <string name="leak_canary_notification_channel">LeakCanary</string>
+  <string name="leak_canary_notification_dumping">Sichere Heap</string>
+  <string name="leak_canary_notification_foreground_text">LeakCanary ist beschäftigt.</string>
+  <string name="leak_canary_notification_message">Für mehr Details, hier klicken</string>
+  <string name="leak_canary_notification_reporting">Sichere LeakCanary Ergebnis</string>
+  <string name="leak_canary_no_leak_details">LeakCanary could not find a valid path to GC roots. Download the heap dump and investigate with MAT or YourKit.</string>
+  <string name="leak_canary_result_failure_no_disk_space">Das Analyseergebnis konnte nicht gespeichert werden</string>
+  <string name="leak_canary_result_failure_no_file">Das Analyseergebnis konnte nicht aus dem Speicher geladen werden</string>
+  <string name="leak_canary_result_failure_title">Analysis result failure</string>
+  <string name="leak_canary_share_leak">Info teilen</string>
+  <string name="leak_canary_share_heap_dump">Heap Dump teilen</string>
+  <string name="leak_canary_share_with">Teilen mit…</string>
+  <string name="leak_canary_display_activity_label">Leaks</string>
+  <string name="leak_canary_storage_permission_activity_label">Storage Berechtigung</string>
+  <string name="leak_canary_toast_heap_dump">LeakCanary is dumping the heap, app will freeze. Brrrr.</string>
+  <string name="leak_canary_delete">Löschen</string>
+  <string name="leak_canary_failure_report">"Bitte sende diesen Fehler an http://github.com/square/leakcanary"</string>
+  <string name="leak_canary_delete_all">Alle löschen</string>
+  <string name="leak_canary_delete_all_leaks_title">Bist du dir sicher, dass du alle Leaks löschen möchtest?</string>
+  <string name="leak_canary_could_not_save_text">LeakCanary konnte das Ergebnis der Analyse nicht speichern.</string>
+  <string name="leak_canary_excluded_row">[Ausgeschlossen] %s</string>
+  <string name="leak_canary_permission_not_granted">Bitte gewähre die Storage Berechtigung, andernfalls werden Memory Leaks nicht erkannt.</string>
+  <string name="leak_canary_permission_notification_title">Leak erkannt, benötige Berechtigung</string>
+  <string name="leak_canary_permission_notification_text">Hier klicken, um Storage Berechtigung für %s zu aktivieren.</string>
+  <string name="leak_canary_shortcut_label">Leaks</string>
+  <string name="leak_canary_stackoverflow_share">Share Leak On Stack Overflow</string>
+  <string name="leak_canary_leak_copied">Leak info copied to clipboard</string>
+  <string name="leak_canary_leak_clipdata_label">LeakCanary Leak Trace</string>
+  <string name="leak_canary_help_title">Tippe hier, um mehr zu erfahren</string>
+  <string name="leak_canary_help_detail"><![CDATA[Ein Memory-Leak ist ein Programmierfehler der
+    dafür sorgt, dass deine Anwendung eine Referenz auf ein Objekt hält, das nicht länger benötigt
+    wird. Daraus folgt, dass der Speicher der dem Objekt zugewiesen wurde nicht wieder freigegeben
+    wird, was eventuell zu einem OutOfMemoryError-Absturz führt.<br>
+  <br>Eine Instanz einer Android-Activity wird nicht mehr benötigt, nachdem ihre <i>onDestroy()</i>
+  Methode aufgerufen wurde. Würde man eine Referenz auf diese Activity in einem statischen Feld
+  speichern, dann wird der durch die Activity genutzte Speicher nicht mehr durch den Garbage
+  Collector freigegeben.<br>
+  <br>
+  LeakCanary identifiziert ein Objekt, dass nicht länger benötigt wird und findet die Kette an
+  <font color=\'#9976a8\'>Referenzen</font> die es davon abhält seinen Speicher freizugeben.<br>
+  <br>
+  Um ein Memory-Leak zu beheben, musst du anhand der Kette herausfinden, welche Referenz für das
+  Leak verantwortlich ist, d.h. welche Referenz beim Auftreten des Leaks bereinigt sein soll.
+  LeakCanary hebt <b><u><font color=\'#9976a8\'>Referenzen</font></u></b> die mögliche Ursachen
+  für das Memory-Leak sein könnten mit einer roten Wellenlinie hervor.<br>
+  <br>
+  Tippe auf eine Zeile mit einer Referenz um mehr Details anzuzeigen, tippe noch einmal um die
+  Details zu schließen.
+]]></string>
+</resources>
diff --git a/leakcanary-android/src/main/res/values-v21/leak_canary_themes.xml b/leakcanary-android-core/src/main/res/values-v21/leak_canary_themes.xml
similarity index 98%
rename from leakcanary-android/src/main/res/values-v21/leak_canary_themes.xml
rename to leakcanary-android-core/src/main/res/values-v21/leak_canary_themes.xml
index 0a43b8f9..bce4a40c 100644
--- a/leakcanary-android/src/main/res/values-v21/leak_canary_themes.xml
+++ b/leakcanary-android-core/src/main/res/values-v21/leak_canary_themes.xml
@@ -17,4 +17,4 @@
 <resources>
   <style name="leak_canary_LeakCanary.Base" parent="android:Theme.Material">
   </style>
-</resources>
\ No newline at end of file
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_int.xml b/leakcanary-android-core/src/main/res/values/leak_canary_attrs.xml
similarity index 78%
rename from leakcanary-android/src/main/res/values/leak_canary_int.xml
rename to leakcanary-android-core/src/main/res/values/leak_canary_attrs.xml
index b7197372..092508ba 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_int.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_attrs.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-  ~ Copyright (C) 2015 Square, Inc.
+  ~ Copyright (C) 2018 Square, Inc.
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
@@ -15,6 +15,7 @@
   ~ limitations under the License.
   -->
 <resources>
-  <integer name="leak_canary_max_stored_leaks">7</integer>
-  <integer name="leak_canary_watch_delay_millis">5000</integer>
+  <declare-styleable name="leak_canary_MoreDetailsView">
+    <attr name="leak_canary_plus_color" format="color" />
+  </declare-styleable>
 </resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_bools.xml b/leakcanary-android-core/src/main/res/values/leak_canary_bools.xml
new file mode 100644
index 00000000..88bbf123
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_bools.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <bool name="leak_canary_add_dynamic_shortcut">true</bool>
+  <bool name="leak_canary_add_launcher_icon">true</bool>
+</resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_colors.xml b/leakcanary-android-core/src/main/res/values/leak_canary_colors.xml
new file mode 100644
index 00000000..25ca9c8e
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_colors.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <color name="leak_canary_class_name">#bababa</color>
+  <color name="leak_canary_leak">#be383f</color>
+  <color name="leak_canary_reference">#9976a8</color>
+  <color name="leak_canary_extra">#919191</color>
+  <color name="leak_canary_help">#6a98b9</color>
+  <color name="leak_canary_background_color">#2b2b2b</color>
+  <color name="leak_canary_icon_background">#ffffff</color>
+  <color name="leak_canary_heap_stack_trace">#ffd40b</color>
+  <color name="leak_canary_heap_app">#00ffff</color>
+  <color name="leak_canary_heap_image">#039dff</color>
+  <color name="leak_canary_heap_zygote">#000a8b</color>
+  <color name="leak_canary_heap_instance">#72547a</color>
+  <color name="leak_canary_heap_load_class">#12580f</color>
+  <color name="leak_canary_heap_class_dump">#689959</color>
+  <color name="leak_canary_heap_hprof_string">#900000</color>
+  <color name="leak_canary_heap_instance_string">#ff0000</color>
+  <color name="leak_canary_heap_char_array">#ffa500</color>
+  <color name="leak_canary_heap_boolean_array">#383838</color>
+  <color name="leak_canary_heap_float_array">#4d4d4d</color>
+  <color name="leak_canary_heap_double_array">#4d4d4d</color>
+  <color name="leak_canary_heap_short_array">#797979</color>
+  <color name="leak_canary_heap_int_array">#797979</color>
+  <color name="leak_canary_heap_long_array">#797979</color>
+  <color name="leak_canary_heap_byte_array">#e23ff7</color>
+  <color name="leak_canary_heap_object_array">#ffffff</color>
+  <color name="leak_canary_heap_other">#000000</color>
+</resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_dimens.xml b/leakcanary-android-core/src/main/res/values/leak_canary_dimens.xml
new file mode 100644
index 00000000..5c445974
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_dimens.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <dimen name="leak_canary_squiggly_span_stroke_width">1dp</dimen>
+  <dimen name="leak_canary_squiggly_span_amplitude">1dp</dimen>
+  <!-- DP because the period increased with the density. -->
+  <dimen name="leak_canary_squiggly_span_period_degrees">4dp</dimen>
+  <dimen name="leak_canary_connector_center_y">24dp</dimen>
+  <dimen name="leak_canary_connector_stroke_size">2dp</dimen>
+  <dimen name="leak_canary_connector_leak_dash_line">5dp</dimen>
+  <dimen name="leak_canary_connector_leak_dash_gap">1dp</dimen>
+  <dimen name="leak_canary_more_stroke_width">2dp</dimen>
+  <dimen name="leak_canary_connector_width">16dp</dimen>
+  <dimen name="leak_canary_row_margins">16dp</dimen>
+  <dimen name="leak_canary_more_size">12dp</dimen>
+  <dimen name="leak_canary_more_margin_top">18dp</dimen>
+  <dimen name="leak_canary_row_min">48dp</dimen>
+  <dimen name="leak_canary_row_title_margin_top">14.5dp</dimen>
+  <dimen name="leak_canary_toast_icon_size">64dp</dimen>
+
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_public.xml b/leakcanary-android-core/src/main/res/values/leak_canary_public.xml
similarity index 81%
rename from leakcanary-android/src/main/res/values/leak_canary_public.xml
rename to leakcanary-android-core/src/main/res/values/leak_canary_public.xml
index b5f11b97..8947e504 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_public.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_public.xml
@@ -18,8 +18,8 @@
 
   <public name="leak_canary_display_activity_label" type="string"/>
   <public name="leak_canary_heap_dump_toast" type="layout"/>
-  <public name="leak_canary_icon" type="drawable"/>
-  <public name="leak_canary_max_stored_leaks" type="integer"/>
-  <public name="leak_canary_watch_delay_millis" type="integer"/>
+  <public name="leak_canary_icon" type="mipmap"/>
+  <public name="leak_canary_add_dynamic_shortcut" type="bool"/>
+  <public name="leak_canary_add_launcher_icon" type="bool"/>
 
 </resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
new file mode 100644
index 00000000..28676e14
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
@@ -0,0 +1,80 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <string name="leak_canary_about_title">About LeakCanary</string>
+  <string name="leak_canary_about_message"><![CDATA[<a href="https://github.com/square/leakcanary">LeakCanary</a>
+  is a memory leak detection library for Android, created by
+  <a href="https://twitter.com/Piwai">Pierre-Yves Ricau</a> and open sourced by Square.<br><br>
+  We welcome contributions from the community, please do not hesitate to
+  <a href="https://github.com/square/leakcanary/issues">report an issue</a> or open a pull request!<br>]]></string>
+  <string name="leak_canary_class_has_leaked">%1$s leaked</string>
+  <string name="leak_canary_class_has_leaked_retaining">%1$s leaked %2$s</string>
+  <string name="leak_canary_class_no_leak">%1$s was never GCed but no leak found</string>
+  <string name="leak_canary_download_dump">You can download the heap dump via \"Menu > Share Heap Dump\" or \"adb pull %1$s\"</string>
+  <string name="leak_canary_leak_excluded">[Excluded] %1$s leaked</string>
+  <string name="leak_canary_leak_excluded_retaining">[Excluded] %1$s leaked %2$s</string>
+  <string name="leak_canary_analysis_failed">Leak analysis failed</string>
+  <string name="leak_canary_leak_list_title">Leaks in %s</string>
+  <string name="leak_canary_notification_analysing">Analyzing Heap Dump</string>
+  <string name="leak_canary_notification_channel">LeakCanary</string>
+  <string name="leak_canary_notification_dumping">Dumping Heap</string>
+  <string name="leak_canary_notification_foreground_text">LeakCanary is working.</string>
+  <string name="leak_canary_notification_message">Click for more details</string>
+  <string name="leak_canary_notification_reporting">Reporting LeakCanary result</string>
+  <string name="leak_canary_no_leak_details">LeakCanary could not find a valid path to GC roots. Download the heap dump and investigate with MAT or YourKit.</string>
+  <string name="leak_canary_result_failure_no_disk_space">The analysis result could not be saved to disk</string>
+  <string name="leak_canary_result_failure_no_file">The analysis result could not be loaded from disk</string>
+  <string name="leak_canary_result_failure_title">Analysis result failure</string>
+  <string name="leak_canary_share_leak">Share info</string>
+  <string name="leak_canary_share_heap_dump">Share heap dump</string>
+  <string name="leak_canary_share_with">Share with…</string>
+  <string name="leak_canary_display_activity_label">Leaks</string>
+  <string name="leak_canary_storage_permission_activity_label">Storage permission</string>
+  <string name="leak_canary_toast_heap_dump">LeakCanary is dumping the heap, app will freeze. Brrrr.</string>
+  <string name="leak_canary_delete">Delete</string>
+  <string name="leak_canary_failure_report">"Please report this failure to http://github.com/square/leakcanary and share the heapdump file that caused it."</string>
+  <string name="leak_canary_delete_all">Delete all</string>
+  <string name="leak_canary_delete_all_leaks_title">Are you sure you want to delete all leaks?</string>
+  <string name="leak_canary_could_not_save_text">LeakCanary was unable to save the analysis result.</string>
+  <string name="leak_canary_excluded_row">[Excluded] %s</string>
+  <string name="leak_canary_permission_not_granted">Please grant external storage permission, otherwise memory leaks will not be detected.</string>
+  <string name="leak_canary_permission_notification_title">Leak detected, need permission</string>
+  <string name="leak_canary_permission_notification_text">Click to enable storage permission for %s.</string>
+  <string name="leak_canary_shortcut_label">Leaks</string>
+  <string name="leak_canary_stackoverflow_share">Share Leak On Stack Overflow</string>
+  <string name="leak_canary_leak_copied">Leak info copied to clipboard</string>
+  <string name="leak_canary_leak_clipdata_label">LeakCanary Leak Trace</string>
+  <string name="leak_canary_help_title">Tap here to learn more</string>
+  <string name="leak_canary_help_detail"><![CDATA[A memory leak is a programming error that causes
+  your application to keep a reference to an object that is no longer needed. As a result, the
+  memory allocated for that object cannot be reclaimed, eventually leading to an OutOfMemoryError
+  crash.<br>
+  <br>For instance, an Android activity instance is no longer needed after its <i>onDestroy()</i>
+  method is called, and storing a reference to that activity in a static field would prevent it from
+  being garbage collected.<br>
+  <br>
+  LeakCanary identifies an object that is no longer needed and finds the chain of
+  <font color=\'#9976a8\'>references</font> that prevents it from being garbage collected.<br>
+  <br>
+  To fix a memory leak, you need to look at that chain and find which reference is causing the
+  leak, i.e. which reference should have been cleared at the time of the leak. LeakCanary highlights
+  with a red underline wave the <b><u><font color=\'#9976a8\'>references</font></u></b> that are the
+  possible causes of the leak.<br>
+  <br>
+  Tap on each reference row for more details, tap again to close.
+]]></string>
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_themes.xml b/leakcanary-android-core/src/main/res/values/leak_canary_themes.xml
similarity index 99%
rename from leakcanary-android/src/main/res/values/leak_canary_themes.xml
rename to leakcanary-android-core/src/main/res/values/leak_canary_themes.xml
index eebd0333..2ca041d4 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_themes.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_themes.xml
@@ -15,7 +15,7 @@
   ~ limitations under the License.
   -->
 <resources>
-  <style name="leak_canary_LeakCanary.Base" parent="android:Theme">
+  <style name="leak_canary_LeakCanary.Base" parent="android:Theme.Holo">
   </style>
 
   <style name="leak_canary_Theme.Transparent" parent="android:Theme">
diff --git a/leakcanary-android-core/src/main/res/xml/leak_canary_file_paths.xml b/leakcanary-android-core/src/main/res/xml/leak_canary_file_paths.xml
new file mode 100644
index 00000000..05952829
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/xml/leak_canary_file_paths.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<paths>
+  <external-path name="downloads" path="Download/" />
+  <files-path name="leakcanary" path="leakcanary/" />
+
+</paths>
diff --git a/leakcanary-android-instrumentation/build.gradle b/leakcanary-android-instrumentation/build.gradle
new file mode 100644
index 00000000..83e526e4
--- /dev/null
+++ b/leakcanary-android-instrumentation/build.gradle
@@ -0,0 +1,33 @@
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+
+dependencies {
+  api project(':leakcanary-android-perflib')
+  api project(':leakcanary-android')
+
+  implementation deps.androidx.test.runner
+  implementation deps.kotlin.stdlib
+
+  androidTestImplementation deps.androidx.test.core
+  androidTestImplementation deps.androidx.test.espresso
+  androidTestImplementation deps.androidx.test.rules
+  androidTestImplementation deps.androidx.test.runner
+  androidTestImplementation deps.androidx.fragment
+}
+
+android {
+  compileSdkVersion versions.compileSdk
+  defaultConfig {
+    minSdkVersion versions.minSdk
+    testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
+  }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    // junit references java.lang.management
+    ignore 'InvalidPackage'
+    check 'Interoperability'
+  }
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android-instrumentation/gradle.properties b/leakcanary-android-instrumentation/gradle.properties
new file mode 100644
index 00000000..ab8ed750
--- /dev/null
+++ b/leakcanary-android-instrumentation/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-android-instrumentation
+POM_NAME=LeakCanary extension for Android instrumentation tests.
+POM_PACKAGING=aar
\ No newline at end of file
diff --git a/leakcanary-android-no-op/src/main/AndroidManifest.xml b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
similarity index 67%
rename from leakcanary-android-no-op/src/main/AndroidManifest.xml
rename to leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
index acd455c3..6a882d52 100644
--- a/leakcanary-android-no-op/src/main/AndroidManifest.xml
+++ b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-  ~ Copyright (C) 2015 Square, Inc.
+  ~ Copyright (C) 2018 Square, Inc.
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
@@ -14,8 +14,9 @@
   ~ See the License for the specific language governing permissions and
   ~ limitations under the License.
   -->
-<manifest
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.squareup.leakcanary.android.noop"
-    >
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.leakcanary.instrumentation.test">
+  <application android:name="leakcanary.InstrumentationTestApplication">
+    <activity android:name="leakcanary.TestActivity"/>
+  </application>
 </manifest>
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
new file mode 100644
index 00000000..fb665265
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
@@ -0,0 +1,113 @@
+package leakcanary
+
+import android.app.Activity
+import android.app.Application
+import android.os.Bundle
+import android.os.Looper
+import android.os.MessageQueue
+import android.view.View
+import androidx.test.core.app.ApplicationProvider.getApplicationContext
+import androidx.test.rule.ActivityTestRule
+import leakcanary.TestUtils.assertLeak
+import leakcanary.internal.ActivityLifecycleCallbacksAdapter
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import java.util.concurrent.CountDownLatch
+
+class FragmentLeakTest {
+
+  @get:Rule
+  var activityRule = ActivityTestRule(
+      TestActivity::class.java, !TOUCH_MODE, !LAUNCH_ACTIVITY
+  )
+
+  @Before fun setUp() {
+    LeakSentry.refWatcher
+        .clearWatchedReferences()
+  }
+
+  @After fun tearDown() {
+    LeakSentry.refWatcher
+        .clearWatchedReferences()
+  }
+
+  @Test
+  fun fragmentShouldLeak() {
+    startActivityAndWaitForCreate()
+
+    LeakingFragment.add(activityRule.activity)
+
+    val waitForFragmentDetach = activityRule.activity.waitForFragmentDetached()
+    val waitForActivityDestroy = waitForActivityDestroy()
+    activityRule.finishActivity()
+    waitForFragmentDetach.await()
+    waitForActivityDestroy.await()
+
+    assertLeak(LeakingFragment::class.java)
+  }
+
+  @Test
+  fun fragmentViewShouldLeak() {
+    startActivityAndWaitForCreate()
+    val activity = activityRule.activity
+
+    val waitForFragmentViewDestroyed = activity.waitForFragmentViewDestroyed()
+    // First, add a new fragment
+    ViewLeakingFragment.addToBackstack(activity)
+    // Then, add a new fragment again, which destroys the view of the previous fragment and puts
+    // that fragment in the backstack.
+    ViewLeakingFragment.addToBackstack(activity)
+    waitForFragmentViewDestroyed.await()
+
+    assertLeak(View::class.java)
+  }
+
+  private fun startActivityAndWaitForCreate() {
+    val waitForActivityOnCreate = CountDownLatch(1)
+    val app = getApplicationContext<Application>()
+    app.registerActivityLifecycleCallbacks(object : ActivityLifecycleCallbacksAdapter() {
+      override fun onActivityCreated(
+        activity: Activity,
+        savedInstanceState: Bundle?
+      ) {
+        app.unregisterActivityLifecycleCallbacks(this)
+        waitForActivityOnCreate.countDown()
+      }
+    })
+
+    activityRule.launchActivity(null)
+
+    try {
+      waitForActivityOnCreate.await()
+    } catch (e: InterruptedException) {
+      throw RuntimeException(e)
+    }
+  }
+
+  private fun waitForActivityDestroy(): CountDownLatch {
+    val latch = CountDownLatch(1)
+    val countDownOnIdle = MessageQueue.IdleHandler {
+      latch.countDown()
+      false
+    }
+    val testActivity = activityRule.activity
+    testActivity.application.registerActivityLifecycleCallbacks(
+        object : ActivityLifecycleCallbacksAdapter() {
+          override fun onActivityDestroyed(activity: Activity) {
+            if (activity == testActivity) {
+              activity.application.unregisterActivityLifecycleCallbacks(this)
+              Looper.myQueue()
+                  .addIdleHandler(countDownOnIdle)
+            }
+          }
+        })
+    return latch
+  }
+
+  companion object {
+    private const val TOUCH_MODE = true
+    private const val LAUNCH_ACTIVITY = true
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Fragments.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Fragments.kt
new file mode 100644
index 00000000..87af731a
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Fragments.kt
@@ -0,0 +1,40 @@
+package leakcanary
+
+import androidx.fragment.app.Fragment
+import androidx.fragment.app.FragmentActivity
+import androidx.fragment.app.FragmentManager
+import java.util.concurrent.CountDownLatch
+
+internal fun FragmentActivity.waitForFragmentDetached(): CountDownLatch {
+  val latch = CountDownLatch(1)
+  val fragmentManager = supportFragmentManager
+  fragmentManager.registerFragmentLifecycleCallbacks(
+      object : FragmentManager.FragmentLifecycleCallbacks() {
+        override fun onFragmentDetached(
+          fm: FragmentManager,
+          f: Fragment
+        ) {
+          fragmentManager.unregisterFragmentLifecycleCallbacks(this)
+          latch.countDown()
+        }
+      }, false
+  )
+  return latch
+}
+
+internal fun FragmentActivity.waitForFragmentViewDestroyed(): CountDownLatch {
+  val latch = CountDownLatch(1)
+  val fragmentManager = supportFragmentManager
+  fragmentManager.registerFragmentLifecycleCallbacks(
+      object : FragmentManager.FragmentLifecycleCallbacks() {
+        override fun onFragmentViewDestroyed(
+          fm: FragmentManager,
+          f: Fragment
+        ) {
+          fragmentManager.unregisterFragmentLifecycleCallbacks(this)
+          latch.countDown()
+        }
+      }, false
+  )
+  return latch
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/HeapAnalyzerComparisonTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/HeapAnalyzerComparisonTest.kt
new file mode 100644
index 00000000..6761a921
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/HeapAnalyzerComparisonTest.kt
@@ -0,0 +1,137 @@
+package leakcanary
+
+import android.os.Debug
+import android.os.Handler
+import android.os.Looper
+import android.os.SystemClock
+import androidx.test.platform.app.InstrumentationRegistry
+import leakcanary.AnalyzerProgressListener.Step
+import leakcanary.internal.perflib.PerflibHeapAnalyzer
+import org.junit.Ignore
+import org.junit.Test
+import java.io.File
+import java.util.Date
+import java.util.concurrent.Executor
+
+/**
+ * Instrumentation test that runs the two heap analyzer implementations on the same heap
+ * dump and logs how they perform. This isn't meant to run as part of the test suite.
+ */
+@Ignore
+class HeapAnalyzerComparisonTest {
+
+  @Volatile
+  var firstMaxMemoryUsed = 0L
+
+  @Volatile
+  var secondMaxMemoryUsed = 0L
+
+  @Test fun compareHprofParsers() {
+    leaking = Date()
+
+    val clock = object : Clock {
+      override fun uptimeMillis(): Long {
+        return SystemClock.uptimeMillis()
+      }
+    }
+    val executor = Executor { command -> command.run() }
+    val onReferenceRetained = {}
+    val refWatcher = RefWatcher(clock, executor, onReferenceRetained)
+    refWatcher.watch(leaking)
+
+    val instrumentation = InstrumentationRegistry.getInstrumentation()
+    val context = instrumentation.targetContext
+
+    val heapDumpFile = File(context.filesDir, "HeapAnalyzerComparisonTest.hprof")
+
+    val heapDump = HeapDump.builder(heapDumpFile)
+        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
+        .reachabilityInspectorClasses(AndroidReachabilityInspectors.defaultAndroidInspectors())
+        .build()
+
+    SystemClock.sleep(2000)
+
+    val retainedKeys = refWatcher.retainedKeys
+    HeapDumpMemoryStore.setRetainedKeysForHeapDump(retainedKeys)
+    HeapDumpMemoryStore.heapDumpUptimeMillis = SystemClock.uptimeMillis()
+
+    Debug.dumpHprofData(heapDumpFile.absolutePath)
+
+    val mainHandler = Handler(Looper.getMainLooper())
+
+    val runtime = Runtime.getRuntime()
+
+    val logMemory: Runnable = object : Runnable {
+      override fun run() {
+        val memoryUsed = runtime.totalMemory() - runtime.freeMemory()
+        CanaryLog.d("Memory: %d Mb", memoryUsed / 1048576L)
+        mainHandler.postDelayed(this, 1000)
+      }
+    }
+    logMemory.run()
+
+    SystemClock.sleep(2000)
+    GcTrigger.Default.runGc()
+    SystemClock.sleep(2000)
+
+    val memoryBeforeFirst = runtime.totalMemory() - runtime.freeMemory()
+
+    val countMemory1: Runnable = object : Runnable {
+      override fun run() {
+        val memoryUsed = runtime.totalMemory() - runtime.freeMemory()
+        firstMaxMemoryUsed = Math.max(firstMaxMemoryUsed, memoryUsed)
+        mainHandler.postDelayed(this, 100)
+      }
+    }
+    countMemory1.run()
+
+    val listener = object : AnalyzerProgressListener {
+      override fun onProgressUpdate(step: Step) {
+        CanaryLog.d("Step %s", step)
+      }
+
+    }
+    CanaryLog.d("Starting first analysis")
+    val firstAnalysis = PerflibHeapAnalyzer(listener).checkForLeaks(heapDump) as HeapAnalysisSuccess
+    CanaryLog.d("Done with first analysis")
+    val memoryUsedFirstInMb = (firstMaxMemoryUsed - memoryBeforeFirst) / 1048576L
+
+    SystemClock.sleep(2000)
+    GcTrigger.Default.runGc()
+    SystemClock.sleep(2000)
+    val memoryBeforeSecond = runtime.totalMemory() - runtime.freeMemory()
+
+    val countMemory2: Runnable = object : Runnable {
+      override fun run() {
+        val memoryUsed = runtime.totalMemory() - runtime.freeMemory()
+        secondMaxMemoryUsed = Math.max(secondMaxMemoryUsed, memoryUsed)
+        mainHandler.postDelayed(this, 100)
+      }
+    }
+    countMemory2.run()
+
+    val secondAnalysis = HeapAnalyzer(listener)
+        .checkForLeaks(heapDump, LeakCanary.config.labelers) as HeapAnalysisSuccess
+    val memoryUsedSecondInMb = (secondMaxMemoryUsed - memoryBeforeSecond) / 1048576L
+
+    CanaryLog.d(
+        "Perflib analysis used %d Mb took %d ms", memoryUsedFirstInMb,
+        firstAnalysis.analysisDurationMillis
+    )
+    CanaryLog.d(
+        "Random Access analysis used %d Mb took %d ms", memoryUsedSecondInMb,
+        secondAnalysis.analysisDurationMillis
+    )
+
+
+    require(firstAnalysis.retainedInstances.size == 1)
+    require(secondAnalysis.retainedInstances.size == 1)
+
+    firstAnalysis.retainedInstances[0] as LeakingInstance
+    secondAnalysis.retainedInstances[0] as LeakingInstance
+  }
+
+  companion object {
+    private lateinit var leaking: Any
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
new file mode 100644
index 00000000..dcc44bc6
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
@@ -0,0 +1,35 @@
+package leakcanary
+
+import leakcanary.TestUtils.assertLeak
+import org.junit.After
+import org.junit.Before
+import org.junit.Test
+import java.util.Date
+
+/**
+ * Tests that the [InstrumentationLeakDetector] can detect leaks
+ * in instrumentation tests
+ */
+class InstrumentationLeakDetectorTest {
+
+  @Before fun setUp() {
+    LeakSentry.refWatcher
+        .clearWatchedReferences()
+  }
+
+  @After fun tearDown() {
+    LeakSentry.refWatcher
+        .clearWatchedReferences()
+  }
+
+  @Test fun detectsLeak() {
+    leaking = Date()
+    val refWatcher = LeakSentry.refWatcher
+    refWatcher.watch(leaking)
+    assertLeak(Date::class.java)
+  }
+
+  companion object {
+    private lateinit var leaking: Any
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationTestApplication.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationTestApplication.kt
new file mode 100644
index 00000000..289621e0
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationTestApplication.kt
@@ -0,0 +1,10 @@
+package leakcanary
+
+import android.app.Application
+
+class InstrumentationTestApplication : Application() {
+  override fun onCreate() {
+    super.onCreate()
+    InstrumentationLeakDetector.updateConfig()
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LeakingFragment.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LeakingFragment.kt
new file mode 100644
index 00000000..316d11f1
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LeakingFragment.kt
@@ -0,0 +1,21 @@
+package leakcanary
+
+import androidx.fragment.app.Fragment
+
+import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
+
+class LeakingFragment : Fragment() {
+  companion object {
+    fun add(activity: TestActivity) {
+      getInstrumentation().runOnMainSync {
+        leakingFragment = LeakingFragment()
+        activity.supportFragmentManager
+            .beginTransaction()
+            .add(0, leakingFragment)
+            .commitNow()
+      }
+    }
+
+    private lateinit var leakingFragment: LeakingFragment
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestActivity.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestActivity.kt
new file mode 100644
index 00000000..d9d7367d
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestActivity.kt
@@ -0,0 +1,12 @@
+package leakcanary
+
+import android.os.Bundle
+import androidx.fragment.app.FragmentActivity
+import com.squareup.leakcanary.instrumentation.test.R
+
+class TestActivity : FragmentActivity() {
+  override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+    setContentView(R.layout.activity_test)
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
new file mode 100644
index 00000000..639e4d8d
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
@@ -0,0 +1,31 @@
+package leakcanary
+
+import leakcanary.InstrumentationLeakDetector.Result.AnalysisPerformed
+import leakcanary.InstrumentationLeakDetector.Result.NoAnalysis
+
+object TestUtils {
+  fun assertLeak(expectedLeakClass: Class<*>) {
+    val leakDetector = InstrumentationLeakDetector()
+    val result = leakDetector.detectLeaks()
+
+    val heapAnalysis = when (result) {
+      is NoAnalysis -> throw AssertionError("Expected analysis to be performed")
+      is AnalysisPerformed -> result.heapAnalysis
+    }
+
+    val applicationLeaks = heapAnalysis.applicationLeaks()
+    if (applicationLeaks.size != 1) {
+      throw AssertionError(
+          "Expected exactly one leak in $heapAnalysis"
+      )
+    }
+
+    val leakInstance = applicationLeaks.first()
+
+    if (leakInstance.instanceClassName != expectedLeakClass.name) {
+      throw AssertionError(
+          "Expected a leak of $expectedLeakClass, not ${leakInstance.instanceClassName} in $heapAnalysis"
+      )
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ViewLeakingFragment.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ViewLeakingFragment.kt
new file mode 100644
index 00000000..0ad9fd42
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ViewLeakingFragment.kt
@@ -0,0 +1,41 @@
+package leakcanary
+
+import android.os.Bundle
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import androidx.fragment.app.Fragment
+import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
+import com.squareup.leakcanary.instrumentation.test.R
+
+class ViewLeakingFragment : Fragment() {
+
+  private var leakingView: View? = null
+
+  override fun onCreateView(
+    inflater: LayoutInflater,
+    container: ViewGroup?,
+    savedInstanceState: Bundle?
+  ) = View(container?.context)
+
+  override fun onViewCreated(
+    view: View,
+    savedInstanceState: Bundle?
+  ) {
+    // Leak: this fragment will stay in memory after being replaced, leakingView should be cleared
+    // onDestroyView()
+    leakingView = view
+  }
+
+  companion object {
+    fun addToBackstack(activity: TestActivity) {
+      getInstrumentation().runOnMainSync {
+        activity.supportFragmentManager
+            .beginTransaction()
+            .addToBackStack(null)
+            .replace(R.id.fragments, ViewLeakingFragment())
+            .commit()
+      }
+    }
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/res/layout/activity_test.xml b/leakcanary-android-instrumentation/src/androidTest/res/layout/activity_test.xml
new file mode 100644
index 00000000..39664a73
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/res/layout/activity_test.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/fragments"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    />
diff --git a/leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml b/leakcanary-android-instrumentation/src/main/AndroidManifest.xml
similarity index 81%
rename from leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml
rename to leakcanary-android-instrumentation/src/main/AndroidManifest.xml
index 409cb66b..72e8cd5f 100644
--- a/leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml
+++ b/leakcanary-android-instrumentation/src/main/AndroidManifest.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-  ~ Copyright (C) 2015 Square, Inc.
+  ~ Copyright (C) 2018 Square, Inc.
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
@@ -14,7 +14,5 @@
   ~ See the License for the specific language governing permissions and
   ~ limitations under the License.
   -->
-<resources>
-  <style name="leak_canary_LeakCanary.Base" parent="android:Theme.Holo">
-  </style>
-</resources>
\ No newline at end of file
+<manifest package="com.squareup.leakcanary.instrumentation">
+</manifest>
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
new file mode 100644
index 00000000..6259a841
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import android.app.Instrumentation
+import android.os.Bundle
+import androidx.test.internal.runner.listener.InstrumentationResultPrinter
+import androidx.test.internal.runner.listener.InstrumentationResultPrinter.REPORT_VALUE_RESULT_FAILURE
+import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
+import leakcanary.InstrumentationLeakDetector.Result.AnalysisPerformed
+import org.junit.runner.Description
+import org.junit.runner.Result
+import org.junit.runner.notification.Failure
+import org.junit.runner.notification.RunListener
+
+/**
+ *
+ * A JUnit [RunListener] for detecting memory leaks in Android instrumentation tests. It
+ * waits for the end of a test, and if the test succeeds then it will look for leaking
+ * references, trigger a heap dump if needed and perform an analysis.
+ *
+ *  [FailTestOnLeakRunListener] can be subclassed to override
+ * [skipLeakDetectionReason], [reportLeaks]
+ * or [buildLeakDetectedMessage]
+ *
+ * @see InstrumentationLeakDetector
+ */
+open class FailTestOnLeakRunListener : RunListener() {
+  private lateinit var bundle: Bundle
+  private var skipLeakDetectionReason: String? = null
+
+  override fun testStarted(description: Description) {
+    skipLeakDetectionReason = skipLeakDetectionReason(description)
+    if (skipLeakDetectionReason != null) {
+      return
+    }
+    val testClass = description.className
+    val testName = description.methodName
+
+    bundle = Bundle()
+    bundle.putString(
+        Instrumentation.REPORT_KEY_IDENTIFIER, FailTestOnLeakRunListener::class.java.name
+    )
+    bundle.putString(InstrumentationResultPrinter.REPORT_KEY_NAME_CLASS, testClass)
+    bundle.putString(InstrumentationResultPrinter.REPORT_KEY_NAME_TEST, testName)
+  }
+
+  /**
+   * Can be overridden to skip leak detection based on the description provided when a test
+   * is started. Returns null to continue leak detection, or a string describing the reason for
+   * skipping otherwise.
+   */
+  protected open fun skipLeakDetectionReason(description: Description): String? {
+    return null
+  }
+
+  override fun testFailure(failure: Failure) {
+    skipLeakDetectionReason = "failed"
+  }
+
+  override fun testIgnored(description: Description) {
+    skipLeakDetectionReason = "was ignored"
+  }
+
+  override fun testAssumptionFailure(failure: Failure) {
+    skipLeakDetectionReason = "had an assumption failure"
+  }
+
+  override fun testFinished(description: Description) {
+    detectLeaks()
+    LeakSentry.refWatcher.clearWatchedReferences()
+  }
+
+  override fun testRunStarted(description: Description) {
+    InstrumentationLeakDetector.updateConfig()
+  }
+
+  override fun testRunFinished(result: Result) {}
+
+  private fun detectLeaks() {
+    if (skipLeakDetectionReason != null) {
+      CanaryLog.d("Skipping leak detection because the test %s", skipLeakDetectionReason)
+      skipLeakDetectionReason = null
+      return
+    }
+
+    val leakDetector = InstrumentationLeakDetector()
+    val result = leakDetector.detectLeaks()
+
+    if (result is AnalysisPerformed) {
+      val applicationLeaks = result.heapAnalysis.applicationLeaks()
+      if (applicationLeaks.isNotEmpty()) {
+        reportLeaks(result.heapAnalysis, applicationLeaks)
+      }
+    }
+  }
+
+  /** Can be overridden to report leaks in a different way or do additional reporting.  */
+  protected open fun reportLeaks(
+    heapAnalysis: HeapAnalysis,
+    applicationLeaks: List<LeakingInstance>
+  ) {
+    val message = buildLeakDetectedMessage(heapAnalysis, applicationLeaks)
+
+    bundle.putString(InstrumentationResultPrinter.REPORT_KEY_STACK, message)
+    getInstrumentation().sendStatus(REPORT_VALUE_RESULT_FAILURE, bundle)
+  }
+
+  /** Can be overridden to customize the failure string message.  */
+  protected open fun buildLeakDetectedMessage(
+    heapAnalysis: HeapAnalysis,
+    applicationLeaks: List<LeakingInstance>
+  ): String {
+    val failureMessage = StringBuilder()
+    failureMessage.append(
+        "Test failed because memory leaks were detected, see leak traces below.\n"
+    )
+    failureMessage.append(SEPARATOR)
+
+    applicationLeaks.forEach { applicationLeak ->
+      // TODO Improve rendering
+      failureMessage.append(applicationLeak.toString())
+      failureMessage.append("\n ")
+      failureMessage.append(SEPARATOR)
+    }
+
+    return failureMessage.toString()
+  }
+
+  companion object {
+    private const val SEPARATOR = "######################################\n"
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
new file mode 100644
index 00000000..14f13cb0
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import android.os.Debug
+import android.os.SystemClock
+import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
+import leakcanary.GcTrigger.Default.runGc
+import leakcanary.InstrumentationLeakDetector.Result.AnalysisPerformed
+import leakcanary.InstrumentationLeakDetector.Result.NoAnalysis
+import org.junit.runner.notification.RunListener
+import java.io.File
+
+/**
+ * TODO Update this doc to match LeakCanary 2.0
+ *
+ * [InstrumentationLeakDetector] can be used to detect memory leaks in instrumentation tests.
+ *
+ * To use it, you need to:
+ *
+ *  * Install a custom RefWatcher that will not trigger heapdumps while the tests run.
+ *  * Add an instrumentation test listener (a [RunListener]) that will invoke
+ * [detectLeaks]
+ *
+ * ### Installing the instrumentation RefWatcher
+ *
+ * For [detectLeaks] to work correctly, the [RefWatcher] must keep track of
+ * references but not trigger any heap dump until this [detectLeaks] runs, otherwise an
+ * analysis in progress might prevent this listener from performing its own analysis.
+ *
+ * Create and install the [RefWatcher] instance using
+ * [instrumentationRefWatcher] instead of
+ * [LeakCanary.install] or [LeakCanary.refWatcher].
+ *
+ * ```
+ * public class InstrumentationExampleApplication extends ExampleApplication {
+ *  @Override protected void setupLeakCanary() {
+ *    InstrumentationLeakDetector.instrumentationRefWatcher(this)
+ *      .buildAndInstall();
+ *  }
+ * }
+ * ```
+ *
+ * ### Add an instrumentation test listener
+ *
+ * LeakCanary provides [FailTestOnLeakRunListener], but you should feel free to implement
+ * your own [RunListener] and call [.detectLeaks] directly if you need a more custom
+ * behavior (for instance running it only once per test suite, or reporting to a backend).
+ *
+ * All you need to do is add the following to the defaultConfig of your build.gradle:
+ *
+ * `testInstrumentationRunnerArgument "listener", "leakcanary.FailTestOnLeakRunListener"`
+ *
+ * Then you can run your instrumentation tests via Gradle as usually, and they will fail when
+ * a memory leak is detected:
+ *
+ * `./gradlew leakcanary-sample:connectedCheck`
+ *
+ * If instead you want to run UI tests via adb, add a *listener* execution argument to
+ * your command line for running the UI tests:
+ * `-e listener leakcanary.FailTestOnLeakRunListener`. The full command line
+ * should look something like this:
+ * ```
+ * adb shell am instrument \\
+ * -w com.android.foo/android.support.test.runner.AndroidJUnitRunner \\
+ * -e listener leakcanary.FailTestOnLeakRunListener
+ * ```
+ *
+ * ### Rationale
+ * Instead of using the [FailTestOnLeakRunListener], one could simply enable LeakCanary in
+ * instrumentation tests.
+ *
+ * This approach would have two disadvantages:
+ *
+ *  * Heap dumps freeze the VM, and the leak analysis is IO and CPU heavy. This can slow down
+ * the test and introduce flakiness
+ *  * The leak analysis is asynchronous by default, and happens in a separate process. This means
+ * the tests could finish and the process die before the analysis is finished.
+ *
+ * The approach taken here is to collect all references to watch as you run the test, but not
+ * do any heap dump during the test. Then, at the end, if any of the watched objects is still in
+ * memory we dump the heap and perform a blocking analysis. There is only one heap dump performed,
+ * no matter the number of objects leaking.
+ */
+class InstrumentationLeakDetector {
+
+  sealed class Result {
+    object NoAnalysis : Result()
+    class AnalysisPerformed(val heapAnalysis: HeapAnalysis) : Result()
+  }
+
+  fun detectLeaks(): Result {
+    val leakDetectionTime = SystemClock.uptimeMillis()
+    val watchDurationMillis = LeakSentry.config.watchDurationMillis
+    val instrumentation = getInstrumentation()
+    val context = instrumentation.targetContext
+    val refWatcher = LeakSentry.refWatcher
+
+    if (!refWatcher.hasWatchedReferences) {
+      return NoAnalysis
+    }
+
+    instrumentation.waitForIdleSync()
+    if (!refWatcher.hasWatchedReferences) {
+      return NoAnalysis
+    }
+
+    runGc()
+    if (!refWatcher.hasWatchedReferences) {
+      return NoAnalysis
+    }
+
+    // Waiting for any delayed UI post (e.g. scroll) to clear. This shouldn't be needed, but
+    // Android simply has way too many delayed posts that aren't canceled when views are detached.
+    SystemClock.sleep(2000)
+
+    if (!refWatcher.hasWatchedReferences) {
+      return NoAnalysis
+    }
+
+    // Aaand we wait some more.
+    // 4 seconds (2+2) is greater than the 3 seconds delay for
+    // FINISH_TOKEN in android.widget.Filter
+    SystemClock.sleep(2000)
+
+    val endOfWatchDelay = watchDurationMillis - (SystemClock.uptimeMillis() - leakDetectionTime)
+    if (endOfWatchDelay > 0) {
+      SystemClock.sleep(endOfWatchDelay)
+    }
+
+    runGc()
+
+    if (!refWatcher.hasRetainedReferences) {
+      return NoAnalysis
+    }
+
+    // We're always reusing the same file since we only execute this once at a time.
+    val heapDumpFile = File(context.filesDir, "instrumentation_tests_heapdump.hprof")
+
+    val config = LeakCanary.config
+
+    val heapDump = HeapDump.builder(heapDumpFile)
+        .excludedRefs(config.excludedRefs)
+        .reachabilityInspectorClasses(config.reachabilityInspectorClasses)
+        .build()
+
+    val retainedKeys = refWatcher.retainedKeys
+    HeapDumpMemoryStore.setRetainedKeysForHeapDump(retainedKeys)
+    HeapDumpMemoryStore.heapDumpUptimeMillis = SystemClock.uptimeMillis()
+
+
+    try {
+      Debug.dumpHprofData(heapDumpFile.absolutePath)
+    } catch (exception: Exception) {
+      CanaryLog.d(exception, "Could not dump heap")
+      return AnalysisPerformed(
+          HeapAnalysisFailure(
+              heapDump, analysisDurationMillis = 0,
+              createdAtTimeMillis = System.currentTimeMillis(),
+              exception = HeapAnalysisException(exception)
+          )
+      )
+    }
+
+    refWatcher.removeRetainedKeys(retainedKeys)
+
+    val listener = AnalyzerProgressListener.NONE
+
+    val heapAnalyzer = HeapAnalyzer(listener)
+    val heapAnalysis = heapAnalyzer.checkForLeaks(heapDump, config.labelers)
+
+    CanaryLog.d("Heap Analysis:\n%s", heapAnalysis)
+
+    return AnalysisPerformed(heapAnalysis)
+  }
+
+  companion object {
+
+    /**
+     * Configures LeakCanary to not dump the heap so that instrumentation tests run smoothly,
+     * and we can look for leaks at the end of a test. This is automatically called by
+     * [FailTestOnLeakRunListener] when the tests start running.
+     */
+    fun updateConfig() {
+      LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
+    }
+  }
+}
diff --git a/leakcanary-android-no-op/build.gradle b/leakcanary-android-no-op/build.gradle
deleted file mode 100644
index 5f3dc025..00000000
--- a/leakcanary-android-no-op/build.gradle
+++ /dev/null
@@ -1,33 +0,0 @@
-version rootProject.ext.VERSION_NAME
-group rootProject.ext.GROUP
-
-buildscript {
-  repositories {
-    mavenCentral()
-  }
-}
-
-apply plugin: 'com.android.library'
-
-repositories {
-  mavenCentral()
-}
-
-dependencies {
-}
-
-android {
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
-  defaultConfig {
-    minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.targetSdkVersion
-  }
-}
-
-task sourceJar(type: Jar) {
-  from 'src/main/java'
-}
-
-apply from: rootProject.file('gradle/checkstyle.gradle')
-apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/leakcanary-android-no-op/gradle.properties b/leakcanary-android-no-op/gradle.properties
deleted file mode 100644
index 60494b8a..00000000
--- a/leakcanary-android-no-op/gradle.properties
+++ /dev/null
@@ -1,2 +0,0 @@
-POM_ARTIFACT_ID=leakcanary-android-no-op
-POM_NAME=No op LeakCanary for Android
\ No newline at end of file
diff --git a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
deleted file mode 100644
index 8fc8a58c..00000000
--- a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package com.squareup.leakcanary;
-
-import android.app.Application;
-
-/**
- * A no-op version of {@link LeakCanary} that can be used in release builds.
- */
-public final class LeakCanary {
-
-  public static RefWatcher install(Application application) {
-    return RefWatcher.DISABLED;
-  }
-
-  private LeakCanary() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/RefWatcher.java
deleted file mode 100644
index ca9f6602..00000000
--- a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package com.squareup.leakcanary;
-
-/**
- * No-op implementation of {@link RefWatcher} for release builds. Please use {@link
- * RefWatcher#DISABLED}.
- */
-public final class RefWatcher {
-
-  public static final RefWatcher DISABLED = new RefWatcher();
-
-  private RefWatcher() {
-  }
-
-  public void watch(Object watchedReference) {
-  }
-
-  public void watch(Object watchedReference, String referenceName) {
-  }
-}
diff --git a/leakcanary-android-perflib/build.gradle b/leakcanary-android-perflib/build.gradle
new file mode 100644
index 00000000..0296c9b5
--- /dev/null
+++ b/leakcanary-android-perflib/build.gradle
@@ -0,0 +1,25 @@
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+
+dependencies {
+  api project(':leakcanary-android-core')
+  api project(':leakcanary-analyzer-perflib')
+
+  implementation deps.kotlin.stdlib
+}
+
+android {
+  compileSdkVersion versions.compileSdk
+  defaultConfig {
+    minSdkVersion versions.minSdk
+  }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    // junit references java.lang.management
+    ignore 'InvalidPackage'
+    check 'Interoperability'
+  }
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android-perflib/gradle.properties b/leakcanary-android-perflib/gradle.properties
new file mode 100644
index 00000000..6931cbfb
--- /dev/null
+++ b/leakcanary-android-perflib/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-android-perflib
+POM_NAME=LeakCanary, analyzing with perflib
+POM_PACKAGING=aar
diff --git a/leakcanary-android-perflib/src/main/AndroidManifest.xml b/leakcanary-android-perflib/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..518781a4
--- /dev/null
+++ b/leakcanary-android-perflib/src/main/AndroidManifest.xml
@@ -0,0 +1,32 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.leakcanary.perflib">
+
+  <application>
+    <service
+        android:name="leakcanary.internal.perflib.PerflibHeapAnalyzerService"
+        android:exported="false"
+        android:process=":leakcanary"
+        >
+      <intent-filter>
+        <action android:name="leakcanary.ANALYSIS_ACTION"/>
+      </intent-filter>
+    </service>
+
+  </application>
+</manifest>
diff --git a/leakcanary-android-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzerService.kt b/leakcanary-android-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzerService.kt
new file mode 100644
index 00000000..31417d44
--- /dev/null
+++ b/leakcanary-android-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzerService.kt
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal.perflib
+
+import android.content.Intent
+import android.os.Process
+import android.os.Process.setThreadPriority
+import com.squareup.leakcanary.core.R
+import leakcanary.AnalyzerProgressListener
+import leakcanary.CanaryLog
+import leakcanary.HeapDump
+import leakcanary.internal.AnalysisResultService
+import leakcanary.internal.ForegroundService
+import leakcanary.internal.HeapAnalyzers
+
+/**
+ * This service runs in a separate process to avoid slowing down the app process or making it run
+ * out of memory.
+ */
+internal class PerflibHeapAnalyzerService : ForegroundService(
+    PerflibHeapAnalyzerService::class.java.simpleName, R.string.leak_canary_notification_analysing
+), AnalyzerProgressListener {
+
+  override fun onHandleIntentInForeground(intent: Intent?) {
+    if (intent == null) {
+      CanaryLog.d("PerflibHeapAnalyzerService received a null intent, ignoring.")
+      return
+    }
+    // Since we're running in the main process we should be careful not to impact it.
+    setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)
+    val heapDump = intent.getSerializableExtra(HeapAnalyzers.HEAPDUMP_EXTRA) as HeapDump
+
+    val heapAnalyzer = PerflibHeapAnalyzer(this)
+    val heapAnalysis = heapAnalyzer.checkForLeaks(heapDump)
+
+    AnalysisResultService.sendResult(this, heapAnalysis)
+  }
+
+  override fun onProgressUpdate(step: AnalyzerProgressListener.Step) {
+    val percent = (100f * step.ordinal / AnalyzerProgressListener.Step.values().size).toInt()
+    CanaryLog.d("Analysis in progress, working on: %s", step.name)
+    val lowercase = step.name.replace("_", " ")
+        .toLowerCase()
+    val message = lowercase.substring(0, 1).toUpperCase() + lowercase.substring(1)
+    showForegroundNotification(100, percent, false, message)
+  }
+}
diff --git a/leakcanary-android/build.gradle b/leakcanary-android/build.gradle
index 70516ea7..dede1431 100644
--- a/leakcanary-android/build.gradle
+++ b/leakcanary-android/build.gradle
@@ -1,45 +1,25 @@
-version rootProject.ext.VERSION_NAME
-group rootProject.ext.GROUP
-
-buildscript {
-  repositories {
-    mavenCentral()
-  }
-}
-
 apply plugin: 'com.android.library'
-
-repositories {
-  mavenCentral()
-}
+apply plugin: 'kotlin-android'
 
 dependencies {
-  compile project(':leakcanary-analyzer')
-}
+  api project(':leakcanary-android-core')
+  api project(':leakcanary-analyzer')
 
-def gitSha() {
-  return 'git rev-parse --short HEAD'.execute().text.trim()
+  implementation deps.kotlin.stdlib
 }
 
 android {
-  resourcePrefix 'leak_canary_'
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
+  compileSdkVersion versions.compileSdk
   defaultConfig {
-    minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.targetSdkVersion
-    buildConfigField "String", "LIBRARY_VERSION", "\"${rootProject.ext.VERSION_NAME}\""
-    buildConfigField "String", "GIT_SHA", "\"${gitSha()}\""
-    consumerProguardFiles 'consumer-proguard-rules.pro'
+    minSdkVersion versions.minSdk
   }
   lintOptions {
     disable 'GoogleAppIndexingWarning'
+    // junit references java.lang.management
+    ignore 'InvalidPackage'
+    check 'Interoperability'
   }
 }
 
-task sourceJar(type: Jar) {
-  from 'src/main/java'
-}
-
 apply from: rootProject.file('gradle/checkstyle.gradle')
-apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android/gradle.properties b/leakcanary-android/gradle.properties
index beee3e6f..e40174ac 100644
--- a/leakcanary-android/gradle.properties
+++ b/leakcanary-android/gradle.properties
@@ -1,2 +1,3 @@
 POM_ARTIFACT_ID=leakcanary-android
-POM_NAME=LeakCanary for Android
\ No newline at end of file
+POM_NAME=LeakCanary Android
+POM_PACKAGING=aar
diff --git a/leakcanary-android/src/main/AndroidManifest.xml b/leakcanary-android/src/main/AndroidManifest.xml
index b5393171..0ee35e1c 100644
--- a/leakcanary-android/src/main/AndroidManifest.xml
+++ b/leakcanary-android/src/main/AndroidManifest.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-  ~ Copyright (C) 2015 Square, Inc.
+  ~ Copyright (C) 2018 Square, Inc.
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
@@ -14,46 +14,19 @@
   ~ See the License for the specific language governing permissions and
   ~ limitations under the License.
   -->
-<manifest
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.squareup.leakcanary"
-    >
-
-  <!-- To store the heap dumps and leak analysis results. -->
-  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
-  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.leakcanary">
 
   <application>
     <service
-        android:name=".internal.HeapAnalyzerService"
-        android:process=":leakcanary"
-        android:enabled="false"
-        />
-    <service
-        android:name=".DisplayLeakService"
-        android:enabled="false"
-        />
-    <activity
-        android:theme="@style/leak_canary_LeakCanary.Base"
-        android:name=".internal.DisplayLeakActivity"
-        android:enabled="false"
-        android:label="@string/leak_canary_display_activity_label"
-        android:icon="@drawable/leak_canary_icon"
-        android:taskAffinity="com.squareup.leakcanary"
+        android:name="leakcanary.internal.HeapAnalyzerService"
+        android:exported="false"
         >
       <intent-filter>
-        <action android:name="android.intent.action.MAIN"/>
-        <category android:name="android.intent.category.LAUNCHER"/>
+        <action android:name="leakcanary.ANALYSIS_ACTION"/>
       </intent-filter>
-    </activity>
-    <activity
-        android:theme="@style/leak_canary_Theme.Transparent"
-        android:name=".internal.RequestStoragePermissionActivity"
-        android:taskAffinity="com.squareup.leakcanary"
-        android:enabled="false"
-        android:icon="@drawable/leak_canary_icon"
-        android:label="@string/leak_canary_storage_permission_activity_label"
-        />
+    </service>
 
   </application>
+
 </manifest>
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
deleted file mode 100644
index 9b193831..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.app.IntentService;
-import android.content.Context;
-import android.content.Intent;
-
-public abstract class AbstractAnalysisResultService extends IntentService {
-
-  private static final String HEAP_DUMP_EXTRA = "heap_dump_extra";
-  private static final String RESULT_EXTRA = "result_extra";
-
-  public static void sendResultToListener(Context context, String listenerServiceClassName,
-      HeapDump heapDump, AnalysisResult result) {
-    Class<?> listenerServiceClass;
-    try {
-      listenerServiceClass = Class.forName(listenerServiceClassName);
-    } catch (ClassNotFoundException e) {
-      throw new RuntimeException(e);
-    }
-    Intent intent = new Intent(context, listenerServiceClass);
-    intent.putExtra(HEAP_DUMP_EXTRA, heapDump);
-    intent.putExtra(RESULT_EXTRA, result);
-    context.startService(intent);
-  }
-
-  public AbstractAnalysisResultService() {
-    super(AbstractAnalysisResultService.class.getName());
-  }
-
-  @Override protected final void onHandleIntent(Intent intent) {
-    HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAP_DUMP_EXTRA);
-    AnalysisResult result = (AnalysisResult) intent.getSerializableExtra(RESULT_EXTRA);
-    try {
-      onHeapAnalyzed(heapDump, result);
-    } finally {
-      //noinspection ResultOfMethodCallIgnored
-      heapDump.heapDumpFile.delete();
-    }
-  }
-
-  /**
-   * Called after a heap dump is analyzed, whether or not a leak was found.
-   * Check {@link AnalysisResult#leakFound} and {@link AnalysisResult#excludedLeak} to see if there
-   * was a leak and if it can be ignored.
-   *
-   * This will be called from a background intent service thread.
-   * <p>
-   * It's OK to block here and wait for the heap dump to be uploaded.
-   * <p>
-   * The heap dump file will be deleted immediately after this callback returns.
-   */
-  protected abstract void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result);
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
deleted file mode 100644
index 160e840f..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.Application;
-import android.os.Bundle;
-
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH;
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-
-@TargetApi(ICE_CREAM_SANDWICH) public final class ActivityRefWatcher {
-
-  public static void installOnIcsPlus(Application application, RefWatcher refWatcher) {
-    if (SDK_INT < ICE_CREAM_SANDWICH) {
-      // If you need to support Android < ICS, override onDestroy() in your base activity.
-      return;
-    }
-    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);
-    activityRefWatcher.watchActivities();
-  }
-
-  private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =
-      new Application.ActivityLifecycleCallbacks() {
-        @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
-        }
-
-        @Override public void onActivityStarted(Activity activity) {
-        }
-
-        @Override public void onActivityResumed(Activity activity) {
-        }
-
-        @Override public void onActivityPaused(Activity activity) {
-        }
-
-        @Override public void onActivityStopped(Activity activity) {
-        }
-
-        @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
-        }
-
-        @Override public void onActivityDestroyed(Activity activity) {
-          ActivityRefWatcher.this.onActivityDestroyed(activity);
-        }
-      };
-
-  private final Application application;
-  private final RefWatcher refWatcher;
-
-  /**
-   * Constructs an {@link ActivityRefWatcher} that will make sure the activities are not leaking
-   * after they have been destroyed.
-   */
-  public ActivityRefWatcher(Application application, final RefWatcher refWatcher) {
-    this.application = checkNotNull(application, "application");
-    this.refWatcher = checkNotNull(refWatcher, "refWatcher");
-  }
-
-  void onActivityDestroyed(Activity activity) {
-    refWatcher.watch(activity);
-  }
-
-  public void watchActivities() {
-    // Make sure you don't get installed twice.
-    stopWatchingActivities();
-    application.registerActivityLifecycleCallbacks(lifecycleCallbacks);
-  }
-
-  public void stopWatchingActivities() {
-    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks);
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
deleted file mode 100644
index e4a9dfd5..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
+++ /dev/null
@@ -1,488 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.lang.ref.PhantomReference;
-import java.lang.ref.SoftReference;
-import java.lang.ref.WeakReference;
-import java.util.EnumSet;
-
-import static android.os.Build.MANUFACTURER;
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.ECLAIR;
-import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH;
-import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1;
-import static android.os.Build.VERSION_CODES.JELLY_BEAN;
-import static android.os.Build.VERSION_CODES.KITKAT;
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
-import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
-import static android.os.Build.VERSION_CODES.M;
-import static com.squareup.leakcanary.AndroidWatchExecutor.LEAK_CANARY_THREAD_NAME;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.LG;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.MOTOROLA;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.NVIDIA;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.SAMSUNG;
-
-/**
- * This class is a work in progress. You can help by reporting leak traces that seem to be caused
- * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
- *
- * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
- * manufacturer implementation, they usually share their builds across multiple models, and the
- * leaks eventually get fixed in newer versions.
- *
- * Most app developers should use {@link #createAppDefaults()}. However, you can also pick the
- * leaks you want to ignore by creating an {@link EnumSet} that matches your needs and calling
- * {@link #createBuilder(EnumSet)}
- */
-public enum AndroidExcludedRefs {
-
-  ACTIVITY_CLIENT_RECORD__NEXT_IDLE(SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle")
-          .reason("Android AOSP sometimes keeps a reference to a destroyed activity as a"
-              + " nextIdle client record in the android.app.ActivityThread.mActivities map."
-              + " Not sure what's going on there, input welcome.");
-    }
-  },
-
-  SPAN_CONTROLLER(SDK_INT <= KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason =
-          "Editor inserts a special span, which has a reference to the EditText. That span is a"
-              + " NoCopySpan, which makes sure it gets dropped when creating a new"
-              + " SpannableStringBuilder from a given CharSequence."
-              + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
-              + " bundle. Prior to KitKat, that copy was done using the SpannableString"
-              + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
-              + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
-              + " reference to the textview and therefore the entire view hierarchy & activity"
-              + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
-              + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
-              + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
-              + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.";
-      excluded.instanceField("android.widget.Editor$EasyEditSpanController", "this$0")
-          .reason(reason);
-      excluded.instanceField("android.widget.Editor$SpanController", "this$0").reason(reason);
-    }
-  },
-
-  MEDIA_SESSION_LEGACY_HELPER__SINSTANCE(SDK_INT == LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance")
-          .reason("MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
-              + " keeps a reference to the context it's given the first time"
-              + " MediaSessionLegacyHelper.getHelper() is called."
-              + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
-              + " calling context.getApplicationContext()."
-              + " Fix: https://github.com/android/platform_frameworks_base/commit"
-              + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
-              + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
-              + " in Application.onCreate() and pass it the application context.");
-    }
-  },
-
-  TEXT_LINE__SCACHED(SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.text.TextLine", "sCached")
-          .reason("TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
-              + " at least two bugs that created memory leaks by not correctly clearing the"
-              + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
-              + " https://github.com/android/platform_frameworks_base/commit"
-              + "/893d6fe48d37f71e683f722457bea646994a10"
-              + " The second was fixed, not released yet:"
-              + " https://github.com/android/platform_frameworks_base/commit"
-              + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
-              + " To fix this, you could access TextLine.sCached and clear the pool every now"
-              + " and then (e.g. on activity destroy).");
-    }
-  },
-
-  BLOCKING_QUEUE(SDK_INT < LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason = "Prior to ART, a thread waiting on a blocking queue will leak the last"
-          + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
-          + " keeps a local reference to the last message it received. That message then gets"
-          + " recycled and can be used again. As long as all messages are recycled after being"
-          + "used, this won't be a problem, because these references are cleared when being"
-          + "recycled. However, dialogs create template Message instances to be copied when a"
-          + "message needs to be sent. These Message templates holds references to the dialog"
-          + "listeners, which most likely leads to holding a reference onto the activity in some"
-          + "way. Dialogs never recycle their template Message, assuming these Message instances"
-          + " will get GCed when the dialog is GCed."
-          + " The combination of these two things creates a high potential for memory leaks as soon"
-          + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
-          + " sleep for a long time."
-          + " To fix this, you could post empty messages to the idle handler threads from time to"
-          + " time. This won't be easy because you cannot access all handler threads, but a library"
-          + "that is widely used should consider doing this for its own handler threads.";
-      excluded.instanceField("android.os.Message", "obj").reason(reason);
-      excluded.instanceField("android.os.Message", "next").reason(reason);
-      excluded.instanceField("android.os.Message", "target").reason(reason);
-    }
-  },
-
-  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= M) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason = "When we detach a view that receives keyboard input, the InputMethodManager"
-          + " leaks a reference to it until a new view asks for keyboard input."
-          + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
-          + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414";
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView")
-          .reason(reason);
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView")
-          .reason(reason);
-      excluded.instanceField("android.view.inputmethod.InputMethodManager",
-          "mServedInputConnection").reason(reason);
-    }
-  },
-
-  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= M) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView")
-          .reason("The singleton InputMethodManager is holding a reference to mCurRootView long"
-              + " after the activity has been destroyed."
-              + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
-              + "#issuecomment-100579429"
-              + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414");
-    }
-  },
-
-  LAYOUT_TRANSITION(SDK_INT >= ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.animation.LayoutTransition$1", "val$parent")
-          .reason("LayoutTransition leaks parent ViewGroup through"
-              + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
-              + " window is destroyed. Tracked here:"
-              + " https://code.google.com/p/android/issues/detail?id=171830");
-    }
-  },
-
-  SPELL_CHECKER_SESSION(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0")
-          .reason("SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
-              + " SpellCheckerSession is closed before the service is connected."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542");
-    }
-  },
-
-  ACTIVITY_CHOOSE_MODEL(SDK_INT > ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason = "ActivityChooserModel holds a static reference to the last set"
-          + " ActivityChooserModelPolicy which can be an activity context."
-          + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
-          + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0";
-      excluded.instanceField("android.support.v7.internal.widget.ActivityChooserModel",
-          "mActivityChoserModelPolicy").reason(reason);
-      excluded.instanceField("android.widget.ActivityChooserModel", "mActivityChoserModelPolicy")
-          .reason(reason);
-    }
-  },
-
-  SPEECH_RECOGNIZER(SDK_INT < LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.speech.SpeechRecognizer$InternalListener", "this$0")
-          .reason("Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
-              + " class and leaked the SpeechRecognizer which leaked an activity context."
-              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
-              + " /b37866db469e81aca534ff6186bdafd44352329b");
-    }
-  },
-
-  ACCOUNT_MANAGER(SDK_INT > ECLAIR && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.accounts.AccountManager$AmsTask$Response", "this$1")
-          .reason("AccountManager$AmsTask$Response is a stub and is held in memory by native code,"
-              + " probably because the reference to the response in the other process hasn't been"
-              + " cleared."
-              + " AccountManager$AmsTask is holding on to the activity reference to use for"
-              + " launching a new sub- Activity."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
-              + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
-              + " with the returned future to to get the result and correctly start an activity"
-              + " when it's available.");
-    }
-  },
-
-  MEDIA_SCANNER_CONNECTION(SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.media.MediaScannerConnection", "mContext")
-          .reason("The static method MediaScannerConnection.scanFile() takes an activity context"
-              + " but the service might not disconnect after the activity has been destroyed."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
-              + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
-              + " application context. Call connect() and disconnect() manually.");
-    }
-  },
-
-  USER_MANAGER__SINSTANCE(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.os.UserManager", "mContext")
-          .reason("UserManager has a static sInstance field that creates an instance and caches it"
-              + " the first time UserManager.get() is called. This instance is created with the"
-              + " outer context (which is an activity base context)."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
-              + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
-              + "/27db46850b708070452c0ce49daf5f79503fbde6"
-              + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
-              + " UserManager instance gets cached with a reference to the application context.");
-    }
-  },
-
-  APP_WIDGET_HOST_CALLBACKS(SDK_INT < LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.appwidget.AppWidgetHost$Callbacks", "this$0")
-          .reason("android.appwidget.AppWidgetHost$Callbacks is a stub and is held in memory native"
-              + " code. The reference to the `mContext` was not being cleared, which caused the"
-              + " Callbacks instance to retain this reference"
-              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
-              + "/7a96f3c917e0001ee739b65da37b2fadec7d7765");
-    }
-  },
-
-  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER(MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      if (MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-        excluded.instanceField("android.app.admin.DevicePolicyManager$SettingsObserver", "this$0")
-            .reason("DevicePolicyManager keeps a reference to the context it has been created with"
-                + " instead of extracting the application context. In this Motorola build,"
-                + " DevicePolicyManager has an inner SettingsObserver class that is a content"
-                + " observer, which is held into memory by a binder transport object.");
-      }
-    }
-  },
-
-  SPEN_GESTURE_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext")
-          .reason("SpenGestureManager has a static mContext field that leaks a reference to the"
-              + " activity. Yes, a STATIC mContext field.");
-    }
-  },
-
-  CLIPBOARD_UI_MANAGER__SINSTANCE(
-      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.sec.clipboard.ClipboardUIManager", "mContext")
-          .reason("ClipboardUIManager is a static singleton that leaks an activity context."
-              + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
-              + " , so that the ClipboardUIManager instance gets cached with a reference to the"
-              + " application context. Example: https://gist.github.com/pepyakin"
-              + "/8d2221501fd572d4a61c");
-    }
-  },
-
-  BUBBLE_POPUP_HELPER__SHELPER(
-      LG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.widget.BubblePopupHelper", "sHelper")
-          .reason("A static helper for EditText bubble popups leaks a reference to the latest"
-              + "focused view.");
-    }
-  },
-
-  AW_RESOURCE__SRESOURCES(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // AwResource#setResources() is called with resources that hold a reference to the
-      // activity context (instead of the application context) and doesn't clear it.
-      // Not sure what's going on there, input welcome.
-      excluded.staticField("com.android.org.chromium.android_webview.AwResource", "sResources");
-    }
-  },
-
-  MAPPER_CLIENT(NVIDIA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient$ServiceClient", "this$0")
-          .reason("Not sure exactly what ControllerMapper is about, but there is an anonymous"
-              + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
-              + " ControllerMapper.MapperClient which leaks the activity context.");
-    }
-  },
-
-  TEXT_VIEW__MLAST_HOVERED_VIEW(
-      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.widget.TextView", "mLastHoveredView")
-          .reason("mLastHoveredView is a static field in TextView that leaks the last hovered"
-              + " view.");
-    }
-  },
-
-  PERSONA_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.os.PersonaManager", "mContext")
-          .reason("android.app.LoadedApk.mResources has a reference to"
-              + " android.content.res.Resources.mPersonaManager which has a reference to"
-              + " android.os.PersonaManager.mContext which is an activity.");
-    }
-  },
-
-  RESOURCES__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.content.res.Resources", "mContext")
-          .reason("In AOSP the Resources class does not have a context."
-              + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
-              + " instance that has a context that is the activity."
-              + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184");
-    }
-  },
-
-  VIEW_CONFIGURATION__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.view.ViewConfiguration", "mContext")
-          .reason("In AOSP the ViewConfiguration class does not have a context."
-              + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
-              + " ViewConfiguration instance that has a context that is the activity."
-              + " Observed here: https://github.com/square/leakcanary/issues"
-              + "/1#issuecomment-100324683");
-    }
-  },
-
-  AUDIO_MANAGER__MCONTEXT_STATIC(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.media.AudioManager", "mContext_static")
-          .reason("Samsung added a static mContext_static field to AudioManager, holds a reference"
-              + " to the activity."
-              + " Observed here: https://github.com/square/leakcanary/issues/32");
-    }
-  },
-
-  AUDIO_MANAGER(SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.media.AudioManager$1", "this$0")
-          .reason("Prior to Android M, VideoView required audio focus from AudioManager and"
-              + " never abandoned it, which leaks the Activity context through the AudioManager."
-              + " The root of the problem is that AudioManager uses whichever"
-              + " context it receives, which in the case of the VideoView example is an Activity,"
-              + " even though it only needs the application's context. The issue is fixed in"
-              + " Android M, and the AudioManager now uses the application's context."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
-              + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2");
-    }
-  },
-
-  EDITTEXT_BLINK_MESSAGEQUEUE {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.widget.Editor$Blink", "this$0")
-          .reason("The EditText Blink of the Cursor is implemented using a callback and Messages,"
-              + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
-              + " contains a blinking cursor is detached a message is posted with a delay after the"
-              + " dialog has been closed and as a result leaks the Activity."
-              + " This can be fixed manually by calling setCursorEnabled(false) in the dismiss()"
-              + " method of the dialog."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
-              + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
-              + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/");
-    }
-  },
-
-  SERVICE_BINDER {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // We should ignore leaks where an android.os.Binder is the root of the leak.
-      // When you bind and unbind from a Service, the OS will keep a reference to the Binder
-      // until the client binder has been GC'ed. This means the Binder can be retained after
-      // Service.onDestroy() is called.
-      excluded.rootClass("android.os.Binder").alwaysExclude();
-    }
-  },
-
-  SOFT_REFERENCES {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.clazz(WeakReference.class.getName()).alwaysExclude();
-      excluded.clazz(SoftReference.class.getName()).alwaysExclude();
-      excluded.clazz(PhantomReference.class.getName()).alwaysExclude();
-      excluded.clazz("java.lang.ref.Finalizer").alwaysExclude();
-      excluded.clazz("java.lang.ref.FinalizerReference").alwaysExclude();
-    }
-  },
-
-  FINALIZER_WATCHDOG_DAEMON {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
-      // reference to the object and it was about to be GCed.
-      excluded.thread("FinalizerWatchdogDaemon").alwaysExclude();
-    }
-  },
-
-  MAIN {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // The main thread stack is ever changing so local variables aren't likely to hold references
-      // for long. If this is on the shortest path, it's probably that there's a longer path with
-      // a real leak.
-      excluded.thread("main").alwaysExclude();
-    }
-  },
-
-  LEAK_CANARY_THREAD {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.thread(LEAK_CANARY_THREAD_NAME).alwaysExclude();
-    }
-  },
-
-  EVENT_RECEIVER__MMESSAGE_QUEUE {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
-      // the native peer of the receiver is using them.
-      // The main thread message queue is held on by the main Looper, but that might be a longer
-      // path. Let's not confuse people with a shorter path that is less meaningful.
-      excluded.instanceField("android.view.Choreographer$FrameDisplayEventReceiver",
-          "mMessageQueue").alwaysExclude();
-    }
-  };
-
-  /**
-   * This returns the references in the leak path that should be ignored by all on Android.
-   */
-  public static ExcludedRefs.Builder createAndroidDefaults() {
-    return createBuilder(
-        EnumSet.of(SOFT_REFERENCES, FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
-            EVENT_RECEIVER__MMESSAGE_QUEUE, SERVICE_BINDER));
-  }
-
-  /**
-   * This returns the references in the leak path that can be ignored for app developers. This
-   * doesn't mean there is no memory leak, to the contrary. However, some leaks are caused by bugs
-   * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
-   * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
-   */
-  public static ExcludedRefs.Builder createAppDefaults() {
-    return createBuilder(EnumSet.allOf(AndroidExcludedRefs.class));
-  }
-
-  public static ExcludedRefs.Builder createBuilder(EnumSet<AndroidExcludedRefs> refs) {
-    ExcludedRefs.Builder excluded = ExcludedRefs.builder();
-    for (AndroidExcludedRefs ref : refs) {
-      if (ref.applies) {
-        ref.add(excluded);
-        ((ExcludedRefs.BuilderWithParams) excluded).named(ref.name());
-      }
-    }
-    return excluded;
-  }
-
-  final boolean applies;
-
-  AndroidExcludedRefs() {
-    this(true);
-  }
-
-  AndroidExcludedRefs(boolean applies) {
-    this.applies = applies;
-  }
-
-  abstract void add(ExcludedRefs.Builder excluded);
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
deleted file mode 100644
index c46435f3..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.content.Context;
-import android.os.Debug;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.MessageQueue;
-import android.view.Gravity;
-import android.view.LayoutInflater;
-import android.widget.Toast;
-import com.squareup.leakcanary.internal.FutureResult;
-import com.squareup.leakcanary.internal.LeakCanaryInternals;
-import java.io.File;
-import java.io.IOException;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-
-public final class AndroidHeapDumper implements HeapDumper {
-
-  private static final String HEAPDUMP_FILE = "suspected_leak_heapdump.hprof";
-
-  final Context context;
-  final LeakDirectoryProvider leakDirectoryProvider;
-  private final Handler mainHandler;
-
-  public AndroidHeapDumper(Context context, LeakDirectoryProvider leakDirectoryProvider) {
-    this.leakDirectoryProvider = leakDirectoryProvider;
-    this.context = context.getApplicationContext();
-    mainHandler = new Handler(Looper.getMainLooper());
-  }
-
-  @Override public File dumpHeap() {
-    if (!leakDirectoryProvider.isLeakStorageWritable()) {
-      CanaryLog.d("Could not write to leak storage to dump heap.");
-      leakDirectoryProvider.requestWritePermissionNotification();
-      return NO_DUMP;
-    }
-    File heapDumpFile = getHeapDumpFile();
-    // Atomic way to check for existence & create the file if it doesn't exist.
-    // Prevents several processes in the same app to attempt a heapdump at the same time.
-    boolean fileCreated;
-    try {
-      fileCreated = heapDumpFile.createNewFile();
-    } catch (IOException e) {
-      cleanup();
-      CanaryLog.d(e, "Could not check if heap dump file exists");
-      return NO_DUMP;
-    }
-
-    if (!fileCreated) {
-      CanaryLog.d("Could not dump heap, previous analysis still is in progress.");
-      // Heap analysis in progress, let's not put too much pressure on the device.
-      return NO_DUMP;
-    }
-
-    FutureResult<Toast> waitingForToast = new FutureResult<>();
-    showToast(waitingForToast);
-
-    if (!waitingForToast.wait(5, SECONDS)) {
-      CanaryLog.d("Did not dump heap, too much time waiting for Toast.");
-      return NO_DUMP;
-    }
-
-    Toast toast = waitingForToast.get();
-    try {
-      Debug.dumpHprofData(heapDumpFile.getAbsolutePath());
-      cancelToast(toast);
-      return heapDumpFile;
-    } catch (Exception e) {
-      cleanup();
-      CanaryLog.d(e, "Could not perform heap dump");
-      // Abort heap dump
-      return NO_DUMP;
-    }
-  }
-
-  /**
-   * Call this on app startup to clean up all heap dump files that had not been handled yet when
-   * the app process was killed.
-   */
-  public void cleanup() {
-    LeakCanaryInternals.executeOnFileIoThread(new Runnable() {
-      @Override public void run() {
-        if (!leakDirectoryProvider.isLeakStorageWritable()) {
-          CanaryLog.d("Could not attempt cleanup, leak storage not writable.");
-          return;
-        }
-        File heapDumpFile = getHeapDumpFile();
-        if (heapDumpFile.exists()) {
-          CanaryLog.d("Previous analysis did not complete correctly, cleaning: %s", heapDumpFile);
-          boolean success = heapDumpFile.delete();
-          if (!success) {
-            CanaryLog.d("Could not delete file %s", heapDumpFile.getPath());
-          }
-        }
-      }
-    });
-  }
-
-  File getHeapDumpFile() {
-    return new File(leakDirectoryProvider.leakDirectory(), HEAPDUMP_FILE);
-  }
-
-  private void showToast(final FutureResult<Toast> waitingForToast) {
-    mainHandler.post(new Runnable() {
-      @Override public void run() {
-        final Toast toast = new Toast(context);
-        toast.setGravity(Gravity.CENTER_VERTICAL, 0, 0);
-        toast.setDuration(Toast.LENGTH_LONG);
-        LayoutInflater inflater = LayoutInflater.from(context);
-        toast.setView(inflater.inflate(R.layout.leak_canary_heap_dump_toast, null));
-        toast.show();
-        // Waiting for Idle to make sure Toast gets rendered.
-        Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
-          @Override public boolean queueIdle() {
-            waitingForToast.set(toast);
-            return false;
-          }
-        });
-      }
-    });
-  }
-
-  private void cancelToast(final Toast toast) {
-    mainHandler.post(new Runnable() {
-      @Override public void run() {
-        toast.cancel();
-      }
-    });
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
deleted file mode 100644
index 8f8eff4b..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.MessageQueue;
-import java.util.concurrent.Executor;
-
-/**
- * {@link Executor} suitable for watching Android reference leaks. This executor waits for the main
- * thread to be idle then posts to a serial background thread with a delay of
- * {@link R.integer#leak_canary_watch_delay_millis} seconds.
- */
-public final class AndroidWatchExecutor implements Executor {
-
-  static final String LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump";
-  private final Handler mainHandler;
-  final Handler backgroundHandler;
-  final long delayMillis;
-
-  public AndroidWatchExecutor(int delayMillis) {
-    mainHandler = new Handler(Looper.getMainLooper());
-    HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);
-    handlerThread.start();
-    backgroundHandler = new Handler(handlerThread.getLooper());
-    this.delayMillis = delayMillis;
-  }
-
-  @Override public void execute(final Runnable command) {
-    if (isOnMainThread()) {
-      executeDelayedAfterIdleUnsafe(command);
-    } else {
-      mainHandler.post(new Runnable() {
-        @Override public void run() {
-          executeDelayedAfterIdleUnsafe(command);
-        }
-      });
-    }
-  }
-
-  private boolean isOnMainThread() {
-    return Looper.getMainLooper().getThread() == Thread.currentThread();
-  }
-
-  void executeDelayedAfterIdleUnsafe(final Runnable runnable) {
-    // This needs to be called from the main thread.
-    Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
-      @Override public boolean queueIdle() {
-        backgroundHandler.postDelayed(runnable, delayMillis);
-        return false;
-      }
-    });
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
deleted file mode 100644
index b4e288db..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package com.squareup.leakcanary;
-
-import android.util.Log;
-
-public final class CanaryLog {
-
-  private static volatile Logger logger = new DefaultLogger();
-
-  public interface Logger {
-    void d(String message, Object... args);
-
-    void d(Throwable throwable, String message, Object... args);
-  }
-
-  private static class DefaultLogger implements Logger {
-    DefaultLogger() { }
-
-    @Override public void d(String message, Object... args) {
-      String formatted = String.format(message, args);
-      if (formatted.length() < 4000) {
-        Log.d("LeakCanary", formatted);
-      } else {
-        String[] lines = formatted.split("\n");
-        for (String line : lines) {
-          Log.d("LeakCanary", line);
-        }
-      }
-    }
-
-    @Override public void d(Throwable throwable, String message, Object... args) {
-      d(String.format(message, args) + '\n' + Log.getStackTraceString(throwable));
-    }
-  }
-
-  public static void setLogger(Logger logger) {
-    CanaryLog.logger = logger;
-  }
-
-  public static void d(String message, Object... args) {
-    // Local variable to prevent the ref from becoming null after the null check.
-    Logger logger = CanaryLog.logger;
-    if (logger == null) {
-      return;
-    }
-    logger.d(message, args);
-  }
-
-  public static void d(Throwable throwable, String message, Object... args) {
-    // Local variable to prevent the ref from becoming null after the null check.
-    Logger logger = CanaryLog.logger;
-    if (logger == null) {
-      return;
-    }
-    logger.d(throwable, message, args);
-  }
-
-  private CanaryLog() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
deleted file mode 100644
index 812b6e64..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.PendingIntent;
-import android.content.Context;
-import android.os.Environment;
-import com.squareup.leakcanary.internal.RequestStoragePermissionActivity;
-import java.io.File;
-
-import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
-import static android.content.pm.PackageManager.PERMISSION_GRANTED;
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.M;
-import static android.os.Environment.DIRECTORY_DOWNLOADS;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.showNotification;
-
-public final class DefaultLeakDirectoryProvider implements LeakDirectoryProvider {
-
-  private final Context context;
-
-  public DefaultLeakDirectoryProvider(Context context) {
-    this.context = context.getApplicationContext();
-  }
-
-  @Override public File leakDirectory() {
-    File downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS);
-    File directory = new File(downloadsDirectory, "leakcanary-" + context.getPackageName());
-    boolean success = directory.mkdirs();
-    if (!success && !directory.exists()) {
-      throw new UnsupportedOperationException(
-          "Could not create leak directory " + directory.getPath());
-    }
-    return directory;
-  }
-
-  @Override public void requestWritePermissionNotification() {
-    if (hasStoragePermission()) {
-      return;
-    }
-    PendingIntent pendingIntent = RequestStoragePermissionActivity.createPendingIntent(context);
-    String contentTitle = context.getString(R.string.leak_canary_permission_notification_title);
-    CharSequence packageName = context.getPackageName();
-    String contentText =
-        context.getString(R.string.leak_canary_permission_notification_text, packageName);
-    showNotification(context, contentTitle, contentText, pendingIntent);
-  }
-
-  @TargetApi(M) @Override public void requestPermission(Activity activity) {
-    if (hasStoragePermission()) {
-      return;
-    }
-    String[] permissions = {
-        WRITE_EXTERNAL_STORAGE
-    };
-    activity.requestPermissions(permissions, 42);
-  }
-
-  @Override public boolean isLeakStorageWritable() {
-    if (!hasStoragePermission()) {
-      return false;
-    }
-    String state = Environment.getExternalStorageState();
-    return Environment.MEDIA_MOUNTED.equals(state);
-  }
-
-  @TargetApi(M) private boolean hasStoragePermission() {
-    if (SDK_INT < M) {
-      return true;
-    }
-    return context.checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED;
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
deleted file mode 100644
index afdc4e94..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.app.PendingIntent;
-import android.content.res.Resources;
-import com.squareup.leakcanary.internal.DisplayLeakActivity;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.FilenameFilter;
-import java.io.IOException;
-import java.io.ObjectOutputStream;
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Comparator;
-import java.util.Date;
-import java.util.Locale;
-
-import static android.text.format.Formatter.formatShortFileSize;
-import static com.squareup.leakcanary.LeakCanary.leakInfo;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.classSimpleName;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.showNotification;
-
-/**
- * Logs leak analysis results, and then shows a notification which will start {@link
- * DisplayLeakActivity}.
- *
- * You can extend this class and override {@link #afterDefaultHandling(HeapDump, AnalysisResult,
- * String)} to add custom behavior, e.g. uploading the heap dump.
- */
-public class DisplayLeakService extends AbstractAnalysisResultService {
-
-  @Override protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
-    String leakInfo = leakInfo(this, heapDump, result, true);
-    CanaryLog.d(leakInfo);
-
-    boolean resultSaved = false;
-    boolean shouldSaveResult = result.leakFound || result.failure != null;
-    if (shouldSaveResult) {
-      heapDump = renameHeapdump(heapDump);
-      resultSaved = saveResult(heapDump, result);
-    }
-
-    PendingIntent pendingIntent;
-    String contentTitle;
-    String contentText;
-
-    if (!shouldSaveResult) {
-      contentTitle = getString(R.string.leak_canary_no_leak_title);
-      contentText = getString(R.string.leak_canary_no_leak_text);
-      pendingIntent = null;
-    } else if (resultSaved) {
-      pendingIntent = DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);
-
-      if (result.failure == null) {
-        String size = formatShortFileSize(this, result.retainedHeapSize);
-        String className = classSimpleName(result.className);
-        if (result.excludedLeak) {
-          contentTitle = getString(R.string.leak_canary_leak_excluded, className, size);
-        } else {
-          contentTitle = getString(R.string.leak_canary_class_has_leaked, className, size);
-        }
-      } else {
-        contentTitle = getString(R.string.leak_canary_analysis_failed);
-      }
-      contentText = getString(R.string.leak_canary_notification_message);
-    } else {
-      contentTitle = getString(R.string.leak_canary_could_not_save_title);
-      contentText = getString(R.string.leak_canary_could_not_save_text);
-      pendingIntent = null;
-    }
-    showNotification(this, contentTitle, contentText, pendingIntent);
-    afterDefaultHandling(heapDump, result, leakInfo);
-  }
-
-  private boolean saveResult(HeapDump heapDump, AnalysisResult result) {
-    File resultFile = new File(heapDump.heapDumpFile.getParentFile(),
-        heapDump.heapDumpFile.getName() + ".result");
-    FileOutputStream fos = null;
-    try {
-      fos = new FileOutputStream(resultFile);
-      ObjectOutputStream oos = new ObjectOutputStream(fos);
-      oos.writeObject(heapDump);
-      oos.writeObject(result);
-      return true;
-    } catch (IOException e) {
-      CanaryLog.d(e, "Could not save leak analysis result to disk.");
-    } finally {
-      if (fos != null) {
-        try {
-          fos.close();
-        } catch (IOException ignored) {
-        }
-      }
-    }
-    return false;
-  }
-
-  private HeapDump renameHeapdump(HeapDump heapDump) {
-    String fileName =
-        new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'.hprof'", Locale.US).format(new Date());
-
-    File newFile = new File(heapDump.heapDumpFile.getParent(), fileName);
-    boolean renamed = heapDump.heapDumpFile.renameTo(newFile);
-    if (!renamed) {
-      CanaryLog.d("Could not rename heap dump file %s to %s", heapDump.heapDumpFile.getPath(),
-          newFile.getPath());
-    }
-    heapDump =
-        new HeapDump(newFile, heapDump.referenceKey, heapDump.referenceName, heapDump.excludedRefs,
-            heapDump.watchDurationMs, heapDump.gcDurationMs, heapDump.heapDumpDurationMs);
-
-    Resources resources = getResources();
-    int maxStoredHeapDumps =
-        Math.max(resources.getInteger(R.integer.leak_canary_max_stored_leaks), 1);
-    File[] hprofFiles = heapDump.heapDumpFile.getParentFile().listFiles(new FilenameFilter() {
-      @Override public boolean accept(File dir, String filename) {
-        return filename.endsWith(".hprof");
-      }
-    });
-
-    if (hprofFiles.length > maxStoredHeapDumps) {
-      // Sort with oldest modified first.
-      Arrays.sort(hprofFiles, new Comparator<File>() {
-        @Override public int compare(File lhs, File rhs) {
-          return Long.valueOf(lhs.lastModified()).compareTo(rhs.lastModified());
-        }
-      });
-      boolean deleted = hprofFiles[0].delete();
-      if (!deleted) {
-        CanaryLog.d("Could not delete old hprof file %s", hprofFiles[0].getPath());
-      }
-    }
-    return heapDump;
-  }
-
-  /**
-   * You can override this method and do a blocking call to a server to upload the leak trace and
-   * the heap dump. Don't forget to check {@link AnalysisResult#leakFound} and {@link
-   * AnalysisResult#excludedLeak} first.
-   */
-  protected void afterDefaultHandling(HeapDump heapDump, AnalysisResult result, String leakInfo) {
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
deleted file mode 100644
index 1081ae34..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.app.Application;
-import android.content.Context;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.res.Resources;
-import android.os.Build;
-import android.util.Log;
-import com.squareup.leakcanary.internal.DisplayLeakActivity;
-import com.squareup.leakcanary.internal.HeapAnalyzerService;
-
-import static android.text.format.Formatter.formatShortFileSize;
-import static com.squareup.leakcanary.BuildConfig.GIT_SHA;
-import static com.squareup.leakcanary.BuildConfig.LIBRARY_VERSION;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.isInServiceProcess;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabled;
-
-public final class LeakCanary {
-
-  /**
-   * Creates a {@link RefWatcher} that works out of the box, and starts watching activity
-   * references (on ICS+).
-   */
-  public static RefWatcher install(Application application) {
-    return install(application, DisplayLeakService.class,
-        AndroidExcludedRefs.createAppDefaults().build());
-  }
-
-  /**
-   * Creates a {@link RefWatcher} that reports results to the provided service, and starts watching
-   * activity references (on ICS+).
-   */
-  public static RefWatcher install(Application application,
-      Class<? extends AbstractAnalysisResultService> listenerServiceClass,
-      ExcludedRefs excludedRefs) {
-    if (isInAnalyzerProcess(application)) {
-      return RefWatcher.DISABLED;
-    }
-    enableDisplayLeakActivity(application);
-    HeapDump.Listener heapDumpListener =
-        new ServiceHeapDumpListener(application, listenerServiceClass);
-    RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);
-    ActivityRefWatcher.installOnIcsPlus(application, refWatcher);
-    return refWatcher;
-  }
-
-  /**
-   * Creates a {@link RefWatcher} with a default configuration suitable for Android.
-   */
-  public static RefWatcher androidWatcher(Context context, HeapDump.Listener heapDumpListener,
-      ExcludedRefs excludedRefs) {
-    LeakDirectoryProvider leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
-    DebuggerControl debuggerControl = new AndroidDebuggerControl();
-    AndroidHeapDumper heapDumper = new AndroidHeapDumper(context, leakDirectoryProvider);
-    heapDumper.cleanup();
-    Resources resources = context.getResources();
-    int watchDelayMillis = resources.getInteger(R.integer.leak_canary_watch_delay_millis);
-    AndroidWatchExecutor executor = new AndroidWatchExecutor(watchDelayMillis);
-    return new RefWatcher(executor, debuggerControl, GcTrigger.DEFAULT, heapDumper,
-        heapDumpListener, excludedRefs);
-  }
-
-  public static void enableDisplayLeakActivity(Context context) {
-    setEnabled(context, DisplayLeakActivity.class, true);
-  }
-
-  public static void setDisplayLeakActivityDirectoryProvider(
-      LeakDirectoryProvider leakDirectoryProvider) {
-    DisplayLeakActivity.setLeakDirectoryProvider(leakDirectoryProvider);
-  }
-
-  /** Returns a string representation of the result of a heap analysis. */
-  public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult result,
-      boolean detailed) {
-    PackageManager packageManager = context.getPackageManager();
-    String packageName = context.getPackageName();
-    PackageInfo packageInfo;
-    try {
-      packageInfo = packageManager.getPackageInfo(packageName, 0);
-    } catch (PackageManager.NameNotFoundException e) {
-      throw new RuntimeException(e);
-    }
-    String versionName = packageInfo.versionName;
-    int versionCode = packageInfo.versionCode;
-    String info = "In " + packageName + ":" + versionName + ":" + versionCode + ".\n";
-    String detailedString = "";
-    if (result.leakFound) {
-      if (result.excludedLeak) {
-        info += "* EXCLUDED LEAK.\n";
-      }
-      info += "* " + result.className;
-      if (!heapDump.referenceName.equals("")) {
-        info += " (" + heapDump.referenceName + ")";
-      }
-      info += " has leaked:\n" + result.leakTrace.toString() + "\n";
-      info += "* Retaining: " + formatShortFileSize(context, result.retainedHeapSize) + ".\n";
-      if (detailed) {
-        detailedString = "\n* Details:\n" + result.leakTrace.toDetailedString();
-      }
-    } else if (result.failure != null) {
-      // We duplicate the library version & Sha information because bug reports often only contain
-      // the stacktrace.
-      info += "* FAILURE in " + LIBRARY_VERSION + " " + GIT_SHA + ":" + Log.getStackTraceString(
-          result.failure) + "\n";
-    } else {
-      info += "* NO LEAK FOUND.\n\n";
-    }
-    if (detailed) {
-      detailedString += "* Excluded Refs:\n" + heapDump.excludedRefs;
-    }
-
-    info += "* Reference Key: "
-        + heapDump.referenceKey
-        + "\n"
-        + "* Device: "
-        + Build.MANUFACTURER
-        + " "
-        + Build.BRAND
-        + " "
-        + Build.MODEL
-        + " "
-        + Build.PRODUCT
-        + "\n"
-        + "* Android Version: "
-        + Build.VERSION.RELEASE
-        + " API: "
-        + Build.VERSION.SDK_INT
-        + " LeakCanary: "
-        + LIBRARY_VERSION
-        + " "
-        + GIT_SHA
-        + "\n"
-        + "* Durations: watch="
-        + heapDump.watchDurationMs
-        + "ms, gc="
-        + heapDump.gcDurationMs
-        + "ms, heap dump="
-        + heapDump.heapDumpDurationMs
-        + "ms, analysis="
-        + result.analysisDurationMs
-        + "ms"
-        + "\n"
-        + detailedString;
-
-    return info;
-  }
-
-  /**
-   * Whether the current process is the process running the {@link HeapAnalyzerService}, which is
-   * a different process than the normal app process.
-   */
-  public static boolean isInAnalyzerProcess(Context context) {
-    return isInServiceProcess(context, HeapAnalyzerService.class);
-  }
-
-  private LeakCanary() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
deleted file mode 100644
index 1e7ebf87..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.app.Activity;
-import java.io.File;
-
-/**
- * Provides the directory in which heap dumps and analysis results will be stored.
- * When using your own implementation, you may also want to call {@link
- * LeakCanary#setDisplayLeakActivityDirectoryProvider(LeakDirectoryProvider)}.
- */
-public interface LeakDirectoryProvider {
-
-  /** Returns a path to an existing directory were leaks can be stored. */
-  File leakDirectory();
-
-  void requestWritePermissionNotification();
-
-  void requestPermission(Activity activity);
-
-  /** True if we can currently write to the leak directory. */
-  boolean isLeakStorageWritable();
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
deleted file mode 100644
index 2ccb1422..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.content.Context;
-import com.squareup.leakcanary.internal.HeapAnalyzerService;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabled;
-
-public final class ServiceHeapDumpListener implements HeapDump.Listener {
-
-  private final Context context;
-  private final Class<? extends AbstractAnalysisResultService> listenerServiceClass;
-
-  public ServiceHeapDumpListener(Context context,
-      Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
-    setEnabled(context, listenerServiceClass, true);
-    setEnabled(context, HeapAnalyzerService.class, true);
-    this.listenerServiceClass = checkNotNull(listenerServiceClass, "listenerServiceClass");
-    this.context = checkNotNull(context, "context").getApplicationContext();
-  }
-
-  @Override public void analyze(HeapDump heapDump) {
-    checkNotNull(heapDump, "heapDump");
-    HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass);
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
deleted file mode 100644
index 4ab1baf2..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
+++ /dev/null
@@ -1,522 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.PendingIntent;
-import android.content.Context;
-import android.content.Intent;
-import android.net.Uri;
-import android.os.Build;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Looper;
-import android.text.format.DateUtils;
-import android.util.Log;
-import android.view.LayoutInflater;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.AdapterView;
-import android.widget.BaseAdapter;
-import android.widget.Button;
-import android.widget.ListAdapter;
-import android.widget.ListView;
-import android.widget.TextView;
-import com.squareup.leakcanary.AnalysisResult;
-import com.squareup.leakcanary.CanaryLog;
-import com.squareup.leakcanary.DefaultLeakDirectoryProvider;
-import com.squareup.leakcanary.HeapDump;
-import com.squareup.leakcanary.LeakDirectoryProvider;
-import com.squareup.leakcanary.R;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FilenameFilter;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-import java.util.concurrent.Executor;
-
-import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
-import static android.text.format.DateUtils.FORMAT_SHOW_DATE;
-import static android.text.format.DateUtils.FORMAT_SHOW_TIME;
-import static android.text.format.Formatter.formatShortFileSize;
-import static android.view.View.GONE;
-import static android.view.View.VISIBLE;
-import static com.squareup.leakcanary.BuildConfig.GIT_SHA;
-import static com.squareup.leakcanary.BuildConfig.LIBRARY_VERSION;
-import static com.squareup.leakcanary.LeakCanary.leakInfo;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.newSingleThreadExecutor;
-
-@SuppressWarnings("ConstantConditions") @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-public final class DisplayLeakActivity extends Activity {
-
-  private static LeakDirectoryProvider leakDirectoryProvider = null;
-
-  private static final String SHOW_LEAK_EXTRA = "show_latest";
-
-  public static PendingIntent createPendingIntent(Context context) {
-    return createPendingIntent(context, null);
-  }
-
-  public static PendingIntent createPendingIntent(Context context, String referenceKey) {
-    Intent intent = new Intent(context, DisplayLeakActivity.class);
-    intent.putExtra(SHOW_LEAK_EXTRA, referenceKey);
-    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
-    return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);
-  }
-
-  public static void setLeakDirectoryProvider(LeakDirectoryProvider leakDirectoryProvider) {
-    DisplayLeakActivity.leakDirectoryProvider = leakDirectoryProvider;
-  }
-
-  private static LeakDirectoryProvider leakDirectoryProvider(Context context) {
-    LeakDirectoryProvider leakDirectoryProvider = DisplayLeakActivity.leakDirectoryProvider;
-    if (leakDirectoryProvider == null) {
-      leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
-    }
-    return leakDirectoryProvider;
-  }
-
-  // null until it's been first loaded.
-  List<Leak> leaks;
-  String visibleLeakRefKey;
-
-  private ListView listView;
-  private TextView failureView;
-  private Button actionButton;
-
-  @Override protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-
-    if (savedInstanceState != null) {
-      visibleLeakRefKey = savedInstanceState.getString("visibleLeakRefKey");
-    } else {
-      Intent intent = getIntent();
-      if (intent.hasExtra(SHOW_LEAK_EXTRA)) {
-        visibleLeakRefKey = intent.getStringExtra(SHOW_LEAK_EXTRA);
-      }
-    }
-
-    //noinspection unchecked
-    leaks = (List<Leak>) getLastNonConfigurationInstance();
-
-    setContentView(R.layout.leak_canary_display_leak);
-
-    listView = (ListView) findViewById(R.id.leak_canary_display_leak_list);
-    failureView = (TextView) findViewById(R.id.leak_canary_display_leak_failure);
-    actionButton = (Button) findViewById(R.id.leak_canary_action);
-
-    updateUi();
-  }
-
-  // No, it's not deprecated. Android lies.
-  @Override public Object onRetainNonConfigurationInstance() {
-    return leaks;
-  }
-
-  @Override protected void onSaveInstanceState(Bundle outState) {
-    super.onSaveInstanceState(outState);
-    outState.putString("visibleLeakRefKey", visibleLeakRefKey);
-  }
-
-  @Override protected void onResume() {
-    super.onResume();
-    LeakDirectoryProvider leakDirectoryProvider = leakDirectoryProvider(this);
-    if (leakDirectoryProvider.isLeakStorageWritable()) {
-      File leakDirectory = leakDirectoryProvider.leakDirectory();
-      LoadLeaks.load(this, leakDirectory);
-    } else {
-      leakDirectoryProvider.requestPermission(this);
-    }
-  }
-
-  @Override public void setTheme(int resid) {
-    // We don't want this to be called with an incompatible theme.
-    // This could happen if you implement runtime switching of themes
-    // using ActivityLifecycleCallbacks.
-    if (resid != R.style.leak_canary_LeakCanary_Base) {
-      return;
-    }
-    super.setTheme(resid);
-  }
-
-  @Override protected void onDestroy() {
-    super.onDestroy();
-    LoadLeaks.forgetActivity();
-  }
-
-  @Override public boolean onCreateOptionsMenu(Menu menu) {
-    Leak visibleLeak = getVisibleLeak();
-    if (visibleLeak != null) {
-      menu.add(R.string.leak_canary_share_leak)
-          .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
-            @Override public boolean onMenuItemClick(MenuItem item) {
-              shareLeak();
-              return true;
-            }
-          });
-      if (visibleLeak.heapDump.heapDumpFile.exists()) {
-        menu.add(R.string.leak_canary_share_heap_dump)
-            .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
-              @Override public boolean onMenuItemClick(MenuItem item) {
-                shareHeapDump();
-                return true;
-              }
-            });
-      }
-      return true;
-    }
-    return false;
-  }
-
-  @Override public boolean onOptionsItemSelected(MenuItem item) {
-    if (item.getItemId() == android.R.id.home) {
-      visibleLeakRefKey = null;
-      updateUi();
-    }
-    return true;
-  }
-
-  @Override public void onBackPressed() {
-    if (visibleLeakRefKey != null) {
-      visibleLeakRefKey = null;
-      updateUi();
-    } else {
-      super.onBackPressed();
-    }
-  }
-
-  void shareLeak() {
-    Leak visibleLeak = getVisibleLeak();
-    String leakInfo = leakInfo(this, visibleLeak.heapDump, visibleLeak.result, true);
-    Intent intent = new Intent(Intent.ACTION_SEND);
-    intent.setType("text/plain");
-    intent.putExtra(Intent.EXTRA_TEXT, leakInfo);
-    startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
-  }
-
-  void shareHeapDump() {
-    Leak visibleLeak = getVisibleLeak();
-    File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
-    heapDumpFile.setReadable(true, false);
-    Intent intent = new Intent(Intent.ACTION_SEND);
-    intent.setType("application/octet-stream");
-    intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(heapDumpFile));
-    startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
-  }
-
-  void deleteVisibleLeak() {
-    Leak visibleLeak = getVisibleLeak();
-    File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
-    File resultFile = visibleLeak.resultFile;
-    boolean resultDeleted = resultFile.delete();
-    if (!resultDeleted) {
-      CanaryLog.d("Could not delete result file %s", resultFile.getPath());
-    }
-    boolean heapDumpDeleted = heapDumpFile.delete();
-    if (!heapDumpDeleted) {
-      CanaryLog.d("Could not delete heap dump file %s", heapDumpFile.getPath());
-    }
-    visibleLeakRefKey = null;
-    leaks.remove(visibleLeak);
-    updateUi();
-  }
-
-  void deleteAllLeaks() {
-    File leakDirectory = leakDirectoryProvider(DisplayLeakActivity.this).leakDirectory();
-    File[] files = leakDirectory.listFiles();
-    if (files != null) {
-      for (File file : files) {
-        boolean deleted = file.delete();
-        if (!deleted) {
-          CanaryLog.d("Could not delete file %s", file.getPath());
-        }
-      }
-    }
-    leaks = Collections.emptyList();
-    updateUi();
-  }
-
-  void updateUi() {
-    if (leaks == null) {
-      setTitle("Loading leaks...");
-      return;
-    }
-    if (leaks.isEmpty()) {
-      visibleLeakRefKey = null;
-    }
-
-    final Leak visibleLeak = getVisibleLeak();
-    if (visibleLeak == null) {
-      visibleLeakRefKey = null;
-    }
-
-    ListAdapter listAdapter = listView.getAdapter();
-    // Reset to defaults
-    listView.setVisibility(VISIBLE);
-    failureView.setVisibility(GONE);
-
-    if (visibleLeak != null) {
-      AnalysisResult result = visibleLeak.result;
-      if (result.failure != null) {
-        listView.setVisibility(GONE);
-        failureView.setVisibility(VISIBLE);
-        String failureMessage = getString(R.string.leak_canary_failure_report)
-            + LIBRARY_VERSION
-            + " "
-            + GIT_SHA
-            + "\n"
-            + Log.getStackTraceString(result.failure);
-        failureView.setText(failureMessage);
-        setTitle(R.string.leak_canary_analysis_failed);
-        invalidateOptionsMenu();
-        getActionBar().setDisplayHomeAsUpEnabled(true);
-        actionButton.setVisibility(VISIBLE);
-        actionButton.setText(R.string.leak_canary_delete);
-        actionButton.setOnClickListener(new View.OnClickListener() {
-          @Override public void onClick(View v) {
-            deleteVisibleLeak();
-          }
-        });
-        listView.setAdapter(null);
-      } else {
-        final DisplayLeakAdapter adapter;
-        if (listAdapter instanceof DisplayLeakAdapter) {
-          adapter = (DisplayLeakAdapter) listAdapter;
-        } else {
-          adapter = new DisplayLeakAdapter();
-          listView.setAdapter(adapter);
-          listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-            @Override
-            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-              adapter.toggleRow(position);
-            }
-          });
-          invalidateOptionsMenu();
-          getActionBar().setDisplayHomeAsUpEnabled(true);
-          actionButton.setVisibility(VISIBLE);
-          actionButton.setText(R.string.leak_canary_delete);
-          actionButton.setOnClickListener(new View.OnClickListener() {
-            @Override public void onClick(View v) {
-              deleteVisibleLeak();
-            }
-          });
-        }
-        HeapDump heapDump = visibleLeak.heapDump;
-        adapter.update(result.leakTrace, heapDump.referenceKey, heapDump.referenceName);
-        String size = formatShortFileSize(this, result.retainedHeapSize);
-        String className = classSimpleName(result.className);
-        setTitle(getString(R.string.leak_canary_class_has_leaked, className, size));
-      }
-    } else {
-      if (listAdapter instanceof LeakListAdapter) {
-        ((LeakListAdapter) listAdapter).notifyDataSetChanged();
-      } else {
-        LeakListAdapter adapter = new LeakListAdapter();
-        listView.setAdapter(adapter);
-        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-          @Override
-          public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-            visibleLeakRefKey = leaks.get(position).heapDump.referenceKey;
-            updateUi();
-          }
-        });
-        invalidateOptionsMenu();
-        setTitle(getString(R.string.leak_canary_leak_list_title, getPackageName()));
-        getActionBar().setDisplayHomeAsUpEnabled(false);
-        actionButton.setText(R.string.leak_canary_delete_all);
-        actionButton.setOnClickListener(new View.OnClickListener() {
-          @Override public void onClick(View v) {
-            deleteAllLeaks();
-          }
-        });
-      }
-      actionButton.setVisibility(leaks.size() == 0 ? GONE : VISIBLE);
-    }
-  }
-
-  Leak getVisibleLeak() {
-    if (leaks == null) {
-      return null;
-    }
-    for (Leak leak : leaks) {
-      if (leak.heapDump.referenceKey.equals(visibleLeakRefKey)) {
-        return leak;
-      }
-    }
-    return null;
-  }
-
-  class LeakListAdapter extends BaseAdapter {
-
-    @Override public int getCount() {
-      return leaks.size();
-    }
-
-    @Override public Leak getItem(int position) {
-      return leaks.get(position);
-    }
-
-    @Override public long getItemId(int position) {
-      return position;
-    }
-
-    @Override public View getView(int position, View convertView, ViewGroup parent) {
-      if (convertView == null) {
-        convertView = LayoutInflater.from(DisplayLeakActivity.this)
-            .inflate(R.layout.leak_canary_leak_row, parent, false);
-      }
-      TextView titleView = (TextView) convertView.findViewById(R.id.leak_canary_row_text);
-      TextView timeView = (TextView) convertView.findViewById(R.id.leak_canary_row_time);
-      Leak leak = getItem(position);
-
-      String index = (leaks.size() - position) + ". ";
-
-      String title;
-      if (leak.result.failure == null) {
-        String className = classSimpleName(leak.result.className);
-        String size = formatShortFileSize(DisplayLeakActivity.this, leak.result.retainedHeapSize);
-        title = getString(R.string.leak_canary_class_has_leaked, className, size);
-        if (leak.result.excludedLeak) {
-          title = getString(R.string.leak_canary_excluded_row, title);
-        }
-        title = index + title;
-      } else {
-        title = index
-            + leak.result.failure.getClass().getSimpleName()
-            + " "
-            + leak.result.failure.getMessage();
-      }
-      titleView.setText(title);
-      String time =
-          DateUtils.formatDateTime(DisplayLeakActivity.this, leak.resultFile.lastModified(),
-              FORMAT_SHOW_TIME | FORMAT_SHOW_DATE);
-      timeView.setText(time);
-      return convertView;
-    }
-  }
-
-  static class Leak {
-    final HeapDump heapDump;
-    final AnalysisResult result;
-    final File resultFile;
-
-    Leak(HeapDump heapDump, AnalysisResult result, File resultFile) {
-      this.heapDump = heapDump;
-      this.result = result;
-      this.resultFile = resultFile;
-    }
-  }
-
-  static class LoadLeaks implements Runnable {
-
-    static final List<LoadLeaks> inFlight = new ArrayList<>();
-
-    static final Executor backgroundExecutor = newSingleThreadExecutor("LoadLeaks");
-
-    static void load(DisplayLeakActivity activity, File leakDirectory) {
-      LoadLeaks loadLeaks = new LoadLeaks(activity, leakDirectory);
-      inFlight.add(loadLeaks);
-      backgroundExecutor.execute(loadLeaks);
-    }
-
-    static void forgetActivity() {
-      for (LoadLeaks loadLeaks : inFlight) {
-        loadLeaks.activityOrNull = null;
-      }
-      inFlight.clear();
-    }
-
-    DisplayLeakActivity activityOrNull;
-    private final File leakDirectory;
-    private final Handler mainHandler;
-
-    LoadLeaks(DisplayLeakActivity activity, File leakDirectory) {
-      this.activityOrNull = activity;
-      this.leakDirectory = leakDirectory;
-      mainHandler = new Handler(Looper.getMainLooper());
-    }
-
-    @Override public void run() {
-      final List<Leak> leaks = new ArrayList<>();
-      File[] files = leakDirectory.listFiles(new FilenameFilter() {
-        @Override public boolean accept(File dir, String filename) {
-          return filename.endsWith(".result");
-        }
-      });
-
-      if (files != null) {
-        for (File resultFile : files) {
-          FileInputStream fis = null;
-          try {
-            fis = new FileInputStream(resultFile);
-            ObjectInputStream ois = new ObjectInputStream(fis);
-            HeapDump heapDump = (HeapDump) ois.readObject();
-            AnalysisResult result = (AnalysisResult) ois.readObject();
-            leaks.add(new Leak(heapDump, result, resultFile));
-          } catch (IOException | ClassNotFoundException e) {
-            // Likely a change in the serializable result class.
-            // Let's remove the files, we can't read them anymore.
-            boolean deleted = resultFile.delete();
-            if (deleted) {
-              CanaryLog.d(e, "Could not read result file %s, deleted it.", resultFile);
-            } else {
-              CanaryLog.d(e, "Could not read result file %s, could not delete it either.",
-                  resultFile);
-            }
-          } finally {
-            if (fis != null) {
-              try {
-                fis.close();
-              } catch (IOException ignored) {
-              }
-            }
-          }
-        }
-        Collections.sort(leaks, new Comparator<Leak>() {
-          @Override public int compare(Leak lhs, Leak rhs) {
-            return Long.valueOf(rhs.resultFile.lastModified())
-                .compareTo(lhs.resultFile.lastModified());
-          }
-        });
-      }
-      mainHandler.post(new Runnable() {
-        @Override public void run() {
-          inFlight.remove(LoadLeaks.this);
-          if (activityOrNull != null) {
-            activityOrNull.leaks = leaks;
-            activityOrNull.updateUi();
-          }
-        }
-      });
-    }
-  }
-
-  static String classSimpleName(String className) {
-    int separator = className.lastIndexOf('.');
-    if (separator == -1) {
-      return className;
-    } else {
-      return className.substring(separator + 1);
-    }
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
deleted file mode 100644
index fd23cfbd..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.Context;
-import android.text.Html;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.BaseAdapter;
-import android.widget.TextView;
-import com.squareup.leakcanary.Exclusion;
-import com.squareup.leakcanary.LeakTrace;
-import com.squareup.leakcanary.LeakTraceElement;
-import com.squareup.leakcanary.R;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-
-final class DisplayLeakAdapter extends BaseAdapter {
-
-  private static final int TOP_ROW = 0;
-  private static final int NORMAL_ROW = 1;
-
-  private boolean[] opened = new boolean[0];
-
-  private List<LeakTraceElement> elements = Collections.emptyList();
-  private String referenceKey;
-  private String referenceName = "";
-
-  @Override public View getView(int position, View convertView, ViewGroup parent) {
-    Context context = parent.getContext();
-    if (getItemViewType(position) == TOP_ROW) {
-      if (convertView == null) {
-        convertView =
-            LayoutInflater.from(context).inflate(R.layout.leak_canary_ref_top_row, parent, false);
-      }
-      TextView textView = findById(convertView, R.id.leak_canary_row_text);
-      textView.setText(context.getPackageName());
-    } else {
-      if (convertView == null) {
-        convertView =
-            LayoutInflater.from(context).inflate(R.layout.leak_canary_ref_row, parent, false);
-      }
-      TextView textView = findById(convertView, R.id.leak_canary_row_text);
-
-      boolean isRoot = position == 1;
-      boolean isLeakingInstance = position == getCount() - 1;
-      LeakTraceElement element = getItem(position);
-      String htmlString = elementToHtmlString(element, isRoot, opened[position]);
-      if (isLeakingInstance && !referenceName.equals("") && opened[position]) {
-        htmlString += " <font color='#919191'>" + referenceName + "</font>";
-      }
-      textView.setText(Html.fromHtml(htmlString));
-
-      DisplayLeakConnectorView connector = findById(convertView, R.id.leak_canary_row_connector);
-      if (isRoot) {
-        connector.setType(DisplayLeakConnectorView.Type.START);
-      } else {
-        if (isLeakingInstance) {
-          connector.setType(DisplayLeakConnectorView.Type.END);
-        } else {
-          connector.setType(DisplayLeakConnectorView.Type.NODE);
-        }
-      }
-      MoreDetailsView moreDetailsView = findById(convertView, R.id.leak_canary_row_more);
-      moreDetailsView.setOpened(opened[position]);
-    }
-
-    return convertView;
-  }
-
-  private String elementToHtmlString(LeakTraceElement element, boolean root, boolean opened) {
-    String htmlString = "";
-
-    if (element.referenceName == null) {
-      htmlString += "leaks ";
-    } else if (!root) {
-      htmlString += "references ";
-    }
-
-    if (element.type == STATIC_FIELD) {
-      htmlString += "<font color='#c48a47'>static</font> ";
-    }
-
-    if (element.holder == ARRAY || element.holder == THREAD) {
-      htmlString += "<font color='#f3cf83'>" + element.holder.name().toLowerCase() + "</font> ";
-    }
-
-    int separator = element.className.lastIndexOf('.');
-    String qualifier;
-    String simpleName;
-    if (separator == -1) {
-      qualifier = "";
-      simpleName = element.className;
-    } else {
-      qualifier = element.className.substring(0, separator + 1);
-      simpleName = element.className.substring(separator + 1);
-    }
-
-    if (opened) {
-      htmlString += "<font color='#919191'>" + qualifier + "</font>";
-    }
-
-    String styledClassName = "<font color='#ffffff'>" + simpleName + "</font>";
-
-    htmlString += styledClassName;
-
-    if (element.referenceName != null) {
-      htmlString += ".<font color='#998bb5'>" + element.referenceName.replaceAll("<", "&lt;")
-          .replaceAll(">", "&gt;") + "</font>";
-    } else {
-      htmlString += " <font color='#f3cf83'>instance</font>";
-    }
-
-    if (opened && element.extra != null) {
-      htmlString += " <font color='#919191'>" + element.extra + "</font>";
-    }
-
-    Exclusion exclusion = element.exclusion;
-    if (exclusion != null) {
-      if (opened) {
-        htmlString += "<br/><br/>Excluded by rule";
-        if (exclusion.name != null) {
-          htmlString += " <font color='#ffffff'>" + exclusion.name + "</font>";
-        }
-        htmlString += " matching <font color='#f3cf83'>" + exclusion.matching + "</font>";
-        if (exclusion.reason != null) {
-          htmlString += " because <font color='#f3cf83'>" + exclusion.reason + "</font>";
-        }
-      } else {
-        htmlString += " (excluded)";
-      }
-    }
-
-    return htmlString;
-  }
-
-  public void update(LeakTrace leakTrace, String referenceKey, String referenceName) {
-    if (referenceKey.equals(this.referenceKey)) {
-      // Same data, nothing to change.
-      return;
-    }
-    this.referenceKey = referenceKey;
-    this.referenceName = referenceName;
-    this.elements = new ArrayList<>(leakTrace.elements);
-    opened = new boolean[1 + elements.size()];
-    notifyDataSetChanged();
-  }
-
-  public void toggleRow(int position) {
-    opened[position] = !opened[position];
-    notifyDataSetChanged();
-  }
-
-  @Override public int getCount() {
-    return 1 + elements.size();
-  }
-
-  @Override public LeakTraceElement getItem(int position) {
-    if (getItemViewType(position) == TOP_ROW) {
-      return null;
-    }
-    return elements.get(position - 1);
-  }
-
-  @Override public int getViewTypeCount() {
-    return 2;
-  }
-
-  @Override public int getItemViewType(int position) {
-    if (position == 0) {
-      return TOP_ROW;
-    }
-    return NORMAL_ROW;
-  }
-
-  @Override public long getItemId(int position) {
-    return position;
-  }
-
-  @SuppressWarnings("unchecked") private static <T extends View> T findById(View view, int id) {
-    return (T) view.findViewById(id);
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
deleted file mode 100644
index e854ac2a..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.Paint;
-import android.util.AttributeSet;
-import android.view.View;
-
-import static android.graphics.Bitmap.Config.ARGB_8888;
-
-public final class DisplayLeakConnectorView extends View {
-
-  private static final Paint iconPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  private static final Paint rootPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  private static final Paint leakPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  private static final Paint clearPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-
-  static {
-    iconPaint.setColor(LeakCanaryUi.LIGHT_GREY);
-    rootPaint.setColor(LeakCanaryUi.ROOT_COLOR);
-    leakPaint.setColor(LeakCanaryUi.LEAK_COLOR);
-    clearPaint.setColor(Color.TRANSPARENT);
-    clearPaint.setXfermode(LeakCanaryUi.CLEAR_XFER_MODE);
-  }
-
-  public enum Type {
-    START, NODE, END
-  }
-
-  private Type type;
-  private Bitmap cache;
-
-  public DisplayLeakConnectorView(Context context, AttributeSet attrs) {
-    super(context, attrs);
-
-    type = Type.NODE;
-  }
-
-  @SuppressWarnings("SuspiciousNameCombination") @Override protected void onDraw(Canvas canvas) {
-    int width = getWidth();
-    int height = getHeight();
-
-    if (cache != null && (cache.getWidth() != width || cache.getHeight() != height)) {
-      cache.recycle();
-      cache = null;
-    }
-
-    if (cache == null) {
-      cache = Bitmap.createBitmap(width, height, ARGB_8888);
-
-      Canvas cacheCanvas = new Canvas(cache);
-
-      float halfWidth = width / 2f;
-      float halfHeight = height / 2f;
-      float thirdWidth = width / 3f;
-
-      float strokeSize = LeakCanaryUi.dpToPixel(4f, getResources());
-
-      iconPaint.setStrokeWidth(strokeSize);
-      rootPaint.setStrokeWidth(strokeSize);
-
-      switch (type) {
-        case NODE:
-          cacheCanvas.drawLine(halfWidth, 0, halfWidth, height, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, halfWidth, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, clearPaint);
-          break;
-        case START:
-          float radiusClear = halfWidth - strokeSize / 2f;
-          cacheCanvas.drawRect(0, 0, width, radiusClear, rootPaint);
-          cacheCanvas.drawCircle(0, radiusClear, radiusClear, clearPaint);
-          cacheCanvas.drawCircle(width, radiusClear, radiusClear, clearPaint);
-          cacheCanvas.drawLine(halfWidth, 0, halfWidth, halfHeight, rootPaint);
-          cacheCanvas.drawLine(halfWidth, halfHeight, halfWidth, height, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, halfWidth, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, clearPaint);
-          break;
-        default:
-          cacheCanvas.drawLine(halfWidth, 0, halfWidth, halfHeight, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, leakPaint);
-          break;
-      }
-    }
-    canvas.drawBitmap(cache, 0, 0, null);
-  }
-
-  public void setType(Type type) {
-    if (type != this.type) {
-      this.type = type;
-      if (cache != null) {
-        cache.recycle();
-        cache = null;
-      }
-      invalidate();
-    }
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.java
deleted file mode 100644
index 8cd6b27f..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-
-public final class FutureResult<T> {
-
-  private final AtomicReference<T> resultHolder;
-  private final CountDownLatch latch;
-
-  public FutureResult() {
-    resultHolder = new AtomicReference<>();
-    latch = new CountDownLatch(1);
-  }
-
-  public boolean wait(long timeout, TimeUnit unit) {
-    try {
-      return latch.await(timeout, unit);
-    } catch (InterruptedException e) {
-      throw new RuntimeException("Did not expect thread to be interrupted", e);
-    }
-  }
-
-  public T get() {
-    if (latch.getCount() > 0) {
-      throw new IllegalStateException("Call wait() and check its result");
-    }
-    return resultHolder.get();
-  }
-
-  public void set(T result) {
-    resultHolder.set(result);
-    latch.countDown();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
deleted file mode 100644
index d03dad94..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.app.IntentService;
-import android.content.Context;
-import android.content.Intent;
-import com.squareup.leakcanary.AbstractAnalysisResultService;
-import com.squareup.leakcanary.AnalysisResult;
-import com.squareup.leakcanary.CanaryLog;
-import com.squareup.leakcanary.HeapAnalyzer;
-import com.squareup.leakcanary.HeapDump;
-
-/**
- * This service runs in a separate process to avoid slowing down the app process or making it run
- * out of memory.
- */
-public final class HeapAnalyzerService extends IntentService {
-
-  private static final String LISTENER_CLASS_EXTRA = "listener_class_extra";
-  private static final String HEAPDUMP_EXTRA = "heapdump_extra";
-
-  public static void runAnalysis(Context context, HeapDump heapDump,
-      Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
-    Intent intent = new Intent(context, HeapAnalyzerService.class);
-    intent.putExtra(LISTENER_CLASS_EXTRA, listenerServiceClass.getName());
-    intent.putExtra(HEAPDUMP_EXTRA, heapDump);
-    context.startService(intent);
-  }
-
-  public HeapAnalyzerService() {
-    super(HeapAnalyzerService.class.getSimpleName());
-  }
-
-  @Override protected void onHandleIntent(Intent intent) {
-    if (intent == null) {
-      CanaryLog.d("HeapAnalyzerService received a null intent, ignoring.");
-      return;
-    }
-    String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);
-    HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);
-
-    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(heapDump.excludedRefs);
-
-    AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);
-    AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
deleted file mode 100644
index cdb5a055..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.annotation.TargetApi;
-import android.app.ActivityManager;
-import android.app.Notification;
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.app.Service;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.ServiceInfo;
-import com.squareup.leakcanary.CanaryLog;
-import com.squareup.leakcanary.R;
-import java.lang.reflect.Method;
-import java.util.List;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
-import static android.content.pm.PackageManager.DONT_KILL_APP;
-import static android.content.pm.PackageManager.GET_SERVICES;
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.HONEYCOMB;
-import static android.os.Build.VERSION_CODES.JELLY_BEAN;
-
-public final class LeakCanaryInternals {
-
-  public static final String SAMSUNG = "samsung";
-  public static final String MOTOROLA = "motorola";
-  public static final String LG = "LGE";
-  public static final String NVIDIA = "NVIDIA";
-
-  private static final Executor fileIoExecutor = newSingleThreadExecutor("File-IO");
-
-  public static void executeOnFileIoThread(Runnable runnable) {
-    fileIoExecutor.execute(runnable);
-  }
-
-  /** Extracts the class simple name out of a string containing a fully qualified class name. */
-  public static String classSimpleName(String className) {
-    int separator = className.lastIndexOf('.');
-    if (separator == -1) {
-      return className;
-    } else {
-      return className.substring(separator + 1);
-    }
-  }
-
-  public static void setEnabled(Context context, final Class<?> componentClass,
-      final boolean enabled) {
-    final Context appContext = context.getApplicationContext();
-    executeOnFileIoThread(new Runnable() {
-      @Override public void run() {
-        setEnabledBlocking(appContext, componentClass, enabled);
-      }
-    });
-  }
-
-  public static void setEnabledBlocking(Context appContext, Class<?> componentClass,
-      boolean enabled) {
-    ComponentName component = new ComponentName(appContext, componentClass);
-    PackageManager packageManager = appContext.getPackageManager();
-    int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED;
-    // Blocks on IPC.
-    packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);
-  }
-
-  public static boolean isInServiceProcess(Context context, Class<? extends Service> serviceClass) {
-    PackageManager packageManager = context.getPackageManager();
-    PackageInfo packageInfo;
-    try {
-      packageInfo = packageManager.getPackageInfo(context.getPackageName(), GET_SERVICES);
-    } catch (Exception e) {
-      CanaryLog.d(e, "Could not get package info for %s", context.getPackageName());
-      return false;
-    }
-    String mainProcess = packageInfo.applicationInfo.processName;
-
-    ComponentName component = new ComponentName(context, serviceClass);
-    ServiceInfo serviceInfo;
-    try {
-      serviceInfo = packageManager.getServiceInfo(component, 0);
-    } catch (PackageManager.NameNotFoundException ignored) {
-      // Service is disabled.
-      return false;
-    }
-
-    if (serviceInfo.processName.equals(mainProcess)) {
-      CanaryLog.d("Did not expect service %s to run in main process %s", serviceClass, mainProcess);
-      // Technically we are in the service process, but we're not in the service dedicated process.
-      return false;
-    }
-
-    int myPid = android.os.Process.myPid();
-    ActivityManager activityManager =
-        (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
-    ActivityManager.RunningAppProcessInfo myProcess = null;
-    List<ActivityManager.RunningAppProcessInfo> runningProcesses =
-        activityManager.getRunningAppProcesses();
-    if (runningProcesses != null) {
-      for (ActivityManager.RunningAppProcessInfo process : runningProcesses) {
-        if (process.pid == myPid) {
-          myProcess = process;
-          break;
-        }
-      }
-    }
-    if (myProcess == null) {
-      CanaryLog.d("Could not find running process for %d", myPid);
-      return false;
-    }
-
-    return myProcess.processName.equals(serviceInfo.processName);
-  }
-
-  @TargetApi(HONEYCOMB)
-  public static void showNotification(Context context, CharSequence contentTitle,
-      CharSequence contentText, PendingIntent pendingIntent) {
-    NotificationManager notificationManager =
-        (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
-
-    Notification notification;
-    if (SDK_INT < HONEYCOMB) {
-      notification = new Notification();
-      notification.icon = R.drawable.leak_canary_notification;
-      notification.when = System.currentTimeMillis();
-      notification.flags |= Notification.FLAG_AUTO_CANCEL;
-      try {
-        Method method =
-            Notification.class.getMethod("setLatestEventInfo", Context.class, CharSequence.class,
-                CharSequence.class, PendingIntent.class);
-        method.invoke(notification, context, contentTitle, contentText, pendingIntent);
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    } else {
-      Notification.Builder builder = new Notification.Builder(context) //
-          .setSmallIcon(R.drawable.leak_canary_notification)
-          .setWhen(System.currentTimeMillis())
-          .setContentTitle(contentTitle)
-          .setContentText(contentText)
-          .setAutoCancel(true)
-          .setContentIntent(pendingIntent);
-      if (SDK_INT < JELLY_BEAN) {
-        notification = builder.getNotification();
-      } else {
-        notification = builder.build();
-      }
-    }
-    notificationManager.notify(0xDEAFBEEF, notification);
-  }
-
-  public static Executor newSingleThreadExecutor(String threadName) {
-    return Executors.newSingleThreadExecutor(new LeakCanarySingleThreadFactory(threadName));
-  }
-
-  private LeakCanaryInternals() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java
deleted file mode 100644
index 74fbf986..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.res.Resources;
-import android.graphics.PorterDuffXfermode;
-import android.util.DisplayMetrics;
-
-import static android.graphics.PorterDuff.Mode.CLEAR;
-
-final class LeakCanaryUi {
-  static final int LIGHT_GREY = 0xFFbababa;
-  static final int ROOT_COLOR = 0xFF84a6c5;
-  static final int LEAK_COLOR = 0xFFb1554e;
-
-  static final PorterDuffXfermode CLEAR_XFER_MODE = new PorterDuffXfermode(CLEAR);
-
-  /**
-   * Converts from device independent pixels (dp or dip) to
-   * device dependent pixels. This method returns the input
-   * multiplied by the display's density. The result is not
-   * rounded nor clamped.
-   *
-   * The value returned by this method is well suited for
-   * drawing with the Canvas API but should not be used to
-   * set layout dimensions.
-   *
-   * @param dp The value in dp to convert to pixels
-   * @param resources An instances of Resources
-   */
-  static float dpToPixel(float dp, Resources resources) {
-    DisplayMetrics metrics = resources.getDisplayMetrics();
-    return metrics.density * dp;
-  }
-
-  private LeakCanaryUi() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
deleted file mode 100644
index 81bf8a0f..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.Context;
-import android.graphics.Canvas;
-import android.graphics.Paint;
-import android.util.AttributeSet;
-import android.view.View;
-
-public final class MoreDetailsView extends View {
-
-  private static final Paint iconPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-
-  static {
-    iconPaint.setColor(LeakCanaryUi.ROOT_COLOR);
-  }
-
-  public MoreDetailsView(Context context, AttributeSet attrs) {
-    super(context, attrs);
-
-    float strokeSize = LeakCanaryUi.dpToPixel(2f, getResources());
-    iconPaint.setStrokeWidth(strokeSize);
-  }
-
-  private boolean opened;
-
-  @Override protected void onDraw(Canvas canvas) {
-    int width = getWidth();
-    int height = getHeight();
-    int halfHeight = height / 2;
-    int halfWidth = width / 2;
-
-    if (opened) {
-      canvas.drawLine(0, halfHeight, width, halfHeight, iconPaint);
-    } else {
-      canvas.drawLine(0, halfHeight, width, halfHeight, iconPaint);
-      canvas.drawLine(halfWidth, 0, halfWidth, height, iconPaint);
-    }
-  }
-
-  public void setOpened(boolean opened) {
-    if (opened != this.opened) {
-      this.opened = opened;
-      invalidate();
-    }
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java
deleted file mode 100644
index 3d8a23f1..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.PendingIntent;
-import android.content.Context;
-import android.content.Intent;
-import android.os.Bundle;
-import android.widget.Toast;
-import com.squareup.leakcanary.R;
-
-import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
-import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
-import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
-import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
-import static android.content.pm.PackageManager.PERMISSION_GRANTED;
-import static android.os.Build.VERSION_CODES.M;
-import static android.widget.Toast.LENGTH_LONG;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabledBlocking;
-
-@TargetApi(M) //
-public class RequestStoragePermissionActivity extends Activity {
-
-  public static PendingIntent createPendingIntent(Context context) {
-    setEnabledBlocking(context, RequestStoragePermissionActivity.class, true);
-    Intent intent = new Intent(context, RequestStoragePermissionActivity.class);
-    intent.setFlags(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TOP);
-    return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);
-  }
-
-  @Override protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-
-    if (savedInstanceState == null) {
-      if (hasStoragePermission()) {
-        finish();
-        return;
-      }
-      String[] permissions = {
-          WRITE_EXTERNAL_STORAGE
-      };
-      requestPermissions(permissions, 42);
-    }
-  }
-
-  @Override public void onRequestPermissionsResult(int requestCode, String[] permissions,
-      int[] grantResults) {
-    if (!hasStoragePermission()) {
-      Toast.makeText(getApplication(), R.string.leak_canary_permission_not_granted, LENGTH_LONG)
-          .show();
-    }
-    finish();
-  }
-
-  private boolean hasStoragePermission() {
-    return checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED;
-  }
-}
diff --git a/leakcanary-android/src/main/java/leakcanary/internal/HeapAnalyzerService.kt b/leakcanary-android/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
new file mode 100644
index 00000000..6d3eb292
--- /dev/null
+++ b/leakcanary-android/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.content.Intent
+import com.squareup.leakcanary.R
+import leakcanary.AnalyzerProgressListener
+import leakcanary.CanaryLog
+import leakcanary.HeapAnalyzer
+import leakcanary.HeapDump
+import leakcanary.LeakCanary
+
+/**
+ * This service runs in a main app process.
+ */
+internal class HeapAnalyzerService : ForegroundService(
+    HeapAnalyzerService::class.java.simpleName,
+    R.string.leak_canary_notification_analysing
+), AnalyzerProgressListener {
+
+  override fun onHandleIntentInForeground(intent: Intent?) {
+    if (intent == null) {
+      CanaryLog.d("HeapAnalyzerService received a null intent, ignoring.")
+      return
+    }
+    val heapDump = intent.getSerializableExtra(HeapAnalyzers.HEAPDUMP_EXTRA) as HeapDump
+    val heapAnalyzer = HeapAnalyzer(this)
+    val heapAnalysis = heapAnalyzer.checkForLeaks(heapDump, LeakCanary.config.labelers)
+
+    AnalysisResultService.sendResult(this, heapAnalysis)
+  }
+
+  override fun onProgressUpdate(step: AnalyzerProgressListener.Step) {
+    val percent = (100f * step.ordinal / AnalyzerProgressListener.Step.values().size).toInt()
+    CanaryLog.d("Analysis in progress, working on: %s", step.name)
+    val lowercase = step.name.replace("_", " ")
+        .toLowerCase()
+    val message = lowercase.substring(0, 1).toUpperCase() + lowercase.substring(1)
+    showForegroundNotification(100, percent, false, message)
+  }
+}
diff --git a/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png
deleted file mode 100755
index 07bb09fc..00000000
Binary files a/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png
deleted file mode 100755
index 74348d82..00000000
Binary files a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png
deleted file mode 100755
index 13b33116..00000000
Binary files a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png
deleted file mode 100755
index 9738ad81..00000000
Binary files a/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png
deleted file mode 100755
index 37f5057f..00000000
Binary files a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png
deleted file mode 100755
index dc92783b..00000000
Binary files a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png
deleted file mode 100755
index 538e0214..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png
deleted file mode 100755
index 56a94f27..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png
deleted file mode 100755
index 1e1b977f..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png
deleted file mode 100755
index d3ef4b71..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png
deleted file mode 100755
index 34b7d41b..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png
deleted file mode 100755
index c652efdd..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png
deleted file mode 100755
index 4713f18d..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png
deleted file mode 100755
index 855d6052..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png
deleted file mode 100755
index bb458f2c..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml b/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
deleted file mode 100644
index 8e56c3d1..00000000
--- a/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
+++ /dev/null
@@ -1,46 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:orientation="vertical"
-    android:background="#3c3c3c"
-    >
-  <ListView
-      android:id="@+id/leak_canary_display_leak_list"
-      android:layout_width="match_parent"
-      android:layout_height="0dp"
-      android:layout_weight="1"
-      android:dividerHeight="0dp"
-      android:divider="@null"
-      />
-  <TextView
-      android:id="@+id/leak_canary_display_leak_failure"
-      android:layout_width="match_parent"
-      android:layout_height="0dp"
-      android:layout_weight="1"
-      android:textSize="12sp"
-      android:visibility="gone"
-      />
-  <Button
-      android:id="@+id/leak_canary_action"
-      android:layout_width="match_parent"
-      android:layout_height="wrap_content"
-      android:visibility="gone"
-      />
-
-</LinearLayout>
diff --git a/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
deleted file mode 100644
index 6e43e4d3..00000000
--- a/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
+++ /dev/null
@@ -1,39 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?><!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<resources>
-    <string name="leak_canary_class_has_leaked">%1$s hat %2$s geleaked</string>
-    <string name="leak_canary_leak_excluded">[Ausgeschlossen] %1$s hat %2$s geleaked</string>
-    <string name="leak_canary_analysis_failed">Leak Analyse fehlgeschlagen</string>
-    <string name="leak_canary_leak_list_title">Leaks in %s</string>
-    <string name="leak_canary_notification_message">Für mehr Details hier klicken</string>
-    <string name="leak_canary_share_leak">Info teilen</string>
-    <string name="leak_canary_share_heap_dump">Heap Dump teilen</string>
-    <string name="leak_canary_share_with">Teilen mit…</string>
-    <string name="leak_canary_display_activity_label">Leaks</string>
-    <string name="leak_canary_storage_permission_activity_label">Storage Berechtigung</string>
-    <string name="leak_canary_toast_heap_dump">Sichere den Speicher, die App wird einfrieren. Brrr.</string>
-    <string name="leak_canary_delete">Löschen</string>
-    <string name="leak_canary_failure_report">"Bitte sende diesen Fehler an http://github.com/square/leakcanary\n"</string>
-    <string name="leak_canary_delete_all">Alle löschen</string>
-    <string name="leak_canary_could_not_save_title">Konnte Ergebnis nicht speichern.</string>
-    <string name="leak_canary_could_not_save_text">LeakCanary konnte das Ergebnis der Analyse nicht speichern.</string>
-    <string name="leak_canary_no_leak_title">Kein Leak gefunden</string>
-    <string name="leak_canary_no_leak_text">Der GC war untätig.</string>
-    <string name="leak_canary_excluded_row">[Ausgeschlossen] %s</string>
-    <string name="leak_canary_permission_not_granted">Bitte gewähre die Storage Berechtigung, andernfalls werden Memory Leaks nicht erkannt.</string>
-    <string name="leak_canary_permission_notification_title">Leak erkannt, benötige Berechtigung</string>
-    <string name="leak_canary_permission_notification_text">Hier klicken, um Storage Berechtigung für %s zu aktivieren.</string>
-</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_strings.xml b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
deleted file mode 100644
index d9aaee13..00000000
--- a/leakcanary-android/src/main/res/values/leak_canary_strings.xml
+++ /dev/null
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<resources>
-  <string name="leak_canary_class_has_leaked">%1$s leaked %2$s</string>
-  <string name="leak_canary_leak_excluded">[Excluded] %1$s leaked %2$s</string>
-  <string name="leak_canary_analysis_failed">Leak analysis failed</string>
-  <string name="leak_canary_leak_list_title">Leaks in %s</string>
-  <string name="leak_canary_notification_message">Click for more details</string>
-  <string name="leak_canary_share_leak">Share info</string>
-  <string name="leak_canary_share_heap_dump">Share heap dump</string>
-  <string name="leak_canary_share_with">Share with…</string>
-  <string name="leak_canary_display_activity_label">Leaks</string>
-  <string name="leak_canary_storage_permission_activity_label">Storage permission</string>
-  <string name="leak_canary_toast_heap_dump">Dumping memory, app will freeze. Brrrr.</string>
-  <string name="leak_canary_delete">Delete</string>
-  <string name="leak_canary_failure_report">"Please report this failure to http://github.com/square/leakcanary\n"</string>
-  <string name="leak_canary_delete_all">Delete all</string>
-  <string name="leak_canary_could_not_save_title">Could not save result.</string>
-  <string name="leak_canary_could_not_save_text">LeakCanary was unable to save the analysis result.</string>
-  <string name="leak_canary_no_leak_title">No leak found</string>
-  <string name="leak_canary_no_leak_text">The GC was being lazy.</string>
-  <string name="leak_canary_excluded_row">[Excluded] %s</string>
-  <string name="leak_canary_permission_not_granted">Please grant external storage permission, otherwise memory leaks will not be detected.</string>
-  <string name="leak_canary_permission_notification_title">Leak detected, need permission</string>
-  <string name="leak_canary_permission_notification_text">Click to enable storage permission for %s.</string>
-</resources>
diff --git a/leakcanary-haha/build.gradle b/leakcanary-haha/build.gradle
new file mode 100644
index 00000000..41aa3d15
--- /dev/null
+++ b/leakcanary-haha/build.gradle
@@ -0,0 +1,15 @@
+apply plugin: 'java-library'
+apply plugin: 'kotlin'
+
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
+
+dependencies {
+  api project(':leakcanary-log')
+
+  implementation deps.kotlin.stdlib
+  implementation deps.okio
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/leakcanary-haha/gradle.properties b/leakcanary-haha/gradle.properties
new file mode 100644
index 00000000..b7629a2c
--- /dev/null
+++ b/leakcanary-haha/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-haha
+POM_NAME=LeakCanary Headless Android Heap Analyzer
+POM_PACKAGING=jar
diff --git a/leakcanary-haha/src/main/java/leakcanary/GcRoot.kt b/leakcanary-haha/src/main/java/leakcanary/GcRoot.kt
new file mode 100644
index 00000000..fa7b3b9f
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/GcRoot.kt
@@ -0,0 +1,102 @@
+package leakcanary
+
+sealed class GcRoot {
+
+  abstract val id: Long
+
+  class Unknown(override val id: Long) : GcRoot()
+
+  /**
+   * A global variable in native code.
+   */
+  class JniGlobal(
+    override val id: Long,
+    val jniGlobalRefId: Long
+  ) : GcRoot()
+
+  /**
+   * A local variable in native code.
+   */
+  class JniLocal(
+    override val id: Long,
+    val threadSerialNumber: Int,
+    /**
+     * frame number in stack trace (-1 for empty)
+     */
+    val frameNumber: Int
+  ) : GcRoot()
+
+  /**
+   * Java local variable
+   */
+  class JavaFrame(
+    override val id: Long,
+    val threadSerialNumber: Int,
+    /**
+     * frame number in stack trace (-1 for empty)
+     */
+    val frameNumber: Int
+  ) : GcRoot()
+
+  /**
+   * Input or output parameters in native code
+   */
+  class NativeStack(
+    override val id: Long,
+    /**
+     * Thread is sometimes not found, see:
+     * https://issuetracker.google.com/issues/122713143
+     */
+    val threadSerialNumber: Int
+  ) : GcRoot()
+
+  /**
+   * System class
+   */
+  class StickyClass(override val id: Long) : GcRoot()
+
+  class ThreadBlock(
+    override val id: Long,
+    val threadSerialNumber: Int
+  ) : GcRoot()
+
+  /**
+   * Everything that called the wait() or notify() methods, or
+   * that is synchronized.
+   */
+  class MonitorUsed(override val id: Long) : GcRoot()
+
+  /**
+   * Added at https://android.googlesource.com/platform/tools/base/+/c0f0d528c155cab32e372dac77370569a386245c
+   */
+  class ThreadObject(
+    override val id: Long,
+    val threadSerialNumber: Int,
+    val stackTraceSerialNumber: Int
+  ) : GcRoot()
+
+  class ReferenceCleanup(override val id: Long) : GcRoot()
+
+  class VmInternal(override val id: Long) : GcRoot()
+
+  class JniMonitor(
+    override val id: Long,
+    val stackTraceSerialNumber: Int,
+    val stackDepth: Int
+  ) : GcRoot()
+
+  class InternedString(override val id: Long) : GcRoot()
+
+  /**
+   * An object that is in a queue, waiting for a finalizer to run.
+   */
+  class Finalizing(override val id: Long) : GcRoot()
+
+  class Debugger(override val id: Long) : GcRoot()
+
+  /**
+   * An object that is unreachable from any other root, but not a root itself.
+   */
+  class Unreachable(override val id: Long) : GcRoot()
+
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt b/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt
new file mode 100644
index 00000000..901ab2a3
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt
@@ -0,0 +1,17 @@
+package leakcanary
+
+sealed class HeapValue {
+  data class ObjectReference(val value: Long) : HeapValue() {
+    val isNull
+      get() = value == 0L
+  }
+
+  data class BooleanValue(val value: Boolean) : HeapValue()
+  data class CharValue(val value: Char) : HeapValue()
+  data class FloatValue(val value: Float) : HeapValue()
+  data class DoubleValue(val value: Double) : HeapValue()
+  data class ByteValue(val value: Byte) : HeapValue()
+  data class ShortValue(val value: Short) : HeapValue()
+  data class IntValue(val value: Int) : HeapValue()
+  data class LongValue(val value: Long) : HeapValue()
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt b/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
new file mode 100644
index 00000000..e44bbc7e
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
@@ -0,0 +1,912 @@
+package leakcanary
+
+import leakcanary.GcRoot.Debugger
+import leakcanary.GcRoot.Finalizing
+import leakcanary.GcRoot.InternedString
+import leakcanary.GcRoot.JavaFrame
+import leakcanary.GcRoot.JniGlobal
+import leakcanary.GcRoot.JniLocal
+import leakcanary.GcRoot.JniMonitor
+import leakcanary.GcRoot.MonitorUsed
+import leakcanary.GcRoot.NativeStack
+import leakcanary.GcRoot.ReferenceCleanup
+import leakcanary.GcRoot.StickyClass
+import leakcanary.GcRoot.ThreadBlock
+import leakcanary.GcRoot.ThreadObject
+import leakcanary.GcRoot.Unknown
+import leakcanary.GcRoot.Unreachable
+import leakcanary.GcRoot.VmInternal
+import leakcanary.HeapValue.IntValue
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.HprofReader.Companion.BYTE_SIZE
+import leakcanary.HprofReader.Companion.INT_SIZE
+import leakcanary.HprofReader.Companion.INT_TYPE
+import leakcanary.HprofReader.Companion.LONG_SIZE
+import leakcanary.HprofReader.Companion.OBJECT_TYPE
+import leakcanary.HprofReader.Companion.SHORT_SIZE
+import leakcanary.ObjectIdMetadata.EMPTY_INSTANCE
+import leakcanary.ObjectIdMetadata.INSTANCE
+import leakcanary.ObjectIdMetadata.INTERNAL_MAYBE_EMPTY_INSTANCE
+import leakcanary.Record.HeapDumpEndRecord
+import leakcanary.Record.HeapDumpRecord.GcRootRecord
+import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import leakcanary.Record.LoadClassRecord
+import leakcanary.Record.StackTraceRecord
+import leakcanary.Record.StringRecord
+import leakcanary.internal.LongToIntSparseArray
+import leakcanary.internal.LongToLongSparseArray
+import leakcanary.internal.LongToStringSparseArray
+import leakcanary.internal.LruCache
+import okio.Buffer
+import okio.buffer
+import okio.source
+import java.io.Closeable
+import java.io.File
+import java.nio.charset.Charset
+import kotlin.math.pow
+import kotlin.properties.Delegates.notNull
+
+/**
+ * A memory efficient heap dump parser.
+ *
+ * Expected usage: call [scan] once, which will go read through the entire heap dump, build indices,
+ * and let consumers collect non indexed data (e.g. all instances of X, or all gc roots, etc).
+ *
+ * Then navigate on the heap using object ids which [scan] has indexed to file positions.
+ *
+ * This class is not thread safe, should be used from a single thread.
+ *
+ * Binary Dump Format reference: http://hg.openjdk.java.net/jdk6/jdk6/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html#mozTocId848088
+ *
+ * The Android Hprof format differs in some ways from that reference. This parser implementation
+ * is largely adapted from https://android.googlesource.com/platform/tools/base/+/studio-master-dev/perflib/src/main/java/com/android/tools/perflib
+ *
+ * Also some of the ideas come from https://github.com/square/leakcanary/pull/1278
+ */
+class HprofParser private constructor(
+  private val reader: SeekableHprofReader
+) : Closeable {
+
+  private var scanning = false
+  private var indexBuilt = false
+
+  val position
+    get() = reader.position
+
+  /**
+   * Map of string id to string
+   * This currently keeps all the hprof strings that we could care about: class names,
+   * static field names and instance fields names
+   */
+  // TODO Replacing with a radix trie reversed into a sparse array of long to trie leaf could save
+  // memory.
+  // Another option is to switch back to reading from the file system as necessary, and keep a much
+  // smaller cache for strings we need during shortest path (those are for exclusions)
+  private val hprofStringCache = LongToStringSparseArray(60000)
+
+  /**
+   * class id to string id
+   */
+  private val classNames = LongToLongSparseArray(20000)
+
+  /**
+   * Object id to ([ObjectIdMetadata], object position). We pack the metadata ordinal and the
+   * position into an int, which gives us 3 bits for the metadata (enum with at most 8 values)
+   * and 29 bits for the position, which means the heap dump file must be at most 512 MiB.
+   *
+   * The id can be for classes instances, classes, object arrays and primitive arrays
+   */
+  private val objectIndex = LongToIntSparseArray(250000)
+
+  /**
+   * LRU cache size of 3000 is a sweet spot to balance hits vs memory usage.
+   * This is based on running InstrumentationLeakDetectorTest a bunch of time on a
+   * Pixel 2 XL API 28. Hit count was ~120K, miss count ~290K
+   */
+  private val objectCache = LruCache<Long, ObjectRecord>(3000)
+
+  /**
+   * Class ids for primitive wrapper types
+   */
+  private val primitiveWrapperTypes = mutableSetOf<Long>()
+
+  /**
+   * String ids for class names of primitive wrapper types
+   */
+  private val primitiveWrapperClassNames = mutableSetOf<Long>()
+
+  private var maybeEmptyInstancesAreEmpty by notNull<Boolean>()
+
+  class RecordCallbacks {
+    private val callbacks = mutableMapOf<Class<out Record>, Any>()
+
+    fun <T : Record> on(
+      recordClass: Class<T>,
+      callback: (T) -> Unit
+    ): RecordCallbacks {
+      callbacks[recordClass] = callback
+      return this
+    }
+
+    fun <T : Record> get(recordClass: Class<T>): ((T) -> Unit)? {
+      @Suppress("UNCHECKED_CAST")
+      return callbacks[recordClass] as ((T) -> Unit)?
+    }
+
+    inline fun <reified T : Record> get(): ((T) -> Unit)? {
+      return get(T::class.java)
+    }
+  }
+
+  override fun close() {
+    reader.close()
+  }
+
+  fun scan(callbacks: RecordCallbacks) {
+    reader.scan(callbacks)
+  }
+
+  private fun SeekableHprofReader.scan(callbacks: RecordCallbacks) {
+    if (!isOpen) {
+      throw IllegalStateException("Reader closed")
+    }
+
+    if (scanning) {
+      throw UnsupportedOperationException("Cannot scan while already scanning.")
+    }
+
+    scanning = true
+
+    reset()
+
+    // heap dump timestamp
+    skip(LONG_SIZE)
+
+    // shadow$_klass_ (object id) + shadow$_monitor_ (Int)
+    val maybeEmptySize = typeSize(OBJECT_TYPE) + typeSize(INT_TYPE)
+
+    while (!exhausted()) {
+      // type of the record
+      val tag = readUnsignedByte()
+
+      // number of microseconds since the time stamp in the header
+      skip(INT_SIZE)
+
+      // number of bytes that follow and belong to this record
+      val length = readUnsignedInt()
+
+      when (tag) {
+        STRING_IN_UTF8 -> {
+          val callback = callbacks.get<StringRecord>()
+          if (callback != null || !indexBuilt) {
+            val id = readId()
+            val stringLength = length - idSize
+            val string = readUtf8(stringLength)
+            if (!indexBuilt) {
+              if (PRIMITIVE_WRAPPER_TYPES.contains(string)) {
+                primitiveWrapperClassNames.add(id)
+              }
+              hprofStringCache[id] = string
+            }
+            if (callback != null) {
+              callback(StringRecord(id, string))
+            }
+          } else {
+            skip(length)
+          }
+        }
+        LOAD_CLASS -> {
+          val callback = callbacks.get<LoadClassRecord>()
+          if (callback != null || !indexBuilt) {
+            val classSerialNumber = readInt()
+            val id = readId()
+            val stackTraceSerialNumber = readInt()
+            val classNameStringId = readId()
+            if (!indexBuilt) {
+              classNames[id] = classNameStringId
+              if (primitiveWrapperClassNames.contains(classNameStringId)) {
+                primitiveWrapperTypes.add(id)
+              }
+            }
+            if (callback != null) {
+              callback(
+                  LoadClassRecord(
+                      classSerialNumber = classSerialNumber,
+                      id = id,
+                      stackTraceSerialNumber = stackTraceSerialNumber,
+                      classNameStringId = classNameStringId
+                  )
+              )
+            }
+          } else {
+            skip(length)
+          }
+        }
+        STACK_TRACE -> {
+          val callback = callbacks.get<StackTraceRecord>()
+          if (callback != null) {
+            val stackTraceSerialNumber = readInt()
+            val threadSerialNumber = readInt()
+            val frameCount = readInt()
+            val stackFrameIds = readIdArray(frameCount)
+            callback(
+                StackTraceRecord(
+                    stackTraceSerialNumber = stackTraceSerialNumber,
+                    threadSerialNumber = threadSerialNumber,
+                    stackFrameIds = stackFrameIds
+                )
+            )
+          } else {
+            skip(length)
+          }
+        }
+        HEAP_DUMP, HEAP_DUMP_SEGMENT -> {
+          val heapDumpStart = position
+          var previousTag = 0
+          while (position - heapDumpStart < length) {
+            val heapDumpTag = readUnsignedByte()
+
+            when (heapDumpTag) {
+              ROOT_UNKNOWN -> {
+                val callback = callbacks.get<GcRootRecord>()
+                if (callback != null) {
+                  callback(
+                      GcRootRecord(
+                          gcRoot = Unknown(id = readId())
+                      )
+                  )
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_JNI_GLOBAL -> {
+                val callback = callbacks.get<GcRootRecord>()
+                if (callback != null) {
+                  callback(
+                      GcRootRecord(
+                          gcRoot = JniGlobal(id = readId(), jniGlobalRefId = readId())
+                      )
+                  )
+                } else {
+                  skip(idSize + idSize)
+                }
+              }
+
+              ROOT_JNI_LOCAL -> {
+                val callback = callbacks.get<GcRootRecord>()
+                if (callback != null) {
+                  callback(
+                      GcRootRecord(
+                          gcRoot = JniLocal(
+                              id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
+                          )
+                      )
+                  )
+                } else {
+                  skip(idSize + INT_SIZE + INT_SIZE)
+                }
+              }
+
+              ROOT_JAVA_FRAME -> {
+                val callback = callbacks.get<GcRootRecord>()
+                if (callback != null) {
+                  callback(
+                      GcRootRecord(
+                          gcRoot = JavaFrame(
+                              id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
+                          )
+                      )
+                  )
+                } else {
+                  skip(idSize + INT_SIZE + INT_SIZE)
+                }
+              }
+
+              ROOT_NATIVE_STACK -> {
+                val callback = callbacks.get<GcRootRecord>()
+                if (callback != null) {
+                  callback(
+                      GcRootRecord(
+                          gcRoot = NativeStack(id = readId(), threadSerialNumber = readInt())
+                      )
+                  )
+                } else {
+                  skip(idSize + INT_SIZE)
+                }
+              }
+
+              ROOT_STICKY_CLASS -> {
+                val callback = callbacks.get<GcRootRecord>()
+                if (callback != null) {
+                  callback(
+                      GcRootRecord(
+                          gcRoot = StickyClass(id = readId())
+                      )
+                  )
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              // An object that was referenced from an active thread block.
+              ROOT_THREAD_BLOCK -> {
+                val callback = callbacks.get<GcRootRecord>()
+                if (callback != null) {
+                  callback(
+                      GcRootRecord(
+                          gcRoot = ThreadBlock(id = readId(), threadSerialNumber = readInt())
+                      )
+                  )
+                } else {
+                  skip(idSize + INT_SIZE)
+                }
+              }
+
+              ROOT_MONITOR_USED -> {
+                val callback = callbacks.get<GcRootRecord>()
+                if (callback != null) {
+                  callback(
+                      GcRootRecord(
+                          gcRoot = MonitorUsed(id = readId())
+                      )
+                  )
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_THREAD_OBJECT -> {
+                val callback = callbacks.get<GcRootRecord>()
+                if (callback != null) {
+                  callback(
+                      GcRootRecord(
+                          gcRoot = ThreadObject(
+                              id = readId(),
+                              threadSerialNumber = readInt(),
+                              stackTraceSerialNumber = readInt()
+                          )
+                      )
+                  )
+                } else {
+                  skip(idSize + INT_SIZE + INT_SIZE)
+                }
+              }
+
+              CLASS_DUMP -> {
+                val callback = callbacks.get<ClassDumpRecord>()
+                val id = readId()
+                if (!indexBuilt) {
+                  objectIndex[id] =
+                    ObjectIdMetadata.CLASS.packOrdinalWithFilePosition(tagPositionAfterReadingId)
+                }
+                if (callback != null || !indexBuilt) {
+                  val classDumpRecord = readClassDumpRecord(id)
+                  if (!indexBuilt) {
+                    if (className(id) == "java.lang.Object") {
+                      val objectClassFieldSize = classDumpRecord.fields.sumBy {
+                        typeSize(it.type)
+                      }
+                      maybeEmptyInstancesAreEmpty = when (objectClassFieldSize) {
+                        0 -> false
+                        maybeEmptySize -> true
+                        else ->
+                          // We might need to make this more generic in the future.
+                          TODO(
+                              "Unexpected Object class field size $objectClassFieldSize, fields ${classDumpRecord.fields}"
+                          )
+                      }
+                    }
+                  }
+                  if (callback != null) {
+                    callback(classDumpRecord)
+                  }
+                } else {
+                  skip(
+                      INT_SIZE + idSize + idSize + idSize + idSize + idSize + idSize + INT_SIZE
+                  )
+                  // Skip over the constant pool
+                  val constantPoolCount = readUnsignedShort()
+                  for (i in 0 until constantPoolCount) {
+                    // constant pool index
+                    skip(SHORT_SIZE)
+                    skip(typeSize(readUnsignedByte()))
+                  }
+
+                  val staticFieldCount = readUnsignedShort()
+
+                  for (i in 0 until staticFieldCount) {
+                    skip(idSize)
+                    val type = readUnsignedByte()
+                    skip(typeSize(type))
+                  }
+
+                  val fieldCount = readUnsignedShort()
+                  skip(fieldCount * (idSize + BYTE_SIZE))
+                }
+              }
+
+              INSTANCE_DUMP -> {
+                val id = readId()
+                val callback = callbacks.get<InstanceDumpRecord>()
+                if (callback != null || !indexBuilt) {
+                  val recordPosition = tagPositionAfterReadingId
+                  val instanceDumpRecord = readInstanceDumpRecord(id)
+                  if (!indexBuilt) {
+                    val metadata = when {
+                      primitiveWrapperTypes.contains(
+                          instanceDumpRecord.classId
+                      ) -> ObjectIdMetadata.PRIMITIVE_WRAPPER
+                      hprofStringCache[classNames[instanceDumpRecord.classId]] == "java.lang.String" -> ObjectIdMetadata.STRING
+                      instanceDumpRecord.fieldValues.isEmpty() -> EMPTY_INSTANCE
+                      instanceDumpRecord.fieldValues.size <= maybeEmptySize -> INTERNAL_MAYBE_EMPTY_INSTANCE
+                      else -> ObjectIdMetadata.INSTANCE
+                    }
+                    objectIndex[id] = metadata.packOrdinalWithFilePosition(recordPosition)
+                  }
+                  if (callback != null) {
+                    callback(instanceDumpRecord)
+                  }
+                } else {
+                  skip(INT_SIZE + idSize)
+                  val remainingBytesInInstance = readInt()
+                  skip(remainingBytesInInstance)
+                }
+              }
+
+              OBJECT_ARRAY_DUMP -> {
+                val id = readId()
+
+                val callback = callbacks.get<ObjectArrayDumpRecord>()
+                if (callback != null || !indexBuilt) {
+                  val recordPosition = tagPositionAfterReadingId
+                  val arrayRecord = readObjectArrayDumpRecord(id)
+                  if (!indexBuilt) {
+                    val metadata = if (primitiveWrapperTypes.contains(arrayRecord.arrayClassId)) {
+                      ObjectIdMetadata.PRIMITIVE_ARRAY_OR_WRAPPER_ARRAY
+                    } else {
+                      ObjectIdMetadata.OBJECT_ARRAY
+                    }
+                    objectIndex[id] = metadata.packOrdinalWithFilePosition(recordPosition)
+                  }
+                  if (callback != null) {
+                    callback(arrayRecord)
+                  }
+                } else {
+                  skip(INT_SIZE)
+                  val arrayLength = readInt()
+                  skip(idSize + arrayLength * idSize)
+                }
+              }
+
+              PRIMITIVE_ARRAY_DUMP -> {
+                val id = readId()
+                if (!indexBuilt) {
+                  objectIndex[id] =
+                    ObjectIdMetadata.PRIMITIVE_ARRAY_OR_WRAPPER_ARRAY.packOrdinalWithFilePosition(
+                        tagPositionAfterReadingId
+                    )
+                }
+                val callback = callbacks.get<PrimitiveArrayDumpRecord>()
+                if (callback != null) {
+                  callback(readPrimitiveArrayDumpRecord(id))
+                } else {
+                  skip(INT_SIZE)
+                  val arrayLength = readInt()
+                  val type = readUnsignedByte()
+                  skip(arrayLength * typeSize(type))
+                }
+              }
+
+              PRIMITIVE_ARRAY_NODATA -> {
+                throw UnsupportedOperationException(
+                    "PRIMITIVE_ARRAY_NODATA cannot be parsed"
+                )
+              }
+
+              HEAP_DUMP_INFO -> {
+                val heapId = readInt()
+                val callback = callbacks.get<HeapDumpInfoRecord>()
+                if (callback != null) {
+                  val record =
+                    HeapDumpInfoRecord(heapId = heapId, heapNameStringId = readId())
+                  callback(record)
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_INTERNED_STRING -> {
+                val callback = callbacks.get<GcRootRecord>()
+                if (callback != null) {
+                  callback(
+                      GcRootRecord(
+                          gcRoot = InternedString(id = readId())
+                      )
+                  )
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_FINALIZING -> {
+                val callback = callbacks.get<GcRootRecord>()
+                if (callback != null) {
+                  callback(
+                      GcRootRecord(
+                          gcRoot = Finalizing(id = readId())
+                      )
+                  )
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_DEBUGGER -> {
+                val callback = callbacks.get<GcRootRecord>()
+                if (callback != null) {
+                  callback(
+                      GcRootRecord(
+                          gcRoot = Debugger(id = readId())
+                      )
+                  )
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_REFERENCE_CLEANUP -> {
+                val callback = callbacks.get<GcRootRecord>()
+                if (callback != null) {
+                  callback(
+                      GcRootRecord(
+                          gcRoot = ReferenceCleanup(id = readId())
+                      )
+                  )
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_VM_INTERNAL -> {
+                val callback = callbacks.get<GcRootRecord>()
+                if (callback != null) {
+                  callback(
+                      GcRootRecord(
+                          gcRoot = VmInternal(id = readId())
+                      )
+                  )
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_JNI_MONITOR -> {
+                val callback = callbacks.get<GcRootRecord>()
+                if (callback != null) {
+                  callback(
+                      GcRootRecord(
+                          gcRoot = JniMonitor(
+                              id = readId(), stackTraceSerialNumber = readInt(),
+                              stackDepth = readInt()
+                          )
+                      )
+                  )
+                } else {
+                  skip(idSize + INT_SIZE + INT_SIZE)
+                }
+              }
+
+              ROOT_UNREACHABLE -> {
+                val callback = callbacks.get<GcRootRecord>()
+                if (callback != null) {
+                  callback(
+                      GcRootRecord(
+                          gcRoot = Unreachable(id = readId())
+                      )
+                  )
+                } else {
+                  skip(idSize)
+                }
+              }
+              else -> throw IllegalStateException(
+                  "Unknown tag $heapDumpTag after $previousTag"
+              )
+            }
+            previousTag = heapDumpTag
+          }
+        }
+        HEAP_DUMP_END -> {
+          val callback = callbacks.get<HeapDumpEndRecord>()
+          if (callback != null) {
+            callback(HeapDumpEndRecord)
+          }
+        }
+        else -> {
+          skip(length)
+        }
+      }
+    }
+
+    if (!indexBuilt) {
+      objectIndex.compact()
+      classNames.compact()
+      hprofStringCache.compact()
+    }
+
+    scanning = false
+    indexBuilt = true
+  }
+
+  /**
+   * Those are strings for class names, fields, etc, ie not strings from the application memory.
+   */
+  fun hprofStringById(id: Long): String {
+    return hprofStringCache[id] ?: throw IllegalArgumentException("Hprof string $id not in cache")
+  }
+
+  fun isPrimitiveWrapper(classId: Long) = primitiveWrapperTypes.contains(classId)
+
+  fun className(classId: Long): String {
+    // String, primitive types
+    return hprofStringById(classNames[classId])
+  }
+
+  fun retrieveString(reference: ObjectReference): String {
+    return retrieveStringById(reference.value)
+  }
+
+  fun retrieveStringById(objectId: Long): String {
+    val instanceRecord = retrieveRecordById(objectId) as InstanceDumpRecord
+    val instance = hydrateInstance(instanceRecord)
+    return instanceAsString(instance)
+  }
+
+  fun objectIdMetadata(objectId: Long): ObjectIdMetadata {
+    val (metadata, _) = ObjectIdMetadata.unpackMetadataAndPosition(objectIndex[objectId])
+    if (metadata == INTERNAL_MAYBE_EMPTY_INSTANCE) {
+      return if (maybeEmptyInstancesAreEmpty) {
+        EMPTY_INSTANCE
+      } else {
+        INSTANCE
+      }
+    }
+    return metadata
+  }
+
+  fun retrieveRecord(reference: ObjectReference): ObjectRecord {
+    return retrieveRecordById(reference.value)
+  }
+
+  fun retrieveRecordById(objectId: Long): ObjectRecord {
+    val objectRecordOrNull = objectCache[objectId]
+    if (objectRecordOrNull != null) {
+      return objectRecordOrNull
+    }
+
+    val (_, position) = ObjectIdMetadata.unpackMetadataAndPosition(objectIndex[objectId])
+
+    require(position != 0L) {
+      "Unknown object id $objectId"
+    }
+    reader.moveTo(position)
+    val heapDumpTag = reader.readUnsignedByte()
+
+    reader.skip(reader.idSize)
+    val objectRecord = when (heapDumpTag) {
+      CLASS_DUMP -> reader.readClassDumpRecord(objectId)
+      INSTANCE_DUMP -> reader.readInstanceDumpRecord(objectId)
+      OBJECT_ARRAY_DUMP -> reader.readObjectArrayDumpRecord(objectId)
+      PRIMITIVE_ARRAY_DUMP -> reader.readPrimitiveArrayDumpRecord(objectId)
+      else -> {
+        throw IllegalStateException(
+            "Unexpected tag $heapDumpTag for id $objectId at position $position"
+        )
+      }
+    }
+    objectCache.put(objectId, objectRecord)
+    return objectRecord
+  }
+
+  /**
+   * Note: it's reasonable to call this repeatedly, there will be no disk reads as long as
+   * the classes are in the [objectCache] LruCache
+   */
+  fun hydrateClassHierarchy(classId: Long): List<HydratedClass> {
+    var currentClassId = classId
+    val classHierarchy = mutableListOf<HydratedClass>()
+    do {
+      val classRecord = retrieveRecordById(currentClassId) as ClassDumpRecord
+
+      val staticFieldNames = classRecord.staticFields.map {
+        hprofStringById(it.nameStringId)
+      }
+
+      val fieldNames = classRecord.fields.map {
+        hprofStringById(it.nameStringId)
+      }
+
+      val className = className(currentClassId)
+
+      classHierarchy.add(
+          HydratedClass(
+              classRecord, className, staticFieldNames, fieldNames
+          )
+      )
+      currentClassId = classRecord.superClassId
+    } while (currentClassId != 0L)
+    return classHierarchy
+  }
+
+  /**
+   * Note: it's reasonable to call this repeatedly, there will be no disk reads as long as
+   * the classes are in the [objectCache] LruCache
+   */
+  fun hydrateInstance(instanceRecord: InstanceDumpRecord): HydratedInstance {
+    val classHierarchy = hydrateClassHierarchy(instanceRecord.classId)
+
+    val buffer = Buffer()
+    buffer.write(instanceRecord.fieldValues)
+    val valuesReader = HprofReader(buffer, 0, reader.idSize)
+
+    val allFieldValues = classHierarchy.map { hydratedClass ->
+      hydratedClass.record.fields.map { field -> valuesReader.readValue(field.type) }
+    }
+
+    return HydratedInstance(instanceRecord, classHierarchy, allFieldValues)
+  }
+
+  fun instanceAsString(instance: HydratedInstance): String {
+    val count = instance.fieldValue<IntValue>("count")
+        .value
+
+    if (count == 0) {
+      return ""
+    }
+
+    val value = instance.fieldValue<ObjectReference>("value")
+
+    // Prior to API 26 String.value was a char array.
+    // Since API 26 String.value is backed by native code. The vast majority of strings in a
+    // heap dump are backed by a byte array, but we still find a few backed by a char array.
+    when (val valueRecord = retrieveRecord(value)) {
+      is CharArrayDump -> {
+        var offset = 0
+
+        // < API 23
+        // As of Marshmallow, substrings no longer share their parent strings' char arrays
+        // eliminating the need for String.offset
+        // https://android-review.googlesource.com/#/c/83611/
+        val offsetValue = instance.fieldValueOrNull<IntValue>("offset")
+        if (offsetValue != null) {
+          offset = offsetValue.value
+        }
+
+        val chars = valueRecord.array.copyOfRange(offset, offset + count)
+        return String(chars)
+      }
+      is ByteArrayDump -> {
+        return String(valueRecord.array, Charset.forName("UTF-8"))
+      }
+      else -> throw UnsupportedOperationException(
+          "'value' field was expected to be either a char or byte array in string instance with id ${instance.record.id}"
+      )
+    }
+  }
+
+  companion object {
+    const val STRING_IN_UTF8 = 0x01
+    const val LOAD_CLASS = 0x02
+    const val UNLOAD_CLASS = 0x03
+    // TODO Maybe parse this?
+    const val STACK_FRAME = 0x04
+    const val STACK_TRACE = 0x05
+    const val ALLOC_SITES = 0x06
+    const val HEAP_SUMMARY = 0x07
+    // TODO Maybe parse this?
+    const val START_THREAD = 0x0a
+    const val END_THREAD = 0x0b
+    const val HEAP_DUMP = 0x0c
+    const val HEAP_DUMP_SEGMENT = 0x1c
+
+    const val HEAP_DUMP_END = 0x2c
+
+    const val CPU_SAMPLES = 0x0d
+
+    const val CONTROL_SETTINGS = 0x0e
+
+    const val ROOT_UNKNOWN = 0xff
+
+    const val ROOT_JNI_GLOBAL = 0x01
+
+    const val ROOT_JNI_LOCAL = 0x02
+
+    const val ROOT_JAVA_FRAME = 0x03
+
+    const val ROOT_NATIVE_STACK = 0x04
+
+    const val ROOT_STICKY_CLASS = 0x05
+
+    const val ROOT_THREAD_BLOCK = 0x06
+
+    const val ROOT_MONITOR_USED = 0x07
+
+    const val ROOT_THREAD_OBJECT = 0x08
+
+    const val CLASS_DUMP = 0x20
+
+    const val INSTANCE_DUMP = 0x21
+
+    const val OBJECT_ARRAY_DUMP = 0x22
+
+    const val PRIMITIVE_ARRAY_DUMP = 0x23
+
+    /**
+     * Android format addition
+     *
+     * Specifies information about which heap certain objects came from. When a sub-tag of this type
+     * appears in a HPROF_HEAP_DUMP or HPROF_HEAP_DUMP_SEGMENT record, entries that follow it will
+     * be associated with the specified heap.  The HEAP_DUMP_INFO data is reset at the end of the
+     * HEAP_DUMP[_SEGMENT].  Multiple HEAP_DUMP_INFO entries may appear in a single
+     * HEAP_DUMP[_SEGMENT].
+     *
+     * Format: u1: Tag value (0xFE) u4: heap ID ID: heap name string ID
+     */
+    const val HEAP_DUMP_INFO = 0xfe
+
+    const val ROOT_INTERNED_STRING = 0x89
+
+    const val ROOT_FINALIZING = 0x8a
+
+    const val ROOT_DEBUGGER = 0x8b
+
+    const val ROOT_REFERENCE_CLEANUP = 0x8c
+
+    const val ROOT_VM_INTERNAL = 0x8d
+
+    const val ROOT_JNI_MONITOR = 0x8e
+
+    const val ROOT_UNREACHABLE = 0x90
+
+    const val PRIMITIVE_ARRAY_NODATA = 0xc3
+
+    const val BITS_FOR_FILE_POSITION = 29
+    private val MAX_HEAP_DUMP_SIZE = 2.toFloat()
+        .pow(BITS_FOR_FILE_POSITION)
+        .toInt()
+
+    private val PRIMITIVE_WRAPPER_TYPES = setOf<String>(
+        Boolean::class.java.name, Char::class.java.name, Float::class.java.name,
+        Double::class.java.name, Byte::class.java.name, Short::class.java.name,
+        Int::class.java.name, Long::class.java.name
+    )
+
+    fun open(heapDump: File): HprofParser {
+      if (heapDump.length() > MAX_HEAP_DUMP_SIZE) {
+        throw IllegalArgumentException(
+            "Heap dump file length is ${heapDump.length()} bytes which is more than the max supported $MAX_HEAP_DUMP_SIZE"
+        )
+      }
+      val inputStream = heapDump.inputStream()
+      val channel = inputStream.channel
+      val source = inputStream.source()
+          .buffer()
+
+      val endOfVersionString = source.indexOf(0)
+      source.skip(endOfVersionString + 1)
+      val idSize = source.readInt()
+      val startPosition = endOfVersionString + 1 + 4
+
+      val hprofReader = SeekableHprofReader(channel, source, startPosition, idSize)
+      return HprofParser(hprofReader)
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt b/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt
new file mode 100644
index 00000000..e949e20b
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt
@@ -0,0 +1,363 @@
+package leakcanary
+
+import leakcanary.HeapValue.BooleanValue
+import leakcanary.HeapValue.ByteValue
+import leakcanary.HeapValue.CharValue
+import leakcanary.HeapValue.DoubleValue
+import leakcanary.HeapValue.FloatValue
+import leakcanary.HeapValue.IntValue
+import leakcanary.HeapValue.LongValue
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.HeapValue.ShortValue
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import okio.BufferedSource
+import java.io.Closeable
+import java.nio.charset.Charset
+
+/**
+ * Not thread safe, should be used from a single thread.
+ */
+open class HprofReader constructor(
+  protected var source: BufferedSource,
+  protected val startPosition: Long,
+  val idSize: Int
+) : Closeable {
+
+  var position: Long = startPosition
+    protected set
+
+  val isOpen
+    get() = source.isOpen
+
+  private val typeSizes = mapOf(
+      // object
+      OBJECT_TYPE to idSize,
+      BOOLEAN_TYPE to BOOLEAN_SIZE,
+      CHAR_TYPE to CHAR_SIZE,
+      FLOAT_TYPE to FLOAT_SIZE,
+      DOUBLE_TYPE to DOUBLE_SIZE,
+      BYTE_TYPE to BYTE_SIZE,
+      SHORT_TYPE to SHORT_SIZE,
+      INT_TYPE to INT_SIZE,
+      LONG_TYPE to LONG_SIZE
+  )
+
+  fun readValue(type: Int): HeapValue {
+    return when (type) {
+      OBJECT_TYPE -> ObjectReference(readId())
+      BOOLEAN_TYPE -> BooleanValue(readBoolean())
+      CHAR_TYPE -> CharValue(readChar())
+      FLOAT_TYPE -> FloatValue(readFloat())
+      DOUBLE_TYPE -> DoubleValue(readDouble())
+      BYTE_TYPE -> ByteValue(readByte())
+      SHORT_TYPE -> ShortValue(readShort())
+      INT_TYPE -> IntValue(readInt())
+      LONG_TYPE -> LongValue(readLong())
+      else -> throw IllegalStateException("Unknown type $type")
+    }
+  }
+
+  fun typeSize(type: Int): Int {
+    return typeSizes.getValue(type)
+  }
+
+  fun readShort(): Short {
+    position += SHORT_SIZE
+    return source.readShort()
+  }
+
+  fun readInt(): Int {
+    position += INT_SIZE
+    return source.readInt()
+  }
+
+  fun readIdArray(arrayLength: Int): LongArray {
+    return LongArray(arrayLength) { readId() }
+  }
+
+  fun readBooleanArray(arrayLength: Int): BooleanArray {
+    return BooleanArray(arrayLength) { readByte().toInt() != 0 }
+  }
+
+  fun readCharArray(arrayLength: Int): CharArray {
+    return readString(CHAR_SIZE * arrayLength, Charsets.UTF_16BE).toCharArray()
+  }
+
+  fun readString(
+    byteCount: Int,
+    charset: Charset
+  ): String {
+    position += byteCount
+    return source.readString(byteCount.toLong(), charset)
+  }
+
+  fun readFloatArray(arrayLength: Int): FloatArray {
+    return FloatArray(arrayLength) { readFloat() }
+  }
+
+  fun readDoubleArray(arrayLength: Int): DoubleArray {
+    return DoubleArray(arrayLength) { readDouble() }
+  }
+
+  fun readShortArray(arrayLength: Int): ShortArray {
+    return ShortArray(arrayLength) { readShort() }
+  }
+
+  fun readIntArray(arrayLength: Int): IntArray {
+    return IntArray(arrayLength) { readInt() }
+  }
+
+  fun readLongArray(arrayLength: Int): LongArray {
+    return LongArray(arrayLength) { readLong() }
+  }
+
+  fun readLong(): Long {
+    position += LONG_SIZE
+    return source.readLong()
+  }
+
+  fun exhausted() = source.exhausted()
+
+  open fun skip(byteCount: Long) {
+    position += byteCount
+    return source.skip(byteCount)
+  }
+
+  fun readByte(): Byte {
+    position += BYTE_SIZE
+    return source.readByte()
+  }
+
+  fun readBoolean(): Boolean {
+    position += BOOLEAN_SIZE
+    return source.readByte().toInt() != 0
+  }
+
+  fun readByteArray(byteCount: Int): ByteArray {
+    position += byteCount
+    return source.readByteArray(byteCount.toLong())
+  }
+
+  fun readChar(): Char {
+    return readString(CHAR_SIZE, Charsets.UTF_16BE)[0]
+  }
+
+  fun readFloat(): Float {
+    return Float.fromBits(readInt())
+  }
+
+  fun readDouble(): Double {
+    return Double.fromBits(readLong())
+  }
+
+  fun readId(): Long {
+    // As long as we don't interpret IDs, reading signed values here is fine.
+    return when (idSize) {
+      1 -> readByte().toLong()
+      2 -> readShort().toLong()
+      4 -> readInt().toLong()
+      8 -> readLong()
+      else -> throw IllegalArgumentException("ID Length must be 1, 2, 4, or 8")
+    }
+  }
+
+  fun readUtf8(byteCount: Long): String {
+    position += byteCount
+    return source.readUtf8(byteCount)
+  }
+
+  fun readUnsignedInt(): Long {
+    return readInt().toLong() and INT_MASK
+  }
+
+  fun readUnsignedByte(): Int {
+    return readByte().toInt() and BYTE_MASK
+  }
+
+  fun readUnsignedShort(): Int {
+    return readShort().toInt() and 0xFFFF
+  }
+
+  fun skip(byteCount: Int) {
+    position += byteCount
+    return source.skip(byteCount.toLong())
+  }
+
+  override fun close() {
+    source.close()
+  }
+
+  fun readInstanceDumpRecord(
+    id: Long
+  ): InstanceDumpRecord {
+    val stackTraceSerialNumber = readInt()
+    val classId = readId()
+    val remainingBytesInInstance = readInt()
+    val fieldValues = readByteArray(remainingBytesInInstance)
+
+    return InstanceDumpRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        classId = classId,
+        fieldValues = fieldValues
+    )
+  }
+
+  fun readClassDumpRecord(
+    id: Long
+  ): ClassDumpRecord {
+    // stack trace serial number
+    val stackTraceSerialNumber = readInt()
+    val superClassId = readId()
+    // class loader object ID
+    val classLoaderId = readId()
+    // signers object ID
+    val signersId = readId()
+    // protection domain object ID
+    val protectionDomainId = readId()
+    // reserved
+    readId()
+    // reserved
+    readId()
+
+    // instance size (in bytes)
+    // Useful to compute retained size
+    val instanceSize = readInt()
+
+    // Skip over the constant pool
+    val constantPoolCount = readUnsignedShort()
+    for (i in 0 until constantPoolCount) {
+      // constant pool index
+      skip(SHORT_SIZE)
+      skip(typeSize(readUnsignedByte()))
+    }
+
+    val staticFieldCount = readUnsignedShort()
+    val staticFields = ArrayList<StaticFieldRecord>(staticFieldCount)
+    for (i in 0 until staticFieldCount) {
+
+      val nameStringId = readId()
+      val type = readUnsignedByte()
+      val value = readValue(type)
+
+      staticFields.add(
+          StaticFieldRecord(
+              nameStringId = nameStringId,
+              type = type,
+              value = value
+          )
+      )
+    }
+
+    val fieldCount = readUnsignedShort()
+    val fields = ArrayList<FieldRecord>(fieldCount)
+    for (i in 0 until fieldCount) {
+      fields.add(FieldRecord(nameStringId = readId(), type = readUnsignedByte()))
+    }
+
+    return ClassDumpRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        superClassId = superClassId,
+        classLoaderId = classLoaderId,
+        signersId = signersId,
+        protectionDomainId = protectionDomainId,
+        instanceSize = instanceSize,
+        staticFields = staticFields,
+        fields = fields
+    )
+  }
+
+  fun readObjectArrayDumpRecord(
+    id: Long
+  ): ObjectArrayDumpRecord {
+    // stack trace serial number
+    val stackTraceSerialNumber = readInt()
+    val arrayLength = readInt()
+    val arrayClassId = readId()
+    val elementIds = readIdArray(arrayLength)
+    return ObjectArrayDumpRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        arrayClassId = arrayClassId,
+        elementIds = elementIds
+    )
+  }
+
+  fun readPrimitiveArrayDumpRecord(
+    id: Long
+  ): PrimitiveArrayDumpRecord {
+    val stackTraceSerialNumber = readInt()
+    // length
+    val arrayLength = readInt()
+    val type = readUnsignedByte()
+    return when (type) {
+      BOOLEAN_TYPE -> BooleanArrayDump(
+          id, stackTraceSerialNumber, readBooleanArray(arrayLength)
+      )
+      CHAR_TYPE -> CharArrayDump(
+          id, stackTraceSerialNumber, readCharArray(arrayLength)
+      )
+      FLOAT_TYPE -> FloatArrayDump(
+          id, stackTraceSerialNumber, readFloatArray(arrayLength)
+      )
+      DOUBLE_TYPE -> DoubleArrayDump(
+          id, stackTraceSerialNumber, readDoubleArray(arrayLength)
+      )
+      BYTE_TYPE -> ByteArrayDump(
+          id, stackTraceSerialNumber, readByteArray(arrayLength)
+      )
+      SHORT_TYPE -> ShortArrayDump(
+          id, stackTraceSerialNumber, readShortArray(arrayLength)
+      )
+      INT_TYPE -> IntArrayDump(
+          id, stackTraceSerialNumber, readIntArray(arrayLength)
+      )
+      LONG_TYPE -> LongArrayDump(
+          id, stackTraceSerialNumber, readLongArray(arrayLength)
+      )
+      else -> throw IllegalStateException("Unexpected type $type")
+    }
+  }
+
+  val tagPositionAfterReadingId
+    get() = position - (idSize + BYTE_SIZE)
+
+  companion object {
+    const val BOOLEAN_SIZE = 1
+    const val CHAR_SIZE = 2
+    const val FLOAT_SIZE = 4
+    const val DOUBLE_SIZE = 8
+    const val BYTE_SIZE = 1
+    const val SHORT_SIZE = 2
+    const val INT_SIZE = 4
+    const val LONG_SIZE = 8
+
+    const val OBJECT_TYPE = 2
+    const val BOOLEAN_TYPE = 4
+    const val CHAR_TYPE = 5
+    const val FLOAT_TYPE = 6
+    const val DOUBLE_TYPE = 7
+    const val BYTE_TYPE = 8
+    const val SHORT_TYPE = 9
+    const val INT_TYPE = 10
+    const val LONG_TYPE = 11
+
+    const val INT_MASK = 0xffffffffL
+    const val BYTE_MASK = 0xff
+  }
+
+}
diff --git a/leakcanary-haha/src/main/java/leakcanary/HydratedClass.kt b/leakcanary-haha/src/main/java/leakcanary/HydratedClass.kt
new file mode 100644
index 00000000..383ed5c8
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/HydratedClass.kt
@@ -0,0 +1,46 @@
+package leakcanary
+
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+
+class HydratedClass(
+  val record: ClassDumpRecord,
+  val className: String,
+  val staticFieldNames: List<String>,
+  val fieldNames: List<String>
+) {
+  fun <T : HeapValue> staticFieldValue(name: String): T {
+    return staticFieldValueOrNull(name) ?: throw IllegalArgumentException(
+        "Could not find static field $name in class $className with id ${record.id} and static fields $staticFieldNames"
+    )
+  }
+
+  fun fieldType(name: String): Int {
+    fieldNames.forEachIndexed { index, fieldName ->
+      if (fieldName == name) {
+        return record.fields[index].type
+      }
+    }
+    throw IllegalArgumentException(
+        "Could not find field $name in class $className with id ${record.id} and fields $fieldNames"
+    )
+  }
+
+  fun <T : HeapValue> staticFieldValueOrNull(name: String): T? {
+    staticFieldNames.forEachIndexed { fieldIndex, fieldName ->
+      if (fieldName == name) {
+        @Suppress("UNCHECKED_CAST")
+        return record.staticFields[fieldIndex].value as T
+      }
+    }
+    return null
+  }
+
+  fun hasStaticField(name: String): Boolean {
+    staticFieldNames.forEach { fieldName ->
+      if (fieldName == name) {
+        return true
+      }
+    }
+    return false
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HydratedInstance.kt b/leakcanary-haha/src/main/java/leakcanary/HydratedInstance.kt
new file mode 100644
index 00000000..a87c2a0e
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/HydratedInstance.kt
@@ -0,0 +1,45 @@
+package leakcanary
+
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+
+class HydratedInstance(
+  val record: InstanceDumpRecord,
+  val classHierarchy: List<HydratedClass>,
+  /**
+   * One list of field values per class
+   */
+  val fieldValues: List<List<HeapValue>>
+) {
+  fun <T : HeapValue> fieldValue(name: String): T {
+    return fieldValueOrNull(name) ?: throw IllegalArgumentException(
+        "Could not find field $name in instance with id ${record.id}"
+    )
+  }
+
+  fun <T : HeapValue> fieldValueOrNull(name: String): T? {
+    classHierarchy.forEachIndexed { classIndex, hydratedClass ->
+      hydratedClass.fieldNames.forEachIndexed { fieldIndex, fieldName ->
+        if (fieldName == name) {
+          @Suppress("UNCHECKED_CAST")
+          return fieldValues[classIndex][fieldIndex] as T
+        }
+      }
+    }
+    return null
+  }
+
+  fun hasField(name: String): Boolean {
+    classHierarchy.forEach { hydratedClass ->
+      hydratedClass.fieldNames.forEach { fieldName ->
+        if (fieldName == name) {
+          return true
+        }
+      }
+    }
+    return false
+  }
+
+  fun isInstanceOf(className: String): Boolean {
+    return classHierarchy.any { it.className == className }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/ObjectIdMetadata.kt b/leakcanary-haha/src/main/java/leakcanary/ObjectIdMetadata.kt
new file mode 100644
index 00000000..265a989b
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/ObjectIdMetadata.kt
@@ -0,0 +1,50 @@
+package leakcanary
+
+import leakcanary.HprofParser.Companion.BITS_FOR_FILE_POSITION
+
+enum class ObjectIdMetadata {
+  PRIMITIVE_WRAPPER,
+  PRIMITIVE_ARRAY_OR_WRAPPER_ARRAY,
+  OBJECT_ARRAY,
+  /**
+   * An [INSTANCE] of the String class.
+   */
+  STRING,
+  INSTANCE,
+  CLASS,
+  /**
+   * An [INSTANCE] with 0 bytes of field values, which therefore has no fields that
+   * could reference other instances.
+   */
+  EMPTY_INSTANCE,
+  /**
+   * An [INSTANCE] with N + 4 bytes of field values, where N is the size of an object id.
+   * Art updated the Object class with two fields: shadow$_klass_ (pointer to a class, N bytes) and
+   * shadow$_monitor_ (Int, 4 bytes). As a empty instances still have at list N + 4 bytes of field
+   * values. The size of the Object class fields is discovered after we've already parsed some
+   * objects so we have to store this separately from [EMPTY_INSTANCE] and check later.
+   */
+  INTERNAL_MAYBE_EMPTY_INSTANCE
+  ;
+
+  fun packOrdinalWithFilePosition(filePosition: Long): Int {
+    val shiftedOrdinal = ordinal shl BITS_FOR_FILE_POSITION
+    return shiftedOrdinal or filePosition.toInt()
+  }
+
+  companion object {
+    init {
+      require(values().size <= 8) {
+        "ObjectIdMetadata is packed as 3 bits in an int, it can only have up to 8 values, not ${values().size}"
+      }
+    }
+
+    fun unpackMetadataAndPosition(packedInt: Int): Pair<ObjectIdMetadata, Long> {
+      val unpackedOrdinal = (packedInt shr BITS_FOR_FILE_POSITION) and 7
+      // 2^BITS_FOR_FILE_POSITION - 1
+      val unpackedPosition = packedInt and 536870911
+
+      return values()[unpackedOrdinal] to unpackedPosition.toLong()
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/Record.kt b/leakcanary-haha/src/main/java/leakcanary/Record.kt
new file mode 100644
index 00000000..250eb44f
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/Record.kt
@@ -0,0 +1,132 @@
+package leakcanary
+
+sealed class Record {
+  class StringRecord(
+    val id: Long,
+    val string: String
+  ) : Record()
+
+  class LoadClassRecord(
+    val classSerialNumber: Int,
+    val id: Long,
+    val stackTraceSerialNumber: Int,
+    val classNameStringId: Long
+  ) : Record()
+
+  object HeapDumpEndRecord : Record()
+
+  class StackTraceRecord(
+    val stackTraceSerialNumber: Int,
+    val threadSerialNumber: Int,
+    val stackFrameIds: LongArray
+  ) : Record()
+
+  sealed class HeapDumpRecord : Record() {
+    class GcRootRecord(
+      val gcRoot: GcRoot
+    ) : HeapDumpRecord()
+
+    sealed class ObjectRecord : HeapDumpRecord() {
+      class ClassDumpRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val superClassId: Long,
+        val classLoaderId: Long,
+        val signersId: Long,
+        val protectionDomainId: Long,
+        val instanceSize: Int,
+        val staticFields: List<StaticFieldRecord>,
+        val fields: List<FieldRecord>
+      ) : ObjectRecord() {
+        data class StaticFieldRecord(
+          val nameStringId: Long,
+          val type: Int,
+          val value: HeapValue
+        )
+
+        data class FieldRecord(
+          val nameStringId: Long,
+          val type: Int
+        )
+      }
+
+      class InstanceDumpRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val classId: Long,
+        val fieldValues: ByteArray
+      ) : ObjectRecord()
+
+      class ObjectArrayDumpRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val arrayClassId: Long,
+        val elementIds: LongArray
+      ) : ObjectRecord()
+
+      /**
+       * Note: we could move the arrays to the parent class as a ByteString or ByteArray
+       * and then each subtype can create a new array of the right type if needed.
+       * However, experimenting with live parsing has shown that we never to read arrays except
+       * when we want to display leak trace information, in which case we do need the data.
+       */
+      sealed class PrimitiveArrayDumpRecord : ObjectRecord() {
+        abstract val id: Long
+        abstract val stackTraceSerialNumber: Int
+
+        class BooleanArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: BooleanArray
+        ) : PrimitiveArrayDumpRecord()
+
+        class CharArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: CharArray
+        ) : PrimitiveArrayDumpRecord()
+
+        class FloatArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: FloatArray
+        ) : PrimitiveArrayDumpRecord()
+
+        class DoubleArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: DoubleArray
+        ) : PrimitiveArrayDumpRecord()
+
+        class ByteArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: ByteArray
+        ) : PrimitiveArrayDumpRecord()
+
+        class ShortArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: ShortArray
+        ) : PrimitiveArrayDumpRecord()
+
+        class IntArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: IntArray
+        ) : PrimitiveArrayDumpRecord()
+
+        class LongArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: LongArray
+        ) : PrimitiveArrayDumpRecord()
+      }
+    }
+
+    class HeapDumpInfoRecord(
+      val heapId: Int,
+      val heapNameStringId: Long
+    ) : HeapDumpRecord()
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt b/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt
new file mode 100644
index 00000000..d5ec5a22
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt
@@ -0,0 +1,25 @@
+package leakcanary
+
+import okio.BufferedSource
+import java.nio.channels.FileChannel
+
+class SeekableHprofReader(
+  private val channel: FileChannel,
+  source: BufferedSource,
+  startPosition: Long,
+  idSize: Int
+) : HprofReader(source, startPosition, idSize) {
+
+  fun moveTo(newPosition: Long) {
+    if (position == newPosition) {
+      return
+    }
+    source.buffer.clear()
+    channel.position(newPosition)
+    position = newPosition
+  }
+
+  fun reset() {
+    moveTo(startPosition)
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToIntSparseArray.kt b/leakcanary-haha/src/main/java/leakcanary/internal/LongToIntSparseArray.kt
new file mode 100644
index 00000000..58bd3923
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/LongToIntSparseArray.kt
@@ -0,0 +1,107 @@
+package leakcanary.internal
+
+import leakcanary.internal.SparseArrayUtils.appendInt
+import leakcanary.internal.SparseArrayUtils.appendLong
+import leakcanary.internal.SparseArrayUtils.binarySearch
+import leakcanary.internal.SparseArrayUtils.insertInt
+import leakcanary.internal.SparseArrayUtils.insertLong
+
+/**
+ * Same as [LongToLongSparseArray] but long to int instead.
+ */
+internal class LongToIntSparseArray(initialCapacity: Int) : Cloneable {
+  private var keys: LongArray
+  private var values: IntArray
+
+  var size: Int = 0
+    private set
+
+  init {
+    keys = LongArray(initialCapacity)
+    values = IntArray(initialCapacity)
+    size = 0
+  }
+
+  operator fun get(key: Long): Int {
+    val i = binarySearch(keys, size, key)
+
+    return if (i < 0 || values[i] == DELETED_INT) {
+      DELETED_INT
+    } else {
+      values[i]
+    }
+  }
+
+  operator fun set(
+    key: Long,
+    value: Int
+  ) {
+    require(value != DELETED_INT) {
+      "$DELETED_INT is a magic value that indicates a deleted entry"
+    }
+
+    if (size != 0 && key <= keys[size - 1]) {
+      insert(key, value)
+      return
+    }
+
+    keys = appendLong(keys, size, key)
+    values = appendInt(values, size, value)
+    size++
+  }
+
+  fun compact() {
+    val initialSize = size
+    var compactedSize = 0
+    val keys = keys
+    val values = values
+    for (i in 0 until initialSize) {
+      val value = values[i]
+      if (value != DELETED_INT) {
+        if (i != compactedSize) {
+          keys[compactedSize] = keys[i]
+          values[compactedSize] = value
+          values[i] = DELETED_INT
+        }
+        compactedSize++
+      }
+    }
+    if (compactedSize != initialSize) {
+      size = compactedSize
+      this.keys = LongArray(compactedSize)
+      System.arraycopy(keys, 0, this.keys, 0, compactedSize)
+      this.values = IntArray(compactedSize)
+      System.arraycopy(values, 0, this.values, 0, compactedSize)
+    }
+  }
+
+  private fun insert(
+    key: Long,
+    value: Int
+  ) {
+    if (value == DELETED_INT) {
+      throw IllegalArgumentException("$DELETED_INT is a special value")
+    }
+    var i = binarySearch(keys, size, key)
+
+    if (i >= 0) {
+      values[i] = value
+    } else {
+      i = i.inv()
+
+      if (i < size && values[i] == DELETED_INT) {
+        keys[i] = key
+        values[i] = value
+        return
+      }
+
+      keys = insertLong(keys, size, i, key)
+      values = insertInt(values, size, i, value)
+      size++
+    }
+  }
+
+  companion object {
+    private const val DELETED_INT = 0
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToLongSparseArray.kt b/leakcanary-haha/src/main/java/leakcanary/internal/LongToLongSparseArray.kt
new file mode 100644
index 00000000..80bfef0f
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/LongToLongSparseArray.kt
@@ -0,0 +1,109 @@
+package leakcanary.internal
+
+import leakcanary.internal.SparseArrayUtils.appendLong
+import leakcanary.internal.SparseArrayUtils.binarySearch
+import leakcanary.internal.SparseArrayUtils.insertLong
+
+/**
+ * Based on android.util.LongSparseArray, but with several tweaks:
+ *
+ * - Values array is a LongArray
+ * - No compaction, ever. This object can only keep growing, until it is garbage collected. Note
+ * that there is no remove() method.
+ */
+internal class LongToLongSparseArray(initialCapacity: Int) : Cloneable {
+  private var keys: LongArray
+  private var values: LongArray
+
+  var size: Int = 0
+    private set
+
+  init {
+    keys = LongArray(initialCapacity)
+    values = LongArray(initialCapacity)
+    size = 0
+  }
+
+  operator fun get(key: Long): Long {
+    val i = binarySearch(keys, size, key)
+
+    return if (i < 0 || values[i] == DELETED_LONG) {
+      DELETED_LONG
+    } else {
+      values[i]
+    }
+  }
+
+  operator fun set(
+    key: Long,
+    value: Long
+  ) {
+    require(value != DELETED_LONG) {
+      "$DELETED_LONG is a magic value that indicates a deleted entry"
+    }
+
+    if (size != 0 && key <= keys[size - 1]) {
+      insert(key, value)
+      return
+    }
+
+    keys = appendLong(keys, size, key)
+    values = appendLong(values, size, value)
+    size++
+  }
+
+  fun compact() {
+    val initialSize = size
+    var compactedSize = 0
+    val keys = keys
+    val values = values
+    for (i in 0 until initialSize) {
+      val value = values[i]
+      if (value != DELETED_LONG) {
+        if (i != compactedSize) {
+          keys[compactedSize] = keys[i]
+          values[compactedSize] = value
+          values[i] = DELETED_LONG
+        }
+        compactedSize++
+      }
+    }
+    if (compactedSize != initialSize) {
+      size = compactedSize
+      this.keys = LongArray(compactedSize)
+      System.arraycopy(keys, 0, this.keys, 0, compactedSize)
+      this.values = LongArray(compactedSize)
+      System.arraycopy(values, 0, this.values, 0, compactedSize)
+    }
+  }
+
+  private fun insert(
+    key: Long,
+    value: Long
+  ) {
+    if (value == DELETED_LONG) {
+      throw IllegalArgumentException("$DELETED_LONG is a special value")
+    }
+    var i = binarySearch(keys, size, key)
+
+    if (i >= 0) {
+      values[i] = value
+    } else {
+      i = i.inv()
+
+      if (i < size && values[i] == DELETED_LONG) {
+        keys[i] = key
+        values[i] = value
+        return
+      }
+
+      keys = insertLong(keys, size, i, key)
+      values = insertLong(values, size, i, value)
+      size++
+    }
+  }
+
+  companion object {
+    private const val DELETED_LONG: Long = 0
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToStringSparseArray.kt b/leakcanary-haha/src/main/java/leakcanary/internal/LongToStringSparseArray.kt
new file mode 100644
index 00000000..49392a67
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/LongToStringSparseArray.kt
@@ -0,0 +1,105 @@
+package leakcanary.internal
+
+import leakcanary.internal.SparseArrayUtils.DELETED_STRING
+import leakcanary.internal.SparseArrayUtils.FILL_WITH_DELETED
+import leakcanary.internal.SparseArrayUtils.appendLong
+import leakcanary.internal.SparseArrayUtils.appendString
+import leakcanary.internal.SparseArrayUtils.binarySearch
+import leakcanary.internal.SparseArrayUtils.insertLong
+import leakcanary.internal.SparseArrayUtils.insertString
+
+/**
+ * Same as [LongToLongSparseArray] but long to string instead.
+ */
+internal class LongToStringSparseArray(initialCapacity: Int) : Cloneable {
+  private var keys: LongArray
+  private var values: Array<String?>
+
+  var size: Int = 0
+    private set
+
+  init {
+    keys = LongArray(initialCapacity)
+    values = Array(initialCapacity, FILL_WITH_DELETED)
+    size = 0
+  }
+
+  operator fun get(key: Long): String? {
+    val i = binarySearch(keys, size, key)
+
+    return if (i < 0 || values[i] == DELETED_STRING) {
+      DELETED_STRING
+    } else {
+      values[i]
+    }
+  }
+
+  fun compact() {
+    val initialSize = size
+    var compactedSize = 0
+    val keys = keys
+    val values = values
+    for (i in 0 until initialSize) {
+      val value = values[i]
+      if (value != DELETED_STRING) {
+        if (i != compactedSize) {
+          keys[compactedSize] = keys[i]
+          values[compactedSize] = value
+          values[i] = DELETED_STRING
+        }
+        compactedSize++
+      }
+    }
+    if (compactedSize != initialSize) {
+      size = compactedSize
+      this.keys = LongArray(compactedSize)
+      System.arraycopy(keys, 0, this.keys, 0, compactedSize)
+      this.values = Array(compactedSize, FILL_WITH_DELETED)
+      System.arraycopy(values, 0, this.values, 0, compactedSize)
+    }
+  }
+
+  operator fun set(
+    key: Long,
+    value: String
+  ) {
+    if (size != 0 && key <= keys[size - 1]) {
+      insert(key, value)
+      return
+    }
+
+    keys = appendLong(keys, size, key)
+    values = appendString(values, size, value)
+    size++
+  }
+
+  private fun insert(
+    key: Long,
+    value: String
+  ) {
+    if (value == DELETED_STRING) {
+      throw IllegalArgumentException("$DELETED_STRING is a special value")
+    }
+    var i = binarySearch(keys, size, key)
+
+    if (i >= 0) {
+      values[i] = value
+    } else {
+      i = i.inv()
+
+      if (i < size && values[i] == DELETED_STRING) {
+        keys[i] = key
+        values[i] = value
+        return
+      }
+
+      keys = insertLong(keys, size, i, key)
+      values = insertString(values, size, i, value)
+      size++
+    }
+  }
+
+  companion object {
+
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LruCache.kt b/leakcanary-haha/src/main/java/leakcanary/internal/LruCache.kt
new file mode 100644
index 00000000..46d81d9b
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/LruCache.kt
@@ -0,0 +1,77 @@
+package leakcanary.internal
+
+import java.util.LinkedHashMap
+import kotlin.collections.MutableMap.MutableEntry
+
+/**
+ * API is a simplified version of android.util.LruCache
+ * Implementation is inspired from http://chriswu.me/blog/a-lru-cache-in-10-lines-of-java/
+ */
+internal class LruCache<K, V>(
+  val maxSize: Int
+) {
+  private val cache: LinkedHashMap<K, V>
+
+  val size
+    get() = cache.size
+
+  var putCount: Int = 0
+    private set
+  var evictionCount: Int = 0
+    private set
+  var hitCount: Int = 0
+    private set
+  var missCount: Int = 0
+    private set
+
+  init {
+    require(maxSize > 0) {
+      "maxSize=$maxSize <= 0"
+    }
+    this.cache = object : LinkedHashMap<K, V>(maxSize, 0.75f, true) {
+      override fun removeEldestEntry(eldest: MutableEntry<K, V>?) = if (size >= maxSize) {
+        evictionCount++
+        true
+      } else {
+        false
+      }
+    }
+  }
+
+  operator fun get(key: K?): V? {
+    // get() moves the key to the front
+    val value: V? = cache[key]
+    return if (value != null) {
+      hitCount++
+      value
+    } else {
+      missCount++
+      null
+    }
+  }
+
+  fun put(
+    key: K,
+    value: V
+  ): V? {
+    putCount++
+    return cache.put(key, value)
+  }
+
+  fun remove(key: K): V? {
+    return cache.remove(key)
+  }
+
+  fun evictAll() {
+    cache.clear()
+  }
+
+  override fun toString(): String {
+    val accesses = hitCount + missCount
+    val hitPercent = if (accesses != 0) 100 * hitCount / accesses else 0
+    return String.format(
+        "LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]",
+        maxSize, hitCount, missCount, hitPercent
+    )
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/SparseArrayUtils.kt b/leakcanary-haha/src/main/java/leakcanary/internal/SparseArrayUtils.kt
new file mode 100644
index 00000000..55b3818e
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/SparseArrayUtils.kt
@@ -0,0 +1,156 @@
+package leakcanary.internal
+
+internal object SparseArrayUtils {
+
+  val DELETED_STRING: String? = null
+
+  val FILL_WITH_DELETED: (Int) -> String? = {
+    null
+  }
+
+  fun insertInt(
+    array: IntArray,
+    currentSize: Int,
+    index: Int,
+    element: Int
+  ): IntArray {
+    if (currentSize + 1 <= array.size) {
+      System.arraycopy(array, index, array, index + 1, currentSize - index)
+      array[index] = element
+      return array
+    }
+
+    val newArray = IntArray(growSize(currentSize))
+    System.arraycopy(array, 0, newArray, 0, index)
+    newArray[index] = element
+    System.arraycopy(array, index, newArray, index + 1, array.size - index)
+    return newArray
+  }
+
+  fun insertLong(
+    array: LongArray,
+    currentSize: Int,
+    index: Int,
+    element: Long
+  ): LongArray {
+    if (currentSize + 1 <= array.size) {
+      System.arraycopy(array, index, array, index + 1, currentSize - index)
+      array[index] = element
+      return array
+    }
+
+    val newArray = LongArray(growSize(currentSize))
+    System.arraycopy(array, 0, newArray, 0, index)
+    newArray[index] = element
+    System.arraycopy(array, index, newArray, index + 1, array.size - index)
+    return newArray
+  }
+
+  fun insertString(
+    array: Array<String?>,
+    currentSize: Int,
+    index: Int,
+    element: String?
+  ): Array<String?> {
+    if (currentSize + 1 <= array.size) {
+      System.arraycopy(array, index, array, index + 1, currentSize - index)
+      array[index] = element
+      return array
+    }
+
+    val newArray = Array(growSize(currentSize), FILL_WITH_DELETED)
+    System.arraycopy(array, 0, newArray, 0, index)
+    newArray[index] = element
+    System.arraycopy(array, index, newArray, index + 1, array.size - index)
+    return newArray
+  }
+
+  fun appendByte(
+    array: ByteArray,
+    currentSize: Int,
+    element: Byte
+  ): ByteArray {
+    var returnedArray = array
+
+    if (currentSize + 1 > returnedArray.size) {
+      val newArray = ByteArray(growSize(currentSize))
+      System.arraycopy(returnedArray, 0, newArray, 0, currentSize)
+      returnedArray = newArray
+    }
+    returnedArray[currentSize] = element
+    return returnedArray
+  }
+
+  fun appendInt(
+    array: IntArray,
+    currentSize: Int,
+    element: Int
+  ): IntArray {
+    var returnedArray = array
+    if (currentSize + 1 > returnedArray.size) {
+      val newArray = IntArray(growSize(currentSize))
+      System.arraycopy(returnedArray, 0, newArray, 0, currentSize)
+      returnedArray = newArray
+    }
+    returnedArray[currentSize] = element
+    return returnedArray
+  }
+
+  fun appendLong(
+    array: LongArray,
+    currentSize: Int,
+    element: Long
+  ): LongArray {
+    var returnedArray = array
+    if (currentSize + 1 > returnedArray.size) {
+      val newArray = LongArray(growSize(currentSize))
+      System.arraycopy(returnedArray, 0, newArray, 0, currentSize)
+      returnedArray = newArray
+    }
+    returnedArray[currentSize] = element
+    return returnedArray
+  }
+
+  fun appendString(
+    array: Array<String?>,
+    currentSize: Int,
+    element: String?
+  ): Array<String?> {
+    var returnedArray = array
+    if (currentSize + 1 > returnedArray.size) {
+
+      val newArray = Array(growSize(currentSize), FILL_WITH_DELETED)
+      System.arraycopy(returnedArray, 0, newArray, 0, currentSize)
+      returnedArray = newArray
+    }
+    returnedArray[currentSize] = element
+    return returnedArray
+  }
+
+  /**
+   * Android array helpers use 2. C++ uses 2. ArrayList uses 1.5
+   * We're dealing with large arrays here so being conservative is good for memory.
+   */
+  private fun growSize(currentSize: Int) = (currentSize * 1.5).toInt()
+
+  fun binarySearch(
+    array: LongArray?,
+    size: Int,
+    value: Long
+  ): Int {
+    var lo = 0
+    var hi = size - 1
+
+    while (lo <= hi) {
+      val mid = (lo + hi).ushr(1)
+      val midVal = array!![mid]
+
+      when {
+        midVal < value -> lo = mid + 1
+        midVal > value -> hi = mid - 1
+        else -> return mid  // value found
+      }
+    }
+    return lo.inv()  // value not present
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/build.gradle b/leakcanary-leaksentry/build.gradle
new file mode 100644
index 00000000..dd0f4e90
--- /dev/null
+++ b/leakcanary-leaksentry/build.gradle
@@ -0,0 +1,32 @@
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+
+dependencies {
+  api project(':leakcanary-watcher')
+
+  implementation deps.androidx.core
+  implementation deps.kotlin.stdlib
+  // Optional dependency
+  compileOnly deps.androidx.fragment
+}
+
+android {
+  compileSdkVersion versions.compileSdk
+
+  defaultConfig {
+    minSdkVersion versions.minSdk
+  }
+
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    check 'Interoperability'
+  }
+
+  // TODO replace with https://issuetracker.google.com/issues/72050365 once released.
+  libraryVariants.all {
+    it.generateBuildConfig.enabled = false
+  }
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-leaksentry/gradle.properties b/leakcanary-leaksentry/gradle.properties
new file mode 100644
index 00000000..a0b9bd2c
--- /dev/null
+++ b/leakcanary-leaksentry/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leaksentry
+POM_NAME=LeakSentry
+POM_PACKAGING=aar
diff --git a/leakcanary-analyzer/src/main/AndroidManifest.xml b/leakcanary-leaksentry/src/androidTest/AndroidManifest.xml
similarity index 81%
rename from leakcanary-analyzer/src/main/AndroidManifest.xml
rename to leakcanary-leaksentry/src/androidTest/AndroidManifest.xml
index 3bde165b..d23bb44d 100644
--- a/leakcanary-analyzer/src/main/AndroidManifest.xml
+++ b/leakcanary-leaksentry/src/androidTest/AndroidManifest.xml
@@ -1,5 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
 <!--
-  ~ Copyright (C) 2015 Square, Inc.
+  ~ Copyright (C) 2018 Square, Inc.
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
@@ -14,6 +15,5 @@
   ~ limitations under the License.
   -->
 <manifest
-    package="com.squareup.leakcanary.analyzer">
-  <application/>
+    package="com.squareup.leakcanary.instrumentation.test">
 </manifest>
diff --git a/leakcanary-leaksentry/src/main/AndroidManifest.xml b/leakcanary-leaksentry/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..3b42b180
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/AndroidManifest.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.leakcanary.leaksentry"
+    >
+
+  <application>
+    <provider
+        android:name="leakcanary.internal.LeakSentryInstaller"
+        android:authorities="${applicationId}.leak-sentry-installer"
+        android:exported="false"/>
+  </application>
+</manifest>
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt b/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
new file mode 100644
index 00000000..3fcac6ba
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
@@ -0,0 +1,30 @@
+package leakcanary
+
+import android.app.Application
+import leakcanary.internal.InternalLeakSentry
+import java.util.concurrent.TimeUnit
+
+object LeakSentry {
+
+  data class Config(
+    val watchActivities: Boolean = true,
+    val watchFragments: Boolean = true,
+    val watchFragmentViews: Boolean = true,
+    val watchDurationMillis: Long = TimeUnit.SECONDS.toMillis(5)
+  )
+
+  @Volatile
+  var config: Config = Config()
+
+  val refWatcher
+    get() = InternalLeakSentry.refWatcher
+
+  /**
+   * [LeakSentry] is automatically installed on process start by
+   * [leaksentry.internal.LeakSentryInstaller] which is registered in the AndroidManifest.xml of
+   * your app. If you disabled [leaksentry.internal.LeakSentryInstaller] then you can call this
+   * method to install [LeakSentry].
+   */
+  fun manualInstall(application: Application) = InternalLeakSentry.install(application)
+
+}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
new file mode 100644
index 00000000..d27c0bb7
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.app.Activity
+import android.app.Application
+import leakcanary.RefWatcher
+import leakcanary.LeakSentry.Config
+
+internal class ActivityDestroyWatcher private constructor(
+  private val refWatcher: RefWatcher,
+  private val configProvider: () -> Config
+) {
+
+  private val lifecycleCallbacks = object : ActivityLifecycleCallbacksAdapter() {
+    override fun onActivityDestroyed(activity: Activity) {
+      if (configProvider().watchActivities) {
+        refWatcher.watch(activity)
+      }
+    }
+  }
+
+  companion object {
+    fun install(
+      application: Application,
+      refWatcher: RefWatcher,
+      configProvider: () -> Config
+    ) {
+      val activityDestroyWatcher =
+        ActivityDestroyWatcher(refWatcher, configProvider)
+      application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)
+    }
+  }
+}
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityLifecycleCallbacksAdapter.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityLifecycleCallbacksAdapter.kt
new file mode 100644
index 00000000..25f6f9c6
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityLifecycleCallbacksAdapter.kt
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.app.Activity
+import android.app.Application
+import android.os.Bundle
+
+abstract class ActivityLifecycleCallbacksAdapter : Application.ActivityLifecycleCallbacks {
+  override fun onActivityCreated(
+    activity: Activity,
+    savedInstanceState: Bundle?
+  ) {
+  }
+
+  override fun onActivityStarted(activity: Activity) {}
+
+  override fun onActivityResumed(activity: Activity) {}
+
+  override fun onActivityPaused(activity: Activity) {}
+
+  override fun onActivityStopped(activity: Activity) {}
+
+  override fun onActivitySaveInstanceState(
+    activity: Activity,
+    outState: Bundle
+  ) {
+  }
+
+  override fun onActivityDestroyed(activity: Activity) {}
+}
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
new file mode 100644
index 00000000..62ef6a25
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@file:Suppress("DEPRECATION")
+
+package leakcanary.internal
+
+import android.app.Activity
+import android.app.Fragment
+import android.app.FragmentManager
+import android.os.Build
+import androidx.annotation.RequiresApi
+import leakcanary.RefWatcher
+import leakcanary.LeakSentry.Config
+
+@RequiresApi(Build.VERSION_CODES.O) //
+internal class AndroidOFragmentDestroyWatcher(
+  private val refWatcher: RefWatcher,
+  private val configProvider: () -> Config
+) : FragmentDestroyWatcher {
+
+  private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {
+
+    override fun onFragmentViewDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      val view = fragment.view
+      if (view != null && configProvider().watchFragmentViews) {
+        refWatcher.watch(view)
+      }
+    }
+
+    override fun onFragmentDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      if (configProvider().watchFragments) {
+        refWatcher.watch(fragment)
+      }
+    }
+  }
+
+  override fun watchFragments(activity: Activity) {
+    val fragmentManager = activity.fragmentManager
+    fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)
+  }
+}
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
new file mode 100644
index 00000000..040538dd
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
@@ -0,0 +1,39 @@
+package leakcanary.internal
+
+import android.util.Log
+import leakcanary.CanaryLog.Logger
+
+class DefaultCanaryLog : Logger {
+
+  override fun d(
+    message: String,
+    vararg args: Any?
+  ) {
+    val formatted = if (args.isNotEmpty()) {
+      String.format(message, *args)
+    } else {
+      message
+    }
+    if (formatted.length < 4000) {
+      Log.d("LeakCanary", formatted)
+    } else {
+      val lines = formatted.split("\n".toRegex())
+          .toTypedArray()
+      for (line in lines) {
+        Log.d("LeakCanary", line)
+      }
+    }
+  }
+
+  override fun d(
+    throwable: Throwable?,
+    message: String,
+    vararg args: Any?
+  ) {
+    d(
+        String.format(message, *args) + '\n'.toString() + Log.getStackTraceString(
+            throwable
+        )
+    )
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
new file mode 100644
index 00000000..60a0b662
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.app.Activity
+import android.app.Application
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.O
+import android.os.Bundle
+import leakcanary.RefWatcher
+import leakcanary.LeakSentry
+
+/**
+ * Internal class used to watch for fragments leaks.
+ */
+internal interface FragmentDestroyWatcher {
+
+  fun watchFragments(activity: Activity)
+
+  companion object {
+
+    private const val SUPPORT_FRAGMENT_CLASS_NAME = "androidx.fragment.app.Fragment"
+
+    fun install(
+      application: Application,
+      refWatcher: RefWatcher,
+      configProvider: () -> LeakSentry.Config
+    ) {
+      val fragmentDestroyWatchers = mutableListOf<FragmentDestroyWatcher>()
+
+      if (SDK_INT >= O) {
+        fragmentDestroyWatchers.add(
+            AndroidOFragmentDestroyWatcher(refWatcher, configProvider)
+        )
+      }
+
+      if (classAvailable(
+              SUPPORT_FRAGMENT_CLASS_NAME
+          )
+      ) {
+        fragmentDestroyWatchers.add(
+            SupportFragmentDestroyWatcher(refWatcher, configProvider)
+        )
+      }
+
+      if (fragmentDestroyWatchers.size == 0) {
+        return
+      }
+
+      application.registerActivityLifecycleCallbacks(object : ActivityLifecycleCallbacksAdapter() {
+        override fun onActivityCreated(
+          activity: Activity,
+          savedInstanceState: Bundle?
+        ) {
+          for (watcher in fragmentDestroyWatchers) {
+            watcher.watchFragments(activity)
+          }
+        }
+      })
+    }
+
+    private fun classAvailable(className: String): Boolean {
+      return try {
+        Class.forName(className)
+        true
+      } catch (e: ClassNotFoundException) {
+        false
+      }
+    }
+  }
+}
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
new file mode 100644
index 00000000..c7b1acd7
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
@@ -0,0 +1,71 @@
+package leakcanary.internal
+
+import android.app.Application
+import android.os.Handler
+import android.os.Looper
+import android.os.SystemClock
+import leakcanary.CanaryLog
+import leakcanary.Clock
+import leakcanary.LeakSentry
+import leakcanary.RefWatcher
+import java.util.concurrent.Executor
+
+internal object InternalLeakSentry {
+
+  private val listener: LeakSentryListener
+
+  lateinit var application: Application
+
+  private val clock = object : Clock {
+    override fun uptimeMillis(): Long {
+      return SystemClock.uptimeMillis()
+    }
+  }
+
+  private val mainHandler = Handler(Looper.getMainLooper())
+
+  init {
+    listener = try {
+      val leakCanaryListener = Class.forName("leakcanary.internal.InternalLeakCanary")
+      leakCanaryListener.getDeclaredField("INSTANCE").get(null) as LeakSentryListener
+    } catch (ignored: Throwable) {
+      LeakSentryListener.None
+    }
+  }
+
+  private val checkRetainedExecutor = Executor {
+    mainHandler.postDelayed(it, LeakSentry.config.watchDurationMillis)
+  }
+  val refWatcher = RefWatcher(
+      clock,
+      checkRetainedExecutor
+  ) {
+    listener.onReferenceRetained()
+  }
+
+  fun install(application: Application) {
+    CanaryLog.d("Installing LeakSentry")
+    checkMainThread()
+    if (this::application.isInitialized) {
+      return
+    }
+    InternalLeakSentry.application = application
+
+    val configProvider = { LeakSentry.config }
+    ActivityDestroyWatcher.install(
+        application, refWatcher, configProvider
+    )
+    FragmentDestroyWatcher.install(
+        application, refWatcher, configProvider
+    )
+    listener.onLeakSentryInstalled(application)
+  }
+
+  private fun checkMainThread() {
+    if (Looper.getMainLooper().thread !== Thread.currentThread()) {
+      throw UnsupportedOperationException(
+          "Should be called from the main thread, not ${Thread.currentThread()}"
+      )
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryInstaller.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryInstaller.kt
new file mode 100644
index 00000000..84cf968b
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryInstaller.kt
@@ -0,0 +1,60 @@
+package leakcanary.internal
+
+import android.app.Application
+import android.content.ContentProvider
+import android.content.ContentValues
+import android.database.Cursor
+import android.net.Uri
+import leakcanary.CanaryLog
+
+/**
+ * Content providers are loaded before the application class is created. [LeakSentryInstaller] is
+ * used to install [leaksentry.LeakSentry] on application start.
+ */
+internal class LeakSentryInstaller : ContentProvider() {
+
+  override fun onCreate(): Boolean {
+    CanaryLog.logger = DefaultCanaryLog()
+    val application = context!!.applicationContext as Application
+    InternalLeakSentry.install(application)
+    return true
+  }
+
+  override fun query(
+    uri: Uri,
+    strings: Array<String>?,
+    s: String?,
+    strings1: Array<String>?,
+    s1: String?
+  ): Cursor? {
+    return null
+  }
+
+  override fun getType(uri: Uri): String? {
+    return null
+  }
+
+  override fun insert(
+    uri: Uri,
+    contentValues: ContentValues?
+  ): Uri? {
+    return null
+  }
+
+  override fun delete(
+    uri: Uri,
+    s: String?,
+    strings: Array<String>?
+  ): Int {
+    return 0
+  }
+
+  override fun update(
+    uri: Uri,
+    contentValues: ContentValues?,
+    s: String?,
+    strings: Array<String>?
+  ): Int {
+    return 0
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryListener.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryListener.kt
new file mode 100644
index 00000000..362550b1
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryListener.kt
@@ -0,0 +1,16 @@
+package leakcanary.internal
+
+import android.app.Application
+
+interface LeakSentryListener {
+  fun onLeakSentryInstalled(application: Application)
+  fun onReferenceRetained()
+
+  object None : LeakSentryListener {
+    override fun onLeakSentryInstalled(application: Application) {
+    }
+
+    override fun onReferenceRetained() {
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/SupportFragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/SupportFragmentDestroyWatcher.kt
new file mode 100644
index 00000000..a4fc2f29
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/SupportFragmentDestroyWatcher.kt
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.app.Activity
+import androidx.fragment.app.Fragment
+import androidx.fragment.app.FragmentActivity
+import androidx.fragment.app.FragmentManager
+import leakcanary.RefWatcher
+import leakcanary.LeakSentry.Config
+
+internal class SupportFragmentDestroyWatcher(
+  private val refWatcher: RefWatcher,
+  private val configProvider: () -> Config
+) : FragmentDestroyWatcher {
+
+  private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {
+
+    override fun onFragmentViewDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      val view = fragment.view
+      if (view != null && configProvider().watchFragmentViews) {
+        refWatcher.watch(view)
+      }
+    }
+
+    override fun onFragmentDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      if (configProvider().watchFragments) {
+        refWatcher.watch(fragment)
+      }
+    }
+  }
+
+  override fun watchFragments(activity: Activity) {
+    if (activity is FragmentActivity) {
+      val supportFragmentManager = activity.supportFragmentManager
+      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)
+    }
+  }
+}
diff --git a/leakcanary-log/build.gradle b/leakcanary-log/build.gradle
new file mode 100644
index 00000000..6655f74f
--- /dev/null
+++ b/leakcanary-log/build.gradle
@@ -0,0 +1,12 @@
+apply plugin: 'java-library'
+apply plugin: 'kotlin'
+
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
+
+dependencies {
+  implementation deps.kotlin.stdlib
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-log/gradle.properties b/leakcanary-log/gradle.properties
new file mode 100644
index 00000000..d14febb2
--- /dev/null
+++ b/leakcanary-log/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-log
+POM_NAME=LeakCanary Log
+POM_PACKAGING=jar
diff --git a/leakcanary-log/src/main/java/leakcanary/CanaryLog.kt b/leakcanary-log/src/main/java/leakcanary/CanaryLog.kt
new file mode 100644
index 00000000..a2eccf46
--- /dev/null
+++ b/leakcanary-log/src/main/java/leakcanary/CanaryLog.kt
@@ -0,0 +1,38 @@
+package leakcanary
+
+object CanaryLog {
+
+  interface Logger {
+    fun d(
+      message: String,
+      vararg args: Any?
+    )
+
+    fun d(
+      throwable: Throwable?,
+      message: String,
+      vararg args: Any?
+    )
+  }
+
+  @Volatile var logger: Logger? = null
+
+  fun d(
+    message: String,
+    vararg args: Any?
+  ) {
+    // Local variable to prevent the ref from becoming null after the null check.
+    val logger = logger ?: return
+    logger.d(message, *args)
+  }
+
+  fun d(
+    throwable: Throwable?,
+    message: String,
+    vararg args: Any?
+  ) {
+    // Local variable to prevent the ref from becoming null after the null check.
+    val logger = logger ?: return
+    logger.d(throwable, message, *args)
+  }
+}
diff --git a/leakcanary-sample/build.gradle b/leakcanary-sample/build.gradle
index 54e0d55c..ad05c169 100644
--- a/leakcanary-sample/build.gradle
+++ b/leakcanary-sample/build.gradle
@@ -1,30 +1,44 @@
 apply plugin: 'com.android.application'
+apply plugin: 'kotlin-android'
 
 dependencies {
-  debugCompile project(':leakcanary-android')
-  releaseCompile project(':leakcanary-android-no-op');
+  debugImplementation project(':leakcanary-android')
+
+  implementation deps.kotlin.stdlib
+
+  testImplementation deps.junit
+  testImplementation deps.robolectric
+
+  androidTestImplementation project(':leakcanary-android-instrumentation')
+  androidTestImplementation deps.androidx.test.espresso
+  androidTestImplementation deps.androidx.test.rules
+  androidTestImplementation deps.androidx.test.runner
 }
 
 android {
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
+  compileSdkVersion versions.compileSdk
 
   compileOptions {
-    sourceCompatibility rootProject.ext.javaVersion
-    targetCompatibility rootProject.ext.javaVersion
+    sourceCompatibility JavaVersion.VERSION_1_8
+    targetCompatibility JavaVersion.VERSION_1_8
   }
 
   defaultConfig {
     applicationId "com.example.leakcanary"
-    minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.compileSdkVersion
+    minSdkVersion versions.minSdk
+    targetSdkVersion versions.compileSdk
 
     versionCode 1
     versionName "1.0"
+
+    testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
+    testInstrumentationRunnerArgument "listener",
+        "leakcanary.FailTestOnLeakRunListener"
   }
 
   buildTypes {
     debug
+    release
   }
 
   dexOptions {
@@ -34,4 +48,22 @@ android {
   lintOptions {
     disable 'GoogleAppIndexingWarning'
   }
+
+  testOptions {
+    unitTests {
+      includeAndroidResources = true
+    }
+  }
+}
+
+// Instrumentation test dependencies resolve to 27.1.1 so we align the sample.
+configurations.all {
+  resolutionStrategy {
+    eachDependency { details ->
+      // Force all of the primary support libraries to use the same version.
+      if (details.requested.group == 'com.android.support') {
+        details.useVersion "27.1.1"
+      }
+    }
+  }
 }
diff --git a/leakcanary-watcher/src/main/AndroidManifest.xml b/leakcanary-sample/src/androidTest/AndroidManifest.xml
similarity index 81%
rename from leakcanary-watcher/src/main/AndroidManifest.xml
rename to leakcanary-sample/src/androidTest/AndroidManifest.xml
index 3f8d7ca9..d23bb44d 100644
--- a/leakcanary-watcher/src/main/AndroidManifest.xml
+++ b/leakcanary-sample/src/androidTest/AndroidManifest.xml
@@ -1,5 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
 <!--
-  ~ Copyright (C) 2015 Square, Inc.
+  ~ Copyright (C) 2018 Square, Inc.
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
@@ -14,6 +15,5 @@
   ~ limitations under the License.
   -->
 <manifest
-    package="com.squareup.leakcanary.watcher">
-  <application/>
+    package="com.squareup.leakcanary.instrumentation.test">
 </manifest>
diff --git a/leakcanary-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt b/leakcanary-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
new file mode 100644
index 00000000..b07ec28f
--- /dev/null
+++ b/leakcanary-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
@@ -0,0 +1,48 @@
+package leakcanary.tests
+
+import androidx.test.espresso.Espresso.onView
+import androidx.test.espresso.assertion.ViewAssertions.matches
+import androidx.test.espresso.matcher.ViewMatchers.withId
+import androidx.test.espresso.matcher.ViewMatchers.withText
+import androidx.test.rule.ActivityTestRule
+import com.example.leakcanary.MainActivity
+import com.example.leakcanary.R
+import org.junit.Rule
+import org.junit.Test
+
+/**
+ * This UI test looks like it should succeed, but it will actually fail because
+ * it triggers a leak.
+ *
+ * Run this test with:
+ *
+ * ./gradlew leakcanary-sample:connectedCheck
+ *
+ * To set this up, we installed a special RefWatcher dedicated to detecting leaks in
+ * instrumentation tests in [InstrumentationExampleApplication], and then added the FailTestOnLeakRunListener
+ * to the config of our build.gradle:
+ *
+ * testInstrumentationRunnerArgument "listener", "leakcanary.FailTestOnLeakRunListener"
+ *
+ *
+ * Why is this class named "TuPeuxPasTest"?
+ *
+ * This test fails, intentionally. In French, "Tu peux pas test" could mean "you cannot test"
+ * written with poor grammar. Except, that's not what it means.
+ * If you're curious, interested in French and have time to waste:
+ * https://www.youtube.com/watch?v=DZZpbmAc-0A
+ * https://www.youtube.com/watch?v=nHeAA6X-XUQ
+ */
+class TuPeuxPasTest {
+
+  @get:Rule
+  var activityRule = ActivityTestRule(MainActivity::class.java)
+
+  /**
+   * A dummy test that fails because MainActivity is leaking
+   */
+  @Test
+  fun helperTextHasExpectedContent() {
+    onView(withId(R.id.helper_text)).check(matches(withText(R.string.helper_text)))
+  }
+}
diff --git a/leakcanary-sample/src/main/AndroidManifest.xml b/leakcanary-sample/src/main/AndroidManifest.xml
index d72ca551..e5b5138c 100644
--- a/leakcanary-sample/src/main/AndroidManifest.xml
+++ b/leakcanary-sample/src/main/AndroidManifest.xml
@@ -18,15 +18,19 @@
     xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.example.leakcanary"
     >
-  <application android:name=".ExampleApplication" android:allowBackup="false"
-      android:icon="@drawable/ic_launcher"
+
+  <application
+      android:name=".ExampleApplication"
+      android:allowBackup="false"
+      android:icon="@mipmap/ic_launcher"
+      android:label="@string/app_name"
       >
     <activity
-        android:label="@string/app_name"
         android:name=".MainActivity"
         >
       <intent-filter>
         <action android:name="android.intent.action.MAIN"/>
+
         <category android:name="android.intent.category.LAUNCHER"/>
         <category android:name="android.intent.category.DEFAULT"/>
       </intent-filter>
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
deleted file mode 100644
index 942be776..00000000
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.leakcanary;
-
-import android.app.Application;
-import android.os.StrictMode;
-import com.squareup.leakcanary.LeakCanary;
-
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.GINGERBREAD;
-
-public class ExampleApplication extends Application {
-
-  @Override public void onCreate() {
-    super.onCreate();
-    enabledStrictMode();
-    LeakCanary.install(this);
-  }
-
-  private void enabledStrictMode() {
-    if (SDK_INT >= GINGERBREAD) {
-      StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() //
-          .detectAll() //
-          .penaltyLog() //
-          .penaltyDeath() //
-          .build());
-    }
-  }
-}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
similarity index 70%
rename from leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
rename to leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
index 715d089a..b8d708ff 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
@@ -13,17 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary;
+package com.example.leakcanary
 
-import java.io.File;
+import android.app.Application
+import android.view.View
 
-public interface HeapDumper {
+open class ExampleApplication : Application() {
+  val leakedViews = mutableListOf<View>()
+}
 
-  File NO_DUMP = null;
-
-  /**
-   * @return a {@link File} referencing the heap dump, or {@link #NO_DUMP} if the heap could not be
-   * dumped.
-   */
-  File dumpHeap();
-}
\ No newline at end of file
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/LeakingSingleton.kt b/leakcanary-sample/src/main/java/com/example/leakcanary/LeakingSingleton.kt
new file mode 100644
index 00000000..9ebe1e19
--- /dev/null
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/LeakingSingleton.kt
@@ -0,0 +1,7 @@
+package com.example.leakcanary
+
+import android.view.View
+
+object LeakingSingleton {
+  val leakedViews = mutableListOf<View>()
+}
\ No newline at end of file
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/LeakingThread.kt b/leakcanary-sample/src/main/java/com/example/leakcanary/LeakingThread.kt
new file mode 100644
index 00000000..24138036
--- /dev/null
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/LeakingThread.kt
@@ -0,0 +1,24 @@
+package com.example.leakcanary
+
+import android.view.View
+
+class LeakingThread : Thread() {
+
+  val leakedViews = mutableListOf<View>()
+
+  init {
+    name = "Leaking thread"
+    start()
+  }
+
+  override fun run() {
+    synchronized(obj) {
+      obj.wait()
+    }
+  }
+
+  companion object {
+    private val obj = Object()
+    val thread = LeakingThread()
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
deleted file mode 100644
index 870f59b1..00000000
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.leakcanary;
-
-import android.app.Activity;
-import android.os.AsyncTask;
-import android.os.Bundle;
-import android.os.SystemClock;
-import android.view.View;
-
-public class MainActivity extends Activity {
-
-  @Override protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-    setContentView(R.layout.main_activity);
-
-    View button = findViewById(R.id.async_task);
-    button.setOnClickListener(new View.OnClickListener() {
-      @Override public void onClick(View v) {
-        startAsyncTask();
-      }
-    });
-  }
-
-  void startAsyncTask() {
-    // This async task is an anonymous class and therefore has a hidden reference to the outer
-    // class MainActivity. If the activity gets destroyed before the task finishes (e.g. rotation),
-    // the activity instance will leak.
-    new AsyncTask<Void, Void, Void>() {
-      @Override protected Void doInBackground(Void... params) {
-        // Do some slow work in background
-        SystemClock.sleep(20000);
-        return null;
-      }
-    }.execute();
-  }
-}
-
-
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.kt
similarity index 51%
rename from leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java
rename to leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.kt
index 227bcb59..a0602506 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.kt
@@ -13,23 +13,26 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.haha.perflib;
+package com.example.leakcanary
 
-public final class HahaSpy {
+import android.app.Activity
+import android.os.Bundle
+import android.view.View
+import kotlin.random.Random
 
-  public static Instance allocatingThread(Instance instance) {
-    Snapshot snapshot = instance.mHeap.mSnapshot;
-    int threadSerialNumber;
-    if (instance instanceof RootObj) {
-      threadSerialNumber = ((RootObj) instance).mThread;
-    } else {
-      threadSerialNumber = instance.mStack.mThreadSerialNumber;
-    }
-    ThreadObj thread = snapshot.getThread(threadSerialNumber);
-    return snapshot.findInstance(thread.mId);
-  }
+class MainActivity : Activity() {
+
+  override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+    setContentView(R.layout.main_activity)
+
+    val app = application as ExampleApplication
+    val leakedView = findViewById<View>(R.id.helper_text)
 
-  private HahaSpy() {
-    throw new AssertionError();
+    when (Random.nextInt(3)) {
+      0 -> app.leakedViews
+      1 -> LeakingSingleton.leakedViews
+      else -> LeakingThread.thread.leakedViews
+    }.add(leakedView)
   }
 }
diff --git a/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png
deleted file mode 100755
index 65948fa3..00000000
Binary files a/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png and /dev/null differ
diff --git a/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png
deleted file mode 100755
index 5d826c42..00000000
Binary files a/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png and /dev/null differ
diff --git a/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png
deleted file mode 100755
index c9c7ec58..00000000
Binary files a/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png and /dev/null differ
diff --git a/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100755
index cb8a98ab..00000000
Binary files a/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png
deleted file mode 100755
index 3ca3a7f6..00000000
Binary files a/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png and /dev/null differ
diff --git a/leakcanary-sample/src/main/res/layout/main_activity.xml b/leakcanary-sample/src/main/res/layout/main_activity.xml
index 2dc62d61..d1f96a18 100644
--- a/leakcanary-sample/src/main/res/layout/main_activity.xml
+++ b/leakcanary-sample/src/main/res/layout/main_activity.xml
@@ -23,17 +23,11 @@
     >
 
   <TextView
+      android:id="@+id/helper_text"
       android:layout_width="match_parent"
       android:layout_height="wrap_content"
       android:layout_marginBottom="16dp"
       android:text="@string/helper_text"
       />
 
-  <Button
-      android:id="@+id/async_task"
-      android:layout_width="match_parent"
-      android:layout_height="wrap_content"
-      android:text="@string/start_async_task"
-      />
-
-</LinearLayout>
\ No newline at end of file
+</LinearLayout>
diff --git a/leakcanary-sample/src/main/res/mipmap-hdpi/ic_launcher.png b/leakcanary-sample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 00000000..97aa0b79
Binary files /dev/null and b/leakcanary-sample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/mipmap-mdpi/ic_launcher.png b/leakcanary-sample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 00000000..77a7ef0c
Binary files /dev/null and b/leakcanary-sample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/mipmap-xhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 00000000..4f046561
Binary files /dev/null and b/leakcanary-sample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 00000000..f8c5988e
Binary files /dev/null and b/leakcanary-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 00000000..42beb64b
Binary files /dev/null and b/leakcanary-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/values/strings.xml b/leakcanary-sample/src/main/res/values/strings.xml
index 9e5bf782..0f66736c 100644
--- a/leakcanary-sample/src/main/res/values/strings.xml
+++ b/leakcanary-sample/src/main/res/values/strings.xml
@@ -14,11 +14,11 @@
   ~ See the License for the specific language governing permissions and
   ~ limitations under the License.
   -->
-<resources>
-  <string name="app_name">LeakCanary Sample</string>
-  <string name="start_async_task">Start new AsyncTask</string>
-  <string name="helper_text">Start the async task, <b>rotate the screen</b> and wait for a bit. A
-    wild notification appears.
+<resources
+    xmlns:tools="http://schemas.android.com/tools"
+    tools:ignore="MissingTranslation">
+  <string name="app_name">Example App</string>
+  <string name="helper_text">Rotate the screen 5 times to create 5 leaks and trigger a foreground
+    heap dump. Or press back to cause a leak and trigger a background heap dump.
   </string>
-  <string name="leak_canary_display_activity_label">Leaks Sample</string>
-</resources>
\ No newline at end of file
+</resources>
diff --git a/leakcanary-watcher/build.gradle b/leakcanary-watcher/build.gradle
index 50543b66..984bad02 100644
--- a/leakcanary-watcher/build.gradle
+++ b/leakcanary-watcher/build.gradle
@@ -1,48 +1,16 @@
-version rootProject.ext.VERSION_NAME
-group rootProject.ext.GROUP
+apply plugin: 'java-library'
+apply plugin: 'kotlin'
 
-buildscript {
-  repositories {
-    mavenCentral()
-  }
-}
-
-apply plugin: 'com.android.library'
-
-repositories {
-  mavenCentral()
-}
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
 
 dependencies {
-  testCompile 'junit:junit:4.12'
-}
-
-android.libraryVariants.all { variant ->
-  def name = variant.buildType.name
-  if (name.equals(com.android.builder.core.BuilderConstants.DEBUG)) {
-    return; // Skip debug builds.
-  }
-  def task = project.tasks.create "jar${name.capitalize()}", Jar
-  task.dependsOn variant.javaCompile
-  task.from variant.javaCompile.destinationDir
-  artifacts.add('archives', task);
-}
-
-android {
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
-  defaultConfig {
-    minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.targetSdkVersion
-  }
-  lintOptions {
-    disable 'GoogleAppIndexingWarning'
-  }
-}
+  implementation deps.kotlin.stdlib
+  api project(':leakcanary-log')
 
-task sourceJar(type: Jar) {
-  from 'src/main/java'
+  testImplementation deps.assertj_core
+  testImplementation deps.junit
 }
 
 apply from: rootProject.file('gradle/checkstyle.gradle')
-apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
deleted file mode 100644
index 47662445..00000000
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
+++ /dev/null
@@ -1,209 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.Serializable;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-import static java.util.Collections.unmodifiableMap;
-
-/**
- * Prevents specific references from being taken into account when computing the shortest reference
- * path from a suspected leaking instance to the GC roots.
- *
- * This class lets you ignore known memory leaks that you know about. If the shortest path
- * matches {@link ExcludedRefs}, than the heap analyzer should look for a longer path with nothing
- * matching in {@link ExcludedRefs}.
- */
-public final class ExcludedRefs implements Serializable {
-
-  public static Builder builder() {
-    return new BuilderWithParams();
-  }
-
-  public final Map<String, Map<String, Exclusion>> fieldNameByClassName;
-  public final Map<String, Map<String, Exclusion>> staticFieldNameByClassName;
-  public final Map<String, Exclusion> threadNames;
-  public final Map<String, Exclusion> classNames;
-  public final Map<String, Exclusion> rootClassNames;
-
-  ExcludedRefs(BuilderWithParams builder) {
-    this.fieldNameByClassName = unmodifiableRefStringMap(builder.fieldNameByClassName);
-    this.staticFieldNameByClassName = unmodifiableRefStringMap(builder.staticFieldNameByClassName);
-    this.threadNames = unmodifiableRefMap(builder.threadNames);
-    this.classNames = unmodifiableRefMap(builder.classNames);
-    this.rootClassNames = unmodifiableRefMap(builder.rootClassNames);
-  }
-
-  private Map<String, Map<String, Exclusion>> unmodifiableRefStringMap(
-      Map<String, Map<String, ParamsBuilder>> mapmap) {
-    LinkedHashMap<String, Map<String, Exclusion>> fieldNameByClassName = new LinkedHashMap<>();
-    for (Map.Entry<String, Map<String, ParamsBuilder>> entry : mapmap.entrySet()) {
-      fieldNameByClassName.put(entry.getKey(), unmodifiableRefMap(entry.getValue()));
-    }
-    return unmodifiableMap(fieldNameByClassName);
-  }
-
-  private Map<String, Exclusion> unmodifiableRefMap(Map<String, ParamsBuilder> fieldBuilderMap) {
-    Map<String, Exclusion> fieldMap = new LinkedHashMap<>();
-    for (Map.Entry<String, ParamsBuilder> fieldEntry : fieldBuilderMap.entrySet()) {
-      fieldMap.put(fieldEntry.getKey(), new Exclusion(fieldEntry.getValue()));
-    }
-    return unmodifiableMap(fieldMap);
-  }
-
-  @Override public String toString() {
-    String string = "";
-    for (Map.Entry<String, Map<String, Exclusion>> classes : fieldNameByClassName.entrySet()) {
-      String clazz = classes.getKey();
-      for (Map.Entry<String, Exclusion> field : classes.getValue().entrySet()) {
-        String always = field.getValue().alwaysExclude ? " (always)" : "";
-        string += "| Field: " + clazz + "." + field.getKey() + always + "\n";
-      }
-    }
-    for (Map.Entry<String, Map<String, Exclusion>> classes : staticFieldNameByClassName.entrySet()) {
-      String clazz = classes.getKey();
-      for (Map.Entry<String, Exclusion> field : classes.getValue().entrySet()) {
-        String always = field.getValue().alwaysExclude ? " (always)" : "";
-        string += "| Static field: " + clazz + "." + field.getKey() + always + "\n";
-      }
-    }
-    for (Map.Entry<String, Exclusion> thread : threadNames.entrySet()) {
-      String always = thread.getValue().alwaysExclude ? " (always)" : "";
-      string += "| Thread:" + thread.getKey() + always + "\n";
-    }
-    for (Map.Entry<String, Exclusion> clazz : classNames.entrySet()) {
-      String always = clazz.getValue().alwaysExclude ? " (always)" : "";
-      string += "| Class:" + clazz.getKey() + always + "\n";
-    }
-    for (Map.Entry<String, Exclusion> clazz : rootClassNames.entrySet()) {
-      String always = clazz.getValue().alwaysExclude ? " (always)" : "";
-      string += "| Root Class:" + clazz.getKey() + always + "\n";
-    }
-    return string;
-  }
-
-  static final class ParamsBuilder {
-    String name;
-    String reason;
-    boolean alwaysExclude;
-    final String matching;
-
-    ParamsBuilder(String matching) {
-      this.matching = matching;
-    }
-  }
-
-  public interface Builder {
-    BuilderWithParams instanceField(String className, String fieldName);
-
-    BuilderWithParams staticField(String className, String fieldName);
-
-    BuilderWithParams thread(String threadName);
-
-    BuilderWithParams clazz(String className);
-
-    BuilderWithParams rootClass(String rootSuperClassName);
-
-    ExcludedRefs build();
-  }
-
-  public static final class BuilderWithParams implements Builder {
-
-    private final Map<String, Map<String, ParamsBuilder>> fieldNameByClassName =
-        new LinkedHashMap<>();
-    private final Map<String, Map<String, ParamsBuilder>> staticFieldNameByClassName =
-        new LinkedHashMap<>();
-    private final Map<String, ParamsBuilder> threadNames = new LinkedHashMap<>();
-    private final Map<String, ParamsBuilder> classNames = new LinkedHashMap<>();
-    private final Map<String, ParamsBuilder> rootClassNames = new LinkedHashMap<>();
-
-    private ParamsBuilder lastParams;
-
-    BuilderWithParams() {
-    }
-
-    @Override public BuilderWithParams instanceField(String className, String fieldName) {
-      checkNotNull(className, "className");
-      checkNotNull(fieldName, "fieldName");
-      Map<String, ParamsBuilder> excludedFields = fieldNameByClassName.get(className);
-      if (excludedFields == null) {
-        excludedFields = new LinkedHashMap<>();
-        fieldNameByClassName.put(className, excludedFields);
-      }
-      lastParams = new ParamsBuilder("field " + className + "#" + fieldName);
-      excludedFields.put(fieldName, lastParams);
-      return this;
-    }
-
-    @Override public BuilderWithParams staticField(String className, String fieldName) {
-      checkNotNull(className, "className");
-      checkNotNull(fieldName, "fieldName");
-      Map<String, ParamsBuilder> excludedFields = staticFieldNameByClassName.get(className);
-      if (excludedFields == null) {
-        excludedFields = new LinkedHashMap<>();
-        staticFieldNameByClassName.put(className, excludedFields);
-      }
-      lastParams = new ParamsBuilder("static field " + className + "#" + fieldName);
-      excludedFields.put(fieldName, lastParams);
-      return this;
-    }
-
-    @Override public BuilderWithParams thread(String threadName) {
-      checkNotNull(threadName, "threadName");
-      lastParams = new ParamsBuilder("any threads named " + threadName);
-      threadNames.put(threadName, lastParams);
-      return this;
-    }
-
-    /** Ignores all fields and static fields of all subclasses of the provided class name. */
-    @Override public BuilderWithParams clazz(String className) {
-      checkNotNull(className, "className");
-      lastParams = new ParamsBuilder("any subclass of " + className);
-      classNames.put(className, lastParams);
-      return this;
-    }
-
-    /** Ignores any GC root that belongs to a subclass of the provided class name. */
-    @Override public BuilderWithParams rootClass(String rootClassName) {
-      checkNotNull(rootClassName, "rootClassName");
-      lastParams = new ParamsBuilder("any GC root subclass of " + rootClassName);
-      rootClassNames.put(rootClassName, lastParams);
-      return this;
-    }
-
-    public BuilderWithParams named(String name) {
-      lastParams.name = name;
-      return this;
-    }
-
-    public BuilderWithParams reason(String reason) {
-      lastParams.reason = reason;
-      return this;
-    }
-
-    public BuilderWithParams alwaysExclude() {
-      lastParams.alwaysExclude = true;
-      return this;
-    }
-
-    public ExcludedRefs build() {
-      return new ExcludedRefs(this);
-    }
-  }
-}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java
deleted file mode 100644
index 4d87d05e..00000000
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package com.squareup.leakcanary;
-
-import java.io.Serializable;
-
-public final class Exclusion implements Serializable {
-  public final String name;
-  public final String reason;
-  public final boolean alwaysExclude;
-  public final String matching;
-
-  Exclusion(ExcludedRefs.ParamsBuilder builder) {
-    this.name = builder.name;
-    this.reason = builder.reason;
-    this.alwaysExclude = builder.alwaysExclude;
-    this.matching = builder.matching;
-  }
-}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
deleted file mode 100644
index fe88f38e..00000000
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.File;
-import java.io.Serializable;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-
-public final class HeapDump implements Serializable {
-
-  public interface Listener {
-    void analyze(HeapDump heapDump);
-  }
-
-  /** The heap dump file, which you might want to upload somewhere. */
-  public final File heapDumpFile;
-
-  /**
-   * Key associated to the {@link KeyedWeakReference} used to detect the memory leak.
-   * When analyzing a heap dump, search for all {@link KeyedWeakReference} instances, then open
-   * the one that has its "key" field set to this value. Its "referent" field contains the
-   * leaking object. Computing the shortest path to GC roots on that leaking object should enable
-   * you to figure out the cause of the leak.
-   */
-  public final String referenceKey;
-
-  /**
-   * User defined name to help identify the leaking instance.
-   */
-  public final String referenceName;
-
-  /** References that should be ignored when analyzing this heap dump. */
-  public final ExcludedRefs excludedRefs;
-
-  /** Time from the request to watch the reference until the GC was triggered. */
-  public final long watchDurationMs;
-  public final long gcDurationMs;
-  public final long heapDumpDurationMs;
-
-  public HeapDump(File heapDumpFile, String referenceKey, String referenceName,
-      ExcludedRefs excludedRefs, long watchDurationMs, long gcDurationMs, long heapDumpDurationMs) {
-    this.heapDumpFile = checkNotNull(heapDumpFile, "heapDumpFile");
-    this.referenceKey = checkNotNull(referenceKey, "referenceKey");
-    this.referenceName = checkNotNull(referenceName, "referenceName");
-    this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
-    this.watchDurationMs = watchDurationMs;
-    this.gcDurationMs = gcDurationMs;
-    this.heapDumpDurationMs = heapDumpDurationMs;
-  }
-}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java
deleted file mode 100644
index 9932308a..00000000
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.lang.ref.ReferenceQueue;
-import java.lang.ref.WeakReference;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-
-/** @see {@link HeapDump#referenceKey}. */
-final class KeyedWeakReference extends WeakReference<Object> {
-  public final String key;
-  public final String name;
-
-  KeyedWeakReference(Object referent, String key, String name,
-      ReferenceQueue<Object> referenceQueue) {
-    super(checkNotNull(referent, "referent"), checkNotNull(referenceQueue, "referenceQueue"));
-    this.key = checkNotNull(key, "key");
-    this.name = checkNotNull(name, "name");
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
deleted file mode 100644
index 5d124535..00000000
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.File;
-import java.lang.ref.ReferenceQueue;
-import java.util.Set;
-import java.util.UUID;
-import java.util.concurrent.CopyOnWriteArraySet;
-import java.util.concurrent.Executor;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-
-/**
- * Watches references that should become weakly reachable. When the {@link RefWatcher} detects that
- * a reference might not be weakly reachable when it should, it triggers the {@link HeapDumper}.
- *
- * <p>This class is thread-safe: you can call {@link #watch(Object)} from any thread.
- */
-public final class RefWatcher {
-
-  public static final RefWatcher DISABLED = new RefWatcher(new Executor() {
-    @Override public void execute(Runnable command) {
-    }
-  }, new DebuggerControl() {
-    @Override public boolean isDebuggerAttached() {
-      // Skips watching.
-      return true;
-    }
-  }, GcTrigger.DEFAULT, new HeapDumper() {
-    @Override public File dumpHeap() {
-      return null;
-    }
-  }, new HeapDump.Listener() {
-    @Override public void analyze(HeapDump heapDump) {
-    }
-  }, new ExcludedRefs.BuilderWithParams().build());
-
-  private final Executor watchExecutor;
-  private final DebuggerControl debuggerControl;
-  private final GcTrigger gcTrigger;
-  private final HeapDumper heapDumper;
-  private final Set<String> retainedKeys;
-  private final ReferenceQueue<Object> queue;
-  private final HeapDump.Listener heapdumpListener;
-  private final ExcludedRefs excludedRefs;
-
-  public RefWatcher(Executor watchExecutor, DebuggerControl debuggerControl, GcTrigger gcTrigger,
-      HeapDumper heapDumper, HeapDump.Listener heapdumpListener, ExcludedRefs excludedRefs) {
-    this.watchExecutor = checkNotNull(watchExecutor, "watchExecutor");
-    this.debuggerControl = checkNotNull(debuggerControl, "debuggerControl");
-    this.gcTrigger = checkNotNull(gcTrigger, "gcTrigger");
-    this.heapDumper = checkNotNull(heapDumper, "heapDumper");
-    this.heapdumpListener = checkNotNull(heapdumpListener, "heapdumpListener");
-    this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
-    retainedKeys = new CopyOnWriteArraySet<>();
-    queue = new ReferenceQueue<>();
-  }
-
-  /**
-   * Identical to {@link #watch(Object, String)} with an empty string reference name.
-   *
-   * @see #watch(Object, String)
-   */
-  public void watch(Object watchedReference) {
-    watch(watchedReference, "");
-  }
-
-  /**
-   * Watches the provided references and checks if it can be GCed. This method is non blocking,
-   * the check is done on the {@link Executor} this {@link RefWatcher} has been constructed with.
-   *
-   * @param referenceName An logical identifier for the watched object.
-   */
-  public void watch(Object watchedReference, String referenceName) {
-    checkNotNull(watchedReference, "watchedReference");
-    checkNotNull(referenceName, "referenceName");
-    if (debuggerControl.isDebuggerAttached()) {
-      return;
-    }
-    final long watchStartNanoTime = System.nanoTime();
-    String key = UUID.randomUUID().toString();
-    retainedKeys.add(key);
-    final KeyedWeakReference reference =
-        new KeyedWeakReference(watchedReference, key, referenceName, queue);
-
-    watchExecutor.execute(new Runnable() {
-      @Override public void run() {
-        ensureGone(reference, watchStartNanoTime);
-      }
-    });
-  }
-
-  void ensureGone(KeyedWeakReference reference, long watchStartNanoTime) {
-    long gcStartNanoTime = System.nanoTime();
-
-    long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);
-    removeWeaklyReachableReferences();
-    if (gone(reference) || debuggerControl.isDebuggerAttached()) {
-      return;
-    }
-    gcTrigger.runGc();
-    removeWeaklyReachableReferences();
-    if (!gone(reference)) {
-      long startDumpHeap = System.nanoTime();
-      long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);
-
-      File heapDumpFile = heapDumper.dumpHeap();
-
-      if (heapDumpFile == HeapDumper.NO_DUMP) {
-        // Could not dump the heap, abort.
-        return;
-      }
-      long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);
-      heapdumpListener.analyze(
-          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,
-              gcDurationMs, heapDumpDurationMs));
-    }
-  }
-
-  private boolean gone(KeyedWeakReference reference) {
-    return !retainedKeys.contains(reference.key);
-  }
-
-  private void removeWeaklyReachableReferences() {
-    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
-    // reachable. This is before finalization or garbage collection has actually happened.
-    KeyedWeakReference ref;
-    while ((ref = (KeyedWeakReference) queue.poll()) != null) {
-      retainedKeys.remove(ref.key);
-    }
-  }
-}
diff --git a/leakcanary-watcher/src/main/java/leakcanary/Clock.kt b/leakcanary-watcher/src/main/java/leakcanary/Clock.kt
new file mode 100644
index 00000000..bd3b146b
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/leakcanary/Clock.kt
@@ -0,0 +1,6 @@
+package leakcanary
+
+interface Clock {
+  /** See Android SystemClock.uptimeMillis().  */
+  fun uptimeMillis(): Long
+}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java b/leakcanary-watcher/src/main/java/leakcanary/GcTrigger.kt
similarity index 68%
rename from leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
rename to leakcanary-watcher/src/main/java/leakcanary/GcTrigger.kt
index 8beade52..023889b8 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
+++ b/leakcanary-watcher/src/main/java/leakcanary/GcTrigger.kt
@@ -13,36 +13,37 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary;
+package leakcanary
 
 /**
  * Called when a watched reference is expected to be weakly reachable, but hasn't been enqueued
- * in the reference queue yet. This gives the application a hook to run the GC before the {@link
- * RefWatcher} checks the reference queue again, to avoid taking a heap dump if possible.
+ * in the reference queue yet. This gives the application a hook to run the GC before the [ ] checks the reference queue again, to avoid taking a heap dump if possible.
  */
-public interface GcTrigger {
-  GcTrigger DEFAULT = new GcTrigger() {
-    @Override public void runGc() {
+interface GcTrigger {
+
+  fun runGc()
+
+  object Default : GcTrigger {
+    override fun runGc() {
       // Code taken from AOSP FinalizationTest:
       // https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
       // java/lang/ref/FinalizationTester.java
       // System.gc() does not garbage collect every time. Runtime.gc() is
-      // more likely to perfom a gc.
-      Runtime.getRuntime().gc();
-      enqueueReferences();
-      System.runFinalization();
+      // more likely to perform a gc.
+      Runtime.getRuntime()
+          .gc()
+      enqueueReferences()
+      System.runFinalization()
     }
 
-    private void enqueueReferences() {
+    private fun enqueueReferences() {
       // Hack. We don't have a programmatic way to wait for the reference queue daemon to move
       // references to the appropriate queues.
       try {
-        Thread.sleep(100);
-      } catch (InterruptedException e) {
-        throw new AssertionError();
+        Thread.sleep(100)
+      } catch (e: InterruptedException) {
+        throw AssertionError()
       }
     }
-  };
-
-  void runGc();
-}
\ No newline at end of file
+  }
+}
diff --git a/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt b/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
new file mode 100644
index 00000000..2e66cab5
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import java.lang.ref.ReferenceQueue
+import java.lang.ref.WeakReference
+
+@Suppress("unused")
+class KeyedWeakReference(
+  referent: Any,
+  /**
+   * Key used to find the retained references in the heap dump.
+   */
+  val key: String,
+  val name: String,
+  val watchUptimeMillis: Long,
+  referenceQueue: ReferenceQueue<Any>
+) : WeakReference<Any>(
+    referent, referenceQueue
+) {
+  val className: String = referent.javaClass.name
+}
diff --git a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
new file mode 100644
index 00000000..291c4a5e
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import java.lang.ref.ReferenceQueue
+import java.util.HashSet
+import java.util.UUID
+import java.util.concurrent.Executor
+
+/**
+ * Thread safe by locking on all methods, which is reasonably efficient given how often
+ * these methods are accessed.
+ */
+class RefWatcher constructor(
+  private val clock: Clock,
+  private val checkRetainedExecutor: Executor,
+  private val onReferenceRetained: () -> Unit
+) {
+
+  /**
+   * References passed to [watch] that haven't made it to [retainedReferences] yet.
+   */
+  private val watchedReferences = mutableMapOf<String, KeyedWeakReference>()
+  /**
+   * References passed to [watch] that we have determined to be retained longer than they should
+   * have been.
+   */
+  private val retainedReferences = mutableMapOf<String, KeyedWeakReference>()
+  private val queue = ReferenceQueue<Any>()
+
+  val hasRetainedReferences: Boolean
+    @Synchronized get() {
+      removeWeaklyReachableReferences()
+      return !retainedReferences.isEmpty()
+    }
+
+  val hasWatchedReferences: Boolean
+    @Synchronized get() {
+      removeWeaklyReachableReferences()
+      return !retainedReferences.isEmpty() || !watchedReferences.isEmpty()
+    }
+
+  val retainedKeys: Set<String>
+    @Synchronized get() {
+      removeWeaklyReachableReferences()
+      return HashSet(retainedReferences.keys)
+    }
+
+  /**
+   * Identical to [.watch] with an empty string reference name.
+   */
+  @Synchronized fun watch(watchedReference: Any) {
+    watch(watchedReference, "")
+  }
+
+  /**
+   * Watches the provided references and notifies registered [NewRefListener]s.
+   *
+   * @param referenceName An logical identifier for the watched object.
+   */
+  @Synchronized fun watch(
+    watchedReference: Any,
+    referenceName: String
+  ) {
+    checkWatchedObjectType(watchedReference)
+    removeWeaklyReachableReferences()
+    val key = UUID.randomUUID()
+        .toString()
+    val watchUptimeMillis = clock.uptimeMillis()
+    val reference =
+      KeyedWeakReference(watchedReference, key, referenceName, watchUptimeMillis, queue)
+    if (referenceName != "") {
+      CanaryLog.d(
+          "Watching instance of %s named %s with key %s", reference.className,
+          referenceName, key
+      )
+    } else {
+      CanaryLog.d(
+          "Watching instance of %s with key %s", reference.className, key
+      )
+    }
+
+    watchedReferences[key] = reference
+    checkRetainedExecutor.execute {
+      moveToRetained(key)
+    }
+  }
+
+  private fun checkWatchedObjectType(watchedReference: Any) {
+    if (watchedReference is String) {
+      throw IllegalArgumentException(
+          "watchedReference $watchedReference has a type that the LeakCanary shortest path finder will skip"
+      )
+    }
+  }
+
+  @Synchronized private fun moveToRetained(key: String) {
+    removeWeaklyReachableReferences()
+    val retainedRef = watchedReferences.remove(key)
+    if (retainedRef != null) {
+      retainedReferences[key] = retainedRef
+      onReferenceRetained()
+    }
+  }
+
+  @Synchronized fun removeRetainedKeys(keysToRemove: Set<String>) {
+    retainedReferences.keys.removeAll(keysToRemove)
+  }
+
+  @Synchronized fun clearWatchedReferences() {
+    watchedReferences.clear()
+    retainedReferences.clear()
+  }
+
+  private fun removeWeaklyReachableReferences() {
+    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
+    // reachable. This is before finalization or garbage collection has actually happened.
+    var ref: KeyedWeakReference?
+    do {
+      ref = queue.poll() as KeyedWeakReference?
+      if (ref != null) {
+        val removedRef = watchedReferences.remove(ref.key)
+        if (removedRef == null) {
+          retainedReferences.remove(ref.key)
+        }
+      }
+    } while (ref != null)
+  }
+}
diff --git a/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java b/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
deleted file mode 100644
index 15b44def..00000000
--- a/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.File;
-import java.util.concurrent.Executor;
-import org.junit.Test;
-
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-public class RefWatcherTest {
-
-  static final ExcludedRefs NO_REF = new ExcludedRefs.BuilderWithParams().build();
-
-  static class TestDumper implements HeapDumper {
-    boolean called;
-
-    @Override public File dumpHeap() {
-      called = true;
-      return new File("");
-    }
-  }
-
-  static class TestListener implements HeapDump.Listener {
-    @Override public void analyze(HeapDump heapDump) {
-    }
-  }
-
-  @SuppressWarnings("FieldCanBeLocal") Object ref;
-
-  static class TestExecutor implements Executor {
-    Runnable command;
-
-    @Override public void execute(Runnable command) {
-      this.command = command;
-    }
-  }
-
-  /**
-   * In theory, this test doesn't have a 100% chance of success. In practice, {@link
-   * GcTrigger#DEFAULT} is good enough.
-   */
-  @Test public void unreachableObject_noDump() {
-    TestDumper dumper = new TestDumper();
-    TestExecutor executor = new TestExecutor();
-    RefWatcher refWatcher = defaultWatcher(dumper, executor);
-    refWatcher.watch(new Object());
-    executor.command.run();
-    assertFalse(dumper.called);
-  }
-
-  @Test public void retainedObject_triggersDump() {
-    TestDumper dumper = new TestDumper();
-    TestExecutor executor = new TestExecutor();
-    RefWatcher refWatcher = defaultWatcher(dumper, executor);
-    ref = new Object();
-    refWatcher.watch(ref);
-    executor.command.run();
-    assertTrue(dumper.called);
-  }
-
-  private RefWatcher defaultWatcher(TestDumper dumper, TestExecutor executor) {
-    return new RefWatcher(executor, DebuggerControl.NONE, GcTrigger.DEFAULT, dumper,
-        new TestListener(), NO_REF);
-  }
-}
diff --git a/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt b/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt
new file mode 100644
index 00000000..a7226e1c
--- /dev/null
+++ b/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt
@@ -0,0 +1,39 @@
+package leakcanary
+
+import leakcanary.GcTrigger.Default.runGc
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import java.util.concurrent.Executor
+
+class RefWatcherTest {
+
+  private val onRefRetained: () -> Unit = {
+  }
+
+  private val checkRetainedExecutor: Executor = Executor {
+    it.run()
+  }
+
+  val refWatcher = RefWatcher(object : Clock {
+    override fun uptimeMillis(): Long {
+      return time
+    }
+  }, checkRetainedExecutor, onRefRetained)
+  var time: Long = 0
+
+  var ref: Any? = Any()
+
+  @Test fun `unreachable object not retained`() {
+    refWatcher.watch(ref!!)
+    ref = null
+    runGc()
+    assertThat(refWatcher.hasRetainedReferences).isFalse()
+  }
+
+  @Test fun `reachable object retained`() {
+    refWatcher.watch(ref!!)
+    runGc()
+    assertThat(refWatcher.hasRetainedReferences).isTrue()
+  }
+
+}
\ No newline at end of file
diff --git a/settings.gradle b/settings.gradle
index 73da17f3..d95526c4 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,5 +1,12 @@
-include ':leakcanary-watcher'
+include ':leakcanary-analyzer-core'
 include ':leakcanary-analyzer'
+include ':leakcanary-analyzer-perflib'
+include ':leakcanary-android-core'
 include ':leakcanary-android'
-include ':leakcanary-android-no-op'
+include ':leakcanary-android-perflib'
+include ':leakcanary-android-instrumentation'
+include ':leakcanary-haha'
+include ':leakcanary-leaksentry'
+include ':leakcanary-log'
 include ':leakcanary-sample'
+include ':leakcanary-watcher'
\ No newline at end of file
