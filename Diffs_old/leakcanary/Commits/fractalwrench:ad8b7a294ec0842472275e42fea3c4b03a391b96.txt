diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
index 5743fed3..5413f1ca 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
@@ -16,7 +16,6 @@
 package com.squareup.leakcanary;
 
 import android.support.annotation.NonNull;
-
 import java.lang.ref.PhantomReference;
 import java.lang.ref.SoftReference;
 import java.lang.ref.WeakReference;
@@ -592,7 +591,7 @@
   /**
    * This returns the references in the leak path that should be ignored by all on Android.
    */
-  @NonNull public static ExcludedRefs.Builder createAndroidDefaults() {
+  public static @NonNull ExcludedRefs.Builder createAndroidDefaults() {
     return createBuilder(
         EnumSet.of(SOFT_REFERENCES, FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
             EVENT_RECEIVER__MMESSAGE_QUEUE));
@@ -604,11 +603,11 @@
    * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
    * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
    */
-  @NonNull public static ExcludedRefs.Builder createAppDefaults() {
+  public static @NonNull ExcludedRefs.Builder createAppDefaults() {
     return createBuilder(EnumSet.allOf(AndroidExcludedRefs.class));
   }
 
-  @NonNull public static ExcludedRefs.Builder createBuilder(EnumSet<AndroidExcludedRefs> refs) {
+  public static @NonNull ExcludedRefs.Builder createBuilder(EnumSet<AndroidExcludedRefs> refs) {
     ExcludedRefs.Builder excluded = ExcludedRefs.builder();
     for (AndroidExcludedRefs ref : refs) {
       if (ref.applies) {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java
index c118b28e..af89bc20 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java
@@ -67,7 +67,7 @@
     this.inspectorClass = inspectorClass;
   }
 
-  @NonNull public static List<Class<? extends Reachability.Inspector>> defaultAndroidInspectors() {
+  public static @NonNull List<Class<? extends Reachability.Inspector>> defaultAndroidInspectors() {
     List<Class<? extends Reachability.Inspector>> inspectorClasses = new ArrayList<>();
     for (AndroidReachabilityInspectors enumValue : AndroidReachabilityInspectors.values()) {
       inspectorClasses.add(enumValue.inspectorClass);
@@ -76,7 +76,7 @@
   }
 
   public static class ViewInspector implements Reachability.Inspector {
-    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (!element.isInstanceOf(View.class)) {
         return Reachability.UNKNOWN;
       }
@@ -89,7 +89,7 @@
   }
 
   public static class ActivityInspector implements Reachability.Inspector {
-    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (!element.isInstanceOf(Activity.class)) {
         return Reachability.UNKNOWN;
       }
@@ -102,7 +102,7 @@
   }
 
   public static class DialogInspector implements Reachability.Inspector {
-    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (!element.isInstanceOf(Dialog.class)) {
         return Reachability.UNKNOWN;
       }
@@ -115,7 +115,7 @@
   }
 
   public static class ApplicationInspector implements Reachability.Inspector {
-    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (element.isInstanceOf(Application.class)) {
         return Reachability.REACHABLE;
       }
@@ -124,7 +124,7 @@
   }
 
   public static class FragmentInspector implements Reachability.Inspector {
-    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (!element.isInstanceOf(Fragment.class)) {
         return Reachability.UNKNOWN;
       }
@@ -137,7 +137,7 @@
   }
 
   public static class SupportFragmentInspector implements Reachability.Inspector {
-    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (!element.isInstanceOf("android.support.v4.app.Fragment")) {
         return Reachability.UNKNOWN;
       }
@@ -150,7 +150,7 @@
   }
 
   public static class MessageQueueInspector implements Reachability.Inspector {
-    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (!element.isInstanceOf(MessageQueue.class)) {
         return Reachability.UNKNOWN;
       }
@@ -165,7 +165,7 @@
   }
 
   public static class MortarPresenterInspector implements Reachability.Inspector {
-    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (!element.isInstanceOf("mortar.Presenter")) {
         return Reachability.UNKNOWN;
       }
@@ -182,7 +182,7 @@
   }
 
   public static class ViewImplInspector implements Reachability.Inspector {
-    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (!element.isInstanceOf("android.view.ViewRootImpl")) {
         return Reachability.UNKNOWN;
       }
@@ -195,7 +195,7 @@
   }
 
   public static class MainThreadInspector implements Reachability.Inspector {
-    @Override @NonNull public Reachability expectedReachability(@NonNull LeakTraceElement element) {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
       if (!element.isInstanceOf(Thread.class)) {
         return Reachability.UNKNOWN;
       }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
index 00f49707..4bf71848 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
@@ -27,7 +27,7 @@
    * Sets a custom {@link AbstractAnalysisResultService} to listen to analysis results. This
    * overrides any call to {@link #heapDumpListener(HeapDump.Listener)}.
    */
-  @NonNull public AndroidRefWatcherBuilder listenerServiceClass(
+  public @NonNull AndroidRefWatcherBuilder listenerServiceClass(
       @NonNull Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
     return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));
   }
@@ -37,7 +37,7 @@
    * tracked object has been garbage collected. This overrides any call to {@link
    * #watchExecutor(WatchExecutor)}.
    */
-  @NonNull public AndroidRefWatcherBuilder watchDelay(long delay, @NonNull TimeUnit unit) {
+  public @NonNull AndroidRefWatcherBuilder watchDelay(long delay, @NonNull TimeUnit unit) {
     return watchExecutor(new AndroidWatchExecutor(unit.toMillis(delay)));
   }
 
@@ -45,7 +45,7 @@
    * Whether we should automatically watch activities when calling {@link #buildAndInstall()}.
    * Default is true.
    */
-  @NonNull public AndroidRefWatcherBuilder watchActivities(boolean watchActivities) {
+  public @NonNull AndroidRefWatcherBuilder watchActivities(boolean watchActivities) {
     this.watchActivities = watchActivities;
     return this;
   }
@@ -55,7 +55,7 @@
    * Default is true. When true, LeakCanary watches native fragments on Android O+ and support
    * fragments if the leakcanary-support-fragment dependency is in the classpath.
    */
-  @NonNull public AndroidRefWatcherBuilder watchFragments(boolean watchFragments) {
+  public @NonNull AndroidRefWatcherBuilder watchFragments(boolean watchFragments) {
     this.watchFragments = watchFragments;
     return this;
   }
@@ -66,7 +66,7 @@
    *
    * @throws IllegalArgumentException if maxStoredHeapDumps < 1.
    */
-  @NonNull public AndroidRefWatcherBuilder maxStoredHeapDumps(int maxStoredHeapDumps) {
+  public @NonNull AndroidRefWatcherBuilder maxStoredHeapDumps(int maxStoredHeapDumps) {
     LeakDirectoryProvider leakDirectoryProvider =
         new DefaultLeakDirectoryProvider(context, maxStoredHeapDumps);
     LeakCanary.setLeakDirectoryProvider(leakDirectoryProvider);
@@ -81,7 +81,7 @@
    *
    * @throws UnsupportedOperationException if called more than once per Android process.
    */
-  @NonNull public RefWatcher buildAndInstall() {
+  public @NonNull RefWatcher buildAndInstall() {
     if (LeakCanaryInternals.installedRefWatcher != null) {
       throw new UnsupportedOperationException("buildAndInstall() should only be called once.");
     }
@@ -102,30 +102,30 @@
     return LeakCanary.isInAnalyzerProcess(context);
   }
 
-  @Override @NonNull protected HeapDumper defaultHeapDumper() {
+  @Override protected @NonNull HeapDumper defaultHeapDumper() {
     LeakDirectoryProvider leakDirectoryProvider =
         LeakCanaryInternals.getLeakDirectoryProvider(context);
     return new AndroidHeapDumper(context, leakDirectoryProvider);
   }
 
-  @Override @NonNull protected DebuggerControl defaultDebuggerControl() {
+  @Override protected @NonNull DebuggerControl defaultDebuggerControl() {
     return new AndroidDebuggerControl();
   }
 
-  @Override @NonNull protected HeapDump.Listener defaultHeapDumpListener() {
+  @Override protected @NonNull HeapDump.Listener defaultHeapDumpListener() {
     return new ServiceHeapDumpListener(context, DisplayLeakService.class);
   }
 
-  @Override @NonNull protected ExcludedRefs defaultExcludedRefs() {
+  @Override protected @NonNull ExcludedRefs defaultExcludedRefs() {
     return AndroidExcludedRefs.createAppDefaults().build();
   }
 
-  @Override @NonNull protected WatchExecutor defaultWatchExecutor() {
+  @Override protected @NonNull WatchExecutor defaultWatchExecutor() {
     return new AndroidWatchExecutor(DEFAULT_WATCH_DELAY_MILLIS);
   }
 
-  @Override @NonNull
-  protected List<Class<? extends Reachability.Inspector>> defaultReachabilityInspectorClasses() {
+  @Override protected @NonNull
+  List<Class<? extends Reachability.Inspector>> defaultReachabilityInspectorClasses() {
     return AndroidReachabilityInspectors.defaultAndroidInspectors();
   }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
index 3a4e81fa..c4f7e256 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
@@ -67,8 +67,7 @@ public DefaultLeakDirectoryProvider(@NonNull Context context, int maxStoredHeapD
     this.maxStoredHeapDumps = maxStoredHeapDumps;
   }
 
-  @NonNull
-  @Override public List<File> listFiles(@NonNull FilenameFilter filter) {
+  @Override public @NonNull List<File> listFiles(@NonNull FilenameFilter filter) {
     if (!hasStoragePermission()) {
       requestWritePermissionNotification();
     }
@@ -86,8 +85,7 @@ public DefaultLeakDirectoryProvider(@NonNull Context context, int maxStoredHeapD
     return files;
   }
 
-  @Nullable
-  @Override public File newHeapDumpFile() {
+  @Override public @Nullable File newHeapDumpFile() {
     List<File> pendingHeapDumps = listFiles(new FilenameFilter() {
       @Override public boolean accept(File dir, String filename) {
         return filename.endsWith(PENDING_HEAPDUMP_SUFFIX);
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
index 3b218447..8f4ab8d7 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -37,7 +37,7 @@
    * Creates a {@link RefWatcher} that works out of the box, and starts watching activity
    * references (on ICS+).
    */
-  @NonNull public static RefWatcher install(@NonNull Application application) {
+  public static @NonNull RefWatcher install(@NonNull Application application) {
     return refWatcher(application).listenerServiceClass(DisplayLeakService.class)
         .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
         .buildAndInstall();
@@ -48,7 +48,7 @@
    * {@link AndroidRefWatcherBuilder#buildAndInstall()}, and {@link RefWatcher#DISABLED} is no
    * {@link RefWatcher} has been installed.
    */
-  @NonNull public static RefWatcher installedRefWatcher() {
+  public static @NonNull RefWatcher installedRefWatcher() {
     RefWatcher refWatcher = LeakCanaryInternals.installedRefWatcher;
     if (refWatcher == null) {
       return RefWatcher.DISABLED;
@@ -56,7 +56,7 @@
     return refWatcher;
   }
 
-  @NonNull public static AndroidRefWatcherBuilder refWatcher(@NonNull Context context) {
+  public static @NonNull AndroidRefWatcherBuilder refWatcher(@NonNull Context context) {
     return new AndroidRefWatcherBuilder(context);
   }
 
@@ -92,7 +92,7 @@ public static void setLeakDirectoryProvider(
   }
 
   /** Returns a string representation of the result of a heap analysis. */
-  @NonNull public static String leakInfo(@NonNull Context context,
+  public static @NonNull String leakInfo(@NonNull Context context,
       @NonNull HeapDump heapDump,
       @NonNull AnalysisResult result,
       boolean detailed) {
