diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
index 479b09e0..8d06d27a 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
@@ -21,7 +21,9 @@
 import android.app.PendingIntent;
 import android.content.Context;
 import android.util.Log;
+
 import com.squareup.leakcanary.internal.DisplayLeakActivity;
+
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -82,10 +84,9 @@ protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
     heapDump = heapDump.renameFile(renamedFile);
 
     File resultFile = leakResultFile(renamedFile);
-    FileOutputStream fos = null;
+    ObjectOutputStream oos = null;
     try {
-      fos = new FileOutputStream(resultFile);
-      ObjectOutputStream oos = new ObjectOutputStream(fos);
+      oos = new ObjectOutputStream(new FileOutputStream(resultFile));
       oos.writeObject(heapDump);
       oos.writeObject(result);
     } catch (IOException e) {
@@ -93,12 +94,7 @@ protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
       afterDefaultHandling(heapDump, result, leakInfo);
       return;
     } finally {
-      if (fos != null) {
-        try {
-          fos.close();
-        } catch (IOException ignored) {
-        }
-      }
+      IOUtils.closeSilently(oos);
     }
 
     PendingIntent pendingIntent =
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/IOUtils.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/IOUtils.java
new file mode 100644
index 00000000..5bcdfdf5
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/IOUtils.java
@@ -0,0 +1,44 @@
+/*
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2014-2015 Umeng, Inc
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+package com.squareup.leakcanary;
+
+import java.io.Closeable;
+import java.io.IOException;
+
+public final class IOUtils {
+    private IOUtils() {
+        throw new RuntimeException("don't create IOUtils instance!");
+    }
+
+    public static void closeSilently(Closeable closeable) {
+        if (closeable != null) {
+            try {
+                closeable.close();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
index d39a8376..154fe249 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
@@ -38,9 +38,12 @@
 import android.widget.ListAdapter;
 import android.widget.ListView;
 import android.widget.TextView;
+
 import com.squareup.leakcanary.AnalysisResult;
 import com.squareup.leakcanary.HeapDump;
+import com.squareup.leakcanary.IOUtils;
 import com.squareup.leakcanary.R;
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FilenameFilter;
@@ -62,393 +65,409 @@
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.detectedLeakDirectory;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.leakResultFile;
 
-@SuppressWarnings("ConstantConditions") @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+@SuppressWarnings("ConstantConditions")
+@TargetApi(Build.VERSION_CODES.HONEYCOMB)
 public final class DisplayLeakActivity extends Activity {
 
-  private static final String TAG = "DisplayLeakActivity";
-  private static final String SHOW_LEAK_EXTRA = "show_latest";
-
-  public static PendingIntent createPendingIntent(Context context) {
-    return createPendingIntent(context, null);
-  }
-
-  public static PendingIntent createPendingIntent(Context context, String referenceKey) {
-    Intent intent = new Intent(context, DisplayLeakActivity.class);
-    intent.putExtra(SHOW_LEAK_EXTRA, referenceKey);
-    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
-    return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);
-  }
-
-  // null until it's been first loaded.
-  private List<Leak> leaks;
-  private String visibleLeakRefKey;
-
-  private ListView listView;
-  private TextView failureView;
-  private Button actionButton;
-  private int maxStoredLeaks;
-
-  @Override protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-
-    if (savedInstanceState != null) {
-      visibleLeakRefKey = savedInstanceState.getString("visibleLeakRefKey");
-    } else {
-      Intent intent = getIntent();
-      if (intent.hasExtra(SHOW_LEAK_EXTRA)) {
-        visibleLeakRefKey = intent.getStringExtra(SHOW_LEAK_EXTRA);
-      }
+    private static final String TAG = "DisplayLeakActivity";
+    private static final String SHOW_LEAK_EXTRA = "show_latest";
+
+    public static PendingIntent createPendingIntent(Context context) {
+        return createPendingIntent(context, null);
     }
 
-    //noinspection unchecked
-    leaks = (List<Leak>) getLastNonConfigurationInstance();
+    public static PendingIntent createPendingIntent(Context context, String referenceKey) {
+        Intent intent = new Intent(context, DisplayLeakActivity.class);
+        intent.putExtra(SHOW_LEAK_EXTRA, referenceKey);
+        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
+        return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);
+    }
 
-    setContentView(R.layout.leak_canary_display_leak);
+    // null until it's been first loaded.
+    private List<Leak> leaks;
+    private String visibleLeakRefKey;
 
-    listView = (ListView) findViewById(R.id.__leak_canary_display_leak_list);
-    failureView = (TextView) findViewById(R.id.__leak_canary_display_leak_failure);
-    actionButton = (Button) findViewById(R.id.__leak_canary_action);
+    private ListView listView;
+    private TextView failureView;
+    private Button actionButton;
+    private int maxStoredLeaks;
 
-    maxStoredLeaks = getResources().getInteger(R.integer.leak_canary_max_stored_leaks);
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
 
-    updateUi();
-  }
+        if (savedInstanceState != null) {
+            visibleLeakRefKey = savedInstanceState.getString("visibleLeakRefKey");
+        } else {
+            Intent intent = getIntent();
+            if (intent.hasExtra(SHOW_LEAK_EXTRA)) {
+                visibleLeakRefKey = intent.getStringExtra(SHOW_LEAK_EXTRA);
+            }
+        }
 
-  // No, it's not deprecated. Android lies.
-  @Override public Object onRetainNonConfigurationInstance() {
-    return leaks;
-  }
+        //noinspection unchecked
+        leaks = (List<Leak>) getLastNonConfigurationInstance();
 
-  @Override protected void onSaveInstanceState(Bundle outState) {
-    super.onSaveInstanceState(outState);
-    outState.putString("visibleLeakRefKey", visibleLeakRefKey);
-  }
+        setContentView(R.layout.leak_canary_display_leak);
 
-  @Override protected void onResume() {
-    super.onResume();
-    LoadLeaks.load(this);
-  }
+        listView = (ListView) findViewById(R.id.__leak_canary_display_leak_list);
+        failureView = (TextView) findViewById(R.id.__leak_canary_display_leak_failure);
+        actionButton = (Button) findViewById(R.id.__leak_canary_action);
 
-  @Override protected void onDestroy() {
-    super.onDestroy();
-    LoadLeaks.forgetActivity();
-  }
+        maxStoredLeaks = getResources().getInteger(R.integer.leak_canary_max_stored_leaks);
 
-  @Override public boolean onCreateOptionsMenu(Menu menu) {
-    if (getVisibleLeak() != null) {
-      menu.add(R.string.leak_canary_share_leak)
-          .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
-            @Override public boolean onMenuItemClick(MenuItem item) {
-              shareLeak();
-              return true;
-            }
-          });
-      menu.add(R.string.leak_canary_share_heap_dump)
-          .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
-            @Override public boolean onMenuItemClick(MenuItem item) {
-              shareHeapDump();
-              return true;
-            }
-          });
-      return true;
+        updateUi();
     }
-    return false;
-  }
 
-  @Override public boolean onOptionsItemSelected(MenuItem item) {
-    if (item.getItemId() == android.R.id.home) {
-      visibleLeakRefKey = null;
-      updateUi();
-    }
-    return true;
-  }
-
-  @Override public void onBackPressed() {
-    if (visibleLeakRefKey != null) {
-      visibleLeakRefKey = null;
-      updateUi();
-    } else {
-      super.onBackPressed();
+    // No, it's not deprecated. Android lies.
+    @Override
+    public Object onRetainNonConfigurationInstance() {
+        return leaks;
     }
-  }
-
-  private void shareLeak() {
-    Leak visibleLeak = getVisibleLeak();
-    String leakInfo = leakInfo(this, visibleLeak.heapDump, visibleLeak.result, true);
-    Intent intent = new Intent(Intent.ACTION_SEND);
-    intent.setType("text/plain");
-    intent.putExtra(Intent.EXTRA_TEXT, leakInfo);
-    startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
-  }
-
-  private void shareHeapDump() {
-    Leak visibleLeak = getVisibleLeak();
-    File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
-    heapDumpFile.setReadable(true, false);
-    Intent intent = new Intent(Intent.ACTION_SEND);
-    intent.setType("application/octet-stream");
-    intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(heapDumpFile));
-    startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
-  }
-
-  private void updateUi() {
-    if (leaks == null) {
-      setTitle("Loading leaks...");
-      return;
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        outState.putString("visibleLeakRefKey", visibleLeakRefKey);
     }
-    if (leaks.isEmpty()) {
-      visibleLeakRefKey = null;
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        LoadLeaks.load(this);
     }
 
-    final Leak visibleLeak = getVisibleLeak();
-    if (visibleLeak == null) {
-      visibleLeakRefKey = null;
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        LoadLeaks.forgetActivity();
     }
 
-    ListAdapter listAdapter = listView.getAdapter();
-    // Reset to defaults
-    listView.setVisibility(VISIBLE);
-    failureView.setVisibility(GONE);
-
-    if (visibleLeak != null) {
-      AnalysisResult result = visibleLeak.result;
-      if (result.failure != null) {
-        listView.setVisibility(GONE);
-        failureView.setVisibility(VISIBLE);
-        failureView.setText(
-            getString(R.string.leak_canary_failure_report) + Log.getStackTraceString(
-                result.failure));
-        setTitle(R.string.leak_canary_analysis_failed);
-        invalidateOptionsMenu();
-        getActionBar().setDisplayHomeAsUpEnabled(true);
-        actionButton.setVisibility(VISIBLE);
-        actionButton.setText(R.string.leak_canary_delete);
-        listView.setAdapter(null);
-      } else {
-        final DisplayLeakAdapter adapter;
-        if (listAdapter instanceof DisplayLeakAdapter) {
-          adapter = (DisplayLeakAdapter) listAdapter;
-        } else {
-          adapter = new DisplayLeakAdapter();
-          listView.setAdapter(adapter);
-          listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-            @Override
-            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-              adapter.toggleRow(position);
-            }
-          });
-          invalidateOptionsMenu();
-          getActionBar().setDisplayHomeAsUpEnabled(true);
-          actionButton.setVisibility(VISIBLE);
-          actionButton.setText(R.string.leak_canary_delete);
-          actionButton.setOnClickListener(new View.OnClickListener() {
-            @Override public void onClick(View v) {
-              Leak visibleLeak = getVisibleLeak();
-              File resultFile = leakResultFile(visibleLeak.heapDump.heapDumpFile);
-              resultFile.delete();
-              visibleLeak.heapDump.heapDumpFile.delete();
-              visibleLeakRefKey = null;
-              leaks.remove(visibleLeak);
-              updateUi();
-            }
-          });
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        if (getVisibleLeak() != null) {
+            menu.add(R.string.leak_canary_share_leak)
+                    .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
+                        @Override
+                        public boolean onMenuItemClick(MenuItem item) {
+                            shareLeak();
+                            return true;
+                        }
+                    });
+            menu.add(R.string.leak_canary_share_heap_dump)
+                    .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
+                        @Override
+                        public boolean onMenuItemClick(MenuItem item) {
+                            shareHeapDump();
+                            return true;
+                        }
+                    });
+            return true;
         }
-        HeapDump heapDump = visibleLeak.heapDump;
-        adapter.update(result.leakTrace, heapDump.referenceKey, heapDump.referenceName);
-        setTitle(
-            getString(R.string.leak_canary_class_has_leaked, classSimpleName(result.className)));
-      }
-    } else {
-      if (listAdapter instanceof LeakListAdapter) {
-        ((LeakListAdapter) listAdapter).notifyDataSetChanged();
-      } else {
-        LeakListAdapter adapter = new LeakListAdapter();
-        listView.setAdapter(adapter);
-        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-          @Override
-          public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-            visibleLeakRefKey = leaks.get(position).heapDump.referenceKey;
-            updateUi();
-          }
-        });
-        invalidateOptionsMenu();
-        setTitle(getString(R.string.leak_canary_leak_list_title, getPackageName()));
-        getActionBar().setDisplayHomeAsUpEnabled(false);
-        actionButton.setText(R.string.leak_canary_delete_all);
-        actionButton.setOnClickListener(new View.OnClickListener() {
-          @Override public void onClick(View v) {
-            File[] files = detectedLeakDirectory().listFiles();
-            if (files != null) {
-              for (File file : files) {
-                file.delete();
-              }
-            }
-            leaks = Collections.emptyList();
-            updateUi();
-          }
-        });
-      }
-      actionButton.setVisibility(leaks.size() == 0 ? GONE : VISIBLE);
+        return false;
     }
-  }
 
-  private Leak getVisibleLeak() {
-    if (leaks == null) {
-      return null;
-    }
-    for (Leak leak : leaks) {
-      if (leak.heapDump.referenceKey.equals(visibleLeakRefKey)) {
-        return leak;
-      }
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        if (item.getItemId() == android.R.id.home) {
+            visibleLeakRefKey = null;
+            updateUi();
+        }
+        return true;
     }
-    return null;
-  }
 
-  class LeakListAdapter extends BaseAdapter {
+    @Override
+    public void onBackPressed() {
+        if (visibleLeakRefKey != null) {
+            visibleLeakRefKey = null;
+            updateUi();
+        } else {
+            super.onBackPressed();
+        }
+    }
 
-    @Override public int getCount() {
-      return leaks.size();
+    private void shareLeak() {
+        Leak visibleLeak = getVisibleLeak();
+        String leakInfo = leakInfo(this, visibleLeak.heapDump, visibleLeak.result, true);
+        Intent intent = new Intent(Intent.ACTION_SEND);
+        intent.setType("text/plain");
+        intent.putExtra(Intent.EXTRA_TEXT, leakInfo);
+        startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
     }
 
-    @Override public Leak getItem(int position) {
-      return leaks.get(position);
+    private void shareHeapDump() {
+        Leak visibleLeak = getVisibleLeak();
+        File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
+        heapDumpFile.setReadable(true, false);
+        Intent intent = new Intent(Intent.ACTION_SEND);
+        intent.setType("application/octet-stream");
+        intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(heapDumpFile));
+        startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
     }
 
-    @Override public long getItemId(int position) {
-      return position;
+    private void updateUi() {
+        if (leaks == null) {
+            setTitle("Loading leaks...");
+            return;
+        }
+        if (leaks.isEmpty()) {
+            visibleLeakRefKey = null;
+        }
+
+        final Leak visibleLeak = getVisibleLeak();
+        if (visibleLeak == null) {
+            visibleLeakRefKey = null;
+        }
+
+        ListAdapter listAdapter = listView.getAdapter();
+        // Reset to defaults
+        listView.setVisibility(VISIBLE);
+        failureView.setVisibility(GONE);
+
+        if (visibleLeak != null) {
+            AnalysisResult result = visibleLeak.result;
+            if (result.failure != null) {
+                listView.setVisibility(GONE);
+                failureView.setVisibility(VISIBLE);
+                failureView.setText(
+                        getString(R.string.leak_canary_failure_report) + Log.getStackTraceString(
+                                result.failure));
+                setTitle(R.string.leak_canary_analysis_failed);
+                invalidateOptionsMenu();
+                getActionBar().setDisplayHomeAsUpEnabled(true);
+                actionButton.setVisibility(VISIBLE);
+                actionButton.setText(R.string.leak_canary_delete);
+                listView.setAdapter(null);
+            } else {
+                final DisplayLeakAdapter adapter;
+                if (listAdapter instanceof DisplayLeakAdapter) {
+                    adapter = (DisplayLeakAdapter) listAdapter;
+                } else {
+                    adapter = new DisplayLeakAdapter();
+                    listView.setAdapter(adapter);
+                    listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+                        @Override
+                        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
+                            adapter.toggleRow(position);
+                        }
+                    });
+                    invalidateOptionsMenu();
+                    getActionBar().setDisplayHomeAsUpEnabled(true);
+                    actionButton.setVisibility(VISIBLE);
+                    actionButton.setText(R.string.leak_canary_delete);
+                    actionButton.setOnClickListener(new View.OnClickListener() {
+                        @Override
+                        public void onClick(View v) {
+                            Leak visibleLeak = getVisibleLeak();
+                            File resultFile = leakResultFile(visibleLeak.heapDump.heapDumpFile);
+                            resultFile.delete();
+                            visibleLeak.heapDump.heapDumpFile.delete();
+                            visibleLeakRefKey = null;
+                            leaks.remove(visibleLeak);
+                            updateUi();
+                        }
+                    });
+                }
+                HeapDump heapDump = visibleLeak.heapDump;
+                adapter.update(result.leakTrace, heapDump.referenceKey, heapDump.referenceName);
+                setTitle(
+                        getString(R.string.leak_canary_class_has_leaked, classSimpleName(result.className)));
+            }
+        } else {
+            if (listAdapter instanceof LeakListAdapter) {
+                ((LeakListAdapter) listAdapter).notifyDataSetChanged();
+            } else {
+                LeakListAdapter adapter = new LeakListAdapter();
+                listView.setAdapter(adapter);
+                listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+                    @Override
+                    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
+                        visibleLeakRefKey = leaks.get(position).heapDump.referenceKey;
+                        updateUi();
+                    }
+                });
+                invalidateOptionsMenu();
+                setTitle(getString(R.string.leak_canary_leak_list_title, getPackageName()));
+                getActionBar().setDisplayHomeAsUpEnabled(false);
+                actionButton.setText(R.string.leak_canary_delete_all);
+                actionButton.setOnClickListener(new View.OnClickListener() {
+                    @Override
+                    public void onClick(View v) {
+                        File[] files = detectedLeakDirectory().listFiles();
+                        if (files != null) {
+                            for (File file : files) {
+                                file.delete();
+                            }
+                        }
+                        leaks = Collections.emptyList();
+                        updateUi();
+                    }
+                });
+            }
+            actionButton.setVisibility(leaks.size() == 0 ? GONE : VISIBLE);
+        }
     }
 
-    @Override public View getView(int position, View convertView, ViewGroup parent) {
-      if (convertView == null) {
-        convertView = LayoutInflater.from(DisplayLeakActivity.this)
-            .inflate(R.layout.leak_canary_leak_row, parent, false);
-      }
-      TextView titleView = (TextView) convertView.findViewById(R.id.__leak_canary_row_text);
-      TextView timeView = (TextView) convertView.findViewById(R.id.__leak_canary_row_time);
-      Leak leak = getItem(position);
-
-      String index;
-      if (position == 0 && leaks.size() == maxStoredLeaks) {
-        index = "MAX. ";
-      } else {
-        index = (leaks.size() - position) + ". ";
-      }
-
-      String title;
-      if (leak.result.failure == null) {
-        title = index + getString(R.string.leak_canary_class_has_leaked,
-            classSimpleName(leak.result.className));
-      } else {
-        title = index
-            + leak.result.failure.getClass().getSimpleName()
-            + " "
-            + leak.result.failure.getMessage();
-      }
-      titleView.setText(title);
-      String time = DateUtils.formatDateTime(DisplayLeakActivity.this,
-          leak.heapDump.heapDumpFile.lastModified(), FORMAT_SHOW_TIME | FORMAT_SHOW_DATE);
-      timeView.setText(time);
-      return convertView;
+    private Leak getVisibleLeak() {
+        if (leaks == null) {
+            return null;
+        }
+        for (Leak leak : leaks) {
+            if (leak.heapDump.referenceKey.equals(visibleLeakRefKey)) {
+                return leak;
+            }
+        }
+        return null;
     }
-  }
 
-  static class Leak {
-    final HeapDump heapDump;
-    final AnalysisResult result;
+    class LeakListAdapter extends BaseAdapter {
 
-    Leak(HeapDump heapDump, AnalysisResult result) {
-      this.heapDump = heapDump;
-      this.result = result;
-    }
-  }
+        @Override
+        public int getCount() {
+            return leaks.size();
+        }
 
-  static class LoadLeaks implements Runnable {
+        @Override
+        public Leak getItem(int position) {
+            return leaks.get(position);
+        }
 
-    static final List<LoadLeaks> inFlight = new ArrayList<>();
+        @Override
+        public long getItemId(int position) {
+            return position;
+        }
 
-    static final Executor backgroundExecutor = Executors.newSingleThreadExecutor();
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+            if (convertView == null) {
+                convertView = LayoutInflater.from(DisplayLeakActivity.this)
+                        .inflate(R.layout.leak_canary_leak_row, parent, false);
+            }
+            TextView titleView = (TextView) convertView.findViewById(R.id.__leak_canary_row_text);
+            TextView timeView = (TextView) convertView.findViewById(R.id.__leak_canary_row_time);
+            Leak leak = getItem(position);
+
+            String index;
+            if (position == 0 && leaks.size() == maxStoredLeaks) {
+                index = "MAX. ";
+            } else {
+                index = (leaks.size() - position) + ". ";
+            }
 
-    static void load(DisplayLeakActivity activity) {
-      LoadLeaks loadLeaks = new LoadLeaks(activity);
-      inFlight.add(loadLeaks);
-      backgroundExecutor.execute(loadLeaks);
+            String title;
+            if (leak.result.failure == null) {
+                title = index + getString(R.string.leak_canary_class_has_leaked,
+                        classSimpleName(leak.result.className));
+            } else {
+                title = index
+                        + leak.result.failure.getClass().getSimpleName()
+                        + " "
+                        + leak.result.failure.getMessage();
+            }
+            titleView.setText(title);
+            String time = DateUtils.formatDateTime(DisplayLeakActivity.this,
+                    leak.heapDump.heapDumpFile.lastModified(), FORMAT_SHOW_TIME | FORMAT_SHOW_DATE);
+            timeView.setText(time);
+            return convertView;
+        }
     }
 
-    static void forgetActivity() {
-      for (LoadLeaks loadLeaks : inFlight) {
-        loadLeaks.activityOrNull = null;
-      }
-      inFlight.clear();
+    static class Leak {
+        final HeapDump heapDump;
+        final AnalysisResult result;
+
+        Leak(HeapDump heapDump, AnalysisResult result) {
+            this.heapDump = heapDump;
+            this.result = result;
+        }
     }
 
-    private DisplayLeakActivity activityOrNull;
-    private final File leakDirectory;
-    private final Handler mainHandler;
+    static class LoadLeaks implements Runnable {
 
-    LoadLeaks(DisplayLeakActivity activity) {
-      this.activityOrNull = activity;
-      leakDirectory = detectedLeakDirectory();
-      mainHandler = new Handler(Looper.getMainLooper());
-    }
+        static final List<LoadLeaks> inFlight = new ArrayList<>();
 
-    @Override public void run() {
-      final List<Leak> leaks = new ArrayList<>();
-      File[] files = leakDirectory.listFiles(new FilenameFilter() {
-        @Override public boolean accept(File dir, String filename) {
-          return filename.endsWith(".hprof");
+        static final Executor backgroundExecutor = Executors.newSingleThreadExecutor();
+
+        static void load(DisplayLeakActivity activity) {
+            LoadLeaks loadLeaks = new LoadLeaks(activity);
+            inFlight.add(loadLeaks);
+            backgroundExecutor.execute(loadLeaks);
         }
-      });
-      if (files != null) {
-        for (File heapDumpFile : files) {
-          File resultFile = leakResultFile(heapDumpFile);
-          FileInputStream fis = null;
-          try {
-            fis = new FileInputStream(resultFile);
-            ObjectInputStream ois = new ObjectInputStream(fis);
-            HeapDump heapDump = (HeapDump) ois.readObject();
-            AnalysisResult result = (AnalysisResult) ois.readObject();
-            leaks.add(new Leak(heapDump, result));
-          } catch (IOException | ClassNotFoundException e) {
-            // Likely a change in the serializable result class.
-            // Let's remove the files, we can't read them anymore.
-            heapDumpFile.delete();
-            resultFile.delete();
-            Log.e(TAG, "Could not read result file, deleted result and heap dump:" + heapDumpFile,
-                e);
-          } finally {
-            if (fis != null) {
-              try {
-                fis.close();
-              } catch (IOException ignored) {
-              }
+
+        static void forgetActivity() {
+            for (LoadLeaks loadLeaks : inFlight) {
+                loadLeaks.activityOrNull = null;
             }
-          }
+            inFlight.clear();
         }
-        Collections.sort(leaks, new Comparator<Leak>() {
-          @Override public int compare(Leak lhs, Leak rhs) {
-            return Long.valueOf(rhs.heapDump.heapDumpFile.lastModified())
-                .compareTo(lhs.heapDump.heapDumpFile.lastModified());
-          }
-        });
-      }
-      mainHandler.post(new Runnable() {
-        @Override public void run() {
-          inFlight.remove(LoadLeaks.this);
-          if (activityOrNull != null) {
-            activityOrNull.leaks = leaks;
-            activityOrNull.updateUi();
-          }
+
+        private DisplayLeakActivity activityOrNull;
+        private final File leakDirectory;
+        private final Handler mainHandler;
+
+        LoadLeaks(DisplayLeakActivity activity) {
+            this.activityOrNull = activity;
+            leakDirectory = detectedLeakDirectory();
+            mainHandler = new Handler(Looper.getMainLooper());
+        }
+
+        @Override
+        public void run() {
+            final List<Leak> leaks = new ArrayList<>();
+            File[] files = leakDirectory.listFiles(new FilenameFilter() {
+                @Override
+                public boolean accept(File dir, String filename) {
+                    return filename.endsWith(".hprof");
+                }
+            });
+            if (files != null) {
+                for (File heapDumpFile : files) {
+                    File resultFile = leakResultFile(heapDumpFile);
+                    ObjectInputStream ois = null;
+                    try {
+                        ois = new ObjectInputStream(new FileInputStream(resultFile));
+                        HeapDump heapDump = (HeapDump) ois.readObject();
+                        AnalysisResult result = (AnalysisResult) ois.readObject();
+                        leaks.add(new Leak(heapDump, result));
+                    } catch (IOException | ClassNotFoundException e) {
+                        // Likely a change in the serializable result class.
+                        // Let's remove the files, we can't read them anymore.
+                        heapDumpFile.delete();
+                        resultFile.delete();
+                        Log.e(TAG, "Could not read result file, deleted result and heap dump:"
+                                        + heapDumpFile,
+                                e);
+                    } finally {
+                        IOUtils.closeSilently(ois);
+                    }
+                }
+                Collections.sort(leaks, new Comparator<Leak>() {
+                    @Override
+                    public int compare(Leak lhs, Leak rhs) {
+                        return Long.valueOf(rhs.heapDump.heapDumpFile.lastModified())
+                                .compareTo(lhs.heapDump.heapDumpFile.lastModified());
+                    }
+                });
+            }
+            mainHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    inFlight.remove(LoadLeaks.this);
+                    if (activityOrNull != null) {
+                        activityOrNull.leaks = leaks;
+                        activityOrNull.updateUi();
+                    }
+                }
+            });
         }
-      });
     }
-  }
-
-  static String classSimpleName(String className) {
-    int separator = className.lastIndexOf('.');
-    if (separator == -1) {
-      return className;
-    } else {
-      return className.substring(separator + 1);
+
+    static String classSimpleName(String className) {
+        int separator = className.lastIndexOf('.');
+        if (separator == -1) {
+            return className;
+        } else {
+            return className.substring(separator + 1);
+        }
     }
-  }
 }
