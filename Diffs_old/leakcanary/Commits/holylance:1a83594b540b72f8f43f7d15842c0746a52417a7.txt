diff --git a/.github/CODE_OF_CONDUCT.md b/.github/CODE_OF_CONDUCT.md
index a2e9a460..173a1908 100644
--- a/.github/CODE_OF_CONDUCT.md
+++ b/.github/CODE_OF_CONDUCT.md
@@ -1,76 +1 @@
-# Contributor Covenant Code of Conduct
-
-## Our Pledge
-
-In the interest of fostering an open and welcoming environment, we as
-contributors and maintainers pledge to making participation in our project and
-our community a harassment-free experience for everyone, regardless of age, body
-size, disability, ethnicity, sex characteristics, gender identity and expression,
-level of experience, education, socio-economic status, nationality, personal
-appearance, race, religion, or sexual identity and orientation.
-
-## Our Standards
-
-Examples of behavior that contributes to creating a positive environment
-include:
-
-* Using welcoming and inclusive language
-* Being respectful of differing viewpoints and experiences
-* Gracefully accepting constructive criticism
-* Focusing on what is best for the community
-* Showing empathy towards other community members
-
-Examples of unacceptable behavior by participants include:
-
-* The use of sexualized language or imagery and unwelcome sexual attention or
- advances
-* Trolling, insulting/derogatory comments, and personal or political attacks
-* Public or private harassment
-* Publishing others' private information, such as a physical or electronic
- address, without explicit permission
-* Other conduct which could reasonably be considered inappropriate in a
- professional setting
-
-## Our Responsibilities
-
-Project maintainers are responsible for clarifying the standards of acceptable
-behavior and are expected to take appropriate and fair corrective action in
-response to any instances of unacceptable behavior.
-
-Project maintainers have the right and responsibility to remove, edit, or
-reject comments, commits, code, wiki edits, issues, and other contributions
-that are not aligned to this Code of Conduct, or to ban temporarily or
-permanently any contributor for other behaviors that they deem inappropriate,
-threatening, offensive, or harmful.
-
-## Scope
-
-This Code of Conduct applies both within project spaces and in public spaces
-when an individual is representing the project or its community. Examples of
-representing a project or community include using an official project e-mail
-address, posting via an official social media account, or acting as an appointed
-representative at an online or offline event. Representation of a project may be
-further defined and clarified by project maintainers.
-
-## Enforcement
-
-Instances of abusive, harassing, or otherwise unacceptable behavior may be
-reported by contacting the project team at py.ricau+leakcanary-coc@gmail.com. All
-complaints will be reviewed and investigated and will result in a response that
-is deemed necessary and appropriate to the circumstances. The project team is
-obligated to maintain confidentiality with regard to the reporter of an incident.
-Further details of specific enforcement policies may be posted separately.
-
-Project maintainers who do not follow or enforce the Code of Conduct in good
-faith may face temporary or permanent repercussions as determined by other
-members of the project's leadership.
-
-## Attribution
-
-This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
-available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html
-
-[homepage]: https://www.contributor-covenant.org
-
-For answers to common questions about this code of conduct, see
-https://www.contributor-covenant.org/faq
+See https://square.github.io/leakcanary/code_of_conduct
\ No newline at end of file
diff --git a/.github/CONTRIBUTING.md b/.github/CONTRIBUTING.md
index 7b4fb258..07ea8d16 100644
--- a/.github/CONTRIBUTING.md
+++ b/.github/CONTRIBUTING.md
@@ -1,8 +1 @@
-# Contributing
-
-If you would like to contribute code to LeakCanary you can do so through GitHub by
-forking the repository and sending a pull request.
-
-When submitting code, please make every effort to follow existing conventions
-and style in order to keep the code as readable as possible. Please also make
-sure your code compiles by running `./gradlew build`.
+See https://square.github.io/leakcanary/contributing
\ No newline at end of file
diff --git a/.github/SUPPORT.md b/.github/SUPPORT.md
index e9a414df..8872c01e 100644
--- a/.github/SUPPORT.md
+++ b/.github/SUPPORT.md
@@ -1,12 +1 @@
-# LeakCanary Support
-
-If you're looking for support for LeakCanary:
-
-* Learn the [Fundamentals](#fundamentals)
-* Try the [code recipes](#code-recipes)
-* Read the [FAQ](#faq)
-* Watch [recorded presentations](https://github.com/square/leakcanary/wiki/Recorded-Presentations)
-* Read [blog articles](https://github.com/square/leakcanary/wiki/Blog-Articles)
-* Check out the StackOverflow [LeakCanary tag](http://stackoverflow.com/questions/tagged/leakcanary) and ask a question
-
-Feel free to edit this file to add links to online communities that can help developers investigate LeakCanary leaks.
+See https://square.github.io/leakcanary/support
\ No newline at end of file
diff --git a/.gitignore b/.gitignore
index 3e76ed69..8b05348b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -34,3 +34,6 @@ out
 
 # Finder
 .DS_Store
+
+# Docs
+site
\ No newline at end of file
diff --git a/README.md b/README.md
index 67d8cced..43f65124 100644
--- a/README.md
+++ b/README.md
@@ -1,362 +1,8 @@
-# üê§ LeakCanary
+# LeakCanary üê§
 
 A memory leak detection library for Android.
 
-*‚ÄúA small leak will sink a great ship.‚Äù* - Benjamin Franklin
-
-<p align="center">
-<img src="https://github.com/square/leakcanary/wiki/assets/screenshot-2.0.png"/>
-</p>
-
-## Getting started
-
-Add LeakCanary to `build.gradle`:
-
-```gradle
-dependencies {
-  // debugImplementation because LeakCanary should only run in debug builds.
-  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-2'
-}
-```
-
-**That's it, there is no code change needed!** LeakCanary will automatically show a notification when a memory leak is detected in debug builds.
-
-What's next?
-* Learn the [Fundamentals](#fundamentals)
-* Try the [code recipes](#code-recipes)
-* Read the [FAQ](#faq)
-* Watch [recorded presentations](https://github.com/square/leakcanary/wiki/Recorded-Presentations)
-* Read [blog articles](https://github.com/square/leakcanary/wiki/Blog-Articles)
-
-Note: **LeakCanary 2 is in alpha**.
-* Check out the [migration guide](https://github.com/square/leakcanary/wiki/Migrating-to-LeakCanary-2.0).
-* Here is the [change log](https://github.com/square/leakcanary/blob/master/CHANGELOG.md#version-20-alpha-2-2019-05-21).
-* To set up LeakCanary 1.6, go to the [1.6 Readme](https://github.com/square/leakcanary/blob/master/README-1.6.md).
-
-## Fundamentals
-
-### What is a memory leak?
-
-In a Java based runtime, a memory leak is a programming error that causes an application to keep a reference to an object that is no longer needed. As a result, the memory allocated for that object cannot be reclaimed, eventually leading to an OutOfMemoryError crash.
-
-For example, an Android activity instance is no longer needed after its `onDestroy()` method is called, and storing a reference to that activity in a static field would prevent it from being garbage collected.
-
-### Why should I use LeakCanary?
-
-Memory leaks are very common in Android apps. OutOfMemoryError (OOM) is the top crash for most apps on the play store, however that's usually not counted correctly. When memory is low the OOM can be thrown from anywhere in your code, which means every OOM has a different stacktrace and they're counted as different crashes.
-
-When we first enabled LeakCanary in the Square Point Of Sale app, we were able to find and fix several leaks and reduced the OutOfMemoryError crash rate by **94%**.
-
-### How does LeakCanary work?
-
-* The library automatically watches destroyed activities and destroyed fragments using weak references. You can also watch any instance that is no longer needed, e.g. a detached view.
-* If the weak references aren't cleared, after waiting 5 seconds and running the GC, the watched instances are considered *retained*, and potentially leaking.
-* When the number of retained instances reaches a threshold, LeakCanary dumps the Java heap into a `.hprof` file stored on the file system. The default threshold is 5 retained instances when the app is visible, 1 otherwise.
-* LeakCanary parses the `.hprof` file and finds the chain of references that prevents retained instances from being garbage collected (**leak trace**). A leak trace is technically the *shortest strong reference path from GC Roots to retained instances*, but that's a mouthful.
-* Once the leak trace is determined, LeakCanary uses its built in knowledge of the Android framework to deduct which instances in the leak trace are leaking. You can help LeakCanary by providing **Reachability inspectors** tailored to your own app.
-* Using the reachability information, LeakCanary narrows down the reference chain to a sub chain of possible leak causes, and displays the result. Leaks are grouped by identical sub chain.
-
-### How do I fix a memory leak?
-To fix a memory leak, you need to look at the sub chain of possible leak causes and find which reference is causing the leak, i.e. which reference should have been cleared at the time of the leak. LeakCanary highlights with a red underline wave the references that are the possible causes of the leak.
-
-If you cannot figure out a leak, **please do not file an issue**. Instead, create a [Stack Overflow question](http://stackoverflow.com/questions/tagged/leakcanary) using the *leakcanary* tag.
-
-### LeakCanary artifacts
-
-LeakCanary is released as several distinct libraries:
-
-* LeakSentry
-  * Detects retained instances.
-  * Suitable for release builds.
-  * Artifact id: `com.squareup.leakcanary:leaksentry`.
-* LeakCanary
-  * Dumps the heap and analyzes it.
-  * Currently only suitable for debug builds.
-  * Depends on LeakSentry.
-  * Artifact id: `com.squareup.leakcanary:leakcanary-android`.
-* LeakCanary for Instrumentation tests
-  * Fails tests if a leak is detected
-  * Only suitable for Instrumentation tests
-  * Configures LeakCanary to wait for the end of tests before dumping the heap.
-  * Artifact id: `com.squareup.leakcanary:leakcanary-android-instrumentation`.
-  * See [Running LeakCanary in instrumentation tests](#running-leakcanary-in-instrumentation-tests)
-
-## Code Recipes
-
-If you think a recipe might be missing or you're not sure that what you're trying to achieve is possible with the current APIs, please [file an issue](https://github.com/square/leakcanary/issues/new/choose). Your feedback help us make LeakCanary better for the entire community.
-
-### Configuring LeakSentry
-
-LeakSentry can be configured by replacing `LeakSentry.config`:
-```kotlin
-class DebugExampleApplication : ExampleApplication() {
-
-  override fun onCreate() {
-    super.onCreate()
-    LeakSentry.config = LeakSentry.config.copy(watchFragmentViews = false)
-  }
-}
-```
-
-### Configuring LeakCanary
-
-LeakCanary can be configured by replacing `LeakCanary.config`:
-
-```kotlin
-disableLeakCanaryButton.setOnClickListener {
-  LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
-}
-```
-
-### Watching objects with a lifecycle
-
-In your application, you may have other objects with a lifecycle, such as fragments, services, Dagger components, etc. Use `LeakSentry.refWatcher` to watch instances that should be garbage collected:
-
-```kotlin
-class MyService : Service {
-
-  // ...
-
-  override fun onDestroy() {
-    super.onDestroy()
-    LeakSentry.refWatcher.watch(this)
-  }
-}
-```
-
-### Counting retained instances in production
-
-`com.squareup.leakcanary:leakcanary-android` should only be used in debug builds. It depends on `com.squareup.leakcanary:leaksentry` which you can use in production to track and count retained instances.
-
-In your `build.gradle`:
-
-```gradle
-dependencies {
-  implementation 'com.squareup.leakcanary:leaksentry:2.0-alpha-2'
-}
-```
-
-In your leak reporting code:
-```kotlin
-val retainedInstanceCount = LeakSentry.refWatcher.retainedKeys.size
-```
-
-### Running LeakCanary in instrumentation tests
-
-Add the `leakcanary-android-instrumentation` dependency to your instrumentation tests:
-
-```
-androidTestImplementation "com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion}"
-```
-
-Add the dedicated run listener to `defaultConfig` in your `build.gradle`:
-
-```
-android {
-  defaultConfig {
-    // ...
-
-    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
-    testInstrumentationRunnerArgument "listener", "leakcanary.FailTestOnLeakRunListener"
-  }
-}
-```
-
-Run the instrumentation tests:
-
-```
-./gradlew leakcanary-sample:connectedCheck
-```
-
-You can extend `FailTestOnLeakRunListener` to customize the behavior.
-
-### Icon and label
-
-The activity that displays leaks comes with a default icon and label, which you can change by providing `R.mipmap.leak_canary_icon` and `R.string.leak_canary_display_activity_label` in your app:
-
-```
-res/
-  mipmap-hdpi/
-    leak_canary_icon.png
-  mipmap-mdpi/
-    leak_canary_icon.png
-  mipmap-xhdpi/
-    leak_canary_icon.png
-  mipmap-xxhdpi/
-    leak_canary_icon.png
-  mipmap-xxxhdpi/
-    leak_canary_icon.png
-   mipmap-anydpi-v26/
-     leak_canary_icon.xml
-```
-
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-  <string name="leak_canary_display_activity_label">MyLeaks</string>
-</resources>
-```
-
-### Uploading to a server
-
-You can change the default behavior to upload the analysis result to a server of your choosing.
-
-Create a custom `AnalysisResultListener` that delegates to the default: 
-
-```kotlin
-class LeakUploader : AnalysisResultListener {
-  override fun invoke(
-    application: Application,
-    heapAnalysis: HeapAnalysis
-  ) {
-    TODO("Upload heap analysis to server")
-
-    // Delegate to default behavior (notification and saving result)
-    DefaultAnalysisResultListener(application, heapAnalysis)
-  }
-}
-```
-
-Set `analysisResultListener` on the LeakCanary config:
-
-```kotlin
-class DebugExampleApplication : ExampleApplication() {
-
-  override fun onCreate() {
-    super.onCreate()
-    LeakCanary.config = LeakCanary.config.copy(analysisResultListener = LeakUploader())
-  }
-}
-```
-
-
-### Identifying 3rd party leaks as "won't fix"
-
-Set `exclusionsFactory` on the LeakCanary config to a `ExclusionsFactory` that delegates to the default one and then and add custom exclusions:
-
-```kotlin
-class DebugExampleApplication : ExampleApplication() {
-
-  override fun onCreate() {
-    super.onCreate()
-    LeakCanary.config = LeakCanary.config.copy(exclusionsFactory = { hprofParser ->
-      val defaultFactory = AndroidExcludedRefs.exclusionsFactory(AndroidExcludedRefs.appDefaults)
-      val appDefaults = defaultFactory(hprofParser)
-      val customExclusion = Exclusion(
-          type = StaticFieldExclusion("com.thirdparty.SomeSingleton", "sContext"),
-          status = Exclusion.Status.WONT_FIX_LEAK,
-          reason = "SomeSingleton in library X has a static field leaking a context."
-      )
-      appDefaults + customExclusion
-    })
-  }
-}
-```
-
-### Identifying leaking instances and labeling instances
-
-```kotlin
-class DebugExampleApplication : ExampleApplication() {
-
-  override fun onCreate() {
-    super.onCreate()
-    val customLabeler: Labeler = { parser, node ->
-      listOf("Heap dump object id is ${node.instance}")
-    }
-    val labelers = AndroidLabelers.defaultAndroidLabelers(this) + customLabeler
-
-    val customInspector: LeakInspector = { parser, node ->
-      with(parser) {
-        if (node.instance.objectRecord.isInstanceOf("com.example.MySingleton")) {
-          LeakNodeStatus.notLeaking("MySingleton is a singleton")
-        } else LeakNodeStatus.unknown()
-      }
-    }
-    val leakInspectors = AndroidLeakInspectors.defaultAndroidInspectors() + customInspector
-
-    LeakCanary.config = LeakCanary.config.copy(labelers = labelers, leakInspectors = leakInspectors)
-  }
-}
-```
-
-## FAQ
-
-### Can a leak be caused by the Android SDK?
-
-Yes. There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: [AndroidExcludedRefs.kt](https://github.com/square/leakcanary/blob/master/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt).
-
-If you find a new one, please [create an issue](https://github.com/square/leakcanary/issues/new/choose) and follow these steps:
-
-1. Provide the entire leak trace information (reference key, device, etc), and use backticks (`) for formatting.
-2. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions [android/platform_frameworks_base](https://github.com/android/platform_frameworks_base).
-3. Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed.
-4. If it's still happening, build a simple repro case
-5. File an issue on [b.android.com](http://b.android.com) with the leak trace and the repro case
-6. Create a PR in LeakCanary to update `AndroidExcludedRefs.kt`. Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
-
-### How do I share a leak trace?
-
-* Go to the leak screen, click the overflow menu and select *Share Info*.
-* You can also find the leak trace in Logcat.
-
-### How can I dig beyond the leak trace?
-
-Sometimes the leak trace isn't enough and you need to dig into a heap dump with [MAT](http://eclipse.org/mat/) or [YourKit](https://www.yourkit.com/).
-
-* Go to a heap analysis screen, click the overflow menu and select *Share Heap Dump*.
-
-Here's how you can find the leaking instance in the heap dump:
-
-1. Look for all instances of `leakcanary.KeyedWeakReference`
-2. For each of these, look at the `key` field.
-3. Find the `KeyedWeakReference` that has a `key` field equal to the reference key reported by LeakCanary.
-4. The `referent` field of that `KeyedWeakReference` is your leaking object.
-5. From then on, the matter is in your hands. A good start is to look at the shortest path to GC Roots (excluding weak references).
-
-### How many methods does LeakCanary add?
-
-**0**. LeakCanary is a debug only library.
-
-### How do I use the SNAPSHOT version?
-
-Update your dependencies to the latest SNAPSHOT (see [build.gradle](https://github.com/square/leakcanary/blob/master/build.gradle)):
-
-```gradle
- dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-3-SNAPSHOT'
- }
-```
-
-Add Sonatype's `snapshots` repository:
-
-```
-  repositories {
-    mavenCentral()
-    maven {
-      url 'https://oss.sonatype.org/content/repositories/snapshots/'
-    }
-  }
-```
-
-Status of the snapshot build: [![Build Status](https://travis-ci.org/square/leakcanary.svg?branch=master)](https://travis-ci.org/square/leakcanary)
-
-### Who's behind LeakCanary?
-
-LeakCanary was created and open sourced by [@pyricau](https://github.com/pyricau), with [many contributions](https://github.com/square/leakcanary/graphs/contributors) from the community.
-
-### Why is it called LeakCanary?
-
-The name **LeakCanary** is a reference to the expression [canary in a coal mine](http://en.wiktionary.org/wiki/canary_in_a_coal_mine), because LeakCanary is a sentinel used to detect risks by providing advance warning of a danger. Props to [@edenman](https://github.com/edenman) for suggesting it!
-
-### Who made the logo?
-
-* [@pyricau](https://github.com/pyricau) quickly made the [first version](https://github.com/square/leakcanary/blob/f0cc04dfbf3cca92a669f0d250034d410eb05816/assets/icon_512.png) of the logo. It was based on cliparts from [Android Asset Studio](http://romannurik.github.io/AndroidAssetStudio/icons-generic.html), mixed with the selection from a photo of a Canary. The exclamation mark means danger, the shield stands for protection, and the bird, well, is a canary.
-* [@romainguy](https://github.com/romainguy) turned the ugly logo into [a nice vector asset](https://github.com/square/leakcanary/pull/36).
-* [@flickator](https://github.com/flickator) designed [a much nicer logo](https://github.com/square/leakcanary/pull/1269) for LeakCanary 2.0!
-
-<p align="center">
-<img src="https://github.com/square/leakcanary/wiki/assets/logo-2.0.png" />
-</p>
+### [square.github.io/leakcanary](http://square.github.io/leakcanary)
 
 ## License
 
@@ -372,4 +18,4 @@ The name **LeakCanary** is a reference to the expression [canary in a coal mine]
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
-    limitations under the License.
+    limitations under the License.
\ No newline at end of file
diff --git a/docs/blog-articles.md b/docs/blog-articles.md
new file mode 100644
index 00000000..b3752f1f
--- /dev/null
+++ b/docs/blog-articles.md
@@ -0,0 +1,4 @@
+* [Detect memory leaks in your instrumentation tests using LeakCanary](https://proandroiddev.com/detecting-memory-leaks-in-your-instrumentation-tests-using-leakcanary-1268e911d5ce)
+* [9 ways to avoid memory leaks in Android](https://android.jlelse.eu/9-ways-to-avoid-memory-leaks-in-android-b6d81648e35e)
+
+Your article should be here, please update this list! Any technical level welcome.
\ No newline at end of file
diff --git a/CHANGELOG.md b/docs/changelog.md
similarity index 93%
rename from CHANGELOG.md
rename to docs/changelog.md
index 1435dc88..37d1abc5 100644
--- a/CHANGELOG.md
+++ b/docs/changelog.md
@@ -2,7 +2,7 @@
 
 ## Version 2.0 Alpha 2 (2019-05-21)
 
-**Thanks for testing the alpha**, we're counting on you to help us find bugs and suggest improvements! Check out the new [Getting Started](https://github.com/square/leakcanary#getting-started) instructions and the [migration guide](https://github.com/square/leakcanary/wiki/Migrating-to-LeakCanary-2.0). 
+**Thanks for testing the alpha**, we're counting on you to help us find bugs and suggest improvements! Check out the new [Getting Started](https://square.github.io/leakcanary/getting_started) instructions and the [migration guide](https://square.github.io/leakcanary/Upgrading-to-LeakCanary-2.0). 
 
 * [#1040](https://github.com/square/leakcanary/pull/1040) Import and analyze hprof files from other devices
 * [#1344](https://github.com/square/leakcanary/pull/1344) Computing retained size
@@ -31,27 +31,25 @@ For more details, see the [2.0-alpha-2 Milestone](https://github.com/square/leak
 
 ## Version 2.0 Alpha 1 (2019-04-23)
 
-This change log is also available as a [Twitter thread](https://twitter.com/Piwai/status/1120681920835276800).
-
 <img src="https://github.com/square/leakcanary/wiki/assets/logo-2.0-200px.png" />
 
 * New [logo](https://github.com/square/leakcanary/wiki/FAQ#who-made-the-logo), thanks [@flickator](https://github.com/flickator)!
 * Entirely rewritten to **100% Kotlin**
 * Multiple leaks detected in one analysis
-  * The heap is dumped when the app goes in the background, or when a minimum of 5 leaks is reached in the foreground.
+    * The heap is dumped when the app goes in the background, or when a minimum of 5 leaks is reached in the foreground.
 * Leak grouping
-  * Leaks that share similar causes are grouped in the UI.
-  * New screens to see the list of groups and each group.
-  * Improved leaktrace strings to highlight leak causes.
-  * Leaks can be shared to Stack Overflow
+    * Leaks that share similar causes are grouped in the UI.
+    * New screens to see the list of groups and each group.
+    * Improved leaktrace strings to highlight leak causes.
+    * Leaks can be shared to Stack Overflow
 * New library: **LeakSentry**.
-  * Detects when objects are leaking and triggers LeakCanary
-  * Can be used independently in production, for instance to report the number of leaking instances on an OutOfMemoryError crash.
+    * Detects when objects are leaking and triggers LeakCanary
+    * Can be used independently in production, for instance to report the number of leaking instances on an OutOfMemoryError crash.
 * New heap parser
-  * Uses **90% less memory and 6 times** faster than the prior heap parser.
-  * Runs in the same process as the app on a low priority thread.
-  * No more dependency on Perflib and TroveJ. New dependency on Okio.
-  * The old parser is still available as `leakcanary-android-perflib` but will be removed after alpha.
+    * Uses **90% less memory and 6 times** faster than the prior heap parser.
+    * Runs in the same process as the app on a low priority thread.
+    * No more dependency on Perflib and TroveJ. New dependency on Okio.
+    * The old parser is still available as `leakcanary-android-perflib` but will be removed after alpha.
 * Labelers can add any string content to leak elements
 * 0 code setup, just add the one debug dependency.
 * Simpler configuration options
@@ -189,8 +187,8 @@ For more details, see the [full diff](https://github.com/square/leakcanary/compa
 * New excluded leaks
 * Added `LeakCanary.isInAnalyzerProcess()` to the no-op jar
 * Fixed several file access issues:
-  * No more cleanup on startup, we rotate the heap dump files on every new heap dump.
-  * LeakCanary now falls back to the app directory until it can write to the external storage.
+    * No more cleanup on startup, we rotate the heap dump files on every new heap dump.
+    * LeakCanary now falls back to the app directory until it can write to the external storage.
 * Leak notifications now each use a distinct notification instead of erasing each other.
 * If LeakCanary can't perform a heap dump for any reason (e.g. analysis in progress, debugger attached), it retries later with an exponential backoff.
 * Added confirmation dialog when user deletes all leaks.
diff --git a/docs/code_of_conduct.md b/docs/code_of_conduct.md
new file mode 100644
index 00000000..6a97690c
--- /dev/null
+++ b/docs/code_of_conduct.md
@@ -0,0 +1,102 @@
+Open Source Code of Conduct
+===========================
+
+At Square, we are committed to contributing to the open source community and simplifying the process
+of releasing and managing open source software. We‚Äôve seen incredible support and enthusiasm from
+thousands of people who have already contributed to our projects‚Ää‚Äî‚Ääand we want to ensure our community
+continues to be truly open for everyone.
+
+This code of conduct outlines our expectations for participants, as well as steps to reporting
+unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and
+expect our code of conduct to be honored.
+
+Square‚Äôs open source community strives to:
+
+ * **Be open**: We invite anyone to participate in any aspect of our projects. Our community is
+   open, and any responsibility can be carried by a contributor who demonstrates the required
+   capacity and competence.
+
+ * **Be considerate**: People use our work, and we depend on the work of others. Consider users and
+   colleagues before taking action. For example, changes to code, infrastructure, policy, and
+   documentation may negatively impact others.
+
+ * **Be respectful**: We expect people to work together to resolve conflict, assume good intentions,
+   and act with empathy. Do not turn disagreements into personal attacks.
+
+ * **Be collaborative**: Collaboration reduces redundancy and improves the quality of our work. We
+   strive for transparency within our open source community, and we work closely with upstream
+   developers and others in the free software community to coordinate our efforts.
+
+ * **Be pragmatic**: Questions are encouraged and should be asked early in the process to avoid
+   problems later. Be thoughtful and considerate when seeking out the appropriate forum for your
+   questions. Those who are asked should be responsive and helpful.
+
+ * **Step down considerately**: Members of every project come and go. When somebody leaves or
+   disengages from the project, they should make it known and take the proper steps to ensure that
+   others can pick up where they left off.
+
+This code is not exhaustive or complete. It serves to distill our common understanding of a
+collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in
+the letter.
+
+Diversity Statement
+-------------------
+
+We encourage everyone to participate and are committed to building a community for all. Although we
+may not be able to satisfy everyone, we all agree that everyone is equal.
+
+Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone
+has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do
+our best to right the wrong.
+
+Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity,
+gender identity or expression, language, national origin, political beliefs, profession, race,
+religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate
+discrimination based on any of the protected characteristics above, including participants with
+disabilities.
+
+Reporting Issues
+----------------
+
+If you experience or witness unacceptable behavior‚Ää‚Äî‚Ääor have any other concerns‚Ää‚Äî‚Ääplease report it by
+emailing [codeofconduct@squareup.com][codeofconduct_at]. For more details, please see our Reporting
+Guidelines below.
+
+Thanks
+------
+
+Some of the ideas and wording for the statements and guidelines above were based on work by the
+[Twitter][twitter_coc], [Ubuntu][ubuntu_coc], [GDC][gdc_coc], and [Django][django_coc] communities.
+We are thankful for their work.
+
+Reporting Guide
+---------------
+
+If you experience or witness unacceptable behavior‚Ää‚Äî‚Ääor have any other concerns‚Ää‚Äî‚Ääplease report it by
+emailing [codeofconduct@squareup.com][codeofconduct_at]. All reports will be handled with
+discretion.
+
+In your report please include:
+
+ * Your contact information.
+ * Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional
+   witnesses, please include them as well.
+ * Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly
+   available record (e.g. a mailing list archive or a public IRC logger), please include a link.
+ * Any additional information that may be helpful.
+
+After filing a report, a representative from the Square Code of Conduct committee will contact you
+personally. The committee will then review the incident, follow up with any additional questions,
+and make a decision as to how to respond.
+
+Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual
+engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem
+appropriate, up to and including a permanent ban from all of Square spaces without warning.
+
+
+[codeofconduct_at]: mailto:codeofconduct@squareup.com
+[twitter_coc]: https://github.com/twitter/code-of-conduct/blob/master/code-of-conduct.md
+[ubuntu_coc]: https://ubuntu.com/community/code-of-conduct
+[gdc_coc]: https://www.gdconf.com/code-of-conduct
+[django_coc]: https://www.djangoproject.com/conduct/reporting/
+
diff --git a/docs/contributing.md b/docs/contributing.md
new file mode 100644
index 00000000..7b4fb258
--- /dev/null
+++ b/docs/contributing.md
@@ -0,0 +1,8 @@
+# Contributing
+
+If you would like to contribute code to LeakCanary you can do so through GitHub by
+forking the repository and sending a pull request.
+
+When submitting code, please make every effort to follow existing conventions
+and style in order to keep the code as readable as possible. Please also make
+sure your code compiles by running `./gradlew build`.
diff --git a/docs/faq.md b/docs/faq.md
new file mode 100644
index 00000000..c163a240
--- /dev/null
+++ b/docs/faq.md
@@ -0,0 +1,78 @@
+# FAQ
+
+## Can a leak be caused by the Android SDK?
+
+Yes. There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: [AndroidExcludedRefs.kt](https://github.com/square/leakcanary/blob/master/leakcanary-analyzer/src/main/java/leakcanary/AndroidExcludedRefs.kt).
+
+If you find a new one, please [create an issue](https://github.com/square/leakcanary/issues/new/choose) and follow these steps:
+
+1. Provide the entire leak trace information (reference key, device, etc), and use backticks (`) for formatting.
+2. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions [android/platform_frameworks_base](https://github.com/android/platform_frameworks_base).
+3. Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed.
+4. If it's still happening, build a simple repro case
+5. File an issue on [b.android.com](http://b.android.com) with the leak trace and the repro case
+6. Create a PR in LeakCanary to update `AndroidExcludedRefs.kt`. Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
+
+## How do I share a leak trace?
+
+* Go to the leak screen, click the overflow menu and select *Share Info*.
+* You can also find the leak trace in Logcat.
+
+## How can I dig beyond the leak trace?
+
+Sometimes the leak trace isn't enough and you need to dig into a heap dump with [MAT](http://eclipse.org/mat/) or [YourKit](https://www.yourkit.com/).
+
+* Go to a heap analysis screen, click the overflow menu and select *Share Heap Dump*.
+
+Here's how you can find the leaking instance in the heap dump:
+
+1. Look for all instances of `leakcanary.KeyedWeakReference`
+2. For each of these, look at the `key` field.
+3. Find the `KeyedWeakReference` that has a `key` field equal to the reference key reported by LeakCanary.
+4. The `referent` field of that `KeyedWeakReference` is your leaking object.
+5. From then on, the matter is in your hands. A good start is to look at the shortest path to GC Roots (excluding weak references).
+
+## How many methods does LeakCanary add?
+
+**0**. LeakCanary is a debug only library.
+
+## How do I use the SNAPSHOT version?
+
+Update your dependencies to the latest SNAPSHOT (see [build.gradle](https://github.com/square/leakcanary/blob/master/build.gradle)):
+
+```gradle
+ dependencies {
+   debugCompile 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-3-SNAPSHOT'
+ }
+```
+
+Add Sonatype's `snapshots` repository:
+
+```
+  repositories {
+    mavenCentral()
+    maven {
+      url 'https://oss.sonatype.org/content/repositories/snapshots/'
+    }
+  }
+```
+
+Status of the snapshot build: [![Build Status](https://travis-ci.org/square/leakcanary.svg?branch=master)](https://travis-ci.org/square/leakcanary)
+
+## Who's behind LeakCanary?
+
+LeakCanary was created and open sourced by [@pyricau](https://github.com/pyricau), with [many contributions](https://github.com/square/leakcanary/graphs/contributors) from the community.
+
+## Why is it called LeakCanary?
+
+The name **LeakCanary** is a reference to the expression [canary in a coal mine](http://en.wiktionary.org/wiki/canary_in_a_coal_mine), because LeakCanary is a sentinel used to detect risks by providing advance warning of a danger. Props to [@edenman](https://github.com/edenman) for suggesting it!
+
+## Who made the logo?
+
+* [@pyricau](https://github.com/pyricau) quickly made the [first version](https://github.com/square/leakcanary/blob/f0cc04dfbf3cca92a669f0d250034d410eb05816/assets/icon_512.png) of the logo. It was based on cliparts from [Android Asset Studio](http://romannurik.github.io/AndroidAssetStudio/icons-generic.html), mixed with the selection from a photo of a Canary. The exclamation mark means danger, the shield stands for protection, and the bird, well, is a canary.
+* [@romainguy](https://github.com/romainguy) turned the ugly logo into [a nice vector asset](https://github.com/square/leakcanary/pull/36).
+* [@flickator](https://github.com/flickator) designed [a much nicer logo](https://github.com/square/leakcanary/pull/1269) for LeakCanary 2.0!
+
+<p align="center">
+<img src="https://github.com/square/leakcanary/wiki/assets/logo-2.0.png" />
+</p>
diff --git a/docs/fundamentals.md b/docs/fundamentals.md
new file mode 100644
index 00000000..42cc51fc
--- /dev/null
+++ b/docs/fundamentals.md
@@ -0,0 +1,230 @@
+# Fundamentals
+
+## What is a memory leak?
+
+In a Java based runtime, a memory leak is a programming error that causes an application to keep a reference to an object that is no longer needed. As a result, the memory allocated for that object cannot be reclaimed, eventually leading to an OutOfMemoryError crash.
+
+For example, an Android activity instance is no longer needed after its `onDestroy()` method is called, and storing a reference to that activity in a static field would prevent it from being garbage collected.
+
+## Common causes for memory leaks
+
+Most memory leaks are caused by bugs related to the lifecycle of objects. Here are a few common Android mistakes:
+
+* Storing an Activity context as a field in an object that survives activity recreation configuration changes.
+* Registering a listener, broadcast receiver or RxJava subscription which references an object with lifecycle, and forgetting to unregister when the lifecycle reaches its end.
+* Storing a view in a static field, and not clearing that field when the view is detached.
+
+## Why should I use LeakCanary?
+
+Memory leaks are very common in Android apps. OutOfMemoryError (OOM) is the top crash for most apps on the play store, however that's usually not counted correctly. When memory is low the OOM can be thrown from anywhere in your code, which means every OOM has a different stacktrace and they're counted as different crashes.
+
+When we first enabled LeakCanary in the Square Point Of Sale app, we were able to find and fix several leaks and reduced the OutOfMemoryError crash rate by **94%**.
+
+## How does LeakCanary work?
+
+### Detecting retained instances
+
+The foundation of LeakCanary is a library called LeakSentry. LeakSentry hooks into the Android lifecycle to automatically detect when activities and fragments are destroyed and should be garbage collected. These destroyed instances are passed to a `RefWatcher`, which holds weak references to them. You can also watch any instance that is no longer needed, e.g. a detached view, a destroyed presenter, etc.
+
+If the weak references aren't cleared after waiting 5 seconds and running the garbage collector, the watched instances are considered *retained*, and potentially leaking.
+
+### Dumping the heap
+
+When the number of retained instances reaches a threshold, LeakCanary dumps the Java heap into a `.hprof` file stored onto the Android file system. The default threshold is 5 retained instances when the app is visible, 1 otherwise.
+
+### Analyzing the heap
+
+LeakCanary parses the `.hprof` file and finds the chain of references that prevents retained instances from being garbage collected: the **leak trace**. Leak trace is another name for the *shortest strong reference path from garbage collection roots to retained instances*. Once the leak trace is determined, LeakCanary uses its built-in knowledge of the Android framework to deduct which instances in the leak trace are leaking (see below [How do I fix a memory leak?](#how-do-i-fix-a-memory-leak)).
+
+### Grouping leaks
+
+Using the leak status information, LeakCanary narrows down the reference chain to a sub chain of possible leak causes, and displays the result. Leaks that have the same causal chain are considered to be the same leak, so leaks are grouped by identical sub chain.
+
+## How do I fix a memory leak?
+
+For each leaking instance, LeakCanary computes a leak trace and displays it in its UI:
+
+![leak trace](images/leaktrace.png)
+
+The leak trace is also logged to Logcat:
+
+```
+    ‚î¨
+    ‚îú‚îÄ leakcanary.internal.InternalLeakCanary
+    ‚îÇ    Leaking: NO (it's a GC root and a class is never leaking)
+    ‚îÇ    ‚Üì static InternalLeakCanary.application
+    ‚îú‚îÄ com.example.leakcanary.ExampleApplication
+    ‚îÇ    Leaking: NO (Application is a singleton)
+    ‚îÇ    ‚Üì ExampleApplication.leakedViews
+    ‚îÇ                         ~~~~~~~~~~~
+    ‚îú‚îÄ java.util.ArrayList
+    ‚îÇ    Leaking: UNKNOWN
+    ‚îÇ    ‚Üì ArrayList.elementData
+    ‚îÇ                ~~~~~~~~~~~
+    ‚îú‚îÄ java.lang.Object[]
+    ‚îÇ    Leaking: UNKNOWN
+    ‚îÇ    ‚Üì array Object[].[0]
+    ‚îÇ                     ~~~
+    ‚îú‚îÄ android.widget.TextView
+    ‚îÇ    Leaking: YES (View detached and has parent)
+    ‚îÇ    View#mAttachInfo is null (view detached)
+    ‚îÇ    View#mParent is set
+    ‚îÇ    View.mWindowAttachCount=1
+    ‚îÇ    ‚Üì TextView.mContext
+    ‚ï∞‚Üí com.example.leakcanary.MainActivity
+    ‚Äã     Leaking: YES (RefWatcher was watching this and MainActivity#mDestroyed
+is true)
+```
+
+### Objects and references
+
+```
+‚îú‚îÄ android.widget.TextView
+```
+
+Each node in the leak trace is a Java object and is either a class, an object array or an instance.
+
+```
+‚îÇ    ‚Üì TextView.mContext
+```
+
+Going down, each node has a reference to the next node. In the UI, that reference is in **<span style="color:#9976a8">purple</span>**. In the Logcat representation, the reference is on the line that starts with a down arrow.
+
+### GC Root
+
+```
+    ‚î¨
+    ‚îú‚îÄ leakcanary.internal.InternalLeakCanary
+    ‚îÇ    Leaking: NO (it's a GC root and a class is never leaking)
+```
+
+At the top of the leak trace is a garbage-collection (GC) root. GC roots are special objects that are always reachable. There are four kinds of GC roots worth mentioning:
+
+  * **Local variables**, which belong to the stack of a thread.
+  * Instances of **active Java threads**.
+  * **Classes**, which never unload on Android.
+  * **Native references**, which are controlled by native code.
+
+### Leaking instance
+
+```
+    ‚ï∞‚Üí com.example.leakcanary.MainActivity
+    ‚Äã     Leaking: YES (RefWatcher was watching this and MainActivity#mDestroyed
+is true)
+```
+
+At the bottom of the leak trace is the leaking instance. This instance was passed to `RefWatcher.watch()` to confirm it would be garbage collected, and it ended up not being garbage collected which triggered LeakCanary.
+
+### Chain of references
+
+```
+...
+    ‚îÇ    ‚Üì static InternalLeakCanary.application
+...
+    ‚îÇ    ‚Üì ExampleApplication.leakedViews
+...
+    ‚îÇ    ‚Üì ArrayList.elementData
+...
+    ‚îÇ    ‚Üì array Object[].[0]
+...
+    ‚îÇ    ‚Üì TextView.mContext
+...
+```
+
+The chain of references from the GC root to the leaking instance is what is preventing the leaking instance from being garbage collected. If you can identify the reference that should not exist at that point in time, then you can figure out why it's incorrectly still set and then fix the memory leak.
+
+### Heuristics and labels
+
+```
+    ‚îú‚îÄ android.widget.TextView
+    ‚îÇ    Leaking: YES (View detached and has parent)
+```
+
+LeakCanary runs heuristics to determine the lifecycle state of the nodes of the leak trace, and therefore whether they are leaking or not. For example, if a view has `View#mAttachInfo = null` and `mParent != null` then it is detached yet has a parent, so that view is probably leaking. In the leak trace, for each node you'll see `Leaking: YES / NO / UNKNOWN` with an explanation in parenthesis. You can customize this behavior and add your own heuristics.
+
+```
+    ‚îÇ    View#mAttachInfo is null (view detached)
+    ‚îÇ    View#mParent is set
+    ‚îÇ    View.mWindowAttachCount=1
+```
+
+LeakCanary can also surface extra information about the state of a node, e.g. `View.mWindowAttachCount=1`. You can add your own labels.
+
+### Narrowing down the cause of a leak
+
+```
+    ‚î¨
+    ‚îú‚îÄ leakcanary.internal.InternalLeakCanary
+    ‚îÇ    Leaking: NO (it's a GC root and a class is never leaking)
+    ‚îÇ    ‚Üì static InternalLeakCanary.application
+    ‚îú‚îÄ com.example.leakcanary.ExampleApplication
+    ‚îÇ    Leaking: NO (Application is a singleton)
+    ‚îÇ    ‚Üì ExampleApplication.leakedViews
+    ‚îÇ                         ~~~~~~~~~~~
+    ‚îú‚îÄ java.util.ArrayList
+    ‚îÇ    Leaking: UNKNOWN
+    ‚îÇ    ‚Üì ArrayList.elementData
+    ‚îÇ                ~~~~~~~~~~~
+    ‚îú‚îÄ java.lang.Object[]
+    ‚îÇ    Leaking: UNKNOWN
+    ‚îÇ    ‚Üì array Object[].[0]
+    ‚îÇ                     ~~~
+    ‚îú‚îÄ android.widget.TextView
+    ‚îÇ    Leaking: YES (View detached and has parent)
+    ‚îÇ    ‚Üì TextView.mContext
+    ‚ï∞‚Üí com.example.leakcanary.MainActivity
+    ‚Äã     Leaking: YES (RefWatcher was watching this and MainActivity#mDestroyed is true)
+```
+
+If a node is not leaking, then any prior reference that points to it is not the source of the leak, and also not leaking. Similarly, if a node is leaking then any node down the leak trace is also leaking. From that, we can deduce that the leak is caused by a reference that is after the last `Leaking: NO`	and before the first `Leaking: YES`.
+
+LeakCanary highlights those references with a **<span style="text-decoration: underline; text-decoration-color: red; text-decoration-style: wavy;">red underline</span>** in the UI, or a **~~~~** underline in the Logcat representation. These highlighted references are the **only possible causes of the leak**. These are the references you should spend time investigating.
+
+In this example, the last `Leaking: NO` is on `com.example.leakcanary.ExampleApplication` and the first `Leaking: YES` is on `android.widget.TextView`, so the leak is caused by one of the 3 references in between:
+
+```
+...
+    ‚îÇ    ‚Üì ExampleApplication.leakedViews
+    ‚îÇ                         ~~~~~~~~~~~
+...
+    ‚îÇ    ‚Üì ArrayList.elementData
+    ‚îÇ                ~~~~~~~~~~~
+...
+    ‚îÇ    ‚Üì array Object[].[0]
+    ‚îÇ                     ~~~
+...
+```
+
+Looking at the [source](https://github.com/square/leakcanary/blob/master/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt#L23), we can see that `ExampleApplication` has a list field:
+
+```
+open class ExampleApplication : Application() {
+  val leakedViews = mutableListOf<View>()
+}
+```
+
+It's unlikely that there's a bug in the `ArrayList` implementation itself, so the leak happens because we're adding views to `ExampleApplication.leakedViews`. If we stop doing that, we've fixed the leak!
+
+### Asking for help with a leak
+
+If you cannot figure out a leak, **please do not file an issue**. Instead, create a [Stack Overflow question](http://stackoverflow.com/questions/tagged/leakcanary?sort=active) using the *leakcanary* tag.
+
+## LeakCanary artifacts
+
+LeakCanary is released as several distinct libraries:
+
+* LeakSentry
+    * Detects retained instances.
+    * Suitable for release builds.
+    * Artifact id: `com.squareup.leakcanary:leaksentry`.
+* LeakCanary
+    * Dumps the heap and analyzes it.
+    * Currently only suitable for debug builds.
+    * Depends on LeakSentry.
+    * Artifact id: `com.squareup.leakcanary:leakcanary-android`.
+* LeakCanary for Instrumentation tests
+    * Fails tests if a leak is detected
+    * Only suitable for Instrumentation tests
+    * Configures LeakCanary to wait for the end of tests before dumping the heap.
+    * Artifact id: `com.squareup.leakcanary:leakcanary-android-instrumentation`.
+    * See [Running LeakCanary in instrumentation tests](recipes.md#running-leakcanary-in-instrumentation-tests)
\ No newline at end of file
diff --git a/docs/getting_started.md b/docs/getting_started.md
new file mode 100644
index 00000000..20ba4063
--- /dev/null
+++ b/docs/getting_started.md
@@ -0,0 +1,18 @@
+# Getting started
+
+Add LeakCanary to `build.gradle`:
+
+```groovy
+dependencies {
+  // debugImplementation because LeakCanary should only run in debug builds.
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-2'
+}
+```
+
+**That's it, there is no code change needed!** LeakCanary will automatically show a notification when a memory leak is detected in debug builds.
+
+What's next?
+
+* Learn the [Fundamentals](fundamentals.md)
+* Try the [code recipes](recipes.md)
+* Read the [FAQ](faq.md)
diff --git a/docs/images/leaktrace.png b/docs/images/leaktrace.png
new file mode 100644
index 00000000..dfbe6a02
Binary files /dev/null and b/docs/images/leaktrace.png differ
diff --git a/docs/images/logo.png b/docs/images/logo.png
new file mode 100644
index 00000000..1c33a1de
Binary files /dev/null and b/docs/images/logo.png differ
diff --git a/docs/index.md b/docs/index.md
new file mode 100644
index 00000000..d35383bf
--- /dev/null
+++ b/docs/index.md
@@ -0,0 +1,16 @@
+# LeakCanary üê§
+
+LeakCanary is a memory leak detection library for Android.
+
+<p align="center">
+<img src="https://github.com/square/leakcanary/wiki/assets/screenshot-2.0.png"/>
+</p>
+
+LeakCanary's knowledge of the internals of the Android Framework gives it a unique ability to narrow down the cause of each leak, helping developers dramatically reduce OutOfMemoryError crashes.
+
+[Get started!](getting_started.md)
+
+
+!!! quote
+    *‚ÄúA small leak will sink a great ship.‚Äù* - Benjamin Franklin
+
diff --git a/docs/recipes.md b/docs/recipes.md
new file mode 100644
index 00000000..2c31ea67
--- /dev/null
+++ b/docs/recipes.md
@@ -0,0 +1,197 @@
+# Code Recipes
+
+If you think a recipe might be missing or you're not sure that what you're trying to achieve is possible with the current APIs, please [file an issue](https://github.com/square/leakcanary/issues/new/choose). Your feedback help us make LeakCanary better for the entire community.
+
+## Configuring LeakSentry
+
+LeakSentry can be configured by replacing `LeakSentry.config`:
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakSentry.config = LeakSentry.config.copy(watchFragmentViews = false)
+  }
+}
+```
+
+## Configuring LeakCanary
+
+LeakCanary can be configured by replacing `LeakCanary.config`:
+
+```kotlin
+disableLeakCanaryButton.setOnClickListener {
+  LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
+}
+```
+
+## Watching objects with a lifecycle
+
+In your application, you may have other objects with a lifecycle, such as fragments, services, Dagger components, etc. Use `LeakSentry.refWatcher` to watch instances that should be garbage collected:
+
+```kotlin
+class MyService : Service {
+
+  // ...
+
+  override fun onDestroy() {
+    super.onDestroy()
+    LeakSentry.refWatcher.watch(this)
+  }
+}
+```
+
+## Counting retained instances in production
+
+`com.squareup.leakcanary:leakcanary-android` should only be used in debug builds. It depends on `com.squareup.leakcanary:leaksentry` which you can use in production to track and count retained instances.
+
+In your `build.gradle`:
+
+```gradle
+dependencies {
+  implementation 'com.squareup.leakcanary:leaksentry:2.0-alpha-2'
+}
+```
+
+In your leak reporting code:
+```kotlin
+val retainedInstanceCount = LeakSentry.refWatcher.retainedKeys.size
+```
+
+## Running LeakCanary in instrumentation tests
+
+Add the `leakcanary-android-instrumentation` dependency to your instrumentation tests:
+
+```
+androidTestImplementation "com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion}"
+```
+
+Add the dedicated run listener to `defaultConfig` in your `build.gradle`:
+
+```
+android {
+  defaultConfig {
+    // ...
+
+    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    testInstrumentationRunnerArgument "listener", "leakcanary.FailTestOnLeakRunListener"
+  }
+}
+```
+
+Run the instrumentation tests:
+
+```
+./gradlew leakcanary-sample:connectedCheck
+```
+
+You can extend `FailTestOnLeakRunListener` to customize the behavior.
+
+## Icon and label
+
+The activity that displays leaks comes with a default icon and label, which you can change by providing `R.mipmap.leak_canary_icon` and `R.string.leak_canary_display_activity_label` in your app:
+
+```
+res/
+  mipmap-hdpi/
+    leak_canary_icon.png
+  mipmap-mdpi/
+    leak_canary_icon.png
+  mipmap-xhdpi/
+    leak_canary_icon.png
+  mipmap-xxhdpi/
+    leak_canary_icon.png
+  mipmap-xxxhdpi/
+    leak_canary_icon.png
+   mipmap-anydpi-v26/
+     leak_canary_icon.xml
+```
+
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <string name="leak_canary_display_activity_label">MyLeaks</string>
+</resources>
+```
+
+## Uploading to a server
+
+You can change the default behavior to upload the analysis result to a server of your choosing.
+
+Create a custom `AnalysisResultListener` that delegates to the default: 
+
+```kotlin
+class LeakUploader : AnalysisResultListener {
+  override fun invoke(
+    application: Application,
+    heapAnalysis: HeapAnalysis
+  ) {
+    TODO("Upload heap analysis to server")
+
+    // Delegate to default behavior (notification and saving result)
+    DefaultAnalysisResultListener(application, heapAnalysis)
+  }
+}
+```
+
+Set `analysisResultListener` on the LeakCanary config:
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakCanary.config = LeakCanary.config.copy(analysisResultListener = LeakUploader())
+  }
+}
+```
+
+
+## Identifying 3rd party leaks as "won't fix"
+
+Set `exclusionsFactory` on the LeakCanary config to a `ExclusionsFactory` that delegates to the default one and then and add custom exclusions:
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakCanary.config = LeakCanary.config.copy(exclusionsFactory = { hprofParser ->
+      val defaultFactory = AndroidExcludedRefs.exclusionsFactory(AndroidExcludedRefs.appDefaults)
+      val appDefaults = defaultFactory(hprofParser)
+      val customExclusion = Exclusion(
+          type = StaticFieldExclusion("com.thirdparty.SomeSingleton", "sContext"),
+          status = Exclusion.Status.WONT_FIX_LEAK,
+          reason = "SomeSingleton in library X has a static field leaking a context."
+      )
+      appDefaults + customExclusion
+    })
+  }
+}
+```
+
+## Identifying leaking instances and labeling instances
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    val customLabeler: Labeler = { parser, node ->
+      listOf("Heap dump object id is ${node.instance}")
+    }
+    val labelers = AndroidLabelers.defaultAndroidLabelers(this) + customLabeler
+
+    val customInspector: LeakInspector = { parser, node ->
+      with(parser) {
+        if (node.instance.objectRecord.isInstanceOf("com.example.MySingleton")) {
+          LeakNodeStatus.notLeaking("MySingleton is a singleton")
+        } else LeakNodeStatus.unknown()
+      }
+    }
+    val leakInspectors = AndroidLeakInspectors.defaultAndroidInspectors() + customInspector
+
+    LeakCanary.config = LeakCanary.config.copy(labelers = labelers, leakInspectors = leakInspectors)
+  }
+}
+```
\ No newline at end of file
diff --git a/docs/recorded-presentations.md b/docs/recorded-presentations.md
new file mode 100644
index 00000000..4e97c309
--- /dev/null
+++ b/docs/recorded-presentations.md
@@ -0,0 +1,7 @@
+* [LeakCanary 2: Leaner, Better, Faster, Kotliner!](https://www.youtube.com/watch?v=LEX8dn4BLUw)
+* [LeakCanary, then what? Nuking Nasty Memory Leaks](https://www.youtube.com/watch?v=fhE--eTEW84)
+* [Memory Leak Hunt](https://www.youtube.com/watch?v=KwArTJHLq5g), a live investigation.
+* [Installing LeakCanary](https://caster.io/lessons/installing-leakcanary) (LeakCanary 1.5)
+* [How to use LeakCanary](https://www.youtube.com/watch?v=qtrZVPGdDkU)
+
+Your presentation should be here, please update this list! Any technical level welcome.
\ No newline at end of file
diff --git a/docs/support.md b/docs/support.md
new file mode 100644
index 00000000..e8527600
--- /dev/null
+++ b/docs/support.md
@@ -0,0 +1,14 @@
+# LeakCanary Support
+
+If you're looking for support for LeakCanary:
+
+* Learn the [Fundamentals](fundamentals.md)
+* Try the [code recipes](recipes.md)
+* Read the [FAQ](https://square.github.io/leakcanary/faq/)
+* Watch [recorded presentations](recorded-presentations.md)
+* Read [blog articles](blog-articles.md)
+* Check out the StackOverflow [LeakCanary tag](http://stackoverflow.com/questions/tagged/leakcanary?sort=active) and ask a question
+
+Feel free to edit this file to add links to online communities that can help developers investigate LeakCanary leaks.
+
+
diff --git a/docs/upgrading-to-leakcanary-2.0.md b/docs/upgrading-to-leakcanary-2.0.md
new file mode 100644
index 00000000..61867055
--- /dev/null
+++ b/docs/upgrading-to-leakcanary-2.0.md
@@ -0,0 +1,214 @@
+## Dependencies
+
+### Before
+
+```groovy
+dependencies {
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.3'
+  releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.3'
+  // Optional, if you use support library fragments:
+  debugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.3'
+}
+```
+
+### Now
+
+```groovy
+dependencies {
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-2'
+}
+```
+
+### Worth noting
+
+* The `leakcanary-android-no-op` artifact is gone. If you have compile errors, see below.
+  * **Question**: if there's no no-op anymore, how do I ensure none of this runs during release builds?
+  * **Answer**: as long as you add `leakcanary-android` as `debugImplementation`, there won't be any code referencing LeakCanary in your release builds.
+* LeakCanary now **depends on AndroidX** instead of the support library.
+* Detection of AndroidX fragments is now automatic if you have the AndroidX fragments dependency.
+
+## Default setup code
+
+### Before
+
+```java
+public class ExampleApplication extends Application {
+
+  @Override public void onCreate() {
+    super.onCreate();
+    if (LeakCanary.isInAnalyzerProcess(this)) {
+      // This process is dedicated to LeakCanary for heap analysis.
+      // You should not init your app in this process.
+      return;
+    }
+    LeakCanary.install(this);
+    // Normal app init code...
+  }
+}
+```
+
+### Now
+
+There is no more code for default setup.
+
+### Worth noting
+
+* LeakCanary auto installs itself
+* LeakCanary analysis now runs in the main process so there is no need to call `LeakCanary.isInAnalyzerProcess()`.
+
+## Retrieve the RefWatcher
+
+### Before
+
+```kotlin
+val refWatcher = LeakCanary.installedRefWatcher()
+```
+
+### Now
+
+```kotlin
+val refWatcher = LeakSentry.refWatcher
+```
+
+## Compile errors because RefWatcher is used in release code
+
+If you were using `RefWatcher` in non debug code, you now get a compile error because the no-op artifact is gone. `RefWatcher` now lives in the `leaksentry` artifact, which is suitable for production. You have two options:
+
+### Option 1: Add `leaksentry` to release builds.
+
+```groovy
+dependencies {
+  implementation 'com.squareup.leakcanary:leaksentry:2.0-alpha-2'
+}
+```
+
+* It will automatically keep weak references on activities, fragments, and any instance you pass to `RefWatcher`.
+* It will not trigger heap dumps or anything else that LeakCanary does.
+* It's very little code and should have a no impact on your release app.
+* You can use it to count how many instances are retained, for instance to add metadata to OutOfMemoryError crashes:
+
+```kotlin
+val retainedInstanceCount = LeakSentry.refWatcher.retainedKeys.size
+```
+
+### Option 2: Make your own `RefWatcher` interface
+
+```kotlin
+// In shared code
+interface MaybeRefWatcher {
+  fun watch(watchedReference: Any)
+
+  object None : MaybeRefWatcher {
+    override fun watch(watchedReference: Any) {
+    }
+  }
+}
+
+// In debug code
+class RealRefWatcher : MaybeRefWatcher {
+  override fun watch(watchedReference: Any) {
+    LeakSentry.refWatcher.watch(watchedReference)
+  }
+}
+```
+
+Use MaybeRefWatcher.None in release code and RealRefWatcher in debug code.
+
+## Configuring LeakCanary
+
+### Before
+
+```java
+public class DebugExampleApplication extends ExampleApplication {
+
+  @Override protected void installLeakCanary() {
+    RefWatcher refWatcher = LeakCanary.refWatcher(this)
+      .watchActivities(false)
+      .buildAndInstall();
+  }
+}
+```
+
+### Now
+
+LeakSentry is in charge of detecting memory leaks. Its configuration can be updated at any time by replacing `LeakSentry.config`:
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakSentry.config = LeakSentry.config.copy(watchFragmentViews = false)
+  }
+}
+```
+
+LeakCanary is in charge of taking heap dumps and analyzing them. Its configuration can be updated at any time by replacing `LeakCanary.config`:
+
+```kotlin
+disableLeakCanaryButton.setOnClickListener {
+  LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
+}
+```
+
+## Running LeakCanary in instrumentation tests
+
+### Before
+
+In your `build.gradle` file:
+
+```groovy
+dependencies {
+  androidTestImplementation "com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion}"
+}
+
+android {
+  defaultConfig {
+    // ...
+
+    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    testInstrumentationRunnerArgument "listener", "com.squareup.leakcanary.FailTestOnLeakRunListener"
+  }
+}
+```
+
+In your test `Application` class:
+
+```java
+public class InstrumentationTestExampleApplication extends DebugExampleApplication {
+  @Override protected void installLeakCanary() {
+    InstrumentationLeakDetector.instrumentationRefWatcher(this)
+      .buildAndInstall();
+  }
+}
+```
+
+### Now
+
+In your `build.gradle` file:
+
+```groovy
+dependencies {
+  androidTestImplementation "com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion}"
+}
+
+android {
+  defaultConfig {
+    // ...
+
+    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    testInstrumentationRunnerArgument "listener", "leakcanary.FailTestOnLeakRunListener"
+  }
+}
+```
+
+No code is necessary.
+
+## Public API packages
+
+### Before
+
+All public APIs were in `com.squareup.leakcanary.*`
+
+### Now
+
+All public APIs are in `leakcanary.*`
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
index d3c0ee79..f6ac1d0c 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
@@ -41,9 +41,7 @@ class HprofGraph(private val parser: HprofParser) {
 
     var currentClassId = classId
     while (currentClassId != 0L) {
-      val wut = parser.className(currentClassId)
-      CanaryLog.d("Found $wut looking for $className: ${wut == className}")
-      if (wut == className) {
+      if (parser.className(currentClassId) == className) {
         return true
       }
       val currentClassRecord = parser.retrieveRecordById(currentClassId) as ClassDumpRecord
diff --git a/mkdocs.yml b/mkdocs.yml
new file mode 100644
index 00000000..305528c4
--- /dev/null
+++ b/mkdocs.yml
@@ -0,0 +1,58 @@
+# pip install mkdocs mkdocs-material
+# mkdocs serve
+# mkdocs gh-deploy
+
+site_name: LeakCanary
+repo_name: LeakCanary
+repo_url: https://github.com/square/leakcanary
+site_description: "A memory leak detection library for Android"
+site_author: Square, Inc.
+remote_branch: gh-pages
+
+copyright: 'Copyright &copy; 2015 Square, Inc.'
+
+theme:
+  name: 'material'
+  logo: 'images/logo.png'
+  favicon: 'images/logo.png'
+  palette:
+    primary: 'deep-orange'
+    accent: 'deep-purple'
+
+
+# extra_css:
+#  - 'css/app.css'
+
+markdown_extensions:
+  - smarty
+  - codehilite:
+      guess_lang: false
+  - footnotes
+  - meta
+  - toc:
+      permalink: true
+  - pymdownx.betterem:
+      smart_enable: all
+  - pymdownx.caret
+  - pymdownx.inlinehilite
+  - pymdownx.magiclink
+  - pymdownx.smartsymbols
+  - pymdownx.superfences
+  - pymdownx.emoji
+  - tables
+  - admonition
+
+nav:
+  - 'Overview': index.md
+  - 'Getting Started': getting_started.md
+  - 'Fundamentals': fundamentals.md
+  - 'Code recipes': recipes.md
+  - 'FAQ': faq.md
+  - 'Stack Overflow ‚èè': https://stackoverflow.com/questions/tagged/leakcanary?sort=active
+  - 'Change Log': changelog.md
+  - 'Support': support.md
+  - 'Upgrading to LeakCanary 2': upgrading-to-leakcanary-2.0.md
+  - 'Blog Articles': blog-articles.md
+  - 'Recorded Presentations': recorded-presentations.md
+  - 'Contributing': contributing.md
+  - 'Code of Conduct': code_of_conduct.md
