diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
index f655ac04..604954df 100644
--- a/.github/ISSUE_TEMPLATE.md
+++ b/.github/ISSUE_TEMPLATE.md
@@ -1,22 +1,25 @@
 Welcome and thank you for reporting an issue!
 
-First, verify that your issue hasn't already been reported by searching over all issues: https://github.com/square/leakcanary/issues?q=is%3Aissue.
+First:
+
+- Confirm that you are using the latest version of LeakCanary (see https://github.com/square/leakcanary/blob/master/CHANGELOG.md)
+- Verify that your issue hasn't already been reported by searching over all issues: https://github.com/square/leakcanary/issues?q=is%3Aissue.
 
 What kind of issue is this?
 
- - Question: This issue tracker is not the place for questions. If you want to ask how to do
+ - *Question*: This issue tracker is not the place for questions. If you want to ask how to do
    something, or to understand why something isn't working the way you expect it to, use Stack
    Overflow: https://stackoverflow.com/questions/tagged/leakcanary.
 
- - Help me fix a leak?: Please do not file an issue.
+ - *Help me fix a leak?*: Please do not file an issue.
    Instead, read here: https://github.com/square/leakcanary/#how-do-i-fix-a-memory-leak
  
- - OOM error: Please provide a heap dump!
+ - *Leak analysis failed*: if it's an OutOfMemoryError, no need to report it. See https://github.com/square/leakcanary/wiki/Future#low-memory-leak-analysis
 
- - Bug report: If you’ve found a bug, spend the time to write a failing test. Bugs with tests get fixed. 
+ - *Bug report*: If you’ve found a bug, spend the time to write a failing test. Bugs with tests get fixed.
    Here’s an example: https://gist.github.com/swankjesse/981fcae102f513eb13ed
    
- - Feature Request: Start by telling us what problem you’re trying to solve. Don’t send pull requests to implement 
+ - *Feature Request*: Start by telling us what problem you’re trying to solve. Don’t send pull requests to implement
    new features without first getting our support. Sometimes we leave features out on purpose to keep the project small.
 
 ^^^^^ DELETE FROM THIS LINE UP ^^^^^
@@ -24,6 +27,6 @@ What kind of issue is this?
 
 ```
 
-REPLACE THIS LINE WITH YOUR STACKTRACE OR OUTPUT FROM LEAKCANARY
+{REPLACE THIS LINE WITH YOUR STACKTRACE OR OUTPUT FROM LEAKCANARY}
 
 ```
diff --git a/.travis.yml b/.travis.yml
index f56fb04c..e1c8fa04 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,11 +1,5 @@
 language: android
 
-android:
-  components:
-    # Update tools and then platform-tools explicitly so lint gets an updated database. Can be removed once 3.0 is out.
-    - tools
-    - platform-tools
-
 jdk:
   - oraclejdk8
 
@@ -13,12 +7,27 @@ before_install:
   # Install SDK license so Android Gradle plugin can install deps.
   - mkdir "$ANDROID_HOME/licenses" || true
   - echo "d56f5187479451eabf01fb78af6dfcb131a6481e" > "$ANDROID_HOME/licenses/android-sdk-license"
+  # Install the rest of tools (e.g., avdmanager)
+  - sdkmanager tools
+  # Install the system image
+  - sdkmanager "system-images;android-16;default;armeabi-v7a"
+  # Create and start emulator for the script. Meant to race the install task.
+  - echo no | avdmanager create avd --force -n test -k "system-images;android-16;default;armeabi-v7a"
+  - $ANDROID_HOME/emulator/emulator -avd test -no-audio -no-window &
+
+install: ./gradlew clean build assembleAndroidTest --stacktrace
+
+before_script:
+  - android-wait-for-emulator
+  # 82 is KEYCODE_MENU
+  - adb shell input keyevent 82
 
 script:
-  - ./gradlew clean build
+  - ./gradlew leakcanary-android-instrumentation:connectedCheck --stacktrace
+  - ./gradlew leakcanary-support-fragment:connectedCheck --stacktrace
 
 after_success:
-  - .buildscript/deploy_snapshot.sh
+  - .buildscript/deploy_snapshot.sh || test true
 
 env:
   global:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index b4e2c55d..8532ea0b 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,69 @@
 # Change Log
 
+## Version 1.6.2 (2018-10-16)
+
+* [#1067](https://github.com/square/leakcanary/issues/1067) Fixed TransactionTooLargeException crash (leak analysis would never complete).
+* [#1061](https://github.com/square/leakcanary/pull/1061) Detection of Fragment view leaks after Fragment#onDestroyView().
+* [#1076](https://github.com/square/leakcanary/pull/1076) Added the FOREGROUND_SERVICE permission for Android P.
+* [#1062](https://github.com/square/leakcanary/issues/1062) The LeakCanary toast now always shows correctly. It doesn't show if there is no activity in foreground.
+* [#1115](https://github.com/square/leakcanary/issues/1115) Reenabled the DisplayLeakActivity icon on fresh installs.
+* [#1100](https://github.com/square/leakcanary/pull/1100) Added nullability annotations to improve Kotlin support.
+* Updates to excluded leaks ([commits](https://github.com/square/leakcanary/commits/v1.6.2/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java)).
+* Updates to reachability inspectors ([commits](https://github.com/square/leakcanary/commits/v1.6.2/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java)).
+
+Many thanks to
+[@fractalwrench](https://github.com/fractalwrench),
+[@hzsweers](https://github.com/hzsweers),
+[@Goddchen](https://github.com/Goddchen),
+[@igokoro](https://github.com/igokoro),
+[@IlyaGulya](https://github.com/IlyaGulya),
+[@JakeWharton](https://github.com/JakeWharton),
+[@javmarina](https://github.com/javmarina),
+[@jokermonn](https://github.com/jokermonn),
+[@jrodbx](https://github.com/jrodbx),
+[@Parseus](https://github.com/Parseus),
+[@pyricau](https://github.com/pyricau),
+[@scottkennedy](https://github.com/scottkennedy)
+for the code contributions!
+
+### Public API changes
+
+* Subclasses of `AbstractAnalysisResultService` should now override `onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap)` instead of `onHeapAnalyzed(@NonNull HeapDump heapDump, @NonNull AnalysisResult result)`
+
+For more details, see the [1.6.2 Milestone](https://github.com/square/leakcanary/milestone/4) and the [full diff](https://github.com/square/leakcanary/compare/v1.6.1...v1.6.2).
+
+## Version 1.6.1 (2018-06-21)
+
+* [#727](https://github.com/square/leakcanary/issues/727) Improved leak analysis: LeakCanary now identifies and highlights the potential causes of the leak.
+* [#1011](https://github.com/square/leakcanary/issues/1011) We noticed that computing the retained heap size could take a long time, so it's now optional and off by default.
+* [#633](https://github.com/square/leakcanary/pull/633) Support for detecting leaks in instrumentation tests ([see the wiki](https://github.com/square/leakcanary/wiki/Customizing-LeakCanary#running-leakcanary-in-instrumentation-tests)).
+* [#985](https://github.com/square/leakcanary/pull/985) Ability to convert leak traces into stack traces for easy remote reporting ([see the wiki](https://github.com/square/leakcanary/wiki/Customizing-LeakCanary#uploading-to-a-server)).
+* [#983](https://github.com/square/leakcanary/issues/983) Support for watching destroyed Fragments.
+* [#846](https://github.com/square/leakcanary/issues/846) LeakCanary now uses foreground services and displays a notification when the analysis is in progress. This also fixes crashes when analyzing in background on O+.
+* The LeakCanary icon (to start to DisplayLeakActivity) is now hidden by default, and only enabled after the first leak is found.
+* [#775](https://github.com/square/leakcanary/issues/775) Fixed crash when sharing heap dumps on O+ and added a dependency to the support-core-utils library.
+* [#930](https://github.com/square/leakcanary/pull/930) DisplayLeakActivity has a responsive icon.
+* [#685](https://github.com/square/leakcanary/issues/685) Stopped doing IO on main thread in DisplayLeakActivity (fixes StrictMode errors).
+* [#999](https://github.com/square/leakcanary/pull/999) Updated HAHA to 2.0.4, which uses Trove4j as an external dependency (from jcenter) instead of rebundling it. This is to clarify licences (Apache v2 vs LGPL 2.1).
+* Several bug and crash fixes.
+
+Many thanks to [@AdityaAnand1](https://github.com/AdityaAnand1), [@alhah](https://github.com/alhah), [@christxph](https://github.com/christxph), [@csoon03](https://github.com/csoon03), [@daqi](https://github.com/daqi), [@JakeWharton](https://github.com/JakeWharton), [@jankovd](https://github.com/jankovd), [@jrodbx](https://github.com/jrodbx), [@kurtisnelson](https://github.com/kurtisnelson), [@NightlyNexus](https://github.com/NightlyNexus), [@pyricau](https://github.com/pyricau), [@SalvatoreT](https://github.com/SalvatoreT), [@shmuelr](https://github.com/shmuelr), [@tokou](https://github.com/tokou), [@xueqiushi](https://github.com/xueqiushi)
+ for the code contributions!
+
+Note: we made a 1.6 release but quickly followed up with 1.6.1 due to [#1058](https://github.com/square/leakcanary/issues/1058).
+
+### Public API changes
+
+* The installed ref watcher singleton is now available via `LeakCanary.installedRefWatcher()`
+* `AnalysisResult.leakTraceAsFakeException()` returns an exception that can be used to report and group leak traces to a tool like Bugsnag or Crashlytics.
+* New `InstrumentationLeakDetector` and `FailTestOnLeakRunListener` APIs for detecting leaks in instrumentation tests.
+* New `Reachability.Inspector` and `RefWatcherBuilder.stethoscopeClasses()` API to establish reachability and help identify leak causes.
+* Watching activities can be disabled with `AndroidRefWatcherBuilder.watchActivities(false)`, watching fragments can be disabled with `AndroidRefWatcherBuilder.watchFragments(false)`
+* `LeakCanary.setDisplayLeakActivityDirectoryProvider()` is deprecated and replaced with `LeakCanary.setLeakDirectoryProvider()`
+* New `RefWatcherBuilder.computeRetainedHeapSize()` API to enable the computing of the retained heap size (off by default).
+
+For more details, see the [1.6.1 Milestone](https://github.com/square/leakcanary/milestone/3) and the [full diff](https://github.com/square/leakcanary/compare/v1.5.4...v1.6.1).
+
 ## Version 1.5.4 *(2017-09-22)*
 
 * Restore Java 7 compatibility in leakcanary-watcher
diff --git a/README.md b/README.md
index b32e0ed9..9bce81c3 100644
--- a/README.md
+++ b/README.md
@@ -6,7 +6,7 @@ A memory leak detection library for Android and Java.
 *“A small leak will sink a great ship.”* - Benjamin Franklin
 
 <p align="center">
-<img src="https://github.com/square/leakcanary/blob/master/assets/screenshot.png"/>
+<img src="https://github.com/square/leakcanary/wiki/assets/screenshot.png"/>
 </p>
 
 ## Getting started
@@ -15,8 +15,10 @@ In your `build.gradle`:
 
 ```groovy
 dependencies {
-  debugCompile 'com.squareup.leakcanary:leakcanary-android:1.5.4'
-  releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.4'
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.2'
+  releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.2'
+  // Optional, if you use support library fragments:
+  debugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.2'
 }
 ```
 
@@ -38,30 +40,33 @@ public class ExampleApplication extends Application {
 }
 ```
 
-**You're good to go!** LeakCanary will automatically show a notification when an activity memory leak is detected in your debug build.
-
-To disable LeakCanary in unit tests, add the following to your `build.gradle`:
-
-```groovy
-// Ensure the no-op dependency is always used in JVM tests.
-configurations.all { config ->
-  if (config.name.contains('UnitTest')) {
-    config.resolutionStrategy.eachDependency { details ->
-      if (details.requested.group == 'com.squareup.leakcanary' && details.requested.name == 'leakcanary-android') {
-        details.useTarget(group: details.requested.group, name: 'leakcanary-android-no-op', version: details.requested.version)
-      }
-    }
-  }
-}
-```
-
-If you want to also disable leak detection in instrumentation tests, add `|| config.name.contains('AndroidTest')` to the
-`if` check above.
-
-Questions? Check out [the FAQ](https://github.com/square/leakcanary/wiki/FAQ)!
+**You're good to go!** LeakCanary will automatically show a notification when an activity or support fragment memory leak is detected in your debug build.
+
+**What's next?** You could watch a [live investigation](https://www.youtube.com/watch?v=KwArTJHLq5g) then [customize LeakCanary](https://github.com/square/leakcanary/wiki/Customizing-LeakCanary) to your needs.
+
+## FAQ
+
+* [Why should I use LeakCanary?](https://github.com/square/leakcanary/wiki/FAQ#why-should-i-use-leakcanary)
+* [How does it work?](https://github.com/square/leakcanary/wiki/FAQ#how-does-it-work)
+* [How do I fix a memory leak?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-fix-a-memory-leak)
+* [How do I customize LeakCanary to my needs?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-customize-leakcanary-to-my-needs)
+* [Where can I learn more?](https://github.com/square/leakcanary/wiki/FAQ#where-can-i-learn-more)
+* [How do I copy the leak trace?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-copy-the-leak-trace)
+* [Can a leak be caused by the Android SDK?](https://github.com/square/leakcanary/wiki/FAQ#can-a-leak-be-caused-by-the-android-sdk)
+* [How can I dig beyond the leak trace?](https://github.com/square/leakcanary/wiki/FAQ#how-can-i-dig-beyond-the-leak-trace)
+* [How do disable I LeakCanary in tests?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-disable-leakcanary-in-tests)
+* [How do I fix build errors?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-fix-build-errors)
+* [How many methods does LeakCanary add?](https://github.com/square/leakcanary/wiki/FAQ#how-many-methods-does-leakcanary-add)
+* [How do I use the SNAPSHOT version?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-use-the-snapshot-version)
+* [How can I be notified of new releases?](https://github.com/square/leakcanary/wiki/FAQ#how-can-i-be-notified-of-new-releases)
+* [Who's behind LeakCanary?](https://github.com/square/leakcanary/wiki/FAQ#whos-behind-leakcanary)
+* [Why is it called LeakCanary?](https://github.com/square/leakcanary/wiki/FAQ#why-is-it-called-leakcanary)
+* [Who made the logo?](https://github.com/square/leakcanary/wiki/FAQ#who-made-the-logo)
+* [Instant Run can trigger invalid leaks](https://github.com/square/leakcanary/wiki/FAQ#instant-run-can-trigger-invalid-leaks)
+* [I know I have a leak. Why doesn't the notification show?](https://github.com/square/leakcanary/wiki/FAQ#i-know-i-have-a-leak-why-doesnt-the-notification-show)
 
 <p align="center">
-<img src="https://github.com/square/leakcanary/blob/master/assets/icon_512.png" width="250"/>
+<img src="https://github.com/square/leakcanary/wiki/assets/icon_512.png" width="250"/>
 </p>
 
 ## License
diff --git a/assets/icon_1024.png b/assets/icon_1024.png
deleted file mode 100644
index f15c7586..00000000
Binary files a/assets/icon_1024.png and /dev/null differ
diff --git a/assets/icon_512.png b/assets/icon_512.png
deleted file mode 100644
index 0ca6bedf..00000000
Binary files a/assets/icon_512.png and /dev/null differ
diff --git a/assets/screenshot.png b/assets/screenshot.png
deleted file mode 100644
index 8faa278f..00000000
Binary files a/assets/screenshot.png and /dev/null differ
diff --git a/assets/source_icon.png b/assets/source_icon.png
deleted file mode 100644
index d04aace6..00000000
Binary files a/assets/source_icon.png and /dev/null differ
diff --git a/assets/vector_icon.afdesign b/assets/vector_icon.afdesign
deleted file mode 100644
index a30fcf97..00000000
Binary files a/assets/vector_icon.afdesign and /dev/null differ
diff --git a/assets/vector_icon.svg b/assets/vector_icon.svg
deleted file mode 100644
index 9a17f0dc..00000000
--- a/assets/vector_icon.svg
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" standalone="no"?>
-<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
-<svg width="100%" height="100%" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421;">
-    <image id="Container" x="33" y="44" width="443px" height="441px" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbsAAAG5CAYAAAAXoZoVAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAcMklEQVR4nO3dT4gkZ/nA8Wd6Zmc3mw1ZXEmCfxJCfgZJMDEHwaiRmEsQEolBAkET0Jw96CEXQQRFDyKePOXgIRhFBFFEzCFBEzRIFj0kIaJBCQZB8mezJG522Z3q38Gttqamqrq6u7q76u3PB4bu6Z3p6V525rvPW2/1bI3H4wCAlO2s+wF0YazYAEu1tbW1te7HsIitvnZi1oD19XkADF3bzvU5iL2KXVPg+vQ4Afivur71LXxrjd08cZv1dgDm0xCymT9v3fFbS+zqIld1c/E2oQNYraZGFf+sbRjXFb2Vxq4cuVnill+f9jkAdKdmSqv98/z9utsL7680eiuJ3bTINUWtTfAEEGBxbaazadfrLuu+xqqit9TYtY1c02Xx+iuvvBJ///vf44033ojXX39939upU6fi/PnzS3suAJvm6NGj8a53vStOnDhx4O2GG26Iyy67bF/UpgVvykS41OgtLXbF0LWJXPn6eDyOLMvixRdfjD/84Q/xzDPPxCuvvLKUxwrAbLa3t+PGG2+MW2+9NT7+8Y/HVVddVRu+ttFbZvCWEru60E2LW/7+yZMn46mnnoo//vGPcerUqc4fHwDduvbaa+NjH/tY3HHHHfH+97//QOzaRm9Zwes8dk2hqwpc8e2FF16IRx55JF588cVOHxMAqzEajeLOO++MBx54IE6cOHEgdnVTX/5+4Xqn0es0dnnoZo3cyy+/HD/84Q/jmWee6eyxALA+hw8fjnvvvTfuu+++OHr0aG30Wmxo6SR6ncWuKXTF4GVZNnn/9ddfj0cffTQef/zxyLKsk8cBQH9cfvnlcf/998fdd98dOzs7MRqN1jLldRK7cuiaJrk8di+88EJ885vfjDfffHPhrw9Av910003xta99LS6//PLK4LU4prdQ8BaOXVXoyteL01yWZfH444/HD37wA6cKAGyQq666Kr7xjW/ENddcsy94xesR1Ts4L16fO3gLxa4pdOXAjcfjuHDhQjzyyCPxi1/8Yu6vCcBwXXLJJfHwww/HRz/60QOhy9+P6D54c8euLnRVy5ZZlsXbb78d3/nOd+JPf/rTXF8PgDSMRqN48MEH47777psErjzpRXQbvLli1yZ0eeTG43GcPXs2Hn744fjb3/4289cCIE33339/fOELX5jEboZjeTPHbjTrJ0wLXR65/G1vby++//3vCx0A+/zkJz+Jp59+el8zql5opGLz48xT2kyxaxO6cvB++tOfxlNPPTXr4wIgcePxeDIMlQelvCX5x5WDN6vWsWuz67IYur29vXjmmWfi0UcfneuBAZC+c+fOxbe+9a14/fXXY29v78B0V3cO9qzT3czLmGVV01yWZfGPf/wjvve9781dYQA2w2uvvRbf/va349y5c5PglaO36HJmq9i13XmZR+/8+fPx3e9+N86ePTvjUwZgE/3lL3+Jxx57rHI5s4vgzbKMObms25Syt7cXe3t78cQTT8Q///nPmZ8sAJvrV7/6Vbz66qv7pru6jSuzmhq7umpWLV1mWRZnz56Nxx57bK4HA8DmOnfuXPz4xz9unOwiKl+acmoBG2NXt3xZdQAxn+x++ctfxhtvvLHI8wVgQz355JPx8ssvVwYvovp3oLZRG7um43TF94uhO336dPz85z9f4GkCsMmyLItHH320cikzD1+VadPdPCeVVz6ALMviZz/7WZw5c2bWuwSAiZMnT8YLL7xQu5xZNe1N03Y3Zu3GlPzy3Llz8cQTTyz2DAEgIn7zm9/UblKJ2H+ud65pupt2zO7A+3U7MZ977rl455135n5iAJD785//HOfOnTvwiirTNqvUqYxdsY5NU13x7dlnn+3sSQKw2c6cORPPP//8zKcf1E13TRtUDrxftwPzwoULcfLkyXmfEwAc8Oyzzx54RZWmE82bHIhduYrTjtVlWRYvvfRSnDp1qsOnCMCmO3ny5NRXVClqOu+u1TE7S5gArNqpU6fipZdeqvxtCAtNduVz66quF79I/sWff/75zp4cAOSee+65A92JmP3k8rkmu/JS5muvvdbFcwKAfV577bXaya5K3e1TN6hM24l54cKFePvttzt4SgCw36lTpxo3pjQcv9t3Q9UGlcovWBe9U6dO1f5yPQBYxOnTpw9siqwLXdNS5iR2bXZhVk13dmECsCz5QDXvKQe5upPKay/L46TYAbAsp0+frvzt5RHVQ1l+e1mb32d34LI42fl1PgAsS/4bdeZZuiyuWJZPPaj7hNr10rfeemumURIA2sjbknemKXjT4je6+IeVx+uK18vn2816jgMAzKrq/O7OjtkVv0j5/brz7QCgK3UDVvH9qo+r0+qYXdOOTABYhmLQyptT8tvbrjI2nlRe9UnlOy4Gz4QHQNfqdl+2+Zxcq5PKpx0QBIBlatpL0mZH5kynHtSdhgAAy9IUtrYNmhq7ui8qdACsUlN7Fj6pvOmLAsCyNZ0C19bUUw+6GB8BoAvzrio2vjZm1W2WLwFYpabuzH3MziuiANB3bU8mzxV/xU/ndw4AXVnkUNpcG1SEDoB1mLc/c+/GXOSLAsAsFu1NqxeCFjUA1qWLMwFaT3ZVr54CAKuySHcWWsYEgCEQOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTO4ABGI/H634IgyZ2AAMwHo8jy7J1P4zBEjuAARG8+YgdwMAI3uzEDqDnqo7XCd5sxA5goASvPbED6LmmnZiC147YAQyc4E0ndgA91vb8OsFrJnYAiRC8emIHkJAsy7zaSgWxA+ixecI1Ho8Fr0TsABIkePuJHUBPLRorwfsfsQNImOD9l9gB9FRXkRI8sQPYCJsePLED2BCbHDyxA+ihZUVpU4MndgAbZhODJ3YAPbTsGG1a8MQOYENtUvDEDqBnVhmgTQme2AFsuE0IntgB9Mw6wpN68MQOgIhIO3hiB8BEqsETO4Ae6UNoUgye2AFwQGrBEzsAKo3H48iybN0PoxNiB9AjfZymUgie2AEw1dCDJ3YAPdHHqa5oyMETOwBaG2rwxA6AmQwxeGIH0BN9X8YsGlrwxA6AuQwpeGIHwNyGEjyxA+iBIS1hlg0heGIHwML6HjyxA+iBIU92uT4HT+wA6Exfgyd2AHQqy7LeTapiB7BmfQtDF/r2K4LEDoCl6FPwxA6ApelL8MQOYM36EINl6kPwxA6ApVt38MQOYI3WPfGs0jqDJ3YArMy6gid2AKzUOoIndgBrtEnLmEWrDp7YAbAWqwye2AGwNqsKntgBrMmmLmGWrSJ4YgfA2i07eGIHsCYmu/2WGbydpdwrAMxB7ADYCMsInmVMgDWwhNms6yVNkx0AvZTHrovomewA6K3xeBx7e3sL34/YAayBZczVEjsAkid2ACRP7ABWzBLm6okdAMkTOwCSJ3YAK2YZc/XEDoDkiR3ACpnq1kPsAEie2AGQPLEDWCHLmOshdgAkT+wASJ7YAayIJcz1ETsAkid2ACRP7ABWxDLm+ogdAMkTO4AVMNWtl9gBkDyxAyB5YgewApYx10vsAEie2AGQPLEDWDJLmOsndgAkT+wASJ7YASyZZcz1EzsAkid2ACRP7ACWyBJmP4gdAMkTO4AlMtn1g9gBkDyxAyB5YgewJJYw+0PsAEie2AGQPLEDWBLLmP0hdgAkT+wASJ7YASyBJcx+ETsAkid2AEtgsusXsQMgeWIH0DFTXf+IHQDJEzsAkid2AB2zjNk/YgdA8sQOoEOmun4SOwCSJ3YAJE/sADpkGbOfxA6A5IkdQEdMdf0ldgAkT+wASJ7YAXTEMmZ/iR0AyRM7gA6Y6vpN7ABIntgBkDyxA+iAZcx+EzsAkid2AAsy1fWf2AGQPLEDWJDJrv/EDoDkiR3AAkx1wyB2ACRP7AAWYLIbBrEDIHliBzAnU91wiB0AyRM7gDmZ7IZD7ABIntgBzMFUNyxiB0DyxA5gDia7YRE7AJIndgAkT+wAZmQJc3jEDoDkiR3AjEx2wyN2ACRP7ABmYKobJrEDIHliBzADk90wiR0AyRM7gJZMdcMldgAtid1wiR0AyRM7gBZMdcMmdgAkT+wAWjDZDZvYAUwhdMMndgAkT+wApjDZDZ/YATQQujSIHQDJEzuABia7NIgdAMkTO4Aaprp0iB1ADbFLh9gBkDyxA6hgqkuL2AGQPLEDqGCyS4vYAZQIXXrEDoDkiR1AickuPWIHUCB0aRI7AJIndgAFJrs0iR3ARUKXLrEDuEjs0iV2ACRP7ADCVJc6sQMIsUud2AEbT+jSJ3YAJE/sgI1nskuf2AEbTeg2g9gBG03sNoPYARtL6DaH2AGQPLEDNpbJbnOIHbCRhG6ziB2wkcRus4gdsHGEbvOIHbBxxG7ziB2wUYRuM4kdsFHEbjOJHbAxhG5ziR2wMcRuc4kdsBGEbrOJHbARxG6ziR2QPKFD7ABIntgByTPZIXZA0oSOCLEDEid2RIgdkLAsy9b9EOgJsQOSZKKjSOyAJIkdRWIHJEfoKBM7IDliR5nYAUkROqqIHZCM8XgsdlQSOyAZQkcdsQOSIHQ0ETsgCWJHE7EDBs8rpTCN2AGDZqKjDbEDBk3saEPsgMGyfElbYgcMkomOWYgdMEhixyzEDhgcy5fMSuyAQTHRMQ+xAwbDa18yL7EDBkPomJfYAYPgOB2LEDug94SORYkd0GuWLumC2AG9ZUMKXRE7oJeEji6JHdBLQkeXxA7oHRtS6JrYAb0idCyD2AG9IXQsi9gBvSB0LJPYAWsndCyb2AFrJXSsgtgBayN0rMrOuh8AsHmcMM6qmeyAlRI61kHsgJUROtbFMiawEo7PsU4mO2DphI51M9kBS2PZkr4w2QFLIXT0ickO6JTI0UcmO6AzQkdfmeyAhYkcfSd2wELstGQIxA6Yi2mOIRE7YCYixxCJHdCKyDFkYgc0EjlSIHasXJZlsbW1FRExuaR/RI6UiB0rNxqNJjv48h+m4tcfIkeKxI612Nra2vcDNb9ejJ/wrY7AkTqxYy3ykNX9gC3+8DX1LUf5PxiQMrFjbaYFL1c19ZXvg/ZMcWwisWOt2gavqGr5UwDrmeBA7OiBeYJXJoD/I25wkNjRC10Er2xaAKveH5qq5wgcJHb0xjKCV1a+7/L7fYzhtMcMTCd29Er5lIRVaxuWZUZQzKB7YkfvFE867ytBgmHxm8rppdHIP02gO36i0FuCB3TFTxN6TfCALvhJQu/1YUckMGxiR+95UWhgUWLHIAgesAixYzAED5iX2DEoggfMQ+wYHMEDZiV2DJLYAbMQOwbLOXhAW35aMGiCB7ThJwWDJ3jANH5KkATBgzR19RtGOvkJMR6P/coT1k7wgDoL/3QQOfrELk1ITxedETuS4hw8SEfely6+p2f+TeX5F80vd3d3DwTPDxvWKf/35z9iMEzlQ2NHjx5d+D4bJ7titOoCdvz48YUfBHTNhAdpGI/HnXSm1TJm0w+N48eP26BCLwkeDN9oNIqdnf8uQi7y/bzQMbutra1J7CIsG9E/ggfDlA9R29vbB76H5/menil25eN1Ef9bxiwGT/ToE7GD4Sg2ZDwex+7ubkQs/n0892SXf+FDhw7FkSNHRI5ecw4eDEfek/F4HIcPH+7kPg/8BKia3qY5duxYZFkmePSa4EH/Fae6LMv27cRc5LDE5Lu/audl8Y7z6+UvtrW1FVdfffXkgRWLDH0jeNBfeTeyLJv05IMf/GDtx88Svrl3Yxajd8stt+yLnNDRZ4IH/VXuyJ133lk7jJVvazLzd33VtHfjjTfGzs7OvhoLHn1m0wr0S3lgyrIsLrvssrjkkksioj5ubb+Xp8auakmzfPvu7m584AMfOPBgBY++ckoC9E+5HzfccMOBASs36/fwzMuYdcfxbr755kmNTXcMgeBBP5Qnurwhd9111+Rj6vaNlP88v14208uFFd8fjUb73r/lllsiIg7ETvDoM8GDfijH7vDhw3HixInGwEV0sIzZtD5anuxGo1EcO3Ysrr/++skDNd0xFIIH61McjPb29ib9+NCHPhQRBye6qgmvaQPL1sUrtefZVX3itLd77rknIv473eUPWvAYAsGD9SlOdFmWxWg0igcffHCygjjtFLj8z5qMLn5Q5Ue1CV3xwVx99dVx880373vQgsdQCB6sVnnpMn+7/fbbY2dnp7Y1uaYJr2zfZFd3MnnVHRe/8Gg0mrz/2c9+Nkaj0b7pLg8e9J3YwWqUQ5f34vDhw3HvvfdWtqZpKXOa1rsxq0JXFbwTJ07ErbfeeuAJmO4YCiedw/IVY1fsxF133XVgiKoL3iym7sactpRZfkCj0SjuuuuuOHLkyIHgmfAYCsGD5akKXZZlcezYsbj99ttbha7NZpWi4mtjbhWuR/F6U+TKoct3Zt5zzz2T3TX5m+AxJIIH3SsvXeZvEREPPfTQvpZU9WWWwBW71njqQd0xvKoHUH679dZb47bbbjvwhCxpMiSCB92pCl3ehM985jNx3XXX1TalzUTXFL+ppx7s++DSMbppwbvnnnvi+uuvPzDhFZ8g9J1NK7C4uokuy7L48Ic/HJ/61Kcae1IVvogOTyov17NqU8r29nZsb2/vu769vR07OzvxxS9+Md797ndXPkHBYwickgDzq9p1WezAlVdeGQ888EBlT+qO3eUrLrMEr3zqwVbp/amnGxTfqh7kJZdcEg899NBkw8re3l5cuHBB9BgUwYPZTQvdkSNH4itf+cq+IanclLrJru6E81y5Z5WTXdU3dfmYXV3sytPdaDSKK664Ir70pS/FpZdeOnmiefAuXLjgtTQZBMGD9so7Li9cuDB5y0P31a9+NXZ3d/c1o9yPcgSrljDLmyqrtHoh6KolzDbLmMW3a6+9Nr785S/HVVdddWDCK056gkefCR40K09yxcjlP+OvuOKK+PrXvx4nTpyobUbdcmbVSmPE9KXMrXJYxhdvyG+vezmX4oSWv50/f37fW/G2/Pq5c+fiRz/6Ubz44osHgrnoAUhYFf8pg/9p04v89ptuuik+//nPx87OTuzs7MShQ4cml8W34m07OzuTfSBVS5s1097+w3JV37DF4FX9nqHiiYDF2FXFrer63t5ePP744/G73/0uxuNx662mxScC6yZ4bLJi4PLL/JBU3YuJfPrTn45PfvKTk9CVg1YVu/zjyhNf1QnnEZPVlwOh2Jn2hOpOMB+NRvtCtb29HVmWxfb29r44lq/n7rzzznjPe94Tv/71r+PNN9+cfEzTQUjRo2/KsVvVv0uRZV2qIlc1zRV//h87dizuv//+uO666/aFrhixqqDVDUER1b8Boen7r3Kyu/gExuUn07SzpmrCq7osr9+eP38+fv/738fTTz8dZ86cqTwmWF6jLT4p0WPdsiw7cNss/y6FiyGoi1x5oitGbnd3N+6444647bbb9gWtagmzPMnVLV/WTXVNOzEjpsSu6olVjal1wSsvX1a95Z979uzZePLJJ+PZZ5+N8+fP5w+41XQnfKxbVfBg6MqBy69PexuNRvGRj3wk7r777srzr8tBqwpeOY7FvR1NG1SqQhfRInZ1T65us0rTlNcUu/x+Tp8+Hb/97W/jr3/9a5w+fbr2pWBm2XIKq2BCY+hq9nBMvcyv7+7uxv/93//F5z73uX2nFIxGowNTXTl2VaErLm222c9RF7qIhthdfBKV013T7sxi7PLrdbErfnz5tdKyLIt//etf8dxzz8VLL70Ur776aozH48a4iR3rZsIjReXJLre1tRWXXnppXHfddfGJT3wirrzyysoXGilPdfn1cuzKf15cuqyLXf44Ll7WRqBxg8rW1tbWeDweb21tVYam+CK5xSBub2/vu738ufnnFx9slmWT9/PYve9974v3vve9kWVZvPnmm/H888/Hv//97/jPf/4Tb7/9dpw5cybeeeedyStmQx+Y8PzHMzWHDh2Ko0ePxtGjR+PYsWNx2WWXxTXXXBM33HBDHDp0qPbFRupiV/fWZnPKvJsVGye7iNmWM8sTXtWUV/V+eSmz/Mv8ipcR//vfc/7Q3nrrrTh9+vTkXI6K59DqLwO6UPXvcJYf/rMszYsKXakaSI4cORLHjx+P3d3dykNJxWNnTS8fWXUMrs2uzGmxm7YppWjqqQfT/kKK013bzys/2PyJ7O3t7bssb2HNL/OvmQf3+PHjcfnll0/uX9wAFtO0EXBa7KpeVaspeMWPaTPRVYR56v/62pxnt5VPd1XLmfn7VUuadX9xTX9J+bl2VedrlF9Dc9qBUwBmV7cBsOqt/HO8OJHl8aqb3KpCV/U6mFN247da3mg12TUFLw9T/mfTJr3yX9CisWsKnegBtFe3hF6MTP4zvnwKQNMSZjl4dUuW5dAVL2seb+t1/NbLmMXglZUjVfXAmv5XUPwL2tvbm1xWnYnfdrorEj2AZlXdqDtOV/czfNpSZtUUV7fjsuo8ulk3pRTNdMyubndmfhwtD115a+rW1lbs7e21Cl1+P/nLj9UFL/+65ejltxeJHUCzqg0q+WXT8bq6ya4ueOX4lT+nvPJXt3w5q5k3qBT/IuqCF1G9caX8wIuvhZmHLo9c+UVEy8ErT3WWMQEWN+/xuvyyKmDTLquWLqeFbpYlzIj5dmNuRfz3lIS2wav7i8oDVjxel7+VJ7umY3Y2qAB0p2ITyIHrdfsuqia8umXKNrsuuwhdxAKTXfEvpSp4VRGqi13dppSqJcy6pczi15nyqjCLPmWAQZvWirbTXdMmlbZvVeEsfr2KxzHXOubUk8qnqXpJsfyyHKaqKa0pblWhm2eDSuGxLvRcAVIxa/CmLWVWxW7abVX3Ufxa5cc5b+giOpjsCg+i8mXBImIy6eVPKP+44kuEFSe7cgyrohlxcKqzMQVgfk2bVPLLWSa8utvaHpvrKnQR3Sxj7juGd/H6gfG3ahorhq94vK9qils0dMIHUK0ucsXrs054VZfFZcqmaa7iMSz8unidTXZFVcfxqp5EHqliDIvBKx77swuTFJT/bXbwPQxLUTdl1U1jVZNa06aTVYYuooNjdmXjwh2WA1QVqbpz5preive9yPKlKAKbpm07Zpnuqm6bthu/+Gd1j62r0EUsIXYR9cHL36+bzOomt2nTXNVzEDKA+bQ5dpdfNgWv7rbi7VVfs8vITe5zWVEYV9xx06RXvK3NRDht96XYAcynqjU1m0Yqp7Sm61X3Ubi+tHX9pcUuV45e06TX9v3y/diMAtCtWTetlC+bPr7mPpd6AHvpscu1mfTa3NZ0e9X9AjC7pumu6s/nCVzhtqXv1FpZ7HJtJr26P2vz523+DICD2jRnWvCabq+4r5VtR1557HLTJr2m29s8ZrEDmM0s7ZkWtKb7WmXkJl9z3VGoil7hz5o+b9r9zv+gADbQtAbNOvkVblv7CaVrj13ZvPEDYHVahm/tkcv1LnZlTfEDoD/6FLey3seujggCrFafYzbNYGMHAG39P8QjHPIeCPK8AAAAAElFTkSuQmCC"/>
-    <path id="Canary Badge" d="M112.189,145.49L254.837,81.3501L396.288,145.49C396.288,145.49 396.862,207.984 396.288,231.803C400.997,350.37 312.745,416.946 254.837,430.897C196.973,416.761 109.794,350.592 112.189,231.803C112.756,203.667 112.189,145.49 112.189,145.49ZM175.089,342.14C175.089,342.14 184.466,327.557 200.474,320.28C204.922,315.034 207.831,307.409 215.292,300.115C219.468,296.033 226.552,291.174 233.166,288.656C239.785,286.137 247.648,284.843 255,285C262.352,285.157 268.152,286.319 277.281,289.599C300.356,298.133 328.246,333.945 334.028,349.404C315.038,361.253 296.986,374.343 277.281,397.842C273.2,395.993 262.831,392.31 245.929,394.232C225.332,398.578 205.605,369.407 206.507,353.455C194.408,348.947 175.089,342.14 175.089,342.14ZM239.502,332.155C236.224,332.127 234.144,330.44 233.732,328.884C233.319,327.329 235.679,323.517 237.026,322.821C244.051,319.192 251.916,319.735 251.916,319.735C251.916,319.735 254.299,332.28 239.502,332.155ZM238.929,221.803L270.281,221.803L270.281,254.418L238.929,254.418L238.929,221.803ZM238.929,136.356L270.281,136.356L270.281,205.834L238.929,205.834L238.929,136.356Z" style="fill:rgb(253,237,0);"/>
-</svg>
diff --git a/build.gradle b/build.gradle
index a76ea2d3..a1396421 100644
--- a/build.gradle
+++ b/build.gradle
@@ -3,7 +3,8 @@ apply plugin: 'com.github.ben-manes.versions'
 buildscript {
   ext.versions = [
     'minSdk': 14,
-    'compileSdk': 27,
+    'compileSdk': 28,
+    'errorProne': '2.3.1',
   ]
   repositories {
     jcenter()
@@ -11,9 +12,9 @@ buildscript {
     maven { url 'https://plugins.gradle.org/m2/' }
   }
   dependencies {
-    classpath 'com.android.tools.build:gradle:3.0.1'
-    classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.0.13'
-    classpath 'com.github.ben-manes:gradle-versions-plugin:0.17.0'
+    classpath 'com.android.tools.build:gradle:3.2.0'
+    classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.0.16'
+    classpath 'com.github.ben-manes:gradle-versions-plugin:0.20.0'
   }
 }
 
@@ -23,6 +24,7 @@ subprojects {
 
   repositories {
     jcenter()
+    google()
 //    maven {
 //      url 'https://oss.sonatype.org/content/repositories/snapshots/'
 //    }
@@ -36,7 +38,9 @@ subprojects {
       '-Xlint:all',
       '-Xlint:-serial',
       '-Xlint:-deprecation',
-      '-Werror'
+        // espresso-core classes say they're compiled with 51.0 but contain 52.0 attributes.
+        // warning: [classfile] MethodParameters attribute introduced in version 52.0 class files is ignored in version 51.0 class files
+      // '-Werror'
     ]
   }
 
@@ -46,7 +50,7 @@ subprojects {
         // Force all the error-prone dependencies to use the same version.
         if (details.requested.group == 'com.google.errorprone' &&
                 details.requested.name.startsWith('error_prone_')) {
-          details.useVersion '2.1.2'
+          details.useVersion versions.errorProne
         }
       }
     }
@@ -60,4 +64,8 @@ subprojects {
       showStackTraces true
     }
   }
+
+  dependencies {
+    errorprone "com.google.errorprone:error_prone_core:${versions.errorProne}"
+  }
 }
diff --git a/checkstyle.xml b/checkstyle.xml
index ca4ebcc5..ce09c3d1 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -83,7 +83,7 @@
       <!--property name="max" value="100"/-->
     <!--/module-->
     <!--module name="MethodLength"/-->
-    <module name="ParameterNumber"/>
+    <!--<module name="ParameterNumber"/>-->
 
 
     <!-- Checks for whitespace                               -->
diff --git a/gradle.properties b/gradle.properties
index 838a4e84..03ab67e4 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,5 +1,5 @@
 GROUP=com.squareup.leakcanary
-VERSION_NAME=1.6-SNAPSHOT
+VERSION_NAME=1.7-SNAPSHOT
 
 POM_DESCRIPTION=Leak Canary
 
diff --git a/gradle/gradle-mvn-push.gradle b/gradle/gradle-mvn-push.gradle
index 63d9a780..406a0d16 100644
--- a/gradle/gradle-mvn-push.gradle
+++ b/gradle/gradle-mvn-push.gradle
@@ -81,7 +81,16 @@ afterEvaluate { project ->
     if (plugins.hasPlugin('com.android.application') || plugins.hasPlugin('com.android.library')) {
       task androidJavadocs(type: Javadoc) {
         source = android.sourceSets.main.java.srcDirs
+        exclude "**/internal/**"
         classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+
+        // Append also the classpath and files for release library variants.
+        // This fixes the javadoc warnings.
+        // Copy pasta from https://github.com/novoda/bintray-release/pull/39/files
+        def releaseVariant = project.android.libraryVariants.find { it.name.endsWith("release") }
+
+        classpath += releaseVariant.javaCompile.classpath
+        classpath += releaseVariant.javaCompile.outputs.files
       }
 
       task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 7a3265ee..0d4a9516 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index f16d2666..7dc503f1 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-bin.zip
diff --git a/leakcanary-analyzer/build.gradle b/leakcanary-analyzer/build.gradle
index b90e4ee4..8cb636a4 100644
--- a/leakcanary-analyzer/build.gradle
+++ b/leakcanary-analyzer/build.gradle
@@ -1,19 +1,28 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-  implementation 'com.squareup.haha:haha:2.0.3'
+  implementation 'com.squareup.haha:haha:2.0.4'
   api project(':leakcanary-watcher')
   testImplementation 'junit:junit:4.12'
-  testImplementation 'org.assertj:assertj-core:3.8.0'
+  testImplementation 'org.assertj:assertj-core:3.9.1'
+  implementation 'com.android.support:support-annotations:26.0.0'
 }
 
 android {
   compileSdkVersion versions.compileSdk
+
   defaultConfig {
     minSdkVersion versions.minSdk
   }
+
   lintOptions {
     disable 'GoogleAppIndexingWarning'
+    check 'Interoperability'
+  }
+
+  // TODO replace with https://issuetracker.google.com/issues/72050365 once released.
+  libraryVariants.all {
+    it.generateBuildConfig.enabled = false
   }
 }
 
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java b/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java
index 227bcb59..ca6fe3a6 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java
@@ -15,9 +15,11 @@
  */
 package com.squareup.haha.perflib;
 
+import android.support.annotation.NonNull;
+
 public final class HahaSpy {
 
-  public static Instance allocatingThread(Instance instance) {
+  public static @NonNull Instance allocatingThread(@NonNull Instance instance) {
     Snapshot snapshot = instance.mHeap.mSnapshot;
     int threadSerialNumber;
     if (instance instanceof RootObj) {
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
index 4c8270c1..823a7534 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
@@ -15,21 +15,27 @@
  */
 package com.squareup.leakcanary;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import java.io.Serializable;
 
 public final class AnalysisResult implements Serializable {
 
-  public static AnalysisResult noLeak(long analysisDurationMs) {
+  public static final long RETAINED_HEAP_SKIPPED = -1;
+
+  public static @NonNull AnalysisResult noLeak(long analysisDurationMs) {
     return new AnalysisResult(false, false, null, null, null, 0, analysisDurationMs);
   }
 
-  public static AnalysisResult leakDetected(boolean excludedLeak, String className,
-      LeakTrace leakTrace, long retainedHeapSize, long analysisDurationMs) {
+  public static @NonNull AnalysisResult leakDetected(boolean excludedLeak,
+      @NonNull String className,
+      @NonNull LeakTrace leakTrace, long retainedHeapSize, long analysisDurationMs) {
     return new AnalysisResult(true, excludedLeak, className, leakTrace, null, retainedHeapSize,
         analysisDurationMs);
   }
 
-  public static AnalysisResult failure(Throwable failure, long analysisDurationMs) {
+  public static @NonNull AnalysisResult failure(@NonNull Throwable failure,
+      long analysisDurationMs) {
     return new AnalysisResult(false, false, null, null, failure, 0, analysisDurationMs);
   }
 
@@ -46,26 +52,86 @@ public static AnalysisResult failure(Throwable failure, long analysisDurationMs)
    * Class name of the object that leaked if {@link #leakFound} is true, null otherwise.
    * The class name format is the same as what would be returned by {@link Class#getName()}.
    */
-  public final String className;
+  @Nullable public final String className;
 
   /**
    * Shortest path to GC roots for the leaking object if {@link #leakFound} is true, null
    * otherwise. This can be used as a unique signature for the leak.
    */
-  public final LeakTrace leakTrace;
+  @Nullable public final LeakTrace leakTrace;
 
   /** Null unless the analysis failed. */
-  public final Throwable failure;
+  @Nullable public final Throwable failure;
 
   /**
    * The number of bytes which would be freed if all references to the leaking object were
-   * released. 0 if {@link #leakFound} is false.
+   * released. {@link #RETAINED_HEAP_SKIPPED} if the retained heap size was not computed. 0 if
+   * {@link #leakFound} is false.
    */
   public final long retainedHeapSize;
 
   /** Total time spent analyzing the heap. */
   public final long analysisDurationMs;
 
+  /**
+   * <p>Creates a new {@link RuntimeException} with a fake stack trace that maps the leak trace.
+   *
+   * <p>Leak traces uniquely identify memory leaks, much like stack traces uniquely identify
+   * exceptions.
+   *
+   * <p>This method enables you to upload leak traces as stack traces to your preferred
+   * exception reporting tool and benefit from the grouping and counting these tools provide out
+   * of the box. This also means you can track all leaks instead of relying on individuals
+   * reporting them when they happen.
+   *
+   * <p>The following example leak trace:
+   * <pre>
+   * * com.foo.WibbleActivity has leaked:
+   * * GC ROOT static com.foo.Bar.qux
+   * * references com.foo.Quz.context
+   * * leaks com.foo.WibbleActivity instance
+   * </pre>
+   *
+   * <p>Will turn into an exception with the following stacktrace:
+   * <pre>
+   * java.lang.RuntimeException: com.foo.WibbleActivity leak from com.foo.Bar (holder=CLASS,
+   * type=STATIC_FIELD)
+   *         at com.foo.Bar.qux(Bar.java:42)
+   *         at com.foo.Quz.context(Quz.java:42)
+   *         at com.foo.WibbleActivity.leaking(WibbleActivity.java:42)
+   * </pre>
+   */
+  public @NonNull RuntimeException leakTraceAsFakeException() {
+    if (!leakFound) {
+      throw new UnsupportedOperationException(
+          "leakTraceAsFakeException() can only be called when leakFound is true");
+    }
+    LeakTraceElement firstElement = leakTrace.elements.get(0);
+    String rootSimpleName = classSimpleName(firstElement.className);
+    String leakSimpleName = classSimpleName(className);
+
+    String exceptionMessage = leakSimpleName
+        + " leak from "
+        + rootSimpleName
+        + " (holder="
+        + firstElement.holder
+        + ", type="
+        + firstElement.type
+        + ")";
+    RuntimeException exception = new RuntimeException(exceptionMessage);
+
+    StackTraceElement[] stackTrace = new StackTraceElement[leakTrace.elements.size()];
+    int i = 0;
+    for (LeakTraceElement element : leakTrace.elements) {
+      String methodName = element.referenceName != null ? element.referenceName : "leaking";
+      String file = classSimpleName(element.className) + ".java";
+      stackTrace[i] = new StackTraceElement(element.className, methodName, file, 42);
+      i++;
+    }
+    exception.setStackTrace(stackTrace);
+    return exception;
+  }
+
   private AnalysisResult(boolean leakFound, boolean excludedLeak, String className,
       LeakTrace leakTrace, Throwable failure, long retainedHeapSize, long analysisDurationMs) {
     this.leakFound = leakFound;
@@ -76,4 +142,9 @@ private AnalysisResult(boolean leakFound, boolean excludedLeak, String className
     this.retainedHeapSize = retainedHeapSize;
     this.analysisDurationMs = analysisDurationMs;
   }
+
+  private String classSimpleName(String className) {
+    int separator = className.lastIndexOf('.');
+    return separator == -1 ? className : className.substring(separator + 1);
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalyzerProgressListener.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalyzerProgressListener.java
new file mode 100644
index 00000000..96e015fa
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalyzerProgressListener.java
@@ -0,0 +1,25 @@
+package com.squareup.leakcanary;
+
+import android.support.annotation.NonNull;
+
+public interface AnalyzerProgressListener {
+
+  @NonNull AnalyzerProgressListener NONE = new AnalyzerProgressListener() {
+    @Override public void onProgressUpdate(@NonNull Step step) {
+    }
+  };
+
+  // These steps should be defined in the order in which they occur.
+  enum Step {
+    READING_HEAP_DUMP_FILE,
+    PARSING_HEAP_DUMP,
+    DEDUPLICATING_GC_ROOTS,
+    FINDING_LEAKING_REF,
+    FINDING_SHORTEST_PATH,
+    BUILDING_LEAK_TRACE,
+    COMPUTING_DOMINATORS,
+    COMPUTING_BITMAP_SIZE,
+  }
+
+  void onProgressUpdate(@NonNull Step step);
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
index a651572d..b322c162 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
@@ -18,7 +18,6 @@
 import com.squareup.haha.perflib.ArrayInstance;
 import com.squareup.haha.perflib.ClassInstance;
 import com.squareup.haha.perflib.ClassObj;
-import com.squareup.haha.perflib.Field;
 import com.squareup.haha.perflib.Instance;
 import com.squareup.haha.perflib.Type;
 import java.lang.reflect.InvocationTargetException;
@@ -26,7 +25,6 @@
 import java.nio.charset.Charset;
 import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
 
 import static com.squareup.leakcanary.Preconditions.checkNotNull;
@@ -39,18 +37,6 @@
           Double.class.getName(), Byte.class.getName(), Short.class.getName(),
           Integer.class.getName(), Long.class.getName()));
 
-  static String fieldToString(Map.Entry<Field, Object> entry) {
-    return fieldToString(entry.getKey(), entry.getValue());
-  }
-
-  static String fieldToString(ClassInstance.FieldValue fieldValue) {
-    return fieldToString(fieldValue.getField(), fieldValue.getValue());
-  }
-
-  static String fieldToString(Field field, Object value) {
-    return field.getName() + " = " + value;
-  }
-
   static String threadName(Instance holder) {
     List<ClassInstance.FieldValue> values = classInstanceValues(holder);
     Object nameField = fieldValue(values, "name");
@@ -66,7 +52,7 @@ static boolean extendsThread(ClassObj clazz) {
     boolean extendsThread = false;
     ClassObj parentClass = clazz;
     while (parentClass.getSuperClassObj() != null) {
-      if (clazz.getClassName().equals(Thread.class.getName())) {
+      if (parentClass.getClassName().equals(Thread.class.getName())) {
         extendsThread = true;
         break;
       }
@@ -75,7 +61,29 @@ static boolean extendsThread(ClassObj clazz) {
     return extendsThread;
   }
 
+  /**
+   * This returns a string representation of any object or value passed in.
+   */
+  static String valueAsString(Object value) {
+    String stringValue;
+    if (value == null) {
+      stringValue = "null";
+    } else if (value instanceof ClassInstance) {
+      String valueClassName = ((ClassInstance) value).getClassObj().getClassName();
+      if (valueClassName.equals(String.class.getName())) {
+        stringValue = '"' + asString(value) + '"';
+      } else {
+        stringValue = value.toString();
+      }
+    } else {
+      stringValue = value.toString();
+    }
+    return stringValue;
+  }
+
+  /** Given a string instance from the heap dump, this returns its actual string value. */
   static String asString(Object stringObject) {
+    checkNotNull(stringObject, "stringObject");
     Instance instance = (Instance) stringObject;
     List<ClassInstance.FieldValue> values = classInstanceValues(instance);
 
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
index 74ec6918..a5093898 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.leakcanary;
 
+import android.support.annotation.NonNull;
 import com.squareup.haha.perflib.ArrayInstance;
 import com.squareup.haha.perflib.ClassInstance;
 import com.squareup.haha.perflib.ClassObj;
@@ -27,11 +28,13 @@
 import com.squareup.haha.perflib.Type;
 import com.squareup.haha.perflib.io.HprofBuffer;
 import com.squareup.haha.perflib.io.MemoryMappedFileBuffer;
-import com.squareup.haha.trove.THashMap;
-import com.squareup.haha.trove.TObjectProcedure;
+import gnu.trove.THashMap;
+import gnu.trove.TObjectProcedure;
 import java.io.File;
+import java.lang.reflect.Constructor;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
@@ -40,17 +43,31 @@
 import static com.squareup.leakcanary.AnalysisResult.failure;
 import static com.squareup.leakcanary.AnalysisResult.leakDetected;
 import static com.squareup.leakcanary.AnalysisResult.noLeak;
+import static com.squareup.leakcanary.AnalyzerProgressListener.Step.BUILDING_LEAK_TRACE;
+import static com.squareup.leakcanary.AnalyzerProgressListener.Step.COMPUTING_BITMAP_SIZE;
+import static com.squareup.leakcanary.AnalyzerProgressListener.Step.COMPUTING_DOMINATORS;
+import static com.squareup.leakcanary.AnalyzerProgressListener.Step.DEDUPLICATING_GC_ROOTS;
+import static com.squareup.leakcanary.AnalyzerProgressListener.Step.FINDING_LEAKING_REF;
+import static com.squareup.leakcanary.AnalyzerProgressListener.Step.FINDING_SHORTEST_PATH;
+import static com.squareup.leakcanary.AnalyzerProgressListener.Step.PARSING_HEAP_DUMP;
+import static com.squareup.leakcanary.AnalyzerProgressListener.Step.READING_HEAP_DUMP_FILE;
 import static com.squareup.leakcanary.HahaHelper.asString;
 import static com.squareup.leakcanary.HahaHelper.classInstanceValues;
 import static com.squareup.leakcanary.HahaHelper.extendsThread;
-import static com.squareup.leakcanary.HahaHelper.fieldToString;
 import static com.squareup.leakcanary.HahaHelper.fieldValue;
 import static com.squareup.leakcanary.HahaHelper.hasField;
 import static com.squareup.leakcanary.HahaHelper.threadName;
+import static com.squareup.leakcanary.HahaHelper.valueAsString;
 import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
 import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
 import static com.squareup.leakcanary.LeakTraceElement.Holder.OBJECT;
 import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
+import static com.squareup.leakcanary.LeakTraceElement.Type.ARRAY_ENTRY;
+import static com.squareup.leakcanary.LeakTraceElement.Type.INSTANCE_FIELD;
+import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
+import static com.squareup.leakcanary.Reachability.REACHABLE;
+import static com.squareup.leakcanary.Reachability.UNKNOWN;
+import static com.squareup.leakcanary.Reachability.UNREACHABLE;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
 /**
@@ -61,12 +78,38 @@
   private static final String ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$";
 
   private final ExcludedRefs excludedRefs;
+  private final AnalyzerProgressListener listener;
+  private final List<Reachability.Inspector> reachabilityInspectors;
 
-  public HeapAnalyzer(ExcludedRefs excludedRefs) {
+  /**
+   * @deprecated Use {@link #HeapAnalyzer(ExcludedRefs, AnalyzerProgressListener, List)}.
+   */
+  @Deprecated
+  public HeapAnalyzer(@NonNull ExcludedRefs excludedRefs) {
+    this(excludedRefs, AnalyzerProgressListener.NONE,
+        Collections.<Class<? extends Reachability.Inspector>>emptyList());
+  }
+
+  public HeapAnalyzer(@NonNull ExcludedRefs excludedRefs,
+      @NonNull AnalyzerProgressListener listener,
+      @NonNull List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses) {
     this.excludedRefs = excludedRefs;
+    this.listener = listener;
+
+    this.reachabilityInspectors = new ArrayList<>();
+    for (Class<? extends Reachability.Inspector> reachabilityInspectorClass
+        : reachabilityInspectorClasses) {
+      try {
+        Constructor<? extends Reachability.Inspector> defaultConstructor =
+            reachabilityInspectorClass.getDeclaredConstructor();
+        reachabilityInspectors.add(defaultConstructor.newInstance());
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }
   }
 
-  public List<TrackedReference> findTrackedReferences(File heapDumpFile) {
+  public @NonNull List<TrackedReference> findTrackedReferences(@NonNull File heapDumpFile) {
     if (!heapDumpFile.exists()) {
       throw new IllegalArgumentException("File does not exist: " + heapDumpFile);
     }
@@ -86,7 +129,7 @@ public HeapAnalyzer(ExcludedRefs excludedRefs) {
         Instance instance = fieldValue(values, "referent");
         if (instance != null) {
           String className = getClassName(instance);
-          List<String> fields = describeFields(instance);
+          List<LeakReference> fields = describeFields(instance);
           references.add(new TrackedReference(key, name, className, fields));
         }
       }
@@ -96,11 +139,24 @@ public HeapAnalyzer(ExcludedRefs excludedRefs) {
     }
   }
 
+  /**
+   * Calls {@link #checkForLeak(File, String, boolean)} with computeRetainedSize set to true.
+   *
+   * @deprecated Use {@link #checkForLeak(File, String, boolean)} instead.
+   */
+  @Deprecated
+  public @NonNull AnalysisResult checkForLeak(@NonNull File heapDumpFile,
+      @NonNull String referenceKey) {
+    return checkForLeak(heapDumpFile, referenceKey, true);
+  }
+
   /**
    * Searches the heap dump for a {@link KeyedWeakReference} instance with the corresponding key,
    * and then computes the shortest strong reference path from that instance to the GC roots.
    */
-  public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
+  public @NonNull AnalysisResult checkForLeak(@NonNull File heapDumpFile,
+      @NonNull String referenceKey,
+      boolean computeRetainedSize) {
     long analysisStartNanoTime = System.nanoTime();
 
     if (!heapDumpFile.exists()) {
@@ -109,19 +165,21 @@ public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
     }
 
     try {
+      listener.onProgressUpdate(READING_HEAP_DUMP_FILE);
       HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
       HprofParser parser = new HprofParser(buffer);
+      listener.onProgressUpdate(PARSING_HEAP_DUMP);
       Snapshot snapshot = parser.parse();
+      listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS);
       deduplicateGcRoots(snapshot);
-
+      listener.onProgressUpdate(FINDING_LEAKING_REF);
       Instance leakingRef = findLeakingReference(referenceKey, snapshot);
 
       // False alarm, weak reference was cleared in between key check and heap dump.
       if (leakingRef == null) {
         return noLeak(since(analysisStartNanoTime));
       }
-
-      return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);
+      return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, computeRetainedSize);
     } catch (Throwable e) {
       return failure(e, since(analysisStartNanoTime));
     }
@@ -157,10 +215,19 @@ private String generateRootKey(RootObj root) {
 
   private Instance findLeakingReference(String key, Snapshot snapshot) {
     ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());
+    if (refClass == null) {
+      throw new IllegalStateException(
+          "Could not find the " + KeyedWeakReference.class.getName() + " class in the heap dump.");
+    }
     List<String> keysFound = new ArrayList<>();
     for (Instance instance : refClass.getInstancesList()) {
       List<ClassInstance.FieldValue> values = classInstanceValues(instance);
-      String keyCandidate = asString(fieldValue(values, "key"));
+      Object keyFieldValue = fieldValue(values, "key");
+      if (keyFieldValue == null) {
+        keysFound.add(null);
+        continue;
+      }
+      String keyCandidate = asString(keyFieldValue);
       if (keyCandidate.equals(key)) {
         return fieldValue(values, "referent");
       }
@@ -171,8 +238,9 @@ private Instance findLeakingReference(String key, Snapshot snapshot) {
   }
 
   private AnalysisResult findLeakTrace(long analysisStartNanoTime, Snapshot snapshot,
-      Instance leakingRef) {
+      Instance leakingRef, boolean computeRetainedSize) {
 
+    listener.onProgressUpdate(FINDING_SHORTEST_PATH);
     ShortestPathFinder pathFinder = new ShortestPathFinder(excludedRefs);
     ShortestPathFinder.Result result = pathFinder.findPath(snapshot, leakingRef);
 
@@ -181,20 +249,29 @@ private AnalysisResult findLeakTrace(long analysisStartNanoTime, Snapshot snapsh
       return noLeak(since(analysisStartNanoTime));
     }
 
+    listener.onProgressUpdate(BUILDING_LEAK_TRACE);
     LeakTrace leakTrace = buildLeakTrace(result.leakingNode);
 
     String className = leakingRef.getClassObj().getClassName();
 
-    // Side effect: computes retained size.
-    snapshot.computeDominators();
+    long retainedSize;
+    if (computeRetainedSize) {
+
+      listener.onProgressUpdate(COMPUTING_DOMINATORS);
+      // Side effect: computes retained size.
+      snapshot.computeDominators();
 
-    Instance leakingInstance = result.leakingNode.instance;
+      Instance leakingInstance = result.leakingNode.instance;
 
-    long retainedSize = leakingInstance.getTotalRetainedSize();
+      retainedSize = leakingInstance.getTotalRetainedSize();
 
-    // TODO: check O sources and see what happened to android.graphics.Bitmap.mBuffer
-    if (SDK_INT <= N_MR1) {
-      retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance);
+      // TODO: check O sources and see what happened to android.graphics.Bitmap.mBuffer
+      if (SDK_INT <= N_MR1) {
+        listener.onProgressUpdate(COMPUTING_BITMAP_SIZE);
+        retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance);
+      }
+    } else {
+      retainedSize = AnalysisResult.RETAINED_HEAP_SKIPPED;
     }
 
     return leakDetected(result.excludingKnownLeaks, className, leakTrace, retainedSize,
@@ -258,7 +335,7 @@ private boolean isIgnoredDominator(Instance dominator, Instance instance) {
   private LeakTrace buildLeakTrace(LeakNode leakingNode) {
     List<LeakTraceElement> elements = new ArrayList<>();
     // We iterate from the leak to the GC root
-    LeakNode node = new LeakNode(null, null, leakingNode, null, null);
+    LeakNode node = new LeakNode(null, null, leakingNode, null);
     while (node != null) {
       LeakTraceElement element = buildLeakElement(node);
       if (element != null) {
@@ -266,7 +343,49 @@ private LeakTrace buildLeakTrace(LeakNode leakingNode) {
       }
       node = node.parent;
     }
-    return new LeakTrace(elements);
+
+    List<Reachability> expectedReachability =
+        computeExpectedReachability(elements);
+
+    return new LeakTrace(elements, expectedReachability);
+  }
+
+  private List<Reachability> computeExpectedReachability(
+      List<LeakTraceElement> elements) {
+    int lastReachableElement = 0;
+    int lastElementIndex = elements.size() - 1;
+    int firstUnreachableElement = lastElementIndex;
+    // No need to inspect the first and last element. We know the first should be reachable (gc
+    // root) and the last should be unreachable (watched instance).
+    elementLoop:
+    for (int i = 1; i < lastElementIndex; i++) {
+      LeakTraceElement element = elements.get(i);
+
+      for (Reachability.Inspector reachabilityInspector : reachabilityInspectors) {
+        Reachability reachability = reachabilityInspector.expectedReachability(element);
+        if (reachability == REACHABLE) {
+          lastReachableElement = i;
+          break;
+        } else if (reachability == UNREACHABLE) {
+          firstUnreachableElement = i;
+          break elementLoop;
+        }
+      }
+    }
+
+    List<Reachability> expectedReachability = new ArrayList<>();
+    for (int i = 0; i < elements.size(); i++) {
+      Reachability status;
+      if (i <= lastReachableElement) {
+        status = REACHABLE;
+      } else if (i >= firstUnreachableElement) {
+        status = UNREACHABLE;
+      } else {
+        status = UNKNOWN;
+      }
+      expectedReachability.add(status);
+    }
+    return expectedReachability;
   }
 
   private LeakTraceElement buildLeakElement(LeakNode node) {
@@ -279,16 +398,23 @@ private LeakTraceElement buildLeakElement(LeakNode node) {
     if (holder instanceof RootObj) {
       return null;
     }
-    LeakTraceElement.Type type = node.referenceType;
-    String referenceName = node.referenceName;
-
     LeakTraceElement.Holder holderType;
     String className;
     String extra = null;
-    List<String> fields = describeFields(holder);
+    List<LeakReference> leakReferences = describeFields(holder);
 
     className = getClassName(holder);
 
+    List<String> classHierarchy = new ArrayList<>();
+    classHierarchy.add(className);
+    String rootClassName = Object.class.getName();
+    if (holder instanceof ClassInstance) {
+      ClassObj classObj = holder.getClassObj();
+      while (!(classObj = classObj.getSuperClassObj()).getClassName().equals(rootClassName)) {
+        classHierarchy.add(classObj.getClassName());
+      }
+    }
+
     if (holder instanceof ClassObj) {
       holderType = CLASS;
     } else if (holder instanceof ArrayInstance) {
@@ -301,7 +427,7 @@ private LeakTraceElement buildLeakElement(LeakNode node) {
         extra = "(named '" + threadName + "')";
       } else if (className.matches(ANONYMOUS_CLASS_NAME_PATTERN)) {
         String parentClassName = classObj.getSuperClassObj().getClassName();
-        if (Object.class.getName().equals(parentClassName)) {
+        if (rootClassName.equals(parentClassName)) {
           holderType = OBJECT;
           try {
             // This is an anonymous class implementing an interface. The API does not give access
@@ -326,39 +452,44 @@ private LeakTraceElement buildLeakElement(LeakNode node) {
         holderType = OBJECT;
       }
     }
-    return new LeakTraceElement(referenceName, type, holderType, className, extra, node.exclusion,
-        fields);
+    return new LeakTraceElement(node.leakReference, holderType, classHierarchy, extra,
+        node.exclusion, leakReferences);
   }
 
-  private List<String> describeFields(Instance instance) {
-    List<String> fields = new ArrayList<>();
-
+  private List<LeakReference> describeFields(Instance instance) {
+    List<LeakReference> leakReferences = new ArrayList<>();
     if (instance instanceof ClassObj) {
       ClassObj classObj = (ClassObj) instance;
       for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-        Field field = entry.getKey();
-        Object value = entry.getValue();
-        fields.add("static " + field.getName() + " = " + value);
+        String name = entry.getKey().getName();
+        String stringValue = valueAsString(entry.getValue());
+        leakReferences.add(new LeakReference(STATIC_FIELD, name, stringValue));
       }
     } else if (instance instanceof ArrayInstance) {
       ArrayInstance arrayInstance = (ArrayInstance) instance;
       if (arrayInstance.getArrayType() == Type.OBJECT) {
         Object[] values = arrayInstance.getValues();
         for (int i = 0; i < values.length; i++) {
-          fields.add("[" + i + "] = " + values[i]);
+          String name = Integer.toString(i);
+          String stringValue = valueAsString(values[i]);
+          leakReferences.add(new LeakReference(ARRAY_ENTRY, name, stringValue));
         }
       }
     } else {
       ClassObj classObj = instance.getClassObj();
       for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-        fields.add("static " + fieldToString(entry));
+        String name = entry.getKey().getName();
+        String stringValue = valueAsString(entry.getValue());
+        leakReferences.add(new LeakReference(STATIC_FIELD, name, stringValue));
       }
       ClassInstance classInstance = (ClassInstance) instance;
       for (ClassInstance.FieldValue field : classInstance.getValues()) {
-        fields.add(fieldToString(field));
+        String name = field.getField().getName();
+        String stringValue = valueAsString(field.getValue());
+        leakReferences.add(new LeakReference(INSTANCE_FIELD, name, stringValue));
       }
     }
-    return fields;
+    return leakReferences;
   }
 
   private String getClassName(Instance instance) {
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
index b30df278..94a77252 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
@@ -22,15 +22,12 @@
   final Exclusion exclusion;
   final Instance instance;
   final LeakNode parent;
-  final String referenceName;
-  final LeakTraceElement.Type referenceType;
+  final LeakReference leakReference;
 
-  LeakNode(Exclusion exclusion, Instance instance, LeakNode parent,
-      String referenceName, LeakTraceElement.Type referenceType) {
+  LeakNode(Exclusion exclusion, Instance instance, LeakNode parent, LeakReference leakReference) {
     this.exclusion = exclusion;
     this.instance = instance;
     this.parent = parent;
-    this.referenceName = referenceName;
-    this.referenceType = referenceType;
+    this.leakReference = leakReference;
   }
 }
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
index 607db22c..1a93d6bc 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
@@ -15,22 +15,22 @@
  */
 package com.squareup.leakcanary;
 
+import android.support.annotation.NonNull;
 import java.io.Serializable;
-import java.util.ArrayList;
 import java.util.List;
 
-import static java.util.Collections.unmodifiableList;
-
 /**
  * A chain of references that constitute the shortest strong reference path from a leaking instance
  * to the GC roots. Fixing the leak usually means breaking one of the references in that chain.
  */
 public final class LeakTrace implements Serializable {
 
-  public final List<LeakTraceElement> elements;
+  @NonNull public final List<LeakTraceElement> elements;
+  @NonNull public final List<Reachability> expectedReachability;
 
-  LeakTrace(List<LeakTraceElement> elements) {
-    this.elements = unmodifiableList(new ArrayList<>(elements));
+  LeakTrace(List<LeakTraceElement> elements, List<Reachability> expectedReachability) {
+    this.elements = elements;
+    this.expectedReachability = expectedReachability;
   }
 
   @Override public String toString() {
@@ -38,19 +38,29 @@
     for (int i = 0; i < elements.size(); i++) {
       LeakTraceElement element = elements.get(i);
       sb.append("* ");
-      if (i == 0) {
-        sb.append("GC ROOT ");
-      } else if (i == elements.size() - 1) {
-        sb.append("leaks ");
-      } else {
-        sb.append("references ");
+      if (i != 0) {
+        sb.append("↳ ");
+      }
+      boolean maybeLeakCause = false;
+      Reachability currentReachability = expectedReachability.get(i);
+      if (currentReachability == Reachability.UNKNOWN) {
+        maybeLeakCause = true;
+      } else if (currentReachability == Reachability.REACHABLE) {
+        if (i < elements.size() - 1) {
+          Reachability nextReachability = expectedReachability.get(i + 1);
+          if (nextReachability != Reachability.REACHABLE) {
+            maybeLeakCause = true;
+          }
+        } else {
+          maybeLeakCause = true;
+        }
       }
-      sb.append(element).append("\n");
+      sb.append(element.toString(maybeLeakCause)).append("\n");
     }
     return sb.toString();
   }
 
-  public String toDetailedString() {
+  public @NonNull String toDetailedString() {
     String string = "";
     for (LeakTraceElement element : elements) {
       string += element.toDetailedString();
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
deleted file mode 100644
index 89ef31e3..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.List;
-
-import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-import static java.util.Collections.unmodifiableList;
-import static java.util.Locale.US;
-
-/** Represents one reference in the chain of references that holds a leaking object in memory. */
-public final class LeakTraceElement implements Serializable {
-
-  public enum Type {
-    INSTANCE_FIELD, STATIC_FIELD, LOCAL, ARRAY_ENTRY
-  }
-
-  public enum Holder {
-    OBJECT, CLASS, THREAD, ARRAY
-  }
-
-  /** Null if this is the last element in the leak trace, ie the leaking object. */
-  public final String referenceName;
-
-  /** Null if this is the last element in the leak trace, ie the leaking object. */
-  public final Type type;
-  public final Holder holder;
-  public final String className;
-
-  /** Additional information, may be null. */
-  public final String extra;
-
-  /** If not null, there was no path that could exclude this element. */
-  public final Exclusion exclusion;
-
-  /** List of all fields (member and static) for that object. */
-  public final List<String> fields;
-
-  LeakTraceElement(String referenceName, Type type, Holder holder, String className, String extra,
-      Exclusion exclusion, List<String> fields) {
-    this.referenceName = referenceName;
-    this.type = type;
-    this.holder = holder;
-    this.className = className;
-    this.extra = extra;
-    this.exclusion = exclusion;
-    this.fields = unmodifiableList(new ArrayList<>(fields));
-  }
-
-  @Override public String toString() {
-    String string = "";
-
-    if (type == STATIC_FIELD) {
-      string += "static ";
-    }
-
-    if (holder == ARRAY || holder == THREAD) {
-      string += holder.name().toLowerCase(US) + " ";
-    }
-
-    string += className;
-
-    if (referenceName != null) {
-      string += "." + referenceName;
-    } else {
-      string += " instance";
-    }
-
-    if (extra != null) {
-      string += " " + extra;
-    }
-
-    if (exclusion != null) {
-      string += " , matching exclusion " + exclusion.matching;
-    }
-
-    return string;
-  }
-
-  public String toDetailedString() {
-    String string = "* ";
-    if (holder == ARRAY) {
-      string += "Array of";
-    } else if (holder == CLASS) {
-      string += "Class";
-    } else {
-      string += "Instance of";
-    }
-    string += " " + className + "\n";
-    for (String field : fields) {
-      string += "|   " + field + "\n";
-    }
-    return string;
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
index d88875f6..1c58dd3a 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
@@ -136,7 +136,7 @@ private void enqueueGcRoots(Snapshot snapshot) {
           String threadName = threadName(thread);
           Exclusion params = excludedRefs.threadNames.get(threadName);
           if (params == null || !params.alwaysExclude) {
-            enqueue(params, null, rootObj, null, null);
+            enqueue(params, null, rootObj, null);
           }
           break;
         case INTERNED_STRING:
@@ -163,7 +163,7 @@ private void enqueueGcRoots(Snapshot snapshot) {
           // Input or output parameters in native code.
         case NATIVE_STACK:
         case JAVA_STATIC:
-          enqueue(null, null, rootObj, null, null);
+          enqueue(null, null, rootObj, null);
           break;
         default:
           throw new UnsupportedOperationException("Unknown root type:" + rootObj.getRootType());
@@ -187,10 +187,10 @@ private void visitRootObj(LeakNode node) {
       if (node.exclusion != null) {
         exclusion = node.exclusion;
       }
-      LeakNode parent = new LeakNode(null, holder, null, null, null);
-      enqueue(exclusion, parent, child, "<Java Local>", LOCAL);
+      LeakNode parent = new LeakNode(null, holder, null, null);
+      enqueue(exclusion, parent, child, new LeakReference(LOCAL, null, null));
     } else {
-      enqueue(null, node, child, null, null);
+      enqueue(null, node, child, null);
     }
   }
 
@@ -209,17 +209,19 @@ private void visitClassObj(LeakNode node) {
       }
       Instance child = (Instance) entry.getValue();
       boolean visit = true;
+      String fieldValue = entry.getValue() == null ? "null" : entry.getValue().toString();
+      LeakReference leakReference = new LeakReference(STATIC_FIELD, fieldName, fieldValue);
       if (ignoredStaticFields != null) {
         Exclusion params = ignoredStaticFields.get(fieldName);
         if (params != null) {
           visit = false;
           if (!params.alwaysExclude) {
-            enqueue(params, node, child, fieldName, STATIC_FIELD);
+            enqueue(params, node, child, leakReference);
           }
         }
       }
       if (visit) {
-        enqueue(null, node, child, fieldName, STATIC_FIELD);
+        enqueue(null, node, child, leakReference);
       }
     }
   }
@@ -263,7 +265,8 @@ private void visitClassInstance(LeakNode node) {
           && !fieldExclusion.alwaysExclude))) {
         fieldExclusion = params;
       }
-      enqueue(fieldExclusion, node, child, fieldName, INSTANCE_FIELD);
+      String value = fieldValue.getValue() == null ? "null" : fieldValue.getValue().toString();
+      enqueue(fieldExclusion, node, child, new LeakReference(INSTANCE_FIELD, fieldName, value));
     }
   }
 
@@ -274,13 +277,15 @@ private void visitArrayInstance(LeakNode node) {
       Object[] values = arrayInstance.getValues();
       for (int i = 0; i < values.length; i++) {
         Instance child = (Instance) values[i];
-        enqueue(null, node, child, "[" + i + "]", ARRAY_ENTRY);
+        String name = Integer.toString(i);
+        String value = child == null ? "null" : child.toString();
+        enqueue(null, node, child, new LeakReference(ARRAY_ENTRY, name, value));
       }
     }
   }
 
-  private void enqueue(Exclusion exclusion, LeakNode parent, Instance child, String referenceName,
-      LeakTraceElement.Type referenceType) {
+  private void enqueue(Exclusion exclusion, LeakNode parent, Instance child,
+      LeakReference leakReference) {
     if (child == null) {
       return;
     }
@@ -301,7 +306,7 @@ private void enqueue(Exclusion exclusion, LeakNode parent, Instance child, Strin
     if (visitedSet.contains(child)) {
       return;
     }
-    LeakNode childNode = new LeakNode(exclusion, child, parent, referenceName, referenceType);
+    LeakNode childNode = new LeakNode(exclusion, child, parent, leakReference);
     if (visitNow) {
       toVisitSet.add(child);
       toVisitQueue.add(childNode);
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/TrackedReference.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/TrackedReference.java
index 61990d16..1460808c 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/TrackedReference.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/TrackedReference.java
@@ -1,5 +1,6 @@
 package com.squareup.leakcanary;
 
+import android.support.annotation.NonNull;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -11,18 +12,19 @@
 public class TrackedReference {
 
   /** Corresponds to {@link KeyedWeakReference#key}. */
-  public final String key;
+  @NonNull public final String key;
 
   /** Corresponds to {@link KeyedWeakReference#name}. */
-  public final String name;
+  @NonNull public final String name;
 
   /** Class of the tracked instance. */
-  public final String className;
+  @NonNull public final String className;
 
   /** List of all fields (member and static) for that instance. */
-  public final List<String> fields;
+  @NonNull public final List<LeakReference> fields;
 
-  public TrackedReference(String key, String name, String className, List<String> fields) {
+  public TrackedReference(@NonNull String key, @NonNull String name, @NonNull String className,
+      @NonNull List<LeakReference> fields) {
     this.key = key;
     this.name = name;
     this.className = className;
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
index 0e6937d5..319ee285 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
@@ -32,7 +32,8 @@
 
   @Before
   public void setUp() {
-    heapAnalyzer = new HeapAnalyzer(NO_EXCLUDED_REFS);
+    heapAnalyzer = new HeapAnalyzer(NO_EXCLUDED_REFS, AnalyzerProgressListener.NONE,
+        Collections.<Class<? extends Reachability.Inspector>>emptyList());
   }
 
   @Test
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
index 8c8523c4..40c8470e 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
@@ -17,6 +17,7 @@
 
 import java.io.File;
 import java.net.URL;
+import java.util.Collections;
 import java.util.List;
 
 final class TestUtil {
@@ -46,15 +47,20 @@ static File fileFromName(String filename) {
 
   static List<TrackedReference> findTrackedReferences(HeapDumpFile heapDumpFile) {
     File file = fileFromName(heapDumpFile.filename);
-    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(NO_EXCLUDED_REFS);
+    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(NO_EXCLUDED_REFS, AnalyzerProgressListener.NONE,
+        Collections.<Class<? extends Reachability.Inspector>>emptyList());
     return heapAnalyzer.findTrackedReferences(file);
   }
 
-  static AnalysisResult analyze(HeapDumpFile heapDumpFile, ExcludedRefs.BuilderWithParams excludedRefs) {
+  static AnalysisResult analyze(HeapDumpFile heapDumpFile,
+      ExcludedRefs.BuilderWithParams excludedRefs) {
     File file = fileFromName(heapDumpFile.filename);
     String referenceKey = heapDumpFile.referenceKey;
-    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(excludedRefs.build());
-    AnalysisResult result = heapAnalyzer.checkForLeak(file, referenceKey);
+    HeapAnalyzer heapAnalyzer =
+        new HeapAnalyzer(excludedRefs.build(), AnalyzerProgressListener.NONE,
+            Collections.<Class<? extends Reachability.Inspector>>emptyList());
+    AnalysisResult result =
+        heapAnalyzer.checkForLeak(file, referenceKey, true);
     if (result.failure != null) {
       result.failure.printStackTrace();
     }
diff --git a/leakcanary-android-instrumentation/build.gradle b/leakcanary-android-instrumentation/build.gradle
new file mode 100644
index 00000000..087bc5d4
--- /dev/null
+++ b/leakcanary-android-instrumentation/build.gradle
@@ -0,0 +1,23 @@
+apply plugin: 'com.android.library'
+
+dependencies {
+  api project(':leakcanary-android')
+  implementation 'com.android.support.test:runner:1.0.2'
+}
+
+android {
+  compileSdkVersion versions.compileSdk
+  defaultConfig {
+    minSdkVersion versions.minSdk
+    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+  }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    // junit references java.lang.management
+    ignore 'InvalidPackage'
+    check 'Interoperability'
+  }
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android-instrumentation/gradle.properties b/leakcanary-android-instrumentation/gradle.properties
new file mode 100644
index 00000000..ab8ed750
--- /dev/null
+++ b/leakcanary-android-instrumentation/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-android-instrumentation
+POM_NAME=LeakCanary extension for Android instrumentation tests.
+POM_PACKAGING=aar
\ No newline at end of file
diff --git a/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
new file mode 100644
index 00000000..dc076259
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.leakcanary.instrumentation.test">
+  <application android:name="com.squareup.leakcanary.InstrumentationTestApplication">
+  </application>
+</manifest>
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/InstrumentationLeakDetectorTest.java b/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/InstrumentationLeakDetectorTest.java
new file mode 100644
index 00000000..fc757727
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/InstrumentationLeakDetectorTest.java
@@ -0,0 +1,44 @@
+package com.squareup.leakcanary;
+
+import java.util.Date;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * Tests that the {@link InstrumentationLeakDetector} can detect leaks
+ * in instrumentation tests
+ */
+public class InstrumentationLeakDetectorTest {
+
+  private static Object leaking;
+
+  @Before public void setUp() {
+    LeakCanary.installedRefWatcher().clearWatchedReferences();
+  }
+
+  @After public void tearDown() {
+    LeakCanary.installedRefWatcher().clearWatchedReferences();
+  }
+
+  @Test public void detectsLeak() {
+    leaking = new Date();
+    RefWatcher refWatcher = LeakCanary.installedRefWatcher();
+    refWatcher.watch(leaking);
+
+    InstrumentationLeakDetector leakDetector = new InstrumentationLeakDetector();
+    InstrumentationLeakResults results = leakDetector.detectLeaks();
+
+    if (results.detectedLeaks.size() != 1) {
+      throw new AssertionError("Expected exactly one leak, not " + results.detectedLeaks.size());
+    }
+
+    InstrumentationLeakResults.Result firstResult = results.detectedLeaks.get(0);
+
+    String leakingClassName = firstResult.analysisResult.className;
+
+    if (!leakingClassName.equals(Date.class.getName())) {
+      throw new AssertionError("Expected a leak of Date, not " + leakingClassName);
+    }
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/InstrumentationTestApplication.java b/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/InstrumentationTestApplication.java
new file mode 100644
index 00000000..c534699b
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/InstrumentationTestApplication.java
@@ -0,0 +1,11 @@
+package com.squareup.leakcanary;
+
+import android.app.Application;
+
+public class InstrumentationTestApplication extends Application {
+  @Override public void onCreate() {
+    super.onCreate();
+    InstrumentationLeakDetector.instrumentationRefWatcher(this)
+        .buildAndInstall();
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/main/AndroidManifest.xml b/leakcanary-android-instrumentation/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..c500f057
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/AndroidManifest.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest package="com.squareup.leakcanary.instrumentation">
+
+  <application>
+  </application>
+</manifest>
diff --git a/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/FailTestOnLeakRunListener.java b/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/FailTestOnLeakRunListener.java
new file mode 100644
index 00000000..6bacb90d
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/FailTestOnLeakRunListener.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import android.app.Instrumentation;
+import android.content.Context;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.test.internal.runner.listener.InstrumentationResultPrinter;
+import java.util.List;
+import org.junit.runner.Description;
+import org.junit.runner.Result;
+import org.junit.runner.notification.Failure;
+import org.junit.runner.notification.RunListener;
+
+import static android.support.test.InstrumentationRegistry.getInstrumentation;
+import static android.support.test.internal.runner.listener.InstrumentationResultPrinter.REPORT_VALUE_RESULT_FAILURE;
+import static com.squareup.leakcanary.Preconditions.checkNotNull;
+
+/**
+ * <p>A JUnit {@link RunListener} for detecting memory leaks in Android instrumentation tests. It
+ * waits for the end of a test, and if the test succeeds then it will look for leaking
+ * references, trigger a heap dump if needed and perform an analysis.
+ * <p> {@link FailTestOnLeakRunListener} can be subclassed to override
+ * {@link #skipLeakDetectionReason(Description)}, {@link #reportLeaks(InstrumentationLeakResults)}
+ * or {@link #buildLeakDetectedMessage(List)}
+ *
+ * @see InstrumentationLeakDetector
+ */
+public class FailTestOnLeakRunListener extends RunListener {
+
+  private static final String SEPARATOR = "######################################\n";
+  private Bundle bundle;
+
+  private String skipLeakDetectionReason;
+
+  @Override public final void testStarted(Description description) {
+    skipLeakDetectionReason = skipLeakDetectionReason(description);
+    if (skipLeakDetectionReason != null) {
+      return;
+    }
+    String testClass = description.getClassName();
+    String testName = description.getMethodName();
+
+    bundle = new Bundle();
+    bundle.putString(Instrumentation.REPORT_KEY_IDENTIFIER,
+        FailTestOnLeakRunListener.class.getName());
+    bundle.putString(InstrumentationResultPrinter.REPORT_KEY_NAME_CLASS, testClass);
+    bundle.putString(InstrumentationResultPrinter.REPORT_KEY_NAME_TEST, testName);
+  }
+
+  /**
+   * Can be overridden to skip leak detection based on the description provided when a test
+   * is started. Returns null to continue leak detection, or a string describing the reason for
+   * skipping otherwise.
+   */
+  protected @Nullable String skipLeakDetectionReason(@NonNull Description description) {
+    return null;
+  }
+
+  @Override public final void testFailure(Failure failure) {
+    skipLeakDetectionReason = "failed";
+  }
+
+  @Override public final void testIgnored(Description description) {
+    skipLeakDetectionReason = "was ignored";
+  }
+
+  @Override public final void testAssumptionFailure(Failure failure) {
+    skipLeakDetectionReason = "had an assumption failure";
+  }
+
+  @Override public final void testFinished(Description description) {
+    detectLeaks();
+    LeakCanary.installedRefWatcher().clearWatchedReferences();
+  }
+
+  @Override public final void testRunStarted(Description description) {
+  }
+
+  @Override public final void testRunFinished(Result result) {
+  }
+
+  private void detectLeaks() {
+    if (skipLeakDetectionReason != null) {
+      CanaryLog.d("Skipping leak detection because the test %s", skipLeakDetectionReason);
+      skipLeakDetectionReason = null;
+      return;
+    }
+
+    InstrumentationLeakDetector leakDetector = new InstrumentationLeakDetector();
+    InstrumentationLeakResults results = leakDetector.detectLeaks();
+
+    reportLeaks(results);
+  }
+
+  /** Can be overridden to report leaks in a different way or do additional reporting. */
+  protected void reportLeaks(@NonNull InstrumentationLeakResults results) {
+    if (!results.detectedLeaks.isEmpty()) {
+      String message =
+          checkNotNull(buildLeakDetectedMessage(results.detectedLeaks), "buildLeakDetectedMessage");
+
+      bundle.putString(InstrumentationResultPrinter.REPORT_KEY_STACK, message);
+      getInstrumentation().sendStatus(REPORT_VALUE_RESULT_FAILURE, bundle);
+    }
+  }
+
+  /** Can be overridden to customize the failure string message. */
+  protected @NonNull String buildLeakDetectedMessage(
+      @NonNull List<InstrumentationLeakResults.Result> detectedLeaks) {
+    StringBuilder failureMessage = new StringBuilder();
+    failureMessage.append(
+        "Test failed because memory leaks were detected, see leak traces below.\n");
+    failureMessage.append(SEPARATOR);
+
+    Context context = getInstrumentation().getContext();
+    for (InstrumentationLeakResults.Result detectedLeak : detectedLeaks) {
+      failureMessage.append(
+          LeakCanary.leakInfo(context, detectedLeak.heapDump, detectedLeak.analysisResult, true));
+      failureMessage.append(SEPARATOR);
+    }
+
+    return failureMessage.toString();
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/InstrumentationLeakDetector.java b/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/InstrumentationLeakDetector.java
new file mode 100644
index 00000000..f8e53dbc
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/InstrumentationLeakDetector.java
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import android.app.Application;
+import android.app.Instrumentation;
+import android.content.Context;
+import android.os.Debug;
+import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArrayList;
+import org.junit.runner.notification.RunListener;
+
+import static android.support.test.InstrumentationRegistry.getInstrumentation;
+
+/**
+ * <p>{@link InstrumentationLeakDetector} can be used to detect memory leaks in instrumentation
+ * tests.
+ *
+ * <p>To use it, you need to:
+ * <ul>
+ * <li>Install a custom RefWatcher that will not trigger heapdumps while the tests run.</li>
+ * <li>Add an instrumentation test listener (a {@link RunListener}) that will invoke
+ * {@link #detectLeaks()}</li>
+ * </ul>
+ *
+ * <h3>Installing the instrumentation RefWatcher</h3>
+ *
+ * <p>For {@link #detectLeaks()} to work correctly, the {@link RefWatcher} must keep track of
+ * references but not trigger any heap dump until this {@link #detectLeaks()} runs, otherwise an
+ * analysis in progress might prevent this listener from performing its own analysis.
+ *
+ * <p>Create and install the {@link RefWatcher} instance using
+ * {@link #instrumentationRefWatcher(Application)} instead of
+ * {@link LeakCanary#install(Application)} or {@link LeakCanary#refWatcher(Context)}.
+ * <pre><code>
+ * public class InstrumentationExampleApplication extends ExampleApplication {
+ *   {@literal @}Override protected void setupLeakCanary() {
+ *     InstrumentationLeakDetector.instrumentationRefWatcher(this)
+ *         .buildAndInstall();
+ *   }
+ * }
+ * </code></pre>
+ *
+ * <h3>Add an intrumentation test listener</h3>
+ *
+ * <p>LeakCanary provides {@link FailTestOnLeakRunListener}, but you should feel free to implement
+ * your own {@link RunListener} and call {@link #detectLeaks()} directly if you need a more custom
+ * behavior (for instance running it only once per test suite, or reporting to a backend).</p>
+ *
+ * <p>All you need to do is add the following to the defaultConfig of your build.gradle:
+ *
+ * <pre><code>testInstrumentationRunnerArgument "listener", "com.squareup.leakcanary.FailTestOnLeakRunListener"</code></pre>
+ *
+ * <p>Then you can run your instrumentation tests via Gradle as usually, and they will fail when
+ * a memory leak is detected:
+ *
+ * <pre><code>./gradlew leakcanary-sample:connectedCheck</code></pre>
+ *
+ * <p>If instead you want to run UI tests via adb, add a <em>listener</em> execution argument to
+ * your command line for running the UI tests:
+ * <code>-e listener com.squareup.leakcanary.FailTestOnLeakRunListener</code>. The full command line
+ * should look something like this:
+ * <pre><code>adb shell am instrument \\
+ * -w com.android.foo/android.support.test.runner.AndroidJUnitRunner \\
+ * -e listener com.squareup.leakcanary.FailTestOnLeakRunListener
+ * </code></pre>
+ *
+ * <h3>Rationale</h3>
+ * Instead of using the {@link FailTestOnLeakRunListener}, one could simply enable LeakCanary in
+ * instrumentation tests.
+ *
+ * <p>This approach would have two disadvantages:
+ * <ul>
+ * <li>Heap dumps freeze the VM, and the leak analysis is IO and CPU heavy. This can slow down
+ * the test and introduce flakiness</li>
+ * <li>The leak analysis is asynchronous by default, and happens in a separate process. This means
+ * the tests could finish and the process die before the analysis is finished.</li>
+ * </ul>
+ *
+ * <p>The approach taken here is to collect all references to watch as you run the test, but not
+ * do any heap dump during the test. Then, at the end, if any of the watched objects is still in
+ * memory we dump the heap and perform a blocking analysis. There is only one heap dump performed,
+ * no matter the number of objects leaking, and then we iterate on the leaking references in the
+ * heap dump and provide all result in a {@link InstrumentationLeakResults}.
+ */
+public final class InstrumentationLeakDetector {
+
+  /**
+   * Returns a new {@link} AndroidRefWatcherBuilder that will create a {@link RefWatcher} suitable
+   * for instrumentation tests. This {@link RefWatcher} will never trigger a heap dump. This should
+   * be installed from the test application class, and should be used in combination with a
+   * {@link RunListener} that calls {@link #detectLeaks()}, for instance
+   * {@link FailTestOnLeakRunListener}.
+   */
+  public static @NonNull AndroidRefWatcherBuilder instrumentationRefWatcher(
+      @NonNull Application application) {
+    return LeakCanary.refWatcher(application)
+        .watchExecutor(new WatchExecutor() {
+          // Storing weak refs to ensure they make it to the queue.
+          final List<Retryable> trackedReferences = new CopyOnWriteArrayList<>();
+
+          @Override public void execute(Retryable retryable) {
+            trackedReferences.add(retryable);
+          }
+        });
+  }
+
+  public @NonNull InstrumentationLeakResults detectLeaks() {
+    Instrumentation instrumentation = getInstrumentation();
+    Context context = instrumentation.getTargetContext();
+    RefWatcher refWatcher = LeakCanary.installedRefWatcher();
+    Set<String> retainedKeys = refWatcher.getRetainedKeys();
+
+    if (refWatcher.isEmpty()) {
+      return InstrumentationLeakResults.NONE;
+    }
+
+    instrumentation.waitForIdleSync();
+    if (refWatcher.isEmpty()) {
+      return InstrumentationLeakResults.NONE;
+    }
+
+    GcTrigger.DEFAULT.runGc();
+    if (refWatcher.isEmpty()) {
+      return InstrumentationLeakResults.NONE;
+    }
+
+    // Waiting for any delayed UI post (e.g. scroll) to clear. This shouldn't be needed, but
+    // Android simply has way too many delayed posts that aren't canceled when views are detached.
+    SystemClock.sleep(2000);
+
+    if (refWatcher.isEmpty()) {
+      return InstrumentationLeakResults.NONE;
+    }
+
+    // Aaand we wait some more.
+    // 4 seconds (2+2) is greater than the 3 seconds delay for
+    // FINISH_TOKEN in android.widget.Filter
+    SystemClock.sleep(2000);
+    GcTrigger.DEFAULT.runGc();
+
+    if (refWatcher.isEmpty()) {
+      return InstrumentationLeakResults.NONE;
+    }
+
+    // We're always reusing the same file since we only execute this once at a time.
+    File heapDumpFile = new File(context.getFilesDir(), "instrumentation_tests_heapdump.hprof");
+    try {
+      Debug.dumpHprofData(heapDumpFile.getAbsolutePath());
+    } catch (Exception e) {
+      CanaryLog.d(e, "Could not dump heap");
+      return InstrumentationLeakResults.NONE;
+    }
+
+    HeapDump.Builder heapDumpBuilder = refWatcher.getHeapDumpBuilder();
+    HeapAnalyzer heapAnalyzer =
+        new HeapAnalyzer(heapDumpBuilder.excludedRefs, AnalyzerProgressListener.NONE,
+            heapDumpBuilder.reachabilityInspectorClasses);
+
+    List<TrackedReference> trackedReferences = heapAnalyzer.findTrackedReferences(heapDumpFile);
+
+    List<InstrumentationLeakResults.Result> detectedLeaks = new ArrayList<>();
+    List<InstrumentationLeakResults.Result> excludedLeaks = new ArrayList<>();
+    List<InstrumentationLeakResults.Result> failures = new ArrayList<>();
+
+    for (TrackedReference trackedReference : trackedReferences) {
+      // Ignore any Weak Reference that this test does not care about.
+      if (!retainedKeys.contains(trackedReference.key)) {
+        continue;
+      }
+
+      HeapDump heapDump = HeapDump.builder()
+          .heapDumpFile(heapDumpFile)
+          .referenceKey(trackedReference.key)
+          .referenceName(trackedReference.name)
+          .excludedRefs(heapDumpBuilder.excludedRefs)
+          .reachabilityInspectorClasses(heapDumpBuilder.reachabilityInspectorClasses)
+          .build();
+
+      AnalysisResult analysisResult =
+          heapAnalyzer.checkForLeak(heapDumpFile, trackedReference.key, false);
+
+      InstrumentationLeakResults.Result leakResult =
+          new InstrumentationLeakResults.Result(heapDump, analysisResult);
+
+      if (analysisResult.leakFound) {
+        if (!analysisResult.excludedLeak) {
+          detectedLeaks.add(leakResult);
+        } else {
+          excludedLeaks.add(leakResult);
+        }
+      } else if (analysisResult.failure != null) {
+        failures.add(leakResult);
+      }
+    }
+
+    CanaryLog.d("Found %d proper leaks, %d excluded leaks and %d leak analysis failures",
+        detectedLeaks.size(),
+        excludedLeaks.size(),
+        failures.size());
+
+    return new InstrumentationLeakResults(detectedLeaks, excludedLeaks, failures);
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/InstrumentationLeakResults.java b/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/InstrumentationLeakResults.java
new file mode 100644
index 00000000..c41e66e5
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/InstrumentationLeakResults.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import android.support.annotation.NonNull;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static java.util.Collections.unmodifiableList;
+
+public final class InstrumentationLeakResults {
+
+  @NonNull public static final InstrumentationLeakResults NONE =
+      new InstrumentationLeakResults(Collections.<Result>emptyList(),
+          Collections.<Result>emptyList(), Collections.<Result>emptyList());
+
+  /** Proper leaks found during instrumentation tests. */
+  @NonNull public final List<Result> detectedLeaks;
+
+  /**
+   * Excluded leaks found during instrumentation tests, based on {@link
+   * RefWatcherBuilder#excludedRefs}
+   */
+  @NonNull public final List<Result> excludedLeaks;
+
+  /**
+   * Leak analysis failures that happened when we tried to detect leaks.
+   */
+  @NonNull public final List<Result> failures;
+
+  public InstrumentationLeakResults(@NonNull List<Result> detectedLeaks,
+      @NonNull List<Result> excludedLeaks, @NonNull List<Result> failures) {
+    this.detectedLeaks = unmodifiableList(new ArrayList<>(detectedLeaks));
+    this.excludedLeaks = unmodifiableList(new ArrayList<>(excludedLeaks));
+    this.failures = unmodifiableList(new ArrayList<>(failures));
+  }
+
+  public static final class Result {
+    @NonNull public final HeapDump heapDump;
+    @NonNull public final AnalysisResult analysisResult;
+
+    public Result(@NonNull HeapDump heapDump, @NonNull AnalysisResult analysisResult) {
+      this.heapDump = heapDump;
+      this.analysisResult = analysisResult;
+    }
+  }
+}
diff --git a/leakcanary-android-no-op/build.gradle b/leakcanary-android-no-op/build.gradle
index a1544aea..0cf39330 100644
--- a/leakcanary-android-no-op/build.gradle
+++ b/leakcanary-android-no-op/build.gradle
@@ -2,9 +2,22 @@ apply plugin: 'com.android.library'
 
 android {
   compileSdkVersion versions.compileSdk
+
   defaultConfig {
     minSdkVersion versions.minSdk
   }
+
+  // TODO replace with https://issuetracker.google.com/issues/72050365 once released.
+  libraryVariants.all {
+    it.generateBuildConfig.enabled = false
+  }
+  lintOptions {
+    check 'Interoperability'
+  }
+}
+
+dependencies {
+  implementation 'com.android.support:support-annotations:26.0.0'
 }
 
 apply from: rootProject.file('gradle/checkstyle.gradle')
diff --git a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
index a9784143..901f6857 100644
--- a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -2,17 +2,22 @@
 
 import android.app.Application;
 import android.content.Context;
+import android.support.annotation.NonNull;
 
 /**
  * A no-op version of {@link LeakCanary} that can be used in release builds.
  */
 public final class LeakCanary {
 
-  public static RefWatcher install(Application application) {
+  public static @NonNull RefWatcher install(@NonNull Application application) {
     return RefWatcher.DISABLED;
   }
 
-  public static boolean isInAnalyzerProcess(Context context) {
+  public static @NonNull RefWatcher installedRefWatcher() {
+    return RefWatcher.DISABLED;
+  }
+
+  public static boolean isInAnalyzerProcess(@NonNull Context context) {
     return false;
   }
 
diff --git a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/RefWatcher.java
index ca9f6602..9fd86367 100644
--- a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/RefWatcher.java
@@ -1,19 +1,21 @@
 package com.squareup.leakcanary;
 
+import android.support.annotation.NonNull;
+
 /**
  * No-op implementation of {@link RefWatcher} for release builds. Please use {@link
  * RefWatcher#DISABLED}.
  */
 public final class RefWatcher {
 
-  public static final RefWatcher DISABLED = new RefWatcher();
+  @NonNull public static final RefWatcher DISABLED = new RefWatcher();
 
   private RefWatcher() {
   }
 
-  public void watch(Object watchedReference) {
+  public void watch(@NonNull Object watchedReference) {
   }
 
-  public void watch(Object watchedReference, String referenceName) {
+  public void watch(@NonNull Object watchedReference, @NonNull String referenceName) {
   }
 }
diff --git a/leakcanary-android/build.gradle b/leakcanary-android/build.gradle
index df59c95c..f9480eca 100644
--- a/leakcanary-android/build.gradle
+++ b/leakcanary-android/build.gradle
@@ -2,6 +2,13 @@ apply plugin: 'com.android.library'
 
 dependencies {
   api project(':leakcanary-analyzer')
+  // We don't need the latest version of the support library (there are no bugs that impact what
+  // LeakCanary relies on), we're sticking a bit older because most apps will be using a more
+  // recent version and they'll automatically resolve to higher version without having to
+  // necessarily resort to a resolution strategy. This is also the version we use in
+  // leakcanary-support-fragment.
+  //noinspection GradleDependency
+  implementation 'com.android.support:support-core-utils:26.0.0'
 }
 
 def gitSha() {
@@ -20,6 +27,7 @@ android {
   lintOptions {
     disable 'GoogleAppIndexingWarning'
     error 'ObsoleteSdkInt'
+    check 'Interoperability'
   }
 }
 
diff --git a/leakcanary-android/src/main/AndroidManifest.xml b/leakcanary-android/src/main/AndroidManifest.xml
index 5797416b..6b2c2a26 100644
--- a/leakcanary-android/src/main/AndroidManifest.xml
+++ b/leakcanary-android/src/main/AndroidManifest.xml
@@ -22,6 +22,8 @@
   <!-- To store the heap dumps and leak analysis results. -->
   <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
   <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+  <!-- To allow starting foreground services on Android P+ - https://developer.android.com/preview/behavior-changes#fg-svc -->
+  <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
 
   <application>
     <service
@@ -34,13 +36,23 @@
         android:process=":leakcanary"
         android:enabled="false"
         />
+    <provider
+        android:name="com.squareup.leakcanary.internal.LeakCanaryFileProvider"
+        android:authorities="com.squareup.leakcanary.fileprovider.${applicationId}"
+        android:exported="false"
+        android:grantUriPermissions="true"
+        >
+      <meta-data
+          android:name="android.support.FILE_PROVIDER_PATHS"
+          android:resource="@xml/leak_canary_file_paths"/>
+    </provider>
     <activity
         android:theme="@style/leak_canary_LeakCanary.Base"
         android:name=".internal.DisplayLeakActivity"
         android:process=":leakcanary"
         android:enabled="false"
         android:label="@string/leak_canary_display_activity_label"
-        android:icon="@drawable/leak_canary_icon"
+        android:icon="@mipmap/leak_canary_icon"
         android:taskAffinity="com.squareup.leakcanary.${applicationId}"
         >
       <intent-filter>
@@ -55,7 +67,8 @@
         android:taskAffinity="com.squareup.leakcanary.${applicationId}"
         android:enabled="false"
         android:excludeFromRecents="true"
-        android:icon="@drawable/leak_canary_icon"
+        android:icon="@mipmap/leak_canary_icon"
+        android:roundIcon="@mipmap/leak_canary_icon"
         android:label="@string/leak_canary_storage_permission_activity_label"
         />
 
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
index 9b193831..e8f3473e 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
@@ -15,17 +15,22 @@
  */
 package com.squareup.leakcanary;
 
-import android.app.IntentService;
 import android.content.Context;
 import android.content.Intent;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v4.content.ContextCompat;
+import com.squareup.leakcanary.internal.ForegroundService;
+import java.io.File;
 
-public abstract class AbstractAnalysisResultService extends IntentService {
+public abstract class AbstractAnalysisResultService extends ForegroundService {
 
-  private static final String HEAP_DUMP_EXTRA = "heap_dump_extra";
-  private static final String RESULT_EXTRA = "result_extra";
+  private static final String ANALYZED_HEAP_PATH_EXTRA = "analyzed_heap_path_extra";
 
-  public static void sendResultToListener(Context context, String listenerServiceClassName,
-      HeapDump heapDump, AnalysisResult result) {
+  public static void sendResultToListener(@NonNull Context context,
+      @NonNull String listenerServiceClassName,
+      @NonNull HeapDump heapDump,
+      @NonNull AnalysisResult result) {
     Class<?> listenerServiceClass;
     try {
       listenerServiceClass = Class.forName(listenerServiceClassName);
@@ -33,36 +38,74 @@ public static void sendResultToListener(Context context, String listenerServiceC
       throw new RuntimeException(e);
     }
     Intent intent = new Intent(context, listenerServiceClass);
-    intent.putExtra(HEAP_DUMP_EXTRA, heapDump);
-    intent.putExtra(RESULT_EXTRA, result);
-    context.startService(intent);
+
+    File analyzedHeapFile = AnalyzedHeap.save(heapDump, result);
+    if (analyzedHeapFile != null) {
+      intent.putExtra(ANALYZED_HEAP_PATH_EXTRA, analyzedHeapFile.getAbsolutePath());
+    }
+    ContextCompat.startForegroundService(context, intent);
   }
 
   public AbstractAnalysisResultService() {
-    super(AbstractAnalysisResultService.class.getName());
+    super(AbstractAnalysisResultService.class.getName(),
+        R.string.leak_canary_notification_reporting);
   }
 
-  @Override protected final void onHandleIntent(Intent intent) {
-    HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAP_DUMP_EXTRA);
-    AnalysisResult result = (AnalysisResult) intent.getSerializableExtra(RESULT_EXTRA);
+  @Override protected final void onHandleIntentInForeground(@Nullable Intent intent) {
+    if (intent == null) {
+      CanaryLog.d("AbstractAnalysisResultService received a null intent, ignoring.");
+      return;
+    }
+    if (!intent.hasExtra(ANALYZED_HEAP_PATH_EXTRA)) {
+      onAnalysisResultFailure(getString(R.string.leak_canary_result_failure_no_disk_space));
+      return;
+    }
+    File analyzedHeapFile = new File(intent.getStringExtra(ANALYZED_HEAP_PATH_EXTRA));
+    AnalyzedHeap analyzedHeap = AnalyzedHeap.load(analyzedHeapFile);
+    if (analyzedHeap == null) {
+      onAnalysisResultFailure(getString(R.string.leak_canary_result_failure_no_file));
+      return;
+    }
     try {
-      onHeapAnalyzed(heapDump, result);
+      onHeapAnalyzed(analyzedHeap);
     } finally {
       //noinspection ResultOfMethodCallIgnored
-      heapDump.heapDumpFile.delete();
+      analyzedHeap.heapDump.heapDumpFile.delete();
+      //noinspection ResultOfMethodCallIgnored
+      analyzedHeap.selfFile.delete();
     }
   }
 
   /**
    * Called after a heap dump is analyzed, whether or not a leak was found.
-   * Check {@link AnalysisResult#leakFound} and {@link AnalysisResult#excludedLeak} to see if there
-   * was a leak and if it can be ignored.
-   *
+   * In {@link AnalyzedHeap#result} check {@link AnalysisResult#leakFound} and {@link
+   * AnalysisResult#excludedLeak} to see if there was a leak and if it can be ignored.
+   * <p>
    * This will be called from a background intent service thread.
    * <p>
    * It's OK to block here and wait for the heap dump to be uploaded.
    * <p>
-   * The heap dump file will be deleted immediately after this callback returns.
+   * The analyzed heap file and heap dump file will be deleted immediately after this callback
+   * returns.
+   */
+  protected void onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap) {
+    onHeapAnalyzed(analyzedHeap.heapDump, analyzedHeap.result);
+  }
+
+  /**
+   * @deprecated Maintained for backward compatibility. You should override {@link
+   * #onHeapAnalyzed(AnalyzedHeap)} instead.
+   */
+  @SuppressWarnings("DeprecatedIsStillUsed")
+  @Deprecated
+  protected void onHeapAnalyzed(@NonNull HeapDump heapDump, @NonNull AnalysisResult result) {
+  }
+
+  /**
+   * Called when there was an error saving or loading the analysis result. This will be called from
+   * a background intent service thread.
    */
-  protected abstract void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result);
+  protected void onAnalysisResultFailure(String failureMessage) {
+    CanaryLog.d(failureMessage);
+  }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
index efb7762e..aaf7dd5e 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
@@ -17,61 +17,44 @@
 
 import android.app.Activity;
 import android.app.Application;
-import android.os.Bundle;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-
+import android.content.Context;
+import android.support.annotation.NonNull;
+import com.squareup.leakcanary.internal.ActivityLifecycleCallbacksAdapter;
+
+/**
+ * @deprecated This was initially part of the LeakCanary API, but should not be any more.
+ * {@link AndroidRefWatcherBuilder#watchActivities} should be used instead.
+ * We will make this class internal in the next major version.
+ */
+@SuppressWarnings("DeprecatedIsStillUsed")
+@Deprecated
 public final class ActivityRefWatcher {
 
-  /** @deprecated Use {@link #install(Application, RefWatcher)}. */
-  @Deprecated
-  public static void installOnIcsPlus(Application application, RefWatcher refWatcher) {
+  public static void installOnIcsPlus(@NonNull Application application,
+      @NonNull RefWatcher refWatcher) {
     install(application, refWatcher);
   }
 
-  public static void install(Application application, RefWatcher refWatcher) {
-    new ActivityRefWatcher(application, refWatcher).watchActivities();
+  public static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) {
+    Application application = (Application) context.getApplicationContext();
+    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);
+
+    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);
   }
 
   private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =
-      new Application.ActivityLifecycleCallbacks() {
-        @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
-        }
-
-        @Override public void onActivityStarted(Activity activity) {
-        }
-
-        @Override public void onActivityResumed(Activity activity) {
-        }
-
-        @Override public void onActivityPaused(Activity activity) {
-        }
-
-        @Override public void onActivityStopped(Activity activity) {
-        }
-
-        @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
-        }
-
+      new ActivityLifecycleCallbacksAdapter() {
         @Override public void onActivityDestroyed(Activity activity) {
-          ActivityRefWatcher.this.onActivityDestroyed(activity);
+          refWatcher.watch(activity);
         }
       };
 
   private final Application application;
   private final RefWatcher refWatcher;
 
-  /**
-   * Constructs an {@link ActivityRefWatcher} that will make sure the activities are not leaking
-   * after they have been destroyed.
-   */
-  public ActivityRefWatcher(Application application, RefWatcher refWatcher) {
-    this.application = checkNotNull(application, "application");
-    this.refWatcher = checkNotNull(refWatcher, "refWatcher");
-  }
-
-  void onActivityDestroyed(Activity activity) {
-    refWatcher.watch(activity);
+  private ActivityRefWatcher(Application application, RefWatcher refWatcher) {
+    this.application = application;
+    this.refWatcher = refWatcher;
   }
 
   public void watchActivities() {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AnalyzedHeap.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AnalyzedHeap.java
new file mode 100644
index 00000000..5113bc92
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AnalyzedHeap.java
@@ -0,0 +1,83 @@
+package com.squareup.leakcanary;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+
+/**
+ * Wraps a {@link HeapDump} and corresponding {@link AnalysisResult}.
+ */
+public final class AnalyzedHeap {
+
+  @Nullable public static File save(@NonNull HeapDump heapDump, @NonNull AnalysisResult result) {
+    File analyzedHeapfile = new File(heapDump.heapDumpFile.getParentFile(),
+        heapDump.heapDumpFile.getName() + ".result");
+    FileOutputStream fos = null;
+    try {
+      fos = new FileOutputStream(analyzedHeapfile);
+      ObjectOutputStream oos = new ObjectOutputStream(fos);
+      oos.writeObject(heapDump);
+      oos.writeObject(result);
+      return analyzedHeapfile;
+    } catch (IOException e) {
+      CanaryLog.d(e, "Could not save leak analysis result to disk.");
+    } finally {
+      if (fos != null) {
+        try {
+          fos.close();
+        } catch (IOException ignored) {
+        }
+      }
+    }
+    return null;
+  }
+
+  @Nullable public static AnalyzedHeap load(@NonNull File resultFile) {
+    FileInputStream fis = null;
+    try {
+      fis = new FileInputStream(resultFile);
+      ObjectInputStream ois = new ObjectInputStream(fis);
+      HeapDump heapDump = (HeapDump) ois.readObject();
+      AnalysisResult result = (AnalysisResult) ois.readObject();
+      return new AnalyzedHeap(heapDump, result, resultFile);
+    } catch (IOException | ClassNotFoundException e) {
+      // Likely a change in the serializable result class.
+      // Let's remove the files, we can't read them anymore.
+      boolean deleted = resultFile.delete();
+      if (deleted) {
+        CanaryLog.d(e, "Could not read result file %s, deleted it.", resultFile);
+      } else {
+        CanaryLog.d(e, "Could not read result file %s, could not delete it either.",
+            resultFile);
+      }
+    } finally {
+      if (fis != null) {
+        try {
+          fis.close();
+        } catch (IOException ignored) {
+        }
+      }
+    }
+    return null;
+  }
+
+  @NonNull public final HeapDump heapDump;
+  @NonNull public final AnalysisResult result;
+  @NonNull public final File selfFile;
+  public final boolean heapDumpFileExists;
+  public final long selfLastModified;
+
+  public AnalyzedHeap(@NonNull HeapDump heapDump, @NonNull AnalysisResult result,
+      @NonNull File analyzedHeapFile) {
+    this.heapDump = heapDump;
+    this.result = result;
+    this.selfFile = analyzedHeapFile;
+    heapDumpFileExists = heapDump.heapDumpFile.exists();
+    selfLastModified = analyzedHeapFile.lastModified();
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
index 836aecae..f83dfb8a 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.leakcanary;
 
+import android.support.annotation.NonNull;
 import java.lang.ref.PhantomReference;
 import java.lang.ref.SoftReference;
 import java.lang.ref.WeakReference;
@@ -25,12 +26,16 @@
 import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH;
 import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1;
 import static android.os.Build.VERSION_CODES.JELLY_BEAN;
+import static android.os.Build.VERSION_CODES.JELLY_BEAN_MR2;
 import static android.os.Build.VERSION_CODES.KITKAT;
 import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.N_MR1;
+import static android.os.Build.VERSION_CODES.O;
+import static android.os.Build.VERSION_CODES.O_MR1;
+import static android.os.Build.VERSION_CODES.P;
 import static com.squareup.leakcanary.AndroidWatchExecutor.LEAK_CANARY_THREAD_NAME;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.HUAWEI;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.LENOVO;
@@ -119,9 +124,9 @@
     }
   },
 
-  BLOCKING_QUEUE(SDK_INT <= LOLLIPOP) {
+  BLOCKING_QUEUE() {
     @Override void add(ExcludedRefs.Builder excluded) {
-      String reason = "Prior to ART, a thread waiting on a blocking queue will leak the last"
+      String reason = "A thread waiting on a blocking queue will leak the last"
           + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
           + " keeps a local reference to the last message it received. That message then gets"
           + " recycled and can be used again. As long as all messages are recycled after being"
@@ -136,14 +141,15 @@
           + " sleep for a long time."
           + " To fix this, you could post empty messages to the idle handler threads from time to"
           + " time. This won't be easy because you cannot access all handler threads, but a library"
-          + "that is widely used should consider doing this for its own handler threads.";
+          + "that is widely used should consider doing this for its own handler threads. This leaks"
+          + "has been shown to happen in both Dalvik and ART.";
       excluded.instanceField("android.os.Message", "obj").reason(reason);
       excluded.instanceField("android.os.Message", "next").reason(reason);
       excluded.instanceField("android.os.Message", "target").reason(reason);
     }
   },
 
-  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= N_MR1) {
+  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= O_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
       String reason = "When we detach a view that receives keyboard input, the InputMethodManager"
           + " leaks a reference to it until a new view asks for keyboard input."
@@ -158,7 +164,7 @@
     }
   },
 
-  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= M) {
+  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= O_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
       excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView")
           .reason("The singleton InputMethodManager is holding a reference to mCurRootView long"
@@ -179,7 +185,7 @@
     }
   },
 
-  SPELL_CHECKER_SESSION((SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) || SDK_INT >= N) {
+  SPELL_CHECKER_SESSION(SDK_INT >= JELLY_BEAN && SDK_INT <= N) {
     @Override void add(ExcludedRefs.Builder excluded) {
       excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0")
           .reason("SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
@@ -188,6 +194,16 @@
     }
   },
 
+  SPELL_CHECKER(SDK_INT == LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("android.widget.SpellChecker$1", "this$0")
+          .reason("SpellChecker holds on to a detached view that points to a destroyed activity."
+              + "mSpellRunnable is being enqueued, and that callback should be removed when "
+              + "closeSession() is called. Maybe closeSession() wasn't called, or maybe it was "
+              + "called after the view was detached.");
+    }
+  },
+
   ACTIVITY_CHOOSE_MODEL(SDK_INT > ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
       String reason = "ActivityChooserModel holds a static reference to the last set"
@@ -211,7 +227,7 @@
     }
   },
 
-  ACCOUNT_MANAGER(SDK_INT <= LOLLIPOP_MR1) {
+  ACCOUNT_MANAGER(SDK_INT <= O_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
       excluded.instanceField("android.accounts.AccountManager$AmsTask$Response", "this$1")
           .reason("AccountManager$AmsTask$Response is a stub and is held in memory by native code,"
@@ -237,7 +253,7 @@
     }
   },
 
-  USER_MANAGER__SINSTANCE(SDK_INT >= JELLY_BEAN && SDK_INT <= M) {
+  USER_MANAGER__SINSTANCE(SDK_INT >= JELLY_BEAN_MR2 && SDK_INT < O) {
     @Override void add(ExcludedRefs.Builder excluded) {
       excluded.instanceField("android.os.UserManager", "mContext")
           .reason("UserManager has a static sInstance field that creates an instance and caches it"
@@ -309,13 +325,38 @@
     }
   },
 
+  ACCESSIBILITY_NODE_INFO__MORIGINALTEXT(SDK_INT >= O && SDK_INT <= O_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("android.view.accessibility.AccessibilityNodeInfo", "mOriginalText")
+          .reason("AccessibilityNodeInfo has a static sPool of AccessibilityNodeInfo. When "
+              + "AccessibilityNodeInfo instances are released back in the pool, "
+              + "AccessibilityNodeInfo.clear() does not clear the mOriginalText field, which "
+              + "causes spans to leak which in turns causes TextView.ChangeWatcher to leak and the "
+              + "whole view hierarchy. Introduced here: https://android.googlesource.com/platform/"
+              + "frameworks/base/+/193520e3dff5248ddcf8435203bf99d2ba667219%5E%21/core/java/"
+              + "android/view/accessibility/AccessibilityNodeInfo.java");
+    }
+  },
+
+  BACKDROP_FRAME_RENDERER__MDECORVIEW(SDK_INT >= N && SDK_INT <= O) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("com.android.internal.policy.BackdropFrameRenderer", "mDecorView")
+          .reason("When BackdropFrameRenderer.releaseRenderer() is called, there's an unknown case "
+              + "where mRenderer becomes null but mChoreographer doesn't and the thread doesn't"
+              + "stop and ends up leaking mDecorView which itself holds on to a destroyed"
+              + "activity");
+    }
+  },
+
   // ######## Manufacturer specific Excluded refs ########
 
-  INSTRUMENTATION_RECOMMEND_ACTIVITY(MEIZU.equals(MANUFACTURER) && SDK_INT >= LOLLIPOP && SDK_INT <= LOLLIPOP_MR1) {
+  INSTRUMENTATION_RECOMMEND_ACTIVITY(
+      MEIZU.equals(MANUFACTURER) && SDK_INT >= LOLLIPOP && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
       excluded.staticField("android.app.Instrumentation", "mRecommendActivity")
-              .reason("Instrumentation would leak com.android.internal.app.RecommendActivity (in framework.jar)"
-                  + " in Meizu FlymeOS 4.5 and above, which is based on Android 5.0 and above");
+          .reason("Instrumentation would leak com.android.internal.app.RecommendActivity (in "
+              + "framework.jar) in Meizu FlymeOS 4.5 and above, which is based on Android 5.0 and "
+              + "above");
     }
   },
 
@@ -344,7 +385,17 @@
     @Override void add(ExcludedRefs.Builder excluded) {
       excluded.staticField("android.gestureboost.GestureBoostManager", "mContext")
           .reason("GestureBoostManager is a static singleton that leaks an activity context."
-          + "Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756");
+              + "Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756");
+    }
+  },
+
+  INPUT_METHOD_MANAGER__LAST_SERVED_VIEW(
+      HUAWEI.equals(MANUFACTURER) && SDK_INT >= M && SDK_INT <= O_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      String reason = "HUAWEI added a mLastSrvView field to InputMethodManager"
+          + " that leaks a reference to the last served view.";
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mLastSrvView")
+          .reason(reason);
     }
   },
 
@@ -374,7 +425,8 @@
       SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= N) {
     @Override void add(ExcludedRefs.Builder excluded) {
       excluded.instanceField("com.samsung.android.emergencymode.SemEmergencyManager", "mContext")
-          .reason("SemEmergencyManager is a static singleton that leaks a DecorContext.");
+          .reason("SemEmergencyManager is a static singleton that leaks a DecorContext. "
+              + "Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d");
     }
   },
 
@@ -413,7 +465,7 @@
   },
 
   TEXT_VIEW__MLAST_HOVERED_VIEW(
-      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP_MR1) {
+      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= O) {
     @Override void add(ExcludedRefs.Builder excluded) {
       excluded.staticField("android.widget.TextView", "mLastHoveredView")
           .reason("mLastHoveredView is a static field in TextView that leaks the last hovered"
@@ -524,12 +576,23 @@
       excluded.instanceField("android.view.Choreographer$FrameDisplayEventReceiver",
           "mMessageQueue").alwaysExclude();
     }
+  },
+
+  VIEWLOCATIONHOLDER_ROOT(SDK_INT == P) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      //  In Android P, ViewLocationHolder has an mRoot field that is not cleared in its clear()
+      // method.
+      // Introduced in https://github.com/aosp-mirror/platform_frameworks_base/commit/86b326012813f09d8f1de7d6d26c986a909de894
+      // Bug report: https://issuetracker.google.com/issues/112792715
+      excluded.instanceField("android.view.ViewGroup$ViewLocationHolder",
+          "mRoot");
+    }
   };
 
   /**
    * This returns the references in the leak path that should be ignored by all on Android.
    */
-  public static ExcludedRefs.Builder createAndroidDefaults() {
+  public static @NonNull ExcludedRefs.Builder createAndroidDefaults() {
     return createBuilder(
         EnumSet.of(SOFT_REFERENCES, FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
             EVENT_RECEIVER__MMESSAGE_QUEUE));
@@ -541,11 +604,11 @@
    * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
    * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
    */
-  public static ExcludedRefs.Builder createAppDefaults() {
+  public static @NonNull ExcludedRefs.Builder createAppDefaults() {
     return createBuilder(EnumSet.allOf(AndroidExcludedRefs.class));
   }
 
-  public static ExcludedRefs.Builder createBuilder(EnumSet<AndroidExcludedRefs> refs) {
+  public static @NonNull ExcludedRefs.Builder createBuilder(EnumSet<AndroidExcludedRefs> refs) {
     ExcludedRefs.Builder excluded = ExcludedRefs.builder();
     for (AndroidExcludedRefs ref : refs) {
       if (ref.applies) {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
index 9d618059..12af6dcf 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
@@ -15,34 +15,59 @@
  */
 package com.squareup.leakcanary;
 
+import android.app.Activity;
+import android.app.Application;
+import android.app.Notification;
+import android.app.NotificationManager;
 import android.content.Context;
 import android.os.Debug;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.MessageQueue;
+import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.Gravity;
 import android.view.LayoutInflater;
 import android.widget.Toast;
+import com.squareup.leakcanary.internal.ActivityLifecycleCallbacksAdapter;
 import com.squareup.leakcanary.internal.FutureResult;
+import com.squareup.leakcanary.internal.LeakCanaryInternals;
 import java.io.File;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
 
 public final class AndroidHeapDumper implements HeapDumper {
 
-  final Context context;
+  private final Context context;
   private final LeakDirectoryProvider leakDirectoryProvider;
   private final Handler mainHandler;
 
-  public AndroidHeapDumper(Context context, LeakDirectoryProvider leakDirectoryProvider) {
+  private Activity resumedActivity;
+
+  public AndroidHeapDumper(@NonNull Context context,
+      @NonNull LeakDirectoryProvider leakDirectoryProvider) {
     this.leakDirectoryProvider = leakDirectoryProvider;
     this.context = context.getApplicationContext();
     mainHandler = new Handler(Looper.getMainLooper());
-  }
 
+    Application application = (Application) context.getApplicationContext();
+    application.registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacksAdapter() {
+      @Override public void onActivityResumed(Activity activity) {
+        resumedActivity = activity;
+      }
+
+      @Override public void onActivityPaused(Activity activity) {
+        if (resumedActivity == activity) {
+          resumedActivity = null;
+        }
+      }
+    });
+  }
 
   @SuppressWarnings("ReferenceEquality") // Explicitly checking for named null.
-  @Override public File dumpHeap() {
+  @Override @Nullable
+  public File dumpHeap() {
     File heapDumpFile = leakDirectoryProvider.newHeapDumpFile();
 
     if (heapDumpFile == RETRY_LATER) {
@@ -57,10 +82,19 @@ public AndroidHeapDumper(Context context, LeakDirectoryProvider leakDirectoryPro
       return RETRY_LATER;
     }
 
+    Notification.Builder builder = new Notification.Builder(context)
+        .setContentTitle(context.getString(R.string.leak_canary_notification_dumping));
+    Notification notification = LeakCanaryInternals.buildNotification(context, builder);
+    NotificationManager notificationManager =
+        (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+    int notificationId = (int) SystemClock.uptimeMillis();
+    notificationManager.notify(notificationId, notification);
+
     Toast toast = waitingForToast.get();
     try {
       Debug.dumpHprofData(heapDumpFile.getAbsolutePath());
       cancelToast(toast);
+      notificationManager.cancel(notificationId);
       return heapDumpFile;
     } catch (Exception e) {
       CanaryLog.d(e, "Could not dump heap");
@@ -72,10 +106,14 @@ public AndroidHeapDumper(Context context, LeakDirectoryProvider leakDirectoryPro
   private void showToast(final FutureResult<Toast> waitingForToast) {
     mainHandler.post(new Runnable() {
       @Override public void run() {
-        final Toast toast = new Toast(context);
+        if (resumedActivity == null) {
+          waitingForToast.set(null);
+          return;
+        }
+        final Toast toast = new Toast(resumedActivity);
         toast.setGravity(Gravity.CENTER_VERTICAL, 0, 0);
         toast.setDuration(Toast.LENGTH_LONG);
-        LayoutInflater inflater = LayoutInflater.from(context);
+        LayoutInflater inflater = LayoutInflater.from(resumedActivity);
         toast.setView(inflater.inflate(R.layout.leak_canary_heap_dump_toast, null));
         toast.show();
         // Waiting for Idle to make sure Toast gets rendered.
@@ -90,6 +128,9 @@ private void showToast(final FutureResult<Toast> waitingForToast) {
   }
 
   private void cancelToast(final Toast toast) {
+    if (toast == null) {
+      return;
+    }
     mainHandler.post(new Runnable() {
       @Override public void run() {
         toast.cancel();
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java
new file mode 100644
index 00000000..ecf2fa91
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java
@@ -0,0 +1,225 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import android.app.Activity;
+import android.app.Application;
+import android.app.Dialog;
+import android.app.Fragment;
+import android.os.MessageQueue;
+import android.support.annotation.NonNull;
+import android.view.View;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A set of default {@link Reachability.Inspector}s that knows about common AOSP and library
+ * classes.
+ *
+ * These are heuristics based on our experience and knownledge of AOSP and various library
+ * internals. We only make a reachability decision if we're reasonably sure such reachability is
+ * unlikely to be the result of a programmer mistake.
+ *
+ * For example, no matter how many mistakes we make in our code, the value of Activity.mDestroy
+ * will not be influenced by those mistakes.
+ */
+public enum AndroidReachabilityInspectors {
+
+  VIEW(ViewInspector.class),
+
+  ACTIVITY(ActivityInspector.class),
+
+  DIALOG(DialogInspector.class),
+
+  APPLICATION(ApplicationInspector.class),
+
+  FRAGMENT(FragmentInspector.class),
+
+  SUPPORT_FRAGMENT(SupportFragmentInspector.class),
+
+  MESSAGE_QUEUE(MessageQueueInspector.class),
+
+  MORTAR_PRESENTER(MortarPresenterInspector.class),
+
+  VIEW_ROOT_IMPL(ViewImplInspector.class),
+
+  MAIN_THEAD(MainThreadInspector.class),
+
+  WINDOW(WindowInspector.class),
+
+  //
+  ;
+
+  private final Class<? extends Reachability.Inspector> inspectorClass;
+
+  AndroidReachabilityInspectors(Class<? extends Reachability.Inspector> inspectorClass) {
+    this.inspectorClass = inspectorClass;
+  }
+
+  public static @NonNull List<Class<? extends Reachability.Inspector>> defaultAndroidInspectors() {
+    List<Class<? extends Reachability.Inspector>> inspectorClasses = new ArrayList<>();
+    for (AndroidReachabilityInspectors enumValue : AndroidReachabilityInspectors.values()) {
+      inspectorClasses.add(enumValue.inspectorClass);
+    }
+    return inspectorClasses;
+  }
+
+  public static class ViewInspector implements Reachability.Inspector {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
+      if (!element.isInstanceOf(View.class)) {
+        return Reachability.UNKNOWN;
+      }
+      String mAttachInfo = element.getFieldReferenceValue("mAttachInfo");
+      if (mAttachInfo == null) {
+        return Reachability.UNKNOWN;
+      }
+      return mAttachInfo.equals("null") ? Reachability.UNREACHABLE : Reachability.REACHABLE;
+    }
+  }
+
+  public static class ActivityInspector implements Reachability.Inspector {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
+      if (!element.isInstanceOf(Activity.class)) {
+        return Reachability.UNKNOWN;
+      }
+      String mDestroyed = element.getFieldReferenceValue("mDestroyed");
+      if (mDestroyed == null) {
+        return Reachability.UNKNOWN;
+      }
+      return mDestroyed.equals("true") ? Reachability.UNREACHABLE : Reachability.REACHABLE;
+    }
+  }
+
+  public static class DialogInspector implements Reachability.Inspector {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
+      if (!element.isInstanceOf(Dialog.class)) {
+        return Reachability.UNKNOWN;
+      }
+      String mDecor = element.getFieldReferenceValue("mDecor");
+      if (mDecor == null) {
+        return Reachability.UNKNOWN;
+      }
+      return mDecor.equals("null") ? Reachability.UNREACHABLE : Reachability.REACHABLE;
+    }
+  }
+
+  public static class ApplicationInspector implements Reachability.Inspector {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
+      if (element.isInstanceOf(Application.class)) {
+        return Reachability.REACHABLE;
+      }
+      return Reachability.UNKNOWN;
+    }
+  }
+
+  public static class FragmentInspector implements Reachability.Inspector {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
+      if (!element.isInstanceOf(Fragment.class)) {
+        return Reachability.UNKNOWN;
+      }
+      String mDetached = element.getFieldReferenceValue("mDetached");
+      if (mDetached == null) {
+        return Reachability.UNKNOWN;
+      }
+      return mDetached.equals("true") ? Reachability.UNREACHABLE : Reachability.REACHABLE;
+    }
+  }
+
+  public static class SupportFragmentInspector implements Reachability.Inspector {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
+      if (!element.isInstanceOf("android.support.v4.app.Fragment")) {
+        return Reachability.UNKNOWN;
+      }
+      String mDetached = element.getFieldReferenceValue("mDetached");
+      if (mDetached == null) {
+        return Reachability.UNKNOWN;
+      }
+      return mDetached.equals("true") ? Reachability.UNREACHABLE : Reachability.REACHABLE;
+    }
+  }
+
+  public static class MessageQueueInspector implements Reachability.Inspector {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
+      if (!element.isInstanceOf(MessageQueue.class)) {
+        return Reachability.UNKNOWN;
+      }
+      String mQuitting = element.getFieldReferenceValue("mQuitting");
+      // If the queue is not quitting, maybe it should actually have been, we don't know.
+      // However, if it's quitting, it is very likely that's not a bug.
+      if ("true".equals(mQuitting)) {
+        return Reachability.UNREACHABLE;
+      }
+      return Reachability.UNKNOWN;
+    }
+  }
+
+  public static class MortarPresenterInspector implements Reachability.Inspector {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
+      if (!element.isInstanceOf("mortar.Presenter")) {
+        return Reachability.UNKNOWN;
+      }
+      String view = element.getFieldReferenceValue("view");
+
+      // Bugs in view code tends to cause Mortar presenters to still have a view when they actually
+      // should be a unreachable, so in that case we don't know their reachability status. However,
+      // when the view is null, we're pretty sure they should be unreachable.
+      if ("null".equals(view)) {
+        return Reachability.UNREACHABLE;
+      }
+      return Reachability.UNKNOWN;
+    }
+  }
+
+  public static class ViewImplInspector implements Reachability.Inspector {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
+      if (!element.isInstanceOf("android.view.ViewRootImpl")) {
+        return Reachability.UNKNOWN;
+      }
+      String mView = element.getFieldReferenceValue("mView");
+      if (mView == null) {
+        return Reachability.UNKNOWN;
+      }
+      return mView.equals("null") ? Reachability.UNREACHABLE : Reachability.REACHABLE;
+    }
+  }
+
+  public static class MainThreadInspector implements Reachability.Inspector {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
+      if (!element.isInstanceOf(Thread.class)) {
+        return Reachability.UNKNOWN;
+      }
+      String name = element.getFieldReferenceValue("name");
+      if ("main".equals(name)) {
+        return Reachability.REACHABLE;
+      }
+      return Reachability.UNKNOWN;
+    }
+  }
+
+  public static class WindowInspector implements Reachability.Inspector {
+    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
+      if (!element.isInstanceOf("android.view.Window")) {
+        return Reachability.UNKNOWN;
+      }
+      String mDestroyed = element.getFieldReferenceValue("mDestroyed");
+      if (mDestroyed == null) {
+        return Reachability.UNKNOWN;
+      }
+      return mDestroyed.equals("true") ? Reachability.UNREACHABLE : Reachability.REACHABLE;
+    }
+  }
+
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
index 6673183f..bc72bb11 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
@@ -1,7 +1,11 @@
 package com.squareup.leakcanary;
 
-import android.app.Application;
 import android.content.Context;
+import android.support.annotation.NonNull;
+import com.squareup.leakcanary.internal.DisplayLeakActivity;
+import com.squareup.leakcanary.internal.FragmentRefWatcher;
+import com.squareup.leakcanary.internal.LeakCanaryInternals;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 
 import static com.squareup.leakcanary.RefWatcher.DISABLED;
@@ -13,8 +17,10 @@
   private static final long DEFAULT_WATCH_DELAY_MILLIS = SECONDS.toMillis(5);
 
   private final Context context;
+  private boolean watchActivities = true;
+  private boolean watchFragments = true;
 
-  AndroidRefWatcherBuilder(Context context) {
+  AndroidRefWatcherBuilder(@NonNull Context context) {
     this.context = context.getApplicationContext();
   }
 
@@ -22,8 +28,8 @@
    * Sets a custom {@link AbstractAnalysisResultService} to listen to analysis results. This
    * overrides any call to {@link #heapDumpListener(HeapDump.Listener)}.
    */
-  public AndroidRefWatcherBuilder listenerServiceClass(
-      Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
+  public @NonNull AndroidRefWatcherBuilder listenerServiceClass(
+      @NonNull Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
     return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));
   }
 
@@ -32,33 +38,65 @@ public AndroidRefWatcherBuilder listenerServiceClass(
    * tracked object has been garbage collected. This overrides any call to {@link
    * #watchExecutor(WatchExecutor)}.
    */
-  public AndroidRefWatcherBuilder watchDelay(long delay, TimeUnit unit) {
+  public @NonNull AndroidRefWatcherBuilder watchDelay(long delay, @NonNull TimeUnit unit) {
     return watchExecutor(new AndroidWatchExecutor(unit.toMillis(delay)));
   }
 
   /**
-   * Sets the maximum number of heap dumps stored. This overrides any call to {@link
-   * #heapDumper(HeapDumper)} as well as any call to
-   * {@link LeakCanary#setDisplayLeakActivityDirectoryProvider(LeakDirectoryProvider)})}
+   * Whether we should automatically watch activities when calling {@link #buildAndInstall()}.
+   * Default is true.
+   */
+  public @NonNull AndroidRefWatcherBuilder watchActivities(boolean watchActivities) {
+    this.watchActivities = watchActivities;
+    return this;
+  }
+
+  /**
+   * Whether we should automatically watch fragments when calling {@link #buildAndInstall()}.
+   * Default is true. When true, LeakCanary watches native fragments on Android O+ and support
+   * fragments if the leakcanary-support-fragment dependency is in the classpath.
+   */
+  public @NonNull AndroidRefWatcherBuilder watchFragments(boolean watchFragments) {
+    this.watchFragments = watchFragments;
+    return this;
+  }
+
+  /**
+   * Sets the maximum number of heap dumps stored. This overrides any call to
+   * {@link LeakCanary#setLeakDirectoryProvider(LeakDirectoryProvider)}
    *
    * @throws IllegalArgumentException if maxStoredHeapDumps < 1.
    */
-  public AndroidRefWatcherBuilder maxStoredHeapDumps(int maxStoredHeapDumps) {
+  public @NonNull AndroidRefWatcherBuilder maxStoredHeapDumps(int maxStoredHeapDumps) {
     LeakDirectoryProvider leakDirectoryProvider =
         new DefaultLeakDirectoryProvider(context, maxStoredHeapDumps);
-    LeakCanary.setDisplayLeakActivityDirectoryProvider(leakDirectoryProvider);
-    return heapDumper(new AndroidHeapDumper(context, leakDirectoryProvider));
+    LeakCanary.setLeakDirectoryProvider(leakDirectoryProvider);
+    return self();
   }
 
   /**
-   * Creates a {@link RefWatcher} instance and starts watching activity references (on ICS+).
+   * Creates a {@link RefWatcher} instance and makes it available through {@link
+   * LeakCanary#installedRefWatcher()}.
+   *
+   * Also starts watching activity references if {@link #watchActivities(boolean)} was set to true.
+   *
+   * @throws UnsupportedOperationException if called more than once per Android process.
    */
-  public RefWatcher buildAndInstall() {
+  public @NonNull RefWatcher buildAndInstall() {
+    if (LeakCanaryInternals.installedRefWatcher != null) {
+      throw new UnsupportedOperationException("buildAndInstall() should only be called once.");
+    }
     RefWatcher refWatcher = build();
     if (refWatcher != DISABLED) {
-      LeakCanary.enableDisplayLeakActivity(context);
-      ActivityRefWatcher.install((Application) context, refWatcher);
+      LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);
+      if (watchActivities) {
+        ActivityRefWatcher.install(context, refWatcher);
+      }
+      if (watchFragments) {
+        FragmentRefWatcher.Helper.install(context, refWatcher);
+      }
     }
+    LeakCanaryInternals.installedRefWatcher = refWatcher;
     return refWatcher;
   }
 
@@ -66,24 +104,30 @@ public RefWatcher buildAndInstall() {
     return LeakCanary.isInAnalyzerProcess(context);
   }
 
-  @Override protected HeapDumper defaultHeapDumper() {
-    LeakDirectoryProvider leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
+  @Override protected @NonNull HeapDumper defaultHeapDumper() {
+    LeakDirectoryProvider leakDirectoryProvider =
+        LeakCanaryInternals.getLeakDirectoryProvider(context);
     return new AndroidHeapDumper(context, leakDirectoryProvider);
   }
 
-  @Override protected DebuggerControl defaultDebuggerControl() {
+  @Override protected @NonNull DebuggerControl defaultDebuggerControl() {
     return new AndroidDebuggerControl();
   }
 
-  @Override protected HeapDump.Listener defaultHeapDumpListener() {
+  @Override protected @NonNull HeapDump.Listener defaultHeapDumpListener() {
     return new ServiceHeapDumpListener(context, DisplayLeakService.class);
   }
 
-  @Override protected ExcludedRefs defaultExcludedRefs() {
+  @Override protected @NonNull ExcludedRefs defaultExcludedRefs() {
     return AndroidExcludedRefs.createAppDefaults().build();
   }
 
-  @Override protected WatchExecutor defaultWatchExecutor() {
+  @Override protected @NonNull WatchExecutor defaultWatchExecutor() {
     return new AndroidWatchExecutor(DEFAULT_WATCH_DELAY_MILLIS);
   }
+
+  @Override protected @NonNull
+  List<Class<? extends Reachability.Inspector>> defaultReachabilityInspectorClasses() {
+    return AndroidReachabilityInspectors.defaultAndroidInspectors();
+  }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
index 585af091..73653194 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
@@ -19,6 +19,7 @@
 import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.MessageQueue;
+import android.support.annotation.NonNull;
 import java.util.concurrent.TimeUnit;
 
 import static com.squareup.leakcanary.Retryable.Result.RETRY;
@@ -45,7 +46,7 @@ public AndroidWatchExecutor(long initialDelayMillis) {
     maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;
   }
 
-  @Override public void execute(Retryable retryable) {
+  @Override public void execute(@NonNull Retryable retryable) {
     if (Looper.getMainLooper().getThread() == Thread.currentThread()) {
       waitForIdle(retryable, 0);
     } else {
@@ -53,7 +54,7 @@ public AndroidWatchExecutor(long initialDelayMillis) {
     }
   }
 
-  void postWaitForIdle(final Retryable retryable, final int failedAttempts) {
+  private void postWaitForIdle(final Retryable retryable, final int failedAttempts) {
     mainHandler.post(new Runnable() {
       @Override public void run() {
         waitForIdle(retryable, failedAttempts);
@@ -61,7 +62,7 @@ void postWaitForIdle(final Retryable retryable, final int failedAttempts) {
     });
   }
 
-  void waitForIdle(final Retryable retryable, final int failedAttempts) {
+  private void waitForIdle(final Retryable retryable, final int failedAttempts) {
     // This needs to be called from the main thread.
     Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
       @Override public boolean queueIdle() {
@@ -71,7 +72,7 @@ void waitForIdle(final Retryable retryable, final int failedAttempts) {
     });
   }
 
-  void postToBackgroundWithDelay(final Retryable retryable, final int failedAttempts) {
+  private void postToBackgroundWithDelay(final Retryable retryable, final int failedAttempts) {
     long exponentialBackoffFactor = (long) Math.min(Math.pow(2, failedAttempts), maxBackoffFactor);
     long delayMillis = initialDelayMillis * exponentialBackoffFactor;
     backgroundHandler.postDelayed(new Runnable() {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
index b4e288db..f9ee9ec8 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
@@ -1,5 +1,7 @@
 package com.squareup.leakcanary;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 
 public final class CanaryLog {
@@ -7,36 +9,39 @@
   private static volatile Logger logger = new DefaultLogger();
 
   public interface Logger {
-    void d(String message, Object... args);
+    void d(@NonNull String message, @NonNull Object... args);
 
-    void d(Throwable throwable, String message, Object... args);
+    void d(@Nullable Throwable throwable, @NonNull String message, @NonNull Object... args);
   }
 
   private static class DefaultLogger implements Logger {
-    DefaultLogger() { }
+    DefaultLogger() {
+    }
 
-    @Override public void d(String message, Object... args) {
+    @Override public void d(@NonNull String message, @NonNull Object... args) {
       String formatted = String.format(message, args);
       if (formatted.length() < 4000) {
         Log.d("LeakCanary", formatted);
       } else {
-        String[] lines = formatted.split("\n");
+        String[] lines = formatted.split("\n", -1);
         for (String line : lines) {
           Log.d("LeakCanary", line);
         }
       }
     }
 
-    @Override public void d(Throwable throwable, String message, Object... args) {
+    @Override public void d(@Nullable Throwable throwable,
+        @NonNull String message,
+        @NonNull Object... args) {
       d(String.format(message, args) + '\n' + Log.getStackTraceString(throwable));
     }
   }
 
-  public static void setLogger(Logger logger) {
+  public static void setLogger(@Nullable Logger logger) {
     CanaryLog.logger = logger;
   }
 
-  public static void d(String message, Object... args) {
+  public static void d(@NonNull String message, @NonNull Object... args) {
     // Local variable to prevent the ref from becoming null after the null check.
     Logger logger = CanaryLog.logger;
     if (logger == null) {
@@ -45,7 +50,9 @@ public static void d(String message, Object... args) {
     logger.d(message, args);
   }
 
-  public static void d(Throwable throwable, String message, Object... args) {
+  public static void d(@Nullable Throwable throwable,
+      @NonNull String message,
+      @NonNull Object... args) {
     // Local variable to prevent the ref from becoming null after the null check.
     Logger logger = CanaryLog.logger;
     if (logger == null) {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
index 94957554..c4f7e256 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
@@ -19,6 +19,8 @@
 import android.app.PendingIntent;
 import android.content.Context;
 import android.os.Environment;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.squareup.leakcanary.internal.RequestStoragePermissionActivity;
 import java.io.File;
 import java.io.FilenameFilter;
@@ -53,11 +55,11 @@
   private volatile boolean writeExternalStorageGranted;
   private volatile boolean permissionNotificationDisplayed;
 
-  public DefaultLeakDirectoryProvider(Context context) {
+  public DefaultLeakDirectoryProvider(@NonNull Context context) {
     this(context, DEFAULT_MAX_STORED_HEAP_DUMPS);
   }
 
-  public DefaultLeakDirectoryProvider(Context context, int maxStoredHeapDumps) {
+  public DefaultLeakDirectoryProvider(@NonNull Context context, int maxStoredHeapDumps) {
     if (maxStoredHeapDumps < 1) {
       throw new IllegalArgumentException("maxStoredHeapDumps must be at least 1");
     }
@@ -65,7 +67,7 @@ public DefaultLeakDirectoryProvider(Context context, int maxStoredHeapDumps) {
     this.maxStoredHeapDumps = maxStoredHeapDumps;
   }
 
-  @Override public List<File> listFiles(FilenameFilter filter) {
+  @Override public @NonNull List<File> listFiles(@NonNull FilenameFilter filter) {
     if (!hasStoragePermission()) {
       requestWritePermissionNotification();
     }
@@ -83,7 +85,7 @@ public DefaultLeakDirectoryProvider(Context context, int maxStoredHeapDumps) {
     return files;
   }
 
-  @Override public File newHeapDumpFile() {
+  @Override public @Nullable File newHeapDumpFile() {
     List<File> pendingHeapDumps = listFiles(new FilenameFilter() {
       @Override public boolean accept(File dir, String filename) {
         return filename.endsWith(PENDING_HEAPDUMP_SUFFIX);
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
index 6bf9450a..a2455c05 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
@@ -17,11 +17,10 @@
 
 import android.app.PendingIntent;
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
 import com.squareup.leakcanary.internal.DisplayLeakActivity;
+import com.squareup.leakcanary.internal.LeakCanaryInternals;
 import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.ObjectOutputStream;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
@@ -29,18 +28,21 @@
 import static android.text.format.Formatter.formatShortFileSize;
 import static com.squareup.leakcanary.LeakCanary.leakInfo;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.classSimpleName;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.showNotification;
 
 /**
  * Logs leak analysis results, and then shows a notification which will start {@link
  * DisplayLeakActivity}.
- *
+ * <p>
  * You can extend this class and override {@link #afterDefaultHandling(HeapDump, AnalysisResult,
  * String)} to add custom behavior, e.g. uploading the heap dump.
  */
 public class DisplayLeakService extends AbstractAnalysisResultService {
 
-  @Override protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
+  @Override
+  protected final void onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap) {
+    HeapDump heapDump = analyzedHeap.heapDump;
+    AnalysisResult result = analyzedHeap.result;
+
     String leakInfo = leakInfo(this, heapDump, result, true);
     CanaryLog.d("%s", leakInfo);
 
@@ -51,61 +53,63 @@
       resultSaved = saveResult(heapDump, result);
     }
 
-    PendingIntent pendingIntent;
-    String contentTitle;
-    String contentText;
-
     if (!shouldSaveResult) {
-      contentTitle = getString(R.string.leak_canary_no_leak_title);
-      contentText = getString(R.string.leak_canary_no_leak_text);
-      pendingIntent = null;
+      String contentTitle = getString(R.string.leak_canary_no_leak_title);
+      String contentText = getString(R.string.leak_canary_no_leak_text);
+      showNotification(null, contentTitle, contentText);
     } else if (resultSaved) {
-      pendingIntent = DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);
+      String contentTitle;
+      String contentText;
+      PendingIntent pendingIntent =
+          DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);
 
       if (result.failure == null) {
-        String size = formatShortFileSize(this, result.retainedHeapSize);
-        String className = classSimpleName(result.className);
-        if (result.excludedLeak) {
-          contentTitle = getString(R.string.leak_canary_leak_excluded, className, size);
+        if (result.retainedHeapSize == AnalysisResult.RETAINED_HEAP_SKIPPED) {
+          String className = classSimpleName(result.className);
+          if (result.excludedLeak) {
+            contentTitle = getString(R.string.leak_canary_leak_excluded, className);
+          } else {
+            contentTitle = getString(R.string.leak_canary_class_has_leaked, className);
+          }
         } else {
-          contentTitle = getString(R.string.leak_canary_class_has_leaked, className, size);
+          String size = formatShortFileSize(this, result.retainedHeapSize);
+          String className = classSimpleName(result.className);
+          if (result.excludedLeak) {
+            contentTitle = getString(R.string.leak_canary_leak_excluded_retaining, className, size);
+          } else {
+            contentTitle =
+                getString(R.string.leak_canary_class_has_leaked_retaining, className, size);
+          }
         }
       } else {
         contentTitle = getString(R.string.leak_canary_analysis_failed);
       }
       contentText = getString(R.string.leak_canary_notification_message);
+      showNotification(pendingIntent, contentTitle, contentText);
     } else {
-      contentTitle = getString(R.string.leak_canary_could_not_save_title);
-      contentText = getString(R.string.leak_canary_could_not_save_text);
-      pendingIntent = null;
+      onAnalysisResultFailure(getString(R.string.leak_canary_could_not_save_text));
     }
+
+    afterDefaultHandling(heapDump, result, leakInfo);
+  }
+
+  @Override protected final void onAnalysisResultFailure(String failureMessage) {
+    super.onAnalysisResultFailure(failureMessage);
+    String failureTitle = getString(R.string.leak_canary_result_failure_title);
+    showNotification(null, failureTitle, failureMessage);
+  }
+
+  private void showNotification(PendingIntent pendingIntent, String contentTitle,
+      String contentText) {
     // New notification id every second.
     int notificationId = (int) (SystemClock.uptimeMillis() / 1000);
-    showNotification(this, contentTitle, contentText, pendingIntent, notificationId);
-    afterDefaultHandling(heapDump, result, leakInfo);
+    LeakCanaryInternals.showNotification(this, contentTitle, contentText, pendingIntent,
+        notificationId);
   }
 
   private boolean saveResult(HeapDump heapDump, AnalysisResult result) {
-    File resultFile = new File(heapDump.heapDumpFile.getParentFile(),
-        heapDump.heapDumpFile.getName() + ".result");
-    FileOutputStream fos = null;
-    try {
-      fos = new FileOutputStream(resultFile);
-      ObjectOutputStream oos = new ObjectOutputStream(fos);
-      oos.writeObject(heapDump);
-      oos.writeObject(result);
-      return true;
-    } catch (IOException e) {
-      CanaryLog.d(e, "Could not save leak analysis result to disk.");
-    } finally {
-      if (fos != null) {
-        try {
-          fos.close();
-        } catch (IOException ignored) {
-        }
-      }
-    }
-    return false;
+    File resultFile = AnalyzedHeap.save(heapDump, result);
+    return resultFile != null;
   }
 
   private HeapDump renameHeapdump(HeapDump heapDump) {
@@ -118,9 +122,7 @@ private HeapDump renameHeapdump(HeapDump heapDump) {
       CanaryLog.d("Could not rename heap dump file %s to %s", heapDump.heapDumpFile.getPath(),
           newFile.getPath());
     }
-    return new HeapDump(newFile, heapDump.referenceKey, heapDump.referenceName,
-        heapDump.excludedRefs, heapDump.watchDurationMs, heapDump.gcDurationMs,
-        heapDump.heapDumpDurationMs);
+    return heapDump.buildUpon().heapDumpFile(newFile).build();
   }
 
   /**
@@ -128,6 +130,7 @@ private HeapDump renameHeapdump(HeapDump heapDump) {
    * the heap dump. Don't forget to check {@link AnalysisResult#leakFound} and {@link
    * AnalysisResult#excludedLeak} first.
    */
-  protected void afterDefaultHandling(HeapDump heapDump, AnalysisResult result, String leakInfo) {
+  protected void afterDefaultHandling(@NonNull HeapDump heapDump, @NonNull AnalysisResult result,
+      @NonNull String leakInfo) {
   }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
index 98f8325a..8f4ab8d7 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -20,15 +20,16 @@
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.os.Build;
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.squareup.leakcanary.internal.DisplayLeakActivity;
 import com.squareup.leakcanary.internal.HeapAnalyzerService;
+import com.squareup.leakcanary.internal.LeakCanaryInternals;
 
 import static android.text.format.Formatter.formatShortFileSize;
 import static com.squareup.leakcanary.BuildConfig.GIT_SHA;
 import static com.squareup.leakcanary.BuildConfig.LIBRARY_VERSION;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.isInServiceProcess;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabled;
 
 public final class LeakCanary {
 
@@ -36,33 +37,64 @@
    * Creates a {@link RefWatcher} that works out of the box, and starts watching activity
    * references (on ICS+).
    */
-  public static RefWatcher install(Application application) {
+  public static @NonNull RefWatcher install(@NonNull Application application) {
     return refWatcher(application).listenerServiceClass(DisplayLeakService.class)
         .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
         .buildAndInstall();
   }
 
-  /** Builder to create a customized {@link RefWatcher} with appropriate Android defaults. */
-  public static AndroidRefWatcherBuilder refWatcher(Context context) {
+  /**
+   * Returns the {@link RefWatcher} installed via
+   * {@link AndroidRefWatcherBuilder#buildAndInstall()}, and {@link RefWatcher#DISABLED} is no
+   * {@link RefWatcher} has been installed.
+   */
+  public static @NonNull RefWatcher installedRefWatcher() {
+    RefWatcher refWatcher = LeakCanaryInternals.installedRefWatcher;
+    if (refWatcher == null) {
+      return RefWatcher.DISABLED;
+    }
+    return refWatcher;
+  }
+
+  public static @NonNull AndroidRefWatcherBuilder refWatcher(@NonNull Context context) {
     return new AndroidRefWatcherBuilder(context);
   }
 
-  public static void enableDisplayLeakActivity(Context context) {
-    setEnabled(context, DisplayLeakActivity.class, true);
+  /**
+   * Blocking inter process call that enables the {@link DisplayLeakActivity}. When you first
+   * install the app, {@link DisplayLeakActivity} is disabled by default and will only be enabled
+   * once a potential leak has been found and the analysis starts. You can call this method to
+   * enable {@link DisplayLeakActivity} before any potential leak has been detected.
+   */
+  public static void enableDisplayLeakActivity(@NonNull Context context) {
+    LeakCanaryInternals.setEnabledBlocking(context, DisplayLeakActivity.class, true);
   }
 
   /**
-   * If you build a {@link RefWatcher} with a {@link AndroidHeapDumper} that has a custom {@link
-   * LeakDirectoryProvider}, then you should also call this method to make sure the activity in
-   * charge of displaying leaks can find those on the file system.
+   * @deprecated Use {@link #setLeakDirectoryProvider(LeakDirectoryProvider)} instead.
    */
+  @Deprecated
   public static void setDisplayLeakActivityDirectoryProvider(
-      LeakDirectoryProvider leakDirectoryProvider) {
-    DisplayLeakActivity.setLeakDirectoryProvider(leakDirectoryProvider);
+      @NonNull LeakDirectoryProvider leakDirectoryProvider) {
+    setLeakDirectoryProvider(leakDirectoryProvider);
+  }
+
+  /**
+   * Used to customize the location for the storage of heap dumps. The default implementation is
+   * {@link DefaultLeakDirectoryProvider}.
+   *
+   * @throws IllegalStateException if a LeakDirectoryProvider has already been set, including
+   * if the default has been automatically set when installing the ref watcher.
+   */
+  public static void setLeakDirectoryProvider(
+      @NonNull LeakDirectoryProvider leakDirectoryProvider) {
+    LeakCanaryInternals.setLeakDirectoryProvider(leakDirectoryProvider);
   }
 
   /** Returns a string representation of the result of a heap analysis. */
-  public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult result,
+  public static @NonNull String leakInfo(@NonNull Context context,
+      @NonNull HeapDump heapDump,
+      @NonNull AnalysisResult result,
       boolean detailed) {
     PackageManager packageManager = context.getPackageManager();
     String packageName = context.getPackageName();
@@ -85,7 +117,9 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
         info += " (" + heapDump.referenceName + ")";
       }
       info += " has leaked:\n" + result.leakTrace.toString() + "\n";
-      info += "* Retaining: " + formatShortFileSize(context, result.retainedHeapSize) + ".\n";
+      if (result.retainedHeapSize != AnalysisResult.RETAINED_HEAP_SKIPPED) {
+        info += "* Retaining: " + formatShortFileSize(context, result.retainedHeapSize) + ".\n";
+      }
       if (detailed) {
         detailedString = "\n* Details:\n" + result.leakTrace.toDetailedString();
       }
@@ -141,8 +175,14 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
    * Whether the current process is the process running the {@link HeapAnalyzerService}, which is
    * a different process than the normal app process.
    */
-  public static boolean isInAnalyzerProcess(Context context) {
-    return isInServiceProcess(context, HeapAnalyzerService.class);
+  public static boolean isInAnalyzerProcess(@NonNull Context context) {
+    Boolean isInAnalyzerProcess = LeakCanaryInternals.isInAnalyzerProcess;
+    // This only needs to be computed once per process.
+    if (isInAnalyzerProcess == null) {
+      isInAnalyzerProcess = isInServiceProcess(context, HeapAnalyzerService.class);
+      LeakCanaryInternals.isInAnalyzerProcess = isInAnalyzerProcess;
+    }
+    return isInAnalyzerProcess;
   }
 
   private LeakCanary() {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
index 1dfa218f..5d27bb33 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
@@ -15,6 +15,8 @@
  */
 package com.squareup.leakcanary;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import java.io.File;
 import java.io.FilenameFilter;
 import java.util.List;
@@ -27,12 +29,12 @@
  */
 public interface LeakDirectoryProvider {
 
-  List<File> listFiles(FilenameFilter filter);
+  @NonNull List<File> listFiles(@NonNull FilenameFilter filter);
 
   /**
    * @return {@link HeapDumper#RETRY_LATER} if a new heap dump file could not be created.
    */
-  File newHeapDumpFile();
+  @Nullable File newHeapDumpFile();
 
   /**
    * Removes all heap dumps and analysis results, except for heap dumps that haven't been
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
index 2ccb1422..4d1fa1a1 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
@@ -16,25 +16,23 @@
 package com.squareup.leakcanary;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.squareup.leakcanary.internal.HeapAnalyzerService;
 
 import static com.squareup.leakcanary.Preconditions.checkNotNull;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabled;
 
 public final class ServiceHeapDumpListener implements HeapDump.Listener {
 
   private final Context context;
   private final Class<? extends AbstractAnalysisResultService> listenerServiceClass;
 
-  public ServiceHeapDumpListener(Context context,
-      Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
-    setEnabled(context, listenerServiceClass, true);
-    setEnabled(context, HeapAnalyzerService.class, true);
+  public ServiceHeapDumpListener(@NonNull final Context context,
+      @NonNull final Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
     this.listenerServiceClass = checkNotNull(listenerServiceClass, "listenerServiceClass");
     this.context = checkNotNull(context, "context").getApplicationContext();
   }
 
-  @Override public void analyze(HeapDump heapDump) {
+  @Override public void analyze(@NonNull HeapDump heapDump) {
     checkNotNull(heapDump, "heapDump");
     HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass);
   }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/ActivityLifecycleCallbacksAdapter.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/ActivityLifecycleCallbacksAdapter.java
new file mode 100644
index 00000000..67e9c0c6
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/ActivityLifecycleCallbacksAdapter.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import android.app.Activity;
+import android.app.Application;
+import android.os.Bundle;
+
+public abstract class ActivityLifecycleCallbacksAdapter
+    implements Application.ActivityLifecycleCallbacks {
+  @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
+  }
+
+  @Override public void onActivityStarted(Activity activity) {
+  }
+
+  @Override public void onActivityResumed(Activity activity) {
+  }
+
+  @Override public void onActivityPaused(Activity activity) {
+  }
+
+  @Override public void onActivityStopped(Activity activity) {
+  }
+
+  @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
+  }
+
+  @Override public void onActivityDestroyed(Activity activity) {
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/AndroidOFragmentRefWatcher.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/AndroidOFragmentRefWatcher.java
new file mode 100644
index 00000000..0bf33b31
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/AndroidOFragmentRefWatcher.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import android.app.Activity;
+import android.app.Fragment;
+import android.app.FragmentManager;
+import android.os.Build;
+import android.support.annotation.RequiresApi;
+import android.view.View;
+
+import com.squareup.leakcanary.RefWatcher;
+
+@RequiresApi(Build.VERSION_CODES.O) //
+class AndroidOFragmentRefWatcher implements FragmentRefWatcher {
+
+  private final RefWatcher refWatcher;
+
+  AndroidOFragmentRefWatcher(RefWatcher refWatcher) {
+    this.refWatcher = refWatcher;
+  }
+
+  private final FragmentManager.FragmentLifecycleCallbacks fragmentLifecycleCallbacks =
+      new FragmentManager.FragmentLifecycleCallbacks() {
+
+        @Override public void onFragmentViewDestroyed(FragmentManager fm, Fragment fragment) {
+          View view = fragment.getView();
+          if (view != null) {
+            refWatcher.watch(view);
+          }
+        }
+
+        @Override
+        public void onFragmentDestroyed(FragmentManager fm, Fragment fragment) {
+          refWatcher.watch(fragment);
+        }
+      };
+
+  @Override public void watchFragments(Activity activity) {
+    FragmentManager fragmentManager = activity.getFragmentManager();
+    fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true);
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
index 49d530f5..98ad42ef 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
@@ -15,6 +15,8 @@
  */
 package com.squareup.leakcanary.internal;
 
+import android.annotation.SuppressLint;
+import android.app.ActionBar;
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.app.PendingIntent;
@@ -22,6 +24,7 @@
 import android.content.DialogInterface;
 import android.content.Intent;
 import android.net.Uri;
+import android.os.AsyncTask;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.Looper;
@@ -39,16 +42,13 @@
 import android.widget.ListView;
 import android.widget.TextView;
 import com.squareup.leakcanary.AnalysisResult;
+import com.squareup.leakcanary.AnalyzedHeap;
 import com.squareup.leakcanary.CanaryLog;
-import com.squareup.leakcanary.DefaultLeakDirectoryProvider;
 import com.squareup.leakcanary.HeapDump;
 import com.squareup.leakcanary.LeakDirectoryProvider;
 import com.squareup.leakcanary.R;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.FilenameFilter;
-import java.io.IOException;
-import java.io.ObjectInputStream;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -56,6 +56,7 @@
 import java.util.concurrent.Executor;
 
 import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
+import static android.support.v4.content.FileProvider.getUriForFile;
 import static android.text.format.DateUtils.FORMAT_SHOW_DATE;
 import static android.text.format.DateUtils.FORMAT_SHOW_TIME;
 import static android.text.format.Formatter.formatShortFileSize;
@@ -64,7 +65,9 @@
 import static com.squareup.leakcanary.BuildConfig.GIT_SHA;
 import static com.squareup.leakcanary.BuildConfig.LIBRARY_VERSION;
 import static com.squareup.leakcanary.LeakCanary.leakInfo;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.getLeakDirectoryProvider;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.newSingleThreadExecutor;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabledBlocking;
 
 @SuppressWarnings("ConstantConditions")
 public final class DisplayLeakActivity extends Activity {
@@ -73,31 +76,22 @@
 
   private static final String SHOW_LEAK_EXTRA = "show_latest";
 
+  // Public API.
+  @SuppressWarnings("unused")
   public static PendingIntent createPendingIntent(Context context) {
     return createPendingIntent(context, null);
   }
 
   public static PendingIntent createPendingIntent(Context context, String referenceKey) {
+    setEnabledBlocking(context, DisplayLeakActivity.class, true);
     Intent intent = new Intent(context, DisplayLeakActivity.class);
     intent.putExtra(SHOW_LEAK_EXTRA, referenceKey);
     intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
     return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);
   }
 
-  public static void setLeakDirectoryProvider(LeakDirectoryProvider leakDirectoryProvider) {
-    DisplayLeakActivity.leakDirectoryProvider = leakDirectoryProvider;
-  }
-
-  private static LeakDirectoryProvider leakDirectoryProvider(Context context) {
-    LeakDirectoryProvider leakDirectoryProvider = DisplayLeakActivity.leakDirectoryProvider;
-    if (leakDirectoryProvider == null) {
-      leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
-    }
-    return leakDirectoryProvider;
-  }
-
   // null until it's been first loaded.
-  List<Leak> leaks;
+  List<AnalyzedHeap> leaks;
   String visibleLeakRefKey;
 
   private ListView listView;
@@ -117,13 +111,13 @@ private static LeakDirectoryProvider leakDirectoryProvider(Context context) {
       }
     }
 
-    leaks = (List<Leak>) getLastNonConfigurationInstance();
+    leaks = (List<AnalyzedHeap>) getLastNonConfigurationInstance();
 
     setContentView(R.layout.leak_canary_display_leak);
 
-    listView = (ListView) findViewById(R.id.leak_canary_display_leak_list);
-    failureView = (TextView) findViewById(R.id.leak_canary_display_leak_failure);
-    actionButton = (Button) findViewById(R.id.leak_canary_action);
+    listView = findViewById(R.id.leak_canary_display_leak_list);
+    failureView = findViewById(R.id.leak_canary_display_leak_failure);
+    actionButton = findViewById(R.id.leak_canary_action);
 
     updateUi();
   }
@@ -139,7 +133,7 @@ private static LeakDirectoryProvider leakDirectoryProvider(Context context) {
 
   @Override protected void onResume() {
     super.onResume();
-    LoadLeaks.load(this, leakDirectoryProvider(this));
+    LoadLeaks.load(this, getLeakDirectoryProvider(this));
   }
 
   @Override public void setTheme(int resid) {
@@ -158,7 +152,7 @@ private static LeakDirectoryProvider leakDirectoryProvider(Context context) {
   }
 
   @Override public boolean onCreateOptionsMenu(Menu menu) {
-    Leak visibleLeak = getVisibleLeak();
+    AnalyzedHeap visibleLeak = getVisibleLeak();
     if (visibleLeak != null) {
       menu.add(R.string.leak_canary_share_leak)
           .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
@@ -167,7 +161,7 @@ private static LeakDirectoryProvider leakDirectoryProvider(Context context) {
               return true;
             }
           });
-      if (visibleLeak.heapDump.heapDumpFile.exists()) {
+      if (visibleLeak.heapDumpFileExists) {
         menu.add(R.string.leak_canary_share_heap_dump)
             .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
               @Override public boolean onMenuItemClick(MenuItem item) {
@@ -199,7 +193,7 @@ private static LeakDirectoryProvider leakDirectoryProvider(Context context) {
   }
 
   void shareLeak() {
-    Leak visibleLeak = getVisibleLeak();
+    AnalyzedHeap visibleLeak = getVisibleLeak();
     String leakInfo = leakInfo(this, visibleLeak.heapDump, visibleLeak.result, true);
     Intent intent = new Intent(Intent.ACTION_SEND);
     intent.setType("text/plain");
@@ -207,35 +201,61 @@ void shareLeak() {
     startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
   }
 
+  @SuppressLint("SetWorldReadable")
   void shareHeapDump() {
-    Leak visibleLeak = getVisibleLeak();
-    File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
-    heapDumpFile.setReadable(true, false);
+    AnalyzedHeap visibleLeak = getVisibleLeak();
+    final File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
+    AsyncTask.SERIAL_EXECUTOR.execute(new Runnable() {
+      @Override public void run() {
+        //noinspection ResultOfMethodCallIgnored
+        heapDumpFile.setReadable(true, false);
+        final Uri heapDumpUri = getUriForFile(getBaseContext(),
+            "com.squareup.leakcanary.fileprovider." + getApplication().getPackageName(),
+            heapDumpFile);
+        runOnUiThread(new Runnable() {
+          @Override public void run() {
+            startShareIntentChooser(heapDumpUri);
+          }
+        });
+      }
+    });
+  }
+
+  private void startShareIntentChooser(Uri heapDumpUri) {
     Intent intent = new Intent(Intent.ACTION_SEND);
     intent.setType("application/octet-stream");
-    intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(heapDumpFile));
+    intent.putExtra(Intent.EXTRA_STREAM, heapDumpUri);
     startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
   }
 
   void deleteVisibleLeak() {
-    Leak visibleLeak = getVisibleLeak();
-    File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
-    File resultFile = visibleLeak.resultFile;
-    boolean resultDeleted = resultFile.delete();
-    if (!resultDeleted) {
-      CanaryLog.d("Could not delete result file %s", resultFile.getPath());
-    }
-    boolean heapDumpDeleted = heapDumpFile.delete();
-    if (!heapDumpDeleted) {
-      CanaryLog.d("Could not delete heap dump file %s", heapDumpFile.getPath());
-    }
+    final AnalyzedHeap visibleLeak = getVisibleLeak();
+    AsyncTask.SERIAL_EXECUTOR.execute(new Runnable() {
+      @Override public void run() {
+        File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
+        File resultFile = visibleLeak.selfFile;
+        boolean resultDeleted = resultFile.delete();
+        if (!resultDeleted) {
+          CanaryLog.d("Could not delete result file %s", resultFile.getPath());
+        }
+        boolean heapDumpDeleted = heapDumpFile.delete();
+        if (!heapDumpDeleted) {
+          CanaryLog.d("Could not delete heap dump file %s", heapDumpFile.getPath());
+        }
+      }
+    });
     visibleLeakRefKey = null;
     leaks.remove(visibleLeak);
     updateUi();
   }
 
   void deleteAllLeaks() {
-    leakDirectoryProvider(DisplayLeakActivity.this).clearLeakDirectory();
+    final LeakDirectoryProvider leakDirectoryProvider = getLeakDirectoryProvider(this);
+    AsyncTask.SERIAL_EXECUTOR.execute(new Runnable() {
+      @Override public void run() {
+        leakDirectoryProvider.clearLeakDirectory();
+      }
+    });
     leaks = Collections.emptyList();
     updateUi();
   }
@@ -249,7 +269,7 @@ void updateUi() {
       visibleLeakRefKey = null;
     }
 
-    final Leak visibleLeak = getVisibleLeak();
+    final AnalyzedHeap visibleLeak = getVisibleLeak();
     if (visibleLeak == null) {
       visibleLeakRefKey = null;
     }
@@ -273,7 +293,7 @@ void updateUi() {
         failureView.setText(failureMessage);
         setTitle(R.string.leak_canary_analysis_failed);
         invalidateOptionsMenu();
-        getActionBar().setDisplayHomeAsUpEnabled(true);
+        setDisplayHomeAsUpEnabled(true);
         actionButton.setVisibility(VISIBLE);
         actionButton.setText(R.string.leak_canary_delete);
         actionButton.setOnClickListener(new View.OnClickListener() {
@@ -287,7 +307,7 @@ void updateUi() {
         if (listAdapter instanceof DisplayLeakAdapter) {
           adapter = (DisplayLeakAdapter) listAdapter;
         } else {
-          adapter = new DisplayLeakAdapter();
+          adapter = new DisplayLeakAdapter(getResources());
           listView.setAdapter(adapter);
           listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
             @Override
@@ -296,7 +316,7 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
             }
           });
           invalidateOptionsMenu();
-          getActionBar().setDisplayHomeAsUpEnabled(true);
+          setDisplayHomeAsUpEnabled(true);
           actionButton.setVisibility(VISIBLE);
           actionButton.setText(R.string.leak_canary_delete);
           actionButton.setOnClickListener(new View.OnClickListener() {
@@ -307,9 +327,14 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
         }
         HeapDump heapDump = visibleLeak.heapDump;
         adapter.update(result.leakTrace, heapDump.referenceKey, heapDump.referenceName);
-        String size = formatShortFileSize(this, result.retainedHeapSize);
-        String className = classSimpleName(result.className);
-        setTitle(getString(R.string.leak_canary_class_has_leaked, className, size));
+        if (result.retainedHeapSize == AnalysisResult.RETAINED_HEAP_SKIPPED) {
+          String className = classSimpleName(result.className);
+          setTitle(getString(R.string.leak_canary_class_has_leaked, className));
+        } else {
+          String size = formatShortFileSize(this, result.retainedHeapSize);
+          String className = classSimpleName(result.className);
+          setTitle(getString(R.string.leak_canary_class_has_leaked_retaining, className, size));
+        }
       }
     } else {
       if (listAdapter instanceof LeakListAdapter) {
@@ -326,7 +351,7 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
         });
         invalidateOptionsMenu();
         setTitle(getString(R.string.leak_canary_leak_list_title, getPackageName()));
-        getActionBar().setDisplayHomeAsUpEnabled(false);
+        setDisplayHomeAsUpEnabled(false);
         actionButton.setText(R.string.leak_canary_delete_all);
         actionButton.setOnClickListener(new View.OnClickListener() {
           @Override public void onClick(View v) {
@@ -348,11 +373,20 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
     }
   }
 
-  Leak getVisibleLeak() {
+  private void setDisplayHomeAsUpEnabled(boolean enabled) {
+    ActionBar actionBar = getActionBar();
+    if (actionBar == null) {
+      // https://github.com/square/leakcanary/issues/967
+      return;
+    }
+    actionBar.setDisplayHomeAsUpEnabled(enabled);
+  }
+
+  AnalyzedHeap getVisibleLeak() {
     if (leaks == null) {
       return null;
     }
-    for (Leak leak : leaks) {
+    for (AnalyzedHeap leak : leaks) {
       if (leak.heapDump.referenceKey.equals(visibleLeakRefKey)) {
         return leak;
       }
@@ -366,7 +400,7 @@ Leak getVisibleLeak() {
       return leaks.size();
     }
 
-    @Override public Leak getItem(int position) {
+    @Override public AnalyzedHeap getItem(int position) {
       return leaks.get(position);
     }
 
@@ -379,17 +413,21 @@ Leak getVisibleLeak() {
         convertView = LayoutInflater.from(DisplayLeakActivity.this)
             .inflate(R.layout.leak_canary_leak_row, parent, false);
       }
-      TextView titleView = (TextView) convertView.findViewById(R.id.leak_canary_row_text);
-      TextView timeView = (TextView) convertView.findViewById(R.id.leak_canary_row_time);
-      Leak leak = getItem(position);
+      TextView titleView = convertView.findViewById(R.id.leak_canary_row_text);
+      TextView timeView = convertView.findViewById(R.id.leak_canary_row_time);
+      AnalyzedHeap leak = getItem(position);
 
       String index = (leaks.size() - position) + ". ";
 
       String title;
       if (leak.result.failure == null) {
         String className = classSimpleName(leak.result.className);
-        String size = formatShortFileSize(DisplayLeakActivity.this, leak.result.retainedHeapSize);
-        title = getString(R.string.leak_canary_class_has_leaked, className, size);
+        if (leak.result.retainedHeapSize == AnalysisResult.RETAINED_HEAP_SKIPPED) {
+          title = getString(R.string.leak_canary_class_has_leaked, className);
+        } else {
+          String size = formatShortFileSize(DisplayLeakActivity.this, leak.result.retainedHeapSize);
+          title = getString(R.string.leak_canary_class_has_leaked_retaining, className, size);
+        }
         if (leak.result.excludedLeak) {
           title = getString(R.string.leak_canary_excluded_row, title);
         }
@@ -402,25 +440,13 @@ Leak getVisibleLeak() {
       }
       titleView.setText(title);
       String time =
-          DateUtils.formatDateTime(DisplayLeakActivity.this, leak.resultFile.lastModified(),
+          DateUtils.formatDateTime(DisplayLeakActivity.this, leak.selfLastModified,
               FORMAT_SHOW_TIME | FORMAT_SHOW_DATE);
       timeView.setText(time);
       return convertView;
     }
   }
 
-  static class Leak {
-    final HeapDump heapDump;
-    final AnalysisResult result;
-    final File resultFile;
-
-    Leak(HeapDump heapDump, AnalysisResult result, File resultFile) {
-      this.heapDump = heapDump;
-      this.result = result;
-      this.resultFile = resultFile;
-    }
-  }
-
   static class LoadLeaks implements Runnable {
 
     static final List<LoadLeaks> inFlight = new ArrayList<>();
@@ -451,43 +477,22 @@ static void forgetActivity() {
     }
 
     @Override public void run() {
-      final List<Leak> leaks = new ArrayList<>();
+      final List<AnalyzedHeap> leaks = new ArrayList<>();
       List<File> files = leakDirectoryProvider.listFiles(new FilenameFilter() {
         @Override public boolean accept(File dir, String filename) {
           return filename.endsWith(".result");
         }
       });
       for (File resultFile : files) {
-        FileInputStream fis = null;
-        try {
-          fis = new FileInputStream(resultFile);
-          ObjectInputStream ois = new ObjectInputStream(fis);
-          HeapDump heapDump = (HeapDump) ois.readObject();
-          AnalysisResult result = (AnalysisResult) ois.readObject();
-          leaks.add(new Leak(heapDump, result, resultFile));
-        } catch (IOException | ClassNotFoundException e) {
-          // Likely a change in the serializable result class.
-          // Let's remove the files, we can't read them anymore.
-          boolean deleted = resultFile.delete();
-          if (deleted) {
-            CanaryLog.d(e, "Could not read result file %s, deleted it.", resultFile);
-          } else {
-            CanaryLog.d(e, "Could not read result file %s, could not delete it either.",
-                resultFile);
-          }
-        } finally {
-          if (fis != null) {
-            try {
-              fis.close();
-            } catch (IOException ignored) {
-            }
-          }
+        final AnalyzedHeap leak = AnalyzedHeap.load(resultFile);
+        if (leak != null) {
+          leaks.add(leak);
         }
       }
-      Collections.sort(leaks, new Comparator<Leak>() {
-        @Override public int compare(Leak lhs, Leak rhs) {
-          return Long.valueOf(rhs.resultFile.lastModified())
-              .compareTo(lhs.resultFile.lastModified());
+      Collections.sort(leaks, new Comparator<AnalyzedHeap>() {
+        @Override public int compare(AnalyzedHeap lhs, AnalyzedHeap rhs) {
+          return Long.valueOf(rhs.selfFile.lastModified())
+              .compareTo(lhs.selfFile.lastModified());
         }
       });
       mainHandler.post(new Runnable() {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
index 4e71b4f1..b350163b 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
@@ -16,7 +16,11 @@
 package com.squareup.leakcanary.internal;
 
 import android.content.Context;
+import android.content.res.Resources;
+import android.support.annotation.ColorRes;
 import android.text.Html;
+import android.text.SpannableStringBuilder;
+import android.text.Spanned;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
@@ -26,12 +30,8 @@
 import com.squareup.leakcanary.LeakTrace;
 import com.squareup.leakcanary.LeakTraceElement;
 import com.squareup.leakcanary.R;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
+import com.squareup.leakcanary.Reachability;
 
-import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
 import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
 
 final class DisplayLeakAdapter extends BaseAdapter {
@@ -41,10 +41,29 @@
 
   private boolean[] opened = new boolean[0];
 
-  private List<LeakTraceElement> elements = Collections.emptyList();
+  private LeakTrace leakTrace = null;
   private String referenceKey;
   private String referenceName = "";
 
+  private final String classNameColorHexString;
+  private final String leakColorHexString;
+  private final String referenceColorHexString;
+  private final String extraColorHexString;
+  private final String helpColorHexString;
+
+  DisplayLeakAdapter(Resources resources) {
+    classNameColorHexString = hexStringColor(resources, R.color.leak_canary_class_name);
+    leakColorHexString = hexStringColor(resources, R.color.leak_canary_leak);
+    referenceColorHexString = hexStringColor(resources, R.color.leak_canary_reference);
+    extraColorHexString = hexStringColor(resources, R.color.leak_canary_extra);
+    helpColorHexString = hexStringColor(resources, R.color.leak_canary_help);
+  }
+
+  // https://stackoverflow.com/a/6540378/703646
+  private static String hexStringColor(Resources resources, @ColorRes int colorResId) {
+    return String.format("#%06X", (0xFFFFFF & resources.getColor(colorResId)));
+  }
+
   @Override public View getView(int position, View convertView, ViewGroup parent) {
     Context context = parent.getContext();
     if (getItemViewType(position) == TOP_ROW) {
@@ -59,98 +78,184 @@
         convertView =
             LayoutInflater.from(context).inflate(R.layout.leak_canary_ref_row, parent, false);
       }
-      TextView textView = findById(convertView, R.id.leak_canary_row_text);
 
-      boolean isRoot = position == 1;
-      boolean isLeakingInstance = position == getCount() - 1;
-      LeakTraceElement element = getItem(position);
-      String htmlString = elementToHtmlString(element, isRoot, opened[position]);
-      if (isLeakingInstance && !referenceName.equals("") && opened[position]) {
-        htmlString += " <font color='#919191'>" + referenceName + "</font>";
+      TextView titleView = findById(convertView, R.id.leak_canary_row_title);
+      TextView detailView = findById(convertView, R.id.leak_canary_row_details);
+      DisplayLeakConnectorView connector = findById(convertView, R.id.leak_canary_row_connector);
+      MoreDetailsView moreDetailsView = findById(convertView, R.id.leak_canary_row_more);
+
+      connector.setType(getConnectorType(position));
+      moreDetailsView.setOpened(opened[position]);
+
+      if (opened[position]) {
+        detailView.setVisibility(View.VISIBLE);
+      } else {
+        detailView.setVisibility(View.GONE);
       }
-      textView.setText(Html.fromHtml(htmlString));
 
-      DisplayLeakConnectorView connector = findById(convertView, R.id.leak_canary_row_connector);
-      if (isRoot) {
-        connector.setType(DisplayLeakConnectorView.Type.START);
+      Resources resources = convertView.getResources();
+      if (position == 1) {
+        titleView.setText(Html.fromHtml("<font color='"
+            + helpColorHexString
+            + "'>"
+            + "<b>" + resources.getString(R.string.leak_canary_help_title) + "</b>"
+            + "</font>"));
+        SpannableStringBuilder detailText =
+            (SpannableStringBuilder) Html.fromHtml(
+                resources.getString(R.string.leak_canary_help_detail));
+        SquigglySpan.replaceUnderlineSpans(detailText, resources);
+        detailView.setText(detailText);
       } else {
-        if (isLeakingInstance) {
-          connector.setType(DisplayLeakConnectorView.Type.END);
+        boolean isLeakingInstance = position == getCount() - 1;
+        LeakTraceElement element = getItem(position);
+
+        Reachability reachability = leakTrace.expectedReachability.get(elementIndex(position));
+        boolean maybeLeakCause;
+        if (isLeakingInstance || reachability == Reachability.UNREACHABLE) {
+          maybeLeakCause = false;
         } else {
-          connector.setType(DisplayLeakConnectorView.Type.NODE);
+          Reachability nextReachability =
+              leakTrace.expectedReachability.get(elementIndex(position + 1));
+          maybeLeakCause = nextReachability != Reachability.REACHABLE;
+        }
+
+        Spanned htmlTitle =
+            htmlTitle(element, maybeLeakCause, resources);
+
+        titleView.setText(htmlTitle);
+
+        if (opened[position]) {
+          Spanned htmlDetail = htmlDetails(isLeakingInstance, element);
+          detailView.setText(htmlDetail);
         }
       }
-      MoreDetailsView moreDetailsView = findById(convertView, R.id.leak_canary_row_more);
-      moreDetailsView.setOpened(opened[position]);
     }
 
     return convertView;
   }
 
-  private String elementToHtmlString(LeakTraceElement element, boolean root, boolean opened) {
+  private Spanned htmlTitle(LeakTraceElement element, boolean maybeLeakCause, Resources resources) {
     String htmlString = "";
 
-    if (element.referenceName == null) {
-      htmlString += "leaks ";
-    } else if (!root) {
-      htmlString += "references ";
-    }
+    String simpleName = element.getSimpleClassName();
+    simpleName = simpleName.replace("[]", "[ ]");
 
-    if (element.type == STATIC_FIELD) {
-      htmlString += "<font color='#c48a47'>static</font> ";
-    }
+    String styledClassName =
+        "<font color='" + classNameColorHexString + "'>" + simpleName + "</font>";
 
-    if (element.holder == ARRAY || element.holder == THREAD) {
-      htmlString += "<font color='#f3cf83'>" + element.holder.name().toLowerCase() + "</font> ";
-    }
+    if (element.reference != null) {
+      String referenceName = element.reference.getDisplayName().replaceAll("<", "&lt;")
+          .replaceAll(">", "&gt;");
 
-    int separator = element.className.lastIndexOf('.');
-    String qualifier;
-    String simpleName;
-    if (separator == -1) {
-      qualifier = "";
-      simpleName = element.className;
-    } else {
-      qualifier = element.className.substring(0, separator + 1);
-      simpleName = element.className.substring(separator + 1);
-    }
+      if (maybeLeakCause) {
+        referenceName =
+            "<u><font color='" + leakColorHexString + "'>" + referenceName + "</font></u>";
+      } else {
+        referenceName =
+            "<font color='" + referenceColorHexString + "'>" + referenceName + "</font>";
+      }
 
-    if (opened) {
-      htmlString += "<font color='#919191'>" + qualifier + "</font>";
-    }
+      if (element.reference.type == STATIC_FIELD) {
+        referenceName = "<i>" + referenceName + "</i>";
+      }
 
-    String styledClassName = "<font color='#ffffff'>" + simpleName + "</font>";
+      String classAndReference = styledClassName + "." + referenceName;
 
-    htmlString += styledClassName;
+      if (maybeLeakCause) {
+        classAndReference = "<b>" + classAndReference + "</b>";
+      }
 
-    if (element.referenceName != null) {
-      htmlString += ".<font color='#998bb5'>" + element.referenceName.replaceAll("<", "&lt;")
-          .replaceAll(">", "&gt;") + "</font>";
+      htmlString += classAndReference;
     } else {
-      htmlString += " <font color='#f3cf83'>instance</font>";
+      htmlString += styledClassName;
     }
 
-    if (opened && element.extra != null) {
-      htmlString += " <font color='#919191'>" + element.extra + "</font>";
+    Exclusion exclusion = element.exclusion;
+    if (exclusion != null) {
+      htmlString += " (excluded)";
+    }
+    SpannableStringBuilder builder = (SpannableStringBuilder) Html.fromHtml(htmlString);
+    if (maybeLeakCause) {
+      SquigglySpan.replaceUnderlineSpans(builder, resources);
+    }
+
+    return builder;
+  }
+
+  private Spanned htmlDetails(boolean isLeakingInstance, LeakTraceElement element) {
+    String htmlString = "";
+    if (element.extra != null) {
+      htmlString += " <font color='" + extraColorHexString + "'>" + element.extra + "</font>";
     }
 
     Exclusion exclusion = element.exclusion;
     if (exclusion != null) {
-      if (opened) {
-        htmlString += "<br/><br/>Excluded by rule";
-        if (exclusion.name != null) {
-          htmlString += " <font color='#ffffff'>" + exclusion.name + "</font>";
-        }
-        htmlString += " matching <font color='#f3cf83'>" + exclusion.matching + "</font>";
-        if (exclusion.reason != null) {
-          htmlString += " because <font color='#f3cf83'>" + exclusion.reason + "</font>";
+      htmlString += "<br/><br/>Excluded by rule";
+      if (exclusion.name != null) {
+        htmlString += " <font color='#ffffff'>" + exclusion.name + "</font>";
+      }
+      htmlString += " matching <font color='#f3cf83'>" + exclusion.matching + "</font>";
+      if (exclusion.reason != null) {
+        htmlString += " because <font color='#f3cf83'>" + exclusion.reason + "</font>";
+      }
+    }
+    htmlString += "<br>"
+        + "<font color='" + extraColorHexString + "'>"
+        + element.toDetailedString().replace("\n", "<br>")
+        + "</font>";
+
+    if (isLeakingInstance && !referenceName.equals("")) {
+      htmlString += " <font color='" + extraColorHexString + "'>" + referenceName + "</font>";
+    }
+
+    return Html.fromHtml(htmlString);
+  }
+
+  private DisplayLeakConnectorView.Type getConnectorType(int position) {
+    if (position == 1) {
+      return DisplayLeakConnectorView.Type.HELP;
+    } else if (position == 2) {
+      Reachability nextReachability =
+          leakTrace.expectedReachability.get(elementIndex(position + 1));
+      if (nextReachability != Reachability.REACHABLE) {
+        return DisplayLeakConnectorView.Type.START_LAST_REACHABLE;
+      }
+      return DisplayLeakConnectorView.Type.START;
+    } else {
+      boolean isLeakingInstance = position == getCount() - 1;
+      if (isLeakingInstance) {
+        Reachability previousReachability =
+            leakTrace.expectedReachability.get(elementIndex(position - 1));
+        if (previousReachability != Reachability.UNREACHABLE) {
+          return DisplayLeakConnectorView.Type.END_FIRST_UNREACHABLE;
         }
+        return DisplayLeakConnectorView.Type.END;
       } else {
-        htmlString += " (excluded)";
+        Reachability reachability = leakTrace.expectedReachability.get(elementIndex(position));
+        switch (reachability) {
+          case UNKNOWN:
+            return DisplayLeakConnectorView.Type.NODE_UNKNOWN;
+          case REACHABLE:
+            Reachability nextReachability =
+                leakTrace.expectedReachability.get(elementIndex(position + 1));
+            if (nextReachability != Reachability.REACHABLE) {
+              return DisplayLeakConnectorView.Type.NODE_LAST_REACHABLE;
+            } else {
+              return DisplayLeakConnectorView.Type.NODE_REACHABLE;
+            }
+          case UNREACHABLE:
+            Reachability previousReachability =
+                leakTrace.expectedReachability.get(elementIndex(position - 1));
+            if (previousReachability != Reachability.UNREACHABLE) {
+              return DisplayLeakConnectorView.Type.NODE_FIRST_UNREACHABLE;
+            } else {
+              return DisplayLeakConnectorView.Type.NODE_UNREACHABLE;
+            }
+          default:
+            throw new IllegalStateException("Unknown value: " + reachability);
+        }
       }
     }
-
-    return htmlString;
   }
 
   public void update(LeakTrace leakTrace, String referenceKey, String referenceName) {
@@ -160,8 +265,8 @@ public void update(LeakTrace leakTrace, String referenceKey, String referenceNam
     }
     this.referenceKey = referenceKey;
     this.referenceName = referenceName;
-    this.elements = new ArrayList<>(leakTrace.elements);
-    opened = new boolean[1 + elements.size()];
+    this.leakTrace = leakTrace;
+    opened = new boolean[2 + leakTrace.elements.size()];
     notifyDataSetChanged();
   }
 
@@ -171,14 +276,24 @@ public void toggleRow(int position) {
   }
 
   @Override public int getCount() {
-    return 1 + elements.size();
+    if (leakTrace == null) {
+      return 2;
+    }
+    return 2 + leakTrace.elements.size();
   }
 
   @Override public LeakTraceElement getItem(int position) {
     if (getItemViewType(position) == TOP_ROW) {
       return null;
     }
-    return elements.get(position - 1);
+    if (position == 1) {
+      return null;
+    }
+    return leakTrace.elements.get(elementIndex(position));
+  }
+
+  private int elementIndex(int position) {
+    return position - 2;
   }
 
   @Override public int getViewTypeCount() {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
index e854ac2a..3a500da3 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
@@ -16,46 +16,81 @@
 package com.squareup.leakcanary.internal;
 
 import android.content.Context;
+import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Color;
+import android.graphics.DashPathEffect;
 import android.graphics.Paint;
+import android.graphics.PorterDuffXfermode;
 import android.util.AttributeSet;
 import android.view.View;
+import com.squareup.leakcanary.R;
 
 import static android.graphics.Bitmap.Config.ARGB_8888;
+import static android.graphics.PorterDuff.Mode.CLEAR;
 
 public final class DisplayLeakConnectorView extends View {
 
-  private static final Paint iconPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  private static final Paint rootPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  private static final Paint leakPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  private static final Paint clearPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-
-  static {
-    iconPaint.setColor(LeakCanaryUi.LIGHT_GREY);
-    rootPaint.setColor(LeakCanaryUi.ROOT_COLOR);
-    leakPaint.setColor(LeakCanaryUi.LEAK_COLOR);
-    clearPaint.setColor(Color.TRANSPARENT);
-    clearPaint.setXfermode(LeakCanaryUi.CLEAR_XFER_MODE);
-  }
+  private static final float SQRT_TWO = (float) Math.sqrt(2);
+  private static final PorterDuffXfermode CLEAR_XFER_MODE = new PorterDuffXfermode(CLEAR);
 
   public enum Type {
-    START, NODE, END
+    HELP,
+    START,
+    START_LAST_REACHABLE,
+    NODE_UNKNOWN,
+    NODE_FIRST_UNREACHABLE,
+    NODE_UNREACHABLE,
+    NODE_REACHABLE,
+    NODE_LAST_REACHABLE,
+    END,
+    END_FIRST_UNREACHABLE,
   }
 
+  private final Paint classNamePaint;
+  private final Paint leakPaint;
+  private final Paint clearPaint;
+  private final Paint referencePaint;
+  private final float strokeSize;
+  private final float circleY;
+
   private Type type;
   private Bitmap cache;
 
   public DisplayLeakConnectorView(Context context, AttributeSet attrs) {
     super(context, attrs);
 
-    type = Type.NODE;
+    Resources resources = getResources();
+
+    type = Type.NODE_UNKNOWN;
+    circleY = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_center_y);
+    strokeSize = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_stroke_size);
+
+    classNamePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    classNamePaint.setColor(resources.getColor(R.color.leak_canary_class_name));
+    classNamePaint.setStrokeWidth(strokeSize);
+
+    leakPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    leakPaint.setColor(resources.getColor(R.color.leak_canary_leak));
+    leakPaint.setStyle(Paint.Style.STROKE);
+    leakPaint.setStrokeWidth(strokeSize);
+    float pathLines = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_leak_dash_line);
+    float pathGaps = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_leak_dash_gap);
+    leakPaint.setPathEffect(new DashPathEffect(new float[] { pathLines, pathGaps }, 0));
+
+    clearPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    clearPaint.setColor(Color.TRANSPARENT);
+    clearPaint.setXfermode(CLEAR_XFER_MODE);
+
+    referencePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    referencePaint.setColor(resources.getColor(R.color.leak_canary_reference));
+    referencePaint.setStrokeWidth(strokeSize);
   }
 
   @SuppressWarnings("SuspiciousNameCombination") @Override protected void onDraw(Canvas canvas) {
-    int width = getWidth();
-    int height = getHeight();
+    int width = getMeasuredWidth();
+    int height = getMeasuredHeight();
 
     if (cache != null && (cache.getWidth() != width || cache.getHeight() != height)) {
       cache.recycle();
@@ -67,40 +102,110 @@ public DisplayLeakConnectorView(Context context, AttributeSet attrs) {
 
       Canvas cacheCanvas = new Canvas(cache);
 
-      float halfWidth = width / 2f;
-      float halfHeight = height / 2f;
-      float thirdWidth = width / 3f;
-
-      float strokeSize = LeakCanaryUi.dpToPixel(4f, getResources());
-
-      iconPaint.setStrokeWidth(strokeSize);
-      rootPaint.setStrokeWidth(strokeSize);
-
       switch (type) {
-        case NODE:
-          cacheCanvas.drawLine(halfWidth, 0, halfWidth, height, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, halfWidth, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, clearPaint);
+        case NODE_UNKNOWN:
+          drawItems(cacheCanvas, leakPaint, leakPaint);
           break;
-        case START:
-          float radiusClear = halfWidth - strokeSize / 2f;
-          cacheCanvas.drawRect(0, 0, width, radiusClear, rootPaint);
-          cacheCanvas.drawCircle(0, radiusClear, radiusClear, clearPaint);
-          cacheCanvas.drawCircle(width, radiusClear, radiusClear, clearPaint);
-          cacheCanvas.drawLine(halfWidth, 0, halfWidth, halfHeight, rootPaint);
-          cacheCanvas.drawLine(halfWidth, halfHeight, halfWidth, height, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, halfWidth, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, clearPaint);
+        case NODE_UNREACHABLE:
+        case NODE_REACHABLE:
+          drawItems(cacheCanvas, referencePaint, referencePaint);
           break;
-        default:
-          cacheCanvas.drawLine(halfWidth, 0, halfWidth, halfHeight, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, leakPaint);
+        case NODE_FIRST_UNREACHABLE:
+          drawItems(cacheCanvas, leakPaint, referencePaint);
+          break;
+        case NODE_LAST_REACHABLE:
+          drawItems(cacheCanvas, referencePaint, leakPaint);
+          break;
+        case START: {
+          drawStartLine(cacheCanvas);
+          drawItems(cacheCanvas, null, referencePaint);
+          break;
+        }
+        case START_LAST_REACHABLE:
+          drawStartLine(cacheCanvas);
+          drawItems(cacheCanvas, null, leakPaint);
+          break;
+        case END:
+          drawItems(cacheCanvas, referencePaint, null);
           break;
+        case END_FIRST_UNREACHABLE:
+          drawItems(cacheCanvas, leakPaint, null);
+          break;
+        case HELP:
+          drawRoot(cacheCanvas);
+          break;
+        default:
+          throw new UnsupportedOperationException("Unknown type " + type);
       }
     }
     canvas.drawBitmap(cache, 0, 0, null);
   }
 
+  private void drawStartLine(Canvas cacheCanvas) {
+    int width = getMeasuredWidth();
+    float halfWidth = width / 2f;
+    cacheCanvas.drawLine(halfWidth, 0, halfWidth, circleY, classNamePaint);
+  }
+
+  private void drawRoot(Canvas cacheCanvas) {
+    int width = getMeasuredWidth();
+    int height = getMeasuredHeight();
+    float halfWidth = width / 2f;
+    float radiusClear = halfWidth - strokeSize / 2f;
+    cacheCanvas.drawRect(0, 0, width, radiusClear, classNamePaint);
+    cacheCanvas.drawCircle(0, radiusClear, radiusClear, clearPaint);
+    cacheCanvas.drawCircle(width, radiusClear, radiusClear, clearPaint);
+    cacheCanvas.drawLine(halfWidth, 0, halfWidth, height, classNamePaint);
+  }
+
+  private void drawItems(Canvas cacheCanvas, Paint arrowHeadPaint, Paint nextArrowPaint) {
+    if (arrowHeadPaint != null) {
+      drawArrowHead(cacheCanvas, arrowHeadPaint);
+    }
+    if (nextArrowPaint != null) {
+      drawNextArrowLine(cacheCanvas, nextArrowPaint);
+    }
+    drawInstanceCircle(cacheCanvas);
+  }
+
+  private void drawArrowHead(Canvas cacheCanvas, Paint paint) {
+    // Circle center is at half height
+    int width = getMeasuredWidth();
+    float halfWidth = width / 2f;
+    float centerX = halfWidth;
+    float circleRadius = width / 3f;
+    float arrowSideLength = halfWidth;
+    // Splitting the arrow head in two makes an isosceles right triangle.
+    // It's hypotenuse is side * sqrt(2)
+    float arrowHeight = (arrowSideLength / 2) * SQRT_TWO;
+    float halfStrokeSize = strokeSize / 2;
+    float translateY = circleY - arrowHeight - (circleRadius * 2) - strokeSize;
+
+    float lineYEnd = circleY - circleRadius - (strokeSize / 2);
+    cacheCanvas.drawLine(centerX, 0, centerX, lineYEnd, paint);
+    cacheCanvas.translate(centerX, translateY);
+    cacheCanvas.rotate(45);
+    cacheCanvas.drawLine(0, arrowSideLength, arrowSideLength + halfStrokeSize, arrowSideLength,
+        paint);
+    cacheCanvas.drawLine(arrowSideLength, 0, arrowSideLength, arrowSideLength, paint);
+    cacheCanvas.rotate(-45);
+    cacheCanvas.translate(-centerX, -translateY);
+  }
+
+  private void drawNextArrowLine(Canvas cacheCanvas, Paint paint) {
+    int height = getMeasuredHeight();
+    int width = getMeasuredWidth();
+    float centerX = width / 2f;
+    cacheCanvas.drawLine(centerX, circleY, centerX, height, paint);
+  }
+
+  private void drawInstanceCircle(Canvas cacheCanvas) {
+    int width = getMeasuredWidth();
+    float circleX = width / 2f;
+    float circleRadius = width / 3f;
+    cacheCanvas.drawCircle(circleX, circleY, circleRadius, classNamePaint);
+  }
+
   public void setType(Type type) {
     if (type != this.type) {
       this.type = type;
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/ForegroundService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/ForegroundService.java
new file mode 100644
index 00000000..b2773db3
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/ForegroundService.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import android.app.IntentService;
+import android.app.Notification;
+import android.content.Intent;
+import android.os.IBinder;
+import android.os.SystemClock;
+import android.support.annotation.Nullable;
+import com.squareup.leakcanary.R;
+
+public abstract class ForegroundService extends IntentService {
+
+  private final int notificationContentTitleResId;
+  private final int notificationId;
+
+  public ForegroundService(String name, int notificationContentTitleResId) {
+    super(name);
+    this.notificationContentTitleResId = notificationContentTitleResId;
+    notificationId = (int) SystemClock.uptimeMillis();
+  }
+
+  @Override
+  public void onCreate() {
+    super.onCreate();
+    showForegroundNotification(100, 0, true,
+        getString(R.string.leak_canary_notification_foreground_text));
+  }
+
+  protected void showForegroundNotification(int max, int progress, boolean indeterminate,
+      String contentText) {
+    Notification.Builder builder = new Notification.Builder(this)
+        .setContentTitle(getString(notificationContentTitleResId))
+        .setContentText(contentText)
+        .setProgress(max, progress, indeterminate);
+    Notification notification = LeakCanaryInternals.buildNotification(this, builder);
+    startForeground(notificationId, notification);
+  }
+
+  @Override protected void onHandleIntent(@Nullable Intent intent) {
+    onHandleIntentInForeground(intent);
+  }
+
+  protected abstract void onHandleIntentInForeground(@Nullable Intent intent);
+
+  @Override public void onDestroy() {
+    super.onDestroy();
+    stopForeground(true);
+  }
+
+  @Override public IBinder onBind(Intent intent) {
+    return null;
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FragmentRefWatcher.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FragmentRefWatcher.java
new file mode 100644
index 00000000..27f1f177
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FragmentRefWatcher.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import android.app.Activity;
+import android.app.Application;
+import android.content.Context;
+import android.os.Bundle;
+import com.squareup.leakcanary.RefWatcher;
+import java.lang.reflect.Constructor;
+import java.util.ArrayList;
+import java.util.List;
+
+import static android.os.Build.VERSION.SDK_INT;
+import static android.os.Build.VERSION_CODES.O;
+
+/**
+ * Internal class used to watch for fragments leaks.
+ */
+public interface FragmentRefWatcher {
+
+  void watchFragments(Activity activity);
+
+  final class Helper {
+
+    private static final String SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME =
+        "com.squareup.leakcanary.internal.SupportFragmentRefWatcher";
+
+    public static void install(Context context, RefWatcher refWatcher) {
+      List<FragmentRefWatcher> fragmentRefWatchers = new ArrayList<>();
+
+      if (SDK_INT >= O) {
+        fragmentRefWatchers.add(new AndroidOFragmentRefWatcher(refWatcher));
+      }
+
+      try {
+        Class<?> fragmentRefWatcherClass = Class.forName(SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME);
+        Constructor<?> constructor =
+            fragmentRefWatcherClass.getDeclaredConstructor(RefWatcher.class);
+        FragmentRefWatcher supportFragmentRefWatcher =
+            (FragmentRefWatcher) constructor.newInstance(refWatcher);
+        fragmentRefWatchers.add(supportFragmentRefWatcher);
+      } catch (Exception ignored) {
+      }
+
+      if (fragmentRefWatchers.size() == 0) {
+        return;
+      }
+
+      Helper helper = new Helper(fragmentRefWatchers);
+
+      Application application = (Application) context.getApplicationContext();
+      application.registerActivityLifecycleCallbacks(helper.activityLifecycleCallbacks);
+    }
+
+    private final Application.ActivityLifecycleCallbacks activityLifecycleCallbacks =
+        new ActivityLifecycleCallbacksAdapter() {
+          @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
+            for (FragmentRefWatcher watcher : fragmentRefWatchers) {
+              watcher.watchFragments(activity);
+            }
+          }
+        };
+
+    private final List<FragmentRefWatcher> fragmentRefWatchers;
+
+    private Helper(List<FragmentRefWatcher> fragmentRefWatchers) {
+      this.fragmentRefWatchers = fragmentRefWatchers;
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
index d03dad94..545d94df 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
@@ -15,37 +15,45 @@
  */
 package com.squareup.leakcanary.internal;
 
-import android.app.IntentService;
 import android.content.Context;
 import android.content.Intent;
+import android.support.annotation.Nullable;
+import android.support.v4.content.ContextCompat;
 import com.squareup.leakcanary.AbstractAnalysisResultService;
 import com.squareup.leakcanary.AnalysisResult;
+import com.squareup.leakcanary.AnalyzerProgressListener;
 import com.squareup.leakcanary.CanaryLog;
 import com.squareup.leakcanary.HeapAnalyzer;
 import com.squareup.leakcanary.HeapDump;
+import com.squareup.leakcanary.R;
+
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabledBlocking;
 
 /**
  * This service runs in a separate process to avoid slowing down the app process or making it run
  * out of memory.
  */
-public final class HeapAnalyzerService extends IntentService {
+public final class HeapAnalyzerService extends ForegroundService
+    implements AnalyzerProgressListener {
 
   private static final String LISTENER_CLASS_EXTRA = "listener_class_extra";
   private static final String HEAPDUMP_EXTRA = "heapdump_extra";
 
   public static void runAnalysis(Context context, HeapDump heapDump,
       Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
+    setEnabledBlocking(context, HeapAnalyzerService.class, true);
+    setEnabledBlocking(context, listenerServiceClass, true);
     Intent intent = new Intent(context, HeapAnalyzerService.class);
     intent.putExtra(LISTENER_CLASS_EXTRA, listenerServiceClass.getName());
     intent.putExtra(HEAPDUMP_EXTRA, heapDump);
-    context.startService(intent);
+    ContextCompat.startForegroundService(context, intent);
   }
 
   public HeapAnalyzerService() {
-    super(HeapAnalyzerService.class.getSimpleName());
+    super(HeapAnalyzerService.class.getSimpleName(), R.string.leak_canary_notification_analysing);
   }
 
-  @Override protected void onHandleIntent(Intent intent) {
+  @Override protected void onHandleIntentInForeground(@Nullable Intent intent) {
     if (intent == null) {
       CanaryLog.d("HeapAnalyzerService received a null intent, ignoring.");
       return;
@@ -53,9 +61,19 @@ public HeapAnalyzerService() {
     String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);
     HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);
 
-    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(heapDump.excludedRefs);
+    HeapAnalyzer heapAnalyzer =
+        new HeapAnalyzer(heapDump.excludedRefs, this, heapDump.reachabilityInspectorClasses);
 
-    AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);
+    AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey,
+        heapDump.computeRetainedHeapSize);
     AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);
   }
+
+  @Override public void onProgressUpdate(Step step) {
+    int percent = (int) ((100f * step.ordinal()) / Step.values().length);
+    CanaryLog.d("Analysis in progress, working on: %s", step.name());
+    String lowercase = step.name().replace("_", " ").toLowerCase();
+    String message = lowercase.substring(0, 1).toUpperCase() + lowercase.substring(1);
+    showForegroundNotification(100, percent, false, message);
+  }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryFileProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryFileProvider.java
new file mode 100644
index 00000000..37c1eb38
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryFileProvider.java
@@ -0,0 +1,10 @@
+package com.squareup.leakcanary.internal;
+
+import android.support.v4.content.FileProvider;
+
+/**
+ * There can only be one {@link FileProvider} provider registered per app, so we extend that class
+ * just to use a distinct name.
+ */
+public class LeakCanaryFileProvider extends FileProvider {
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
index 8a4ba98f..6a776235 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
@@ -15,7 +15,6 @@
  */
 package com.squareup.leakcanary.internal;
 
-import android.annotation.TargetApi;
 import android.app.ActivityManager;
 import android.app.Notification;
 import android.app.NotificationChannel;
@@ -27,8 +26,12 @@
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.ServiceInfo;
+import android.os.AsyncTask;
 import com.squareup.leakcanary.CanaryLog;
+import com.squareup.leakcanary.DefaultLeakDirectoryProvider;
+import com.squareup.leakcanary.LeakDirectoryProvider;
 import com.squareup.leakcanary.R;
+import com.squareup.leakcanary.RefWatcher;
 import java.util.List;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
@@ -52,13 +55,12 @@
   public static final String HUAWEI = "HUAWEI";
   public static final String VIVO = "vivo";
 
-  private static final Executor fileIoExecutor = newSingleThreadExecutor("File-IO");
+  public static volatile RefWatcher installedRefWatcher;
+  private static volatile LeakDirectoryProvider leakDirectoryProvider;
 
   private static final String NOTIFICATION_CHANNEL_ID = "leakcanary";
 
-  public static void executeOnFileIoThread(Runnable runnable) {
-    fileIoExecutor.execute(runnable);
-  }
+  public static volatile Boolean isInAnalyzerProcess;
 
   /** Extracts the class simple name out of a string containing a fully qualified class name. */
   public static String classSimpleName(String className) {
@@ -70,10 +72,10 @@ public static String classSimpleName(String className) {
     }
   }
 
-  public static void setEnabled(Context context, final Class<?> componentClass,
+  public static void setEnabledAsync(Context context, final Class<?> componentClass,
       final boolean enabled) {
     final Context appContext = context.getApplicationContext();
-    executeOnFileIoThread(new Runnable() {
+    AsyncTask.THREAD_POOL_EXECUTOR.execute(new Runnable() {
       @Override public void run() {
         setEnabledBlocking(appContext, componentClass, enabled);
       }
@@ -119,8 +121,14 @@ public static boolean isInServiceProcess(Context context, Class<? extends Servic
     ActivityManager activityManager =
         (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
     ActivityManager.RunningAppProcessInfo myProcess = null;
-    List<ActivityManager.RunningAppProcessInfo> runningProcesses =
-        activityManager.getRunningAppProcesses();
+    List<ActivityManager.RunningAppProcessInfo> runningProcesses;
+    try {
+      runningProcesses = activityManager.getRunningAppProcesses();
+    } catch (SecurityException exception) {
+      // https://github.com/square/leakcanary/issues/948
+      CanaryLog.d("Could not get running app processes %d", exception);
+      return false;
+    }
     if (runningProcesses != null) {
       for (ActivityManager.RunningAppProcessInfo process : runningProcesses) {
         if (process.pid == myPid) {
@@ -139,43 +147,63 @@ public static boolean isInServiceProcess(Context context, Class<? extends Servic
 
   public static void showNotification(Context context, CharSequence contentTitle,
       CharSequence contentText, PendingIntent pendingIntent, int notificationId) {
+    Notification.Builder builder = new Notification.Builder(context)
+        .setContentText(contentText)
+        .setContentTitle(contentTitle)
+        .setAutoCancel(true)
+        .setContentIntent(pendingIntent);
+
+    Notification notification = buildNotification(context, builder);
     NotificationManager notificationManager =
         (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+    notificationManager.notify(notificationId, notification);
+  }
 
-    Notification notification;
-    Notification.Builder builder = new Notification.Builder(context) //
-        .setSmallIcon(R.drawable.leak_canary_notification)
+  public static Notification buildNotification(Context context,
+      Notification.Builder builder) {
+    builder.setSmallIcon(R.drawable.leak_canary_notification)
         .setWhen(System.currentTimeMillis())
-        .setContentTitle(contentTitle)
-        .setContentText(contentText)
-        .setAutoCancel(true)
-        .setContentIntent(pendingIntent);
+        .setOnlyAlertOnce(true);
+
     if (SDK_INT >= O) {
-      String channelName = context.getString(R.string.leak_canary_notification_channel);
-      setupNotificationChannel(channelName, notificationManager, builder);
+      NotificationManager notificationManager =
+          (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+      NotificationChannel notificationChannel =
+          notificationManager.getNotificationChannel(NOTIFICATION_CHANNEL_ID);
+      if (notificationChannel == null) {
+        String channelName = context.getString(R.string.leak_canary_notification_channel);
+        notificationChannel = new NotificationChannel(NOTIFICATION_CHANNEL_ID, channelName,
+            NotificationManager.IMPORTANCE_DEFAULT);
+        notificationManager.createNotificationChannel(notificationChannel);
+      }
+      builder.setChannelId(NOTIFICATION_CHANNEL_ID);
     }
+
     if (SDK_INT < JELLY_BEAN) {
-      notification = builder.getNotification();
+      return builder.getNotification();
     } else {
-      notification = builder.build();
+      return builder.build();
     }
-    notificationManager.notify(notificationId, notification);
   }
 
-  @TargetApi(O)
-  private static void setupNotificationChannel(String channelName,
-      NotificationManager notificationManager, Notification.Builder builder) {
-    if (notificationManager.getNotificationChannel(NOTIFICATION_CHANNEL_ID) == null) {
-      NotificationChannel notificationChannel =
-          new NotificationChannel(NOTIFICATION_CHANNEL_ID, channelName,
-              NotificationManager.IMPORTANCE_DEFAULT);
-      notificationManager.createNotificationChannel(notificationChannel);
+  public static Executor newSingleThreadExecutor(String threadName) {
+    return Executors.newSingleThreadExecutor(new LeakCanarySingleThreadFactory(threadName));
+  }
+
+  public static void setLeakDirectoryProvider(LeakDirectoryProvider leakDirectoryProvider) {
+    if (LeakCanaryInternals.leakDirectoryProvider != null) {
+      throw new IllegalStateException("Cannot set the LeakDirectoryProvider after it has already "
+          + "been set. Try setting it before installing the RefWatcher.");
     }
-    builder.setChannelId(NOTIFICATION_CHANNEL_ID);
+    LeakCanaryInternals.leakDirectoryProvider = leakDirectoryProvider;
   }
 
-  public static Executor newSingleThreadExecutor(String threadName) {
-    return Executors.newSingleThreadExecutor(new LeakCanarySingleThreadFactory(threadName));
+  public static LeakDirectoryProvider getLeakDirectoryProvider(Context context) {
+    LeakDirectoryProvider leakDirectoryProvider = LeakCanaryInternals.leakDirectoryProvider;
+    if (leakDirectoryProvider == null) {
+      leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
+    }
+    return leakDirectoryProvider;
   }
 
   private LeakCanaryInternals() {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java
deleted file mode 100644
index 74fbf986..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.res.Resources;
-import android.graphics.PorterDuffXfermode;
-import android.util.DisplayMetrics;
-
-import static android.graphics.PorterDuff.Mode.CLEAR;
-
-final class LeakCanaryUi {
-  static final int LIGHT_GREY = 0xFFbababa;
-  static final int ROOT_COLOR = 0xFF84a6c5;
-  static final int LEAK_COLOR = 0xFFb1554e;
-
-  static final PorterDuffXfermode CLEAR_XFER_MODE = new PorterDuffXfermode(CLEAR);
-
-  /**
-   * Converts from device independent pixels (dp or dip) to
-   * device dependent pixels. This method returns the input
-   * multiplied by the display's density. The result is not
-   * rounded nor clamped.
-   *
-   * The value returned by this method is well suited for
-   * drawing with the Canvas API but should not be used to
-   * set layout dimensions.
-   *
-   * @param dp The value in dp to convert to pixels
-   * @param resources An instances of Resources
-   */
-  static float dpToPixel(float dp, Resources resources) {
-    DisplayMetrics metrics = resources.getDisplayMetrics();
-    return metrics.density * dp;
-  }
-
-  private LeakCanaryUi() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
index 81bf8a0f..c88e5dcf 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
@@ -15,25 +15,37 @@
  */
 package com.squareup.leakcanary.internal;
 
+import android.annotation.SuppressLint;
 import android.content.Context;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
 import android.graphics.Canvas;
+import android.graphics.Color;
 import android.graphics.Paint;
 import android.util.AttributeSet;
 import android.view.View;
+import com.squareup.leakcanary.R;
 
 public final class MoreDetailsView extends View {
 
-  private static final Paint iconPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-
-  static {
-    iconPaint.setColor(LeakCanaryUi.ROOT_COLOR);
-  }
+  private final Paint iconPaint;
 
   public MoreDetailsView(Context context, AttributeSet attrs) {
     super(context, attrs);
-
-    float strokeSize = LeakCanaryUi.dpToPixel(2f, getResources());
+    Resources resources = getResources();
+    iconPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    float strokeSize = resources.getDimensionPixelSize(R.dimen.leak_canary_more_stroke_width);
     iconPaint.setStrokeWidth(strokeSize);
+
+    // This lint check doesn't work for libraries which have a common prefix.
+    @SuppressLint("CustomViewStyleable") //
+        TypedArray a =
+        context.obtainStyledAttributes(attrs, R.styleable.leak_canary_MoreDetailsView);
+    int plusColor =
+        a.getColor(R.styleable.leak_canary_MoreDetailsView_leak_canary_plus_color, Color.BLACK);
+    a.recycle();
+
+    iconPaint.setColor(plusColor);
   }
 
   private boolean opened;
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RowElementLayout.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RowElementLayout.java
new file mode 100644
index 00000000..f552716d
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RowElementLayout.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.util.AttributeSet;
+import android.view.View;
+import android.view.ViewGroup;
+import com.squareup.leakcanary.R;
+
+public class RowElementLayout extends ViewGroup {
+
+  private final int connectorWidth;
+  private final int rowMargins;
+  private final int moreSize;
+  private final int minHeight;
+  private final int titleMarginTop;
+  private final int moreMarginTop;
+
+  private View connector;
+  private View moreButton;
+  private View title;
+  private View details;
+
+  public RowElementLayout(Context context, AttributeSet attrs) {
+    super(context, attrs);
+    Resources resources = getResources();
+    connectorWidth = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_width);
+    rowMargins = resources.getDimensionPixelSize(R.dimen.leak_canary_row_margins);
+    moreSize = resources.getDimensionPixelSize(R.dimen.leak_canary_more_size);
+    minHeight = resources.getDimensionPixelSize(R.dimen.leak_canary_row_min);
+    titleMarginTop = resources.getDimensionPixelSize(R.dimen.leak_canary_row_title_margin_top);
+    moreMarginTop = resources.getDimensionPixelSize(R.dimen.leak_canary_more_margin_top);
+  }
+
+  @Override protected void onFinishInflate() {
+    super.onFinishInflate();
+    connector = findViewById(R.id.leak_canary_row_connector);
+    moreButton = findViewById(R.id.leak_canary_row_more);
+    title = findViewById(R.id.leak_canary_row_title);
+    details = findViewById(R.id.leak_canary_row_details);
+  }
+
+  @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+    int availableWidth = MeasureSpec.getSize(widthMeasureSpec);
+    int titleWidth = availableWidth - connectorWidth - moreSize - 4 * rowMargins;
+    int titleWidthSpec = MeasureSpec.makeMeasureSpec(titleWidth, MeasureSpec.AT_MOST);
+    int titleHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
+    title.measure(titleWidthSpec, titleHeightSpec);
+
+    int moreSizeSpec = MeasureSpec.makeMeasureSpec(moreSize, MeasureSpec.EXACTLY);
+    moreButton.measure(moreSizeSpec, moreSizeSpec);
+
+    int totalHeight = titleMarginTop + title.getMeasuredHeight();
+
+    int detailsWidth = availableWidth - connectorWidth - 3 * rowMargins;
+    int detailsWidthSpec = MeasureSpec.makeMeasureSpec(detailsWidth, MeasureSpec.AT_MOST);
+    int detailsHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
+    details.measure(detailsWidthSpec, detailsHeightSpec);
+    if (details.getVisibility() != GONE) {
+      totalHeight += details.getMeasuredHeight();
+    }
+    totalHeight = Math.max(totalHeight, minHeight);
+
+    int connectorWidthSpec = MeasureSpec.makeMeasureSpec(connectorWidth, MeasureSpec.EXACTLY);
+    int connectorHeightSpec = MeasureSpec.makeMeasureSpec(totalHeight, MeasureSpec.EXACTLY);
+
+    connector.measure(connectorWidthSpec, connectorHeightSpec);
+    setMeasuredDimension(availableWidth, totalHeight);
+  }
+
+  @Override protected void onLayout(boolean changed, int l, int t, int r, int b) {
+    int width = getMeasuredWidth();
+    int connectorRight = rowMargins + connector.getMeasuredWidth();
+    connector.layout(rowMargins, 0, connectorRight, connector.getMeasuredHeight());
+
+    moreButton.layout(width - rowMargins - moreSize, moreMarginTop, width - rowMargins,
+        moreMarginTop + moreSize);
+
+    int titleLeft = connectorRight + rowMargins;
+    int titleBottom = titleMarginTop + title.getMeasuredHeight();
+    title.layout(titleLeft, titleMarginTop, titleLeft + title.getMeasuredWidth(), titleBottom);
+
+    if (details.getVisibility() != GONE) {
+      details.layout(titleLeft, titleBottom, width - rowMargins,
+          titleBottom + details.getMeasuredHeight());
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/SquigglySpan.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/SquigglySpan.java
new file mode 100644
index 00000000..31a2cfee
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/SquigglySpan.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import android.content.res.Resources;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Path;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.SpannableStringBuilder;
+import android.text.style.ReplacementSpan;
+import android.text.style.UnderlineSpan;
+import com.squareup.leakcanary.R;
+
+/**
+ * Inspired from https://github.com/flavienlaurent/spans and
+ * https://github.com/andyxialm/WavyLineView
+ */
+class SquigglySpan extends ReplacementSpan {
+
+
+  public static void replaceUnderlineSpans(SpannableStringBuilder builder, Resources resources) {
+    UnderlineSpan[] underlineSpans = builder.getSpans(0, builder.length(), UnderlineSpan.class);
+    for (UnderlineSpan span : underlineSpans) {
+      int start = builder.getSpanStart(span);
+      int end = builder.getSpanEnd(span);
+      builder.removeSpan(span);
+      builder.setSpan(new SquigglySpan(resources), start, end, 0);
+    }
+  }
+
+  private final Paint squigglyPaint;
+  private final Path path;
+  private final int referenceColor;
+  private final float halfStrokeWidth;
+  private final float amplitude;
+  private final float halfWaveHeight;
+  private final float periodDegrees;
+
+  private int width;
+
+  SquigglySpan(Resources resources) {
+    squigglyPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    squigglyPaint.setStyle(Paint.Style.STROKE);
+    squigglyPaint.setColor(resources.getColor(R.color.leak_canary_leak));
+    float strokeWidth =
+        resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_stroke_width);
+    squigglyPaint.setStrokeWidth(strokeWidth);
+
+    halfStrokeWidth = strokeWidth / 2;
+    amplitude = resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_amplitude);
+    periodDegrees =
+        resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_period_degrees);
+    path = new Path();
+    float waveHeight = 2 * amplitude + strokeWidth;
+    halfWaveHeight = waveHeight / 2;
+    referenceColor = resources.getColor(R.color.leak_canary_reference);
+  }
+
+  @Override public int getSize(@NonNull Paint paint, CharSequence text, int start, int end,
+      @Nullable Paint.FontMetricsInt fm) {
+    width = (int) paint.measureText(text, start, end);
+    return width;
+  }
+
+  @Override
+  public void draw(@NonNull Canvas canvas, CharSequence text, int start, int end, float x, int top,
+      int y, int bottom, @NonNull Paint paint) {
+    squigglyHorizontalPath(path,
+        x + halfStrokeWidth,
+        x + width - halfStrokeWidth,
+        bottom - halfWaveHeight,
+        amplitude, periodDegrees);
+    canvas.drawPath(path, squigglyPaint);
+
+    paint.setColor(referenceColor);
+    canvas.drawText(text, start, end, x, y, paint);
+  }
+
+  private static void squigglyHorizontalPath(Path path, float left, float right, float centerY,
+      float amplitude,
+      float periodDegrees) {
+    path.reset();
+
+    float y;
+    path.moveTo(left, centerY);
+    float period = (float) (2 * Math.PI / periodDegrees);
+
+    for (float x = 0; x <= right - left; x += 1) {
+      y = (float) (amplitude * Math.sin(40 + period * x) + centerY);
+      path.lineTo(left + x, y);
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png
deleted file mode 100755
index 74348d82..00000000
Binary files a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png
deleted file mode 100755
index 37f5057f..00000000
Binary files a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png
deleted file mode 100755
index 56a94f27..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png
deleted file mode 100755
index 34b7d41b..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png
deleted file mode 100755
index 855d6052..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable/leak_canary_icon_foreground.xml b/leakcanary-android/src/main/res/drawable/leak_canary_icon_foreground.xml
new file mode 100644
index 00000000..07b6f09c
--- /dev/null
+++ b/leakcanary-android/src/main/res/drawable/leak_canary_icon_foreground.xml
@@ -0,0 +1,19 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+        android:width="108dp"
+        android:height="108dp"
+        android:viewportWidth="108.0"
+        android:viewportHeight="108.0">
+    <path
+        android:pathData="M108,72.77L75.27,37.54C75.27,37.54 75.36,46.84 75.27,50.38C75.97,68.02 62.84,77.92 54.23,80C51.3,79.28 47.86,77.67 44.62,75.16C44.62,75.16 54.84,86.1 75.27,108L108,108L108,72.77Z"
+        android:strokeColor="#00000000"
+        android:fillType="evenOdd"
+        android:fillAlpha="0.02"
+        android:fillColor="#000000"
+        android:strokeWidth="1"/>
+    <path
+        android:pathData="M33.01,37.54L54.23,28L75.27,37.54C75.27,37.54 75.36,46.84 75.27,50.38C75.97,68.02 62.84,77.92 54.23,80C45.62,77.9 32.65,68.05 33.01,50.38C33.09,46.2 33.01,37.54 33.01,37.54ZM42.36,66.8C42.36,66.8 43.76,64.63 46.14,63.54C46.8,62.76 47.24,61.63 48.35,60.54C48.97,59.94 50.02,59.21 51,58.84C51.99,58.46 53.16,58.27 54.25,58.3C55.35,58.32 56.21,58.49 57.57,58.98C61,60.25 65.15,65.58 66.01,67.88C63.18,69.64 60.5,71.59 57.57,75.08C56.96,74.81 55.42,74.26 52.9,74.55C49.84,75.19 46.9,70.85 47.04,68.48C45.24,67.81 42.36,66.8 42.36,66.8ZM51.95,65.31C51.46,65.31 51.15,65.06 51.09,64.82C51.03,64.59 51.38,64.03 51.58,63.92C52.62,63.38 53.79,63.46 53.79,63.46C53.79,63.46 54.15,65.33 51.95,65.31ZM51.86,48.89L56.53,48.89L56.53,53.75L51.86,53.75L51.86,48.89ZM51.86,36.18L56.53,36.18L56.53,46.52L51.86,46.52L51.86,36.18Z"
+        android:strokeColor="#00000000"
+        android:fillType="evenOdd"
+        android:fillColor="#FDED00"
+        android:strokeWidth="1"/>
+</vector>
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml b/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
index 8e56c3d1..9dde7974 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
@@ -18,7 +18,7 @@
     android:layout_width="match_parent"
     android:layout_height="match_parent"
     android:orientation="vertical"
-    android:background="#3c3c3c"
+    android:background="@color/leak_canary_background_color"
     >
   <ListView
       android:id="@+id/leak_canary_display_leak_list"
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml b/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml
index d6057ed2..14a2c648 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml
@@ -25,7 +25,7 @@
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
       android:layout_gravity="center_horizontal"
-      android:src="@drawable/leak_canary_icon"/>
+      android:src="@mipmap/leak_canary_icon"/>
 
   <TextView
       android:layout_width="wrap_content"
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml b/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
index 947af46c..2f1996a3 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
@@ -14,36 +14,39 @@
   ~ See the License for the specific language governing permissions and
   ~ limitations under the License.
   -->
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+<com.squareup.leakcanary.internal.RowElementLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:lib="http://schemas.android.com/apk/res-auto"
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
-    android:minHeight="48dp"
-    android:orientation="horizontal"
+    android:id="@+id/leak_canary_row_layout"
+    android:clipChildren="false"
     >
 
   <com.squareup.leakcanary.internal.DisplayLeakConnectorView
       android:id="@+id/leak_canary_row_connector"
-      android:layout_width="16dp"
-      android:layout_height="match_parent"
-      android:layout_marginStart="16dp"
-      android:layout_marginEnd="16dp"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      />
+
+  <com.squareup.leakcanary.internal.MoreDetailsView
+      android:id="@+id/leak_canary_row_more"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      lib:leak_canary_plus_color="@color/leak_canary_class_name"
       />
 
   <TextView
-      android:id="@+id/leak_canary_row_text"
-      android:layout_width="0dp"
-      android:layout_weight="1"
+      android:id="@+id/leak_canary_row_title"
+      android:layout_width="wrap_content"
       android:layout_height="wrap_content"
-      android:layout_gravity="center_vertical"
       />
 
-  <com.squareup.leakcanary.internal.MoreDetailsView
-      android:id="@+id/leak_canary_row_more"
-      android:layout_width="12dp"
-      android:layout_height="12dp"
-      android:layout_gravity="center_vertical"
-      android:layout_marginStart="16dp"
-      android:layout_marginEnd="16dp"
+  <TextView
+      android:id="@+id/leak_canary_row_details"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:visibility="gone"
       />
 
-</LinearLayout>
+</com.squareup.leakcanary.internal.RowElementLayout>
\ No newline at end of file
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml b/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
index c4803b76..4d70df54 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
@@ -21,7 +21,7 @@
     android:layout_height="wrap_content"
     android:layout_margin="16dp"
     android:textSize="18sp"
-    android:background="#84a6c5"
+    android:background="@color/leak_canary_class_name"
     android:padding="16dp"
-    android:textColor="#ffffff"
+    android:textColor="@color/leak_canary_background_color"
     />
diff --git a/leakcanary-android/src/main/res/mipmap-anydpi-v26/leak_canary_icon.xml b/leakcanary-android/src/main/res/mipmap-anydpi-v26/leak_canary_icon.xml
new file mode 100644
index 00000000..c58c886c
--- /dev/null
+++ b/leakcanary-android/src/main/res/mipmap-anydpi-v26/leak_canary_icon.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
+  <background android:drawable="@color/leak_canary_icon_background"/>
+  <foreground android:drawable="@drawable/leak_canary_icon_foreground"/>
+</adaptive-icon>
diff --git a/leakcanary-android/src/main/res/mipmap-hdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/mipmap-hdpi/leak_canary_icon.png
new file mode 100644
index 00000000..b1a69510
Binary files /dev/null and b/leakcanary-android/src/main/res/mipmap-hdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/mipmap-mdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/mipmap-mdpi/leak_canary_icon.png
new file mode 100644
index 00000000..304c0d3d
Binary files /dev/null and b/leakcanary-android/src/main/res/mipmap-mdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/mipmap-xhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/mipmap-xhdpi/leak_canary_icon.png
new file mode 100644
index 00000000..b79b532b
Binary files /dev/null and b/leakcanary-android/src/main/res/mipmap-xhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/mipmap-xxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/mipmap-xxhdpi/leak_canary_icon.png
new file mode 100644
index 00000000..950797ed
Binary files /dev/null and b/leakcanary-android/src/main/res/mipmap-xxhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/mipmap-xxxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/mipmap-xxxhdpi/leak_canary_icon.png
new file mode 100644
index 00000000..f0655aac
Binary files /dev/null and b/leakcanary-android/src/main/res/mipmap-xxxhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
index 2c784aec..4f69d615 100644
--- a/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
+++ b/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
@@ -14,12 +14,21 @@
   ~ limitations under the License.
   -->
 <resources>
-    <string name="leak_canary_class_has_leaked">%1$s hat %2$s geleaked</string>
-    <string name="leak_canary_leak_excluded">[Ausgeschlossen] %1$s hat %2$s geleaked</string>
+    <string name="leak_canary_class_has_leaked">%1$s hat geleaked</string>
+    <string name="leak_canary_class_has_leaked_retaining">%1$s hat %2$s geleaked</string>
+    <string name="leak_canary_leak_excluded">[Ausgeschlossen] %1$s hat geleaked</string>
+    <string name="leak_canary_leak_excluded_retaining">[Ausgeschlossen] %1$s hat %2$s geleaked</string>
     <string name="leak_canary_analysis_failed">Leak Analyse fehlgeschlagen</string>
     <string name="leak_canary_leak_list_title">Leaks in %s</string>
-    <string name="leak_canary_notification_message">Für mehr Details hier klicken</string>
+    <string name="leak_canary_notification_analysing">Analyisere Heap Dump</string>
     <string name="leak_canary_notification_channel">LeakCanary</string>
+    <string name="leak_canary_notification_dumping">Sichere Heap</string>
+    <string name="leak_canary_notification_foreground_text">LeakCanary ist beschäftigt.</string>
+    <string name="leak_canary_notification_message">Für mehr Details, hier klicken</string>
+    <string name="leak_canary_notification_reporting">Sichere LeakCanary Ergebnis</string>
+    <string name="leak_canary_result_failure_no_disk_space">Das Analyseergebnis konnte nicht gespeichert werden</string>
+    <string name="leak_canary_result_failure_no_file">Das Analyseergebnis konnte nicht aus dem Speicher geladen werden</string>
+    <string name="leak_canary_result_failure_title">Analysis result failure</string>
     <string name="leak_canary_share_leak">Info teilen</string>
     <string name="leak_canary_share_heap_dump">Heap Dump teilen</string>
     <string name="leak_canary_share_with">Teilen mit…</string>
@@ -30,7 +39,6 @@
     <string name="leak_canary_failure_report">"Bitte sende diesen Fehler an http://github.com/square/leakcanary\n"</string>
     <string name="leak_canary_delete_all">Alle löschen</string>
     <string name="leak_canary_delete_all_leaks_title">Bist du dir sicher, dass du alle Leaks löschen möchtest?</string>
-    <string name="leak_canary_could_not_save_title">Konnte Ergebnis nicht speichern.</string>
     <string name="leak_canary_could_not_save_text">LeakCanary konnte das Ergebnis der Analyse nicht speichern.</string>
     <string name="leak_canary_no_leak_title">Kein Leak gefunden</string>
     <string name="leak_canary_no_leak_text">Der GC war untätig.</string>
@@ -38,4 +46,25 @@
     <string name="leak_canary_permission_not_granted">Bitte gewähre die Storage Berechtigung, andernfalls werden Memory Leaks nicht erkannt.</string>
     <string name="leak_canary_permission_notification_title">Leak erkannt, benötige Berechtigung</string>
     <string name="leak_canary_permission_notification_text">Hier klicken, um Storage Berechtigung für %s zu aktivieren.</string>
+    <string name="leak_canary_help_title">Tippe hier, um mehr zu erfahren</string>
+    <string name="leak_canary_help_detail"><![CDATA[Ein Memory-Leak ist ein Programmierfehler der
+    dafür sorgt, dass deine Anwendung eine Referenz auf ein Objekt hält, das nicht länger benötigt
+    wird. Daraus folgt, dass der Speicher der dem Objekt zugewiesen wurde nicht wieder freigegeben
+    wird, was eventuell zu einem OutOfMemoryError-Absturz führt.<br>
+  <br>Eine Instanz einer Android-Activity wird nicht mehr benötigt, nachdem ihre <i>onDestroy()</i>
+  Methode aufgerufen wurde. Würde man eine Referenz auf diese Activity in einem statischen Feld
+  speichern, dann wird der durch die Activity genutzte Speicher nicht mehr durch den Garbage
+  Collector freigegeben.<br>
+  <br>
+  LeakCanary identifiziert ein Objekt, dass nicht länger benötigt wird und findet die Kette an
+  <font color=\'#9976a8\'>Referenzen</font> die es davon abhält seinen Speicher freizugeben.<br>
+  <br>
+  Um ein Memory-Leak zu beheben, musst du anhand der Kette herausfinden, welche Referenz für das
+  Leak verantwortlich ist, d.h. welche Referenz beim Auftreten des Leaks bereinigt sein soll.
+  LeakCanary hebt <b><u><font color=\'#9976a8\'>Referenzen</font></u></b> die mögliche Ursachen
+  für das Memory-Leak sein könnten mit einer roten Wellenlinie hervor.<br>
+  <br>
+  Tippe auf eine Zeile mit einer Referenz um mehr Details anzuzeigen, tippe noch einmal um die
+  Details zu schließen.
+]]></string>
 </resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_attrs.xml b/leakcanary-android/src/main/res/values/leak_canary_attrs.xml
new file mode 100644
index 00000000..092508ba
--- /dev/null
+++ b/leakcanary-android/src/main/res/values/leak_canary_attrs.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <declare-styleable name="leak_canary_MoreDetailsView">
+    <attr name="leak_canary_plus_color" format="color" />
+  </declare-styleable>
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_colors.xml b/leakcanary-android/src/main/res/values/leak_canary_colors.xml
new file mode 100644
index 00000000..2d44e384
--- /dev/null
+++ b/leakcanary-android/src/main/res/values/leak_canary_colors.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <color name="leak_canary_class_name">#bababa</color>
+  <color name="leak_canary_leak">#be383f</color>
+  <color name="leak_canary_reference">#9976a8</color>
+  <color name="leak_canary_extra">#919191</color>
+  <color name="leak_canary_help">#6a98b9</color>
+  <color name="leak_canary_background_color">#2b2b2b</color>
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_dimens.xml b/leakcanary-android/src/main/res/values/leak_canary_dimens.xml
new file mode 100644
index 00000000..f9cbdfb4
--- /dev/null
+++ b/leakcanary-android/src/main/res/values/leak_canary_dimens.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <dimen name="leak_canary_squiggly_span_stroke_width">1dp</dimen>
+  <dimen name="leak_canary_squiggly_span_amplitude">1dp</dimen>
+  <!-- DP because the period increased with the density. -->
+  <dimen name="leak_canary_squiggly_span_period_degrees">4dp</dimen>
+  <dimen name="leak_canary_connector_center_y">24dp</dimen>
+  <dimen name="leak_canary_connector_stroke_size">2dp</dimen>
+  <dimen name="leak_canary_connector_leak_dash_line">5dp</dimen>
+  <dimen name="leak_canary_connector_leak_dash_gap">1dp</dimen>
+  <dimen name="leak_canary_more_stroke_width">2dp</dimen>
+  <dimen name="leak_canary_connector_width">16dp</dimen>
+  <dimen name="leak_canary_row_margins">16dp</dimen>
+  <dimen name="leak_canary_more_size">12dp</dimen>
+  <dimen name="leak_canary_more_margin_top">18dp</dimen>
+  <dimen name="leak_canary_row_min">48dp</dimen>
+  <dimen name="leak_canary_row_title_margin_top">14.5dp</dimen>
+
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_icon_background.xml b/leakcanary-android/src/main/res/values/leak_canary_icon_background.xml
new file mode 100644
index 00000000..833b79dc
--- /dev/null
+++ b/leakcanary-android/src/main/res/values/leak_canary_icon_background.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <color name="leak_canary_icon_background">#3C3C3C</color>
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_public.xml b/leakcanary-android/src/main/res/values/leak_canary_public.xml
index 7e90f597..165c1738 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_public.xml
+++ b/leakcanary-android/src/main/res/values/leak_canary_public.xml
@@ -18,6 +18,6 @@
 
   <public name="leak_canary_display_activity_label" type="string"/>
   <public name="leak_canary_heap_dump_toast" type="layout"/>
-  <public name="leak_canary_icon" type="drawable"/>
+  <public name="leak_canary_icon" type="mipmap"/>
 
 </resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_strings.xml b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
index faef413c..ffed5076 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_strings.xml
+++ b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
@@ -15,12 +15,21 @@
   ~ limitations under the License.
   -->
 <resources>
-  <string name="leak_canary_class_has_leaked">%1$s leaked %2$s</string>
-  <string name="leak_canary_leak_excluded">[Excluded] %1$s leaked %2$s</string>
+  <string name="leak_canary_class_has_leaked">%1$s leaked</string>
+  <string name="leak_canary_class_has_leaked_retaining">%1$s leaked %2$s</string>
+  <string name="leak_canary_leak_excluded">[Excluded] %1$s leaked</string>
+  <string name="leak_canary_leak_excluded_retaining">[Excluded] %1$s leaked %2$s</string>
   <string name="leak_canary_analysis_failed">Leak analysis failed</string>
   <string name="leak_canary_leak_list_title">Leaks in %s</string>
-  <string name="leak_canary_notification_message">Click for more details</string>
+  <string name="leak_canary_notification_analysing">Analyzing Heap Dump</string>
   <string name="leak_canary_notification_channel">LeakCanary</string>
+  <string name="leak_canary_notification_dumping">Dumping Heap</string>
+  <string name="leak_canary_notification_foreground_text">LeakCanary is working.</string>
+  <string name="leak_canary_notification_message">Click for more details</string>
+  <string name="leak_canary_notification_reporting">Reporting LeakCanary result</string>
+  <string name="leak_canary_result_failure_no_disk_space">The analysis result could not be saved to disk</string>
+  <string name="leak_canary_result_failure_no_file">The analysis result could not be loaded from disk</string>
+  <string name="leak_canary_result_failure_title">Analysis result failure</string>
   <string name="leak_canary_share_leak">Share info</string>
   <string name="leak_canary_share_heap_dump">Share heap dump</string>
   <string name="leak_canary_share_with">Share with…</string>
@@ -28,10 +37,9 @@
   <string name="leak_canary_storage_permission_activity_label">Storage permission</string>
   <string name="leak_canary_toast_heap_dump">Dumping memory, app will freeze. Brrrr.</string>
   <string name="leak_canary_delete">Delete</string>
-  <string name="leak_canary_failure_report">"Please report this failure to http://github.com/square/leakcanary\n"</string>
+  <string name="leak_canary_failure_report">"Please report this failure to http://github.com/square/leakcanary and share the heapdump file that caused it.\n"</string>
   <string name="leak_canary_delete_all">Delete all</string>
   <string name="leak_canary_delete_all_leaks_title">Are you sure you want to delete all leaks?</string>
-  <string name="leak_canary_could_not_save_title">Could not save result.</string>
   <string name="leak_canary_could_not_save_text">LeakCanary was unable to save the analysis result.</string>
   <string name="leak_canary_no_leak_title">No leak found</string>
   <string name="leak_canary_no_leak_text">The GC was being lazy.</string>
@@ -39,4 +47,23 @@
   <string name="leak_canary_permission_not_granted">Please grant external storage permission, otherwise memory leaks will not be detected.</string>
   <string name="leak_canary_permission_notification_title">Leak detected, need permission</string>
   <string name="leak_canary_permission_notification_text">Click to enable storage permission for %s.</string>
+  <string name="leak_canary_help_title">Tap here to learn more</string>
+  <string name="leak_canary_help_detail"><![CDATA[A memory leak is a programming error that causes
+  your application to keep a reference to an object that is no longer needed. As a result, the
+  memory allocated for that object cannot be reclaimed, eventually leading to an OutOfMemoryError
+  crash.<br>
+  <br>For instance, an Android activity instance is no longer needed after its <i>onDestroy()</i>
+  method is called, and storing a reference to that activity in a static field would prevent it from
+  being garbage collected.<br>
+  <br>
+  LeakCanary identifies an object that is no longer needed and finds the chain of
+  <font color=\'#9976a8\'>references</font> that prevents it from being garbage collected.<br>
+  <br>
+  To fix a memory leak, you need to look at that chain and find which reference is causing the
+  leak, i.e. which reference should have been cleared at the time of the leak. LeakCanary highlights
+  with a red underline wave the <b><u><font color=\'#9976a8\'>references</font></u></b> that are the
+  possible causes of the leak.<br>
+  <br>
+  Tap on each reference row for more details, tap again to close.
+]]></string>
 </resources>
diff --git a/leakcanary-android/src/main/res/xml/leak_canary_file_paths.xml b/leakcanary-android/src/main/res/xml/leak_canary_file_paths.xml
new file mode 100644
index 00000000..05952829
--- /dev/null
+++ b/leakcanary-android/src/main/res/xml/leak_canary_file_paths.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<paths>
+  <external-path name="downloads" path="Download/" />
+  <files-path name="leakcanary" path="leakcanary/" />
+
+</paths>
diff --git a/leakcanary-sample/build.gradle b/leakcanary-sample/build.gradle
index d5105fe9..70b25c53 100644
--- a/leakcanary-sample/build.gradle
+++ b/leakcanary-sample/build.gradle
@@ -5,7 +5,11 @@ dependencies {
   releaseImplementation project(':leakcanary-android-no-op')
 
   testImplementation "junit:junit:4.12"
-  testImplementation "org.robolectric:robolectric:3.5.1"
+  testImplementation "org.robolectric:robolectric:4.0-alpha-3"
+  androidTestImplementation project(':leakcanary-android-instrumentation')
+  androidTestImplementation 'com.android.support.test:runner:1.0.2'
+  androidTestImplementation 'com.android.support.test:rules:1.0.2'
+  androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
 }
 
 android {
@@ -23,6 +27,9 @@ android {
 
     versionCode 1
     versionName "1.0"
+
+    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    testInstrumentationRunnerArgument "listener", "com.squareup.leakcanary.FailTestOnLeakRunListener"
   }
 
   buildTypes {
@@ -43,3 +50,15 @@ android {
     }
   }
 }
+
+// Instrumentation test dependencies resolve to 27.1.1 so we align the sample.
+configurations.all {
+  resolutionStrategy {
+    eachDependency { details ->
+      // Force all of the primary support libraries to use the same version.
+      if (details.requested.group == 'com.android.support') {
+        details.useVersion "27.1.1"
+      }
+    }
+  }
+}
diff --git a/leakcanary-sample/src/androidTest/AndroidManifest.xml b/leakcanary-sample/src/androidTest/AndroidManifest.xml
new file mode 100644
index 00000000..902375ba
--- /dev/null
+++ b/leakcanary-sample/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.leakcanary.instrumentation.test">
+
+  <application android:name="com.example.leakcanary.tests.InstrumentationExampleApplication">
+  </application>
+</manifest>
diff --git a/leakcanary-sample/src/androidTest/java/com/example/leakcanary/tests/InstrumentationExampleApplication.java b/leakcanary-sample/src/androidTest/java/com/example/leakcanary/tests/InstrumentationExampleApplication.java
new file mode 100644
index 00000000..b3233c00
--- /dev/null
+++ b/leakcanary-sample/src/androidTest/java/com/example/leakcanary/tests/InstrumentationExampleApplication.java
@@ -0,0 +1,12 @@
+package com.example.leakcanary.tests;
+
+import com.example.leakcanary.ExampleApplication;
+import com.squareup.leakcanary.InstrumentationLeakDetector;
+
+public class InstrumentationExampleApplication extends ExampleApplication {
+
+  @Override protected void setupLeakCanary() {
+    InstrumentationLeakDetector.instrumentationRefWatcher(this)
+        .buildAndInstall();
+  }
+}
diff --git a/leakcanary-sample/src/androidTest/java/com/example/leakcanary/tests/TuPeuxPasTest.java b/leakcanary-sample/src/androidTest/java/com/example/leakcanary/tests/TuPeuxPasTest.java
new file mode 100644
index 00000000..c96446a2
--- /dev/null
+++ b/leakcanary-sample/src/androidTest/java/com/example/leakcanary/tests/TuPeuxPasTest.java
@@ -0,0 +1,53 @@
+package com.example.leakcanary.tests;
+
+import android.support.test.rule.ActivityTestRule;
+import com.example.leakcanary.MainActivity;
+import com.example.leakcanary.R;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static android.support.test.espresso.Espresso.onView;
+import static android.support.test.espresso.action.ViewActions.click;
+import static android.support.test.espresso.assertion.ViewAssertions.matches;
+import static android.support.test.espresso.matcher.ViewMatchers.withId;
+import static android.support.test.espresso.matcher.ViewMatchers.withText;
+
+/**
+ * This UI test looks like it should succeed, but it will actually fail because
+ * it triggers a leak.
+ *
+ * Run this test with:
+ *
+ * ./gradlew leakcanary-sample:connectedCheck
+ *
+ * To set this up, we installed a special RefWatcher dedicated to detecting leaks in
+ * instrumentation tests in {@link InstrumentationExampleApplication}, and then added the FailTestOnLeakRunListener
+ * to the config of our build.gradle:
+ *
+ * testInstrumentationRunnerArgument "listener", "com.squareup.leakcanary.FailTestOnLeakRunListener"
+ *
+ *
+ * Why is this class named "TuPeuxPasTest"?
+ *
+ * This test fails, intentionally. In French, "Tu peux pas test" could mean "you cannot test"
+ * written with poor grammar. Except, that's not what it means.
+ * If you're curious, interested in French and have time to waste:
+ * https://www.youtube.com/watch?v=DZZpbmAc-0A
+ * https://www.youtube.com/watch?v=nHeAA6X-XUQ
+ */
+public class TuPeuxPasTest {
+
+  @Rule
+  public ActivityTestRule<MainActivity> activityRule = new ActivityTestRule<>(
+      MainActivity.class);
+
+  @Test
+  public void clickAsyncWork() {
+    onView(withId(R.id.async_work)).perform(click());
+  }
+
+  @Test
+  public void asyncButtonHasStartText() {
+    onView(withId(R.id.async_work)).check(matches(withText(R.string.start_async_work)));
+  }
+}
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
index 08cb841b..5f31c152 100644
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
@@ -26,12 +26,12 @@
   }
 
   protected void setupLeakCanary() {
+    enabledStrictMode();
     if (LeakCanary.isInAnalyzerProcess(this)) {
       // This process is dedicated to LeakCanary for heap analysis.
       // You should not init your app in this process.
       return;
     }
-    enabledStrictMode();
     LeakCanary.install(this);
   }
 
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/HttpRequestHelper.java b/leakcanary-sample/src/main/java/com/example/leakcanary/HttpRequestHelper.java
new file mode 100644
index 00000000..58569fe9
--- /dev/null
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/HttpRequestHelper.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.leakcanary;
+
+import android.view.View;
+
+/**
+ * Fake class for the purpose of demonstrating a leak.
+ */
+public class HttpRequestHelper {
+
+  private final View button;
+
+  HttpRequestHelper(View button) {
+    this.button = button;
+  }
+}
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
index e51f5a9a..93a43378 100644
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
@@ -17,37 +17,47 @@
 
 import android.annotation.SuppressLint;
 import android.app.Activity;
-import android.os.AsyncTask;
 import android.os.Bundle;
 import android.os.SystemClock;
 import android.view.View;
 
 public class MainActivity extends Activity {
 
+  private HttpRequestHelper httpRequestHelper;
+
   @Override protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     setContentView(R.layout.main_activity);
 
-    View button = findViewById(R.id.async_task);
+    View button = findViewById(R.id.async_work);
     button.setOnClickListener(new View.OnClickListener() {
       @Override public void onClick(View v) {
-        startAsyncTask();
+        startAsyncWork();
       }
     });
+
+    httpRequestHelper = (HttpRequestHelper) getLastNonConfigurationInstance();
+    if (httpRequestHelper == null) {
+      httpRequestHelper = new HttpRequestHelper(button);
+    }
+  }
+
+  @Override public Object onRetainNonConfigurationInstance() {
+    return httpRequestHelper;
   }
 
   @SuppressLint("StaticFieldLeak")
-  void startAsyncTask() {
-    // This async task is an anonymous class and therefore has a hidden reference to the outer
-    // class MainActivity. If the activity gets destroyed before the task finishes (e.g. rotation),
+  void startAsyncWork() {
+    // This runnable is an anonymous class and therefore has a hidden reference to the outer
+    // class MainActivity. If the activity gets destroyed before the thread finishes (e.g. rotation),
     // the activity instance will leak.
-    new AsyncTask<Void, Void, Void>() {
-      @Override protected Void doInBackground(Void... params) {
+    Runnable work = new Runnable() {
+      @Override public void run() {
         // Do some slow work in background
         SystemClock.sleep(20000);
-        return null;
       }
-    }.execute();
+    };
+    new Thread(work).start();
   }
 }
 
diff --git a/leakcanary-sample/src/main/res/layout/main_activity.xml b/leakcanary-sample/src/main/res/layout/main_activity.xml
index 2dc62d61..3e63f8d4 100644
--- a/leakcanary-sample/src/main/res/layout/main_activity.xml
+++ b/leakcanary-sample/src/main/res/layout/main_activity.xml
@@ -30,10 +30,10 @@
       />
 
   <Button
-      android:id="@+id/async_task"
+      android:id="@+id/async_work"
       android:layout_width="match_parent"
       android:layout_height="wrap_content"
-      android:text="@string/start_async_task"
+      android:text="@string/start_async_work"
       />
 
 </LinearLayout>
\ No newline at end of file
diff --git a/leakcanary-sample/src/main/res/values/strings.xml b/leakcanary-sample/src/main/res/values/strings.xml
index 8aa73b33..4d896835 100644
--- a/leakcanary-sample/src/main/res/values/strings.xml
+++ b/leakcanary-sample/src/main/res/values/strings.xml
@@ -18,9 +18,8 @@
     xmlns:tools="http://schemas.android.com/tools"
     tools:ignore="MissingTranslation" >
   <string name="app_name">LeakCanary Sample</string>
-  <string name="start_async_task">Start new AsyncTask</string>
-  <string name="helper_text">Start the async task, <b>rotate the screen</b> and wait for a bit. A
-    wild notification appears.
-  </string>
+  <string name="start_async_work">Start new async work</string>
+  <string name="helper_text">There are two example leaks you can trigger: 1) Rotate the screen and
+    wait. 2) Start the async work, <b>rotate the screen</b> and wait.</string>
   <string name="leak_canary_display_activity_label">Leaks Sample</string>
 </resources>
\ No newline at end of file
diff --git a/leakcanary-sample/src/test/java/com/example/leakcanary/SampleTest.java b/leakcanary-sample/src/test/java/com/example/leakcanary/SampleTest.java
index 960cfedb..29f1f367 100644
--- a/leakcanary-sample/src/test/java/com/example/leakcanary/SampleTest.java
+++ b/leakcanary-sample/src/test/java/com/example/leakcanary/SampleTest.java
@@ -8,12 +8,12 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(constants = BuildConfig.class, application = TestExampleApplication.class)
+@Config(application = TestExampleApplication.class)
 public class SampleTest {
   @Test public void testTheThing() throws Exception {
     ActivityController<MainActivity> controller =
         Robolectric.buildActivity(MainActivity.class).create().start().resume().visible();
-    controller.get().findViewById(R.id.async_task).performClick();
+    controller.get().findViewById(R.id.async_work).performClick();
     controller.stop();
     controller.destroy();
   }
diff --git a/leakcanary-support-fragment/build.gradle b/leakcanary-support-fragment/build.gradle
new file mode 100644
index 00000000..79abea3e
--- /dev/null
+++ b/leakcanary-support-fragment/build.gradle
@@ -0,0 +1,34 @@
+apply plugin: 'com.android.library'
+
+dependencies {
+  api project(':leakcanary-android')
+  // 25.1.0 is the version that introduced https://developer.android.com/reference/android/support/v4/app/FragmentManager#registerfragmentlifecyclecallbacks
+  // However, FragmentLifecycleCallbacks wasn't properly usable until 25.2.0 where it became static
+  // https://developer.android.com/topic/libraries/support-library/rev-archive#fixed-issues_12
+  // For mysterious reasons we get a NoClassDefFoundError (FragmentActivity) if we use a version
+  // lower than 26.0.0.
+  //noinspection GradleDependency
+  implementation 'com.android.support:support-fragment:26.0.0'
+
+  androidTestImplementation project(':leakcanary-android-instrumentation')
+  androidTestImplementation 'com.android.support.test:runner:1.0.2'
+  androidTestImplementation 'com.android.support.test:rules:1.0.2'
+  androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
+}
+
+android {
+  compileSdkVersion versions.compileSdk
+  defaultConfig {
+    minSdkVersion versions.minSdk
+
+    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+  }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    // junit references java.lang.management
+    ignore 'InvalidPackage'
+  }
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-support-fragment/gradle.properties b/leakcanary-support-fragment/gradle.properties
new file mode 100644
index 00000000..426b0187
--- /dev/null
+++ b/leakcanary-support-fragment/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-support-fragment
+POM_NAME=LeakCanary extension to watch Android support fragments
+POM_PACKAGING=aar
\ No newline at end of file
diff --git a/leakcanary-support-fragment/src/androidTest/AndroidManifest.xml b/leakcanary-support-fragment/src/androidTest/AndroidManifest.xml
new file mode 100644
index 00000000..d12071a3
--- /dev/null
+++ b/leakcanary-support-fragment/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.leakcanary.support.fragment.test">
+
+  <application android:name="com.squareup.leakcanary.tests.InstrumentationTestApplication">
+
+    <activity android:name="com.squareup.leakcanary.tests.TestActivity"/>
+
+  </application>
+</manifest>
diff --git a/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/FragmentLeakTest.java b/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/FragmentLeakTest.java
new file mode 100644
index 00000000..e3811b5c
--- /dev/null
+++ b/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/FragmentLeakTest.java
@@ -0,0 +1,123 @@
+package com.squareup.leakcanary.tests;
+
+import android.app.Activity;
+import android.app.Application;
+import android.content.Context;
+import android.os.Bundle;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.rule.ActivityTestRule;
+import android.view.View;
+import com.squareup.leakcanary.InstrumentationLeakDetector;
+import com.squareup.leakcanary.InstrumentationLeakResults;
+import com.squareup.leakcanary.LeakCanary;
+import com.squareup.leakcanary.internal.ActivityLifecycleCallbacksAdapter;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static com.squareup.leakcanary.tests.Fragments.waitForFragmentDetached;
+import static com.squareup.leakcanary.tests.Fragments.waitForFragmentViewDestroyed;
+
+public class FragmentLeakTest {
+
+  private static final boolean TOUCH_MODE = true;
+  private static final boolean LAUNCH_ACTIVITY = true;
+
+  @Rule
+  public ActivityTestRule<TestActivity> activityRule =
+      new ActivityTestRule<>(TestActivity.class, !TOUCH_MODE, !LAUNCH_ACTIVITY);
+
+  @Before public void setUp() {
+    LeakCanary.installedRefWatcher().clearWatchedReferences();
+  }
+
+  @After public void tearDown() {
+    LeakCanary.installedRefWatcher().clearWatchedReferences();
+  }
+
+  @Test
+  public void fragmentShouldLeak() throws InterruptedException {
+    startActivityAndWaitForCreate();
+
+    LeakingFragment.add(activityRule.getActivity());
+
+    CountDownLatch waitForFragmentDetach = waitForFragmentDetached(activityRule.getActivity());
+    activityRule.finishActivity();
+    waitForFragmentDetach.await();
+
+    assertLeak(LeakingFragment.class);
+  }
+
+  @Test
+  public void fragmentViewShouldLeak() throws InterruptedException {
+    startActivityAndWaitForCreate();
+    TestActivity activity = activityRule.getActivity();
+
+    CountDownLatch waitForFragmentViewDestroyed = waitForFragmentViewDestroyed(activity);
+    // First, add a new fragment
+    ViewLeakingFragment.addToBackstack(activity);
+    // Then, add a new fragment again, which destroys the view of the previous fragment and puts
+    // that fragment in the backstack.
+    ViewLeakingFragment.addToBackstack(activity);
+    waitForFragmentViewDestroyed.await();
+
+    assertLeak(View.class);
+  }
+
+  private void startActivityAndWaitForCreate() {
+    final CountDownLatch waitForActivityOnCreate = new CountDownLatch(1);
+    final Application app =
+        (Application) InstrumentationRegistry.getTargetContext().getApplicationContext();
+    app.registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacksAdapter() {
+      @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
+        app.unregisterActivityLifecycleCallbacks(this);
+        waitForActivityOnCreate.countDown();
+      }
+    });
+
+    activityRule.launchActivity(null);
+
+    try {
+      waitForActivityOnCreate.await();
+    } catch (InterruptedException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  private void assertLeak(Class<?> expectedLeakClass) {
+    InstrumentationLeakDetector leakDetector = new InstrumentationLeakDetector();
+    InstrumentationLeakResults results = leakDetector.detectLeaks();
+
+    if (results.detectedLeaks.size() != 1) {
+      throw new AssertionError(
+          "Expected exactly one leak, not " + results.detectedLeaks.size() + resultsAsString(
+              results.detectedLeaks));
+    }
+
+    InstrumentationLeakResults.Result firstResult = results.detectedLeaks.get(0);
+
+    String leakingClassName = firstResult.analysisResult.className;
+
+    if (!leakingClassName.equals(expectedLeakClass.getName())) {
+      throw new AssertionError(
+          "Expected a leak of " + expectedLeakClass + ", not " + leakingClassName + resultsAsString(
+              results.detectedLeaks));
+    }
+  }
+
+  private String resultsAsString(List<InstrumentationLeakResults.Result> results) {
+    Context context = InstrumentationRegistry.getTargetContext();
+    StringBuilder message = new StringBuilder();
+    message.append("\nLeaks found:\n##################\n");
+    for (InstrumentationLeakResults.Result detectedLeak : results) {
+      message.append(
+          LeakCanary.leakInfo(context, detectedLeak.heapDump, detectedLeak.analysisResult,
+              false));
+    }
+    message.append("\n##################\n");
+    return message.toString();
+  }
+}
diff --git a/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/Fragments.java b/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/Fragments.java
new file mode 100644
index 00000000..a8f0cc31
--- /dev/null
+++ b/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/Fragments.java
@@ -0,0 +1,39 @@
+package com.squareup.leakcanary.tests;
+
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+import java.util.concurrent.CountDownLatch;
+
+public final class Fragments {
+
+  public static CountDownLatch waitForFragmentDetached(FragmentActivity activity) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    final FragmentManager fragmentManager = activity.getSupportFragmentManager();
+    fragmentManager.registerFragmentLifecycleCallbacks(
+        new FragmentManager.FragmentLifecycleCallbacks() {
+          @Override public void onFragmentDetached(FragmentManager fm, Fragment f) {
+            fragmentManager.unregisterFragmentLifecycleCallbacks(this);
+            latch.countDown();
+          }
+        }, false);
+    return latch;
+  }
+
+  public static CountDownLatch waitForFragmentViewDestroyed(FragmentActivity activity) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    final FragmentManager fragmentManager = activity.getSupportFragmentManager();
+    fragmentManager.registerFragmentLifecycleCallbacks(
+        new FragmentManager.FragmentLifecycleCallbacks() {
+          @Override public void onFragmentViewDestroyed(FragmentManager fm, Fragment f) {
+            fragmentManager.unregisterFragmentLifecycleCallbacks(this);
+            latch.countDown();
+          }
+        }, false);
+    return latch;
+  }
+
+  private Fragments() {
+    throw new AssertionError();
+  }
+}
diff --git a/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/InstrumentationTestApplication.java b/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/InstrumentationTestApplication.java
new file mode 100644
index 00000000..bd0321f5
--- /dev/null
+++ b/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/InstrumentationTestApplication.java
@@ -0,0 +1,12 @@
+package com.squareup.leakcanary.tests;
+
+import android.app.Application;
+import com.squareup.leakcanary.InstrumentationLeakDetector;
+
+public class InstrumentationTestApplication extends Application {
+  @Override public void onCreate() {
+    super.onCreate();
+    InstrumentationLeakDetector.instrumentationRefWatcher(this)
+        .buildAndInstall();
+  }
+}
diff --git a/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/LeakingFragment.java b/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/LeakingFragment.java
new file mode 100644
index 00000000..e549835b
--- /dev/null
+++ b/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/LeakingFragment.java
@@ -0,0 +1,21 @@
+package com.squareup.leakcanary.tests;
+
+import android.support.test.InstrumentationRegistry;
+import android.support.v4.app.Fragment;
+
+public class LeakingFragment extends Fragment {
+
+  public static void add(final TestActivity activity) {
+    InstrumentationRegistry.getInstrumentation().runOnMainSync(new Runnable() {
+      @Override public void run() {
+        leakingFragment = new LeakingFragment();
+        activity.getSupportFragmentManager()
+            .beginTransaction()
+            .add(0, leakingFragment)
+            .commitNow();
+      }
+    });
+  }
+
+  private static LeakingFragment leakingFragment;
+}
diff --git a/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/TestActivity.java b/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/TestActivity.java
new file mode 100644
index 00000000..85210092
--- /dev/null
+++ b/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/TestActivity.java
@@ -0,0 +1,14 @@
+package com.squareup.leakcanary.tests;
+
+import android.os.Bundle;
+import android.support.annotation.Nullable;
+import android.support.v4.app.FragmentActivity;
+import com.squareup.leakcanary.support.fragment.R;
+
+public class TestActivity extends FragmentActivity {
+
+  @Override protected void onCreate(@Nullable Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.activity_test);
+  }
+}
diff --git a/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/ViewLeakingFragment.java b/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/ViewLeakingFragment.java
new file mode 100644
index 00000000..16ac9b3a
--- /dev/null
+++ b/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/ViewLeakingFragment.java
@@ -0,0 +1,38 @@
+package com.squareup.leakcanary.tests;
+
+import android.os.Bundle;
+import android.support.test.InstrumentationRegistry;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import com.squareup.leakcanary.support.fragment.R;
+
+public class ViewLeakingFragment extends Fragment {
+
+  public static void addToBackstack(final TestActivity activity) {
+    InstrumentationRegistry.getInstrumentation().runOnMainSync(new Runnable() {
+      @Override public void run() {
+        activity.getSupportFragmentManager()
+            .beginTransaction()
+            .addToBackStack(null)
+            .replace(R.id.fragments, new ViewLeakingFragment())
+            .commit();
+      }
+    });
+  }
+
+  private View leakingView;
+
+  @Override public View onCreateView(LayoutInflater inflater, ViewGroup container,
+      Bundle savedInstanceState) {
+    return new View(container.getContext());
+  }
+
+  @Override
+  public void onViewCreated(View view, Bundle savedInstanceState) {
+    // Leak: this fragment will stay in memory after being replaced, leakingView should be cleared
+    // onDestroyView()
+    leakingView = view;
+  }
+}
diff --git a/leakcanary-support-fragment/src/main/AndroidManifest.xml b/leakcanary-support-fragment/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..41a07002
--- /dev/null
+++ b/leakcanary-support-fragment/src/main/AndroidManifest.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest package="com.squareup.leakcanary.support.fragment">
+
+  <application>
+  </application>
+</manifest>
diff --git a/leakcanary-support-fragment/src/main/java/com/squareup/leakcanary/internal/SupportFragmentRefWatcher.java b/leakcanary-support-fragment/src/main/java/com/squareup/leakcanary/internal/SupportFragmentRefWatcher.java
new file mode 100644
index 00000000..ad8b85e2
--- /dev/null
+++ b/leakcanary-support-fragment/src/main/java/com/squareup/leakcanary/internal/SupportFragmentRefWatcher.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import android.app.Activity;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+import android.view.View;
+import com.squareup.leakcanary.RefWatcher;
+
+class SupportFragmentRefWatcher implements FragmentRefWatcher {
+  private final RefWatcher refWatcher;
+
+  SupportFragmentRefWatcher(RefWatcher refWatcher) {
+    this.refWatcher = refWatcher;
+  }
+
+  private final FragmentManager.FragmentLifecycleCallbacks fragmentLifecycleCallbacks =
+      new FragmentManager.FragmentLifecycleCallbacks() {
+
+        @Override public void onFragmentViewDestroyed(FragmentManager fm, Fragment fragment) {
+          View view = fragment.getView();
+          if (view != null) {
+            refWatcher.watch(view);
+          }
+        }
+
+        @Override public void onFragmentDestroyed(FragmentManager fm, Fragment fragment) {
+          refWatcher.watch(fragment);
+        }
+      };
+
+  @Override public void watchFragments(Activity activity) {
+    if (activity instanceof FragmentActivity) {
+      FragmentManager supportFragmentManager =
+          ((FragmentActivity) activity).getSupportFragmentManager();
+      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true);
+    }
+  }
+}
diff --git a/leakcanary-support-fragment/src/main/res/layout/activity_test.xml b/leakcanary-support-fragment/src/main/res/layout/activity_test.xml
new file mode 100644
index 00000000..39664a73
--- /dev/null
+++ b/leakcanary-support-fragment/src/main/res/layout/activity_test.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/fragments"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    />
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
index 8beade52..ff5afad0 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
@@ -27,7 +27,7 @@
       // https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
       // java/lang/ref/FinalizationTester.java
       // System.gc() does not garbage collect every time. Runtime.gc() is
-      // more likely to perfom a gc.
+      // more likely to perform a gc.
       Runtime.getRuntime().gc();
       enqueueReferences();
       System.runFinalization();
@@ -45,4 +45,4 @@ private void enqueueReferences() {
   };
 
   void runGc();
-}
\ No newline at end of file
+}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
index ee201585..14041244 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
@@ -17,12 +17,19 @@
 
 import java.io.File;
 import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
 
 import static com.squareup.leakcanary.Preconditions.checkNotNull;
+import static java.util.Collections.unmodifiableList;
 
 /** Data structure holding information about a heap dump. */
 public final class HeapDump implements Serializable {
 
+  public static Builder builder() {
+    return new Builder();
+  }
+
   /** Receives a heap dump to analyze. */
   public interface Listener {
     Listener NONE = new Listener() {
@@ -57,15 +64,132 @@
   public final long watchDurationMs;
   public final long gcDurationMs;
   public final long heapDumpDurationMs;
+  public final boolean computeRetainedHeapSize;
+  public final List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses;
 
+  /**
+   * Calls {@link #HeapDump(Builder)} with computeRetainedHeapSize set to true.
+   *
+   * @deprecated Use {@link #HeapDump(Builder)}  instead.
+   */
+  @Deprecated
   public HeapDump(File heapDumpFile, String referenceKey, String referenceName,
       ExcludedRefs excludedRefs, long watchDurationMs, long gcDurationMs, long heapDumpDurationMs) {
-    this.heapDumpFile = checkNotNull(heapDumpFile, "heapDumpFile");
-    this.referenceKey = checkNotNull(referenceKey, "referenceKey");
-    this.referenceName = checkNotNull(referenceName, "referenceName");
-    this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
-    this.watchDurationMs = watchDurationMs;
-    this.gcDurationMs = gcDurationMs;
-    this.heapDumpDurationMs = heapDumpDurationMs;
+    this(new Builder().heapDumpFile(heapDumpFile)
+        .referenceKey(referenceKey)
+        .referenceName(referenceName)
+        .excludedRefs(excludedRefs)
+        .computeRetainedHeapSize(true)
+        .watchDurationMs(watchDurationMs)
+        .gcDurationMs(gcDurationMs)
+        .heapDumpDurationMs(heapDumpDurationMs));
+  }
+
+  HeapDump(Builder builder) {
+    this.heapDumpFile = builder.heapDumpFile;
+    this.referenceKey = builder.referenceKey;
+    this.referenceName = builder.referenceName;
+    this.excludedRefs = builder.excludedRefs;
+    this.computeRetainedHeapSize = builder.computeRetainedHeapSize;
+    this.watchDurationMs = builder.watchDurationMs;
+    this.gcDurationMs = builder.gcDurationMs;
+    this.heapDumpDurationMs = builder.heapDumpDurationMs;
+    this.reachabilityInspectorClasses = builder.reachabilityInspectorClasses;
+  }
+
+  public Builder buildUpon() {
+    return new Builder(this);
+  }
+
+  public static final class Builder {
+    File heapDumpFile;
+    String referenceKey;
+    String referenceName;
+    ExcludedRefs excludedRefs;
+    long watchDurationMs;
+    long gcDurationMs;
+    long heapDumpDurationMs;
+    boolean computeRetainedHeapSize;
+    List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses;
+
+    Builder() {
+      this.heapDumpFile = null;
+      this.referenceKey = null;
+      referenceName = "";
+      excludedRefs = null;
+      watchDurationMs = 0;
+      gcDurationMs = 0;
+      heapDumpDurationMs = 0;
+      computeRetainedHeapSize = false;
+      reachabilityInspectorClasses = null;
+    }
+
+    Builder(HeapDump heapDump) {
+      this.heapDumpFile = heapDump.heapDumpFile;
+      this.referenceKey = heapDump.referenceKey;
+      this.referenceName = heapDump.referenceName;
+      this.excludedRefs = heapDump.excludedRefs;
+      this.computeRetainedHeapSize = heapDump.computeRetainedHeapSize;
+      this.watchDurationMs = heapDump.watchDurationMs;
+      this.gcDurationMs = heapDump.gcDurationMs;
+      this.heapDumpDurationMs = heapDump.heapDumpDurationMs;
+      this.reachabilityInspectorClasses = heapDump.reachabilityInspectorClasses;
+    }
+
+    public Builder heapDumpFile(File heapDumpFile) {
+      this.heapDumpFile = checkNotNull(heapDumpFile, "heapDumpFile");
+      return this;
+    }
+
+    public Builder referenceKey(String referenceKey) {
+      this.referenceKey = checkNotNull(referenceKey, "referenceKey");
+      return this;
+    }
+
+    public Builder referenceName(String referenceName) {
+      this.referenceName = checkNotNull(referenceName, "referenceName");
+      return this;
+    }
+
+    public Builder excludedRefs(ExcludedRefs excludedRefs) {
+      this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
+      return this;
+    }
+
+    public Builder watchDurationMs(long watchDurationMs) {
+      this.watchDurationMs = watchDurationMs;
+      return this;
+    }
+
+    public Builder gcDurationMs(long gcDurationMs) {
+      this.gcDurationMs = gcDurationMs;
+      return this;
+    }
+
+    public Builder heapDumpDurationMs(long heapDumpDurationMs) {
+      this.heapDumpDurationMs = heapDumpDurationMs;
+      return this;
+    }
+
+    public Builder computeRetainedHeapSize(boolean computeRetainedHeapSize) {
+      this.computeRetainedHeapSize = computeRetainedHeapSize;
+      return this;
+    }
+
+    public Builder reachabilityInspectorClasses(
+        List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses) {
+      checkNotNull(reachabilityInspectorClasses, "reachabilityInspectorClasses");
+      this.reachabilityInspectorClasses =
+          unmodifiableList(new ArrayList<>(reachabilityInspectorClasses));
+      return this;
+    }
+
+    public HeapDump build() {
+      checkNotNull(excludedRefs, "excludedRefs");
+      checkNotNull(heapDumpFile, "heapDumpFile");
+      checkNotNull(referenceKey, "referenceKey");
+      checkNotNull(reachabilityInspectorClasses, "reachabilityInspectorClasses");
+      return new HeapDump(this);
+    }
   }
 }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/LeakReference.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/LeakReference.java
new file mode 100644
index 00000000..824e329b
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/LeakReference.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import java.io.Serializable;
+
+/**
+ * A single field in a {@link LeakTraceElement}.
+ */
+public final class LeakReference implements Serializable {
+
+  public final LeakTraceElement.Type type;
+  public final String name;
+  public final String value;
+
+  public LeakReference(LeakTraceElement.Type type, String name, String value) {
+    this.type = type;
+    this.name = name;
+    this.value = value;
+  }
+
+  public String getDisplayName() {
+    switch (type) {
+      case ARRAY_ENTRY:
+        return "[" + name + "]";
+      case STATIC_FIELD:
+      case INSTANCE_FIELD:
+        return name;
+      case LOCAL:
+        return "<Java Local>";
+      default:
+        throw new IllegalStateException(
+            "Unexpected type " + type + " name = " + name + " value = " + value);
+    }
+  }
+
+  @Override public String toString() {
+    switch (type) {
+      case ARRAY_ENTRY:
+      case INSTANCE_FIELD:
+        return getDisplayName() + " = " + value;
+      case STATIC_FIELD:
+        return "static " + getDisplayName() + " = " + value;
+      case LOCAL:
+        return getDisplayName();
+      default:
+        throw new IllegalStateException(
+            "Unexpected type " + type + " name = " + name + " value = " + value);
+    }
+  }
+}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/LeakTraceElement.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
new file mode 100644
index 00000000..2a73dfe8
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
+import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
+import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
+import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
+import static java.util.Collections.unmodifiableList;
+import static java.util.Locale.US;
+
+/** Represents one reference in the chain of references that holds a leaking object in memory. */
+public final class LeakTraceElement implements Serializable {
+
+  public enum Type {
+    INSTANCE_FIELD, STATIC_FIELD, LOCAL, ARRAY_ENTRY
+  }
+
+  public enum Holder {
+    OBJECT, CLASS, THREAD, ARRAY
+  }
+
+  /**
+   * Information about the reference that points to the next {@link LeakTraceElement} in the leak
+   * chain. Null if this is the last element in the leak trace, ie the leaking object.
+   */
+  public final LeakReference reference;
+
+  /**
+   * @deprecated Use {@link #reference} and {@link LeakReference#getDisplayName()} instead.
+   * Null if this is the last element in the leak trace, ie the leaking object.
+   */
+  @Deprecated
+  public final String referenceName;
+
+  /**
+   * @deprecated Use {@link #reference} and {@link LeakReference#type} instead.
+   * Null if this is the last element in the leak trace, ie the leaking object.
+   */
+  @Deprecated
+  public final Type type;
+
+  public final Holder holder;
+
+  /**
+   * Class hierarchy for that object. The first element is {@link #className}. {@link Object}
+   * is excluded. There is always at least one element.
+   */
+  public final List<String> classHierarchy;
+
+  public final String className;
+
+  /** Additional information, may be null. */
+  public final String extra;
+
+  /** If not null, there was no path that could exclude this element. */
+  public final Exclusion exclusion;
+
+  /** List of all fields (member and static) for that object. */
+  public final List<LeakReference> fieldReferences;
+
+  /**
+   * @deprecated Use {@link #fieldReferences} instead.
+   */
+  @Deprecated
+  public final List<String> fields;
+
+  LeakTraceElement(LeakReference reference, Holder holder, List<String> classHierarchy,
+      String extra, Exclusion exclusion, List<LeakReference> leakReferences) {
+    this.reference = reference;
+    this.referenceName = reference == null ? null : reference.getDisplayName();
+    this.type = reference == null ? null : reference.type;
+    this.holder = holder;
+    this.classHierarchy = Collections.unmodifiableList(new ArrayList<>(classHierarchy));
+    this.className = classHierarchy.get(0);
+    this.extra = extra;
+    this.exclusion = exclusion;
+    this.fieldReferences = unmodifiableList(new ArrayList<>(leakReferences));
+    List<String> stringFields = new ArrayList<>();
+    for (LeakReference leakReference : leakReferences) {
+      stringFields.add(leakReference.toString());
+    }
+    fields = Collections.unmodifiableList(stringFields);
+  }
+
+  /**
+   * Returns the string value of the first field reference that has the provided referenceName, or
+   * null if no field reference with that name was found.
+   */
+  public String getFieldReferenceValue(String referenceName) {
+    for (LeakReference fieldReference : fieldReferences) {
+      if (fieldReference.name.equals(referenceName)) {
+        return fieldReference.value;
+      }
+    }
+    return null;
+  }
+
+  /** @see #isInstanceOf(String) */
+  public boolean isInstanceOf(Class<?> expectedClass) {
+    return isInstanceOf(expectedClass.getName());
+  }
+
+  /**
+   * Returns true if this element is an instance of the provided class name, false otherwise.
+   */
+  public boolean isInstanceOf(String expectedClassName) {
+    for (String className : classHierarchy) {
+      if (className.equals(expectedClassName)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Returns {@link #className} without the package.
+   */
+  public String getSimpleClassName() {
+    int separator = className.lastIndexOf('.');
+    if (separator == -1) {
+      return className;
+    } else {
+      return className.substring(separator + 1);
+    }
+  }
+
+  @Override public String toString() {
+    return toString(false);
+  }
+
+  public String toString(boolean maybeLeakCause) {
+    String string = "";
+
+    if (reference != null && reference.type == STATIC_FIELD) {
+      string += "static ";
+    }
+
+    if (holder == ARRAY || holder == THREAD) {
+      string += holder.name().toLowerCase(US) + " ";
+    }
+
+    string += getSimpleClassName();
+
+    if (reference != null) {
+      String referenceName = reference.getDisplayName();
+      if (maybeLeakCause) {
+        referenceName = "!(" + referenceName + ")!";
+      }
+      string += "." + referenceName;
+    }
+
+    if (extra != null) {
+      string += " " + extra;
+    }
+
+    if (exclusion != null) {
+      string += " , matching exclusion " + exclusion.matching;
+    }
+
+    return string;
+  }
+
+  public String toDetailedString() {
+    String string = "* ";
+    if (holder == ARRAY) {
+      string += "Array of";
+    } else if (holder == CLASS) {
+      string += "Class";
+    } else {
+      string += "Instance of";
+    }
+    string += " " + className + "\n";
+    for (LeakReference leakReference : fieldReferences) {
+      string += "|   " + leakReference + "\n";
+    }
+    return string;
+  }
+}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Reachability.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Reachability.java
new file mode 100644
index 00000000..ea46c4d1
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Reachability.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+/** Result returned by {@link Inspector#expectedReachability(LeakTraceElement)}. */
+public enum Reachability {
+  /** The instance was needed and therefore expected to be reachable. */
+  REACHABLE,
+
+  /** The instance was no longer needed and therefore expected to be unreachable. */
+  UNREACHABLE,
+
+  /** No decision can be made about the provided instance. */
+  UNKNOWN;
+
+  /**
+   * Evaluates whether a {@link LeakTraceElement} should be reachable or not.
+   *
+   * Implementations should have a public zero argument constructor as instances will be created
+   * via reflection in the LeakCanary analysis process.
+   */
+  public interface Inspector {
+
+    Reachability expectedReachability(LeakTraceElement element);
+  }
+}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
index 8a01a472..c3d27a1c 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
@@ -17,6 +17,7 @@
 
 import java.io.File;
 import java.lang.ref.ReferenceQueue;
+import java.util.HashSet;
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.CopyOnWriteArraySet;
@@ -41,19 +42,19 @@
   private final DebuggerControl debuggerControl;
   private final GcTrigger gcTrigger;
   private final HeapDumper heapDumper;
+  private final HeapDump.Listener heapdumpListener;
+  private final HeapDump.Builder heapDumpBuilder;
   private final Set<String> retainedKeys;
   private final ReferenceQueue<Object> queue;
-  private final HeapDump.Listener heapdumpListener;
-  private final ExcludedRefs excludedRefs;
 
   RefWatcher(WatchExecutor watchExecutor, DebuggerControl debuggerControl, GcTrigger gcTrigger,
-      HeapDumper heapDumper, HeapDump.Listener heapdumpListener, ExcludedRefs excludedRefs) {
+      HeapDumper heapDumper, HeapDump.Listener heapdumpListener, HeapDump.Builder heapDumpBuilder) {
     this.watchExecutor = checkNotNull(watchExecutor, "watchExecutor");
     this.debuggerControl = checkNotNull(debuggerControl, "debuggerControl");
     this.gcTrigger = checkNotNull(gcTrigger, "gcTrigger");
     this.heapDumper = checkNotNull(heapDumper, "heapDumper");
     this.heapdumpListener = checkNotNull(heapdumpListener, "heapdumpListener");
-    this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
+    this.heapDumpBuilder = heapDumpBuilder;
     retainedKeys = new CopyOnWriteArraySet<>();
     queue = new ReferenceQueue<>();
   }
@@ -89,6 +90,27 @@ public void watch(Object watchedReference, String referenceName) {
     ensureGoneAsync(watchStartNanoTime, reference);
   }
 
+  /**
+   * LeakCanary will stop watching any references that were passed to {@link #watch(Object, String)}
+   * so far.
+   */
+  public void clearWatchedReferences() {
+    retainedKeys.clear();
+  }
+
+  boolean isEmpty() {
+    removeWeaklyReachableReferences();
+    return retainedKeys.isEmpty();
+  }
+
+  HeapDump.Builder getHeapDumpBuilder() {
+    return heapDumpBuilder;
+  }
+
+  Set<String> getRetainedKeys() {
+    return new HashSet<>(retainedKeys);
+  }
+
   private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {
     watchExecutor.execute(new Retryable() {
       @Override public Retryable.Result run() {
@@ -123,9 +145,15 @@ private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakRefer
         return RETRY;
       }
       long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);
-      heapdumpListener.analyze(
-          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,
-              gcDurationMs, heapDumpDurationMs));
+
+      HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)
+          .referenceName(reference.name)
+          .watchDurationMs(watchDurationMs)
+          .gcDurationMs(gcDurationMs)
+          .heapDumpDurationMs(heapDumpDurationMs)
+          .build();
+
+      heapdumpListener.analyze(heapDump);
     }
     return DONE;
   }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
index b4c9eb33..866e35c4 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
@@ -1,17 +1,24 @@
 package com.squareup.leakcanary;
 
+import java.util.Collections;
+import java.util.List;
+
 /**
  * Responsible for building {@link RefWatcher} instances. Subclasses should provide sane defaults
  * for the platform they support.
  */
 public class RefWatcherBuilder<T extends RefWatcherBuilder<T>> {
 
-  private ExcludedRefs excludedRefs;
   private HeapDump.Listener heapDumpListener;
   private DebuggerControl debuggerControl;
   private HeapDumper heapDumper;
   private WatchExecutor watchExecutor;
   private GcTrigger gcTrigger;
+  private final HeapDump.Builder heapDumpBuilder;
+
+  public RefWatcherBuilder() {
+    heapDumpBuilder = new HeapDump.Builder();
+  }
 
   /** @see HeapDump.Listener */
   public final T heapDumpListener(HeapDump.Listener heapDumpListener) {
@@ -21,7 +28,7 @@ public final T heapDumpListener(HeapDump.Listener heapDumpListener) {
 
   /** @see ExcludedRefs */
   public final T excludedRefs(ExcludedRefs excludedRefs) {
-    this.excludedRefs = excludedRefs;
+    heapDumpBuilder.excludedRefs(excludedRefs);
     return self();
   }
 
@@ -49,15 +56,30 @@ public final T gcTrigger(GcTrigger gcTrigger) {
     return self();
   }
 
+  /** @see Reachability.Inspector */
+  public final T stethoscopeClasses(
+      List<Class<? extends Reachability.Inspector>> stethoscopeClasses) {
+    heapDumpBuilder.reachabilityInspectorClasses(stethoscopeClasses);
+    return self();
+  }
+
+  /**
+   * Whether LeakCanary should compute the retained heap size when a leak is detected. False by
+   * default, because computing the retained heap size takes a long time.
+   */
+  public final T computeRetainedHeapSize(boolean computeRetainedHeapSize) {
+    heapDumpBuilder.computeRetainedHeapSize(computeRetainedHeapSize);
+    return self();
+  }
+
   /** Creates a {@link RefWatcher}. */
   public final RefWatcher build() {
     if (isDisabled()) {
       return RefWatcher.DISABLED;
     }
 
-    ExcludedRefs excludedRefs = this.excludedRefs;
-    if (excludedRefs == null) {
-      excludedRefs = defaultExcludedRefs();
+    if (heapDumpBuilder.excludedRefs == null) {
+      heapDumpBuilder.excludedRefs(defaultExcludedRefs());
     }
 
     HeapDump.Listener heapDumpListener = this.heapDumpListener;
@@ -85,8 +107,12 @@ public final RefWatcher build() {
       gcTrigger = defaultGcTrigger();
     }
 
+    if (heapDumpBuilder.reachabilityInspectorClasses == null) {
+      heapDumpBuilder.reachabilityInspectorClasses(defaultReachabilityInspectorClasses());
+    }
+
     return new RefWatcher(watchExecutor, debuggerControl, gcTrigger, heapDumper, heapDumpListener,
-        excludedRefs);
+        heapDumpBuilder);
   }
 
   protected boolean isDisabled() {
@@ -117,6 +143,10 @@ protected WatchExecutor defaultWatchExecutor() {
     return WatchExecutor.NONE;
   }
 
+  protected List<Class<? extends Reachability.Inspector>> defaultReachabilityInspectorClasses() {
+    return Collections.emptyList();
+  }
+
   @SuppressWarnings("unchecked")
   protected final T self() {
     return (T) this;
diff --git a/settings.gradle b/settings.gradle
index 73da17f3..688c3347 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -2,4 +2,6 @@ include ':leakcanary-watcher'
 include ':leakcanary-analyzer'
 include ':leakcanary-android'
 include ':leakcanary-android-no-op'
+include ':leakcanary-android-instrumentation'
 include ':leakcanary-sample'
+include ':leakcanary-support-fragment'
