diff --git a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
index 8916c887..a6b0bc89 100644
--- a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
+++ b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
@@ -82,7 +82,7 @@ class RefWatcher constructor(
     if (!isEnabled()) {
       return
     }
-    removeWeaklyReachableReferences()
+    removeWeaklyReachableReferences() // 首先清空引用队列 queue
     val key = UUID.randomUUID()
         .toString()
     val watchUptimeMillis = clock.uptimeMillis()
@@ -106,7 +106,7 @@ class RefWatcher constructor(
   }
 
   @Synchronized private fun moveToRetained(key: String) {
-    removeWeaklyReachableReferences()
+    removeWeaklyReachableReferences() // 再次调用，防止遗漏
     val retainedRef = watchedReferences.remove(key)
     if (retainedRef != null) {
       retainedReferences[key] = retainedRef
@@ -126,14 +126,16 @@ class RefWatcher constructor(
   private fun removeWeaklyReachableReferences() {
     // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
     // reachable. This is before finalization or garbage collection has actually happened.
+    // 弱引用一旦变得弱可达，就会立即入队。这将在 finalization 或者 GC 之前发生。
     var ref: KeyedWeakReference?
     do {
-      ref = queue.poll() as KeyedWeakReference?
+      ref = queue.poll() as KeyedWeakReference? // 队列 queue 中的对象都是会被 GC 的
       if (ref != null) {
         val removedRef = watchedReferences.remove(ref.key)
         if (removedRef == null) {
           retainedReferences.remove(ref.key)
         }
+        // 移除 watchedReferences 队列中的会被 GC 的 ref 对象，剩下的就是可能泄露的对象
       }
     } while (ref != null)
   }
