diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakTraceInspectors.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidObjectInspectors.kt
similarity index 68%
rename from leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakTraceInspectors.kt
rename to leakcanary-analyzer/src/main/java/leakcanary/AndroidObjectInspectors.kt
index 8706daae..658b4126 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakTraceInspectors.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AndroidObjectInspectors.kt
@@ -20,7 +20,7 @@ import leakcanary.GraphObjectRecord.GraphInstanceRecord
 import kotlin.reflect.KClass
 
 /**
- * A set of default [LeakInspector]s that knows about common AOSP and library
+ * A set of default [ObjectInspector]s that knows about common AOSP and library
  * classes.
  *
  * These are heuristics based on our experience and knowledge of AOSP and various library
@@ -30,14 +30,14 @@ import kotlin.reflect.KClass
  * For example, no matter how many mistakes we make in our code, the value of Activity.mDestroy
  * will not be influenced by those mistakes.
  */
-enum class AndroidLeakTraceInspectors : LeakTraceInspector {
+enum class AndroidObjectInspectors : ObjectInspector {
 
   VIEW {
     override fun inspect(
       graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
+      reporter: ObjectReporter
     ) {
-      leakTrace.forEachInstanceOf("android.view.View") { instance ->
+      reporter.asInstance("android.view.View") { instance ->
         // This skips edge cases like Toast$TN.mNextView holding on to an unattached and unparented
         // next toast view
         val mParentRef = instance["android.view.View", "mParent"]!!.value
@@ -48,9 +48,10 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
           if (viewDetached) {
             reportLeaking("View detached and has parent")
           } else {
-            val viewParent = mParentRef.readObjectRecord()!!.asInstance!!
+            val viewParent = mParentRef.asObject!!.asInstance!!
             if (viewParent instanceOf "android.view.View" &&
-                viewParent["android.view.View", "mAttachInfo"]!!.value.isNullReference) {
+                viewParent["android.view.View", "mAttachInfo"]!!.value.isNullReference
+            ) {
               reportLeaking("View attached but parent detached (attach disorder)")
             } else {
               reportNotLeaking("View attached")
@@ -84,9 +85,9 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
   ACTIVITY {
     override fun inspect(
       graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
+      reporter: ObjectReporter
     ) {
-      leakTrace.forEachInstanceOf("android.app.Activity") { instance ->
+      reporter.asInstance("android.app.Activity") { instance ->
         // Activity.mDestroyed was introduced in 17.
         // https://android.googlesource.com/platform/frameworks/base/+
         // /6d9dcbccec126d9b87ab6587e686e28b87e5a04d
@@ -106,9 +107,9 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
   CONTEXT_WRAPPER {
     override fun inspect(
       graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
+      reporter: ObjectReporter
     ) {
-      leakTrace.forEachInstanceOf("android.content.ContextWrapper") { instance ->
+      reporter.asInstance("android.content.ContextWrapper") { instance ->
         // Activity is already taken care of
         if (!(instance instanceOf "android.app.Activity")) {
           var context = instance
@@ -116,12 +117,12 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
           val visitedInstances = mutableListOf<Long>()
           var keepUnwrapping = true
           while (keepUnwrapping) {
-            visitedInstances += context.record.id
+            visitedInstances += context.objectId
             keepUnwrapping = false
             val mBase = context["android.content.ContextWrapper", "mBase"]!!.value
 
             if (mBase.isNonNullReference) {
-              context = mBase.readObjectRecord()!!.asInstance!!
+              context = mBase.asObject!!.asInstance!!
               if (context instanceOf "android.app.Activity") {
                 val mDestroyed = instance["android.app.Activity", "mDestroyed"]
                 if (mDestroyed != null) {
@@ -132,12 +133,14 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
                   } else {
                     // We can't assume it's not leaking, because this context might have a shorter lifecycle
                     // than the activity. So we'll just add a label.
-                    addLabel("${instance.classSimpleName} wraps an Activity with Activity.mDestroyed false")
+                    addLabel(
+                        "${instance.classSimpleName} wraps an Activity with Activity.mDestroyed false"
+                    )
                   }
                 }
               } else if (context instanceOf "android.content.ContextWrapper" &&
                   // Avoids infinite loops
-                  context.record.id !in visitedInstances
+                  context.objectId !in visitedInstances
               ) {
                 keepUnwrapping = true
               }
@@ -151,9 +154,9 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
   DIALOG {
     override fun inspect(
       graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
+      reporter: ObjectReporter
     ) {
-      leakTrace.forEachInstanceOf("android.app.Dialog") { instance ->
+      reporter.asInstance("android.app.Dialog") { instance ->
         val mDecor = instance["android.app.Dialog", "mDecor"]!!
         if (mDecor.value.isNullReference) {
           reportLeaking(mDecor describedWithValue "null")
@@ -167,9 +170,9 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
   APPLICATION {
     override fun inspect(
       graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
+      reporter: ObjectReporter
     ) {
-      leakTrace.forEachInstanceOf("android.app.Application") {
+      reporter.asInstance("android.app.Application") {
         reportNotLeaking("Application is a singleton")
       }
     }
@@ -178,9 +181,9 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
   INPUT_METHOD_MANAGER {
     override fun inspect(
       graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
+      reporter: ObjectReporter
     ) {
-      leakTrace.forEachInstanceOf("android.view.inputmethod.InputMethodManager") {
+      reporter.asInstance("android.view.inputmethod.InputMethodManager") {
         reportNotLeaking("InputMethodManager is a singleton")
       }
     }
@@ -189,9 +192,9 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
   CLASSLOADER {
     override fun inspect(
       graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
+      reporter: ObjectReporter
     ) {
-      leakTrace.forEachInstanceOf(ClassLoader::class) {
+      reporter.asInstance(ClassLoader::class) {
         reportNotLeaking("A ClassLoader is never leaking")
       }
     }
@@ -200,12 +203,10 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
   CLASS {
     override fun inspect(
       graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
+      reporter: ObjectReporter
     ) {
-      leakTrace.forEach { reporter ->
-        if (reporter.objectRecord is GraphClassRecord) {
-          reporter.reportNotLeaking("a class is never leaking")
-        }
+      if (reporter.objectRecord is GraphClassRecord) {
+        reporter.reportNotLeaking("a class is never leaking")
       }
     }
   },
@@ -213,9 +214,9 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
   FRAGMENT {
     override fun inspect(
       graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
+      reporter: ObjectReporter
     ) {
-      leakTrace.forEachInstanceOf("android.app.Fragment") { instance ->
+      reporter.asInstance("android.app.Fragment") { instance ->
         val fragmentManager = instance["android.app.Fragment", "mFragmentManager"]!!
         if (fragmentManager.value.isNullReference) {
           reportLeaking(fragmentManager describedWithValue "null")
@@ -233,9 +234,9 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
   SUPPORT_FRAGMENT {
     override fun inspect(
       graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
+      reporter: ObjectReporter
     ) {
-      leakTrace.forEachInstanceOf("android.support.v4.app.Fragment") { instance ->
+      reporter.asInstance("android.support.v4.app.Fragment") { instance ->
         val fragmentManager = instance["android.support.v4.app.Fragment", "mFragmentManager"]!!
         if (fragmentManager.value.isNullReference) {
           reportLeaking(fragmentManager describedWithValue "null")
@@ -253,9 +254,9 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
   ANDROIDX_FRAGMENT {
     override fun inspect(
       graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
+      reporter: ObjectReporter
     ) {
-      leakTrace.forEachInstanceOf("androidx.fragment.app.Fragment") { instance ->
+      reporter.asInstance("androidx.fragment.app.Fragment") { instance ->
         val fragmentManager = instance["androidx.fragment.app.Fragment", "mFragmentManager"]!!
         if (fragmentManager.value.isNullReference) {
           reportLeaking(fragmentManager describedWithValue "null")
@@ -273,9 +274,9 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
   MESSAGE_QUEUE {
     override fun inspect(
       graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
+      reporter: ObjectReporter
     ) {
-      leakTrace.forEachInstanceOf("android.os.MessageQueue") { instance ->
+      reporter.asInstance("android.os.MessageQueue") { instance ->
         val mQuitting = instance["android.os.MessageQueue", "mQuitting"]!!
         if (mQuitting.value.asBoolean!!) {
           reportLeaking(mQuitting describedWithValue "true")
@@ -289,9 +290,9 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
   MORTAR_PRESENTER {
     override fun inspect(
       graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
+      reporter: ObjectReporter
     ) {
-      leakTrace.forEachInstanceOf("mortar.Presenter") { instance ->
+      reporter.asInstance("mortar.Presenter") { instance ->
         // Bugs in view code tends to cause Mortar presenters to still have a view when they actually
         // should be unreachable, so in that case we don't know their reachability status. However,
         // when the view is null, we're pretty sure they  never leaking.
@@ -306,9 +307,9 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
   COORDINATOR {
     override fun inspect(
       graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
+      reporter: ObjectReporter
     ) {
-      leakTrace.forEachInstanceOf("com.squareup.coordinators.Coordinator") { instance ->
+      reporter.asInstance("com.squareup.coordinators.Coordinator") { instance ->
         val attached = instance["com.squareup.coordinators.Coordinator", "attached"]
         if (attached!!.value.asBoolean!!) {
           reportNotLeaking(attached describedWithValue "true")
@@ -322,34 +323,32 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
   ANONYMOUS_CLASS {
     override fun inspect(
       graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
+      reporter: ObjectReporter
     ) {
-      leakTrace.forEach { reporter ->
-        if (reporter.objectRecord is GraphInstanceRecord) {
-          val classRecord = reporter.objectRecord.readClass()
-          if (classRecord.name.matches(HeapAnalyzer.ANONYMOUS_CLASS_NAME_PATTERN_REGEX)) {
-            val parentClassRecord = classRecord.readSuperClass()!!
-            if (parentClassRecord.name == "java.lang.Object") {
-              try {
-                // This is an anonymous class implementing an interface. The API does not give access
-                // to the interfaces implemented by the class. We check if it's in the class path and
-                // use that instead.
-                val actualClass = Class.forName(classRecord.name)
-                val interfaces = actualClass.interfaces
-                reporter.addLabel(
-                    if (interfaces.isNotEmpty()) {
-                      val implementedInterface = interfaces[0]
-                      "Anonymous class implementing ${implementedInterface.name}"
-                    } else {
-                      "Anonymous subclass of java.lang.Object"
-                    }
-                )
-              } catch (ignored: ClassNotFoundException) {
-              }
-            } else {
-              // Makes it easier to figure out which anonymous class we're looking at.
-              reporter.addLabel("Anonymous subclass of ${parentClassRecord.name}")
+      if (reporter.objectRecord is GraphInstanceRecord) {
+        val classRecord = reporter.objectRecord.instanceClass
+        if (classRecord.name.matches(HeapAnalyzer.ANONYMOUS_CLASS_NAME_PATTERN_REGEX)) {
+          val parentClassRecord = classRecord.superClass!!
+          if (parentClassRecord.name == "java.lang.Object") {
+            try {
+              // This is an anonymous class implementing an interface. The API does not give access
+              // to the interfaces implemented by the class. We check if it's in the class path and
+              // use that instead.
+              val actualClass = Class.forName(classRecord.name)
+              val interfaces = actualClass.interfaces
+              reporter.addLabel(
+                  if (interfaces.isNotEmpty()) {
+                    val implementedInterface = interfaces[0]
+                    "Anonymous class implementing ${implementedInterface.name}"
+                  } else {
+                    "Anonymous subclass of java.lang.Object"
+                  }
+              )
+            } catch (ignored: ClassNotFoundException) {
             }
+          } else {
+            // Makes it easier to figure out which anonymous class we're looking at.
+            reporter.addLabel("Anonymous subclass of ${parentClassRecord.name}")
           }
         }
       }
@@ -359,9 +358,9 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
   THREAD {
     override fun inspect(
       graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
+      reporter: ObjectReporter
     ) {
-      leakTrace.forEachInstanceOf(Thread::class) { instance ->
+      reporter.asInstance(Thread::class) { instance ->
         val threadName = instance[Thread::class, "name"]!!.value.readAsJavaString()
         if (threadName == "main") {
           reportNotLeaking("the main thread always runs")
@@ -374,9 +373,9 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
   WINDOW {
     override fun inspect(
       graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
+      reporter: ObjectReporter
     ) {
-      leakTrace.forEachInstanceOf("android.view.Window") { instance ->
+      reporter.asInstance("android.view.Window") { instance ->
         val mDestroyed = instance["android.view.Window", "mDestroyed"]!!
 
         if (mDestroyed.value.asBoolean!!) {
@@ -391,11 +390,11 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
   TOAST {
     override fun inspect(
       graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
+      reporter: ObjectReporter
     ) {
-      leakTrace.forEachInstanceOf("android.widget.Toast") { instance ->
+      reporter.asInstance("android.widget.Toast") { instance ->
         val tnInstance =
-          instance["android.widget.Toast", "mTN"]!!.value.readObjectRecord()!!.asInstance!!
+          instance["android.widget.Toast", "mTN"]!!.value.asObject!!.asInstance!!
         // mWM is set in android.widget.Toast.TN#handleShow and never unset, so this toast was never
         // shown, we don't know if it's leaking.
         if (tnInstance["android.widget.Toast\$TN", "mWM"]!!.value.isNonNullReference) {
@@ -417,16 +416,16 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
   TOAST_TN {
     override fun inspect(
       graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
+      reporter: ObjectReporter
     ) {
-      leakTrace.forEachInstanceOf("android.widget.Toast\$TN") {
+      reporter.asInstance("android.widget.Toast\$TN") {
         reportNotLeaking("Toast.TN (Transient Notification) is never leaking")
       }
     }
   };
 
   companion object {
-    fun defaultInspectors(): List<LeakTraceInspector> {
+    fun defaultInspectors(): List<ObjectInspector> {
       return values().toList()
     }
   }
@@ -436,20 +435,18 @@ private infix fun GraphField.describedWithValue(valueDescription: String): Strin
   return "${classRecord.simpleName}#$name is $valueDescription"
 }
 
-inline fun List<LeakTraceElementReporter>.forEachInstanceOf(
+inline fun ObjectReporter.asInstance(
   expectedClass: KClass<out Any>,
-  action: LeakTraceElementReporter.(GraphInstanceRecord) -> Unit
+  action: ObjectReporter.(GraphInstanceRecord) -> Unit
 ) {
-  forEachInstanceOf(expectedClass.java.name, action)
+  asInstance(expectedClass.java.name, action)
 }
 
-inline fun List<LeakTraceElementReporter>.forEachInstanceOf(
+inline fun ObjectReporter.asInstance(
   className: String,
-  action: LeakTraceElementReporter.(GraphInstanceRecord) -> Unit
+  block: ObjectReporter.(GraphInstanceRecord) -> Unit
 ) {
-  for (reporter in this) {
-    if (reporter.objectRecord is GraphInstanceRecord && reporter.objectRecord instanceOf className) {
-      reporter.action(reporter.objectRecord)
-    }
+  if (objectRecord is GraphInstanceRecord && objectRecord instanceOf className) {
+    block(objectRecord)
   }
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AppSingletonInspector.kt b/leakcanary-analyzer/src/main/java/leakcanary/AppSingletonInspector.kt
index 50f30c0d..f68b3a55 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/AppSingletonInspector.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AppSingletonInspector.kt
@@ -6,21 +6,19 @@ import leakcanary.GraphObjectRecord.GraphInstanceRecord
  * Inspector that automatically marks instances of the provided class names as not leaking
  * because they're app wide singletons.
  */
-class AppSingletonInspector(private vararg val singletonClasses: String) : LeakTraceInspector {
+class AppSingletonInspector(private vararg val singletonClasses: String) : ObjectInspector {
   override fun inspect(
     graph: HprofGraph,
-    leakTrace: List<LeakTraceElementReporter>
+    reporter: ObjectReporter
   ) {
-    leakTrace.forEach { reporter ->
-      if (reporter.objectRecord is GraphInstanceRecord) {
-        reporter.objectRecord.readClass()
-            .readClassHierarchy()
-            .forEach { classRecord ->
-              if (classRecord.name in singletonClasses) {
-                reporter.reportNotLeaking("${classRecord.name} is an app singleton")
-              }
+    if (reporter.objectRecord is GraphInstanceRecord) {
+      reporter.objectRecord.instanceClass
+          .classHierarchy
+          .forEach { classRecord ->
+            if (classRecord.name in singletonClasses) {
+              reporter.reportNotLeaking("${classRecord.name} is an app singleton")
             }
-      }
+          }
     }
   }
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/BuildMirror.kt b/leakcanary-analyzer/src/main/java/leakcanary/BuildMirror.kt
index bbf4d947..3cdfab9c 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/BuildMirror.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/BuildMirror.kt
@@ -14,8 +14,8 @@ class BuildMirror {
 
   fun wrapFilter(filter: BuildFilter): (HprofGraph) -> Boolean = { graph ->
     if (!::manufacturer.isInitialized) {
-      val buildClass = graph.readClass("android.os.Build")!!
-      val versionClass = graph.readClass("android.os.Build\$VERSION")!!
+      val buildClass = graph.indexedClass("android.os.Build")!!
+      val versionClass = graph.indexedClass("android.os.Build\$VERSION")!!
       manufacturer = buildClass["MANUFACTURER"]!!.value.readAsJavaString()!!
       sdkInt = versionClass["SDK_INT"]!!.value.asInt!!
     }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
index be6c36a7..d1b55154 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
@@ -35,8 +35,9 @@ import leakcanary.GraphObjectRecord.GraphClassRecord
 import leakcanary.GraphObjectRecord.GraphInstanceRecord
 import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
 import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
-import leakcanary.HprofParser.RecordCallbacks
+import leakcanary.HprofPushRecordsParser.OnRecordListener
 import leakcanary.LeakNode.ChildNode
+import leakcanary.LeakNode.RootNode
 import leakcanary.LeakNodeStatus.LEAKING
 import leakcanary.LeakNodeStatus.NOT_LEAKING
 import leakcanary.LeakNodeStatus.UNKNOWN
@@ -44,29 +45,27 @@ import leakcanary.LeakTraceElement.Holder.ARRAY
 import leakcanary.LeakTraceElement.Holder.CLASS
 import leakcanary.LeakTraceElement.Holder.OBJECT
 import leakcanary.LeakTraceElement.Holder.THREAD
+import leakcanary.PrimitiveType.BOOLEAN
+import leakcanary.PrimitiveType.BYTE
+import leakcanary.PrimitiveType.CHAR
+import leakcanary.PrimitiveType.DOUBLE
+import leakcanary.PrimitiveType.FLOAT
+import leakcanary.PrimitiveType.INT
+import leakcanary.PrimitiveType.LONG
+import leakcanary.PrimitiveType.SHORT
 import leakcanary.Record.HeapDumpRecord.GcRootRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
 import leakcanary.internal.KeyedWeakReferenceMirror
 import leakcanary.internal.ShortestPathFinder
 import leakcanary.internal.ShortestPathFinder.Result
 import leakcanary.internal.ShortestPathFinder.Results
 import leakcanary.internal.hppc.LongLongScatterMap
 import leakcanary.internal.lastSegment
+import java.io.Closeable
 import java.io.File
 import java.util.ArrayList
 import java.util.LinkedHashMap
 import java.util.concurrent.TimeUnit.NANOSECONDS
+import kotlin.reflect.KClass
 
 /**
  * Analyzes heap dumps to look for leaks.
@@ -83,7 +82,7 @@ class HeapAnalyzer constructor(
     heapDumpFile: File,
     exclusions: List<Exclusion> = emptyList(),
     computeRetainedHeapSize: Boolean = false,
-    leakTraceInspectors: List<LeakTraceInspector> = emptyList()
+    objectInspectors: List<ObjectInspector> = emptyList()
   ): HeapAnalysis {
     val analysisStartNanoTime = System.nanoTime()
 
@@ -98,50 +97,48 @@ class HeapAnalyzer constructor(
     listener.onProgressUpdate(READING_HEAP_DUMP_FILE)
 
     try {
-      HprofParser.open(heapDumpFile)
-          .use { parser ->
-            val graph = HprofGraph(parser)
-            listener.onProgressUpdate(SCANNING_HEAP_DUMP)
-            val (gcRootIds, keyedWeakReferenceInstances, cleaners) = scan(
-                parser, graph, computeRetainedHeapSize
-            )
-            val analysisResults = mutableMapOf<String, RetainedInstance>()
-            listener.onProgressUpdate(FINDING_WATCHED_REFERENCES)
-
-            val retainedWeakRefs = findLeakingReferences(graph, keyedWeakReferenceInstances)
-
-            if (retainedWeakRefs.isEmpty()) {
-              val exception = IllegalStateException("No retained instances found in heap dump")
-              return HeapAnalysisFailure(
-                  heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
-                  HeapAnalysisException(exception)
-              )
-            }
+      listener.onProgressUpdate(SCANNING_HEAP_DUMP)
+      val (graph, hprofCloseable, gcRootIds, keyedWeakReferenceInstances, cleaners) = scan(
+          heapDumpFile, computeRetainedHeapSize
+      )
+      hprofCloseable.use {
+        val analysisResults = mutableMapOf<String, RetainedInstance>()
+        listener.onProgressUpdate(FINDING_WATCHED_REFERENCES)
 
-            val (pathResults, dominatedInstances) =
-              findShortestPaths(
-                  graph, exclusions, retainedWeakRefs, gcRootIds,
-                  computeRetainedHeapSize
-              )
+        val retainedWeakRefs = findLeakingReferences(graph, keyedWeakReferenceInstances)
 
-            val retainedSizes = if (computeRetainedHeapSize) {
-              computeRetainedSizes(graph, pathResults, dominatedInstances, cleaners)
-            } else {
-              null
-            }
+        if (retainedWeakRefs.isEmpty()) {
+          val exception = IllegalStateException("No retained instances found in heap dump")
+          return HeapAnalysisFailure(
+              heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
+              HeapAnalysisException(exception)
+          )
+        }
+
+        val (pathResults, dominatedInstances) =
+          findShortestPaths(
+              graph, exclusions, retainedWeakRefs, gcRootIds,
+              computeRetainedHeapSize
+          )
+
+        val retainedSizes = if (computeRetainedHeapSize) {
+          computeRetainedSizes(graph, pathResults, dominatedInstances, cleaners)
+        } else {
+          null
+        }
 
-            buildLeakTraces(
-                leakTraceInspectors, pathResults, graph,
-                retainedWeakRefs, analysisResults, retainedSizes
-            )
+        buildLeakTraces(
+            objectInspectors, pathResults, graph,
+            retainedWeakRefs, analysisResults, retainedSizes
+        )
 
-            addRemainingInstancesWithNoPath(retainedWeakRefs, analysisResults)
+        addRemainingInstancesWithNoPath(retainedWeakRefs, analysisResults)
 
-            return HeapAnalysisSuccess(
-                heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
-                analysisResults.values.toList()
-            )
-          }
+        return HeapAnalysisSuccess(
+            heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
+            analysisResults.values.toList()
+        )
+      }
     } catch (exception: Throwable) {
       return HeapAnalysisFailure(
           heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
@@ -151,58 +148,74 @@ class HeapAnalyzer constructor(
   }
 
   private data class ScanResult(
+    val graph: HprofGraph,
+    val hprofCloseable: Closeable,
     val gcRootIds: MutableList<GcRoot>,
     val keyedWeakReferenceInstances: List<GraphInstanceRecord>,
     val cleaners: MutableList<Long>
   )
 
   private fun scan(
-    parser: HprofParser,
-    graph: HprofGraph,
+    hprofFile: File,
     computeRetainedSize: Boolean
   ): ScanResult {
-    val keyedWeakReferenceInstances = mutableListOf<GraphInstanceRecord>()
     val gcRoot = mutableListOf<GcRoot>()
     val cleaners = mutableListOf<Long>()
-    val callbacks = RecordCallbacks()
-        .on(InstanceDumpRecord::class.java) { record ->
-          when (parser.className(record.classId)) {
-            KeyedWeakReference::class.java.name -> keyedWeakReferenceInstances.add(
-                GraphInstanceRecord(graph, record)
-            )
-            // Pre 2.0 KeyedWeakReference
-            "com.squareup.leakcanary.KeyedWeakReference" -> keyedWeakReferenceInstances.add(
-                GraphInstanceRecord(graph, record)
-            )
-            "sun.misc.Cleaner" -> if (computeRetainedSize) cleaners.add(record.id)
+
+    val recordListener = object : OnRecordListener {
+      override fun recordTypes(): Set<KClass<out Record>> = setOf(GcRootRecord::class)
+
+      override fun onTypeSizesAvailable(typeSizes: Map<Int, Int>) {
+      }
+
+      override fun onRecord(
+        position: Long,
+        record: Record
+      ) {
+        when (record) {
+          is GcRootRecord -> {
+            // TODO Ignoring VmInternal because we've got 150K of it, but is this the right thing
+            // to do? What's VmInternal exactly? History does not go further than
+            // https://android.googlesource.com/platform/dalvik2/+/refs/heads/master/hit/src/com/android/hit/HprofParser.java#77
+            // We should log to figure out what objects VmInternal points to.
+            when (record.gcRoot) {
+              // ThreadObject points to threads, which we need to find the thread that a JavaLocalExclusion
+              // belongs to
+              is ThreadObject,
+              is JniGlobal,
+              is JniLocal,
+              is JavaFrame,
+              is NativeStack,
+              is StickyClass,
+              is ThreadBlock,
+              is MonitorUsed,
+                // TODO What is this and why do we care about it as a root?
+              is ReferenceCleanup,
+              is JniMonitor
+              -> {
+                gcRoot.add(record.gcRoot)
+              }
+            }
+          }
+          else -> {
+            throw IllegalArgumentException("Unexpected record $record")
           }
         }
-        .on(GcRootRecord::class.java) {
-          // TODO Ignoring VmInternal because we've got 150K of it, but is this the right thing
-          // to do? What's VmInternal exactly? History does not go further than
-          // https://android.googlesource.com/platform/dalvik2/+/refs/heads/master/hit/src/com/android/hit/HprofParser.java#77
-          // We should log to figure out what objects VmInternal points to.
-          when (it.gcRoot) {
-            // ThreadObject points to threads, which we need to find the thread that a JavaLocalExclusion
-            // belongs to
-            is ThreadObject,
-            is JniGlobal,
-            is JniLocal,
-            is JavaFrame,
-            is NativeStack,
-            is StickyClass,
-            is ThreadBlock,
-            is MonitorUsed,
-              // TODO What is this and why do we care about it as a root?
-            is ReferenceCleanup,
-            is JniMonitor
-            -> {
-              gcRoot.add(it.gcRoot)
-            }
+      }
+    }
+    val (graph, hprofCloseable) = HprofGraph.readHprof(hprofFile, recordListener)
+
+    val keyedWeakReferenceInstances = mutableListOf<GraphInstanceRecord>()
+    graph.instanceSequence()
+        .forEach { instance ->
+          val className = instance.className
+          if (className == "leakcanary.KeyedWeakReference" || className == "com.squareup.leakcanary.KeyedWeakReference") {
+            keyedWeakReferenceInstances.add(instance)
+          } else if (computeRetainedSize && className == "sun.misc.Cleaner") {
+            cleaners.add(instance.objectId)
           }
         }
-    parser.scan(callbacks)
-    return ScanResult(gcRoot, keyedWeakReferenceInstances, cleaners)
+    return ScanResult(graph, hprofCloseable, gcRoot, keyedWeakReferenceInstances, cleaners)
   }
 
   private fun findLeakingReferences(
@@ -210,7 +223,7 @@ class HeapAnalyzer constructor(
     keyedWeakReferenceInstances: List<GraphInstanceRecord>
   ): MutableList<KeyedWeakReferenceMirror> {
 
-    val keyedWeakReferenceClass = graph.readClass(KeyedWeakReference::class.java.name)
+    val keyedWeakReferenceClass = graph.indexedClass(KeyedWeakReference::class.java.name)
 
     val heapDumpUptimeMillis = if (keyedWeakReferenceClass == null) {
       null
@@ -270,18 +283,18 @@ class HeapAnalyzer constructor(
     // the CleanerThunk. The hprof does not include the native bytes pointed to.
 
     cleaners.forEach { objectId ->
-      val cleaner = graph.readGraphObjectRecord(objectId).asInstance!!
+      val cleaner = graph.indexedObject(objectId).asInstance!!
       val thunkField = cleaner["sun.misc.Cleaner", "thunk"]
       val thunkId = thunkField?.value?.asNonNullObjectIdReference
       val referentId =
         cleaner["java.lang.ref.Reference", "referent"]?.value?.asNonNullObjectIdReference
       if (thunkId != null && referentId != null) {
-        val thunkRecord = thunkField.value.readObjectRecord()
+        val thunkRecord = thunkField.value.asObject
         if (thunkRecord is GraphInstanceRecord && thunkRecord instanceOf "libcore.util.NativeAllocationRegistry\$CleanerThunk") {
           val allocationRegistryIdField =
             thunkRecord["libcore.util.NativeAllocationRegistry\$CleanerThunk", "this\$0"]
           if (allocationRegistryIdField != null && allocationRegistryIdField.value.isNonNullReference) {
-            val allocationRegistryRecord = allocationRegistryIdField.value.readObjectRecord()
+            val allocationRegistryRecord = allocationRegistryIdField.value.asObject
             if (allocationRegistryRecord is GraphInstanceRecord && allocationRegistryRecord instanceOf "libcore.util.NativeAllocationRegistry") {
               var nativeSize = nativeSizes.getValue(referentId)
               nativeSize += allocationRegistryRecord["libcore.util.NativeAllocationRegistry", "size"]?.value?.asLong?.toInt()
@@ -302,11 +315,12 @@ class HeapAnalyzer constructor(
     results.forEach { result ->
       val leakingInstanceId = result.weakReference.referent.value
       leakingInstanceIds.add(leakingInstanceId)
-      val instanceRecord = graph.readGraphObjectRecord(leakingInstanceId).asInstance!!
-      val classRecord = instanceRecord.readClass()
+      val instanceRecord = graph.indexedObject(leakingInstanceId).asInstance!!
+      val classRecord = instanceRecord.instanceClass
       var retainedSize = sizeByDominator.getValue(leakingInstanceId)
 
-      retainedSize += classRecord.record.instanceSize
+      retainedSize += classRecord.readRecord()
+          .instanceSize
       sizeByDominator[leakingInstanceId] = retainedSize
     }
 
@@ -316,8 +330,7 @@ class HeapAnalyzer constructor(
       if (instanceId !in leakingInstanceIds) {
         val currentSize = sizeByDominator.getValue(dominatorId)
         val nativeSize = nativeSizes.getValue(instanceId)
-        val record = graph.readObjectRecord(instanceId)
-        val shallowSize = graph.computeShallowSize(record)
+        val shallowSize = graph.computeShallowSize(graph.indexedObject(instanceId))
         sizeByDominator[dominatorId] = currentSize + nativeSize + shallowSize
       }
     }
@@ -348,7 +361,7 @@ class HeapAnalyzer constructor(
   }
 
   private fun buildLeakTraces(
-    leakTraceInspectors: List<LeakTraceInspector>,
+    objectInspectors: List<ObjectInspector>,
     pathResults: List<Result>,
     graph: HprofGraph,
     leakingWeakRefs: MutableList<KeyedWeakReferenceMirror>,
@@ -367,12 +380,12 @@ class HeapAnalyzer constructor(
       }
 
       val leakTrace =
-        buildLeakTrace(graph, leakTraceInspectors, pathResult.leakingNode)
+        buildLeakTrace(graph, objectInspectors, pathResult.leakingNode)
 
       // We get the class name from the heap dump rather than the weak reference because primitive
       // arrays are more readable that way, e.g. "[C" at runtime vs "char[]" in the heap dump.
       val instanceClassName =
-        recordClassName(graph.readGraphObjectRecord(pathResult.leakingNode.instance))
+        recordClassName(graph.indexedObject(pathResult.leakingNode.instance))
 
       val leakDetected = LeakingInstance(
           referenceKey = weakReference.key,
@@ -405,7 +418,7 @@ class HeapAnalyzer constructor(
 
   private fun buildLeakTrace(
     graph: HprofGraph,
-    leakTraceInspectors: List<LeakTraceInspector>,
+    objectInspectors: List<ObjectInspector>,
     leakingNode: LeakNode
   ): LeakTrace {
     val elements = ArrayList<LeakTraceElement>()
@@ -416,16 +429,24 @@ class HeapAnalyzer constructor(
 
     var node: LeakNode = leafNode
     val nodes = mutableListOf<LeakNode>()
-    val leakReporters = mutableListOf<LeakTraceElementReporter>()
+    val leakReporters = mutableListOf<ObjectReporter>()
     while (node is ChildNode) {
       nodes.add(0, node.parent)
-      leakReporters.add(0, LeakTraceElementReporter(graph.readGraphObjectRecord(node.parent.instance)))
+      leakReporters.add(
+          0, ObjectReporter(graph.indexedObject(node.parent.instance))
+      )
       node = node.parent
     }
+    val rootNode = node as RootNode
 
-    leakTraceInspectors.forEach { it.inspect(graph, leakReporters) }
+    // Looping on inspectors first to get more cache hits.
+    objectInspectors.forEach {inspector ->
+      leakReporters.forEach { reporter ->
+        inspector.inspect(graph, reporter)
+      }
+    }
 
-    val leakStatuses = computeLeakStatuses(leakReporters)
+    val leakStatuses = computeLeakStatuses(rootNode, leakReporters)
 
     node = leafNode
     while (node is ChildNode) {
@@ -439,16 +460,42 @@ class HeapAnalyzer constructor(
   }
 
   private fun computeLeakStatuses(
-    leakReporters: List<LeakTraceElementReporter>
+    rootNode: RootNode,
+    leakReporters: List<ObjectReporter>
   ): List<LeakNodeStatusAndReason> {
-    var lastNotLeakingElementIndex = 0
     val lastElementIndex = leakReporters.size - 1
+
+    val rootNodeReporter = leakReporters[0]
+
+    rootNodeReporter.addLabel(
+        "GC Root: " + when (rootNode.gcRoot) {
+          is ThreadObject -> "Thread object"
+          is JniGlobal -> "Global variable in native code"
+          is JniLocal -> "Local variable in native code"
+          is JavaFrame -> "Java local variable"
+          is NativeStack -> "Input or output parameters in native code"
+          is StickyClass -> "System class"
+          is ThreadBlock -> "Thread block"
+          is MonitorUsed -> "Monitor (anything that called the wait() or notify() methods, or that is synchronized.)"
+          is ReferenceCleanup -> "Reference cleanup"
+          is JniMonitor -> "Root JNI monitor"
+          else -> throw IllegalStateException("Unexpected gc root ${rootNode.gcRoot}")
+        }
+    )
+
+    when (rootNode.gcRoot) {
+      is StickyClass -> rootNodeReporter.reportNotLeaking("a system class never leaks")
+    }
+
+    leakReporters[lastElementIndex].reportLeaking("RefWatcher was watching this")
+
+    var lastNotLeakingElementIndex = 0
     var firstLeakingElementIndex = lastElementIndex
 
     val leakStatuses = ArrayList<LeakNodeStatusAndReason>()
 
     for ((index, reporter) in leakReporters.withIndex()) {
-      val leakStatus = inspectElementLeakStatus(reporter)
+      val leakStatus = resolveStatus(reporter)
       leakStatuses.add(leakStatus)
       if (leakStatus.status == NOT_LEAKING) {
         lastNotLeakingElementIndex = index
@@ -460,32 +507,12 @@ class HeapAnalyzer constructor(
       }
     }
 
-    leakStatuses[0] = when (leakStatuses[0].status) {
-      UNKNOWN -> LeakNodeStatus.notLeaking("it's a GC root")
-      NOT_LEAKING -> LeakNodeStatus.notLeaking(
-          "it's a GC root and ${leakStatuses[0].reason}"
-      )
-      LEAKING -> LeakNodeStatus.notLeaking(
-          "it's a GC root. Conflicts with ${leakStatuses[0].reason}"
-      )
-    }
-
-    leakStatuses[lastElementIndex] = when (leakStatuses[lastElementIndex].status) {
-      UNKNOWN -> LeakNodeStatus.leaking("RefWatcher was watching this")
-      LEAKING -> LeakNodeStatus.leaking(
-          "RefWatcher was watching this and ${leakStatuses[lastElementIndex].reason}"
-      )
-      NOT_LEAKING -> LeakNodeStatus.leaking(
-          "RefWatcher was watching this. Conflicts with ${leakStatuses[lastElementIndex].reason}"
-      )
-    }
-
     val simpleClassNames = leakReporters.map { reporter ->
       recordClassName(reporter.objectRecord).lastSegment('.')
     }
 
     // First and last are always known.
-    for (i in 1 until lastElementIndex) {
+    for (i in 0 ..lastElementIndex) {
       val leakStatus = leakStatuses[i]
       if (i < lastNotLeakingElementIndex) {
         val nextNotLeakingName = simpleClassNames[i + 1]
@@ -514,9 +541,10 @@ class HeapAnalyzer constructor(
     return leakStatuses
   }
 
-  private fun inspectElementLeakStatus(
-    reporter: LeakTraceElementReporter
+  private fun resolveStatus(
+    reporter: ObjectReporter
   ): LeakNodeStatusAndReason {
+    // NOT_LEAKING always wins over LEAKING
     var current = LeakNodeStatus.unknown()
     for (statusAndReason in reporter.leakNodeStatuses) {
       current = when {
@@ -553,17 +581,17 @@ class HeapAnalyzer constructor(
   ): LeakTraceElement {
     val objectId = node.parent.instance
 
-    val graphRecord = graph.readGraphObjectRecord(objectId)
+    val graphRecord = graph.indexedObject(objectId)
 
     val className = recordClassName(graphRecord)
 
-    val holderType = if (graphRecord.record is ClassDumpRecord) {
+    val holderType = if (graphRecord is GraphClassRecord) {
       CLASS
-    } else if (graphRecord.record is ObjectArrayDumpRecord || graphRecord.record is PrimitiveArrayDumpRecord) {
+    } else if (graphRecord is GraphObjectArrayRecord || graphRecord is GraphPrimitiveArrayRecord) {
       ARRAY
     } else {
       val instanceRecord = graphRecord.asInstance!!
-      if (instanceRecord.readClass().readClassHierarchy().any { it.name == Thread::class.java.name }) {
+      if (instanceRecord.instanceClass.classHierarchy.any { it.name == Thread::class.java.name }) {
         THREAD
       } else {
         OBJECT
@@ -581,15 +609,15 @@ class HeapAnalyzer constructor(
       is GraphClassRecord -> graphRecord.name
       is GraphInstanceRecord -> graphRecord.className
       is GraphObjectArrayRecord -> graphRecord.arrayClassName
-      is GraphPrimitiveArrayRecord -> when (graphRecord.record) {
-        is BooleanArrayDump -> "boolean[]"
-        is CharArrayDump -> "char[]"
-        is FloatArrayDump -> "float[]"
-        is DoubleArrayDump -> "double[]"
-        is ByteArrayDump -> "byte[]"
-        is ShortArrayDump -> "short[]"
-        is IntArrayDump -> "int[]"
-        is LongArrayDump -> "long[]"
+      is GraphPrimitiveArrayRecord -> when (graphRecord.primitiveType) {
+        BOOLEAN -> "boolean[]"
+        CHAR -> "char[]"
+        FLOAT -> "float[]"
+        DOUBLE -> "double[]"
+        BYTE -> "byte[]"
+        SHORT -> "short[]"
+        INT -> "int[]"
+        LONG -> "long[]"
       }
     }
   }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
index 60ef3694..9ea3e5d2 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
@@ -6,6 +6,7 @@ sealed class LeakNode {
   abstract val visitOrder: Int
 
   class RootNode(
+    val gcRoot: GcRoot,
     override val instance: Long,
     override val visitOrder: Int
   ) : LeakNode()
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakTrace.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakTrace.kt
index 1f05e5cb..c577e693 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakTrace.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakTrace.kt
@@ -32,7 +32,7 @@ data class LeakTrace(
       NOT_LEAKING -> if (index < elements.lastIndex) {
         elements[index + 1].leakStatusAndReason.status != NOT_LEAKING
       } else {
-        true
+        false
       }
       else -> false
     }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceInspector.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceInspector.kt
deleted file mode 100644
index 786bddb8..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceInspector.kt
+++ /dev/null
@@ -1,8 +0,0 @@
-package leakcanary
-
-interface LeakTraceInspector {
-  fun inspect(
-    graph: HprofGraph,
-    leakTrace: List<LeakTraceElementReporter>
-  )
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/ObjectInspector.kt b/leakcanary-analyzer/src/main/java/leakcanary/ObjectInspector.kt
new file mode 100644
index 00000000..3c0be75f
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/ObjectInspector.kt
@@ -0,0 +1,8 @@
+package leakcanary
+
+interface ObjectInspector {
+  fun inspect(
+    graph: HprofGraph,
+    reporter: ObjectReporter
+  )
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElementReporter.kt b/leakcanary-analyzer/src/main/java/leakcanary/ObjectReporter.kt
similarity index 89%
rename from leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElementReporter.kt
rename to leakcanary-analyzer/src/main/java/leakcanary/ObjectReporter.kt
index a9344870..7b81295e 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElementReporter.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/ObjectReporter.kt
@@ -1,6 +1,6 @@
 package leakcanary
 
-class LeakTraceElementReporter(val objectRecord: GraphObjectRecord) {
+class ObjectReporter(val objectRecord: GraphObjectRecord) {
 
   private val mutableLabels = mutableListOf<String>()
   private val mutableLeakNodeStatuses = mutableListOf<LeakNodeStatusAndReason>()
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
index 3fedb641..e73d150f 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
@@ -31,7 +31,9 @@ import leakcanary.GcRoot.ThreadObject
 import leakcanary.GraphObjectRecord.GraphClassRecord
 import leakcanary.GraphObjectRecord.GraphInstanceRecord
 import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
+import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
 import leakcanary.HprofGraph
+import leakcanary.HprofReader
 import leakcanary.LeakNode
 import leakcanary.LeakNode.ChildNode
 import leakcanary.LeakNode.RootNode
@@ -40,14 +42,6 @@ import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
 import leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
 import leakcanary.LeakTraceElement.Type.LOCAL
 import leakcanary.LeakTraceElement.Type.STATIC_FIELD
-import leakcanary.ObjectIdMetadata.CLASS
-import leakcanary.ObjectIdMetadata.EMPTY_INSTANCE
-import leakcanary.ObjectIdMetadata.INSTANCE
-import leakcanary.ObjectIdMetadata.OBJECT_ARRAY
-import leakcanary.ObjectIdMetadata.PRIMITIVE_WRAPPER_ARRAY
-import leakcanary.ObjectIdMetadata.PRIMITIVE_WRAPPER_OR_PRIMITIVE_ARRAY
-import leakcanary.ObjectIdMetadata.STRING
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
 import leakcanary.internal.hppc.LongLongScatterMap
 import leakcanary.internal.hppc.LongScatterSet
@@ -94,6 +88,7 @@ internal class ShortestPathFinder {
    * and cannot be dominated by a leaking instance.
    */
   private var dominatedInstances = LongLongScatterMap()
+  private var sizeOfObjectInstances = 0
 
   class Result(
     val leakingNode: LeakNode,
@@ -117,6 +112,28 @@ internal class ShortestPathFinder {
     listener.onProgressUpdate(FINDING_SHORTEST_PATHS)
     clearState()
 
+    val objectClass = graph.indexedClass("java.lang.Object")
+    sizeOfObjectInstances = if (objectClass != null) {
+      // In Android 16 ClassDumpRecord.instanceSize can be 8 yet there are 0 fields.
+      // Better rely on our own computation of instance size.
+      // See #1374
+      val objectClassFieldSize = objectClass.readRecord()
+          .fields.sumBy {
+        graph.sizeOfFieldType(it.type)
+      }
+
+      // shadow$_klass_ (object id) + shadow$_monitor_ (Int)
+      val sizeOfObjectOnArt =
+        graph.sizeOfFieldType(HprofReader.OBJECT_TYPE) + graph.sizeOfFieldType(HprofReader.INT_TYPE)
+      if (objectClassFieldSize == sizeOfObjectOnArt) {
+        sizeOfObjectOnArt
+      } else {
+        0
+      }
+    } else {
+      0
+    }
+
     val fieldNameByClassName = mutableMapOf<String, MutableMap<String, Exclusion>>()
     val staticFieldNameByClassName = mutableMapOf<String, MutableMap<String, Exclusion>>()
     val threadNames = mutableMapOf<String, Exclusion>()
@@ -187,7 +204,7 @@ internal class ShortestPathFinder {
         break@visitingQueue
       }
 
-      when (val graphRecord = graph.readGraphObjectRecord(node.instance)) {
+      when (val graphRecord = graph.indexedObject(node.instance)) {
         is GraphClassRecord -> visitClassRecord(
             graph, graphRecord, node, staticFieldNameByClassName, computeDominators
         )
@@ -195,7 +212,7 @@ internal class ShortestPathFinder {
             graph, graphRecord, node, fieldNameByClassName, computeDominators
         )
         is GraphObjectArrayRecord -> visitObjectArrayRecord(
-            graph, graphRecord.record, node, computeDominators
+            graph, graphRecord.readRecord(), node, computeDominators
         )
       }
     }
@@ -219,6 +236,7 @@ internal class ShortestPathFinder {
     visitOrder = 0
     referentMap = emptyMap()
     dominatedInstances = LongLongScatterMap()
+    sizeOfObjectInstances = 0
   }
 
   private fun enqueueGcRoots(
@@ -243,17 +261,17 @@ internal class ShortestPathFinder {
       when (gcRoot) {
         is ThreadObject -> {
           threadsBySerialNumber[gcRoot.threadSerialNumber] = gcRoot
-          enqueue(graph, RootNode(gcRoot.id, visitOrder++), exclusionPriority = null)
+          enqueue(graph, RootNode(gcRoot, gcRoot.id, visitOrder++), exclusionPriority = null)
         }
         is JavaFrame -> {
           val threadRoot = threadsBySerialNumber.getValue(gcRoot.threadSerialNumber)
-          val threadInstance = graph.readGraphObjectRecord(threadRoot.id).asInstance!!
+          val threadInstance = graph.indexedObject(threadRoot.id).asInstance!!
           val threadName = threadInstance[Thread::class, "name"]?.value?.readAsJavaString()
           val exclusion = threadNameExclusions[threadName]
 
           if (exclusion == null || exclusion.status != NEVER_REACHABLE) {
             // visitOrder is unused as this root node isn't enqueued.
-            val rootNode = RootNode(threadRoot.id, visitOrder = 0)
+            val rootNode = RootNode(gcRoot, threadRoot.id, visitOrder = 0)
             // TODO #1352 Instead of <Java Local>, it should be <local variable in Foo.bar()>
             // We should also add the full stacktrace as a label of thread objects
             val leakReference = LeakReference(LOCAL, "")
@@ -264,7 +282,7 @@ internal class ShortestPathFinder {
             )
           }
         }
-        else -> enqueue(graph, RootNode(gcRoot.id, visitOrder++), exclusionPriority = null)
+        else -> enqueue(graph, RootNode(gcRoot, gcRoot.id, visitOrder++), exclusionPriority = null)
       }
     }
     gcRoots.clear()
@@ -275,19 +293,19 @@ internal class ShortestPathFinder {
     gcRoots: MutableList<GcRoot>
   ) {
     val rootClassName: (GcRoot) -> String = {
-      when (val metadata = graph.objectIdMetadata(it.id)) {
-        PRIMITIVE_WRAPPER_OR_PRIMITIVE_ARRAY, PRIMITIVE_WRAPPER_ARRAY, EMPTY_INSTANCE -> metadata.name
-        STRING -> "java.lang.String"
-        OBJECT_ARRAY -> {
-          val record = graph.readObjectRecord(it.id) as ObjectArrayDumpRecord
-          graph.className(record.arrayClassId)
+      when (val graphObject = graph.indexedObject(it.id)) {
+        is GraphClassRecord -> {
+          graphObject.name
         }
-        INSTANCE -> {
-          val record = graph.readObjectRecord(it.id) as InstanceDumpRecord
-          graph.className(record.classId)
+        is GraphInstanceRecord -> {
+          graphObject.className
+        }
+        is GraphObjectArrayRecord -> {
+          graphObject.arrayClassName
+        }
+        is GraphPrimitiveArrayRecord -> {
+          graphObject.primitiveType.name
         }
-        CLASS -> graph.className(it.id)
-        else -> throw IllegalStateException("Unexpected type $metadata")
       }
     }
     gcRoots.sortWith(Comparator { root1, root2 ->
@@ -310,7 +328,7 @@ internal class ShortestPathFinder {
   ) {
     val ignoredStaticFields = staticFieldNameByClassName[classRecord.name] ?: emptyMap()
 
-    for (staticField in classRecord.staticFields) {
+    for (staticField in classRecord.readStaticFields()) {
       if (!staticField.value.isNonNullReference) {
         continue
       }
@@ -347,7 +365,7 @@ internal class ShortestPathFinder {
   ) {
     val ignoredFields = LinkedHashMap<String, Exclusion>()
 
-    instanceRecord.readClass().readClassHierarchy().forEach {
+    instanceRecord.instanceClass.classHierarchy.forEach {
       val classExclusions = fieldNameByClassName[it.name]
       if (classExclusions != null) {
         for ((fieldName, exclusion) in classExclusions) {
@@ -387,14 +405,15 @@ internal class ShortestPathFinder {
     parentNode: LeakNode,
     computeRetainedHeapSize: Boolean
   ) {
-    record.elementIds.forEachIndexed { index, elementId ->
-      if (computeRetainedHeapSize) {
-        updateDominatorWithSkips(graph, parentNode.instance, elementId)
-      }
-      val name = Integer.toString(index)
-      val reference = LeakReference(ARRAY_ENTRY, name)
-      enqueue(graph, ChildNode(elementId, visitOrder++, null, parentNode, reference), null)
-    }
+    record.elementIds.filter { it != 0L }
+        .forEachIndexed { index, elementId ->
+          if (computeRetainedHeapSize) {
+            updateDominatorWithSkips(graph, parentNode.instance, elementId)
+          }
+          val name = Integer.toString(index)
+          val reference = LeakReference(ARRAY_ENTRY, name)
+          enqueue(graph, ChildNode(elementId, visitOrder++, null, parentNode, reference), null)
+        }
   }
 
   private fun enqueue(
@@ -424,9 +443,25 @@ internal class ShortestPathFinder {
 
     val isLeakingInstance = referentMap[node.instance] != null
 
-    val objectIdMetadata = graph.objectIdMetadata(node.instance)
-    if (!isLeakingInstance && objectIdMetadata in SKIP_ENQUEUE) {
-      return
+    if (!isLeakingInstance) {
+      val skip = when (val graphObject = graph.indexedObject(node.instance)) {
+        is GraphClassRecord -> false
+        is GraphInstanceRecord ->
+          when {
+            graphObject.isPrimitiveWrapper -> true
+            graphObject.className == "java.lang.String" -> true
+            graphObject.instanceClass.instanceSize <= sizeOfObjectInstances -> true
+            else -> false
+          }
+        is GraphObjectArrayRecord -> when {
+          graphObject.isPrimitiveWrapperArray -> true
+          else -> false
+        }
+        is GraphPrimitiveArrayRecord -> true
+      }
+      if (skip) {
+        return
+      }
     }
 
     if (existingPriority != null) {
@@ -441,25 +476,32 @@ internal class ShortestPathFinder {
     parentObjectId: Long,
     objectId: Long
   ) {
-    when (graph.objectIdMetadata(objectId)) {
-      CLASS -> {
+
+    when (val graphObject = graph.indexedObject(objectId)) {
+      is GraphClassRecord -> {
         undominate(objectId, false)
       }
-      // String internal array is never enqueued
-      STRING -> {
-        updateDominator(parentObjectId, objectId, true)
-        val stringInstance = graph.readGraphObjectRecord(objectId).asInstance!!
-        val valueId = stringInstance["java.lang.String", "value"]?.value?.asNonNullObjectIdReference
-        if (valueId != null) {
-          updateDominator(parentObjectId, valueId, true)
+      is GraphInstanceRecord -> {
+        // String internal array is never enqueued
+        if (graphObject.className == "java.lang.String") {
+          updateDominator(parentObjectId, objectId, true)
+          val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectIdReference
+          if (valueId != null) {
+            updateDominator(parentObjectId, valueId, true)
+          }
+        } else {
+          updateDominator(parentObjectId, objectId, false)
         }
       }
-      // Primitive wrapper array elements are never enqueued
-      PRIMITIVE_WRAPPER_ARRAY -> {
-        updateDominator(parentObjectId, objectId, true)
-        val arrayRecord = graph.readObjectRecord(objectId) as ObjectArrayDumpRecord
-        for (wrapperId in arrayRecord.elementIds) {
-          updateDominator(parentObjectId, wrapperId, true)
+      is GraphObjectArrayRecord -> {
+        // Primitive wrapper array elements are never enqueued
+        if (graphObject.isPrimitiveWrapperArray) {
+          updateDominator(parentObjectId, objectId, true)
+          for (wrapperId in graphObject.readRecord().elementIds) {
+            updateDominator(parentObjectId, wrapperId, true)
+          }
+        } else {
+          updateDominator(parentObjectId, objectId, false)
         }
       }
       else -> {
@@ -535,27 +577,31 @@ internal class ShortestPathFinder {
     graph: HprofGraph,
     objectId: Long
   ) {
-    when (graph.objectIdMetadata(objectId)) {
-      CLASS -> {
+    when (val graphObject = graph.indexedObject(objectId)) {
+      is GraphClassRecord -> {
         undominate(objectId, false)
       }
-      // String internal array is never enqueued
-      STRING -> {
-        undominate(objectId, true)
-        val stringRecord = graph.readGraphObjectRecord(objectId)
-        val stringInstance = stringRecord.asInstance!!
-        val valueId = stringInstance["java.lang.String", "value"]?.value?.asObjectIdReference
-        if (valueId != null) {
-          undominate(valueId, true)
+      is GraphInstanceRecord -> {
+        // String internal array is never enqueued
+        if (graphObject.className == "java.lang.String") {
+          undominate(objectId, true)
+          val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectIdReference
+          if (valueId != null) {
+            undominate(valueId, true)
+          }
+        } else {
+          undominate(objectId, false)
         }
       }
-      // Primitive wrapper array elements are never enqueued
-      PRIMITIVE_WRAPPER_ARRAY -> {
-        undominate(objectId, true)
-        val arrayRecord =
-          graph.readObjectRecord(objectId) as ObjectArrayDumpRecord
-        for (wrapperId in arrayRecord.elementIds) {
-          undominate(wrapperId, true)
+      is GraphObjectArrayRecord -> {
+        // Primitive wrapper array elements are never enqueued
+        if (graphObject.isPrimitiveWrapperArray) {
+          undominate(objectId, true)
+          for (wrapperId in graphObject.readRecord().elementIds) {
+            undominate(wrapperId, true)
+          }
+        } else {
+          undominate(objectId, false)
         }
       }
       else -> {
@@ -575,9 +621,6 @@ internal class ShortestPathFinder {
   }
 
   companion object {
-    private val SKIP_ENQUEUE =
-      setOf(PRIMITIVE_WRAPPER_OR_PRIMITIVE_ARRAY, PRIMITIVE_WRAPPER_ARRAY, STRING, EMPTY_INSTANCE)
-
     // Since NEVER_REACHABLE never ends up in the queue, we use its value to mean "ALWAYS_REACHABLE"
     // For this to work we need NEVER_REACHABLE to be declared as the first enum value.
     private val ALWAYS_REACHABLE = NEVER_REACHABLE
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
index 284f3248..b631ce6c 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
@@ -1,12 +1,12 @@
 package leakcanary.internal
 
-import leakcanary.AndroidLeakTraceInspectors
+import leakcanary.AndroidObjectInspectors
 import leakcanary.HeapAnalysisSuccess
 import leakcanary.HprofGraph
-import leakcanary.LeakTraceElementReporter
-import leakcanary.LeakTraceInspector
 import leakcanary.LeakingInstance
-import leakcanary.forEachInstanceOf
+import leakcanary.ObjectInspector
+import leakcanary.ObjectReporter
+import leakcanary.asInstance
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
@@ -28,18 +28,18 @@ class LabelerTest {
   @Test fun stringContentAsLabel() {
     hprofFile.writeSinglePathToString("World")
 
-    val labeler = object : LeakTraceInspector{
+    val labeler = object : ObjectInspector{
       override fun inspect(
         graph: HprofGraph,
-        leakTrace: List<LeakTraceElementReporter>
+        reporter: ObjectReporter
       ) {
-        leakTrace.forEachInstanceOf("java.lang.String")  { instance ->
+        reporter.asInstance("java.lang.String")  { instance ->
           addLabel("Hello ${instance.readAsJavaString()}")
         }
       }
     }
 
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(leakTraceInspectors = listOf(labeler))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(objectInspectors = listOf(labeler))
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
 
@@ -50,7 +50,7 @@ class LabelerTest {
     hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
 
     val analysis =
-      hprofFile.checkForLeaks<HeapAnalysisSuccess>(leakTraceInspectors = listOf(AndroidLeakTraceInspectors.THREAD))
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(objectInspectors = listOf(AndroidObjectInspectors.THREAD))
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
 
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
index 761db959..cbac3b1a 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
@@ -7,9 +7,9 @@ import leakcanary.HprofGraph
 import leakcanary.LeakNodeStatus.LEAKING
 import leakcanary.LeakNodeStatus.NOT_LEAKING
 import leakcanary.LeakNodeStatus.UNKNOWN
-import leakcanary.LeakTraceElementReporter
-import leakcanary.LeakTraceInspector
+import leakcanary.ObjectReporter
 import leakcanary.LeakingInstance
+import leakcanary.ObjectInspector
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
@@ -74,7 +74,7 @@ class LeakStatusTest {
     }
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-        leakTraceInspectors = listOf(notLeaking("Class1"))
+        objectInspectors = listOf(notLeaking("Class1"))
     )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
@@ -92,7 +92,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(leaking("Class1"))
+          objectInspectors = listOf(leaking("Class1"))
       )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
@@ -110,7 +110,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(leaking("Class1"))
+          objectInspectors = listOf(leaking("Class1"))
       )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
@@ -132,7 +132,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(notLeaking("Class3"))
+          objectInspectors = listOf(notLeaking("Class3"))
       )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
@@ -154,7 +154,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(leaking("Class1"))
+          objectInspectors = listOf(leaking("Class1"))
       )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
@@ -176,14 +176,16 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(
+          objectInspectors = listOf(
               notLeaking("Class3"), leaking("Class1")
           )
       )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
     assertThat(leak.leakTrace.elements[0].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements[0].leakStatusAndReason.reason).isEqualTo("it's a GC root")
+    assertThat(leak.leakTrace.elements[0].leakStatusAndReason.reason).isEqualTo(
+        "Class1↓ is not leaking and a system class never leaks"
+    )
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.reason).isEqualTo(
         "Class2↓ is not leaking. Conflicts with Class1 is leaking"
@@ -213,7 +215,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(
+          objectInspectors = listOf(
               notLeaking("Class1"), leaking("Class3")
           )
       )
@@ -227,14 +229,14 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(leaking("GcRoot"))
+          objectInspectors = listOf(leaking("GcRoot"))
       )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
 
     assertThat(leak.leakTrace.elements.first().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
     assertThat(leak.leakTrace.elements.first().leakStatusAndReason.reason).isEqualTo(
-        "it's a GC root. Conflicts with GcRoot is leaking"
+        "a system class never leaks. Conflicts with GcRoot is leaking"
     )
   }
 
@@ -243,14 +245,14 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(notLeaking("GcRoot"))
+          objectInspectors = listOf(notLeaking("GcRoot"))
       )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
 
     assertThat(leak.leakTrace.elements.first().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
     assertThat(leak.leakTrace.elements.first().leakStatusAndReason.reason).isEqualTo(
-        "it's a GC root and GcRoot is not leaking"
+        "GcRoot is not leaking and a system class never leaks"
     )
   }
 
@@ -258,13 +260,13 @@ class LeakStatusTest {
     hprofFile.writeSinglePathToInstance()
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(notLeaking("Leaking"))
+          objectInspectors = listOf(notLeaking("Leaking"))
       )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(LEAKING)
+    assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
     assertThat(leak.leakTrace.elements.last().leakStatusAndReason.reason).isEqualTo(
-        "RefWatcher was watching this. Conflicts with Leaking is not leaking"
+        "Leaking is not leaking. Conflicts with RefWatcher was watching this"
     )
   }
 
@@ -272,13 +274,13 @@ class LeakStatusTest {
     hprofFile.writeSinglePathToInstance()
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(leaking("Leaking"))
+          objectInspectors = listOf(leaking("Leaking"))
       )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
     assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(LEAKING)
     assertThat(leak.leakTrace.elements.last().leakStatusAndReason.reason).isEqualTo(
-        "RefWatcher was watching this and Leaking is leaking"
+        "Leaking is leaking and RefWatcher was watching this"
     )
   }
 
@@ -293,7 +295,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(
+          objectInspectors = listOf(
               notLeaking("Class1"), leaking("Class1")
           )
       )
@@ -316,7 +318,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(
+          objectInspectors = listOf(
               notLeaking("Class1"), notLeaking("Class1")
           )
       )
@@ -339,7 +341,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(leaking("Class1"), leaking("Class1"))
+          objectInspectors = listOf(leaking("Class1"), leaking("Class1"))
       )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
@@ -364,7 +366,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(
+          objectInspectors = listOf(
               notLeaking("Class1"), leaking("Class3")
           )
       )
@@ -461,37 +463,33 @@ class LeakStatusTest {
     assertThat(hash1).isEqualTo(hash2)
   }
 
-  private fun notLeaking(className: String): LeakTraceInspector {
-    return object : LeakTraceInspector {
+  private fun notLeaking(className: String): ObjectInspector {
+    return object : ObjectInspector {
       override fun inspect(
         graph: HprofGraph,
-        leakTrace: List<LeakTraceElementReporter>
+        reporter: ObjectReporter
       ) {
-        leakTrace.forEach { reporter ->
-          val record = reporter.objectRecord
-          if (record is GraphInstanceRecord && record.className == className) {
-            reporter.reportNotLeaking("$className is not leaking")
-          } else if (record is GraphClassRecord && record.name == className) {
-            reporter.reportNotLeaking("$className is not leaking")
-          }
+        val record = reporter.objectRecord
+        if (record is GraphInstanceRecord && record.className == className) {
+          reporter.reportNotLeaking("$className is not leaking")
+        } else if (record is GraphClassRecord && record.name == className) {
+          reporter.reportNotLeaking("$className is not leaking")
         }
       }
     }
   }
 
-  private fun leaking(className: String): LeakTraceInspector {
-    return object : LeakTraceInspector {
+  private fun leaking(className: String): ObjectInspector {
+    return object : ObjectInspector {
       override fun inspect(
         graph: HprofGraph,
-        leakTrace: List<LeakTraceElementReporter>
+        reporter: ObjectReporter
       ) {
-        leakTrace.forEach { reporter ->
-          val record = reporter.objectRecord
-          if (record is GraphInstanceRecord && record.className == className) {
-            reporter.reportLeaking("$className is leaking")
-          } else if (record is GraphClassRecord && record.name == className) {
-            reporter.reportLeaking("$className is leaking")
-          }
+        val record = reporter.objectRecord
+        if (record is GraphInstanceRecord && record.className == className) {
+          reporter.reportLeaking("$className is leaking")
+        } else if (record is GraphClassRecord && record.name == className) {
+          reporter.reportLeaking("$className is leaking")
         }
       }
     }
@@ -503,7 +501,7 @@ class LeakStatusTest {
   ): String {
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(notLeaking(notLeaking), leaking(leaking))
+          objectInspectors = listOf(notLeaking(notLeaking), leaking(leaking))
       )
     val leak = analysis.retainedInstances[0] as LeakingInstance
     return leak.groupHash
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
index 0bcdfaeb..c0d5eb65 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
@@ -4,10 +4,10 @@ import leakcanary.Exclusion
 import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
 import leakcanary.HeapAnalysisSuccess
 import leakcanary.HprofGraph
-import leakcanary.LeakTraceElementReporter
-import leakcanary.LeakTraceInspector
+import leakcanary.ObjectReporter
 import leakcanary.LeakingInstance
-import leakcanary.forEachInstanceOf
+import leakcanary.ObjectInspector
+import leakcanary.asInstance
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
@@ -38,7 +38,8 @@ class LeakTraceRendererTest {
     analysis renders """
     ┬
     ├─ GcRoot
-    │    Leaking: NO (it's a GC root)
+    │    Leaking: NO (a system class never leaks)
+    │    GC Root: System class
     │    ↓ static GcRoot.leak
     │                    ~~~~
     ╰→ Leaking
@@ -59,12 +60,12 @@ class LeakTraceRendererTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(object : LeakTraceInspector {
+          objectInspectors = listOf(object : ObjectInspector {
             override fun inspect(
               graph: HprofGraph,
-              leakTrace: List<LeakTraceElementReporter>
+              reporter: ObjectReporter
             ) {
-              leakTrace.forEachInstanceOf("ClassB") {
+              reporter.asInstance("ClassB") {
                 reportLeaking("because reasons")
               }
             }
@@ -74,7 +75,8 @@ class LeakTraceRendererTest {
     analysis renders """
     ┬
     ├─ GcRoot
-    │    Leaking: NO (it's a GC root)
+    │    Leaking: NO (a system class never leaks)
+    │    GC Root: System class
     │    ↓ static GcRoot.instanceA
     │                    ~~~~~~~~~
     ├─ ClassA
@@ -85,7 +87,7 @@ class LeakTraceRendererTest {
     │    Leaking: YES (because reasons)
     │    ↓ ClassB.leak
     ╰→ Leaking
-    ​     Leaking: YES (RefWatcher was watching this)
+    ​     Leaking: YES (ClassB↑ is leaking and RefWatcher was watching this)
     """
   }
 
@@ -97,14 +99,12 @@ class LeakTraceRendererTest {
     }
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-        leakTraceInspectors = listOf(object : LeakTraceInspector {
+        objectInspectors = listOf(object : ObjectInspector {
           override fun inspect(
             graph: HprofGraph,
-            leakTrace: List<LeakTraceElementReporter>
+            reporter: ObjectReporter
           ) {
-            leakTrace.forEach { reporter ->
-              reporter.addLabel("¯\\_(ツ)_/¯")
-            }
+            reporter.addLabel("¯\\_(ツ)_/¯")
           }
 
         })
@@ -113,8 +113,9 @@ class LeakTraceRendererTest {
     analysis renders """
     ┬
     ├─ GcRoot
-    │    Leaking: NO (it's a GC root)
+    │    Leaking: NO (a system class never leaks)
     │    ¯\_(ツ)_/¯
+    │    GC Root: System class
     │    ↓ static GcRoot.leak
     │                    ~~~~
     ╰→ Leaking
@@ -140,7 +141,8 @@ class LeakTraceRendererTest {
     analysis renders """
     ┬
     ├─ GcRoot
-    │    Leaking: NO (it's a GC root)
+    │    Leaking: NO (a system class never leaks)
+    │    GC Root: System class
     │    ↓ static GcRoot.instanceA
     │                    ~~~~~~~~~
     ├─ ClassA
@@ -166,7 +168,8 @@ class LeakTraceRendererTest {
     analysis renders """
     ┬
     ├─ GcRoot
-    │    Leaking: NO (it's a GC root)
+    │    Leaking: NO (a system class never leaks)
+    │    GC Root: System class
     │    ↓ static GcRoot.array
     │                    ~~~~~
     ├─ java.lang.Object[]
@@ -187,7 +190,8 @@ class LeakTraceRendererTest {
     analysis renders """
     ┬
     ├─ MyThread
-    │    Leaking: NO (it's a GC root)
+    │    Leaking: UNKNOWN
+    │    GC Root: Java local variable
     │    ↓ thread MyThread.<Java Local>
     │                      ~~~~~~~~~~~~
     ╰→ Leaking
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
index 785e69e9..5e1c8a5d 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
@@ -1,7 +1,7 @@
 package leakcanary.internal
 
 import leakcanary.AndroidKnownReference
-import leakcanary.AndroidLeakTraceInspectors
+import leakcanary.AndroidObjectInspectors
 import leakcanary.HeapAnalysis
 import leakcanary.HeapAnalysisFailure
 import leakcanary.HeapAnalysisSuccess
@@ -53,7 +53,7 @@ class LegacyHprofTest {
     val hprofFile = File(url.path)
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysis>(
-        leakTraceInspectors = AndroidLeakTraceInspectors.defaultInspectors(),
+        objectInspectors = AndroidObjectInspectors.defaultInspectors(),
         exclusions = AndroidKnownReference.mapToExclusions(AndroidKnownReference.appDefaults)
     )
     if (analysis is HeapAnalysisFailure) {
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
index 371ca88e..210dcc19 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
@@ -7,9 +7,10 @@ import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
 import leakcanary.Exclusion.Status.NEVER_REACHABLE
 import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.HeapAnalysis
+import leakcanary.HeapAnalysisFailure
 import leakcanary.HeapAnalyzer
 import leakcanary.KeyedWeakReference
-import leakcanary.LeakTraceInspector
+import leakcanary.ObjectInspector
 import java.io.File
 import java.lang.ref.PhantomReference
 import java.lang.ref.SoftReference
@@ -17,14 +18,18 @@ import java.lang.ref.WeakReference
 
 @Suppress("UNCHECKED_CAST")
 fun <T : HeapAnalysis> File.checkForLeaks(
-  leakTraceInspectors: List<LeakTraceInspector> = emptyList(),
+  objectInspectors: List<ObjectInspector> = emptyList(),
   computeRetainedHeapSize: Boolean = false,
   exclusions: List<Exclusion> = defaultExclusionsFactory
 ): T {
   val heapAnalyzer = HeapAnalyzer(AnalyzerProgressListener.NONE)
-  return heapAnalyzer.checkForLeaks(
-      this, exclusions, computeRetainedHeapSize, leakTraceInspectors
-  ) as T
+  val result = heapAnalyzer.checkForLeaks(
+      this, exclusions, computeRetainedHeapSize, objectInspectors
+  )
+  if (result is HeapAnalysisFailure) {
+    println(result)
+  }
+  return result as T
 }
 
 val defaultExclusionsFactory: List<Exclusion> =
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
index 251a6407..f4f01046 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -31,7 +31,7 @@ object LeakCanary {
 
     val knownReferences: Set<AndroidKnownReference> = AndroidKnownReference.appDefaults,
 
-    val leakTraceInspectors: List<LeakTraceInspector> = AndroidLeakTraceInspectors.defaultInspectors(),
+    val objectInspectors: List<ObjectInspector> = AndroidObjectInspectors.defaultInspectors(),
 
     /**
      * Called with the heap analysis result from a background thread.
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
index 263f6946..fa62ba45 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
@@ -60,7 +60,7 @@ internal class HeapAnalyzerService : ForegroundService(
 
     val heapAnalysis =
       heapAnalyzer.checkForLeaks(
-          heapDumpFile, exclusions, config.computeRetainedHeapSize, config.leakTraceInspectors
+          heapDumpFile, exclusions, config.computeRetainedHeapSize, config.objectInspectors
       )
 
     config.analysisResultListener(application, heapAnalysis)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
index 8c71a08b..7da229c2 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -44,7 +44,7 @@ internal object InternalLeakCanary : LeakSentryListener {
 
   val noInstallConfig: Config
     get() = Config(
-        dumpHeap = false, knownReferences = emptySet(), leakTraceInspectors = emptyList()
+        dumpHeap = false, knownReferences = emptySet(), objectInspectors = emptyList()
     )
 
   override fun onLeakSentryInstalled(application: Application) {
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
index 3d0b3d1f..2a010a8e 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
@@ -25,7 +25,7 @@ internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
   }
 
   companion object {
-    // Last updated for 2.0-alpha-3
-    private const val VERSION = 10
+    // Last updated for next after 2.0-alpha-3
+    private const val VERSION = 11
   }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt
index 005e697d..18b43754 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt
@@ -9,6 +9,7 @@ import android.widget.ListView
 import android.widget.TextView
 import androidx.core.content.ContextCompat
 import androidx.core.text.HtmlCompat
+import com.squareup.leakcanary.core.BuildConfig
 import com.squareup.leakcanary.core.R
 import leakcanary.internal.activity.LeakActivity
 import leakcanary.internal.activity.db.LeakingInstanceTable
@@ -37,11 +38,11 @@ internal class GroupListScreen : Screen() {
               true
             }
 
-        menu.add(R.string.leak_canary_about_title)
+        menu.add(R.string.leak_canary_about_menu)
             .setOnMenuItemClickListener {
               val dialog = AlertDialog.Builder(context)
                   .setIcon(ContextCompat.getDrawable(context, R.drawable.leak_canary_icon))
-                  .setTitle(R.string.leak_canary_about_title)
+                  .setTitle(resources.getString(R.string.leak_canary_about_title, BuildConfig.LIBRARY_VERSION))
                   .setMessage(
                       HtmlCompat.fromHtml(
                           resources.getString(R.string.leak_canary_about_message),
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
index b1aa79a0..a8c4aa94 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
@@ -79,6 +79,11 @@ internal class HeapAnalysisSuccessScreen(
               goTo(RenderHeapDumpScreen(heapAnalysis.heapDumpFile))
               true
             }
+        menu.add(R.string.leak_canary_options_menu_explore_heap_dump)
+            .setOnMenuItemClickListener {
+              goTo(HprofExplorerScreen(heapAnalysis.heapDumpFile))
+              true
+            }
       }
     }
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
index b0723f55..d310f95d 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
@@ -12,15 +12,15 @@ import android.graphics.Paint.Style.STROKE
 import android.graphics.Rect
 import androidx.core.content.ContextCompat
 import com.squareup.leakcanary.core.R
-import leakcanary.HprofParser
-import leakcanary.HprofParser.RecordCallbacks
+import leakcanary.HprofPushRecordsParser
+import leakcanary.HprofPushRecordsParser.OnRecordListener
 import leakcanary.Record
 import leakcanary.Record.HeapDumpEndRecord
+import leakcanary.Record.HeapDumpRecord.GcRootRecord
 import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
@@ -33,6 +33,7 @@ import leakcanary.Record.LoadClassRecord
 import leakcanary.Record.StackTraceRecord
 import leakcanary.Record.StringRecord
 import java.io.File
+import kotlin.reflect.KClass
 
 object HeapDumpRenderer {
 
@@ -56,8 +57,6 @@ object HeapDumpRenderer {
      */
     sourceBytesPerPixel: Int
   ): Bitmap = with(HasDensity(context.resources)) {
-    val parser = HprofParser.open(heapDumpFile)
-
     val recordPositions = mutableListOf<Pair<Int, Long>>()
     var currentRecord: Record? = null
 
@@ -91,7 +90,8 @@ object HeapDumpRenderer {
         IntArrayDump::class to intArrayColor,
         LongArrayDump::class to longArrayColor,
         StackTraceRecord::class to stackTraceColor,
-        HeapDumpEndRecord::class to otherColor
+        HeapDumpEndRecord::class to otherColor,
+        GcRootRecord::class to otherColor
     )
 
     val appHeapColor = ContextCompat.getColor(context, R.color.leak_canary_heap_app)
@@ -99,13 +99,33 @@ object HeapDumpRenderer {
     val zygoteHeapColor = ContextCompat.getColor(context, R.color.leak_canary_heap_zygote)
     val stringColor = ContextCompat.getColor(context, R.color.leak_canary_heap_instance_string)
 
-    val updatePosition: (Record) -> Unit =
-      { newRecord ->
+    val parser = HprofPushRecordsParser()
+    val reader = parser.readHprofRecords(heapDumpFile, setOf(object : OnRecordListener {
+      override fun recordTypes(): Set<KClass<out Record>> = setOf(Record::class)
+
+      val hprofStringCache = mutableMapOf<Long, String>()
+      val classNames = mutableMapOf<Long, Long>()
+
+      override fun onTypeSizesAvailable(typeSizes: Map<Int, Int>) {
+      }
+
+      override fun onRecord(
+        position: Long,
+        record: Record
+      ) {
+        when (record) {
+          is StringRecord -> {
+            hprofStringCache[record.id] = record.string
+          }
+          is LoadClassRecord -> {
+            classNames[record.id] = record.classNameStringId
+          }
+        }
         val localCurrentRecord = currentRecord
         when {
           localCurrentRecord is HeapDumpInfoRecord -> {
             val colorForHeapInfo =
-              when (parser.hprofStringById(localCurrentRecord.heapNameStringId)) {
+              when (hprofStringCache[localCurrentRecord.heapNameStringId]) {
                 // The primary heap on which your app allocates memory.
                 "app" -> appHeapColor
                 // The system boot image, containing classes that are preloaded during boot time.
@@ -117,44 +137,30 @@ object HeapDumpRenderer {
                 // default heap: When no heap is specified by the system
                 else -> otherColor
               }
-            recordPositions.add(colorForHeapInfo to parser.position)
-            currentRecord = newRecord
+            recordPositions.add(colorForHeapInfo to position)
+            currentRecord = record
           }
           localCurrentRecord is InstanceDumpRecord
-              && parser.className(localCurrentRecord.classId) == "java.lang.String"
-              && (newRecord !is InstanceDumpRecord || parser.className(
-              newRecord.classId
-          ) != "java.lang.String")
+              && hprofStringCache[classNames[localCurrentRecord.classId]] == "java.lang.String"
+              && (record !is InstanceDumpRecord || hprofStringCache[classNames[record.classId]]
+              != "java.lang.String")
           -> {
-            recordPositions.add(stringColor to parser.position)
-            currentRecord = newRecord
+            recordPositions.add(stringColor to position)
+            currentRecord = record
           }
           currentRecord == null -> {
-            recordPositions.add(otherColor to parser.position)
-            currentRecord = newRecord
+            recordPositions.add(otherColor to position)
+            currentRecord = record
           }
-          currentRecord!!::class != newRecord::class -> {
-            recordPositions.add(colors.getValue(currentRecord!!::class) to parser.position)
-            currentRecord = newRecord
+          currentRecord!!::class != record::class -> {
+            recordPositions.add(colors.getValue(currentRecord!!::class) to position)
+            currentRecord = record
           }
         }
       }
-
-    parser.scan(
-        RecordCallbacks()
-            .on(StringRecord::class.java, updatePosition)
-            .on(LoadClassRecord::class.java, updatePosition)
-            .on(ClassDumpRecord::class.java, updatePosition)
-            .on(InstanceDumpRecord::class.java, updatePosition)
-            .on(ObjectArrayDumpRecord::class.java, updatePosition)
-            .on(PrimitiveArrayDumpRecord::class.java, updatePosition)
-            .on(HeapDumpInfoRecord::class.java, updatePosition)
-            .on(HeapDumpEndRecord::class.java, updatePosition)
-            .on(StackTraceRecord::class.java, updatePosition)
-    )
-
-    val heapLength = parser.position
-    parser.close()
+    }))
+    val heapLength = reader.position
+    reader.close()
 
     val width = sourceWidth
     var height: Int
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
new file mode 100644
index 00000000..a29c00c5
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
@@ -0,0 +1,330 @@
+package leakcanary.internal.activity.screen
+
+import android.app.AlertDialog
+import android.view.View
+import android.view.View.OnAttachStateChangeListener
+import android.view.View.VISIBLE
+import android.view.ViewGroup
+import android.widget.EditText
+import android.widget.ListView
+import android.widget.TextView
+import android.widget.Toast
+import com.squareup.leakcanary.core.R
+import leakcanary.GraphField
+import leakcanary.GraphHeapValue
+import leakcanary.GraphObjectRecord.GraphClassRecord
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
+import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
+import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
+import leakcanary.HeapValue.BooleanValue
+import leakcanary.HeapValue.ByteValue
+import leakcanary.HeapValue.CharValue
+import leakcanary.HeapValue.DoubleValue
+import leakcanary.HeapValue.FloatValue
+import leakcanary.HeapValue.IntValue
+import leakcanary.HeapValue.LongValue
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.HeapValue.ShortValue
+import leakcanary.HprofGraph
+import leakcanary.PrimitiveType.BOOLEAN
+import leakcanary.PrimitiveType.BYTE
+import leakcanary.PrimitiveType.CHAR
+import leakcanary.PrimitiveType.DOUBLE
+import leakcanary.PrimitiveType.FLOAT
+import leakcanary.PrimitiveType.INT
+import leakcanary.PrimitiveType.LONG
+import leakcanary.PrimitiveType.SHORT
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import leakcanary.internal.activity.db.Io
+import leakcanary.internal.activity.db.executeOnIo
+import leakcanary.internal.activity.ui.SimpleListAdapter
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.inflate
+import java.io.Closeable
+import java.io.File
+
+internal class HprofExplorerScreen(
+  private val heapDumpFile: File
+) : Screen() {
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_hprof_explorer).apply {
+      container.activity.title = resources.getString(R.string.leak_canary_loading_title)
+
+      lateinit var closeable: Closeable
+
+      addOnAttachStateChangeListener(object : OnAttachStateChangeListener {
+        override fun onViewAttachedToWindow(view: View) {
+        }
+
+        override fun onViewDetachedFromWindow(view: View) {
+          Io.execute {
+            closeable.close()
+          }
+        }
+      })
+
+      executeOnIo {
+        val pair = HprofGraph.readHprof(heapDumpFile)
+        val graph = pair.first
+        closeable = pair.second
+        updateUi {
+          container.activity.title =
+            resources.getString(R.string.leak_canary_options_menu_explore_heap_dump)
+          val titleView = findViewById<TextView>(R.id.leak_canary_explorer_title)
+          val searchView = findViewById<View>(R.id.leak_canary_search_button)
+          val listView = findViewById<ListView>(R.id.leak_canary_explorer_list)
+          titleView.visibility = VISIBLE
+          searchView.visibility = VISIBLE
+          listView.visibility = VISIBLE
+          searchView.setOnClickListener {
+            val input = EditText(context)
+            AlertDialog.Builder(context)
+                .setIcon(android.R.drawable.ic_dialog_alert)
+                .setTitle("Type a fully qualified class name")
+                .setView(input)
+                .setPositiveButton(android.R.string.ok) { _, _ ->
+                  executeOnIo {
+                    val partialClassName = input.text.toString()
+                    val matchingClasses = graph.classSequence()
+                        .filter { partialClassName in it.name }
+                        .toList()
+
+                    if (matchingClasses.isEmpty()) {
+                      updateUi {
+                        Toast.makeText(
+                            context, "No class matching [$partialClassName]", Toast.LENGTH_LONG
+                        )
+                            .show()
+                      }
+                    } else {
+                      updateUi {
+                        titleView.text =
+                          "${matchingClasses.size} classes matching [$partialClassName]"
+                        listView.adapter = SimpleListAdapter(
+                            R.layout.leak_canary_leak_row, matchingClasses
+                        ) { view, position ->
+                          val itemTitleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
+                          itemTitleView.text = matchingClasses[position].name
+                        }
+                        listView.setOnItemClickListener { _, _, position, _ ->
+                          val selectedClass = matchingClasses[position]
+                          showClass(titleView, listView, selectedClass)
+                        }
+                      }
+                    }
+                  }
+                }
+                .setNegativeButton(android.R.string.cancel, null)
+                .show()
+          }
+        }
+      }
+    }
+
+  private fun View.showClass(
+    titleView: TextView,
+    listView: ListView,
+    selectedClass: GraphClassRecord
+  ) {
+    executeOnIo {
+      val className = selectedClass.name
+      val instances = selectedClass.directInstances.toList()
+      val staticFields = selectedClass.readStaticFields()
+          .fieldsAsString()
+      updateUi {
+        titleView.text =
+          "Class $className (${instances.size} instances)"
+        listView.adapter = SimpleListAdapter(
+            R.layout.leak_canary_leak_row, staticFields + instances
+        ) { view, position ->
+          val itemTitleView =
+            view.findViewById<TextView>(R.id.leak_canary_row_text)
+          if (position < staticFields.size) {
+            itemTitleView.text = staticFields[position].second
+          } else {
+            itemTitleView.text = "@${instances[position - staticFields.size].objectId}"
+          }
+        }
+        listView.setOnItemClickListener { _, _, position, _ ->
+          if (position < staticFields.size) {
+            val staticField = staticFields[position].first
+            onHeapValueClicked(titleView, listView, staticField.value)
+          } else {
+            val instance = instances[position - staticFields.size]
+            showInstance(titleView, listView, instance)
+          }
+        }
+      }
+    }
+  }
+
+  private fun View.showInstance(
+    titleView: TextView,
+    listView: ListView,
+    instance: GraphInstanceRecord
+  ) {
+    executeOnIo {
+      val fields = instance.readFields()
+          .fieldsAsString()
+      val className = instance.className
+      updateUi {
+        titleView.text = "Instance @${instance.objectId} of class $className"
+        listView.adapter = SimpleListAdapter(
+            R.layout.leak_canary_leak_row, fields
+        ) { view, position ->
+          val itemTitleView =
+            view.findViewById<TextView>(R.id.leak_canary_row_text)
+          itemTitleView.text = fields[position].second
+        }
+        listView.setOnItemClickListener { _, _, position, _ ->
+          val field = fields[position].first
+          onHeapValueClicked(titleView, listView, field.value)
+        }
+      }
+    }
+  }
+
+  private fun View.showObjectArray(
+    titleView: TextView,
+    listView: ListView,
+    instance: GraphObjectArrayRecord
+  ) {
+    executeOnIo {
+      val elements = instance.readElements()
+          .mapIndexed { index: Int, element: GraphHeapValue ->
+            element to "[$index] = ${element.heapValueAsString()}"
+          }
+          .toList()
+      val arrayClassName = instance.arrayClassName
+      val className = arrayClassName.substring(0, arrayClassName.length - 2)
+      updateUi {
+        titleView.text = "Array $className[${elements.size}]"
+        listView.adapter = SimpleListAdapter(
+            R.layout.leak_canary_leak_row, elements
+        ) { view, position ->
+          val itemTitleView =
+            view.findViewById<TextView>(R.id.leak_canary_row_text)
+          itemTitleView.text = elements[position].second
+        }
+        listView.setOnItemClickListener { _, _, position, _ ->
+          val element = elements[position].first
+          onHeapValueClicked(titleView, listView, element)
+        }
+      }
+    }
+  }
+
+  private fun View.showPrimitiveArray(
+    titleView: TextView,
+    listView: ListView,
+    instance: GraphPrimitiveArrayRecord
+  ) {
+    executeOnIo {
+      val (type, values) = when (val record = instance.readRecord()) {
+        is BooleanArrayDump -> "boolean" to record.array.map { it.toString() }
+        is CharArrayDump -> "char" to record.array.map { "'$it'" }
+        is FloatArrayDump -> "float" to record.array.map { it.toString() }
+        is DoubleArrayDump -> "double" to record.array.map { it.toString() }
+        is ByteArrayDump -> "byte" to record.array.map { it.toString() }
+        is ShortArrayDump -> "short" to record.array.map { it.toString() }
+        is IntArrayDump -> "int" to record.array.map { it.toString() }
+        is LongArrayDump -> "long" to record.array.map { it.toString() }
+      }
+      updateUi {
+        titleView.text = "Array $type[${values.size}]"
+        listView.adapter = SimpleListAdapter(
+            R.layout.leak_canary_leak_row, values
+        ) { view, position ->
+          val itemTitleView =
+            view.findViewById<TextView>(R.id.leak_canary_row_text)
+          itemTitleView.text = "$type ${values[position]}"
+        }
+        listView.setOnItemClickListener { _, _, _, _ ->
+        }
+      }
+    }
+  }
+
+  private fun View.onHeapValueClicked(
+    titleView: TextView,
+    listView: ListView,
+    graphHeapValue: GraphHeapValue
+  ) {
+    if (graphHeapValue.isNonNullReference) {
+      when (val objectRecord = graphHeapValue.asObject!!) {
+        is GraphInstanceRecord -> {
+          showInstance(titleView, listView, objectRecord)
+        }
+        is GraphClassRecord -> {
+          showClass(titleView, listView, objectRecord)
+        }
+        is GraphObjectArrayRecord -> {
+          showObjectArray(titleView, listView, objectRecord)
+        }
+        is GraphPrimitiveArrayRecord -> {
+          showPrimitiveArray(titleView, listView, objectRecord)
+        }
+      }
+    }
+  }
+
+  private fun Sequence<GraphField>.fieldsAsString(): List<Pair<GraphField, String>> {
+    return map { field ->
+      field to "${field.classRecord.simpleName}.${field.name} = ${field.value.heapValueAsString()}"
+    }
+        .toList()
+  }
+
+  private fun GraphHeapValue.heapValueAsString(): String {
+    return when (val heapValue = actual) {
+      is ObjectReference -> {
+        if (isNullReference) {
+          "null"
+        } else {
+          when (val objectRecord = asObject!!) {
+            is GraphInstanceRecord -> {
+              if (objectRecord instanceOf "java.lang.String") {
+                "${objectRecord.className}@${heapValue.value} \"${objectRecord.readAsJavaString()!!}\""
+              } else {
+                "${objectRecord.className}@${heapValue.value}"
+              }
+            }
+            is GraphClassRecord -> {
+              "Class ${objectRecord.name}"
+            }
+            is GraphObjectArrayRecord -> {
+              objectRecord.arrayClassName
+            }
+            is GraphPrimitiveArrayRecord -> when (objectRecord.primitiveType) {
+              BOOLEAN -> "boolean[]"
+              CHAR -> "char[]"
+              FLOAT -> "float[]"
+              DOUBLE -> "double[]"
+              BYTE -> "byte[]"
+              SHORT -> "short[]"
+              INT -> "int[]"
+              LONG -> "long[]"
+            }
+          }
+        }
+      }
+      is BooleanValue -> "boolean ${heapValue.value}"
+      is CharValue -> "char ${heapValue.value}"
+      is FloatValue -> "float ${heapValue.value}"
+      is DoubleValue -> "double ${heapValue.value}"
+      is ByteValue -> "byte ${heapValue.value}"
+      is ShortValue -> "short ${heapValue.value}"
+      is IntValue -> "int ${heapValue.value}"
+      is LongValue -> "long ${heapValue.value}"
+    }
+
+  }
+}
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_hprof_explorer.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_hprof_explorer.xml
new file mode 100644
index 00000000..3f98e4f2
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_hprof_explorer.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@color/leak_canary_background_color"
+    android:orientation="vertical"
+    >
+  <Button
+      android:id="@+id/leak_canary_search_button"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:text="@string/leak_canary_explorer_search_classes"
+      android:visibility="invisible"
+      />
+  <TextView
+      android:id="@+id/leak_canary_explorer_title"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:visibility="invisible"
+      />
+  <ListView
+      android:id="@+id/leak_canary_explorer_list"
+      android:layout_width="match_parent"
+      android:layout_height="match_parent"
+      android:divider="@null"
+      android:dividerHeight="0dp"
+      android:visibility="invisible"
+      />
+</LinearLayout>
diff --git a/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
index b5b1e2c9..56cf4619 100644
--- a/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
+++ b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
@@ -14,7 +14,7 @@
   ~ limitations under the License.
   -->
 <resources>
-  <string name="leak_canary_about_title">About LeakCanary</string>
+  <string name="leak_canary_about_title">About LeakCanary %s</string>
   <string name="leak_canary_about_message"><![CDATA[<a href="https://github.com/square/leakcanary">LeakCanary</a>
   ist eine Memory-Leak-Detection Bibliothek für Android, erstellt von
   <a href="https://twitter.com/Piwai">Pierre-Yves Ricau</a> und open-sourced von <a href="https://square.github.io">Square</a>.<br><br>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
index 314fdf00..3445d9ab 100644
--- a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
@@ -15,7 +15,8 @@
   ~ limitations under the License.
   -->
 <resources xmlns:tools="http://schemas.android.com/tools" tools:ignore="MissingTranslation">
-  <string name="leak_canary_about_title">About LeakCanary</string>
+  <string name="leak_canary_about_menu">About LeakCanary</string>
+  <string name="leak_canary_about_title">About LeakCanary %s</string>
   <string name="leak_canary_about_message"><![CDATA[<a href="https://github.com/square/leakcanary">LeakCanary</a>
   is a memory leak detection library for Android, created by
   <a href="https://twitter.com/Piwai">Pierre-Yves Ricau</a> and open sourced by <a href="https://square.github.io">Square</a>.<br><br>
@@ -25,6 +26,7 @@
   <string name="leak_canary_analysis_success_notification">Analysis done: %1$d leaks (%2$d new, %3$d known, %4$d won\'t fix)</string>
   <string name="leak_canary_class_has_leaked">%1$s Leaked</string>
   <string name="leak_canary_download_dump">You can download the heap dump via \"Menu > Share Heap Dump\" or \"adb pull %1$s\"</string>
+  <string name="leak_canary_explorer_search_classes">Search classes</string>
   <string name="leak_canary_loading_title">Loading…</string>
   <string name="leak_canary_notification_analysing">Analyzing Heap Dump</string>
   <string name="leak_canary_notification_channel_low">LeakCanary Low Priority</string>
@@ -82,6 +84,7 @@
   <string name="leak_canary_options_menu_import_hprof_file">Import &amp; Analyze Hprof File</string>
   <string name="leak_canary_options_menu_see_analysis_list">See Analysis List</string>
   <string name="leak_canary_options_menu_render_heap_dump">Render Heap Dump</string>
+  <string name="leak_canary_options_menu_explore_heap_dump">Explore Heap Dump</string>
   <string name="leak_canary_heap_analysis_success_screen_no_path_to_instance_count">%d non leaking retained instances</string>
   <string name="leak_canary_help_title">Tap here to learn more</string>
 </resources>
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
index 3310522f..f38d1d44 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
@@ -175,7 +175,7 @@ class InstrumentationLeakDetector {
     val heapAnalyzer = HeapAnalyzer(listener)
     val heapAnalysis = heapAnalyzer.checkForLeaks(
         heapDumpFile, AndroidKnownReference.mapToExclusions(config.knownReferences), config.computeRetainedHeapSize,
-        config.leakTraceInspectors
+        config.objectInspectors
     )
 
     CanaryLog.d("Heap Analysis:\n%s", heapAnalysis)
diff --git a/leakcanary-cli/build.gradle b/leakcanary-cli/build.gradle
new file mode 100644
index 00000000..0aa040f9
--- /dev/null
+++ b/leakcanary-cli/build.gradle
@@ -0,0 +1,31 @@
+apply plugin: 'java'
+apply plugin: 'kotlin'
+apply plugin: 'application'
+
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
+
+dependencies {
+  api project(':leakcanary-analyzer')
+
+  implementation deps.androidx.annotation
+  implementation deps.kotlin.stdlib
+}
+
+def mainClass = 'leakcanary.MainKt'
+
+application {
+  mainClassName = mainClass
+}
+
+jar {
+  manifest {
+    attributes 'Main-Class': mainClass
+  }
+  from {
+    configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
+  }
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/leakcanary-cli/gradle.properties b/leakcanary-cli/gradle.properties
new file mode 100644
index 00000000..0f3d503e
--- /dev/null
+++ b/leakcanary-cli/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-cli
+POM_NAME=LeakCanary Command Line Interface
+POM_PACKAGING=jar
diff --git a/leakcanary-cli/src/main/java/leakcanary/CLILogger.kt b/leakcanary-cli/src/main/java/leakcanary/CLILogger.kt
new file mode 100644
index 00000000..ddfea9c9
--- /dev/null
+++ b/leakcanary-cli/src/main/java/leakcanary/CLILogger.kt
@@ -0,0 +1,39 @@
+package leakcanary
+
+import leakcanary.CanaryLog.Logger
+import java.io.PrintWriter
+import java.io.StringWriter
+
+class CLILogger : Logger {
+
+  override fun d(
+    message: String,
+    vararg args: Any?
+  ) {
+    val formatted = if (args.isNotEmpty()) {
+      String.format(message, *args)
+    } else {
+      message
+    }
+    println(formatted)
+  }
+
+  override fun d(
+    throwable: Throwable?,
+    message: String,
+    vararg args: Any?
+  ) {
+    d(String.format(message, *args) + '\n' + getStackTraceString(throwable))
+  }
+
+  private fun getStackTraceString(throwable: Throwable?): String {
+    if (throwable == null) {
+      return ""
+    }
+    val stringWriter = StringWriter()
+    val printWriter = PrintWriter(stringWriter, false)
+    throwable.printStackTrace(printWriter)
+    printWriter.flush()
+    return stringWriter.toString()
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-cli/src/main/java/leakcanary/Main.kt b/leakcanary-cli/src/main/java/leakcanary/Main.kt
new file mode 100644
index 00000000..4d91efb0
--- /dev/null
+++ b/leakcanary-cli/src/main/java/leakcanary/Main.kt
@@ -0,0 +1,135 @@
+package leakcanary
+
+import leakcanary.AnalyzerProgressListener.Step
+import java.io.File
+import java.text.SimpleDateFormat
+import java.util.Date
+import java.util.Locale
+import java.util.concurrent.TimeUnit.SECONDS
+
+fun main(args: Array<String>) {
+  CanaryLog.logger = CLILogger()
+  when {
+    args.size == 2 && args[0] == "analyze-process" -> {
+      val heapDumpFile = dumpHeap(args[1])
+      analyze(heapDumpFile)
+    }
+    args.size == 2 && args[0] == "dump-process" -> dumpHeap(args[1])
+    args.size == 2 && args[0] == "analyze-file" -> analyze(File(args[1]))
+    else -> printHelp()
+  }
+}
+
+fun printHelp() {
+  val workingDirectory = File(System.getProperty("user.dir"))
+
+  CanaryLog.d("""
+    LeakCanary CLI
+    Running in directory $workingDirectory
+
+    Commands: [analyze-process, dump-process, analyze-file]
+
+    analyze-process: Dumps the heap for the provided process name, pulls the hprof file and analyzes it.
+      USAGE: analyze-process PROCESS_PACKAGE_NAME
+
+    dump-process: Dumps the heap for the provided process name and pulls the hprof file.
+      USAGE: dump-process PROCESS_PACKAGE_NAME
+
+    analyze-file: Analyzes the provided hprof file.
+      USAGE: analyze-file HPROF_FILE_PATH
+  """.trimIndent())
+}
+
+private fun dumpHeap(packageName: String): File {
+  val workingDirectory = File(System.getProperty("user.dir"))
+
+  val processList = runCommand(workingDirectory, "adb", "shell", "ps")
+
+  val matchingProcesses = processList.lines()
+      .filter { it.contains(packageName) }
+      .map {
+        val columns = Regex("\\s+").split(it)
+        columns[8] to columns[1]
+      }
+
+  val (processName, processId) = if (matchingProcesses.size == 1) {
+    matchingProcesses[0]
+  } else if (matchingProcesses.isEmpty()) {
+    CanaryLog.d("No process matching \"$packageName\"")
+    System.exit(1)
+    throw RuntimeException("System exiting with error")
+  } else {
+    val matchingExactly = matchingProcesses.firstOrNull { it.first == packageName }
+    if (matchingExactly != null) {
+      matchingExactly
+    } else {
+      CanaryLog.d(
+          "More than one process matches \"$packageName\" but none matches exactly: ${matchingProcesses.map { it.first }}"
+      )
+      System.exit(1)
+      throw RuntimeException("System exiting with error")
+    }
+  }
+
+  val heapDumpFileName =
+    SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'-$processName.hprof'", Locale.US).format(
+        Date()
+    )
+
+  val heapDumpDevicePath = "/data/local/tmp/$heapDumpFileName"
+
+  CanaryLog.d(
+      "Dumping heap for process \"$processName\" with pid $processId to $heapDumpDevicePath"
+  )
+
+  runCommand(workingDirectory, "adb", "shell", "am", "dumpheap", processId, heapDumpDevicePath)
+
+  // Dump heap takes time but adb returns immediately.
+  Thread.sleep(5000)
+
+  CanaryLog.d("Pulling $heapDumpDevicePath")
+
+  val pullResult = runCommand(workingDirectory, "adb", "pull", heapDumpDevicePath)
+  CanaryLog.d(pullResult)
+  CanaryLog.d("Removing $heapDumpDevicePath")
+
+  runCommand(workingDirectory, "adb", "shell", "rm", heapDumpDevicePath)
+
+  val heapDumpFile = File(workingDirectory, heapDumpFileName)
+  CanaryLog.d("Pulled heap dump to $heapDumpFile")
+
+  return heapDumpFile
+}
+
+private fun runCommand(
+  directory: File,
+  vararg arguments: String
+): String {
+  val process = ProcessBuilder(*arguments)
+      .directory(directory)
+      .start()
+      .also { it.waitFor(10, SECONDS) }
+
+  if (process.exitValue() != 0) {
+    throw Exception(process.errorStream.bufferedReader().readText())
+  }
+  return process.inputStream.bufferedReader()
+      .readText()
+}
+
+private fun analyze(heapDumpFile: File) {
+  val listener = object : AnalyzerProgressListener {
+    override fun onProgressUpdate(step: Step) {
+      CanaryLog.d(step.name)
+    }
+  }
+
+  val heapAnalyzer = HeapAnalyzer(listener)
+  CanaryLog.d("Analyzing heap dump $heapDumpFile")
+  val heapAnalysis = heapAnalyzer.checkForLeaks(
+      heapDumpFile, AndroidKnownReference.mapToExclusions(AndroidKnownReference.appDefaults), true,
+      AndroidObjectInspectors.defaultInspectors()
+  )
+
+  CanaryLog.d(heapAnalysis.toString())
+}
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt b/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
index b9608557..a19c8de3 100644
--- a/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
@@ -50,21 +50,16 @@ class GraphHeapValue(
   val isNonNullReference: Boolean
     get() = actual is ObjectReference && !actual.isNull
 
-  val referencesJavaString: Boolean
-    get() = actual is ObjectReference && graph.referencesJavaString(actual)
-
-  val referencesClass: Boolean
-    get() = actual is ObjectReference && graph.referencesClass(actual)
+  val asObject: GraphObjectRecord?
+    get() {
+      return if (actual is ObjectReference && !actual.isNull) {
+        return graph.indexedObject(actual.value)
+      } else {
+        null
+      }
+    }
 
   fun readAsJavaString(): String? {
-    return readObjectRecord()?.asInstance?.readAsJavaString()
-  }
-
-  fun readObjectRecord(): GraphObjectRecord? {
-    return if (actual is ObjectReference && !actual.isNull) {
-      return graph.readGraphObjectRecord(actual.value)
-    } else {
-      null
-    }
+    return asObject?.asInstance?.readAsJavaString()
   }
 }
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt b/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
index b52d3491..de1dc72c 100644
--- a/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
@@ -1,5 +1,6 @@
 package leakcanary
 
+import leakcanary.HeapValue.ObjectReference
 import leakcanary.Record.HeapDumpRecord.ObjectRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
@@ -7,11 +8,18 @@ import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import leakcanary.internal.IndexedObject.IndexedClass
+import leakcanary.internal.IndexedObject.IndexedInstance
+import leakcanary.internal.IndexedObject.IndexedObjectArray
+import leakcanary.internal.IndexedObject.IndexedPrimitiveArray
 import java.nio.charset.Charset
 import kotlin.reflect.KClass
 
 sealed class GraphObjectRecord {
-  abstract val record: ObjectRecord
+
+  abstract val objectId: Long
+
+  abstract fun readRecord(): ObjectRecord
 
   val asClass: GraphClassRecord?
     get() = if (this is GraphClassRecord) this else null
@@ -25,13 +33,17 @@ sealed class GraphObjectRecord {
   val asPrimitiveArray: GraphPrimitiveArrayRecord?
     get() = if (this is GraphPrimitiveArrayRecord) this else null
 
-  class GraphClassRecord(
+  class GraphClassRecord internal constructor(
     private val graph: HprofGraph,
-    override val record: ClassDumpRecord
+    private val indexedObject: IndexedClass,
+    override val objectId: Long
   ) : GraphObjectRecord() {
+    override fun readRecord(): ClassDumpRecord {
+      return graph.readClassDumpRecord(objectId, indexedObject)
+    }
 
     val name: String
-      get() = graph.className(record.id)
+      get() = graph.className(objectId)
 
     val simpleName: String
       get() {
@@ -44,28 +56,32 @@ sealed class GraphObjectRecord {
         }
       }
 
-    fun readSuperClass(): GraphClassRecord? {
-      if (record.superClassId == 0L) return null
-      val superClassRecord = graph.readObjectRecord(record.superClassId) as ClassDumpRecord
-      return GraphClassRecord(graph, superClassRecord)
-    }
+    val instanceSize: Int
+      get() = indexedObject.instanceSize
 
-    fun readClassHierarchy(): Sequence<GraphClassRecord> =
-      generateSequence(this) { it.readSuperClass() }
-
-    val staticFields
-      get(): List<GraphField> {
-        val fields = mutableListOf<GraphField>()
-        for (fieldRecord in record.staticFields) {
-          fields += GraphField(
-              this, graph.staticFieldName(fieldRecord), GraphHeapValue(graph, fieldRecord.value)
-          )
-        }
-        return fields
+    val superClass: GraphClassRecord?
+      get() {
+        if (indexedObject.superClassId == 0L) return null
+        return graph.indexedObject(indexedObject.superClassId) as GraphClassRecord
       }
 
+    val classHierarchy: Sequence<GraphClassRecord>
+      get() = generateSequence(this) { it.superClass }
+
+    val directInstances: Sequence<GraphInstanceRecord>
+      get() = graph.instanceSequence().filter { it.indexedObject.classId == objectId }
+
+    fun readStaticFields(): Sequence<GraphField> {
+      return readRecord().staticFields.asSequence()
+          .map { fieldRecord ->
+            GraphField(
+                this, graph.staticFieldName(fieldRecord), GraphHeapValue(graph, fieldRecord.value)
+            )
+          }
+    }
+
     operator fun get(fieldName: String): GraphField? {
-      for (fieldRecord in record.staticFields) {
+      for (fieldRecord in readRecord().staticFields) {
         if (graph.staticFieldName(fieldRecord) == fieldName) {
           return GraphField(
               this, graph.staticFieldName(fieldRecord), GraphHeapValue(graph, fieldRecord.value)
@@ -76,13 +92,18 @@ sealed class GraphObjectRecord {
     }
   }
 
-  class GraphInstanceRecord(
+  class GraphInstanceRecord internal constructor(
     private val graph: HprofGraph,
-    override val record: InstanceDumpRecord
+    internal val indexedObject: IndexedInstance,
+    override val objectId: Long,
+    val isPrimitiveWrapper: Boolean
   ) : GraphObjectRecord() {
+    override fun readRecord(): InstanceDumpRecord {
+      return graph.readInstanceDumpRecord(objectId, indexedObject)
+    }
 
     infix fun instanceOf(className: String): Boolean {
-      var currentClassId = record.classId
+      var currentClassId = indexedObject.classId
       while (currentClassId != 0L) {
         if (graph.className(currentClassId) == className) {
           return true
@@ -112,7 +133,7 @@ sealed class GraphObjectRecord {
     }
 
     val className: String
-      get() = graph.className(record.classId)
+      get() = graph.className(indexedObject.classId)
 
     val classSimpleName: String
       get() {
@@ -125,18 +146,19 @@ sealed class GraphObjectRecord {
         }
       }
 
-    fun readClass(): GraphClassRecord {
-      val classRecord = graph.readObjectRecord(record.classId) as ClassDumpRecord
-      return GraphClassRecord(graph, classRecord)
-    }
+    val instanceClass: GraphClassRecord
+      get() {
+        return graph.indexedObject(indexedObject.classId) as GraphClassRecord
+      }
 
     fun readFields(): Sequence<GraphField> {
       val fieldReader by lazy {
-        graph.createFieldValuesReader(record)
+        graph.createFieldValuesReader(readRecord())
       }
-      return readClass().readClassHierarchy()
+      return instanceClass.classHierarchy
           .map { classRecord ->
-            classRecord.record.fields.asSequence()
+            classRecord.readRecord()
+                .fields.asSequence()
                 .map { fieldRecord ->
                   val fieldName = graph.fieldName(fieldRecord)
                   val fieldValue = fieldReader.readValue(fieldRecord)
@@ -147,7 +169,7 @@ sealed class GraphObjectRecord {
     }
 
     fun readAsJavaString(): String? {
-      if (!graph.isJavaString(record)) {
+      if (className != "java.lang.String") {
         return null
       }
       val count = this["java.lang.String", "count"]!!.value.asInt!!
@@ -159,7 +181,7 @@ sealed class GraphObjectRecord {
       // Since API 26 String.value is backed by native code. The vast majority of strings in a
       // heap dump are backed by a byte array, but we still find a few backed by a char array.
       when (val valueRecord =
-        this["java.lang.String", "value"]!!.value.readObjectRecord()!!.record) {
+        this["java.lang.String", "value"]!!.value.asObject!!.readRecord()) {
         is CharArrayDump -> {
           // < API 23
           // As of Marshmallow, substrings no longer share their parent strings' char arrays
@@ -175,24 +197,43 @@ sealed class GraphObjectRecord {
         }
         else -> throw UnsupportedOperationException(
             "'value' field ${this["java.lang.String", "value"]!!.value} was expected to be either" +
-                " a char or byte array in string instance with id ${record.id}"
+                " a char or byte array in string instance with id $objectId"
         )
       }
     }
   }
 
-  class GraphObjectArrayRecord(
+  class GraphObjectArrayRecord internal constructor(
     private val graph: HprofGraph,
-    override val record: ObjectArrayDumpRecord
+    private val indexedObject: IndexedObjectArray,
+    override val objectId: Long,
+    val isPrimitiveWrapperArray: Boolean
   ) : GraphObjectRecord() {
 
     val arrayClassName: String
-      get() = graph.className(record.arrayClassId)
+      get() = graph.className(indexedObject.arrayClassId)
+
+    override fun readRecord(): ObjectArrayDumpRecord {
+      return graph.readObjectArrayDumpRecord(objectId, indexedObject)
+    }
+
+    fun readElements(): Sequence<GraphHeapValue> {
+      return readRecord().elementIds.asSequence()
+          .map { GraphHeapValue(graph, ObjectReference(it)) }
+    }
   }
 
-  class GraphPrimitiveArrayRecord(
-    override val record: PrimitiveArrayDumpRecord
+  class GraphPrimitiveArrayRecord internal constructor(
+    private val graph: HprofGraph,
+    private val indexedObject: IndexedPrimitiveArray,
+    override val objectId: Long
   ) : GraphObjectRecord() {
+    val primitiveType: PrimitiveType
+      get() = indexedObject.primitiveType
+
+    override fun readRecord(): PrimitiveArrayDumpRecord {
+      return graph.readPrimitiveArrayDumpRecord(objectId, indexedObject)
+    }
   }
 
 }
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
index e3d4c523..71810636 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
@@ -4,9 +4,7 @@ import leakcanary.GraphObjectRecord.GraphClassRecord
 import leakcanary.GraphObjectRecord.GraphInstanceRecord
 import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
 import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.ObjectIdMetadata.CLASS
-import leakcanary.ObjectIdMetadata.STRING
+import leakcanary.HprofPushRecordsParser.OnRecordListener
 import leakcanary.Record.HeapDumpRecord.ObjectRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
@@ -22,56 +20,120 @@ import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.Fl
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import leakcanary.internal.HprofInMemoryIndex
+import leakcanary.internal.IndexedObject
+import leakcanary.internal.IndexedObject.IndexedClass
+import leakcanary.internal.IndexedObject.IndexedInstance
+import leakcanary.internal.IndexedObject.IndexedObjectArray
+import leakcanary.internal.IndexedObject.IndexedPrimitiveArray
+import leakcanary.internal.LruCache
 import okio.Buffer
+import java.io.Closeable
+import java.io.File
 
 /**
  * Enables navigation through the Hprof graph of objects.
  */
-class HprofGraph(private val parser: HprofParser) {
+class HprofGraph internal constructor(
+  private val reader: SeekableHprofReader,
+  private val index: HprofInMemoryIndex
+) {
 
-  fun readClass(className: String): GraphClassRecord? {
-    val classId = parser.classId(className)
+  /**
+   * LRU cache size of 3000 is a sweet spot to balance hits vs memory usage.
+   * This is based on running InstrumentationLeakDetectorTest a bunch of time on a
+   * Pixel 2 XL API 28. Hit count was ~120K, miss count ~290K
+   */
+  private val objectCache = LruCache<Long, ObjectRecord>(3000)
+
+  fun indexedClass(className: String): GraphClassRecord? {
+    val classId = index.classId(className)
     return if (classId == null) {
       null
     } else {
-      GraphClassRecord(this, readObjectRecord(classId) as ClassDumpRecord)
+      return indexedObject(classId) as GraphClassRecord
     }
   }
 
   fun readObjectRecord(objectId: Long): ObjectRecord {
-    return parser.retrieveRecordById(objectId)
+    return when (val indexedObject = index.indexedObject(objectId)) {
+      is IndexedInstance -> readInstanceDumpRecord(objectId, indexedObject)
+      is IndexedClass -> readClassDumpRecord(objectId, indexedObject)
+      is IndexedObjectArray -> readObjectArrayDumpRecord(objectId, indexedObject)
+      is IndexedPrimitiveArray -> readPrimitiveArrayDumpRecord(objectId, indexedObject)
+    }
   }
 
-  fun readGraphObjectRecord(objectId: Long): GraphObjectRecord {
-    return wrapObject(parser.retrieveRecordById(objectId))
+  fun indexedObject(objectId: Long): GraphObjectRecord {
+    return when (val indexedObject = index.indexedObject(objectId)) {
+      is IndexedClass -> GraphClassRecord(this, indexedObject, objectId)
+      is IndexedInstance -> {
+        val isPrimitiveWrapper = index.primitiveWrapperTypes.contains(indexedObject.classId)
+        GraphInstanceRecord(this, indexedObject, objectId, isPrimitiveWrapper)
+      }
+      is IndexedObjectArray -> {
+        val isPrimitiveWrapperArray =
+          index.primitiveWrapperTypes.contains(indexedObject.arrayClassId)
+        GraphObjectArrayRecord(this, indexedObject, objectId, isPrimitiveWrapperArray)
+      }
+      is IndexedPrimitiveArray -> GraphPrimitiveArrayRecord(this, indexedObject, objectId)
+    }
   }
 
-  private fun wrapObject(record: ObjectRecord): GraphObjectRecord {
-    return when (record) {
-      is ClassDumpRecord -> GraphClassRecord(this, record)
-      is InstanceDumpRecord -> GraphInstanceRecord(this, record)
-      is ObjectArrayDumpRecord -> GraphObjectArrayRecord(this, record)
-      is PrimitiveArrayDumpRecord -> GraphPrimitiveArrayRecord(record)
+  fun computeShallowSize(graphObject: GraphObjectRecord): Int {
+    return when (graphObject) {
+      is GraphInstanceRecord -> graphObject.instanceClass.instanceSize
+      is GraphObjectArrayRecord -> graphObject.readRecord().elementIds.size * index.idSize
+      is GraphPrimitiveArrayRecord -> when (val record = graphObject.readRecord()) {
+        is BooleanArrayDump -> record.array.size * HprofReader.BOOLEAN_SIZE
+        is CharArrayDump -> record.array.size * HprofReader.CHAR_SIZE
+        is FloatArrayDump -> record.array.size * HprofReader.FLOAT_SIZE
+        is DoubleArrayDump -> record.array.size * HprofReader.DOUBLE_SIZE
+        is ByteArrayDump -> record.array.size * HprofReader.BYTE_SIZE
+        is ShortArrayDump -> record.array.size * HprofReader.SHORT_SIZE
+        is IntArrayDump -> record.array.size * HprofReader.INT_SIZE
+        is LongArrayDump -> record.array.size * HprofReader.LONG_SIZE
+      }
+      is GraphClassRecord -> throw IllegalStateException(
+          "Unexpected record ${graphObject.readRecord()}"
+      )
     }
   }
 
-  fun className(classId: Long): String {
-    return parser.className(classId)
+  fun instanceSequence(): Sequence<GraphInstanceRecord> {
+    return index.indexedInstanceSequence()
+        .map {
+          val objectId = it.first
+          val indexedObject = it.second
+          val isPrimitiveWrapper = index.primitiveWrapperTypes.contains(indexedObject.classId)
+          GraphInstanceRecord(this, indexedObject, objectId, isPrimitiveWrapper)
+        }
   }
 
-  fun fieldName(fieldRecord: FieldRecord): String {
-    return parser.hprofStringById(fieldRecord.nameStringId)
+  fun classSequence(): Sequence<GraphClassRecord> {
+    return index.indexedClassSequence()
+        .map {
+          val objectId = it.first
+          val indexedObject = it.second
+          GraphClassRecord(this, indexedObject, objectId)
+        }
   }
 
-  fun staticFieldName(fieldRecord: StaticFieldRecord): String {
-    return parser.hprofStringById(fieldRecord.nameStringId)
+  fun sizeOfFieldType(hprofType: Int) = index.sizeOfFieldType(hprofType)
+
+  internal fun fieldName(fieldRecord: FieldRecord): String {
+    return index.hprofStringById(fieldRecord.nameStringId)
+  }
+
+  internal fun staticFieldName(fieldRecord: StaticFieldRecord): String {
+    return index.hprofStringById(fieldRecord.nameStringId)
   }
 
-  fun createFieldValuesReader(record: InstanceDumpRecord): FieldValuesReader {
+  internal fun createFieldValuesReader(record: InstanceDumpRecord): FieldValuesReader {
     val buffer = Buffer()
     buffer.write(record.fieldValues)
 
-    val reader = HprofReader(buffer, 0, parser.idSize)
+    val reader = HprofReader(buffer, 0, index.idSize)
 
     return object : FieldValuesReader {
       override fun readValue(field: FieldRecord): HeapValue {
@@ -80,42 +142,74 @@ class HprofGraph(private val parser: HprofParser) {
     }
   }
 
-  fun isJavaString(record: InstanceDumpRecord): Boolean {
-    return parser.objectIdMetadata(record.id) == STRING
+  internal fun className(classId: Long): String {
+    return index.className(classId)
   }
 
-  fun referencesJavaString(reference: ObjectReference): Boolean {
-    return !reference.isNull && parser.objectIdMetadata(reference.value) == STRING
+  internal fun readObjectArrayDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedObjectArray
+  ): ObjectArrayDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      reader.readObjectArrayDumpRecord()
+    }
   }
 
-  fun referencesClass(reference: ObjectReference): Boolean {
-    return !reference.isNull && parser.objectIdMetadata(reference.value) == CLASS
+  internal fun readPrimitiveArrayDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedPrimitiveArray
+  ): PrimitiveArrayDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      reader.readPrimitiveArrayDumpRecord()
+    }
   }
 
-  /**
-   * This API should eventually be removed.
-   */
-  fun objectIdMetadata(objectId: Long): ObjectIdMetadata = parser.objectIdMetadata(objectId)
-
-  fun computeShallowSize(record: ObjectRecord): Int {
-    return when (record) {
-      is InstanceDumpRecord -> {
-        val classRecord = readObjectRecord(record.classId) as ClassDumpRecord
-        // Note: instanceSize is the sum of shallow size through the class hierarchy
-        classRecord.instanceSize
-      }
-      is ObjectArrayDumpRecord -> record.elementIds.size * parser.idSize
-      is BooleanArrayDump -> record.array.size * HprofReader.BOOLEAN_SIZE
-      is CharArrayDump -> record.array.size * HprofReader.CHAR_SIZE
-      is FloatArrayDump -> record.array.size * HprofReader.FLOAT_SIZE
-      is DoubleArrayDump -> record.array.size * HprofReader.DOUBLE_SIZE
-      is ByteArrayDump -> record.array.size * HprofReader.BYTE_SIZE
-      is ShortArrayDump -> record.array.size * HprofReader.SHORT_SIZE
-      is IntArrayDump -> record.array.size * HprofReader.INT_SIZE
-      is LongArrayDump -> record.array.size * HprofReader.LONG_SIZE
-      else -> {
-        throw IllegalStateException("Unexpected record $record")
-      }
+  internal fun readClassDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedClass
+  ): ClassDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      reader.readClassDumpRecord()
+    }
+  }
+
+  internal fun readInstanceDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedInstance
+  ): InstanceDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      reader.readInstanceDumpRecord()
+    }
+  }
+
+  private fun <T : ObjectRecord> readObjectRecord(
+    objectId: Long,
+    indexedObject: IndexedObject,
+    readBlock: () -> T
+  ): T {
+    val objectRecordOrNull = objectCache[objectId]
+    @Suppress("UNCHECKED_CAST")
+    if (objectRecordOrNull != null) {
+      return objectRecordOrNull as T
+    }
+    reader.moveTo(indexedObject.position)
+    return readBlock().apply { objectCache.put(objectId, this) }
+  }
+
+  companion object {
+    fun readHprof(
+      heapDump: File,
+      vararg onRecordListeners: OnRecordListener
+    ): Pair<HprofGraph, Closeable> {
+      val indexListener = HprofInMemoryIndex.createOnRecordListener()
+
+      val parser = HprofPushRecordsParser()
+
+      val reader = parser.readHprofRecords(heapDump, setOf(indexListener) + onRecordListeners)
+
+      val hprofGraph = HprofGraph(reader, indexListener.buildIndex())
+
+      return hprofGraph to reader
     }
   }
 
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt b/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
deleted file mode 100644
index 05633e84..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
+++ /dev/null
@@ -1,838 +0,0 @@
-package leakcanary
-
-import leakcanary.GcRoot.Debugger
-import leakcanary.GcRoot.Finalizing
-import leakcanary.GcRoot.InternedString
-import leakcanary.GcRoot.JavaFrame
-import leakcanary.GcRoot.JniGlobal
-import leakcanary.GcRoot.JniLocal
-import leakcanary.GcRoot.JniMonitor
-import leakcanary.GcRoot.MonitorUsed
-import leakcanary.GcRoot.NativeStack
-import leakcanary.GcRoot.ReferenceCleanup
-import leakcanary.GcRoot.StickyClass
-import leakcanary.GcRoot.ThreadBlock
-import leakcanary.GcRoot.ThreadObject
-import leakcanary.GcRoot.Unknown
-import leakcanary.GcRoot.Unreachable
-import leakcanary.GcRoot.VmInternal
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.HprofReader.Companion.BYTE_SIZE
-import leakcanary.HprofReader.Companion.INT_SIZE
-import leakcanary.HprofReader.Companion.INT_TYPE
-import leakcanary.HprofReader.Companion.LONG_SIZE
-import leakcanary.HprofReader.Companion.OBJECT_TYPE
-import leakcanary.HprofReader.Companion.SHORT_SIZE
-import leakcanary.ObjectIdMetadata.EMPTY_INSTANCE
-import leakcanary.ObjectIdMetadata.INSTANCE
-import leakcanary.ObjectIdMetadata.INTERNAL_MAYBE_EMPTY_INSTANCE
-import leakcanary.ObjectIdMetadata.STRING
-import leakcanary.Record.HeapDumpEndRecord
-import leakcanary.Record.HeapDumpRecord.GcRootRecord
-import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import leakcanary.Record.LoadClassRecord
-import leakcanary.Record.StackFrameRecord
-import leakcanary.Record.StackTraceRecord
-import leakcanary.Record.StringRecord
-import leakcanary.internal.LongToIntSparseArray
-import leakcanary.internal.LongToLongSparseArray
-import leakcanary.internal.LongToStringSparseArray
-import leakcanary.internal.LruCache
-import okio.Buffer
-import okio.buffer
-import okio.source
-import java.io.Closeable
-import java.io.File
-import java.nio.charset.Charset
-import kotlin.properties.Delegates.notNull
-import kotlin.reflect.KClass
-
-/**
- * A memory efficient heap dump parser.
- *
- * Expected usage: call [scan] once, which will go read through the entire heap dump, build indices,
- * and let consumers collect non indexed data (e.g. all instances of X, or all gc roots, etc).
- *
- * Then navigate on the heap using object ids which [scan] has indexed to file positions.
- *
- * This class is not thread safe, should be used from a single thread.
- *
- * Binary Dump Format reference: http://hg.openjdk.java.net/jdk6/jdk6/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html#mozTocId848088
- *
- * The Android Hprof format differs in some ways from that reference. This parser implementation
- * is largely adapted from https://android.googlesource.com/platform/tools/base/+/studio-master-dev/perflib/src/main/java/com/android/tools/perflib
- *
- * Also some of the ideas come from https://github.com/square/leakcanary/pull/1278
- */
-class HprofParser private constructor(
-  private val reader: SeekableHprofReader
-) : Closeable {
-
-  private var scanning = false
-  private var indexBuilt = false
-
-  val position
-    get() = reader.position
-
-  val idSize
-    get() = reader.idSize
-
-  /**
-   * Map of string id to string
-   * This currently keeps all the hprof strings that we could care about: class names,
-   * static field names and instance fields names
-   */
-  // TODO Replacing with a radix trie reversed into a sparse array of long to trie leaf could save
-  // memory.
-  // Another option is to switch back to reading from the file system as necessary, and keep a much
-  // smaller cache for strings we need during shortest path (those are for exclusions)
-  private val hprofStringCache = LongToStringSparseArray(60000)
-
-  /**
-   * class id to string id
-   */
-  private val classNames = LongToLongSparseArray(20000)
-
-  /**
-   * Object id to ([ObjectIdMetadata], object position). We pack the metadata ordinal and the
-   * position into an int, which gives us 3 bits for the metadata (enum with at most 8 values)
-   * and 29 bits for the position, which means the heap dump file must be at most 512 MiB.
-   *
-   * The id can be for classes instances, classes, object arrays and primitive arrays
-   */
-  private val objectIndex = LongToIntSparseArray(250000)
-
-  /**
-   * LRU cache size of 3000 is a sweet spot to balance hits vs memory usage.
-   * This is based on running InstrumentationLeakDetectorTest a bunch of time on a
-   * Pixel 2 XL API 28. Hit count was ~120K, miss count ~290K
-   */
-  private val objectCache = LruCache<Long, ObjectRecord>(3000)
-
-  /**
-   * Class ids for primitive wrapper types
-   */
-  private val primitiveWrapperTypes = mutableSetOf<Long>()
-
-  /**
-   * String ids for class names of primitive wrapper types
-   */
-  private val primitiveWrapperClassNames = mutableSetOf<Long>()
-
-  private var maybeEmptyInstancesAreEmpty by notNull<Boolean>()
-
-  class RecordCallbacks {
-    private val callbacks = mutableMapOf<Class<out Record>, Any>()
-
-    fun <T : Record> on(
-      recordClass: Class<T>,
-      callback: (T) -> Unit
-    ): RecordCallbacks {
-      callbacks[recordClass] = callback
-      return this
-    }
-
-    fun <T : Record> get(recordClass: Class<T>): ((T) -> Unit)? {
-      @Suppress("UNCHECKED_CAST")
-      return callbacks[recordClass] as ((T) -> Unit)?
-    }
-
-    inline fun <reified T : Record> get(): ((T) -> Unit)? {
-      return get(T::class.java)
-    }
-  }
-
-  override fun close() {
-    reader.close()
-  }
-
-  fun scan(callbacks: RecordCallbacks) {
-    reader.scan(callbacks)
-  }
-
-  private fun SeekableHprofReader.scan(callbacks: RecordCallbacks) {
-    if (!isOpen) {
-      throw IllegalStateException("Reader closed")
-    }
-
-    if (scanning) {
-      throw UnsupportedOperationException("Cannot scan while already scanning.")
-    }
-
-    scanning = true
-
-    reset()
-
-    // heap dump timestamp
-    skip(LONG_SIZE)
-
-    // shadow$_klass_ (object id) + shadow$_monitor_ (Int)
-    val maybeEmptySize = typeSize(OBJECT_TYPE) + typeSize(INT_TYPE)
-
-    while (!exhausted()) {
-      // type of the record
-      val tag = readUnsignedByte()
-
-      // number of microseconds since the time stamp in the header
-      skip(INT_SIZE)
-
-      // number of bytes that follow and belong to this record
-      val length = readUnsignedInt()
-
-      when (tag) {
-        STRING_IN_UTF8 -> {
-          val callback = callbacks.get<StringRecord>()
-          if (callback != null || !indexBuilt) {
-            val id = readId()
-            val stringLength = length - idSize
-            val string = readUtf8(stringLength)
-            if (!indexBuilt) {
-              if (PRIMITIVE_WRAPPER_TYPES.contains(string)) {
-                primitiveWrapperClassNames.add(id)
-              }
-              hprofStringCache[id] = string
-            }
-            if (callback != null) {
-              callback(StringRecord(id, string))
-            }
-          } else {
-            skip(length)
-          }
-        }
-        LOAD_CLASS -> {
-          val callback = callbacks.get<LoadClassRecord>()
-          if (callback != null || !indexBuilt) {
-            val classSerialNumber = readInt()
-            val id = readId()
-            val stackTraceSerialNumber = readInt()
-            val classNameStringId = readId()
-            if (!indexBuilt) {
-              classNames[id] = classNameStringId
-              if (primitiveWrapperClassNames.contains(classNameStringId)) {
-                primitiveWrapperTypes.add(id)
-              }
-            }
-            if (callback != null) {
-              callback(
-                  LoadClassRecord(
-                      classSerialNumber = classSerialNumber,
-                      id = id,
-                      stackTraceSerialNumber = stackTraceSerialNumber,
-                      classNameStringId = classNameStringId
-                  )
-              )
-            }
-          } else {
-            skip(length)
-          }
-        }
-        STACK_FRAME -> {
-          val callback = callbacks.get<StackFrameRecord>()
-          if (callback != null) {
-            callback(
-                StackFrameRecord(
-                    id = readId(),
-                    methodNameStringId = readId(),
-                    methodSignatureStringId = readId(),
-                    sourceFileNameStringId = readId(),
-                    classSerialNumber = readInt(),
-                    lineNumber = readInt()
-                )
-            )
-          } else {
-            skip(length)
-          }
-        }
-        STACK_TRACE -> {
-          val callback = callbacks.get<StackTraceRecord>()
-          if (callback != null) {
-            val stackTraceSerialNumber = readInt()
-            val threadSerialNumber = readInt()
-            val frameCount = readInt()
-            val stackFrameIds = readIdArray(frameCount)
-            callback(
-                StackTraceRecord(
-                    stackTraceSerialNumber = stackTraceSerialNumber,
-                    threadSerialNumber = threadSerialNumber,
-                    stackFrameIds = stackFrameIds
-                )
-            )
-          } else {
-            skip(length)
-          }
-        }
-        HEAP_DUMP, HEAP_DUMP_SEGMENT -> {
-          val heapDumpStart = position
-          var previousTag = 0
-          while (position - heapDumpStart < length) {
-            val heapDumpTag = readUnsignedByte()
-
-            when (heapDumpTag) {
-              ROOT_UNKNOWN -> {
-                val callback = callbacks.get<GcRootRecord>()
-                if (callback != null) {
-                  callback(
-                      GcRootRecord(
-                          gcRoot = Unknown(id = readId())
-                      )
-                  )
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_JNI_GLOBAL -> {
-                val callback = callbacks.get<GcRootRecord>()
-                if (callback != null) {
-                  callback(
-                      GcRootRecord(
-                          gcRoot = JniGlobal(id = readId(), jniGlobalRefId = readId())
-                      )
-                  )
-                } else {
-                  skip(idSize + idSize)
-                }
-              }
-
-              ROOT_JNI_LOCAL -> {
-                val callback = callbacks.get<GcRootRecord>()
-                if (callback != null) {
-                  callback(
-                      GcRootRecord(
-                          gcRoot = JniLocal(
-                              id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
-                          )
-                      )
-                  )
-                } else {
-                  skip(idSize + INT_SIZE + INT_SIZE)
-                }
-              }
-
-              ROOT_JAVA_FRAME -> {
-                val callback = callbacks.get<GcRootRecord>()
-                if (callback != null) {
-                  callback(
-                      GcRootRecord(
-                          gcRoot = JavaFrame(
-                              id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
-                          )
-                      )
-                  )
-                } else {
-                  skip(idSize + INT_SIZE + INT_SIZE)
-                }
-              }
-
-              ROOT_NATIVE_STACK -> {
-                val callback = callbacks.get<GcRootRecord>()
-                if (callback != null) {
-                  callback(
-                      GcRootRecord(
-                          gcRoot = NativeStack(id = readId(), threadSerialNumber = readInt())
-                      )
-                  )
-                } else {
-                  skip(idSize + INT_SIZE)
-                }
-              }
-
-              ROOT_STICKY_CLASS -> {
-                val callback = callbacks.get<GcRootRecord>()
-                if (callback != null) {
-                  callback(
-                      GcRootRecord(
-                          gcRoot = StickyClass(id = readId())
-                      )
-                  )
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              // An object that was referenced from an active thread block.
-              ROOT_THREAD_BLOCK -> {
-                val callback = callbacks.get<GcRootRecord>()
-                if (callback != null) {
-                  callback(
-                      GcRootRecord(
-                          gcRoot = ThreadBlock(id = readId(), threadSerialNumber = readInt())
-                      )
-                  )
-                } else {
-                  skip(idSize + INT_SIZE)
-                }
-              }
-
-              ROOT_MONITOR_USED -> {
-                val callback = callbacks.get<GcRootRecord>()
-                if (callback != null) {
-                  callback(
-                      GcRootRecord(
-                          gcRoot = MonitorUsed(id = readId())
-                      )
-                  )
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_THREAD_OBJECT -> {
-                val callback = callbacks.get<GcRootRecord>()
-                if (callback != null) {
-                  callback(
-                      GcRootRecord(
-                          gcRoot = ThreadObject(
-                              id = readId(),
-                              threadSerialNumber = readInt(),
-                              stackTraceSerialNumber = readInt()
-                          )
-                      )
-                  )
-                } else {
-                  skip(idSize + INT_SIZE + INT_SIZE)
-                }
-              }
-
-              CLASS_DUMP -> {
-                val callback = callbacks.get<ClassDumpRecord>()
-                val id = readId()
-                if (!indexBuilt) {
-                  objectIndex[id] =
-                    ObjectIdMetadata.CLASS.packOrdinalWithFilePosition(tagPositionAfterReadingId)
-                }
-
-                val computeObjectClassSize = !indexBuilt && className(id) == "java.lang.Object"
-                if (callback != null || computeObjectClassSize) {
-                  val classDumpRecord = readClassDumpRecord(id)
-                  if (computeObjectClassSize) {
-                    // In Android 16 classDumpRecord.instanceSize can be 8 yet there are 0 fields.
-                    // Better rely on our own computation of instance size.
-                    // See #1374
-                    val objectClassFieldSize = classDumpRecord.fields.sumBy {
-                      typeSize(it.type)
-                    }
-                    maybeEmptyInstancesAreEmpty = when (objectClassFieldSize) {
-                      0 -> false
-                      maybeEmptySize -> true
-                      else ->
-                        // We might need to make this more generic in the future.
-                        TODO(
-                            "Unexpected Object class field size ${classDumpRecord.instanceSize}, fields ${classDumpRecord.fields}"
-                        )
-                    }
-                  }
-                  if (callback != null) {
-                    callback(classDumpRecord)
-                  }
-                } else {
-                  skip(
-                      INT_SIZE + idSize + idSize + idSize + idSize + idSize + idSize + INT_SIZE
-                  )
-                  // Skip over the constant pool
-                  val constantPoolCount = readUnsignedShort()
-                  for (i in 0 until constantPoolCount) {
-                    // constant pool index
-                    skip(SHORT_SIZE)
-                    skip(typeSize(readUnsignedByte()))
-                  }
-
-                  val staticFieldCount = readUnsignedShort()
-
-                  for (i in 0 until staticFieldCount) {
-                    skip(idSize)
-                    val type = readUnsignedByte()
-                    skip(typeSize(type))
-                  }
-
-                  val fieldCount = readUnsignedShort()
-                  skip(fieldCount * (idSize + BYTE_SIZE))
-                }
-              }
-
-              INSTANCE_DUMP -> {
-                val id = readId()
-                val callback = callbacks.get<InstanceDumpRecord>()
-                if (callback != null || !indexBuilt) {
-                  val recordPosition = tagPositionAfterReadingId
-                  val instanceDumpRecord = readInstanceDumpRecord(id)
-                  if (!indexBuilt) {
-                    val metadata = when {
-                      primitiveWrapperTypes.contains(
-                          instanceDumpRecord.classId
-                      ) -> ObjectIdMetadata.PRIMITIVE_WRAPPER_OR_PRIMITIVE_ARRAY
-                      hprofStringCache[classNames[instanceDumpRecord.classId]] == "java.lang.String" -> STRING
-                      instanceDumpRecord.fieldValues.isEmpty() -> EMPTY_INSTANCE
-                      instanceDumpRecord.fieldValues.size <= maybeEmptySize -> INTERNAL_MAYBE_EMPTY_INSTANCE
-                      else -> INSTANCE
-                    }
-                    objectIndex[id] = metadata.packOrdinalWithFilePosition(recordPosition)
-                  }
-                  if (callback != null) {
-                    callback(instanceDumpRecord)
-                  }
-                } else {
-                  skip(INT_SIZE + idSize)
-                  val remainingBytesInInstance = readInt()
-                  skip(remainingBytesInInstance)
-                }
-              }
-
-              OBJECT_ARRAY_DUMP -> {
-                val id = readId()
-
-                val callback = callbacks.get<ObjectArrayDumpRecord>()
-                if (callback != null || !indexBuilt) {
-                  val recordPosition = tagPositionAfterReadingId
-                  val arrayRecord = readObjectArrayDumpRecord(id)
-                  if (!indexBuilt) {
-                    val metadata = if (primitiveWrapperTypes.contains(arrayRecord.arrayClassId)) {
-                      ObjectIdMetadata.PRIMITIVE_WRAPPER_ARRAY
-                    } else {
-                      ObjectIdMetadata.OBJECT_ARRAY
-                    }
-                    objectIndex[id] = metadata.packOrdinalWithFilePosition(recordPosition)
-                  }
-                  if (callback != null) {
-                    callback(arrayRecord)
-                  }
-                } else {
-                  skip(INT_SIZE)
-                  val arrayLength = readInt()
-                  skip(idSize + arrayLength * idSize)
-                }
-              }
-
-              PRIMITIVE_ARRAY_DUMP -> {
-                val id = readId()
-                if (!indexBuilt) {
-                  objectIndex[id] =
-                    ObjectIdMetadata.PRIMITIVE_WRAPPER_OR_PRIMITIVE_ARRAY.packOrdinalWithFilePosition(
-                        tagPositionAfterReadingId
-                    )
-                }
-                val callback = callbacks.get<PrimitiveArrayDumpRecord>()
-                if (callback != null) {
-                  callback(readPrimitiveArrayDumpRecord(id))
-                } else {
-                  skip(INT_SIZE)
-                  val arrayLength = readInt()
-                  val type = readUnsignedByte()
-                  skip(arrayLength * typeSize(type))
-                }
-              }
-
-              PRIMITIVE_ARRAY_NODATA -> {
-                throw UnsupportedOperationException(
-                    "PRIMITIVE_ARRAY_NODATA cannot be parsed"
-                )
-              }
-
-              HEAP_DUMP_INFO -> {
-                val heapId = readInt()
-                val callback = callbacks.get<HeapDumpInfoRecord>()
-                if (callback != null) {
-                  val record =
-                    HeapDumpInfoRecord(heapId = heapId, heapNameStringId = readId())
-                  callback(record)
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_INTERNED_STRING -> {
-                val callback = callbacks.get<GcRootRecord>()
-                if (callback != null) {
-                  callback(
-                      GcRootRecord(
-                          gcRoot = InternedString(id = readId())
-                      )
-                  )
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_FINALIZING -> {
-                val callback = callbacks.get<GcRootRecord>()
-                if (callback != null) {
-                  callback(
-                      GcRootRecord(
-                          gcRoot = Finalizing(id = readId())
-                      )
-                  )
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_DEBUGGER -> {
-                val callback = callbacks.get<GcRootRecord>()
-                if (callback != null) {
-                  callback(
-                      GcRootRecord(
-                          gcRoot = Debugger(id = readId())
-                      )
-                  )
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_REFERENCE_CLEANUP -> {
-                val callback = callbacks.get<GcRootRecord>()
-                if (callback != null) {
-                  callback(
-                      GcRootRecord(
-                          gcRoot = ReferenceCleanup(id = readId())
-                      )
-                  )
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_VM_INTERNAL -> {
-                val callback = callbacks.get<GcRootRecord>()
-                if (callback != null) {
-                  callback(
-                      GcRootRecord(
-                          gcRoot = VmInternal(id = readId())
-                      )
-                  )
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_JNI_MONITOR -> {
-                val callback = callbacks.get<GcRootRecord>()
-                if (callback != null) {
-                  callback(
-                      GcRootRecord(
-                          gcRoot = JniMonitor(
-                              id = readId(), stackTraceSerialNumber = readInt(),
-                              stackDepth = readInt()
-                          )
-                      )
-                  )
-                } else {
-                  skip(idSize + INT_SIZE + INT_SIZE)
-                }
-              }
-
-              ROOT_UNREACHABLE -> {
-                val callback = callbacks.get<GcRootRecord>()
-                if (callback != null) {
-                  callback(
-                      GcRootRecord(
-                          gcRoot = Unreachable(id = readId())
-                      )
-                  )
-                } else {
-                  skip(idSize)
-                }
-              }
-              else -> throw IllegalStateException(
-                  "Unknown tag $heapDumpTag after $previousTag"
-              )
-            }
-            previousTag = heapDumpTag
-          }
-        }
-        HEAP_DUMP_END -> {
-          val callback = callbacks.get<HeapDumpEndRecord>()
-          if (callback != null) {
-            callback(HeapDumpEndRecord)
-          }
-        }
-        else -> {
-          skip(length)
-        }
-      }
-    }
-
-    scanning = false
-    indexBuilt = true
-  }
-
-  /**
-   * Those are strings for class names, fields, etc, ie not strings from the application memory.
-   */
-  fun hprofStringById(id: Long): String {
-    return hprofStringCache[id] ?: throw IllegalArgumentException("Hprof string $id not in cache")
-  }
-
-  fun isPrimitiveWrapper(classId: Long) = primitiveWrapperTypes.contains(classId)
-
-  fun className(classId: Long): String {
-    // String, primitive types
-    return hprofStringById(classNames[classId])
-  }
-
-  fun classId(className: String): Long? {
-    // Note: this performs two linear scans over arrays
-    return hprofStringCache.getKey(className)
-        ?.let { stringId -> classNames.getKey(stringId) }
-  }
-
-  fun objectIdMetadata(objectId: Long): ObjectIdMetadata {
-    val (metadata, _) = ObjectIdMetadata.unpackMetadataAndPosition(objectIndex[objectId])
-    if (metadata == INTERNAL_MAYBE_EMPTY_INSTANCE) {
-      return if (maybeEmptyInstancesAreEmpty) {
-        EMPTY_INSTANCE
-      } else {
-        INSTANCE
-      }
-    }
-    return metadata
-  }
-
-  fun retrieveRecordById(objectId: Long): ObjectRecord {
-    val objectRecordOrNull = objectCache[objectId]
-    if (objectRecordOrNull != null) {
-      return objectRecordOrNull
-    }
-
-    val (_, position) = ObjectIdMetadata.unpackMetadataAndPosition(objectIndex[objectId])
-
-    require(position != 0L) {
-      "Unknown object id $objectId"
-    }
-    reader.moveTo(position)
-    val heapDumpTag = reader.readUnsignedByte()
-
-    reader.skip(reader.idSize)
-    val objectRecord = when (heapDumpTag) {
-      CLASS_DUMP -> reader.readClassDumpRecord(objectId)
-      INSTANCE_DUMP -> reader.readInstanceDumpRecord(objectId)
-      OBJECT_ARRAY_DUMP -> reader.readObjectArrayDumpRecord(objectId)
-      PRIMITIVE_ARRAY_DUMP -> reader.readPrimitiveArrayDumpRecord(objectId)
-      else -> {
-        throw IllegalStateException(
-            "Unexpected tag $heapDumpTag for id $objectId at position $position"
-        )
-      }
-    }
-    objectCache.put(objectId, objectRecord)
-    return objectRecord
-  }
-
-  companion object {
-    const val STRING_IN_UTF8 = 0x01
-    const val LOAD_CLASS = 0x02
-    const val UNLOAD_CLASS = 0x03
-    const val STACK_FRAME = 0x04
-    const val STACK_TRACE = 0x05
-    const val ALLOC_SITES = 0x06
-    const val HEAP_SUMMARY = 0x07
-    // TODO Maybe parse this?
-    const val START_THREAD = 0x0a
-    const val END_THREAD = 0x0b
-    const val HEAP_DUMP = 0x0c
-    const val HEAP_DUMP_SEGMENT = 0x1c
-
-    const val HEAP_DUMP_END = 0x2c
-
-    const val CPU_SAMPLES = 0x0d
-
-    const val CONTROL_SETTINGS = 0x0e
-
-    const val ROOT_UNKNOWN = 0xff
-
-    const val ROOT_JNI_GLOBAL = 0x01
-
-    const val ROOT_JNI_LOCAL = 0x02
-
-    const val ROOT_JAVA_FRAME = 0x03
-
-    const val ROOT_NATIVE_STACK = 0x04
-
-    const val ROOT_STICKY_CLASS = 0x05
-
-    const val ROOT_THREAD_BLOCK = 0x06
-
-    const val ROOT_MONITOR_USED = 0x07
-
-    const val ROOT_THREAD_OBJECT = 0x08
-
-    const val CLASS_DUMP = 0x20
-
-    const val INSTANCE_DUMP = 0x21
-
-    const val OBJECT_ARRAY_DUMP = 0x22
-
-    const val PRIMITIVE_ARRAY_DUMP = 0x23
-
-    /**
-     * Android format addition
-     *
-     * Specifies information about which heap certain objects came from. When a sub-tag of this type
-     * appears in a HPROF_HEAP_DUMP or HPROF_HEAP_DUMP_SEGMENT record, entries that follow it will
-     * be associated with the specified heap.  The HEAP_DUMP_INFO data is reset at the end of the
-     * HEAP_DUMP[_SEGMENT].  Multiple HEAP_DUMP_INFO entries may appear in a single
-     * HEAP_DUMP[_SEGMENT].
-     *
-     * Format: u1: Tag value (0xFE) u4: heap ID ID: heap name string ID
-     */
-    const val HEAP_DUMP_INFO = 0xfe
-
-    const val ROOT_INTERNED_STRING = 0x89
-
-    const val ROOT_FINALIZING = 0x8a
-
-    const val ROOT_DEBUGGER = 0x8b
-
-    const val ROOT_REFERENCE_CLEANUP = 0x8c
-
-    const val ROOT_VM_INTERNAL = 0x8d
-
-    const val ROOT_JNI_MONITOR = 0x8e
-
-    const val ROOT_UNREACHABLE = 0x90
-
-    const val PRIMITIVE_ARRAY_NODATA = 0xc3
-
-    const val BITS_FOR_FILE_POSITION = 29
-    private val MAX_HEAP_DUMP_SIZE = 1 shl BITS_FOR_FILE_POSITION
-
-    private val PRIMITIVE_WRAPPER_TYPES = setOf<String>(
-        Boolean::class.java.name, Char::class.java.name, Float::class.java.name,
-        Double::class.java.name, Byte::class.java.name, Short::class.java.name,
-        Int::class.java.name, Long::class.java.name
-    )
-
-    fun open(heapDump: File): HprofParser {
-      val fileLength = heapDump.length()
-      if (fileLength > MAX_HEAP_DUMP_SIZE) {
-        throw IllegalArgumentException(
-            "Heap dump file length is $fileLength bytes which is more than the max supported $MAX_HEAP_DUMP_SIZE"
-        )
-      }
-      if (fileLength == 0L) {
-        throw IllegalArgumentException("Heap dump file is 0 byte length")
-      }
-      val inputStream = heapDump.inputStream()
-      val channel = inputStream.channel
-      val source = inputStream.source()
-          .buffer()
-
-      val endOfVersionString = source.indexOf(0)
-      source.skip(endOfVersionString + 1)
-      val idSize = source.readInt()
-      val startPosition = endOfVersionString + 1 + 4
-
-      val hprofReader = SeekableHprofReader(channel, source, startPosition, idSize)
-      return HprofParser(hprofReader)
-    }
-  }
-
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt b/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt
new file mode 100644
index 00000000..10b6847f
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt
@@ -0,0 +1,658 @@
+package leakcanary
+
+import leakcanary.GcRoot.Debugger
+import leakcanary.GcRoot.Finalizing
+import leakcanary.GcRoot.InternedString
+import leakcanary.GcRoot.JavaFrame
+import leakcanary.GcRoot.JniGlobal
+import leakcanary.GcRoot.JniLocal
+import leakcanary.GcRoot.JniMonitor
+import leakcanary.GcRoot.MonitorUsed
+import leakcanary.GcRoot.NativeStack
+import leakcanary.GcRoot.ReferenceCleanup
+import leakcanary.GcRoot.StickyClass
+import leakcanary.GcRoot.ThreadBlock
+import leakcanary.GcRoot.ThreadObject
+import leakcanary.GcRoot.Unknown
+import leakcanary.GcRoot.Unreachable
+import leakcanary.GcRoot.VmInternal
+import leakcanary.HprofReader.Companion.INT_SIZE
+import leakcanary.HprofReader.Companion.LONG_SIZE
+import leakcanary.Record.HeapDumpEndRecord
+import leakcanary.Record.HeapDumpRecord
+import leakcanary.Record.HeapDumpRecord.GcRootRecord
+import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import leakcanary.Record.LoadClassRecord
+import leakcanary.Record.StackFrameRecord
+import leakcanary.Record.StackTraceRecord
+import leakcanary.Record.StringRecord
+import okio.buffer
+import okio.source
+import java.io.File
+import kotlin.reflect.KClass
+
+/**
+ * A streaming push heap dump parser.
+ *
+ * Expected usage: call [readHprofRecords] once, which will go read through the entire heap dump
+ * and notify the provided listener of records found.
+ *
+ * This class is not thread safe, should be used from a single thread.
+ *
+ * Binary Dump Format reference: http://hg.openjdk.java.net/jdk6/jdk6/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html#mozTocId848088
+ *
+ * The Android Hprof format differs in some ways from that reference. This parser implementation
+ * is largely adapted from https://android.googlesource.com/platform/tools/base/+/studio-master-dev/perflib/src/main/java/com/android/tools/perflib
+ */
+class HprofPushRecordsParser {
+
+  interface OnRecordListener {
+    fun recordTypes(): Set<KClass<out Record>>
+
+    fun onTypeSizesAvailable(typeSizes: Map<Int, Int>)
+
+    fun onRecord(
+      position: Long,
+      record: Record
+    )
+  }
+
+  fun readHprofRecords(
+    heapDump: File,
+    listeners: Set<OnRecordListener>
+  ): SeekableHprofReader {
+    if (heapDump.length() == 0L) {
+      throw IllegalArgumentException("Heap dump file is 0 byte length")
+    }
+    val inputStream = heapDump.inputStream()
+    val channel = inputStream.channel
+    val source = inputStream.source()
+        .buffer()
+
+    val endOfVersionString = source.indexOf(0)
+    source.skip(endOfVersionString + 1)
+    val idSize = source.readInt()
+    val startPosition = endOfVersionString + 1 + 4
+
+    val reader = SeekableHprofReader(channel, source, startPosition, idSize)
+
+    listeners.forEach { it.onTypeSizesAvailable(reader.typeSizes) }
+
+    reader.readHprofRecords(listeners)
+    return reader
+  }
+
+  private fun SeekableHprofReader.readHprofRecords(listeners: Set<OnRecordListener>) {
+
+    val readStringRecord = mutableSetOf<OnRecordListener>()
+    val readLoadClassRecord = mutableSetOf<OnRecordListener>()
+    val readStackFrameRecord = mutableSetOf<OnRecordListener>()
+    val readStackTraceRecord = mutableSetOf<OnRecordListener>()
+    val readGcRootRecord = mutableSetOf<OnRecordListener>()
+    val readClassDumpRecord = mutableSetOf<OnRecordListener>()
+    val readInstanceDumpRecord = mutableSetOf<OnRecordListener>()
+    val readObjectArrayDumpRecord = mutableSetOf<OnRecordListener>()
+    val readPrimitiveArrayDumpRecord = mutableSetOf<OnRecordListener>()
+    val readHeapDumpInfoRecord = mutableSetOf<OnRecordListener>()
+    val readHeapDumpEnd = mutableSetOf<OnRecordListener>()
+
+    for (listener in listeners) {
+      val config = listener.recordTypes()
+      config.forEach { recordClass ->
+        when (recordClass) {
+          Record::class -> {
+            readStringRecord += listener
+            readLoadClassRecord += listener
+            readStackFrameRecord += listener
+            readStackTraceRecord += listener
+            readGcRootRecord += listener
+            readClassDumpRecord += listener
+            readInstanceDumpRecord += listener
+            readObjectArrayDumpRecord += listener
+            readPrimitiveArrayDumpRecord += listener
+            readHeapDumpInfoRecord += listener
+            readHeapDumpEnd += listener
+          }
+          StringRecord::class -> {
+            readStringRecord += listener
+          }
+          LoadClassRecord::class -> {
+            readLoadClassRecord += listener
+          }
+          HeapDumpEndRecord::class -> {
+            readHeapDumpEnd += listener
+          }
+          StackFrameRecord::class -> {
+            readStackFrameRecord += listener
+          }
+          StackTraceRecord::class -> {
+            readStackTraceRecord += listener
+          }
+          HeapDumpRecord::class -> {
+            readGcRootRecord += listener
+            readClassDumpRecord += listener
+            readInstanceDumpRecord += listener
+            readObjectArrayDumpRecord += listener
+            readPrimitiveArrayDumpRecord += listener
+            readHeapDumpInfoRecord += listener
+          }
+          GcRootRecord::class -> {
+            readGcRootRecord += listener
+          }
+          ObjectRecord::class -> {
+            readClassDumpRecord += listener
+            readInstanceDumpRecord += listener
+            readObjectArrayDumpRecord += listener
+            readPrimitiveArrayDumpRecord += listener
+          }
+          ClassDumpRecord::class -> {
+            readClassDumpRecord += listener
+          }
+          InstanceDumpRecord::class -> {
+            readInstanceDumpRecord += listener
+          }
+          ObjectArrayDumpRecord::class -> {
+            readObjectArrayDumpRecord += listener
+          }
+          PrimitiveArrayDumpRecord::class -> {
+            readPrimitiveArrayDumpRecord += listener
+          }
+          HeapDumpInfoRecord::class -> {
+            readHeapDumpInfoRecord += listener
+          }
+        }
+      }
+    }
+
+    // heap dump timestamp
+    skip(LONG_SIZE)
+
+    while (!exhausted()) {
+      // type of the record
+      val tag = readUnsignedByte()
+
+      // number of microseconds since the time stamp in the header
+      skip(INT_SIZE)
+
+      // number of bytes that follow and belong to this record
+      val length = readUnsignedInt()
+
+      when (tag) {
+        STRING_IN_UTF8 -> {
+          if (readStringRecord.isNotEmpty()) {
+            val recordPosition = position
+            val id = readId()
+            val stringLength = length - idSize
+            val string = readUtf8(stringLength)
+            val record = StringRecord(id, string)
+            readStringRecord.forEach { it.onRecord(recordPosition, record) }
+          } else {
+            skip(length)
+          }
+        }
+        LOAD_CLASS -> {
+          if (readLoadClassRecord.isNotEmpty()) {
+            val recordPosition = position
+            val classSerialNumber = readInt()
+            val id = readId()
+            val stackTraceSerialNumber = readInt()
+            val classNameStringId = readId()
+            val record = LoadClassRecord(
+                classSerialNumber = classSerialNumber,
+                id = id,
+                stackTraceSerialNumber = stackTraceSerialNumber,
+                classNameStringId = classNameStringId
+            )
+            readLoadClassRecord.forEach {
+              it.onRecord(recordPosition, record)
+            }
+          } else {
+            skip(length)
+          }
+        }
+        STACK_FRAME -> {
+          if (readStackFrameRecord.isNotEmpty()) {
+            val recordPosition = position
+            val record = StackFrameRecord(
+                id = readId(),
+                methodNameStringId = readId(),
+                methodSignatureStringId = readId(),
+                sourceFileNameStringId = readId(),
+                classSerialNumber = readInt(),
+                lineNumber = readInt()
+            )
+            readStackFrameRecord.forEach {
+              it.onRecord(recordPosition, record)
+            }
+          } else {
+            skip(length)
+          }
+        }
+        STACK_TRACE -> {
+          if (readStackTraceRecord.isNotEmpty()) {
+            val recordPosition = position
+            val stackTraceSerialNumber = readInt()
+            val threadSerialNumber = readInt()
+            val frameCount = readInt()
+            val stackFrameIds = readIdArray(frameCount)
+            val record = StackTraceRecord(
+                stackTraceSerialNumber = stackTraceSerialNumber,
+                threadSerialNumber = threadSerialNumber,
+                stackFrameIds = stackFrameIds
+            )
+            readStackTraceRecord.forEach {
+              it.onRecord(recordPosition, record)
+            }
+          } else {
+            skip(length)
+          }
+        }
+        HEAP_DUMP, HEAP_DUMP_SEGMENT -> {
+          val heapDumpStart = position
+          var previousTag = 0
+          while (position - heapDumpStart < length) {
+            val heapDumpTag = readUnsignedByte()
+
+            when (heapDumpTag) {
+              ROOT_UNKNOWN -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val record = GcRootRecord(gcRoot = Unknown(id = readId()))
+                  readGcRootRecord.forEach { it.onRecord(recordPosition, record) }
+                } else {
+                  skip(idSize)
+                }
+              }
+              ROOT_JNI_GLOBAL -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord =
+                    GcRootRecord(gcRoot = JniGlobal(id = readId(), jniGlobalRefId = readId()))
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize + idSize)
+                }
+              }
+
+              ROOT_JNI_LOCAL -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = JniLocal(
+                          id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
+                      )
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize + INT_SIZE + INT_SIZE)
+                }
+              }
+
+              ROOT_JAVA_FRAME -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = JavaFrame(
+                          id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
+                      )
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize + INT_SIZE + INT_SIZE)
+                }
+              }
+
+              ROOT_NATIVE_STACK -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = NativeStack(id = readId(), threadSerialNumber = readInt())
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize + INT_SIZE)
+                }
+              }
+
+              ROOT_STICKY_CLASS -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = StickyClass(id = readId())
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              // An object that was referenced from an active thread block.
+              ROOT_THREAD_BLOCK -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = ThreadBlock(id = readId(), threadSerialNumber = readInt())
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize + INT_SIZE)
+                }
+              }
+
+              ROOT_MONITOR_USED -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = MonitorUsed(id = readId())
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_THREAD_OBJECT -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = ThreadObject(
+                          id = readId(),
+                          threadSerialNumber = readInt(),
+                          stackTraceSerialNumber = readInt()
+                      )
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize + INT_SIZE + INT_SIZE)
+                }
+              }
+
+              ROOT_INTERNED_STRING -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(gcRoot = InternedString(id = readId()))
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_FINALIZING -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = Finalizing(id = readId())
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_DEBUGGER -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = Debugger(id = readId())
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_REFERENCE_CLEANUP -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = ReferenceCleanup(id = readId())
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_VM_INTERNAL -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = VmInternal(id = readId())
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_JNI_MONITOR -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = JniMonitor(
+                          id = readId(), stackTraceSerialNumber = readInt(),
+                          stackDepth = readInt()
+                      )
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize + INT_SIZE + INT_SIZE)
+                }
+              }
+
+              ROOT_UNREACHABLE -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = Unreachable(id = readId())
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize)
+                }
+              }
+              CLASS_DUMP -> {
+                if (readClassDumpRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val record = readClassDumpRecord()
+                  readClassDumpRecord.forEach {
+                    it.onRecord(recordPosition, record)
+                  }
+                } else {
+                  skipClassDumpRecord()
+                }
+              }
+
+              INSTANCE_DUMP -> {
+                if (readInstanceDumpRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val instanceDumpRecord = readInstanceDumpRecord()
+                  readInstanceDumpRecord.forEach {
+                    it.onRecord(recordPosition, instanceDumpRecord)
+                  }
+                } else {
+                  skipInstanceDumpRecord()
+                }
+              }
+
+              OBJECT_ARRAY_DUMP -> {
+                if (readObjectArrayDumpRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val arrayRecord = readObjectArrayDumpRecord()
+                  readObjectArrayDumpRecord.forEach {
+                    it.onRecord(recordPosition, arrayRecord)
+                  }
+                } else {
+                  skipObjectArrayDumpRecord()
+                }
+              }
+
+              PRIMITIVE_ARRAY_DUMP -> {
+                if (readPrimitiveArrayDumpRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val record = readPrimitiveArrayDumpRecord()
+                  readPrimitiveArrayDumpRecord.forEach {
+                    it.onRecord(recordPosition, record)
+                  }
+                } else {
+                  skipPrimitiveArrayDumpRecord()
+                }
+              }
+
+              PRIMITIVE_ARRAY_NODATA -> {
+                throw UnsupportedOperationException("PRIMITIVE_ARRAY_NODATA cannot be parsed")
+              }
+
+              HEAP_DUMP_INFO -> {
+                if (readHeapDumpInfoRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val record = readHeapDumpInfoRecord()
+                  readHeapDumpInfoRecord.forEach {
+                    it.onRecord(recordPosition, record)
+                  }
+                } else {
+                  skipHeapDumpInfoRecord()
+                }
+              }
+
+              else -> throw IllegalStateException(
+                  "Unknown tag $heapDumpTag after $previousTag"
+              )
+            }
+            previousTag = heapDumpTag
+          }
+        }
+        HEAP_DUMP_END -> {
+          if (readHeapDumpEnd.isNotEmpty()) {
+            val recordPosition = position
+            val record = HeapDumpEndRecord
+            readHeapDumpEnd.forEach {
+              it.onRecord(recordPosition, record)
+            }
+          }
+        }
+        else -> {
+          skip(length)
+        }
+      }
+    }
+  }
+
+  companion object {
+    internal const val STRING_IN_UTF8 = 0x01
+    internal const val LOAD_CLASS = 0x02
+    internal const val UNLOAD_CLASS = 0x03
+    internal const val STACK_FRAME = 0x04
+    internal const val STACK_TRACE = 0x05
+    internal const val ALLOC_SITES = 0x06
+    internal const val HEAP_SUMMARY = 0x07
+    // TODO Maybe parse this?
+    internal const val START_THREAD = 0x0a
+    internal const val END_THREAD = 0x0b
+    internal const val HEAP_DUMP = 0x0c
+    internal const val HEAP_DUMP_SEGMENT = 0x1c
+    internal const val HEAP_DUMP_END = 0x2c
+    internal const val CPU_SAMPLES = 0x0d
+    internal const val CONTROL_SETTINGS = 0x0e
+    internal const val ROOT_UNKNOWN = 0xff
+    internal const val ROOT_JNI_GLOBAL = 0x01
+    internal const val ROOT_JNI_LOCAL = 0x02
+    internal const val ROOT_JAVA_FRAME = 0x03
+    internal const val ROOT_NATIVE_STACK = 0x04
+    internal const val ROOT_STICKY_CLASS = 0x05
+    internal const val ROOT_THREAD_BLOCK = 0x06
+    internal const val ROOT_MONITOR_USED = 0x07
+    internal const val ROOT_THREAD_OBJECT = 0x08
+    internal const val CLASS_DUMP = 0x20
+    internal const val INSTANCE_DUMP = 0x21
+    internal const val OBJECT_ARRAY_DUMP = 0x22
+    internal const val PRIMITIVE_ARRAY_DUMP = 0x23
+
+    /**
+     * Android format addition
+     *
+     * Specifies information about which heap certain objects came from. When a sub-tag of this type
+     * appears in a HPROF_HEAP_DUMP or HPROF_HEAP_DUMP_SEGMENT record, entries that follow it will
+     * be associated with the specified heap.  The HEAP_DUMP_INFO data is reset at the end of the
+     * HEAP_DUMP[_SEGMENT].  Multiple HEAP_DUMP_INFO entries may appear in a single
+     * HEAP_DUMP[_SEGMENT].
+     *
+     * Format: u1: Tag value (0xFE) u4: heap ID ID: heap name string ID
+     */
+    internal const val HEAP_DUMP_INFO = 0xfe
+    internal const val ROOT_INTERNED_STRING = 0x89
+    internal const val ROOT_FINALIZING = 0x8a
+    internal const val ROOT_DEBUGGER = 0x8b
+    internal const val ROOT_REFERENCE_CLEANUP = 0x8c
+    internal const val ROOT_VM_INTERNAL = 0x8d
+    internal const val ROOT_JNI_MONITOR = 0x8e
+    internal const val ROOT_UNREACHABLE = 0x90
+    internal const val PRIMITIVE_ARRAY_NODATA = 0xc3
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt b/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt
index e949e20b..596228ef 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt
@@ -9,6 +9,7 @@ import leakcanary.HeapValue.IntValue
 import leakcanary.HeapValue.LongValue
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.HeapValue.ShortValue
+import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
@@ -34,7 +35,10 @@ open class HprofReader constructor(
   protected var source: BufferedSource,
   protected val startPosition: Long,
   val idSize: Int
-) : Closeable {
+): Closeable {
+  override fun close() {
+    source.close()
+  }
 
   var position: Long = startPosition
     protected set
@@ -42,7 +46,7 @@ open class HprofReader constructor(
   val isOpen
     get() = source.isOpen
 
-  private val typeSizes = mapOf(
+  val typeSizes = mapOf(
       // object
       OBJECT_TYPE to idSize,
       BOOLEAN_TYPE to BOOLEAN_SIZE,
@@ -196,18 +200,12 @@ open class HprofReader constructor(
     return source.skip(byteCount.toLong())
   }
 
-  override fun close() {
-    source.close()
-  }
-
-  fun readInstanceDumpRecord(
-    id: Long
-  ): InstanceDumpRecord {
+  fun readInstanceDumpRecord(): InstanceDumpRecord {
+    val id = readId()
     val stackTraceSerialNumber = readInt()
     val classId = readId()
     val remainingBytesInInstance = readInt()
     val fieldValues = readByteArray(remainingBytesInInstance)
-
     return InstanceDumpRecord(
         id = id,
         stackTraceSerialNumber = stackTraceSerialNumber,
@@ -216,9 +214,8 @@ open class HprofReader constructor(
     )
   }
 
-  fun readClassDumpRecord(
-    id: Long
-  ): ClassDumpRecord {
+  fun readClassDumpRecord(): ClassDumpRecord {
+    val id = readId()
     // stack trace serial number
     val stackTraceSerialNumber = readInt()
     val superClassId = readId()
@@ -281,9 +278,39 @@ open class HprofReader constructor(
     )
   }
 
+  fun skipInstanceDumpRecord() {
+    skip(idSize + INT_SIZE + idSize)
+    val remainingBytesInInstance = readInt()
+    skip(remainingBytesInInstance)
+  }
+
+  fun skipClassDumpRecord() {
+    skip(
+        idSize + INT_SIZE + idSize + idSize + idSize + idSize + idSize + idSize + INT_SIZE
+    )
+    // Skip over the constant pool
+    val constantPoolCount = readUnsignedShort()
+    for (i in 0 until constantPoolCount) {
+      // constant pool index
+      skip(SHORT_SIZE)
+      skip(typeSize(readUnsignedByte()))
+    }
+
+    val staticFieldCount = readUnsignedShort()
+
+    for (i in 0 until staticFieldCount) {
+      skip(idSize)
+      val type = readUnsignedByte()
+      skip(typeSize(type))
+    }
+
+    val fieldCount = readUnsignedShort()
+    skip(fieldCount * (idSize + BYTE_SIZE))
+  }
+
   fun readObjectArrayDumpRecord(
-    id: Long
   ): ObjectArrayDumpRecord {
+    val id = readId()
     // stack trace serial number
     val stackTraceSerialNumber = readInt()
     val arrayLength = readInt()
@@ -297,9 +324,14 @@ open class HprofReader constructor(
     )
   }
 
-  fun readPrimitiveArrayDumpRecord(
-    id: Long
-  ): PrimitiveArrayDumpRecord {
+  fun skipObjectArrayDumpRecord() {
+    skip(idSize + INT_SIZE)
+    val arrayLength = readInt()
+    skip(idSize + arrayLength * idSize)
+  }
+
+  fun readPrimitiveArrayDumpRecord(): PrimitiveArrayDumpRecord {
+    val id = readId()
     val stackTraceSerialNumber = readInt()
     // length
     val arrayLength = readInt()
@@ -333,6 +365,22 @@ open class HprofReader constructor(
     }
   }
 
+  fun skipPrimitiveArrayDumpRecord() {
+    skip(idSize + INT_SIZE)
+    val arrayLength = readInt()
+    val type = readUnsignedByte()
+    skip(idSize + arrayLength * typeSize(type))
+  }
+
+  fun readHeapDumpInfoRecord(): HeapDumpInfoRecord {
+    val heapId = readInt()
+    return HeapDumpInfoRecord(heapId = heapId, heapNameStringId = readId())
+  }
+
+  fun skipHeapDumpInfoRecord() {
+    skip(idSize + idSize)
+  }
+
   val tagPositionAfterReadingId
     get() = position - (idSize + BYTE_SIZE)
 
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt b/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt
index ad62d483..421f922d 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt
@@ -64,13 +64,13 @@ class HprofWriter private constructor(
   private fun BufferedSink.write(record: Record) {
     when (record) {
       is StringRecord -> {
-        writeNonHeapRecord(HprofParser.STRING_IN_UTF8) {
+        writeNonHeapRecord(HprofPushRecordsParser.STRING_IN_UTF8) {
           writeId(record.id)
           writeUtf8(record.string)
         }
       }
       is LoadClassRecord -> {
-        writeNonHeapRecord(HprofParser.LOAD_CLASS) {
+        writeNonHeapRecord(HprofPushRecordsParser.LOAD_CLASS) {
           writeInt(record.classSerialNumber)
           writeId(record.id)
           writeInt(record.stackTraceSerialNumber)
@@ -78,7 +78,7 @@ class HprofWriter private constructor(
         }
       }
       is StackTraceRecord -> {
-        writeNonHeapRecord(HprofParser.STACK_TRACE) {
+        writeNonHeapRecord(HprofPushRecordsParser.STACK_TRACE) {
           writeInt(record.stackTraceSerialNumber)
           writeInt(record.threadSerialNumber)
           writeInt(record.stackFrameIds.size)
@@ -89,80 +89,80 @@ class HprofWriter private constructor(
         with(workBuffer) {
           when (val gcRoot = record.gcRoot) {
             is Unknown -> {
-              writeByte(HprofParser.ROOT_UNKNOWN)
+              writeByte(HprofPushRecordsParser.ROOT_UNKNOWN)
               writeId(gcRoot.id)
             }
             is JniGlobal -> {
               writeByte(
-                  HprofParser.ROOT_JNI_GLOBAL
+                  HprofPushRecordsParser.ROOT_JNI_GLOBAL
               )
               writeId(gcRoot.id)
               writeId(gcRoot.jniGlobalRefId)
             }
             is JniLocal -> {
-              writeByte(HprofParser.ROOT_JNI_LOCAL)
+              writeByte(HprofPushRecordsParser.ROOT_JNI_LOCAL)
               writeId(gcRoot.id)
               writeInt(gcRoot.threadSerialNumber)
               writeInt(gcRoot.frameNumber)
             }
             is JavaFrame -> {
-              writeByte(HprofParser.ROOT_JAVA_FRAME)
+              writeByte(HprofPushRecordsParser.ROOT_JAVA_FRAME)
               writeId(gcRoot.id)
               writeInt(gcRoot.threadSerialNumber)
               writeInt(gcRoot.frameNumber)
             }
             is NativeStack -> {
-              writeByte(HprofParser.ROOT_NATIVE_STACK)
+              writeByte(HprofPushRecordsParser.ROOT_NATIVE_STACK)
               writeId(gcRoot.id)
               writeInt(gcRoot.threadSerialNumber)
             }
             is StickyClass -> {
-              writeByte(HprofParser.ROOT_STICKY_CLASS)
+              writeByte(HprofPushRecordsParser.ROOT_STICKY_CLASS)
               writeId(gcRoot.id)
             }
             is ThreadBlock -> {
-              writeByte(HprofParser.ROOT_THREAD_BLOCK)
+              writeByte(HprofPushRecordsParser.ROOT_THREAD_BLOCK)
               writeId(gcRoot.id)
               writeInt(gcRoot.threadSerialNumber)
             }
             is MonitorUsed -> {
-              writeByte(HprofParser.ROOT_MONITOR_USED)
+              writeByte(HprofPushRecordsParser.ROOT_MONITOR_USED)
               writeId(gcRoot.id)
             }
             is ThreadObject -> {
-              writeByte(HprofParser.ROOT_THREAD_OBJECT)
+              writeByte(HprofPushRecordsParser.ROOT_THREAD_OBJECT)
               writeId(gcRoot.id)
               writeInt(gcRoot.threadSerialNumber)
               writeInt(gcRoot.stackTraceSerialNumber)
             }
             is ReferenceCleanup -> {
-              writeByte(HprofParser.ROOT_REFERENCE_CLEANUP)
+              writeByte(HprofPushRecordsParser.ROOT_REFERENCE_CLEANUP)
               writeId(gcRoot.id)
             }
             is VmInternal -> {
-              writeByte(HprofParser.ROOT_VM_INTERNAL)
+              writeByte(HprofPushRecordsParser.ROOT_VM_INTERNAL)
               writeId(gcRoot.id)
             }
             is JniMonitor -> {
-              writeByte(HprofParser.ROOT_JNI_MONITOR)
+              writeByte(HprofPushRecordsParser.ROOT_JNI_MONITOR)
               writeId(gcRoot.id)
               writeInt(gcRoot.stackTraceSerialNumber)
               writeInt(gcRoot.stackDepth)
             }
             is InternedString -> {
-              writeByte(HprofParser.ROOT_INTERNED_STRING)
+              writeByte(HprofPushRecordsParser.ROOT_INTERNED_STRING)
               writeId(gcRoot.id)
             }
             is Finalizing -> {
-              writeByte(HprofParser.ROOT_FINALIZING)
+              writeByte(HprofPushRecordsParser.ROOT_FINALIZING)
               writeId(gcRoot.id)
             }
             is Debugger -> {
-              writeByte(HprofParser.ROOT_DEBUGGER)
+              writeByte(HprofPushRecordsParser.ROOT_DEBUGGER)
               writeId(gcRoot.id)
             }
             is Unreachable -> {
-              writeByte(HprofParser.ROOT_UNREACHABLE)
+              writeByte(HprofPushRecordsParser.ROOT_UNREACHABLE)
               writeId(gcRoot.id)
             }
           }
@@ -170,7 +170,7 @@ class HprofWriter private constructor(
       }
       is ClassDumpRecord -> {
         with(workBuffer) {
-          writeByte(HprofParser.CLASS_DUMP)
+          writeByte(HprofPushRecordsParser.CLASS_DUMP)
           writeId(record.id)
           writeInt(record.stackTraceSerialNumber)
           writeId(record.superClassId)
@@ -200,7 +200,7 @@ class HprofWriter private constructor(
       }
       is InstanceDumpRecord -> {
         with(workBuffer) {
-          writeByte(HprofParser.INSTANCE_DUMP)
+          writeByte(HprofPushRecordsParser.INSTANCE_DUMP)
           writeId(record.id)
           writeInt(record.stackTraceSerialNumber)
           writeId(record.classId)
@@ -210,7 +210,7 @@ class HprofWriter private constructor(
       }
       is ObjectArrayDumpRecord -> {
         with(workBuffer) {
-          writeByte(HprofParser.OBJECT_ARRAY_DUMP)
+          writeByte(HprofPushRecordsParser.OBJECT_ARRAY_DUMP)
           writeId(record.id)
           writeInt(record.stackTraceSerialNumber)
           writeInt(record.elementIds.size)
@@ -220,7 +220,7 @@ class HprofWriter private constructor(
       }
       is PrimitiveArrayDumpRecord -> {
         with(workBuffer) {
-          writeByte(HprofParser.PRIMITIVE_ARRAY_DUMP)
+          writeByte(HprofPushRecordsParser.PRIMITIVE_ARRAY_DUMP)
           writeId(record.id)
           writeInt(record.stackTraceSerialNumber)
 
@@ -270,7 +270,7 @@ class HprofWriter private constructor(
       }
       is HeapDumpInfoRecord -> {
         with(workBuffer) {
-          writeByte(HprofParser.HEAP_DUMP_INFO)
+          writeByte(HprofPushRecordsParser.HEAP_DUMP_INFO)
           writeInt(record.heapId)
           writeId(record.heapNameStringId)
         }
@@ -351,9 +351,9 @@ class HprofWriter private constructor(
 
   private fun BufferedSink.flushHeapBuffer() {
     if (workBuffer.size > 0) {
-      writeTagHeader(HprofParser.HEAP_DUMP, workBuffer.size)
+      writeTagHeader(HprofPushRecordsParser.HEAP_DUMP, workBuffer.size)
       writeAll(workBuffer)
-      writeTagHeader(HprofParser.HEAP_DUMP_END, 0)
+      writeTagHeader(HprofPushRecordsParser.HEAP_DUMP_END, 0)
     }
   }
 
diff --git a/leakcanary-haha/src/main/java/leakcanary/ObjectIdMetadata.kt b/leakcanary-haha/src/main/java/leakcanary/ObjectIdMetadata.kt
deleted file mode 100644
index 6bb90335..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/ObjectIdMetadata.kt
+++ /dev/null
@@ -1,52 +0,0 @@
-package leakcanary
-
-import leakcanary.HprofParser.Companion.BITS_FOR_FILE_POSITION
-
-enum class ObjectIdMetadata {
-  PRIMITIVE_WRAPPER_OR_PRIMITIVE_ARRAY,
-  PRIMITIVE_WRAPPER_ARRAY,
-  OBJECT_ARRAY,
-  /**
-   * An [INSTANCE] of the String class.
-   */
-  STRING,
-  INSTANCE,
-  CLASS,
-  /**
-   * An [INSTANCE] with 0 bytes of field values, which therefore has no fields that
-   * could reference other instances.
-   */
-  EMPTY_INSTANCE,
-  /**
-   * An [INSTANCE] with N + 4 bytes of field values, where N is the size of an object id.
-   * Art updated the Object class with two fields: shadow$_klass_ (pointer to a class, N bytes) and
-   * shadow$_monitor_ (Int, 4 bytes). As a empty instances still have at list N + 4 bytes of field
-   * values. The size of the Object class fields is discovered after we've already parsed some
-   * objects so we have to store this separately from [EMPTY_INSTANCE] and check later.
-   */
-  INTERNAL_MAYBE_EMPTY_INSTANCE
-  ;
-
-  fun packOrdinalWithFilePosition(filePosition: Long): Int {
-    val shiftedOrdinal = ordinal shl BITS_FOR_FILE_POSITION
-    return shiftedOrdinal or filePosition.toInt()
-  }
-
-  companion object {
-
-    private const val POSITION_MASK = (1 shl BITS_FOR_FILE_POSITION) - 1
-    private const val ORDINAL_MASK = 0x7
-
-    init {
-      require(values().size <= 8) {
-        "ObjectIdMetadata is packed as 3 bits in an int, it can only have up to 8 values, not ${values().size}"
-      }
-    }
-
-    fun unpackMetadataAndPosition(packedInt: Int): Pair<ObjectIdMetadata, Long> {
-      val unpackedOrdinal = (packedInt shr BITS_FOR_FILE_POSITION) and ORDINAL_MASK
-      val unpackedPosition = packedInt and POSITION_MASK
-      return values()[unpackedOrdinal] to unpackedPosition.toLong()
-    }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/PrimitiveType.kt b/leakcanary-haha/src/main/java/leakcanary/PrimitiveType.kt
new file mode 100644
index 00000000..f809124d
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/PrimitiveType.kt
@@ -0,0 +1,12 @@
+package leakcanary
+
+enum class PrimitiveType {
+  BOOLEAN,
+  CHAR,
+  FLOAT,
+  DOUBLE,
+  BYTE,
+  SHORT,
+  INT,
+  LONG
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/Record.kt b/leakcanary-haha/src/main/java/leakcanary/Record.kt
index a5367788..cd139855 100644
--- a/leakcanary-haha/src/main/java/leakcanary/Record.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/Record.kt
@@ -1,7 +1,5 @@
 package leakcanary
 
-import leakcanary.HeapValue.ObjectReference
-
 sealed class Record {
   class StringRecord(
     val id: Long,
@@ -91,54 +89,79 @@ sealed class Record {
       sealed class PrimitiveArrayDumpRecord : ObjectRecord() {
         abstract val id: Long
         abstract val stackTraceSerialNumber: Int
+        abstract val size: Int
 
         class BooleanArrayDump(
           override val id: Long,
           override val stackTraceSerialNumber: Int,
           val array: BooleanArray
-        ) : PrimitiveArrayDumpRecord()
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
 
         class CharArrayDump(
           override val id: Long,
           override val stackTraceSerialNumber: Int,
           val array: CharArray
-        ) : PrimitiveArrayDumpRecord()
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
 
         class FloatArrayDump(
           override val id: Long,
           override val stackTraceSerialNumber: Int,
           val array: FloatArray
-        ) : PrimitiveArrayDumpRecord()
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
 
         class DoubleArrayDump(
           override val id: Long,
           override val stackTraceSerialNumber: Int,
           val array: DoubleArray
-        ) : PrimitiveArrayDumpRecord()
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
 
         class ByteArrayDump(
           override val id: Long,
           override val stackTraceSerialNumber: Int,
           val array: ByteArray
-        ) : PrimitiveArrayDumpRecord()
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
 
         class ShortArrayDump(
           override val id: Long,
           override val stackTraceSerialNumber: Int,
           val array: ShortArray
-        ) : PrimitiveArrayDumpRecord()
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
 
         class IntArrayDump(
           override val id: Long,
           override val stackTraceSerialNumber: Int,
           val array: IntArray
-        ) : PrimitiveArrayDumpRecord()
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
 
         class LongArrayDump(
           override val id: Long,
           override val stackTraceSerialNumber: Int,
           val array: LongArray
-        ) : PrimitiveArrayDumpRecord()
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
       }
     }
 
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt b/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt
new file mode 100644
index 00000000..031e1c9a
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt
@@ -0,0 +1,193 @@
+package leakcanary.internal
+
+import leakcanary.HprofPushRecordsParser.OnRecordListener
+import leakcanary.HprofReader
+import leakcanary.PrimitiveType
+import leakcanary.Record
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import leakcanary.Record.LoadClassRecord
+import leakcanary.Record.StringRecord
+import leakcanary.internal.IndexedObject.IndexedClass
+import leakcanary.internal.IndexedObject.IndexedInstance
+import leakcanary.internal.IndexedObject.IndexedObjectArray
+import leakcanary.internal.IndexedObject.IndexedPrimitiveArray
+import kotlin.reflect.KClass
+
+/**
+ * This class is not thread safe, should be used from a single thread.
+ */
+internal class HprofInMemoryIndex private constructor(
+  private val hprofStringCache: LongToStringSparseArray,
+  private val classNames: LongToLongSparseArray,
+  private val objectIndex: LongToObjectSparseArray<IndexedObject>,
+  private val typeSizes: Map<Int, Int>,
+  val primitiveWrapperTypes: Set<Long>
+) {
+  val idSize: Int
+    get() = typeSizes.getValue(HprofReader.OBJECT_TYPE)
+
+  fun sizeOfFieldType(hprofType: Int): Int = typeSizes.getValue(hprofType)
+
+  fun hprofStringById(id: Long): String {
+    return hprofStringCache[id] ?: throw IllegalArgumentException("Hprof string $id not in cache")
+  }
+
+  fun className(classId: Long): String {
+    // String, primitive types
+    return hprofStringById(classNames[classId])
+  }
+
+  fun classId(className: String): Long? {
+    // Note: this performs two linear scans over arrays
+    return hprofStringCache.getKey(className)
+        ?.let { stringId -> classNames.getKey(stringId) }
+  }
+
+  fun indexedClassSequence(): Sequence<Pair<Long, IndexedClass>> {
+    return objectIndex.entrySequence()
+        .filter { it.second is IndexedClass }
+        .map { it.first to it.second as IndexedClass }
+  }
+
+  fun indexedInstanceSequence(): Sequence<Pair<Long, IndexedInstance>> {
+    return objectIndex.entrySequence()
+        .filter { it.second is IndexedInstance }
+        .map { it.first to it.second as IndexedInstance }
+  }
+
+  fun indexedObject(objectId: Long): IndexedObject {
+    return objectIndex[objectId]
+  }
+
+  class Builder : OnRecordListener {
+    /**
+     * Map of string id to string
+     * This currently keeps all the hprof strings that we could care about: class names,
+     * static field names and instance fields names
+     */
+    // TODO Replacing with a radix trie reversed into a sparse array of long to trie leaf could save
+    // memory.
+    // Another option is to switch back to reading from the file system as necessary, and keep a much
+    // smaller cache for strings we need during shortest path (those are for exclusions)
+    private val hprofStringCache = LongToStringSparseArray(60000)
+
+    /**
+     * class id to string id
+     */
+    private val classNames = LongToLongSparseArray(20000)
+
+    /**
+     * Object id to [IndexedObject].
+     * The id can be for classes instances, classes, object arrays and primitive arrays
+     */
+    private val objectIndex = LongToObjectSparseArray<IndexedObject>(250000)
+
+    /**
+     * Class ids for primitive wrapper types
+     */
+    private val primitiveWrapperTypes = mutableSetOf<Long>()
+
+    /**
+     * String ids for class names of primitive wrapper types
+     */
+    private val primitiveWrapperClassNames = mutableSetOf<Long>()
+
+    private lateinit var typeSizes: Map<Int, Int>
+    private var consumed = false
+
+    override fun recordTypes(): Set<KClass<out Record>> = setOf(
+        StringRecord::class,
+        LoadClassRecord::class,
+        ClassDumpRecord::class,
+        InstanceDumpRecord::class,
+        ObjectArrayDumpRecord::class,
+        PrimitiveArrayDumpRecord::class
+    )
+
+    override fun onTypeSizesAvailable(typeSizes: Map<Int, Int>) {
+      this.typeSizes = typeSizes
+    }
+
+    override fun onRecord(
+      position: Long,
+      record: Record
+    ) {
+      if (consumed) {
+        throw IllegalStateException("This builder instance already produced a HprofInMemoryIndex")
+      }
+      when (record) {
+        is StringRecord -> {
+          if (PRIMITIVE_WRAPPER_TYPES.contains(record.string)) {
+            primitiveWrapperClassNames.add(record.id)
+          }
+          hprofStringCache[record.id] = record.string
+        }
+        is LoadClassRecord -> {
+          classNames[record.id] = record.classNameStringId
+          if (primitiveWrapperClassNames.contains(record.classNameStringId)) {
+            primitiveWrapperTypes.add(record.id)
+          }
+        }
+        is ClassDumpRecord -> {
+          objectIndex[record.id] = IndexedClass(position, record.superClassId, record.instanceSize)
+        }
+        is InstanceDumpRecord -> {
+          objectIndex[record.id] =
+            IndexedInstance(position, record.classId)
+        }
+        is ObjectArrayDumpRecord -> {
+          objectIndex[record.id] = IndexedObjectArray(position, record.arrayClassId)
+        }
+        is PrimitiveArrayDumpRecord -> {
+          val primitiveType = when (record) {
+            is BooleanArrayDump -> PrimitiveType.BOOLEAN
+            is CharArrayDump -> PrimitiveType.CHAR
+            is FloatArrayDump -> PrimitiveType.FLOAT
+            is DoubleArrayDump -> PrimitiveType.DOUBLE
+            is ByteArrayDump -> PrimitiveType.BYTE
+            is ShortArrayDump -> PrimitiveType.SHORT
+            is IntArrayDump -> PrimitiveType.INT
+            is LongArrayDump -> PrimitiveType.LONG
+          }
+          objectIndex[record.id] = IndexedPrimitiveArray(position, primitiveType)
+        }
+      }
+    }
+
+    fun buildIndex(): HprofInMemoryIndex {
+      consumed = true
+      // Passing references to avoid copying the underlying data structures.
+      return HprofInMemoryIndex(
+          hprofStringCache, classNames, objectIndex,
+          typeSizes,
+          primitiveWrapperTypes
+      )
+    }
+
+  }
+
+  companion object {
+
+    private val PRIMITIVE_WRAPPER_TYPES = setOf<String>(
+        Boolean::class.java.name, Char::class.java.name, Float::class.java.name,
+        Double::class.java.name, Byte::class.java.name, Short::class.java.name,
+        Int::class.java.name, Long::class.java.name
+    )
+
+    fun createOnRecordListener(): Builder {
+      return Builder()
+    }
+
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/IndexedObject.kt b/leakcanary-haha/src/main/java/leakcanary/internal/IndexedObject.kt
new file mode 100644
index 00000000..925fe8f1
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/IndexedObject.kt
@@ -0,0 +1,33 @@
+package leakcanary.internal
+
+import leakcanary.PrimitiveType
+
+internal sealed class IndexedObject {
+  abstract val position: Long
+
+  class IndexedClass(
+    override val position: Long,
+    val superClassId: Long,
+    val instanceSize: Int
+  ) : IndexedObject()
+
+  class IndexedInstance(
+    override val position: Long,
+    val classId: Long
+  ) : IndexedObject()
+
+  class IndexedObjectArray(
+    override val position: Long,
+    val arrayClassId: Long
+  ) : IndexedObject()
+
+  class IndexedPrimitiveArray(
+    override val position: Long,
+    primitiveType: PrimitiveType
+  ) : IndexedObject() {
+    private val primitiveTypeOrdinal: Byte = primitiveType.ordinal.toByte()
+    val primitiveType: PrimitiveType
+      get() = PrimitiveType.values()[primitiveTypeOrdinal.toInt()]
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToObjectSparseArray.kt b/leakcanary-haha/src/main/java/leakcanary/internal/LongToObjectSparseArray.kt
new file mode 100644
index 00000000..cf2ff87a
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/LongToObjectSparseArray.kt
@@ -0,0 +1,77 @@
+package leakcanary.internal
+
+import leakcanary.internal.SparseArrayUtils.appendLong
+import leakcanary.internal.SparseArrayUtils.appendObject
+import leakcanary.internal.SparseArrayUtils.binarySearch
+import leakcanary.internal.SparseArrayUtils.insertLong
+import leakcanary.internal.SparseArrayUtils.insertObject
+
+/**
+ * Same as [LongToLongSparseArray] but long to object instead.
+ */
+internal class LongToObjectSparseArray<T>(initialCapacity: Int) : Cloneable {
+  private var keys: LongArray
+  private var values: Array<T?>
+
+  var size: Int = 0
+    private set
+
+  init {
+    keys = LongArray(initialCapacity)
+    @Suppress("UNCHECKED_CAST")
+    values = arrayOfNulls<Any?>(initialCapacity) as Array<T?>
+    size = 0
+  }
+
+  operator fun get(key: Long): T {
+    val i = binarySearch(keys, size, key)
+
+    return if (i < 0 || values[i] == null) {
+      throw NullPointerException("Key $key not set")
+    } else {
+      values[i]!!
+    }
+  }
+
+  operator fun set(
+    key: Long,
+    value: T
+  ) {
+    if (size != 0 && key <= keys[size - 1]) {
+      insert(key, value)
+      return
+    }
+
+    keys = appendLong(keys, size, key)
+    values = appendObject(values, size, value)
+    size++
+  }
+
+  fun entrySequence(): Sequence<Pair<Long, T>> {
+    return (0..size).asSequence().filter { values[it] != null }.map { keys[it] to values[it]!! }
+  }
+
+  private fun insert(
+    key: Long,
+    value: T
+  ) {
+    var i = binarySearch(keys, size, key)
+
+    if (i >= 0) {
+      values[i] = value
+    } else {
+      i = i.inv()
+
+      if (i < size && values[i] == null) {
+        keys[i] = key
+        values[i] = value
+        return
+      }
+
+      keys = insertLong(keys, size, i, key)
+      values = insertObject(values, size, i, value)
+      size++
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/SparseArrayUtils.kt b/leakcanary-haha/src/main/java/leakcanary/internal/SparseArrayUtils.kt
index e0b39d53..8a3e0557 100644
--- a/leakcanary-haha/src/main/java/leakcanary/internal/SparseArrayUtils.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/SparseArrayUtils.kt
@@ -21,6 +21,26 @@ internal object SparseArrayUtils {
     return newArray
   }
 
+  fun <T> insertObject(
+    array: Array<T?>,
+    currentSize: Int,
+    index: Int,
+    element: T
+  ): Array<T?> {
+    if (currentSize + 1 <= array.size) {
+      System.arraycopy(array, index, array, index + 1, currentSize - index)
+      array[index] = element
+      return array
+    }
+
+    @Suppress("UNCHECKED_CAST")
+    val newArray = arrayOfNulls<Any?>(growSize(currentSize)) as Array<T?>
+    System.arraycopy(array, 0, newArray, 0, index)
+    newArray[index] = element
+    System.arraycopy(array, index, newArray, index + 1, array.size - index)
+    return newArray
+  }
+
   fun insertLong(
     array: LongArray,
     currentSize: Int,
@@ -89,6 +109,22 @@ internal object SparseArrayUtils {
     return returnedArray
   }
 
+  fun <T> appendObject(
+    array: Array<T?>,
+    currentSize: Int,
+    element: T
+  ): Array<T?> {
+    var returnedArray = array
+    if (currentSize + 1 > returnedArray.size) {
+      @Suppress("UNCHECKED_CAST")
+      val newArray = arrayOfNulls<Any?>(growSize(currentSize)) as Array<T?>
+      System.arraycopy(returnedArray, 0, newArray, 0, currentSize)
+      returnedArray = newArray
+    }
+    returnedArray[currentSize] = element
+    return returnedArray
+  }
+
   fun appendString(
     array: Array<String?>,
     currentSize: Int,
diff --git a/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt b/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
index 0aeca12b..a3d0b26d 100644
--- a/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
+++ b/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
@@ -1,7 +1,6 @@
 package leakcanary
 
 import leakcanary.HeapValue.ObjectReference
-import leakcanary.HprofParser.RecordCallbacks
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
@@ -31,11 +30,13 @@ class HprofWriterTest {
     hprofFile.writeRecords(records)
 
     hprofFile.readHprof { graph ->
-      val treasureChestClass = graph.readClass(TREASURE_CHEST_CLASS_NAME)!!
+      val treasureChestClass = graph.indexedClass(TREASURE_CHEST_CLASS_NAME)!!
       val baguetteInstance =
-        treasureChestClass[CONTENT_FIELD_NAME]!!.value.readObjectRecord()!!.asInstance!!
+        treasureChestClass[CONTENT_FIELD_NAME]!!.value.asObject!!.asInstance!!
 
-      assertThat(baguetteInstance[BAGUETTE_CLASS_NAME, ANSWER_FIELD_NAME]!!.value.asInt!!).isEqualTo(42)
+      assertThat(
+          baguetteInstance[BAGUETTE_CLASS_NAME, ANSWER_FIELD_NAME]!!.value.asInt!!
+      ).isEqualTo(42)
     }
   }
 
@@ -115,11 +116,10 @@ class HprofWriterTest {
   }
 
   fun File.readHprof(block: (HprofGraph) -> Unit) {
-    HprofParser.open(this)
-        .use { parser ->
-          parser.scan(RecordCallbacks())
-          block(HprofGraph(parser))
-        }
+    val (graph, closeable) = HprofGraph.readHprof(this)
+    closeable.use {
+      block(graph)
+    }
   }
 
   companion object {
diff --git a/settings.gradle b/settings.gradle
index ed968aba..5b1579ed 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -3,6 +3,7 @@ include ':leakcanary-android'
 include ':leakcanary-android-core'
 include ':leakcanary-android-instrumentation'
 include ':leakcanary-android-process'
+include ':leakcanary-cli'
 include ':leakcanary-haha'
 include ':leakcanary-leaksentry'
 include ':leakcanary-log'
