diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 00000000..e4452455
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,23 @@
+language: android
+
+android:
+  components:
+    - build-tools-21.1.2
+    - android-21
+  licenses:
+    - android-sdk-license-5be876d5
+
+jdk:
+  - oraclejdk7
+
+script:
+  - ./gradlew clean build check
+
+notifications:
+  email: false
+
+sudo: false
+
+cache:
+  directories:
+    - $HOME/.gradle
\ No newline at end of file
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 01be9cfd..13227b52 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,84 @@
 # Change Log
 
+## Version 1.3.2-SNAPSHOT
+
+* Added ProGuard configuration for debug library [132](https://github.com/square/leakcanary/issues/132).
+* 2 new ignored Android SDK leaks: [#26](https://github.com/square/leakcanary/issues/26) [#62](https://github.com/square/leakcanary/issues/62).
+* Added excluded leaks to text report [#119](https://github.com/square/leakcanary/issues/119).
+* Added LeakCanary SHA to text report [#120](https://github.com/square/leakcanary/issues/120).
+
+### Dependencies
+
+```gradle
+ dependencies {
+   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3.2-SNAPSHOT'
+   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.2-SNAPSHOT'
+ }
+```
+
+Snapshots are available in Sonatype's `snapshots` repository:
+
+```
+  repositories {
+    mavenCentral()
+    maven {
+      url 'https://oss.sonatype.org/content/repositories/snapshots/'
+    }
+  }
+```
+
+[![Build Status](https://travis-ci.org/square/leakcanary.svg?branch=master)](https://travis-ci.org/square/leakcanary)
+
+## Version 1.3.1 *(2015-05-16)*
+
+* Heap dumps and analysis results are now saved on the sd card: [#21](https://github.com/square/leakcanary/issues/21).
+* `ExcludedRef` and `AndroidExcludedRefs` are customizable: [#12](https://github.com/square/leakcanary/issues/12) [#73](https://github.com/square/leakcanary/issues/73).
+* 7 new ignored Android SDK leaks: [#1](https://github.com/square/leakcanary/issues/1) [#4](https://github.com/square/leakcanary/issues/4) [#32](https://github.com/square/leakcanary/issues/32) [#89](https://github.com/square/leakcanary/pull/89) [#82](https://github.com/square/leakcanary/pull/82) [#97](https://github.com/square/leakcanary/pull/97).
+* Fixed 3 crashes in LeakCanary: [#37](https://github.com/square/leakcanary/issues/37) [#46](https://github.com/square/leakcanary/issues/46) [#66](https://github.com/square/leakcanary/issues/66).
+* Fixed StrictMode thread policy violations: [#15](https://github.com/square/leakcanary/issues/15).
+* Updated `minSdkVersion` from `9` to `8`: [#57](https://github.com/square/leakcanary/issues/57).
+* Added LeakCanary version name to `LeakCanary.leakInfo()`: [#49](https://github.com/square/leakcanary/issues/49).
+* `leakcanary-android-no-op` is lighter, it does not depend on `leakcanary-watcher` anymore, only 2 classes now: [#74](https://github.com/square/leakcanary/issues/74).
+* Adding field state details to the text leak trace.
+* A Toast is displayed while the heap dump is in progress to warn that the UI will freeze: [#20](https://github.com/square/leakcanary/issues/49). You can customize the toast by providing your own layout named `__leak_canary_heap_dump_toast.xml` (e.g. you could make it an empty layout).
+* If the analysis fails, the result and heap dump are kept so that it can be reported to LeakCanary: [#102](https://github.com/square/leakcanary/issues/102).
+* Update to HAHA 1.3 to fix a 2 crashes [#3](https://github.com/square/leakcanary/issues/3) [46](https://github.com/square/leakcanary/issues/46)
+
+### Public API changes
+
+* When upgrading from 1.3 to 1.3.1, previously saved heap dumps will not be readable any more, but they won't be removed from the app directory. You should probably uninstall your app.
+* Added `android.permission.WRITE_EXTERNAL_STORAGE` to `leakcanary-android` artifact.
+* `LeakCanary.androidWatcher()` parameter types have changed (+ExcludedRefs).
+* `LeakCanary.leakInfo()` parameter types have changed (+boolean)
+* `ExcludedRef` is now serializable and immutable, instances can be created using `ExcludedRef.Builder`.
+* `ExcludedRef` is available in `HeapDump`
+* `AndroidExcludedRefs` is an enum, you can now pick the leaks you want to ignore in `AndroidExcludedRefs` by creating an `EnumSet` and calling `AndroidExcludedRefs.createBuilder()`.
+* `AndroidExcludedRefs.createAppDefaults()` & `AndroidExcludedRefs.createAndroidDefaults()` return a `ExcludedRef.Builder`.
+* `ExcludedRef` moved from `leakcanary-analyzer` to `leakcanary-watcher`
+
+### Dependencies
+
+```gradle
+ dependencies {
+   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3.1'
+   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.1'
+ }
+```
+
+### Statistics
+
+* 33 commits to the LeakCanary library code and 11 commits to [HAHA](https://github.com/square/haha).
+* 6 contributors: [Pierre-Yves Ricau](https://github.com/square/leakcanary/commits?author=pyricau), [Sergey Shulepov](https://github.com/square/leakcanary/commits?author=pepyakin), [Romain Guy](https://github.com/square/leakcanary/commits?author=romainguy), [liaohuqiu](https://github.com/square/leakcanary/commits?author=liaohuqiu), [Dario Marcato](https://github.com/square/leakcanary/commits?author=dmarcato), [Anders Aagaard](https://github.com/square/leakcanary/commits?author=andaag).
+
 ## Version 1.3 *(2015-05-08)*
 
-Initial release.
\ No newline at end of file
+Initial release.
+
+### Dependencies
+
+```gradle
+ dependencies {
+   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3'
+   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3'
+ }
+```
\ No newline at end of file
diff --git a/README.md b/README.md
index 1bc82550..193b193e 100644
--- a/README.md
+++ b/README.md
@@ -12,8 +12,8 @@ In your `build.gradle`:
 
 ```gradle
  dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3'
-   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3'
+   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3.1'
+   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.1'
  }
 ```
 
@@ -81,7 +81,7 @@ public abstract class BaseFragment extends Fragment {
 
 ## How does it work?
 
-1. `RefWatcher.watch()` creates a [KeyedWeakReference](https://github.com/square/leakcanary/blob/master/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java) to the watched object.
+1. `RefWatcher.watch()` creates a [KeyedWeakReference](https://github.com/square/leakcanary/blob/master/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java) to the watched object.
 2. Later, in a background thread, it checks if the reference has been cleared and if not it triggers a GC.
 3. If the reference is still not cleared, it then dumps the heap into a `.hprof` file stored on the app file system.
 4. `HeapAnalyzerService` is started in a separate process and `HeapAnalyzer` parses the heap dump using [HAHA](https://github.com/square/haha).
@@ -113,11 +113,18 @@ Once you have the leak trace, figure out which reference in the path should not
 
 ## My leak is caused by the Android SDK implementation!
 
-There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: [AndroidExcludedRefs.java](https://github.com/square/leakcanary/blob/master/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java). If you find a new one, please [create an issue](https://github.com/square/leakcanary/issues/new) with the leak trace, the reference key, the device and the Android version. It's even better if you provide a link to a heap dump file.
+There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: [AndroidExcludedRefs.java](https://github.com/square/leakcanary/blob/master/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java).
 
-This is especially important for **new releases of Android**. You have the opportunity to help detect new memory leaks early on, which could benefit the entire Android community. 
+If you find a new one, please [create an issue](https://github.com/square/leakcanary/issues/new) and follow these steps:
 
-Snapshots of the development version are available in [Sonatype's `snapshots` repository](https://oss.sonatype.org/content/repositories/snapshots/).
+1. Provide the entire leak trace information (reference key, device, etc).
+2. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions [android/platform_frameworks_base](https://github.com/android/platform_frameworks_base).
+3. Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed.
+4. If it's still happening, build a simple repro case
+5. File an issue on [b.android.com](http://b.android.com) with the leak trace and the repro case
+6. Create a PR in LeakCanary to update `AndroidExcludedRefs.java`. Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
+
+This is especially important for **new releases of Android**. You have the opportunity to help detect new memory leaks early on, which benefits the entire Android community. 
 
 ## Beyond the leak trace
 
@@ -171,10 +178,10 @@ res/
 
 You can change the default behavior to upload the leak trace and heap dump to a server of your choosing.
 
-Create your own `AbstractAnalysisResultService`. The easiest way is to extend `DefaultAnalysisResultService` in your debug sources:
+Create your own `AbstractAnalysisResultService`. The easiest way is to extend `DisplayLeakService` in your debug sources:
 
 ```java
-public class LeakUploadService extends DefaultAnalysisResultService {
+public class LeakUploadService extends DisplayLeakService {
   @Override protected void afterDefaultHandling(HeapDump heapDump, AnalysisResult result, String leakInfo) {
     if (!result.leakFound || result.excludedLeak) {
       return;
@@ -212,7 +219,7 @@ Build a custom `RefWatcher` in your debug Application class:
 ```java
 public class DebugExampleApplication extends ExampleApplication {
   protected RefWatcher installLeakCanary() {
-    return LeakCanary.install(app, LeakUploadService.class);
+    return LeakCanary.install(app, LeakUploadService.class, AndroidExcludedRefs.createAppDefaults().build());
   }
 }
 ```
@@ -232,8 +239,78 @@ Don't forget to register the service in your debug manifest:
 
 You can also upload the leak traces to Slack or HipChat, [here's an example](https://gist.github.com/pyricau/06c2c486d24f5f85f7f0).
 
+### Ignoring specific references
+
+You can create your own version of `ExcludedRefs` to ignore specific references that you know are causing leaks but you still want to ignore:
+
+```java
+public class DebugExampleApplication extends ExampleApplication {
+  protected RefWatcher installLeakCanary() {
+    ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults()
+        .instanceField("com.example.ExampleClass", "exampleField")
+        .build();
+    return LeakCanary.install(this, DisplayLeakService.class, excludedRefs);
+  }
+}
+```
+
+### Not watching specific activity classes
+
+`ActivityRefWatcher` is installed by default and watches all activities. You can customize the installation steps to use something different instead:
+
+```java
+public class DebugExampleApplication extends ExampleApplication {
+  protected RefWatcher installLeakCanary() {
+    if (isInAnalyzerProcess(this)) {
+      return RefWatcher.DISABLED;
+    } else {
+      ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults().build();
+      enableDisplayLeakActivity(application);
+      ServiceHeapDumpListener heapDumpListener = new ServiceHeapDumpListener(application, DisplayLeakService.class);
+      final RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);
+      registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() {
+        public void onActivityDestroyed(Activity activity) {
+          if (activity instanceof ThirdPartyActivity) {
+              return;
+          }
+          refWatcher.watch(activity);
+        }
+        // ...
+      });
+      return refWatcher;
+    }
+  }
+}
+```
+
+
+## Snapshots of the development version
+
+See the [CHANGELOG](https://github.com/square/leakcanary/blob/master/CHANGELOG.md).
+
+## Troubleshooting
+
+* if `leakcanary-android` is not in the list of external libraries in Android Studio, but `leakcanary-analyzer` and `leakcanary-watcher` are there: try doing a `Clean Build`. If it's still a problem, try building from the command line.
+* `error: package com.squareup.leakcanary does not exist`: if you have other build types than `debug` and `release`, you need to add a specific dependency for those too (`xxxCompile`).
+
+## Resources
+
+* LeakCanary: Detect all memory leaks! [squ.re/leakcanary](http://squ.re/leakcanary).
+* Wrangling Dalvik series: [Memory management in Android](http://www.raizlabs.com/dev/2014/03/wrangling-dalvik-memory-management-in-android-part-1-of-2/).
+* Uploading leak traces to a [Slack or HipChat channel](https://gist.github.com/pyricau/06c2c486d24f5f85f7f0).
+* Dump the heap on [OutOfMemoryError crashes](https://gist.github.com/pyricau/4726389fd64f3b7c6f32).
+* StackOverflow: [leakcanary tag](http://stackoverflow.com/questions/tagged/leakcanary).
+
+### Translations
+
+* squ.re/leakcanary [in Chinese](http://www.liaohuqiu.net/cn/posts/leak-canary/).
+* squ.re/leakcanary [in Russian](http://habrahabr.ru/post/257633/).
+* `README.md` in Chinese: [中文版说明](http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/).
+
 ![icon_512.png](assets/icon_512.png)
 
+The name **LeakCanary** is a reference to the expression [canary in a coal mine](http://en.wiktionary.org/wiki/canary_in_a_coal_mine), because LeakCanary is a sentinel used to detect risks by providing advance warning of a danger. Props to [@edenman](https://github.com/edenman) for suggesting it!
+
 ## License
 
     Copyright 2015 Square, Inc.
diff --git a/assets/icon_1024.png b/assets/icon_1024.png
new file mode 100644
index 00000000..5dfdcf84
Binary files /dev/null and b/assets/icon_1024.png differ
diff --git a/assets/icon_512.png b/assets/icon_512.png
old mode 100755
new mode 100644
index 44caf54d..bb24dbad
Binary files a/assets/icon_512.png and b/assets/icon_512.png differ
diff --git a/assets/screenshot.png b/assets/screenshot.png
index dab89476..f68053b6 100644
Binary files a/assets/screenshot.png and b/assets/screenshot.png differ
diff --git a/assets/source_icon.png b/assets/source_icon.png
index 0bfbd9ec..827e5552 100644
Binary files a/assets/source_icon.png and b/assets/source_icon.png differ
diff --git a/assets/vector_icon.afdesign b/assets/vector_icon.afdesign
new file mode 100644
index 00000000..a30fcf97
Binary files /dev/null and b/assets/vector_icon.afdesign differ
diff --git a/assets/vector_icon.svg b/assets/vector_icon.svg
new file mode 100644
index 00000000..9a17f0dc
--- /dev/null
+++ b/assets/vector_icon.svg
@@ -0,0 +1,6 @@
+<?xml version="1.0" standalone="no"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg width="100%" height="100%" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421;">
+    <image id="Container" x="33" y="44" width="443px" height="441px" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbsAAAG5CAYAAAAXoZoVAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAcMklEQVR4nO3dT4gkZ/nA8Wd6Zmc3mw1ZXEmCfxJCfgZJMDEHwaiRmEsQEolBAkET0Jw96CEXQQRFDyKePOXgIRhFBFFEzCFBEzRIFj0kIaJBCQZB8mezJG522Z3q38Gttqamqrq6u7q76u3PB4bu6Z3p6V525rvPW2/1bI3H4wCAlO2s+wF0YazYAEu1tbW1te7HsIitvnZi1oD19XkADF3bzvU5iL2KXVPg+vQ4Afivur71LXxrjd08cZv1dgDm0xCymT9v3fFbS+zqIld1c/E2oQNYraZGFf+sbRjXFb2Vxq4cuVnill+f9jkAdKdmSqv98/z9utsL7680eiuJ3bTINUWtTfAEEGBxbaazadfrLuu+xqqit9TYtY1c02Xx+iuvvBJ///vf44033ojXX39939upU6fi/PnzS3suAJvm6NGj8a53vStOnDhx4O2GG26Iyy67bF/UpgVvykS41OgtLXbF0LWJXPn6eDyOLMvixRdfjD/84Q/xzDPPxCuvvLKUxwrAbLa3t+PGG2+MW2+9NT7+8Y/HVVddVRu+ttFbZvCWEru60E2LW/7+yZMn46mnnoo//vGPcerUqc4fHwDduvbaa+NjH/tY3HHHHfH+97//QOzaRm9Zwes8dk2hqwpc8e2FF16IRx55JF588cVOHxMAqzEajeLOO++MBx54IE6cOHEgdnVTX/5+4Xqn0es0dnnoZo3cyy+/HD/84Q/jmWee6eyxALA+hw8fjnvvvTfuu+++OHr0aG30Wmxo6SR6ncWuKXTF4GVZNnn/9ddfj0cffTQef/zxyLKsk8cBQH9cfvnlcf/998fdd98dOzs7MRqN1jLldRK7cuiaJrk8di+88EJ885vfjDfffHPhrw9Av910003xta99LS6//PLK4LU4prdQ8BaOXVXoyteL01yWZfH444/HD37wA6cKAGyQq666Kr7xjW/ENddcsy94xesR1Ts4L16fO3gLxa4pdOXAjcfjuHDhQjzyyCPxi1/8Yu6vCcBwXXLJJfHwww/HRz/60QOhy9+P6D54c8euLnRVy5ZZlsXbb78d3/nOd+JPf/rTXF8PgDSMRqN48MEH47777psErjzpRXQbvLli1yZ0eeTG43GcPXs2Hn744fjb3/4289cCIE33339/fOELX5jEboZjeTPHbjTrJ0wLXR65/G1vby++//3vCx0A+/zkJz+Jp59+el8zql5opGLz48xT2kyxaxO6cvB++tOfxlNPPTXr4wIgcePxeDIMlQelvCX5x5WDN6vWsWuz67IYur29vXjmmWfi0UcfneuBAZC+c+fOxbe+9a14/fXXY29v78B0V3cO9qzT3czLmGVV01yWZfGPf/wjvve9781dYQA2w2uvvRbf/va349y5c5PglaO36HJmq9i13XmZR+/8+fPx3e9+N86ePTvjUwZgE/3lL3+Jxx57rHI5s4vgzbKMObms25Syt7cXe3t78cQTT8Q///nPmZ8sAJvrV7/6Vbz66qv7pru6jSuzmhq7umpWLV1mWRZnz56Nxx57bK4HA8DmOnfuXPz4xz9unOwiKl+acmoBG2NXt3xZdQAxn+x++ctfxhtvvLHI8wVgQz355JPx8ssvVwYvovp3oLZRG7um43TF94uhO336dPz85z9f4GkCsMmyLItHH320cikzD1+VadPdPCeVVz6ALMviZz/7WZw5c2bWuwSAiZMnT8YLL7xQu5xZNe1N03Y3Zu3GlPzy3Llz8cQTTyz2DAEgIn7zm9/UblKJ2H+ud65pupt2zO7A+3U7MZ977rl455135n5iAJD785//HOfOnTvwiirTNqvUqYxdsY5NU13x7dlnn+3sSQKw2c6cORPPP//8zKcf1E13TRtUDrxftwPzwoULcfLkyXmfEwAc8Oyzzx54RZWmE82bHIhduYrTjtVlWRYvvfRSnDp1qsOnCMCmO3ny5NRXVClqOu+u1TE7S5gArNqpU6fipZdeqvxtCAtNduVz66quF79I/sWff/75zp4cAOSee+65A92JmP3k8rkmu/JS5muvvdbFcwKAfV577bXaya5K3e1TN6hM24l54cKFePvttzt4SgCw36lTpxo3pjQcv9t3Q9UGlcovWBe9U6dO1f5yPQBYxOnTpw9siqwLXdNS5iR2bXZhVk13dmECsCz5QDXvKQe5upPKay/L46TYAbAsp0+frvzt5RHVQ1l+e1mb32d34LI42fl1PgAsS/4bdeZZuiyuWJZPPaj7hNr10rfeemumURIA2sjbknemKXjT4je6+IeVx+uK18vn2816jgMAzKrq/O7OjtkVv0j5/brz7QCgK3UDVvH9qo+r0+qYXdOOTABYhmLQyptT8tvbrjI2nlRe9UnlOy4Gz4QHQNfqdl+2+Zxcq5PKpx0QBIBlatpL0mZH5kynHtSdhgAAy9IUtrYNmhq7ui8qdACsUlN7Fj6pvOmLAsCyNZ0C19bUUw+6GB8BoAvzrio2vjZm1W2WLwFYpabuzH3MziuiANB3bU8mzxV/xU/ndw4AXVnkUNpcG1SEDoB1mLc/c+/GXOSLAsAsFu1NqxeCFjUA1qWLMwFaT3ZVr54CAKuySHcWWsYEgCEQOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTO4ABGI/H634IgyZ2AAMwHo8jy7J1P4zBEjuAARG8+YgdwMAI3uzEDqDnqo7XCd5sxA5goASvPbED6LmmnZiC147YAQyc4E0ndgA91vb8OsFrJnYAiRC8emIHkJAsy7zaSgWxA+ixecI1Ho8Fr0TsABIkePuJHUBPLRorwfsfsQNImOD9l9gB9FRXkRI8sQPYCJsePLED2BCbHDyxA+ihZUVpU4MndgAbZhODJ3YAPbTsGG1a8MQOYENtUvDEDqBnVhmgTQme2AFsuE0IntgB9Mw6wpN68MQOgIhIO3hiB8BEqsETO4Ae6UNoUgye2AFwQGrBEzsAKo3H48iybN0PoxNiB9AjfZymUgie2AEw1dCDJ3YAPdHHqa5oyMETOwBaG2rwxA6AmQwxeGIH0BN9X8YsGlrwxA6AuQwpeGIHwNyGEjyxA+iBIS1hlg0heGIHwML6HjyxA+iBIU92uT4HT+wA6Exfgyd2AHQqy7LeTapiB7BmfQtDF/r2K4LEDoCl6FPwxA6ApelL8MQOYM36EINl6kPwxA6ApVt38MQOYI3WPfGs0jqDJ3YArMy6gid2AKzUOoIndgBrtEnLmEWrDp7YAbAWqwye2AGwNqsKntgBrMmmLmGWrSJ4YgfA2i07eGIHsCYmu/2WGbydpdwrAMxB7ADYCMsInmVMgDWwhNms6yVNkx0AvZTHrovomewA6K3xeBx7e3sL34/YAayBZczVEjsAkid2ACRP7ABWzBLm6okdAMkTOwCSJ3YAK2YZc/XEDoDkiR3ACpnq1kPsAEie2AGQPLEDWCHLmOshdgAkT+wASJ7YAayIJcz1ETsAkid2ACRP7ABWxDLm+ogdAMkTO4AVMNWtl9gBkDyxAyB5YgewApYx10vsAEie2AGQPLEDWDJLmOsndgAkT+wASJ7YASyZZcz1EzsAkid2ACRP7ACWyBJmP4gdAMkTO4AlMtn1g9gBkDyxAyB5YgewJJYw+0PsAEie2AGQPLEDWBLLmP0hdgAkT+wASJ7YASyBJcx+ETsAkid2AEtgsusXsQMgeWIH0DFTXf+IHQDJEzsAkid2AB2zjNk/YgdA8sQOoEOmun4SOwCSJ3YAJE/sADpkGbOfxA6A5IkdQEdMdf0ldgAkT+wASJ7YAXTEMmZ/iR0AyRM7gA6Y6vpN7ABIntgBkDyxA+iAZcx+EzsAkid2AAsy1fWf2AGQPLEDWJDJrv/EDoDkiR3AAkx1wyB2ACRP7AAWYLIbBrEDIHliBzAnU91wiB0AyRM7gDmZ7IZD7ABIntgBzMFUNyxiB0DyxA5gDia7YRE7AJIndgAkT+wAZmQJc3jEDoDkiR3AjEx2wyN2ACRP7ABmYKobJrEDIHliBzADk90wiR0AyRM7gJZMdcMldgAtid1wiR0AyRM7gBZMdcMmdgAkT+wAWjDZDZvYAUwhdMMndgAkT+wApjDZDZ/YATQQujSIHQDJEzuABia7NIgdAMkTO4Aaprp0iB1ADbFLh9gBkDyxA6hgqkuL2AGQPLEDqGCyS4vYAZQIXXrEDoDkiR1AickuPWIHUCB0aRI7AJIndgAFJrs0iR3ARUKXLrEDuEjs0iV2ACRP7ADCVJc6sQMIsUud2AEbT+jSJ3YAJE/sgI1nskuf2AEbTeg2g9gBG03sNoPYARtL6DaH2AGQPLEDNpbJbnOIHbCRhG6ziB2wkcRus4gdsHGEbvOIHbBxxG7ziB2wUYRuM4kdsFHEbjOJHbAxhG5ziR2wMcRuc4kdsBGEbrOJHbARxG6ziR2QPKFD7ABIntgByTPZIXZA0oSOCLEDEid2RIgdkLAsy9b9EOgJsQOSZKKjSOyAJIkdRWIHJEfoKBM7IDliR5nYAUkROqqIHZCM8XgsdlQSOyAZQkcdsQOSIHQ0ETsgCWJHE7EDBs8rpTCN2AGDZqKjDbEDBk3saEPsgMGyfElbYgcMkomOWYgdMEhixyzEDhgcy5fMSuyAQTHRMQ+xAwbDa18yL7EDBkPomJfYAYPgOB2LEDug94SORYkd0GuWLumC2AG9ZUMKXRE7oJeEji6JHdBLQkeXxA7oHRtS6JrYAb0idCyD2AG9IXQsi9gBvSB0LJPYAWsndCyb2AFrJXSsgtgBayN0rMrOuh8AsHmcMM6qmeyAlRI61kHsgJUROtbFMiawEo7PsU4mO2DphI51M9kBS2PZkr4w2QFLIXT0ickO6JTI0UcmO6AzQkdfmeyAhYkcfSd2wELstGQIxA6Yi2mOIRE7YCYixxCJHdCKyDFkYgc0EjlSIHasXJZlsbW1FRExuaR/RI6UiB0rNxqNJjv48h+m4tcfIkeKxI612Nra2vcDNb9ejJ/wrY7AkTqxYy3ykNX9gC3+8DX1LUf5PxiQMrFjbaYFL1c19ZXvg/ZMcWwisWOt2gavqGr5UwDrmeBA7OiBeYJXJoD/I25wkNjRC10Er2xaAKveH5qq5wgcJHb0xjKCV1a+7/L7fYzhtMcMTCd29Er5lIRVaxuWZUZQzKB7YkfvFE867ytBgmHxm8rppdHIP02gO36i0FuCB3TFTxN6TfCALvhJQu/1YUckMGxiR+95UWhgUWLHIAgesAixYzAED5iX2DEoggfMQ+wYHMEDZiV2DJLYAbMQOwbLOXhAW35aMGiCB7ThJwWDJ3jANH5KkATBgzR19RtGOvkJMR6P/coT1k7wgDoL/3QQOfrELk1ITxedETuS4hw8SEfely6+p2f+TeX5F80vd3d3DwTPDxvWKf/35z9iMEzlQ2NHjx5d+D4bJ7titOoCdvz48YUfBHTNhAdpGI/HnXSm1TJm0w+N48eP26BCLwkeDN9oNIqdnf8uQi7y/bzQMbutra1J7CIsG9E/ggfDlA9R29vbB76H5/menil25eN1Ef9bxiwGT/ToE7GD4Sg2ZDwex+7ubkQs/n0892SXf+FDhw7FkSNHRI5ecw4eDEfek/F4HIcPH+7kPg/8BKia3qY5duxYZFkmePSa4EH/Fae6LMv27cRc5LDE5Lu/audl8Y7z6+UvtrW1FVdfffXkgRWLDH0jeNBfeTeyLJv05IMf/GDtx88Svrl3Yxajd8stt+yLnNDRZ4IH/VXuyJ133lk7jJVvazLzd33VtHfjjTfGzs7OvhoLHn1m0wr0S3lgyrIsLrvssrjkkksioj5ubb+Xp8auakmzfPvu7m584AMfOPBgBY++ckoC9E+5HzfccMOBASs36/fwzMuYdcfxbr755kmNTXcMgeBBP5Qnurwhd9111+Rj6vaNlP88v14208uFFd8fjUb73r/lllsiIg7ETvDoM8GDfijH7vDhw3HixInGwEV0sIzZtD5anuxGo1EcO3Ysrr/++skDNd0xFIIH61McjPb29ib9+NCHPhQRBye6qgmvaQPL1sUrtefZVX3itLd77rknIv473eUPWvAYAsGD9SlOdFmWxWg0igcffHCygjjtFLj8z5qMLn5Q5Ue1CV3xwVx99dVx880373vQgsdQCB6sVnnpMn+7/fbbY2dnp7Y1uaYJr2zfZFd3MnnVHRe/8Gg0mrz/2c9+Nkaj0b7pLg8e9J3YwWqUQ5f34vDhw3HvvfdWtqZpKXOa1rsxq0JXFbwTJ07ErbfeeuAJmO4YCiedw/IVY1fsxF133XVgiKoL3iym7sactpRZfkCj0SjuuuuuOHLkyIHgmfAYCsGD5akKXZZlcezYsbj99ttbha7NZpWi4mtjbhWuR/F6U+TKoct3Zt5zzz2T3TX5m+AxJIIH3SsvXeZvEREPPfTQvpZU9WWWwBW71njqQd0xvKoHUH679dZb47bbbjvwhCxpMiSCB92pCl3ehM985jNx3XXX1TalzUTXFL+ppx7s++DSMbppwbvnnnvi+uuvPzDhFZ8g9J1NK7C4uokuy7L48Ic/HJ/61Kcae1IVvogOTyov17NqU8r29nZsb2/vu769vR07OzvxxS9+Md797ndXPkHBYwickgDzq9p1WezAlVdeGQ888EBlT+qO3eUrLrMEr3zqwVbp/amnGxTfqh7kJZdcEg899NBkw8re3l5cuHBB9BgUwYPZTQvdkSNH4itf+cq+IanclLrJru6E81y5Z5WTXdU3dfmYXV3sytPdaDSKK664Ir70pS/FpZdeOnmiefAuXLjgtTQZBMGD9so7Li9cuDB5y0P31a9+NXZ3d/c1o9yPcgSrljDLmyqrtHoh6KolzDbLmMW3a6+9Nr785S/HVVdddWDCK056gkefCR40K09yxcjlP+OvuOKK+PrXvx4nTpyobUbdcmbVSmPE9KXMrXJYxhdvyG+vezmX4oSWv50/f37fW/G2/Pq5c+fiRz/6Ubz44osHgrnoAUhYFf8pg/9p04v89ptuuik+//nPx87OTuzs7MShQ4cml8W34m07OzuTfSBVS5s1097+w3JV37DF4FX9nqHiiYDF2FXFrer63t5ePP744/G73/0uxuNx662mxScC6yZ4bLJi4PLL/JBU3YuJfPrTn45PfvKTk9CVg1YVu/zjyhNf1QnnEZPVlwOh2Jn2hOpOMB+NRvtCtb29HVmWxfb29r44lq/n7rzzznjPe94Tv/71r+PNN9+cfEzTQUjRo2/KsVvVv0uRZV2qIlc1zRV//h87dizuv//+uO666/aFrhixqqDVDUER1b8Boen7r3Kyu/gExuUn07SzpmrCq7osr9+eP38+fv/738fTTz8dZ86cqTwmWF6jLT4p0WPdsiw7cNss/y6FiyGoi1x5oitGbnd3N+6444647bbb9gWtagmzPMnVLV/WTXVNOzEjpsSu6olVjal1wSsvX1a95Z979uzZePLJJ+PZZ5+N8+fP5w+41XQnfKxbVfBg6MqBy69PexuNRvGRj3wk7r777srzr8tBqwpeOY7FvR1NG1SqQhfRInZ1T65us0rTlNcUu/x+Tp8+Hb/97W/jr3/9a5w+fbr2pWBm2XIKq2BCY+hq9nBMvcyv7+7uxv/93//F5z73uX2nFIxGowNTXTl2VaErLm222c9RF7qIhthdfBKV013T7sxi7PLrdbErfnz5tdKyLIt//etf8dxzz8VLL70Ur776aozH48a4iR3rZsIjReXJLre1tRWXXnppXHfddfGJT3wirrzyysoXGilPdfn1cuzKf15cuqyLXf44Ll7WRqBxg8rW1tbWeDweb21tVYam+CK5xSBub2/vu738ufnnFx9slmWT9/PYve9974v3vve9kWVZvPnmm/H888/Hv//97/jPf/4Tb7/9dpw5cybeeeedyStmQx+Y8PzHMzWHDh2Ko0ePxtGjR+PYsWNx2WWXxTXXXBM33HBDHDp0qPbFRupiV/fWZnPKvJsVGye7iNmWM8sTXtWUV/V+eSmz/Mv8ipcR//vfc/7Q3nrrrTh9+vTkXI6K59DqLwO6UPXvcJYf/rMszYsKXakaSI4cORLHjx+P3d3dykNJxWNnTS8fWXUMrs2uzGmxm7YppWjqqQfT/kKK013bzys/2PyJ7O3t7bssb2HNL/OvmQf3+PHjcfnll0/uX9wAFtO0EXBa7KpeVaspeMWPaTPRVYR56v/62pxnt5VPd1XLmfn7VUuadX9xTX9J+bl2VedrlF9Dc9qBUwBmV7cBsOqt/HO8OJHl8aqb3KpCV/U6mFN247da3mg12TUFLw9T/mfTJr3yX9CisWsKnegBtFe3hF6MTP4zvnwKQNMSZjl4dUuW5dAVL2seb+t1/NbLmMXglZUjVfXAmv5XUPwL2tvbm1xWnYnfdrorEj2AZlXdqDtOV/czfNpSZtUUV7fjsuo8ulk3pRTNdMyubndmfhwtD115a+rW1lbs7e21Cl1+P/nLj9UFL/+65ejltxeJHUCzqg0q+WXT8bq6ya4ueOX4lT+nvPJXt3w5q5k3qBT/IuqCF1G9caX8wIuvhZmHLo9c+UVEy8ErT3WWMQEWN+/xuvyyKmDTLquWLqeFbpYlzIj5dmNuRfz3lIS2wav7i8oDVjxel7+VJ7umY3Y2qAB0p2ITyIHrdfsuqia8umXKNrsuuwhdxAKTXfEvpSp4VRGqi13dppSqJcy6pczi15nyqjCLPmWAQZvWirbTXdMmlbZvVeEsfr2KxzHXOubUk8qnqXpJsfyyHKaqKa0pblWhm2eDSuGxLvRcAVIxa/CmLWVWxW7abVX3Ufxa5cc5b+giOpjsCg+i8mXBImIy6eVPKP+44kuEFSe7cgyrohlxcKqzMQVgfk2bVPLLWSa8utvaHpvrKnQR3Sxj7juGd/H6gfG3ahorhq94vK9qils0dMIHUK0ucsXrs054VZfFZcqmaa7iMSz8unidTXZFVcfxqp5EHqliDIvBKx77swuTFJT/bXbwPQxLUTdl1U1jVZNa06aTVYYuooNjdmXjwh2WA1QVqbpz5preive9yPKlKAKbpm07Zpnuqm6bthu/+Gd1j62r0EUsIXYR9cHL36+bzOomt2nTXNVzEDKA+bQ5dpdfNgWv7rbi7VVfs8vITe5zWVEYV9xx06RXvK3NRDht96XYAcynqjU1m0Yqp7Sm61X3Ubi+tHX9pcUuV45e06TX9v3y/diMAtCtWTetlC+bPr7mPpd6AHvpscu1mfTa3NZ0e9X9AjC7pumu6s/nCVzhtqXv1FpZ7HJtJr26P2vz523+DICD2jRnWvCabq+4r5VtR1557HLTJr2m29s8ZrEDmM0s7ZkWtKb7WmXkJl9z3VGoil7hz5o+b9r9zv+gADbQtAbNOvkVblv7CaVrj13ZvPEDYHVahm/tkcv1LnZlTfEDoD/6FLey3seujggCrFafYzbNYGMHAG39P8QjHPIeCPK8AAAAAElFTkSuQmCC"/>
+    <path id="Canary Badge" d="M112.189,145.49L254.837,81.3501L396.288,145.49C396.288,145.49 396.862,207.984 396.288,231.803C400.997,350.37 312.745,416.946 254.837,430.897C196.973,416.761 109.794,350.592 112.189,231.803C112.756,203.667 112.189,145.49 112.189,145.49ZM175.089,342.14C175.089,342.14 184.466,327.557 200.474,320.28C204.922,315.034 207.831,307.409 215.292,300.115C219.468,296.033 226.552,291.174 233.166,288.656C239.785,286.137 247.648,284.843 255,285C262.352,285.157 268.152,286.319 277.281,289.599C300.356,298.133 328.246,333.945 334.028,349.404C315.038,361.253 296.986,374.343 277.281,397.842C273.2,395.993 262.831,392.31 245.929,394.232C225.332,398.578 205.605,369.407 206.507,353.455C194.408,348.947 175.089,342.14 175.089,342.14ZM239.502,332.155C236.224,332.127 234.144,330.44 233.732,328.884C233.319,327.329 235.679,323.517 237.026,322.821C244.051,319.192 251.916,319.735 251.916,319.735C251.916,319.735 254.299,332.28 239.502,332.155ZM238.929,221.803L270.281,221.803L270.281,254.418L238.929,254.418L238.929,221.803ZM238.929,136.356L270.281,136.356L270.281,205.834L238.929,205.834L238.929,136.356Z" style="fill:rgb(253,237,0);"/>
+</svg>
diff --git a/library/build.gradle b/build.gradle
similarity index 80%
rename from library/build.gradle
rename to build.gradle
index 7d6edde7..708f8146 100644
--- a/library/build.gradle
+++ b/build.gradle
@@ -2,6 +2,9 @@ subprojects {
 
   repositories {
     mavenCentral()
+//    maven {
+//      url 'https://oss.sonatype.org/content/repositories/snapshots/'
+//    }
   }
 
   buildscript {
@@ -9,21 +12,20 @@ subprojects {
       mavenCentral()
     }
     dependencies {
-      classpath 'com.android.tools.build:gradle:1.2.2'
+      classpath 'com.android.tools.build:gradle:1.2.3'
     }
   }
 }
 
 ext {
-  androidPlugin = 'com.android.tools.build:gradle:1.2.0'
-  minSdkVersion = 9
+  minSdkVersion = 8
   compileSdkVersion = 21
   targetSdkVersion = compileSdkVersion
   buildToolsVersion = '21.1.2'
   javaVersion = JavaVersion.VERSION_1_7
 
   GROUP = 'com.squareup.leakcanary'
-  VERSION_NAME = "1.3.1-SNAPSHOT"
+  VERSION_NAME = "1.3.2-SNAPSHOT"
   POM_PACKAGING = "pom"
   POM_DESCRIPTION= "Leak Canary"
 
@@ -38,4 +40,4 @@ ext {
 
   POM_DEVELOPER_ID="square"
   POM_DEVELOPER_NAME="Square, Inc."
-}
\ No newline at end of file
+}
diff --git a/library/checkstyle.xml b/checkstyle.xml
similarity index 100%
rename from library/checkstyle.xml
rename to checkstyle.xml
diff --git a/library/gradle/checkstyle.gradle b/gradle/checkstyle.gradle
similarity index 100%
rename from library/gradle/checkstyle.gradle
rename to gradle/checkstyle.gradle
diff --git a/library/gradle/gradle-mvn-push.gradle b/gradle/gradle-mvn-push.gradle
similarity index 100%
rename from library/gradle/gradle-mvn-push.gradle
rename to gradle/gradle-mvn-push.gradle
diff --git a/library/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
similarity index 100%
rename from library/gradle/wrapper/gradle-wrapper.jar
rename to gradle/wrapper/gradle-wrapper.jar
diff --git a/library/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
similarity index 100%
rename from library/gradle/wrapper/gradle-wrapper.properties
rename to gradle/wrapper/gradle-wrapper.properties
diff --git a/library/gradlew b/gradlew
similarity index 100%
rename from library/gradlew
rename to gradlew
diff --git a/library/leakcanary-analyzer/build.gradle b/leakcanary-analyzer/build.gradle
similarity index 97%
rename from library/leakcanary-analyzer/build.gradle
rename to leakcanary-analyzer/build.gradle
index 0df56e10..a64cb553 100644
--- a/library/leakcanary-analyzer/build.gradle
+++ b/leakcanary-analyzer/build.gradle
@@ -14,7 +14,7 @@ repositories {
 }
 
 dependencies {
-  compile 'com.squareup.haha:haha:1.1'
+  compile 'com.squareup.haha:haha:1.3'
   compile project(':leakcanary-watcher')
   testCompile 'junit:junit:4.12'
 }
diff --git a/library/leakcanary-analyzer/gradle.properties b/leakcanary-analyzer/gradle.properties
similarity index 100%
rename from library/leakcanary-analyzer/gradle.properties
rename to leakcanary-analyzer/gradle.properties
diff --git a/library/leakcanary-analyzer/src/main/AndroidManifest.xml b/leakcanary-analyzer/src/main/AndroidManifest.xml
similarity index 100%
rename from library/leakcanary-analyzer/src/main/AndroidManifest.xml
rename to leakcanary-analyzer/src/main/AndroidManifest.xml
diff --git a/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
similarity index 100%
rename from library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
rename to leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
diff --git a/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
similarity index 76%
rename from library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
rename to leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
index 3e8e775a..b12dcce4 100644
--- a/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.leakcanary;
 
+import android.util.Log;
 import java.io.File;
 import java.io.FileFilter;
 import java.util.ArrayList;
@@ -29,10 +30,14 @@
 import org.eclipse.mat.snapshot.IPathsFromGCRootsComputer;
 import org.eclipse.mat.snapshot.ISnapshot;
 import org.eclipse.mat.snapshot.PathsFromGCRootsTree;
+import org.eclipse.mat.snapshot.model.Field;
 import org.eclipse.mat.snapshot.model.IArray;
 import org.eclipse.mat.snapshot.model.IClass;
+import org.eclipse.mat.snapshot.model.IInstance;
 import org.eclipse.mat.snapshot.model.IObject;
+import org.eclipse.mat.snapshot.model.IObjectArray;
 import org.eclipse.mat.snapshot.model.NamedReference;
+import org.eclipse.mat.snapshot.model.ObjectReference;
 import org.eclipse.mat.snapshot.model.PrettyPrinter;
 import org.eclipse.mat.snapshot.model.ThreadToLocalReference;
 import org.eclipse.mat.util.VoidProgressListener;
@@ -57,12 +62,13 @@
 public final class HeapAnalyzer {
 
   private static final String ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$";
+  private static final String TAG = "HeapAnalyzer";
 
   private final ExcludedRefs baseExcludedRefs;
   private final ExcludedRefs excludedRefs;
 
   public HeapAnalyzer(ExcludedRefs excludedRefs) {
-    this(new ExcludedRefs(), excludedRefs);
+    this(new ExcludedRefs.Builder().build(), excludedRefs);
   }
 
   public HeapAnalyzer(ExcludedRefs baseExcludedRefs, ExcludedRefs excludedRefs) {
@@ -103,7 +109,7 @@ public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
       }
 
       return result;
-    } catch (SnapshotException e) {
+    } catch (Exception e) {
       return failure(e, since(analysisStartNanoTime));
     } finally {
       cleanup(heapDumpFile, snapshot);
@@ -207,25 +213,25 @@ private boolean validPath(ISnapshot snapshot, PathsFromGCRootsTree tree,
       return true;
     }
     // Note: the first child is the leaking object, the last child is the GC root.
-    IObject parent = null;
+    IObject held = null;
     while (tree != null) {
-      IObject child = snapshot.getObject(tree.getOwnId());
+      IObject holder = snapshot.getObject(tree.getOwnId());
       // Static field reference
-      if (child instanceof IClass) {
-        IClass childClass = (IClass) child;
+      if (holder instanceof IClass) {
+        IClass childClass = (IClass) holder;
         Set<String> childClassExcludedFields = excludedStaticFields.get(childClass);
         if (childClassExcludedFields != null) {
-          NamedReference ref = findChildInParent(parent, child, excludedRefs);
+          NamedReference ref = findHeldInHolder(held, holder, excludedRefs);
           if (ref != null && childClassExcludedFields.contains(ref.getName())) {
             return false;
           }
         }
-      } else if (child.getClazz().doesExtend(Thread.class.getName())) {
-        if (excludedRefs.excludedThreads.contains(getThreadName(child))) {
+      } else if (holder.getClazz().doesExtend(Thread.class.getName())) {
+        if (excludedRefs.excludedThreads.contains(getThreadName(holder))) {
           return false;
         }
       }
-      parent = child;
+      held = holder;
       int[] branchIds = tree.getObjectIds();
       tree = branchIds.length > 0 ? tree.getBranch(branchIds[0]) : null;
     }
@@ -236,16 +242,16 @@ private String getThreadName(IObject thread) throws SnapshotException {
     return PrettyPrinter.objectAsString((IObject) thread.resolveValue("name"), MAX_VALUE);
   }
 
-  private NamedReference findChildInParent(IObject parent, IObject child, ExcludedRefs excludedRefs)
+  private NamedReference findHeldInHolder(IObject held, IObject holder, ExcludedRefs excludedRefs)
       throws SnapshotException {
-    if (parent == null) {
+    if (held == null) {
       return null;
     }
-    Set<String> excludedFields = excludedRefs.excludeFieldMap.get(child.getClazz().getName());
-    for (NamedReference childRef : child.getOutboundReferences()) {
-      if (childRef.getObjectId() == parent.getObjectId() && (excludedFields == null
-          || !excludedFields.contains(childRef.getName()))) {
-        return childRef;
+    Set<String> excludedFields = excludedRefs.excludeFieldMap.get(holder.getClazz().getName());
+    for (NamedReference holdingRef : holder.getOutboundReferences()) {
+      if (holdingRef.getObjectId() == held.getObjectId() && (excludedFields == null
+          || !excludedFields.contains(holdingRef.getName()))) {
+        return holdingRef;
       }
     }
     return null;
@@ -254,55 +260,82 @@ private NamedReference findChildInParent(IObject parent, IObject child, Excluded
   private LeakTrace buildLeakTrace(ISnapshot snapshot, PathsFromGCRootsTree tree,
       ExcludedRefs excludedRefs) throws SnapshotException {
     List<LeakTraceElement> elements = new ArrayList<>();
-    IObject parent = null;
+    // We iterate from the leak to the GC root
+    IObject held = null;
     while (tree != null) {
-      IObject child = snapshot.getObject(tree.getOwnId());
-      elements.add(0, buildLeakElement(parent, child, excludedRefs));
-      parent = child;
+      IObject holder = snapshot.getObject(tree.getOwnId());
+      elements.add(0, buildLeakElement(held, holder, excludedRefs));
+      held = holder;
       int[] branchIds = tree.getObjectIds();
       tree = branchIds.length > 0 ? tree.getBranch(branchIds[0]) : null;
     }
     return new LeakTrace(elements);
   }
 
-  private LeakTraceElement buildLeakElement(IObject parent, IObject child,
-      ExcludedRefs excludedRefs) throws SnapshotException {
+  private LeakTraceElement buildLeakElement(IObject held, IObject holder, ExcludedRefs excludedRefs)
+      throws SnapshotException {
     LeakTraceElement.Type type = null;
     String referenceName = null;
-    NamedReference childRef = findChildInParent(parent, child, excludedRefs);
-    if (childRef != null) {
-      referenceName = childRef.getName();
-      if (child instanceof IClass) {
+    NamedReference holdingRef = findHeldInHolder(held, holder, excludedRefs);
+    if (holdingRef != null) {
+      referenceName = holdingRef.getName();
+      if (holder instanceof IClass) {
         type = STATIC_FIELD;
-      } else if (childRef instanceof ThreadToLocalReference) {
+      } else if (holdingRef instanceof ThreadToLocalReference) {
         type = LOCAL;
       } else {
         type = INSTANCE_FIELD;
       }
     }
 
-    LeakTraceElement.Holder holder;
+    LeakTraceElement.Holder holderType;
     String className;
     String extra = null;
-    if (child instanceof IClass) {
-      IClass clazz = (IClass) child;
-      holder = CLASS;
+    List<String> fields = new ArrayList<>();
+    if (holder instanceof IClass) {
+      IClass clazz = (IClass) holder;
+      holderType = CLASS;
       className = clazz.getName();
-    } else if (child instanceof IArray) {
-      holder = ARRAY;
-      IClass clazz = child.getClazz();
+      for (Field staticField : clazz.getStaticFields()) {
+        fields.add("static " + fieldToString(staticField));
+      }
+    } else if (holder instanceof IArray) {
+      holderType = ARRAY;
+      IClass clazz = holder.getClazz();
       className = clazz.getName();
+      if (holder instanceof IObjectArray) {
+        IObjectArray array = (IObjectArray) holder;
+        int i = 0;
+        ISnapshot snapshot = holder.getSnapshot();
+        for (long address : array.getReferenceArray()) {
+          if (address == 0) {
+            fields.add("[" + i + "] = null");
+          } else {
+            int objectId = snapshot.mapAddressToId(address);
+            IObject object = snapshot.getObject(objectId);
+            fields.add("[" + i + "] = " + object);
+          }
+          i++;
+        }
+      }
     } else {
-      IClass clazz = child.getClazz();
+      IInstance instance = (IInstance) holder;
+      IClass clazz = holder.getClazz();
+      for (Field staticField : clazz.getStaticFields()) {
+        fields.add("static " + fieldToString(staticField));
+      }
+      for (Field field : instance.getFields()) {
+        fields.add(fieldToString(field));
+      }
       className = clazz.getName();
       if (clazz.doesExtend(Thread.class.getName())) {
-        holder = THREAD;
-        String threadName = getThreadName(child);
+        holderType = THREAD;
+        String threadName = getThreadName(holder);
         extra = "(named '" + threadName + "')";
       } else if (className.matches(ANONYMOUS_CLASS_NAME_PATTERN)) {
         String parentClassName = clazz.getSuperClass().getName();
         if (Object.class.getName().equals(parentClassName)) {
-          holder = OBJECT;
+          holderType = OBJECT;
           // This is an anonymous class implementing an interface. The API does not give access
           // to the interfaces implemented by the class. Let's see if it's in the class path and
           // use that instead.
@@ -313,15 +346,23 @@ private LeakTraceElement buildLeakElement(IObject parent, IObject child,
           } catch (ClassNotFoundException ignored) {
           }
         } else {
-          holder = OBJECT;
+          holderType = OBJECT;
           // Makes it easier to figure out which anonymous class we're looking at.
           extra = "(anonymous class extends " + parentClassName + ")";
         }
       } else {
-        holder = OBJECT;
+        holderType = OBJECT;
       }
     }
-    return new LeakTraceElement(referenceName, type, holder, className, extra);
+    return new LeakTraceElement(referenceName, type, holderType, className, extra, fields);
+  }
+
+  private String fieldToString(Field field) throws SnapshotException {
+    Object value = field.getValue();
+    if (value instanceof ObjectReference) {
+      value = ((ObjectReference) value).getObject();
+    }
+    return field.getName() + " = " + value;
   }
 
   private void cleanup(File heapDumpFile, ISnapshot snapshot) {
@@ -337,8 +378,12 @@ private void cleanup(File heapDumpFile, ISnapshot snapshot) {
             .equals(heapDumpFileName);
       }
     });
-    for (File file : toRemove) {
-      file.delete();
+    if (toRemove != null) {
+      for (File file : toRemove) {
+        file.delete();
+      }
+    } else {
+      Log.d(TAG, "Could not find HAHA files to cleanup.");
     }
   }
 
diff --git a/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
similarity index 85%
rename from library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
rename to leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
index 446ec62e..607db22c 100644
--- a/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
@@ -16,6 +16,7 @@
 package com.squareup.leakcanary;
 
 import java.io.Serializable;
+import java.util.ArrayList;
 import java.util.List;
 
 import static java.util.Collections.unmodifiableList;
@@ -29,7 +30,7 @@
   public final List<LeakTraceElement> elements;
 
   LeakTrace(List<LeakTraceElement> elements) {
-    this.elements = unmodifiableList(elements);
+    this.elements = unmodifiableList(new ArrayList<>(elements));
   }
 
   @Override public String toString() {
@@ -48,4 +49,12 @@
     }
     return sb.toString();
   }
+
+  public String toDetailedString() {
+    String string = "";
+    for (LeakTraceElement element : elements) {
+      string += element.toDetailedString();
+    }
+    return string;
+  }
 }
diff --git a/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
similarity index 74%
rename from library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
rename to leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
index 3c170421..7838fcac 100644
--- a/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
@@ -16,10 +16,14 @@
 package com.squareup.leakcanary;
 
 import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
 
 import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
+import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
 import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
 import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
+import static java.util.Collections.unmodifiableList;
 import static java.util.Locale.US;
 
 /** Represents one reference in the chain of references that holds a leaking object in memory. */
@@ -44,12 +48,17 @@
   /** Additional information, may be null. */
   public final String extra;
 
-  LeakTraceElement(String referenceName, Type type, Holder holder, String className, String extra) {
+  /** List of all fields (member and static) for that object. */
+  public final List<String> fields;
+
+  LeakTraceElement(String referenceName, Type type, Holder holder, String className, String extra,
+      List<String> fields) {
     this.referenceName = referenceName;
     this.type = type;
     this.holder = holder;
     this.className = className;
     this.extra = extra;
+    this.fields = unmodifiableList(new ArrayList<>(fields));
   }
 
   @Override public String toString() {
@@ -76,4 +85,20 @@
     }
     return string;
   }
+
+  public String toDetailedString() {
+    String string = "* ";
+    if (holder == ARRAY) {
+      string += "Array of";
+    } else if (holder == CLASS) {
+      string += "Class";
+    } else {
+      string += "Instance of";
+    }
+    string += " " + className + "\n";
+    for (String field : fields) {
+      string += "|   " + field + "\n";
+    }
+    return string;
+  }
 }
diff --git a/library/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
similarity index 89%
rename from library/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
rename to leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
index 494b8393..e1f88416 100644
--- a/library/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
@@ -28,7 +28,7 @@
 
 public class HeapAnalyzerTest {
 
-  static final ExcludedRefs NONE = new ExcludedRefs();
+  static final ExcludedRefs NONE = new ExcludedRefs.Builder().build();
 
   static final String ASYNC_TASK_THREAD = "AsyncTask #1";
   static final String ASYNC_TASK_CLASS = "android.os.AsyncTask";
@@ -45,9 +45,9 @@
   }
 
   @Test public void excludeThread() {
-    ExcludedRefs excludedRefs = new ExcludedRefs();
+    ExcludedRefs.Builder excludedRefs = new ExcludedRefs.Builder();
     excludedRefs.thread(ASYNC_TASK_THREAD);
-    AnalysisResult result = analyze(new HeapAnalyzer(excludedRefs));
+    AnalysisResult result = analyze(new HeapAnalyzer(excludedRefs.build()));
     assertTrue(result.leakFound);
     assertFalse(result.excludedLeak);
     LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
@@ -57,19 +57,19 @@
   }
 
   @Test public void excludeStatic() {
-    ExcludedRefs excludedRefs = new ExcludedRefs();
+    ExcludedRefs.Builder excludedRefs = new ExcludedRefs.Builder();
     excludedRefs.thread(ASYNC_TASK_THREAD);
     excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD);
-    AnalysisResult result = analyze(new HeapAnalyzer(excludedRefs));
+    AnalysisResult result = analyze(new HeapAnalyzer(excludedRefs.build()));
     assertTrue(result.leakFound);
     assertTrue(result.excludedLeak);
   }
 
   @Test public void excludeStaticForBase() {
-    ExcludedRefs excludedRefs = new ExcludedRefs();
+    ExcludedRefs.Builder excludedRefs = new ExcludedRefs.Builder();
     excludedRefs.thread(ASYNC_TASK_THREAD);
     excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD);
-    AnalysisResult result = analyze(new HeapAnalyzer(excludedRefs, excludedRefs));
+    AnalysisResult result = analyze(new HeapAnalyzer(excludedRefs.build(), excludedRefs.build()));
     assertFalse(result.leakFound);
   }
 
diff --git a/library/leakcanary-analyzer/src/test/resources/leak_asynctask.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask.hprof
similarity index 100%
rename from library/leakcanary-analyzer/src/test/resources/leak_asynctask.hprof
rename to leakcanary-analyzer/src/test/resources/leak_asynctask.hprof
diff --git a/library/leakcanary-android-no-op/build.gradle b/leakcanary-android-no-op/build.gradle
similarity index 84%
rename from library/leakcanary-android-no-op/build.gradle
rename to leakcanary-android-no-op/build.gradle
index b14f5807..5f3dc025 100644
--- a/library/leakcanary-android-no-op/build.gradle
+++ b/leakcanary-android-no-op/build.gradle
@@ -14,7 +14,6 @@ repositories {
 }
 
 dependencies {
-  compile project(':leakcanary-watcher')
 }
 
 android {
diff --git a/library/leakcanary-android-no-op/gradle.properties b/leakcanary-android-no-op/gradle.properties
similarity index 100%
rename from library/leakcanary-android-no-op/gradle.properties
rename to leakcanary-android-no-op/gradle.properties
diff --git a/library/leakcanary-android-no-op/src/main/AndroidManifest.xml b/leakcanary-android-no-op/src/main/AndroidManifest.xml
similarity index 100%
rename from library/leakcanary-android-no-op/src/main/AndroidManifest.xml
rename to leakcanary-android-no-op/src/main/AndroidManifest.xml
diff --git a/library/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
similarity index 100%
rename from library/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
rename to leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
diff --git a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/RefWatcher.java
new file mode 100644
index 00000000..ca9f6602
--- /dev/null
+++ b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/RefWatcher.java
@@ -0,0 +1,19 @@
+package com.squareup.leakcanary;
+
+/**
+ * No-op implementation of {@link RefWatcher} for release builds. Please use {@link
+ * RefWatcher#DISABLED}.
+ */
+public final class RefWatcher {
+
+  public static final RefWatcher DISABLED = new RefWatcher();
+
+  private RefWatcher() {
+  }
+
+  public void watch(Object watchedReference) {
+  }
+
+  public void watch(Object watchedReference, String referenceName) {
+  }
+}
diff --git a/library/leakcanary-android/build.gradle b/leakcanary-android/build.gradle
similarity index 64%
rename from library/leakcanary-android/build.gradle
rename to leakcanary-android/build.gradle
index bff0b97d..394da675 100644
--- a/library/leakcanary-android/build.gradle
+++ b/leakcanary-android/build.gradle
@@ -17,12 +17,19 @@ dependencies {
   compile project(':leakcanary-analyzer')
 }
 
+def gitSha() {
+  return 'git rev-parse --short HEAD'.execute().text.trim()
+}
+
 android {
   compileSdkVersion rootProject.ext.compileSdkVersion
   buildToolsVersion rootProject.ext.buildToolsVersion
   defaultConfig {
     minSdkVersion rootProject.ext.minSdkVersion
     targetSdkVersion rootProject.ext.targetSdkVersion
+    buildConfigField "String", "LIBRARY_VERSION", "\"${rootProject.ext.VERSION_NAME}\""
+    buildConfigField "String", "GIT_SHA", "\"${gitSha()}\""
+    consumerProguardFiles 'consumer-proguard-rules.pro'
   }
 }
 
diff --git a/leakcanary-android/consumer-proguard-rules.pro b/leakcanary-android/consumer-proguard-rules.pro
new file mode 100644
index 00000000..0a28de9b
--- /dev/null
+++ b/leakcanary-android/consumer-proguard-rules.pro
@@ -0,0 +1,2 @@
+-keep class org.eclipse.mat.** { *; }
+-keep class com.squareup.leakcanary.** { *; }
diff --git a/library/leakcanary-android/gradle.properties b/leakcanary-android/gradle.properties
similarity index 100%
rename from library/leakcanary-android/gradle.properties
rename to leakcanary-android/gradle.properties
diff --git a/library/leakcanary-android/src/main/AndroidManifest.xml b/leakcanary-android/src/main/AndroidManifest.xml
similarity index 91%
rename from library/leakcanary-android/src/main/AndroidManifest.xml
rename to leakcanary-android/src/main/AndroidManifest.xml
index f0cdef25..05d4ad81 100644
--- a/library/leakcanary-android/src/main/AndroidManifest.xml
+++ b/leakcanary-android/src/main/AndroidManifest.xml
@@ -19,6 +19,9 @@
     package="com.squareup.leakcanary"
     >
 
+  <!-- To store the heap dumps and leak analysis results. -->
+  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+
   <application>
     <service
         android:name=".internal.HeapAnalyzerService"
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
similarity index 100%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
similarity index 100%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java
similarity index 100%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
new file mode 100644
index 00000000..0a1a7368
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
@@ -0,0 +1,410 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import java.util.EnumSet;
+
+import static android.os.Build.MANUFACTURER;
+import static android.os.Build.VERSION.SDK_INT;
+import static android.os.Build.VERSION_CODES.ECLAIR;
+import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH;
+import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1;
+import static android.os.Build.VERSION_CODES.JELLY_BEAN;
+import static android.os.Build.VERSION_CODES.KITKAT;
+import static android.os.Build.VERSION_CODES.LOLLIPOP;
+import static com.squareup.leakcanary.AndroidWatchExecutor.LEAK_CANARY_THREAD_NAME;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.LG;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.LOLLIPOP_MR1;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.MOTOROLA;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.NVIDIA;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.SAMSUNG;
+
+/**
+ * This class is a work in progress. You can help by reporting leak traces that seem to be caused
+ * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
+ *
+ * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
+ * manufacturer implementation, they usually share their builds across multiple models, and the
+ * leaks eventually get fixed in newer versions.
+ *
+ * Most app developers should use {@link #createAppDefaults()}. However, you can also pick the
+ * leaks you want to ignore by creating an {@link EnumSet} that matches your needs and calling
+ * {@link #createBuilder(EnumSet)}
+ */
+public enum AndroidExcludedRefs {
+
+  ACTIVITY_CLIENT_RECORD__NEXT_IDLE(SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // Android AOSP sometimes keeps a reference to a destroyed activity as a "nextIdle" client
+      // record in the android.app.ActivityThread.mActivities map.
+      // Not sure what's going on there, input welcome.
+      excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle");
+    }
+  },
+
+  SPAN_CONTROLLER(SDK_INT <= KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // Editor inserts a special span, which has a reference to the EditText. That span is a
+      // NoCopySpan, which makes sure it gets dropped when creating a new SpannableStringBuilder
+      // from a given CharSequence.
+      // TextView.onSaveInstanceState() does a copy of its mText before saving it in the bundle.
+      // Prior to KitKat, that copy was done using the SpannableString constructor, instead of
+      // SpannableStringBuilder. The SpannableString constructor does not drop NoCopySpan spans.
+      // So we end up with a saved state that holds a reference to the textview and therefore the
+      // entire view hierarchy & activity context.
+      // Fix: https://github.com/android/platform_frameworks_base/commit
+      // /af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b
+
+      // Hack: to fix this, you could override TextView.onSaveInstanceState(), and then use
+      // reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.
+      excluded.instanceField("android.widget.Editor$EasyEditSpanController", "this$0");
+      excluded.instanceField("android.widget.Editor$SpanController", "this$0");
+    }
+  },
+
+  MEDIA_SESSION_LEGACY_HELPER__SINSTANCE(SDK_INT == LOLLIPOP) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // MediaSessionLegacyHelper is a static singleton that is lazily instantiated and keeps a
+      // reference to the context it's given the first time MediaSessionLegacyHelper.getHelper()
+      // is called.
+      // This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by calling
+      // context.getApplicationContext().
+      // Fix: https://github.com/android/platform_frameworks_base/commit
+      // /9b5257c9c99c4cb541d8e8e78fb04f008b1a9091
+
+      // Hack: to fix this, you could call MediaSessionLegacyHelper.getHelper() early in
+      // Application.onCreate() and pass it the application context.
+      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance");
+    }
+  },
+
+  TEXT_LINE__SCACHED(SDK_INT < LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had at least two
+      // bugs that created memory leaks by not correctly clearing the recycled TextLine instances.
+      // The first was fixed in android-5.1.0_r1:
+      // https://github.com/android/platform_frameworks_base/commit
+      // /893d6fe48d37f71e683f722457bea646994a10bf
+
+      // The second was fixed, not released yet:
+      // https://github.com/android/platform_frameworks_base/commit
+      // /b3a9bc038d3a218b1dbdf7b5668e3d6c12be5ee4
+
+      // Hack: to fix this, you could access TextLine.sCached and clear the pool every now and then
+      // (e.g. on activity destroy).
+      excluded.staticField("android.text.TextLine", "sCached");
+    }
+  },
+
+  BLOCKING_QUEUE(SDK_INT < LOLLIPOP) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // Prior to ART, a thread waiting on a blocking queue will leak the last dequeued object
+      // as a stack local reference.
+      // So when a HandlerThread becomes idle, it keeps a local reference to the last message it
+      // received. That message then gets recycled and can be used again.
+      // As long as all messages are recycled after being used, this won't be a problem, because
+      // there references are cleared when being recycled.
+      // However, dialogs create template Message instances to be copied when a message needs to be
+      // sent. These Message templates holds references to the dialog listeners, which most likely
+      // leads to holding a reference onto the activity in some way. Dialogs never recycle their
+      // template Message, assuming these Message instances will get GCed when the dialog is GCed.
+      // The combination of these two things creates a high potential for memory leaks as soon
+      // as you use dialogs. These memory leaks might be temporary, but some handler threads sleep
+      // for a long time.
+
+      // Hack: to fix this, you could post empty messages to the idle handler threads from time to
+      // time. This won't be easy because you cannot access all handler threads, but a library
+      // that is widely used should consider doing this for its own handler threads.
+      excluded.instanceField("android.os.Message", "obj");
+      excluded.instanceField("android.os.Message", "next");
+      excluded.instanceField("android.os.Message", "target");
+    }
+  },
+
+  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // When we detach a view that receives keyboard input, the InputMethodManager leaks a
+      // reference to it until a new view asks for keyboard input.
+      // Tracked here: https://code.google.com/p/android/issues/detail?id=171190
+      // Hack: https://gist.github.com/pyricau/4df64341cc978a7de414
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView");
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView");
+      excluded.instanceField("android.view.inputmethod.InputMethodManager",
+          "mServedInputConnection");
+    }
+  },
+
+  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // The singleton InputMethodManager is holding a reference to mCurRootView long after the
+      // activity has been destroyed.
+      // Observed on ICS MR1: https://github.com/square/leakcanary/issues/1#issuecomment-100579429
+      // Hack: https://gist.github.com/pyricau/4df64341cc978a7de414
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView");
+    }
+  },
+
+  LAYOUT_TRANSITION(SDK_INT >= ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // LayoutTransition leaks parent ViewGroup through ViewTreeObserver.OnPreDrawListener
+      // When triggered, this leaks stays until the window is destroyed.
+      // Tracked here: https://code.google.com/p/android/issues/detail?id=171830
+      excluded.instanceField("android.animation.LayoutTransition$1", "val$parent");
+    }
+  },
+
+  SPELL_CHECKER_SESSION(SDK_INT >= JELLY_BEAN || SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the
+      // SpellCheckerSession is closed before the service is connected.
+      // Tracked here: https://code.google.com/p/android/issues/detail?id=172542
+      excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0");
+    }
+  },
+
+  ACTIVITY_CHOOSE_MODEL(SDK_INT > ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // ActivityChooserModel holds a static reference to the last set ActivityChooserModelPolicy
+      // which can be an activity context.
+      // Tracked here : https://code.google.com/p/android/issues/detail?id=172659
+      // Hack : https://gist.github.com/andaag/b05ab66ed0f06167d6e0
+      excluded.staticField("android.support.v7.internal.widget.ActivityChooserModel",
+          "mActivityChoserModelPolicy");
+      excluded.staticField("android.widget.ActivityChooserModel", "mActivityChoserModelPolicy");
+    }
+  },
+
+  SPEECH_RECOGNIZER(SDK_INT < LOLLIPOP) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner class and
+      // leaked the SpeechRecognizer which leaked an activity context.
+      // Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit
+      // /b37866db469e81aca534ff6186bdafd44352329b
+      excluded.instanceField("android.speech.SpeechRecognizer$InternalListener", "this$0");
+    }
+  },
+
+  ACCOUNT_MANAGER(SDK_INT > ECLAIR && SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // AccountManager$AmsTask$Response is a stub and is held in memory by native code, probably
+      // because the reference to the response in the other process hasn't been cleared.
+      // AccountManager$AmsTask is holding on to the activity reference to use for launching a new
+      // sub- Activity.
+      // Tracked here: https://code.google.com/p/android/issues/detail?id=173689
+      // Fix: Pass a null activity reference to the AccountManager methods and then deal with the
+      // returned future to to get the result and correctly start an activity when it's available.
+      excluded.instanceField("android.accounts.AccountManager$AmsTask$Response", "this$1");
+    }
+  },
+
+  MEDIA_SCANNER_CONNECTION(SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // The static method MediaScannerConnection.scanFile() takes an activity context but the
+      // service might not disconnect after the activity has been destroyed.
+      // Tracked here: https://code.google.com/p/android/issues/detail?id=173788
+      // Fix: Create an instance of MediaScannerConnection yourself and pass in the application
+      // context. Call connect() and disconnect() manually.
+      excluded.instanceField("android.media.MediaScannerConnection", "mContext");
+    }
+  },
+
+  USER_MANAGER__SINSTANCE(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // UserManager has a static sInstance field that creates an instance and caches it the first
+      // time UserManager.get() is called. This instance is created with the outer context (which
+      // is an activity base context).
+      // Tracked here: https://code.google.com/p/android/issues/detail?id=173789
+      // Introduced by: https://github.com/android/platform_frameworks_base/commit
+      // /27db46850b708070452c0ce49daf5f79503fbde6
+      // Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the
+      // UserManager instance gets cached with a reference to the application context.
+      excluded.instanceField("android.os.UserManager", "mContext");
+    }
+  },
+
+  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER(MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      if (MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+        // DevicePolicyManager keeps a reference to the context it has been created with instead of
+        // extracting the application context. In this Motorola build, DevicePolicyManager has an
+        // inner SettingsObserver class that is a content observer, which is held into memory
+        // by a binder transport object.
+        excluded.instanceField("android.app.admin.DevicePolicyManager$SettingsObserver", "this$0");
+      }
+    }
+  },
+
+  SPEN_GESTURE_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // SpenGestureManager has a static mContext field that leaks a reference to the activity.
+      // Yes, a STATIC "mContext" field.
+      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext");
+    }
+  },
+
+  CLIPBOARD_UI_MANAGER__SINSTANCE(
+      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // ClipboardUIManager is a static singleton that leaks an activity context.
+      excluded.staticField("android.sec.clipboard.ClipboardUIManager", "sInstance");
+    }
+  },
+
+  BUBBLE_POPUP_HELPER__SHELPER(
+      LG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // A static helper for EditText "bubble popups" leaks a reference to the latest focused view.
+      excluded.staticField("android.widget.BubblePopupHelper", "sHelper");
+    }
+  },
+
+  AW_RESOURCE__SRESOURCES(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // AwResource#setResources() is called with resources that hold a reference to the
+      // activity context (instead of the application context) and doesn't clear it.
+      // Not sure what's going on there, input welcome.
+      excluded.staticField("com.android.org.chromium.android_webview.AwResource", "sResources");
+    }
+  },
+
+  MAPPER_CLIENT(NVIDIA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // Not sure exactly what ControllerMapper is about, but there is an anonymous Handler in
+      // ControllerMapper.MapperClient.ServiceClient, which leaks ControllerMapper.MapperClient
+      // which leaks the activity context.
+      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient$ServiceClient", "this$0");
+    }
+  },
+
+  TEXT_VIEW__MLAST_HOVERED_VIEW(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // mLastHoveredView is a static field in TextView that leaks the last hovered view.
+      excluded.staticField("android.widget.TextView", "mLastHoveredView");
+    }
+  },
+
+  PERSONA_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // android.app.LoadedApk.mResources has a reference to
+      // android.content.res.Resources.mPersonaManager which has a reference to
+      // android.os.PersonaManager.mContext which is an activity.
+      excluded.instanceField("android.os.PersonaManager", "mContext");
+    }
+  },
+
+  RESOURCES__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // In AOSP the Resources class does not have a context.
+      // Here we have ZygoteInit.mResources (static field) holding on to a Resources instance that
+      // has a context that is the activity.
+      // Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184
+      excluded.instanceField("android.content.res.Resources", "mContext");
+    }
+  },
+
+  VIEW_CONFIGURATION__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // In AOSP the ViewConfiguration class does not have a context.
+      // Here we have ViewConfiguration.sConfigurations (static field) holding on to a
+      // ViewConfiguration instance that has a context that is the activity.
+      // Observed here: https://github.com/square/leakcanary/issues/1#issuecomment-100324683
+      excluded.instanceField("android.view.ViewConfiguration", "mContext");
+    }
+  },
+
+  AUDIO_MANAGER__MCONTEXT_STATIC(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // Samsung added a static mContext_static field to AudioManager, holds a reference to the
+      // activity.
+      // Observed here: https://github.com/square/leakcanary/issues/32
+      excluded.staticField("android.media.AudioManager", "mContext_static");
+    }
+  },
+
+  FINALIZER_WATCHDOG_DAEMON {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
+      // reference to the object and it was about to be GCed.
+      excluded.thread("FinalizerWatchdogDaemon");
+    }
+  },
+
+  MAIN {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // The main thread stack is ever changing so local variables aren't likely to hold references
+      // for long. If this is on the shortest path, it's probably that there's a longer path with
+      // a real leak.
+      excluded.thread("main");
+    }
+  },
+
+  LEAK_CANARY_THREAD {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.thread(LEAK_CANARY_THREAD_NAME);
+    }
+  },
+
+  EVENT_RECEIVER__MMESSAGE_QUEUE {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
+      // the native peer of the receiver is using them.
+      // The main thread message queue is held on by the main Looper, but that might be a longer
+      // path. Let's not confuse people with a shorter path that is less meaningful.
+      excluded.instanceField("android.view.Choreographer$FrameDisplayEventReceiver",
+          "mMessageQueue");
+    }
+  };
+
+  /**
+   * This returns the references in the leak path that should be ignored by all on Android.
+   */
+  public static ExcludedRefs.Builder createAndroidDefaults() {
+    return createBuilder(EnumSet.of(FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
+        EVENT_RECEIVER__MMESSAGE_QUEUE));
+  }
+
+  /**
+   * This returns the references in the leak path that can be ignored for app developers. This
+   * doesn't mean there is no memory leak, to the contrary. However, some leaks are caused by bugs
+   * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
+   * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
+   */
+  public static ExcludedRefs.Builder createAppDefaults() {
+    return createBuilder(EnumSet.allOf(AndroidExcludedRefs.class));
+  }
+
+  public static ExcludedRefs.Builder createBuilder(EnumSet<AndroidExcludedRefs> refs) {
+    ExcludedRefs.Builder excluded = new ExcludedRefs.Builder();
+    for (AndroidExcludedRefs ref : refs) {
+      if (ref.applies) {
+        ref.add(excluded);
+      }
+    }
+    return excluded;
+  }
+
+  final boolean applies;
+
+  AndroidExcludedRefs() {
+    this(true);
+  }
+
+  AndroidExcludedRefs(boolean applies) {
+    this.applies = applies;
+  }
+
+  abstract void add(ExcludedRefs.Builder excluded);
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
new file mode 100644
index 00000000..53b0ef5c
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import android.content.Context;
+import android.os.Debug;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.MessageQueue;
+import android.util.Log;
+import android.view.Gravity;
+import android.view.LayoutInflater;
+import android.widget.Toast;
+import com.squareup.leakcanary.internal.FutureResult;
+import com.squareup.leakcanary.internal.LeakCanaryInternals;
+import java.io.File;
+import java.io.IOException;
+
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.isExternalStorageWritable;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.storageDirectory;
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+public final class AndroidHeapDumper implements HeapDumper {
+
+  private static final String TAG = "AndroidHeapDumper";
+
+  private final Context context;
+  private final Handler mainHandler;
+
+  public AndroidHeapDumper(Context context) {
+    this.context = context.getApplicationContext();
+    mainHandler = new Handler(Looper.getMainLooper());
+  }
+
+  @Override public File dumpHeap() {
+    if (!isExternalStorageWritable()) {
+      Log.d(TAG, "Could not dump heap, external storage not mounted.");
+    }
+    File heapDumpFile = getHeapDumpFile();
+    if (heapDumpFile.exists()) {
+      Log.d(TAG, "Could not dump heap, previous analysis still is in progress.");
+      // Heap analysis in progress, let's not put too much pressure on the device.
+      return NO_DUMP;
+    }
+
+    FutureResult<Toast> waitingForToast = new FutureResult<>();
+    showToast(waitingForToast);
+
+    if (!waitingForToast.wait(5, SECONDS)) {
+      Log.d(TAG, "Did not dump heap, too much time waiting for Toast.");
+      return NO_DUMP;
+    }
+
+    Toast toast = waitingForToast.get();
+    try {
+      Debug.dumpHprofData(heapDumpFile.getAbsolutePath());
+      cancelToast(toast);
+      return heapDumpFile;
+    } catch (IOException e) {
+      cleanup();
+      Log.e(TAG, "Could not perform heap dump", e);
+      // Abort heap dump
+      return NO_DUMP;
+    }
+  }
+
+  /**
+   * Call this on app startup to clean up all heap dump files that had not been handled yet when
+   * the app process was killed.
+   */
+  public void cleanup() {
+    LeakCanaryInternals.executeOnFileIoThread(new Runnable() {
+      @Override public void run() {
+        if (isExternalStorageWritable()) {
+          Log.d(TAG, "Could not attempt cleanup, external storage not mounted.");
+        }
+        File heapDumpFile = getHeapDumpFile();
+        if (heapDumpFile.exists()) {
+          Log.d(TAG, "Previous analysis did not complete correctly, cleaning: " + heapDumpFile);
+          heapDumpFile.delete();
+        }
+      }
+    });
+  }
+
+  private File getHeapDumpFile() {
+    return new File(storageDirectory(), "suspected_leak_heapdump.hprof");
+  }
+
+  private void showToast(final FutureResult<Toast> waitingForToast) {
+    mainHandler.post(new Runnable() {
+      @Override public void run() {
+        final Toast toast = new Toast(context);
+        toast.setGravity(Gravity.CENTER_VERTICAL, 0, 0);
+        toast.setDuration(Toast.LENGTH_LONG);
+        LayoutInflater inflater = LayoutInflater.from(context);
+        toast.setView(inflater.inflate(R.layout.__leak_canary_heap_dump_toast, null));
+        toast.show();
+        // Waiting for Idle to make sure Toast gets rendered.
+        Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
+          @Override public boolean queueIdle() {
+            waitingForToast.set(toast);
+            return false;
+          }
+        });
+      }
+    });
+  }
+
+  private void cancelToast(final Toast toast) {
+    mainHandler.post(new Runnable() {
+      @Override public void run() {
+        toast.cancel();
+      }
+    });
+  }
+}
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
similarity index 100%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
similarity index 81%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
index d6ff6117..ce02d8fa 100644
--- a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
@@ -30,8 +30,10 @@
 import static android.os.Build.VERSION.SDK_INT;
 import static android.os.Build.VERSION_CODES.HONEYCOMB;
 import static android.os.Build.VERSION_CODES.JELLY_BEAN;
-import static com.squareup.leakcanary.LeakCanary.classSimpleName;
 import static com.squareup.leakcanary.LeakCanary.leakInfo;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.classSimpleName;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.findNextAvailableHprofFile;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.leakResultFile;
 
 /**
  * Logs leak analysis results, and then shows a notification which will start {@link
@@ -42,33 +44,25 @@
  */
 public class DisplayLeakService extends AbstractAnalysisResultService {
 
-  private static File findNextAvailableHprofFile(File directory, int maxFiles) {
-    if (!directory.exists()) {
-      directory.mkdir();
-    }
-    for (int i = 0; i < maxFiles; i++) {
-      String heapDumpName = "heap_dump_" + i + ".hprof";
-      File file = new File(directory, heapDumpName);
-      if (!file.exists()) {
-        return file;
-      }
-    }
-    return null;
-  }
-
   @TargetApi(HONEYCOMB) @Override
   protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
-    String leakInfo = leakInfo(this, heapDump, result);
-    Log.d("LeakCanary", leakInfo);
+    String leakInfo = leakInfo(this, heapDump, result, true);
+    if (leakInfo.length() < 4000) {
+      Log.d("LeakCanary", leakInfo);
+    } else {
+      String[] lines = leakInfo.split("\n");
+      for (String line : lines) {
+        Log.d("LeakCanary", line);
+      }
+    }
 
-    if (!result.leakFound || result.excludedLeak) {
+    if (result.failure == null && (!result.leakFound || result.excludedLeak)) {
       afterDefaultHandling(heapDump, result, leakInfo);
       return;
     }
 
-    File leakDirectory = DisplayLeakActivity.leakDirectory(this);
     int maxStoredLeaks = getResources().getInteger(R.integer.__leak_canary_max_stored_leaks);
-    File renamedFile = findNextAvailableHprofFile(leakDirectory, maxStoredLeaks);
+    File renamedFile = findNextAvailableHprofFile(maxStoredLeaks);
 
     if (renamedFile == null) {
       // No file available.
@@ -80,7 +74,7 @@ protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
 
     heapDump = heapDump.renameFile(renamedFile);
 
-    File resultFile = DisplayLeakActivity.leakResultFile(renamedFile);
+    File resultFile = leakResultFile(renamedFile);
     FileOutputStream fos = null;
     try {
       fos = new FileOutputStream(resultFile);
@@ -103,8 +97,13 @@ protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
     PendingIntent pendingIntent =
         DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);
 
-    String contentTitle =
-        getString(R.string.__leak_canary_class_has_leaked, classSimpleName(result.className));
+    String contentTitle;
+    if (result.failure == null) {
+      contentTitle =
+          getString(R.string.__leak_canary_class_has_leaked, classSimpleName(result.className));
+    } else {
+      contentTitle = getString(R.string.__leak_canary_analysis_failed);
+    }
     String contentText = getString(R.string.__leak_canary_notification_message);
 
     NotificationManager notificationManager =
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
similarity index 58%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
index e8affabb..6c71381d 100644
--- a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -15,23 +15,17 @@
  */
 package com.squareup.leakcanary;
 
-import android.app.ActivityManager;
 import android.app.Application;
-import android.app.Service;
-import android.content.ComponentName;
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
-import android.content.pm.ServiceInfo;
 import android.os.Build;
 import android.util.Log;
 import com.squareup.leakcanary.internal.DisplayLeakActivity;
 import com.squareup.leakcanary.internal.HeapAnalyzerService;
 
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
-import static android.content.pm.PackageManager.DONT_KILL_APP;
-import static android.content.pm.PackageManager.GET_SERVICES;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.isInServiceProcess;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabled;
 
 public final class LeakCanary {
 
@@ -40,7 +34,8 @@
    * references (on ICS+).
    */
   public static RefWatcher install(Application application) {
-    return install(application, DisplayLeakService.class);
+    return install(application, DisplayLeakService.class,
+        AndroidExcludedRefs.createAppDefaults().build());
   }
 
   /**
@@ -48,14 +43,15 @@ public static RefWatcher install(Application application) {
    * activity references (on ICS+).
    */
   public static RefWatcher install(Application application,
-      Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
+      Class<? extends AbstractAnalysisResultService> listenerServiceClass,
+      ExcludedRefs excludedRefs) {
     if (isInAnalyzerProcess(application)) {
       return RefWatcher.DISABLED;
     }
     enableDisplayLeakActivity(application);
     HeapDump.Listener heapDumpListener =
         new ServiceHeapDumpListener(application, listenerServiceClass);
-    RefWatcher refWatcher = androidWatcher(application, heapDumpListener);
+    RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);
     ActivityRefWatcher.installOnIcsPlus(application, refWatcher);
     return refWatcher;
   }
@@ -63,12 +59,13 @@ public static RefWatcher install(Application application,
   /**
    * Creates a {@link RefWatcher} with a default configuration suitable for Android.
    */
-  public static RefWatcher androidWatcher(Application app, HeapDump.Listener heapDumpListener) {
+  public static RefWatcher androidWatcher(Context context, HeapDump.Listener heapDumpListener,
+      ExcludedRefs excludedRefs) {
     DebuggerControl debuggerControl = new AndroidDebuggerControl();
-    AndroidHeapDumper heapDumper = new AndroidHeapDumper(app);
+    AndroidHeapDumper heapDumper = new AndroidHeapDumper(context);
     heapDumper.cleanup();
     return new RefWatcher(new AndroidWatchExecutor(), debuggerControl, GcTrigger.DEFAULT,
-        heapDumper, heapDumpListener);
+        heapDumper, heapDumpListener, excludedRefs);
   }
 
   public static void enableDisplayLeakActivity(Context context) {
@@ -76,7 +73,8 @@ public static void enableDisplayLeakActivity(Context context) {
   }
 
   /** Returns a string representation of the result of a heap analysis. */
-  public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult result) {
+  public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult result,
+      boolean detailed) {
     PackageManager packageManager = context.getPackageManager();
     String packageName = context.getPackageName();
     PackageInfo packageInfo;
@@ -88,6 +86,7 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
     String versionName = packageInfo.versionName;
     int versionCode = packageInfo.versionCode;
     String info = "In " + packageName + ":" + versionName + ":" + versionCode + ".\n";
+    String detailedString = "";
     if (result.leakFound) {
       if (result.excludedLeak) {
         info += "* LEAK CAN BE IGNORED.\n";
@@ -97,11 +96,18 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
         info += " (" + heapDump.referenceName + ")";
       }
       info += " has leaked:\n" + result.leakTrace.toString() + "\n";
+      if (detailed) {
+        detailedString = "\n* Details:\n" + result.leakTrace.toDetailedString();
+      }
     } else if (result.failure != null) {
       info += "* FAILURE:\n" + Log.getStackTraceString(result.failure) + "\n";
     } else {
       info += "* NO LEAK FOUND.\n\n";
     }
+    if (detailed) {
+      detailedString += "* Excluded Refs:\n" + heapDump.excludedRefs;
+    }
+
     info += "* Reference Key: "
         + heapDump.referenceKey
         + "\n"
@@ -118,6 +124,10 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
         + Build.VERSION.RELEASE
         + " API: "
         + Build.VERSION.SDK_INT
+        + " LeakCanary: "
+        + BuildConfig.LIBRARY_VERSION
+        + " "
+        + BuildConfig.GIT_SHA
         + "\n"
         + "* Durations: watch="
         + heapDump.watchDurationMs
@@ -128,7 +138,8 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
         + "ms, analysis="
         + result.analysisDurationMs
         + "ms"
-        + "\n";
+        + "\n"
+        + detailedString;
 
     return info;
   }
@@ -141,70 +152,6 @@ public static boolean isInAnalyzerProcess(Context context) {
     return isInServiceProcess(context, HeapAnalyzerService.class);
   }
 
-  private static boolean isInServiceProcess(Context context,
-      Class<? extends Service> serviceClass) {
-    PackageManager packageManager = context.getPackageManager();
-    PackageInfo packageInfo;
-    try {
-      packageInfo = packageManager.getPackageInfo(context.getPackageName(), GET_SERVICES);
-    } catch (Exception e) {
-      Log.e("AndroidUtils", "Could not get package info for " + context.getPackageName(), e);
-      return false;
-    }
-    String mainProcess = packageInfo.applicationInfo.processName;
-
-    ComponentName component = new ComponentName(context, serviceClass);
-    ServiceInfo serviceInfo;
-    try {
-      serviceInfo = packageManager.getServiceInfo(component, 0);
-    } catch (PackageManager.NameNotFoundException ignored) {
-      // Service is disabled.
-      return false;
-    }
-
-    if (serviceInfo.processName.equals(mainProcess)) {
-      Log.e("AndroidUtils",
-          "Did not expect service " + serviceClass + " to run in main process " + mainProcess);
-      // Technically we are in the service process, but we're not in the service dedicated process.
-      return false;
-    }
-
-    int myPid = android.os.Process.myPid();
-    ActivityManager activityManager =
-        (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
-    ActivityManager.RunningAppProcessInfo myProcess = null;
-    for (ActivityManager.RunningAppProcessInfo process : activityManager.getRunningAppProcesses()) {
-      if (process.pid == myPid) {
-        myProcess = process;
-        break;
-      }
-    }
-    if (myProcess == null) {
-      Log.e("AndroidUtils", "Could not find running process for " + myPid);
-      return false;
-    }
-
-    return myProcess.processName.equals(serviceInfo.processName);
-  }
-
-  static void setEnabled(Context context, Class<?> componentClass, boolean enabled) {
-    ComponentName component = new ComponentName(context, componentClass);
-    PackageManager packageManager = context.getPackageManager();
-    int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED;
-    // Blocks on IPC.
-    packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);
-  }
-
-  /** Extracts the class simple name out of a string containing a fully qualified class name. */
-  static String classSimpleName(String className) {
-    int separator = className.lastIndexOf('.');
-    if (separator == -1) {
-      return className;
-    } else {
-      return className.substring(separator + 1);
-    }
-  }
-
   private LeakCanary() {
     throw new AssertionError();
   }
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
similarity index 88%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
index b297f152..2ccb1422 100644
--- a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
@@ -19,6 +19,7 @@
 import com.squareup.leakcanary.internal.HeapAnalyzerService;
 
 import static com.squareup.leakcanary.Preconditions.checkNotNull;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabled;
 
 public final class ServiceHeapDumpListener implements HeapDump.Listener {
 
@@ -27,8 +28,8 @@
 
   public ServiceHeapDumpListener(Context context,
       Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
-    LeakCanary.setEnabled(context, listenerServiceClass, true);
-    LeakCanary.setEnabled(context, HeapAnalyzerService.class, true);
+    setEnabled(context, listenerServiceClass, true);
+    setEnabled(context, HeapAnalyzerService.class, true);
     this.listenerServiceClass = checkNotNull(listenerServiceClass, "listenerServiceClass");
     this.context = checkNotNull(context, "context").getApplicationContext();
   }
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
similarity index 78%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
index 8268dff0..4e58471d 100644
--- a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
@@ -56,7 +56,11 @@
 import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
 import static android.text.format.DateUtils.FORMAT_SHOW_DATE;
 import static android.text.format.DateUtils.FORMAT_SHOW_TIME;
+import static android.view.View.GONE;
+import static android.view.View.VISIBLE;
 import static com.squareup.leakcanary.LeakCanary.leakInfo;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.detectedLeakDirectory;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.leakResultFile;
 
 @SuppressWarnings("ConstantConditions") @TargetApi(Build.VERSION_CODES.HONEYCOMB)
 public final class DisplayLeakActivity extends Activity {
@@ -64,14 +68,6 @@
   private static final String TAG = "DisplayLeakActivity";
   private static final String SHOW_LEAK_EXTRA = "show_latest";
 
-  public static File leakDirectory(Context context) {
-    return new File(context.getFilesDir(), "detected_leaks");
-  }
-
-  public static File leakResultFile(File heapdumpFile) {
-    return new File(heapdumpFile.getParentFile(), heapdumpFile.getName() + ".result");
-  }
-
   public static PendingIntent createPendingIntent(Context context, String referenceKey) {
     Intent intent = new Intent(context, DisplayLeakActivity.class);
     intent.putExtra(SHOW_LEAK_EXTRA, referenceKey);
@@ -84,6 +80,7 @@ public static PendingIntent createPendingIntent(Context context, String referenc
   private String visibleLeakRefKey;
 
   private ListView listView;
+  private TextView failureView;
   private Button actionButton;
   private int maxStoredLeaks;
 
@@ -105,6 +102,7 @@ public static PendingIntent createPendingIntent(Context context, String referenc
     setContentView(R.layout.__leak_canary_display_leak);
 
     listView = (ListView) findViewById(R.id.__leak_canary_display_leak_list);
+    failureView = (TextView) findViewById(R.id.__leak_canary_display_leak_failure);
     actionButton = (Button) findViewById(R.id.__leak_canary_action);
 
     maxStoredLeaks = getResources().getInteger(R.integer.__leak_canary_max_stored_leaks);
@@ -172,7 +170,7 @@ public static PendingIntent createPendingIntent(Context context, String referenc
 
   private void shareLeak() {
     Leak visibleLeak = getVisibleLeak();
-    String leakInfo = leakInfo(this, visibleLeak.heapDump, visibleLeak.result);
+    String leakInfo = leakInfo(this, visibleLeak.heapDump, visibleLeak.result, true);
     Intent intent = new Intent(Intent.ACTION_SEND);
     intent.setType("text/plain");
     intent.putExtra(Intent.EXTRA_TEXT, leakInfo);
@@ -204,40 +202,58 @@ private void updateUi() {
     }
 
     ListAdapter listAdapter = listView.getAdapter();
+    // Reset to defaults
+    listView.setVisibility(VISIBLE);
+    failureView.setVisibility(GONE);
+
     if (visibleLeak != null) {
-      final DisplayLeakAdapter adapter;
-      if (listAdapter instanceof DisplayLeakAdapter) {
-        adapter = (DisplayLeakAdapter) listAdapter;
-      } else {
-        adapter = new DisplayLeakAdapter();
-        listView.setAdapter(adapter);
-        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-          @Override
-          public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-            adapter.toggleRow(position);
-          }
-        });
+      AnalysisResult result = visibleLeak.result;
+      if (result.failure != null) {
+        listView.setVisibility(GONE);
+        failureView.setVisibility(VISIBLE);
+        failureView.setText(
+            getString(R.string.__leak_canary_failure_report) + Log.getStackTraceString(
+                result.failure));
+        setTitle(R.string.__leak_canary_analysis_failed);
         invalidateOptionsMenu();
         getActionBar().setDisplayHomeAsUpEnabled(true);
-        actionButton.setVisibility(View.VISIBLE);
-        actionButton.setText("Remove leak");
-        actionButton.setOnClickListener(new View.OnClickListener() {
-          @Override public void onClick(View v) {
-            Leak visibleLeak = getVisibleLeak();
-            File resultFile = leakResultFile(visibleLeak.heapDump.heapDumpFile);
-            resultFile.delete();
-            visibleLeak.heapDump.heapDumpFile.delete();
-            visibleLeakRefKey = null;
-            leaks.remove(visibleLeak);
-            updateUi();
-          }
-        });
+        actionButton.setVisibility(VISIBLE);
+        actionButton.setText(R.string.__leak_canary_delete);
+        listView.setAdapter(null);
+      } else {
+        final DisplayLeakAdapter adapter;
+        if (listAdapter instanceof DisplayLeakAdapter) {
+          adapter = (DisplayLeakAdapter) listAdapter;
+        } else {
+          adapter = new DisplayLeakAdapter();
+          listView.setAdapter(adapter);
+          listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+            @Override
+            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
+              adapter.toggleRow(position);
+            }
+          });
+          invalidateOptionsMenu();
+          getActionBar().setDisplayHomeAsUpEnabled(true);
+          actionButton.setVisibility(VISIBLE);
+          actionButton.setText(R.string.__leak_canary_delete);
+          actionButton.setOnClickListener(new View.OnClickListener() {
+            @Override public void onClick(View v) {
+              Leak visibleLeak = getVisibleLeak();
+              File resultFile = leakResultFile(visibleLeak.heapDump.heapDumpFile);
+              resultFile.delete();
+              visibleLeak.heapDump.heapDumpFile.delete();
+              visibleLeakRefKey = null;
+              leaks.remove(visibleLeak);
+              updateUi();
+            }
+          });
+        }
+        HeapDump heapDump = visibleLeak.heapDump;
+        adapter.update(result.leakTrace, heapDump.referenceKey, heapDump.referenceName);
+        setTitle(
+            getString(R.string.__leak_canary_class_has_leaked, classSimpleName(result.className)));
       }
-      AnalysisResult result = visibleLeak.result;
-      HeapDump heapDump = visibleLeak.heapDump;
-      adapter.update(result.leakTrace, heapDump.referenceKey, heapDump.referenceName);
-      setTitle(
-          getString(R.string.__leak_canary_class_has_leaked, classSimpleName(result.className)));
     } else {
       if (listAdapter instanceof LeakListAdapter) {
         ((LeakListAdapter) listAdapter).notifyDataSetChanged();
@@ -254,12 +270,12 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
         invalidateOptionsMenu();
         setTitle(getString(R.string.__leak_canary_leak_list_title, getPackageName()));
         getActionBar().setDisplayHomeAsUpEnabled(false);
-        actionButton.setText("Remove all leaks");
+        actionButton.setText(R.string.__leak_canary_delete_all);
         actionButton.setOnClickListener(new View.OnClickListener() {
           @Override public void onClick(View v) {
-            File directory = leakDirectory(DisplayLeakActivity.this);
-            if (directory.exists()) {
-              for (File file : directory.listFiles()) {
+            File[] files = detectedLeakDirectory().listFiles();
+            if (files != null) {
+              for (File file : files) {
                 file.delete();
               }
             }
@@ -268,7 +284,7 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
           }
         });
       }
-      actionButton.setVisibility(leaks.size() == 0 ? View.GONE : View.VISIBLE);
+      actionButton.setVisibility(leaks.size() == 0 ? GONE : VISIBLE);
     }
   }
 
@@ -314,8 +330,16 @@ private Leak getVisibleLeak() {
         index = (leaks.size() - position) + ". ";
       }
 
-      String title = index + getString(R.string.__leak_canary_class_has_leaked,
-          classSimpleName(leak.result.className));
+      String title;
+      if (leak.result.failure == null) {
+        title = index + getString(R.string.__leak_canary_class_has_leaked,
+            classSimpleName(leak.result.className));
+      } else {
+        title = index
+            + leak.result.failure.getClass().getSimpleName()
+            + " "
+            + leak.result.failure.getMessage();
+      }
       titleView.setText(title);
       String time = DateUtils.formatDateTime(DisplayLeakActivity.this,
           leak.heapDump.heapDumpFile.lastModified(), FORMAT_SHOW_TIME | FORMAT_SHOW_DATE);
@@ -359,7 +383,7 @@ static void forgetActivity() {
 
     LoadLeaks(DisplayLeakActivity activity) {
       this.activityOrNull = activity;
-      leakDirectory = leakDirectory(activity);
+      leakDirectory = detectedLeakDirectory();
       mainHandler = new Handler(Looper.getMainLooper());
     }
 
@@ -371,8 +395,8 @@ static void forgetActivity() {
         }
       });
       if (files != null) {
-        for (File file : files) {
-          File resultFile = leakResultFile(file);
+        for (File heapDumpFile : files) {
+          File resultFile = leakResultFile(heapDumpFile);
           FileInputStream fis = null;
           try {
             fis = new FileInputStream(resultFile);
@@ -383,9 +407,10 @@ static void forgetActivity() {
           } catch (IOException | ClassNotFoundException e) {
             // Likely a change in the serializable result class.
             // Let's remove the files, we can't read them anymore.
-            file.delete();
+            heapDumpFile.delete();
             resultFile.delete();
-            Log.e(TAG, "Could not read result file, deleted result and heap dump:" + file, e);
+            Log.e(TAG, "Could not read result file, deleted result and heap dump:" + heapDumpFile,
+                e);
           } finally {
             if (fis != null) {
               try {
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
similarity index 100%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
new file mode 100644
index 00000000..e854ac2a
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.util.AttributeSet;
+import android.view.View;
+
+import static android.graphics.Bitmap.Config.ARGB_8888;
+
+public final class DisplayLeakConnectorView extends View {
+
+  private static final Paint iconPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+  private static final Paint rootPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+  private static final Paint leakPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+  private static final Paint clearPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+
+  static {
+    iconPaint.setColor(LeakCanaryUi.LIGHT_GREY);
+    rootPaint.setColor(LeakCanaryUi.ROOT_COLOR);
+    leakPaint.setColor(LeakCanaryUi.LEAK_COLOR);
+    clearPaint.setColor(Color.TRANSPARENT);
+    clearPaint.setXfermode(LeakCanaryUi.CLEAR_XFER_MODE);
+  }
+
+  public enum Type {
+    START, NODE, END
+  }
+
+  private Type type;
+  private Bitmap cache;
+
+  public DisplayLeakConnectorView(Context context, AttributeSet attrs) {
+    super(context, attrs);
+
+    type = Type.NODE;
+  }
+
+  @SuppressWarnings("SuspiciousNameCombination") @Override protected void onDraw(Canvas canvas) {
+    int width = getWidth();
+    int height = getHeight();
+
+    if (cache != null && (cache.getWidth() != width || cache.getHeight() != height)) {
+      cache.recycle();
+      cache = null;
+    }
+
+    if (cache == null) {
+      cache = Bitmap.createBitmap(width, height, ARGB_8888);
+
+      Canvas cacheCanvas = new Canvas(cache);
+
+      float halfWidth = width / 2f;
+      float halfHeight = height / 2f;
+      float thirdWidth = width / 3f;
+
+      float strokeSize = LeakCanaryUi.dpToPixel(4f, getResources());
+
+      iconPaint.setStrokeWidth(strokeSize);
+      rootPaint.setStrokeWidth(strokeSize);
+
+      switch (type) {
+        case NODE:
+          cacheCanvas.drawLine(halfWidth, 0, halfWidth, height, iconPaint);
+          cacheCanvas.drawCircle(halfWidth, halfHeight, halfWidth, iconPaint);
+          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, clearPaint);
+          break;
+        case START:
+          float radiusClear = halfWidth - strokeSize / 2f;
+          cacheCanvas.drawRect(0, 0, width, radiusClear, rootPaint);
+          cacheCanvas.drawCircle(0, radiusClear, radiusClear, clearPaint);
+          cacheCanvas.drawCircle(width, radiusClear, radiusClear, clearPaint);
+          cacheCanvas.drawLine(halfWidth, 0, halfWidth, halfHeight, rootPaint);
+          cacheCanvas.drawLine(halfWidth, halfHeight, halfWidth, height, iconPaint);
+          cacheCanvas.drawCircle(halfWidth, halfHeight, halfWidth, iconPaint);
+          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, clearPaint);
+          break;
+        default:
+          cacheCanvas.drawLine(halfWidth, 0, halfWidth, halfHeight, iconPaint);
+          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, leakPaint);
+          break;
+      }
+    }
+    canvas.drawBitmap(cache, 0, 0, null);
+  }
+
+  public void setType(Type type) {
+    if (type != this.type) {
+      this.type = type;
+      if (cache != null) {
+        cache.recycle();
+        cache = null;
+      }
+      invalidate();
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.java
new file mode 100644
index 00000000..8cd6b27f
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+
+public final class FutureResult<T> {
+
+  private final AtomicReference<T> resultHolder;
+  private final CountDownLatch latch;
+
+  public FutureResult() {
+    resultHolder = new AtomicReference<>();
+    latch = new CountDownLatch(1);
+  }
+
+  public boolean wait(long timeout, TimeUnit unit) {
+    try {
+      return latch.await(timeout, unit);
+    } catch (InterruptedException e) {
+      throw new RuntimeException("Did not expect thread to be interrupted", e);
+    }
+  }
+
+  public T get() {
+    if (latch.getCount() > 0) {
+      throw new IllegalStateException("Call wait() and check its result");
+    }
+    return resultHolder.get();
+  }
+
+  public void set(T result) {
+    resultHolder.set(result);
+    latch.countDown();
+  }
+}
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
similarity index 84%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
index 0f134eff..fa01a52d 100644
--- a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
@@ -18,13 +18,14 @@
 import android.app.IntentService;
 import android.content.Context;
 import android.content.Intent;
+import android.util.Log;
 import com.squareup.leakcanary.AbstractAnalysisResultService;
 import com.squareup.leakcanary.AnalysisResult;
+import com.squareup.leakcanary.ExcludedRefs;
 import com.squareup.leakcanary.HeapAnalyzer;
 import com.squareup.leakcanary.HeapDump;
 
 import static com.squareup.leakcanary.AndroidExcludedRefs.createAndroidDefaults;
-import static com.squareup.leakcanary.AndroidExcludedRefs.createAppDefaults;
 
 /**
  * This service runs in a separate process to avoid slowing down the app process or making it run
@@ -34,6 +35,7 @@
 
   private static final String LISTENER_CLASS_EXTRA = "listener_class_extra";
   private static final String HEAPDUMP_EXTRA = "heapdump_extra";
+  public static final String TAG = "HeapAnalyzerService";
 
   public static void runAnalysis(Context context, HeapDump heapDump,
       Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
@@ -43,16 +45,21 @@ public static void runAnalysis(Context context, HeapDump heapDump,
     context.startService(intent);
   }
 
-  private final HeapAnalyzer heapAnalyzer;
-
   public HeapAnalyzerService() {
     super(HeapAnalyzerService.class.getSimpleName());
-    heapAnalyzer = new HeapAnalyzer(createAndroidDefaults(), createAppDefaults());
   }
 
   @Override protected void onHandleIntent(Intent intent) {
+    if (intent == null) {
+      Log.d(TAG, "HeapAnalyzerService received a null intent, ignoring.");
+      return;
+    }
     String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);
     HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);
+
+    ExcludedRefs androidExcludedDefault = createAndroidDefaults().build();
+    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(androidExcludedDefault, heapDump.excludedRefs);
+
     AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);
     AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);
   }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
new file mode 100644
index 00000000..ac8ecba7
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import android.app.ActivityManager;
+import android.app.Service;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ServiceInfo;
+import android.os.Environment;
+import android.util.Log;
+import java.io.File;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+
+import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
+import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
+import static android.content.pm.PackageManager.DONT_KILL_APP;
+import static android.content.pm.PackageManager.GET_SERVICES;
+import static android.os.Environment.DIRECTORY_DOWNLOADS;
+
+public final class LeakCanaryInternals {
+
+  // SDK INT for API 22.
+  public static final int LOLLIPOP_MR1 = 22;
+  public static final String SAMSUNG = "samsung";
+  public static final String MOTOROLA = "motorola";
+  public static final String LG = "LGE";
+  public static final String NVIDIA = "NVIDIA";
+
+  private static final Executor fileIoExecutor = Executors.newSingleThreadExecutor();
+
+  public static void executeOnFileIoThread(Runnable runnable) {
+    fileIoExecutor.execute(runnable);
+  }
+
+  public static File storageDirectory() {
+    File downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS);
+    File leakCanaryDirectory = new File(downloadsDirectory, "leakcanary");
+    leakCanaryDirectory.mkdirs();
+    return leakCanaryDirectory;
+  }
+
+  public static File detectedLeakDirectory() {
+    File directory = new File(storageDirectory(), "detected_leaks");
+    directory.mkdirs();
+    return directory;
+  }
+
+  public static File leakResultFile(File heapdumpFile) {
+    return new File(heapdumpFile.getParentFile(), heapdumpFile.getName() + ".result");
+  }
+
+  public static boolean isExternalStorageWritable() {
+    String state = Environment.getExternalStorageState();
+    return Environment.MEDIA_MOUNTED.equals(state);
+  }
+
+  public static File findNextAvailableHprofFile(int maxFiles) {
+    File directory = detectedLeakDirectory();
+    for (int i = 0; i < maxFiles; i++) {
+      String heapDumpName = "heap_dump_" + i + ".hprof";
+      File file = new File(directory, heapDumpName);
+      if (!file.exists()) {
+        return file;
+      }
+    }
+    return null;
+  }
+
+  /** Extracts the class simple name out of a string containing a fully qualified class name. */
+  public static String classSimpleName(String className) {
+    int separator = className.lastIndexOf('.');
+    if (separator == -1) {
+      return className;
+    } else {
+      return className.substring(separator + 1);
+    }
+  }
+
+  public static void setEnabled(Context context, final Class<?> componentClass,
+      final boolean enabled) {
+    final Context appContext = context.getApplicationContext();
+    executeOnFileIoThread(new Runnable() {
+      @Override public void run() {
+        ComponentName component = new ComponentName(appContext, componentClass);
+        PackageManager packageManager = appContext.getPackageManager();
+        int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED;
+        // Blocks on IPC.
+        packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);
+      }
+    });
+  }
+
+  public static boolean isInServiceProcess(Context context, Class<? extends Service> serviceClass) {
+    PackageManager packageManager = context.getPackageManager();
+    PackageInfo packageInfo;
+    try {
+      packageInfo = packageManager.getPackageInfo(context.getPackageName(), GET_SERVICES);
+    } catch (Exception e) {
+      Log.e("AndroidUtils", "Could not get package info for " + context.getPackageName(), e);
+      return false;
+    }
+    String mainProcess = packageInfo.applicationInfo.processName;
+
+    ComponentName component = new ComponentName(context, serviceClass);
+    ServiceInfo serviceInfo;
+    try {
+      serviceInfo = packageManager.getServiceInfo(component, 0);
+    } catch (PackageManager.NameNotFoundException ignored) {
+      // Service is disabled.
+      return false;
+    }
+
+    if (serviceInfo.processName.equals(mainProcess)) {
+      Log.e("AndroidUtils",
+          "Did not expect service " + serviceClass + " to run in main process " + mainProcess);
+      // Technically we are in the service process, but we're not in the service dedicated process.
+      return false;
+    }
+
+    int myPid = android.os.Process.myPid();
+    ActivityManager activityManager =
+        (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+    ActivityManager.RunningAppProcessInfo myProcess = null;
+    for (ActivityManager.RunningAppProcessInfo process : activityManager.getRunningAppProcesses()) {
+      if (process.pid == myPid) {
+        myProcess = process;
+        break;
+      }
+    }
+    if (myProcess == null) {
+      Log.e("AndroidUtils", "Could not find running process for " + myPid);
+      return false;
+    }
+
+    return myProcess.processName.equals(serviceInfo.processName);
+  }
+
+  private LeakCanaryInternals() {
+    throw new AssertionError();
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java
new file mode 100644
index 00000000..74fbf986
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import android.content.res.Resources;
+import android.graphics.PorterDuffXfermode;
+import android.util.DisplayMetrics;
+
+import static android.graphics.PorterDuff.Mode.CLEAR;
+
+final class LeakCanaryUi {
+  static final int LIGHT_GREY = 0xFFbababa;
+  static final int ROOT_COLOR = 0xFF84a6c5;
+  static final int LEAK_COLOR = 0xFFb1554e;
+
+  static final PorterDuffXfermode CLEAR_XFER_MODE = new PorterDuffXfermode(CLEAR);
+
+  /**
+   * Converts from device independent pixels (dp or dip) to
+   * device dependent pixels. This method returns the input
+   * multiplied by the display's density. The result is not
+   * rounded nor clamped.
+   *
+   * The value returned by this method is well suited for
+   * drawing with the Canvas API but should not be used to
+   * set layout dimensions.
+   *
+   * @param dp The value in dp to convert to pixels
+   * @param resources An instances of Resources
+   */
+  static float dpToPixel(float dp, Resources resources) {
+    DisplayMetrics metrics = resources.getDisplayMetrics();
+    return metrics.density * dp;
+  }
+
+  private LeakCanaryUi() {
+    throw new AssertionError();
+  }
+}
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
similarity index 74%
rename from library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
index 556fe147..81bf8a0f 100644
--- a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
@@ -16,27 +16,24 @@
 package com.squareup.leakcanary.internal;
 
 import android.content.Context;
-import android.content.res.Resources;
 import android.graphics.Canvas;
 import android.graphics.Paint;
 import android.util.AttributeSet;
-import android.util.DisplayMetrics;
 import android.view.View;
 
-import static com.squareup.leakcanary.internal.DisplayLeakConnectorView.ROOT_COLOR;
-
 public final class MoreDetailsView extends View {
 
-  private final Paint iconPaint;
+  private static final Paint iconPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+
+  static {
+    iconPaint.setColor(LeakCanaryUi.ROOT_COLOR);
+  }
 
   public MoreDetailsView(Context context, AttributeSet attrs) {
     super(context, attrs);
 
-    float strokeSize = dpToPixel(2, getResources());
-    iconPaint = new Paint();
-    iconPaint.setColor(ROOT_COLOR);
+    float strokeSize = LeakCanaryUi.dpToPixel(2f, getResources());
     iconPaint.setStrokeWidth(strokeSize);
-    iconPaint.setAntiAlias(true);
   }
 
   private boolean opened;
@@ -61,10 +58,4 @@ public void setOpened(boolean opened) {
       invalidate();
     }
   }
-
-  static float dpToPixel(float dp, Resources resources) {
-    DisplayMetrics metrics = resources.getDisplayMetrics();
-    float px = dp * (metrics.densityDpi / 160f);
-    return px;
-  }
 }
diff --git a/leakcanary-android/src/main/res/drawable-hdpi-v11/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi-v11/__leak_canary_notification.png
new file mode 100755
index 00000000..f1049229
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-hdpi-v11/__leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_icon.png
new file mode 100755
index 00000000..7e375c54
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_notification.png
new file mode 100755
index 00000000..09c78cc0
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi-v11/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi-v11/__leak_canary_notification.png
new file mode 100755
index 00000000..d29b9f1d
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-mdpi-v11/__leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_icon.png
new file mode 100755
index 00000000..f354c3f2
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_notification.png
new file mode 100755
index 00000000..c825fa4a
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi-v11/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi-v11/__leak_canary_notification.png
new file mode 100755
index 00000000..d0cdbcd8
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xhdpi-v11/__leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_icon.png
new file mode 100755
index 00000000..a5e85b41
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_notification.png
new file mode 100755
index 00000000..b2978d57
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi-v11/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi-v11/__leak_canary_notification.png
new file mode 100755
index 00000000..0194b4e1
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xxhdpi-v11/__leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_icon.png
new file mode 100755
index 00000000..3d4b76af
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_notification.png
new file mode 100755
index 00000000..22db2020
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/__leak_canary_notification.png
new file mode 100755
index 00000000..05141619
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/__leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_icon.png
new file mode 100755
index 00000000..eb9c0724
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_notification.png
new file mode 100755
index 00000000..34b76141
Binary files /dev/null and b/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable/__leak_canary_toast_background.xml b/leakcanary-android/src/main/res/drawable/__leak_canary_toast_background.xml
new file mode 100644
index 00000000..a90b8c2c
--- /dev/null
+++ b/leakcanary-android/src/main/res/drawable/__leak_canary_toast_background.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android">
+  <solid android:color="#cc000000"/>
+  <corners android:radius="16dp"/>
+</shape>
\ No newline at end of file
diff --git a/library/leakcanary-android/src/main/res/layout/__leak_canary_display_leak.xml b/leakcanary-android/src/main/res/layout/__leak_canary_display_leak.xml
similarity index 84%
rename from library/leakcanary-android/src/main/res/layout/__leak_canary_display_leak.xml
rename to leakcanary-android/src/main/res/layout/__leak_canary_display_leak.xml
index 3a40ce25..d9d312e0 100644
--- a/library/leakcanary-android/src/main/res/layout/__leak_canary_display_leak.xml
+++ b/leakcanary-android/src/main/res/layout/__leak_canary_display_leak.xml
@@ -28,7 +28,14 @@
       android:dividerHeight="0dp"
       android:divider="@null"
       />
-
+  <TextView
+      android:id="@+id/__leak_canary_display_leak_failure"
+      android:layout_width="match_parent"
+      android:layout_height="0dp"
+      android:layout_weight="1"
+      android:textSize="12sp"
+      android:visibility="gone"
+      />
   <Button
       android:id="@+id/__leak_canary_action"
       android:layout_width="match_parent"
diff --git a/leakcanary-android/src/main/res/layout/__leak_canary_heap_dump_toast.xml b/leakcanary-android/src/main/res/layout/__leak_canary_heap_dump_toast.xml
new file mode 100644
index 00000000..7bc707c3
--- /dev/null
+++ b/leakcanary-android/src/main/res/layout/__leak_canary_heap_dump_toast.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:orientation="vertical"
+    android:background="@drawable/__leak_canary_toast_background"
+    android:padding="16dp"
+    >
+  <ImageView
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_gravity="center_horizontal"
+      android:src="@drawable/__leak_canary_icon"/>
+
+  <TextView
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_gravity="center_horizontal"
+      android:textColor="#ffffff"
+      android:textSize="18sp"
+      android:text="@string/__leak_canary_toast_heap_dump"
+      />
+
+</LinearLayout>
diff --git a/library/leakcanary-android/src/main/res/layout/__leak_canary_leak_row.xml b/leakcanary-android/src/main/res/layout/__leak_canary_leak_row.xml
similarity index 100%
rename from library/leakcanary-android/src/main/res/layout/__leak_canary_leak_row.xml
rename to leakcanary-android/src/main/res/layout/__leak_canary_leak_row.xml
diff --git a/library/leakcanary-android/src/main/res/layout/__leak_canary_ref_row.xml b/leakcanary-android/src/main/res/layout/__leak_canary_ref_row.xml
similarity index 100%
rename from library/leakcanary-android/src/main/res/layout/__leak_canary_ref_row.xml
rename to leakcanary-android/src/main/res/layout/__leak_canary_ref_row.xml
diff --git a/library/leakcanary-android/src/main/res/layout/__leak_canary_ref_top_row.xml b/leakcanary-android/src/main/res/layout/__leak_canary_ref_top_row.xml
similarity index 100%
rename from library/leakcanary-android/src/main/res/layout/__leak_canary_ref_top_row.xml
rename to leakcanary-android/src/main/res/layout/__leak_canary_ref_top_row.xml
diff --git a/library/leakcanary-android/src/main/res/values-v14/__leak_canary_themes.xml b/leakcanary-android/src/main/res/values-v14/__leak_canary_themes.xml
similarity index 100%
rename from library/leakcanary-android/src/main/res/values-v14/__leak_canary_themes.xml
rename to leakcanary-android/src/main/res/values-v14/__leak_canary_themes.xml
diff --git a/library/leakcanary-android/src/main/res/values-v21/__leak_canary_themes.xml b/leakcanary-android/src/main/res/values-v21/__leak_canary_themes.xml
similarity index 100%
rename from library/leakcanary-android/src/main/res/values-v21/__leak_canary_themes.xml
rename to leakcanary-android/src/main/res/values-v21/__leak_canary_themes.xml
diff --git a/library/leakcanary-android/src/main/res/values/__leak_canary_int.xml b/leakcanary-android/src/main/res/values/__leak_canary_int.xml
similarity index 100%
rename from library/leakcanary-android/src/main/res/values/__leak_canary_int.xml
rename to leakcanary-android/src/main/res/values/__leak_canary_int.xml
diff --git a/library/leakcanary-android/src/main/res/values/__leak_canary_strings.xml b/leakcanary-android/src/main/res/values/__leak_canary_strings.xml
similarity index 69%
rename from library/leakcanary-android/src/main/res/values/__leak_canary_strings.xml
rename to leakcanary-android/src/main/res/values/__leak_canary_strings.xml
index 4113b2b0..f92e8fd1 100644
--- a/library/leakcanary-android/src/main/res/values/__leak_canary_strings.xml
+++ b/leakcanary-android/src/main/res/values/__leak_canary_strings.xml
@@ -17,11 +17,16 @@
 <resources>
 
   <string name="__leak_canary_class_has_leaked">%s has leaked</string>
+  <string name="__leak_canary_analysis_failed">Leak analysis failed</string>
   <string name="__leak_canary_leak_list_title">Leaks in %s</string>
   <string name="__leak_canary_notification_message">Click for more details</string>
-  <string name="__leak_canary_share_leak">Share leak</string>
+  <string name="__leak_canary_share_leak">Share info</string>
   <string name="__leak_canary_share_heap_dump">Share heap dump</string>
   <string name="__leak_canary_share_with">Share with…</string>
   <string name="__leak_canary_display_activity_label">Leaks</string>
+  <string name="__leak_canary_toast_heap_dump">Dumping memory, app will freeze. Brrrr.</string>
+  <string name="__leak_canary_delete">Delete</string>
+  <string name="__leak_canary_failure_report">"Please report this failure to http://github.com/square/leakcanary\n"</string>
+  <string name="__leak_canary_delete_all">Delete all</string>
 
 </resources>
\ No newline at end of file
diff --git a/library/leakcanary-android/src/main/res/values/__leak_canary_themes.xml b/leakcanary-android/src/main/res/values/__leak_canary_themes.xml
similarity index 100%
rename from library/leakcanary-android/src/main/res/values/__leak_canary_themes.xml
rename to leakcanary-android/src/main/res/values/__leak_canary_themes.xml
diff --git a/library/leakcanary-sample/build.gradle b/leakcanary-sample/build.gradle
similarity index 88%
rename from library/leakcanary-sample/build.gradle
rename to leakcanary-sample/build.gradle
index 512049b5..d80081b8 100644
--- a/library/leakcanary-sample/build.gradle
+++ b/leakcanary-sample/build.gradle
@@ -1,9 +1,3 @@
-buildscript {
-  dependencies {
-    classpath rootProject.ext.androidPlugin
-  }
-}
-
 apply plugin: 'com.android.application'
 
 dependencies {
diff --git a/library/leakcanary-sample/src/main/AndroidManifest.xml b/leakcanary-sample/src/main/AndroidManifest.xml
similarity index 100%
rename from library/leakcanary-sample/src/main/AndroidManifest.xml
rename to leakcanary-sample/src/main/AndroidManifest.xml
diff --git a/library/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
similarity index 65%
rename from library/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
rename to leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
index 220e05ec..942be776 100644
--- a/library/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
@@ -16,21 +16,27 @@
 package com.example.leakcanary;
 
 import android.app.Application;
-import android.content.Context;
+import android.os.StrictMode;
 import com.squareup.leakcanary.LeakCanary;
-import com.squareup.leakcanary.RefWatcher;
 
-public class ExampleApplication extends Application {
-
-  public static RefWatcher getRefWatcher(Context context) {
-    ExampleApplication application = (ExampleApplication) context.getApplicationContext();
-    return application.refWatcher;
-  }
+import static android.os.Build.VERSION.SDK_INT;
+import static android.os.Build.VERSION_CODES.GINGERBREAD;
 
-  private RefWatcher refWatcher;
+public class ExampleApplication extends Application {
 
   @Override public void onCreate() {
     super.onCreate();
-    refWatcher = LeakCanary.install(this);
+    enabledStrictMode();
+    LeakCanary.install(this);
+  }
+
+  private void enabledStrictMode() {
+    if (SDK_INT >= GINGERBREAD) {
+      StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() //
+          .detectAll() //
+          .penaltyLog() //
+          .penaltyDeath() //
+          .build());
+    }
   }
 }
diff --git a/library/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
similarity index 100%
rename from library/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
rename to leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
diff --git a/library/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png
similarity index 100%
rename from library/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png
rename to leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png
diff --git a/library/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png
similarity index 100%
rename from library/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png
rename to leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png
diff --git a/library/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png
similarity index 100%
rename from library/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png
rename to leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png
diff --git a/library/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png
similarity index 100%
rename from library/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png
rename to leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png
diff --git a/library/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png
similarity index 100%
rename from library/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png
rename to leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png
diff --git a/library/leakcanary-sample/src/main/res/layout/main_activity.xml b/leakcanary-sample/src/main/res/layout/main_activity.xml
similarity index 100%
rename from library/leakcanary-sample/src/main/res/layout/main_activity.xml
rename to leakcanary-sample/src/main/res/layout/main_activity.xml
diff --git a/library/leakcanary-sample/src/main/res/values/strings.xml b/leakcanary-sample/src/main/res/values/strings.xml
similarity index 100%
rename from library/leakcanary-sample/src/main/res/values/strings.xml
rename to leakcanary-sample/src/main/res/values/strings.xml
diff --git a/library/leakcanary-watcher/build.gradle b/leakcanary-watcher/build.gradle
similarity index 100%
rename from library/leakcanary-watcher/build.gradle
rename to leakcanary-watcher/build.gradle
diff --git a/library/leakcanary-watcher/gradle.properties b/leakcanary-watcher/gradle.properties
similarity index 100%
rename from library/leakcanary-watcher/gradle.properties
rename to leakcanary-watcher/gradle.properties
diff --git a/library/leakcanary-watcher/src/main/AndroidManifest.xml b/leakcanary-watcher/src/main/AndroidManifest.xml
similarity index 100%
rename from library/leakcanary-watcher/src/main/AndroidManifest.xml
rename to leakcanary-watcher/src/main/AndroidManifest.xml
diff --git a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/DebuggerControl.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/DebuggerControl.java
similarity index 100%
rename from library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/DebuggerControl.java
rename to leakcanary-watcher/src/main/java/com/squareup/leakcanary/DebuggerControl.java
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
new file mode 100644
index 00000000..3bc1a45f
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import java.io.Serializable;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
+import static com.squareup.leakcanary.Preconditions.checkNotNull;
+import static java.util.Collections.unmodifiableMap;
+import static java.util.Collections.unmodifiableSet;
+
+/**
+ * Prevents specific references from being taken into account when computing the shortest strong
+ * reference path from a suspected leaking instance to the GC roots.
+ *
+ * This class lets you ignore known memory leaks that you known about. If the shortest path
+ * matches {@link ExcludedRefs}, than the heap analyzer should look for a longer path with nothing
+ * matching in {@link ExcludedRefs}.
+ */
+public final class ExcludedRefs implements Serializable {
+
+  public final Map<String, Set<String>> excludeFieldMap;
+  public final Map<String, Set<String>> excludeStaticFieldMap;
+  public final Set<String> excludedThreads;
+
+  private ExcludedRefs(Map<String, Set<String>> excludeFieldMap,
+      Map<String, Set<String>> excludeStaticFieldMap, Set<String> excludedThreads) {
+    // Copy + unmodifiable.
+    this.excludeFieldMap = unmodifiableMap(new LinkedHashMap<>(excludeFieldMap));
+    this.excludeStaticFieldMap = unmodifiableMap(new LinkedHashMap<>(excludeStaticFieldMap));
+    this.excludedThreads = unmodifiableSet(new LinkedHashSet<>(excludedThreads));
+  }
+
+  @Override public String toString() {
+    String string = "";
+    for (Map.Entry<String, Set<String>> classes : excludeFieldMap.entrySet()) {
+      String clazz = classes.getKey();
+      for (String field : classes.getValue()) {
+        string += "| Field: " + clazz + "." + field + "\n";
+      }
+    }
+    for (Map.Entry<String, Set<String>> classes : excludeStaticFieldMap.entrySet()) {
+      String clazz = classes.getKey();
+      for (String field : classes.getValue()) {
+        string += "| Static field: " + clazz + "." + field + "\n";
+      }
+    }
+    for (String thread : excludedThreads) {
+      string += "| Thread:" + thread;
+    }
+    return string;
+  }
+
+  public static final class Builder {
+    private final Map<String, Set<String>> excludeFieldMap = new LinkedHashMap<>();
+    private final Map<String, Set<String>> excludeStaticFieldMap = new LinkedHashMap<>();
+    private final Set<String> excludedThreads = new LinkedHashSet<>();
+
+    public Builder instanceField(String className, String fieldName) {
+      checkNotNull(className, "className");
+      checkNotNull(fieldName, "fieldName");
+      Set<String> excludedFields = excludeFieldMap.get(className);
+      if (excludedFields == null) {
+        excludedFields = new LinkedHashSet<>();
+        excludeFieldMap.put(className, excludedFields);
+      }
+      excludedFields.add(fieldName);
+      return this;
+    }
+
+    public Builder staticField(String className, String fieldName) {
+      checkNotNull(className, "className");
+      checkNotNull(fieldName, "fieldName");
+      Set<String> excludedFields = excludeStaticFieldMap.get(className);
+      if (excludedFields == null) {
+        excludedFields = new LinkedHashSet<>();
+        excludeStaticFieldMap.put(className, excludedFields);
+      }
+      excludedFields.add(fieldName);
+      return this;
+    }
+
+    public Builder thread(String threadName) {
+      checkNotNull(threadName, "threadName");
+      excludedThreads.add(threadName);
+      return this;
+    }
+
+    public ExcludedRefs build() {
+      return new ExcludedRefs(excludeFieldMap, excludeStaticFieldMap, excludedThreads);
+    }
+  }
+}
diff --git a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
similarity index 100%
rename from library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
rename to leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
diff --git a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
similarity index 84%
rename from library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
rename to leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
index e2a906d4..2423dc9b 100644
--- a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
@@ -43,16 +43,20 @@
    */
   public final String referenceName;
 
+  /** References that should be ignored when analyzing this heap dump. */
+  public final ExcludedRefs excludedRefs;
+
   /** Time from the request to watch the reference until the GC was triggered. */
   public final long watchDurationMs;
   public final long gcDurationMs;
   public final long heapDumpDurationMs;
 
   public HeapDump(File heapDumpFile, String referenceKey, String referenceName,
-      long watchDurationMs, long gcDurationMs, long heapDumpDurationMs) {
+      ExcludedRefs excludedRefs, long watchDurationMs, long gcDurationMs, long heapDumpDurationMs) {
     this.heapDumpFile = checkNotNull(heapDumpFile, "heapDumpFile");
     this.referenceKey = checkNotNull(referenceKey, "referenceKey");
     this.referenceName = checkNotNull(referenceName, "referenceName");
+    this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
     this.watchDurationMs = watchDurationMs;
     this.gcDurationMs = gcDurationMs;
     this.heapDumpDurationMs = heapDumpDurationMs;
@@ -61,7 +65,7 @@ public HeapDump(File heapDumpFile, String referenceKey, String referenceName,
   /** Renames the heap dump file and creates a new {@link HeapDump} pointing to it. */
   public HeapDump renameFile(File newFile) {
     heapDumpFile.renameTo(newFile);
-    return new HeapDump(newFile, referenceKey, referenceName, watchDurationMs, gcDurationMs,
-        heapDumpDurationMs);
+    return new HeapDump(newFile, referenceKey, referenceName, excludedRefs, watchDurationMs,
+        gcDurationMs, heapDumpDurationMs);
   }
 }
diff --git a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
similarity index 82%
rename from library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
rename to leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
index 1bd3c4c2..715d089a 100644
--- a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
@@ -19,6 +19,11 @@
 
 public interface HeapDumper {
 
-  /** @return a {@link File} referencing the heap dump, or null if the heap could not be dumped. */
+  File NO_DUMP = null;
+
+  /**
+   * @return a {@link File} referencing the heap dump, or {@link #NO_DUMP} if the heap could not be
+   * dumped.
+   */
   File dumpHeap();
 }
\ No newline at end of file
diff --git a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java
similarity index 100%
rename from library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java
rename to leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java
diff --git a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Preconditions.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Preconditions.java
similarity index 100%
rename from library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Preconditions.java
rename to leakcanary-watcher/src/main/java/com/squareup/leakcanary/Preconditions.java
diff --git a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
similarity index 92%
rename from library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
rename to leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
index 6f3ea0d2..7d2b9fc4 100644
--- a/library/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
@@ -48,7 +48,7 @@
   }, new HeapDump.Listener() {
     @Override public void analyze(HeapDump heapDump) {
     }
-  });
+  }, new ExcludedRefs.Builder().build());
 
   private final Executor watchExecutor;
   private final DebuggerControl debuggerControl;
@@ -57,20 +57,23 @@
   private final Set<String> retainedKeys;
   private final ReferenceQueue<Object> queue;
   private final HeapDump.Listener heapdumpListener;
+  private final ExcludedRefs excludedRefs;
 
   public RefWatcher(Executor watchExecutor, DebuggerControl debuggerControl, GcTrigger gcTrigger,
-      HeapDumper heapDumper, HeapDump.Listener heapdumpListener) {
+      HeapDumper heapDumper, HeapDump.Listener heapdumpListener, ExcludedRefs excludedRefs) {
     this.watchExecutor = checkNotNull(watchExecutor, "watchExecutor");
     this.debuggerControl = checkNotNull(debuggerControl, "debuggerControl");
     this.gcTrigger = checkNotNull(gcTrigger, "gcTrigger");
     this.heapDumper = checkNotNull(heapDumper, "heapDumper");
     this.heapdumpListener = checkNotNull(heapdumpListener, "heapdumpListener");
+    this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
     retainedKeys = new CopyOnWriteArraySet<>();
     queue = new ReferenceQueue<>();
   }
 
   /**
    * Identical to {@link #watch(Object, String)} with an empty string reference name.
+   *
    * @see #watch(Object, String)
    */
   public void watch(Object watchedReference) {
@@ -118,14 +121,14 @@ void ensureGone(KeyedWeakReference reference, long watchStartNanoTime) {
 
       File heapDumpFile = heapDumper.dumpHeap();
 
-      if (heapDumpFile == null) {
+      if (heapDumpFile == HeapDumper.NO_DUMP) {
         // Could not dump the heap, abort.
         return;
       }
       long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);
       heapdumpListener.analyze(
-          new HeapDump(heapDumpFile, reference.key, reference.name, watchDurationMs, gcDurationMs,
-              heapDumpDurationMs));
+          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,
+              gcDurationMs, heapDumpDurationMs));
     }
   }
 
diff --git a/library/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java b/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
similarity index 82%
rename from library/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
rename to leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
index f93e8fd3..421ceea0 100644
--- a/library/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
+++ b/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
@@ -19,13 +19,13 @@
 import java.util.concurrent.Executor;
 import org.junit.Test;
 
-import static com.squareup.leakcanary.DebuggerControl.NONE;
-import static com.squareup.leakcanary.GcTrigger.DEFAULT;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 public class RefWatcherTest {
 
+  static final ExcludedRefs NO_REF = new ExcludedRefs.Builder().build();
+
   static class TestDumper implements HeapDumper {
     boolean called;
 
@@ -44,10 +44,11 @@
 
   static class TestExecutor implements Executor {
     private Runnable command;
+
     @Override public void execute(Runnable command) {
       this.command = command;
     }
-  };
+  }
 
   /**
    * In theory, this test doesn't have a 100% chance of success. In practice, {@link
@@ -56,7 +57,7 @@
   @Test public void unreachableObject_noDump() {
     TestDumper dumper = new TestDumper();
     TestExecutor executor = new TestExecutor();
-    RefWatcher refWatcher = new RefWatcher(executor, NONE, DEFAULT, dumper, new TestListener());
+    RefWatcher refWatcher = defaultWatcher(dumper, executor);
     refWatcher.watch(new Object());
     executor.command.run();
     assertFalse(dumper.called);
@@ -65,10 +66,15 @@
   @Test public void retainedObject_triggersDump() {
     TestDumper dumper = new TestDumper();
     TestExecutor executor = new TestExecutor();
-    RefWatcher refWatcher = new RefWatcher(executor, NONE, DEFAULT, dumper, new TestListener());
+    RefWatcher refWatcher = defaultWatcher(dumper, executor);
     ref = new Object();
     refWatcher.watch(ref);
     executor.command.run();
     assertTrue(dumper.called);
   }
+
+  private RefWatcher defaultWatcher(TestDumper dumper, TestExecutor executor) {
+    return new RefWatcher(executor, DebuggerControl.NONE, GcTrigger.DEFAULT, dumper,
+        new TestListener(), NO_REF);
+  }
 }
diff --git a/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ExcludedRefs.java b/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
deleted file mode 100644
index a5b25272..00000000
--- a/library/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-
-/**
- * Prevents specific references from being taken into account when computing the shortest strong
- * reference path from a suspected leaking instance to the GC roots.
- *
- * This class lets you ignore known memory leaks that you known about. If the shortest path
- * matches {@link ExcludedRefs}, than the {@link HeapAnalyzer} looks for a longer path with nothing
- * matching in {@link ExcludedRefs}.
- */
-public final class ExcludedRefs {
-
-  final Map<String, Set<String>> excludeFieldMap = new LinkedHashMap<>();
-  final Map<String, Set<String>> excludeStaticFieldMap = new LinkedHashMap<>();
-  final Set<String> excludedThreads = new LinkedHashSet<>();
-
-  public void instanceField(String className, String fieldName) {
-    checkNotNull(className, "className");
-    checkNotNull(fieldName, "fieldName");
-    Set<String> excludedFields = excludeFieldMap.get(className);
-    if (excludedFields == null) {
-      excludedFields = new LinkedHashSet<>();
-      excludeFieldMap.put(className, excludedFields);
-    }
-    excludedFields.add(fieldName);
-  }
-
-  public void staticField(String className, String fieldName) {
-    checkNotNull(className, "className");
-    checkNotNull(fieldName, "fieldName");
-    Set<String> excludedFields = excludeStaticFieldMap.get(className);
-    if (excludedFields == null) {
-      excludedFields = new LinkedHashSet<>();
-      excludeStaticFieldMap.put(className, excludedFields);
-    }
-    excludedFields.add(fieldName);
-  }
-
-  public void thread(String threadName) {
-    checkNotNull(threadName, "threadName");
-    excludedThreads.add(threadName);
-  }
-}
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java b/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
deleted file mode 100644
index dc72cd3f..00000000
--- a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
+++ /dev/null
@@ -1,237 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import static android.os.Build.MANUFACTURER;
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH;
-import static android.os.Build.VERSION_CODES.JELLY_BEAN;
-import static android.os.Build.VERSION_CODES.KITKAT;
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
-import static com.squareup.leakcanary.AndroidWatchExecutor.LEAK_CANARY_THREAD_NAME;
-
-/**
- * This class is a work in progress. You can help by reporting leak traces that seem to be caused
- * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
- *
- * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
- * manufacturer implementation, they usually share their builds across multiple models, and the
- * leaks eventually get fixed in newer versions.
- */
-public final class AndroidExcludedRefs {
-
-  private static final String SAMSUNG = "samsung";
-  private static final String MOTOROLA = "motorola";
-  private static final String LG = "LGE";
-  private static final String NVIDIA = "NVIDIA";
-
-  // SDK INT for API 22.
-  private static final int LOLLIPOP_MR1 = 22;
-
-  /**
-   * This returns the references in the leak path that should be ignored by all on Android.
-   */
-  public static ExcludedRefs createAndroidDefaults() {
-    ExcludedRefs excluded = new ExcludedRefs();
-    // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
-    // reference to the object and it was about to be GCed.
-    excluded.thread("FinalizerWatchdogDaemon");
-
-    // The main thread stack is ever changing so local variables aren't likely to hold references
-    // for long. If this is on the shortest path, it's probably that there's a longer path with
-    // a real leak.
-    excluded.thread("main");
-
-    excluded.thread(LEAK_CANARY_THREAD_NAME);
-    return excluded;
-  }
-
-  /**
-   * This returns the references in the leak path that can be ignored for app developers. This
-   * doesn't mean there is no memory leak, to the contrary. However, some leaks are caused by bugs
-   * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
-   * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
-   */
-  public static ExcludedRefs createAppDefaults() {
-    ExcludedRefs excluded = createAndroidDefaults();
-    if (SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-      // Android AOSP sometimes keeps a reference to a destroyed activity as a "nextIdle" client
-      // record in the android.app.ActivityThread.mActivities map.
-      // Not sure what's going on there, input welcome.
-      excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle");
-    }
-
-    if (SDK_INT <= KITKAT) {
-      // Editor inserts a special span, which has a reference to the EditText. That span is a
-      // NoCopySpan, which makes sure it gets dropped when creating a new SpannableStringBuilder
-      // from a given CharSequence.
-      // TextView.onSaveInstanceState() does a copy of its mText before saving it in the bundle.
-      // Prior to KitKat, that copy was done using the SpannableString constructor, instead of
-      // SpannableStringBuilder. The SpannableString constructor does not drop NoCopySpan spans.
-      // So we end up with a saved state that holds a reference to the textview and therefore the
-      // entire view hierarchy & activity context.
-      // Fix: https://github.com/android/platform_frameworks_base/commit
-      // /af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b
-
-      // Hack: to fix this, you could override TextView.onSaveInstanceState(), and then use
-      // reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.
-      excluded.instanceField("android.widget.Editor$EasyEditSpanController", "this$0");
-      excluded.instanceField("android.widget.Editor$SpanController", "this$0");
-    }
-
-    if (SDK_INT == LOLLIPOP) {
-      // MediaSessionLegacyHelper is a static singleton that is lazily instantiated and keeps a
-      // reference to the context it's given the first time MediaSessionLegacyHelper.getHelper()
-      // is called.
-      // This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by calling
-      // context.getApplicationContext().
-      // Fix: https://github.com/android/platform_frameworks_base/commit
-      // /9b5257c9c99c4cb541d8e8e78fb04f008b1a9091
-
-      // Hack: to fix this, you could call MediaSessionLegacyHelper.getHelper() early in
-      // Application.onCreate() and pass it the application context.
-      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance");
-    }
-
-    if (SDK_INT < LOLLIPOP_MR1) {
-      // TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had at least two
-      // bugs that created memory leaks by not correctly clearing the recycled TextLine instances.
-      // The first was fixed in android-5.1.0_r1:
-      // https://github.com/android/platform_frameworks_base/commit
-      // /893d6fe48d37f71e683f722457bea646994a10bf
-
-      // The second was fixed, not released yet:
-      // https://github.com/android/platform_frameworks_base/commit
-      // /b3a9bc038d3a218b1dbdf7b5668e3d6c12be5ee4
-
-      // Hack: to fix this, you could access TextLine.sCached and clear the pool every now and then
-      // (e.g. on activity destroy).
-      excluded.staticField("android.text.TextLine", "sCached");
-    }
-
-    if (SDK_INT < LOLLIPOP) {
-      // Prior to ART, a thread waiting on a blocking queue will leak the last dequeued object
-      // as a stack local reference.
-      // So when a HandlerThread becomes idle, it keeps a local reference to the last message it
-      // received. That message then gets recycled and can be used again.
-      // As long as all messages are recycled after being used, this won't be a problem, because
-      // there references are cleared when being recycled.
-      // However, dialogs create template Message instances to be copied when a message needs to be
-      // sent. These Message templates holds references to the dialog listeners, which most likely
-      // leads to holding a reference onto the activity in some way. Dialogs never recycle their
-      // template Message, assuming these Message instances will get GCed when the dialog is GCed.
-      // The combination of these two things creates a high potential for memory leaks as soon
-      // as you use dialogs. These memory leaks might be temporary, but some handler threads sleep
-      // for a long time.
-
-      // Hack: to fix this, you could post empty messages to the idle handler threads from time to
-      // time. This won't be easy because you cannot access all handler threads, but a library
-      // that is widely used should consider doing this for its own handler threads.
-      excluded.instanceField("android.os.Message", "obj");
-      excluded.instanceField("android.os.Message", "next");
-      excluded.instanceField("android.os.Message", "target");
-    }
-
-    if (SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP_MR1) {
-      // When we detach a view that receives keyboard input, the InputMethodManager leaks a
-      // reference to it until a new view asks for keyboard input.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=171190
-      // Hack: https://gist.github.com/pyricau/4df64341cc978a7de414
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView");
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView");
-      excluded.instanceField("android.view.inputmethod.InputMethodManager",
-          "mServedInputConnection");
-    }
-
-    if (SDK_INT >= LOLLIPOP && SDK_INT <= LOLLIPOP_MR1) {
-      // The singleton InputMethodManager is holding a reference to mCurRootView long after the
-      // activity has been destroyed.
-      // Hack: https://gist.github.com/pyricau/4df64341cc978a7de414
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView");
-    }
-
-    if (SDK_INT >= ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
-      // LayoutTransition leaks parent ViewGroup through ViewTreeObserver.OnPreDrawListener
-      // When triggered, this leaks stays until the window is destroyed.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=171830
-      excluded.instanceField("android.animation.LayoutTransition$1", "val$parent");
-    }
-
-    if (MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-      // DevicePolicyManager keeps a reference to the context it has been created with instead of
-      // extracting the application context. In this Motorola build, DevicePolicyManager has an
-      // inner SettingsObserver class that is a content observer, which is held into memory
-      // by a binder transport object.
-      excluded.instanceField("android.app.admin.DevicePolicyManager$SettingsObserver", "this$0");
-    }
-
-    if (SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-      // SpenGestureManager has a static mContext field that leaks a reference to the activity.
-      // Yes, a STATIC "mContext" field.
-      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext");
-    }
-
-    if (SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-      // ClipboardUIManager is a static singleton that leaks an activity context.
-      excluded.staticField("android.sec.clipboard.ClipboardUIManager", "sInstance");
-    }
-
-    if (LG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-      // A static helper for EditText "bubble popups" leaks a reference to the latest focused view.
-      excluded.staticField("android.widget.BubblePopupHelper", "sHelper");
-    }
-
-    if (SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-      // AwResource#setResources() is called with resources that hold a reference to the
-      // activity context (instead of the application context) and doesn't clear it.
-      // Not sure what's going on there, input welcome.
-      excluded.staticField("com.android.org.chromium.android_webview.AwResource", "sResources");
-    }
-
-    if (NVIDIA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-      // Not sure exactly what ControllerMapper is about, but there is an anonymous Handler in
-      // ControllerMapper.MapperClient.ServiceClient, which leaks ControllerMapper.MapperClient
-      // which leaks the activity context.
-      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient$ServiceClient", "this$0");
-    }
-
-    if (SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-      // mLastHoveredView is a static field in TextView that leaks the last hovered view.
-      excluded.staticField("android.widget.TextView", "mLastHoveredView");
-    }
-
-    if (MOTOROLA.equals(MANUFACTURER) && SDK_INT == JELLY_BEAN) {
-      // android.view.textservice.SpellCheckerSession$SpellCheckerSessionListenerImpl.mHandler is
-      // a GC root, it's an inner class that references SpellCheckerSession which itself references
-      // a SpellChecker through SpellCheckerSession.mSpellCheckerSessionListener.
-      excluded.instanceField("android.view.textservice.SpellCheckerSession",
-          "mSpellCheckerSessionListener");
-    }
-
-    if (SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-      // android.app.LoadedApk.mResources has a reference to
-      // android.content.res.Resources.mPersonaManager which has a reference to
-      // android.os.PersonaManager.mContext which is an activity.
-      excluded.instanceField("android.os.PersonaManager", "mContext");
-    }
-
-    return excluded;
-  }
-
-  private AndroidExcludedRefs() {
-    throw new AssertionError();
-  }
-}
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java b/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
deleted file mode 100644
index f6e7f7d8..00000000
--- a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.content.Context;
-import android.os.Debug;
-import android.util.Log;
-import java.io.File;
-import java.io.IOException;
-
-public final class AndroidHeapDumper implements HeapDumper {
-
-  private final File heapDumpFile;
-
-  public AndroidHeapDumper(Context context) {
-    heapDumpFile = new File(context.getFilesDir(), "suspected_leak_heapdump.hprof");
-  }
-
-  @Override public File dumpHeap() {
-    if (heapDumpFile.exists()) {
-      Log.d("AndroidHeapDumper", "Could not dump heap, previous analysis still is in progress.");
-      // Heap analysis in progress, let's not put to much pressure on the device.
-      return null;
-    }
-    try {
-      Debug.dumpHprofData(heapDumpFile.getAbsolutePath());
-      return heapDumpFile;
-    } catch (IOException e) {
-      cleanup();
-      Log.e("AndroidHeapDumper", "Could not perform heap dump", e);
-      // Abort heap dump
-      return null;
-    }
-  }
-
-  /**
-   * Call this on app startup to clean up all heap dump files that had not been handled yet when
-   * the app process was killed.
-   */
-  public void cleanup() {
-    if (heapDumpFile.exists()) {
-      Log.d("AndroidHeapDumper",
-          "Previous analysis did not complete correctly, cleaning: " + heapDumpFile);
-      heapDumpFile.delete();
-    }
-  }
-}
diff --git a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java b/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
deleted file mode 100644
index e9e80017..00000000
--- a/library/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.Context;
-import android.content.res.Resources;
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.Paint;
-import android.graphics.PorterDuffXfermode;
-import android.util.AttributeSet;
-import android.util.DisplayMetrics;
-import android.view.View;
-
-import static android.graphics.Bitmap.Config.ARGB_8888;
-import static android.graphics.PorterDuff.Mode.CLEAR;
-import static com.squareup.leakcanary.internal.DisplayLeakConnectorView.Type.NODE;
-import static com.squareup.leakcanary.internal.DisplayLeakConnectorView.Type.START;
-
-public final class DisplayLeakConnectorView extends View {
-
-  static final int LIGHT_GREY = 0xFFbababa;
-  static final int ROOT_COLOR = 0xFF84a6c5;
-  static final int LEAK_COLOR = 0xFFb1554e;
-
-  public enum Type {
-    START, NODE, END
-  }
-
-  private final Paint iconPaint;
-  private final Paint clearPaint;
-  private final Paint rootPaint;
-  private final Paint leakPaint;
-  private final float strokeSize;
-
-  private Type type;
-  private Bitmap cache;
-
-  public DisplayLeakConnectorView(Context context, AttributeSet attrs) {
-    super(context, attrs);
-
-    iconPaint = new Paint();
-    iconPaint.setColor(LIGHT_GREY);
-    strokeSize = dpToPixel(4, getResources());
-    iconPaint.setStrokeWidth(strokeSize);
-    iconPaint.setAntiAlias(true);
-
-    clearPaint = new Paint();
-    clearPaint.setColor(0);
-    clearPaint.setXfermode(new PorterDuffXfermode(CLEAR));
-    clearPaint.setAntiAlias(true);
-
-    rootPaint = new Paint();
-    rootPaint.setColor(ROOT_COLOR);
-    rootPaint.setAntiAlias(true);
-    rootPaint.setStrokeWidth(strokeSize);
-
-    leakPaint = new Paint();
-    leakPaint.setColor(LEAK_COLOR);
-    leakPaint.setAntiAlias(true);
-    type = NODE;
-  }
-
-  @SuppressWarnings("SuspiciousNameCombination") @Override protected void onDraw(Canvas canvas) {
-    int width = getWidth();
-    int height = getHeight();
-
-    if (cache != null && (cache.getWidth() != width || cache.getHeight() != height)) {
-      cache.recycle();
-      cache = null;
-    }
-
-    if (cache == null) {
-      cache = Bitmap.createBitmap(width, height, ARGB_8888);
-
-      Canvas cacheCanvas = new Canvas(cache);
-
-      float halfWidth = width / 2f;
-      float halfHeight = height / 2f;
-      float thirdWidth = width / 3;
-
-      if (type == NODE) {
-        cacheCanvas.drawLine(halfWidth, 0, halfWidth, height, iconPaint);
-        cacheCanvas.drawCircle(halfWidth, halfHeight, halfWidth, iconPaint);
-        cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, clearPaint);
-      } else if (type == START) {
-        float radiusClear = halfWidth - strokeSize / 2;
-        cacheCanvas.drawRect(0, 0, width, radiusClear, rootPaint);
-        cacheCanvas.drawCircle(0, radiusClear, radiusClear, clearPaint);
-        cacheCanvas.drawCircle(width, radiusClear, radiusClear, clearPaint);
-        cacheCanvas.drawLine(halfWidth, 0, halfWidth, halfHeight, rootPaint);
-        cacheCanvas.drawLine(halfWidth, halfHeight, halfWidth, height, iconPaint);
-        cacheCanvas.drawCircle(halfWidth, halfHeight, halfWidth, iconPaint);
-        cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, clearPaint);
-      } else {
-        cacheCanvas.drawLine(halfWidth, 0, halfWidth, halfHeight, iconPaint);
-        cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, leakPaint);
-      }
-    }
-    canvas.drawBitmap(cache, 0, 0, null);
-  }
-
-  public void setType(Type type) {
-    if (type != this.type) {
-      this.type = type;
-      if (cache != null) {
-        cache.recycle();
-        cache = null;
-      }
-      invalidate();
-    }
-  }
-
-  static float dpToPixel(float dp, Resources resources) {
-    DisplayMetrics metrics = resources.getDisplayMetrics();
-    float px = dp * (metrics.densityDpi / 160f);
-    return px;
-  }
-}
diff --git a/library/leakcanary-android/src/main/res/drawable-hdpi-v11/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-hdpi-v11/__leak_canary_notification.png
deleted file mode 100755
index ca53e710..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-hdpi-v11/__leak_canary_notification.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_icon.png b/library/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_icon.png
deleted file mode 100755
index 69911f30..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_icon.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_notification.png
deleted file mode 100755
index 86841e4e..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-hdpi/__leak_canary_notification.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-mdpi-v11/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-mdpi-v11/__leak_canary_notification.png
deleted file mode 100755
index dc71e62b..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-mdpi-v11/__leak_canary_notification.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_icon.png b/library/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_icon.png
deleted file mode 100755
index e6c8e1f2..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_icon.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_notification.png
deleted file mode 100755
index 98a55ee4..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-mdpi/__leak_canary_notification.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-xhdpi-v11/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-xhdpi-v11/__leak_canary_notification.png
deleted file mode 100755
index e8e7421f..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-xhdpi-v11/__leak_canary_notification.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_icon.png b/library/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_icon.png
deleted file mode 100755
index 9d3bb119..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_icon.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_notification.png
deleted file mode 100755
index 594ed22a..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-xhdpi/__leak_canary_notification.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-xxhdpi-v11/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-xxhdpi-v11/__leak_canary_notification.png
deleted file mode 100755
index 1aac2c0c..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-xxhdpi-v11/__leak_canary_notification.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_icon.png b/library/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_icon.png
deleted file mode 100755
index 7072b8ec..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_icon.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_notification.png
deleted file mode 100755
index b11f1547..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-xxhdpi/__leak_canary_notification.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/__leak_canary_notification.png
deleted file mode 100755
index 3aaa2a5b..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/__leak_canary_notification.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_icon.png b/library/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_icon.png
deleted file mode 100755
index c72d0d84..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_icon.png and /dev/null differ
diff --git a/library/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_notification.png b/library/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_notification.png
deleted file mode 100755
index 41eae0d3..00000000
Binary files a/library/leakcanary-android/src/main/res/drawable-xxxhdpi/__leak_canary_notification.png and /dev/null differ
diff --git a/library/settings.gradle b/settings.gradle
similarity index 100%
rename from library/settings.gradle
rename to settings.gradle
