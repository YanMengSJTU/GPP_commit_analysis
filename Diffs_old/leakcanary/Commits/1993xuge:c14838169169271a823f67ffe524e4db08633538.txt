diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
index a5093898..177c1caa 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
@@ -30,6 +30,7 @@
 import com.squareup.haha.perflib.io.MemoryMappedFileBuffer;
 import gnu.trove.THashMap;
 import gnu.trove.TObjectProcedure;
+
 import java.io.File;
 import java.lang.reflect.Constructor;
 import java.util.ArrayList;
@@ -75,439 +76,462 @@
  */
 public final class HeapAnalyzer {
 
-  private static final String ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$";
-
-  private final ExcludedRefs excludedRefs;
-  private final AnalyzerProgressListener listener;
-  private final List<Reachability.Inspector> reachabilityInspectors;
-
-  /**
-   * @deprecated Use {@link #HeapAnalyzer(ExcludedRefs, AnalyzerProgressListener, List)}.
-   */
-  @Deprecated
-  public HeapAnalyzer(@NonNull ExcludedRefs excludedRefs) {
-    this(excludedRefs, AnalyzerProgressListener.NONE,
-        Collections.<Class<? extends Reachability.Inspector>>emptyList());
-  }
-
-  public HeapAnalyzer(@NonNull ExcludedRefs excludedRefs,
-      @NonNull AnalyzerProgressListener listener,
-      @NonNull List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses) {
-    this.excludedRefs = excludedRefs;
-    this.listener = listener;
-
-    this.reachabilityInspectors = new ArrayList<>();
-    for (Class<? extends Reachability.Inspector> reachabilityInspectorClass
-        : reachabilityInspectorClasses) {
-      try {
-        Constructor<? extends Reachability.Inspector> defaultConstructor =
-            reachabilityInspectorClass.getDeclaredConstructor();
-        reachabilityInspectors.add(defaultConstructor.newInstance());
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
+    private static final String ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$";
+
+    private final ExcludedRefs excludedRefs;
+    private final AnalyzerProgressListener listener;
+    private final List<Reachability.Inspector> reachabilityInspectors;
+
+    /**
+     * @deprecated Use {@link #HeapAnalyzer(ExcludedRefs, AnalyzerProgressListener, List)}.
+     */
+    @Deprecated
+    public HeapAnalyzer(@NonNull ExcludedRefs excludedRefs) {
+        this(excludedRefs, AnalyzerProgressListener.NONE,
+                Collections.<Class<? extends Reachability.Inspector>>emptyList());
     }
-  }
 
-  public @NonNull List<TrackedReference> findTrackedReferences(@NonNull File heapDumpFile) {
-    if (!heapDumpFile.exists()) {
-      throw new IllegalArgumentException("File does not exist: " + heapDumpFile);
+    public HeapAnalyzer(@NonNull ExcludedRefs excludedRefs,
+                        @NonNull AnalyzerProgressListener listener,
+                        @NonNull List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses) {
+        this.excludedRefs = excludedRefs;
+        this.listener = listener;
+
+        this.reachabilityInspectors = new ArrayList<>();
+        for (Class<? extends Reachability.Inspector> reachabilityInspectorClass
+                : reachabilityInspectorClasses) {
+            try {
+                Constructor<? extends Reachability.Inspector> defaultConstructor =
+                        reachabilityInspectorClass.getDeclaredConstructor();
+                reachabilityInspectors.add(defaultConstructor.newInstance());
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
+        }
     }
-    try {
-      HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
-      HprofParser parser = new HprofParser(buffer);
-      Snapshot snapshot = parser.parse();
-      deduplicateGcRoots(snapshot);
-
-      ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());
-      List<TrackedReference> references = new ArrayList<>();
-      for (Instance weakRef : refClass.getInstancesList()) {
-        List<ClassInstance.FieldValue> values = classInstanceValues(weakRef);
-        String key = asString(fieldValue(values, "key"));
-        String name =
-            hasField(values, "name") ? asString(fieldValue(values, "name")) : "(No name field)";
-        Instance instance = fieldValue(values, "referent");
-        if (instance != null) {
-          String className = getClassName(instance);
-          List<LeakReference> fields = describeFields(instance);
-          references.add(new TrackedReference(key, name, className, fields));
+
+    public @NonNull
+    List<TrackedReference> findTrackedReferences(@NonNull File heapDumpFile) {
+        if (!heapDumpFile.exists()) {
+            throw new IllegalArgumentException("File does not exist: " + heapDumpFile);
+        }
+        try {
+            HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
+            HprofParser parser = new HprofParser(buffer);
+            Snapshot snapshot = parser.parse();
+            deduplicateGcRoots(snapshot);
+
+            ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());
+            List<TrackedReference> references = new ArrayList<>();
+            for (Instance weakRef : refClass.getInstancesList()) {
+                List<ClassInstance.FieldValue> values = classInstanceValues(weakRef);
+                String key = asString(fieldValue(values, "key"));
+                String name =
+                        hasField(values, "name") ? asString(fieldValue(values, "name")) : "(No name field)";
+                Instance instance = fieldValue(values, "referent");
+                if (instance != null) {
+                    String className = getClassName(instance);
+                    List<LeakReference> fields = describeFields(instance);
+                    references.add(new TrackedReference(key, name, className, fields));
+                }
+            }
+            return references;
+        } catch (Throwable e) {
+            throw new RuntimeException(e);
         }
-      }
-      return references;
-    } catch (Throwable e) {
-      throw new RuntimeException(e);
     }
-  }
-
-  /**
-   * Calls {@link #checkForLeak(File, String, boolean)} with computeRetainedSize set to true.
-   *
-   * @deprecated Use {@link #checkForLeak(File, String, boolean)} instead.
-   */
-  @Deprecated
-  public @NonNull AnalysisResult checkForLeak(@NonNull File heapDumpFile,
-      @NonNull String referenceKey) {
-    return checkForLeak(heapDumpFile, referenceKey, true);
-  }
-
-  /**
-   * Searches the heap dump for a {@link KeyedWeakReference} instance with the corresponding key,
-   * and then computes the shortest strong reference path from that instance to the GC roots.
-   */
-  public @NonNull AnalysisResult checkForLeak(@NonNull File heapDumpFile,
-      @NonNull String referenceKey,
-      boolean computeRetainedSize) {
-    long analysisStartNanoTime = System.nanoTime();
-
-    if (!heapDumpFile.exists()) {
-      Exception exception = new IllegalArgumentException("File does not exist: " + heapDumpFile);
-      return failure(exception, since(analysisStartNanoTime));
+
+    /**
+     * Calls {@link #checkForLeak(File, String, boolean)} with computeRetainedSize set to true.
+     *
+     * @deprecated Use {@link #checkForLeak(File, String, boolean)} instead.
+     */
+    @Deprecated
+    public @NonNull
+    AnalysisResult checkForLeak(@NonNull File heapDumpFile,
+                                @NonNull String referenceKey) {
+        return checkForLeak(heapDumpFile, referenceKey, true);
     }
 
-    try {
-      listener.onProgressUpdate(READING_HEAP_DUMP_FILE);
-      HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
-      HprofParser parser = new HprofParser(buffer);
-      listener.onProgressUpdate(PARSING_HEAP_DUMP);
-      Snapshot snapshot = parser.parse();
-      listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS);
-      deduplicateGcRoots(snapshot);
-      listener.onProgressUpdate(FINDING_LEAKING_REF);
-      Instance leakingRef = findLeakingReference(referenceKey, snapshot);
-
-      // False alarm, weak reference was cleared in between key check and heap dump.
-      if (leakingRef == null) {
-        return noLeak(since(analysisStartNanoTime));
-      }
-      return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, computeRetainedSize);
-    } catch (Throwable e) {
-      return failure(e, since(analysisStartNanoTime));
+    /**
+     * Searches the heap dump for a {@link KeyedWeakReference} instance with the corresponding key,
+     * and then computes the shortest strong reference path from that instance to the GC roots.
+     * 进一步 分析内存泄露，将 heapDumpFile文件解析成 便于理解的形式
+     */
+    public @NonNull
+    AnalysisResult checkForLeak(@NonNull File heapDumpFile,
+                                @NonNull String referenceKey,
+                                boolean computeRetainedSize) {
+        long analysisStartNanoTime = System.nanoTime();
+
+        if (!heapDumpFile.exists()) {
+            // 如果 dump的heap内存快照信息不存在，则分析失败
+            Exception exception = new IllegalArgumentException("File does not exist: " + heapDumpFile);
+            return failure(exception, since(analysisStartNanoTime));
+        }
+
+        try {
+            listener.onProgressUpdate(READING_HEAP_DUMP_FILE);
+            // 将 heapDumpFile文件封装成 MemoryMappedFileBuffer 对象
+            HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
+            // 创建解析器对象，解析MemoryMappedFileBuffer对象
+            HprofParser parser = new HprofParser(buffer);
+            listener.onProgressUpdate(PARSING_HEAP_DUMP);
+            // 执行 解析操作
+            Snapshot snapshot = parser.parse();
+            listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS);
+            //  对 分析的结果进行去重
+            deduplicateGcRoots(snapshot);
+            listener.onProgressUpdate(FINDING_LEAKING_REF);
+            // 根据需要检测类的key 去查询解析结果中，是否存在 需要的对象
+            Instance leakingRef = findLeakingReference(referenceKey, snapshot);
+
+            // False alarm, weak reference was cleared in between key check and heap dump.
+            if (leakingRef == null) {
+                // 结果是null，那么不存在 内存泄漏
+                return noLeak(since(analysisStartNanoTime));
+            }
+            // 存在内存泄漏，把内存泄漏的路径显示出来
+            return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, computeRetainedSize);
+        } catch (Throwable e) {
+            return failure(e, since(analysisStartNanoTime));
+        }
     }
-  }
-
-  /**
-   * Pruning duplicates reduces memory pressure from hprof bloat added in Marshmallow.
-   */
-  void deduplicateGcRoots(Snapshot snapshot) {
-    // THashMap has a smaller memory footprint than HashMap.
-    final THashMap<String, RootObj> uniqueRootMap = new THashMap<>();
-
-    final Collection<RootObj> gcRoots = snapshot.getGCRoots();
-    for (RootObj root : gcRoots) {
-      String key = generateRootKey(root);
-      if (!uniqueRootMap.containsKey(key)) {
-        uniqueRootMap.put(key, root);
-      }
+
+    /**
+     * Pruning duplicates reduces memory pressure from hprof bloat added in Marshmallow.
+     */
+    void deduplicateGcRoots(Snapshot snapshot) {
+        // THashMap has a smaller memory footprint than HashMap.
+        final THashMap<String, RootObj> uniqueRootMap = new THashMap<>();
+
+        final Collection<RootObj> gcRoots = snapshot.getGCRoots();
+        for (RootObj root : gcRoots) {
+            String key = generateRootKey(root);
+            if (!uniqueRootMap.containsKey(key)) {
+                uniqueRootMap.put(key, root);
+            }
+        }
+
+        // Repopulate snapshot with unique GC roots.
+        gcRoots.clear();
+        uniqueRootMap.forEach(new TObjectProcedure<String>() {
+            @Override
+            public boolean execute(String key) {
+                return gcRoots.add(uniqueRootMap.get(key));
+            }
+        });
     }
 
-    // Repopulate snapshot with unique GC roots.
-    gcRoots.clear();
-    uniqueRootMap.forEach(new TObjectProcedure<String>() {
-      @Override public boolean execute(String key) {
-        return gcRoots.add(uniqueRootMap.get(key));
-      }
-    });
-  }
-
-  private String generateRootKey(RootObj root) {
-    return String.format("%s@0x%08x", root.getRootType().getName(), root.getId());
-  }
-
-  private Instance findLeakingReference(String key, Snapshot snapshot) {
-    ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());
-    if (refClass == null) {
-      throw new IllegalStateException(
-          "Could not find the " + KeyedWeakReference.class.getName() + " class in the heap dump.");
+    private String generateRootKey(RootObj root) {
+        return String.format("%s@0x%08x", root.getRootType().getName(), root.getId());
     }
-    List<String> keysFound = new ArrayList<>();
-    for (Instance instance : refClass.getInstancesList()) {
-      List<ClassInstance.FieldValue> values = classInstanceValues(instance);
-      Object keyFieldValue = fieldValue(values, "key");
-      if (keyFieldValue == null) {
-        keysFound.add(null);
-        continue;
-      }
-      String keyCandidate = asString(keyFieldValue);
-      if (keyCandidate.equals(key)) {
-        return fieldValue(values, "referent");
-      }
-      keysFound.add(keyCandidate);
+
+    private Instance findLeakingReference(String key, Snapshot snapshot) {
+        // 通过 弱引用的class名称 查找 被监测对象
+        ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());
+        if (refClass == null) {
+            throw new IllegalStateException(
+                    "Could not find the " + KeyedWeakReference.class.getName() + " class in the heap dump.");
+        }
+
+        // 遍历
+        List<String> keysFound = new ArrayList<>();
+        for (Instance instance : refClass.getInstancesList()) {
+            List<ClassInstance.FieldValue> values = classInstanceValues(instance);
+            Object keyFieldValue = fieldValue(values, "key");
+            if (keyFieldValue == null) {
+                keysFound.add(null);
+                continue;
+            }
+            String keyCandidate = asString(keyFieldValue);
+            if (keyCandidate.equals(key)) {
+                // 找到了 监测对象
+                return fieldValue(values, "referent");
+            }
+            keysFound.add(keyCandidate);
+        }
+        throw new IllegalStateException(
+                "Could not find weak reference with key " + key + " in " + keysFound);
     }
-    throw new IllegalStateException(
-        "Could not find weak reference with key " + key + " in " + keysFound);
-  }
 
-  private AnalysisResult findLeakTrace(long analysisStartNanoTime, Snapshot snapshot,
-      Instance leakingRef, boolean computeRetainedSize) {
+    private AnalysisResult findLeakTrace(long analysisStartNanoTime, Snapshot snapshot,
+                                         Instance leakingRef, boolean computeRetainedSize) {
 
-    listener.onProgressUpdate(FINDING_SHORTEST_PATH);
-    ShortestPathFinder pathFinder = new ShortestPathFinder(excludedRefs);
-    ShortestPathFinder.Result result = pathFinder.findPath(snapshot, leakingRef);
+        listener.onProgressUpdate(FINDING_SHORTEST_PATH);
+        // 通过 分析 hprof文件 ，然后找到 内存泄漏的点
+        //
+        ShortestPathFinder pathFinder = new ShortestPathFinder(excludedRefs);
+        ShortestPathFinder.Result result = pathFinder.findPath(snapshot, leakingRef);
 
-    // False alarm, no strong reference path to GC Roots.
-    if (result.leakingNode == null) {
-      return noLeak(since(analysisStartNanoTime));
-    }
+        // False alarm, no strong reference path to GC Roots.
+        if (result.leakingNode == null) {
+            // 没有 找到 gcroot的判断
+            return noLeak(since(analysisStartNanoTime));
+        }
 
-    listener.onProgressUpdate(BUILDING_LEAK_TRACE);
-    LeakTrace leakTrace = buildLeakTrace(result.leakingNode);
+        listener.onProgressUpdate(BUILDING_LEAK_TRACE);
 
-    String className = leakingRef.getClassObj().getClassName();
+        // 生成 内存泄漏的调用栈
+        LeakTrace leakTrace = buildLeakTrace(result.leakingNode);
 
-    long retainedSize;
-    if (computeRetainedSize) {
+        String className = leakingRef.getClassObj().getClassName();
 
-      listener.onProgressUpdate(COMPUTING_DOMINATORS);
-      // Side effect: computes retained size.
-      snapshot.computeDominators();
+        long retainedSize;
+        if (computeRetainedSize) {
 
-      Instance leakingInstance = result.leakingNode.instance;
+            listener.onProgressUpdate(COMPUTING_DOMINATORS);
+            // Side effect: computes retained size.
+            snapshot.computeDominators();
 
-      retainedSize = leakingInstance.getTotalRetainedSize();
+            Instance leakingInstance = result.leakingNode.instance;
 
-      // TODO: check O sources and see what happened to android.graphics.Bitmap.mBuffer
-      if (SDK_INT <= N_MR1) {
-        listener.onProgressUpdate(COMPUTING_BITMAP_SIZE);
-        retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance);
-      }
-    } else {
-      retainedSize = AnalysisResult.RETAINED_HEAP_SKIPPED;
-    }
+            // 计算 内存泄漏大小的方法
+            retainedSize = leakingInstance.getTotalRetainedSize();
 
-    return leakDetected(result.excludingKnownLeaks, className, leakTrace, retainedSize,
-        since(analysisStartNanoTime));
-  }
-
-  /**
-   * Bitmaps and bitmap byte arrays are sometimes held by native gc roots, so they aren't included
-   * in the retained size because their root dominator is a native gc root.
-   * To fix this, we check if the leaking instance is a dominator for each bitmap instance and then
-   * add the bitmap size.
-   *
-   * From experience, we've found that bitmap created in code (Bitmap.createBitmap()) are correctly
-   * accounted for, however bitmaps set in layouts are not.
-   */
-  private long computeIgnoredBitmapRetainedSize(Snapshot snapshot, Instance leakingInstance) {
-    long bitmapRetainedSize = 0;
-    ClassObj bitmapClass = snapshot.findClass("android.graphics.Bitmap");
-
-    for (Instance bitmapInstance : bitmapClass.getInstancesList()) {
-      if (isIgnoredDominator(leakingInstance, bitmapInstance)) {
-        ArrayInstance mBufferInstance = fieldValue(classInstanceValues(bitmapInstance), "mBuffer");
-        // Native bitmaps have mBuffer set to null. We sadly can't account for them.
-        if (mBufferInstance == null) {
-          continue;
-        }
-        long bufferSize = mBufferInstance.getTotalRetainedSize();
-        long bitmapSize = bitmapInstance.getTotalRetainedSize();
-        // Sometimes the size of the buffer isn't accounted for in the bitmap retained size. Since
-        // the buffer is large, it's easy to detect by checking for bitmap size < buffer size.
-        if (bitmapSize < bufferSize) {
-          bitmapSize += bufferSize;
+            // TODO: check O sources and see what happened to android.graphics.Bitmap.mBuffer
+            if (SDK_INT <= N_MR1) {
+                listener.onProgressUpdate(COMPUTING_BITMAP_SIZE);
+                retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance);
+            }
+        } else {
+            retainedSize = AnalysisResult.RETAINED_HEAP_SKIPPED;
         }
-        bitmapRetainedSize += bitmapSize;
-      }
-    }
-    return bitmapRetainedSize;
-  }
-
-  private boolean isIgnoredDominator(Instance dominator, Instance instance) {
-    boolean foundNativeRoot = false;
-    while (true) {
-      Instance immediateDominator = instance.getImmediateDominator();
-      if (immediateDominator instanceof RootObj
-          && ((RootObj) immediateDominator).getRootType() == RootType.UNKNOWN) {
-        // Ignore native roots
-        instance = instance.getNextInstanceToGcRoot();
-        foundNativeRoot = true;
-      } else {
-        instance = immediateDominator;
-      }
-      if (instance == null) {
-        return false;
-      }
-      if (instance == dominator) {
-        return foundNativeRoot;
-      }
-    }
-  }
-
-  private LeakTrace buildLeakTrace(LeakNode leakingNode) {
-    List<LeakTraceElement> elements = new ArrayList<>();
-    // We iterate from the leak to the GC root
-    LeakNode node = new LeakNode(null, null, leakingNode, null);
-    while (node != null) {
-      LeakTraceElement element = buildLeakElement(node);
-      if (element != null) {
-        elements.add(0, element);
-      }
-      node = node.parent;
+
+        return leakDetected(result.excludingKnownLeaks, className, leakTrace, retainedSize,
+                since(analysisStartNanoTime));
     }
 
-    List<Reachability> expectedReachability =
-        computeExpectedReachability(elements);
-
-    return new LeakTrace(elements, expectedReachability);
-  }
-
-  private List<Reachability> computeExpectedReachability(
-      List<LeakTraceElement> elements) {
-    int lastReachableElement = 0;
-    int lastElementIndex = elements.size() - 1;
-    int firstUnreachableElement = lastElementIndex;
-    // No need to inspect the first and last element. We know the first should be reachable (gc
-    // root) and the last should be unreachable (watched instance).
-    elementLoop:
-    for (int i = 1; i < lastElementIndex; i++) {
-      LeakTraceElement element = elements.get(i);
-
-      for (Reachability.Inspector reachabilityInspector : reachabilityInspectors) {
-        Reachability reachability = reachabilityInspector.expectedReachability(element);
-        if (reachability == REACHABLE) {
-          lastReachableElement = i;
-          break;
-        } else if (reachability == UNREACHABLE) {
-          firstUnreachableElement = i;
-          break elementLoop;
+    /**
+     * Bitmaps and bitmap byte arrays are sometimes held by native gc roots, so they aren't included
+     * in the retained size because their root dominator is a native gc root.
+     * To fix this, we check if the leaking instance is a dominator for each bitmap instance and then
+     * add the bitmap size.
+     * <p>
+     * From experience, we've found that bitmap created in code (Bitmap.createBitmap()) are correctly
+     * accounted for, however bitmaps set in layouts are not.
+     */
+    private long computeIgnoredBitmapRetainedSize(Snapshot snapshot, Instance leakingInstance) {
+        long bitmapRetainedSize = 0;
+        ClassObj bitmapClass = snapshot.findClass("android.graphics.Bitmap");
+
+        for (Instance bitmapInstance : bitmapClass.getInstancesList()) {
+            if (isIgnoredDominator(leakingInstance, bitmapInstance)) {
+                ArrayInstance mBufferInstance = fieldValue(classInstanceValues(bitmapInstance), "mBuffer");
+                // Native bitmaps have mBuffer set to null. We sadly can't account for them.
+                if (mBufferInstance == null) {
+                    continue;
+                }
+                long bufferSize = mBufferInstance.getTotalRetainedSize();
+                long bitmapSize = bitmapInstance.getTotalRetainedSize();
+                // Sometimes the size of the buffer isn't accounted for in the bitmap retained size. Since
+                // the buffer is large, it's easy to detect by checking for bitmap size < buffer size.
+                if (bitmapSize < bufferSize) {
+                    bitmapSize += bufferSize;
+                }
+                bitmapRetainedSize += bitmapSize;
+            }
         }
-      }
+        return bitmapRetainedSize;
     }
 
-    List<Reachability> expectedReachability = new ArrayList<>();
-    for (int i = 0; i < elements.size(); i++) {
-      Reachability status;
-      if (i <= lastReachableElement) {
-        status = REACHABLE;
-      } else if (i >= firstUnreachableElement) {
-        status = UNREACHABLE;
-      } else {
-        status = UNKNOWN;
-      }
-      expectedReachability.add(status);
+    private boolean isIgnoredDominator(Instance dominator, Instance instance) {
+        boolean foundNativeRoot = false;
+        while (true) {
+            Instance immediateDominator = instance.getImmediateDominator();
+            if (immediateDominator instanceof RootObj
+                    && ((RootObj) immediateDominator).getRootType() == RootType.UNKNOWN) {
+                // Ignore native roots
+                instance = instance.getNextInstanceToGcRoot();
+                foundNativeRoot = true;
+            } else {
+                instance = immediateDominator;
+            }
+            if (instance == null) {
+                return false;
+            }
+            if (instance == dominator) {
+                return foundNativeRoot;
+            }
+        }
     }
-    return expectedReachability;
-  }
 
-  private LeakTraceElement buildLeakElement(LeakNode node) {
-    if (node.parent == null) {
-      // Ignore any root node.
-      return null;
-    }
-    Instance holder = node.parent.instance;
+    private LeakTrace buildLeakTrace(LeakNode leakingNode) {
+        List<LeakTraceElement> elements = new ArrayList<>();
+        // We iterate from the leak to the GC root
+        LeakNode node = new LeakNode(null, null, leakingNode, null);
+        while (node != null) {
+            LeakTraceElement element = buildLeakElement(node);
+            if (element != null) {
+                elements.add(0, element);
+            }
+            node = node.parent;
+        }
 
-    if (holder instanceof RootObj) {
-      return null;
-    }
-    LeakTraceElement.Holder holderType;
-    String className;
-    String extra = null;
-    List<LeakReference> leakReferences = describeFields(holder);
-
-    className = getClassName(holder);
-
-    List<String> classHierarchy = new ArrayList<>();
-    classHierarchy.add(className);
-    String rootClassName = Object.class.getName();
-    if (holder instanceof ClassInstance) {
-      ClassObj classObj = holder.getClassObj();
-      while (!(classObj = classObj.getSuperClassObj()).getClassName().equals(rootClassName)) {
-        classHierarchy.add(classObj.getClassName());
-      }
+        List<Reachability> expectedReachability =
+                computeExpectedReachability(elements);
+
+        return new LeakTrace(elements, expectedReachability);
     }
 
-    if (holder instanceof ClassObj) {
-      holderType = CLASS;
-    } else if (holder instanceof ArrayInstance) {
-      holderType = ARRAY;
-    } else {
-      ClassObj classObj = holder.getClassObj();
-      if (extendsThread(classObj)) {
-        holderType = THREAD;
-        String threadName = threadName(holder);
-        extra = "(named '" + threadName + "')";
-      } else if (className.matches(ANONYMOUS_CLASS_NAME_PATTERN)) {
-        String parentClassName = classObj.getSuperClassObj().getClassName();
-        if (rootClassName.equals(parentClassName)) {
-          holderType = OBJECT;
-          try {
-            // This is an anonymous class implementing an interface. The API does not give access
-            // to the interfaces implemented by the class. We check if it's in the class path and
-            // use that instead.
-            Class<?> actualClass = Class.forName(classObj.getClassName());
-            Class<?>[] interfaces = actualClass.getInterfaces();
-            if (interfaces.length > 0) {
-              Class<?> implementedInterface = interfaces[0];
-              extra = "(anonymous implementation of " + implementedInterface.getName() + ")";
+    private List<Reachability> computeExpectedReachability(
+            List<LeakTraceElement> elements) {
+        int lastReachableElement = 0;
+        int lastElementIndex = elements.size() - 1;
+        int firstUnreachableElement = lastElementIndex;
+        // No need to inspect the first and last element. We know the first should be reachable (gc
+        // root) and the last should be unreachable (watched instance).
+        elementLoop:
+        for (int i = 1; i < lastElementIndex; i++) {
+            LeakTraceElement element = elements.get(i);
+
+            for (Reachability.Inspector reachabilityInspector : reachabilityInspectors) {
+                Reachability reachability = reachabilityInspector.expectedReachability(element);
+                if (reachability == REACHABLE) {
+                    lastReachableElement = i;
+                    break;
+                } else if (reachability == UNREACHABLE) {
+                    firstUnreachableElement = i;
+                    break elementLoop;
+                }
+            }
+        }
+
+        List<Reachability> expectedReachability = new ArrayList<>();
+        for (int i = 0; i < elements.size(); i++) {
+            Reachability status;
+            if (i <= lastReachableElement) {
+                status = REACHABLE;
+            } else if (i >= firstUnreachableElement) {
+                status = UNREACHABLE;
             } else {
-              extra = "(anonymous subclass of java.lang.Object)";
+                status = UNKNOWN;
+            }
+            expectedReachability.add(status);
+        }
+        return expectedReachability;
+    }
+
+    private LeakTraceElement buildLeakElement(LeakNode node) {
+        if (node.parent == null) {
+            // Ignore any root node.
+            return null;
+        }
+        Instance holder = node.parent.instance;
+
+        if (holder instanceof RootObj) {
+            return null;
+        }
+        LeakTraceElement.Holder holderType;
+        String className;
+        String extra = null;
+        List<LeakReference> leakReferences = describeFields(holder);
+
+        className = getClassName(holder);
+
+        List<String> classHierarchy = new ArrayList<>();
+        classHierarchy.add(className);
+        String rootClassName = Object.class.getName();
+        if (holder instanceof ClassInstance) {
+            ClassObj classObj = holder.getClassObj();
+            while (!(classObj = classObj.getSuperClassObj()).getClassName().equals(rootClassName)) {
+                classHierarchy.add(classObj.getClassName());
             }
-          } catch (ClassNotFoundException ignored) {
-          }
+        }
+
+        if (holder instanceof ClassObj) {
+            holderType = CLASS;
+        } else if (holder instanceof ArrayInstance) {
+            holderType = ARRAY;
         } else {
-          holderType = OBJECT;
-          // Makes it easier to figure out which anonymous class we're looking at.
-          extra = "(anonymous subclass of " + parentClassName + ")";
+            ClassObj classObj = holder.getClassObj();
+            if (extendsThread(classObj)) {
+                holderType = THREAD;
+                String threadName = threadName(holder);
+                extra = "(named '" + threadName + "')";
+            } else if (className.matches(ANONYMOUS_CLASS_NAME_PATTERN)) {
+                String parentClassName = classObj.getSuperClassObj().getClassName();
+                if (rootClassName.equals(parentClassName)) {
+                    holderType = OBJECT;
+                    try {
+                        // This is an anonymous class implementing an interface. The API does not give access
+                        // to the interfaces implemented by the class. We check if it's in the class path and
+                        // use that instead.
+                        Class<?> actualClass = Class.forName(classObj.getClassName());
+                        Class<?>[] interfaces = actualClass.getInterfaces();
+                        if (interfaces.length > 0) {
+                            Class<?> implementedInterface = interfaces[0];
+                            extra = "(anonymous implementation of " + implementedInterface.getName() + ")";
+                        } else {
+                            extra = "(anonymous subclass of java.lang.Object)";
+                        }
+                    } catch (ClassNotFoundException ignored) {
+                    }
+                } else {
+                    holderType = OBJECT;
+                    // Makes it easier to figure out which anonymous class we're looking at.
+                    extra = "(anonymous subclass of " + parentClassName + ")";
+                }
+            } else {
+                holderType = OBJECT;
+            }
         }
-      } else {
-        holderType = OBJECT;
-      }
+        return new LeakTraceElement(node.leakReference, holderType, classHierarchy, extra,
+                node.exclusion, leakReferences);
     }
-    return new LeakTraceElement(node.leakReference, holderType, classHierarchy, extra,
-        node.exclusion, leakReferences);
-  }
-
-  private List<LeakReference> describeFields(Instance instance) {
-    List<LeakReference> leakReferences = new ArrayList<>();
-    if (instance instanceof ClassObj) {
-      ClassObj classObj = (ClassObj) instance;
-      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-        String name = entry.getKey().getName();
-        String stringValue = valueAsString(entry.getValue());
-        leakReferences.add(new LeakReference(STATIC_FIELD, name, stringValue));
-      }
-    } else if (instance instanceof ArrayInstance) {
-      ArrayInstance arrayInstance = (ArrayInstance) instance;
-      if (arrayInstance.getArrayType() == Type.OBJECT) {
-        Object[] values = arrayInstance.getValues();
-        for (int i = 0; i < values.length; i++) {
-          String name = Integer.toString(i);
-          String stringValue = valueAsString(values[i]);
-          leakReferences.add(new LeakReference(ARRAY_ENTRY, name, stringValue));
+
+    private List<LeakReference> describeFields(Instance instance) {
+        List<LeakReference> leakReferences = new ArrayList<>();
+        if (instance instanceof ClassObj) {
+            ClassObj classObj = (ClassObj) instance;
+            for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
+                String name = entry.getKey().getName();
+                String stringValue = valueAsString(entry.getValue());
+                leakReferences.add(new LeakReference(STATIC_FIELD, name, stringValue));
+            }
+        } else if (instance instanceof ArrayInstance) {
+            ArrayInstance arrayInstance = (ArrayInstance) instance;
+            if (arrayInstance.getArrayType() == Type.OBJECT) {
+                Object[] values = arrayInstance.getValues();
+                for (int i = 0; i < values.length; i++) {
+                    String name = Integer.toString(i);
+                    String stringValue = valueAsString(values[i]);
+                    leakReferences.add(new LeakReference(ARRAY_ENTRY, name, stringValue));
+                }
+            }
+        } else {
+            ClassObj classObj = instance.getClassObj();
+            for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
+                String name = entry.getKey().getName();
+                String stringValue = valueAsString(entry.getValue());
+                leakReferences.add(new LeakReference(STATIC_FIELD, name, stringValue));
+            }
+            ClassInstance classInstance = (ClassInstance) instance;
+            for (ClassInstance.FieldValue field : classInstance.getValues()) {
+                String name = field.getField().getName();
+                String stringValue = valueAsString(field.getValue());
+                leakReferences.add(new LeakReference(INSTANCE_FIELD, name, stringValue));
+            }
         }
-      }
-    } else {
-      ClassObj classObj = instance.getClassObj();
-      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-        String name = entry.getKey().getName();
-        String stringValue = valueAsString(entry.getValue());
-        leakReferences.add(new LeakReference(STATIC_FIELD, name, stringValue));
-      }
-      ClassInstance classInstance = (ClassInstance) instance;
-      for (ClassInstance.FieldValue field : classInstance.getValues()) {
-        String name = field.getField().getName();
-        String stringValue = valueAsString(field.getValue());
-        leakReferences.add(new LeakReference(INSTANCE_FIELD, name, stringValue));
-      }
+        return leakReferences;
     }
-    return leakReferences;
-  }
-
-  private String getClassName(Instance instance) {
-    String className;
-    if (instance instanceof ClassObj) {
-      ClassObj classObj = (ClassObj) instance;
-      className = classObj.getClassName();
-    } else if (instance instanceof ArrayInstance) {
-      ArrayInstance arrayInstance = (ArrayInstance) instance;
-      className = arrayInstance.getClassObj().getClassName();
-    } else {
-      ClassObj classObj = instance.getClassObj();
-      className = classObj.getClassName();
+
+    private String getClassName(Instance instance) {
+        String className;
+        if (instance instanceof ClassObj) {
+            ClassObj classObj = (ClassObj) instance;
+            className = classObj.getClassName();
+        } else if (instance instanceof ArrayInstance) {
+            ArrayInstance arrayInstance = (ArrayInstance) instance;
+            className = arrayInstance.getClassObj().getClassName();
+        } else {
+            ClassObj classObj = instance.getClassObj();
+            className = classObj.getClassName();
+        }
+        return className;
     }
-    return className;
-  }
 
-  private long since(long analysisStartNanoTime) {
-    return NANOSECONDS.toMillis(System.nanoTime() - analysisStartNanoTime);
-  }
+    private long since(long analysisStartNanoTime) {
+        return NANOSECONDS.toMillis(System.nanoTime() - analysisStartNanoTime);
+    }
 }
diff --git a/leakcanary-android/src/main/AndroidManifest.xml b/leakcanary-android/src/main/AndroidManifest.xml
index 6b2c2a26..87462842 100644
--- a/leakcanary-android/src/main/AndroidManifest.xml
+++ b/leakcanary-android/src/main/AndroidManifest.xml
@@ -15,62 +15,61 @@
   ~ limitations under the License.
   -->
 <manifest
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.squareup.leakcanary"
-    >
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        package="com.squareup.leakcanary"
+>
 
-  <!-- To store the heap dumps and leak analysis results. -->
-  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
-  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
-  <!-- To allow starting foreground services on Android P+ - https://developer.android.com/preview/behavior-changes#fg-svc -->
-  <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
+    <!-- To store the heap dumps and leak analysis results. -->
+    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+    <!-- To allow starting foreground services on Android P+ - https://developer.android.com/preview/behavior-changes#fg-svc -->
+    <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
 
-  <application>
-    <service
-        android:name=".internal.HeapAnalyzerService"
-        android:process=":leakcanary"
-        android:enabled="false"
+    <application>
+        <service
+                android:name=".internal.HeapAnalyzerService"
+                android:process=":leakcanary"
+                android:enabled="false"
         />
-    <service
-        android:name=".DisplayLeakService"
-        android:process=":leakcanary"
-        android:enabled="false"
+        <service
+                android:name=".DisplayLeakService"
+                android:process=":leakcanary"
+                android:enabled="false"
         />
-    <provider
-        android:name="com.squareup.leakcanary.internal.LeakCanaryFileProvider"
-        android:authorities="com.squareup.leakcanary.fileprovider.${applicationId}"
-        android:exported="false"
-        android:grantUriPermissions="true"
+        <provider
+                android:name="com.squareup.leakcanary.internal.LeakCanaryFileProvider"
+                android:authorities="com.squareup.leakcanary.fileprovider.${applicationId}"
+                android:exported="false"
+                android:grantUriPermissions="true"
         >
-      <meta-data
-          android:name="android.support.FILE_PROVIDER_PATHS"
-          android:resource="@xml/leak_canary_file_paths"/>
-    </provider>
-    <activity
-        android:theme="@style/leak_canary_LeakCanary.Base"
-        android:name=".internal.DisplayLeakActivity"
-        android:process=":leakcanary"
-        android:enabled="false"
-        android:label="@string/leak_canary_display_activity_label"
-        android:icon="@mipmap/leak_canary_icon"
-        android:taskAffinity="com.squareup.leakcanary.${applicationId}"
-        >
-      <intent-filter>
-        <action android:name="android.intent.action.MAIN"/>
-        <category android:name="android.intent.category.LAUNCHER"/>
-      </intent-filter>
-    </activity>
-    <activity
-        android:theme="@style/leak_canary_Theme.Transparent"
-        android:name=".internal.RequestStoragePermissionActivity"
-        android:process=":leakcanary"
-        android:taskAffinity="com.squareup.leakcanary.${applicationId}"
-        android:enabled="false"
-        android:excludeFromRecents="true"
-        android:icon="@mipmap/leak_canary_icon"
-        android:roundIcon="@mipmap/leak_canary_icon"
-        android:label="@string/leak_canary_storage_permission_activity_label"
+            <meta-data
+                    android:name="android.support.FILE_PROVIDER_PATHS"
+                    android:resource="@xml/leak_canary_file_paths"/>
+        </provider>
+        <activity
+                android:theme="@style/leak_canary_LeakCanary.Base"
+                android:name=".internal.DisplayLeakActivity"
+                android:process=":leakcanary"
+                android:enabled="false"
+                android:label="@string/leak_canary_display_activity_label"
+                android:icon="@mipmap/leak_canary_icon"
+                android:taskAffinity="com.squareup.leakcanary.${applicationId}">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+        <activity
+                android:theme="@style/leak_canary_Theme.Transparent"
+                android:name=".internal.RequestStoragePermissionActivity"
+                android:process=":leakcanary"
+                android:taskAffinity="com.squareup.leakcanary.${applicationId}"
+                android:enabled="false"
+                android:excludeFromRecents="true"
+                android:icon="@mipmap/leak_canary_icon"
+                android:roundIcon="@mipmap/leak_canary_icon"
+                android:label="@string/leak_canary_storage_permission_activity_label"
         />
 
-  </application>
+    </application>
 </manifest>
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
index e8f3473e..2be3fc64 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
@@ -21,91 +21,104 @@
 import android.support.annotation.Nullable;
 import android.support.v4.content.ContextCompat;
 import com.squareup.leakcanary.internal.ForegroundService;
+
 import java.io.File;
 
 public abstract class AbstractAnalysisResultService extends ForegroundService {
 
-  private static final String ANALYZED_HEAP_PATH_EXTRA = "analyzed_heap_path_extra";
+    private static final String ANALYZED_HEAP_PATH_EXTRA = "analyzed_heap_path_extra";
+
+    // 将分析的结果发送到 listenerService中
+    public static void sendResultToListener(@NonNull Context context,
+                                            @NonNull String listenerServiceClassName,
+                                            @NonNull HeapDump heapDump,
+                                            @NonNull AnalysisResult result) {
+        // 根据ClassName 反射 listenerServiceClass
+        Class<?> listenerServiceClass;
+        try {
+            listenerServiceClass = Class.forName(listenerServiceClassName);
+        } catch (ClassNotFoundException e) {
+            throw new RuntimeException(e);
+        }
+        // 创建 Intent
+        Intent intent = new Intent(context, listenerServiceClass);
 
-  public static void sendResultToListener(@NonNull Context context,
-      @NonNull String listenerServiceClassName,
-      @NonNull HeapDump heapDump,
-      @NonNull AnalysisResult result) {
-    Class<?> listenerServiceClass;
-    try {
-      listenerServiceClass = Class.forName(listenerServiceClassName);
-    } catch (ClassNotFoundException e) {
-      throw new RuntimeException(e);
+        // 将 heapDump和 分析的结果 写入到文件中
+        File analyzedHeapFile = AnalyzedHeap.save(heapDump, result);
+        if (analyzedHeapFile != null) {
+            // 将文件的绝对路径 作为 参数 加入到 Intent中
+            intent.putExtra(ANALYZED_HEAP_PATH_EXTRA, analyzedHeapFile.getAbsolutePath());
+        }
+        // start service
+        ContextCompat.startForegroundService(context, intent);
     }
-    Intent intent = new Intent(context, listenerServiceClass);
 
-    File analyzedHeapFile = AnalyzedHeap.save(heapDump, result);
-    if (analyzedHeapFile != null) {
-      intent.putExtra(ANALYZED_HEAP_PATH_EXTRA, analyzedHeapFile.getAbsolutePath());
+    public AbstractAnalysisResultService() {
+        super(AbstractAnalysisResultService.class.getName(),
+                R.string.leak_canary_notification_reporting);
     }
-    ContextCompat.startForegroundService(context, intent);
-  }
 
-  public AbstractAnalysisResultService() {
-    super(AbstractAnalysisResultService.class.getName(),
-        R.string.leak_canary_notification_reporting);
-  }
+    @Override
+    protected final void onHandleIntentInForeground(@Nullable Intent intent) {
+        // intent为null，则抛出异常
+        if (intent == null) {
+            CanaryLog.d("AbstractAnalysisResultService received a null intent, ignoring.");
+            return;
+        }
 
-  @Override protected final void onHandleIntentInForeground(@Nullable Intent intent) {
-    if (intent == null) {
-      CanaryLog.d("AbstractAnalysisResultService received a null intent, ignoring.");
-      return;
-    }
-    if (!intent.hasExtra(ANALYZED_HEAP_PATH_EXTRA)) {
-      onAnalysisResultFailure(getString(R.string.leak_canary_result_failure_no_disk_space));
-      return;
-    }
-    File analyzedHeapFile = new File(intent.getStringExtra(ANALYZED_HEAP_PATH_EXTRA));
-    AnalyzedHeap analyzedHeap = AnalyzedHeap.load(analyzedHeapFile);
-    if (analyzedHeap == null) {
-      onAnalysisResultFailure(getString(R.string.leak_canary_result_failure_no_file));
-      return;
+        // 检测 内存泄露结果文件 是否为null
+        if (!intent.hasExtra(ANALYZED_HEAP_PATH_EXTRA)) {
+            // null，则表明 分析失败
+            onAnalysisResultFailure(getString(R.string.leak_canary_result_failure_no_disk_space));
+            return;
+        }
+        // 根据路径，获取分析结果的文件
+        File analyzedHeapFile = new File(intent.getStringExtra(ANALYZED_HEAP_PATH_EXTRA));
+        AnalyzedHeap analyzedHeap = AnalyzedHeap.load(analyzedHeapFile);
+        if (analyzedHeap == null) {
+            onAnalysisResultFailure(getString(R.string.leak_canary_result_failure_no_file));
+            return;
+        }
+        try {
+            onHeapAnalyzed(analyzedHeap);
+        } finally {
+            //noinspection ResultOfMethodCallIgnored
+            analyzedHeap.heapDump.heapDumpFile.delete();
+            //noinspection ResultOfMethodCallIgnored
+            analyzedHeap.selfFile.delete();
+        }
     }
-    try {
-      onHeapAnalyzed(analyzedHeap);
-    } finally {
-      //noinspection ResultOfMethodCallIgnored
-      analyzedHeap.heapDump.heapDumpFile.delete();
-      //noinspection ResultOfMethodCallIgnored
-      analyzedHeap.selfFile.delete();
-    }
-  }
 
-  /**
-   * Called after a heap dump is analyzed, whether or not a leak was found.
-   * In {@link AnalyzedHeap#result} check {@link AnalysisResult#leakFound} and {@link
-   * AnalysisResult#excludedLeak} to see if there was a leak and if it can be ignored.
-   * <p>
-   * This will be called from a background intent service thread.
-   * <p>
-   * It's OK to block here and wait for the heap dump to be uploaded.
-   * <p>
-   * The analyzed heap file and heap dump file will be deleted immediately after this callback
-   * returns.
-   */
-  protected void onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap) {
-    onHeapAnalyzed(analyzedHeap.heapDump, analyzedHeap.result);
-  }
+    /**
+     * Called after a heap dump is analyzed, whether or not a leak was found.
+     * In {@link AnalyzedHeap#result} check {@link AnalysisResult#leakFound} and {@link
+     * AnalysisResult#excludedLeak} to see if there was a leak and if it can be ignored.
+     * <p>
+     * This will be called from a background intent service thread.
+     * <p>
+     * It's OK to block here and wait for the heap dump to be uploaded.
+     * <p>
+     * The analyzed heap file and heap dump file will be deleted immediately after this callback
+     * returns.
+     */
+    protected void onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap) {
+        onHeapAnalyzed(analyzedHeap.heapDump, analyzedHeap.result);
+    }
 
-  /**
-   * @deprecated Maintained for backward compatibility. You should override {@link
-   * #onHeapAnalyzed(AnalyzedHeap)} instead.
-   */
-  @SuppressWarnings("DeprecatedIsStillUsed")
-  @Deprecated
-  protected void onHeapAnalyzed(@NonNull HeapDump heapDump, @NonNull AnalysisResult result) {
-  }
+    /**
+     * @deprecated Maintained for backward compatibility. You should override {@link
+     * #onHeapAnalyzed(AnalyzedHeap)} instead.
+     */
+    @SuppressWarnings("DeprecatedIsStillUsed")
+    @Deprecated
+    protected void onHeapAnalyzed(@NonNull HeapDump heapDump, @NonNull AnalysisResult result) {
+    }
 
-  /**
-   * Called when there was an error saving or loading the analysis result. This will be called from
-   * a background intent service thread.
-   */
-  protected void onAnalysisResultFailure(String failureMessage) {
-    CanaryLog.d(failureMessage);
-  }
+    /**
+     * Called when there was an error saving or loading the analysis result. This will be called from
+     * a background intent service thread.
+     */
+    protected void onAnalysisResultFailure(String failureMessage) {
+        CanaryLog.d(failureMessage);
+    }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
index aaf7dd5e..67177ca3 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
@@ -30,40 +30,45 @@
 @Deprecated
 public final class ActivityRefWatcher {
 
-  public static void installOnIcsPlus(@NonNull Application application,
-      @NonNull RefWatcher refWatcher) {
-    install(application, refWatcher);
-  }
+    public static void installOnIcsPlus(@NonNull Application application,
+                                        @NonNull RefWatcher refWatcher) {
+        install(application, refWatcher);
+    }
 
-  public static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) {
-    Application application = (Application) context.getApplicationContext();
-    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);
+    public static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) {
+        Application application = (Application) context.getApplicationContext();
+        // 创建一个 ActivityRefWatcher对象
+        ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);
 
-    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);
-  }
+        // 注册 Activity生命周期的Callback，
+        // 在这个Callback中只关心所有Activity的Destory事件，因为 LeakCanary是在Activity被销毁时 才去watch
+        application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);
+    }
 
-  private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =
-      new ActivityLifecycleCallbacksAdapter() {
-        @Override public void onActivityDestroyed(Activity activity) {
-          refWatcher.watch(activity);
-        }
-      };
+    private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =
+            new ActivityLifecycleCallbacksAdapter() {
+                @Override
+                public void onActivityDestroyed(Activity activity) {
+                    // 在Activity Destory时，开始 监测 被销毁的 Activity
+                    refWatcher.watch(activity);
+                }
+            };
 
-  private final Application application;
-  private final RefWatcher refWatcher;
+    private final Application application;
+    private final RefWatcher refWatcher;
 
-  private ActivityRefWatcher(Application application, RefWatcher refWatcher) {
-    this.application = application;
-    this.refWatcher = refWatcher;
-  }
+    private ActivityRefWatcher(Application application, RefWatcher refWatcher) {
+        this.application = application;
+        this.refWatcher = refWatcher;
+    }
 
-  public void watchActivities() {
-    // Make sure you don't get installed twice.
-    stopWatchingActivities();
-    application.registerActivityLifecycleCallbacks(lifecycleCallbacks);
-  }
+    public void watchActivities() {
+        // Make sure you don't get installed twice.
+        stopWatchingActivities();
+        application.registerActivityLifecycleCallbacks(lifecycleCallbacks);
+    }
 
-  public void stopWatchingActivities() {
-    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks);
-  }
+    public void stopWatchingActivities() {
+        application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks);
+    }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
index f83dfb8a..37aae4e2 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
@@ -16,6 +16,7 @@
 package com.squareup.leakcanary;
 
 import android.support.annotation.NonNull;
+
 import java.lang.ref.PhantomReference;
 import java.lang.ref.SoftReference;
 import java.lang.ref.WeakReference;
@@ -49,585 +50,634 @@
 /**
  * This class is a work in progress. You can help by reporting leak traces that seem to be caused
  * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
- *
+ * <p>
  * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
  * manufacturer implementation, they usually share their builds across multiple models, and the
  * leaks eventually get fixed in newer versions.
- *
+ * <p>
  * Most app developers should use {@link #createAppDefaults()}. However, you can also pick the
  * leaks you want to ignore by creating an {@link EnumSet} that matches your needs and calling
  * {@link #createBuilder(EnumSet)}
  */
-@SuppressWarnings({ "unused", "WeakerAccess" }) // Public API.
+@SuppressWarnings({"unused", "WeakerAccess"}) // Public API.
 public enum AndroidExcludedRefs {
 
-  // ######## Android SDK Excluded refs ########
-
-  ACTIVITY_CLIENT_RECORD__NEXT_IDLE(SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle")
-          .reason("Android AOSP sometimes keeps a reference to a destroyed activity as a"
-              + " nextIdle client record in the android.app.ActivityThread.mActivities map."
-              + " Not sure what's going on there, input welcome.");
-    }
-  },
-
-  SPAN_CONTROLLER(SDK_INT <= KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason =
-          "Editor inserts a special span, which has a reference to the EditText. That span is a"
-              + " NoCopySpan, which makes sure it gets dropped when creating a new"
-              + " SpannableStringBuilder from a given CharSequence."
-              + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
-              + " bundle. Prior to KitKat, that copy was done using the SpannableString"
-              + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
-              + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
-              + " reference to the textview and therefore the entire view hierarchy & activity"
-              + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
-              + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
-              + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
-              + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.";
-      excluded.instanceField("android.widget.Editor$EasyEditSpanController", "this$0")
-          .reason(reason);
-      excluded.instanceField("android.widget.Editor$SpanController", "this$0").reason(reason);
-    }
-  },
-
-  MEDIA_SESSION_LEGACY_HELPER__SINSTANCE(SDK_INT == LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance")
-          .reason("MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
-              + " keeps a reference to the context it's given the first time"
-              + " MediaSessionLegacyHelper.getHelper() is called."
-              + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
-              + " calling context.getApplicationContext()."
-              + " Fix: https://github.com/android/platform_frameworks_base/commit"
-              + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
-              + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
-              + " in Application.onCreate() and pass it the application context.");
-    }
-  },
-
-  TEXT_LINE__SCACHED(SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.text.TextLine", "sCached")
-          .reason("TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
-              + " at least two bugs that created memory leaks by not correctly clearing the"
-              + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
-              + " https://github.com/android/platform_frameworks_base/commit"
-              + "/893d6fe48d37f71e683f722457bea646994a10"
-              + " The second was fixed, not released yet:"
-              + " https://github.com/android/platform_frameworks_base/commit"
-              + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
-              + " To fix this, you could access TextLine.sCached and clear the pool every now"
-              + " and then (e.g. on activity destroy).");
-    }
-  },
-
-  BLOCKING_QUEUE() {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason = "A thread waiting on a blocking queue will leak the last"
-          + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
-          + " keeps a local reference to the last message it received. That message then gets"
-          + " recycled and can be used again. As long as all messages are recycled after being"
-          + "used, this won't be a problem, because these references are cleared when being"
-          + "recycled. However, dialogs create template Message instances to be copied when a"
-          + "message needs to be sent. These Message templates holds references to the dialog"
-          + "listeners, which most likely leads to holding a reference onto the activity in some"
-          + "way. Dialogs never recycle their template Message, assuming these Message instances"
-          + " will get GCed when the dialog is GCed."
-          + " The combination of these two things creates a high potential for memory leaks as soon"
-          + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
-          + " sleep for a long time."
-          + " To fix this, you could post empty messages to the idle handler threads from time to"
-          + " time. This won't be easy because you cannot access all handler threads, but a library"
-          + "that is widely used should consider doing this for its own handler threads. This leaks"
-          + "has been shown to happen in both Dalvik and ART.";
-      excluded.instanceField("android.os.Message", "obj").reason(reason);
-      excluded.instanceField("android.os.Message", "next").reason(reason);
-      excluded.instanceField("android.os.Message", "target").reason(reason);
-    }
-  },
-
-  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= O_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason = "When we detach a view that receives keyboard input, the InputMethodManager"
-          + " leaks a reference to it until a new view asks for keyboard input."
-          + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
-          + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414";
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView")
-          .reason(reason);
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView")
-          .reason(reason);
-      excluded.instanceField("android.view.inputmethod.InputMethodManager",
-          "mServedInputConnection").reason(reason);
-    }
-  },
-
-  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= O_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView")
-          .reason("The singleton InputMethodManager is holding a reference to mCurRootView long"
-              + " after the activity has been destroyed."
-              + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
-              + "#issuecomment-100579429"
-              + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414");
-    }
-  },
-
-  LAYOUT_TRANSITION(SDK_INT >= ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.animation.LayoutTransition$1", "val$parent")
-          .reason("LayoutTransition leaks parent ViewGroup through"
-              + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
-              + " window is destroyed. Tracked here:"
-              + " https://code.google.com/p/android/issues/detail?id=171830");
-    }
-  },
-
-  SPELL_CHECKER_SESSION(SDK_INT >= JELLY_BEAN && SDK_INT <= N) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0")
-          .reason("SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
-              + " SpellCheckerSession is closed before the service is connected."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542");
-    }
-  },
-
-  SPELL_CHECKER(SDK_INT == LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.widget.SpellChecker$1", "this$0")
-          .reason("SpellChecker holds on to a detached view that points to a destroyed activity."
-              + "mSpellRunnable is being enqueued, and that callback should be removed when "
-              + "closeSession() is called. Maybe closeSession() wasn't called, or maybe it was "
-              + "called after the view was detached.");
-    }
-  },
-
-  ACTIVITY_CHOOSE_MODEL(SDK_INT > ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason = "ActivityChooserModel holds a static reference to the last set"
-          + " ActivityChooserModelPolicy which can be an activity context."
-          + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
-          + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0";
-      excluded.instanceField("android.support.v7.internal.widget.ActivityChooserModel",
-          "mActivityChoserModelPolicy").reason(reason);
-      excluded.instanceField("android.widget.ActivityChooserModel", "mActivityChoserModelPolicy")
-          .reason(reason);
-    }
-  },
-
-  SPEECH_RECOGNIZER(SDK_INT < LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.speech.SpeechRecognizer$InternalListener", "this$0")
-          .reason("Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
-              + " class and leaked the SpeechRecognizer which leaked an activity context."
-              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
-              + " /b37866db469e81aca534ff6186bdafd44352329b");
-    }
-  },
-
-  ACCOUNT_MANAGER(SDK_INT <= O_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.accounts.AccountManager$AmsTask$Response", "this$1")
-          .reason("AccountManager$AmsTask$Response is a stub and is held in memory by native code,"
-              + " probably because the reference to the response in the other process hasn't been"
-              + " cleared."
-              + " AccountManager$AmsTask is holding on to the activity reference to use for"
-              + " launching a new sub- Activity."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
-              + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
-              + " with the returned future to to get the result and correctly start an activity"
-              + " when it's available.");
-    }
-  },
-
-  MEDIA_SCANNER_CONNECTION(SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.media.MediaScannerConnection", "mContext")
-          .reason("The static method MediaScannerConnection.scanFile() takes an activity context"
-              + " but the service might not disconnect after the activity has been destroyed."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
-              + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
-              + " application context. Call connect() and disconnect() manually.");
-    }
-  },
-
-  USER_MANAGER__SINSTANCE(SDK_INT >= JELLY_BEAN_MR2 && SDK_INT < O) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.os.UserManager", "mContext")
-          .reason("UserManager has a static sInstance field that creates an instance and caches it"
-              + " the first time UserManager.get() is called. This instance is created with the"
-              + " outer context (which is an activity base context)."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
-              + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
-              + "/27db46850b708070452c0ce49daf5f79503fbde6"
-              + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
-              + " UserManager instance gets cached with a reference to the application context.");
-    }
-  },
-
-  APP_WIDGET_HOST_CALLBACKS(SDK_INT < LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.appwidget.AppWidgetHost$Callbacks", "this$0")
-          .reason("android.appwidget.AppWidgetHost$Callbacks is a stub and is held in memory native"
-              + " code. The reference to the `mContext` was not being cleared, which caused the"
-              + " Callbacks instance to retain this reference"
-              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
-              + "/7a96f3c917e0001ee739b65da37b2fadec7d7765");
-    }
-  },
-
-  AUDIO_MANAGER(SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.media.AudioManager$1", "this$0")
-          .reason("Prior to Android M, VideoView required audio focus from AudioManager and"
-              + " never abandoned it, which leaks the Activity context through the AudioManager."
-              + " The root of the problem is that AudioManager uses whichever"
-              + " context it receives, which in the case of the VideoView example is an Activity,"
-              + " even though it only needs the application's context. The issue is fixed in"
-              + " Android M, and the AudioManager now uses the application's context."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
-              + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2");
-    }
-  },
-
-  EDITTEXT_BLINK_MESSAGEQUEUE(SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.widget.Editor$Blink", "this$0")
-          .reason("The EditText Blink of the Cursor is implemented using a callback and Messages,"
-              + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
-              + " contains a blinking cursor is detached, a message is posted with a delay after the"
-              + " dialog has been closed and as a result leaks the Activity."
-              + " This can be fixed manually by calling TextView.setCursorVisible(false) in the"
-              + " dismiss() method of the dialog."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
-              + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
-              + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/");
-    }
-  },
-
-  CONNECTIVITY_MANAGER__SINSTANCE(SDK_INT <= M) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.net.ConnectivityManager", "sInstance")
-          .reason("ConnectivityManager has a sInstance field that is set when the first"
-              + "ConnectivityManager instance is created. ConnectivityManager has a mContext field."
-              + "When calling activity.getSystemService(Context.CONNECTIVITY_SERVICE) , the first"
-              + "ConnectivityManager instance is created with the activity context and stored in"
-              + "sInstance. That activity context then leaks forever."
-              + "Until this is fixed, app developers can prevent this leak by making sure the"
-              + " ConnectivityManager is first created with an App Context. E.g. in some static"
-              + " init do: context.getApplicationContext()"
-              + ".getSystemService(Context.CONNECTIVITY_SERVICE)"
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=198852"
-              + " Introduced here: https://github.com/android/platform_frameworks_base/commit/"
-              + "e0bef71662d81caaaa0d7214fb0bef5d39996a69");
-    }
-  },
-
-  ACCESSIBILITY_NODE_INFO__MORIGINALTEXT(SDK_INT >= O && SDK_INT <= O_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.view.accessibility.AccessibilityNodeInfo", "mOriginalText")
-          .reason("AccessibilityNodeInfo has a static sPool of AccessibilityNodeInfo. When "
-              + "AccessibilityNodeInfo instances are released back in the pool, "
-              + "AccessibilityNodeInfo.clear() does not clear the mOriginalText field, which "
-              + "causes spans to leak which in turns causes TextView.ChangeWatcher to leak and the "
-              + "whole view hierarchy. Introduced here: https://android.googlesource.com/platform/"
-              + "frameworks/base/+/193520e3dff5248ddcf8435203bf99d2ba667219%5E%21/core/java/"
-              + "android/view/accessibility/AccessibilityNodeInfo.java");
-    }
-  },
-
-  BACKDROP_FRAME_RENDERER__MDECORVIEW(SDK_INT >= N && SDK_INT <= O) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("com.android.internal.policy.BackdropFrameRenderer", "mDecorView")
-          .reason("When BackdropFrameRenderer.releaseRenderer() is called, there's an unknown case "
-              + "where mRenderer becomes null but mChoreographer doesn't and the thread doesn't"
-              + "stop and ends up leaking mDecorView which itself holds on to a destroyed"
-              + "activity");
-    }
-  },
-
-  // ######## Manufacturer specific Excluded refs ########
-
-  INSTRUMENTATION_RECOMMEND_ACTIVITY(
-      MEIZU.equals(MANUFACTURER) && SDK_INT >= LOLLIPOP && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.app.Instrumentation", "mRecommendActivity")
-          .reason("Instrumentation would leak com.android.internal.app.RecommendActivity (in "
-              + "framework.jar) in Meizu FlymeOS 4.5 and above, which is based on Android 5.0 and "
-              + "above");
-    }
-  },
-
-  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER(
-      MOTOROLA.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      if (MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-        excluded.instanceField("android.app.admin.DevicePolicyManager$SettingsObserver", "this$0")
-            .reason("DevicePolicyManager keeps a reference to the context it has been created with"
-                + " instead of extracting the application context. In this Motorola build,"
-                + " DevicePolicyManager has an inner SettingsObserver class that is a content"
-                + " observer, which is held into memory by a binder transport object.");
-      }
-    }
-  },
-
-  SPEN_GESTURE_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext")
-          .reason("SpenGestureManager has a static mContext field that leaks a reference to the"
-              + " activity. Yes, a STATIC mContext field.");
-    }
-  },
-
-  GESTURE_BOOST_MANAGER(HUAWEI.equals(MANUFACTURER) && SDK_INT >= N && SDK_INT <= N_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.gestureboost.GestureBoostManager", "mContext")
-          .reason("GestureBoostManager is a static singleton that leaks an activity context."
-              + "Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756");
-    }
-  },
-
-  INPUT_METHOD_MANAGER__LAST_SERVED_VIEW(
-      HUAWEI.equals(MANUFACTURER) && SDK_INT >= M && SDK_INT <= O_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason = "HUAWEI added a mLastSrvView field to InputMethodManager"
-          + " that leaks a reference to the last served view.";
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mLastSrvView")
-          .reason(reason);
-    }
-  },
-
-  CLIPBOARD_UI_MANAGER__SINSTANCE(
-      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.sec.clipboard.ClipboardUIManager", "mContext")
-          .reason("ClipboardUIManager is a static singleton that leaks an activity context."
-              + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
-              + " , so that the ClipboardUIManager instance gets cached with a reference to the"
-              + " application context. Example: https://gist.github.com/cypressious/"
-              + "91c4fb1455470d803a602838dfcd5774");
-    }
-  },
-
-  SEM_CLIPBOARD_MANAGER__MCONTEXT(
-      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= N) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("com.samsung.android.content.clipboard.SemClipboardManager",
-          "mContext")
-          .reason("SemClipboardManager is held in memory by an anonymous inner class "
-              + "implementation of android.os.Binder, thereby leaking an activity context.");
-    }
-  },
-
-  SEM_EMERGENCY_MANAGER__MCONTEXT(
-      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= N) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("com.samsung.android.emergencymode.SemEmergencyManager", "mContext")
-          .reason("SemEmergencyManager is a static singleton that leaks a DecorContext. "
-              + "Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d");
-    }
-  },
-
-  BUBBLE_POPUP_HELPER__SHELPER(
-      LG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.widget.BubblePopupHelper", "sHelper")
-          .reason("A static helper for EditText bubble popups leaks a reference to the latest"
-              + "focused view.");
-    }
-  },
-
-  LGCONTEXT__MCONTEXT(LG.equals(MANUFACTURER) && SDK_INT == LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("com.lge.systemservice.core.LGContext", "mContext")
-          .reason("LGContext is a static singleton that leaks an activity context.");
-    }
-  },
-
-  AW_RESOURCE__SRESOURCES(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // AwResource#setResources() is called with resources that hold a reference to the
-      // activity context (instead of the application context) and doesn't clear it.
-      // Not sure what's going on there, input welcome.
-      excluded.staticField("com.android.org.chromium.android_webview.AwResource", "sResources");
-    }
-  },
-
-  MAPPER_CLIENT(NVIDIA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient$ServiceClient", "this$0")
-          .reason("Not sure exactly what ControllerMapper is about, but there is an anonymous"
-              + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
-              + " ControllerMapper.MapperClient which leaks the activity context.");
-    }
-  },
-
-  TEXT_VIEW__MLAST_HOVERED_VIEW(
-      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= O) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.widget.TextView", "mLastHoveredView")
-          .reason("mLastHoveredView is a static field in TextView that leaks the last hovered"
-              + " view.");
-    }
-  },
-
-  PERSONA_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.os.PersonaManager", "mContext")
-          .reason("android.app.LoadedApk.mResources has a reference to"
-              + " android.content.res.Resources.mPersonaManager which has a reference to"
-              + " android.os.PersonaManager.mContext which is an activity.");
-    }
-  },
-
-  RESOURCES__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.content.res.Resources", "mContext")
-          .reason("In AOSP the Resources class does not have a context."
-              + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
-              + " instance that has a context that is the activity."
-              + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184");
-    }
-  },
-
-  VIEW_CONFIGURATION__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.view.ViewConfiguration", "mContext")
-          .reason("In AOSP the ViewConfiguration class does not have a context."
-              + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
-              + " ViewConfiguration instance that has a context that is the activity."
-              + " Observed here: https://github.com/square/leakcanary/issues"
-              + "/1#issuecomment-100324683");
-    }
-  },
-
-  SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL((LENOVO.equals(MANUFACTURER) && SDK_INT == KITKAT) //
-      || (VIVO.equals(MANUFACTURER) && SDK_INT == LOLLIPOP_MR1)) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.hardware.SystemSensorManager", "mAppContextImpl")
-          .reason("SystemSensorManager stores a reference to context "
-              + "in a static field in its constructor."
-              + "Fix: use application context to get SensorManager");
-    }
-  },
-
-  AUDIO_MANAGER__MCONTEXT_STATIC(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.media.AudioManager", "mContext_static")
-          .reason("Samsung added a static mContext_static field to AudioManager, holds a reference"
-              + " to the activity."
-              + " Observed here: https://github.com/square/leakcanary/issues/32");
-    }
-  },
-
-  ACTIVITY_MANAGER_MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.app.ActivityManager", "mContext")
-          .reason("Samsung added a static mContext field to ActivityManager, holds a reference"
-              + " to the activity."
-              + " Observed here: https://github.com/square/leakcanary/issues/177 Fix in comment:"
-              + " https://github.com/square/leakcanary/issues/177#issuecomment-222724283");
-    }
-  },
-
-  // ######## General Excluded refs ########
-
-  SOFT_REFERENCES {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.clazz(WeakReference.class.getName()).alwaysExclude();
-      excluded.clazz(SoftReference.class.getName()).alwaysExclude();
-      excluded.clazz(PhantomReference.class.getName()).alwaysExclude();
-      excluded.clazz("java.lang.ref.Finalizer").alwaysExclude();
-      excluded.clazz("java.lang.ref.FinalizerReference").alwaysExclude();
-    }
-  },
-
-  FINALIZER_WATCHDOG_DAEMON {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
-      // reference to the object and it was about to be GCed.
-      excluded.thread("FinalizerWatchdogDaemon").alwaysExclude();
-    }
-  },
-
-  MAIN {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // The main thread stack is ever changing so local variables aren't likely to hold references
-      // for long. If this is on the shortest path, it's probably that there's a longer path with
-      // a real leak.
-      excluded.thread("main").alwaysExclude();
-    }
-  },
-
-  LEAK_CANARY_THREAD {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.thread(LEAK_CANARY_THREAD_NAME).alwaysExclude();
-    }
-  },
-
-  EVENT_RECEIVER__MMESSAGE_QUEUE {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
-      // the native peer of the receiver is using them.
-      // The main thread message queue is held on by the main Looper, but that might be a longer
-      // path. Let's not confuse people with a shorter path that is less meaningful.
-      excluded.instanceField("android.view.Choreographer$FrameDisplayEventReceiver",
-          "mMessageQueue").alwaysExclude();
-    }
-  },
-
-  VIEWLOCATIONHOLDER_ROOT(SDK_INT == P) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      //  In Android P, ViewLocationHolder has an mRoot field that is not cleared in its clear()
-      // method.
-      // Introduced in https://github.com/aosp-mirror/platform_frameworks_base/commit/86b326012813f09d8f1de7d6d26c986a909de894
-      // Bug report: https://issuetracker.google.com/issues/112792715
-      excluded.instanceField("android.view.ViewGroup$ViewLocationHolder",
-          "mRoot");
-    }
-  };
-
-  /**
-   * This returns the references in the leak path that should be ignored by all on Android.
-   */
-  public static @NonNull ExcludedRefs.Builder createAndroidDefaults() {
-    return createBuilder(
-        EnumSet.of(SOFT_REFERENCES, FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
-            EVENT_RECEIVER__MMESSAGE_QUEUE));
-  }
-
-  /**
-   * This returns the references in the leak path that can be ignored for app developers. This
-   * doesn't mean there is no memory leak, to the contrary. However, some leaks are caused by bugs
-   * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
-   * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
-   */
-  public static @NonNull ExcludedRefs.Builder createAppDefaults() {
-    return createBuilder(EnumSet.allOf(AndroidExcludedRefs.class));
-  }
-
-  public static @NonNull ExcludedRefs.Builder createBuilder(EnumSet<AndroidExcludedRefs> refs) {
-    ExcludedRefs.Builder excluded = ExcludedRefs.builder();
-    for (AndroidExcludedRefs ref : refs) {
-      if (ref.applies) {
-        ref.add(excluded);
-        ((ExcludedRefs.BuilderWithParams) excluded).named(ref.name());
-      }
-    }
-    return excluded;
-  }
-
-  final boolean applies;
-
-  AndroidExcludedRefs() {
-    this(true);
-  }
-
-  AndroidExcludedRefs(boolean applies) {
-    this.applies = applies;
-  }
-
-  abstract void add(ExcludedRefs.Builder excluded);
+    // ######## Android SDK Excluded refs ########
+
+    ACTIVITY_CLIENT_RECORD__NEXT_IDLE(SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle")
+                    .reason("Android AOSP sometimes keeps a reference to a destroyed activity as a"
+                            + " nextIdle client record in the android.app.ActivityThread.mActivities map."
+                            + " Not sure what's going on there, input welcome.");
+        }
+    },
+
+    SPAN_CONTROLLER(SDK_INT <= KITKAT) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            String reason =
+                    "Editor inserts a special span, which has a reference to the EditText. That span is a"
+                            + " NoCopySpan, which makes sure it gets dropped when creating a new"
+                            + " SpannableStringBuilder from a given CharSequence."
+                            + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
+                            + " bundle. Prior to KitKat, that copy was done using the SpannableString"
+                            + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
+                            + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
+                            + " reference to the textview and therefore the entire view hierarchy & activity"
+                            + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
+                            + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
+                            + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
+                            + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.";
+            excluded.instanceField("android.widget.Editor$EasyEditSpanController", "this$0")
+                    .reason(reason);
+            excluded.instanceField("android.widget.Editor$SpanController", "this$0").reason(reason);
+        }
+    },
+
+    MEDIA_SESSION_LEGACY_HELPER__SINSTANCE(SDK_INT == LOLLIPOP) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance")
+                    .reason("MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
+                            + " keeps a reference to the context it's given the first time"
+                            + " MediaSessionLegacyHelper.getHelper() is called."
+                            + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
+                            + " calling context.getApplicationContext()."
+                            + " Fix: https://github.com/android/platform_frameworks_base/commit"
+                            + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
+                            + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
+                            + " in Application.onCreate() and pass it the application context.");
+        }
+    },
+
+    TEXT_LINE__SCACHED(SDK_INT <= LOLLIPOP_MR1) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.staticField("android.text.TextLine", "sCached")
+                    .reason("TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
+                            + " at least two bugs that created memory leaks by not correctly clearing the"
+                            + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
+                            + " https://github.com/android/platform_frameworks_base/commit"
+                            + "/893d6fe48d37f71e683f722457bea646994a10"
+                            + " The second was fixed, not released yet:"
+                            + " https://github.com/android/platform_frameworks_base/commit"
+                            + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
+                            + " To fix this, you could access TextLine.sCached and clear the pool every now"
+                            + " and then (e.g. on activity destroy).");
+        }
+    },
+
+    BLOCKING_QUEUE() {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            String reason = "A thread waiting on a blocking queue will leak the last"
+                    + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
+                    + " keeps a local reference to the last message it received. That message then gets"
+                    + " recycled and can be used again. As long as all messages are recycled after being"
+                    + "used, this won't be a problem, because these references are cleared when being"
+                    + "recycled. However, dialogs create template Message instances to be copied when a"
+                    + "message needs to be sent. These Message templates holds references to the dialog"
+                    + "listeners, which most likely leads to holding a reference onto the activity in some"
+                    + "way. Dialogs never recycle their template Message, assuming these Message instances"
+                    + " will get GCed when the dialog is GCed."
+                    + " The combination of these two things creates a high potential for memory leaks as soon"
+                    + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
+                    + " sleep for a long time."
+                    + " To fix this, you could post empty messages to the idle handler threads from time to"
+                    + " time. This won't be easy because you cannot access all handler threads, but a library"
+                    + "that is widely used should consider doing this for its own handler threads. This leaks"
+                    + "has been shown to happen in both Dalvik and ART.";
+            excluded.instanceField("android.os.Message", "obj").reason(reason);
+            excluded.instanceField("android.os.Message", "next").reason(reason);
+            excluded.instanceField("android.os.Message", "target").reason(reason);
+        }
+    },
+
+    INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= O_MR1) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            String reason = "When we detach a view that receives keyboard input, the InputMethodManager"
+                    + " leaks a reference to it until a new view asks for keyboard input."
+                    + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
+                    + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414";
+            excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView")
+                    .reason(reason);
+            excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView")
+                    .reason(reason);
+            excluded.instanceField("android.view.inputmethod.InputMethodManager",
+                    "mServedInputConnection").reason(reason);
+        }
+    },
+
+    INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= O_MR1) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView")
+                    .reason("The singleton InputMethodManager is holding a reference to mCurRootView long"
+                            + " after the activity has been destroyed."
+                            + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
+                            + "#issuecomment-100579429"
+                            + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414");
+        }
+    },
+
+    LAYOUT_TRANSITION(SDK_INT >= ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("android.animation.LayoutTransition$1", "val$parent")
+                    .reason("LayoutTransition leaks parent ViewGroup through"
+                            + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
+                            + " window is destroyed. Tracked here:"
+                            + " https://code.google.com/p/android/issues/detail?id=171830");
+        }
+    },
+
+    SPELL_CHECKER_SESSION(SDK_INT >= JELLY_BEAN && SDK_INT <= N) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0")
+                    .reason("SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
+                            + " SpellCheckerSession is closed before the service is connected."
+                            + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542");
+        }
+    },
+
+    SPELL_CHECKER(SDK_INT == LOLLIPOP_MR1) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("android.widget.SpellChecker$1", "this$0")
+                    .reason("SpellChecker holds on to a detached view that points to a destroyed activity."
+                            + "mSpellRunnable is being enqueued, and that callback should be removed when "
+                            + "closeSession() is called. Maybe closeSession() wasn't called, or maybe it was "
+                            + "called after the view was detached.");
+        }
+    },
+
+    ACTIVITY_CHOOSE_MODEL(SDK_INT > ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            String reason = "ActivityChooserModel holds a static reference to the last set"
+                    + " ActivityChooserModelPolicy which can be an activity context."
+                    + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
+                    + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0";
+            excluded.instanceField("android.support.v7.internal.widget.ActivityChooserModel",
+                    "mActivityChoserModelPolicy").reason(reason);
+            excluded.instanceField("android.widget.ActivityChooserModel", "mActivityChoserModelPolicy")
+                    .reason(reason);
+        }
+    },
+
+    SPEECH_RECOGNIZER(SDK_INT < LOLLIPOP) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("android.speech.SpeechRecognizer$InternalListener", "this$0")
+                    .reason("Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
+                            + " class and leaked the SpeechRecognizer which leaked an activity context."
+                            + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+                            + " /b37866db469e81aca534ff6186bdafd44352329b");
+        }
+    },
+
+    ACCOUNT_MANAGER(SDK_INT <= O_MR1) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("android.accounts.AccountManager$AmsTask$Response", "this$1")
+                    .reason("AccountManager$AmsTask$Response is a stub and is held in memory by native code,"
+                            + " probably because the reference to the response in the other process hasn't been"
+                            + " cleared."
+                            + " AccountManager$AmsTask is holding on to the activity reference to use for"
+                            + " launching a new sub- Activity."
+                            + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
+                            + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
+                            + " with the returned future to to get the result and correctly start an activity"
+                            + " when it's available.");
+        }
+    },
+
+    MEDIA_SCANNER_CONNECTION(SDK_INT <= LOLLIPOP_MR1) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("android.media.MediaScannerConnection", "mContext")
+                    .reason("The static method MediaScannerConnection.scanFile() takes an activity context"
+                            + " but the service might not disconnect after the activity has been destroyed."
+                            + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
+                            + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
+                            + " application context. Call connect() and disconnect() manually.");
+        }
+    },
+
+    USER_MANAGER__SINSTANCE(SDK_INT >= JELLY_BEAN_MR2 && SDK_INT < O) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("android.os.UserManager", "mContext")
+                    .reason("UserManager has a static sInstance field that creates an instance and caches it"
+                            + " the first time UserManager.get() is called. This instance is created with the"
+                            + " outer context (which is an activity base context)."
+                            + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
+                            + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
+                            + "/27db46850b708070452c0ce49daf5f79503fbde6"
+                            + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
+                            + " UserManager instance gets cached with a reference to the application context.");
+        }
+    },
+
+    APP_WIDGET_HOST_CALLBACKS(SDK_INT < LOLLIPOP_MR1) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("android.appwidget.AppWidgetHost$Callbacks", "this$0")
+                    .reason("android.appwidget.AppWidgetHost$Callbacks is a stub and is held in memory native"
+                            + " code. The reference to the `mContext` was not being cleared, which caused the"
+                            + " Callbacks instance to retain this reference"
+                            + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+                            + "/7a96f3c917e0001ee739b65da37b2fadec7d7765");
+        }
+    },
+
+    AUDIO_MANAGER(SDK_INT <= LOLLIPOP_MR1) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("android.media.AudioManager$1", "this$0")
+                    .reason("Prior to Android M, VideoView required audio focus from AudioManager and"
+                            + " never abandoned it, which leaks the Activity context through the AudioManager."
+                            + " The root of the problem is that AudioManager uses whichever"
+                            + " context it receives, which in the case of the VideoView example is an Activity,"
+                            + " even though it only needs the application's context. The issue is fixed in"
+                            + " Android M, and the AudioManager now uses the application's context."
+                            + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
+                            + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2");
+        }
+    },
+
+    EDITTEXT_BLINK_MESSAGEQUEUE(SDK_INT <= LOLLIPOP_MR1) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("android.widget.Editor$Blink", "this$0")
+                    .reason("The EditText Blink of the Cursor is implemented using a callback and Messages,"
+                            + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
+                            + " contains a blinking cursor is detached, a message is posted with a delay after the"
+                            + " dialog has been closed and as a result leaks the Activity."
+                            + " This can be fixed manually by calling TextView.setCursorVisible(false) in the"
+                            + " dismiss() method of the dialog."
+                            + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
+                            + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
+                            + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/");
+        }
+    },
+
+    CONNECTIVITY_MANAGER__SINSTANCE(SDK_INT <= M) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("android.net.ConnectivityManager", "sInstance")
+                    .reason("ConnectivityManager has a sInstance field that is set when the first"
+                            + "ConnectivityManager instance is created. ConnectivityManager has a mContext field."
+                            + "When calling activity.getSystemService(Context.CONNECTIVITY_SERVICE) , the first"
+                            + "ConnectivityManager instance is created with the activity context and stored in"
+                            + "sInstance. That activity context then leaks forever."
+                            + "Until this is fixed, app developers can prevent this leak by making sure the"
+                            + " ConnectivityManager is first created with an App Context. E.g. in some static"
+                            + " init do: context.getApplicationContext()"
+                            + ".getSystemService(Context.CONNECTIVITY_SERVICE)"
+                            + " Tracked here: https://code.google.com/p/android/issues/detail?id=198852"
+                            + " Introduced here: https://github.com/android/platform_frameworks_base/commit/"
+                            + "e0bef71662d81caaaa0d7214fb0bef5d39996a69");
+        }
+    },
+
+    ACCESSIBILITY_NODE_INFO__MORIGINALTEXT(SDK_INT >= O && SDK_INT <= O_MR1) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("android.view.accessibility.AccessibilityNodeInfo", "mOriginalText")
+                    .reason("AccessibilityNodeInfo has a static sPool of AccessibilityNodeInfo. When "
+                            + "AccessibilityNodeInfo instances are released back in the pool, "
+                            + "AccessibilityNodeInfo.clear() does not clear the mOriginalText field, which "
+                            + "causes spans to leak which in turns causes TextView.ChangeWatcher to leak and the "
+                            + "whole view hierarchy. Introduced here: https://android.googlesource.com/platform/"
+                            + "frameworks/base/+/193520e3dff5248ddcf8435203bf99d2ba667219%5E%21/core/java/"
+                            + "android/view/accessibility/AccessibilityNodeInfo.java");
+        }
+    },
+
+    BACKDROP_FRAME_RENDERER__MDECORVIEW(SDK_INT >= N && SDK_INT <= O) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("com.android.internal.policy.BackdropFrameRenderer", "mDecorView")
+                    .reason("When BackdropFrameRenderer.releaseRenderer() is called, there's an unknown case "
+                            + "where mRenderer becomes null but mChoreographer doesn't and the thread doesn't"
+                            + "stop and ends up leaking mDecorView which itself holds on to a destroyed"
+                            + "activity");
+        }
+    },
+
+    // ######## Manufacturer specific Excluded refs ########
+
+    INSTRUMENTATION_RECOMMEND_ACTIVITY(
+            MEIZU.equals(MANUFACTURER) && SDK_INT >= LOLLIPOP && SDK_INT <= LOLLIPOP_MR1) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.staticField("android.app.Instrumentation", "mRecommendActivity")
+                    .reason("Instrumentation would leak com.android.internal.app.RecommendActivity (in "
+                            + "framework.jar) in Meizu FlymeOS 4.5 and above, which is based on Android 5.0 and "
+                            + "above");
+        }
+    },
+
+    DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER(
+            MOTOROLA.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP_MR1) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            if (MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+                excluded.instanceField("android.app.admin.DevicePolicyManager$SettingsObserver", "this$0")
+                        .reason("DevicePolicyManager keeps a reference to the context it has been created with"
+                                + " instead of extracting the application context. In this Motorola build,"
+                                + " DevicePolicyManager has an inner SettingsObserver class that is a content"
+                                + " observer, which is held into memory by a binder transport object.");
+            }
+        }
+    },
+
+    SPEN_GESTURE_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext")
+                    .reason("SpenGestureManager has a static mContext field that leaks a reference to the"
+                            + " activity. Yes, a STATIC mContext field.");
+        }
+    },
+
+    GESTURE_BOOST_MANAGER(HUAWEI.equals(MANUFACTURER) && SDK_INT >= N && SDK_INT <= N_MR1) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.staticField("android.gestureboost.GestureBoostManager", "mContext")
+                    .reason("GestureBoostManager is a static singleton that leaks an activity context."
+                            + "Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756");
+        }
+    },
+
+    INPUT_METHOD_MANAGER__LAST_SERVED_VIEW(
+            HUAWEI.equals(MANUFACTURER) && SDK_INT >= M && SDK_INT <= O_MR1) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            String reason = "HUAWEI added a mLastSrvView field to InputMethodManager"
+                    + " that leaks a reference to the last served view.";
+            excluded.instanceField("android.view.inputmethod.InputMethodManager", "mLastSrvView")
+                    .reason(reason);
+        }
+    },
+
+    CLIPBOARD_UI_MANAGER__SINSTANCE(
+            SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("android.sec.clipboard.ClipboardUIManager", "mContext")
+                    .reason("ClipboardUIManager is a static singleton that leaks an activity context."
+                            + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
+                            + " , so that the ClipboardUIManager instance gets cached with a reference to the"
+                            + " application context. Example: https://gist.github.com/cypressious/"
+                            + "91c4fb1455470d803a602838dfcd5774");
+        }
+    },
+
+    SEM_CLIPBOARD_MANAGER__MCONTEXT(
+            SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= N) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("com.samsung.android.content.clipboard.SemClipboardManager",
+                    "mContext")
+                    .reason("SemClipboardManager is held in memory by an anonymous inner class "
+                            + "implementation of android.os.Binder, thereby leaking an activity context.");
+        }
+    },
+
+    SEM_EMERGENCY_MANAGER__MCONTEXT(
+            SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= N) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("com.samsung.android.emergencymode.SemEmergencyManager", "mContext")
+                    .reason("SemEmergencyManager is a static singleton that leaks a DecorContext. "
+                            + "Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d");
+        }
+    },
+
+    BUBBLE_POPUP_HELPER__SHELPER(
+            LG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.staticField("android.widget.BubblePopupHelper", "sHelper")
+                    .reason("A static helper for EditText bubble popups leaks a reference to the latest"
+                            + "focused view.");
+        }
+    },
+
+    LGCONTEXT__MCONTEXT(LG.equals(MANUFACTURER) && SDK_INT == LOLLIPOP) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("com.lge.systemservice.core.LGContext", "mContext")
+                    .reason("LGContext is a static singleton that leaks an activity context.");
+        }
+    },
+
+    AW_RESOURCE__SRESOURCES(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            // AwResource#setResources() is called with resources that hold a reference to the
+            // activity context (instead of the application context) and doesn't clear it.
+            // Not sure what's going on there, input welcome.
+            excluded.staticField("com.android.org.chromium.android_webview.AwResource", "sResources");
+        }
+    },
+
+    MAPPER_CLIENT(NVIDIA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("com.nvidia.ControllerMapper.MapperClient$ServiceClient", "this$0")
+                    .reason("Not sure exactly what ControllerMapper is about, but there is an anonymous"
+                            + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
+                            + " ControllerMapper.MapperClient which leaks the activity context.");
+        }
+    },
+
+    TEXT_VIEW__MLAST_HOVERED_VIEW(
+            SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= O) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.staticField("android.widget.TextView", "mLastHoveredView")
+                    .reason("mLastHoveredView is a static field in TextView that leaks the last hovered"
+                            + " view.");
+        }
+    },
+
+    PERSONA_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("android.os.PersonaManager", "mContext")
+                    .reason("android.app.LoadedApk.mResources has a reference to"
+                            + " android.content.res.Resources.mPersonaManager which has a reference to"
+                            + " android.os.PersonaManager.mContext which is an activity.");
+        }
+    },
+
+    RESOURCES__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("android.content.res.Resources", "mContext")
+                    .reason("In AOSP the Resources class does not have a context."
+                            + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
+                            + " instance that has a context that is the activity."
+                            + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184");
+        }
+    },
+
+    VIEW_CONFIGURATION__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.instanceField("android.view.ViewConfiguration", "mContext")
+                    .reason("In AOSP the ViewConfiguration class does not have a context."
+                            + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
+                            + " ViewConfiguration instance that has a context that is the activity."
+                            + " Observed here: https://github.com/square/leakcanary/issues"
+                            + "/1#issuecomment-100324683");
+        }
+    },
+
+    SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL((LENOVO.equals(MANUFACTURER) && SDK_INT == KITKAT) //
+            || (VIVO.equals(MANUFACTURER) && SDK_INT == LOLLIPOP_MR1)) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.staticField("android.hardware.SystemSensorManager", "mAppContextImpl")
+                    .reason("SystemSensorManager stores a reference to context "
+                            + "in a static field in its constructor."
+                            + "Fix: use application context to get SensorManager");
+        }
+    },
+
+    AUDIO_MANAGER__MCONTEXT_STATIC(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.staticField("android.media.AudioManager", "mContext_static")
+                    .reason("Samsung added a static mContext_static field to AudioManager, holds a reference"
+                            + " to the activity."
+                            + " Observed here: https://github.com/square/leakcanary/issues/32");
+        }
+    },
+
+    ACTIVITY_MANAGER_MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == LOLLIPOP_MR1) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.staticField("android.app.ActivityManager", "mContext")
+                    .reason("Samsung added a static mContext field to ActivityManager, holds a reference"
+                            + " to the activity."
+                            + " Observed here: https://github.com/square/leakcanary/issues/177 Fix in comment:"
+                            + " https://github.com/square/leakcanary/issues/177#issuecomment-222724283");
+        }
+    },
+
+    // ######## General Excluded refs ########
+
+    SOFT_REFERENCES {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.clazz(WeakReference.class.getName()).alwaysExclude();
+            excluded.clazz(SoftReference.class.getName()).alwaysExclude();
+            excluded.clazz(PhantomReference.class.getName()).alwaysExclude();
+            excluded.clazz("java.lang.ref.Finalizer").alwaysExclude();
+            excluded.clazz("java.lang.ref.FinalizerReference").alwaysExclude();
+        }
+    },
+
+    FINALIZER_WATCHDOG_DAEMON {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
+            // reference to the object and it was about to be GCed.
+            excluded.thread("FinalizerWatchdogDaemon").alwaysExclude();
+        }
+    },
+
+    MAIN {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            // The main thread stack is ever changing so local variables aren't likely to hold references
+            // for long. If this is on the shortest path, it's probably that there's a longer path with
+            // a real leak.
+            excluded.thread("main").alwaysExclude();
+        }
+    },
+
+    LEAK_CANARY_THREAD {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            excluded.thread(LEAK_CANARY_THREAD_NAME).alwaysExclude();
+        }
+    },
+
+    EVENT_RECEIVER__MMESSAGE_QUEUE {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
+            // the native peer of the receiver is using them.
+            // The main thread message queue is held on by the main Looper, but that might be a longer
+            // path. Let's not confuse people with a shorter path that is less meaningful.
+            excluded.instanceField("android.view.Choreographer$FrameDisplayEventReceiver",
+                    "mMessageQueue").alwaysExclude();
+        }
+    },
+
+    VIEWLOCATIONHOLDER_ROOT(SDK_INT == P) {
+        @Override
+        void add(ExcludedRefs.Builder excluded) {
+            //  In Android P, ViewLocationHolder has an mRoot field that is not cleared in its clear()
+            // method.
+            // Introduced in https://github.com/aosp-mirror/platform_frameworks_base/commit/86b326012813f09d8f1de7d6d26c986a909de894
+            // Bug report: https://issuetracker.google.com/issues/112792715
+            excluded.instanceField("android.view.ViewGroup$ViewLocationHolder",
+                    "mRoot");
+        }
+    };
+
+    /**
+     * This returns the references in the leak path that should be ignored by all on Android.
+     */
+    public static @NonNull
+    ExcludedRefs.Builder createAndroidDefaults() {
+        return createBuilder(
+                EnumSet.of(SOFT_REFERENCES, FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
+                        EVENT_RECEIVER__MMESSAGE_QUEUE));
+    }
+
+    /**
+     * This returns the references in the leak path that can be ignored for app developers. This
+     * doesn't mean there is no memory leak, to the contrary. However, some leaks are caused by bugs
+     * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
+     * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
+     */
+    public static @NonNull
+    ExcludedRefs.Builder createAppDefaults() {
+        return createBuilder(EnumSet.allOf(AndroidExcludedRefs.class));
+    }
+
+    public static @NonNull
+    ExcludedRefs.Builder createBuilder(EnumSet<AndroidExcludedRefs> refs) {
+        ExcludedRefs.Builder excluded = ExcludedRefs.builder();
+        for (AndroidExcludedRefs ref : refs) {
+            if (ref.applies) {
+                ref.add(excluded);
+                ((ExcludedRefs.BuilderWithParams) excluded).named(ref.name());
+            }
+        }
+        return excluded;
+    }
+
+    final boolean applies;
+
+    AndroidExcludedRefs() {
+        this(true);
+    }
+
+    AndroidExcludedRefs(boolean applies) {
+        this.applies = applies;
+    }
+
+    abstract void add(ExcludedRefs.Builder excluded);
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
index 12af6dcf..f088024e 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
@@ -33,108 +33,120 @@
 import com.squareup.leakcanary.internal.ActivityLifecycleCallbacksAdapter;
 import com.squareup.leakcanary.internal.FutureResult;
 import com.squareup.leakcanary.internal.LeakCanaryInternals;
+
 import java.io.File;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
 
 public final class AndroidHeapDumper implements HeapDumper {
 
-  private final Context context;
-  private final LeakDirectoryProvider leakDirectoryProvider;
-  private final Handler mainHandler;
+    private final Context context;
+    private final LeakDirectoryProvider leakDirectoryProvider;
+    private final Handler mainHandler;
+
+    private Activity resumedActivity;
+
+    public AndroidHeapDumper(@NonNull Context context,
+                             @NonNull LeakDirectoryProvider leakDirectoryProvider) {
+        this.leakDirectoryProvider = leakDirectoryProvider;
+        this.context = context.getApplicationContext();
+        mainHandler = new Handler(Looper.getMainLooper());
+
+        Application application = (Application) context.getApplicationContext();
+        application.registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacksAdapter() {
+            @Override
+            public void onActivityResumed(Activity activity) {
+                resumedActivity = activity;
+            }
+
+            @Override
+            public void onActivityPaused(Activity activity) {
+                if (resumedActivity == activity) {
+                    resumedActivity = null;
+                }
+            }
+        });
+    }
 
-  private Activity resumedActivity;
+    @SuppressWarnings("ReferenceEquality") // Explicitly checking for named null.
+    @Override
+    @Nullable
+    public File dumpHeap() {
+        File heapDumpFile = leakDirectoryProvider.newHeapDumpFile();
 
-  public AndroidHeapDumper(@NonNull Context context,
-      @NonNull LeakDirectoryProvider leakDirectoryProvider) {
-    this.leakDirectoryProvider = leakDirectoryProvider;
-    this.context = context.getApplicationContext();
-    mainHandler = new Handler(Looper.getMainLooper());
+        if (heapDumpFile == RETRY_LATER) {
+            return RETRY_LATER;
+        }
 
-    Application application = (Application) context.getApplicationContext();
-    application.registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacksAdapter() {
-      @Override public void onActivityResumed(Activity activity) {
-        resumedActivity = activity;
-      }
+        //显示冻结弹层
+        FutureResult<Toast> waitingForToast = new FutureResult<>();
+        showToast(waitingForToast);
 
-      @Override public void onActivityPaused(Activity activity) {
-        if (resumedActivity == activity) {
-          resumedActivity = null;
+        if (!waitingForToast.wait(5, SECONDS)) {
+            CanaryLog.d("Did not dump heap, too much time waiting for Toast.");
+            return RETRY_LATER;
         }
-      }
-    });
-  }
-
-  @SuppressWarnings("ReferenceEquality") // Explicitly checking for named null.
-  @Override @Nullable
-  public File dumpHeap() {
-    File heapDumpFile = leakDirectoryProvider.newHeapDumpFile();
 
-    if (heapDumpFile == RETRY_LATER) {
-      return RETRY_LATER;
+        // 创建并展示 Notification
+        Notification.Builder builder = new Notification.Builder(context)
+                .setContentTitle(context.getString(R.string.leak_canary_notification_dumping));
+        Notification notification = LeakCanaryInternals.buildNotification(context, builder);
+        NotificationManager notificationManager =
+                (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+        int notificationId = (int) SystemClock.uptimeMillis();
+        notificationManager.notify(notificationId, notification);
+
+        Toast toast = waitingForToast.get();
+        try {
+            // 关键实现，调用系统方法，dump堆内存信息，并将其保存到指定文件中
+            Debug.dumpHprofData(heapDumpFile.getAbsolutePath());
+            //隐藏冻结弹层
+            cancelToast(toast);
+            // 取消Notification
+            notificationManager.cancel(notificationId);
+            return heapDumpFile;
+        } catch (Exception e) {
+            CanaryLog.d(e, "Could not dump heap");
+            // Abort heap dump
+            return RETRY_LATER;
+        }
     }
 
-    FutureResult<Toast> waitingForToast = new FutureResult<>();
-    showToast(waitingForToast);
-
-    if (!waitingForToast.wait(5, SECONDS)) {
-      CanaryLog.d("Did not dump heap, too much time waiting for Toast.");
-      return RETRY_LATER;
+    private void showToast(final FutureResult<Toast> waitingForToast) {
+        mainHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                if (resumedActivity == null) {
+                    waitingForToast.set(null);
+                    return;
+                }
+                final Toast toast = new Toast(resumedActivity);
+                toast.setGravity(Gravity.CENTER_VERTICAL, 0, 0);
+                toast.setDuration(Toast.LENGTH_LONG);
+                LayoutInflater inflater = LayoutInflater.from(resumedActivity);
+                toast.setView(inflater.inflate(R.layout.leak_canary_heap_dump_toast, null));
+                toast.show();
+                // Waiting for Idle to make sure Toast gets rendered.
+                Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
+                    @Override
+                    public boolean queueIdle() {
+                        waitingForToast.set(toast);
+                        return false;
+                    }
+                });
+            }
+        });
     }
 
-    Notification.Builder builder = new Notification.Builder(context)
-        .setContentTitle(context.getString(R.string.leak_canary_notification_dumping));
-    Notification notification = LeakCanaryInternals.buildNotification(context, builder);
-    NotificationManager notificationManager =
-        (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
-    int notificationId = (int) SystemClock.uptimeMillis();
-    notificationManager.notify(notificationId, notification);
-
-    Toast toast = waitingForToast.get();
-    try {
-      Debug.dumpHprofData(heapDumpFile.getAbsolutePath());
-      cancelToast(toast);
-      notificationManager.cancel(notificationId);
-      return heapDumpFile;
-    } catch (Exception e) {
-      CanaryLog.d(e, "Could not dump heap");
-      // Abort heap dump
-      return RETRY_LATER;
-    }
-  }
-
-  private void showToast(final FutureResult<Toast> waitingForToast) {
-    mainHandler.post(new Runnable() {
-      @Override public void run() {
-        if (resumedActivity == null) {
-          waitingForToast.set(null);
-          return;
+    private void cancelToast(final Toast toast) {
+        if (toast == null) {
+            return;
         }
-        final Toast toast = new Toast(resumedActivity);
-        toast.setGravity(Gravity.CENTER_VERTICAL, 0, 0);
-        toast.setDuration(Toast.LENGTH_LONG);
-        LayoutInflater inflater = LayoutInflater.from(resumedActivity);
-        toast.setView(inflater.inflate(R.layout.leak_canary_heap_dump_toast, null));
-        toast.show();
-        // Waiting for Idle to make sure Toast gets rendered.
-        Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
-          @Override public boolean queueIdle() {
-            waitingForToast.set(toast);
-            return false;
-          }
+        mainHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                toast.cancel();
+            }
         });
-      }
-    });
-  }
-
-  private void cancelToast(final Toast toast) {
-    if (toast == null) {
-      return;
     }
-    mainHandler.post(new Runnable() {
-      @Override public void run() {
-        toast.cancel();
-      }
-    });
-  }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
index bc72bb11..48ef0d3c 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
@@ -5,129 +5,155 @@
 import com.squareup.leakcanary.internal.DisplayLeakActivity;
 import com.squareup.leakcanary.internal.FragmentRefWatcher;
 import com.squareup.leakcanary.internal.LeakCanaryInternals;
+
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 
 import static com.squareup.leakcanary.RefWatcher.DISABLED;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
-/** A {@link RefWatcherBuilder} with appropriate Android defaults. */
+/**
+ * A {@link RefWatcherBuilder} with appropriate Android defaults.
+ */
 public final class AndroidRefWatcherBuilder extends RefWatcherBuilder<AndroidRefWatcherBuilder> {
 
-  private static final long DEFAULT_WATCH_DELAY_MILLIS = SECONDS.toMillis(5);
-
-  private final Context context;
-  private boolean watchActivities = true;
-  private boolean watchFragments = true;
-
-  AndroidRefWatcherBuilder(@NonNull Context context) {
-    this.context = context.getApplicationContext();
-  }
-
-  /**
-   * Sets a custom {@link AbstractAnalysisResultService} to listen to analysis results. This
-   * overrides any call to {@link #heapDumpListener(HeapDump.Listener)}.
-   */
-  public @NonNull AndroidRefWatcherBuilder listenerServiceClass(
-      @NonNull Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
-    return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));
-  }
-
-  /**
-   * Sets a custom delay for how long the {@link RefWatcher} should wait until it checks if a
-   * tracked object has been garbage collected. This overrides any call to {@link
-   * #watchExecutor(WatchExecutor)}.
-   */
-  public @NonNull AndroidRefWatcherBuilder watchDelay(long delay, @NonNull TimeUnit unit) {
-    return watchExecutor(new AndroidWatchExecutor(unit.toMillis(delay)));
-  }
-
-  /**
-   * Whether we should automatically watch activities when calling {@link #buildAndInstall()}.
-   * Default is true.
-   */
-  public @NonNull AndroidRefWatcherBuilder watchActivities(boolean watchActivities) {
-    this.watchActivities = watchActivities;
-    return this;
-  }
-
-  /**
-   * Whether we should automatically watch fragments when calling {@link #buildAndInstall()}.
-   * Default is true. When true, LeakCanary watches native fragments on Android O+ and support
-   * fragments if the leakcanary-support-fragment dependency is in the classpath.
-   */
-  public @NonNull AndroidRefWatcherBuilder watchFragments(boolean watchFragments) {
-    this.watchFragments = watchFragments;
-    return this;
-  }
-
-  /**
-   * Sets the maximum number of heap dumps stored. This overrides any call to
-   * {@link LeakCanary#setLeakDirectoryProvider(LeakDirectoryProvider)}
-   *
-   * @throws IllegalArgumentException if maxStoredHeapDumps < 1.
-   */
-  public @NonNull AndroidRefWatcherBuilder maxStoredHeapDumps(int maxStoredHeapDumps) {
-    LeakDirectoryProvider leakDirectoryProvider =
-        new DefaultLeakDirectoryProvider(context, maxStoredHeapDumps);
-    LeakCanary.setLeakDirectoryProvider(leakDirectoryProvider);
-    return self();
-  }
-
-  /**
-   * Creates a {@link RefWatcher} instance and makes it available through {@link
-   * LeakCanary#installedRefWatcher()}.
-   *
-   * Also starts watching activity references if {@link #watchActivities(boolean)} was set to true.
-   *
-   * @throws UnsupportedOperationException if called more than once per Android process.
-   */
-  public @NonNull RefWatcher buildAndInstall() {
-    if (LeakCanaryInternals.installedRefWatcher != null) {
-      throw new UnsupportedOperationException("buildAndInstall() should only be called once.");
+    private static final long DEFAULT_WATCH_DELAY_MILLIS = SECONDS.toMillis(5);
+
+    private final Context context;
+    private boolean watchActivities = true;
+    private boolean watchFragments = true;
+
+    AndroidRefWatcherBuilder(@NonNull Context context) {
+        this.context = context.getApplicationContext();
+    }
+
+    /**
+     * Sets a custom {@link AbstractAnalysisResultService} to listen to analysis results. This
+     * overrides any call to {@link #heapDumpListener(HeapDump.Listener)}.
+     */
+    public @NonNull
+    AndroidRefWatcherBuilder listenerServiceClass(
+            @NonNull Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
+        return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));
+    }
+
+    /**
+     * Sets a custom delay for how long the {@link RefWatcher} should wait until it checks if a
+     * tracked object has been garbage collected. This overrides any call to {@link
+     * #watchExecutor(WatchExecutor)}.
+     */
+    public @NonNull
+    AndroidRefWatcherBuilder watchDelay(long delay, @NonNull TimeUnit unit) {
+        return watchExecutor(new AndroidWatchExecutor(unit.toMillis(delay)));
+    }
+
+    /**
+     * Whether we should automatically watch activities when calling {@link #buildAndInstall()}.
+     * Default is true.
+     */
+    public @NonNull
+    AndroidRefWatcherBuilder watchActivities(boolean watchActivities) {
+        this.watchActivities = watchActivities;
+        return this;
+    }
+
+    /**
+     * Whether we should automatically watch fragments when calling {@link #buildAndInstall()}.
+     * Default is true. When true, LeakCanary watches native fragments on Android O+ and support
+     * fragments if the leakcanary-support-fragment dependency is in the classpath.
+     */
+    public @NonNull
+    AndroidRefWatcherBuilder watchFragments(boolean watchFragments) {
+        this.watchFragments = watchFragments;
+        return this;
+    }
+
+    /**
+     * Sets the maximum number of heap dumps stored. This overrides any call to
+     * {@link LeakCanary#setLeakDirectoryProvider(LeakDirectoryProvider)}
+     *
+     * @throws IllegalArgumentException if maxStoredHeapDumps < 1.
+     */
+    public @NonNull
+    AndroidRefWatcherBuilder maxStoredHeapDumps(int maxStoredHeapDumps) {
+        LeakDirectoryProvider leakDirectoryProvider =
+                new DefaultLeakDirectoryProvider(context, maxStoredHeapDumps);
+        LeakCanary.setLeakDirectoryProvider(leakDirectoryProvider);
+        return self();
+    }
+
+    /**
+     * Creates a {@link RefWatcher} instance and makes it available through {@link
+     * LeakCanary#installedRefWatcher()}.
+     * <p>
+     * Also starts watching activity references if {@link #watchActivities(boolean)} was set to true.
+     *
+     * @throws UnsupportedOperationException if called more than once per Android process.
+     */
+    public @NonNull
+    RefWatcher buildAndInstall() {
+        if (LeakCanaryInternals.installedRefWatcher != null) {
+            throw new UnsupportedOperationException("buildAndInstall() should only be called once.");
+        }
+        // 1、通过build方法创建 RefWatcher对象
+        RefWatcher refWatcher = build();
+        if (refWatcher != DISABLED) {
+            // 2、开启 DisplayLeakActivity
+            LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);
+            // 3、开始监测
+            if (watchActivities) {
+                // watch Activity
+                ActivityRefWatcher.install(context, refWatcher);
+            }
+            if (watchFragments) {
+                // watch Fragment and View（in Fragment）
+                FragmentRefWatcher.Helper.install(context, refWatcher);
+            }
+        }
+        LeakCanaryInternals.installedRefWatcher = refWatcher;
+        return refWatcher;
+    }
+
+    @Override
+    protected boolean isDisabled() {
+        return LeakCanary.isInAnalyzerProcess(context);
+    }
+
+    @Override
+    protected @NonNull
+    HeapDumper defaultHeapDumper() {
+        LeakDirectoryProvider leakDirectoryProvider =
+                LeakCanaryInternals.getLeakDirectoryProvider(context);
+        return new AndroidHeapDumper(context, leakDirectoryProvider);
+    }
+
+    @Override
+    protected @NonNull
+    DebuggerControl defaultDebuggerControl() {
+        return new AndroidDebuggerControl();
     }
-    RefWatcher refWatcher = build();
-    if (refWatcher != DISABLED) {
-      LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);
-      if (watchActivities) {
-        ActivityRefWatcher.install(context, refWatcher);
-      }
-      if (watchFragments) {
-        FragmentRefWatcher.Helper.install(context, refWatcher);
-      }
+
+    @Override
+    protected @NonNull
+    HeapDump.Listener defaultHeapDumpListener() {
+        return new ServiceHeapDumpListener(context, DisplayLeakService.class);
+    }
+
+    @Override
+    protected @NonNull
+    ExcludedRefs defaultExcludedRefs() {
+        return AndroidExcludedRefs.createAppDefaults().build();
+    }
+
+    @Override
+    protected @NonNull
+    WatchExecutor defaultWatchExecutor() {
+        return new AndroidWatchExecutor(DEFAULT_WATCH_DELAY_MILLIS);
+    }
+
+    @Override
+    protected @NonNull
+    List<Class<? extends Reachability.Inspector>> defaultReachabilityInspectorClasses() {
+        return AndroidReachabilityInspectors.defaultAndroidInspectors();
     }
-    LeakCanaryInternals.installedRefWatcher = refWatcher;
-    return refWatcher;
-  }
-
-  @Override protected boolean isDisabled() {
-    return LeakCanary.isInAnalyzerProcess(context);
-  }
-
-  @Override protected @NonNull HeapDumper defaultHeapDumper() {
-    LeakDirectoryProvider leakDirectoryProvider =
-        LeakCanaryInternals.getLeakDirectoryProvider(context);
-    return new AndroidHeapDumper(context, leakDirectoryProvider);
-  }
-
-  @Override protected @NonNull DebuggerControl defaultDebuggerControl() {
-    return new AndroidDebuggerControl();
-  }
-
-  @Override protected @NonNull HeapDump.Listener defaultHeapDumpListener() {
-    return new ServiceHeapDumpListener(context, DisplayLeakService.class);
-  }
-
-  @Override protected @NonNull ExcludedRefs defaultExcludedRefs() {
-    return AndroidExcludedRefs.createAppDefaults().build();
-  }
-
-  @Override protected @NonNull WatchExecutor defaultWatchExecutor() {
-    return new AndroidWatchExecutor(DEFAULT_WATCH_DELAY_MILLIS);
-  }
-
-  @Override protected @NonNull
-  List<Class<? extends Reachability.Inspector>> defaultReachabilityInspectorClasses() {
-    return AndroidReachabilityInspectors.defaultAndroidInspectors();
-  }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
index a2455c05..1d41d90e 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
@@ -20,6 +20,7 @@
 import android.support.annotation.NonNull;
 import com.squareup.leakcanary.internal.DisplayLeakActivity;
 import com.squareup.leakcanary.internal.LeakCanaryInternals;
+
 import java.io.File;
 import java.text.SimpleDateFormat;
 import java.util.Date;
@@ -32,105 +33,108 @@
 /**
  * Logs leak analysis results, and then shows a notification which will start {@link
  * DisplayLeakActivity}.
+ * 记录内存泄露分析的结果，然后展示一条Notification，点击这个Notification可以启动DisplayLeakActivity
  * <p>
  * You can extend this class and override {@link #afterDefaultHandling(HeapDump, AnalysisResult,
  * String)} to add custom behavior, e.g. uploading the heap dump.
+ * 你可以继承这个类，并重写afterDefaultHandling方法，以便添加自定义的行为，例如上传heap文件
  */
 public class DisplayLeakService extends AbstractAnalysisResultService {
 
-  @Override
-  protected final void onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap) {
-    HeapDump heapDump = analyzedHeap.heapDump;
-    AnalysisResult result = analyzedHeap.result;
+    @Override
+    protected final void onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap) {
+        HeapDump heapDump = analyzedHeap.heapDump;
+        AnalysisResult result = analyzedHeap.result;
 
-    String leakInfo = leakInfo(this, heapDump, result, true);
-    CanaryLog.d("%s", leakInfo);
+        String leakInfo = leakInfo(this, heapDump, result, true);
+        CanaryLog.d("%s", leakInfo);
 
-    boolean resultSaved = false;
-    boolean shouldSaveResult = result.leakFound || result.failure != null;
-    if (shouldSaveResult) {
-      heapDump = renameHeapdump(heapDump);
-      resultSaved = saveResult(heapDump, result);
-    }
+        boolean resultSaved = false;
+        boolean shouldSaveResult = result.leakFound || result.failure != null;
+        if (shouldSaveResult) {
+            heapDump = renameHeapdump(heapDump);
+            resultSaved = saveResult(heapDump, result);
+        }
+
+        if (!shouldSaveResult) {
+            String contentTitle = getString(R.string.leak_canary_no_leak_title);
+            String contentText = getString(R.string.leak_canary_no_leak_text);
+            showNotification(null, contentTitle, contentText);
+        } else if (resultSaved) {
+            String contentTitle;
+            String contentText;
+            PendingIntent pendingIntent =
+                    DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);
 
-    if (!shouldSaveResult) {
-      String contentTitle = getString(R.string.leak_canary_no_leak_title);
-      String contentText = getString(R.string.leak_canary_no_leak_text);
-      showNotification(null, contentTitle, contentText);
-    } else if (resultSaved) {
-      String contentTitle;
-      String contentText;
-      PendingIntent pendingIntent =
-          DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);
-
-      if (result.failure == null) {
-        if (result.retainedHeapSize == AnalysisResult.RETAINED_HEAP_SKIPPED) {
-          String className = classSimpleName(result.className);
-          if (result.excludedLeak) {
-            contentTitle = getString(R.string.leak_canary_leak_excluded, className);
-          } else {
-            contentTitle = getString(R.string.leak_canary_class_has_leaked, className);
-          }
+            if (result.failure == null) {
+                if (result.retainedHeapSize == AnalysisResult.RETAINED_HEAP_SKIPPED) {
+                    String className = classSimpleName(result.className);
+                    if (result.excludedLeak) {
+                        contentTitle = getString(R.string.leak_canary_leak_excluded, className);
+                    } else {
+                        contentTitle = getString(R.string.leak_canary_class_has_leaked, className);
+                    }
+                } else {
+                    String size = formatShortFileSize(this, result.retainedHeapSize);
+                    String className = classSimpleName(result.className);
+                    if (result.excludedLeak) {
+                        contentTitle = getString(R.string.leak_canary_leak_excluded_retaining, className, size);
+                    } else {
+                        contentTitle =
+                                getString(R.string.leak_canary_class_has_leaked_retaining, className, size);
+                    }
+                }
+            } else {
+                contentTitle = getString(R.string.leak_canary_analysis_failed);
+            }
+            contentText = getString(R.string.leak_canary_notification_message);
+            showNotification(pendingIntent, contentTitle, contentText);
         } else {
-          String size = formatShortFileSize(this, result.retainedHeapSize);
-          String className = classSimpleName(result.className);
-          if (result.excludedLeak) {
-            contentTitle = getString(R.string.leak_canary_leak_excluded_retaining, className, size);
-          } else {
-            contentTitle =
-                getString(R.string.leak_canary_class_has_leaked_retaining, className, size);
-          }
+            onAnalysisResultFailure(getString(R.string.leak_canary_could_not_save_text));
+        }
+
+        afterDefaultHandling(heapDump, result, leakInfo);
+    }
+
+    @Override
+    protected final void onAnalysisResultFailure(String failureMessage) {
+        super.onAnalysisResultFailure(failureMessage);
+        String failureTitle = getString(R.string.leak_canary_result_failure_title);
+        showNotification(null, failureTitle, failureMessage);
+    }
+
+    private void showNotification(PendingIntent pendingIntent, String contentTitle,
+                                  String contentText) {
+        // New notification id every second.
+        int notificationId = (int) (SystemClock.uptimeMillis() / 1000);
+        LeakCanaryInternals.showNotification(this, contentTitle, contentText, pendingIntent,
+                notificationId);
+    }
+
+    private boolean saveResult(HeapDump heapDump, AnalysisResult result) {
+        File resultFile = AnalyzedHeap.save(heapDump, result);
+        return resultFile != null;
+    }
+
+    private HeapDump renameHeapdump(HeapDump heapDump) {
+        String fileName =
+                new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'.hprof'", Locale.US).format(new Date());
+
+        File newFile = new File(heapDump.heapDumpFile.getParent(), fileName);
+        boolean renamed = heapDump.heapDumpFile.renameTo(newFile);
+        if (!renamed) {
+            CanaryLog.d("Could not rename heap dump file %s to %s", heapDump.heapDumpFile.getPath(),
+                    newFile.getPath());
         }
-      } else {
-        contentTitle = getString(R.string.leak_canary_analysis_failed);
-      }
-      contentText = getString(R.string.leak_canary_notification_message);
-      showNotification(pendingIntent, contentTitle, contentText);
-    } else {
-      onAnalysisResultFailure(getString(R.string.leak_canary_could_not_save_text));
+        return heapDump.buildUpon().heapDumpFile(newFile).build();
     }
 
-    afterDefaultHandling(heapDump, result, leakInfo);
-  }
-
-  @Override protected final void onAnalysisResultFailure(String failureMessage) {
-    super.onAnalysisResultFailure(failureMessage);
-    String failureTitle = getString(R.string.leak_canary_result_failure_title);
-    showNotification(null, failureTitle, failureMessage);
-  }
-
-  private void showNotification(PendingIntent pendingIntent, String contentTitle,
-      String contentText) {
-    // New notification id every second.
-    int notificationId = (int) (SystemClock.uptimeMillis() / 1000);
-    LeakCanaryInternals.showNotification(this, contentTitle, contentText, pendingIntent,
-        notificationId);
-  }
-
-  private boolean saveResult(HeapDump heapDump, AnalysisResult result) {
-    File resultFile = AnalyzedHeap.save(heapDump, result);
-    return resultFile != null;
-  }
-
-  private HeapDump renameHeapdump(HeapDump heapDump) {
-    String fileName =
-        new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'.hprof'", Locale.US).format(new Date());
-
-    File newFile = new File(heapDump.heapDumpFile.getParent(), fileName);
-    boolean renamed = heapDump.heapDumpFile.renameTo(newFile);
-    if (!renamed) {
-      CanaryLog.d("Could not rename heap dump file %s to %s", heapDump.heapDumpFile.getPath(),
-          newFile.getPath());
+    /**
+     * You can override this method and do a blocking call to a server to upload the leak trace and
+     * the heap dump. Don't forget to check {@link AnalysisResult#leakFound} and {@link
+     * AnalysisResult#excludedLeak} first.
+     */
+    protected void afterDefaultHandling(@NonNull HeapDump heapDump, @NonNull AnalysisResult result,
+                                        @NonNull String leakInfo) {
     }
-    return heapDump.buildUpon().heapDumpFile(newFile).build();
-  }
-
-  /**
-   * You can override this method and do a blocking call to a server to upload the leak trace and
-   * the heap dump. Don't forget to check {@link AnalysisResult#leakFound} and {@link
-   * AnalysisResult#excludedLeak} first.
-   */
-  protected void afterDefaultHandling(@NonNull HeapDump heapDump, @NonNull AnalysisResult result,
-      @NonNull String leakInfo) {
-  }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
index 8f4ab8d7..66a1c53b 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -33,159 +33,174 @@
 
 public final class LeakCanary {
 
-  /**
-   * Creates a {@link RefWatcher} that works out of the box, and starts watching activity
-   * references (on ICS+).
-   */
-  public static @NonNull RefWatcher install(@NonNull Application application) {
-    return refWatcher(application).listenerServiceClass(DisplayLeakService.class)
-        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
-        .buildAndInstall();
-  }
-
-  /**
-   * Returns the {@link RefWatcher} installed via
-   * {@link AndroidRefWatcherBuilder#buildAndInstall()}, and {@link RefWatcher#DISABLED} is no
-   * {@link RefWatcher} has been installed.
-   */
-  public static @NonNull RefWatcher installedRefWatcher() {
-    RefWatcher refWatcher = LeakCanaryInternals.installedRefWatcher;
-    if (refWatcher == null) {
-      return RefWatcher.DISABLED;
+    /**
+     * Creates a {@link RefWatcher} that works out of the box, and starts watching activity
+     * references (on ICS+).
+     * 用于启动 ActivityRefWatcher的，
+     */
+    public static @NonNull
+    RefWatcher install(@NonNull Application application) {
+        // LeakCanary使用的入口
+        return refWatcher(application) //创建AndroidRefWatcherBuilder对象，显然这里将会使用Builder模式
+
+                // 设置分析结果监听的ListenerService，在这个Service中会通过Notification展示内存泄漏
+                .listenerServiceClass(DisplayLeakService.class)
+                // AndroidExcludedRefs就是一个枚举，用来定义白名单
+                // 在白名单里面的泄漏case，不会被记录，也不会通过DisplayLeakService通知给用户
+                // 如果我们发现有系统的内存泄漏，当前是无法解决的，就可以继承这个类，增加相应的白名单，避免开发时不必要的内存泄漏上报
+                .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
+
+                .buildAndInstall();
+    }
+
+    /**
+     * Returns the {@link RefWatcher} installed via
+     * {@link AndroidRefWatcherBuilder#buildAndInstall()}, and {@link RefWatcher#DISABLED} is no
+     * {@link RefWatcher} has been installed.
+     */
+    public static @NonNull
+    RefWatcher installedRefWatcher() {
+        RefWatcher refWatcher = LeakCanaryInternals.installedRefWatcher;
+        if (refWatcher == null) {
+            return RefWatcher.DISABLED;
+        }
+        return refWatcher;
+    }
+
+    public static @NonNull
+    AndroidRefWatcherBuilder refWatcher(@NonNull Context context) {
+        return new AndroidRefWatcherBuilder(context);
+    }
+
+    /**
+     * Blocking inter process call that enables the {@link DisplayLeakActivity}. When you first
+     * install the app, {@link DisplayLeakActivity} is disabled by default and will only be enabled
+     * once a potential leak has been found and the analysis starts. You can call this method to
+     * enable {@link DisplayLeakActivity} before any potential leak has been detected.
+     */
+    public static void enableDisplayLeakActivity(@NonNull Context context) {
+        LeakCanaryInternals.setEnabledBlocking(context, DisplayLeakActivity.class, true);
     }
-    return refWatcher;
-  }
-
-  public static @NonNull AndroidRefWatcherBuilder refWatcher(@NonNull Context context) {
-    return new AndroidRefWatcherBuilder(context);
-  }
-
-  /**
-   * Blocking inter process call that enables the {@link DisplayLeakActivity}. When you first
-   * install the app, {@link DisplayLeakActivity} is disabled by default and will only be enabled
-   * once a potential leak has been found and the analysis starts. You can call this method to
-   * enable {@link DisplayLeakActivity} before any potential leak has been detected.
-   */
-  public static void enableDisplayLeakActivity(@NonNull Context context) {
-    LeakCanaryInternals.setEnabledBlocking(context, DisplayLeakActivity.class, true);
-  }
-
-  /**
-   * @deprecated Use {@link #setLeakDirectoryProvider(LeakDirectoryProvider)} instead.
-   */
-  @Deprecated
-  public static void setDisplayLeakActivityDirectoryProvider(
-      @NonNull LeakDirectoryProvider leakDirectoryProvider) {
-    setLeakDirectoryProvider(leakDirectoryProvider);
-  }
-
-  /**
-   * Used to customize the location for the storage of heap dumps. The default implementation is
-   * {@link DefaultLeakDirectoryProvider}.
-   *
-   * @throws IllegalStateException if a LeakDirectoryProvider has already been set, including
-   * if the default has been automatically set when installing the ref watcher.
-   */
-  public static void setLeakDirectoryProvider(
-      @NonNull LeakDirectoryProvider leakDirectoryProvider) {
-    LeakCanaryInternals.setLeakDirectoryProvider(leakDirectoryProvider);
-  }
-
-  /** Returns a string representation of the result of a heap analysis. */
-  public static @NonNull String leakInfo(@NonNull Context context,
-      @NonNull HeapDump heapDump,
-      @NonNull AnalysisResult result,
-      boolean detailed) {
-    PackageManager packageManager = context.getPackageManager();
-    String packageName = context.getPackageName();
-    PackageInfo packageInfo;
-    try {
-      packageInfo = packageManager.getPackageInfo(packageName, 0);
-    } catch (PackageManager.NameNotFoundException e) {
-      throw new RuntimeException(e);
+
+    /**
+     * @deprecated Use {@link #setLeakDirectoryProvider(LeakDirectoryProvider)} instead.
+     */
+    @Deprecated
+    public static void setDisplayLeakActivityDirectoryProvider(
+            @NonNull LeakDirectoryProvider leakDirectoryProvider) {
+        setLeakDirectoryProvider(leakDirectoryProvider);
     }
-    String versionName = packageInfo.versionName;
-    int versionCode = packageInfo.versionCode;
-    String info = "In " + packageName + ":" + versionName + ":" + versionCode + ".\n";
-    String detailedString = "";
-    if (result.leakFound) {
-      if (result.excludedLeak) {
-        info += "* EXCLUDED LEAK.\n";
-      }
-      info += "* " + result.className;
-      if (!heapDump.referenceName.equals("")) {
-        info += " (" + heapDump.referenceName + ")";
-      }
-      info += " has leaked:\n" + result.leakTrace.toString() + "\n";
-      if (result.retainedHeapSize != AnalysisResult.RETAINED_HEAP_SKIPPED) {
-        info += "* Retaining: " + formatShortFileSize(context, result.retainedHeapSize) + ".\n";
-      }
-      if (detailed) {
-        detailedString = "\n* Details:\n" + result.leakTrace.toDetailedString();
-      }
-    } else if (result.failure != null) {
-      // We duplicate the library version & Sha information because bug reports often only contain
-      // the stacktrace.
-      info += "* FAILURE in " + LIBRARY_VERSION + " " + GIT_SHA + ":" + Log.getStackTraceString(
-          result.failure) + "\n";
-    } else {
-      info += "* NO LEAK FOUND.\n\n";
+
+    /**
+     * Used to customize the location for the storage of heap dumps. The default implementation is
+     * {@link DefaultLeakDirectoryProvider}.
+     *
+     * @throws IllegalStateException if a LeakDirectoryProvider has already been set, including
+     *                               if the default has been automatically set when installing the ref watcher.
+     */
+    public static void setLeakDirectoryProvider(
+            @NonNull LeakDirectoryProvider leakDirectoryProvider) {
+        LeakCanaryInternals.setLeakDirectoryProvider(leakDirectoryProvider);
     }
-    if (detailed) {
-      detailedString += "* Excluded Refs:\n" + heapDump.excludedRefs;
+
+    /**
+     * Returns a string representation of the result of a heap analysis.
+     */
+    public static @NonNull
+    String leakInfo(@NonNull Context context,
+                    @NonNull HeapDump heapDump,
+                    @NonNull AnalysisResult result,
+                    boolean detailed) {
+        PackageManager packageManager = context.getPackageManager();
+        String packageName = context.getPackageName();
+        PackageInfo packageInfo;
+        try {
+            packageInfo = packageManager.getPackageInfo(packageName, 0);
+        } catch (PackageManager.NameNotFoundException e) {
+            throw new RuntimeException(e);
+        }
+        String versionName = packageInfo.versionName;
+        int versionCode = packageInfo.versionCode;
+        String info = "In " + packageName + ":" + versionName + ":" + versionCode + ".\n";
+        String detailedString = "";
+        if (result.leakFound) {
+            if (result.excludedLeak) {
+                info += "* EXCLUDED LEAK.\n";
+            }
+            info += "* " + result.className;
+            if (!heapDump.referenceName.equals("")) {
+                info += " (" + heapDump.referenceName + ")";
+            }
+            info += " has leaked:\n" + result.leakTrace.toString() + "\n";
+            if (result.retainedHeapSize != AnalysisResult.RETAINED_HEAP_SKIPPED) {
+                info += "* Retaining: " + formatShortFileSize(context, result.retainedHeapSize) + ".\n";
+            }
+            if (detailed) {
+                detailedString = "\n* Details:\n" + result.leakTrace.toDetailedString();
+            }
+        } else if (result.failure != null) {
+            // We duplicate the library version & Sha information because bug reports often only contain
+            // the stacktrace.
+            info += "* FAILURE in " + LIBRARY_VERSION + " " + GIT_SHA + ":" + Log.getStackTraceString(
+                    result.failure) + "\n";
+        } else {
+            info += "* NO LEAK FOUND.\n\n";
+        }
+        if (detailed) {
+            detailedString += "* Excluded Refs:\n" + heapDump.excludedRefs;
+        }
+
+        info += "* Reference Key: "
+                + heapDump.referenceKey
+                + "\n"
+                + "* Device: "
+                + Build.MANUFACTURER
+                + " "
+                + Build.BRAND
+                + " "
+                + Build.MODEL
+                + " "
+                + Build.PRODUCT
+                + "\n"
+                + "* Android Version: "
+                + Build.VERSION.RELEASE
+                + " API: "
+                + Build.VERSION.SDK_INT
+                + " LeakCanary: "
+                + LIBRARY_VERSION
+                + " "
+                + GIT_SHA
+                + "\n"
+                + "* Durations: watch="
+                + heapDump.watchDurationMs
+                + "ms, gc="
+                + heapDump.gcDurationMs
+                + "ms, heap dump="
+                + heapDump.heapDumpDurationMs
+                + "ms, analysis="
+                + result.analysisDurationMs
+                + "ms"
+                + "\n"
+                + detailedString;
+
+        return info;
     }
 
-    info += "* Reference Key: "
-        + heapDump.referenceKey
-        + "\n"
-        + "* Device: "
-        + Build.MANUFACTURER
-        + " "
-        + Build.BRAND
-        + " "
-        + Build.MODEL
-        + " "
-        + Build.PRODUCT
-        + "\n"
-        + "* Android Version: "
-        + Build.VERSION.RELEASE
-        + " API: "
-        + Build.VERSION.SDK_INT
-        + " LeakCanary: "
-        + LIBRARY_VERSION
-        + " "
-        + GIT_SHA
-        + "\n"
-        + "* Durations: watch="
-        + heapDump.watchDurationMs
-        + "ms, gc="
-        + heapDump.gcDurationMs
-        + "ms, heap dump="
-        + heapDump.heapDumpDurationMs
-        + "ms, analysis="
-        + result.analysisDurationMs
-        + "ms"
-        + "\n"
-        + detailedString;
-
-    return info;
-  }
-
-  /**
-   * Whether the current process is the process running the {@link HeapAnalyzerService}, which is
-   * a different process than the normal app process.
-   */
-  public static boolean isInAnalyzerProcess(@NonNull Context context) {
-    Boolean isInAnalyzerProcess = LeakCanaryInternals.isInAnalyzerProcess;
-    // This only needs to be computed once per process.
-    if (isInAnalyzerProcess == null) {
-      isInAnalyzerProcess = isInServiceProcess(context, HeapAnalyzerService.class);
-      LeakCanaryInternals.isInAnalyzerProcess = isInAnalyzerProcess;
+    /**
+     * Whether the current process is the process running the {@link HeapAnalyzerService}, which is
+     * a different process than the normal app process.
+     */
+    public static boolean isInAnalyzerProcess(@NonNull Context context) {
+        Boolean isInAnalyzerProcess = LeakCanaryInternals.isInAnalyzerProcess;
+        // This only needs to be computed once per process.
+        if (isInAnalyzerProcess == null) {
+            isInAnalyzerProcess = isInServiceProcess(context, HeapAnalyzerService.class);
+            LeakCanaryInternals.isInAnalyzerProcess = isInAnalyzerProcess;
+        }
+        return isInAnalyzerProcess;
     }
-    return isInAnalyzerProcess;
-  }
 
-  private LeakCanary() {
-    throw new AssertionError();
-  }
+    private LeakCanary() {
+        throw new AssertionError();
+    }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
index 4d1fa1a1..1d93bbd0 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
@@ -23,17 +23,19 @@
 
 public final class ServiceHeapDumpListener implements HeapDump.Listener {
 
-  private final Context context;
-  private final Class<? extends AbstractAnalysisResultService> listenerServiceClass;
+    private final Context context;
+    private final Class<? extends AbstractAnalysisResultService> listenerServiceClass;
 
-  public ServiceHeapDumpListener(@NonNull final Context context,
-      @NonNull final Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
-    this.listenerServiceClass = checkNotNull(listenerServiceClass, "listenerServiceClass");
-    this.context = checkNotNull(context, "context").getApplicationContext();
-  }
+    public ServiceHeapDumpListener(@NonNull final Context context,
+                                   @NonNull final Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
+        this.listenerServiceClass = checkNotNull(listenerServiceClass, "listenerServiceClass");
+        this.context = checkNotNull(context, "context").getApplicationContext();
+    }
 
-  @Override public void analyze(@NonNull HeapDump heapDump) {
-    checkNotNull(heapDump, "heapDump");
-    HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass);
-  }
+    @Override
+    public void analyze(@NonNull HeapDump heapDump) {
+        checkNotNull(heapDump, "heapDump");
+        // 开启Service，开始分析
+        HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass);
+    }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/ForegroundService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/ForegroundService.java
index b2773db3..0449e5b7 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/ForegroundService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/ForegroundService.java
@@ -25,44 +25,49 @@
 
 public abstract class ForegroundService extends IntentService {
 
-  private final int notificationContentTitleResId;
-  private final int notificationId;
+    private final int notificationContentTitleResId;
+    private final int notificationId;
 
-  public ForegroundService(String name, int notificationContentTitleResId) {
-    super(name);
-    this.notificationContentTitleResId = notificationContentTitleResId;
-    notificationId = (int) SystemClock.uptimeMillis();
-  }
+    public ForegroundService(String name, int notificationContentTitleResId) {
+        super(name);
+        this.notificationContentTitleResId = notificationContentTitleResId;
+        notificationId = (int) SystemClock.uptimeMillis();
+    }
 
-  @Override
-  public void onCreate() {
-    super.onCreate();
-    showForegroundNotification(100, 0, true,
-        getString(R.string.leak_canary_notification_foreground_text));
-  }
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        showForegroundNotification(100, 0, true,
+                getString(R.string.leak_canary_notification_foreground_text));
+    }
 
-  protected void showForegroundNotification(int max, int progress, boolean indeterminate,
-      String contentText) {
-    Notification.Builder builder = new Notification.Builder(this)
-        .setContentTitle(getString(notificationContentTitleResId))
-        .setContentText(contentText)
-        .setProgress(max, progress, indeterminate);
-    Notification notification = LeakCanaryInternals.buildNotification(this, builder);
-    startForeground(notificationId, notification);
-  }
+    // 将内存泄漏的Notification 展示 出来
+    protected void showForegroundNotification(int max, int progress, boolean indeterminate,
+                                              String contentText) {
+        Notification.Builder builder = new Notification.Builder(this)
+                .setContentTitle(getString(notificationContentTitleResId))
+                .setContentText(contentText)
+                .setProgress(max, progress, indeterminate);
+        Notification notification = LeakCanaryInternals.buildNotification(this, builder);
+        startForeground(notificationId, notification);
+    }
 
-  @Override protected void onHandleIntent(@Nullable Intent intent) {
-    onHandleIntentInForeground(intent);
-  }
+    @Override
+    protected void onHandleIntent(@Nullable Intent intent) {
+        // 将 事件传递到 onHandleIntentInForeground 方法中
+        onHandleIntentInForeground(intent);
+    }
 
-  protected abstract void onHandleIntentInForeground(@Nullable Intent intent);
+    protected abstract void onHandleIntentInForeground(@Nullable Intent intent);
 
-  @Override public void onDestroy() {
-    super.onDestroy();
-    stopForeground(true);
-  }
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        stopForeground(true);
+    }
 
-  @Override public IBinder onBind(Intent intent) {
-    return null;
-  }
+    @Override
+    public IBinder onBind(Intent intent) {
+        return null;
+    }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FragmentRefWatcher.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FragmentRefWatcher.java
index 27f1f177..7e38acc0 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FragmentRefWatcher.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FragmentRefWatcher.java
@@ -20,6 +20,7 @@
 import android.content.Context;
 import android.os.Bundle;
 import com.squareup.leakcanary.RefWatcher;
+
 import java.lang.reflect.Constructor;
 import java.util.ArrayList;
 import java.util.List;
@@ -32,53 +33,57 @@
  */
 public interface FragmentRefWatcher {
 
-  void watchFragments(Activity activity);
+    void watchFragments(Activity activity);
 
-  final class Helper {
+    final class Helper {
 
-    private static final String SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME =
-        "com.squareup.leakcanary.internal.SupportFragmentRefWatcher";
+        private static final String SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME =
+                "com.squareup.leakcanary.internal.SupportFragmentRefWatcher";
 
-    public static void install(Context context, RefWatcher refWatcher) {
-      List<FragmentRefWatcher> fragmentRefWatchers = new ArrayList<>();
+        public static void install(Context context, RefWatcher refWatcher) {
+            List<FragmentRefWatcher> fragmentRefWatchers = new ArrayList<>();
 
-      if (SDK_INT >= O) {
-        fragmentRefWatchers.add(new AndroidOFragmentRefWatcher(refWatcher));
-      }
+            if (SDK_INT >= O) {
+                // Android API 26
+                fragmentRefWatchers.add(new AndroidOFragmentRefWatcher(refWatcher));
+            }
 
-      try {
-        Class<?> fragmentRefWatcherClass = Class.forName(SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME);
-        Constructor<?> constructor =
-            fragmentRefWatcherClass.getDeclaredConstructor(RefWatcher.class);
-        FragmentRefWatcher supportFragmentRefWatcher =
-            (FragmentRefWatcher) constructor.newInstance(refWatcher);
-        fragmentRefWatchers.add(supportFragmentRefWatcher);
-      } catch (Exception ignored) {
-      }
+            try {
+                Class<?> fragmentRefWatcherClass = Class.forName(SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME);
+                Constructor<?> constructor =
+                        fragmentRefWatcherClass.getDeclaredConstructor(RefWatcher.class);
+                FragmentRefWatcher supportFragmentRefWatcher =
+                        (FragmentRefWatcher) constructor.newInstance(refWatcher);
+                fragmentRefWatchers.add(supportFragmentRefWatcher);
+            } catch (Exception ignored) {
+            }
 
-      if (fragmentRefWatchers.size() == 0) {
-        return;
-      }
+            if (fragmentRefWatchers.size() == 0) {
+                return;
+            }
 
-      Helper helper = new Helper(fragmentRefWatchers);
+            Helper helper = new Helper(fragmentRefWatchers);
 
-      Application application = (Application) context.getApplicationContext();
-      application.registerActivityLifecycleCallbacks(helper.activityLifecycleCallbacks);
-    }
+            // 此处，也是 注册Activity生命周期的回调，是为了 在某一Activity create时，就开始监测 其中的Activity
+            Application application = (Application) context.getApplicationContext();
+            application.registerActivityLifecycleCallbacks(helper.activityLifecycleCallbacks);
+        }
 
-    private final Application.ActivityLifecycleCallbacks activityLifecycleCallbacks =
-        new ActivityLifecycleCallbacksAdapter() {
-          @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
-            for (FragmentRefWatcher watcher : fragmentRefWatchers) {
-              watcher.watchFragments(activity);
-            }
-          }
-        };
+        private final Application.ActivityLifecycleCallbacks activityLifecycleCallbacks =
+                new ActivityLifecycleCallbacksAdapter() {
+                    @Override
+                    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
+                        // Activity Create时，为Activity 添加 Fragment的生命周期 Callback
+                        for (FragmentRefWatcher watcher : fragmentRefWatchers) {
+                            watcher.watchFragments(activity);
+                        }
+                    }
+                };
 
-    private final List<FragmentRefWatcher> fragmentRefWatchers;
+        private final List<FragmentRefWatcher> fragmentRefWatchers;
 
-    private Helper(List<FragmentRefWatcher> fragmentRefWatchers) {
-      this.fragmentRefWatchers = fragmentRefWatchers;
+        private Helper(List<FragmentRefWatcher> fragmentRefWatchers) {
+            this.fragmentRefWatchers = fragmentRefWatchers;
+        }
     }
-  }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
index 545d94df..42d54dd2 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
@@ -34,46 +34,54 @@
  * out of memory.
  */
 public final class HeapAnalyzerService extends ForegroundService
-    implements AnalyzerProgressListener {
+        implements AnalyzerProgressListener {
 
-  private static final String LISTENER_CLASS_EXTRA = "listener_class_extra";
-  private static final String HEAPDUMP_EXTRA = "heapdump_extra";
+    private static final String LISTENER_CLASS_EXTRA = "listener_class_extra";
+    private static final String HEAPDUMP_EXTRA = "heapdump_extra";
 
-  public static void runAnalysis(Context context, HeapDump heapDump,
-      Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
-    setEnabledBlocking(context, HeapAnalyzerService.class, true);
-    setEnabledBlocking(context, listenerServiceClass, true);
-    Intent intent = new Intent(context, HeapAnalyzerService.class);
-    intent.putExtra(LISTENER_CLASS_EXTRA, listenerServiceClass.getName());
-    intent.putExtra(HEAPDUMP_EXTRA, heapDump);
-    ContextCompat.startForegroundService(context, intent);
-  }
-
-  public HeapAnalyzerService() {
-    super(HeapAnalyzerService.class.getSimpleName(), R.string.leak_canary_notification_analysing);
-  }
+    public static void runAnalysis(Context context, HeapDump heapDump,
+                                   Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
+        setEnabledBlocking(context, HeapAnalyzerService.class, true);
+        setEnabledBlocking(context, listenerServiceClass, true);
+        Intent intent = new Intent(context, HeapAnalyzerService.class);
+        intent.putExtra(LISTENER_CLASS_EXTRA, listenerServiceClass.getName());
+        intent.putExtra(HEAPDUMP_EXTRA, heapDump);
+        //开启一个 前台Service
+        ContextCompat.startForegroundService(context, intent);
+    }
 
-  @Override protected void onHandleIntentInForeground(@Nullable Intent intent) {
-    if (intent == null) {
-      CanaryLog.d("HeapAnalyzerService received a null intent, ignoring.");
-      return;
+    public HeapAnalyzerService() {
+        super(HeapAnalyzerService.class.getSimpleName(), R.string.leak_canary_notification_analysing);
     }
-    String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);
-    HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);
 
-    HeapAnalyzer heapAnalyzer =
-        new HeapAnalyzer(heapDump.excludedRefs, this, heapDump.reachabilityInspectorClasses);
+    @Override
+    protected void onHandleIntentInForeground(@Nullable Intent intent) {
+        // 判断并获取 传递进来的参数
+        if (intent == null) {
+            CanaryLog.d("HeapAnalyzerService received a null intent, ignoring.");
+            return;
+        }
+        String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);
+        HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);
+
+        // 创建 HeapAnalyzer对象
+        HeapAnalyzer heapAnalyzer =
+                new HeapAnalyzer(heapDump.excludedRefs, this, heapDump.reachabilityInspectorClasses);
 
-    AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey,
-        heapDump.computeRetainedHeapSize);
-    AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);
-  }
+        // 开始 分析 内存泄露
+        AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey,
+                heapDump.computeRetainedHeapSize);
 
-  @Override public void onProgressUpdate(Step step) {
-    int percent = (int) ((100f * step.ordinal()) / Step.values().length);
-    CanaryLog.d("Analysis in progress, working on: %s", step.name());
-    String lowercase = step.name().replace("_", " ").toLowerCase();
-    String message = lowercase.substring(0, 1).toUpperCase() + lowercase.substring(1);
-    showForegroundNotification(100, percent, false, message);
-  }
+        // 将结果传递给 Listener
+        AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);
+    }
+
+    @Override
+    public void onProgressUpdate(Step step) {
+        int percent = (int) ((100f * step.ordinal()) / Step.values().length);
+        CanaryLog.d("Analysis in progress, working on: %s", step.name());
+        String lowercase = step.name().replace("_", " ").toLowerCase();
+        String message = lowercase.substring(0, 1).toUpperCase() + lowercase.substring(1);
+        showForegroundNotification(100, percent, false, message);
+    }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
index 6a776235..685a1086 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
@@ -32,6 +32,7 @@
 import com.squareup.leakcanary.LeakDirectoryProvider;
 import com.squareup.leakcanary.R;
 import com.squareup.leakcanary.RefWatcher;
+
 import java.util.List;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
@@ -46,167 +47,173 @@
 
 public final class LeakCanaryInternals {
 
-  public static final String SAMSUNG = "samsung";
-  public static final String MOTOROLA = "motorola";
-  public static final String LENOVO = "LENOVO";
-  public static final String LG = "LGE";
-  public static final String NVIDIA = "NVIDIA";
-  public static final String MEIZU = "Meizu";
-  public static final String HUAWEI = "HUAWEI";
-  public static final String VIVO = "vivo";
-
-  public static volatile RefWatcher installedRefWatcher;
-  private static volatile LeakDirectoryProvider leakDirectoryProvider;
-
-  private static final String NOTIFICATION_CHANNEL_ID = "leakcanary";
-
-  public static volatile Boolean isInAnalyzerProcess;
-
-  /** Extracts the class simple name out of a string containing a fully qualified class name. */
-  public static String classSimpleName(String className) {
-    int separator = className.lastIndexOf('.');
-    if (separator == -1) {
-      return className;
-    } else {
-      return className.substring(separator + 1);
-    }
-  }
-
-  public static void setEnabledAsync(Context context, final Class<?> componentClass,
-      final boolean enabled) {
-    final Context appContext = context.getApplicationContext();
-    AsyncTask.THREAD_POOL_EXECUTOR.execute(new Runnable() {
-      @Override public void run() {
-        setEnabledBlocking(appContext, componentClass, enabled);
-      }
-    });
-  }
-
-  public static void setEnabledBlocking(Context appContext, Class<?> componentClass,
-      boolean enabled) {
-    ComponentName component = new ComponentName(appContext, componentClass);
-    PackageManager packageManager = appContext.getPackageManager();
-    int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED;
-    // Blocks on IPC.
-    packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);
-  }
-
-  public static boolean isInServiceProcess(Context context, Class<? extends Service> serviceClass) {
-    PackageManager packageManager = context.getPackageManager();
-    PackageInfo packageInfo;
-    try {
-      packageInfo = packageManager.getPackageInfo(context.getPackageName(), GET_SERVICES);
-    } catch (Exception e) {
-      CanaryLog.d(e, "Could not get package info for %s", context.getPackageName());
-      return false;
-    }
-    String mainProcess = packageInfo.applicationInfo.processName;
-
-    ComponentName component = new ComponentName(context, serviceClass);
-    ServiceInfo serviceInfo;
-    try {
-      serviceInfo = packageManager.getServiceInfo(component, 0);
-    } catch (PackageManager.NameNotFoundException ignored) {
-      // Service is disabled.
-      return false;
+    public static final String SAMSUNG = "samsung";
+    public static final String MOTOROLA = "motorola";
+    public static final String LENOVO = "LENOVO";
+    public static final String LG = "LGE";
+    public static final String NVIDIA = "NVIDIA";
+    public static final String MEIZU = "Meizu";
+    public static final String HUAWEI = "HUAWEI";
+    public static final String VIVO = "vivo";
+
+    public static volatile RefWatcher installedRefWatcher;
+    private static volatile LeakDirectoryProvider leakDirectoryProvider;
+
+    private static final String NOTIFICATION_CHANNEL_ID = "leakcanary";
+
+    public static volatile Boolean isInAnalyzerProcess;
+
+    /**
+     * Extracts the class simple name out of a string containing a fully qualified class name.
+     */
+    public static String classSimpleName(String className) {
+        int separator = className.lastIndexOf('.');
+        if (separator == -1) {
+            return className;
+        } else {
+            return className.substring(separator + 1);
+        }
     }
 
-    if (serviceInfo.processName.equals(mainProcess)) {
-      CanaryLog.d("Did not expect service %s to run in main process %s", serviceClass, mainProcess);
-      // Technically we are in the service process, but we're not in the service dedicated process.
-      return false;
+    public static void setEnabledAsync(Context context, final Class<?> componentClass,
+                                       final boolean enabled) {
+        // 异步 的开启 DisplayLeakActivity
+        final Context appContext = context.getApplicationContext();
+        AsyncTask.THREAD_POOL_EXECUTOR.execute(new Runnable() {
+            @Override
+            public void run() {
+                setEnabledBlocking(appContext, componentClass, enabled);
+            }
+        });
     }
 
-    int myPid = android.os.Process.myPid();
-    ActivityManager activityManager =
-        (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
-    ActivityManager.RunningAppProcessInfo myProcess = null;
-    List<ActivityManager.RunningAppProcessInfo> runningProcesses;
-    try {
-      runningProcesses = activityManager.getRunningAppProcesses();
-    } catch (SecurityException exception) {
-      // https://github.com/square/leakcanary/issues/948
-      CanaryLog.d("Could not get running app processes %d", exception);
-      return false;
+    public static void setEnabledBlocking(Context appContext, Class<?> componentClass,
+                                          boolean enabled) {
+        ComponentName component = new ComponentName(appContext, componentClass);
+        PackageManager packageManager = appContext.getPackageManager();
+        // 设置 Activity enable还是disable
+        // 设置因为 LeakCanary中所有的组件在初始时 都是 disable的
+        int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED;
+        // Blocks on IPC.
+        packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);
     }
-    if (runningProcesses != null) {
-      for (ActivityManager.RunningAppProcessInfo process : runningProcesses) {
-        if (process.pid == myPid) {
-          myProcess = process;
-          break;
+
+    public static boolean isInServiceProcess(Context context, Class<? extends Service> serviceClass) {
+        PackageManager packageManager = context.getPackageManager();
+        PackageInfo packageInfo;
+        try {
+            packageInfo = packageManager.getPackageInfo(context.getPackageName(), GET_SERVICES);
+        } catch (Exception e) {
+            CanaryLog.d(e, "Could not get package info for %s", context.getPackageName());
+            return false;
         }
-      }
-    }
-    if (myProcess == null) {
-      CanaryLog.d("Could not find running process for %d", myPid);
-      return false;
+        String mainProcess = packageInfo.applicationInfo.processName;
+
+        ComponentName component = new ComponentName(context, serviceClass);
+        ServiceInfo serviceInfo;
+        try {
+            serviceInfo = packageManager.getServiceInfo(component, 0);
+        } catch (PackageManager.NameNotFoundException ignored) {
+            // Service is disabled.
+            return false;
+        }
+
+        if (serviceInfo.processName.equals(mainProcess)) {
+            CanaryLog.d("Did not expect service %s to run in main process %s", serviceClass, mainProcess);
+            // Technically we are in the service process, but we're not in the service dedicated process.
+            return false;
+        }
+
+        int myPid = android.os.Process.myPid();
+        ActivityManager activityManager =
+                (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+        ActivityManager.RunningAppProcessInfo myProcess = null;
+        List<ActivityManager.RunningAppProcessInfo> runningProcesses;
+        try {
+            runningProcesses = activityManager.getRunningAppProcesses();
+        } catch (SecurityException exception) {
+            // https://github.com/square/leakcanary/issues/948
+            CanaryLog.d("Could not get running app processes %d", exception);
+            return false;
+        }
+        if (runningProcesses != null) {
+            for (ActivityManager.RunningAppProcessInfo process : runningProcesses) {
+                if (process.pid == myPid) {
+                    myProcess = process;
+                    break;
+                }
+            }
+        }
+        if (myProcess == null) {
+            CanaryLog.d("Could not find running process for %d", myPid);
+            return false;
+        }
+
+        return myProcess.processName.equals(serviceInfo.processName);
     }
 
-    return myProcess.processName.equals(serviceInfo.processName);
-  }
-
-  public static void showNotification(Context context, CharSequence contentTitle,
-      CharSequence contentText, PendingIntent pendingIntent, int notificationId) {
-    Notification.Builder builder = new Notification.Builder(context)
-        .setContentText(contentText)
-        .setContentTitle(contentTitle)
-        .setAutoCancel(true)
-        .setContentIntent(pendingIntent);
-
-    Notification notification = buildNotification(context, builder);
-    NotificationManager notificationManager =
-        (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
-    notificationManager.notify(notificationId, notification);
-  }
-
-  public static Notification buildNotification(Context context,
-      Notification.Builder builder) {
-    builder.setSmallIcon(R.drawable.leak_canary_notification)
-        .setWhen(System.currentTimeMillis())
-        .setOnlyAlertOnce(true);
-
-    if (SDK_INT >= O) {
-      NotificationManager notificationManager =
-          (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
-      NotificationChannel notificationChannel =
-          notificationManager.getNotificationChannel(NOTIFICATION_CHANNEL_ID);
-      if (notificationChannel == null) {
-        String channelName = context.getString(R.string.leak_canary_notification_channel);
-        notificationChannel = new NotificationChannel(NOTIFICATION_CHANNEL_ID, channelName,
-            NotificationManager.IMPORTANCE_DEFAULT);
-        notificationManager.createNotificationChannel(notificationChannel);
-      }
-      builder.setChannelId(NOTIFICATION_CHANNEL_ID);
+    public static void showNotification(Context context, CharSequence contentTitle,
+                                        CharSequence contentText, PendingIntent pendingIntent, int notificationId) {
+        Notification.Builder builder = new Notification.Builder(context)
+                .setContentText(contentText)
+                .setContentTitle(contentTitle)
+                .setAutoCancel(true)
+                .setContentIntent(pendingIntent);
+
+        Notification notification = buildNotification(context, builder);
+        NotificationManager notificationManager =
+                (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+        notificationManager.notify(notificationId, notification);
     }
 
-    if (SDK_INT < JELLY_BEAN) {
-      return builder.getNotification();
-    } else {
-      return builder.build();
+    public static Notification buildNotification(Context context,
+                                                 Notification.Builder builder) {
+        builder.setSmallIcon(R.drawable.leak_canary_notification)
+                .setWhen(System.currentTimeMillis())
+                .setOnlyAlertOnce(true);
+
+        if (SDK_INT >= O) {
+            NotificationManager notificationManager =
+                    (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+            NotificationChannel notificationChannel =
+                    notificationManager.getNotificationChannel(NOTIFICATION_CHANNEL_ID);
+            if (notificationChannel == null) {
+                String channelName = context.getString(R.string.leak_canary_notification_channel);
+                notificationChannel = new NotificationChannel(NOTIFICATION_CHANNEL_ID, channelName,
+                        NotificationManager.IMPORTANCE_DEFAULT);
+                notificationManager.createNotificationChannel(notificationChannel);
+            }
+            builder.setChannelId(NOTIFICATION_CHANNEL_ID);
+        }
+
+        if (SDK_INT < JELLY_BEAN) {
+            return builder.getNotification();
+        } else {
+            return builder.build();
+        }
     }
-  }
 
-  public static Executor newSingleThreadExecutor(String threadName) {
-    return Executors.newSingleThreadExecutor(new LeakCanarySingleThreadFactory(threadName));
-  }
+    public static Executor newSingleThreadExecutor(String threadName) {
+        return Executors.newSingleThreadExecutor(new LeakCanarySingleThreadFactory(threadName));
+    }
 
-  public static void setLeakDirectoryProvider(LeakDirectoryProvider leakDirectoryProvider) {
-    if (LeakCanaryInternals.leakDirectoryProvider != null) {
-      throw new IllegalStateException("Cannot set the LeakDirectoryProvider after it has already "
-          + "been set. Try setting it before installing the RefWatcher.");
+    public static void setLeakDirectoryProvider(LeakDirectoryProvider leakDirectoryProvider) {
+        if (LeakCanaryInternals.leakDirectoryProvider != null) {
+            throw new IllegalStateException("Cannot set the LeakDirectoryProvider after it has already "
+                    + "been set. Try setting it before installing the RefWatcher.");
+        }
+        LeakCanaryInternals.leakDirectoryProvider = leakDirectoryProvider;
     }
-    LeakCanaryInternals.leakDirectoryProvider = leakDirectoryProvider;
-  }
 
-  public static LeakDirectoryProvider getLeakDirectoryProvider(Context context) {
-    LeakDirectoryProvider leakDirectoryProvider = LeakCanaryInternals.leakDirectoryProvider;
-    if (leakDirectoryProvider == null) {
-      leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
+    public static LeakDirectoryProvider getLeakDirectoryProvider(Context context) {
+        LeakDirectoryProvider leakDirectoryProvider = LeakCanaryInternals.leakDirectoryProvider;
+        if (leakDirectoryProvider == null) {
+            leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
+        }
+        return leakDirectoryProvider;
     }
-    return leakDirectoryProvider;
-  }
 
-  private LeakCanaryInternals() {
-    throw new AssertionError();
-  }
+    private LeakCanaryInternals() {
+        throw new AssertionError();
+    }
 }
diff --git a/leakcanary-support-fragment/src/main/java/com/squareup/leakcanary/internal/SupportFragmentRefWatcher.java b/leakcanary-support-fragment/src/main/java/com/squareup/leakcanary/internal/SupportFragmentRefWatcher.java
index ad8b85e2..167ddd66 100644
--- a/leakcanary-support-fragment/src/main/java/com/squareup/leakcanary/internal/SupportFragmentRefWatcher.java
+++ b/leakcanary-support-fragment/src/main/java/com/squareup/leakcanary/internal/SupportFragmentRefWatcher.java
@@ -23,32 +23,41 @@
 import com.squareup.leakcanary.RefWatcher;
 
 class SupportFragmentRefWatcher implements FragmentRefWatcher {
-  private final RefWatcher refWatcher;
+    private final RefWatcher refWatcher;
 
-  SupportFragmentRefWatcher(RefWatcher refWatcher) {
-    this.refWatcher = refWatcher;
-  }
+    SupportFragmentRefWatcher(RefWatcher refWatcher) {
+        this.refWatcher = refWatcher;
+    }
 
-  private final FragmentManager.FragmentLifecycleCallbacks fragmentLifecycleCallbacks =
-      new FragmentManager.FragmentLifecycleCallbacks() {
+    private final FragmentManager.FragmentLifecycleCallbacks fragmentLifecycleCallbacks =
+            new FragmentManager.FragmentLifecycleCallbacks() {
 
-        @Override public void onFragmentViewDestroyed(FragmentManager fm, Fragment fragment) {
-          View view = fragment.getView();
-          if (view != null) {
-            refWatcher.watch(view);
-          }
-        }
+                @Override
+                public void onFragmentViewDestroyed(FragmentManager fm, Fragment fragment) {
+                    // Fragment View Destory
+                    View view = fragment.getView();
+                    if (view != null) {
+                        // 监测 Fragment中的View
+                        refWatcher.watch(view);
+                    }
+                }
 
-        @Override public void onFragmentDestroyed(FragmentManager fm, Fragment fragment) {
-          refWatcher.watch(fragment);
-        }
-      };
+                @Override
+                public void onFragmentDestroyed(FragmentManager fm, Fragment fragment) {
+                    // Fragment Destory，watch fragment
+                    refWatcher.watch(fragment);
+                }
+            };
 
-  @Override public void watchFragments(Activity activity) {
-    if (activity instanceof FragmentActivity) {
-      FragmentManager supportFragmentManager =
-          ((FragmentActivity) activity).getSupportFragmentManager();
-      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true);
+    @Override
+    public void watchFragments(Activity activity) {
+        if (activity instanceof FragmentActivity) {
+            // Activity必须是 FragmentActivity的子类
+            FragmentManager supportFragmentManager =
+                    ((FragmentActivity) activity).getSupportFragmentManager();
+            // 为 Activity注册一个 FragmentLifecycleCallbacks，用来监测 Fragment的生命周期
+            // 同样也是监测到 Fragment Destory时，才去 watch
+            supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true);
+        }
     }
-  }
 }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
index 14041244..2ff3e20f 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
@@ -23,173 +23,184 @@
 import static com.squareup.leakcanary.Preconditions.checkNotNull;
 import static java.util.Collections.unmodifiableList;
 
-/** Data structure holding information about a heap dump. */
+/**
+ * Data structure holding information about a heap dump.
+ */
 public final class HeapDump implements Serializable {
 
-  public static Builder builder() {
-    return new Builder();
-  }
-
-  /** Receives a heap dump to analyze. */
-  public interface Listener {
-    Listener NONE = new Listener() {
-      @Override public void analyze(HeapDump heapDump) {
-      }
-    };
-
-    void analyze(HeapDump heapDump);
-  }
-
-  /** The heap dump file, which you might want to upload somewhere. */
-  public final File heapDumpFile;
-
-  /**
-   * Key associated to the {@link KeyedWeakReference} used to detect the memory leak.
-   * When analyzing a heap dump, search for all {@link KeyedWeakReference} instances, then open
-   * the one that has its "key" field set to this value. Its "referent" field contains the
-   * leaking object. Computing the shortest path to GC roots on that leaking object should enable
-   * you to figure out the cause of the leak.
-   */
-  public final String referenceKey;
-
-  /**
-   * User defined name to help identify the leaking instance.
-   */
-  public final String referenceName;
-
-  /** References that should be ignored when analyzing this heap dump. */
-  public final ExcludedRefs excludedRefs;
-
-  /** Time from the request to watch the reference until the GC was triggered. */
-  public final long watchDurationMs;
-  public final long gcDurationMs;
-  public final long heapDumpDurationMs;
-  public final boolean computeRetainedHeapSize;
-  public final List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses;
-
-  /**
-   * Calls {@link #HeapDump(Builder)} with computeRetainedHeapSize set to true.
-   *
-   * @deprecated Use {@link #HeapDump(Builder)}  instead.
-   */
-  @Deprecated
-  public HeapDump(File heapDumpFile, String referenceKey, String referenceName,
-      ExcludedRefs excludedRefs, long watchDurationMs, long gcDurationMs, long heapDumpDurationMs) {
-    this(new Builder().heapDumpFile(heapDumpFile)
-        .referenceKey(referenceKey)
-        .referenceName(referenceName)
-        .excludedRefs(excludedRefs)
-        .computeRetainedHeapSize(true)
-        .watchDurationMs(watchDurationMs)
-        .gcDurationMs(gcDurationMs)
-        .heapDumpDurationMs(heapDumpDurationMs));
-  }
-
-  HeapDump(Builder builder) {
-    this.heapDumpFile = builder.heapDumpFile;
-    this.referenceKey = builder.referenceKey;
-    this.referenceName = builder.referenceName;
-    this.excludedRefs = builder.excludedRefs;
-    this.computeRetainedHeapSize = builder.computeRetainedHeapSize;
-    this.watchDurationMs = builder.watchDurationMs;
-    this.gcDurationMs = builder.gcDurationMs;
-    this.heapDumpDurationMs = builder.heapDumpDurationMs;
-    this.reachabilityInspectorClasses = builder.reachabilityInspectorClasses;
-  }
-
-  public Builder buildUpon() {
-    return new Builder(this);
-  }
-
-  public static final class Builder {
-    File heapDumpFile;
-    String referenceKey;
-    String referenceName;
-    ExcludedRefs excludedRefs;
-    long watchDurationMs;
-    long gcDurationMs;
-    long heapDumpDurationMs;
-    boolean computeRetainedHeapSize;
-    List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses;
-
-    Builder() {
-      this.heapDumpFile = null;
-      this.referenceKey = null;
-      referenceName = "";
-      excludedRefs = null;
-      watchDurationMs = 0;
-      gcDurationMs = 0;
-      heapDumpDurationMs = 0;
-      computeRetainedHeapSize = false;
-      reachabilityInspectorClasses = null;
-    }
-
-    Builder(HeapDump heapDump) {
-      this.heapDumpFile = heapDump.heapDumpFile;
-      this.referenceKey = heapDump.referenceKey;
-      this.referenceName = heapDump.referenceName;
-      this.excludedRefs = heapDump.excludedRefs;
-      this.computeRetainedHeapSize = heapDump.computeRetainedHeapSize;
-      this.watchDurationMs = heapDump.watchDurationMs;
-      this.gcDurationMs = heapDump.gcDurationMs;
-      this.heapDumpDurationMs = heapDump.heapDumpDurationMs;
-      this.reachabilityInspectorClasses = heapDump.reachabilityInspectorClasses;
-    }
-
-    public Builder heapDumpFile(File heapDumpFile) {
-      this.heapDumpFile = checkNotNull(heapDumpFile, "heapDumpFile");
-      return this;
-    }
-
-    public Builder referenceKey(String referenceKey) {
-      this.referenceKey = checkNotNull(referenceKey, "referenceKey");
-      return this;
-    }
-
-    public Builder referenceName(String referenceName) {
-      this.referenceName = checkNotNull(referenceName, "referenceName");
-      return this;
-    }
-
-    public Builder excludedRefs(ExcludedRefs excludedRefs) {
-      this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
-      return this;
-    }
-
-    public Builder watchDurationMs(long watchDurationMs) {
-      this.watchDurationMs = watchDurationMs;
-      return this;
+    public static Builder builder() {
+        return new Builder();
     }
 
-    public Builder gcDurationMs(long gcDurationMs) {
-      this.gcDurationMs = gcDurationMs;
-      return this;
+    /**
+     * Receives a heap dump to analyze.
+     */
+    public interface Listener {
+        Listener NONE = new Listener() {
+            @Override
+            public void analyze(HeapDump heapDump) {
+            }
+        };
+
+        void analyze(HeapDump heapDump);
     }
 
-    public Builder heapDumpDurationMs(long heapDumpDurationMs) {
-      this.heapDumpDurationMs = heapDumpDurationMs;
-      return this;
+    /**
+     * The heap dump file, which you might want to upload somewhere.
+     */
+    public final File heapDumpFile;
+
+    /**
+     * Key associated to the {@link KeyedWeakReference} used to detect the memory leak.
+     * When analyzing a heap dump, search for all {@link KeyedWeakReference} instances, then open
+     * the one that has its "key" field set to this value. Its "referent" field contains the
+     * leaking object. Computing the shortest path to GC roots on that leaking object should enable
+     * you to figure out the cause of the leak.
+     */
+    public final String referenceKey;
+
+    /**
+     * User defined name to help identify the leaking instance.
+     */
+    public final String referenceName;
+
+    /**
+     * References that should be ignored when analyzing this heap dump.
+     */
+    public final ExcludedRefs excludedRefs;
+
+    /**
+     * Time from the request to watch the reference until the GC was triggered.
+     */
+    public final long watchDurationMs;
+    public final long gcDurationMs;
+    public final long heapDumpDurationMs;
+    public final boolean computeRetainedHeapSize;
+    public final List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses;
+
+    /**
+     * Calls {@link #HeapDump(Builder)} with computeRetainedHeapSize set to true.
+     *
+     * @deprecated Use {@link #HeapDump(Builder)}  instead.
+     */
+    @Deprecated
+    public HeapDump(File heapDumpFile, String referenceKey, String referenceName,
+                    ExcludedRefs excludedRefs, long watchDurationMs, long gcDurationMs, long heapDumpDurationMs) {
+        this(new Builder().heapDumpFile(heapDumpFile)
+                .referenceKey(referenceKey)
+                .referenceName(referenceName)
+                .excludedRefs(excludedRefs)
+                .computeRetainedHeapSize(true)
+                .watchDurationMs(watchDurationMs)
+                .gcDurationMs(gcDurationMs)
+                .heapDumpDurationMs(heapDumpDurationMs));
     }
 
-    public Builder computeRetainedHeapSize(boolean computeRetainedHeapSize) {
-      this.computeRetainedHeapSize = computeRetainedHeapSize;
-      return this;
+    HeapDump(Builder builder) {
+        this.heapDumpFile = builder.heapDumpFile;
+        this.referenceKey = builder.referenceKey;
+        this.referenceName = builder.referenceName;
+        this.excludedRefs = builder.excludedRefs;
+        this.computeRetainedHeapSize = builder.computeRetainedHeapSize;
+        this.watchDurationMs = builder.watchDurationMs;
+        this.gcDurationMs = builder.gcDurationMs;
+        this.heapDumpDurationMs = builder.heapDumpDurationMs;
+        this.reachabilityInspectorClasses = builder.reachabilityInspectorClasses;
     }
 
-    public Builder reachabilityInspectorClasses(
-        List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses) {
-      checkNotNull(reachabilityInspectorClasses, "reachabilityInspectorClasses");
-      this.reachabilityInspectorClasses =
-          unmodifiableList(new ArrayList<>(reachabilityInspectorClasses));
-      return this;
+    public Builder buildUpon() {
+        return new Builder(this);
     }
 
-    public HeapDump build() {
-      checkNotNull(excludedRefs, "excludedRefs");
-      checkNotNull(heapDumpFile, "heapDumpFile");
-      checkNotNull(referenceKey, "referenceKey");
-      checkNotNull(reachabilityInspectorClasses, "reachabilityInspectorClasses");
-      return new HeapDump(this);
+    public static final class Builder {
+        File heapDumpFile;
+        String referenceKey;
+        String referenceName;
+        ExcludedRefs excludedRefs;
+        long watchDurationMs;
+        long gcDurationMs;
+        long heapDumpDurationMs;
+        boolean computeRetainedHeapSize;
+        List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses;
+
+        Builder() {
+            this.heapDumpFile = null;
+            this.referenceKey = null;
+            referenceName = "";
+            excludedRefs = null;
+            watchDurationMs = 0;
+            gcDurationMs = 0;
+            heapDumpDurationMs = 0;
+            computeRetainedHeapSize = false;
+            reachabilityInspectorClasses = null;
+        }
+
+        Builder(HeapDump heapDump) {
+            this.heapDumpFile = heapDump.heapDumpFile;
+            this.referenceKey = heapDump.referenceKey;
+            this.referenceName = heapDump.referenceName;
+            this.excludedRefs = heapDump.excludedRefs;
+            this.computeRetainedHeapSize = heapDump.computeRetainedHeapSize;
+            this.watchDurationMs = heapDump.watchDurationMs;
+            this.gcDurationMs = heapDump.gcDurationMs;
+            this.heapDumpDurationMs = heapDump.heapDumpDurationMs;
+            this.reachabilityInspectorClasses = heapDump.reachabilityInspectorClasses;
+        }
+
+        public Builder heapDumpFile(File heapDumpFile) {
+            this.heapDumpFile = checkNotNull(heapDumpFile, "heapDumpFile");
+            return this;
+        }
+
+        public Builder referenceKey(String referenceKey) {
+            this.referenceKey = checkNotNull(referenceKey, "referenceKey");
+            return this;
+        }
+
+        public Builder referenceName(String referenceName) {
+            this.referenceName = checkNotNull(referenceName, "referenceName");
+            return this;
+        }
+
+        public Builder excludedRefs(ExcludedRefs excludedRefs) {
+            this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
+            return this;
+        }
+
+        public Builder watchDurationMs(long watchDurationMs) {
+            this.watchDurationMs = watchDurationMs;
+            return this;
+        }
+
+        public Builder gcDurationMs(long gcDurationMs) {
+            this.gcDurationMs = gcDurationMs;
+            return this;
+        }
+
+        public Builder heapDumpDurationMs(long heapDumpDurationMs) {
+            this.heapDumpDurationMs = heapDumpDurationMs;
+            return this;
+        }
+
+        public Builder computeRetainedHeapSize(boolean computeRetainedHeapSize) {
+            this.computeRetainedHeapSize = computeRetainedHeapSize;
+            return this;
+        }
+
+        public Builder reachabilityInspectorClasses(
+                List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses) {
+            checkNotNull(reachabilityInspectorClasses, "reachabilityInspectorClasses");
+            this.reachabilityInspectorClasses =
+                    unmodifiableList(new ArrayList<>(reachabilityInspectorClasses));
+            return this;
+        }
+
+        public HeapDump build() {
+            checkNotNull(excludedRefs, "excludedRefs");
+            checkNotNull(heapDumpFile, "heapDumpFile");
+            checkNotNull(referenceKey, "referenceKey");
+            checkNotNull(reachabilityInspectorClasses, "reachabilityInspectorClasses");
+            return new HeapDump(this);
+        }
     }
-  }
 }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
index c3d27a1c..d83b7432 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
@@ -36,138 +36,178 @@
  */
 public final class RefWatcher {
 
-  public static final RefWatcher DISABLED = new RefWatcherBuilder<>().build();
-
-  private final WatchExecutor watchExecutor;
-  private final DebuggerControl debuggerControl;
-  private final GcTrigger gcTrigger;
-  private final HeapDumper heapDumper;
-  private final HeapDump.Listener heapdumpListener;
-  private final HeapDump.Builder heapDumpBuilder;
-  private final Set<String> retainedKeys;
-  private final ReferenceQueue<Object> queue;
-
-  RefWatcher(WatchExecutor watchExecutor, DebuggerControl debuggerControl, GcTrigger gcTrigger,
-      HeapDumper heapDumper, HeapDump.Listener heapdumpListener, HeapDump.Builder heapDumpBuilder) {
-    this.watchExecutor = checkNotNull(watchExecutor, "watchExecutor");
-    this.debuggerControl = checkNotNull(debuggerControl, "debuggerControl");
-    this.gcTrigger = checkNotNull(gcTrigger, "gcTrigger");
-    this.heapDumper = checkNotNull(heapDumper, "heapDumper");
-    this.heapdumpListener = checkNotNull(heapdumpListener, "heapdumpListener");
-    this.heapDumpBuilder = heapDumpBuilder;
-    retainedKeys = new CopyOnWriteArraySet<>();
-    queue = new ReferenceQueue<>();
-  }
-
-  /**
-   * Identical to {@link #watch(Object, String)} with an empty string reference name.
-   *
-   * @see #watch(Object, String)
-   */
-  public void watch(Object watchedReference) {
-    watch(watchedReference, "");
-  }
-
-  /**
-   * Watches the provided references and checks if it can be GCed. This method is non blocking,
-   * the check is done on the {@link WatchExecutor} this {@link RefWatcher} has been constructed
-   * with.
-   *
-   * @param referenceName An logical identifier for the watched object.
-   */
-  public void watch(Object watchedReference, String referenceName) {
-    if (this == DISABLED) {
-      return;
+    public static final RefWatcher DISABLED = new RefWatcherBuilder<>().build();
+
+    // 异步分析线程池
+    private final WatchExecutor watchExecutor;
+    // 用于判断是否debug模式，如果正在调试中，就不会执行内存泄露的监测判断
+    private final DebuggerControl debuggerControl;
+    // 触发gc
+    private final GcTrigger gcTrigger;
+    // 用于dump内存堆快照信息
+    private final HeapDumper heapDumper;
+    // 用于监听 产生Heap文件的回调
+    private final HeapDump.Listener heapdumpListener;
+    private final HeapDump.Builder heapDumpBuilder;
+    // 会持有那些待检测的 以及 已经发生内存泄露的引用的Key
+    private final Set<String> retainedKeys;
+    // 引用队列，主要用于判断 弱引用所持有的对象是否已经被 执行了gc垃圾回收
+    private final ReferenceQueue<Object> queue;
+
+    RefWatcher(WatchExecutor watchExecutor, DebuggerControl debuggerControl, GcTrigger gcTrigger,
+               HeapDumper heapDumper, HeapDump.Listener heapdumpListener, HeapDump.Builder heapDumpBuilder) {
+        this.watchExecutor = checkNotNull(watchExecutor, "watchExecutor");
+        this.debuggerControl = checkNotNull(debuggerControl, "debuggerControl");
+        this.gcTrigger = checkNotNull(gcTrigger, "gcTrigger");
+        this.heapDumper = checkNotNull(heapDumper, "heapDumper");
+        this.heapdumpListener = checkNotNull(heapdumpListener, "heapdumpListener");
+        this.heapDumpBuilder = heapDumpBuilder;
+        retainedKeys = new CopyOnWriteArraySet<>();
+        queue = new ReferenceQueue<>();
     }
-    checkNotNull(watchedReference, "watchedReference");
-    checkNotNull(referenceName, "referenceName");
-    final long watchStartNanoTime = System.nanoTime();
-    String key = UUID.randomUUID().toString();
-    retainedKeys.add(key);
-    final KeyedWeakReference reference =
-        new KeyedWeakReference(watchedReference, key, referenceName, queue);
-
-    ensureGoneAsync(watchStartNanoTime, reference);
-  }
-
-  /**
-   * LeakCanary will stop watching any references that were passed to {@link #watch(Object, String)}
-   * so far.
-   */
-  public void clearWatchedReferences() {
-    retainedKeys.clear();
-  }
-
-  boolean isEmpty() {
-    removeWeaklyReachableReferences();
-    return retainedKeys.isEmpty();
-  }
-
-  HeapDump.Builder getHeapDumpBuilder() {
-    return heapDumpBuilder;
-  }
-
-  Set<String> getRetainedKeys() {
-    return new HashSet<>(retainedKeys);
-  }
-
-  private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {
-    watchExecutor.execute(new Retryable() {
-      @Override public Retryable.Result run() {
-        return ensureGone(reference, watchStartNanoTime);
-      }
-    });
-  }
-
-  @SuppressWarnings("ReferenceEquality") // Explicitly checking for named null.
-  Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {
-    long gcStartNanoTime = System.nanoTime();
-    long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);
-
-    removeWeaklyReachableReferences();
-
-    if (debuggerControl.isDebuggerAttached()) {
-      // The debugger can create false leaks.
-      return RETRY;
+
+    /**
+     * Identical to {@link #watch(Object, String)} with an empty string reference name.
+     *
+     * @see #watch(Object, String)
+     */
+    public void watch(Object watchedReference) {
+        watch(watchedReference, "");
+    }
+
+    /**
+     * Watches the provided references and checks if it can be GCed. This method is non blocking,
+     * the check is done on the {@link WatchExecutor} this {@link RefWatcher} has been constructed
+     * with.
+     * Activity、Fragment、View，最终都会 调用到这个方法
+     *
+     * @param referenceName An logical identifier for the watched object.
+     */
+    public void watch(Object watchedReference, String referenceName) {
+        if (this == DISABLED) {
+            return;
+        }
+        // 检测watchedReference是否为null
+        checkNotNull(watchedReference, "watchedReference");
+        // 检测referenceName是否为null
+        checkNotNull(referenceName, "referenceName");
+        final long watchStartNanoTime = System.nanoTime();
+        // 1、创建唯一的key，并将其加入到retainedKeys中
+        String key = UUID.randomUUID().toString();
+        retainedKeys.add(key);
+
+        // 2、创建一个弱引用，将key与watchedReference绑定，
+        // 同时此处为弱引用关联一个ReferenceQueue，以便在gc回收这个对象后，将弱引用加入到队列中
+        final KeyedWeakReference reference =
+                new KeyedWeakReference(watchedReference, key, referenceName, queue);
+
+        // 3、开启 异步线程，执行内存泄漏 分析工作
+        ensureGoneAsync(watchStartNanoTime, reference);
+    }
+
+    /**
+     * LeakCanary will stop watching any references that were passed to {@link #watch(Object, String)}
+     * so far.
+     */
+    public void clearWatchedReferences() {
+        retainedKeys.clear();
+    }
+
+    boolean isEmpty() {
+        removeWeaklyReachableReferences();
+        return retainedKeys.isEmpty();
+    }
+
+    HeapDump.Builder getHeapDumpBuilder() {
+        return heapDumpBuilder;
+    }
+
+    Set<String> getRetainedKeys() {
+        return new HashSet<>(retainedKeys);
+    }
+
+    private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {
+        // 在 线程池 中执行 Runnable
+        watchExecutor.execute(new Retryable() {
+            @Override
+            public Retryable.Result run() {
+                return ensureGone(reference, watchStartNanoTime);
+            }
+        });
     }
-    if (gone(reference)) {
-      return DONE;
+
+    @SuppressWarnings("ReferenceEquality")
+        // Explicitly checking for named null.
+    Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {
+        long gcStartNanoTime = System.nanoTime();
+        // 用于 计算从调用 watch方法 到 调用 GC垃圾回收 所用的时间
+        long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);
+
+        // 移除掉已经回收的对象的key
+        removeWeaklyReachableReferences();
+
+        // 如果此时 已经处于 debug的状态，那么就直接return
+        if (debuggerControl.isDebuggerAttached()) {
+            // The debugger can create false leaks.
+            return RETRY;
+        }
+
+        // 如果retainedKeys已经不包含这个reference，说明对象已经回收了
+        if (gone(reference)) {
+            return DONE;
+        }
+
+        // 手动 触发GC
+        gcTrigger.runGc();
+        // 再次移除GC后已经回收的对象的key
+        removeWeaklyReachableReferences();
+        if (!gone(reference)) {
+            // 如果reference没被回收，则表明已经发生了内存泄漏
+            long startDumpHeap = System.nanoTime();
+            // gc的时间
+            long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);
+
+            // dump出所需要的heap文件
+            File heapDumpFile = heapDumper.dumpHeap();
+            if (heapDumpFile == RETRY_LATER) {
+                // Could not dump the heap.
+                return RETRY;
+            }
+            // dump内存堆快照信息的时间
+            long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);
+
+            HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)
+                    .referenceName(reference.name)
+                    .watchDurationMs(watchDurationMs)
+                    .gcDurationMs(gcDurationMs)
+                    .heapDumpDurationMs(heapDumpDurationMs)
+                    .build();
+
+            // 分析 内存泄露
+            heapdumpListener.analyze(heapDump);
+        }
+        return DONE;
     }
-    gcTrigger.runGc();
-    removeWeaklyReachableReferences();
-    if (!gone(reference)) {
-      long startDumpHeap = System.nanoTime();
-      long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);
-
-      File heapDumpFile = heapDumper.dumpHeap();
-      if (heapDumpFile == RETRY_LATER) {
-        // Could not dump the heap.
-        return RETRY;
-      }
-      long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);
-
-      HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)
-          .referenceName(reference.name)
-          .watchDurationMs(watchDurationMs)
-          .gcDurationMs(gcDurationMs)
-          .heapDumpDurationMs(heapDumpDurationMs)
-          .build();
-
-      heapdumpListener.analyze(heapDump);
+
+    /**
+     * 判断 retainedKeys 中是否包含 reference的key，以表明reference所引用的对象是否已经被回收。
+     * return true：不包含reference的key，表明reference所引用的对象已经被回收。
+     * return false：包含reference的key，表明reference所引用的对象没有被回收。
+     */
+    private boolean gone(KeyedWeakReference reference) {
+        return !retainedKeys.contains(reference.key);
     }
-    return DONE;
-  }
-
-  private boolean gone(KeyedWeakReference reference) {
-    return !retainedKeys.contains(reference.key);
-  }
-
-  private void removeWeaklyReachableReferences() {
-    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
-    // reachable. This is before finalization or garbage collection has actually happened.
-    KeyedWeakReference ref;
-    while ((ref = (KeyedWeakReference) queue.poll()) != null) {
-      retainedKeys.remove(ref.key);
+
+    /**
+     * 循环从引用队列中取出加入其中的虚引用KeyedWeakReference对象，将标识这个虚引用的key从retainedKeys中移除。
+     * retainedKeys中剩下的就是 标识 未被垃圾回收的被检测对象的虚引用的key
+     */
+    private void removeWeaklyReachableReferences() {
+        // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
+        // reachable. This is before finalization or garbage collection has actually happened.
+        KeyedWeakReference ref;
+        while ((ref = (KeyedWeakReference) queue.poll()) != null) {
+            retainedKeys.remove(ref.key);
+        }
     }
-  }
 }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
index 866e35c4..b68cedfa 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
@@ -9,146 +9,162 @@
  */
 public class RefWatcherBuilder<T extends RefWatcherBuilder<T>> {
 
-  private HeapDump.Listener heapDumpListener;
-  private DebuggerControl debuggerControl;
-  private HeapDumper heapDumper;
-  private WatchExecutor watchExecutor;
-  private GcTrigger gcTrigger;
-  private final HeapDump.Builder heapDumpBuilder;
-
-  public RefWatcherBuilder() {
-    heapDumpBuilder = new HeapDump.Builder();
-  }
-
-  /** @see HeapDump.Listener */
-  public final T heapDumpListener(HeapDump.Listener heapDumpListener) {
-    this.heapDumpListener = heapDumpListener;
-    return self();
-  }
-
-  /** @see ExcludedRefs */
-  public final T excludedRefs(ExcludedRefs excludedRefs) {
-    heapDumpBuilder.excludedRefs(excludedRefs);
-    return self();
-  }
-
-  /** @see HeapDumper */
-  public final T heapDumper(HeapDumper heapDumper) {
-    this.heapDumper = heapDumper;
-    return self();
-  }
-
-  /** @see DebuggerControl */
-  public final T debuggerControl(DebuggerControl debuggerControl) {
-    this.debuggerControl = debuggerControl;
-    return self();
-  }
-
-  /** @see WatchExecutor */
-  public final T watchExecutor(WatchExecutor watchExecutor) {
-    this.watchExecutor = watchExecutor;
-    return self();
-  }
-
-  /** @see GcTrigger */
-  public final T gcTrigger(GcTrigger gcTrigger) {
-    this.gcTrigger = gcTrigger;
-    return self();
-  }
-
-  /** @see Reachability.Inspector */
-  public final T stethoscopeClasses(
-      List<Class<? extends Reachability.Inspector>> stethoscopeClasses) {
-    heapDumpBuilder.reachabilityInspectorClasses(stethoscopeClasses);
-    return self();
-  }
-
-  /**
-   * Whether LeakCanary should compute the retained heap size when a leak is detected. False by
-   * default, because computing the retained heap size takes a long time.
-   */
-  public final T computeRetainedHeapSize(boolean computeRetainedHeapSize) {
-    heapDumpBuilder.computeRetainedHeapSize(computeRetainedHeapSize);
-    return self();
-  }
+    private HeapDump.Listener heapDumpListener;
+    private DebuggerControl debuggerControl;
+    private HeapDumper heapDumper;
+    private WatchExecutor watchExecutor;
+    private GcTrigger gcTrigger;
+    private final HeapDump.Builder heapDumpBuilder;
+
+    public RefWatcherBuilder() {
+        heapDumpBuilder = new HeapDump.Builder();
+    }
 
-  /** Creates a {@link RefWatcher}. */
-  public final RefWatcher build() {
-    if (isDisabled()) {
-      return RefWatcher.DISABLED;
+    /**
+     * @see HeapDump.Listener
+     */
+    public final T heapDumpListener(HeapDump.Listener heapDumpListener) {
+        this.heapDumpListener = heapDumpListener;
+        return self();
     }
 
-    if (heapDumpBuilder.excludedRefs == null) {
-      heapDumpBuilder.excludedRefs(defaultExcludedRefs());
+    /**
+     * @see ExcludedRefs
+     */
+    public final T excludedRefs(ExcludedRefs excludedRefs) {
+        heapDumpBuilder.excludedRefs(excludedRefs);
+        return self();
     }
 
-    HeapDump.Listener heapDumpListener = this.heapDumpListener;
-    if (heapDumpListener == null) {
-      heapDumpListener = defaultHeapDumpListener();
+    /**
+     * @see HeapDumper
+     */
+    public final T heapDumper(HeapDumper heapDumper) {
+        this.heapDumper = heapDumper;
+        return self();
     }
 
-    DebuggerControl debuggerControl = this.debuggerControl;
-    if (debuggerControl == null) {
-      debuggerControl = defaultDebuggerControl();
+    /**
+     * @see DebuggerControl
+     */
+    public final T debuggerControl(DebuggerControl debuggerControl) {
+        this.debuggerControl = debuggerControl;
+        return self();
     }
 
-    HeapDumper heapDumper = this.heapDumper;
-    if (heapDumper == null) {
-      heapDumper = defaultHeapDumper();
+    /**
+     * @see WatchExecutor
+     */
+    public final T watchExecutor(WatchExecutor watchExecutor) {
+        this.watchExecutor = watchExecutor;
+        return self();
     }
 
-    WatchExecutor watchExecutor = this.watchExecutor;
-    if (watchExecutor == null) {
-      watchExecutor = defaultWatchExecutor();
+    /**
+     * @see GcTrigger
+     */
+    public final T gcTrigger(GcTrigger gcTrigger) {
+        this.gcTrigger = gcTrigger;
+        return self();
     }
 
-    GcTrigger gcTrigger = this.gcTrigger;
-    if (gcTrigger == null) {
-      gcTrigger = defaultGcTrigger();
+    /**
+     * @see Reachability.Inspector
+     */
+    public final T stethoscopeClasses(
+            List<Class<? extends Reachability.Inspector>> stethoscopeClasses) {
+        heapDumpBuilder.reachabilityInspectorClasses(stethoscopeClasses);
+        return self();
     }
 
-    if (heapDumpBuilder.reachabilityInspectorClasses == null) {
-      heapDumpBuilder.reachabilityInspectorClasses(defaultReachabilityInspectorClasses());
+    /**
+     * Whether LeakCanary should compute the retained heap size when a leak is detected. False by
+     * default, because computing the retained heap size takes a long time.
+     */
+    public final T computeRetainedHeapSize(boolean computeRetainedHeapSize) {
+        heapDumpBuilder.computeRetainedHeapSize(computeRetainedHeapSize);
+        return self();
     }
 
-    return new RefWatcher(watchExecutor, debuggerControl, gcTrigger, heapDumper, heapDumpListener,
-        heapDumpBuilder);
-  }
+    /**
+     * Creates a {@link RefWatcher}.
+     */
+    public final RefWatcher build() {
+        if (isDisabled()) {
+            return RefWatcher.DISABLED;
+        }
+
+        if (heapDumpBuilder.excludedRefs == null) {
+            heapDumpBuilder.excludedRefs(defaultExcludedRefs());
+        }
+
+        HeapDump.Listener heapDumpListener = this.heapDumpListener;
+        if (heapDumpListener == null) {
+            heapDumpListener = defaultHeapDumpListener();
+        }
+
+        DebuggerControl debuggerControl = this.debuggerControl;
+        if (debuggerControl == null) {
+            debuggerControl = defaultDebuggerControl();
+        }
+
+        HeapDumper heapDumper = this.heapDumper;
+        if (heapDumper == null) {
+            heapDumper = defaultHeapDumper();
+        }
+
+        WatchExecutor watchExecutor = this.watchExecutor;
+        if (watchExecutor == null) {
+            watchExecutor = defaultWatchExecutor();
+        }
+
+        GcTrigger gcTrigger = this.gcTrigger;
+        if (gcTrigger == null) {
+            gcTrigger = defaultGcTrigger();
+        }
+
+        if (heapDumpBuilder.reachabilityInspectorClasses == null) {
+            heapDumpBuilder.reachabilityInspectorClasses(defaultReachabilityInspectorClasses());
+        }
+
+        return new RefWatcher(watchExecutor, debuggerControl, gcTrigger, heapDumper, heapDumpListener,
+                heapDumpBuilder);
+    }
 
-  protected boolean isDisabled() {
-    return false;
-  }
+    protected boolean isDisabled() {
+        return false;
+    }
 
-  protected GcTrigger defaultGcTrigger() {
-    return GcTrigger.DEFAULT;
-  }
+    protected GcTrigger defaultGcTrigger() {
+        return GcTrigger.DEFAULT;
+    }
 
-  protected DebuggerControl defaultDebuggerControl() {
-    return DebuggerControl.NONE;
-  }
+    protected DebuggerControl defaultDebuggerControl() {
+        return DebuggerControl.NONE;
+    }
 
-  protected ExcludedRefs defaultExcludedRefs() {
-    return ExcludedRefs.builder().build();
-  }
+    protected ExcludedRefs defaultExcludedRefs() {
+        return ExcludedRefs.builder().build();
+    }
 
-  protected HeapDumper defaultHeapDumper() {
-    return HeapDumper.NONE;
-  }
+    protected HeapDumper defaultHeapDumper() {
+        return HeapDumper.NONE;
+    }
 
-  protected HeapDump.Listener defaultHeapDumpListener() {
-    return HeapDump.Listener.NONE;
-  }
+    protected HeapDump.Listener defaultHeapDumpListener() {
+        return HeapDump.Listener.NONE;
+    }
 
-  protected WatchExecutor defaultWatchExecutor() {
-    return WatchExecutor.NONE;
-  }
+    protected WatchExecutor defaultWatchExecutor() {
+        return WatchExecutor.NONE;
+    }
 
-  protected List<Class<? extends Reachability.Inspector>> defaultReachabilityInspectorClasses() {
-    return Collections.emptyList();
-  }
+    protected List<Class<? extends Reachability.Inspector>> defaultReachabilityInspectorClasses() {
+        return Collections.emptyList();
+    }
 
-  @SuppressWarnings("unchecked")
-  protected final T self() {
-    return (T) this;
-  }
+    @SuppressWarnings("unchecked")
+    protected final T self() {
+        return (T) this;
+    }
 }
