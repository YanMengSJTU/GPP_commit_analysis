diff --git a/leakcanary-analyzer/build.gradle b/leakcanary-analyzer/build.gradle
index 618addf1..8cb636a4 100644
--- a/leakcanary-analyzer/build.gradle
+++ b/leakcanary-analyzer/build.gradle
@@ -5,6 +5,7 @@ dependencies {
   api project(':leakcanary-watcher')
   testImplementation 'junit:junit:4.12'
   testImplementation 'org.assertj:assertj-core:3.9.1'
+  implementation 'com.android.support:support-annotations:26.0.0'
 }
 
 android {
@@ -16,6 +17,7 @@ android {
 
   lintOptions {
     disable 'GoogleAppIndexingWarning'
+    check 'Interoperability'
   }
 
   // TODO replace with https://issuetracker.google.com/issues/72050365 once released.
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java b/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java
index 227bcb59..ca6fe3a6 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java
@@ -15,9 +15,11 @@
  */
 package com.squareup.haha.perflib;
 
+import android.support.annotation.NonNull;
+
 public final class HahaSpy {
 
-  public static Instance allocatingThread(Instance instance) {
+  public static @NonNull Instance allocatingThread(@NonNull Instance instance) {
     Snapshot snapshot = instance.mHeap.mSnapshot;
     int threadSerialNumber;
     if (instance instanceof RootObj) {
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
index 26ef2c1b..16039d32 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
@@ -15,23 +15,27 @@
  */
 package com.squareup.leakcanary;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import java.io.Serializable;
 
 public final class AnalysisResult implements Serializable {
 
   public static final long RETAINED_HEAP_SKIPPED = -1;
 
-  public static AnalysisResult noLeak(long analysisDurationMs) {
+  public static @NonNull AnalysisResult noLeak(long analysisDurationMs) {
     return new AnalysisResult(false, false, null, null, null, 0, analysisDurationMs);
   }
 
-  public static AnalysisResult leakDetected(boolean excludedLeak, String className,
-      LeakTrace leakTrace, long retainedHeapSize, long analysisDurationMs) {
+  public static @NonNull AnalysisResult leakDetected(boolean excludedLeak,
+      @NonNull String className,
+      @NonNull LeakTrace leakTrace, long retainedHeapSize, long analysisDurationMs) {
     return new AnalysisResult(true, excludedLeak, className, leakTrace, null, retainedHeapSize,
         analysisDurationMs);
   }
 
-  public static AnalysisResult failure(Throwable failure, long analysisDurationMs) {
+  public static @NonNull AnalysisResult failure(@NonNull Throwable failure,
+      long analysisDurationMs) {
     return new AnalysisResult(false, false, null, null, failure, 0, analysisDurationMs);
   }
 
@@ -48,16 +52,16 @@ public static AnalysisResult failure(Throwable failure, long analysisDurationMs)
    * Class name of the object that leaked if {@link #leakFound} is true, null otherwise.
    * The class name format is the same as what would be returned by {@link Class#getName()}.
    */
-  public final String className;
+  public final @Nullable String className;
 
   /**
    * Shortest path to GC roots for the leaking object if {@link #leakFound} is true, null
    * otherwise. This can be used as a unique signature for the leak.
    */
-  public final LeakTrace leakTrace;
+  public final @Nullable LeakTrace leakTrace;
 
   /** Null unless the analysis failed. */
-  public final Throwable failure;
+  public final @Nullable Throwable failure;
 
   /**
    * The number of bytes which would be freed if all references to the leaking object were
@@ -97,7 +101,7 @@ public static AnalysisResult failure(Throwable failure, long analysisDurationMs)
    *         at com.foo.WibbleActivity.leaking(WibbleActivity.java:42)
    * </pre>
    */
-  public RuntimeException leakTraceAsFakeException() {
+  public @NonNull RuntimeException leakTraceAsFakeException() {
     if (!leakFound) {
       throw new UnsupportedOperationException(
           "leakTraceAsFakeException() can only be called when leakFound is true");
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalyzerProgressListener.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalyzerProgressListener.java
index 0c211a49..917a98ba 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalyzerProgressListener.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalyzerProgressListener.java
@@ -1,9 +1,11 @@
 package com.squareup.leakcanary;
 
+import android.support.annotation.NonNull;
+
 public interface AnalyzerProgressListener {
 
   AnalyzerProgressListener NONE = new AnalyzerProgressListener() {
-    @Override public void onProgressUpdate(Step step) {
+    @Override public void onProgressUpdate(@NonNull Step step) {
     }
   };
 
@@ -19,5 +21,5 @@
     COMPUTING_BITMAP_SIZE,
   }
 
-  void onProgressUpdate(Step step);
+  void onProgressUpdate(@NonNull Step step);
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
index ebd5617f..a5093898 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.leakcanary;
 
+import android.support.annotation.NonNull;
 import com.squareup.haha.perflib.ArrayInstance;
 import com.squareup.haha.perflib.ClassInstance;
 import com.squareup.haha.perflib.ClassObj;
@@ -84,13 +85,14 @@
    * @deprecated Use {@link #HeapAnalyzer(ExcludedRefs, AnalyzerProgressListener, List)}.
    */
   @Deprecated
-  public HeapAnalyzer(ExcludedRefs excludedRefs) {
+  public HeapAnalyzer(@NonNull ExcludedRefs excludedRefs) {
     this(excludedRefs, AnalyzerProgressListener.NONE,
         Collections.<Class<? extends Reachability.Inspector>>emptyList());
   }
 
-  public HeapAnalyzer(ExcludedRefs excludedRefs, AnalyzerProgressListener listener,
-      List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses) {
+  public HeapAnalyzer(@NonNull ExcludedRefs excludedRefs,
+      @NonNull AnalyzerProgressListener listener,
+      @NonNull List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses) {
     this.excludedRefs = excludedRefs;
     this.listener = listener;
 
@@ -107,7 +109,7 @@ public HeapAnalyzer(ExcludedRefs excludedRefs, AnalyzerProgressListener listener
     }
   }
 
-  public List<TrackedReference> findTrackedReferences(File heapDumpFile) {
+  public @NonNull List<TrackedReference> findTrackedReferences(@NonNull File heapDumpFile) {
     if (!heapDumpFile.exists()) {
       throw new IllegalArgumentException("File does not exist: " + heapDumpFile);
     }
@@ -143,7 +145,8 @@ public HeapAnalyzer(ExcludedRefs excludedRefs, AnalyzerProgressListener listener
    * @deprecated Use {@link #checkForLeak(File, String, boolean)} instead.
    */
   @Deprecated
-  public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
+  public @NonNull AnalysisResult checkForLeak(@NonNull File heapDumpFile,
+      @NonNull String referenceKey) {
     return checkForLeak(heapDumpFile, referenceKey, true);
   }
 
@@ -151,7 +154,8 @@ public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
    * Searches the heap dump for a {@link KeyedWeakReference} instance with the corresponding key,
    * and then computes the shortest strong reference path from that instance to the GC roots.
    */
-  public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey,
+  public @NonNull AnalysisResult checkForLeak(@NonNull File heapDumpFile,
+      @NonNull String referenceKey,
       boolean computeRetainedSize) {
     long analysisStartNanoTime = System.nanoTime();
 
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
index 6b15fe63..b276aef9 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.leakcanary;
 
+import android.support.annotation.NonNull;
 import java.io.Serializable;
 import java.util.List;
 
@@ -24,8 +25,8 @@
  */
 public final class LeakTrace implements Serializable {
 
-  public final List<LeakTraceElement> elements;
-  public final List<Reachability> expectedReachability;
+  public final @NonNull List<LeakTraceElement> elements;
+  public final @NonNull List<Reachability> expectedReachability;
 
   LeakTrace(List<LeakTraceElement> elements, List<Reachability> expectedReachability) {
     this.elements = elements;
@@ -55,7 +56,7 @@
     return sb.toString();
   }
 
-  public String toDetailedString() {
+  public @NonNull String toDetailedString() {
     String string = "";
     for (LeakTraceElement element : elements) {
       string += element.toDetailedString();
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/TrackedReference.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/TrackedReference.java
index 66c1223b..ebfd9f8c 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/TrackedReference.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/TrackedReference.java
@@ -1,5 +1,6 @@
 package com.squareup.leakcanary;
 
+import android.support.annotation.NonNull;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -11,18 +12,19 @@
 public class TrackedReference {
 
   /** Corresponds to {@link KeyedWeakReference#key}. */
-  public final String key;
+  public final @NonNull String key;
 
   /** Corresponds to {@link KeyedWeakReference#name}. */
-  public final String name;
+  public final @NonNull String name;
 
   /** Class of the tracked instance. */
-  public final String className;
+  public final @NonNull String className;
 
   /** List of all fields (member and static) for that instance. */
   public final List<LeakReference> fields;
 
-  public TrackedReference(String key, String name, String className, List<LeakReference> fields) {
+  public TrackedReference(@NonNull String key, @NonNull String name, @NonNull String className,
+      @NonNull List<LeakReference> fields) {
     this.key = key;
     this.name = name;
     this.className = className;
