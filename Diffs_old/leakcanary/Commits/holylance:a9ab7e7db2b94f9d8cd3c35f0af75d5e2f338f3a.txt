diff --git a/build.gradle b/build.gradle
index 93378d1f..9f94ef10 100644
--- a/build.gradle
+++ b/build.gradle
@@ -22,7 +22,8 @@ buildscript {
               espresso: 'androidx.test.espresso:espresso-core:3.1.1',
               rules   : 'androidx.test:rules:1.1.1',
               runner  : 'androidx.test:runner:1.1.1',
-          ]
+          ],
+          benchmark : 'androidx.benchmark:benchmark:1.0.0-alpha01'
       ],
       haha          : 'com.squareup.haha:haha:2.1',
       junit         : 'junit:junit:4.12',
diff --git a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzer.kt b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzer.kt
index c581d644..7e03c259 100644
--- a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzer.kt
+++ b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzer.kt
@@ -319,7 +319,7 @@ class PerflibHeapAnalyzer @TestOnly internal constructor(
       val leakTrace = buildLeakTrace(pathResult.leakingNode)
 
       val retainedSize = if (heapDump.computeRetainedHeapSize) {
-        pathResult.leakingNode.instance.totalRetainedSize
+        pathResult.leakingNode.instance.totalRetainedSize.toInt()
       } else {
         null
       }
diff --git a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/ShortestPathFinder.kt b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/ShortestPathFinder.kt
index 34b50e6f..a8a58e1b 100644
--- a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/ShortestPathFinder.kt
+++ b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/ShortestPathFinder.kt
@@ -245,7 +245,7 @@ internal class ShortestPathFinder(
         exclusion = node.exclusion
       }
       val parent = LeakNode(null, holder, null, null)
-      enqueue(exclusion, parent, child, LeakReference(LOCAL, "", ""))
+      enqueue(exclusion, parent, child, LeakReference(LOCAL, ""))
     } else {
       enqueue(null, node, child, null)
     }
@@ -264,8 +264,7 @@ internal class ShortestPathFinder(
       }
       val child = value as Instance?
       var visit = true
-      val fieldValue = value?.toString() ?: "null"
-      val leakReference = LeakReference(STATIC_FIELD, fieldName, fieldValue)
+      val leakReference = LeakReference(STATIC_FIELD, fieldName)
       if (ignoredStaticFields != null) {
         val params = ignoredStaticFields[fieldName]
         if (params != null) {
@@ -320,10 +319,9 @@ internal class ShortestPathFinder(
       if (params != null && (fieldExclusion == null || params.alwaysExclude && !fieldExclusion.alwaysExclude)) {
         fieldExclusion = params
       }
-      val value = if (fieldValue.value == null) "null" else fieldValue.value.toString()
       enqueue(
           fieldExclusion, node, child,
-          LeakReference(INSTANCE_FIELD, fieldName, value)
+          LeakReference(INSTANCE_FIELD, fieldName)
       )
     }
   }
@@ -335,8 +333,7 @@ internal class ShortestPathFinder(
       for (i in values.indices) {
         val child = values[i] as Instance?
         val name = Integer.toString(i)
-        val value = child?.toString() ?: "null"
-        enqueue(null, node, child, LeakReference(ARRAY_ENTRY, name, value))
+        enqueue(null, node, child, LeakReference(ARRAY_ENTRY, name))
       }
     }
   }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt b/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt
index f26e9818..52ca9f9c 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt
@@ -13,6 +13,9 @@ interface AnalyzerProgressListener {
     FINDING_LEAKING_REFS,
     FINDING_SHORTEST_PATH,
     FINDING_SHORTEST_PATHS,
+    FINDING_DOMINATORS,
+    COMPUTING_NATIVE_RETAINED_SIZE,
+    COMPUTING_RETAINED_SIZE,
     BUILDING_LEAK_TRACE,
     BUILDING_LEAK_TRACES,
     COMPUTING_DOMINATORS
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
index 609662bc..26c22646 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
@@ -85,7 +85,7 @@ data class LeakingInstance(
    * The number of bytes which would be freed if all references to the leaking object were
    * released. Null if the retained heap size was not computed.
    */
-  val retainedHeapSize: Long?
+  val retainedHeapSize: Int?
 
 ) : WeakReferenceFound() {
 
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
index 40037d40..fccdfb44 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
@@ -16,9 +16,9 @@
 package leakcanary
 
 import leakcanary.AnalyzerProgressListener.Step.BUILDING_LEAK_TRACES
-import leakcanary.AnalyzerProgressListener.Step.COMPUTING_DOMINATORS
+import leakcanary.AnalyzerProgressListener.Step.COMPUTING_NATIVE_RETAINED_SIZE
+import leakcanary.AnalyzerProgressListener.Step.COMPUTING_RETAINED_SIZE
 import leakcanary.AnalyzerProgressListener.Step.FINDING_LEAKING_REFS
-import leakcanary.AnalyzerProgressListener.Step.FINDING_SHORTEST_PATHS
 import leakcanary.AnalyzerProgressListener.Step.FINDING_WATCHED_REFERENCES
 import leakcanary.AnalyzerProgressListener.Step.READING_HEAP_DUMP_FILE
 import leakcanary.AnalyzerProgressListener.Step.SCANNING_HEAP_DUMP
@@ -31,7 +31,6 @@ import leakcanary.GcRoot.NativeStack
 import leakcanary.GcRoot.ReferenceCleanup
 import leakcanary.GcRoot.StickyClass
 import leakcanary.GcRoot.ThreadBlock
-import leakcanary.HeapValue.LongValue
 import leakcanary.HprofParser.RecordCallbacks
 import leakcanary.LeakNode.ChildNode
 import leakcanary.LeakNodeStatus.LEAKING
@@ -55,14 +54,15 @@ import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.Fl
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
-import leakcanary.Record.LoadClassRecord
-import leakcanary.Record.StringRecord
 import leakcanary.internal.KeyedWeakReferenceMirror
 import leakcanary.internal.ShortestPathFinder
 import leakcanary.internal.ShortestPathFinder.Result
+import leakcanary.internal.ShortestPathFinder.Results
+import leakcanary.internal.hppc.LongLongScatterMap
 import leakcanary.internal.lastSegment
 import java.io.File
 import java.util.ArrayList
+import java.util.LinkedHashMap
 import java.util.concurrent.TimeUnit.NANOSECONDS
 
 /**
@@ -95,17 +95,16 @@ class HeapAnalyzer constructor(
 
     listener.onProgressUpdate(READING_HEAP_DUMP_FILE)
 
-
     try {
       HprofParser.open(heapDumpFile)
           .use { parser ->
             listener.onProgressUpdate(SCANNING_HEAP_DUMP)
-            val (gcRootIds, heapDumpMemoryStoreClassId, keyedWeakReferenceInstances) = scan(parser)
+            val (gcRootIds, keyedWeakReferenceInstances, cleaners) = scan(
+                parser, computeRetainedHeapSize
+            )
             val analysisResults = mutableMapOf<String, RetainedInstance>()
             listener.onProgressUpdate(FINDING_WATCHED_REFERENCES)
-            val (retainedKeys, heapDumpUptimeMillis) = readHeapDumpMemoryStore(
-                parser, heapDumpMemoryStoreClassId
-            )
+            val (retainedKeys, heapDumpUptimeMillis) = readHeapDumpMemoryStore(parser)
 
             if (retainedKeys.isEmpty()) {
               val exception = IllegalStateException("No retained keys found in heap dump")
@@ -121,12 +120,21 @@ class HeapAnalyzer constructor(
                   heapDumpUptimeMillis
               )
 
-            val pathResults =
-              findShortestPaths(parser, exclusionsFactory, leakingWeakRefs, gcRootIds)
+            val (pathResults, dominatedInstances) =
+              findShortestPaths(
+                  parser, exclusionsFactory, leakingWeakRefs, gcRootIds,
+                  computeRetainedHeapSize
+              )
+
+            val retainedSizes = if (computeRetainedHeapSize) {
+              computeRetainedSizes(parser, pathResults, dominatedInstances, cleaners)
+            } else {
+              null
+            }
 
             buildLeakTraces(
-                computeRetainedHeapSize, reachabilityInspectors, labelers, pathResults, parser,
-                leakingWeakRefs, analysisResults
+                reachabilityInspectors, labelers, pathResults, parser,
+                leakingWeakRefs, analysisResults, retainedSizes
             )
 
             addRemainingInstancesWithNoPath(parser, leakingWeakRefs, analysisResults)
@@ -144,31 +152,24 @@ class HeapAnalyzer constructor(
     }
   }
 
-  private fun scan(parser: HprofParser): Triple<MutableList<Long>, Long, List<InstanceDumpRecord>> {
-    var keyedWeakReferenceStringId = -1L
-    var heapDumpMemoryStoreStringId = -1L
-    var keyedWeakReferenceClassId = -1L
-    var heapDumpMemoryStoreClassId = -1L
+  private data class ScanResult(
+    val gcRootIds: MutableList<Long>,
+    val keyedWeakReferenceInstances: List<InstanceDumpRecord>,
+    val cleaners: MutableList<Long>
+  )
+
+  private fun scan(
+    parser: HprofParser,
+    computeRetainedSize: Boolean
+  ): ScanResult {
     val keyedWeakReferenceInstances = mutableListOf<InstanceDumpRecord>()
     val gcRootIds = mutableListOf<Long>()
+    val cleaners = mutableListOf<Long>()
     val callbacks = RecordCallbacks()
-        .on(StringRecord::class.java) {
-          if (it.string == KeyedWeakReference::class.java.name) {
-            keyedWeakReferenceStringId = it.id
-          } else if (it.string == HeapDumpMemoryStore::class.java.name) {
-            heapDumpMemoryStoreStringId = it.id
-          }
-        }
-        .on(LoadClassRecord::class.java) {
-          if (it.classNameStringId == keyedWeakReferenceStringId) {
-            keyedWeakReferenceClassId = it.id
-          } else if (it.classNameStringId == heapDumpMemoryStoreStringId) {
-            heapDumpMemoryStoreClassId = it.id
-          }
-        }
-        .on(InstanceDumpRecord::class.java) {
-          if (it.classId == keyedWeakReferenceClassId) {
-            keyedWeakReferenceInstances.add(it)
+        .on(InstanceDumpRecord::class.java) { record ->
+          when (parser.className(record.classId)) {
+            KeyedWeakReference::class.java.name -> keyedWeakReferenceInstances.add(record)
+            "sun.misc.Cleaner" -> if (computeRetainedSize) cleaners.add(record.id)
           }
         }
         .on(GcRootRecord::class.java) {
@@ -194,20 +195,19 @@ class HeapAnalyzer constructor(
           }
         }
     parser.scan(callbacks)
-    return Triple(gcRootIds, heapDumpMemoryStoreClassId, keyedWeakReferenceInstances)
+    return ScanResult(gcRootIds, keyedWeakReferenceInstances, cleaners)
   }
 
   private fun readHeapDumpMemoryStore(
-    parser: HprofParser,
-    heapDumpMemoryStoreClassId: Long
-  ): Pair<MutableSet<Long>, Long> {
+    parser: HprofParser
+  ): Pair<MutableSet<Long>, Long> = with(parser) {
+    val heapDumpMemoryStoreClassId = parser.classId(HeapDumpMemoryStore::class.java.name)!!
     val storeClass = parser.hydrateClassHierarchy(heapDumpMemoryStoreClassId)[0]
-    val retainedKeysForHeapDump = (parser.retrieveRecord(
-        storeClass.staticFieldValue("retainedKeysForHeapDump")
-    ) as ObjectArrayDumpRecord).elementIds.toMutableSet()
-    val heapDumpUptimeMillis =
-      storeClass.staticFieldValue<LongValue>("heapDumpUptimeMillis")
-          .value
+    val retainedKeysRecord =
+      storeClass["retainedKeysForHeapDump"].reference!!.objectRecord as ObjectArrayDumpRecord
+
+    val retainedKeysForHeapDump = retainedKeysRecord.elementIds.toMutableSet()
+    val heapDumpUptimeMillis = storeClass["heapDumpUptimeMillis"].long!!
     return retainedKeysForHeapDump to heapDumpUptimeMillis
   }
 
@@ -252,32 +252,145 @@ class HeapAnalyzer constructor(
     parser: HprofParser,
     exclusionsFactory: ExclusionsFactory,
     leakingWeakRefs: List<KeyedWeakReferenceMirror>,
-    gcRootIds: MutableList<Long>
-  ): List<Result> {
-    listener.onProgressUpdate(FINDING_SHORTEST_PATHS)
-
+    gcRootIds: MutableList<Long>,
+    computeDominators: Boolean
+  ): Results {
     val pathFinder = ShortestPathFinder()
-    return pathFinder.findPaths(parser, exclusionsFactory, leakingWeakRefs, gcRootIds)
+    return pathFinder.findPaths(
+        parser, exclusionsFactory, leakingWeakRefs, gcRootIds, computeDominators, listener
+    )
+  }
+
+  private fun computeRetainedSizes(
+    parser: HprofParser,
+    results: List<Result>,
+    dominatedInstances: LongLongScatterMap,
+    cleaners: MutableList<Long>
+  ): List<Int> {
+    listener.onProgressUpdate(COMPUTING_NATIVE_RETAINED_SIZE)
+
+    // Map of Object id to native size as tracked by NativeAllocationRegistry$CleanerThunk
+    val nativeSizes = mutableMapOf<Long, Int>().withDefault { 0 }
+    // Doc from perflib:
+    // Native allocations can be identified by looking at instances of
+    // libcore.util.NativeAllocationRegistry$CleanerThunk. The "owning" Java object is the
+    // "referent" field of the "sun.misc.Cleaner" instance with a hard reference to the
+    // CleanerThunk.
+    //
+    // The size is in the 'size' field of the libcore.util.NativeAllocationRegistry instance
+    // that the CleanerThunk has a pointer to. The native pointer is in the 'nativePtr' field of
+    // the CleanerThunk. The hprof does not include the native bytes pointed to.
+
+    with(parser) {
+      cleaners.forEach {
+        val cleaner = it.hydratedInstance
+        val thunkId = cleaner["thunk"].reference
+        val referentId = cleaner["referent"].reference
+        if (thunkId != null && referentId != null) {
+          val thunkRecord = thunkId.objectRecord
+          if (thunkRecord instanceOf "libcore.util.NativeAllocationRegistry\$CleanerThunk") {
+            val thunkRunnable = thunkRecord.hydratedInstance
+            val allocationRegistryId = thunkRunnable["this\$0"].reference
+            if (allocationRegistryId != null) {
+              val allocationRegistryRecord = allocationRegistryId.objectRecord
+              if (allocationRegistryRecord instanceOf "libcore.util.NativeAllocationRegistry") {
+                val allocationRegistry = allocationRegistryRecord.hydratedInstance
+                var nativeSize = nativeSizes.getValue(referentId)
+                nativeSize += allocationRegistry["size"].long?.toInt() ?: 0
+                nativeSizes[referentId] = nativeSize
+              }
+            }
+          }
+        }
+      }
+    }
+
+    listener.onProgressUpdate(COMPUTING_RETAINED_SIZE)
+
+    val sizeByDominator = LinkedHashMap<Long, Int>().withDefault { 0 }
+
+    // Include self size for leaking instances
+    val leakingInstanceIds = mutableSetOf<Long>()
+    results.forEach { result ->
+      val leakingInstanceId = result.weakReference.referent.value
+      leakingInstanceIds.add(leakingInstanceId)
+      val instanceRecord =
+        parser.retrieveRecordById(leakingInstanceId) as InstanceDumpRecord
+      val classRecord =
+        parser.retrieveRecordById(instanceRecord.classId) as ClassDumpRecord
+      var retainedSize = sizeByDominator.getValue(leakingInstanceId)
+
+      retainedSize += classRecord.instanceSize
+      sizeByDominator[leakingInstanceId] = retainedSize
+    }
+
+    // Compute the size of each dominated instance and add to dominator
+    dominatedInstances.forEach { instanceId, dominatorId ->
+      // Avoid double reporting as those sizes will move up to the root dominator
+      if (instanceId !in leakingInstanceIds) {
+        val currentSize = sizeByDominator.getValue(dominatorId)
+        val record = parser.retrieveRecordById(instanceId)
+        val nativeSize = nativeSizes.getValue(instanceId)
+        val shallowSize = when (record) {
+          is InstanceDumpRecord -> {
+            val classRecord = parser.retrieveRecordById(record.classId) as ClassDumpRecord
+            // Note: instanceSize is the sum of shallow size through the class hierarchy
+            classRecord.instanceSize
+          }
+          is ObjectArrayDumpRecord -> record.elementIds.size * parser.idSize
+          is BooleanArrayDump -> record.array.size * HprofReader.BOOLEAN_SIZE
+          is CharArrayDump -> record.array.size * HprofReader.CHAR_SIZE
+          is FloatArrayDump -> record.array.size * HprofReader.FLOAT_SIZE
+          is DoubleArrayDump -> record.array.size * HprofReader.DOUBLE_SIZE
+          is ByteArrayDump -> record.array.size * HprofReader.BYTE_SIZE
+          is ShortArrayDump -> record.array.size * HprofReader.SHORT_SIZE
+          is IntArrayDump -> record.array.size * HprofReader.INT_SIZE
+          is LongArrayDump -> record.array.size * HprofReader.LONG_SIZE
+          else -> {
+            throw IllegalStateException("Unexpected record $record")
+          }
+        }
+        sizeByDominator[dominatorId] = currentSize + nativeSize + shallowSize
+      }
+    }
+
+    // Move retained sizes from dominated leaking instance to dominators leaking instances.
+    // Keep doing this until nothing moves.
+    var sizedMoved: Boolean
+    do {
+      sizedMoved = false
+      results.map { it.weakReference.referent.value }
+          .forEach { leakingInstanceId ->
+            val dominator = dominatedInstances[leakingInstanceId]
+            if (dominator != null) {
+              val retainedSize = sizeByDominator.getValue(leakingInstanceId)
+              if (retainedSize > 0) {
+                sizeByDominator[leakingInstanceId] = 0
+                val dominatorRetainedSize = sizeByDominator.getValue(dominator)
+                sizeByDominator[dominator] = retainedSize + dominatorRetainedSize
+                sizedMoved = true
+              }
+            }
+          }
+    } while (sizedMoved)
+    dominatedInstances.release()
+    return results.map { result ->
+      sizeByDominator[result.weakReference.referent.value]!!
+    }
   }
 
   private fun buildLeakTraces(
-    computeRetainedHeapSize: Boolean,
     leakInspectors: List<LeakInspector>,
     labelers: List<Labeler>,
     pathResults: List<Result>,
     parser: HprofParser,
     leakingWeakRefs: MutableList<KeyedWeakReferenceMirror>,
-    analysisResults: MutableMap<String, RetainedInstance>
+    analysisResults: MutableMap<String, RetainedInstance>,
+    retainedSizes: List<Int>?
   ) {
-    if (computeRetainedHeapSize && pathResults.isNotEmpty()) {
-      listener.onProgressUpdate(COMPUTING_DOMINATORS)
-      // Computing dominators has the side effect of computing retained size.
-      CanaryLog.d("Cannot compute retained heap size because dominators is not implemented yet")
-    }
-
     listener.onProgressUpdate(BUILDING_LEAK_TRACES)
 
-    pathResults.forEach { pathResult ->
+    pathResults.forEachIndexed { index, pathResult ->
       val weakReference = pathResult.weakReference
       val removed = leakingWeakRefs.remove(weakReference)
       if (!removed) {
@@ -294,8 +407,6 @@ class HeapAnalyzer constructor(
       val instanceClassName =
         recordClassName(parser.retrieveRecordById(pathResult.leakingNode.instance), parser)
 
-      // TODO Compute retained heap size
-      val retainedSize = null
       val key = parser.retrieveString(weakReference.key)
       val leakDetected = LeakingInstance(
           referenceKey = key,
@@ -303,7 +414,7 @@ class HeapAnalyzer constructor(
           instanceClassName = instanceClassName,
           watchDurationMillis = weakReference.watchDurationMillis,
           exclusionStatus = pathResult.exclusionStatus, leakTrace = leakTrace,
-          retainedHeapSize = retainedSize
+          retainedHeapSize = retainedSizes?.get(index)
       )
       analysisResults[key] = leakDetected
     }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakNodeStatus.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakNodeStatus.kt
index 4a5e8771..0fcca05f 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakNodeStatus.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakNodeStatus.kt
@@ -1,5 +1,7 @@
 package leakcanary
 
+import java.io.Serializable
+
 /**
  * Evaluates whether a [LeakNode] is leaking or not, and provides a reason for that decision.
  */
@@ -34,4 +36,4 @@ enum class LeakNodeStatus {
 class LeakNodeStatusAndReason internal constructor(
   val status: LeakNodeStatus,
   val reason: String
-)
\ No newline at end of file
+) : Serializable
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakReference.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakReference.kt
index 9e64c7d3..1673d2d4 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakReference.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakReference.kt
@@ -27,8 +27,7 @@ import java.io.Serializable
  */
 data class LeakReference(
   val type: Type,
-  val name: String,
-  val value: String
+  val name: String
 ) : Serializable {
 
   val displayName: String
@@ -49,12 +48,4 @@ data class LeakReference(
         LOCAL -> "<Java Local>"
       }
     }
-
-  override fun toString(): String {
-    return when (type) {
-      ARRAY_ENTRY, INSTANCE_FIELD -> "$displayName = $value"
-      STATIC_FIELD -> "static $displayName = $value"
-      LOCAL -> displayName
-    }
-  }
 }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
index 993aaf1d..e5441abc 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
@@ -15,12 +15,16 @@
  */
 package leakcanary.internal
 
+import leakcanary.AnalyzerProgressListener
+import leakcanary.AnalyzerProgressListener.Step.FINDING_DOMINATORS
+import leakcanary.AnalyzerProgressListener.Step.FINDING_SHORTEST_PATHS
 import leakcanary.Exclusion
 import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
 import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
 import leakcanary.Exclusion.ExclusionType.ThreadExclusion
 import leakcanary.Exclusion.Status
 import leakcanary.Exclusion.Status.NEVER_REACHABLE
+import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.ExclusionsFactory
 import leakcanary.HeapValue
 import leakcanary.HeapValue.ObjectReference
@@ -32,15 +36,18 @@ import leakcanary.LeakReference
 import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
 import leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
 import leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import leakcanary.ObjectIdMetadata.CLASS
 import leakcanary.ObjectIdMetadata.EMPTY_INSTANCE
-import leakcanary.ObjectIdMetadata.PRIMITIVE_ARRAY_OR_WRAPPER_ARRAY
-import leakcanary.ObjectIdMetadata.PRIMITIVE_WRAPPER
+import leakcanary.ObjectIdMetadata.PRIMITIVE_WRAPPER_ARRAY
+import leakcanary.ObjectIdMetadata.PRIMITIVE_WRAPPER_OR_PRIMITIVE_ARRAY
 import leakcanary.ObjectIdMetadata.STRING
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.internal.hppc.LongLongScatterMap
+import leakcanary.internal.hppc.LongScatterSet
+import leakcanary.reference
 import java.util.LinkedHashMap
-import java.util.LinkedHashSet
 import java.util.PriorityQueue
 
 /**
@@ -69,22 +76,41 @@ internal class ShortestPathFinder {
   })
   /** Set of instances to visit */
   private val toVisitMap = LinkedHashMap<Long, Status>()
-  private val visitedSet = LinkedHashSet<Long>()
+  private val visitedSet = LongScatterSet()
   private lateinit var referentMap: Map<Long, KeyedWeakReferenceMirror>
   private var visitOrder = 0
 
-  internal class Result(
+  /**
+   * Map of instances to their leaking dominator.
+   * var because the instance will be returned by [findPaths] and replaced with a new empty map
+   * here (copying it could be expensive).
+   *
+   * If an instance has been added to [toVisitMap] or [visitedSet] and is missing from
+   * [dominatedInstances] then it's considered "undomitable" ie it is dominated by gc roots
+   * and cannot be dominated by a leaking instance.
+   */
+  private var dominatedInstances = LongLongScatterMap()
+
+  class Result(
     val leakingNode: LeakNode,
     val exclusionStatus: Status?,
     val weakReference: KeyedWeakReferenceMirror
   )
 
+  data class Results(
+    val results: List<Result>,
+    val dominatedInstances: LongLongScatterMap
+  )
+
   fun findPaths(
     parser: HprofParser,
     exclusionsFactory: ExclusionsFactory,
     leakingWeakRefs: List<KeyedWeakReferenceMirror>,
-    gcRootIds: MutableList<Long>
-  ): List<Result> {
+    gcRootIds: MutableList<Long>,
+    computeDominators: Boolean,
+    listener: AnalyzerProgressListener
+  ): Results {
+    listener.onProgressUpdate(FINDING_SHORTEST_PATHS)
     clearState()
 
     val fieldNameByClassName = mutableMapOf<String, MutableMap<String, Exclusion>>()
@@ -123,12 +149,12 @@ internal class ShortestPathFinder {
     // Referent object id to weak ref mirror
     referentMap = leakingWeakRefs.associateBy { it.referent.value }
 
-    enqueueGcRoots(parser, gcRootIds)
+    enqueueGcRoots(parser, gcRootIds, computeDominators)
     gcRootIds.clear()
 
     var lowestPriority = ALWAYS_REACHABLE
     val results = mutableListOf<Result>()
-    while (!toVisitQueue.isEmpty()) {
+    visitingQueue@ while (!toVisitQueue.isEmpty()) {
       val node = toVisitQueue.poll()!!
       val priority = toVisitMap[node.instance]!!
       // Lowest priority has the highest value
@@ -146,21 +172,38 @@ internal class ShortestPathFinder {
       if (weakReference != null) {
         val exclusionPriority = if (lowestPriority == ALWAYS_REACHABLE) null else lowestPriority
         results.add(Result(node, exclusionPriority, weakReference))
-        // Found all refs, stop searching.
+        // Found all refs, stop searching (unless computing retained size which stops on weak reachables)
         if (results.size == leakingWeakRefs.size) {
-          break
+          if (computeDominators && lowestPriority < WEAKLY_REACHABLE) {
+            listener.onProgressUpdate(FINDING_DOMINATORS)
+          } else {
+            break@visitingQueue
+          }
         }
       }
 
+      if (results.size == leakingWeakRefs.size && computeDominators && lowestPriority >= WEAKLY_REACHABLE) {
+        break@visitingQueue
+      }
+
       when (val record = parser.retrieveRecordById(node.instance)) {
-        is ClassDumpRecord -> visitClassRecord(parser, record, node, staticFieldNameByClassName)
-        is InstanceDumpRecord -> visitInstanceRecord(parser, record, node, fieldNameByClassName)
-        is ObjectArrayDumpRecord -> visitObjectArrayRecord(parser, record, node)
+        is ClassDumpRecord -> visitClassRecord(
+            parser, record, node, staticFieldNameByClassName, computeDominators
+        )
+        is InstanceDumpRecord -> visitInstanceRecord(
+            parser, record, node, fieldNameByClassName, computeDominators
+        )
+        is ObjectArrayDumpRecord -> visitObjectArrayRecord(
+            parser, record, node, computeDominators
+        )
       }
     }
 
+    val dominatedInstances = this.dominatedInstances
+
     clearState()
-    return results
+
+    return Results(results, dominatedInstances)
   }
 
   private fun checkSeen(node: LeakNode): Boolean {
@@ -171,14 +214,16 @@ internal class ShortestPathFinder {
   private fun clearState() {
     toVisitQueue.clear()
     toVisitMap.clear()
-    visitedSet.clear()
+    visitedSet.release()
     visitOrder = 0
     referentMap = emptyMap()
+    dominatedInstances = LongLongScatterMap()
   }
 
   private fun enqueueGcRoots(
     hprofParser: HprofParser,
-    gcRootIds: List<Long>
+    gcRootIds: List<Long>,
+    computeDominators: Boolean
   ) {
     // TODO sort GC roots based on type and class name (for class / instance / array)
     // Goal is to get a stable shortest path
@@ -186,6 +231,9 @@ internal class ShortestPathFinder {
     // TODO java local: exclude specific threads,
     // TODO java local: parent should be set to the allocated thread
     gcRootIds.forEach {
+      if (computeDominators) {
+        undominateWithSkips(hprofParser, it)
+      }
       enqueue(hprofParser, RootNode(it), exclusionPriority = null)
     }
   }
@@ -194,7 +242,8 @@ internal class ShortestPathFinder {
     hprofParser: HprofParser,
     record: ClassDumpRecord,
     node: LeakNode,
-    staticFieldNameByClassName: Map<String, Map<String, Exclusion>>
+    staticFieldNameByClassName: Map<String, Map<String, Exclusion>>,
+    computeRetainedHeapSize: Boolean
   ) {
     val className = hprofParser.className(record.id)
 
@@ -207,7 +256,11 @@ internal class ShortestPathFinder {
         continue
       }
 
-      val leakReference = LeakReference(STATIC_FIELD, fieldName, "object $objectId")
+      if (computeRetainedHeapSize) {
+        undominateWithSkips(hprofParser, objectId)
+      }
+
+      val leakReference = LeakReference(STATIC_FIELD, fieldName)
 
       val exclusion = ignoredStaticFields[fieldName]
 
@@ -223,7 +276,8 @@ internal class ShortestPathFinder {
     hprofParser: HprofParser,
     record: InstanceDumpRecord,
     parent: LeakNode,
-    fieldNameByClassName: Map<String, Map<String, Exclusion>>
+    fieldNameByClassName: Map<String, Map<String, Exclusion>>,
+    computeRetainedHeapSize: Boolean
   ) {
     val instance = hprofParser.hydrateInstance(record)
 
@@ -247,12 +301,16 @@ internal class ShortestPathFinder {
     fieldNamesAndValues.filter { (_, value) -> value is ObjectReference }
         .map { (name, reference) -> name to (reference as ObjectReference).value }
         .forEach { (fieldName, objectId) ->
+          if (computeRetainedHeapSize) {
+            updateDominatorWithSkips(hprofParser, parent.instance, objectId)
+          }
+
           val exclusion = ignoredFields[fieldName]
           enqueue(
               hprofParser, ChildNode(
               objectId,
               visitOrder++, exclusion?.description, parent,
-              LeakReference(INSTANCE_FIELD, fieldName, "object $objectId")
+              LeakReference(INSTANCE_FIELD, fieldName)
           ), exclusion?.status
           )
         }
@@ -261,11 +319,15 @@ internal class ShortestPathFinder {
   private fun visitObjectArrayRecord(
     hprofParser: HprofParser,
     record: ObjectArrayDumpRecord,
-    parentNode: LeakNode
+    parentNode: LeakNode,
+    computeRetainedHeapSize: Boolean
   ) {
     record.elementIds.forEachIndexed { index, elementId ->
+      if (computeRetainedHeapSize) {
+        updateDominatorWithSkips(hprofParser, parentNode.instance, elementId)
+      }
       val name = Integer.toString(index)
-      val reference = LeakReference(ARRAY_ENTRY, name, "object $elementId")
+      val reference = LeakReference(ARRAY_ENTRY, name)
       enqueue(hprofParser, ChildNode(elementId, visitOrder++, null, parentNode, reference), null)
     }
   }
@@ -309,9 +371,147 @@ internal class ShortestPathFinder {
     toVisitQueue.add(node)
   }
 
+  private fun updateDominatorWithSkips(
+    hprofParser: HprofParser,
+    parentObjectId: Long,
+    objectId: Long
+  ) {
+    when (hprofParser.objectIdMetadata(objectId)) {
+      CLASS -> {
+        undominate(objectId, false)
+      }
+      // String internal array is never enqueued
+      STRING -> {
+        updateDominator(parentObjectId, objectId, true)
+        val stringRecord = hprofParser.retrieveRecordById(objectId) as InstanceDumpRecord
+        val stringInstance = hprofParser.hydrateInstance(stringRecord)
+        val valueId = stringInstance["value"].reference
+        if (valueId != null) {
+          updateDominator(parentObjectId, valueId, true)
+        }
+      }
+      // Primitive wrapper array elements are never enqueued
+      PRIMITIVE_WRAPPER_ARRAY -> {
+        updateDominator(parentObjectId, objectId, true)
+        val arrayRecord = hprofParser.retrieveRecordById(objectId) as ObjectArrayDumpRecord
+        for (wrapperId in arrayRecord.elementIds) {
+          updateDominator(parentObjectId, wrapperId, true)
+        }
+      }
+      else -> {
+        updateDominator(parentObjectId, objectId, false)
+      }
+    }
+  }
+
+  private fun updateDominator(
+    parent: Long,
+    instance: Long,
+    neverEnqueued: Boolean
+  ) {
+    val currentDominator = dominatedInstances[instance]
+    if (currentDominator == null && (instance in visitedSet || instance in toVisitMap)) {
+      return
+    }
+    val parentDominator = dominatedInstances[parent]
+
+    val parentIsRetainedInstance = referentMap.containsKey(parent)
+
+    val nextDominator = if (parentIsRetainedInstance) parent else parentDominator
+
+    if (nextDominator == null) {
+      // parent is not a retained instance and parent has no dominator, but it must have been
+      // visited therefore we know parent belongs to undominated.
+      if (neverEnqueued) {
+        visitedSet.add(instance)
+      }
+
+      if (currentDominator != null) {
+        dominatedInstances.remove(instance)
+      }
+      return
+    }
+    if (currentDominator == null) {
+      dominatedInstances[instance] = nextDominator
+    } else {
+      val parentDominators = mutableListOf<Long>()
+      val currentDominators = mutableListOf<Long>()
+      var dominator: Long? = nextDominator
+      while (dominator != null) {
+        parentDominators.add(dominator)
+        dominator = dominatedInstances[dominator]
+      }
+      dominator = currentDominator
+      while (dominator != null) {
+        currentDominators.add(dominator)
+        dominator = dominatedInstances[dominator]
+      }
+
+      var sharedDominator: Long? = null
+      exit@ for (parentD in parentDominators) {
+        for (currentD in currentDominators) {
+          if (currentD == parentD) {
+            sharedDominator = currentD
+            break@exit
+          }
+        }
+      }
+      if (sharedDominator == null) {
+        dominatedInstances.remove(instance)
+        if (neverEnqueued) {
+          visitedSet.add(instance)
+        }
+      } else {
+        dominatedInstances[instance] = sharedDominator
+      }
+    }
+  }
+
+  private fun undominateWithSkips(
+    hprofParser: HprofParser,
+    objectId: Long
+  ) {
+    when (hprofParser.objectIdMetadata(objectId)) {
+      CLASS -> {
+        undominate(objectId, false)
+      }
+      // String internal array is never enqueued
+      STRING -> {
+        undominate(objectId, true)
+        val stringRecord = hprofParser.retrieveRecordById(objectId) as InstanceDumpRecord
+        val stringInstance = hprofParser.hydrateInstance(stringRecord)
+        val valueId = stringInstance["value"].reference
+        if (valueId != null) {
+          undominate(valueId, true)
+        }
+      }
+      // Primitive wrapper array elements are never enqueued
+      PRIMITIVE_WRAPPER_ARRAY -> {
+        undominate(objectId, true)
+        val arrayRecord = hprofParser.retrieveRecordById(objectId) as ObjectArrayDumpRecord
+        for (wrapperId in arrayRecord.elementIds) {
+          undominate(wrapperId, true)
+        }
+      }
+      else -> {
+        undominate(objectId, false)
+      }
+    }
+  }
+
+  private fun undominate(
+    instance: Long,
+    neverEnqueued: Boolean
+  ) {
+    dominatedInstances.remove(instance)
+    if (neverEnqueued) {
+      visitedSet.add(instance)
+    }
+  }
+
   companion object {
     private val SKIP_ENQUEUE =
-      setOf(PRIMITIVE_WRAPPER, PRIMITIVE_ARRAY_OR_WRAPPER_ARRAY, STRING, EMPTY_INSTANCE)
+      setOf(PRIMITIVE_WRAPPER_OR_PRIMITIVE_ARRAY, PRIMITIVE_WRAPPER_ARRAY, STRING, EMPTY_INSTANCE)
 
     // Since NEVER_REACHABLE never ends up in the queue, we use its value to mean "ALWAYS_REACHABLE"
     // For this to work we need NEVER_REACHABLE to be declared as the first enum value.
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/HHPC.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/HHPC.kt
new file mode 100644
index 00000000..08357b54
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/HHPC.kt
@@ -0,0 +1,88 @@
+package leakcanary.internal.hppc
+
+import java.util.Locale
+
+/**
+ * Code from https://github.com/carrotsearch/hppc copy pasted, inlined and converted to Kotlin.
+ */
+internal object HHPC {
+
+  private const val PHI_C64 = -0x61c8864680b583ebL
+
+  fun mixPhi(k: Long): Int {
+    val h = k * PHI_C64
+    return (h xor h.ushr(32)).toInt()
+  }
+
+  private const val MIN_HASH_ARRAY_LENGTH = 4
+  private const val MAX_HASH_ARRAY_LENGTH = (-0x80000000).ushr(1)
+
+
+  fun minBufferSize(
+    elements: Int,
+    loadFactor: Double
+  ): Int {
+    var length = Math.ceil(elements / loadFactor)
+        .toLong()
+    if (length == elements.toLong()) {
+      length++
+    }
+    length = Math.max(MIN_HASH_ARRAY_LENGTH.toLong(), nextHighestPowerOfTwo(length))
+
+    if (length > MAX_HASH_ARRAY_LENGTH) {
+      throw RuntimeException(
+          String.format(
+              Locale.ROOT,
+              "Maximum array size exceeded for this load factor (elements: %d, load factor: %f)",
+              elements,
+              loadFactor
+          )
+      )
+    }
+
+    return length.toInt()
+  }
+
+
+  fun nextHighestPowerOfTwo(input: Long): Long {
+    var v = input
+    v--
+    v = v or (v shr 1)
+    v = v or (v shr 2)
+    v = v or (v shr 4)
+    v = v or (v shr 8)
+    v = v or (v shr 16)
+    v = v or (v shr 32)
+    v++
+    return v
+  }
+
+
+  fun expandAtCount(
+    arraySize: Int,
+    loadFactor: Double
+  ): Int {
+    return Math.min(arraySize - 1, Math.ceil(arraySize * loadFactor).toInt())
+  }
+
+
+  fun nextBufferSize(
+    arraySize: Int,
+    elements: Int,
+    loadFactor: Double
+  ): Int {
+    if (arraySize == MAX_HASH_ARRAY_LENGTH) {
+      throw RuntimeException(
+          String.format(
+              Locale.ROOT,
+              "Maximum array size exceeded for this load factor (elements: %d, load factor: %f)",
+              elements,
+              loadFactor
+          )
+      )
+    }
+
+    return arraySize shl 1
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongLongScatterMap.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongLongScatterMap.kt
new file mode 100644
index 00000000..90e13d31
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongLongScatterMap.kt
@@ -0,0 +1,342 @@
+package leakcanary.internal.hppc
+
+import java.util.Locale
+
+/**
+ * Code from com.carrotsearch.hppc.LongLongScatterMap copy pasted, inlined and converted to Kotlin.
+ *
+ * See https://github.com/carrotsearch/hppc .
+ */
+internal class LongLongScatterMap {
+  /**
+   * The array holding keys.
+   */
+  private var keys: LongArray = longArrayOf()
+
+  /**
+   * The array holding values.
+   */
+  private var values: LongArray = longArrayOf()
+
+  /**
+   * The number of stored keys (assigned key slots), excluding the special
+   * "empty" key, if any (use [.size] instead).
+   *
+   * @see .size
+   */
+  private var assigned: Int = 0
+
+  /**
+   * Mask for slot scans in [.keys].
+   */
+  private var mask: Int = 0
+
+  /**
+   * Expand (rehash) [.keys] when [.assigned] hits this value.
+   */
+  private var resizeAt: Int = 0
+
+  /**
+   * Special treatment for the "empty slot" key marker.
+   */
+  private var hasEmptyKey: Boolean = false
+
+  /**
+   * The load factor for [.keys].
+   */
+  private var loadFactor: Double = 0.75
+
+  val isEmpty: Boolean
+    get() = size == 0
+
+  init {
+    ensureCapacity(4)
+  }
+
+  operator fun set(
+    key: Long,
+    value: Long
+  ): Long {
+    val mask = this.mask
+    if (key == 0L) {
+      hasEmptyKey = true
+      val previousValue = values[mask + 1]
+      values[mask + 1] = value
+      return previousValue
+    } else {
+      val keys = this.keys
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          val previousValue = values[slot]
+          values[slot] = value
+          return previousValue
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      if (assigned == resizeAt) {
+        allocateThenInsertThenRehash(slot, key, value)
+      } else {
+        keys[slot] = key
+        values[slot] = value
+      }
+
+      assigned++
+      return 0L
+    }
+  }
+
+  fun remove(key: Long): Long {
+    val mask = this.mask
+    if (key == 0L) {
+      hasEmptyKey = false
+      val previousValue = values[mask + 1]
+      values[mask + 1] = 0L
+      return previousValue
+    } else {
+      val keys = this.keys
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          val previousValue = values[slot]
+          shiftConflictingKeys(slot)
+          return previousValue
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      return 0L
+    }
+  }
+
+  operator fun get(key: Long): Long? {
+    if (key == 0L) {
+      return if (hasEmptyKey) values[mask + 1] else null
+    } else {
+      val keys = this.keys
+      val mask = this.mask
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          return values[slot]
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      return null
+    }
+  }
+
+  fun forEach(block: (Long, Long) -> Unit) {
+    val max = mask + 1
+    var slot = -1
+
+    exitWhile@while (true) {
+      if (slot < max) {
+        var existing: Long
+        slot++
+        while (slot < max) {
+          existing = keys[slot]
+          if (existing != 0L) {
+            block(existing, values[slot])
+            continue@exitWhile
+          }
+          slot++
+        }
+      }
+
+      if (slot == max && hasEmptyKey) {
+        slot++
+        block(0L, values[max])
+        continue@exitWhile
+      }
+      break@exitWhile
+    }
+  }
+
+  fun containsKey(key: Long): Boolean {
+    if (key == 0L) {
+      return hasEmptyKey
+    } else {
+      val keys = this.keys
+      val mask = this.mask
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          return true
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      return false
+    }
+  }
+
+  fun release() {
+    assigned = 0
+    hasEmptyKey = false
+
+    allocateBuffers(HHPC.minBufferSize(4, loadFactor))
+  }
+
+  val size: Int
+    get() {
+      return assigned + if (hasEmptyKey) 1 else 0
+    }
+
+  fun ensureCapacity(expectedElements: Int) {
+    if (expectedElements > resizeAt) {
+      val prevKeys = this.keys
+      val prevValues = this.values
+      allocateBuffers(HHPC.minBufferSize(expectedElements, loadFactor))
+      if (!isEmpty) {
+        rehash(prevKeys, prevValues)
+      }
+    }
+  }
+
+  private fun hashKey(key: Long): Int {
+    return HHPC.mixPhi(key)
+  }
+
+  /**
+   * Rehash from old buffers to new buffers.
+   */
+  private fun rehash(
+    fromKeys: LongArray,
+    fromValues: LongArray
+  ) {
+    // Rehash all stored key/value pairs into the new buffers.
+    val keys = this.keys
+    val values = this.values
+    val mask = this.mask
+    var existing: Long
+
+    // Copy the zero element's slot, then rehash everything else.
+    var from = fromKeys.size - 1
+    keys[keys.size - 1] = fromKeys[from]
+    values[values.size - 1] = fromValues[from]
+    while (--from >= 0) {
+      existing = fromKeys[from]
+      if (existing != 0L) {
+        var slot = hashKey(existing) and mask
+        while (keys[slot] != 0L) {
+          slot = slot + 1 and mask
+        }
+        keys[slot] = existing
+        values[slot] = fromValues[from]
+      }
+    }
+  }
+
+  /**
+   * Allocate new internal buffers. This method attempts to allocate
+   * and assign internal buffers atomically (either allocations succeed or not).
+   */
+  private fun allocateBuffers(arraySize: Int) {
+
+    // Ensure no change is done if we hit an OOM.
+    val prevKeys = this.keys
+    val prevValues = this.values
+    try {
+      val emptyElementSlot = 1
+      this.keys = LongArray(arraySize + emptyElementSlot)
+      this.values = LongArray(arraySize + emptyElementSlot)
+    } catch (e: OutOfMemoryError) {
+      this.keys = prevKeys
+      this.values = prevValues
+      throw RuntimeException(
+          String.format(
+              Locale.ROOT,
+              "Not enough memory to allocate buffers for rehashing: %,d -> %,d",
+              this.mask + 1,
+              arraySize
+          ), e
+      )
+    }
+
+    this.resizeAt = HHPC.expandAtCount(arraySize, loadFactor)
+    this.mask = arraySize - 1
+  }
+
+  /**
+   * This method is invoked when there is a new key/ value pair to be inserted into
+   * the buffers but there is not enough empty slots to do so.
+   *
+   * New buffers are allocated. If this succeeds, we know we can proceed
+   * with rehashing so we assign the pending element to the previous buffer
+   * (possibly violating the invariant of having at least one empty slot)
+   * and rehash all keys, substituting new buffers at the end.
+   */
+  private fun allocateThenInsertThenRehash(
+    slot: Int,
+    pendingKey: Long,
+    pendingValue: Long
+  ) {
+
+    // Try to allocate new buffers first. If we OOM, we leave in a consistent state.
+    val prevKeys = this.keys
+    val prevValues = this.values
+    allocateBuffers(HHPC.nextBufferSize(mask + 1, size, loadFactor))
+
+    // We have succeeded at allocating new data so insert the pending key/value at
+    // the free slot in the old arrays before rehashing.
+    prevKeys[slot] = pendingKey
+    prevValues[slot] = pendingValue
+
+    // Rehash old keys, including the pending key.
+    rehash(prevKeys, prevValues)
+  }
+
+  /**
+   * Shift all the slot-conflicting keys and values allocated to
+   * (and including) `slot`.
+   */
+  private fun shiftConflictingKeys(gapSlot: Int) {
+    var gapSlot = gapSlot
+    val keys = this.keys
+    val values = this.values
+    val mask = this.mask
+
+    // Perform shifts of conflicting keys to fill in the gap.
+    var distance = 0
+    while (true) {
+      val slot = gapSlot + ++distance and mask
+      val existing = keys[slot]
+      if (existing == 0L) {
+        break
+      }
+
+      val idealSlot = hashKey(existing)
+      val shift = slot - idealSlot and mask
+      if (shift >= distance) {
+        // Entry at this position was originally at or before the gap slot.
+        // Move the conflict-shifted entry to the gap's position and repeat the procedure
+        // for any entries to the right of the current position, treating it
+        // as the new gap.
+        keys[gapSlot] = existing
+        values[gapSlot] = values[slot]
+        gapSlot = slot
+        distance = 0
+      }
+    }
+
+    // Mark the last found gap slot without a conflict as empty.
+    keys[gapSlot] = 0L
+    values[gapSlot] = 0L
+    assigned--
+  }
+}
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongScatterSet.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongScatterSet.kt
new file mode 100644
index 00000000..7a4034f2
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongScatterSet.kt
@@ -0,0 +1,179 @@
+package leakcanary.internal.hppc
+
+import java.util.Locale
+
+/**
+ * Code from com.carrotsearch.hppc.LongScatterSet copy pasted, inlined and converted to Kotlin.
+ *
+ * See https://github.com/carrotsearch/hppc .
+ */
+internal class LongScatterSet {
+  /** The hash array holding keys.  */
+  private var keys: LongArray = longArrayOf()
+  /**
+   * The number of stored keys (assigned key slots), excluding the special
+   * "empty" key, if any.
+   *
+   * @see .size
+   * @see .hasEmptyKey
+   */
+  private var assigned = 0
+  /**
+   * Mask for slot scans in [.keys].
+   */
+  private var mask = 0
+
+  /**
+   * Expand (rehash) [.keys] when [.assigned] hits this value.
+   */
+  private var resizeAt = 0
+  /**
+   * Special treatment for the "empty slot" key marker.
+   */
+  private var hasEmptyKey = false
+  /**
+   * The load factor for [.keys].
+   */
+  private val loadFactor = 0.75
+
+  init {
+    ensureCapacity(4)
+  }
+
+  private fun hashKey(key: Long): Int {
+    return HHPC.mixPhi(key)
+  }
+
+  operator fun plusAssign(key: Long) {
+    add(key)
+  }
+
+  fun add(key: Long): Boolean {
+    if (key == 0L) {
+      val added = !hasEmptyKey
+      hasEmptyKey = true
+      return added
+    } else {
+      val keys = this.keys
+      val mask = this.mask
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          return false
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      if (assigned == resizeAt) {
+        allocateThenInsertThenRehash(slot, key)
+      } else {
+        keys[slot] = key
+      }
+
+      assigned++
+      return true
+    }
+  }
+
+  operator fun contains(key: Long): Boolean {
+    if (key == 0L) {
+      return hasEmptyKey
+    } else {
+      val keys = this.keys
+      val mask = this.mask
+      var slot = hashKey(key) and mask
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          return true
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+      return false
+    }
+  }
+
+  fun release() {
+    assigned = 0
+    hasEmptyKey = false
+    allocateBuffers(HHPC.minBufferSize(4, loadFactor))
+  }
+
+  fun ensureCapacity(expectedElements: Int) {
+    if (expectedElements > resizeAt) {
+      val prevKeys = this.keys
+      allocateBuffers(HHPC.minBufferSize(expectedElements, loadFactor))
+      if (size() != 0) {
+        rehash(prevKeys)
+      }
+    }
+  }
+
+  fun size(): Int {
+    return assigned + if (hasEmptyKey) 1 else 0
+  }
+
+  private fun rehash(fromKeys: LongArray) {
+    // Rehash all stored keys into the new buffers.
+    val keys = this.keys
+    val mask = this.mask
+    var existing: Long
+    var i = fromKeys.size - 1
+    while (--i >= 0) {
+      existing = fromKeys[i]
+      if (existing != 0L) {
+        var slot = hashKey(existing) and mask
+        while (keys[slot] != 0L) {
+          slot = slot + 1 and mask
+        }
+        keys[slot] = existing
+      }
+    }
+  }
+
+  /**
+   * Allocate new internal buffers. This method attempts to allocate
+   * and assign internal buffers atomically (either allocations succeed or not).
+   */
+  private fun allocateBuffers(arraySize: Int) {
+    // Ensure no change is done if we hit an OOM.
+    val prevKeys = this.keys
+    try {
+      val emptyElementSlot = 1
+      this.keys = LongArray(arraySize + emptyElementSlot)
+    } catch (e: OutOfMemoryError) {
+      this.keys = prevKeys
+      throw RuntimeException(
+          String.format(
+              Locale.ROOT,
+              "Not enough memory to allocate buffers for rehashing: %,d -> %,d",
+              size(),
+              arraySize
+          ), e
+      )
+    }
+
+    this.resizeAt = HHPC.expandAtCount(arraySize, loadFactor)
+    this.mask = arraySize - 1
+  }
+
+  private fun allocateThenInsertThenRehash(
+    slot: Int,
+    pendingKey: Long
+  ) {
+    // Try to allocate new buffers first. If we OOM, we leave in a consistent state.
+    val prevKeys = this.keys
+    allocateBuffers(HHPC.nextBufferSize(mask + 1, size(), loadFactor))
+
+    // We have succeeded at allocating new data so insert the pending key/value at
+    // the free slot in the old arrays before rehashing.
+    prevKeys[slot] = pendingKey
+
+    // Rehash old keys, including the pending key.
+    rehash(prevKeys)
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
index cf6059f4..e7a0450a 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
@@ -41,7 +41,7 @@ class HeapAnalyzerTest {
   }
 
   @Test fun pathToCharArray() {
-    hprofFile.writeSinglePathsToCharArrays(listOf("Hello".toCharArray()))
+    hprofFile.writeSinglePathsToCharArrays(listOf("Hello"))
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
     val leak = analysis.retainedInstances[0] as LeakingInstance
     assertThat(leak.instanceClassName).isEqualTo("char[]")
@@ -49,7 +49,7 @@ class HeapAnalyzerTest {
 
   // Two char arrays to ensure we keep going after finding the first one
   @Test fun pathToTwoCharArrays() {
-    hprofFile.writeSinglePathsToCharArrays(listOf("Hello".toCharArray(), "World".toCharArray()))
+    hprofFile.writeSinglePathsToCharArrays(listOf("Hello", "World"))
     val analysis = hprofFile.checkForLeaks<HeapAnalysis>()
     assertThat(analysis).isInstanceOf(HeapAnalysisSuccess::class.java)
   }
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt
index 0cb5250f..17e2a2e4 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt
@@ -4,11 +4,12 @@ import leakcanary.HeapValue.BooleanValue
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.HprofWriter
 import java.io.File
+import kotlin.jvm.internal.Ref.ObjectRef
 
 fun File.writeWeakReferenceCleared() {
   HprofWriter.open(this)
       .helper {
-        keyedWeakReference("Leaking", 0)
+        keyedWeakReference("Leaking", ObjectReference(0))
       }
 }
 
@@ -22,13 +23,11 @@ fun File.writeNoPathToInstance() {
 fun File.writeSinglePathToInstance() {
   HprofWriter.open(this)
       .helper {
-        val leaking = instance(
-            clazz("Leaking")
-        )
+        val leaking = instance(clazz("Leaking"))
         keyedWeakReference("Leaking", leaking)
         clazz(
             "GcRoot", staticFields = listOf(
-            "shortestPath" to ObjectReference(leaking)
+            "shortestPath" to leaking
         )
         )
       }
@@ -41,20 +40,20 @@ fun File.writeSinglePathToString(value: String = "Hi") {
         keyedWeakReference("java.lang.String", leaking)
         clazz(
             "GcRoot", staticFields = listOf(
-            "shortestPath" to ObjectReference(leaking)
+            "shortestPath" to leaking
         )
         )
       }
 }
 
-fun File.writeSinglePathsToCharArrays(values: List<CharArray>) {
+fun File.writeSinglePathsToCharArrays(values: List<String>) {
   HprofWriter.open(this)
       .helper {
         val arrays = mutableListOf<Long>()
         values.forEach {
-          val leaking = array(it)
+          val leaking = it.charArrayDump
           keyedWeakReference("char[]", leaking)
-          arrays.add(leaking)
+          arrays.add(leaking.value)
         }
         clazz(
             className = "GcRoot",
@@ -68,30 +67,6 @@ fun File.writeSinglePathsToCharArrays(values: List<CharArray>) {
       }
 }
 
-fun File.writeCustomPathToInstance(path: List<Pair<String, String>>) {
-  HprofWriter.open(this)
-      .helper {
-        val leaking = instance(
-            clazz("Leaking")
-        )
-        keyedWeakReference("Leaking", leaking)
-        var previousInstance = leaking
-        for (index in path.lastIndex downTo 1) {
-          val (className, fieldName) = path[index]
-          previousInstance = instance(
-              clazz(className, fields = listOf(fieldName to ObjectReference::class)),
-              fields = listOf(ObjectReference(previousInstance))
-          )
-        }
-        val root = path.first()
-        clazz(
-            root.first, staticFields = listOf(
-            root.second to ObjectReference(previousInstance)
-        )
-        )
-      }
-}
-
 fun File.writeTwoPathsToInstance() {
   HprofWriter.open(this)
       .helper {
@@ -99,12 +74,12 @@ fun File.writeTwoPathsToInstance() {
         keyedWeakReference("Leaking", leaking)
         val hasLeaking = instance(
             clazz("HasLeaking", fields = listOf("leaking" to ObjectReference::class)),
-            fields = listOf(ObjectReference(leaking))
+            fields = listOf(leaking)
         )
         clazz(
             "GcRoot", staticFields = listOf(
-            "shortestPath" to ObjectReference(leaking),
-            "longestPath" to ObjectReference(hasLeaking)
+            "shortestPath" to leaking,
+            "longestPath" to hasLeaking
         )
         )
       }
@@ -123,7 +98,7 @@ fun File.writeMultipleActivityLeaks(leakCount: Int) {
         )
         val activityArrayClassId = arrayClass("com.example.ExampleActivity")
 
-        val destroyedActivities = mutableListOf<Long>()
+        val destroyedActivities = mutableListOf<ObjectReference>()
         for (i in 1..leakCount) {
           destroyedActivities.add(instance(exampleActivityClassId, listOf(BooleanValue(true))))
         }
@@ -131,9 +106,10 @@ fun File.writeMultipleActivityLeaks(leakCount: Int) {
         clazz(
             className = "com.example.ActivityHolder",
             staticFields = listOf(
-                "activities" to ObjectReference(
-                    objectArray(activityArrayClassId, destroyedActivities.toLongArray())
-                )
+                "activities" to
+                    objectArrayOf(
+                        activityArrayClassId, *destroyedActivities.toTypedArray()
+                    )
             )
         )
         destroyedActivities.forEach { instanceId ->
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
index a7428c75..a5097712 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
@@ -25,6 +25,7 @@ import leakcanary.Record.LoadClassRecord
 import leakcanary.Record.StringRecord
 import okio.Buffer
 import java.io.Closeable
+import java.io.File
 import java.util.UUID
 import kotlin.reflect.KClass
 
@@ -36,8 +37,23 @@ class HprofWriterHelper constructor(
   private val id: Long
     get() = ++lastId
 
+  private val typeSizes = mapOf(
+      // object
+      HprofReader.OBJECT_TYPE to writer.idSize,
+      HprofReader.BOOLEAN_TYPE to HprofReader.BOOLEAN_SIZE,
+      HprofReader.CHAR_TYPE to HprofReader.CHAR_SIZE,
+      HprofReader.FLOAT_TYPE to HprofReader.FLOAT_SIZE,
+      HprofReader.DOUBLE_TYPE to HprofReader.DOUBLE_SIZE,
+      HprofReader.BYTE_TYPE to HprofReader.BYTE_SIZE,
+      HprofReader.SHORT_TYPE to HprofReader.SHORT_SIZE,
+      HprofReader.INT_TYPE to HprofReader.INT_SIZE,
+      HprofReader.LONG_TYPE to HprofReader.LONG_SIZE
+  )
+
   private val weakRefKeys = mutableSetOf<Long>()
 
+  private val classDumps = mutableMapOf<Long, ClassDumpRecord>()
+
   private val objectClassId = clazz(superClassId = 0, className = "java.lang.Object")
   private val stringClassId = clazz(
       className = "java.lang.String", fields = listOf(
@@ -84,6 +100,19 @@ class HprofWriterHelper constructor(
       writer.write(fieldName)
       FieldRecord(fieldName.id, typeOf(it.second))
     }
+
+    var instanceSize = fieldRecords.sumBy {
+      typeSizes.getValue(it.type)
+    }
+
+    var nextUpId = if (superClassId == -1L) objectClassId else superClassId
+    while (nextUpId != 0L) {
+      val nextUp = classDumps[nextUpId]!!
+      instanceSize += nextUp.fields.sumBy {
+        typeSizes.getValue(it.type)
+      }
+      nextUpId = nextUp.superClassId
+    }
     val classDump = ClassDumpRecord(
         id = loadClass.id,
         stackTraceSerialNumber = 1,
@@ -91,10 +120,11 @@ class HprofWriterHelper constructor(
         classLoaderId = 0,
         signersId = 0,
         protectionDomainId = 0,
-        instanceSize = 0,
+        instanceSize = instanceSize,
         staticFields = staticFieldRecords,
         fields = fieldRecords
     )
+    classDumps[loadClass.id] = classDump
     writer.write(classDump)
     val gcRootRecord = GcRootRecord(gcRoot = StickyClass(classDump.id))
     writer.write(gcRootRecord)
@@ -107,28 +137,27 @@ class HprofWriterHelper constructor(
 
   fun string(
     string: String
-  ): Long {
+  ): ObjectReference {
     return instance(
         stringClassId,
-        fields = listOf(ObjectReference(array(string.toCharArray())), IntValue(string.length))
+        fields = listOf(string.charArrayDump, IntValue(string.length))
     )
   }
 
   fun keyedWeakReference(
     className: String,
-    referentInstanceId: Long
-  ): Long {
+    referentInstanceId: ObjectReference
+  ): ObjectReference {
     val referenceKey = string(UUID.randomUUID().toString())
-    weakRefKeys.add(referenceKey)
+    weakRefKeys.add(referenceKey.value)
     return instance(
         classId = keyedWeakReferenceClassId,
         fields = listOf(
-            ObjectReference(referenceKey),
-            ObjectReference(string("")),
-            ObjectReference(string(className)),
+            referenceKey,
+            string(""),
+            string(className),
             LongValue(System.currentTimeMillis()),
-            ObjectReference(referentInstanceId)
-
+            ObjectReference(referentInstanceId.value)
         )
     )
   }
@@ -136,7 +165,7 @@ class HprofWriterHelper constructor(
   fun instance(
     classId: Long,
     fields: List<HeapValue> = emptyList()
-  ): Long {
+  ): ObjectReference {
     val fieldsBuffer = Buffer()
     fields.forEach { value ->
       with(writer) {
@@ -150,13 +179,65 @@ class HprofWriterHelper constructor(
         fieldValues = fieldsBuffer.readByteArray()
     )
     writer.write(instanceDump)
-    return instanceDump.id
+    return ObjectReference(instanceDump.id)
   }
 
-  fun array(array: CharArray): Long {
-    val arrayDump = CharArrayDump(id, 1, array)
-    writer.write(arrayDump)
-    return arrayDump.id
+  inner class InstanceAndClassDefinition {
+    val field = LinkedHashMap<String, HeapValue>()
+    val staticField = LinkedHashMap<String, HeapValue>()
+  }
+
+  inner class ClassDefinition {
+    val staticField = LinkedHashMap<String, HeapValue>()
+  }
+
+  infix fun String.watchedInstance(block: InstanceAndClassDefinition.() -> Unit): ObjectReference {
+    val instance = this.instance(block)
+    keyedWeakReference("DummyClassName", instance)
+    return instance
+  }
+
+  infix fun String.instance(block: InstanceAndClassDefinition.() -> Unit): ObjectReference {
+    val definition = InstanceAndClassDefinition()
+    block(definition)
+
+    val classFields = definition.field.map {
+      it.key to it.value::class
+    }
+
+    val staticFields = definition.staticField.map { it.key to it.value }
+
+    val instanceFields = definition.field.map { it.value }
+
+    return instance(clazz(this, fields = classFields, staticFields = staticFields), instanceFields)
+  }
+
+  infix fun String.clazz(block: ClassDefinition.() -> Unit): Long {
+    val definition = ClassDefinition()
+    block(definition)
+
+    val staticFields = definition.staticField.map { it.key to it.value }
+    return clazz(this, staticFields = staticFields)
+  }
+
+  val String.charArrayDump: ObjectReference
+    get() {
+      val arrayDump = CharArrayDump(id, 1, toCharArray())
+      writer.write(arrayDump)
+      return ObjectReference(arrayDump.id)
+    }
+
+  fun objectArray(
+    vararg elements: ObjectReference
+  ): ObjectReference {
+    return objectArrayOf(objectClassId, *elements)
+  }
+
+  fun objectArrayOf(
+    classId: Long,
+    vararg elements: ObjectReference
+  ): ObjectReference {
+    return ObjectReference(objectArray(classId, elements.map { it.value }.toLongArray()))
   }
 
   fun objectArray(
@@ -212,6 +293,10 @@ class HprofWriterHelper constructor(
   }
 }
 
+fun File.dump(block: HprofWriterHelper.() -> Unit) {
+  HprofWriterHelper(HprofWriter.open(this)).use(block)
+}
+
 fun HprofWriter.helper(block: HprofWriterHelper.() -> Unit) {
   HprofWriterHelper(this).use(block)
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
index 85cb882d..b71c985b 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
@@ -48,7 +48,13 @@ class LeakStatusTest {
   }
 
   @Test fun defaultsToUnknown() {
-    hprofFile.writeCustomPathToInstance(listOf("GcRoot" to "staticField1", "Class1" to "field1"))
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
@@ -58,7 +64,13 @@ class LeakStatusTest {
   }
 
   @Test fun inspectorNotLeaking() {
-    hprofFile.writeCustomPathToInstance(listOf("GcRoot" to "staticField1", "Class1" to "field1"))
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
         leakInspectors = listOf(notLeaking("Class1"))
@@ -69,7 +81,13 @@ class LeakStatusTest {
   }
 
   @Test fun inspectorLeaking() {
-    hprofFile.writeCustomPathToInstance(listOf("GcRoot" to "staticField1", "Class1" to "field1"))
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
@@ -81,7 +99,13 @@ class LeakStatusTest {
   }
 
   @Test fun leakingWinsUnknown() {
-    hprofFile.writeCustomPathToInstance(listOf("GcRoot" to "staticField1", "Class1" to "field1"))
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
@@ -93,14 +117,17 @@ class LeakStatusTest {
   }
 
   @Test fun notLeakingWhenNextIsNotLeaking() {
-    hprofFile.writeCustomPathToInstance(
-        listOf(
-            "GcRoot" to "staticField1",
-            "Class1" to "field1",
-            "Class2" to "field2",
-            "Class3" to "field3"
-        )
-    )
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
@@ -112,14 +139,17 @@ class LeakStatusTest {
   }
 
   @Test fun leakingWhenPreviousIsLeaking() {
-    hprofFile.writeCustomPathToInstance(
-        listOf(
-            "GcRoot" to "staticField1",
-            "Class1" to "field1",
-            "Class2" to "field2",
-            "Class3" to "field3"
-        )
-    )
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
@@ -131,14 +161,17 @@ class LeakStatusTest {
   }
 
   @Test fun notLeakingWinsConflicts() {
-    hprofFile.writeCustomPathToInstance(
-        listOf(
-            "GcRoot" to "staticField1",
-            "Class1" to "field1",
-            "Class2" to "field2",
-            "Class3" to "field3"
-        )
-    )
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
@@ -165,14 +198,17 @@ class LeakStatusTest {
   }
 
   @Test fun middleUnknown() {
-    hprofFile.writeCustomPathToInstance(
-        listOf(
-            "GcRoot" to "staticField1",
-            "Class1" to "field1",
-            "Class2" to "field2",
-            "Class3" to "field3"
-        )
-    )
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
@@ -246,12 +282,13 @@ class LeakStatusTest {
   }
 
   @Test fun conflictNotLeakingWins() {
-    hprofFile.writeCustomPathToInstance(
-        listOf(
-            "GcRoot" to "staticField1",
-            "Class1" to "field1"
-        )
-    )
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
@@ -268,12 +305,13 @@ class LeakStatusTest {
   }
 
   @Test fun twoInspectorsAgreeNotLeaking() {
-    hprofFile.writeCustomPathToInstance(
-        listOf(
-            "GcRoot" to "staticField1",
-            "Class1" to "field1"
-        )
-    )
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
@@ -290,12 +328,13 @@ class LeakStatusTest {
   }
 
   @Test fun twoInspectorsAgreeLeaking() {
-    hprofFile.writeCustomPathToInstance(
-        listOf(
-            "GcRoot" to "staticField1",
-            "Class1" to "field1"
-        )
-    )
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
@@ -310,14 +349,17 @@ class LeakStatusTest {
   }
 
   @Test fun leakCausesAreLastNotLeakingAndUnknown() {
-    hprofFile.writeCustomPathToInstance(
-        listOf(
-            "GcRoot" to "staticField1",
-            "Class1" to "field1",
-            "Class2" to "field2",
-            "Class3" to "field3"
-        )
-    )
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
@@ -334,69 +376,88 @@ class LeakStatusTest {
   }
 
   @Test fun sameLeakTraceSameGroup() {
-    assertThat(
-        computeGroupHash(
-            path = listOf(
-                "GcRoot" to "staticField1",
-                "Class1" to "field1",
-                "Class2" to "field2",
-                "Class3" to "field3"
-            ), notLeaking = "Class1", leaking = "Class3"
-        )
-    ).isEqualTo(
-        computeGroupHash(
-            path = listOf(
-                "GcRoot" to "staticField1",
-                "Class1" to "field1",
-                "Class2" to "field2",
-                "Class3" to "field3"
-            ), notLeaking = "Class1", leaking = "Class3"
-        )
-    )
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+    val hash1 = computeGroupHash(notLeaking = "Class1", leaking = "Class3")
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+    val hash2 = computeGroupHash(notLeaking = "Class1", leaking = "Class3")
+    assertThat(hash1).isEqualTo(hash2)
   }
 
   @Test fun differentLeakTraceDifferentGroup() {
-    assertThat(
-        computeGroupHash(
-            path = listOf(
-                "GcRoot" to "staticField1",
-                "Class1" to "field1a",
-                "Class2" to "field2",
-                "Class3" to "field3"
-            ), notLeaking = "Class1", leaking = "Class3"
-        )
-    ).isNotEqualTo(
-        computeGroupHash(
-            path = listOf(
-                "GcRoot" to "staticField1",
-                "Class1" to "field1b",
-                "Class2" to "field2",
-                "Class3" to "field3"
-            ), notLeaking = "Class1", leaking = "Class3"
-        )
-    )
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1a"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+    val hash1 = computeGroupHash(notLeaking = "Class1", leaking = "Class3")
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1b"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+    val hash2 = computeGroupHash(notLeaking = "Class1", leaking = "Class3")
+    assertThat(hash1).isNotEqualTo(hash2)
   }
 
   @Test fun sameCausesSameGroup() {
-    assertThat(
-        computeGroupHash(
-            path = listOf(
-                "GcRoot" to "staticField1",
-                "Class1" to "field1",
-                "Class2" to "field2",
-                "Class3" to "field3a"
-            ), notLeaking = "Class1", leaking = "Class3"
-        )
-    ).isEqualTo(
-        computeGroupHash(
-            path = listOf(
-                "GcRoot" to "staticField1",
-                "Class1" to "field1",
-                "Class2" to "field2",
-                "Class3" to "field3b"
-            ), notLeaking = "Class1", leaking = "Class3"
-        )
-    )
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3a"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+    val hash1 = computeGroupHash(notLeaking = "Class1", leaking = "Class3")
+
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3b"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+    val hash2 = computeGroupHash(notLeaking = "Class1", leaking = "Class3")
+    assertThat(hash1).isEqualTo(hash2)
   }
 
   private fun unknownInstance(): LeakInspector {
@@ -440,12 +501,9 @@ class LeakStatusTest {
   }
 
   private fun computeGroupHash(
-    path: List<Pair<String, String>>,
     notLeaking: String,
     leaking: String
   ): String {
-    hprofFile.writeCustomPathToInstance(path)
-
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
           leakInspectors = listOf(notLeaking(notLeaking), leaking(leaking))
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt
new file mode 100644
index 00000000..7dd0a719
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt
@@ -0,0 +1,319 @@
+package leakcanary.internal
+
+import leakcanary.HeapAnalysis
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.HeapValue
+import leakcanary.HeapValue.IntValue
+import leakcanary.HeapValue.LongValue
+import leakcanary.HeapValue.ShortValue
+import leakcanary.LeakingInstance
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+
+class RetainedSizeTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun emptyLeakingInstance() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {}
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    assertThat(retainedSize).isEqualTo(0)
+  }
+
+  @Test fun leakingInstanceWithPrimitiveType() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = LongValue(42)
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 8 bytes for long
+    assertThat(retainedSize).isEqualTo(8)
+  }
+
+  @Test fun leakingInstanceWithPrimitiveArray() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = "42".charArrayDump
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference, 2 bytes per char
+    assertThat(retainedSize).isEqualTo(8)
+  }
+
+  @Test fun leakingInstanceWithString() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = string("42")
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference, string (4 array ref + 4 int + 2 byte per char)
+    assertThat(retainedSize).isEqualTo(16)
+  }
+
+  @Test fun leakingInstanceWithInstance() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = "FortyTwo" instance {
+            field["number"] = IntValue(42)
+          }
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference + 4 byte int
+    assertThat(retainedSize).isEqualTo(8)
+  }
+
+  @Test fun leakingInstanceWithPrimitiveWrapper() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = "java.lang.Integer" instance {
+            field["value"] = IntValue(42)
+          }
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference, int field
+    assertThat(retainedSize).isEqualTo(8)
+  }
+
+  @Test fun leakingInstanceWithPrimitiveWrapperArray() {
+    hprofFile.dump {
+      val intWrapperClass = clazz("java.lang.Integer", fields = listOf("value" to IntValue::class))
+
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = objectArrayOf(
+              intWrapperClass,
+              instance(
+                  intWrapperClass,
+                  fields = listOf<HeapValue>(IntValue(4))
+              ),
+              instance(
+                  intWrapperClass,
+                  fields = listOf<HeapValue>(IntValue(2))
+              )
+          )
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference * 3, 2 ints
+    assertThat(retainedSize).isEqualTo(20)
+  }
+
+  @Test fun leakingInstanceWithObjectArray() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = objectArray("Forty" instance {}, "Two" instance {})
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference, 4 bytes per object entry
+    assertThat(retainedSize).isEqualTo(12)
+  }
+
+  @Test fun leakingInstanceWithDeepRetainedObjects() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = "Forty" instance {
+            field["forty"] = "Two" instance {
+              field["two"] = string("42")
+            }
+          }
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference * 3, string (4 array ref + 4 int + 2 byte per char)
+    assertThat(retainedSize).isEqualTo(24)
+  }
+
+  @Test fun leakingInstanceNotDominating() {
+    hprofFile.dump {
+      val fortyTwo = string("42")
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = fortyTwo
+        }
+        staticField["rootDominator"] = fortyTwo
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference
+    assertThat(retainedSize).isEqualTo(4)
+  }
+
+  @Test fun leakingInstanceWithSuperClass() {
+    hprofFile.dump {
+      val parentClass = clazz("Parent", fields = listOf("value" to LongValue::class))
+      val childClass =
+        clazz("Child", superClassId = parentClass, fields = listOf("value" to IntValue::class))
+
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = instance(childClass, listOf(LongValue(42), IntValue(42)))
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference + Long + Int
+    assertThat(retainedSize).isEqualTo(16)
+  }
+
+  @Test fun leakingInstanceDominatedByOther() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "GrandParentLeaking" watchedInstance {
+          field["answer"] = ShortValue(42)
+          field["child"] = "ParentLeaking" watchedInstance {
+            field["answer"] = IntValue(42)
+            field["child"] = "ChildLeaking" watchedInstance {
+              field["answer"] = LongValue(42)
+            }
+          }
+        }
+      }
+    }
+
+    val retainedInstances = retainedInstances()
+    require(retainedInstances.size == 3)
+
+    retainedInstances.forEach { instance ->
+      when (instance.instanceClassName) {
+        "GrandParentLeaking" -> {
+          // 4 bytes per ref * 2 + short + int + long
+          assertThat(instance.retainedHeapSize).isEqualTo(22)
+        }
+        "ParentLeaking", "ChildLeaking" -> {
+          assertThat(instance.retainedHeapSize).isEqualTo(0)
+        }
+        else -> throw IllegalStateException("Unexpected ${instance.instanceClassName}")
+      }
+    }
+  }
+
+  @Test fun crossDominatedIsNotDominated() {
+    hprofFile.dump {
+      val fortyTwo = string("42")
+      "GcRoot1" clazz {
+        staticField["shortestPath"] = "Leaking1" watchedInstance {
+          field["answer"] = fortyTwo
+        }
+      }
+      "GcRoot2" clazz {
+        staticField["shortestPath"] = "Leaking2" watchedInstance {
+          field["answer"] = fortyTwo
+        }
+      }
+    }
+
+    val retainedInstances = retainedInstances()
+    require(retainedInstances.size == 2)
+
+    retainedInstances.forEach { instance ->
+      // 4 byte reference
+      assertThat(instance.retainedHeapSize).isEqualTo(4)
+    }
+  }
+
+  @Test fun nativeSizeAccountedFor() {
+    val width = 24
+    val height = 16
+    // pixel count * 4 bytes per pixel (ARGB_8888)
+    val nativeBitmapSize = width * height * 4
+
+    hprofFile.dump {
+      val bitmap = "android.graphics.Bitmap" instance {
+        field["mWidth"] = IntValue(width)
+        field["mHeight"] = IntValue(height)
+      }
+
+      "sun.misc.Cleaner" instance {
+        field["referent"] = bitmap
+        field["thunk"] = "libcore.util.NativeAllocationRegistry\$CleanerThunk" instance {
+          field["this\$0"] = "libcore.util.NativeAllocationRegistry" instance {
+            field["size"] = LongValue(nativeBitmapSize.toLong())
+          }
+        }
+      }
+
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["bitmap"] = bitmap
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference + 2 * Int + native size
+    assertThat(retainedSize).isEqualTo(12 + nativeBitmapSize)
+  }
+
+  private fun retainedInstances(): List<LeakingInstance> {
+    val analysis = hprofFile.checkForLeaks<HeapAnalysis>(computeRetainedHeapSize = true)
+    println(analysis.toString())
+    analysis as HeapAnalysisSuccess
+    return analysis.retainedInstances.map { it as LeakingInstance }
+  }
+
+  private fun firstRetainedSize(): Int {
+    return retainedInstances()
+        .map { it.retainedHeapSize!! }
+        .first()
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
index ffe7b7d9..a1a2c24c 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
@@ -1,6 +1,7 @@
 package leakcanary.internal
 
 import leakcanary.AnalyzerProgressListener
+import leakcanary.CanaryLog
 import leakcanary.Exclusion
 import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
 import leakcanary.Exclusion.ExclusionType.ThreadExclusion
@@ -9,6 +10,7 @@ import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.ExclusionsFactory
 import leakcanary.LeakInspector
 import leakcanary.HeapAnalysis
+import leakcanary.HeapAnalysisFailure
 import leakcanary.HeapAnalyzer
 import leakcanary.HprofParser
 import leakcanary.KeyedWeakReference
@@ -22,11 +24,12 @@ import java.lang.ref.WeakReference
 fun <T : HeapAnalysis> File.checkForLeaks(
   labelers: List<Labeler> = emptyList(),
   leakInspectors: List<LeakInspector> = emptyList(),
+  computeRetainedHeapSize: Boolean = false,
   exclusionsFactory: ExclusionsFactory = defaultExclusionsFactory
 ): T {
   val heapAnalyzer = HeapAnalyzer(AnalyzerProgressListener.NONE)
   return heapAnalyzer.checkForLeaks(
-      this, exclusionsFactory, false, leakInspectors, labelers
+      this, exclusionsFactory, computeRetainedHeapSize, leakInspectors, labelers
   ) as T
 }
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
index 7d36776f..7e77630b 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -33,7 +33,10 @@ object LeakCanary {
         AndroidExcludedRefs.appDefaults
     ),
     /**
-     * Note: this is currently not implemented in the new heap parser.
+     * Whether to compute the total number of bytes in memory that would be reclaimed if the
+     * detected leaks didn't happen. This includes native memory associated to Java objects
+     * (e.g. bitmaps).
+     * Computing the retained heap size can slow down the leak analysis and is off by default.
      */
     val computeRetainedHeapSize: Boolean = false,
     val leakInspectors: List<LeakInspector> = AndroidLeakInspectors.defaultAndroidInspectors(),
@@ -50,7 +53,7 @@ object LeakCanary {
   )
 
   @Volatile
-  var config: Config = Config()
+  var config: Config = if (LeakSentry.isInstalled) Config() else InternalLeakCanary.noInstallConfig
 
   /** [Intent] that can be used to programmatically launch the leak display activity. */
   val leakDisplayActivityIntent
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
index 85e4f5aa..7b96e942 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -14,6 +14,7 @@ import com.squareup.leakcanary.core.R
 import leakcanary.CanaryLog
 import leakcanary.GcTrigger
 import leakcanary.LeakCanary
+import leakcanary.LeakCanary.Config
 import leakcanary.LeakSentry
 import leakcanary.internal.activity.LeakActivity
 
@@ -35,6 +36,12 @@ internal object InternalLeakCanary : LeakSentryListener {
   val leakDisplayActivityIntent: Intent
     get() = LeakActivity.createIntent(application)
 
+  val noInstallConfig: Config
+    get() = Config(
+        dumpHeap = false, exclusionsFactory = { emptyList() }, leakInspectors = emptyList(),
+        labelers = emptyList()
+    )
+
   override fun onLeakSentryInstalled(application: Application) {
     this.application = application
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
index 710ccedf..cc63c5ad 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
@@ -26,6 +26,6 @@ internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
 
   companion object {
     // Last updated for 2.0-alpha-2
-    private const val VERSION = 7
+    private const val VERSION = 9
   }
 }
\ No newline at end of file
diff --git a/leakcanary-android-instrumentation/build.gradle b/leakcanary-android-instrumentation/build.gradle
index d481e596..0226a1ae 100644
--- a/leakcanary-android-instrumentation/build.gradle
+++ b/leakcanary-android-instrumentation/build.gradle
@@ -13,6 +13,7 @@ dependencies {
   androidTestImplementation deps.androidx.test.rules
   androidTestImplementation deps.androidx.test.runner
   androidTestImplementation deps.androidx.fragment
+  androidTestImplementation deps.androidx.benchmark
 }
 
 android {
diff --git a/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
index 6a882d52..db8d12fe 100644
--- a/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
+++ b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
@@ -15,8 +15,14 @@
   ~ limitations under the License.
   -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
     package="com.squareup.leakcanary.instrumentation.test">
-  <application android:name="leakcanary.InstrumentationTestApplication">
+  <!-- Disabled debuggable for accurate performance results -->
+  <application android:name="leakcanary.InstrumentationTestApplication"
+      android:debuggable="false"
+      tools:ignore="HardcodedDebugMode"
+      tools:replace="android:debuggable"
+      >
     <activity android:name="leakcanary.TestActivity"/>
   </application>
 </manifest>
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/AnalysisBenchmarkTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/AnalysisBenchmarkTest.kt
new file mode 100644
index 00000000..10947dc2
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/AnalysisBenchmarkTest.kt
@@ -0,0 +1,61 @@
+package leakcanary
+
+import android.os.Debug
+import android.os.SystemClock
+import androidx.benchmark.BenchmarkRule
+import androidx.benchmark.measureRepeated
+import androidx.test.platform.app.InstrumentationRegistry
+import org.junit.Ignore
+import org.junit.Rule
+import org.junit.Test
+import java.io.File
+import java.util.Date
+import java.util.concurrent.Executor
+
+@Ignore
+class AnalysisBenchmarkTest {
+
+  @get:Rule
+  val benchmarkRule = BenchmarkRule()
+
+  @Test fun benchmarkAnalysis() {
+    leaking = Date()
+
+    val clock = object : Clock {
+      override fun uptimeMillis(): Long {
+        return SystemClock.uptimeMillis()
+      }
+    }
+    val executor = Executor { command -> command.run() }
+    val onReferenceRetained = {}
+    val refWatcher = RefWatcher(clock, executor, onReferenceRetained)
+    refWatcher.watch(leaking)
+
+    val instrumentation = InstrumentationRegistry.getInstrumentation()
+    val context = instrumentation.targetContext
+
+    val heapDumpFile = File(context.filesDir, "HeapAnalyzerComparisonTest.hprof")
+
+    val retainedKeys = refWatcher.retainedKeys
+    HeapDumpMemoryStore.setRetainedKeysForHeapDump(retainedKeys)
+    HeapDumpMemoryStore.heapDumpUptimeMillis = SystemClock.uptimeMillis()
+
+    Debug.dumpHprofData(heapDumpFile.absolutePath)
+
+    val config = LeakCanary.config
+    val heapAnalyzer = HeapAnalyzer(AnalyzerProgressListener.NONE)
+
+
+    benchmarkRule.measureRepeated {
+      val analysis = heapAnalyzer.checkForLeaks(
+          heapDumpFile, config.exclusionsFactory, true, config.leakInspectors, config.labelers
+      ) as HeapAnalysisSuccess
+      require(analysis.retainedInstances.size == 1)
+      require(analysis.retainedInstances[0] is LeakingInstance)
+    }
+  }
+
+  companion object {
+    private lateinit var leaking: Any
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
index 971b6910..d2b126d5 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
@@ -194,6 +194,7 @@ class InstrumentationLeakDetector {
      */
     fun updateConfig() {
       LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
+      LeakSentry.config = LeakSentry.config.copy(enabled = true)
     }
   }
 }
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt b/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
index 77ec2531..9d64edd1 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
@@ -16,7 +16,6 @@ import leakcanary.GcRoot.ThreadObject
 import leakcanary.GcRoot.Unknown
 import leakcanary.GcRoot.Unreachable
 import leakcanary.GcRoot.VmInternal
-import leakcanary.HeapValue.IntValue
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.HprofReader.Companion.BYTE_SIZE
 import leakcanary.HprofReader.Companion.INT_SIZE
@@ -81,6 +80,9 @@ class HprofParser private constructor(
   val position
     get() = reader.position
 
+  val idSize
+    get() = reader.idSize
+
   /**
    * Map of string id to string
    * This currently keeps all the hprof strings that we could care about: class names,
@@ -388,22 +390,19 @@ class HprofParser private constructor(
                   objectIndex[id] =
                     ObjectIdMetadata.CLASS.packOrdinalWithFilePosition(tagPositionAfterReadingId)
                 }
-                if (callback != null || !indexBuilt) {
+
+                val computeObjectClassSize = !indexBuilt && className(id) == "java.lang.Object"
+                if (callback != null || computeObjectClassSize) {
                   val classDumpRecord = readClassDumpRecord(id)
-                  if (!indexBuilt) {
-                    if (className(id) == "java.lang.Object") {
-                      val objectClassFieldSize = classDumpRecord.fields.sumBy {
-                        typeSize(it.type)
-                      }
-                      maybeEmptyInstancesAreEmpty = when (objectClassFieldSize) {
-                        0 -> false
-                        maybeEmptySize -> true
-                        else ->
-                          // We might need to make this more generic in the future.
-                          TODO(
-                              "Unexpected Object class field size $objectClassFieldSize, fields ${classDumpRecord.fields}"
-                          )
-                      }
+                  if (computeObjectClassSize) {
+                    maybeEmptyInstancesAreEmpty = when (classDumpRecord.instanceSize) {
+                      0 -> false
+                      maybeEmptySize -> true
+                      else ->
+                        // We might need to make this more generic in the future.
+                        TODO(
+                            "Unexpected Object class field size ${classDumpRecord.instanceSize}, fields ${classDumpRecord.fields}"
+                        )
                     }
                   }
                   if (callback != null) {
@@ -444,7 +443,7 @@ class HprofParser private constructor(
                     val metadata = when {
                       primitiveWrapperTypes.contains(
                           instanceDumpRecord.classId
-                      ) -> ObjectIdMetadata.PRIMITIVE_WRAPPER
+                      ) -> ObjectIdMetadata.PRIMITIVE_WRAPPER_OR_PRIMITIVE_ARRAY
                       hprofStringCache[classNames[instanceDumpRecord.classId]] == "java.lang.String" -> ObjectIdMetadata.STRING
                       instanceDumpRecord.fieldValues.isEmpty() -> EMPTY_INSTANCE
                       instanceDumpRecord.fieldValues.size <= maybeEmptySize -> INTERNAL_MAYBE_EMPTY_INSTANCE
@@ -471,7 +470,7 @@ class HprofParser private constructor(
                   val arrayRecord = readObjectArrayDumpRecord(id)
                   if (!indexBuilt) {
                     val metadata = if (primitiveWrapperTypes.contains(arrayRecord.arrayClassId)) {
-                      ObjectIdMetadata.PRIMITIVE_ARRAY_OR_WRAPPER_ARRAY
+                      ObjectIdMetadata.PRIMITIVE_WRAPPER_ARRAY
                     } else {
                       ObjectIdMetadata.OBJECT_ARRAY
                     }
@@ -491,7 +490,7 @@ class HprofParser private constructor(
                 val id = readId()
                 if (!indexBuilt) {
                   objectIndex[id] =
-                    ObjectIdMetadata.PRIMITIVE_ARRAY_OR_WRAPPER_ARRAY.packOrdinalWithFilePosition(
+                    ObjectIdMetadata.PRIMITIVE_WRAPPER_OR_PRIMITIVE_ARRAY.packOrdinalWithFilePosition(
                         tagPositionAfterReadingId
                     )
                 }
@@ -636,12 +635,6 @@ class HprofParser private constructor(
       }
     }
 
-    if (!indexBuilt) {
-      objectIndex.compact()
-      classNames.compact()
-      hprofStringCache.compact()
-    }
-
     scanning = false
     indexBuilt = true
   }
@@ -771,30 +764,22 @@ class HprofParser private constructor(
   }
 
   fun instanceAsString(instance: HydratedInstance): String {
-    val count = instance.fieldValue<IntValue>("count")
-        .value
+    val count = instance["count"].int!!
 
     if (count == 0) {
       return ""
     }
 
-    val value = instance.fieldValue<ObjectReference>("value")
-
     // Prior to API 26 String.value was a char array.
     // Since API 26 String.value is backed by native code. The vast majority of strings in a
     // heap dump are backed by a byte array, but we still find a few backed by a char array.
-    when (val valueRecord = retrieveRecord(value)) {
+    when (val valueRecord = instance["value"].reference!!.objectRecord) {
       is CharArrayDump -> {
-        var offset = 0
-
         // < API 23
         // As of Marshmallow, substrings no longer share their parent strings' char arrays
         // eliminating the need for String.offset
         // https://android-review.googlesource.com/#/c/83611/
-        val offsetValue = instance.fieldValueOrNull<IntValue>("offset")
-        if (offsetValue != null) {
-          offset = offsetValue.value
-        }
+        val offset = instance["offset"].int ?: 0
 
         val chars = valueRecord.array.copyOfRange(offset, offset + count)
         return String(chars)
@@ -815,6 +800,14 @@ class HprofParser private constructor(
         this as InstanceDumpRecord
     )
 
+  /**
+   * Returns true if [this] is an [InstanceDumpRecord] and its class name is [className].
+   * Note: this does not return true if this is an instance of a subclass of [className].
+   */
+  infix fun ObjectRecord.instanceOf(className: String): Boolean {
+    return this is InstanceDumpRecord && className(this.classId) == className
+  }
+
   val Long.hydratedInstance: HydratedInstance
     get() = hydrateInstance(
         retrieveRecordById(this) as InstanceDumpRecord
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt b/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt
index fd474f79..ad62d483 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt
@@ -52,7 +52,7 @@ import java.io.File
 
 class HprofWriter private constructor(
   private val sink: BufferedSink,
-  private val idSize: Int
+  val idSize: Int
 ) : Closeable {
 
   private val workBuffer = Buffer()
diff --git a/leakcanary-haha/src/main/java/leakcanary/ObjectIdMetadata.kt b/leakcanary-haha/src/main/java/leakcanary/ObjectIdMetadata.kt
index 0521e9f1..6bb90335 100644
--- a/leakcanary-haha/src/main/java/leakcanary/ObjectIdMetadata.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/ObjectIdMetadata.kt
@@ -3,8 +3,8 @@ package leakcanary
 import leakcanary.HprofParser.Companion.BITS_FOR_FILE_POSITION
 
 enum class ObjectIdMetadata {
-  PRIMITIVE_WRAPPER,
-  PRIMITIVE_ARRAY_OR_WRAPPER_ARRAY,
+  PRIMITIVE_WRAPPER_OR_PRIMITIVE_ARRAY,
+  PRIMITIVE_WRAPPER_ARRAY,
   OBJECT_ARRAY,
   /**
    * An [INSTANCE] of the String class.
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToIntSparseArray.kt b/leakcanary-haha/src/main/java/leakcanary/internal/LongToIntSparseArray.kt
index 58bd3923..4f701ae1 100644
--- a/leakcanary-haha/src/main/java/leakcanary/internal/LongToIntSparseArray.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/LongToIntSparseArray.kt
@@ -50,31 +50,6 @@ internal class LongToIntSparseArray(initialCapacity: Int) : Cloneable {
     size++
   }
 
-  fun compact() {
-    val initialSize = size
-    var compactedSize = 0
-    val keys = keys
-    val values = values
-    for (i in 0 until initialSize) {
-      val value = values[i]
-      if (value != DELETED_INT) {
-        if (i != compactedSize) {
-          keys[compactedSize] = keys[i]
-          values[compactedSize] = value
-          values[i] = DELETED_INT
-        }
-        compactedSize++
-      }
-    }
-    if (compactedSize != initialSize) {
-      size = compactedSize
-      this.keys = LongArray(compactedSize)
-      System.arraycopy(keys, 0, this.keys, 0, compactedSize)
-      this.values = IntArray(compactedSize)
-      System.arraycopy(values, 0, this.values, 0, compactedSize)
-    }
-  }
-
   private fun insert(
     key: Long,
     value: Int
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToLongSparseArray.kt b/leakcanary-haha/src/main/java/leakcanary/internal/LongToLongSparseArray.kt
index 9a7234c5..4a9dd23c 100644
--- a/leakcanary-haha/src/main/java/leakcanary/internal/LongToLongSparseArray.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/LongToLongSparseArray.kt
@@ -61,31 +61,6 @@ internal class LongToLongSparseArray(initialCapacity: Int) : Cloneable {
     size++
   }
 
-  fun compact() {
-    val initialSize = size
-    var compactedSize = 0
-    val keys = keys
-    val values = values
-    for (i in 0 until initialSize) {
-      val value = values[i]
-      if (value != DELETED_LONG) {
-        if (i != compactedSize) {
-          keys[compactedSize] = keys[i]
-          values[compactedSize] = value
-          values[i] = DELETED_LONG
-        }
-        compactedSize++
-      }
-    }
-    if (compactedSize != initialSize) {
-      size = compactedSize
-      this.keys = LongArray(compactedSize)
-      System.arraycopy(keys, 0, this.keys, 0, compactedSize)
-      this.values = LongArray(compactedSize)
-      System.arraycopy(values, 0, this.values, 0, compactedSize)
-    }
-  }
-
   private fun insert(
     key: Long,
     value: Long
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToStringSparseArray.kt b/leakcanary-haha/src/main/java/leakcanary/internal/LongToStringSparseArray.kt
index d43b9278..67ec9435 100644
--- a/leakcanary-haha/src/main/java/leakcanary/internal/LongToStringSparseArray.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/LongToStringSparseArray.kt
@@ -42,31 +42,6 @@ internal class LongToStringSparseArray(initialCapacity: Int) : Cloneable {
     return null
   }
 
-  fun compact() {
-    val initialSize = size
-    var compactedSize = 0
-    val keys = keys
-    val values = values
-    for (i in 0 until initialSize) {
-      val value = values[i]
-      if (value != null) {
-        if (i != compactedSize) {
-          keys[compactedSize] = keys[i]
-          values[compactedSize] = value
-          values[i] = null
-        }
-        compactedSize++
-      }
-    }
-    if (compactedSize != initialSize) {
-      size = compactedSize
-      this.keys = LongArray(compactedSize)
-      System.arraycopy(keys, 0, this.keys, 0, compactedSize)
-      this.values = arrayOfNulls(compactedSize)
-      System.arraycopy(values, 0, this.values, 0, compactedSize)
-    }
-  }
-
   operator fun set(
     key: Long,
     value: String
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt b/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
index 1c6c61aa..c516606f 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
@@ -15,16 +15,21 @@ object LeakSentry {
   )
 
   @Volatile
-  var config: Config = Config()
+  var config: Config = if (isInstalled) Config() else Config(enabled = false)
 
   val refWatcher
     get() = InternalLeakSentry.refWatcher
 
+  /** @see [manualInstall] */
+  val isInstalled
+    get() = InternalLeakSentry.isInstalled
+
   /**
-   * [LeakSentry] is automatically installed on process start by
-   * [leaksentry.internal.LeakSentryInstaller] which is registered in the AndroidManifest.xml of
-   * your app. If you disabled [leaksentry.internal.LeakSentryInstaller] then you can call this
-   * method to install [LeakSentry].
+   * [LeakSentry] is automatically installed on main process start by
+   * [leakcanary.internal.LeakSentryInstaller] which is registered in the AndroidManifest.xml of
+   * your app. If you disabled [leakcanary.internal.LeakSentryInstaller] or you need LeakSentry
+   * or LeakCanary to run outside of the main process then you can call this method to install
+   * [LeakSentry].
    */
   fun manualInstall(application: Application) = InternalLeakSentry.install(application)
 
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
index 6966d81b..a0317e8d 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
@@ -13,6 +13,9 @@ import java.util.concurrent.Executor
 
 internal object InternalLeakSentry {
 
+  val isInstalled
+    get() = ::application.isInitialized
+
   private val listener: LeakSentryListener
 
   val isDebuggableBuild by lazy {
