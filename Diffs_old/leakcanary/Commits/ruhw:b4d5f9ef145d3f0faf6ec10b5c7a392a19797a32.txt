diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
index b55f33ac..6ee4f5c2 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -73,6 +73,7 @@ internal class HeapDumpTrigger(
 
     var retainedKeys = refWatcher.retainedKeys
 
+    // 当前泄露实例个数小于 5 个，不进行 heap dump
     if (checkRetainedCount(retainedKeys, config.retainedVisibleThreshold)) return
 
     if (!config.dumpHeapWhenDebugging && DebuggerControl.isDebuggerAttached) {
@@ -152,7 +153,7 @@ internal class HeapDumpTrigger(
 
   private fun checkRetainedCount(
     retainedKeys: Set<String>,
-    retainedVisibleThreshold: Int
+    retainedVisibleThreshold: Int // 默认为 5 个
   ): Boolean {
     if (retainedKeys.isEmpty()) {
       CanaryLog.d("No retained instances")
@@ -167,8 +168,9 @@ internal class HeapDumpTrigger(
             retainedKeys.size,
             retainedVisibleThreshold
         )
+        // 通知用户 "App visible, waiting until 5 retained instances"
         showRetainedCountBelowThresholdNotification(retainedKeys.size, retainedVisibleThreshold)
-        scheduleRetainedInstanceCheck(
+        scheduleRetainedInstanceCheck( // 5s 后再次发起检测
             "Showing retained instance notification", WAIT_FOR_INSTANCE_THRESHOLD_MILLIS
         )
         return true
@@ -184,13 +186,13 @@ internal class HeapDumpTrigger(
     checkScheduled = true
     backgroundHandler.post {
       checkScheduled = false
-      checkRetainedInstances(reason)
+      checkRetainedInstances(reason) // 检测泄露实例
     }
   }
 
   private fun scheduleRetainedInstanceCheck(
     reason: String,
-    delayMillis: Long
+    delayMillis: Long // 默认 5 s
   ) {
     if (checkScheduled) {
       return
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
index 88877522..d8ea37de 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -45,15 +45,15 @@ internal object InternalLeakCanary : LeakSentryListener {
   override fun onLeakSentryInstalled(application: Application) {
     this.application = application
 
-    val heapDumper = AndroidHeapDumper(application, leakDirectoryProvider)
+    val heapDumper = AndroidHeapDumper(application, leakDirectoryProvider) // 用于 heap dump
 
-    val gcTrigger = GcTrigger.Default
+    val gcTrigger = GcTrigger.Default // 用于手动调用 GC
 
-    val configProvider = { LeakCanary.config }
+    val configProvider = { LeakCanary.config } // 配置项
 
     val handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)
     handlerThread.start()
-    val backgroundHandler = Handler(handlerThread.looper)
+    val backgroundHandler = Handler(handlerThread.looper) // 发起内存泄漏检测的线程
 
     heapDumpTrigger = HeapDumpTrigger(
         application, backgroundHandler, LeakSentry.refWatcher, gcTrigger, heapDumper, configProvider
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
index 0ae6927c..02a23184 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
@@ -28,7 +28,7 @@ internal class ActivityDestroyWatcher private constructor(
   private val lifecycleCallbacks = object : ActivityLifecycleCallbacksAdapter() {
     override fun onActivityDestroyed(activity: Activity) {
       if (configProvider().watchActivities) {
-        refWatcher.watch(activity)
+        refWatcher.watch(activity) // 监听到 onDestroy() 之后，通过 refWatcher 监测 Activity
       }
     }
   }
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
index 60a0b662..2e7b41b2 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
@@ -41,7 +41,7 @@ internal interface FragmentDestroyWatcher {
     ) {
       val fragmentDestroyWatchers = mutableListOf<FragmentDestroyWatcher>()
 
-      if (SDK_INT >= O) {
+      if (SDK_INT >= O) { // >= 26，使用 AndroidOFragmentDestroyWatcher
         fragmentDestroyWatchers.add(
             AndroidOFragmentDestroyWatcher(refWatcher, configProvider)
         )
@@ -51,7 +51,7 @@ internal interface FragmentDestroyWatcher {
               SUPPORT_FRAGMENT_CLASS_NAME
           )
       ) {
-        fragmentDestroyWatchers.add(
+        fragmentDestroyWatchers.add( // androidx 使用 SupportFragmentDestroyWatcher
             SupportFragmentDestroyWatcher(refWatcher, configProvider)
         )
       }
diff --git a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
index a6b0bc89..dbeb7336 100644
--- a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
+++ b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
@@ -36,14 +36,16 @@ class RefWatcher constructor(
 
   /**
    * References passed to [watch] that haven't made it to [retainedReferences] yet.
+   * watch() 方法传进来的引用，尚未判定为泄露
    */
   private val watchedReferences = mutableMapOf<String, KeyedWeakReference>()
   /**
    * References passed to [watch] that we have determined to be retained longer than they should
    * have been.
+   * watch() 方法传进来的引用，已经被判定为泄露
    */
   private val retainedReferences = mutableMapOf<String, KeyedWeakReference>()
-  private val queue = ReferenceQueue<Any>()
+  private val queue = ReferenceQueue<Any>() // 引用队列，配合弱引用使用
 
   val hasRetainedReferences: Boolean
     @Synchronized get() {
@@ -82,11 +84,11 @@ class RefWatcher constructor(
     if (!isEnabled()) {
       return
     }
-    removeWeaklyReachableReferences() // 首先清空引用队列 queue
+    removeWeaklyReachableReferences() // 移除队列中将要被 GC 的引用
     val key = UUID.randomUUID()
         .toString()
     val watchUptimeMillis = clock.uptimeMillis()
-    val reference =
+    val reference = // 构建当前引用的弱引用对象，并关联引用队列 queue
       KeyedWeakReference(watchedReference, key, referenceName, watchUptimeMillis, queue)
     if (referenceName != "") {
       CanaryLog.d(
@@ -99,9 +101,10 @@ class RefWatcher constructor(
       )
     }
 
-    watchedReferences[key] = reference
+    watchedReferences[key] = reference // 将引用存入 watchedReferences
     checkRetainedExecutor.execute {
-      moveToRetained(key)
+      moveToRetained(key) // 如果当前引用未被移除，仍在 watchedReferences  队列中，
+                          // 说明仍未被 GC，移入 retainedReferences 队列中,暂时标记为泄露
     }
   }
 
