diff --git a/docs/changelog.md b/docs/changelog.md
index 37d1abc5..e315d1da 100644
--- a/docs/changelog.md
+++ b/docs/changelog.md
@@ -1,8 +1,35 @@
 # Change Log
 
-## Version 2.0 Alpha 2 (2019-05-21)
+## Version 2.0 Alpha 3 (2019-07-04)
+
+**Thanks for testing the alpha**, we're counting on you to help us find bugs and suggest improvements! Check out the new [Getting Started](https://square.github.io/leakcanary/getting_started) instructions and the [migration guide](https://square.github.io/leakcanary/upgrading-to-leakcanary-2.0/). 
+
+* [#1401](https://github.com/square/leakcanary/pull/1401) LeakCanary can now import all hprof files created from prior LeakCanary versions.
+* [#1414](https://github.com/square/leakcanary/pull/1414) New API: `RefWatcher.retainedInstances` which returns the instances that are currently considered retained.
+* [#1419](https://github.com/square/leakcanary/pull/1419) New APIs: `LeakCanary.Config.maxStoredHeapDumps` (default 7) and `LeakCanary.Config.requestWriteExternalStoragePermission` (default false). LeakCanary won't ask for the external storage permission anymore by default.
+* [#1338](https://github.com/square/leakcanary/issues/1338) API change: `LeakCanary.Config.exclusionsFactory` replaced with `LeakCanary.Config.knownReferences` (simpler use), `LeakCanary.Config.leakInspectors` and `LeakCanary.Config.labelers` merged into `LeakCanary.Config.leakTraceInspectors` which provides access to the entire leak trace as well as a new graph oriented API that replaces the low level hprof parser API.
+* [#1382](https://github.com/square/leakcanary/issues/1382) LeakCanary now disables automatic heap dumping when running in AndroidX UI tests.
+* [#1424](https://github.com/square/leakcanary/pull/1424) API rename: `RefWatcher.hasRetainedReferences` => `RefWatcher.hasRetainedInstances`, `RefWatcher.retainedReferenceCount` => `RefWatcher.retainedInstanceCount`, `RefWatcher.hasWatchedReferences` => `RefWatcher.hasWatchedInstances`, `RefWatcher.removeKeysRetainedBeforeHeapDump` => `RefWatcher.removeInstancesRetainedBeforeHeapDump`, `RefWatcher.clearWatchedReferences` => `RefWatcher.clearWatchedInstances`.
+* [#1432](https://github.com/square/leakcanary/pull/1432) [#1438](https://github.com/square/leakcanary/pull/1438) [#1440](https://github.com/square/leakcanary/pull/1440) New "won't fix" leaks and leak trace inspectors
+* [#1374](https://github.com/square/leakcanary/issues/1374) [#1364](https://github.com/square/leakcanary/issues/1364) [#1366](https://github.com/square/leakcanary/issues/1366) [#1417](https://github.com/square/leakcanary/issues/1417) [#1399](https://github.com/square/leakcanary/issues/#1399) [#1416](https://github.com/square/leakcanary/issues/1416) [#1407](https://github.com/square/leakcanary/issues/1407) [#1427](https://github.com/square/leakcanary/issues/1427) [#1385](https://github.com/square/leakcanary/issues/1385) Bug and crash fixes
 
-**Thanks for testing the alpha**, we're counting on you to help us find bugs and suggest improvements! Check out the new [Getting Started](https://square.github.io/leakcanary/getting_started) instructions and the [migration guide](https://square.github.io/leakcanary/Upgrading-to-LeakCanary-2.0). 
+Many thanks to
+[@1step2hell](https://github.com/1step2hell),
+[@afollestad](https://github.com/afollestad),
+[@ansman](https://github.com/ansman),
+[@bjdodson](https://github.com/bjdodson),
+[@BraisGabin](https://github.com/BraisGabin),
+[@EBfVince](https://github.com/EBfVince),
+[@jaredsburrows](https://github.com/jaredsburrows),
+[@pforhan](https://github.com/pforhan),
+[@pyricau](https://github.com/pyricau),
+[@tellypresence](https://github.com/tellypresence),
+[@wiyarmir](https://github.com/wiyarmir)
+for the contributions, bug reports and feature requests.
+
+For more details, see the [2.0-alpha-3 Milestone](https://github.com/square/leakcanary/milestone/8) and the [full diff](https://github.com/square/leakcanary/compare/v2.0-alpha-2...v2.0-alpha-3).
+
+## Version 2.0 Alpha 2 (2019-05-21)
 
 * [#1040](https://github.com/square/leakcanary/pull/1040) Import and analyze hprof files from other devices
 * [#1344](https://github.com/square/leakcanary/pull/1344) Computing retained size
diff --git a/docs/faq.md b/docs/faq.md
index c163a240..b5e4d21e 100644
--- a/docs/faq.md
+++ b/docs/faq.md
@@ -9,8 +9,8 @@ If you find a new one, please [create an issue](https://github.com/square/leakca
 1. Provide the entire leak trace information (reference key, device, etc), and use backticks (`) for formatting.
 2. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions [android/platform_frameworks_base](https://github.com/android/platform_frameworks_base).
 3. Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed.
-4. If it's still happening, build a simple repro case
-5. File an issue on [b.android.com](http://b.android.com) with the leak trace and the repro case
+4. If it's still happening, build a simple repro case.
+5. File an issue on [b.android.com](http://b.android.com) with the leak trace and the repro case.
 6. Create a PR in LeakCanary to update `AndroidExcludedRefs.kt`. Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
 
 ## How do I share a leak trace?
@@ -26,7 +26,7 @@ Sometimes the leak trace isn't enough and you need to dig into a heap dump with
 
 Here's how you can find the leaking instance in the heap dump:
 
-1. Look for all instances of `leakcanary.KeyedWeakReference`
+1. Look for all instances of `leakcanary.KeyedWeakReference`.
 2. For each of these, look at the `key` field.
 3. Find the `KeyedWeakReference` that has a `key` field equal to the reference key reported by LeakCanary.
 4. The `referent` field of that `KeyedWeakReference` is your leaking object.
@@ -42,7 +42,7 @@ Update your dependencies to the latest SNAPSHOT (see [build.gradle](https://gith
 
 ```gradle
  dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-3-SNAPSHOT'
+   debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-4-SNAPSHOT'
  }
 ```
 
diff --git a/docs/fundamentals.md b/docs/fundamentals.md
index 42cc51fc..8c76ccba 100644
--- a/docs/fundamentals.md
+++ b/docs/fundamentals.md
@@ -138,17 +138,12 @@ The chain of references from the GC root to the leaking instance is what is prev
 ```
     ├─ android.widget.TextView
     │    Leaking: YES (View detached and has parent)
-```
-
-LeakCanary runs heuristics to determine the lifecycle state of the nodes of the leak trace, and therefore whether they are leaking or not. For example, if a view has `View#mAttachInfo = null` and `mParent != null` then it is detached yet has a parent, so that view is probably leaking. In the leak trace, for each node you'll see `Leaking: YES / NO / UNKNOWN` with an explanation in parenthesis. You can customize this behavior and add your own heuristics.
-
-```
     │    View#mAttachInfo is null (view detached)
     │    View#mParent is set
     │    View.mWindowAttachCount=1
 ```
 
-LeakCanary can also surface extra information about the state of a node, e.g. `View.mWindowAttachCount=1`. You can add your own labels.
+LeakCanary runs heuristics to determine the lifecycle state of the nodes of the leak trace, and therefore whether they are leaking or not. For example, if a view has `View#mAttachInfo = null` and `mParent != null` then it is detached yet has a parent, so that view is probably leaking. In the leak trace, for each node you'll see `Leaking: YES / NO / UNKNOWN` with an explanation in parenthesis. LeakCanary can also surface extra information about the state of a node, e.g. `View.mWindowAttachCount=1`. You can customize this behavior and add your own heuristics by updating `LeakCanary.Config.leakTraceInspectors`.
 
 ### Narrowing down the cause of a leak
 
@@ -223,8 +218,8 @@ LeakCanary is released as several distinct libraries:
     * Depends on LeakSentry.
     * Artifact id: `com.squareup.leakcanary:leakcanary-android`.
 * LeakCanary for Instrumentation tests
-    * Fails tests if a leak is detected
-    * Only suitable for Instrumentation tests
+    * Fails tests if a leak is detected.
+    * Only suitable for Instrumentation tests.
     * Configures LeakCanary to wait for the end of tests before dumping the heap.
     * Artifact id: `com.squareup.leakcanary:leakcanary-android-instrumentation`.
-    * See [Running LeakCanary in instrumentation tests](recipes.md#running-leakcanary-in-instrumentation-tests)
\ No newline at end of file
+    * See [Running LeakCanary in instrumentation tests](recipes.md#running-leakcanary-in-instrumentation-tests).
diff --git a/docs/getting_started.md b/docs/getting_started.md
index 20ba4063..2172d3c5 100644
--- a/docs/getting_started.md
+++ b/docs/getting_started.md
@@ -5,7 +5,7 @@ Add LeakCanary to `build.gradle`:
 ```groovy
 dependencies {
   // debugImplementation because LeakCanary should only run in debug builds.
-  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-2'
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-3'
 }
 ```
 
diff --git a/gradle.properties b/gradle.properties
index 840adde5..176c24f4 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,5 +1,5 @@
 GROUP=com.squareup.leakcanary
-VERSION_NAME=2.0-alpha-3-SNAPSHOT
+VERSION_NAME=2.0-alpha-4-SNAPSHOT
 
 POM_DESCRIPTION=Leak Canary
 
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakTraceInspectors.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakTraceInspectors.kt
index d2b4cdd8..8706daae 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakTraceInspectors.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakTraceInspectors.kt
@@ -40,16 +40,17 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
       leakTrace.forEachInstanceOf("android.view.View") { instance ->
         // This skips edge cases like Toast$TN.mNextView holding on to an unattached and unparented
         // next toast view
-        val mParentRef = instance["mParent"]!!.value
+        val mParentRef = instance["android.view.View", "mParent"]!!.value
         val mParentSet = mParentRef.isNonNullReference
-        val viewDetached = instance["mAttachInfo"]!!.value.isNullReference
+        val viewDetached = instance["android.view.View", "mAttachInfo"]!!.value.isNullReference
 
         if (mParentSet) {
           if (viewDetached) {
             reportLeaking("View detached and has parent")
           } else {
             val viewParent = mParentRef.readObjectRecord()!!.asInstance!!
-            if (viewParent instanceOf "android.view.View" && viewParent["mAttachInfo"]!!.value.isNullReference) {
+            if (viewParent instanceOf "android.view.View" &&
+                viewParent["android.view.View", "mAttachInfo"]!!.value.isNullReference) {
               reportLeaking("View attached but parent detached (attach disorder)")
             } else {
               reportNotLeaking("View attached")
@@ -71,7 +72,7 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
 
         // TODO Add back support for view id labels, see https://github.com/square/leakcanary/issues/1297
 
-        val mWindowAttachCount = instance["mWindowAttachCount"]?.value?.asInt
+        val mWindowAttachCount = instance["android.view.View", "mWindowAttachCount"]?.value?.asInt
 
         if (mWindowAttachCount != null) {
           addLabel("View.mWindowAttachCount=$mWindowAttachCount")
@@ -89,7 +90,7 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
         // Activity.mDestroyed was introduced in 17.
         // https://android.googlesource.com/platform/frameworks/base/+
         // /6d9dcbccec126d9b87ab6587e686e28b87e5a04d
-        val field = instance["mDestroyed"]
+        val field = instance["android.app.Activity", "mDestroyed"]
 
         if (field != null) {
           if (field.value.asBoolean!!) {
@@ -126,12 +127,12 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
                 if (mDestroyed != null) {
                   if (mDestroyed.value.asBoolean!!) {
                     reportLeaking(
-                        "${instance.simpleClassName} wraps an Activity with Activity.mDestroyed true"
+                        "${instance.classSimpleName} wraps an Activity with Activity.mDestroyed true"
                     )
                   } else {
                     // We can't assume it's not leaking, because this context might have a shorter lifecycle
                     // than the activity. So we'll just add a label.
-                    addLabel("${instance.simpleClassName} wraps an Activity with Activity.mDestroyed false")
+                    addLabel("${instance.classSimpleName} wraps an Activity with Activity.mDestroyed false")
                   }
                 }
               } else if (context instanceOf "android.content.ContextWrapper" &&
@@ -153,7 +154,7 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
       leakTrace: List<LeakTraceElementReporter>
     ) {
       leakTrace.forEachInstanceOf("android.app.Dialog") { instance ->
-        val mDecor = instance["mDecor"]!!
+        val mDecor = instance["android.app.Dialog", "mDecor"]!!
         if (mDecor.value.isNullReference) {
           reportLeaking(mDecor describedWithValue "null")
         } else {
@@ -275,7 +276,7 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
       leakTrace: List<LeakTraceElementReporter>
     ) {
       leakTrace.forEachInstanceOf("android.os.MessageQueue") { instance ->
-        val mQuitting = instance["mQuitting"]!!
+        val mQuitting = instance["android.os.MessageQueue", "mQuitting"]!!
         if (mQuitting.value.asBoolean!!) {
           reportLeaking(mQuitting describedWithValue "true")
         } else {
@@ -294,7 +295,7 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
         // Bugs in view code tends to cause Mortar presenters to still have a view when they actually
         // should be unreachable, so in that case we don't know their reachability status. However,
         // when the view is null, we're pretty sure they  never leaking.
-        val view = instance["view"]!!
+        val view = instance["mortar.Presenter", "view"]!!
         if (view.value.isNullReference) {
           reportLeaking(view describedWithValue "null")
         }
@@ -308,7 +309,7 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
       leakTrace: List<LeakTraceElementReporter>
     ) {
       leakTrace.forEachInstanceOf("com.squareup.coordinators.Coordinator") { instance ->
-        val attached = instance["attached"]
+        val attached = instance["com.squareup.coordinators.Coordinator", "attached"]
         if (attached!!.value.asBoolean!!) {
           reportNotLeaking(attached describedWithValue "true")
         } else {
@@ -361,7 +362,7 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
       leakTrace: List<LeakTraceElementReporter>
     ) {
       leakTrace.forEachInstanceOf(Thread::class) { instance ->
-        val threadName = instance["name"]!!.value.readAsJavaString()
+        val threadName = instance[Thread::class, "name"]!!.value.readAsJavaString()
         if (threadName == "main") {
           reportNotLeaking("the main thread always runs")
         }
@@ -376,7 +377,7 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
       leakTrace: List<LeakTraceElementReporter>
     ) {
       leakTrace.forEachInstanceOf("android.view.Window") { instance ->
-        val mDestroyed = instance["mDestroyed"]!!
+        val mDestroyed = instance["android.view.Window", "mDestroyed"]!!
 
         if (mDestroyed.value.asBoolean!!) {
           reportLeaking(mDestroyed describedWithValue "true")
@@ -393,12 +394,13 @@ enum class AndroidLeakTraceInspectors : LeakTraceInspector {
       leakTrace: List<LeakTraceElementReporter>
     ) {
       leakTrace.forEachInstanceOf("android.widget.Toast") { instance ->
-        val tnInstance = instance["mTN"]!!.value.readObjectRecord()!!.asInstance!!
+        val tnInstance =
+          instance["android.widget.Toast", "mTN"]!!.value.readObjectRecord()!!.asInstance!!
         // mWM is set in android.widget.Toast.TN#handleShow and never unset, so this toast was never
         // shown, we don't know if it's leaking.
-        if (tnInstance["mWM"]!!.value.isNonNullReference) {
+        if (tnInstance["android.widget.Toast\$TN", "mWM"]!!.value.isNonNullReference) {
           // mView is reset to null in android.widget.Toast.TN#handleHide
-          if (tnInstance["mView"]!!.value.isNullReference) {
+          if (tnInstance["android.widget.Toast\$TN", "mView"]!!.value.isNullReference) {
             reportLeaking(
                 "This toast is done showing (Toast.mTN.mWM != null && Toast.mTN.mView == null)"
             )
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
index efd56bd4..be6c36a7 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
@@ -425,7 +425,7 @@ class HeapAnalyzer constructor(
 
     leakTraceInspectors.forEach { it.inspect(graph, leakReporters) }
 
-    val leakStatuses = computeLeakStatuses(graph, leakReporters)
+    val leakStatuses = computeLeakStatuses(leakReporters)
 
     node = leafNode
     while (node is ChildNode) {
@@ -439,7 +439,6 @@ class HeapAnalyzer constructor(
   }
 
   private fun computeLeakStatuses(
-    graph: HprofGraph,
     leakReporters: List<LeakTraceElementReporter>
   ): List<LeakNodeStatusAndReason> {
     var lastNotLeakingElementIndex = 0
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt
index cb7f869f..940bf3fa 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt
@@ -28,7 +28,7 @@ data class LeakTraceElement(
   /**
    * Returns {@link #className} without the package.
    */
-  val simpleClassName: String get() = className.lastSegment('.')
+  val classSimpleName: String get() = className.lastSegment('.')
 
   enum class Type {
     INSTANCE_FIELD,
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
index f606e7c8..9ccacdab 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
@@ -30,23 +30,24 @@ internal class KeyedWeakReferenceMirror(
       heapDumpUptimeMillis: Long?
     ): KeyedWeakReferenceMirror {
 
+      val keyWeakRefClassName = weakRef.className
       val watchDurationMillis = if (heapDumpUptimeMillis != null)
-        heapDumpUptimeMillis - weakRef["watchUptimeMillis"]!!.value.asLong!!
+        heapDumpUptimeMillis - weakRef[keyWeakRefClassName, "watchUptimeMillis"]!!.value.asLong!!
       else 0L
 
       val retainedDurationMillis = if (heapDumpUptimeMillis != null) {
-        val retainedUptimeMillis = weakRef["retainedUptimeMillis"]!!.value.asLong!!
+        val retainedUptimeMillis = weakRef[keyWeakRefClassName, "retainedUptimeMillis"]!!.value.asLong!!
         if (retainedUptimeMillis == -1L) -1L else heapDumpUptimeMillis - retainedUptimeMillis
       } else null
 
-      val keyString = weakRef["key"]!!.value.readAsJavaString()!!
+      val keyString = weakRef[keyWeakRefClassName, "key"]!!.value.readAsJavaString()!!
 
-      val name = weakRef["name"]?.value?.readAsJavaString() ?: UNKNOWN_LEGACY
-      val className = weakRef["className"]?.value?.readAsJavaString() ?: UNKNOWN_LEGACY
+      val name = weakRef[keyWeakRefClassName, "name"]?.value?.readAsJavaString() ?: UNKNOWN_LEGACY
+      val className = weakRef[keyWeakRefClassName, "className"]?.value?.readAsJavaString() ?: UNKNOWN_LEGACY
       return KeyedWeakReferenceMirror(
           watchDurationMillis = watchDurationMillis,
           retainedDurationMillis = retainedDurationMillis,
-          referent = weakRef["referent"]!!.value.actual as ObjectReference,
+          referent = weakRef["java.lang.ref.Reference", "referent"]!!.value.actual as ObjectReference,
           key = keyString,
           name = name,
           className = className
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
index c8a67e51..476a011f 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
@@ -69,7 +69,7 @@ private fun getNextElementString(
     if (element.holder == ARRAY || element.holder == THREAD) {
       "${element.holder.name.toLowerCase(Locale.US)} "
     } else ""
-  val simpleClassName = element.simpleClassName
+  val simpleClassName = element.classSimpleName
   val referenceName = if (element.reference != null) ".${element.reference.displayName}" else ""
   val requiredSpaces =
     staticString.length + holderString.length + simpleClassName.length + "├─".length
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
index 57877b93..3fedb641 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
@@ -248,7 +248,7 @@ internal class ShortestPathFinder {
         is JavaFrame -> {
           val threadRoot = threadsBySerialNumber.getValue(gcRoot.threadSerialNumber)
           val threadInstance = graph.readGraphObjectRecord(threadRoot.id).asInstance!!
-          val threadName = threadInstance["name"]?.value?.readAsJavaString()
+          val threadName = threadInstance[Thread::class, "name"]?.value?.readAsJavaString()
           val exclusion = threadNameExclusions[threadName]
 
           if (exclusion == null || exclusion.status != NEVER_REACHABLE) {
@@ -449,7 +449,7 @@ internal class ShortestPathFinder {
       STRING -> {
         updateDominator(parentObjectId, objectId, true)
         val stringInstance = graph.readGraphObjectRecord(objectId).asInstance!!
-        val valueId = stringInstance["value"]?.value?.asNonNullObjectIdReference
+        val valueId = stringInstance["java.lang.String", "value"]?.value?.asNonNullObjectIdReference
         if (valueId != null) {
           updateDominator(parentObjectId, valueId, true)
         }
@@ -544,7 +544,7 @@ internal class ShortestPathFinder {
         undominate(objectId, true)
         val stringRecord = graph.readGraphObjectRecord(objectId)
         val stringInstance = stringRecord.asInstance!!
-        val valueId = stringInstance["value"]?.value?.asObjectIdReference
+        val valueId = stringInstance["java.lang.String", "value"]?.value?.asObjectIdReference
         if (valueId != null) {
           undominate(valueId, true)
         }
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
index 7b0b0f0b..d4e0b835 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
@@ -60,12 +60,18 @@ class HprofWriterHelper constructor(
       "count" to IntValue::class
   )
   )
-  private val weakReferenceClassId = clazz(
-      className = "java.lang.ref.WeakReference",
+
+  private val referenceClassId  = clazz(
+      className = "java.lang.ref.Reference",
       fields = listOf(
           "referent" to ObjectReference::class
       )
   )
+
+  private val weakReferenceClassId = clazz(
+      className = "java.lang.ref.WeakReference",
+      superClassId = referenceClassId
+  )
   private val keyedWeakReferenceClassId = clazz(
       superClassId = weakReferenceClassId,
       className = "leakcanary.KeyedWeakReference",
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
index c4d8919b..17655635 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
@@ -116,7 +116,7 @@ internal class AndroidHeapDumper(
       toast.setGravity(Gravity.CENTER_VERTICAL, 0, -iconSize)
       toast.duration = Toast.LENGTH_LONG
       // Inflating with application context: https://github.com/square/leakcanary/issues/1385
-      val inflater = LayoutInflater.from(resumedActivity.application)
+      val inflater = LayoutInflater.from(context)
       toast.view = inflater.inflate(R.layout.leak_canary_heap_dump_toast, null)
       toast.show()
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
index 7d4c5c87..06c6eec8 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
@@ -211,7 +211,7 @@ internal class DisplayLeakAdapter private constructor(
   ): Spanned {
 
     val packageEnd = element.className.lastIndexOf('.')
-    var simpleName = element.simpleClassName
+    var simpleName = element.classSimpleName
     simpleName = simpleName.replace("[]", "[ ]")
     val styledClassName = "<font color='$classNameColorHexString'>$simpleName</font>"
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
index afc0b086..0803bb72 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
@@ -282,7 +282,7 @@ internal object LeakingInstanceTable {
       } else {
         val element = leakCauses.first()
         val referenceName = element.reference!!.groupingName
-        val refDescription = element.simpleClassName + "." + referenceName
+        val refDescription = element.classSimpleName + "." + referenceName
         refDescription
       }
     }
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt b/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
index fde36349..b52d3491 100644
--- a/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
@@ -98,20 +98,23 @@ sealed class GraphObjectRecord {
       this instanceOf expectedClass.java.name
 
     operator fun get(
-      className: String,
+      declaringClass: KClass<out Any>,
       fieldName: String
     ): GraphField? {
-      return readFields().firstOrNull { field -> field.classRecord.name == className && field.name == fieldName }
+      return get(declaringClass.java.name, fieldName)
     }
 
-    operator fun get(fieldName: String): GraphField? {
-      return readFields().firstOrNull { field -> field.name == fieldName }
+    operator fun get(
+      declaringClassName: String,
+      fieldName: String
+    ): GraphField? {
+      return readFields().firstOrNull { field -> field.classRecord.name == declaringClassName && field.name == fieldName }
     }
 
     val className: String
       get() = graph.className(record.classId)
 
-    val simpleClassName: String
+    val classSimpleName: String
       get() {
         val className = this.className
         val separator = className.lastIndexOf('.')
@@ -147,7 +150,7 @@ sealed class GraphObjectRecord {
       if (!graph.isJavaString(record)) {
         return null
       }
-      val count = this["count"]!!.value.asInt!!
+      val count = this["java.lang.String", "count"]!!.value.asInt!!
       if (count == 0) {
         return ""
       }
@@ -155,13 +158,14 @@ sealed class GraphObjectRecord {
       // Prior to API 26 String.value was a char array.
       // Since API 26 String.value is backed by native code. The vast majority of strings in a
       // heap dump are backed by a byte array, but we still find a few backed by a char array.
-      when (val valueRecord = this["value"]!!.value.readObjectRecord()!!.record) {
+      when (val valueRecord =
+        this["java.lang.String", "value"]!!.value.readObjectRecord()!!.record) {
         is CharArrayDump -> {
           // < API 23
           // As of Marshmallow, substrings no longer share their parent strings' char arrays
           // eliminating the need for String.offset
           // https://android-review.googlesource.com/#/c/83611/
-          val offset = this["offset"]?.value?.asInt ?: 0
+          val offset = this["java.lang.String", "offset"]?.value?.asInt ?: 0
 
           val chars = valueRecord.array.copyOfRange(offset, offset + count)
           return String(chars)
@@ -170,7 +174,8 @@ sealed class GraphObjectRecord {
           return String(valueRecord.array, Charset.forName("UTF-8"))
         }
         else -> throw UnsupportedOperationException(
-            "'value' field ${this["value"]!!.value} was expected to be either a char or byte array in string instance with id ${record.id}"
+            "'value' field ${this["java.lang.String", "value"]!!.value} was expected to be either" +
+                " a char or byte array in string instance with id ${record.id}"
         )
       }
     }
diff --git a/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt b/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
index a8715ef2..0aeca12b 100644
--- a/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
+++ b/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
@@ -35,7 +35,7 @@ class HprofWriterTest {
       val baguetteInstance =
         treasureChestClass[CONTENT_FIELD_NAME]!!.value.readObjectRecord()!!.asInstance!!
 
-      assertThat(baguetteInstance[ANSWER_FIELD_NAME]!!.value.asInt!!).isEqualTo(42)
+      assertThat(baguetteInstance[BAGUETTE_CLASS_NAME, ANSWER_FIELD_NAME]!!.value.asInt!!).isEqualTo(42)
     }
   }
 
