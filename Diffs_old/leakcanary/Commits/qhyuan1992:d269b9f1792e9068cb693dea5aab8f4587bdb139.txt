diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
index f5c96da0..ac0b1eda 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
@@ -120,6 +120,8 @@ public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) { //
       Instance leakingRef = findLeakingReference(referenceKey, snapshot);
 
       // False alarm, weak reference was cleared in between key check and heap dump.
+      // 即使经过gc对象还存在，并不能说明发生了泄露，在开始检测到dump堆这段时间还有可能被回收
+      // 因此现在再判断下，如果在hprof中没找到那就是这段时间内被回收了，没有发生泄漏
       if (leakingRef == null) {
         return noLeak(since(analysisStartNanoTime));
       }
@@ -168,11 +170,14 @@ private String generateRootKey(RootObj root) {
     return String.format("%s@0x%08x", root.getRootType().getName(), root.getId());
   }
 
+  // 返回的是泄露的那个对象实例
   private Instance findLeakingReference(String key, Snapshot snapshot) {
     // 找到KeyedWeakReference类型的对象
     // 类似的 也可以找到android.graphic.Bitmap等其他对象
     ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());
     List<String> keysFound = new ArrayList<>();
+    // 一个类可能有很多实例，如何找到在监控的的那个可能泄露的对象？
+    // 在这个类的所有实例中找key相同的那个对象
     for (Instance instance : refClass.getInstancesList()) {
       List<ClassInstance.FieldValue> values = classInstanceValues(instance);
       String keyCandidate = asString(fieldValue(values, "key"));
