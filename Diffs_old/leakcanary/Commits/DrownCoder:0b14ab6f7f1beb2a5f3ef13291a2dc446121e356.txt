diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
index 78563f40..5d1acc05 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
@@ -81,7 +81,7 @@ public RefWatcher buildAndInstall() {
       LeakCanary.enableDisplayLeakActivity(context);
       //默认为true
       if (watchActivities) {
-        //监听Activity的生命周期
+        //注意，在这里通过监听Application,监听Activity的生命周期
         ActivityRefWatcher.install((Application) context, refWatcher);
       }
     }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
index ecabddd5..6cadbc76 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
@@ -42,7 +42,7 @@ public AndroidWatchExecutor(long initialDelayMillis) {
     //这里new了一个HandlerThread，内部封装好了looper.prepare()等操作
     HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);
     handlerThread.start();
-    //handlerThread内部等handler
+    //handlerThread内部的handler
     backgroundHandler = new Handler(handlerThread.getLooper());
     this.initialDelayMillis = initialDelayMillis;
     maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
index 3395ac62..b15aab88 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -40,6 +40,7 @@
   public static RefWatcher install(Application application) {
     //创建RefWatcher
     return refWatcher(application).listenerServiceClass(DisplayLeakService.class)
+            //设置已知的内存泄漏问题，或者系统的内存泄漏问题
         .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
         .buildAndInstall();
   }
@@ -55,6 +56,9 @@ public static RefWatcher installedRefWatcher() {
     return refWatcher;
   }
 
+  /**
+   * 创建一个builder对象
+   */
   public static AndroidRefWatcherBuilder refWatcher(Context context) {
     return new AndroidRefWatcherBuilder(context);
   }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
index 2bcdbece..23034970 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
@@ -35,8 +35,11 @@
 
   public static void runAnalysis(Context context, HeapDump heapDump,
       Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
+    //开启一个IntentService用于分析内存泄漏
     Intent intent = new Intent(context, HeapAnalyzerService.class);
+    //将回调的监听Service的class传入，分析完成，回调到这个service
     intent.putExtra(LISTENER_CLASS_EXTRA, listenerServiceClass.getName());
+    //收集的文件
     intent.putExtra(HEAPDUMP_EXTRA, heapDump);
     context.startService(intent);
   }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
index b5c2b292..af6cd57c 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
@@ -112,6 +112,8 @@ private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakRefer
   @SuppressWarnings("ReferenceEquality") // Explicitly checking for named null.
     // 避免因为gc不及时带来的误判，leakcanay会手动进行gc,进行二次确认进行保证
   Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {
+    //System.currentTimeMillis，那么每次的结果将会差别很小，甚至一样，因为现代的计算机运行速度很快
+    //检测系统的耗时所用，所以使用System.nanoTime提供相对精确的计时
     long gcStartNanoTime = System.nanoTime();
     long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);
     //第一次判断，移除此时已经被回收的对象
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
index ed91d534..51c1d802 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
@@ -54,33 +54,33 @@ public final RefWatcher build() {
     if (isDisabled()) {
       return RefWatcher.DISABLED;
     }
-
+    //用于排除某些系统bug导致的内存泄露
     ExcludedRefs excludedRefs = this.excludedRefs;
     if (excludedRefs == null) {
       excludedRefs = defaultExcludedRefs();
     }
-
+    //用于分析生成的dump文件，找到内存泄露的原因
     HeapDump.Listener heapDumpListener = this.heapDumpListener;
     if (heapDumpListener == null) {
       heapDumpListener = defaultHeapDumpListener();
     }
-
+    //用于查询是否正在调试中，调试中不会执行内存泄露检测
     DebuggerControl debuggerControl = this.debuggerControl;
     if (debuggerControl == null) {
       debuggerControl = defaultDebuggerControl();
     }
-
+    //用于在产生内存泄露室执行dump 内存heap
     HeapDumper heapDumper = this.heapDumper;
     if (heapDumper == null) {
       heapDumper = defaultHeapDumper();
     }
-
+    //执行内存泄露检测的executor
     WatchExecutor watchExecutor = this.watchExecutor;
     if (watchExecutor == null) {
       //创建默认的监听内存泄漏的线程池
       watchExecutor = defaultWatchExecutor();
     }
-
+    //用于在判断内存泄露之前，再给一次GC的机会
     GcTrigger gcTrigger = this.gcTrigger;
     if (gcTrigger == null) {
       gcTrigger = defaultGcTrigger();
