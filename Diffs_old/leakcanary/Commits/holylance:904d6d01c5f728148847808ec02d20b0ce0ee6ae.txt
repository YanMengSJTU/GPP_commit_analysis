diff --git a/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidExcludedRefs.kt
similarity index 92%
rename from leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt
rename to leakcanary-analyzer/src/main/java/leakcanary/AndroidExcludedRefs.kt
index 0bab26f7..edd40ad8 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AndroidExcludedRefs.kt
@@ -15,26 +15,12 @@
  */
 package leakcanary
 
-import android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH
-import android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1
-import android.os.Build.VERSION_CODES.JELLY_BEAN
-import android.os.Build.VERSION_CODES.JELLY_BEAN_MR2
-import android.os.Build.VERSION_CODES.KITKAT
-import android.os.Build.VERSION_CODES.LOLLIPOP
-import android.os.Build.VERSION_CODES.LOLLIPOP_MR1
-import android.os.Build.VERSION_CODES.M
-import android.os.Build.VERSION_CODES.N
-import android.os.Build.VERSION_CODES.N_MR1
-import android.os.Build.VERSION_CODES.O
-import android.os.Build.VERSION_CODES.O_MR1
-import android.os.Build.VERSION_CODES.P
 import leakcanary.AndroidExcludedRefs.Companion.exclusionsFactory
 import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
 import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
 import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
 import leakcanary.Exclusion.Status.NEVER_REACHABLE
 import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
-import leakcanary.internal.HeapDumpTrigger
 import java.lang.ref.PhantomReference
 import java.lang.ref.SoftReference
 import java.lang.ref.WeakReference
@@ -62,7 +48,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt in KITKAT..LOLLIPOP) {
+      if (build.sdkInt in 19..21) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion(
@@ -82,7 +68,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt <= KITKAT) {
+      if (build.sdkInt <= 19) {
         val reason =
           ("Editor inserts a special span, which has a reference to the EditText. That span is a"
               + " NoCopySpan, which makes sure it gets dropped when creating a new"
@@ -119,7 +105,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt == LOLLIPOP) {
+      if (build.sdkInt == 21) {
         exclusions.add(
             Exclusion(
                 type = StaticFieldExclusion(
@@ -145,7 +131,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt <= LOLLIPOP_MR1) {
+      if (build.sdkInt <= 22) {
         exclusions.add(
             Exclusion(
                 type = StaticFieldExclusion("android.text.TextLine", "sCached"),
@@ -213,7 +199,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt in ICE_CREAM_SANDWICH_MR1..O_MR1) {
+      if (build.sdkInt in 15..27) {
         val reason = ("When we detach a view that receives keyboard input, the InputMethodManager"
             + " leaks a reference to it until a new view asks for keyboard input."
             + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
@@ -251,7 +237,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt in ICE_CREAM_SANDWICH_MR1..P) {
+      if (build.sdkInt in 15..28) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion(
@@ -273,7 +259,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt in ICE_CREAM_SANDWICH..LOLLIPOP_MR1) {
+      if (build.sdkInt in 14..22) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion(
@@ -294,7 +280,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt in JELLY_BEAN..N) {
+      if (build.sdkInt in 16..24) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion(
@@ -314,7 +300,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt == LOLLIPOP_MR1) {
+      if (build.sdkInt == 22) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion("android.widget.SpellChecker$1", "this$0"),
@@ -337,7 +323,7 @@ enum class AndroidExcludedRefs {
           + " ActivityChooserModelPolicy which can be an activity context."
           + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
           + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0")
-      if (build.sdkInt in ICE_CREAM_SANDWICH_MR1..LOLLIPOP_MR1) {
+      if (build.sdkInt in 15..22) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion(
@@ -364,7 +350,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt < LOLLIPOP) {
+      if (build.sdkInt < 21) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion(
@@ -385,7 +371,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt <= O_MR1) {
+      if (build.sdkInt <= 27) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion(
@@ -412,7 +398,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt <= LOLLIPOP_MR1) exclusions.add(
+      if (build.sdkInt <= 22) exclusions.add(
           Exclusion(
               type = InstanceFieldExclusion("android.media.MediaScannerConnection", "mContext"),
 
@@ -432,7 +418,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt in JELLY_BEAN_MR2..N_MR1) {
+      if (build.sdkInt in 18..25) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion("android.os.UserManager", "mContext"),
@@ -456,7 +442,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt < LOLLIPOP_MR1) {
+      if (build.sdkInt < 22) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion(
@@ -479,7 +465,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt <= LOLLIPOP_MR1) {
+      if (build.sdkInt <= 22) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion("android.media.AudioManager$1", "this$0"),
@@ -503,7 +489,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt <= LOLLIPOP_MR1) {
+      if (build.sdkInt <= 22) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion("android.widget.Editor\$Blink", "this$0"),
@@ -528,7 +514,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt <= M) {
+      if (build.sdkInt <= 23) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion("android.net.ConnectivityManager", "sInstance"),
@@ -556,7 +542,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt in O..O_MR1) {
+      if (build.sdkInt in 26..27) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion(
@@ -581,7 +567,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt in N..O) {
+      if (build.sdkInt in 24..26) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion(
@@ -603,7 +589,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt == P) {
+      if (build.sdkInt == 28) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion(
@@ -625,7 +611,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.sdkInt == N) {
+      if (build.sdkInt == 24) {
         val reason =
           ("TextToSpeech.shutdown() does not release its references to context objects." +
               " Furthermore, TextToSpeech instances cannot be garbage collected due to other process" +
@@ -657,7 +643,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.manufacturer == MEIZU && build.sdkInt in LOLLIPOP..LOLLIPOP_MR1) {
+      if (build.manufacturer == MEIZU && build.sdkInt in 21..22) {
         exclusions.add(
             Exclusion(
                 type = StaticFieldExclusion("android.app.Instrumentation", "mRecommendActivity"),
@@ -676,7 +662,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.manufacturer == MOTOROLA && build.sdkInt in KITKAT..LOLLIPOP_MR1) {
+      if (build.manufacturer == MOTOROLA && build.sdkInt in 19..22) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion(
@@ -698,7 +684,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt == KITKAT) {
+      if (build.manufacturer == SAMSUNG && build.sdkInt == 19) {
         exclusions.add(
             Exclusion(
                 type = StaticFieldExclusion(
@@ -717,7 +703,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.manufacturer == HUAWEI && build.sdkInt in N..N_MR1) {
+      if (build.manufacturer == HUAWEI && build.sdkInt in 24..25) {
         exclusions.add(
             Exclusion(
                 type = StaticFieldExclusion("android.gestureboost.GestureBoostManager", "mContext"),
@@ -734,7 +720,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.manufacturer == HUAWEI && build.sdkInt in M..O_MR1) {
+      if (build.manufacturer == HUAWEI && build.sdkInt in 23..27) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion(
@@ -753,7 +739,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt in KITKAT..LOLLIPOP) {
+      if (build.manufacturer == SAMSUNG && build.sdkInt in 19..21) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion(
@@ -776,7 +762,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt in KITKAT..N) {
+      if (build.manufacturer == SAMSUNG && build.sdkInt in 19..24) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion(
@@ -796,7 +782,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt in KITKAT..N) {
+      if (build.manufacturer == SAMSUNG && build.sdkInt in 19..24) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion(
@@ -815,7 +801,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.manufacturer == LG && build.sdkInt in KITKAT..LOLLIPOP) {
+      if (build.manufacturer == LG && build.sdkInt in 19..21) {
         exclusions.add(
             Exclusion(
                 type = StaticFieldExclusion("android.widget.BubblePopupHelper", "sHelper"),
@@ -832,7 +818,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.manufacturer == LG && build.sdkInt == LOLLIPOP) {
+      if (build.manufacturer == LG && build.sdkInt == 21) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion("com.lge.systemservice.core.LGContext", "mContext"),
@@ -851,7 +837,7 @@ enum class AndroidExcludedRefs {
       // AwResource#setResources() is called with resources that hold a reference to the
       // activity context (instead of the application context) and doesn't clear it.
       // Not sure what's going on there, input welcome.
-      if (build.manufacturer == SAMSUNG && build.sdkInt == KITKAT) {
+      if (build.manufacturer == SAMSUNG && build.sdkInt == 19) {
         exclusions.add(
             Exclusion(
                 type = StaticFieldExclusion(
@@ -868,7 +854,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.manufacturer == NVIDIA && build.sdkInt == KITKAT) {
+      if (build.manufacturer == NVIDIA && build.sdkInt == 19) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion(
@@ -889,7 +875,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt in KITKAT..O) {
+      if (build.manufacturer == SAMSUNG && build.sdkInt in 19..26) {
         exclusions.add(
             Exclusion(
                 type = StaticFieldExclusion("android.widget.TextView", "mLastHoveredView"),
@@ -906,7 +892,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt == KITKAT) {
+      if (build.manufacturer == SAMSUNG && build.sdkInt == 19) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion("android.os.PersonaManager", "mContext"),
@@ -925,7 +911,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt == KITKAT) {
+      if (build.manufacturer == SAMSUNG && build.sdkInt == 19) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion("android.content.res.Resources", "mContext"),
@@ -945,7 +931,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt == KITKAT) {
+      if (build.manufacturer == SAMSUNG && build.sdkInt == 19) {
         exclusions.add(
             Exclusion(
                 type = InstanceFieldExclusion("android.view.ViewConfiguration", "mContext"),
@@ -966,8 +952,8 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if ((build.manufacturer == LENOVO && build.sdkInt == KITKAT) ||
-          (build.manufacturer == VIVO && build.sdkInt == LOLLIPOP_MR1)
+      if ((build.manufacturer == LENOVO && build.sdkInt == 19) ||
+          (build.manufacturer == VIVO && build.sdkInt == 22)
       ) {
         exclusions.add(
             Exclusion(
@@ -989,7 +975,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt == KITKAT) {
+      if (build.manufacturer == SAMSUNG && build.sdkInt == 19) {
         exclusions.add(
             Exclusion(
                 type = StaticFieldExclusion("android.media.AudioManager", "mContext_static"),
@@ -1008,7 +994,7 @@ enum class AndroidExcludedRefs {
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt == LOLLIPOP_MR1) {
+      if (build.manufacturer == SAMSUNG && build.sdkInt == 22) {
         exclusions.add(
             Exclusion(
                 type = StaticFieldExclusion("android.app.ActivityManager", "mContext"),
@@ -1038,7 +1024,9 @@ enum class AndroidExcludedRefs {
       )
       exclusions.add(
           Exclusion(
-              type = InstanceFieldExclusion(KeyedWeakReference::class.java.name, "referent"),
+              type = InstanceFieldExclusion(
+                  KeyedWeakReference::class.java.name, "referent"
+              ),
               status = NEVER_REACHABLE
           )
       )
@@ -1143,7 +1131,7 @@ enum class AndroidExcludedRefs {
     ) {
       exclusions.add(
           Exclusion(
-              type = JavaLocalExclusion(HeapDumpTrigger.LEAK_CANARY_THREAD_NAME),
+              type = JavaLocalExclusion(LEAK_CANARY_THREAD_NAME),
               status = NEVER_REACHABLE
           )
       )
@@ -1221,6 +1209,7 @@ enum class AndroidExcludedRefs {
   }
 }
 
+private const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
 private const val SAMSUNG = "samsung"
 private const val MOTOROLA = "motorola"
 private const val LENOVO = "LENOVO"
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidLabelers.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidLabelers.kt
new file mode 100644
index 00000000..f882c5ea
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AndroidLabelers.kt
@@ -0,0 +1,26 @@
+package leakcanary
+
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+
+enum class AndroidLabelers : Labeler {
+
+  FRAGMENT_LABELER {
+    override fun invoke(
+      parser: HprofParser,
+      node: LeakNode
+    ): List<String> = with(HprofGraph(parser)) {
+      val record = ObjectReference(node.instance)
+          .record
+      if (record instanceOf "androidx.fragment.app.Fragment" || record instanceOf "android.app.Fragment") {
+        record as InstanceDumpRecord
+        val mTag = record["mTag"].record.string
+        if (!mTag.isNullOrEmpty()) {
+          return listOf("Fragment.mTag=$mTag")
+        }
+      }
+      return emptyList()
+    }
+  };
+
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/AndroidLeakInspectors.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakInspectors.kt
similarity index 91%
rename from leakcanary-android-core/src/main/java/leakcanary/AndroidLeakInspectors.kt
rename to leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakInspectors.kt
index d2e754f6..9ef74e9d 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/AndroidLeakInspectors.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakInspectors.kt
@@ -15,12 +15,6 @@
  */
 package leakcanary
 
-import android.app.Activity
-import android.app.Application
-import android.app.Dialog
-import android.app.Fragment
-import android.os.MessageQueue
-import android.view.View
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
 import kotlin.reflect.KClass
@@ -43,7 +37,7 @@ enum class AndroidLeakInspectors : LeakInspector {
       parser: HprofParser,
       node: LeakNode
     ): LeakNodeStatusAndReason =
-      (parser to node).instanceOfOrUnknown(View::class) { instance ->
+      (parser to node).instanceOfOrUnknown("android.view.View") { instance ->
         // This skips edge cases like Toast$TN.mNextView holding on to an unattached and unparented
         // next toast view
         if (instance["mParent"].reference == null) {
@@ -63,7 +57,7 @@ enum class AndroidLeakInspectors : LeakInspector {
       parser: HprofParser,
       node: LeakNode
     ): LeakNodeStatusAndReason =
-      (parser to node).instanceOfOrUnknown(Activity::class) { instance ->
+      (parser to node).instanceOfOrUnknown("android.app.Activity") { instance ->
         instance.leakingWhenTrue("mDestroyed")
       }
   },
@@ -73,7 +67,7 @@ enum class AndroidLeakInspectors : LeakInspector {
       parser: HprofParser,
       node: LeakNode
     ): LeakNodeStatusAndReason =
-      (parser to node).instanceOfOrUnknown(Dialog::class) { instance ->
+      (parser to node).instanceOfOrUnknown("android.app.Dialog") { instance ->
         instance.leakingWhenNull("mDecor")
       }
   },
@@ -83,7 +77,7 @@ enum class AndroidLeakInspectors : LeakInspector {
       parser: HprofParser,
       node: LeakNode
     ): LeakNodeStatusAndReason = with(parser) {
-      return if (node.instance.objectRecord.isInstanceOf(Application::class)) {
+      return if (node.instance.objectRecord.isInstanceOf("android.app.Application")) {
         LeakNodeStatus.notLeaking("Application is a singleton")
       } else LeakNodeStatus.unknown()
     }
@@ -117,7 +111,7 @@ enum class AndroidLeakInspectors : LeakInspector {
       parser: HprofParser,
       node: LeakNode
     ): LeakNodeStatusAndReason =
-      (parser to node).instanceOfOrUnknown(Fragment::class) { instance ->
+      (parser to node).instanceOfOrUnknown("android.app.Fragment") { instance ->
         instance.leakingWhenNull("mFragmentManager")
       }
   },
@@ -137,7 +131,7 @@ enum class AndroidLeakInspectors : LeakInspector {
       parser: HprofParser,
       node: LeakNode
     ): LeakNodeStatusAndReason =
-      (parser to node).instanceOfOrUnknown(MessageQueue::class) { instance ->
+      (parser to node).instanceOfOrUnknown("android.os.MessageQueue") { instance ->
         // If the queue is not quitting, maybe it should actually have been, we don't know.
         // However, if it's quitting, it is very likely that's not a bug.
         when (instance["mQuitting"].boolean) {
@@ -194,7 +188,9 @@ enum class AndroidLeakInspectors : LeakInspector {
       node: LeakNode
     ): LeakNodeStatusAndReason = with(parser) {
       return if (node.instance.objectRecord.isInstanceOf("android.widget.Toast\$TN")) {
-        LeakNodeStatus.notLeaking("Toast.TN (Transient Notification) is never leaking")
+        LeakNodeStatus.notLeaking(
+            "Toast.TN (Transient Notification) is never leaking"
+        )
       } else LeakNodeStatus.unknown()
     }
   };
diff --git a/leakcanary-android-core/src/main/java/leakcanary/BuildMirror.kt b/leakcanary-analyzer/src/main/java/leakcanary/BuildMirror.kt
similarity index 100%
rename from leakcanary-android-core/src/main/java/leakcanary/BuildMirror.kt
rename to leakcanary-analyzer/src/main/java/leakcanary/BuildMirror.kt
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
index ca2d78e7..1168e02e 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
@@ -32,6 +32,7 @@ import leakcanary.GcRoot.ReferenceCleanup
 import leakcanary.GcRoot.StickyClass
 import leakcanary.GcRoot.ThreadBlock
 import leakcanary.GcRoot.ThreadObject
+import leakcanary.HeapValue.ObjectReference
 import leakcanary.HprofParser.RecordCallbacks
 import leakcanary.LeakNode.ChildNode
 import leakcanary.LeakNodeStatus.LEAKING
@@ -41,6 +42,7 @@ import leakcanary.LeakTraceElement.Holder.ARRAY
 import leakcanary.LeakTraceElement.Holder.CLASS
 import leakcanary.LeakTraceElement.Holder.OBJECT
 import leakcanary.LeakTraceElement.Holder.THREAD
+import leakcanary.ObjectIdMetadata.STRING
 import leakcanary.Record.HeapDumpRecord.GcRootRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
@@ -105,7 +107,9 @@ class HeapAnalyzer constructor(
             )
             val analysisResults = mutableMapOf<String, RetainedInstance>()
             listener.onProgressUpdate(FINDING_WATCHED_REFERENCES)
-            val (retainedKeys, heapDumpUptimeMillis) = readHeapDumpMemoryStore(parser)
+            val (retainedKeys, heapDumpUptimeMillis) = readHeapDumpMemoryStore(
+                parser, keyedWeakReferenceInstances
+            )
 
             if (retainedKeys.isEmpty()) {
               val exception = IllegalStateException("No retained keys found in heap dump")
@@ -170,6 +174,8 @@ class HeapAnalyzer constructor(
         .on(InstanceDumpRecord::class.java) { record ->
           when (parser.className(record.classId)) {
             KeyedWeakReference::class.java.name -> keyedWeakReferenceInstances.add(record)
+            // Pre 2.0 KeyedWeakReference
+            "com.squareup.leakcanary.KeyedWeakReference" -> keyedWeakReferenceInstances.add(record)
             "sun.misc.Cleaner" -> if (computeRetainedSize) cleaners.add(record.id)
           }
         }
@@ -202,16 +208,35 @@ class HeapAnalyzer constructor(
   }
 
   private fun readHeapDumpMemoryStore(
-    parser: HprofParser
+    parser: HprofParser,
+    keyedWeakReferenceInstances: List<InstanceDumpRecord>
   ): Pair<MutableSet<Long>, Long> = with(parser) {
-    val heapDumpMemoryStoreClassId = parser.classId(HeapDumpMemoryStore::class.java.name)!!
-    val storeClass = parser.hydrateClassHierarchy(heapDumpMemoryStoreClassId)[0]
-    val retainedKeysRecord =
-      storeClass["retainedKeysForHeapDump"].reference!!.objectRecord as ObjectArrayDumpRecord
-
-    val retainedKeysForHeapDump = retainedKeysRecord.elementIds.toMutableSet()
-    val heapDumpUptimeMillis = storeClass["heapDumpUptimeMillis"].long!!
-    return retainedKeysForHeapDump to heapDumpUptimeMillis
+    val heapDumpMemoryStoreClassId = parser.classId(HeapDumpMemoryStore::class.java.name)
+
+    // Pre 2.0 had no HeapDumpMemoryStore, so instead we look for all KeyedWeakReference instances
+    if (heapDumpMemoryStoreClassId == null) {
+      val leakingWeakRefs = mutableListOf<KeyedWeakReferenceMirror>()
+      keyedWeakReferenceInstances.forEach { record ->
+        val weakRef =
+          KeyedWeakReferenceMirror.fromInstance(parser.hydrateInstance(record), 0)
+        if (weakRef.hasReferent) {
+          leakingWeakRefs.add(weakRef)
+        }
+      }
+
+      val retainedKeysForHeapDump = leakingWeakRefs.map { it.key.value }
+          .toMutableSet()
+      val heapDumpUptimeMillis = 0L
+      return retainedKeysForHeapDump to heapDumpUptimeMillis
+    } else {
+      val storeClass = parser.hydrateClassHierarchy(heapDumpMemoryStoreClassId)[0]
+      val retainedKeysRecord =
+        storeClass["retainedKeysForHeapDump"].reference!!.objectRecord as ObjectArrayDumpRecord
+
+      val retainedKeysForHeapDump = retainedKeysRecord.elementIds.toMutableSet()
+      val heapDumpUptimeMillis = storeClass["heapDumpUptimeMillis"].long!!
+      return retainedKeysForHeapDump to heapDumpUptimeMillis
+    }
   }
 
   private fun findLeakingReferences(
@@ -234,8 +259,12 @@ class HeapAnalyzer constructor(
           leakingWeakRefs.add(weakRef)
         } else {
           val key = parser.retrieveString(weakRef.key)
-          val name = parser.retrieveString(weakRef.name)
-          val className = parser.retrieveString(weakRef.className)
+          val name =
+            if (weakRef.name != null) parser.retrieveString(weakRef.name) else UNKNOWN_LEGACY
+          val className =
+            if (weakRef.className != null) parser.retrieveString(
+                weakRef.className
+            ) else UNKNOWN_LEGACY
           val noLeak = WeakReferenceCleared(key, name, className, weakRef.watchDurationMillis)
           analysisResults[key] = noLeak
         }
@@ -413,7 +442,9 @@ class HeapAnalyzer constructor(
       val key = parser.retrieveString(weakReference.key)
       val leakDetected = LeakingInstance(
           referenceKey = key,
-          referenceName = parser.retrieveString(weakReference.name),
+          referenceName = if (weakReference.name != null) parser.retrieveString(
+              weakReference.name
+          ) else UNKNOWN_LEGACY,
           instanceClassName = instanceClassName,
           watchDurationMillis = weakReference.watchDurationMillis,
           exclusionStatus = pathResult.exclusionStatus, leakTrace = leakTrace,
@@ -424,14 +455,18 @@ class HeapAnalyzer constructor(
   }
 
   private fun addRemainingInstancesWithNoPath(
-    hprofParser: HprofParser,
+    parser: HprofParser,
     leakingWeakRefs: List<KeyedWeakReferenceMirror>,
     analysisResults: MutableMap<String, RetainedInstance>
   ) {
     leakingWeakRefs.forEach { refWithNoPath ->
-      val key = hprofParser.retrieveString(refWithNoPath.key)
-      val name = hprofParser.retrieveString(refWithNoPath.name)
-      val className = hprofParser.retrieveString(refWithNoPath.className)
+      val key = parser.retrieveString(refWithNoPath.key)
+      val name = if (refWithNoPath.name != null) parser.retrieveString(
+          refWithNoPath.name
+      ) else UNKNOWN_LEGACY
+      val className = if (refWithNoPath.className != null) parser.retrieveString(
+          refWithNoPath.className
+      ) else UNKNOWN_LEGACY
       val noLeak = NoPathToInstance(key, name, className, refWithNoPath.watchDurationMillis)
       analysisResults[key] = noLeak
     }
@@ -640,6 +675,7 @@ class HeapAnalyzer constructor(
   }
 
   companion object {
+    private const val UNKNOWN_LEGACY = "Unknown (legacy)"
     private const val ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$"
     internal val ANONYMOUS_CLASS_NAME_PATTERN_REGEX = ANONYMOUS_CLASS_NAME_PATTERN.toRegex()
   }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
index 39105bd4..ed9d9b38 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
@@ -6,8 +6,10 @@ import leakcanary.HydratedInstance
 
 internal class KeyedWeakReferenceMirror(
   val key: ObjectReference,
-  val name: ObjectReference,
-  val className: ObjectReference,
+    // The className field does not exist in pre 1.0 heap dumps.
+  val name: ObjectReference?,
+    // The className field does not exist in pre 2.0 heap dumps.
+  val className: ObjectReference?,
   val watchDurationMillis: Long,
   val referent: ObjectReference
 ) {
@@ -19,13 +21,16 @@ internal class KeyedWeakReferenceMirror(
       weakRef: HydratedInstance,
       heapDumpUptimeMillis: Long
     ): KeyedWeakReferenceMirror {
+      // The watchUptimeMillis field does not exist in pre 2.0 heap dumps.
+      val watchUptimeMillis = weakRef.fieldValueOrNull<LongValue>(
+          "watchUptimeMillis"
+      )
+          ?.value ?: 0
       return KeyedWeakReferenceMirror(
           key = weakRef.fieldValue("key"),
-          name = weakRef.fieldValue("name"),
-          className = weakRef.fieldValue("className"),
-          watchDurationMillis = heapDumpUptimeMillis - weakRef.fieldValue<LongValue>(
-              "watchUptimeMillis"
-          ).value,
+          name = weakRef.fieldValueOrNull("name"),
+          className = weakRef.fieldValueOrNull("className"),
+          watchDurationMillis = heapDumpUptimeMillis - watchUptimeMillis,
           referent = weakRef.fieldValue("referent")
       )
     }
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
new file mode 100644
index 00000000..38accd4d
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
@@ -0,0 +1,67 @@
+package leakcanary.internal
+
+import leakcanary.AndroidExcludedRefs
+import leakcanary.AndroidLabelers
+import leakcanary.AndroidLeakInspectors
+import leakcanary.HeapAnalysis
+import leakcanary.HeapAnalysisFailure
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.LeakingInstance
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import java.io.File
+
+class LegacyHprofTest {
+
+  @Test fun preM() {
+    val analysis = analyzeHprof("leak_asynctask_pre_m.hprof")
+
+    assertThat(analysis.retainedInstances).hasSize(2)
+    val leak1 = analysis.retainedInstances[0] as LeakingInstance
+    val leak2 = analysis.retainedInstances[1] as LeakingInstance
+    assertThat(leak1.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
+    assertThat(leak2.instanceClassName).isEqualTo("android.graphics.Bitmap")
+  }
+
+  @Test fun androidM() {
+    val analysis = analyzeHprof("leak_asynctask_m.hprof")
+
+    assertThat(analysis.retainedInstances).hasSize(1)
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
+  }
+
+  @Test fun androidO() {
+    val analysis = analyzeHprof("leak_asynctask_o.hprof")
+
+    assertThat(analysis.retainedInstances).hasSize(1)
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
+  }
+
+  @Test fun gcRootInNonPrimaryHeap() {
+    val analysis = analyzeHprof("gc_root_in_non_primary_heap.hprof")
+
+    assertThat(analysis.retainedInstances).hasSize(1)
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
+  }
+
+  private fun analyzeHprof(fileName: String): HeapAnalysisSuccess {
+    val classLoader = Thread.currentThread()
+        .contextClassLoader
+    val url = classLoader.getResource(fileName)
+    val hprofFile = File(url.path)
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysis>(
+        labelers = AndroidLabelers.values().toList(),
+        leakInspectors = AndroidLeakInspectors.defaultAndroidInspectors(),
+        exclusionsFactory = AndroidExcludedRefs.exclusionsFactory(AndroidExcludedRefs.appDefaults)
+    )
+    if (analysis is HeapAnalysisFailure) {
+      print(analysis)
+    }
+    return analysis as HeapAnalysisSuccess
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/resources/gc_root_in_non_primary_heap.hprof b/leakcanary-analyzer/src/test/resources/gc_root_in_non_primary_heap.hprof
new file mode 100644
index 00000000..7ca6d0bc
Binary files /dev/null and b/leakcanary-analyzer/src/test/resources/gc_root_in_non_primary_heap.hprof differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_m.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_m.hprof
new file mode 100644
index 00000000..6945c82d
Binary files /dev/null and b/leakcanary-analyzer/src/test/resources/leak_asynctask_m.hprof differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_o.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_o.hprof
new file mode 100644
index 00000000..1c62d0e5
Binary files /dev/null and b/leakcanary-analyzer/src/test/resources/leak_asynctask_o.hprof differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_pre_m.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_pre_m.hprof
new file mode 100644
index 00000000..a1d60adc
Binary files /dev/null and b/leakcanary-analyzer/src/test/resources/leak_asynctask_pre_m.hprof differ
diff --git a/leakcanary-android-core/src/main/java/leakcanary/AndroidLabelers.kt b/leakcanary-android-core/src/main/java/leakcanary/AndroidLabelers.kt
deleted file mode 100644
index a8498481..00000000
--- a/leakcanary-android-core/src/main/java/leakcanary/AndroidLabelers.kt
+++ /dev/null
@@ -1,99 +0,0 @@
-package leakcanary
-
-import android.app.Application
-import android.content.res.Resources.NotFoundException
-import android.view.View
-import leakcanary.HeapValue.IntValue
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import java.util.ArrayList
-
-enum class AndroidLabelers : Labeler {
-
-  FRAGMENT_LABELER {
-    override fun invoke(
-      parser: HprofParser,
-      node: LeakNode
-    ): List<String> = with(HprofGraph(parser)) {
-      val record = ObjectReference(node.instance).record
-      if (record instanceOf "androidx.fragment.app.Fragment" || record instanceOf "android.app.Fragment") {
-        record as InstanceDumpRecord
-        val mTag = record["mTag"].record.string
-        if (!mTag.isNullOrEmpty()) {
-          return listOf("Fragment.mTag=$mTag")
-        }
-      }
-      return emptyList()
-    }
-  };
-
-  class ViewLabeler(
-    private val application: Application
-  ) : Labeler {
-    override fun invoke(
-      parser: HprofParser,
-      node: LeakNode
-    ): List<String> = with(HprofGraph(parser)) {
-      val record = ObjectReference(node.instance).record
-
-      if (record instanceOf View::class) {
-        val viewLabels = mutableListOf<String>()
-        record as InstanceDumpRecord
-        val mAttachInfo = record["mAttachInfo"]
-        if (mAttachInfo != null) {
-          if (mAttachInfo.isNullReference) {
-            viewLabels.add("View#mAttachInfo is null (view detached)")
-          } else {
-            viewLabels.add("View#mAttachInfo is not null (view attached)")
-          }
-        }
-
-        val mParent = record["mParent"]
-        if (mParent != null) {
-          if (mParent.isNullReference) {
-            viewLabels.add("View#mParent is null")
-          } else {
-            viewLabels.add("View#mParent is set")
-          }
-        }
-
-        val mID = record["mId"]
-        if (mID is IntValue) {
-          if (mID.value != 0) {
-            try {
-              val name = application.resources.getResourceEntryName(mID.value)
-              viewLabels.add("View.mID=R.id.$name (${mID.value})")
-            } catch (ignored: NotFoundException) {
-              viewLabels.add("View.mID=${mID.value} (name not found)")
-            }
-          } else {
-            viewLabels.add("View.mID=0")
-          }
-        }
-
-        val mWindowAttachCount = record["mWindowAttachCount"]
-
-        if (mWindowAttachCount is IntValue) {
-          viewLabels.add("View.mWindowAttachCount=${mWindowAttachCount.value}")
-        }
-        return viewLabels
-      }
-      return emptyList()
-    }
-  }
-
-  companion object {
-    fun defaultAndroidLabelers(application: Application): List<Labeler> {
-      val labelers = ArrayList<Labeler>()
-      labelers.add(InstanceDefaultLabeler)
-      labelers.add(
-          ViewLabeler(
-              application
-          )
-      )
-      labelers.addAll(values())
-      return labelers
-    }
-  }
-
-}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
index 7e77630b..d9c4babb 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -4,6 +4,7 @@ import android.app.Application
 import android.content.Intent
 import leakcanary.AndroidExcludedRefs.Companion.exclusionsFactory
 import leakcanary.internal.InternalLeakCanary
+import java.util.ArrayList
 
 typealias AnalysisResultListener = (Application, HeapAnalysis) -> Unit
 
@@ -40,7 +41,7 @@ object LeakCanary {
      */
     val computeRetainedHeapSize: Boolean = false,
     val leakInspectors: List<LeakInspector> = AndroidLeakInspectors.defaultAndroidInspectors(),
-    val labelers: List<Labeler> = AndroidLabelers.defaultAndroidLabelers(
+    val labelers: List<Labeler> = defaultAndroidLabelers(
         InternalLeakCanary.application
     ),
     /**
@@ -58,4 +59,16 @@ object LeakCanary {
   /** [Intent] that can be used to programmatically launch the leak display activity. */
   val leakDisplayActivityIntent
     get() = InternalLeakCanary.leakDisplayActivityIntent
+
+  fun defaultAndroidLabelers(application: Application): List<Labeler> {
+    val labelers = ArrayList<Labeler>()
+    labelers.add(InstanceDefaultLabeler)
+    labelers.add(
+        ViewLabeler(
+            application
+        )
+    )
+    labelers.addAll(AndroidLabelers.values())
+    return labelers
+  }
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/ViewLabeler.kt b/leakcanary-android-core/src/main/java/leakcanary/ViewLabeler.kt
new file mode 100644
index 00000000..398181f0
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/ViewLabeler.kt
@@ -0,0 +1,63 @@
+package leakcanary
+
+import android.app.Application
+import android.content.res.Resources.NotFoundException
+import leakcanary.HeapValue.IntValue
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+
+class ViewLabeler(
+  private val application: Application
+) : Labeler {
+  override fun invoke(
+    parser: HprofParser,
+    node: LeakNode
+  ): List<String> = with(HprofGraph(parser)) {
+    val record = ObjectReference(node.instance)
+        .record
+
+    if (record instanceOf "android.view.View") {
+      val viewLabels = mutableListOf<String>()
+      record as InstanceDumpRecord
+      val mAttachInfo = record["mAttachInfo"]
+      if (mAttachInfo != null) {
+        if (mAttachInfo.isNullReference) {
+          viewLabels.add("View#mAttachInfo is null (view detached)")
+        } else {
+          viewLabels.add("View#mAttachInfo is not null (view attached)")
+        }
+      }
+
+      val mParent = record["mParent"]
+      if (mParent != null) {
+        if (mParent.isNullReference) {
+          viewLabels.add("View#mParent is null")
+        } else {
+          viewLabels.add("View#mParent is set")
+        }
+      }
+
+      val mID = record["mId"]
+      if (mID is IntValue) {
+        if (mID.value != 0) {
+          try {
+            val name = application.resources.getResourceEntryName(mID.value)
+            viewLabels.add("View.mID=R.id.$name (${mID.value})")
+          } catch (ignored: NotFoundException) {
+            viewLabels.add("View.mID=${mID.value} (name not found)")
+          }
+        } else {
+          viewLabels.add("View.mID=0")
+        }
+      }
+
+      val mWindowAttachCount = record["mWindowAttachCount"]
+
+      if (mWindowAttachCount is IntValue) {
+        viewLabels.add("View.mWindowAttachCount=${mWindowAttachCount.value}")
+      }
+      return viewLabels
+    }
+    return emptyList()
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
index a40f711b..ab5d9fd5 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -248,7 +248,6 @@ internal class HeapDumpTrigger(
   }
 
   companion object {
-    const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
     private const val WAIT_FOR_DEBUG_MILLIS = 20_000L
     private const val WAIT_AFTER_DUMP_FAILED_MILLIS = 5_000L
     private const val WAIT_FOR_INSTANCE_THRESHOLD_MILLIS = 5_000L
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
index 7b96e942..88877522 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -51,7 +51,7 @@ internal object InternalLeakCanary : LeakSentryListener {
 
     val configProvider = { LeakCanary.config }
 
-    val handlerThread = HandlerThread(HeapDumpTrigger.LEAK_CANARY_THREAD_NAME)
+    val handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)
     handlerThread.start()
     val backgroundHandler = Handler(handlerThread.looper)
 
@@ -181,4 +181,6 @@ internal object InternalLeakCanary : LeakSentryListener {
       heapDumpTrigger.onDumpHeapReceived()
     }
   }
+
+  const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
index 65418a1e..d5d67d06 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
@@ -205,7 +205,7 @@ internal object LeakingInstanceTable {
             val groupLeakTrace = if (leakingInstance.exclusionStatus == WONT_FIX_LEAK) {
               val index = leakTrace.elements.indexOfFirst { element -> element.exclusion != null }
               LeakTrace(
-                  elements = listOf(leakTrace.elements[index])
+                  elements = listOf(leakTrace.elements[index].copy(labels = emptyList()))
               )
             } else {
               val elements = mutableListOf<LeakTraceElement>()
@@ -216,7 +216,9 @@ internal object LeakingInstanceTable {
                   val reference = element.reference!!
                   if (reference.type == ARRAY_ENTRY) {
                     // No array index in groups
-                    element = element.copy(reference = reference.copy(name = "x"))
+                    element = element.copy(reference = reference.copy(name = "x"), labels = emptyList())
+                  } else {
+                    element = element.copy(labels = emptyList())
                   }
 
                   elements.add(element)
