diff --git a/build.gradle b/build.gradle
index ed183988..7a6154c4 100644
--- a/build.gradle
+++ b/build.gradle
@@ -18,12 +18,11 @@ buildscript {
           core: 'androidx.core:core:1.0.1',
           fragment  : 'androidx.fragment:fragment:1.0.0',
           test      : [
-              core    : 'androidx.test:core:1.1.0',
-              espresso: 'androidx.test.espresso:espresso-core:3.1.1',
-              rules   : 'androidx.test:rules:1.1.1',
-              runner  : 'androidx.test:runner:1.1.1',
+              core    : 'androidx.test:core:1.0.0',
+              espresso: 'androidx.test.espresso:espresso-core:3.1.0',
+              rules   : 'androidx.test:rules:1.1.0',
+              runner  : 'androidx.test:runner:1.1.0',
           ],
-          benchmark : 'androidx.benchmark:benchmark:1.0.0-alpha01'
       ],
       junit         : 'junit:junit:4.12',
       kotlin        : [
diff --git a/docs/upgrading-to-leakcanary-2.0.md b/docs/upgrading-to-leakcanary-2.0.md
index 61867055..480b6745 100644
--- a/docs/upgrading-to-leakcanary-2.0.md
+++ b/docs/upgrading-to-leakcanary-2.0.md
@@ -88,7 +88,7 @@ dependencies {
 * You can use it to count how many instances are retained, for instance to add metadata to OutOfMemoryError crashes:
 
 ```kotlin
-val retainedInstanceCount = LeakSentry.refWatcher.retainedKeys.size
+val retainedInstanceCount = LeakSentry.refWatcher.retainedInstanceCount
 ```
 
 ### Option 2: Make your own `RefWatcher` interface
@@ -96,18 +96,18 @@ val retainedInstanceCount = LeakSentry.refWatcher.retainedKeys.size
 ```kotlin
 // In shared code
 interface MaybeRefWatcher {
-  fun watch(watchedReference: Any)
+  fun watch(watchedInstance: Any)
 
   object None : MaybeRefWatcher {
-    override fun watch(watchedReference: Any) {
+    override fun watch(watchedInstance: Any) {
     }
   }
 }
 
 // In debug code
 class RealRefWatcher : MaybeRefWatcher {
-  override fun watch(watchedReference: Any) {
-    LeakSentry.refWatcher.watch(watchedReference)
+  override fun watch(watchedInstance: Any) {
+    LeakSentry.refWatcher.watch(watchedInstance)
   }
 }
 ```
@@ -203,6 +203,78 @@ android {
 
 No code is necessary.
 
+## Analysis listener / uploading to a server
+
+### Before
+
+
+```java
+public class LeakUploadService extends DisplayLeakService {
+  @Override protected void afterDefaultHandling(HeapDump heapDump, AnalysisResult result, String leakInfo) {
+    // TODO Upload result to server
+  }
+}
+```
+
+```java
+RefWatcher refWatcher = LeakCanary.refWatcher(this)
+  .listenerServiceClass(LeakUploadService.class);
+  .buildAndInstall();
+```
+
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    >
+  <application android:name="com.example.DebugExampleApplication">
+    <service android:name="com.example.LeakUploadService" />
+  </application>
+</manifest>
+```
+
+### Now
+
+```Kotlin
+LeakCanary.config = LeakCanary.config.copy(
+    analysisResultListener = { application, heapAnalysis ->
+      // TODO Upload result to server
+      DefaultAnalysisResultListener(application, heapAnalysis)
+    }
+)
+```
+
+### Marking known framework leaks as won't fix
+
+### Before
+
+```java
+ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults()
+    .instanceField("com.example.ExampleClass", "exampleField")
+    .build();
+RefWatcher refWatcher = LeakCanary.refWatcher(this)
+  .excludedRefs(excludedRefs)
+  .buildAndInstall();
+}
+```
+
+### Now
+
+```kotlin
+LeakCanary.config = LeakCanary.config.copy(
+  exclusionsFactory = { parser ->
+    val build = BuildMirror.readFromHprof(parser)
+    val exclusions =
+      AndroidExcludedRefs.exclusionsMatchingBuild(AndroidExcludedRefs.appDefaults, build)
+          .toMutableList()
+    exclusions += Exclusion(
+        type = InstanceFieldExclusion("com.example.ExampleClass", "exampleField")
+    )
+    exclusions
+  }
+)
+```
+
 ## Public API packages
 
 ### Before
diff --git a/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt b/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt
index f73f308c..8c24a7d1 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt
@@ -4,8 +4,8 @@ import android.app.Application
 import com.squareup.leakcanary.core.R
 import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.Exclusion.Status.WONT_FIX_LEAK
-import leakcanary.internal.Notifications
 import leakcanary.internal.NotificationType.LEAKCANARY_RESULT
+import leakcanary.internal.Notifications
 import leakcanary.internal.activity.LeakActivity
 import leakcanary.internal.activity.db.HeapAnalysisTable
 import leakcanary.internal.activity.db.LeakingInstanceTable
@@ -14,10 +14,6 @@ import leakcanary.internal.activity.screen.GroupListScreen
 import leakcanary.internal.activity.screen.HeapAnalysisFailureScreen
 import leakcanary.internal.activity.screen.HeapAnalysisListScreen
 import leakcanary.internal.activity.screen.HeapAnalysisSuccessScreen
-import java.io.File
-import java.text.SimpleDateFormat
-import java.util.Date
-import java.util.Locale
 
 object DefaultAnalysisResultListener : AnalysisResultListener {
   override fun invoke(
@@ -28,16 +24,9 @@ object DefaultAnalysisResultListener : AnalysisResultListener {
     // TODO better log that include leakcanary version, exclusions, etc.
     CanaryLog.d("%s", heapAnalysis)
 
-    val movedHeapDump = renameHeapdump(heapAnalysis.heapDumpFile)
-
-    val updatedHeapAnalysis = when (heapAnalysis) {
-      is HeapAnalysisFailure -> heapAnalysis.copy(heapDumpFile = movedHeapDump)
-      is HeapAnalysisSuccess -> heapAnalysis.copy(heapDumpFile = movedHeapDump)
-    }
-
     val (id, groupProjections) = LeaksDbHelper(application)
         .writableDatabase.use { db ->
-      val id = HeapAnalysisTable.insert(db, updatedHeapAnalysis)
+      val id = HeapAnalysisTable.insert(db, heapAnalysis)
       id to LeakingInstanceTable.retrieveAllByHeapAnalysisId(db, id)
     }
 
@@ -81,17 +70,4 @@ object DefaultAnalysisResultListener : AnalysisResultListener {
         LEAKCANARY_RESULT
     )
   }
-
-  private fun renameHeapdump(heapDumpFile: File): File {
-    val fileName = SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'.hprof'", Locale.US).format(Date())
-
-    val newFile = File(heapDumpFile.parent, fileName)
-    val renamed = heapDumpFile.renameTo(newFile)
-    if (!renamed) {
-      CanaryLog.d(
-          "Could not rename heap dump file %s to %s", heapDumpFile.path, newFile.path
-      )
-    }
-    return newFile
-  }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
index d9c4babb..aba12f5b 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -33,13 +33,6 @@ object LeakCanary {
     val exclusionsFactory: ExclusionsFactory = exclusionsFactory(
         AndroidExcludedRefs.appDefaults
     ),
-    /**
-     * Whether to compute the total number of bytes in memory that would be reclaimed if the
-     * detected leaks didn't happen. This includes native memory associated to Java objects
-     * (e.g. bitmaps).
-     * Computing the retained heap size can slow down the leak analysis and is off by default.
-     */
-    val computeRetainedHeapSize: Boolean = false,
     val leakInspectors: List<LeakInspector> = AndroidLeakInspectors.defaultAndroidInspectors(),
     val labelers: List<Labeler> = defaultAndroidLabelers(
         InternalLeakCanary.application
@@ -50,7 +43,29 @@ object LeakCanary {
      * If you want leaks to be added to the activity that lists leaks, make sure to delegate
      * calls to [DefaultAnalysisResultListener].
      */
-    val analysisResultListener: AnalysisResultListener = DefaultAnalysisResultListener
+    val analysisResultListener: AnalysisResultListener = DefaultAnalysisResultListener,
+    /**
+     * Whether to compute the total number of bytes in memory that would be reclaimed if the
+     * detected leaks didn't happen. This includes native memory associated to Java objects
+     * (e.g. bitmaps).
+     * Computing the retained heap size can slow down the leak analysis and is off by default.
+     */
+    val computeRetainedHeapSize: Boolean = false,
+
+    /**
+     * How many heap dumps are kept locally. When this threshold is reached LeakCanary starts
+     * deleting the older heap dumps. As several heap dumps may be enqueued you should avoid
+     * going down to 1 or 2.
+     */
+    val maxStoredHeapDumps: Int = 7,
+
+    /**
+     * LeakCanary always attempts to store heap dumps on the external storage first. If the
+     * WRITE_EXTERNAL_STORAGE permission is not granted and [requestWriteExternalStoragePermission]
+     * is true, then LeakCanary will display a notification to ask for that permission.
+     */
+    val requestWriteExternalStoragePermission: Boolean = false
+
   )
 
   @Volatile
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
index 8caa7ebb..202f85d0 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
@@ -31,6 +31,7 @@ import android.view.View
 import android.widget.Toast
 import com.squareup.leakcanary.core.R
 import leakcanary.CanaryLog
+import leakcanary.internal.InternalHelper.noOpDelegate
 import leakcanary.internal.NotificationType.LEAKCANARY_LOW
 import java.io.File
 import java.util.concurrent.TimeUnit.SECONDS
@@ -47,7 +48,7 @@ internal class AndroidHeapDumper(
 
   init {
     val application = context.applicationContext as Application
-    application.registerActivityLifecycleCallbacks(object : ActivityLifecycleCallbacksAdapter() {
+    application.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate()  {
       override fun onActivityResumed(activity: Activity) {
         resumedActivity = activity
       }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
index 8e3ba4a9..4a1bc376 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
@@ -43,6 +43,15 @@ internal class HeapAnalyzerService : ForegroundService(
     // Since we're running in the main process we should be careful not to impact it.
     Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)
     val heapDumpFile = intent.getSerializableExtra(HEAPDUMP_FILE_EXTRA) as File
+
+    if (!heapDumpFile.exists()) {
+      throw IllegalStateException(
+          "Hprof file missing due to: [${LeakDirectoryProvider.hprofDeleteReason(
+              heapDumpFile
+          )}] $heapDumpFile"
+      )
+    }
+
     val heapAnalyzer = HeapAnalyzer(this)
     val config = LeakCanary.config
     val heapAnalysis =
@@ -51,11 +60,7 @@ internal class HeapAnalyzerService : ForegroundService(
           config.leakInspectors, config.labelers
       )
 
-    try {
-      config.analysisResultListener(application, heapAnalysis)
-    } finally {
-      heapAnalysis.heapDumpFile.delete()
-    }
+    config.analysisResultListener(application, heapAnalysis)
   }
 
   override fun onProgressUpdate(step: AnalyzerProgressListener.Step) {
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
index 88877522..6dfe9b95 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -30,7 +30,11 @@ internal object InternalLeakCanary : LeakSentryListener {
     private set
 
   val leakDirectoryProvider: LeakDirectoryProvider by lazy {
-    LeakDirectoryProvider(application)
+    LeakDirectoryProvider(application, {
+      LeakCanary.config.maxStoredHeapDumps
+    }, {
+      LeakCanary.config.requestWriteExternalStoragePermission
+    })
   }
 
   val leakDisplayActivityIntent: Intent
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
index 6e06d3a5..a42d6fdc 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
@@ -28,32 +28,28 @@ import leakcanary.CanaryLog
 import leakcanary.internal.NotificationType.LEAKCANARY_LOW
 import java.io.File
 import java.io.FilenameFilter
+import java.text.SimpleDateFormat
 import java.util.ArrayList
 import java.util.Arrays
-import java.util.UUID
+import java.util.Date
+import java.util.Locale
 
 /**
  * Provides access to where heap dumps and analysis results will be stored.
  */
-internal class LeakDirectoryProvider @JvmOverloads constructor(
+internal class LeakDirectoryProvider constructor(
   context: Context,
-  private val maxStoredHeapDumps: Int = DEFAULT_MAX_STORED_HEAP_DUMPS
+  private val maxStoredHeapDumps: () -> Int,
+  private val requestExternalStoragePermission: () -> Boolean
 ) {
 
-  private val context: Context
+  private val context: Context = context.applicationContext
 
   @Volatile private var writeExternalStorageGranted: Boolean = false
   @Volatile private var permissionNotificationDisplayed: Boolean = false
 
-  init {
-    if (maxStoredHeapDumps < 1) {
-      throw IllegalArgumentException("maxStoredHeapDumps must be at least 1")
-    }
-    this.context = context.applicationContext
-  }
-
   fun listFiles(filter: FilenameFilter): MutableList<File> {
-    if (!hasStoragePermission()) {
+    if (!hasStoragePermission() && requestExternalStoragePermission()) {
       requestWritePermissionNotification()
     }
     val files = ArrayList<File>()
@@ -76,8 +72,12 @@ internal class LeakDirectoryProvider @JvmOverloads constructor(
     var storageDirectory = externalStorageDirectory()
     if (!directoryWritableAfterMkdirs(storageDirectory)) {
       if (!hasStoragePermission()) {
-        CanaryLog.d("WRITE_EXTERNAL_STORAGE permission not granted")
-        requestWritePermissionNotification()
+        if (requestExternalStoragePermission()) {
+          CanaryLog.d("WRITE_EXTERNAL_STORAGE permission not granted, requesting")
+          requestWritePermissionNotification()
+        } else {
+          CanaryLog.d("WRITE_EXTERNAL_STORAGE permission not granted, ignoring")
+        }
       } else {
         val state = Environment.getExternalStorageState()
         if (Environment.MEDIA_MOUNTED != state) {
@@ -99,20 +99,22 @@ internal class LeakDirectoryProvider @JvmOverloads constructor(
         return null
       }
     }
-    // If two processes from the same app get to this step at the same time, they could both
-    // create a heap dump. This is an edge case we ignore.
-    return File(storageDirectory, UUID.randomUUID().toString() + PENDING_HEAPDUMP_SUFFIX)
+
+    val fileName = SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'.hprof'", Locale.US).format(Date())
+    return File(storageDirectory, fileName)
   }
 
   fun clearLeakDirectory() {
     val allFilesExceptPending =
       listFiles(FilenameFilter { _, filename ->
-        !filename.endsWith(
-            PENDING_HEAPDUMP_SUFFIX
-        )
+        true
       })
     for (file in allFilesExceptPending) {
+      val path = file.absolutePath
       val deleted = file.delete()
+      if (deleted) {
+        filesDeletedClearDirectory += path
+      }
       if (!deleted) {
         CanaryLog.d("Could not delete file %s", file.path)
       }
@@ -173,6 +175,11 @@ internal class LeakDirectoryProvider @JvmOverloads constructor(
           HPROF_SUFFIX
       )
     })
+    val maxStoredHeapDumps = maxStoredHeapDumps()
+    if (maxStoredHeapDumps < 1) {
+      throw IllegalArgumentException("maxStoredHeapDumps must be at least 1")
+    }
+
     val filesToRemove = hprofFiles.size - maxStoredHeapDumps
     if (filesToRemove > 0) {
       CanaryLog.d("Removing %d heap dumps", filesToRemove)
@@ -182,8 +189,11 @@ internal class LeakDirectoryProvider @JvmOverloads constructor(
             .compareTo(rhs.lastModified())
       })
       for (i in 0 until filesToRemove) {
+        val path = hprofFiles[i].absolutePath
         val deleted = hprofFiles[i].delete()
-        if (!deleted) {
+        if (deleted) {
+          filesDeletedTooOld += path
+        } else {
           CanaryLog.d("Could not delete old hprof file %s", hprofFiles[i].path)
         }
       }
@@ -192,9 +202,20 @@ internal class LeakDirectoryProvider @JvmOverloads constructor(
 
   companion object {
 
-    private const val DEFAULT_MAX_STORED_HEAP_DUMPS = 7
+    private val filesDeletedTooOld = mutableListOf<String>()
+    private val filesDeletedClearDirectory = mutableListOf<String>()
+    val filesDeletedRemoveLeak = mutableListOf<String>()
 
     private const val HPROF_SUFFIX = ".hprof"
-    private const val PENDING_HEAPDUMP_SUFFIX = "_pending$HPROF_SUFFIX"
+
+    fun hprofDeleteReason(file: File): String {
+      val path = file.absolutePath
+      return when {
+        filesDeletedTooOld.contains(path) -> "Older than all other hprof files"
+        filesDeletedClearDirectory.contains(path) -> "Hprof directory cleared"
+        filesDeletedRemoveLeak.contains(path) -> "Leak manually removed"
+        else -> "Unknown"
+      }
+    }
   }
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
index a3e5f726..ca214b51 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
@@ -2,12 +2,12 @@ package leakcanary.internal
 
 import android.app.Activity
 import android.app.Application
-import leakcanary.CanaryLog
+import leakcanary.internal.InternalHelper.noOpDelegate
 
 internal class VisibilityTracker(
   private val listener: (Boolean) -> Unit
 ) :
-    ActivityLifecycleCallbacksAdapter() {
+    Application.ActivityLifecycleCallbacks by noOpDelegate() {
 
   private var startedActivityCount = 0
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
index 6fb91079..69b48390 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
@@ -10,6 +10,7 @@ import leakcanary.HeapAnalysisFailure
 import leakcanary.HeapAnalysisSuccess
 import leakcanary.Serializables
 import leakcanary.internal.InternalLeakCanary
+import leakcanary.internal.LeakDirectoryProvider
 import leakcanary.leakingInstances
 import leakcanary.toByteArray
 import org.intellij.lang.annotations.Language
@@ -120,8 +121,11 @@ internal object HeapAnalysisTable {
   ) {
     if (heapDumpFile != null) {
       AsyncTask.SERIAL_EXECUTOR.execute {
+        val path = heapDumpFile.absolutePath
         val heapDumpDeleted = heapDumpFile.delete()
-        if (!heapDumpDeleted) {
+        if (heapDumpDeleted) {
+          LeakDirectoryProvider.filesDeletedRemoveLeak += path
+        } else {
           CanaryLog.d("Could not delete heap dump file %s", heapDumpFile.path)
         }
       }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
index fdbaac68..afc0b086 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
@@ -275,10 +275,16 @@ internal object LeakingInstanceTable {
     return if (exclusionStatus == WONT_FIX_LEAK) {
       leakTrace.firstElementExclusion.matching
     } else {
-      val element = leakTrace.leakCauses.first()
-      val referenceName = element.reference!!.groupingName
-      val refDescription = element.simpleClassName + "." + referenceName
-      refDescription
+      val leakCauses = leakTrace.leakCauses
+      if (leakCauses.isEmpty()) {
+        // Should rarely happen, don't expect to see 0 unknown and 100% leaking or 100% not leaking
+        instanceClassName
+      } else {
+        val element = leakCauses.first()
+        val referenceName = element.reference!!.groupingName
+        val refDescription = element.simpleClassName + "." + referenceName
+        refDescription
+      }
     }
   }
 
diff --git a/leakcanary-android-instrumentation/build.gradle b/leakcanary-android-instrumentation/build.gradle
index 7e5f37bf..02f90246 100644
--- a/leakcanary-android-instrumentation/build.gradle
+++ b/leakcanary-android-instrumentation/build.gradle
@@ -12,7 +12,6 @@ dependencies {
   androidTestImplementation deps.androidx.test.rules
   androidTestImplementation deps.androidx.test.runner
   androidTestImplementation deps.androidx.fragment
-  androidTestImplementation deps.androidx.benchmark
 }
 
 android {
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
index fb665265..048dacf1 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
@@ -9,7 +9,7 @@ import android.view.View
 import androidx.test.core.app.ApplicationProvider.getApplicationContext
 import androidx.test.rule.ActivityTestRule
 import leakcanary.TestUtils.assertLeak
-import leakcanary.internal.ActivityLifecycleCallbacksAdapter
+import leakcanary.internal.InternalHelper.noOpDelegate
 import org.junit.After
 import org.junit.Before
 import org.junit.Rule
@@ -67,7 +67,7 @@ class FragmentLeakTest {
   private fun startActivityAndWaitForCreate() {
     val waitForActivityOnCreate = CountDownLatch(1)
     val app = getApplicationContext<Application>()
-    app.registerActivityLifecycleCallbacks(object : ActivityLifecycleCallbacksAdapter() {
+    app.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
       override fun onActivityCreated(
         activity: Activity,
         savedInstanceState: Bundle?
@@ -94,7 +94,7 @@ class FragmentLeakTest {
     }
     val testActivity = activityRule.activity
     testActivity.application.registerActivityLifecycleCallbacks(
-        object : ActivityLifecycleCallbacksAdapter() {
+        object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
           override fun onActivityDestroyed(activity: Activity) {
             if (activity == testActivity) {
               activity.application.unregisterActivityLifecycleCallbacks(this)
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt b/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
index c516606f..c79c1d45 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
@@ -7,10 +7,26 @@ import java.util.concurrent.TimeUnit
 object LeakSentry {
 
   data class Config(
+    /**
+     * Whether LeakSentry should watch instances (by keeping weak references to them). Default is
+     * true in debuggable builds and false is non debuggable builds.
+     */
     val enabled: Boolean = InternalLeakSentry.isDebuggableBuild,
+    /**
+     * Whether LeakCanary should automatically watch destroyed activities.
+     */
     val watchActivities: Boolean = true,
+    /**
+     * Whether LeakCanary should automatically watch destroyed fragments.
+     */
     val watchFragments: Boolean = true,
+    /**
+     * Whether LeakCanary should automatically watch destroyed fragment views.
+     */
     val watchFragmentViews: Boolean = true,
+    /**
+     * How long to wait before reporting a watched instance as retained. Default is 5 seconds.
+     */
     val watchDurationMillis: Long = TimeUnit.SECONDS.toMillis(5)
   )
 
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
index d27c0bb7..aec2cc7c 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
@@ -17,21 +17,23 @@ package leakcanary.internal
 
 import android.app.Activity
 import android.app.Application
-import leakcanary.RefWatcher
 import leakcanary.LeakSentry.Config
+import leakcanary.RefWatcher
+import leakcanary.internal.InternalHelper.noOpDelegate
 
 internal class ActivityDestroyWatcher private constructor(
   private val refWatcher: RefWatcher,
   private val configProvider: () -> Config
 ) {
 
-  private val lifecycleCallbacks = object : ActivityLifecycleCallbacksAdapter() {
-    override fun onActivityDestroyed(activity: Activity) {
-      if (configProvider().watchActivities) {
-        refWatcher.watch(activity)
+  private val lifecycleCallbacks =
+    object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
+      override fun onActivityDestroyed(activity: Activity) {
+        if (configProvider().watchActivities) {
+          refWatcher.watch(activity)
+        }
       }
     }
-  }
 
   companion object {
     fun install(
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityLifecycleCallbacksAdapter.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityLifecycleCallbacksAdapter.kt
deleted file mode 100644
index 25f6f9c6..00000000
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityLifecycleCallbacksAdapter.kt
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary.internal
-
-import android.app.Activity
-import android.app.Application
-import android.os.Bundle
-
-abstract class ActivityLifecycleCallbacksAdapter : Application.ActivityLifecycleCallbacks {
-  override fun onActivityCreated(
-    activity: Activity,
-    savedInstanceState: Bundle?
-  ) {
-  }
-
-  override fun onActivityStarted(activity: Activity) {}
-
-  override fun onActivityResumed(activity: Activity) {}
-
-  override fun onActivityPaused(activity: Activity) {}
-
-  override fun onActivityStopped(activity: Activity) {}
-
-  override fun onActivitySaveInstanceState(
-    activity: Activity,
-    outState: Bundle
-  ) {
-  }
-
-  override fun onActivityDestroyed(activity: Activity) {}
-}
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
index 040538dd..2b7e8e45 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
@@ -3,7 +3,7 @@ package leakcanary.internal
 import android.util.Log
 import leakcanary.CanaryLog.Logger
 
-class DefaultCanaryLog : Logger {
+internal class DefaultCanaryLog : Logger {
 
   override fun d(
     message: String,
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
index 60a0b662..54976015 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
@@ -20,8 +20,9 @@ import android.app.Application
 import android.os.Build.VERSION.SDK_INT
 import android.os.Build.VERSION_CODES.O
 import android.os.Bundle
-import leakcanary.RefWatcher
 import leakcanary.LeakSentry
+import leakcanary.RefWatcher
+import leakcanary.internal.InternalHelper.noOpDelegate
 
 /**
  * Internal class used to watch for fragments leaks.
@@ -60,7 +61,7 @@ internal interface FragmentDestroyWatcher {
         return
       }
 
-      application.registerActivityLifecycleCallbacks(object : ActivityLifecycleCallbacksAdapter() {
+      application.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
         override fun onActivityCreated(
           activity: Activity,
           savedInstanceState: Bundle?
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalHelper.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalHelper.kt
new file mode 100644
index 00000000..64e05ead
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalHelper.kt
@@ -0,0 +1,18 @@
+package leakcanary.internal
+
+import java.lang.reflect.InvocationHandler
+import java.lang.reflect.Proxy
+
+/** Visible across several internal modules. */
+object InternalHelper {
+  inline fun <reified T : Any> noOpDelegate(): T {
+    val javaClass = T::class.java
+    val noOpHandler = InvocationHandler { _, _, _ ->
+      // no op
+    }
+    return Proxy.newProxyInstance(
+        javaClass.classLoader, arrayOf(javaClass), noOpHandler
+    ) as T
+  }
+
+}
\ No newline at end of file
