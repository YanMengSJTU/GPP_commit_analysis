diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
index 3b1effb6..2b2238f9 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
@@ -32,8 +32,10 @@
 
 import java.io.File;
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 import static com.squareup.leakcanary.AnalysisResult.failure;
 import static com.squareup.leakcanary.AnalysisResult.leakDetected;
@@ -48,6 +50,7 @@
 import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
 import static com.squareup.leakcanary.LeakTraceElement.Holder.OBJECT;
 import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
+import static java.util.Arrays.asList;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
 /**
@@ -94,6 +97,37 @@ public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
     }
   }
 
+  /**
+   * Searches the heap dump for all {@link KeyedWeakReference} objects, and then computes the
+   * shortest strong reference path from that instance to the GC roots.
+   */
+  public List<AnalysisResult> checkForLeaks(File heapDumpFile) {
+    long analysisStartNanoTime = System.nanoTime();
+
+    if (!heapDumpFile.exists()) {
+      Exception exception = new IllegalArgumentException("File does not exist: " + heapDumpFile);
+      return asList(failure(exception, since(analysisStartNanoTime)));
+    }
+
+    List<AnalysisResult> results = new ArrayList<>();
+    try {
+      HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
+      HprofParser parser = new HprofParser(buffer);
+      Snapshot snapshot = parser.parse();
+      deduplicateGcRoots(snapshot);
+      Set<String> keys = keysForSnapshot(snapshot);
+      for (String key : keys) {
+        Instance leakingRef = findLeakingReference(key, snapshot);
+        if (leakingRef != null) {
+          results.add(findLeakTrace(analysisStartNanoTime, snapshot, leakingRef));
+        }
+      }
+    } catch (Throwable e) {
+      results.add(failure(e, since(analysisStartNanoTime)));
+    }
+    return results;
+  }
+
   /**
    * Pruning duplicates reduces memory pressure from hprof bloat added in Marshmallow.
    */
@@ -138,6 +172,17 @@ private Instance findLeakingReference(String key, Snapshot snapshot) {
         "Could not find weak reference with key " + key + " in " + keysFound);
   }
 
+  private Set<String> keysForSnapshot(Snapshot snapshot) {
+    ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());
+    Set<String> keysFound = new HashSet<>();
+    for (Instance instance : refClass.getInstancesList()) {
+      List<ClassInstance.FieldValue> values = classInstanceValues(instance);
+      String keyCandidate = asString(fieldValue(values, "key"));
+      keysFound.add(keyCandidate);
+    }
+    return keysFound;
+  }
+
   private AnalysisResult findLeakTrace(long analysisStartNanoTime, Snapshot snapshot,
       Instance leakingRef) {
 
