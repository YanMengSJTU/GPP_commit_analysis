diff --git a/docs/recipes.md b/docs/recipes.md
index aee2ba89..e7390104 100644
--- a/docs/recipes.md
+++ b/docs/recipes.md
@@ -90,7 +90,11 @@ val retainedInstanceCount = AppWatcher.objectWatcher.retainedObjectCount
 
 ## Running LeakCanary in instrumentation tests
 
-Add the `leakcanary-android-instrumentation` dependency to your instrumentation tests:
+Running leak detection in UI tests means you can detect memory leaks automatically in Continuous Integration prior to those leaks being merged into the codebase. However, as LeakCanary runs with a 5 seconds delay and freezes the VM to take a heap dump, this can introduce flakiness to the UI tests. Therefore LeakCanary automatically disables itself by setting `LeakCanary.config.dumpHeap` to `false` if it detects classes from the `androidx.test` dependency in the runtime classpath. If you run UI tests without `androidx.test`, we strongly advise that you set `dumpHeap` to `false`: `LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)`.
+
+LeakCanary provides an artifact dedicated to detecting leaks in UI tests which provides a run listener that waits for the end of a test, and if the test succeeds then it look for retained objects, trigger a heap dump if needed and perform an analysis.
+
+To set it up, add the `leakcanary-android-instrumentation` dependency to your instrumentation tests:
 
 ```
 androidTestImplementation "com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion}"
@@ -176,7 +180,6 @@ class DebugExampleApplication : ExampleApplication() {
 }
 ```
 
-
 ## Matching known library leaks
 
 Set [LeakCanary.Config.referenceMatchers](/leakcanary/api/leakcanary-android-core/leakcanary/-leak-canary/-config/reference-matchers/) to a list that builds on top of [AndroidReferenceMatchers.appDefaults](/leakcanary/api/shark-android/shark/-android-reference-matchers/app-defaults/):
@@ -201,6 +204,13 @@ class DebugExampleApplication : ExampleApplication() {
 }
 ```
 
+## Ignoring specific activities or fragment classes
+
+Sometimes a 3rd party library provides its own activities or fragments which contain a number of bugs leading to leaks of those specific 3rd party activities and fragments. You should push hard on that library to fix their memory leaks as it's directly impacting your application. That being said, until those are fixed, you have two options:
+
+1. Add the specific leaks as known library leaks (see [Matching known library leaks](#matching-known-library-leaks)). LeakCanary will run when those leaks are detected and then report them as known library leaks.
+2. Disable LeakCanary automatic activity or fragment watching (e.g. `AppWatcher.config = AppWatcher.config.copy(watchActivities = false)`) and then manually pass objects to `AppWatcher.objectWatcher.watch`.
+
 ## Identifying leaking objects and labeling objects
 
 ```kotlin
diff --git a/docs/upgrading-to-leakcanary-2.0.md b/docs/upgrading-to-leakcanary-2.0.md
index d982bac0..cd4204e2 100644
--- a/docs/upgrading-to-leakcanary-2.0.md
+++ b/docs/upgrading-to-leakcanary-2.0.md
@@ -293,6 +293,9 @@ LeakCanary.config = LeakCanary.config.copy(
 )
 ```
 
+!!! info
+    There is no equivalent API to `ExcludedRefs.Builder.clazz()` because it led to abuses. Instead see [Ignoring specific activities or fragment classes](recipes.md#ignoring-specific-activities-or-fragment-classes).
+
 ## Public API packages
 
 ### Before
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
index cf17596a..431d3434 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -158,16 +158,10 @@ internal object InternalLeakCanary : (Application) -> Unit, OnObjectRetainedList
       longLabel = leakActivityLabel
       shortLabel = leakActivityLabel
     } else {
-
       val firstLauncherActivityLabel = if (firstMainActivity.labelRes != 0) {
         application.getString(firstMainActivity.labelRes)
       } else {
-        val applicationInfo = application.applicationInfo
-        if (applicationInfo.labelRes != 0) {
-          application.getString(applicationInfo.labelRes)
-        } else {
-          applicationInfo.nonLocalizedLabel.toString()
-        }
+        application.packageManager.getApplicationLabel(application.applicationInfo)
       }
       val fullLengthLabel = "$firstLauncherActivityLabel $leakActivityLabel"
       // short label should be under 10 and long label under 25
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/NavigatingActivity.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/NavigatingActivity.kt
index f53117e1..a45ee811 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/NavigatingActivity.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/NavigatingActivity.kt
@@ -123,7 +123,9 @@ internal abstract class NavigatingActivity : Activity() {
     val actionBar = actionBar
         ?: // https://github.com/square/leakcanary/issues/967
         return
-    actionBar.setDisplayHomeAsUpEnabled(backstack.size > 0)
+    val homeEnabled = backstack.size > 0
+    actionBar.setDisplayHomeAsUpEnabled(homeEnabled)
+    actionBar.setHomeButtonEnabled(homeEnabled)
   }
 
   override fun onCreateOptionsMenu(menu: Menu): Boolean {
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt
index 45bf7c17..a102ba22 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt
@@ -45,6 +45,8 @@ class ProfiledTest {
         leakFinders = listOf(KEYED_WEAK_REFERENCE)
     )
     SharkLog.d { result.toString() }
+    // Giving time to stop CPU profiler (otherwise trace won't succeed)
+    Thread.sleep(20000)
   }
 
 }
diff --git a/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt b/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
index 46bb84f5..ad8f6d28 100644
--- a/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
+++ b/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
@@ -19,6 +19,7 @@ import shark.AndroidReferenceMatchers.Companion.appDefaults
 import shark.AndroidReferenceMatchers.Companion.buildKnownReferences
 import shark.ReferencePattern.InstanceFieldPattern
 import shark.ReferencePattern.JavaLocalPattern
+import shark.ReferencePattern.NativeGlobalVariablePattern
 import shark.ReferencePattern.StaticFieldPattern
 import java.lang.ref.PhantomReference
 import java.lang.ref.SoftReference
@@ -522,7 +523,7 @@ enum class AndroidReferenceMatchers {
               " on the screen. TextView.ChangeWatcher and android.widget.Editor end up in spans and" +
               " typically hold on to the view hierarchy"
       ) {
-        sdkInt in 24..27
+        sdkInt in 24..28
       }
     }
   },
@@ -667,6 +668,28 @@ enum class AndroidReferenceMatchers {
     }
   },
 
+  CONTROLLED_INPUT_CONNECTION_WRAPPER {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += nativeGlobalVariableLeak(
+          "android.view.inputmethod.InputMethodManager\$ControlledInputConnectionWrapper",
+          description = """
+        ControlledInputConnectionWrapper is held by a global variable in native code. 
+      """.trimIndent()
+      )
+    }
+  },
+
+  TOAST_TN {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += nativeGlobalVariableLeak(
+          "android.widget.Toast\$TN",
+          description = """
+        Toast.TN is held by a global variable in native code due to an IPC call to show the toast.
+      """.trimIndent()
+      )
+    }
+  },
+
   // ######## Manufacturer specific known leaks ########
 
   // SAMSUNG
@@ -709,35 +732,18 @@ enum class AndroidReferenceMatchers {
     override fun add(
       references: MutableList<ReferenceMatcher>
     ) {
-      references += instanceFieldLeak(
-          "com.samsung.android.content.clipboard.SemClipboardManager",
-          "mContext"
-          ,
-          description =
-          "SemClipboardManager is held in memory by an anonymous inner class" +
-              " implementation of android.os.Binder, thereby leaking an activity context."
+      val description = """
+         SemClipboardManager inner classes are held by native references due to IPC calls 
+      """.trimIndent()
+      references += nativeGlobalVariableLeak(
+          "com.samsung.android.content.clipboard.SemClipboardManager$1", description
       ) {
-        manufacturer == SAMSUNG && sdkInt in 19..24
+        manufacturer == SAMSUNG && sdkInt in 19..28
       }
-      references += instanceFieldLeak(
-          "com.samsung.android.content.clipboard.SemClipboardManager$3",
-          "this$0"
-          ,
-          description =
-          "SemClipboardManager is held in memory by an anonymous inner class" +
-              " implementation of android.os.Binder, thereby leaking an activity context."
+      references += nativeGlobalVariableLeak(
+          "com.samsung.android.content.clipboard.SemClipboardManager$3", description
       ) {
-        manufacturer == SAMSUNG && sdkInt in 22..28
-      }
-      references += instanceFieldLeak(
-          "com.samsung.android.content.clipboard.SemClipboardManager$1",
-          "this$0"
-          ,
-          description =
-          "SemClipboardManager is held in memory by an anonymous inner class" +
-              " implementation of android.os.Binder, thereby leaking an activity context."
-      ) {
-        manufacturer == SAMSUNG && sdkInt == 24
+        manufacturer == SAMSUNG && sdkInt in 19..28
       }
     }
   },
@@ -1081,6 +1087,22 @@ enum class AndroidReferenceMatchers {
     }
   },
 
+  OEM_SCENE_CALL_BLOCKER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "com.oneplus.util.OemSceneCallBlocker", "sContext",
+          description =
+          """
+            OemSceneCallBlocker has a sContext static field which holds on to an activity instance.
+          """.trimIndent()
+      ) {
+        manufacturer == ONE_PLUS && sdkInt == 28
+      }
+    }
+  },
+
   // ######## Ignored references (not leaks) ########
 
   REFERENCES {
@@ -1172,6 +1194,7 @@ enum class AndroidReferenceMatchers {
     const val LG = "LGE"
     const val NVIDIA = "NVIDIA"
     const val MEIZU = "Meizu"
+    const val ONE_PLUS = "OnePlus"
     const val HUAWEI = "HUAWEI"
     const val VIVO = "vivo"
     const val SHARP = "SHARP"
@@ -1239,6 +1262,14 @@ enum class AndroidReferenceMatchers {
       return libraryLeak(InstanceFieldPattern(className, fieldName), description, patternApplies)
     }
 
+    fun nativeGlobalVariableLeak(
+      className: String,
+      description: String = "",
+      patternApplies: AndroidBuildMirror.() -> Boolean = ALWAYS
+    ): LibraryLeakReferenceMatcher {
+      return libraryLeak(NativeGlobalVariablePattern(className), description, patternApplies)
+    }
+
     private fun libraryLeak(
       referencePattern: ReferencePattern,
       description: String,
diff --git a/shark-graph/src/main/java/shark/HprofHeapGraph.kt b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
index f49d5168..0a23e73c 100644
--- a/shark-graph/src/main/java/shark/HprofHeapGraph.kt
+++ b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
@@ -1,6 +1,5 @@
 package shark
 
-import okio.Buffer
 import shark.HeapObject.HeapClass
 import shark.HeapObject.HeapInstance
 import shark.HeapObject.HeapObjectArray
@@ -103,18 +102,8 @@ class HprofHeapGraph internal constructor(
     return index.fieldName(classId, fieldRecord.nameStringId)
   }
 
-  internal fun createFieldValuesReader(record: InstanceDumpRecord): FieldValuesReader {
-    val buffer = Buffer()
-    buffer.write(record.fieldValues)
-
-    val reader = HprofReader(buffer, identifierByteSize)
-
-    return object : FieldValuesReader {
-      override fun readValue(field: FieldRecord): ValueHolder {
-        return reader.readValue(field.type)
-      }
-    }
-  }
+  internal fun createFieldValuesReader(record: InstanceDumpRecord) =
+    FieldValuesReader(record, identifierByteSize)
 
   internal fun className(classId: Long): String {
     return index.className(classId)
diff --git a/shark-graph/src/main/java/shark/internal/ByteSubArray.kt b/shark-graph/src/main/java/shark/internal/ByteSubArray.kt
index 6222e13a..ab634de6 100644
--- a/shark-graph/src/main/java/shark/internal/ByteSubArray.kt
+++ b/shark-graph/src/main/java/shark/internal/ByteSubArray.kt
@@ -5,12 +5,13 @@ package shark.internal
  */
 internal class ByteSubArray(
   private val array: ByteArray,
-  private val range: IntRange,
+  private val rangeStart: Int,
+  size: Int,
   private val longIdentifiers: Boolean
 ) {
-  private val endInclusive = range.endInclusive - range.start
 
-  val size = endInclusive + 1
+  private val endInclusive = size - 1
+
   private var currentIndex = 0
 
   fun readByte(): Byte {
@@ -19,7 +20,7 @@ internal class ByteSubArray(
     require(index in 0..endInclusive) {
       "Index $index should be between 0 and $endInclusive"
     }
-    return array[range.first + index]
+    return array[rangeStart + index]
   }
 
   fun readId(): Long {
@@ -36,7 +37,7 @@ internal class ByteSubArray(
     require(index >= 0 && index <= endInclusive - 3) {
       "Index $index should be between 0 and ${endInclusive - 3}"
     }
-    return array.readInt(range.first + index)
+    return array.readInt(rangeStart + index)
   }
 
   fun readTruncatedLong(byteCount: Int): Long {
@@ -45,12 +46,15 @@ internal class ByteSubArray(
     require(index >= 0 && index <= endInclusive - (byteCount - 1)) {
       "Index $index should be between 0 and ${endInclusive - (byteCount - 1)}"
     }
-    var pos = range.first + index
+    var pos = rangeStart + index
     val array = array
 
     var value = 0L
-    for (shift in ((byteCount - 1) * 8) downTo 8 step 8) {
+
+    var shift = (byteCount - 1) * 8
+    while (shift >= 8) {
       value = value or (array[pos++] and 0xffL shl shift)
+      shift -= 8
     }
     value = value or (array[pos] and 0xffL)
     return value
@@ -62,10 +66,17 @@ internal class ByteSubArray(
     require(index >= 0 && index <= endInclusive - 7) {
       "Index $index should be between 0 and ${endInclusive - 7}"
     }
-    return array.readLong(range.first + index)
+    return array.readLong(rangeStart + index)
   }
 }
 
+internal fun ByteArray.readShort(index: Int): Short {
+  var pos = index
+  val array = this
+  val valueAsInt = array[pos++] and 0xff shl 8 or (array[pos] and 0xff)
+  return valueAsInt.toShort()
+}
+
 internal fun ByteArray.readInt(index: Int): Int {
   var pos = index
   val array = this
diff --git a/shark-graph/src/main/java/shark/internal/FieldValuesReader.kt b/shark-graph/src/main/java/shark/internal/FieldValuesReader.kt
index 794b3bfe..666e0a9e 100644
--- a/shark-graph/src/main/java/shark/internal/FieldValuesReader.kt
+++ b/shark-graph/src/main/java/shark/internal/FieldValuesReader.kt
@@ -1,8 +1,113 @@
 package shark.internal
 
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.PrimitiveType
+import shark.PrimitiveType.BOOLEAN
+import shark.PrimitiveType.BYTE
+import shark.PrimitiveType.CHAR
+import shark.PrimitiveType.DOUBLE
+import shark.PrimitiveType.FLOAT
+import shark.PrimitiveType.INT
+import shark.PrimitiveType.LONG
+import shark.PrimitiveType.SHORT
 import shark.ValueHolder
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
+
+internal class FieldValuesReader(
+  private val record: InstanceDumpRecord,
+  private val identifierByteSize: Int
+) {
+
+  private var position = 0
+
+  fun readValue(field: FieldRecord): ValueHolder {
+    return when (field.type) {
+      PrimitiveType.REFERENCE_HPROF_TYPE -> ReferenceHolder(readId())
+      BOOLEAN_TYPE -> BooleanHolder(readBoolean())
+      CHAR_TYPE -> CharHolder(readChar())
+      FLOAT_TYPE -> FloatHolder(readFloat())
+      DOUBLE_TYPE -> DoubleHolder(readDouble())
+      BYTE_TYPE -> ByteHolder(readByte())
+      SHORT_TYPE -> ShortHolder(readShort())
+      INT_TYPE -> IntHolder(readInt())
+      LONG_TYPE -> LongHolder(readLong())
+      else -> throw IllegalStateException("Unknown type ${field.type}")
+    }
+  }
+
+  private fun readId(): Long {
+    // As long as we don't interpret IDs, reading signed values here is fine.
+    return when (identifierByteSize) {
+      1 -> readByte().toLong()
+      2 -> readShort().toLong()
+      4 -> readInt().toLong()
+      8 -> readLong()
+      else -> throw IllegalArgumentException("ID Length must be 1, 2, 4, or 8")
+    }
+  }
+
+  private fun readBoolean(): Boolean {
+    val value = record.fieldValues[position]
+    position++
+    return value != 0.toByte()
+  }
+
+  private fun readByte(): Byte {
+    val value = record.fieldValues[position]
+    position++
+    return value
+  }
+
+  private fun readInt(): Int {
+    val value = record.fieldValues.readInt(position)
+    position += 4
+    return value
+  }
+
+  private fun readShort(): Short {
+    val value = record.fieldValues.readShort(position)
+    position += 2
+    return value
+  }
+
+  private fun readLong(): Long {
+    val value = record.fieldValues.readLong(position)
+    position += 8
+    return value
+  }
+
+  private fun readFloat(): Float {
+    return Float.fromBits(readInt())
+  }
+
+  private fun readDouble(): Double {
+    return Double.fromBits(readLong())
+  }
+
+  private fun readChar(): Char {
+    val string = String(record.fieldValues, position, 2, Charsets.UTF_16BE)
+    position += 2
+    return string[0]
+  }
+
+  companion object {
+    private val BOOLEAN_TYPE = BOOLEAN.hprofType
+    private val CHAR_TYPE = CHAR.hprofType
+    private val FLOAT_TYPE = FLOAT.hprofType
+    private val DOUBLE_TYPE = DOUBLE.hprofType
+    private val BYTE_TYPE = BYTE.hprofType
+    private val SHORT_TYPE = SHORT.hprofType
+    private val INT_TYPE = INT.hprofType
+    private val LONG_TYPE = LONG.hprofType
+  }
 
-internal interface FieldValuesReader {
-  fun readValue(field: FieldRecord): ValueHolder
 }
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
index ce3665f7..91eb1749 100644
--- a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
+++ b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
@@ -54,8 +54,7 @@ internal class HprofInMemoryIndex private constructor(
   ): String {
     val fieldNameString = hprofStringById(id)
     return proguardMapping?.let {
-      val classNameStringId =
-        classNames[classId] ?: throw IllegalArgumentException("Unknown class id $classId")
+      val classNameStringId = classNames[classId]
       val classNameString = hprofStringById(classNameStringId)
       proguardMapping.deobfuscateFieldName(classNameString, fieldNameString)
     } ?: fieldNameString
@@ -63,8 +62,7 @@ internal class HprofInMemoryIndex private constructor(
 
   fun className(classId: Long): String {
     // String, primitive types
-    val classNameStringId =
-      classNames[classId] ?: throw IllegalArgumentException("Unknown class id $classId")
+    val classNameStringId = classNames[classId]
     val classNameString = hprofStringById(classNameStringId)
     return proguardMapping?.deobfuscateClassName(classNameString) ?: classNameString
   }
diff --git a/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt b/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt
index d3488191..54658e88 100644
--- a/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt
+++ b/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt
@@ -24,9 +24,7 @@ internal class SortedBytesMap(
       return null
     }
     val valueIndex = keyIndex * bytesPerEntry + bytesPerKey
-    return ByteSubArray(
-        sortedEntries, valueIndex until valueIndex + bytesPerValue, longIdentifiers
-    )
+    return ByteSubArray(sortedEntries, valueIndex, bytesPerValue, longIdentifiers)
   }
 
   operator fun contains(key: Long): Boolean {
@@ -38,9 +36,7 @@ internal class SortedBytesMap(
     return (0 until size).asSequence()
         .map { keyIndex ->
           val valueIndex = keyIndex * bytesPerEntry + bytesPerKey
-          keyAt(keyIndex) to ByteSubArray(
-              sortedEntries, valueIndex until valueIndex + bytesPerValue, longIdentifiers
-          )
+          keyAt(keyIndex) to ByteSubArray(sortedEntries, valueIndex, bytesPerValue, longIdentifiers)
         }
   }
 
diff --git a/shark-graph/src/main/java/shark/internal/UnsortedByteEntries.kt b/shark-graph/src/main/java/shark/internal/UnsortedByteEntries.kt
index 698ca66a..9dfc81dd 100644
--- a/shark-graph/src/main/java/shark/internal/UnsortedByteEntries.kt
+++ b/shark-graph/src/main/java/shark/internal/UnsortedByteEntries.kt
@@ -163,8 +163,11 @@ internal class UnsortedByteEntries(
       }
       var pos = ((assigned - 1) * bytesPerEntry) + index
       val values = entries!!
-      for (shift in ((byteCount - 1) * 8) downTo 8 step 8) {
+
+      var shift = (byteCount - 1) * 8
+      while(shift >= 8) {
         values[pos++] = (value ushr shift and 0xffL).toByte()
+        shift -= 8
       }
       values[pos] = (value and 0xffL).toByte()
     }
diff --git a/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt b/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
index 25ab8c96..a37d1ceb 100644
--- a/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
+++ b/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
@@ -133,9 +133,15 @@ class LongLongScatterMap {
     }
   }
 
-  operator fun get(key: Long): Long? {
+  /**
+   * Being given a key looks it up in the map and returns the slot where element sits, so it later
+   * can be retrieved with [getSlotValue]; return '-1' if element not found.
+   * Why so complicated and not just make [get] return null if value not found? The reason is performance:
+   * this approach prevents unnecessary boxing of the primitive long that would happen with nullable Long?
+   */
+  fun getSlot(key: Long): Int {
     if (key == 0L) {
-      return if (hasEmptyKey) values[mask + 1] else null
+      return if (hasEmptyKey) mask + 1 else -1
     } else {
       val keys = this.keys
       val mask = this.mask
@@ -144,16 +150,31 @@ class LongLongScatterMap {
       var existing = keys[slot]
       while (existing != 0L) {
         if (existing == key) {
-          return values[slot]
+          return slot
         }
         slot = slot + 1 and mask
         existing = keys[slot]
       }
 
-      return null
+      return -1
     }
   }
 
+  /**
+   * Being given a slot of element retrieves it from the collection
+   */
+  fun getSlotValue(slot: Int): Long = values[slot]
+
+  /**
+   * Returns an element matching a provided [key]; throws [IllegalArgumentException] if element not found
+   */
+  operator fun get(key: Long): Long {
+    val slot = getSlot(key)
+    require(slot != -1) { "Unknown key $key" }
+
+    return getSlotValue(slot)
+  }
+
   fun forEach(block: (Long, Long) -> Unit) {
     val max = mask + 1
     var slot = -1
diff --git a/shark-hprof/src/main/java/shark/HprofReader.kt b/shark-hprof/src/main/java/shark/HprofReader.kt
index 4b126963..685e98c1 100644
--- a/shark-hprof/src/main/java/shark/HprofReader.kt
+++ b/shark-hprof/src/main/java/shark/HprofReader.kt
@@ -213,7 +213,9 @@ class HprofReader constructor(
         HEAP_DUMP, HEAP_DUMP_SEGMENT -> {
           val heapDumpStart = position
           var previousTag = 0
+          var previousTagPosition = 0L
           while (position - heapDumpStart < length) {
+            val heapDumpTagPosition = position
             val heapDumpTag = readUnsignedByte()
 
             when (heapDumpTag) {
@@ -491,10 +493,11 @@ class HprofReader constructor(
                 }
               }
               else -> throw IllegalStateException(
-                  "Unknown tag $heapDumpTag after $previousTag"
+                  "Unknown tag ${"0x%02x".format(heapDumpTag)} at $heapDumpTagPosition after ${"0x%02x".format(previousTag)} at $previousTagPosition"
               )
             }
             previousTag = heapDumpTag
+            previousTagPosition = heapDumpTagPosition
           }
         }
         HEAP_DUMP_END -> {
@@ -944,7 +947,7 @@ class HprofReader constructor(
     skip(identifierByteSize + INT_SIZE)
     val arrayLength = readInt()
     val type = readUnsignedByte()
-    skip(identifierByteSize + arrayLength * typeSize(type))
+    skip(arrayLength * typeSize(type))
   }
 
   private fun readHeapDumpInfoRecord(): HeapDumpInfoRecord {
diff --git a/shark-hprof/src/test/java/HeapDumpRule.kt b/shark-hprof/src/test/java/HeapDumpRule.kt
new file mode 100644
index 00000000..bafd457e
--- /dev/null
+++ b/shark-hprof/src/test/java/HeapDumpRule.kt
@@ -0,0 +1,33 @@
+import com.sun.management.HotSpotDiagnosticMXBean
+import org.junit.rules.ExternalResource
+import org.junit.rules.TemporaryFolder
+
+import java.io.File
+import java.io.IOException
+import java.lang.management.ManagementFactory
+import java.util.UUID
+
+class HeapDumpRule : ExternalResource() {
+    private val temporaryFolder = TemporaryFolder()
+
+    @Throws(Throwable::class)
+    override fun before() {
+        temporaryFolder.create()
+    }
+
+    override fun after() {
+        temporaryFolder.delete()
+    }
+
+    @Throws(IOException::class)
+    fun dumpHeap(): File {
+        val hotSpotDiag = ManagementFactory.newPlatformMXBeanProxy(
+                ManagementFactory.getPlatformMBeanServer(),
+                "com.sun.management:type=HotSpotDiagnostic",
+                HotSpotDiagnosticMXBean::class.java
+        )
+        val hprof = File(temporaryFolder.root, "heapDump" + UUID.randomUUID() + ".hprof")
+        hotSpotDiag.dumpHeap(hprof.absolutePath, true)
+        return hprof
+    }
+}
diff --git a/shark-hprof/src/test/java/HprofReaderPrimitiveArrayTest.kt b/shark-hprof/src/test/java/HprofReaderPrimitiveArrayTest.kt
new file mode 100644
index 00000000..10fb7616
--- /dev/null
+++ b/shark-hprof/src/test/java/HprofReaderPrimitiveArrayTest.kt
@@ -0,0 +1,45 @@
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Rule
+import org.junit.Test
+import shark.Hprof
+import shark.HprofRecord
+import shark.OnHprofRecordListener
+import kotlin.text.Charsets.UTF_8
+
+class HprofReaderPrimitiveArrayTest {
+
+    @get:Rule
+    var heapDumpRule = HeapDumpRule()
+
+    @Test
+    fun skips_primitive_arrays_correctly() {
+        val heapDump = heapDumpRule.dumpHeap()
+
+        Hprof.open(heapDump).use { hprof ->
+            hprof.reader.readHprofRecords(
+                    emptySet(), // skip everything including primitive arrays
+                    OnHprofRecordListener { _, _ -> })
+        }
+    }
+
+    @Test
+    fun reads_primitive_arrays_correctly() {
+        val byteArray = "mybytes".toByteArray(UTF_8)
+
+        val heapDump = heapDumpRule.dumpHeap()
+
+        var myByteArrayIsInHeapDump = false
+        Hprof.open(heapDump).use { hprof ->
+            hprof.reader.readHprofRecords(
+                    setOf(HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord::class),
+                    OnHprofRecordListener { _, record ->
+                        if (record is HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump) {
+                            if (byteArray.contentEquals(record.array)) {
+                                myByteArrayIsInHeapDump = true
+                            }
+                        }
+                    })
+        }
+        assertThat(myByteArrayIsInHeapDump).isTrue()
+    }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/HeapAnalyzer.kt b/shark/src/main/java/shark/HeapAnalyzer.kt
index bfeb6bde..1ad4ca5b 100644
--- a/shark/src/main/java/shark/HeapAnalyzer.kt
+++ b/shark/src/main/java/shark/HeapAnalyzer.kt
@@ -48,7 +48,7 @@ import shark.internal.PathFinder
 import shark.internal.PathFinder.PathFindingResults
 import shark.internal.ReferencePathNode
 import shark.internal.ReferencePathNode.ChildNode
-import shark.internal.ReferencePathNode.ChildNode.LibraryLeakNode
+import shark.internal.ReferencePathNode.LibraryLeakNode
 import shark.internal.ReferencePathNode.RootNode
 import shark.internal.lastSegment
 import java.io.File
@@ -308,8 +308,9 @@ class HeapAnalyzer constructor(
       sizedMoved = false
       pathsToLeakingInstances.map { it.objectId }
           .forEach { leakingInstanceId ->
-            val dominator = dominatedInstances[leakingInstanceId]
-            if (dominator != null) {
+            val dominatorSlot = dominatedInstances.getSlot(leakingInstanceId)
+            if (dominatorSlot != -1) {
+              val dominator = dominatedInstances.getSlotValue(dominatorSlot)
               val retainedSize = sizeByDominator.getValue(leakingInstanceId)
               if (retainedSize > 0) {
                 sizeByDominator[leakingInstanceId] = 0
@@ -352,7 +353,7 @@ class HeapAnalyzer constructor(
       val className =
         recordClassName(graph.findObjectById(pathNode.objectId))
 
-      val firstLibraryLeakNode =
+      val firstLibraryLeakNode = if (rootNode is LibraryLeakNode) rootNode else
         shortestChildPath.firstOrNull { it is LibraryLeakNode } as LibraryLeakNode?
 
       if (firstLibraryLeakNode != null) {
diff --git a/shark/src/main/java/shark/ReferencePattern.kt b/shark/src/main/java/shark/ReferencePattern.kt
index 9de31795..eb17d5ed 100644
--- a/shark/src/main/java/shark/ReferencePattern.kt
+++ b/shark/src/main/java/shark/ReferencePattern.kt
@@ -13,9 +13,7 @@ sealed class ReferencePattern : Serializable {
   data class JavaLocalPattern(
     val threadName: String
   ) : ReferencePattern() {
-    override fun toString(): String {
-      return "local variable on thread $threadName"
-    }
+    override fun toString() = "local variable on thread $threadName"
   }
 
   /**
@@ -25,9 +23,7 @@ sealed class ReferencePattern : Serializable {
     val className: String,
     val fieldName: String
   ) : ReferencePattern() {
-    override fun toString(): String {
-      return "static field $className#$fieldName"
-    }
+    override fun toString() = "static field $className#$fieldName"
   }
 
   /**
@@ -42,8 +38,15 @@ sealed class ReferencePattern : Serializable {
     val className: String,
     val fieldName: String
   ) : ReferencePattern() {
-    override fun toString(): String {
-      return "instance field $className#$fieldName"
-    }
+    override fun toString() = "instance field $className#$fieldName"
+  }
+
+  /**
+   * Matches native global variables (also known as jni global gc roots) that reference
+   * Java objects. The class name will match against classes, instances and object arrays with
+   * a matching class name.
+   */
+  data class NativeGlobalVariablePattern(val className: String) : ReferencePattern() {
+    override fun toString() = "native global variable referencing $className"
   }
 }
\ No newline at end of file
diff --git a/shark/src/main/java/shark/internal/PathFinder.kt b/shark/src/main/java/shark/internal/PathFinder.kt
index d3553c28..30bb3bfe 100644
--- a/shark/src/main/java/shark/internal/PathFinder.kt
+++ b/shark/src/main/java/shark/internal/PathFinder.kt
@@ -17,6 +17,7 @@ package shark.internal
 
 import shark.GcRoot
 import shark.GcRoot.JavaFrame
+import shark.GcRoot.JniGlobal
 import shark.GcRoot.ThreadObject
 import shark.HeapGraph
 import shark.HeapObject
@@ -38,12 +39,16 @@ import shark.PrimitiveType.INT
 import shark.ReferenceMatcher
 import shark.ReferencePattern
 import shark.ReferencePattern.InstanceFieldPattern
+import shark.ReferencePattern.NativeGlobalVariablePattern
 import shark.ReferencePattern.StaticFieldPattern
 import shark.SharkLog
 import shark.ValueHolder
-import shark.internal.ReferencePathNode.ChildNode.LibraryLeakNode
+import shark.internal.ReferencePathNode.ChildNode.LibraryLeakChildNode
 import shark.internal.ReferencePathNode.ChildNode.NormalNode
+import shark.internal.ReferencePathNode.LibraryLeakNode
 import shark.internal.ReferencePathNode.RootNode
+import shark.internal.ReferencePathNode.RootNode.LibraryLeakRootNode
+import shark.internal.ReferencePathNode.RootNode.NormalRootNode
 import shark.internal.hppc.LongLongScatterMap
 import shark.internal.hppc.LongScatterSet
 import java.util.ArrayDeque
@@ -106,11 +111,13 @@ internal class PathFinder(
   private val fieldNameByClassName: Map<String, Map<String, ReferenceMatcher>>
   private val staticFieldNameByClassName: Map<String, Map<String, ReferenceMatcher>>
   private val threadNameReferenceMatchers: Map<String, ReferenceMatcher>
+  private val jniGlobalReferenceMatchers: Map<String, ReferenceMatcher>
 
   init {
     val fieldNameByClassName = mutableMapOf<String, MutableMap<String, ReferenceMatcher>>()
     val staticFieldNameByClassName = mutableMapOf<String, MutableMap<String, ReferenceMatcher>>()
     val threadNames = mutableMapOf<String, ReferenceMatcher>()
+    val jniGlobals = mutableMapOf<String, ReferenceMatcher>()
 
     referenceMatchers.filter {
       (it is IgnoredReferenceMatcher || (it is LibraryLeakReferenceMatcher && it.patternApplies(
@@ -140,11 +147,15 @@ internal class PathFinder(
               }
               map[pattern.fieldName] = referenceMatcher
             }
+            is NativeGlobalVariablePattern -> {
+              jniGlobals[pattern.className] = referenceMatcher
+            }
           }
         }
     this.fieldNameByClassName = fieldNameByClassName
     this.staticFieldNameByClassName = staticFieldNameByClassName
     this.threadNameReferenceMatchers = threadNames
+    this.jniGlobalReferenceMatchers = jniGlobals
   }
 
   fun findPathsFromGcRoots(
@@ -243,35 +254,49 @@ internal class PathFinder(
       when (gcRoot) {
         is ThreadObject -> {
           threadsBySerialNumber[gcRoot.threadSerialNumber] = objectRecord.asInstance!! to gcRoot
-          enqueue(RootNode(gcRoot, gcRoot.id))
+          enqueue(NormalRootNode(gcRoot.id, gcRoot))
         }
         is JavaFrame -> {
           val (threadInstance, threadRoot) = threadsBySerialNumber.getValue(
               gcRoot.threadSerialNumber
           )
           val threadName = threadNames[threadInstance] ?: {
-            val name = threadInstance[Thread::class, "name"]?.value?.readAsJavaString()?:""
+            val name = threadInstance[Thread::class, "name"]?.value?.readAsJavaString() ?: ""
             threadNames[threadInstance] = name
             name
           }()
           val referenceMatcher = threadNameReferenceMatchers[threadName]
 
           if (referenceMatcher !is IgnoredReferenceMatcher) {
-            val rootNode = RootNode(gcRoot, threadRoot.id)
+            val rootNode = NormalRootNode(threadRoot.id, gcRoot)
             // Unfortunately Android heap dumps do not include stack trace data, so
             // JavaFrame.frameNumber is always -1 and we cannot know which method is causing the
             // reference to be held.
             val leakReference = LeakReference(LOCAL, "")
 
             val childNode = if (referenceMatcher is LibraryLeakReferenceMatcher) {
-              LibraryLeakNode(gcRoot.id, rootNode, leakReference, referenceMatcher)
+              LibraryLeakChildNode(gcRoot.id, rootNode, leakReference, referenceMatcher)
             } else {
               NormalNode(gcRoot.id, rootNode, leakReference)
             }
             enqueue(childNode)
           }
         }
-        else -> enqueue(RootNode(gcRoot, gcRoot.id))
+        is JniGlobal -> {
+          val referenceMatcher = when (objectRecord) {
+            is HeapClass -> jniGlobalReferenceMatchers[objectRecord.name]
+            is HeapInstance -> jniGlobalReferenceMatchers[objectRecord.instanceClassName]
+            is HeapObjectArray -> jniGlobalReferenceMatchers[objectRecord.arrayClassName]
+            is HeapPrimitiveArray -> jniGlobalReferenceMatchers[objectRecord.arrayClassName]
+          }
+          if (referenceMatcher !is IgnoredReferenceMatcher) {
+            if (referenceMatcher is LibraryLeakReferenceMatcher)
+              enqueue(LibraryLeakRootNode(gcRoot.id, gcRoot, referenceMatcher))
+          } else {
+            enqueue(NormalRootNode(gcRoot.id, gcRoot))
+          }
+        }
+        else -> enqueue(NormalRootNode(gcRoot.id, gcRoot))
       }
     }
   }
@@ -307,7 +332,7 @@ internal class PathFinder(
           val objectExists = graph.objectExists(gcRoot.id)
           if (!objectExists) {
             SharkLog.d {
-                "${gcRoot::class.java.simpleName} gc root ignored because it's pointing to unknown object @${gcRoot.id}"
+              "${gcRoot::class.java.simpleName} gc root ignored because it's pointing to unknown object @${gcRoot.id}"
             }
           }
           objectExists
@@ -348,7 +373,7 @@ internal class PathFinder(
 
       val node = when (val referenceMatcher = ignoredStaticFields[fieldName]) {
         null -> NormalNode(objectId, parent, LeakReference(STATIC_FIELD, fieldName))
-        is LibraryLeakReferenceMatcher -> LibraryLeakNode(
+        is LibraryLeakReferenceMatcher -> LibraryLeakChildNode(
             objectId, parent, LeakReference(STATIC_FIELD, fieldName), referenceMatcher
         )
         is IgnoredReferenceMatcher -> null
@@ -397,7 +422,7 @@ internal class PathFinder(
         if (threadLocalValuesMatcher != null && field.declaringClass.name == "java.lang.Thread" && field.name == "localValues") {
           // Earlier Android versions store local references in a Thread.localValues field.
           if (threadLocalValuesMatcher is LibraryLeakReferenceMatcher) {
-            LibraryLeakNode(
+            LibraryLeakChildNode(
                 objectId, parent, LeakReference(INSTANCE_FIELD, field.name),
                 threadLocalValuesMatcher
             )
@@ -407,7 +432,7 @@ internal class PathFinder(
         } else when (val referenceMatcher = fieldReferenceMatchers[field.name]) {
           null -> NormalNode(objectId, parent, LeakReference(INSTANCE_FIELD, field.name))
           is LibraryLeakReferenceMatcher ->
-            LibraryLeakNode(
+            LibraryLeakChildNode(
                 objectId, parent, LeakReference(INSTANCE_FIELD, field.name), referenceMatcher
             )
           is IgnoredReferenceMatcher -> null
@@ -552,42 +577,54 @@ internal class PathFinder(
     objectId: Long,
     neverEnqueued: Boolean
   ) {
-    val currentDominator = dominatedObjectIds[objectId]
-    if (currentDominator == null && (objectId in visitedSet || objectId in toVisitSet || objectId in toVisitLastSet)) {
+    val currentDominatorSlot = dominatedObjectIds.getSlot(objectId)
+    if (currentDominatorSlot == -1 && (objectId in visitedSet || objectId in toVisitSet || objectId in toVisitLastSet)) {
       return
     }
-    val parentDominator = dominatedObjectIds[parent]
+    val parentDominatorSlot = dominatedObjectIds.getSlot(parent)
 
     val parentIsRetainedObject = parent in leakingObjectIds
 
-    val nextDominator = if (parentIsRetainedObject) parent else parentDominator
-
-    if (nextDominator == null) {
+    if (!parentIsRetainedObject && parentDominatorSlot == -1) {
       // parent is not a retained instance and parent has no dominator, but it must have been
       // visited therefore we know parent belongs to undominated.
       if (neverEnqueued) {
         visitedSet.add(objectId)
       }
 
-      if (currentDominator != null) {
+      if (currentDominatorSlot != -1) {
         dominatedObjectIds.remove(objectId)
       }
       return
     }
-    if (currentDominator == null) {
+    val nextDominator =
+      if (parentIsRetainedObject) parent else dominatedObjectIds.getSlotValue(parentDominatorSlot)
+    if (currentDominatorSlot == -1) {
       dominatedObjectIds[objectId] = nextDominator
     } else {
       val parentDominators = mutableListOf<Long>()
       val currentDominators = mutableListOf<Long>()
-      var dominator: Long? = nextDominator
-      while (dominator != null) {
+      var stop = false
+      var dominator: Long = nextDominator
+      while (!stop) {
         parentDominators.add(dominator)
-        dominator = dominatedObjectIds[dominator]
+        val nextDominatorSlot = dominatedObjectIds.getSlot(dominator)
+        if (nextDominatorSlot == -1) {
+          stop = true
+        } else {
+          dominator = dominatedObjectIds.getSlotValue(nextDominatorSlot)
+        }
       }
-      dominator = currentDominator
-      while (dominator != null) {
+      stop = false
+      dominator = dominatedObjectIds.getSlotValue(currentDominatorSlot)
+      while (!stop) {
         currentDominators.add(dominator)
-        dominator = dominatedObjectIds[dominator]
+        val nextDominatorSlot = dominatedObjectIds.getSlot(dominator)
+        if (nextDominatorSlot == -1) {
+          stop = true
+        } else {
+          dominator = dominatedObjectIds.getSlotValue(nextDominatorSlot)
+        }
       }
 
       var sharedDominator: Long? = null
diff --git a/shark/src/main/java/shark/internal/ReferencePathNode.kt b/shark/src/main/java/shark/internal/ReferencePathNode.kt
index 3e2c0e62..bf83a23b 100644
--- a/shark/src/main/java/shark/internal/ReferencePathNode.kt
+++ b/shark/src/main/java/shark/internal/ReferencePathNode.kt
@@ -7,10 +7,25 @@ import shark.LibraryLeakReferenceMatcher
 internal sealed class ReferencePathNode {
   abstract val objectId: Long
 
-  class RootNode(
-    val gcRoot: GcRoot,
-    override val objectId: Long
-  ) : ReferencePathNode()
+  interface LibraryLeakNode {
+    val matcher: LibraryLeakReferenceMatcher
+  }
+
+  sealed class RootNode : ReferencePathNode() {
+    abstract val gcRoot: GcRoot
+
+    class LibraryLeakRootNode(
+      override val objectId: Long,
+      override val gcRoot: GcRoot,
+      override val matcher: LibraryLeakReferenceMatcher
+    ) : RootNode(), LibraryLeakNode
+
+    class NormalRootNode(
+      override val objectId: Long,
+      override val gcRoot: GcRoot
+    ) : RootNode()
+
+  }
 
   sealed class ChildNode : ReferencePathNode() {
 
@@ -21,12 +36,12 @@ internal sealed class ReferencePathNode {
      */
     abstract val referenceFromParent: LeakReference
 
-    class LibraryLeakNode(
+    class LibraryLeakChildNode(
       override val objectId: Long,
       override val parent: ReferencePathNode,
       override val referenceFromParent: LeakReference,
-      val matcher: LibraryLeakReferenceMatcher
-    ) : ChildNode()
+      override val matcher: LibraryLeakReferenceMatcher
+    ) : ChildNode(), LibraryLeakNode
 
     class NormalNode(
       override val objectId: Long,
diff --git a/shark/src/test/java/shark/ReferenceMatcherTest.kt b/shark/src/test/java/shark/ReferenceMatcherTest.kt
index bf1c1007..f9831986 100644
--- a/shark/src/test/java/shark/ReferenceMatcherTest.kt
+++ b/shark/src/test/java/shark/ReferenceMatcherTest.kt
@@ -5,9 +5,12 @@ import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
+import shark.GcRoot.JniGlobal
 import shark.ReferencePattern.InstanceFieldPattern
 import shark.ReferencePattern.JavaLocalPattern
+import shark.ReferencePattern.NativeGlobalVariablePattern
 import shark.ReferencePattern.StaticFieldPattern
+import shark.ValueHolder.ReferenceHolder
 import java.io.File
 import java.lang.ref.WeakReference
 
@@ -116,4 +119,39 @@ class ReferenceMatcherTest {
     assertThat(analysis.libraryLeaks).isEmpty()
   }
 
+  @Test fun nativeGlobalVariableLibraryLeak() {
+    hprofFile.dump {
+      gcRoot(JniGlobal(id = "Leaking".watchedInstance {}.value, jniGlobalRefId = 42))
+    }
+
+    val matcher = LibraryLeakReferenceMatcher(NativeGlobalVariablePattern("Leaking"))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        referenceMatchers = listOf(matcher)
+    )
+    val leak = analysis.libraryLeaks[0]
+    assertThat(leak.pattern).isEqualTo(matcher.pattern)
+  }
+
+  @Test fun nativeGlobalVariableShortestPathExcluded() {
+    hprofFile.dump {
+      val leaking = instance(clazz("Leaking"))
+      keyedWeakReference(leaking)
+      val hasLeaking = instance(
+          clazz("HasLeaking", fields = listOf("leaking" to ReferenceHolder::class)),
+          fields = listOf(leaking)
+      )
+      clazz("GcRoot", staticFields = listOf("longestPath" to hasLeaking))
+      gcRoot(JniGlobal(id = leaking.value, jniGlobalRefId = 42))
+    }
+
+    val matcher = LibraryLeakReferenceMatcher(NativeGlobalVariablePattern("Leaking"))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        referenceMatchers = listOf(matcher)
+    )
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.leakTrace.elements).hasSize(3)
+    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
+    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("longestPath")
+  }
+
 }
\ No newline at end of file
