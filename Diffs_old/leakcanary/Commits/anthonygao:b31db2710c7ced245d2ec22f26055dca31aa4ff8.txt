diff --git a/CONTRIBUTING.md b/.github/CONTRIBUTING.md
similarity index 100%
rename from CONTRIBUTING.md
rename to .github/CONTRIBUTING.md
diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
new file mode 100644
index 00000000..a6e3c3d1
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE.md
@@ -0,0 +1,29 @@
+Welcome and thank you for reporting an issue!
+
+First, **verify that your issue hasn't already been reported** by searching over all issues: https://github.com/square/leakcanary/issues?q=is%3Aissue.
+
+What kind of issue is this?
+
+ - **Question**: This issue tracker is not the place for questions. If you want to ask how to do
+   something, or to understand why something isn't working the way you expect it to, use Stack
+   Overflow: https://stackoverflow.com/questions/tagged/leakcanary.
+
+ - **Help me fix a leak?**: Please do not file an issue.
+   Instead, read here: https://github.com/square/leakcanary/#how-do-i-fix-a-memory-leak
+ 
+ - **Leak analysis failed**: if it's an OutOfMemoryError, no need to report it. See https://github.com/square/leakcanary/wiki/Future#low-memory-leak-analysis
+
+ - **Bug report**: If you’ve found a bug, spend the time to write a failing test. Bugs with tests get fixed. 
+   Here’s an example: https://gist.github.com/swankjesse/981fcae102f513eb13ed
+   
+ - **Feature Request**: Start by telling us what problem you’re trying to solve. Don’t send pull requests to implement 
+   new features without first getting our support. Sometimes we leave features out on purpose to keep the project small.
+
+^^^^^ DELETE FROM THIS LINE UP ^^^^^
+
+
+```
+
+REPLACE THIS LINE WITH YOUR STACKTRACE OR OUTPUT FROM LEAKCANARY
+
+```
diff --git a/.travis.yml b/.travis.yml
index ad327f32..f56fb04c 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -2,15 +2,18 @@ language: android
 
 android:
   components:
+    # Update tools and then platform-tools explicitly so lint gets an updated database. Can be removed once 3.0 is out.
     - tools
     - platform-tools
-    - build-tools-23.0.2
-    - android-23
 
 jdk:
-  - oraclejdk7
   - oraclejdk8
 
+before_install:
+  # Install SDK license so Android Gradle plugin can install deps.
+  - mkdir "$ANDROID_HOME/licenses" || true
+  - echo "d56f5187479451eabf01fb78af6dfcb131a6481e" > "$ANDROID_HOME/licenses/android-sdk-license"
+
 script:
   - ./gradlew clean build
 
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 064b12c7..b4e2c55d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,41 +1,88 @@
 # Change Log
 
-You can watch releases [on Bintray](https://bintray.com/pyricau/maven/com.squareup.leakcanary%3Aleakcanary-android/view?source=watch).
+## Version 1.5.4 *(2017-09-22)*
 
-## Version 1.4-SNAPSHOT
+* Restore Java 7 compatibility in leakcanary-watcher
 
-Nothing yet.
+## Version 1.5.3 *(2017-09-17)*
 
-### Public API changes
+* Fix broken 1.5.2 [build](https://github.com/square/leakcanary/issues/815)
+* Convert leakcanary-watcher from Android library to Java library
+* Disable finish animations in RequestStoragePermissionActivity
+* Corrected README sample for Robolectric tests
 
-Nothing yet.
+For more details, see the [full diff](https://github.com/square/leakcanary/compare/v1.5.2...v1.5.3).
 
-### Dependencies
+## Version 1.5.2 *(2017-08-09)*
 
-```gradle
- dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.4-SNAPSHOT'
-   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.4-SNAPSHOT'
- }
-```
+* New excluded leaks
+* Move Leakcanary UI into leak analyzer process
+* Ignore computing retained sizes for bitmaps on O+
+* Add notification channel for persistent messages on O+
+* Exclude permission activity from recents menu
+* Updated README and sample for handling Robolectric tests
 
-Snapshots are available in Sonatype's `snapshots` repository:
+For more details, see the [full diff](https://github.com/square/leakcanary/compare/v1.5.1...v1.5.2).
 
-```
-  repositories {
-    mavenCentral()
-    maven {
-      url 'https://oss.sonatype.org/content/repositories/snapshots/'
-    }
-  }
-```
+## Version 1.5.1 *(2017-04-25)*
 
-[![Build Status](https://travis-ci.org/square/leakcanary.svg?branch=master)](https://travis-ci.org/square/leakcanary)
+* New excluded leaks
+* Fix java.util.MissingFormatArgumentException in DisplayLeakService
+* Separate task affinities for different apps
+* Bump minSdk to 14
+* Fix HahaHelper for O Preview
+  
+For more details, see the [full diff](https://github.com/square/leakcanary/compare/v1.5...v1.5.1).
 
+## Version 1.5 *(2016-09-28)*
 
-## Version 1.4-beta1 *(2016-01-08)*
+* New excluded leaks
+* Added `LeakCanary.isInAnalyzerProcess()` to the no-op jar
+* Fixed several file access issues:
+  * No more cleanup on startup, we rotate the heap dump files on every new heap dump.
+  * LeakCanary now falls back to the app directory until it can write to the external storage.
+* Leak notifications now each use a distinct notification instead of erasing each other.
+* If LeakCanary can't perform a heap dump for any reason (e.g. analysis in progress, debugger attached), it retries later with an exponential backoff.
+* Added confirmation dialog when user deletes all leaks.
+* Replace the two LeakCanary configuration methods with a builder that provides more flexibility, see `LeakCanary.refWatcher()`.
 
-All actual changes are [tracked here](https://github.com/square/leakcanary/pulls?utf8=%E2%9C%93&q=milestone%3A1.4+is%3Apr).
+For more details, see the [full diff](https://github.com/square/leakcanary/compare/v1.4...v1.5).
+
+### Public API changes
+
+* New `HeapAnalyzer.findTrackedReferences()` method for headless analysis when you have no context on what leaked.
+* Added `LeakCanary.isInAnalyzerProcess()` to the no-op jar
+* Added `LeakCanary.refWatcher()` which returns an `AndroidRefWatcherBuilder` that extends `RefWatcherBuilder` and lets you fully customize the `RefWatcher` instance.
+* Removed `LeakCanary.install(Application, Class)` and `LeakCanary.androidWatcher(Context, HeapDump.Listener, ExcludedRefs)`.
+* Removed `R.integer.leak_canary_max_stored_leaks` and `R.integer.leak_canary_watch_delay_millis`, those can now be set via `LeakCanary.refWatcher()`.
+* Updated the `LeakDirectoryProvider` API to centralize all file related responsibilities.
+* `RefWatcher` is now constructed with a `WatchExecutor` which executes a `Retryable`, instead of an `Executor` that executes a `Runnable`.
+* `HeapDumper.NO_DUMP` was renamed `HeapDumper.RETRY_LATER`
+
+## Version 1.4 *(2016-09-11)*
+
+* Fix false negative where GC root is of type android.os.Binder [#482](https://github.com/square/leakcanary/issues/482)
+* Update HAHA to 2.0.3; clear compiler warnings [#563](https://github.com/square/leakcanary/issues/563) 
+* Correct some mistakes in German translation [#516](https://github.com/square/leakcanary/pull/516)
+* Don't loop when storage permission denied [#422](https://github.com/square/leakcanary/issues/422)
+* Remove old references to "__" prefixed resources [#477](https://github.com/square/leakcanary/pull/477)
+* Fix permission crash for DisplayLeakActivity on M [#382](https://github.com/square/leakcanary/issues/382)
+* Fix NPE when thread name not found in heap dump [#417](https://github.com/square/leakcanary/issues/417)
+* Add version info to stacktrace [#473](https://github.com/square/leakcanary/issues/473)
+
+## Version 1.4-beta2 *(2016-03-23)*
+
+* Add reason for ignoring to analysis result [#365](https://github.com/square/leakcanary/issues/365).
+* Lower memory usage when parsing heap dumps on M [#223](https://github.com/square/leakcanary/issues/223).
+* Fix NPE in LeakCanaryInternals.isInServiceProcess() [#449](https://github.com/square/leakcanary/issues/449).
+* New ignored Android SDK leaks [#297](https://github.com/square/leakcanary/issues/297),[#322](https://github.com/square/leakcanary/issues/322).
+* Use leakcanary-android-no-op in test builds [#143](https://github.com/square/leakcanary/issues/143).
+* Fixes to allow LeakCanary to work with ProGuard [#398](https://github.com/square/leakcanary/pull/398).
+* Optimize png assets [#406](https://github.com/square/leakcanary/pull/406).
+* Fix delete button not working on error views [#408](https://github.com/square/leakcanary/pull/408).
+* Add German translation [#437](https://github.com/square/leakcanary/pull/437).
+
+## Version 1.4-beta1 *(2016-01-08)*
 
 * Switched to [HAHA 2.0.2](https://github.com/square/haha/blob/master/CHANGELOG.md#version-202-2015-07-20) with uses Perflib instead of MAT under the hood [#219](https://github.com/square/leakcanary/pull/219). This fixes crashes and improves speed a lot.
 * We can now parse Android M heap dumps [#267](https://github.com/square/leakcanary/issues/267), although there are still memory issues (see [#223](https://github.com/square/leakcanary/issues/223)).
@@ -57,15 +104,6 @@ All actual changes are [tracked here](https://github.com/square/leakcanary/pulls
 * Each `ExcludedRef` entry can now be ignored entirely or "kept only if no other path".
 * Added support for ignoring all fields (static and non static) for a given class.
 
-### Dependencies
-
-```gradle
- dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.4-beta1'
-   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.4-beta1'
- }
-```
-
 ## Version 1.3.1 *(2015-05-16)*
 
 * Heap dumps and analysis results are now saved on the sd card: [#21](https://github.com/square/leakcanary/issues/21).
@@ -93,29 +131,8 @@ All actual changes are [tracked here](https://github.com/square/leakcanary/pulls
 * `AndroidExcludedRefs.createAppDefaults()` & `AndroidExcludedRefs.createAndroidDefaults()` return a `ExcludedRef.Builder`.
 * `ExcludedRef` moved from `leakcanary-analyzer` to `leakcanary-watcher`
 
-### Dependencies
-
-```gradle
- dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3.1'
-   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.1'
- }
-```
-
-### Statistics
-
-* 33 commits to the LeakCanary library code and 11 commits to [HAHA](https://github.com/square/haha).
-* 6 contributors: [Pierre-Yves Ricau](https://github.com/square/leakcanary/commits?author=pyricau), [Sergey Shulepov](https://github.com/square/leakcanary/commits?author=pepyakin), [Romain Guy](https://github.com/square/leakcanary/commits?author=romainguy), [liaohuqiu](https://github.com/square/leakcanary/commits?author=liaohuqiu), [Dario Marcato](https://github.com/square/leakcanary/commits?author=dmarcato), [Anders Aagaard](https://github.com/square/leakcanary/commits?author=andaag).
-
 ## Version 1.3 *(2015-05-08)*
 
 Initial release.
 
 ### Dependencies
-
-```gradle
- dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3'
-   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3'
- }
-```
diff --git a/README.md b/README.md
index cb88617b..13682630 100644
--- a/README.md
+++ b/README.md
@@ -1,358 +1,72 @@
+
 # LeakCanary
 
 A memory leak detection library for Android and Java.
 
 *“A small leak will sink a great ship.”* - Benjamin Franklin
 
-![screenshot.png](assets/screenshot.png)
+<p align="center">
+<img src="https://github.com/square/leakcanary/blob/master/assets/screenshot.png"/>
+</p>
 
 ## Getting started
 
 In your `build.gradle`:
 
-```gradle
- dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3.1' // or 1.4-beta1
-   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.1' // or 1.4-beta1
-   testCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.1' // or 1.4-beta1
- }
-```
-
-In your `Application` class:
-
-```java
-public class ExampleApplication extends Application {
-
-  @Override public void onCreate() {
-    super.onCreate();
-    LeakCanary.install(this);
-  }
-}
-```
-
-**You're good to go!** LeakCanary will automatically show a notification when an activity memory leak is detected in your debug build.
-
-## Why should I use LeakCanary?
-
-Glad you ask! We wrote a [blog post](http://squ.re/leakcanary) to answer precisely that question.
-
-## How do I use it?
-
-Use a `RefWatcher` to watch references that should be GCed:
-
-```java
-RefWatcher refWatcher = {...};
-
-// We expect schrodingerCat to be gone soon (or not), let's watch it.
-refWatcher.watch(schrodingerCat);
-```
-
-`LeakCanary.install()` returns a pre configured `RefWatcher`.
-It also installs an `ActivityRefWatcher` that automatically detects if an activity is leaking after `Activity.onDestroy()` has been called.
-
-```java
-public class ExampleApplication extends Application {
-
-  public static RefWatcher getRefWatcher(Context context) {
-    ExampleApplication application = (ExampleApplication) context.getApplicationContext();
-    return application.refWatcher;
-  }
-
-  private RefWatcher refWatcher;
-
-  @Override public void onCreate() {
-    super.onCreate();
-    refWatcher = LeakCanary.install(this);
-  }
-}
-```
-
-You could use the `RefWatcher` to watch for fragment leaks:
-
-```java
-public abstract class BaseFragment extends Fragment {
-
-  @Override public void onDestroy() {
-    super.onDestroy();
-    RefWatcher refWatcher = ExampleApplication.getRefWatcher(getActivity());
-    refWatcher.watch(this);
-  }
+```groovy
+dependencies {
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.5.4'
+  releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.4'
 }
 ```
 
-## How does it work?
-
-1. `RefWatcher.watch()` creates a [KeyedWeakReference](https://github.com/square/leakcanary/blob/master/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java) to the watched object.
-2. Later, in a background thread, it checks if the reference has been cleared and if not it triggers a GC.
-3. If the reference is still not cleared, it then dumps the heap into a `.hprof` file stored on the app file system.
-4. `HeapAnalyzerService` is started in a separate process and `HeapAnalyzer` parses the heap dump using [HAHA](https://github.com/square/haha).
-5. `HeapAnalyzer` finds the `KeyedWeakReference` in the heap dump thanks to a unique reference key and locates the leaking reference.
-6. `HeapAnalyzer` computes the *shortest strong reference path to the GC Roots* to determine if there is a leak, and then builds the chain of references causing the leak.
-7. The result is passed back to `DisplayLeakService` in the app process, and the leak notification is shown.
-
-## How do I copy the leak trace?
-
-You can see the leak trace in Logcat:
-
-```
-In com.example.leakcanary:1.0:1 com.example.leakcanary.MainActivity has leaked:
-* GC ROOT thread java.lang.Thread.<Java Local> (named 'AsyncTask #1')
-* references com.example.leakcanary.MainActivity$3.this$0 (anonymous class extends android.os.AsyncTask)
-* leaks com.example.leakcanary.MainActivity instance
-
-* Reference Key: e71f3bf5-d786-4145-8539-584afaecad1d
-* Device: Genymotion generic Google Nexus 6 - 5.1.0 - API 22 - 1440x2560 vbox86p
-* Android Version: 5.1 API: 22
-* Durations: watch=5086ms, gc=110ms, heap dump=435ms, analysis=2086ms
-```
-
-You can also share the leak trace and the heap dump file from the **action bar menu**.
-
-## How do I fix a memory leak?
-
-Once you have the leak trace, figure out which reference in the path should not exist. Then figure out why that reference still exists. Often times it's a registered listener that should have been unregistered, a `close()` method that wasn't called, an anonymous class that holds a reference an outer class. If you cannot figure out an issue in your code, **please do not file an issue**. Instead, create a [Stack Overflow question](http://stackoverflow.com/questions/tagged/leakcanary) (using the *leakcanary* tag).
-
-## My leak is caused by the Android SDK implementation!
-
-There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: [AndroidExcludedRefs.java](https://github.com/square/leakcanary/blob/master/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java).
-
-If you find a new one, please [create an issue](https://github.com/square/leakcanary/issues/new) and follow these steps:
-
-1. Provide the entire leak trace information (reference key, device, etc).
-2. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions [android/platform_frameworks_base](https://github.com/android/platform_frameworks_base).
-3. Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed.
-4. If it's still happening, build a simple repro case
-5. File an issue on [b.android.com](http://b.android.com) with the leak trace and the repro case
-6. Create a PR in LeakCanary to update `AndroidExcludedRefs.java`. Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
-
-This is especially important for **new releases of Android**. You have the opportunity to help detect new memory leaks early on, which benefits the entire Android community. 
-
-## Beyond the leak trace
-
-Sometimes the leak trace isn't enough and you need to dig into the heap dump with [MAT](http://eclipse.org/mat/) or [YourKit](https://www.yourkit.com/). Here's how you can find the leaking instance in the head dump:
-
-1. Look for all instances of `com.squareup.leakcanary.KeyedWeakReference`
-2. For each of these, look at the `key` field.
-3. Find the `KeyedWeakReference` that has a `key` field equal to the reference key reported by LeakCanary.
-4. The `referent` field of that `KeyedWeakReference` is your leaking object.
-5. From then on, the matter is in your hands. A good start is to look at the shortest path to GC Roots (excluding weak references).
-
-## Customizing
-
-### Customizing and using the no-op dependency
-
-The `leakcanary-android-no-op` dependency for release builds only contains the `LeakCanary` and `RefWatcher` class. If you start customizing LeakCanary, you need to make sure that the customization happens only in debug build, since it will likely reference classes that do not exist in the `leakcanary-android-no-op` dependency.
-
-Let's say your release build declares an `ExampleApplication` class in `AndroidManifest.xml`, and your debug build declares a `DebugExampleApplication` that extends `ExampleApplication`.
-
-In your shared sources:
+In your `Application` class:
 
 ```java
 public class ExampleApplication extends Application {
 
-  public static RefWatcher getRefWatcher(Context context) {
-    ExampleApplication application = (ExampleApplication) context.getApplicationContext();
-    return application.refWatcher;
-  }
-
-  private RefWatcher refWatcher;
-
   @Override public void onCreate() {
     super.onCreate();
-    refWatcher = installLeakCanary();
-  }
-
-  protected RefWatcher installLeakCanary() {
-    return RefWatcher.DISABLED;
-  }
-}
-```
-
-In your debug sources:
-
-```java
-public class DebugExampleApplication extends ExampleApplication {
-  protected RefWatcher installLeakCanary() {
-	RefWatcher refWatcher = ? // Build a customized RefWatcher
-    return refWatcher;
-  }
-}
-```
-That way, your release code will contain no reference to LeakCanary other than the two empty classes that exist in the `leakcanary-android-no-op` dependency.
-
-### Icon and label
-
-`DisplayLeakActivity` comes with a default icon and label, which you can change by providing `R.drawable.__leak_canary_icon` and `R.string.__leak_canary_display_activity_label` in your app:
-
-```
-res/
-  drawable-hdpi/
-    __leak_canary_icon.png
-  drawable-mdpi/
-    __leak_canary_icon.png
-  drawable-xhdpi/
-    __leak_canary_icon.png
-  drawable-xxhdpi/
-    __leak_canary_icon.png
-  drawable-xxxhdpi/
-    __leak_canary_icon.png
-```
-
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-  <string name="__leak_canary_display_activity_label">MyLeaks</string>
-</resources>
-```
-
-### Stored leak traces
-
-`DisplayLeakActivity` saves up to 7 heap dumps & leak traces in the app directory. You can change that number by providing `R.integer.__leak_canary_max_stored_leaks` in your app:
-
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-  <integer name="__leak_canary_max_stored_leaks">20</integer>
-</resources>
-```
-
-### Watcher delay
-
-*Available in 1.4-SNAPSHOT*.
-
-You can change the delay until a reference is considered a memory leak by providing `R.integer.leak_canary_watch_delay_millis` in your app:
-
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-  <integer name="leak_canary_watch_delay_millis">1500</integer>
-</resources>
-```
-
-The default delay is 5 seconds.
-
-### Uploading to a server
-
-You can change the default behavior to upload the leak trace and heap dump to a server of your choosing.
-
-Create your own `AbstractAnalysisResultService`. The easiest way is to extend `DisplayLeakService` in your debug sources:
-
-```java
-public class LeakUploadService extends DisplayLeakService {
-  @Override protected void afterDefaultHandling(HeapDump heapDump, AnalysisResult result, String leakInfo) {
-    if (!result.leakFound || result.excludedLeak) {
+    if (LeakCanary.isInAnalyzerProcess(this)) {
+      // This process is dedicated to LeakCanary for heap analysis.
+      // You should not init your app in this process.
       return;
     }
-	myServer.uploadLeakBlocking(heapDump.heapDumpFile, leakInfo);
-  }
-}
-```
-
-Build a custom `RefWatcher` in your debug Application class:
-
-```java
-public class DebugExampleApplication extends ExampleApplication {
-  protected RefWatcher installLeakCanary() {
-    return LeakCanary.install(app, LeakUploadService.class, AndroidExcludedRefs.createAppDefaults().build());
-  }
-}
-```
-
-Don't forget to register the service in your debug `AndroidManifest.xml`:
-
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
-    >
-  <application android:name="com.example.DebugExampleApplication">
-    <service android:name="com.example.LeakUploadService" />
-  </application>
-</manifest>
-```
-
-You can also upload the leak traces to Slack or HipChat, [here's an example](https://gist.github.com/pyricau/06c2c486d24f5f85f7f0).
-
-### Ignoring specific references
-
-You can create your own version of `ExcludedRefs` to ignore specific references that you know are causing leaks but you still want to ignore:
-
-```java
-public class DebugExampleApplication extends ExampleApplication {
-  protected RefWatcher installLeakCanary() {
-    ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults()
-        .instanceField("com.example.ExampleClass", "exampleField")
-        .build();
-    return LeakCanary.install(this, DisplayLeakService.class, excludedRefs);
-  }
-}
-```
-
-### Not watching specific activity classes
-
-`ActivityRefWatcher` is installed by default and watches all activities. You can customize the installation steps to use something different instead:
-
-```java
-public class DebugExampleApplication extends ExampleApplication {
-  protected RefWatcher installLeakCanary() {
-    if (isInAnalyzerProcess(this)) {
-      return RefWatcher.DISABLED;
-    } else {
-      ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults().build();
-      enableDisplayLeakActivity(this);
-      ServiceHeapDumpListener heapDumpListener = new ServiceHeapDumpListener(this, DisplayLeakService.class);
-      final RefWatcher refWatcher = androidWatcher(this, heapDumpListener, excludedRefs);
-      registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() {
-        public void onActivityDestroyed(Activity activity) {
-          if (activity instanceof ThirdPartyActivity) {
-              return;
-          }
-          refWatcher.watch(activity);
-        }
-        // ...
-      });
-      return refWatcher;
-    }
+    LeakCanary.install(this);
+    // Normal app init code...
   }
 }
 ```
 
-### ProGuard
-
-If you use Proguard in your debug builds, make sure to keep the HAHA and LeakCanary classes:
-
-```
-# LeakCanary
--keep class org.eclipse.mat.** { *; }
--keep class com.squareup.leakcanary.** { *; }
-```
-
-## Snapshots of the development version
-
-See the [CHANGELOG](https://github.com/square/leakcanary/blob/master/CHANGELOG.md).
-
-## Troubleshooting
-
-* if `leakcanary-android` is not in the list of external libraries in Android Studio, but `leakcanary-analyzer` and `leakcanary-watcher` are there: try doing a `Clean Build`. If it's still a problem, try building from the command line.
-* `error: package com.squareup.leakcanary does not exist`: if you have other build types than `debug` and `release`, you need to add a specific dependency for those too (`xxxCompile`).
-
-## Resources
-
-* LeakCanary: Detect all memory leaks! [squ.re/leakcanary](http://squ.re/leakcanary).
-* Wrangling Dalvik series: [Memory management in Android](http://www.raizlabs.com/dev/2014/03/wrangling-dalvik-memory-management-in-android-part-1-of-2/).
-* Uploading leak traces to a [Slack or HipChat channel](https://gist.github.com/pyricau/06c2c486d24f5f85f7f0).
-* Dump the heap on [OutOfMemoryError crashes](https://gist.github.com/pyricau/4726389fd64f3b7c6f32).
-* StackOverflow: [leakcanary tag](http://stackoverflow.com/questions/tagged/leakcanary).
-
-### Translations
-
-* squ.re/leakcanary [in Chinese](http://www.liaohuqiu.net/cn/posts/leak-canary/).
-* squ.re/leakcanary [in Russian](http://habrahabr.ru/post/257633/).
-* `README.md` in Chinese: [中文版说明](http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/).
-
-![icon_512.png](assets/icon_512.png)
+**You're good to go!** LeakCanary will automatically show a notification when an activity memory leak is detected in your debug build.
 
-The name **LeakCanary** is a reference to the expression [canary in a coal mine](http://en.wiktionary.org/wiki/canary_in_a_coal_mine), because LeakCanary is a sentinel used to detect risks by providing advance warning of a danger. Props to [@edenman](https://github.com/edenman) for suggesting it!
+## FAQ
+
+* [Why should I use LeakCanary?](https://github.com/square/leakcanary/wiki/FAQ#why-should-i-use-leakcanary)
+* [How do I use it?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-use-it)
+* [How does it work?](https://github.com/square/leakcanary/wiki/FAQ#how-does-it-work)
+* [How do I customize LeakCanary to my needs?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-customize-leakcanary-to-my-needs)
+* [How do I copy the leak trace?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-copy-the-leak-trace)
+* [How do I fix a memory leak?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-fix-a-memory-leak)
+* [Can a leak be caused by the Android SDK?](https://github.com/square/leakcanary/wiki/FAQ#can-a-leak-be-caused-by-the-android-sdk)
+* [How can I dig beyond the leak trace?](https://github.com/square/leakcanary/wiki/FAQ#how-can-i-dig-beyond-the-leak-trace)
+* [How do I disable LeakCanary in tests?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-disable-leakcanary-in-tests)
+* [How do I fix build errors?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-fix-build-errors)
+* [How many methods does LeakCanary add?](https://github.com/square/leakcanary/wiki/FAQ#how-many-methods-does-leakcanary-add)
+* [Where can I learn more?](https://github.com/square/leakcanary/wiki/FAQ#where-can-i-learn-more)
+* [How do I use the SNAPSHOT version?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-use-the-snapshot-version)
+* [How can I be notified of new releases?](https://github.com/square/leakcanary/wiki/FAQ#how-can-i-be-notified-of-new-releases)
+* [Who's behind LeakCanary?](https://github.com/square/leakcanary/wiki/FAQ#whos-behind-leakcanary)
+* [Why is it called LeakCanary?](https://github.com/square/leakcanary/wiki/FAQ#why-is-it-called-leakcanary)
+* [Who made the logo?](https://github.com/square/leakcanary/wiki/FAQ#who-made-the-logo)
+* [Build error: Failed to resolve](https://github.com/square/leakcanary/wiki/FAQ#build-error-failed-to-resolve)
+* [Instant Run can trigger invalid leaks](https://github.com/square/leakcanary/wiki/FAQ#instant-run-can-trigger-invalid-leaks)
+* [I know I have a leak. Why doesn't the notification show?](https://github.com/square/leakcanary/wiki/FAQ#i-know-i-have-a-leak-why-doesnt-the-notification-show)
+
+
+<p align="center">
+<img src="https://github.com/square/leakcanary/blob/master/assets/icon_512.png" width="250"/>
+</p>
 
 ## License
 
diff --git a/assets/adaptative_icon.sketch b/assets/adaptative_icon.sketch
new file mode 100644
index 00000000..7978b281
Binary files /dev/null and b/assets/adaptative_icon.sketch differ
diff --git a/assets/icon_1024.png b/assets/icon_1024.png
index 5dfdcf84..f15c7586 100644
Binary files a/assets/icon_1024.png and b/assets/icon_1024.png differ
diff --git a/assets/icon_512.png b/assets/icon_512.png
index bb24dbad..0ca6bedf 100644
Binary files a/assets/icon_512.png and b/assets/icon_512.png differ
diff --git a/assets/screenshot.png b/assets/screenshot.png
index f68053b6..8faa278f 100644
Binary files a/assets/screenshot.png and b/assets/screenshot.png differ
diff --git a/assets/source_icon.png b/assets/source_icon.png
index 827e5552..d04aace6 100644
Binary files a/assets/source_icon.png and b/assets/source_icon.png differ
diff --git a/build.gradle b/build.gradle
index b0568c40..da721146 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,44 +1,64 @@
+apply plugin: 'com.github.ben-manes.versions'
+
+buildscript {
+  ext.versions = [
+    'minSdk': 14,
+    'compileSdk': 27,
+  ]
+  repositories {
+    jcenter()
+    google()
+    maven { url 'https://plugins.gradle.org/m2/' }
+  }
+  dependencies {
+    classpath 'com.android.tools.build:gradle:3.1.0'
+    classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.0.13'
+    classpath 'com.github.ben-manes:gradle-versions-plugin:0.17.0'
+  }
+}
+
 subprojects {
+  group = GROUP
+  version = VERSION_NAME
 
   repositories {
-    mavenCentral()
+    jcenter()
+    google()
 //    maven {
 //      url 'https://oss.sonatype.org/content/repositories/snapshots/'
 //    }
 //    mavenLocal()
   }
 
-  buildscript {
-    repositories {
-      mavenCentral()
-    }
-    dependencies {
-      classpath 'com.android.tools.build:gradle:1.5.0'
-    }
-  }
-}
-
-ext {
-  minSdkVersion = 8
-  compileSdkVersion = 23
-  targetSdkVersion = compileSdkVersion
-  buildToolsVersion = '23.0.2'
-  javaVersion = JavaVersion.VERSION_1_7
+  apply plugin: 'net.ltgt.errorprone'
 
-  GROUP = 'com.squareup.leakcanary'
-  VERSION_NAME = "1.4-SNAPSHOT"
-  POM_PACKAGING = "pom"
-  POM_DESCRIPTION= "Leak Canary"
-
-  POM_URL="http://github.com/square/leakcanary/"
-  POM_SCM_URL="http://github.com/square/leakcanary/"
-  POM_SCM_CONNECTION="scm:git:https://github.com/square/leakcanary.git"
-  POM_SCM_DEV_CONNECTION="scm:git:git@github.com:square/leakcanary.git"
+  tasks.withType(JavaCompile) {
+    options.compilerArgs += [
+      '-Xlint:all',
+      '-Xlint:-serial',
+      '-Xlint:-deprecation',
+      '-Werror'
+    ]
+  }
 
-  POM_LICENCE_NAME="The Apache Software License, Version 2.0"
-  POM_LICENCE_URL="http://www.apache.org/licenses/LICENSE-2.0.txt"
-  POM_LICENCE_DIST="repo"
+  configurations.all {
+    resolutionStrategy {
+      eachDependency { details ->
+        // Force all the error-prone dependencies to use the same version.
+        if (details.requested.group == 'com.google.errorprone' &&
+                details.requested.name.startsWith('error_prone_')) {
+          details.useVersion '2.1.2'
+        }
+      }
+    }
+  }
 
-  POM_DEVELOPER_ID="square"
-  POM_DEVELOPER_NAME="Square, Inc."
+  tasks.withType(Test) {
+    testLogging {
+      exceptionFormat 'FULL'
+      showCauses true
+      showExceptions true
+      showStackTraces true
+    }
+  }
 }
diff --git a/checkstyle.xml b/checkstyle.xml
index 7fb7ad32..ca4ebcc5 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -72,7 +72,9 @@
     <module name="AvoidStarImport"/>
     <module name="IllegalImport"/>
     <module name="RedundantImport"/>
-    <module name="UnusedImports"/>
+    <module name="UnusedImports">
+      <property name="processJavadoc" value="true"/>
+    </module>
 
 
     <!-- Checks for Size Violations.                    -->
@@ -89,8 +91,8 @@
     <module name="GenericWhitespace"/>
     <module name="EmptyForIteratorPad"/>
     <module name="MethodParamPad"/>
-    <module name="NoWhitespaceAfter"/>
-    <module name="NoWhitespaceBefore"/>
+    <!--<module name="NoWhitespaceAfter"/>-->
+    <!--<module name="NoWhitespaceBefore"/>-->
     <module name="OperatorWrap"/>
     <module name="ParenPad"/>
     <module name="TypecastParenPad"/>
@@ -145,4 +147,4 @@
     <!--module name="TodoComment"/-->
     <module name="UpperEll"/>
   </module>
-</module>
\ No newline at end of file
+</module>
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 00000000..838a4e84
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,16 @@
+GROUP=com.squareup.leakcanary
+VERSION_NAME=1.6-SNAPSHOT
+
+POM_DESCRIPTION=Leak Canary
+
+POM_URL=http://github.com/square/leakcanary/
+POM_SCM_URL=http://github.com/square/leakcanary/
+POM_SCM_CONNECTION=scm:git:https://github.com/square/leakcanary.git
+POM_SCM_DEV_CONNECTION=scm:git:git@github.com:square/leakcanary.git
+
+POM_LICENCE_NAME=The Apache Software License, Version 2.0
+POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
+POM_LICENCE_DIST=repo
+
+POM_DEVELOPER_ID=square
+POM_DEVELOPER_NAME=Square, Inc.
\ No newline at end of file
diff --git a/gradle/checkstyle.gradle b/gradle/checkstyle.gradle
index 2e7c512c..afc5281a 100644
--- a/gradle/checkstyle.gradle
+++ b/gradle/checkstyle.gradle
@@ -2,17 +2,22 @@ apply plugin: 'checkstyle'
 
 checkstyle {
   configFile rootProject.file('checkstyle.xml')
+  ignoreFailures false
   showViolations true
 }
 
-android.libraryVariants.all { variant ->
-  def name = variant.buildType.name
+task checkstyle(type: Checkstyle) {
+  configFile rootProject.file('checkstyle.xml')
+  source 'src/main/java'
+  ignoreFailures false
+  showViolations true
+  include '**/*.java'
+
+  classpath = files()
+}
 
-  def checkstyle = project.tasks.create "checkstyle${name.capitalize()}", Checkstyle
-  checkstyle.dependsOn variant.javaCompile
-  checkstyle.source variant.javaCompile.source
-  checkstyle.classpath = project.fileTree(variant.javaCompile.destinationDir)
-  checkstyle.exclude('**/BuildConfig.java')
-  checkstyle.exclude('**/R.java')
-  project.tasks.getByName("check").dependsOn checkstyle
+afterEvaluate {
+  if (project.tasks.getByName("check")) {
+    check.dependsOn('checkstyle')
+  }
 }
\ No newline at end of file
diff --git a/gradle/gradle-mvn-push.gradle b/gradle/gradle-mvn-push.gradle
index 32763c86..63d9a780 100644
--- a/gradle/gradle-mvn-push.gradle
+++ b/gradle/gradle-mvn-push.gradle
@@ -77,32 +77,50 @@ afterEvaluate { project ->
         sign configurations.archives
     }
 
-    task androidJavadocs(type: Javadoc) {
+    def plugins = project.getPlugins()
+    if (plugins.hasPlugin('com.android.application') || plugins.hasPlugin('com.android.library')) {
+      task androidJavadocs(type: Javadoc) {
         source = android.sourceSets.main.java.srcDirs
-        ext.androidJar = "${android.sdkDirectory}/platforms/${android.compileSdkVersion}/android.jar"
-        classpath += files(ext.androidJar)
-    }
+        classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+      }
 
-    task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
+      task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
         classifier = 'javadoc'
         from androidJavadocs.destinationDir
-    }
+      }
 
-    task androidSourcesJar(type: Jar) {
+      task androidSourcesJar(type: Jar) {
         classifier = 'sources'
         from android.sourceSets.main.java.sourceFiles
+      }
+
+      artifacts {
+        archives androidSourcesJar
+        archives androidJavadocsJar
+      }
     }
+    else {
+      task sourcesJar(type: Jar, dependsOn: classes) {
+        classifier = 'sources'
+        from sourceSets.main.allSource
+      }
 
-    if (JavaVersion.current().isJava8Compatible()) {
-        allprojects {
-            tasks.withType(Javadoc) {
-                options.addStringOption('Xdoclint:none', '-quiet')
-            }
-        }
+      task javadocsJar(type: Jar, dependsOn: javadoc) {
+        classifier = 'javadoc'
+        from javadoc.destinationDir
+      }
+
+      artifacts {
+        archives sourcesJar
+        archives javadocsJar
+      }
     }
 
-    artifacts {
-        archives androidSourcesJar
-        archives androidJavadocsJar
+    if (JavaVersion.current().isJava8Compatible()) {
+      allprojects {
+        tasks.withType(Javadoc) {
+          options.addStringOption('Xdoclint:none', '-quiet')
+        }
+      }
     }
 }
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 58385981..7a3265ee 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 63b80488..3f0f9be6 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Wed Feb 04 10:58:17 PST 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.6-all.zip
diff --git a/gradlew b/gradlew
index 91a7e269..cccdd3d5 100755
--- a/gradlew
+++ b/gradlew
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 ##############################################################################
 ##
@@ -6,20 +6,38 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,31 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -90,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
@@ -114,6 +113,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
@@ -154,11 +154,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+exec "$JAVACMD" "$@"
diff --git a/leakcanary-analyzer/build.gradle b/leakcanary-analyzer/build.gradle
index 84c46338..51794e3f 100644
--- a/leakcanary-analyzer/build.gradle
+++ b/leakcanary-analyzer/build.gradle
@@ -1,57 +1,27 @@
-version rootProject.ext.VERSION_NAME
-group rootProject.ext.GROUP
-
-buildscript {
-  repositories {
-    mavenCentral()
-  }
-}
-
 apply plugin: 'com.android.library'
 
-repositories {
-  mavenCentral()
-}
-
 dependencies {
-  compile 'com.squareup.haha:haha:2.0.2'
-  compile project(':leakcanary-watcher')
-  testCompile 'junit:junit:4.12'
-}
-
-android.libraryVariants.all { variant ->
-  def name = variant.buildType.name
-  if (name.equals(com.android.builder.core.BuilderConstants.DEBUG)) {
-    return; // Skip debug builds.
-  }
-  def task = project.tasks.create "jar${name.capitalize()}", Jar
-  task.dependsOn variant.javaCompile
-  task.from variant.javaCompile.destinationDir
-  artifacts.add('archives', task);
-}
-
-
-// See: https://code.google.com/p/android/issues/detail?id=64887#c13
-task copyTestResources(type: Copy) {
-  from "${projectDir}/src/test/resources"
-  into "${buildDir}/classes/test"
-}
-
-afterEvaluate { project ->
-  testDebugUnitTest.dependsOn copyTestResources
+  implementation 'com.squareup.haha:haha:2.0.3'
+  api project(':leakcanary-watcher')
+  testImplementation 'junit:junit:4.12'
+  testImplementation 'org.assertj:assertj-core:3.9.1'
 }
 
 android {
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
+  compileSdkVersion versions.compileSdk
+
   defaultConfig {
-    minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.targetSdkVersion
+    minSdkVersion versions.minSdk
+  }
+
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
   }
-}
 
-task sourceJar(type: Jar) {
-  from 'src/main/java'
+  // TODO replace with https://issuetracker.google.com/issues/72050365 once released.
+  libraryVariants.all {
+    it.generateBuildConfig.enabled = false
+  }
 }
 
 apply from: rootProject.file('gradle/checkstyle.gradle')
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
index 4c8270c1..574e3f27 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
@@ -66,6 +66,65 @@ public static AnalysisResult failure(Throwable failure, long analysisDurationMs)
   /** Total time spent analyzing the heap. */
   public final long analysisDurationMs;
 
+  /**
+   * <p>Creates a new {@link RuntimeException} with a fake stack trace that maps the leak trace.
+   *
+   * <p>Leak traces uniquely identify memory leaks, much like stack traces uniquely identify
+   * exceptions.
+   *
+   * <p>This method enables you to upload leak traces as stack traces to your preferred
+   * exception reporting tool and benefit from the grouping and counting these tools provide out
+   * of the box. This also means you can track all leaks instead of relying on individuals
+   * reporting them when they happen.
+   *
+   * <p>The following example leak trace:
+   * <pre>
+   * * com.foo.WibbleActivity has leaked:
+   * * GC ROOT static com.foo.Bar.qux
+   * * references com.foo.Quz.context
+   * * leaks com.foo.WibbleActivity instance
+   * </pre>
+   *
+   * <p>Will turn into an exception with the following stacktrace:
+   * <pre>
+   * java.lang.RuntimeException: com.foo.WibbleActivity leak from com.foo.Bar (holder=CLASS,
+   * type=STATIC_FIELD)
+   *         at com.foo.Bar.qux(Bar.java:42)
+   *         at com.foo.Quz.context(Quz.java:42)
+   *         at com.foo.WibbleActivity.leaking(WibbleActivity.java:42)
+   * </pre>
+   */
+  public RuntimeException leakTraceAsFakeException() {
+    if (!leakFound) {
+      throw new UnsupportedOperationException(
+          "leakTraceAsFakeException() can only be called when leakFound is true");
+    }
+    LeakTraceElement firstElement = leakTrace.elements.get(0);
+    String rootSimpleName = classSimpleName(firstElement.className);
+    String leakSimpleName = classSimpleName(className);
+
+    String exceptionMessage = leakSimpleName
+        + " leak from "
+        + rootSimpleName
+        + " (holder="
+        + firstElement.holder
+        + ", type="
+        + firstElement.type
+        + ")";
+    RuntimeException exception = new RuntimeException(exceptionMessage);
+
+    StackTraceElement[] stackTrace = new StackTraceElement[leakTrace.elements.size()];
+    int i = 0;
+    for (LeakTraceElement element : leakTrace.elements) {
+      String methodName = element.referenceName != null ? element.referenceName : "leaking";
+      String file = classSimpleName(element.className) + ".java";
+      stackTrace[i] = new StackTraceElement(element.className, methodName, file, 42);
+      i++;
+    }
+    exception.setStackTrace(stackTrace);
+    return exception;
+  }
+
   private AnalysisResult(boolean leakFound, boolean excludedLeak, String className,
       LeakTrace leakTrace, Throwable failure, long retainedHeapSize, long analysisDurationMs) {
     this.leakFound = leakFound;
@@ -76,4 +135,9 @@ private AnalysisResult(boolean leakFound, boolean excludedLeak, String className
     this.retainedHeapSize = retainedHeapSize;
     this.analysisDurationMs = analysisDurationMs;
   }
+
+  private String classSimpleName(String className) {
+    int separator = className.lastIndexOf('.');
+    return separator == -1 ? className : className.substring(separator + 1);
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
index fbbf8ba0..6eb3d070 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
@@ -18,13 +18,13 @@
 import com.squareup.haha.perflib.ArrayInstance;
 import com.squareup.haha.perflib.ClassInstance;
 import com.squareup.haha.perflib.ClassObj;
-import com.squareup.haha.perflib.Field;
-import com.squareup.haha.perflib.Heap;
 import com.squareup.haha.perflib.Instance;
 import com.squareup.haha.perflib.Type;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.nio.charset.Charset;
 import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
 
 import static com.squareup.leakcanary.Preconditions.checkNotNull;
@@ -37,21 +37,14 @@
           Double.class.getName(), Byte.class.getName(), Short.class.getName(),
           Integer.class.getName(), Long.class.getName()));
 
-  static String fieldToString(Map.Entry<Field, Object> entry) {
-    return fieldToString(entry.getKey(), entry.getValue());
-  }
-
-  static String fieldToString(ClassInstance.FieldValue fieldValue) {
-    return fieldToString(fieldValue.getField(), fieldValue.getValue());
-  }
-
-  static String fieldToString(Field field, Object value) {
-    return field.getName() + " = " + value;
-  }
-
   static String threadName(Instance holder) {
     List<ClassInstance.FieldValue> values = classInstanceValues(holder);
     Object nameField = fieldValue(values, "name");
+    if (nameField == null) {
+      // Sometimes we can't find the String at the expected memory address in the heap dump.
+      // See https://github.com/square/leakcanary/issues/417 .
+      return "Thread name not available";
+    }
     return asString(nameField);
   }
 
@@ -59,7 +52,7 @@ static boolean extendsThread(ClassObj clazz) {
     boolean extendsThread = false;
     ClassObj parentClass = clazz;
     while (parentClass.getSuperClassObj() != null) {
-      if (clazz.getClassName().equals(Thread.class.getName())) {
+      if (parentClass.getClassName().equals(Thread.class.getName())) {
         extendsThread = true;
         break;
       }
@@ -73,11 +66,19 @@ static String asString(Object stringObject) {
     List<ClassInstance.FieldValue> values = classInstanceValues(instance);
 
     Integer count = fieldValue(values, "count");
+    checkNotNull(count, "count");
+    if (count == 0) {
+      return "";
+    }
+
     Object value = fieldValue(values, "value");
+    checkNotNull(value, "value");
+
     Integer offset;
-    ArrayInstance charArray;
+    ArrayInstance array;
     if (isCharArray(value)) {
-      charArray = (ArrayInstance) value;
+      array = (ArrayInstance) value;
+
       offset = 0;
       // < API 23
       // As of Marshmallow, substrings no longer share their parent strings' char arrays
@@ -85,35 +86,32 @@ static String asString(Object stringObject) {
       // https://android-review.googlesource.com/#/c/83611/
       if (hasField(values, "offset")) {
         offset = fieldValue(values, "offset");
+        checkNotNull(offset, "offset");
       }
-    } else {
-      // In M preview 2, the underlying char buffer resides in the heap with ID equaling the
-      // String's ID + 16.
-      // https://android-review.googlesource.com/#/c/160380/2/android/src/com/android/tools/idea/
-      // editors/hprof/descriptors/InstanceFieldDescriptorImpl.java
-      // This workaround is only needed for M preview 2, as it has been fixed on the hprof
-      // generation end by reintroducing a virtual "value" variable.
-      // https://android.googlesource.com/platform/art/+/master/runtime/hprof/hprof.cc#1242
-      Heap heap = instance.getHeap();
-      Instance inlineInstance = heap.getInstance(instance.getId() + 16);
-      if (isCharArray(inlineInstance)) {
-        charArray = (ArrayInstance) inlineInstance;
-        offset = 0;
-      } else {
-        throw new UnsupportedOperationException("Could not find char array in " + instance);
-      }
-    }
-    checkNotNull(count, "count");
-    checkNotNull(charArray, "charArray");
-    checkNotNull(offset, "offset");
 
-    if (count == 0) {
-      return "";
+      char[] chars = array.asCharArray(offset, count);
+      return new String(chars);
+    } else if (isByteArray(value)) {
+      // In API 26, Strings are now internally represented as byte arrays.
+      array = (ArrayInstance) value;
+
+      // HACK - remove when HAHA's perflib is updated to https://goo.gl/Oe7ZwO.
+      try {
+        Method asRawByteArray =
+            ArrayInstance.class.getDeclaredMethod("asRawByteArray", int.class, int.class);
+        asRawByteArray.setAccessible(true);
+        byte[] rawByteArray = (byte[]) asRawByteArray.invoke(array, 0, count);
+        return new String(rawByteArray, Charset.forName("UTF-8"));
+      } catch (NoSuchMethodException e) {
+        throw new RuntimeException(e);
+      } catch (IllegalAccessException e) {
+        throw new RuntimeException(e);
+      } catch (InvocationTargetException e) {
+        throw new RuntimeException(e);
+      }
+    } else {
+      throw new UnsupportedOperationException("Could not find char array in " + instance);
     }
-
-    char[] chars = charArray.asCharArray(offset, count);
-
-    return new String(chars);
   }
 
   public static boolean isPrimitiveWrapper(Object value) {
@@ -138,15 +136,19 @@ private static boolean isCharArray(Object value) {
     return value instanceof ArrayInstance && ((ArrayInstance) value).getArrayType() == Type.CHAR;
   }
 
+  private static boolean isByteArray(Object value) {
+    return value instanceof ArrayInstance && ((ArrayInstance) value).getArrayType() == Type.BYTE;
+  }
+
   static List<ClassInstance.FieldValue> classInstanceValues(Instance instance) {
     ClassInstance classInstance = (ClassInstance) instance;
     return classInstance.getValues();
   }
 
+  @SuppressWarnings({ "unchecked", "TypeParameterUnusedInFormals" })
   static <T> T fieldValue(List<ClassInstance.FieldValue> values, String fieldName) {
     for (ClassInstance.FieldValue fieldValue : values) {
       if (fieldValue.getField().getName().equals(fieldName)) {
-        //noinspection unchecked
         return (T) fieldValue.getValue();
       }
     }
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
index a972ef20..0075abcd 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
@@ -27,24 +27,32 @@
 import com.squareup.haha.perflib.Type;
 import com.squareup.haha.perflib.io.HprofBuffer;
 import com.squareup.haha.perflib.io.MemoryMappedFileBuffer;
+import com.squareup.haha.trove.THashMap;
+import com.squareup.haha.trove.TObjectProcedure;
 import java.io.File;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 
+import static android.os.Build.VERSION.SDK_INT;
+import static android.os.Build.VERSION_CODES.N_MR1;
 import static com.squareup.leakcanary.AnalysisResult.failure;
 import static com.squareup.leakcanary.AnalysisResult.leakDetected;
 import static com.squareup.leakcanary.AnalysisResult.noLeak;
 import static com.squareup.leakcanary.HahaHelper.asString;
 import static com.squareup.leakcanary.HahaHelper.classInstanceValues;
 import static com.squareup.leakcanary.HahaHelper.extendsThread;
-import static com.squareup.leakcanary.HahaHelper.fieldToString;
 import static com.squareup.leakcanary.HahaHelper.fieldValue;
+import static com.squareup.leakcanary.HahaHelper.hasField;
 import static com.squareup.leakcanary.HahaHelper.threadName;
 import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
 import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
 import static com.squareup.leakcanary.LeakTraceElement.Holder.OBJECT;
 import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
+import static com.squareup.leakcanary.LeakTraceElement.Type.ARRAY_ENTRY;
+import static com.squareup.leakcanary.LeakTraceElement.Type.INSTANCE_FIELD;
+import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
 /**
@@ -60,6 +68,36 @@ public HeapAnalyzer(ExcludedRefs excludedRefs) {
     this.excludedRefs = excludedRefs;
   }
 
+  public List<TrackedReference> findTrackedReferences(File heapDumpFile) {
+    if (!heapDumpFile.exists()) {
+      throw new IllegalArgumentException("File does not exist: " + heapDumpFile);
+    }
+    try {
+      HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
+      HprofParser parser = new HprofParser(buffer);
+      Snapshot snapshot = parser.parse();
+      deduplicateGcRoots(snapshot);
+
+      ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());
+      List<TrackedReference> references = new ArrayList<>();
+      for (Instance weakRef : refClass.getInstancesList()) {
+        List<ClassInstance.FieldValue> values = classInstanceValues(weakRef);
+        String key = asString(fieldValue(values, "key"));
+        String name =
+            hasField(values, "name") ? asString(fieldValue(values, "name")) : "(No name field)";
+        Instance instance = fieldValue(values, "referent");
+        if (instance != null) {
+          String className = getClassName(instance);
+          List<LeakReference> fields = describeFields(instance);
+          references.add(new TrackedReference(key, name, className, fields));
+        }
+      }
+      return references;
+    } catch (Throwable e) {
+      throw new RuntimeException(e);
+    }
+  }
+
   /**
    * Searches the heap dump for a {@link KeyedWeakReference} instance with the corresponding key,
    * and then computes the shortest strong reference path from that instance to the GC roots.
@@ -76,6 +114,7 @@ public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
       HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
       HprofParser parser = new HprofParser(buffer);
       Snapshot snapshot = parser.parse();
+      deduplicateGcRoots(snapshot);
 
       Instance leakingRef = findLeakingReference(referenceKey, snapshot);
 
@@ -90,6 +129,34 @@ public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
     }
   }
 
+  /**
+   * Pruning duplicates reduces memory pressure from hprof bloat added in Marshmallow.
+   */
+  void deduplicateGcRoots(Snapshot snapshot) {
+    // THashMap has a smaller memory footprint than HashMap.
+    final THashMap<String, RootObj> uniqueRootMap = new THashMap<>();
+
+    final Collection<RootObj> gcRoots = snapshot.getGCRoots();
+    for (RootObj root : gcRoots) {
+      String key = generateRootKey(root);
+      if (!uniqueRootMap.containsKey(key)) {
+        uniqueRootMap.put(key, root);
+      }
+    }
+
+    // Repopulate snapshot with unique GC roots.
+    gcRoots.clear();
+    uniqueRootMap.forEach(new TObjectProcedure<String>() {
+      @Override public boolean execute(String key) {
+        return gcRoots.add(uniqueRootMap.get(key));
+      }
+    });
+  }
+
+  private String generateRootKey(RootObj root) {
+    return String.format("%s@0x%08x", root.getRootType().getName(), root.getId());
+  }
+
   private Instance findLeakingReference(String key, Snapshot snapshot) {
     ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());
     List<String> keysFound = new ArrayList<>();
@@ -127,7 +194,10 @@ private AnalysisResult findLeakTrace(long analysisStartNanoTime, Snapshot snapsh
 
     long retainedSize = leakingInstance.getTotalRetainedSize();
 
-    retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance);
+    // TODO: check O sources and see what happened to android.graphics.Bitmap.mBuffer
+    if (SDK_INT <= N_MR1) {
+      retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance);
+    }
 
     return leakDetected(result.excludingKnownLeaks, className, leakTrace, retainedSize,
         since(analysisStartNanoTime));
@@ -142,8 +212,8 @@ private AnalysisResult findLeakTrace(long analysisStartNanoTime, Snapshot snapsh
    * From experience, we've found that bitmap created in code (Bitmap.createBitmap()) are correctly
    * accounted for, however bitmaps set in layouts are not.
    */
-  private int computeIgnoredBitmapRetainedSize(Snapshot snapshot, Instance leakingInstance) {
-    int bitmapRetainedSize = 0;
+  private long computeIgnoredBitmapRetainedSize(Snapshot snapshot, Instance leakingInstance) {
+    long bitmapRetainedSize = 0;
     ClassObj bitmapClass = snapshot.findClass("android.graphics.Bitmap");
 
     for (Instance bitmapInstance : bitmapClass.getInstancesList()) {
@@ -190,7 +260,7 @@ private boolean isIgnoredDominator(Instance dominator, Instance instance) {
   private LeakTrace buildLeakTrace(LeakNode leakingNode) {
     List<LeakTraceElement> elements = new ArrayList<>();
     // We iterate from the leak to the GC root
-    LeakNode node = new LeakNode(null, leakingNode, null, null);
+    LeakNode node = new LeakNode(null, null, leakingNode, null);
     while (node != null) {
       LeakTraceElement element = buildLeakElement(node);
       if (element != null) {
@@ -211,50 +281,36 @@ private LeakTraceElement buildLeakElement(LeakNode node) {
     if (holder instanceof RootObj) {
       return null;
     }
-    LeakTraceElement.Type type = node.referenceType;
-    String referenceName = node.referenceName;
-
     LeakTraceElement.Holder holderType;
     String className;
     String extra = null;
-    List<String> fields = new ArrayList<>();
+    List<LeakReference> leakReferences = describeFields(holder);
+
+    className = getClassName(holder);
+
+    List<String> classHierarchy = new ArrayList<>();
+    classHierarchy.add(className);
+    String rootClassName = Object.class.getName();
+    if (holder instanceof ClassInstance) {
+      ClassObj classObj = holder.getClassObj();
+      while (!(classObj = classObj.getSuperClassObj()).getClassName().equals(rootClassName)) {
+        classHierarchy.add(classObj.getClassName());
+      }
+    }
+
     if (holder instanceof ClassObj) {
-      ClassObj classObj = (ClassObj) holder;
       holderType = CLASS;
-      className = classObj.getClassName();
-      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-        Field field = entry.getKey();
-        Object value = entry.getValue();
-        fields.add("static " + field.getName() + " = " + value);
-      }
     } else if (holder instanceof ArrayInstance) {
-      ArrayInstance arrayInstance = (ArrayInstance) holder;
       holderType = ARRAY;
-      className = arrayInstance.getClassObj().getClassName();
-      if (arrayInstance.getArrayType() == Type.OBJECT) {
-        Object[] values = arrayInstance.getValues();
-        for (int i = 0; i < values.length; i++) {
-          fields.add("[" + i + "] = " + values[i]);
-        }
-      }
     } else {
-      ClassInstance classInstance = (ClassInstance) holder;
       ClassObj classObj = holder.getClassObj();
-      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-        fields.add("static " + fieldToString(entry));
-      }
-      for (ClassInstance.FieldValue field : classInstance.getValues()) {
-        fields.add(fieldToString(field));
-      }
-      className = classObj.getClassName();
-
       if (extendsThread(classObj)) {
         holderType = THREAD;
         String threadName = threadName(holder);
         extra = "(named '" + threadName + "')";
       } else if (className.matches(ANONYMOUS_CLASS_NAME_PATTERN)) {
         String parentClassName = classObj.getSuperClassObj().getClassName();
-        if (Object.class.getName().equals(parentClassName)) {
+        if (rootClassName.equals(parentClassName)) {
           holderType = OBJECT;
           try {
             // This is an anonymous class implementing an interface. The API does not give access
@@ -264,22 +320,75 @@ private LeakTraceElement buildLeakElement(LeakNode node) {
             Class<?>[] interfaces = actualClass.getInterfaces();
             if (interfaces.length > 0) {
               Class<?> implementedInterface = interfaces[0];
-              extra = "(anonymous class implements " + implementedInterface.getName() + ")";
+              extra = "(anonymous implementation of " + implementedInterface.getName() + ")";
             } else {
-              extra = "(anonymous class extends java.lang.Object)";
+              extra = "(anonymous subclass of java.lang.Object)";
             }
           } catch (ClassNotFoundException ignored) {
           }
         } else {
           holderType = OBJECT;
           // Makes it easier to figure out which anonymous class we're looking at.
-          extra = "(anonymous class extends " + parentClassName + ")";
+          extra = "(anonymous subclass of " + parentClassName + ")";
         }
       } else {
         holderType = OBJECT;
       }
     }
-    return new LeakTraceElement(referenceName, type, holderType, className, extra, fields);
+    return new LeakTraceElement(node.leakReference, holderType, classHierarchy, extra,
+        node.exclusion, leakReferences);
+  }
+
+  private List<LeakReference> describeFields(Instance instance) {
+    List<LeakReference> leakReferences = new ArrayList<>();
+
+    if (instance instanceof ClassObj) {
+      ClassObj classObj = (ClassObj) instance;
+      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
+        String name = entry.getKey().getName();
+        String value = entry.getValue() == null ? "null" : entry.getValue().toString();
+        leakReferences.add(new LeakReference(STATIC_FIELD, name, value));
+      }
+    } else if (instance instanceof ArrayInstance) {
+      ArrayInstance arrayInstance = (ArrayInstance) instance;
+      if (arrayInstance.getArrayType() == Type.OBJECT) {
+        Object[] values = arrayInstance.getValues();
+        for (int i = 0; i < values.length; i++) {
+          String name = Integer.toString(i);
+          String value = values[i] == null ? "null" : values[i].toString();
+          leakReferences.add(new LeakReference(ARRAY_ENTRY, name, value));
+        }
+      }
+    } else {
+      ClassObj classObj = instance.getClassObj();
+      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
+        String name = entry.getKey().getName();
+        String value = entry.getValue() == null ? "null" : entry.getValue().toString();
+        leakReferences.add(new LeakReference(STATIC_FIELD, name, value));
+      }
+      ClassInstance classInstance = (ClassInstance) instance;
+      for (ClassInstance.FieldValue field : classInstance.getValues()) {
+        String name = field.getField().getName();
+        String value = field.getValue() == null ? "null" : field.getValue().toString();
+        leakReferences.add(new LeakReference(INSTANCE_FIELD, name, value));
+      }
+    }
+    return leakReferences;
+  }
+
+  private String getClassName(Instance instance) {
+    String className;
+    if (instance instanceof ClassObj) {
+      ClassObj classObj = (ClassObj) instance;
+      className = classObj.getClassName();
+    } else if (instance instanceof ArrayInstance) {
+      ArrayInstance arrayInstance = (ArrayInstance) instance;
+      className = arrayInstance.getClassObj().getClassName();
+    } else {
+      ClassObj classObj = instance.getClassObj();
+      className = classObj.getClassName();
+    }
+    return className;
   }
 
   private long since(long analysisStartNanoTime) {
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
index 69ec8717..94a77252 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
@@ -18,16 +18,16 @@
 import com.squareup.haha.perflib.Instance;
 
 final class LeakNode {
+  /** May be null. */
+  final Exclusion exclusion;
   final Instance instance;
   final LeakNode parent;
-  final String referenceName;
-  final LeakTraceElement.Type referenceType;
+  final LeakReference leakReference;
 
-  LeakNode(Instance instance, LeakNode parent, String referenceName,
-      LeakTraceElement.Type referenceType) {
+  LeakNode(Exclusion exclusion, Instance instance, LeakNode parent, LeakReference leakReference) {
+    this.exclusion = exclusion;
     this.instance = instance;
     this.parent = parent;
-    this.referenceName = referenceName;
-    this.referenceType = referenceType;
+    this.leakReference = leakReference;
   }
 }
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakReference.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakReference.java
new file mode 100644
index 00000000..824e329b
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakReference.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import java.io.Serializable;
+
+/**
+ * A single field in a {@link LeakTraceElement}.
+ */
+public final class LeakReference implements Serializable {
+
+  public final LeakTraceElement.Type type;
+  public final String name;
+  public final String value;
+
+  public LeakReference(LeakTraceElement.Type type, String name, String value) {
+    this.type = type;
+    this.name = name;
+    this.value = value;
+  }
+
+  public String getDisplayName() {
+    switch (type) {
+      case ARRAY_ENTRY:
+        return "[" + name + "]";
+      case STATIC_FIELD:
+      case INSTANCE_FIELD:
+        return name;
+      case LOCAL:
+        return "<Java Local>";
+      default:
+        throw new IllegalStateException(
+            "Unexpected type " + type + " name = " + name + " value = " + value);
+    }
+  }
+
+  @Override public String toString() {
+    switch (type) {
+      case ARRAY_ENTRY:
+      case INSTANCE_FIELD:
+        return getDisplayName() + " = " + value;
+      case STATIC_FIELD:
+        return "static " + getDisplayName() + " = " + value;
+      case LOCAL:
+        return getDisplayName();
+      default:
+        throw new IllegalStateException(
+            "Unexpected type " + type + " name = " + name + " value = " + value);
+    }
+  }
+}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
index 02f85f64..5c1392ab 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
@@ -17,6 +17,7 @@
 
 import java.io.Serializable;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
@@ -38,33 +39,69 @@
   }
 
   /** Null if this is the last element in the leak trace, ie the leaking object. */
+  public final LeakReference reference;
+
+  /**
+   * @deprecated Use {@link #reference} and {@link LeakReference#getDisplayName()} instead.
+   * Null if this is the last element in the leak trace, ie the leaking object.
+   */
+  @Deprecated
   public final String referenceName;
 
-  /** Null if this is the last element in the leak trace, ie the leaking object. */
+  /**
+   * @deprecated Use {@link #reference} and {@link LeakReference#type} instead.
+   * Null if this is the last element in the leak trace, ie the leaking object.
+   */
+  @Deprecated
   public final Type type;
+
   public final Holder holder;
+
+  /**
+   * Class hierarchy for that object. The first element is {@link #className}. {@link Object}
+   * is excluded. There is always at least one element.
+   */
+  public final List<String> classHierarchy;
+
   public final String className;
 
   /** Additional information, may be null. */
   public final String extra;
 
+  /** If not null, there was no path that could exclude this element. */
+  public final Exclusion exclusion;
+
   /** List of all fields (member and static) for that object. */
+  public final List<LeakReference> fieldReferences;
+
+  /**
+   * @deprecated Use {@link #fieldReferences} instead.
+   */
+  @Deprecated
   public final List<String> fields;
 
-  LeakTraceElement(String referenceName, Type type, Holder holder, String className, String extra,
-      List<String> fields) {
-    this.referenceName = referenceName;
-    this.type = type;
+  LeakTraceElement(LeakReference reference, Holder holder, List<String> classHierarchy,
+      String extra, Exclusion exclusion, List<LeakReference> leakReferences) {
+    this.reference = reference;
+    this.referenceName = reference == null ? null : reference.getDisplayName();
+    this.type = reference == null ? null : reference.type;
     this.holder = holder;
-    this.className = className;
+    this.classHierarchy = Collections.unmodifiableList(new ArrayList<>(classHierarchy));
+    this.className = classHierarchy.get(0);
     this.extra = extra;
-    this.fields = unmodifiableList(new ArrayList<>(fields));
+    this.exclusion = exclusion;
+    this.fieldReferences = unmodifiableList(new ArrayList<>(leakReferences));
+    List<String> stringFields = new ArrayList<>();
+    for (LeakReference leakReference : leakReferences) {
+      stringFields.add(leakReference.toString());
+    }
+    fields = Collections.unmodifiableList(stringFields);
   }
 
   @Override public String toString() {
     String string = "";
 
-    if (type == STATIC_FIELD) {
+    if (reference != null && reference.type == STATIC_FIELD) {
       string += "static ";
     }
 
@@ -72,10 +109,10 @@
       string += holder.name().toLowerCase(US) + " ";
     }
 
-    string += className;
+    string += classHierarchy.get(0);
 
-    if (referenceName != null) {
-      string += "." + referenceName;
+    if (reference != null) {
+      string += "." + reference.getDisplayName();
     } else {
       string += " instance";
     }
@@ -83,6 +120,11 @@
     if (extra != null) {
       string += " " + extra;
     }
+
+    if (exclusion != null) {
+      string += " , matching exclusion " + exclusion.matching;
+    }
+
     return string;
   }
 
@@ -96,8 +138,8 @@ public String toDetailedString() {
       string += "Instance of";
     }
     string += " " + className + "\n";
-    for (String field : fields) {
-      string += "|   " + field + "\n";
+    for (LeakReference leakReference : fieldReferences) {
+      string += "|   " + leakReference + "\n";
     }
     return string;
   }
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
index 82028a18..1c58dd3a 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
@@ -25,11 +25,11 @@
 import com.squareup.haha.perflib.RootType;
 import com.squareup.haha.perflib.Snapshot;
 import com.squareup.haha.perflib.Type;
+import java.util.ArrayDeque;
+import java.util.Deque;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
-import java.util.LinkedList;
 import java.util.Map;
-import java.util.Queue;
 
 import static com.squareup.leakcanary.HahaHelper.isPrimitiveOrWrapperArray;
 import static com.squareup.leakcanary.HahaHelper.isPrimitiveWrapper;
@@ -49,8 +49,8 @@
 final class ShortestPathFinder {
 
   private final ExcludedRefs excludedRefs;
-  private final Queue<LeakNode> toVisitQueue;
-  private final Queue<LeakNode> toVisitIfNoPathQueue;
+  private final Deque<LeakNode> toVisitQueue;
+  private final Deque<LeakNode> toVisitIfNoPathQueue;
   private final LinkedHashSet<Instance> toVisitSet;
   private final LinkedHashSet<Instance> toVisitIfNoPathSet;
   private final LinkedHashSet<Instance> visitedSet;
@@ -58,8 +58,8 @@
 
   ShortestPathFinder(ExcludedRefs excludedRefs) {
     this.excludedRefs = excludedRefs;
-    toVisitQueue = new LinkedList<>();
-    toVisitIfNoPathQueue = new LinkedList<>();
+    toVisitQueue = new ArrayDeque<>();
+    toVisitIfNoPathQueue = new ArrayDeque<>();
     toVisitSet = new LinkedHashSet<>();
     toVisitIfNoPathSet = new LinkedHashSet<>();
     visitedSet = new LinkedHashSet<>();
@@ -89,6 +89,9 @@ Result findPath(Snapshot snapshot, Instance leakingRef) {
         node = toVisitQueue.poll();
       } else {
         node = toVisitIfNoPathQueue.poll();
+        if (node.exclusion == null) {
+          throw new IllegalStateException("Expected node to have an exclusion " + node);
+        }
         excludingKnownLeaks = true;
       }
 
@@ -131,9 +134,9 @@ private void enqueueGcRoots(Snapshot snapshot) {
         case JAVA_LOCAL:
           Instance thread = HahaSpy.allocatingThread(rootObj);
           String threadName = threadName(thread);
-          Boolean alwaysIgnore = excludedRefs.threadNames.get(threadName);
-          if (alwaysIgnore == null || !alwaysIgnore) {
-            enqueue(alwaysIgnore == null, null, rootObj, null, null);
+          Exclusion params = excludedRefs.threadNames.get(threadName);
+          if (params == null || !params.alwaysExclude) {
+            enqueue(params, null, rootObj, null);
           }
           break;
         case INTERNED_STRING:
@@ -160,7 +163,7 @@ private void enqueueGcRoots(Snapshot snapshot) {
           // Input or output parameters in native code.
         case NATIVE_STACK:
         case JAVA_STATIC:
-          enqueue(true, null, rootObj, null, null);
+          enqueue(null, null, rootObj, null);
           break;
         default:
           throw new UnsupportedOperationException("Unknown root type:" + rootObj.getRootType());
@@ -176,50 +179,24 @@ private void visitRootObj(LeakNode node) {
     RootObj rootObj = (RootObj) node.instance;
     Instance child = rootObj.getReferredInstance();
 
-    boolean visitRootNow = true;
-    if (child != null) {
-      // true = ignore root, false = visit root later, null = visit root now.
-      Boolean rootSuperClassAlwaysIgnored = rootSuperClassAlwaysIgnored(child);
-      if (rootSuperClassAlwaysIgnored != null) {
-        if (rootSuperClassAlwaysIgnored) {
-          return;
-        } else {
-          visitRootNow = false;
-        }
-      }
-    }
-
     if (rootObj.getRootType() == RootType.JAVA_LOCAL) {
       Instance holder = HahaSpy.allocatingThread(rootObj);
       // We switch the parent node with the thread instance that holds
       // the local reference.
-      LeakNode parent = new LeakNode(holder, null, null, null);
-      enqueue(visitRootNow, parent, child, "<Java Local>", LOCAL);
-    } else {
-      enqueue(visitRootNow, node, child, null, null);
-    }
-  }
-
-  private Boolean rootSuperClassAlwaysIgnored(Instance child) {
-    Boolean alwaysIgnoreClassHierarchy = null;
-    ClassObj superClassObj = child.getClassObj();
-    while (superClassObj != null) {
-      Boolean alwaysIgnoreClass =
-          excludedRefs.rootSuperClassNames.get(superClassObj.getClassName());
-      if (alwaysIgnoreClass != null) {
-        // true overrides null or false.
-        if (alwaysIgnoreClassHierarchy == null || !alwaysIgnoreClassHierarchy) {
-          alwaysIgnoreClassHierarchy = alwaysIgnoreClass;
-        }
+      Exclusion exclusion = null;
+      if (node.exclusion != null) {
+        exclusion = node.exclusion;
       }
-      superClassObj = superClassObj.getSuperClassObj();
+      LeakNode parent = new LeakNode(null, holder, null, null);
+      enqueue(exclusion, parent, child, new LeakReference(LOCAL, null, null));
+    } else {
+      enqueue(null, node, child, null);
     }
-    return alwaysIgnoreClassHierarchy;
   }
 
   private void visitClassObj(LeakNode node) {
     ClassObj classObj = (ClassObj) node.instance;
-    Map<String, Boolean> ignoredStaticFields =
+    Map<String, Exclusion> ignoredStaticFields =
         excludedRefs.staticFieldNameByClassName.get(classObj.getClassName());
     for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
       Field field = entry.getKey();
@@ -232,73 +209,64 @@ private void visitClassObj(LeakNode node) {
       }
       Instance child = (Instance) entry.getValue();
       boolean visit = true;
+      String fieldValue = entry.getValue() == null ? "null" : entry.getValue().toString();
+      LeakReference leakReference = new LeakReference(STATIC_FIELD, fieldName, fieldValue);
       if (ignoredStaticFields != null) {
-        Boolean alwaysIgnore = ignoredStaticFields.get(fieldName);
-        if (alwaysIgnore != null) {
+        Exclusion params = ignoredStaticFields.get(fieldName);
+        if (params != null) {
           visit = false;
-          if (!alwaysIgnore) {
-            enqueue(false, node, child, fieldName, STATIC_FIELD);
+          if (!params.alwaysExclude) {
+            enqueue(params, node, child, leakReference);
           }
         }
       }
       if (visit) {
-        enqueue(true, node, child, fieldName, STATIC_FIELD);
+        enqueue(null, node, child, leakReference);
       }
     }
   }
 
   private void visitClassInstance(LeakNode node) {
     ClassInstance classInstance = (ClassInstance) node.instance;
-    Map<String, Boolean> ignoredFields = null;
+    Map<String, Exclusion> ignoredFields = new LinkedHashMap<>();
     ClassObj superClassObj = classInstance.getClassObj();
-    Boolean alwaysIgnoreClassHierarchy = null;
+    Exclusion classExclusion = null;
     while (superClassObj != null) {
-      Boolean alwaysIgnoreClass = excludedRefs.classNames.get(superClassObj.getClassName());
-      if (alwaysIgnoreClass != null) {
+      Exclusion params = excludedRefs.classNames.get(superClassObj.getClassName());
+      if (params != null) {
         // true overrides null or false.
-        if (alwaysIgnoreClassHierarchy == null || !alwaysIgnoreClassHierarchy) {
-          alwaysIgnoreClassHierarchy = alwaysIgnoreClass;
+        if (classExclusion == null || !classExclusion.alwaysExclude) {
+          classExclusion = params;
         }
       }
-      Map<String, Boolean> classIgnoredFields =
+      Map<String, Exclusion> classIgnoredFields =
           excludedRefs.fieldNameByClassName.get(superClassObj.getClassName());
       if (classIgnoredFields != null) {
-        if (ignoredFields == null) {
-          ignoredFields = new LinkedHashMap<>();
-        }
         ignoredFields.putAll(classIgnoredFields);
       }
       superClassObj = superClassObj.getSuperClassObj();
     }
 
-    if (alwaysIgnoreClassHierarchy != null && alwaysIgnoreClassHierarchy) {
+    if (classExclusion != null && classExclusion.alwaysExclude) {
       return;
     }
 
     for (ClassInstance.FieldValue fieldValue : classInstance.getValues()) {
+      Exclusion fieldExclusion = classExclusion;
       Field field = fieldValue.getField();
       if (field.getType() != Type.OBJECT) {
         continue;
       }
       Instance child = (Instance) fieldValue.getValue();
-      boolean visit = true;
-      boolean visitIfNoPath = false;
-      // We don't even get here if alwaysIgnoreClassHierarchy is false.
-      if (alwaysIgnoreClassHierarchy != null) {
-        visit = false;
-        visitIfNoPath = true;
-      }
       String fieldName = field.getName();
-      if (ignoredFields != null) {
-        Boolean alwaysIgnore = ignoredFields.get(fieldName);
-        if (alwaysIgnore != null) {
-          visit = false;
-          visitIfNoPath = !alwaysIgnore;
-        }
-      }
-      if (visit || visitIfNoPath) {
-        enqueue(visit, node, child, fieldName, INSTANCE_FIELD);
+      Exclusion params = ignoredFields.get(fieldName);
+      // If we found a field exclusion and it's stronger than a class exclusion
+      if (params != null && (fieldExclusion == null || (params.alwaysExclude
+          && !fieldExclusion.alwaysExclude))) {
+        fieldExclusion = params;
       }
+      String value = fieldValue.getValue() == null ? "null" : fieldValue.getValue().toString();
+      enqueue(fieldExclusion, node, child, new LeakReference(INSTANCE_FIELD, fieldName, value));
     }
   }
 
@@ -309,13 +277,15 @@ private void visitArrayInstance(LeakNode node) {
       Object[] values = arrayInstance.getValues();
       for (int i = 0; i < values.length; i++) {
         Instance child = (Instance) values[i];
-        enqueue(true, node, child, "[" + i + "]", ARRAY_ENTRY);
+        String name = Integer.toString(i);
+        String value = child == null ? "null" : child.toString();
+        enqueue(null, node, child, new LeakReference(ARRAY_ENTRY, name, value));
       }
     }
   }
 
-  private void enqueue(boolean visitNow, LeakNode parent, Instance child, String referenceName,
-      LeakTraceElement.Type referenceType) {
+  private void enqueue(Exclusion exclusion, LeakNode parent, Instance child,
+      LeakReference leakReference) {
     if (child == null) {
       return;
     }
@@ -326,6 +296,7 @@ private void enqueue(boolean visitNow, LeakNode parent, Instance child, String r
     if (toVisitSet.contains(child)) {
       return;
     }
+    boolean visitNow = exclusion == null;
     if (!visitNow && toVisitIfNoPathSet.contains(child)) {
       return;
     }
@@ -335,7 +306,7 @@ private void enqueue(boolean visitNow, LeakNode parent, Instance child, String r
     if (visitedSet.contains(child)) {
       return;
     }
-    LeakNode childNode = new LeakNode(child, parent, referenceName, referenceType);
+    LeakNode childNode = new LeakNode(exclusion, child, parent, leakReference);
     if (visitNow) {
       toVisitSet.add(child);
       toVisitQueue.add(childNode);
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/TrackedReference.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/TrackedReference.java
new file mode 100644
index 00000000..66c1223b
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/TrackedReference.java
@@ -0,0 +1,31 @@
+package com.squareup.leakcanary;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * An instance tracked by a {@link KeyedWeakReference} that hadn't been cleared when the
+ * heap was dumped. May or may not point to a leaking reference.
+ */
+public class TrackedReference {
+
+  /** Corresponds to {@link KeyedWeakReference#key}. */
+  public final String key;
+
+  /** Corresponds to {@link KeyedWeakReference#name}. */
+  public final String name;
+
+  /** Class of the tracked instance. */
+  public final String className;
+
+  /** List of all fields (member and static) for that instance. */
+  public final List<LeakReference> fields;
+
+  public TrackedReference(String key, String name, String className, List<LeakReference> fields) {
+    this.key = key;
+    this.name = name;
+    this.className = className;
+    this.fields = Collections.unmodifiableList(new ArrayList<>(fields));
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java
index df8a9fd2..ba071eaa 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java
@@ -15,9 +15,10 @@
  */
 package com.squareup.leakcanary;
 
+import java.lang.ref.PhantomReference;
 import java.lang.ref.WeakReference;
-import java.util.Arrays;
 import java.util.Collection;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -25,10 +26,11 @@
 
 import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
 import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_MPREVIEW2;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_M_POSTPREVIEW2;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_M;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_O;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_PRE_M;
 import static com.squareup.leakcanary.TestUtil.analyze;
+import static java.util.Arrays.asList;
 import static org.hamcrest.core.StringContains.containsString;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -44,23 +46,28 @@
   static final String EXECUTOR_FIELD_2 = "sDefaultExecutor";
 
   @Parameterized.Parameters public static Collection<Object[]> data() {
-    return Arrays.asList(new Object[][] {
-        { ASYNC_TASK }, //
-        { ASYNC_TASK_MPREVIEW2 }, //
-        { ASYNC_TASK_M_POSTPREVIEW2 } //
+    return asList(new Object[][] {
+        { ASYNC_TASK_PRE_M }, //
+        { ASYNC_TASK_M }, //
+        { ASYNC_TASK_O } //
     });
   }
 
   private final TestUtil.HeapDumpFile heapDumpFile;
-  ExcludedRefs.Builder excludedRefs;
+  ExcludedRefs.BuilderWithParams excludedRefs;
 
   public AsyncTaskLeakTest(TestUtil.HeapDumpFile heapDumpFile) {
     this.heapDumpFile = heapDumpFile;
   }
 
   @Before public void setUp() {
-    excludedRefs = new ExcludedRefs.Builder().clazz(WeakReference.class.getName(), true)
-        .clazz("java.lang.ref.FinalizerReference", true);
+    excludedRefs = new ExcludedRefs.BuilderWithParams() //
+        .clazz(WeakReference.class.getName())
+        .alwaysExclude()
+        .clazz("java.lang.ref.FinalizerReference")
+        .alwaysExclude()
+        .clazz(PhantomReference.class.getName())
+        .alwaysExclude();
   }
 
   @Test public void leakFound() {
@@ -86,11 +93,17 @@ public AsyncTaskLeakTest(TestUtil.HeapDumpFile heapDumpFile) {
   }
 
   @Test public void excludeStatic() {
-    excludedRefs.thread(ASYNC_TASK_THREAD);
-    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_1);
-    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_2);
+    excludedRefs.thread(ASYNC_TASK_THREAD).named(ASYNC_TASK_THREAD);
+    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_1).named(EXECUTOR_FIELD_1);
+    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_2).named(EXECUTOR_FIELD_2);
     AnalysisResult result = analyze(heapDumpFile, excludedRefs);
     assertTrue(result.leakFound);
     assertTrue(result.excludedLeak);
+    LeakTrace leakTrace = result.leakTrace;
+    List<LeakTraceElement> elements = leakTrace.elements;
+    Exclusion exclusion = elements.get(0).exclusion;
+
+    List<String> expectedExclusions = asList(ASYNC_TASK_THREAD, EXECUTOR_FIELD_1, EXECUTOR_FIELD_2);
+    assertTrue(expectedExclusions.contains(exclusion.name));
   }
 }
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java
index ba62c2ad..59f1949c 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java
@@ -6,6 +6,10 @@
 import java.util.List;
 
 public final class FakeHprofBuffer implements HprofBuffer {
+  private static final String PRE_O_CHARSET = "UTF-16BE";
+
+  private final String stringCharset;
+
   private List<Byte> byteList;
   private List<byte[]> byteArrayList;
 
@@ -14,6 +18,14 @@
   private String[] stringsToRead;
   private int stringIndex = -1;
 
+  FakeHprofBuffer() {
+    this(PRE_O_CHARSET);
+  }
+
+  FakeHprofBuffer(String stringCharset) {
+    this.stringCharset = stringCharset;
+  }
+
   public void setIntsToRead(int... ints) {
     intsToRead = ints;
     intIndex = 0;
@@ -42,7 +54,7 @@ public void readSubSequence(byte[] bytes, int start, int length) {
 
     String s = stringsToRead[stringIndex++];
     try {
-      System.arraycopy(s.getBytes("UTF-16BE"), start, bytes, 0, length);
+      System.arraycopy(s.getBytes(stringCharset), start, bytes, 0, length);
     } catch (UnsupportedEncodingException e) {
       throw new UnsupportedOperationException(e);
     }
@@ -82,7 +94,7 @@ public double readDouble() {
   }
 
   @Override
-  public void setPosition(long l) {}
+  public void setPosition(long l) { }
 
   @Override
   public long position() {
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
index 03178cbe..bb9e5bc8 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
@@ -6,18 +6,22 @@
 import com.squareup.haha.perflib.Field;
 import com.squareup.haha.perflib.Snapshot;
 import com.squareup.haha.perflib.Type;
-
+import com.squareup.haha.perflib.io.HprofBuffer;
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+@RunWith(JUnit4.class)
 public class HahaHelperTest {
   private static final int STRING_CLASS_ID = 100;
   private static final int CHAR_ARRAY_CLASS_ID = 101;
   private static final int STRING_INSTANCE_ID = 102;
   private static final int VALUE_ARRAY_INSTANCE_ID = 103;
+  private static final int BYTE_ARRAY_CLASS_ID = 104;
 
   private static final int VALUE_ARRAY_LENGTH = 6;
   private static final int COUNT_VALUE = 5;
@@ -29,15 +33,17 @@
   @Before
   public void setUp() {
     buffer = new FakeHprofBuffer();
+    initSnapshot(buffer);
+  }
 
+  private void initSnapshot(HprofBuffer buffer) {
     snapshot = new Snapshot(buffer);
     // set HPROF identifier size; required for Object instance field lookups
     // cf. https://java.net/downloads/heap-snapshot/hprof-binary-format.html
     snapshot.setIdSize(4);
   }
 
-  @Test
-  public void readStringOffsetFromHeapDumpInstance() {
+  @Test public void readStringOffsetFromHeapDumpInstance_pre_O() {
     buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
     buffer.setStringsToRead("abcdef");
 
@@ -54,8 +60,7 @@ public void readStringOffsetFromHeapDumpInstance() {
     assertTrue(actual.equals("bcdef"));
   }
 
-  @Test
-  public void defaultToZeroStringOffsetWhenHeapDumpInstanceIsMissingOffsetValue() {
+  @Test public void defaultToZeroStringOffsetWhenHeapDumpInstanceIsMissingOffsetValue_pre_O() {
     buffer.setIntsToRead(COUNT_VALUE, VALUE_ARRAY_INSTANCE_ID);
     buffer.setStringsToRead("abcdef");
 
@@ -71,26 +76,27 @@ public void defaultToZeroStringOffsetWhenHeapDumpInstanceIsMissingOffsetValue()
     assertTrue(actual.equals("abcde"));
   }
 
-  @Test
-  public void defaultToZeroStringOffsetWhenReadingMPreview2HeapDump() {
-    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
+  @Test public void readStringAsByteArrayFromHeapDumpInstance_O() {
+    // O uses default charset UTF-8
+    buffer = new FakeHprofBuffer("UTF-8");
+    initSnapshot(buffer);
+
+    buffer.setIntsToRead(COUNT_VALUE, VALUE_ARRAY_INSTANCE_ID);
     buffer.setStringsToRead("abcdef");
 
-    addStringClassToSnapshotWithFields(snapshot, new Field[]{
-            new Field(Type.INT, "count"),
-            new Field(Type.INT, "offset"),
-            new Field(Type.OBJECT, "value")
+    addStringClassToSnapshotWithFields_O(snapshot, new Field[]{
+        new Field(Type.INT, "count"),
+        new Field(Type.OBJECT, "value")
     });
 
     ClassInstance stringInstance = createStringInstance();
-    createCharArrayValueInstance_M_Preview2();
+    createByteArrayValueInstance();
 
     String actual = HahaHelper.asString(stringInstance);
     assertTrue(actual.equals("abcde"));
   }
 
-  @Test
-  public void throwExceptionWhenMissingCharArrayValueForStringInMPreview2HeapDump() {
+  @Test public void throwExceptionWhenNotArrayValueForString() {
     buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
     buffer.setStringsToRead("abcdef");
 
@@ -101,13 +107,12 @@ public void throwExceptionWhenMissingCharArrayValueForStringInMPreview2HeapDump(
     });
 
     ClassInstance stringInstance = createStringInstance();
-    createObjectValueInstance_M_Preview2();
+    createObjectValueInstance();
 
     try {
       HahaHelper.asString(stringInstance);
       fail("this test should have thrown UnsupportedOperationException");
-    }
-    catch (UnsupportedOperationException uoe) {
+    } catch (UnsupportedOperationException uoe) {
       String message = uoe.getMessage();
       assertTrue(message.equals("Could not find char array in " + stringInstance));
     }
@@ -122,19 +127,28 @@ private void addStringClassToSnapshotWithFields(Snapshot snapshot, Field[] field
     snapshot.addClass(STRING_CLASS_ID, stringClass);
   }
 
+  private void addStringClassToSnapshotWithFields_O(Snapshot snapshot, Field[] fields) {
+    ClassObj byteArrayClass = new ClassObj(0, null, "byte[]", 0);
+    snapshot.addClass(BYTE_ARRAY_CLASS_ID, byteArrayClass);
+
+    ClassObj stringClass = new ClassObj(0, null, "string", 0);
+    stringClass.setFields(fields);
+    snapshot.addClass(STRING_CLASS_ID, stringClass);
+  }
+
   private void createCharArrayValueInstance() {
     ArrayInstance valueArrayInstance = new ArrayInstance(0, null, Type.CHAR, VALUE_ARRAY_LENGTH, 0);
     snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID, valueArrayInstance);
   }
 
-  private void createCharArrayValueInstance_M_Preview2() {
-    ArrayInstance valueInstance = new ArrayInstance(0, null, Type.CHAR, VALUE_ARRAY_LENGTH, 0);
-    snapshot.addInstance(STRING_INSTANCE_ID + 16, valueInstance);
+  private void createByteArrayValueInstance() {
+    ArrayInstance valueArrayInstance = new ArrayInstance(0, null, Type.BYTE, VALUE_ARRAY_LENGTH, 0);
+    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID, valueArrayInstance);
   }
 
-  private void createObjectValueInstance_M_Preview2() {
+  private void createObjectValueInstance() {
     ClassInstance valueInstance = new ClassInstance(0, null, 0);
-    snapshot.addInstance(STRING_INSTANCE_ID + 16, valueInstance);
+    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID, valueInstance);
   }
 
   private ClassInstance createStringInstance() {
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
new file mode 100644
index 00000000..0e6937d5
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
@@ -0,0 +1,64 @@
+package com.squareup.leakcanary;
+
+import com.squareup.haha.perflib.RootObj;
+import com.squareup.haha.perflib.Snapshot;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+import static com.squareup.haha.perflib.RootType.NATIVE_STATIC;
+import static com.squareup.haha.perflib.RootType.SYSTEM_CLASS;
+import static com.squareup.leakcanary.TestUtil.NO_EXCLUDED_REFS;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
+
+@RunWith(JUnit4.class)
+public class HeapAnalyzerTest {
+  private static final List<RootObj> DUP_ROOTS =
+          asList(new RootObj(SYSTEM_CLASS, 6L),
+                  new RootObj(SYSTEM_CLASS, 5L),
+                  new RootObj(SYSTEM_CLASS, 3L),
+                  new RootObj(SYSTEM_CLASS, 5L),
+                  new RootObj(NATIVE_STATIC, 3L));
+
+  private HeapAnalyzer heapAnalyzer;
+
+  @Before
+  public void setUp() {
+    heapAnalyzer = new HeapAnalyzer(NO_EXCLUDED_REFS);
+  }
+
+  @Test
+  public void ensureUniqueRoots() {
+    Snapshot snapshot = createSnapshot(DUP_ROOTS);
+
+    heapAnalyzer.deduplicateGcRoots(snapshot);
+
+    Collection<RootObj> uniqueRoots = snapshot.getGCRoots();
+    assertThat(uniqueRoots).hasSize(4);
+
+    List<Long> rootIds = new ArrayList<>();
+    for (RootObj root : uniqueRoots) {
+      rootIds.add(root.getId());
+    }
+    Collections.sort(rootIds);
+
+    // 3 appears twice because even though two RootObjs have the same id, they're different types.
+    assertThat(rootIds).containsExactly(3L, 3L, 5L, 6L);
+  }
+
+  private Snapshot createSnapshot(List<RootObj> gcRoots) {
+    Snapshot snapshot = new Snapshot(null);
+    for (RootObj root : gcRoots) {
+      snapshot.addRoot(root);
+    }
+    return snapshot;
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java
index d3f2cd4c..349cd9c0 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java
@@ -8,11 +8,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_MPREVIEW2;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_M_POSTPREVIEW2;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER_IGNORED;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_M;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_O;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_PRE_M;
 import static com.squareup.leakcanary.TestUtil.analyze;
 import static org.junit.Assert.assertEquals;
 
@@ -24,17 +22,15 @@
 
   @Parameterized.Parameters public static Collection<Object[]> data() {
     return Arrays.asList(new Object[][] {
-        { ASYNC_TASK, 207_407 }, //
-        { ASYNC_TASK_MPREVIEW2, 1_604 }, //
-        { ASYNC_TASK_M_POSTPREVIEW2, 1_870 }, //
-        { SERVICE_BINDER, 378 }, //
-        { SERVICE_BINDER_IGNORED, 378 }, //
+        { ASYNC_TASK_PRE_M, 207_407 }, //
+        { ASYNC_TASK_M, 1_870 }, //
+        { ASYNC_TASK_O, 753 }, //
     });
   }
 
   private final TestUtil.HeapDumpFile heapDumpFile;
   private final long expectedRetainedHeapSize;
-  ExcludedRefs.Builder excludedRefs;
+  ExcludedRefs.BuilderWithParams excludedRefs;
 
   public RetainedSizeTest(TestUtil.HeapDumpFile heapDumpFile, long expectedRetainedHeapSize) {
     this.heapDumpFile = heapDumpFile;
@@ -42,8 +38,10 @@ public RetainedSizeTest(TestUtil.HeapDumpFile heapDumpFile, long expectedRetaine
   }
 
   @Before public void setUp() {
-    excludedRefs = new ExcludedRefs.Builder().clazz(WeakReference.class.getName(), true)
-        .clazz("java.lang.ref.FinalizerReference", true);
+    excludedRefs = new ExcludedRefs.BuilderWithParams().clazz(WeakReference.class.getName())
+        .alwaysExclude()
+        .clazz("java.lang.ref.FinalizerReference")
+        .alwaysExclude();
   }
 
   @Test public void leakFound() {
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/ServiceBinderLeakTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/ServiceBinderLeakTest.java
deleted file mode 100644
index 1851ce75..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/ServiceBinderLeakTest.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.lang.ref.WeakReference;
-import org.junit.Before;
-import org.junit.Test;
-
-import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.OBJECT;
-import static com.squareup.leakcanary.LeakTraceElement.Type.INSTANCE_FIELD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER_IGNORED;
-import static com.squareup.leakcanary.TestUtil.analyze;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-/**
- * leak_service_binder_ignored.hprof contains a "normal" leak when binding to a service, where
- * leak_service_binder.hprof contains a leak where a binder is leaked by a static field.
- */
-public class ServiceBinderLeakTest {
-
-  ExcludedRefs.Builder excludedRefs;
-
-  @Before public void setUp() {
-    excludedRefs = new ExcludedRefs.Builder().clazz(WeakReference.class.getName(), true)
-        .clazz("java.lang.ref.FinalizerReference", true);
-  }
-
-  @Test public void realBinderLeak() {
-    excludedRefs.rootSuperClass("android.os.Binder", true);
-
-    AnalysisResult result = analyze(SERVICE_BINDER, excludedRefs);
-
-    assertTrue(result.leakFound);
-    assertFalse(result.excludedLeak);
-    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
-    assertEquals(STATIC_FIELD, gcRoot.type);
-    assertEquals("com.example.leakcanary.LeakyService", gcRoot.className);
-    assertEquals(CLASS, gcRoot.holder);
-  }
-
-  @Test public void ignorableBinderLeak() {
-    excludedRefs.rootSuperClass("android.os.Binder", false);
-
-    AnalysisResult result = analyze(SERVICE_BINDER_IGNORED, excludedRefs);
-
-    assertTrue(result.leakFound);
-    assertTrue(result.excludedLeak);
-    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
-    assertEquals(INSTANCE_FIELD, gcRoot.type);
-    assertEquals("com.example.leakcanary.LeakyService$MyBinder", gcRoot.className);
-    assertEquals(OBJECT, gcRoot.holder);
-  }
-
-  @Test public void alwaysIgnorableBinderLeak() {
-    excludedRefs.rootSuperClass("android.os.Binder", true);
-
-    AnalysisResult result = analyze(SERVICE_BINDER_IGNORED, excludedRefs);
-
-    assertFalse(result.leakFound);
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
index d58d0aa3..8c8523c4 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
@@ -17,21 +17,19 @@
 
 import java.io.File;
 import java.net.URL;
+import java.util.List;
 
 final class TestUtil {
 
-  enum HeapDumpFile {
-    ASYNC_TASK("leak_asynctask.hprof", "dc983a12-d029-4003-8890-7dd644c664c5"),
-    ASYNC_TASK_MPREVIEW2("leak_asynctask_mpreview2.hprof", "1114018e-e154-435f-9a3d-da63ae9b47fa"),
-    ASYNC_TASK_M_POSTPREVIEW2("leak_asynctask_m_postpreview2.hprof",
-        "25ae1778-7c1d-4ec7-ac50-5cce55424069"),
+  public static final ExcludedRefs NO_EXCLUDED_REFS = ExcludedRefs.builder().build();
 
-    SERVICE_BINDER("leak_service_binder.hprof", "b3abfae6-2c53-42e1-b8c1-96b0558dbeae"),
-    SERVICE_BINDER_IGNORED("leak_service_binder_ignored.hprof",
-        "6e524414-9581-4ce7-8690-e8ddf8b82454"),;
+  enum HeapDumpFile {
+    ASYNC_TASK_PRE_M("leak_asynctask_pre_m.hprof", "dc983a12-d029-4003-8890-7dd644c664c5"), //
+    ASYNC_TASK_M("leak_asynctask_m.hprof", "25ae1778-7c1d-4ec7-ac50-5cce55424069"), //
+    ASYNC_TASK_O("leak_asynctask_o.hprof", "0e8d40d7-8302-4493-93d5-962a4c176089");
 
-    private final String filename;
-    private final String referenceKey;
+    public final String filename;
+    public final String referenceKey;
 
     HeapDumpFile(String filename, String referenceKey) {
       this.filename = filename;
@@ -46,7 +44,13 @@ static File fileFromName(String filename) {
     return new File(url.getPath());
   }
 
-  static AnalysisResult analyze(HeapDumpFile heapDumpFile, ExcludedRefs.Builder excludedRefs) {
+  static List<TrackedReference> findTrackedReferences(HeapDumpFile heapDumpFile) {
+    File file = fileFromName(heapDumpFile.filename);
+    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(NO_EXCLUDED_REFS);
+    return heapAnalyzer.findTrackedReferences(file);
+  }
+
+  static AnalysisResult analyze(HeapDumpFile heapDumpFile, ExcludedRefs.BuilderWithParams excludedRefs) {
     File file = fileFromName(heapDumpFile.filename);
     String referenceKey = heapDumpFile.referenceKey;
     HeapAnalyzer heapAnalyzer = new HeapAnalyzer(excludedRefs.build());
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TrackedReferencesTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TrackedReferencesTest.java
new file mode 100644
index 00000000..0be0d76f
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TrackedReferencesTest.java
@@ -0,0 +1,28 @@
+package com.squareup.leakcanary;
+
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_PRE_M;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_M;
+import static com.squareup.leakcanary.TestUtil.findTrackedReferences;
+import static org.assertj.core.api.Assertions.assertThat;
+
+@RunWith(JUnit4.class)
+public class TrackedReferencesTest {
+
+  @Test public void findsExpectedRef() {
+    List<TrackedReference> trackedReferences = findTrackedReferences(ASYNC_TASK_M);
+    assertThat(trackedReferences).hasSize(1);
+    TrackedReference firstRef = trackedReferences.get(0);
+    assertThat(firstRef.key).isEqualTo(ASYNC_TASK_M.referenceKey);
+    assertThat(firstRef.className).isEqualTo("com.example.leakcanary.MainActivity");
+  }
+
+  @Test public void findsSeveralRefs() {
+    List<TrackedReference> trackedReferences = findTrackedReferences(ASYNC_TASK_PRE_M);
+    assertThat(trackedReferences).hasSize(2);
+  }
+}
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_m_postpreview2.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_m.hprof
similarity index 100%
rename from leakcanary-analyzer/src/test/resources/leak_asynctask_m_postpreview2.hprof
rename to leakcanary-analyzer/src/test/resources/leak_asynctask_m.hprof
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof
deleted file mode 100644
index 548f3a2a..00000000
Binary files a/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof and /dev/null differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_o.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_o.hprof
new file mode 100644
index 00000000..1c62d0e5
Binary files /dev/null and b/leakcanary-analyzer/src/test/resources/leak_asynctask_o.hprof differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_pre_m.hprof
similarity index 100%
rename from leakcanary-analyzer/src/test/resources/leak_asynctask.hprof
rename to leakcanary-analyzer/src/test/resources/leak_asynctask_pre_m.hprof
diff --git a/leakcanary-analyzer/src/test/resources/leak_service_binder.hprof b/leakcanary-analyzer/src/test/resources/leak_service_binder.hprof
deleted file mode 100644
index af1dab18..00000000
Binary files a/leakcanary-analyzer/src/test/resources/leak_service_binder.hprof and /dev/null differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_service_binder_ignored.hprof b/leakcanary-analyzer/src/test/resources/leak_service_binder_ignored.hprof
deleted file mode 100644
index cdb867c4..00000000
Binary files a/leakcanary-analyzer/src/test/resources/leak_service_binder_ignored.hprof and /dev/null differ
diff --git a/leakcanary-android-no-op/build.gradle b/leakcanary-android-no-op/build.gradle
index 5f3dc025..1a81ee40 100644
--- a/leakcanary-android-no-op/build.gradle
+++ b/leakcanary-android-no-op/build.gradle
@@ -1,33 +1,17 @@
-version rootProject.ext.VERSION_NAME
-group rootProject.ext.GROUP
-
-buildscript {
-  repositories {
-    mavenCentral()
-  }
-}
-
 apply plugin: 'com.android.library'
 
-repositories {
-  mavenCentral()
-}
-
-dependencies {
-}
-
 android {
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
+  compileSdkVersion versions.compileSdk
+
   defaultConfig {
-    minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.targetSdkVersion
+    minSdkVersion versions.minSdk
   }
-}
 
-task sourceJar(type: Jar) {
-  from 'src/main/java'
+  // TODO replace with https://issuetracker.google.com/issues/72050365 once released.
+  libraryVariants.all {
+    it.generateBuildConfig.enabled = false
+  }
 }
 
 apply from: rootProject.file('gradle/checkstyle.gradle')
-apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android-no-op/gradle.properties b/leakcanary-android-no-op/gradle.properties
index 60494b8a..9a1cd04b 100644
--- a/leakcanary-android-no-op/gradle.properties
+++ b/leakcanary-android-no-op/gradle.properties
@@ -1,2 +1,3 @@
 POM_ARTIFACT_ID=leakcanary-android-no-op
-POM_NAME=No op LeakCanary for Android
\ No newline at end of file
+POM_NAME=No op LeakCanary for Android
+POM_PACKAGING=aar
\ No newline at end of file
diff --git a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
index 8fc8a58c..a9784143 100644
--- a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -1,6 +1,7 @@
 package com.squareup.leakcanary;
 
 import android.app.Application;
+import android.content.Context;
 
 /**
  * A no-op version of {@link LeakCanary} that can be used in release builds.
@@ -11,6 +12,10 @@ public static RefWatcher install(Application application) {
     return RefWatcher.DISABLED;
   }
 
+  public static boolean isInAnalyzerProcess(Context context) {
+    return false;
+  }
+
   private LeakCanary() {
     throw new AssertionError();
   }
diff --git a/leakcanary-android/build.gradle b/leakcanary-android/build.gradle
index beb07063..16b371f0 100644
--- a/leakcanary-android/build.gradle
+++ b/leakcanary-android/build.gradle
@@ -1,20 +1,8 @@
-version rootProject.ext.VERSION_NAME
-group rootProject.ext.GROUP
-
-buildscript {
-  repositories {
-    mavenCentral()
-  }
-}
-
 apply plugin: 'com.android.library'
 
-repositories {
-  mavenCentral()
-}
-
 dependencies {
-  compile project(':leakcanary-analyzer')
+  api project(':leakcanary-analyzer')
+  implementation 'com.android.support:support-core-utils:27.1.0'
 }
 
 def gitSha() {
@@ -23,20 +11,18 @@ def gitSha() {
 
 android {
   resourcePrefix 'leak_canary_'
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
+  compileSdkVersion versions.compileSdk
   defaultConfig {
-    minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.targetSdkVersion
+    minSdkVersion versions.minSdk
     buildConfigField "String", "LIBRARY_VERSION", "\"${rootProject.ext.VERSION_NAME}\""
     buildConfigField "String", "GIT_SHA", "\"${gitSha()}\""
     consumerProguardFiles 'consumer-proguard-rules.pro'
   }
-}
-
-task sourceJar(type: Jar) {
-  from 'src/main/java'
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    error 'ObsoleteSdkInt'
+  }
 }
 
 apply from: rootProject.file('gradle/checkstyle.gradle')
-apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android/consumer-proguard-rules.pro b/leakcanary-android/consumer-proguard-rules.pro
index 741501bb..48ffcc28 100644
--- a/leakcanary-android/consumer-proguard-rules.pro
+++ b/leakcanary-android/consumer-proguard-rules.pro
@@ -1,5 +1,9 @@
--keep class org.eclipse.mat.** { *; }
+-dontwarn com.squareup.haha.guava.**
+-dontwarn com.squareup.haha.perflib.**
+-dontwarn com.squareup.haha.trove.**
+-dontwarn com.squareup.leakcanary.**
+-keep class com.squareup.haha.** { *; }
 -keep class com.squareup.leakcanary.** { *; }
 
 # Marshmallow removed Notification.setLatestEventInfo()
--dontwarn android.app.Notification
\ No newline at end of file
+-dontwarn android.app.Notification
diff --git a/leakcanary-android/gradle.properties b/leakcanary-android/gradle.properties
index beee3e6f..f3d0feb4 100644
--- a/leakcanary-android/gradle.properties
+++ b/leakcanary-android/gradle.properties
@@ -1,2 +1,3 @@
 POM_ARTIFACT_ID=leakcanary-android
-POM_NAME=LeakCanary for Android
\ No newline at end of file
+POM_NAME=LeakCanary for Android
+POM_PACKAGING=aar
\ No newline at end of file
diff --git a/leakcanary-android/src/main/AndroidManifest.xml b/leakcanary-android/src/main/AndroidManifest.xml
index b5393171..1142e58e 100644
--- a/leakcanary-android/src/main/AndroidManifest.xml
+++ b/leakcanary-android/src/main/AndroidManifest.xml
@@ -31,15 +31,27 @@
         />
     <service
         android:name=".DisplayLeakService"
+        android:process=":leakcanary"
         android:enabled="false"
         />
+    <provider
+        android:name="android.support.v4.content.FileProvider"
+        android:authorities="com.squareup.leakcanary.fileprovider.${applicationId}"
+        android:exported="false"
+        android:grantUriPermissions="true"
+        >
+      <meta-data
+          android:name="android.support.FILE_PROVIDER_PATHS"
+          android:resource="@xml/leak_canary_file_paths"/>
+    </provider>
     <activity
         android:theme="@style/leak_canary_LeakCanary.Base"
         android:name=".internal.DisplayLeakActivity"
+        android:process=":leakcanary"
         android:enabled="false"
         android:label="@string/leak_canary_display_activity_label"
-        android:icon="@drawable/leak_canary_icon"
-        android:taskAffinity="com.squareup.leakcanary"
+        android:icon="@mipmap/leak_canary_icon"
+        android:taskAffinity="com.squareup.leakcanary.${applicationId}"
         >
       <intent-filter>
         <action android:name="android.intent.action.MAIN"/>
@@ -49,9 +61,12 @@
     <activity
         android:theme="@style/leak_canary_Theme.Transparent"
         android:name=".internal.RequestStoragePermissionActivity"
-        android:taskAffinity="com.squareup.leakcanary"
+        android:process=":leakcanary"
+        android:taskAffinity="com.squareup.leakcanary.${applicationId}"
         android:enabled="false"
-        android:icon="@drawable/leak_canary_icon"
+        android:excludeFromRecents="true"
+        android:icon="@mipmap/leak_canary_icon"
+        android:roundIcon="@mipmap/leak_canary_icon"
         android:label="@string/leak_canary_storage_permission_activity_label"
         />
 
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
index 160e840f..efb7762e 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
@@ -15,24 +15,22 @@
  */
 package com.squareup.leakcanary;
 
-import android.annotation.TargetApi;
 import android.app.Activity;
 import android.app.Application;
 import android.os.Bundle;
 
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH;
 import static com.squareup.leakcanary.Preconditions.checkNotNull;
 
-@TargetApi(ICE_CREAM_SANDWICH) public final class ActivityRefWatcher {
+public final class ActivityRefWatcher {
 
+  /** @deprecated Use {@link #install(Application, RefWatcher)}. */
+  @Deprecated
   public static void installOnIcsPlus(Application application, RefWatcher refWatcher) {
-    if (SDK_INT < ICE_CREAM_SANDWICH) {
-      // If you need to support Android < ICS, override onDestroy() in your base activity.
-      return;
-    }
-    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);
-    activityRefWatcher.watchActivities();
+    install(application, refWatcher);
+  }
+
+  public static void install(Application application, RefWatcher refWatcher) {
+    new ActivityRefWatcher(application, refWatcher).watchActivities();
   }
 
   private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =
@@ -67,7 +65,7 @@ public static void installOnIcsPlus(Application application, RefWatcher refWatch
    * Constructs an {@link ActivityRefWatcher} that will make sure the activities are not leaking
    * after they have been destroyed.
    */
-  public ActivityRefWatcher(Application application, final RefWatcher refWatcher) {
+  public ActivityRefWatcher(Application application, RefWatcher refWatcher) {
     this.application = checkNotNull(application, "application");
     this.refWatcher = checkNotNull(refWatcher, "refWatcher");
   }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
index 0db6e64c..e60b0a5d 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
@@ -22,19 +22,25 @@
 
 import static android.os.Build.MANUFACTURER;
 import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.ECLAIR;
 import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH;
 import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1;
 import static android.os.Build.VERSION_CODES.JELLY_BEAN;
 import static android.os.Build.VERSION_CODES.KITKAT;
 import static android.os.Build.VERSION_CODES.LOLLIPOP;
+import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
 import static android.os.Build.VERSION_CODES.M;
+import static android.os.Build.VERSION_CODES.N;
+import static android.os.Build.VERSION_CODES.N_MR1;
+import static android.os.Build.VERSION_CODES.O_MR1;
 import static com.squareup.leakcanary.AndroidWatchExecutor.LEAK_CANARY_THREAD_NAME;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.HUAWEI;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.LENOVO;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.LG;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.LOLLIPOP_MR1;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.MEIZU;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.MOTOROLA;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.NVIDIA;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.SAMSUNG;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.VIVO;
 
 /**
  * This class is a work in progress. You can help by reporting leak traces that seem to be caused
@@ -48,242 +54,354 @@
  * leaks you want to ignore by creating an {@link EnumSet} that matches your needs and calling
  * {@link #createBuilder(EnumSet)}
  */
+@SuppressWarnings({ "unused", "WeakerAccess" }) // Public API.
 public enum AndroidExcludedRefs {
 
+  // ######## Android SDK Excluded refs ########
+
   ACTIVITY_CLIENT_RECORD__NEXT_IDLE(SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Android AOSP sometimes keeps a reference to a destroyed activity as a "nextIdle" client
-      // record in the android.app.ActivityThread.mActivities map.
-      // Not sure what's going on there, input welcome.
-      excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle");
+      excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle")
+          .reason("Android AOSP sometimes keeps a reference to a destroyed activity as a"
+              + " nextIdle client record in the android.app.ActivityThread.mActivities map."
+              + " Not sure what's going on there, input welcome.");
     }
   },
 
   SPAN_CONTROLLER(SDK_INT <= KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Editor inserts a special span, which has a reference to the EditText. That span is a
-      // NoCopySpan, which makes sure it gets dropped when creating a new SpannableStringBuilder
-      // from a given CharSequence.
-      // TextView.onSaveInstanceState() does a copy of its mText before saving it in the bundle.
-      // Prior to KitKat, that copy was done using the SpannableString constructor, instead of
-      // SpannableStringBuilder. The SpannableString constructor does not drop NoCopySpan spans.
-      // So we end up with a saved state that holds a reference to the textview and therefore the
-      // entire view hierarchy & activity context.
-      // Fix: https://github.com/android/platform_frameworks_base/commit
-      // /af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b
-
-      // Hack: to fix this, you could override TextView.onSaveInstanceState(), and then use
-      // reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.
-      excluded.instanceField("android.widget.Editor$EasyEditSpanController", "this$0");
-      excluded.instanceField("android.widget.Editor$SpanController", "this$0");
+      String reason =
+          "Editor inserts a special span, which has a reference to the EditText. That span is a"
+              + " NoCopySpan, which makes sure it gets dropped when creating a new"
+              + " SpannableStringBuilder from a given CharSequence."
+              + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
+              + " bundle. Prior to KitKat, that copy was done using the SpannableString"
+              + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
+              + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
+              + " reference to the textview and therefore the entire view hierarchy & activity"
+              + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
+              + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
+              + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
+              + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.";
+      excluded.instanceField("android.widget.Editor$EasyEditSpanController", "this$0")
+          .reason(reason);
+      excluded.instanceField("android.widget.Editor$SpanController", "this$0").reason(reason);
     }
   },
 
   MEDIA_SESSION_LEGACY_HELPER__SINSTANCE(SDK_INT == LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // MediaSessionLegacyHelper is a static singleton that is lazily instantiated and keeps a
-      // reference to the context it's given the first time MediaSessionLegacyHelper.getHelper()
-      // is called.
-      // This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by calling
-      // context.getApplicationContext().
-      // Fix: https://github.com/android/platform_frameworks_base/commit
-      // /9b5257c9c99c4cb541d8e8e78fb04f008b1a9091
-
-      // Hack: to fix this, you could call MediaSessionLegacyHelper.getHelper() early in
-      // Application.onCreate() and pass it the application context.
-      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance");
+      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance")
+          .reason("MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
+              + " keeps a reference to the context it's given the first time"
+              + " MediaSessionLegacyHelper.getHelper() is called."
+              + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
+              + " calling context.getApplicationContext()."
+              + " Fix: https://github.com/android/platform_frameworks_base/commit"
+              + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
+              + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
+              + " in Application.onCreate() and pass it the application context.");
     }
   },
 
   TEXT_LINE__SCACHED(SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had at least two
-      // bugs that created memory leaks by not correctly clearing the recycled TextLine instances.
-      // The first was fixed in android-5.1.0_r1:
-      // https://github.com/android/platform_frameworks_base/commit
-      // /893d6fe48d37f71e683f722457bea646994a10bf
-
-      // The second was fixed, not released yet:
-      // https://github.com/android/platform_frameworks_base/commit
-      // /b3a9bc038d3a218b1dbdf7b5668e3d6c12be5ee4
+      excluded.staticField("android.text.TextLine", "sCached")
+          .reason("TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
+              + " at least two bugs that created memory leaks by not correctly clearing the"
+              + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
+              + " https://github.com/android/platform_frameworks_base/commit"
+              + "/893d6fe48d37f71e683f722457bea646994a10"
+              + " The second was fixed, not released yet:"
+              + " https://github.com/android/platform_frameworks_base/commit"
+              + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
+              + " To fix this, you could access TextLine.sCached and clear the pool every now"
+              + " and then (e.g. on activity destroy).");
+    }
+  },
+
+  BLOCKING_QUEUE(SDK_INT <= LOLLIPOP) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      String reason = "Prior to ART, a thread waiting on a blocking queue will leak the last"
+          + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
+          + " keeps a local reference to the last message it received. That message then gets"
+          + " recycled and can be used again. As long as all messages are recycled after being"
+          + "used, this won't be a problem, because these references are cleared when being"
+          + "recycled. However, dialogs create template Message instances to be copied when a"
+          + "message needs to be sent. These Message templates holds references to the dialog"
+          + "listeners, which most likely leads to holding a reference onto the activity in some"
+          + "way. Dialogs never recycle their template Message, assuming these Message instances"
+          + " will get GCed when the dialog is GCed."
+          + " The combination of these two things creates a high potential for memory leaks as soon"
+          + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
+          + " sleep for a long time."
+          + " To fix this, you could post empty messages to the idle handler threads from time to"
+          + " time. This won't be easy because you cannot access all handler threads, but a library"
+          + "that is widely used should consider doing this for its own handler threads.";
+      excluded.instanceField("android.os.Message", "obj").reason(reason);
+      excluded.instanceField("android.os.Message", "next").reason(reason);
+      excluded.instanceField("android.os.Message", "target").reason(reason);
+    }
+  },
+
+  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= O_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      String reason = "When we detach a view that receives keyboard input, the InputMethodManager"
+          + " leaks a reference to it until a new view asks for keyboard input."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
+          + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414";
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView")
+          .reason(reason);
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView")
+          .reason(reason);
+      excluded.instanceField("android.view.inputmethod.InputMethodManager",
+          "mServedInputConnection").reason(reason);
+    }
+  },
 
-      // Hack: to fix this, you could access TextLine.sCached and clear the pool every now and then
-      // (e.g. on activity destroy).
-      excluded.staticField("android.text.TextLine", "sCached");
+  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= O_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView")
+          .reason("The singleton InputMethodManager is holding a reference to mCurRootView long"
+              + " after the activity has been destroyed."
+              + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
+              + "#issuecomment-100579429"
+              + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414");
     }
   },
 
-  BLOCKING_QUEUE(SDK_INT < LOLLIPOP) {
+  LAYOUT_TRANSITION(SDK_INT >= ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Prior to ART, a thread waiting on a blocking queue will leak the last dequeued object
-      // as a stack local reference.
-      // So when a HandlerThread becomes idle, it keeps a local reference to the last message it
-      // received. That message then gets recycled and can be used again.
-      // As long as all messages are recycled after being used, this won't be a problem, because
-      // there references are cleared when being recycled.
-      // However, dialogs create template Message instances to be copied when a message needs to be
-      // sent. These Message templates holds references to the dialog listeners, which most likely
-      // leads to holding a reference onto the activity in some way. Dialogs never recycle their
-      // template Message, assuming these Message instances will get GCed when the dialog is GCed.
-      // The combination of these two things creates a high potential for memory leaks as soon
-      // as you use dialogs. These memory leaks might be temporary, but some handler threads sleep
-      // for a long time.
+      excluded.instanceField("android.animation.LayoutTransition$1", "val$parent")
+          .reason("LayoutTransition leaks parent ViewGroup through"
+              + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
+              + " window is destroyed. Tracked here:"
+              + " https://code.google.com/p/android/issues/detail?id=171830");
+    }
+  },
 
-      // Hack: to fix this, you could post empty messages to the idle handler threads from time to
-      // time. This won't be easy because you cannot access all handler threads, but a library
-      // that is widely used should consider doing this for its own handler threads.
-      excluded.instanceField("android.os.Message", "obj");
-      excluded.instanceField("android.os.Message", "next");
-      excluded.instanceField("android.os.Message", "target");
+  SPELL_CHECKER_SESSION((SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) || SDK_INT >= N) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0")
+          .reason("SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
+              + " SpellCheckerSession is closed before the service is connected."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542");
     }
   },
 
-  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= M) {
+  ACTIVITY_CHOOSE_MODEL(SDK_INT > ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // When we detach a view that receives keyboard input, the InputMethodManager leaks a
-      // reference to it until a new view asks for keyboard input.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=171190
-      // Hack: https://gist.github.com/pyricau/4df64341cc978a7de414
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView");
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView");
-      excluded.instanceField("android.view.inputmethod.InputMethodManager",
-          "mServedInputConnection");
+      String reason = "ActivityChooserModel holds a static reference to the last set"
+          + " ActivityChooserModelPolicy which can be an activity context."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
+          + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0";
+      excluded.instanceField("android.support.v7.internal.widget.ActivityChooserModel",
+          "mActivityChoserModelPolicy").reason(reason);
+      excluded.instanceField("android.widget.ActivityChooserModel", "mActivityChoserModelPolicy")
+          .reason(reason);
     }
   },
 
-  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= LOLLIPOP_MR1) {
+  SPEECH_RECOGNIZER(SDK_INT < LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // The singleton InputMethodManager is holding a reference to mCurRootView long after the
-      // activity has been destroyed.
-      // Observed on ICS MR1: https://github.com/square/leakcanary/issues/1#issuecomment-100579429
-      // Hack: https://gist.github.com/pyricau/4df64341cc978a7de414
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView");
+      excluded.instanceField("android.speech.SpeechRecognizer$InternalListener", "this$0")
+          .reason("Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
+              + " class and leaked the SpeechRecognizer which leaked an activity context."
+              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+              + " /b37866db469e81aca534ff6186bdafd44352329b");
     }
   },
 
-  LAYOUT_TRANSITION(SDK_INT >= ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
+  ACCOUNT_MANAGER(SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // LayoutTransition leaks parent ViewGroup through ViewTreeObserver.OnPreDrawListener
-      // When triggered, this leaks stays until the window is destroyed.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=171830
-      excluded.instanceField("android.animation.LayoutTransition$1", "val$parent");
+      excluded.instanceField("android.accounts.AccountManager$AmsTask$Response", "this$1")
+          .reason("AccountManager$AmsTask$Response is a stub and is held in memory by native code,"
+              + " probably because the reference to the response in the other process hasn't been"
+              + " cleared."
+              + " AccountManager$AmsTask is holding on to the activity reference to use for"
+              + " launching a new sub- Activity."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
+              + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
+              + " with the returned future to to get the result and correctly start an activity"
+              + " when it's available.");
     }
   },
 
-  SPELL_CHECKER_SESSION(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
+  MEDIA_SCANNER_CONNECTION(SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the
-      // SpellCheckerSession is closed before the service is connected.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=172542
-      excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0");
+      excluded.instanceField("android.media.MediaScannerConnection", "mContext")
+          .reason("The static method MediaScannerConnection.scanFile() takes an activity context"
+              + " but the service might not disconnect after the activity has been destroyed."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
+              + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
+              + " application context. Call connect() and disconnect() manually.");
     }
   },
 
-  ACTIVITY_CHOOSE_MODEL(SDK_INT > ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
+  USER_MANAGER__SINSTANCE(SDK_INT >= JELLY_BEAN && SDK_INT <= M) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // ActivityChooserModel holds a static reference to the last set ActivityChooserModelPolicy
-      // which can be an activity context.
-      // Tracked here : https://code.google.com/p/android/issues/detail?id=172659
-      // Hack : https://gist.github.com/andaag/b05ab66ed0f06167d6e0
-      excluded.instanceField("android.support.v7.internal.widget.ActivityChooserModel",
-                             "mActivityChoserModelPolicy");
-      excluded.instanceField("android.widget.ActivityChooserModel", "mActivityChoserModelPolicy");
+      excluded.instanceField("android.os.UserManager", "mContext")
+          .reason("UserManager has a static sInstance field that creates an instance and caches it"
+              + " the first time UserManager.get() is called. This instance is created with the"
+              + " outer context (which is an activity base context)."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
+              + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
+              + "/27db46850b708070452c0ce49daf5f79503fbde6"
+              + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
+              + " UserManager instance gets cached with a reference to the application context.");
     }
   },
 
-  SPEECH_RECOGNIZER(SDK_INT < LOLLIPOP) {
+  APP_WIDGET_HOST_CALLBACKS(SDK_INT < LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner class and
-      // leaked the SpeechRecognizer which leaked an activity context.
-      // Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit
-      // /b37866db469e81aca534ff6186bdafd44352329b
-      excluded.instanceField("android.speech.SpeechRecognizer$InternalListener", "this$0");
+      excluded.instanceField("android.appwidget.AppWidgetHost$Callbacks", "this$0")
+          .reason("android.appwidget.AppWidgetHost$Callbacks is a stub and is held in memory native"
+              + " code. The reference to the `mContext` was not being cleared, which caused the"
+              + " Callbacks instance to retain this reference"
+              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+              + "/7a96f3c917e0001ee739b65da37b2fadec7d7765");
     }
   },
 
-  ACCOUNT_MANAGER(SDK_INT > ECLAIR && SDK_INT <= LOLLIPOP_MR1) {
+  AUDIO_MANAGER(SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // AccountManager$AmsTask$Response is a stub and is held in memory by native code, probably
-      // because the reference to the response in the other process hasn't been cleared.
-      // AccountManager$AmsTask is holding on to the activity reference to use for launching a new
-      // sub- Activity.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=173689
-      // Fix: Pass a null activity reference to the AccountManager methods and then deal with the
-      // returned future to to get the result and correctly start an activity when it's available.
-      excluded.instanceField("android.accounts.AccountManager$AmsTask$Response", "this$1");
+      excluded.instanceField("android.media.AudioManager$1", "this$0")
+          .reason("Prior to Android M, VideoView required audio focus from AudioManager and"
+              + " never abandoned it, which leaks the Activity context through the AudioManager."
+              + " The root of the problem is that AudioManager uses whichever"
+              + " context it receives, which in the case of the VideoView example is an Activity,"
+              + " even though it only needs the application's context. The issue is fixed in"
+              + " Android M, and the AudioManager now uses the application's context."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
+              + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2");
     }
   },
 
-  MEDIA_SCANNER_CONNECTION(SDK_INT <= LOLLIPOP_MR1) {
+  EDITTEXT_BLINK_MESSAGEQUEUE(SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // The static method MediaScannerConnection.scanFile() takes an activity context but the
-      // service might not disconnect after the activity has been destroyed.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=173788
-      // Fix: Create an instance of MediaScannerConnection yourself and pass in the application
-      // context. Call connect() and disconnect() manually.
-      excluded.instanceField("android.media.MediaScannerConnection", "mContext");
+      excluded.instanceField("android.widget.Editor$Blink", "this$0")
+          .reason("The EditText Blink of the Cursor is implemented using a callback and Messages,"
+              + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
+              + " contains a blinking cursor is detached, a message is posted with a delay after the"
+              + " dialog has been closed and as a result leaks the Activity."
+              + " This can be fixed manually by calling TextView.setCursorVisible(false) in the"
+              + " dismiss() method of the dialog."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
+              + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
+              + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/");
     }
   },
 
-  USER_MANAGER__SINSTANCE(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
+  CONNECTIVITY_MANAGER__SINSTANCE(SDK_INT <= M) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // UserManager has a static sInstance field that creates an instance and caches it the first
-      // time UserManager.get() is called. This instance is created with the outer context (which
-      // is an activity base context).
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=173789
-      // Introduced by: https://github.com/android/platform_frameworks_base/commit
-      // /27db46850b708070452c0ce49daf5f79503fbde6
-      // Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the
-      // UserManager instance gets cached with a reference to the application context.
-      excluded.instanceField("android.os.UserManager", "mContext");
+      excluded.instanceField("android.net.ConnectivityManager", "sInstance")
+          .reason("ConnectivityManager has a sInstance field that is set when the first"
+              + "ConnectivityManager instance is created. ConnectivityManager has a mContext field."
+              + "When calling activity.getSystemService(Context.CONNECTIVITY_SERVICE) , the first"
+              + "ConnectivityManager instance is created with the activity context and stored in"
+              + "sInstance. That activity context then leaks forever."
+              + "Until this is fixed, app developers can prevent this leak by making sure the"
+              + " ConnectivityManager is first created with an App Context. E.g. in some static"
+              + " init do: context.getApplicationContext()"
+              + ".getSystemService(Context.CONNECTIVITY_SERVICE)"
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=198852"
+              + " Introduced here: https://github.com/android/platform_frameworks_base/commit/"
+              + "e0bef71662d81caaaa0d7214fb0bef5d39996a69");
     }
   },
 
-  APP_WIDGET_HOST_CALLBACKS(SDK_INT < LOLLIPOP_MR1) {
+  // ######## Manufacturer specific Excluded refs ########
+
+  INSTRUMENTATION_RECOMMEND_ACTIVITY(MEIZU.equals(MANUFACTURER) && SDK_INT >= LOLLIPOP && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // android.appwidget.AppWidgetHost$Callbacks is a stub and is held in memory native code
-      // The reference to the `mContext` was not being cleared, which caused the Callbacks instance to retain this reference
-      // Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit/7a96f3c917e0001ee739b65da37b2fadec7d7765
-      excluded.instanceField("android.appwidget.AppWidgetHost$Callbacks", "this$0");
+      excluded.staticField("android.app.Instrumentation", "mRecommendActivity")
+              .reason("Instrumentation would leak com.android.internal.app.RecommendActivity (in framework.jar)"
+                  + " in Meizu FlymeOS 4.5 and above, which is based on Android 5.0 and above");
     }
   },
 
-  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER(MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER(
+      MOTOROLA.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
       if (MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-        // DevicePolicyManager keeps a reference to the context it has been created with instead of
-        // extracting the application context. In this Motorola build, DevicePolicyManager has an
-        // inner SettingsObserver class that is a content observer, which is held into memory
-        // by a binder transport object.
-        excluded.instanceField("android.app.admin.DevicePolicyManager$SettingsObserver", "this$0");
+        excluded.instanceField("android.app.admin.DevicePolicyManager$SettingsObserver", "this$0")
+            .reason("DevicePolicyManager keeps a reference to the context it has been created with"
+                + " instead of extracting the application context. In this Motorola build,"
+                + " DevicePolicyManager has an inner SettingsObserver class that is a content"
+                + " observer, which is held into memory by a binder transport object.");
       }
     }
   },
 
   SPEN_GESTURE_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // SpenGestureManager has a static mContext field that leaks a reference to the activity.
-      // Yes, a STATIC "mContext" field.
-      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext");
+      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext")
+          .reason("SpenGestureManager has a static mContext field that leaks a reference to the"
+              + " activity. Yes, a STATIC mContext field.");
+    }
+  },
+
+  GESTURE_BOOST_MANAGER(HUAWEI.equals(MANUFACTURER) && SDK_INT >= N && SDK_INT <= N_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.staticField("android.gestureboost.GestureBoostManager", "mContext")
+          .reason("GestureBoostManager is a static singleton that leaks an activity context."
+          + "Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756");
+    }
+  },
+
+  INPUT_METHOD_MANAGER__LAST_SERVED_VIEW(HUAWEI.equals(MANUFACTURER) && SDK_INT == N) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      String reason = "HUAWEI added a mLastSrvView field to InputMethodManager"
+          + " that leaks a reference to the last served view.";
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mLastSrvView")
+          .reason(reason);
     }
   },
 
   CLIPBOARD_UI_MANAGER__SINSTANCE(
       SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // ClipboardUIManager is a static singleton that leaks an activity context.
-      // Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate(), so
-      // that the ClipboardUIManager instance gets cached with a reference to the
-      // application context. Example: https://gist.github.com/pepyakin/8d2221501fd572d4a61c
-      excluded.instanceField("android.sec.clipboard.ClipboardUIManager", "mContext");
+      excluded.instanceField("android.sec.clipboard.ClipboardUIManager", "mContext")
+          .reason("ClipboardUIManager is a static singleton that leaks an activity context."
+              + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
+              + " , so that the ClipboardUIManager instance gets cached with a reference to the"
+              + " application context. Example: https://gist.github.com/cypressious/"
+              + "91c4fb1455470d803a602838dfcd5774");
+    }
+  },
+
+  SEM_CLIPBOARD_MANAGER__MCONTEXT(
+      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= N) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("com.samsung.android.content.clipboard.SemClipboardManager",
+          "mContext")
+          .reason("SemClipboardManager is held in memory by an anonymous inner class "
+              + "implementation of android.os.Binder, thereby leaking an activity context.");
+    }
+  },
+
+  SEM_EMERGENCY_MANAGER__MCONTEXT(
+      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= N) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("com.samsung.android.emergencymode.SemEmergencyManager", "mContext")
+          .reason("SemEmergencyManager is a static singleton that leaks a DecorContext. "
+              + "Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d");
     }
   },
 
   BUBBLE_POPUP_HELPER__SHELPER(
       LG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // A static helper for EditText "bubble popups" leaks a reference to the latest focused view.
-      excluded.staticField("android.widget.BubblePopupHelper", "sHelper");
+      excluded.staticField("android.widget.BubblePopupHelper", "sHelper")
+          .reason("A static helper for EditText bubble popups leaks a reference to the latest"
+              + "focused view.");
+    }
+  },
+
+  LGCONTEXT__MCONTEXT(LG.equals(MANUFACTURER) && SDK_INT == LOLLIPOP) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("com.lge.systemservice.core.LGContext", "mContext")
+          .reason("LGContext is a static singleton that leaks an activity context.");
     }
   },
 
@@ -298,90 +416,90 @@
 
   MAPPER_CLIENT(NVIDIA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Not sure exactly what ControllerMapper is about, but there is an anonymous Handler in
-      // ControllerMapper.MapperClient.ServiceClient, which leaks ControllerMapper.MapperClient
-      // which leaks the activity context.
-      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient$ServiceClient", "this$0");
+      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient$ServiceClient", "this$0")
+          .reason("Not sure exactly what ControllerMapper is about, but there is an anonymous"
+              + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
+              + " ControllerMapper.MapperClient which leaks the activity context.");
     }
   },
 
   TEXT_VIEW__MLAST_HOVERED_VIEW(
-      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
+      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // mLastHoveredView is a static field in TextView that leaks the last hovered view.
-      excluded.staticField("android.widget.TextView", "mLastHoveredView");
+      excluded.staticField("android.widget.TextView", "mLastHoveredView")
+          .reason("mLastHoveredView is a static field in TextView that leaks the last hovered"
+              + " view.");
     }
   },
 
   PERSONA_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // android.app.LoadedApk.mResources has a reference to
-      // android.content.res.Resources.mPersonaManager which has a reference to
-      // android.os.PersonaManager.mContext which is an activity.
-      excluded.instanceField("android.os.PersonaManager", "mContext");
+      excluded.instanceField("android.os.PersonaManager", "mContext")
+          .reason("android.app.LoadedApk.mResources has a reference to"
+              + " android.content.res.Resources.mPersonaManager which has a reference to"
+              + " android.os.PersonaManager.mContext which is an activity.");
     }
   },
 
   RESOURCES__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // In AOSP the Resources class does not have a context.
-      // Here we have ZygoteInit.mResources (static field) holding on to a Resources instance that
-      // has a context that is the activity.
-      // Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184
-      excluded.instanceField("android.content.res.Resources", "mContext");
+      excluded.instanceField("android.content.res.Resources", "mContext")
+          .reason("In AOSP the Resources class does not have a context."
+              + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
+              + " instance that has a context that is the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184");
     }
   },
 
   VIEW_CONFIGURATION__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // In AOSP the ViewConfiguration class does not have a context.
-      // Here we have ViewConfiguration.sConfigurations (static field) holding on to a
-      // ViewConfiguration instance that has a context that is the activity.
-      // Observed here: https://github.com/square/leakcanary/issues/1#issuecomment-100324683
-      excluded.instanceField("android.view.ViewConfiguration", "mContext");
+      excluded.instanceField("android.view.ViewConfiguration", "mContext")
+          .reason("In AOSP the ViewConfiguration class does not have a context."
+              + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
+              + " ViewConfiguration instance that has a context that is the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues"
+              + "/1#issuecomment-100324683");
     }
   },
 
-  AUDIO_MANAGER__MCONTEXT_STATIC(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+  SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL((LENOVO.equals(MANUFACTURER) && SDK_INT == KITKAT) //
+      || (VIVO.equals(MANUFACTURER) && SDK_INT == LOLLIPOP_MR1)) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Samsung added a static mContext_static field to AudioManager, holds a reference to the
-      // activity.
-      // Observed here: https://github.com/square/leakcanary/issues/32
-      excluded.staticField("android.media.AudioManager", "mContext_static");
+      excluded.staticField("android.hardware.SystemSensorManager", "mAppContextImpl")
+          .reason("SystemSensorManager stores a reference to context "
+              + "in a static field in its constructor."
+              + "Fix: use application context to get SensorManager");
     }
   },
 
-  SERVICE_BINDER {
+  AUDIO_MANAGER__MCONTEXT_STATIC(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // We should ignore leaks where an android.os.Binder is the root of the leak.
-      // When you bind and unbind from a Service, the OS will keep a reference to the Binder
-      // until the client binder has been GC'ed. This means the Binder can be retained after
-      // Service.onDestroy() is called.
-      excluded.rootSuperClass("android.os.Binder", true);
+      excluded.staticField("android.media.AudioManager", "mContext_static")
+          .reason("Samsung added a static mContext_static field to AudioManager, holds a reference"
+              + " to the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues/32");
     }
   },
 
-  SOFT_REFERENCES {
+  ACTIVITY_MANAGER_MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.clazz(WeakReference.class.getName(), true);
-      excluded.clazz(SoftReference.class.getName(), true);
-      excluded.clazz(PhantomReference.class.getName(), true);
-      excluded.clazz("java.lang.ref.Finalizer", true);
-      excluded.clazz("java.lang.ref.FinalizerReference", true);
+      excluded.staticField("android.app.ActivityManager", "mContext")
+          .reason("Samsung added a static mContext field to ActivityManager, holds a reference"
+              + " to the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues/177 Fix in comment:"
+              + " https://github.com/square/leakcanary/issues/177#issuecomment-222724283");
     }
   },
 
-  AUDIO_MANAGER(SDK_INT <= LOLLIPOP_MR1) {
+  // ######## General Excluded refs ########
+
+  SOFT_REFERENCES {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Prior to Android M, VideoView required audio focus from AudioManager and
-      // never abandoned it, which leaks the Activity context through the AudioManager.
-      // The root of the problem is that AudioManager uses whichever
-      // context it receives, which in the case of the VideoView example is an Activity,
-      // even though it only needs the application's context. The issue is fixed in
-      // Android M, and the AudioManager now uses the application's context.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=152173
-      // Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2
-      excluded.instanceField("android.media.AudioManager$1", "this$0");
+      excluded.clazz(WeakReference.class.getName()).alwaysExclude();
+      excluded.clazz(SoftReference.class.getName()).alwaysExclude();
+      excluded.clazz(PhantomReference.class.getName()).alwaysExclude();
+      excluded.clazz("java.lang.ref.Finalizer").alwaysExclude();
+      excluded.clazz("java.lang.ref.FinalizerReference").alwaysExclude();
     }
   },
 
@@ -389,7 +507,7 @@
     @Override void add(ExcludedRefs.Builder excluded) {
       // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
       // reference to the object and it was about to be GCed.
-      excluded.thread("FinalizerWatchdogDaemon", true);
+      excluded.thread("FinalizerWatchdogDaemon").alwaysExclude();
     }
   },
 
@@ -398,13 +516,13 @@
       // The main thread stack is ever changing so local variables aren't likely to hold references
       // for long. If this is on the shortest path, it's probably that there's a longer path with
       // a real leak.
-      excluded.thread("main", true);
+      excluded.thread("main").alwaysExclude();
     }
   },
 
   LEAK_CANARY_THREAD {
     @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.thread(LEAK_CANARY_THREAD_NAME, true);
+      excluded.thread(LEAK_CANARY_THREAD_NAME).alwaysExclude();
     }
   },
 
@@ -415,7 +533,7 @@
       // The main thread message queue is held on by the main Looper, but that might be a longer
       // path. Let's not confuse people with a shorter path that is less meaningful.
       excluded.instanceField("android.view.Choreographer$FrameDisplayEventReceiver",
-          "mMessageQueue", true);
+          "mMessageQueue").alwaysExclude();
     }
   };
 
@@ -423,8 +541,9 @@
    * This returns the references in the leak path that should be ignored by all on Android.
    */
   public static ExcludedRefs.Builder createAndroidDefaults() {
-    return createBuilder(EnumSet.of(SOFT_REFERENCES, FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
-        EVENT_RECEIVER__MMESSAGE_QUEUE, SERVICE_BINDER));
+    return createBuilder(
+        EnumSet.of(SOFT_REFERENCES, FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
+            EVENT_RECEIVER__MMESSAGE_QUEUE));
   }
 
   /**
@@ -438,10 +557,11 @@
   }
 
   public static ExcludedRefs.Builder createBuilder(EnumSet<AndroidExcludedRefs> refs) {
-    ExcludedRefs.Builder excluded = new ExcludedRefs.Builder();
+    ExcludedRefs.Builder excluded = ExcludedRefs.builder();
     for (AndroidExcludedRefs ref : refs) {
       if (ref.applies) {
         ref.add(excluded);
+        ((ExcludedRefs.BuilderWithParams) excluded).named(ref.name());
       }
     }
     return excluded;
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
index 86a232f0..9d618059 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
@@ -24,18 +24,14 @@
 import android.view.LayoutInflater;
 import android.widget.Toast;
 import com.squareup.leakcanary.internal.FutureResult;
-import com.squareup.leakcanary.internal.LeakCanaryInternals;
 import java.io.File;
-import java.io.IOException;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
 
 public final class AndroidHeapDumper implements HeapDumper {
 
-  private static final String HEAPDUMP_FILE = "suspected_leak_heapdump.hprof";
-
   final Context context;
-  final LeakDirectoryProvider leakDirectoryProvider;
+  private final LeakDirectoryProvider leakDirectoryProvider;
   private final Handler mainHandler;
 
   public AndroidHeapDumper(Context context, LeakDirectoryProvider leakDirectoryProvider) {
@@ -44,28 +40,13 @@ public AndroidHeapDumper(Context context, LeakDirectoryProvider leakDirectoryPro
     mainHandler = new Handler(Looper.getMainLooper());
   }
 
+
+  @SuppressWarnings("ReferenceEquality") // Explicitly checking for named null.
   @Override public File dumpHeap() {
-    if (!leakDirectoryProvider.isLeakStorageWritable()) {
-      CanaryLog.d("Could not write to leak storage to dump heap.");
-      leakDirectoryProvider.requestWritePermission();
-      return NO_DUMP;
-    }
-    File heapDumpFile = getHeapDumpFile();
-    // Atomic way to check for existence & create the file if it doesn't exist.
-    // Prevents several processes in the same app to attempt a heapdump at the same time.
-    boolean fileCreated;
-    try {
-      fileCreated = heapDumpFile.createNewFile();
-    } catch (IOException e) {
-      cleanup();
-      CanaryLog.d(e, "Could not check if heap dump file exists");
-      return NO_DUMP;
-    }
+    File heapDumpFile = leakDirectoryProvider.newHeapDumpFile();
 
-    if (!fileCreated) {
-      CanaryLog.d("Could not dump heap, previous analysis still is in progress.");
-      // Heap analysis in progress, let's not put too much pressure on the device.
-      return NO_DUMP;
+    if (heapDumpFile == RETRY_LATER) {
+      return RETRY_LATER;
     }
 
     FutureResult<Toast> waitingForToast = new FutureResult<>();
@@ -73,7 +54,7 @@ public AndroidHeapDumper(Context context, LeakDirectoryProvider leakDirectoryPro
 
     if (!waitingForToast.wait(5, SECONDS)) {
       CanaryLog.d("Did not dump heap, too much time waiting for Toast.");
-      return NO_DUMP;
+      return RETRY_LATER;
     }
 
     Toast toast = waitingForToast.get();
@@ -82,40 +63,12 @@ public AndroidHeapDumper(Context context, LeakDirectoryProvider leakDirectoryPro
       cancelToast(toast);
       return heapDumpFile;
     } catch (Exception e) {
-      cleanup();
-      CanaryLog.d(e, "Could not perform heap dump");
+      CanaryLog.d(e, "Could not dump heap");
       // Abort heap dump
-      return NO_DUMP;
+      return RETRY_LATER;
     }
   }
 
-  /**
-   * Call this on app startup to clean up all heap dump files that had not been handled yet when
-   * the app process was killed.
-   */
-  public void cleanup() {
-    LeakCanaryInternals.executeOnFileIoThread(new Runnable() {
-      @Override public void run() {
-        if (!leakDirectoryProvider.isLeakStorageWritable()) {
-          CanaryLog.d("Could not attempt cleanup, leak storage not writable.");
-          return;
-        }
-        File heapDumpFile = getHeapDumpFile();
-        if (heapDumpFile.exists()) {
-          CanaryLog.d("Previous analysis did not complete correctly, cleaning: %s", heapDumpFile);
-          boolean success = heapDumpFile.delete();
-          if (!success) {
-            CanaryLog.d("Could not delete file %s", heapDumpFile.getPath());
-          }
-        }
-      }
-    });
-  }
-
-  File getHeapDumpFile() {
-    return new File(leakDirectoryProvider.leakDirectory(), HEAPDUMP_FILE);
-  }
-
   private void showToast(final FutureResult<Toast> waitingForToast) {
     mainHandler.post(new Runnable() {
       @Override public void run() {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
new file mode 100644
index 00000000..52fe7c4a
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
@@ -0,0 +1,111 @@
+package com.squareup.leakcanary;
+
+import android.app.Application;
+import android.content.Context;
+import com.squareup.leakcanary.internal.LeakCanaryInternals;
+import java.util.concurrent.TimeUnit;
+
+import static com.squareup.leakcanary.RefWatcher.DISABLED;
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/** A {@link RefWatcherBuilder} with appropriate Android defaults. */
+public final class AndroidRefWatcherBuilder extends RefWatcherBuilder<AndroidRefWatcherBuilder> {
+
+  private static final long DEFAULT_WATCH_DELAY_MILLIS = SECONDS.toMillis(5);
+
+  private final Context context;
+  private boolean watchActivities = true;
+
+  AndroidRefWatcherBuilder(Context context) {
+    this.context = context.getApplicationContext();
+  }
+
+  /**
+   * Sets a custom {@link AbstractAnalysisResultService} to listen to analysis results. This
+   * overrides any call to {@link #heapDumpListener(HeapDump.Listener)}.
+   */
+  public AndroidRefWatcherBuilder listenerServiceClass(
+      Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
+    return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));
+  }
+
+  /**
+   * Sets a custom delay for how long the {@link RefWatcher} should wait until it checks if a
+   * tracked object has been garbage collected. This overrides any call to {@link
+   * #watchExecutor(WatchExecutor)}.
+   */
+  public AndroidRefWatcherBuilder watchDelay(long delay, TimeUnit unit) {
+    return watchExecutor(new AndroidWatchExecutor(unit.toMillis(delay)));
+  }
+
+  /**
+   * Whether we should automatically watch activities when {@link #buildAndInstall()}. Default is
+   * true.
+   */
+  public AndroidRefWatcherBuilder watchActivities(boolean watchActivities) {
+    this.watchActivities = watchActivities;
+    return this;
+  }
+
+  /**
+   * Sets the maximum number of heap dumps stored. This overrides any call to {@link
+   * #heapDumper(HeapDumper)} as well as any call to
+   * {@link LeakCanary#setDisplayLeakActivityDirectoryProvider(LeakDirectoryProvider)})}
+   *
+   * @throws IllegalArgumentException if maxStoredHeapDumps < 1.
+   */
+  public AndroidRefWatcherBuilder maxStoredHeapDumps(int maxStoredHeapDumps) {
+    LeakDirectoryProvider leakDirectoryProvider =
+        new DefaultLeakDirectoryProvider(context, maxStoredHeapDumps);
+    LeakCanary.setDisplayLeakActivityDirectoryProvider(leakDirectoryProvider);
+    return heapDumper(new AndroidHeapDumper(context, leakDirectoryProvider));
+  }
+
+  /**
+   * Creates a {@link RefWatcher} instance and makes it available through {@link
+   * LeakCanary#installedRefWatcher()}.
+   *
+   * Also starts watching activity references if {@link #watchActivities(boolean)} was set to true.
+   *
+   * @throws UnsupportedOperationException if called more than once per Android process.
+   */
+  public RefWatcher buildAndInstall() {
+    if (LeakCanaryInternals.installedRefWatcher != null) {
+      throw new UnsupportedOperationException("buildAndInstall() should only be called once.");
+    }
+    RefWatcher refWatcher = build();
+    if (refWatcher != DISABLED) {
+      LeakCanary.enableDisplayLeakActivity(context);
+      if (watchActivities) {
+        ActivityRefWatcher.install((Application) context, refWatcher);
+      }
+    }
+    LeakCanaryInternals.installedRefWatcher = refWatcher;
+    return refWatcher;
+  }
+
+  @Override protected boolean isDisabled() {
+    return LeakCanary.isInAnalyzerProcess(context);
+  }
+
+  @Override protected HeapDumper defaultHeapDumper() {
+    LeakDirectoryProvider leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
+    return new AndroidHeapDumper(context, leakDirectoryProvider);
+  }
+
+  @Override protected DebuggerControl defaultDebuggerControl() {
+    return new AndroidDebuggerControl();
+  }
+
+  @Override protected HeapDump.Listener defaultHeapDumpListener() {
+    return new ServiceHeapDumpListener(context, DisplayLeakService.class);
+  }
+
+  @Override protected ExcludedRefs defaultExcludedRefs() {
+    return AndroidExcludedRefs.createAppDefaults().build();
+  }
+
+  @Override protected WatchExecutor defaultWatchExecutor() {
+    return new AndroidWatchExecutor(DEFAULT_WATCH_DELAY_MILLIS);
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
index 8f8eff4b..585af091 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
@@ -19,51 +19,68 @@
 import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.MessageQueue;
-import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+
+import static com.squareup.leakcanary.Retryable.Result.RETRY;
 
 /**
- * {@link Executor} suitable for watching Android reference leaks. This executor waits for the main
- * thread to be idle then posts to a serial background thread with a delay of
- * {@link R.integer#leak_canary_watch_delay_millis} seconds.
+ * {@link WatchExecutor} suitable for watching Android reference leaks. This executor waits for the
+ * main thread to be idle then posts to a serial background thread with the delay specified by
+ * {@link AndroidRefWatcherBuilder#watchDelay(long, TimeUnit)}.
  */
-public final class AndroidWatchExecutor implements Executor {
+public final class AndroidWatchExecutor implements WatchExecutor {
 
   static final String LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump";
   private final Handler mainHandler;
-  final Handler backgroundHandler;
-  final long delayMillis;
+  private final Handler backgroundHandler;
+  private final long initialDelayMillis;
+  private final long maxBackoffFactor;
 
-  public AndroidWatchExecutor(int delayMillis) {
+  public AndroidWatchExecutor(long initialDelayMillis) {
     mainHandler = new Handler(Looper.getMainLooper());
     HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);
     handlerThread.start();
     backgroundHandler = new Handler(handlerThread.getLooper());
-    this.delayMillis = delayMillis;
+    this.initialDelayMillis = initialDelayMillis;
+    maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;
   }
 
-  @Override public void execute(final Runnable command) {
-    if (isOnMainThread()) {
-      executeDelayedAfterIdleUnsafe(command);
+  @Override public void execute(Retryable retryable) {
+    if (Looper.getMainLooper().getThread() == Thread.currentThread()) {
+      waitForIdle(retryable, 0);
     } else {
-      mainHandler.post(new Runnable() {
-        @Override public void run() {
-          executeDelayedAfterIdleUnsafe(command);
-        }
-      });
+      postWaitForIdle(retryable, 0);
     }
   }
 
-  private boolean isOnMainThread() {
-    return Looper.getMainLooper().getThread() == Thread.currentThread();
+  void postWaitForIdle(final Retryable retryable, final int failedAttempts) {
+    mainHandler.post(new Runnable() {
+      @Override public void run() {
+        waitForIdle(retryable, failedAttempts);
+      }
+    });
   }
 
-  void executeDelayedAfterIdleUnsafe(final Runnable runnable) {
+  void waitForIdle(final Retryable retryable, final int failedAttempts) {
     // This needs to be called from the main thread.
     Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
       @Override public boolean queueIdle() {
-        backgroundHandler.postDelayed(runnable, delayMillis);
+        postToBackgroundWithDelay(retryable, failedAttempts);
         return false;
       }
     });
   }
+
+  void postToBackgroundWithDelay(final Retryable retryable, final int failedAttempts) {
+    long exponentialBackoffFactor = (long) Math.min(Math.pow(2, failedAttempts), maxBackoffFactor);
+    long delayMillis = initialDelayMillis * exponentialBackoffFactor;
+    backgroundHandler.postDelayed(new Runnable() {
+      @Override public void run() {
+        Retryable.Result result = retryable.run();
+        if (result == RETRY) {
+          postWaitForIdle(retryable, failedAttempts + 1);
+        }
+      }
+    }, delayMillis);
+  }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
index 988906e3..94957554 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
@@ -21,57 +21,191 @@
 import android.os.Environment;
 import com.squareup.leakcanary.internal.RequestStoragePermissionActivity;
 import java.io.File;
+import java.io.FilenameFilter;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.UUID;
 
 import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
 import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 import static android.os.Build.VERSION.SDK_INT;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Environment.DIRECTORY_DOWNLOADS;
+import static com.squareup.leakcanary.HeapDumper.RETRY_LATER;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.showNotification;
 
 public final class DefaultLeakDirectoryProvider implements LeakDirectoryProvider {
 
+  private static final int DEFAULT_MAX_STORED_HEAP_DUMPS = 7;
+
+  private static final String HPROF_SUFFIX = ".hprof";
+  private static final String PENDING_HEAPDUMP_SUFFIX = "_pending" + HPROF_SUFFIX;
+
+  /** 10 minutes */
+  private static final int ANALYSIS_MAX_DURATION_MS = 10 * 60 * 1000;
+
   private final Context context;
+  private final int maxStoredHeapDumps;
+
+  private volatile boolean writeExternalStorageGranted;
+  private volatile boolean permissionNotificationDisplayed;
 
   public DefaultLeakDirectoryProvider(Context context) {
+    this(context, DEFAULT_MAX_STORED_HEAP_DUMPS);
+  }
+
+  public DefaultLeakDirectoryProvider(Context context, int maxStoredHeapDumps) {
+    if (maxStoredHeapDumps < 1) {
+      throw new IllegalArgumentException("maxStoredHeapDumps must be at least 1");
+    }
     this.context = context.getApplicationContext();
+    this.maxStoredHeapDumps = maxStoredHeapDumps;
   }
 
-  @Override public File leakDirectory() {
-    File downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS);
-    File directory = new File(downloadsDirectory, "leakcanary-" + context.getPackageName());
-    boolean success = directory.mkdirs();
-    if (!success && !directory.exists()) {
-      throw new UnsupportedOperationException(
-          "Could not create leak directory " + directory.getPath());
+  @Override public List<File> listFiles(FilenameFilter filter) {
+    if (!hasStoragePermission()) {
+      requestWritePermissionNotification();
+    }
+    List<File> files = new ArrayList<>();
+
+    File[] externalFiles = externalStorageDirectory().listFiles(filter);
+    if (externalFiles != null) {
+      files.addAll(Arrays.asList(externalFiles));
+    }
+
+    File[] appFiles = appStorageDirectory().listFiles(filter);
+    if (appFiles != null) {
+      files.addAll(Arrays.asList(appFiles));
+    }
+    return files;
+  }
+
+  @Override public File newHeapDumpFile() {
+    List<File> pendingHeapDumps = listFiles(new FilenameFilter() {
+      @Override public boolean accept(File dir, String filename) {
+        return filename.endsWith(PENDING_HEAPDUMP_SUFFIX);
+      }
+    });
+
+    // If a new heap dump file has been created recently and hasn't been processed yet, we skip.
+    // Otherwise we move forward and assume that the analyzer process crashes. The file will
+    // eventually be removed with heap dump file rotation.
+    for (File file : pendingHeapDumps) {
+      if (System.currentTimeMillis() - file.lastModified() < ANALYSIS_MAX_DURATION_MS) {
+        CanaryLog.d("Could not dump heap, previous analysis still is in progress.");
+        return RETRY_LATER;
+      }
+    }
+
+    cleanupOldHeapDumps();
+
+    File storageDirectory = externalStorageDirectory();
+    if (!directoryWritableAfterMkdirs(storageDirectory)) {
+      if (!hasStoragePermission()) {
+        CanaryLog.d("WRITE_EXTERNAL_STORAGE permission not granted");
+        requestWritePermissionNotification();
+      } else {
+        String state = Environment.getExternalStorageState();
+        if (!Environment.MEDIA_MOUNTED.equals(state)) {
+          CanaryLog.d("External storage not mounted, state: %s", state);
+        } else {
+          CanaryLog.d("Could not create heap dump directory in external storage: [%s]",
+              storageDirectory.getAbsolutePath());
+        }
+      }
+      // Fallback to app storage.
+      storageDirectory = appStorageDirectory();
+      if (!directoryWritableAfterMkdirs(storageDirectory)) {
+        CanaryLog.d("Could not create heap dump directory in app storage: [%s]",
+            storageDirectory.getAbsolutePath());
+        return RETRY_LATER;
+      }
+    }
+    // If two processes from the same app get to this step at the same time, they could both
+    // create a heap dump. This is an edge case we ignore.
+    return new File(storageDirectory, UUID.randomUUID().toString() + PENDING_HEAPDUMP_SUFFIX);
+  }
+
+  @Override public void clearLeakDirectory() {
+    List<File> allFilesExceptPending = listFiles(new FilenameFilter() {
+      @Override public boolean accept(File dir, String filename) {
+        return !filename.endsWith(PENDING_HEAPDUMP_SUFFIX);
+      }
+    });
+    for (File file : allFilesExceptPending) {
+      boolean deleted = file.delete();
+      if (!deleted) {
+        CanaryLog.d("Could not delete file %s", file.getPath());
+      }
     }
-    return directory;
   }
 
-  @Override public void requestWritePermission() {
-    if (hasStoragePermission()) {
+  @TargetApi(M) private boolean hasStoragePermission() {
+    if (SDK_INT < M) {
+      return true;
+    }
+    // Once true, this won't change for the life of the process so we can cache it.
+    if (writeExternalStorageGranted) {
+      return true;
+    }
+    writeExternalStorageGranted =
+        context.checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED;
+    return writeExternalStorageGranted;
+  }
+
+  private void requestWritePermissionNotification() {
+    if (permissionNotificationDisplayed) {
       return;
     }
+    permissionNotificationDisplayed = true;
+
     PendingIntent pendingIntent = RequestStoragePermissionActivity.createPendingIntent(context);
     String contentTitle = context.getString(R.string.leak_canary_permission_notification_title);
     CharSequence packageName = context.getPackageName();
     String contentText =
         context.getString(R.string.leak_canary_permission_notification_text, packageName);
-    showNotification(context, contentTitle, contentText, pendingIntent);
+    showNotification(context, contentTitle, contentText, pendingIntent, 0xDEAFBEEF);
   }
 
-  @Override public boolean isLeakStorageWritable() {
-    if (!hasStoragePermission()) {
-      return false;
-    }
-    String state = Environment.getExternalStorageState();
-    return Environment.MEDIA_MOUNTED.equals(state);
+  private File externalStorageDirectory() {
+    File downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS);
+    return new File(downloadsDirectory, "leakcanary-" + context.getPackageName());
   }
 
-  @TargetApi(M) private boolean hasStoragePermission() {
-    if (SDK_INT < M) {
-      return true;
+  private File appStorageDirectory() {
+    File appFilesDirectory = context.getFilesDir();
+    return new File(appFilesDirectory, "leakcanary");
+  }
+
+  private boolean directoryWritableAfterMkdirs(File directory) {
+    boolean success = directory.mkdirs();
+    return (success || directory.exists()) && directory.canWrite();
+  }
+
+  private void cleanupOldHeapDumps() {
+    List<File> hprofFiles = listFiles(new FilenameFilter() {
+      @Override public boolean accept(File dir, String filename) {
+        return filename.endsWith(HPROF_SUFFIX);
+      }
+    });
+    int filesToRemove = hprofFiles.size() - maxStoredHeapDumps;
+    if (filesToRemove > 0) {
+      CanaryLog.d("Removing %d heap dumps", filesToRemove);
+      // Sort with oldest modified first.
+      Collections.sort(hprofFiles, new Comparator<File>() {
+        @Override public int compare(File lhs, File rhs) {
+          return Long.valueOf(lhs.lastModified()).compareTo(rhs.lastModified());
+        }
+      });
+      for (int i = 0; i < filesToRemove; i++) {
+        boolean deleted = hprofFiles.get(i).delete();
+        if (!deleted) {
+          CanaryLog.d("Could not delete old hprof file %s", hprofFiles.get(i).getPath());
+        }
+      }
     }
-    return context.checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED;
   }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
index afdc4e94..6bf9450a 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
@@ -16,16 +16,13 @@
 package com.squareup.leakcanary;
 
 import android.app.PendingIntent;
-import android.content.res.Resources;
+import android.os.SystemClock;
 import com.squareup.leakcanary.internal.DisplayLeakActivity;
 import java.io.File;
 import java.io.FileOutputStream;
-import java.io.FilenameFilter;
 import java.io.IOException;
 import java.io.ObjectOutputStream;
 import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Comparator;
 import java.util.Date;
 import java.util.Locale;
 
@@ -45,7 +42,7 @@
 
   @Override protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
     String leakInfo = leakInfo(this, heapDump, result, true);
-    CanaryLog.d(leakInfo);
+    CanaryLog.d("%s", leakInfo);
 
     boolean resultSaved = false;
     boolean shouldSaveResult = result.leakFound || result.failure != null;
@@ -82,7 +79,9 @@
       contentText = getString(R.string.leak_canary_could_not_save_text);
       pendingIntent = null;
     }
-    showNotification(this, contentTitle, contentText, pendingIntent);
+    // New notification id every second.
+    int notificationId = (int) (SystemClock.uptimeMillis() / 1000);
+    showNotification(this, contentTitle, contentText, pendingIntent, notificationId);
     afterDefaultHandling(heapDump, result, leakInfo);
   }
 
@@ -119,32 +118,9 @@ private HeapDump renameHeapdump(HeapDump heapDump) {
       CanaryLog.d("Could not rename heap dump file %s to %s", heapDump.heapDumpFile.getPath(),
           newFile.getPath());
     }
-    heapDump =
-        new HeapDump(newFile, heapDump.referenceKey, heapDump.referenceName, heapDump.excludedRefs,
-            heapDump.watchDurationMs, heapDump.gcDurationMs, heapDump.heapDumpDurationMs);
-
-    Resources resources = getResources();
-    int maxStoredHeapDumps =
-        Math.max(resources.getInteger(R.integer.leak_canary_max_stored_leaks), 1);
-    File[] hprofFiles = heapDump.heapDumpFile.getParentFile().listFiles(new FilenameFilter() {
-      @Override public boolean accept(File dir, String filename) {
-        return filename.endsWith(".hprof");
-      }
-    });
-
-    if (hprofFiles.length > maxStoredHeapDumps) {
-      // Sort with oldest modified first.
-      Arrays.sort(hprofFiles, new Comparator<File>() {
-        @Override public int compare(File lhs, File rhs) {
-          return Long.valueOf(lhs.lastModified()).compareTo(rhs.lastModified());
-        }
-      });
-      boolean deleted = hprofFiles[0].delete();
-      if (!deleted) {
-        CanaryLog.d("Could not delete old hprof file %s", hprofFiles[0].getPath());
-      }
-    }
-    return heapDump;
+    return new HeapDump(newFile, heapDump.referenceKey, heapDump.referenceName,
+        heapDump.excludedRefs, heapDump.watchDurationMs, heapDump.gcDurationMs,
+        heapDump.heapDumpDurationMs);
   }
 
   /**
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
index 39ffd8f3..1ae3abd6 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -19,13 +19,15 @@
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
-import android.content.res.Resources;
 import android.os.Build;
 import android.util.Log;
 import com.squareup.leakcanary.internal.DisplayLeakActivity;
 import com.squareup.leakcanary.internal.HeapAnalyzerService;
+import com.squareup.leakcanary.internal.LeakCanaryInternals;
 
 import static android.text.format.Formatter.formatShortFileSize;
+import static com.squareup.leakcanary.BuildConfig.GIT_SHA;
+import static com.squareup.leakcanary.BuildConfig.LIBRARY_VERSION;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.isInServiceProcess;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabled;
 
@@ -36,48 +38,35 @@
    * references (on ICS+).
    */
   public static RefWatcher install(Application application) {
-    return install(application, DisplayLeakService.class,
-        AndroidExcludedRefs.createAppDefaults().build());
+    return refWatcher(application).listenerServiceClass(DisplayLeakService.class)
+        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
+        .buildAndInstall();
   }
 
   /**
-   * Creates a {@link RefWatcher} that reports results to the provided service, and starts watching
-   * activity references (on ICS+).
+   * @return the {@link RefWatcher} installed via {@link AndroidRefWatcherBuilder#buildAndInstall()}.
    */
-  public static RefWatcher install(Application application,
-      Class<? extends AbstractAnalysisResultService> listenerServiceClass,
-      ExcludedRefs excludedRefs) {
-    if (isInAnalyzerProcess(application)) {
-      return RefWatcher.DISABLED;
+  public static RefWatcher installedRefWatcher() {
+    RefWatcher refWatcher = LeakCanaryInternals.installedRefWatcher;
+    if (refWatcher == null) {
+      throw new IllegalStateException("AndroidRefWatcherBuilder.buildAndInstall() was not called");
     }
-    enableDisplayLeakActivity(application);
-    HeapDump.Listener heapDumpListener =
-        new ServiceHeapDumpListener(application, listenerServiceClass);
-    RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);
-    ActivityRefWatcher.installOnIcsPlus(application, refWatcher);
     return refWatcher;
   }
 
-  /**
-   * Creates a {@link RefWatcher} with a default configuration suitable for Android.
-   */
-  public static RefWatcher androidWatcher(Context context, HeapDump.Listener heapDumpListener,
-      ExcludedRefs excludedRefs) {
-    LeakDirectoryProvider leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
-    DebuggerControl debuggerControl = new AndroidDebuggerControl();
-    AndroidHeapDumper heapDumper = new AndroidHeapDumper(context, leakDirectoryProvider);
-    heapDumper.cleanup();
-    Resources resources = context.getResources();
-    int watchDelayMillis = resources.getInteger(R.integer.leak_canary_watch_delay_millis);
-    AndroidWatchExecutor executor = new AndroidWatchExecutor(watchDelayMillis);
-    return new RefWatcher(executor, debuggerControl, GcTrigger.DEFAULT, heapDumper,
-        heapDumpListener, excludedRefs);
+  public static AndroidRefWatcherBuilder refWatcher(Context context) {
+    return new AndroidRefWatcherBuilder(context);
   }
 
   public static void enableDisplayLeakActivity(Context context) {
     setEnabled(context, DisplayLeakActivity.class, true);
   }
 
+  /**
+   * If you build a {@link RefWatcher} with a {@link AndroidHeapDumper} that has a custom {@link
+   * LeakDirectoryProvider}, then you should also call this method to make sure the activity in
+   * charge of displaying leaks can find those on the file system.
+   */
   public static void setDisplayLeakActivityDirectoryProvider(
       LeakDirectoryProvider leakDirectoryProvider) {
     DisplayLeakActivity.setLeakDirectoryProvider(leakDirectoryProvider);
@@ -100,7 +89,7 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
     String detailedString = "";
     if (result.leakFound) {
       if (result.excludedLeak) {
-        info += "* LEAK CAN BE IGNORED.\n";
+        info += "* EXCLUDED LEAK.\n";
       }
       info += "* " + result.className;
       if (!heapDump.referenceName.equals("")) {
@@ -112,7 +101,10 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
         detailedString = "\n* Details:\n" + result.leakTrace.toDetailedString();
       }
     } else if (result.failure != null) {
-      info += "* FAILURE:\n" + Log.getStackTraceString(result.failure) + "\n";
+      // We duplicate the library version & Sha information because bug reports often only contain
+      // the stacktrace.
+      info += "* FAILURE in " + LIBRARY_VERSION + " " + GIT_SHA + ":" + Log.getStackTraceString(
+          result.failure) + "\n";
     } else {
       info += "* NO LEAK FOUND.\n\n";
     }
@@ -137,9 +129,9 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
         + " API: "
         + Build.VERSION.SDK_INT
         + " LeakCanary: "
-        + BuildConfig.LIBRARY_VERSION
+        + LIBRARY_VERSION
         + " "
-        + BuildConfig.GIT_SHA
+        + GIT_SHA
         + "\n"
         + "* Durations: watch="
         + heapDump.watchDurationMs
@@ -161,7 +153,13 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
    * a different process than the normal app process.
    */
   public static boolean isInAnalyzerProcess(Context context) {
-    return isInServiceProcess(context, HeapAnalyzerService.class);
+    Boolean isInAnalyzerProcess = LeakCanaryInternals.isInAnalyzerProcess;
+    // This only needs to be computed once per process.
+    if (isInAnalyzerProcess == null) {
+      isInAnalyzerProcess = isInServiceProcess(context, HeapAnalyzerService.class);
+      LeakCanaryInternals.isInAnalyzerProcess = isInAnalyzerProcess;
+    }
+    return isInAnalyzerProcess;
   }
 
   private LeakCanary() {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
index 6c8cf056..1dfa218f 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
@@ -16,19 +16,27 @@
 package com.squareup.leakcanary;
 
 import java.io.File;
+import java.io.FilenameFilter;
+import java.util.List;
 
 /**
- * Provides the directory in which heap dumps and analysis results will be stored.
- * When using your own implementation, you may also want to call {@link
- * LeakCanary#setDisplayLeakActivityDirectoryProvider(LeakDirectoryProvider)}.
+ * Provides access to where heap dumps and analysis results will be stored.
+ * When using your own implementation, you should also call {@link
+ * LeakCanary#setDisplayLeakActivityDirectoryProvider(LeakDirectoryProvider)} to ensure the
+ * provided activity is able to display the leaks.
  */
 public interface LeakDirectoryProvider {
 
-  /** Returns a path to an existing directory were leaks can be stored. */
-  File leakDirectory();
+  List<File> listFiles(FilenameFilter filter);
 
-  void requestWritePermission();
+  /**
+   * @return {@link HeapDumper#RETRY_LATER} if a new heap dump file could not be created.
+   */
+  File newHeapDumpFile();
 
-  /** True if we can currently write to the leak directory. */
-  boolean isLeakStorageWritable();
+  /**
+   * Removes all heap dumps and analysis results, except for heap dumps that haven't been
+   * analyzed yet.
+   */
+  void clearLeakDirectory();
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
index 349b933f..cacbfe72 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
@@ -15,13 +15,15 @@
  */
 package com.squareup.leakcanary.internal;
 
-import android.annotation.TargetApi;
+import android.annotation.SuppressLint;
+import android.app.ActionBar;
 import android.app.Activity;
+import android.app.AlertDialog;
 import android.app.PendingIntent;
 import android.content.Context;
+import android.content.DialogInterface;
 import android.content.Intent;
 import android.net.Uri;
-import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.Looper;
@@ -56,21 +58,26 @@
 import java.util.concurrent.Executor;
 
 import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
+import static android.support.v4.content.FileProvider.getUriForFile;
 import static android.text.format.DateUtils.FORMAT_SHOW_DATE;
 import static android.text.format.DateUtils.FORMAT_SHOW_TIME;
 import static android.text.format.Formatter.formatShortFileSize;
 import static android.view.View.GONE;
 import static android.view.View.VISIBLE;
+import static com.squareup.leakcanary.BuildConfig.GIT_SHA;
+import static com.squareup.leakcanary.BuildConfig.LIBRARY_VERSION;
 import static com.squareup.leakcanary.LeakCanary.leakInfo;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.newSingleThreadExecutor;
 
-@SuppressWarnings("ConstantConditions") @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+@SuppressWarnings("ConstantConditions")
 public final class DisplayLeakActivity extends Activity {
 
   private static LeakDirectoryProvider leakDirectoryProvider = null;
 
   private static final String SHOW_LEAK_EXTRA = "show_latest";
 
+  // Public API.
+  @SuppressWarnings("unused")
   public static PendingIntent createPendingIntent(Context context) {
     return createPendingIntent(context, null);
   }
@@ -86,13 +93,12 @@ public static void setLeakDirectoryProvider(LeakDirectoryProvider leakDirectoryP
     DisplayLeakActivity.leakDirectoryProvider = leakDirectoryProvider;
   }
 
-  static File getLeakDirectory(Context context) {
+  private static LeakDirectoryProvider leakDirectoryProvider(Context context) {
     LeakDirectoryProvider leakDirectoryProvider = DisplayLeakActivity.leakDirectoryProvider;
-    if (leakDirectoryProvider != null) {
-      return leakDirectoryProvider.leakDirectory();
-    } else {
-      return new DefaultLeakDirectoryProvider(context).leakDirectory();
+    if (leakDirectoryProvider == null) {
+      leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
     }
+    return leakDirectoryProvider;
   }
 
   // null until it's been first loaded.
@@ -103,6 +109,7 @@ static File getLeakDirectory(Context context) {
   private TextView failureView;
   private Button actionButton;
 
+  @SuppressWarnings("unchecked")
   @Override protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
 
@@ -115,19 +122,17 @@ static File getLeakDirectory(Context context) {
       }
     }
 
-    //noinspection unchecked
     leaks = (List<Leak>) getLastNonConfigurationInstance();
 
     setContentView(R.layout.leak_canary_display_leak);
 
-    listView = (ListView) findViewById(R.id.__leak_canary_display_leak_list);
-    failureView = (TextView) findViewById(R.id.__leak_canary_display_leak_failure);
-    actionButton = (Button) findViewById(R.id.__leak_canary_action);
+    listView = findViewById(R.id.leak_canary_display_leak_list);
+    failureView = findViewById(R.id.leak_canary_display_leak_failure);
+    actionButton = findViewById(R.id.leak_canary_action);
 
     updateUi();
   }
 
-  // No, it's not deprecated. Android lies.
   @Override public Object onRetainNonConfigurationInstance() {
     return leaks;
   }
@@ -139,7 +144,7 @@ static File getLeakDirectory(Context context) {
 
   @Override protected void onResume() {
     super.onResume();
-    LoadLeaks.load(this);
+    LoadLeaks.load(this, leakDirectoryProvider(this));
   }
 
   @Override public void setTheme(int resid) {
@@ -207,16 +212,43 @@ void shareLeak() {
     startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
   }
 
+  @SuppressLint("SetWorldReadable")
   void shareHeapDump() {
     Leak visibleLeak = getVisibleLeak();
     File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
+    //noinspection ResultOfMethodCallIgnored
     heapDumpFile.setReadable(true, false);
     Intent intent = new Intent(Intent.ACTION_SEND);
     intent.setType("application/octet-stream");
-    intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(heapDumpFile));
+    Uri heapDumpUri = getUriForFile(getBaseContext(),
+        "com.squareup.leakcanary.fileprovider." + getApplication().getPackageName(), heapDumpFile);
+    intent.putExtra(Intent.EXTRA_STREAM, heapDumpUri);
     startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
   }
 
+  void deleteVisibleLeak() {
+    Leak visibleLeak = getVisibleLeak();
+    File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
+    File resultFile = visibleLeak.resultFile;
+    boolean resultDeleted = resultFile.delete();
+    if (!resultDeleted) {
+      CanaryLog.d("Could not delete result file %s", resultFile.getPath());
+    }
+    boolean heapDumpDeleted = heapDumpFile.delete();
+    if (!heapDumpDeleted) {
+      CanaryLog.d("Could not delete heap dump file %s", heapDumpFile.getPath());
+    }
+    visibleLeakRefKey = null;
+    leaks.remove(visibleLeak);
+    updateUi();
+  }
+
+  void deleteAllLeaks() {
+    leakDirectoryProvider(DisplayLeakActivity.this).clearLeakDirectory();
+    leaks = Collections.emptyList();
+    updateUi();
+  }
+
   void updateUi() {
     if (leaks == null) {
       setTitle("Loading leaks...");
@@ -241,14 +273,23 @@ void updateUi() {
       if (result.failure != null) {
         listView.setVisibility(GONE);
         failureView.setVisibility(VISIBLE);
-        failureView.setText(
-            getString(R.string.leak_canary_failure_report) + Log.getStackTraceString(
-                result.failure));
+        String failureMessage = getString(R.string.leak_canary_failure_report)
+            + LIBRARY_VERSION
+            + " "
+            + GIT_SHA
+            + "\n"
+            + Log.getStackTraceString(result.failure);
+        failureView.setText(failureMessage);
         setTitle(R.string.leak_canary_analysis_failed);
         invalidateOptionsMenu();
-        getActionBar().setDisplayHomeAsUpEnabled(true);
+        setDisplayHomeAsUpEnabled(true);
         actionButton.setVisibility(VISIBLE);
         actionButton.setText(R.string.leak_canary_delete);
+        actionButton.setOnClickListener(new View.OnClickListener() {
+          @Override public void onClick(View v) {
+            deleteVisibleLeak();
+          }
+        });
         listView.setAdapter(null);
       } else {
         final DisplayLeakAdapter adapter;
@@ -264,25 +305,12 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
             }
           });
           invalidateOptionsMenu();
-          getActionBar().setDisplayHomeAsUpEnabled(true);
+          setDisplayHomeAsUpEnabled(true);
           actionButton.setVisibility(VISIBLE);
           actionButton.setText(R.string.leak_canary_delete);
           actionButton.setOnClickListener(new View.OnClickListener() {
             @Override public void onClick(View v) {
-              Leak visibleLeak = getVisibleLeak();
-              File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
-              File resultFile = visibleLeak.resultFile;
-              boolean resultDeleted = resultFile.delete();
-              if (!resultDeleted) {
-                CanaryLog.d("Could not delete result file %s", resultFile.getPath());
-              }
-              boolean heapDumpDeleted = heapDumpFile.delete();
-              if (!heapDumpDeleted) {
-                CanaryLog.d("Could not delete heap dump file %s", heapDumpFile.getPath());
-              }
-              visibleLeakRefKey = null;
-              leaks.remove(visibleLeak);
-              updateUi();
+              deleteVisibleLeak();
             }
           });
         }
@@ -307,22 +335,21 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
         });
         invalidateOptionsMenu();
         setTitle(getString(R.string.leak_canary_leak_list_title, getPackageName()));
-        getActionBar().setDisplayHomeAsUpEnabled(false);
+        setDisplayHomeAsUpEnabled(false);
         actionButton.setText(R.string.leak_canary_delete_all);
         actionButton.setOnClickListener(new View.OnClickListener() {
           @Override public void onClick(View v) {
-            File leakDirectory = getLeakDirectory(DisplayLeakActivity.this);
-            File[] files = leakDirectory.listFiles();
-            if (files != null) {
-              for (File file : files) {
-                boolean deleted = file.delete();
-                if (!deleted) {
-                  CanaryLog.d("Could not delete file %s", file.getPath());
-                }
-              }
-            }
-            leaks = Collections.emptyList();
-            updateUi();
+            new AlertDialog.Builder(DisplayLeakActivity.this).setIcon(
+                android.R.drawable.ic_dialog_alert)
+                .setTitle(R.string.leak_canary_delete_all)
+                .setMessage(R.string.leak_canary_delete_all_leaks_title)
+                .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
+                  @Override public void onClick(DialogInterface dialog, int which) {
+                    deleteAllLeaks();
+                  }
+                })
+                .setNegativeButton(android.R.string.cancel, null)
+                .show();
           }
         });
       }
@@ -330,6 +357,15 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
     }
   }
 
+  private void setDisplayHomeAsUpEnabled(boolean enabled) {
+    ActionBar actionBar = getActionBar();
+    if (actionBar == null) {
+      // https://github.com/square/leakcanary/issues/967
+      return;
+    }
+    actionBar.setDisplayHomeAsUpEnabled(enabled);
+  }
+
   Leak getVisibleLeak() {
     if (leaks == null) {
       return null;
@@ -361,8 +397,8 @@ Leak getVisibleLeak() {
         convertView = LayoutInflater.from(DisplayLeakActivity.this)
             .inflate(R.layout.leak_canary_leak_row, parent, false);
       }
-      TextView titleView = (TextView) convertView.findViewById(R.id.__leak_canary_row_text);
-      TextView timeView = (TextView) convertView.findViewById(R.id.__leak_canary_row_time);
+      TextView titleView = convertView.findViewById(R.id.leak_canary_row_text);
+      TextView timeView = convertView.findViewById(R.id.leak_canary_row_time);
       Leak leak = getItem(position);
 
       String index = (leaks.size() - position) + ". ";
@@ -409,8 +445,8 @@ Leak getVisibleLeak() {
 
     static final Executor backgroundExecutor = newSingleThreadExecutor("LoadLeaks");
 
-    static void load(DisplayLeakActivity activity) {
-      LoadLeaks loadLeaks = new LoadLeaks(activity);
+    static void load(DisplayLeakActivity activity, LeakDirectoryProvider leakDirectoryProvider) {
+      LoadLeaks loadLeaks = new LoadLeaks(activity, leakDirectoryProvider);
       inFlight.add(loadLeaks);
       backgroundExecutor.execute(loadLeaks);
     }
@@ -423,58 +459,55 @@ static void forgetActivity() {
     }
 
     DisplayLeakActivity activityOrNull;
-    private final File leakDirectory;
+    private final LeakDirectoryProvider leakDirectoryProvider;
     private final Handler mainHandler;
 
-    LoadLeaks(DisplayLeakActivity activity) {
+    LoadLeaks(DisplayLeakActivity activity, LeakDirectoryProvider leakDirectoryProvider) {
       this.activityOrNull = activity;
-      leakDirectory = getLeakDirectory(activity);
+      this.leakDirectoryProvider = leakDirectoryProvider;
       mainHandler = new Handler(Looper.getMainLooper());
     }
 
     @Override public void run() {
       final List<Leak> leaks = new ArrayList<>();
-      File[] files = leakDirectory.listFiles(new FilenameFilter() {
+      List<File> files = leakDirectoryProvider.listFiles(new FilenameFilter() {
         @Override public boolean accept(File dir, String filename) {
           return filename.endsWith(".result");
         }
       });
-
-      if (files != null) {
-        for (File resultFile : files) {
-          FileInputStream fis = null;
-          try {
-            fis = new FileInputStream(resultFile);
-            ObjectInputStream ois = new ObjectInputStream(fis);
-            HeapDump heapDump = (HeapDump) ois.readObject();
-            AnalysisResult result = (AnalysisResult) ois.readObject();
-            leaks.add(new Leak(heapDump, result, resultFile));
-          } catch (IOException | ClassNotFoundException e) {
-            // Likely a change in the serializable result class.
-            // Let's remove the files, we can't read them anymore.
-            boolean deleted = resultFile.delete();
-            if (deleted) {
-              CanaryLog.d(e, "Could not read result file %s, deleted it.", resultFile);
-            } else {
-              CanaryLog.d(e, "Could not read result file %s, could not delete it either.",
-                  resultFile);
-            }
-          } finally {
-            if (fis != null) {
-              try {
-                fis.close();
-              } catch (IOException ignored) {
-              }
+      for (File resultFile : files) {
+        FileInputStream fis = null;
+        try {
+          fis = new FileInputStream(resultFile);
+          ObjectInputStream ois = new ObjectInputStream(fis);
+          HeapDump heapDump = (HeapDump) ois.readObject();
+          AnalysisResult result = (AnalysisResult) ois.readObject();
+          leaks.add(new Leak(heapDump, result, resultFile));
+        } catch (IOException | ClassNotFoundException e) {
+          // Likely a change in the serializable result class.
+          // Let's remove the files, we can't read them anymore.
+          boolean deleted = resultFile.delete();
+          if (deleted) {
+            CanaryLog.d(e, "Could not read result file %s, deleted it.", resultFile);
+          } else {
+            CanaryLog.d(e, "Could not read result file %s, could not delete it either.",
+                resultFile);
+          }
+        } finally {
+          if (fis != null) {
+            try {
+              fis.close();
+            } catch (IOException ignored) {
             }
           }
         }
-        Collections.sort(leaks, new Comparator<Leak>() {
-          @Override public int compare(Leak lhs, Leak rhs) {
-            return Long.valueOf(rhs.resultFile.lastModified())
-                .compareTo(lhs.resultFile.lastModified());
-          }
-        });
       }
+      Collections.sort(leaks, new Comparator<Leak>() {
+        @Override public int compare(Leak lhs, Leak rhs) {
+          return Long.valueOf(rhs.resultFile.lastModified())
+              .compareTo(lhs.resultFile.lastModified());
+        }
+      });
       mainHandler.post(new Runnable() {
         @Override public void run() {
           inFlight.remove(LoadLeaks.this);
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
index cb16c7fe..4e71b4f1 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
@@ -22,6 +22,7 @@
 import android.view.ViewGroup;
 import android.widget.BaseAdapter;
 import android.widget.TextView;
+import com.squareup.leakcanary.Exclusion;
 import com.squareup.leakcanary.LeakTrace;
 import com.squareup.leakcanary.LeakTraceElement;
 import com.squareup.leakcanary.R;
@@ -51,14 +52,14 @@
         convertView =
             LayoutInflater.from(context).inflate(R.layout.leak_canary_ref_top_row, parent, false);
       }
-      TextView textView = findById(convertView, R.id.__leak_canary_row_text);
+      TextView textView = findById(convertView, R.id.leak_canary_row_text);
       textView.setText(context.getPackageName());
     } else {
       if (convertView == null) {
         convertView =
             LayoutInflater.from(context).inflate(R.layout.leak_canary_ref_row, parent, false);
       }
-      TextView textView = findById(convertView, R.id.__leak_canary_row_text);
+      TextView textView = findById(convertView, R.id.leak_canary_row_text);
 
       boolean isRoot = position == 1;
       boolean isLeakingInstance = position == getCount() - 1;
@@ -69,7 +70,7 @@
       }
       textView.setText(Html.fromHtml(htmlString));
 
-      DisplayLeakConnectorView connector = findById(convertView, R.id.__leak_canary_row_connector);
+      DisplayLeakConnectorView connector = findById(convertView, R.id.leak_canary_row_connector);
       if (isRoot) {
         connector.setType(DisplayLeakConnectorView.Type.START);
       } else {
@@ -79,7 +80,7 @@
           connector.setType(DisplayLeakConnectorView.Type.NODE);
         }
       }
-      MoreDetailsView moreDetailsView = findById(convertView, R.id.__leak_canary_row_more);
+      MoreDetailsView moreDetailsView = findById(convertView, R.id.leak_canary_row_more);
       moreDetailsView.setOpened(opened[position]);
     }
 
@@ -132,6 +133,23 @@ private String elementToHtmlString(LeakTraceElement element, boolean root, boole
     if (opened && element.extra != null) {
       htmlString += " <font color='#919191'>" + element.extra + "</font>";
     }
+
+    Exclusion exclusion = element.exclusion;
+    if (exclusion != null) {
+      if (opened) {
+        htmlString += "<br/><br/>Excluded by rule";
+        if (exclusion.name != null) {
+          htmlString += " <font color='#ffffff'>" + exclusion.name + "</font>";
+        }
+        htmlString += " matching <font color='#f3cf83'>" + exclusion.matching + "</font>";
+        if (exclusion.reason != null) {
+          htmlString += " because <font color='#f3cf83'>" + exclusion.reason + "</font>";
+        }
+      } else {
+        htmlString += " (excluded)";
+      }
+    }
+
     return htmlString;
   }
 
@@ -178,7 +196,8 @@ public void toggleRow(int position) {
     return position;
   }
 
-  @SuppressWarnings("unchecked") private static <T extends View> T findById(View view, int id) {
+  @SuppressWarnings({ "unchecked", "TypeParameterUnusedInFormals" })
+  private static <T extends View> T findById(View view, int id) {
     return (T) view.findViewById(id);
   }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
index b334079f..8308376d 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
@@ -18,6 +18,7 @@
 import android.annotation.TargetApi;
 import android.app.ActivityManager;
 import android.app.Notification;
+import android.app.NotificationChannel;
 import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.app.Service;
@@ -28,7 +29,8 @@
 import android.content.pm.ServiceInfo;
 import com.squareup.leakcanary.CanaryLog;
 import com.squareup.leakcanary.R;
-import java.lang.reflect.Method;
+import com.squareup.leakcanary.RefWatcher;
+import java.util.List;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 
@@ -37,19 +39,26 @@
 import static android.content.pm.PackageManager.DONT_KILL_APP;
 import static android.content.pm.PackageManager.GET_SERVICES;
 import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.HONEYCOMB;
 import static android.os.Build.VERSION_CODES.JELLY_BEAN;
+import static android.os.Build.VERSION_CODES.O;
 
 public final class LeakCanaryInternals {
 
-  // SDK INT for API 22.
-  public static final int LOLLIPOP_MR1 = 22;
   public static final String SAMSUNG = "samsung";
   public static final String MOTOROLA = "motorola";
+  public static final String LENOVO = "LENOVO";
   public static final String LG = "LGE";
   public static final String NVIDIA = "NVIDIA";
+  public static final String MEIZU = "Meizu";
+  public static final String HUAWEI = "HUAWEI";
+  public static final String VIVO = "vivo";
 
   private static final Executor fileIoExecutor = newSingleThreadExecutor("File-IO");
+  public static volatile RefWatcher installedRefWatcher;
+
+  private static final String NOTIFICATION_CHANNEL_ID = "leakcanary";
+
+  public static volatile Boolean isInAnalyzerProcess;
 
   public static void executeOnFileIoThread(Runnable runnable) {
     fileIoExecutor.execute(runnable);
@@ -114,10 +123,20 @@ public static boolean isInServiceProcess(Context context, Class<? extends Servic
     ActivityManager activityManager =
         (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
     ActivityManager.RunningAppProcessInfo myProcess = null;
-    for (ActivityManager.RunningAppProcessInfo process : activityManager.getRunningAppProcesses()) {
-      if (process.pid == myPid) {
-        myProcess = process;
-        break;
+    List<ActivityManager.RunningAppProcessInfo> runningProcesses;
+    try {
+      runningProcesses = activityManager.getRunningAppProcesses();
+    } catch (SecurityException exception) {
+      // https://github.com/square/leakcanary/issues/948
+      CanaryLog.d("Could not get running app processes %d", exception);
+      return false;
+    }
+    if (runningProcesses != null) {
+      for (ActivityManager.RunningAppProcessInfo process : runningProcesses) {
+        if (process.pid == myPid) {
+          myProcess = process;
+          break;
+        }
       }
     }
     if (myProcess == null) {
@@ -128,41 +147,41 @@ public static boolean isInServiceProcess(Context context, Class<? extends Servic
     return myProcess.processName.equals(serviceInfo.processName);
   }
 
-  @TargetApi(HONEYCOMB)
   public static void showNotification(Context context, CharSequence contentTitle,
-      CharSequence contentText, PendingIntent pendingIntent) {
+      CharSequence contentText, PendingIntent pendingIntent, int notificationId) {
     NotificationManager notificationManager =
         (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
 
     Notification notification;
-    if (SDK_INT < HONEYCOMB) {
-      notification = new Notification();
-      notification.icon = R.drawable.leak_canary_notification;
-      notification.when = System.currentTimeMillis();
-      notification.flags |= Notification.FLAG_AUTO_CANCEL;
-      try {
-        Method method =
-            Notification.class.getMethod("setLatestEventInfo", Context.class, CharSequence.class,
-                CharSequence.class, PendingIntent.class);
-        method.invoke(notification, context, contentTitle, contentText, pendingIntent);
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
+    Notification.Builder builder = new Notification.Builder(context) //
+        .setSmallIcon(R.drawable.leak_canary_notification)
+        .setWhen(System.currentTimeMillis())
+        .setContentTitle(contentTitle)
+        .setContentText(contentText)
+        .setAutoCancel(true)
+        .setContentIntent(pendingIntent);
+    if (SDK_INT >= O) {
+      String channelName = context.getString(R.string.leak_canary_notification_channel);
+      setupNotificationChannel(channelName, notificationManager, builder);
+    }
+    if (SDK_INT < JELLY_BEAN) {
+      notification = builder.getNotification();
     } else {
-      Notification.Builder builder = new Notification.Builder(context) //
-          .setSmallIcon(R.drawable.leak_canary_notification)
-          .setWhen(System.currentTimeMillis())
-          .setContentTitle(contentTitle)
-          .setContentText(contentText)
-          .setAutoCancel(true)
-          .setContentIntent(pendingIntent);
-      if (SDK_INT < JELLY_BEAN) {
-        notification = builder.getNotification();
-      } else {
-        notification = builder.build();
-      }
+      notification = builder.build();
+    }
+    notificationManager.notify(notificationId, notification);
+  }
+
+  @TargetApi(O)
+  private static void setupNotificationChannel(String channelName,
+      NotificationManager notificationManager, Notification.Builder builder) {
+    if (notificationManager.getNotificationChannel(NOTIFICATION_CHANNEL_ID) == null) {
+      NotificationChannel notificationChannel =
+          new NotificationChannel(NOTIFICATION_CHANNEL_ID, channelName,
+              NotificationManager.IMPORTANCE_DEFAULT);
+      notificationManager.createNotificationChannel(notificationChannel);
     }
-    notificationManager.notify(0xDEAFBEEF, notification);
+    builder.setChannelId(NOTIFICATION_CHANNEL_ID);
   }
 
   public static Executor newSingleThreadExecutor(String threadName) {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java
index 2d941302..1146ac21 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java
@@ -20,6 +20,9 @@
 import android.app.PendingIntent;
 import android.content.Context;
 import android.content.Intent;
+import android.os.Bundle;
+import android.widget.Toast;
+import com.squareup.leakcanary.R;
 
 import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
 import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
@@ -27,6 +30,7 @@
 import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
 import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 import static android.os.Build.VERSION_CODES.M;
+import static android.widget.Toast.LENGTH_LONG;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabledBlocking;
 
 @TargetApi(M) //
@@ -39,18 +43,37 @@ public static PendingIntent createPendingIntent(Context context) {
     return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);
   }
 
-  @Override protected void onResume() {
-    super.onResume();
-    // This won't work well if the user doesn't enable the permission.
-    // Seems ok for a dev tool, especially since you have to click a notification
-    // to get here.
-    if (checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED) {
-      finish();
-    } else {
+  @Override protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+
+    if (savedInstanceState == null) {
+      if (hasStoragePermission()) {
+        finish();
+        return;
+      }
       String[] permissions = {
           WRITE_EXTERNAL_STORAGE
       };
       requestPermissions(permissions, 42);
     }
   }
+
+  @Override public void onRequestPermissionsResult(int requestCode, String[] permissions,
+      int[] grantResults) {
+    if (!hasStoragePermission()) {
+      Toast.makeText(getApplication(), R.string.leak_canary_permission_not_granted, LENGTH_LONG)
+          .show();
+    }
+    finish();
+  }
+
+  @Override public void finish() {
+    // Reset the animation to avoid flickering.
+    overridePendingTransition(0, 0);
+    super.finish();
+  }
+
+  private boolean hasStoragePermission() {
+    return checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED;
+  }
 }
diff --git a/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png
deleted file mode 100755
index f1049229..00000000
Binary files a/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png
deleted file mode 100755
index 7e375c54..00000000
Binary files a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png
index 09c78cc0..13b33116 100755
Binary files a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png
deleted file mode 100755
index d29b9f1d..00000000
Binary files a/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png
deleted file mode 100755
index f354c3f2..00000000
Binary files a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png
index c825fa4a..dc92783b 100755
Binary files a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png
deleted file mode 100755
index d0cdbcd8..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png
deleted file mode 100755
index a5e85b41..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png
index b2978d57..1e1b977f 100755
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png
deleted file mode 100755
index 0194b4e1..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png
deleted file mode 100755
index 3d4b76af..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png
index 22db2020..c652efdd 100755
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png
deleted file mode 100755
index 05141619..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png
deleted file mode 100755
index eb9c0724..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png
index 34b76141..bb458f2c 100755
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable/leak_canary_icon_foreground.xml b/leakcanary-android/src/main/res/drawable/leak_canary_icon_foreground.xml
new file mode 100644
index 00000000..07b6f09c
--- /dev/null
+++ b/leakcanary-android/src/main/res/drawable/leak_canary_icon_foreground.xml
@@ -0,0 +1,19 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+        android:width="108dp"
+        android:height="108dp"
+        android:viewportWidth="108.0"
+        android:viewportHeight="108.0">
+    <path
+        android:pathData="M108,72.77L75.27,37.54C75.27,37.54 75.36,46.84 75.27,50.38C75.97,68.02 62.84,77.92 54.23,80C51.3,79.28 47.86,77.67 44.62,75.16C44.62,75.16 54.84,86.1 75.27,108L108,108L108,72.77Z"
+        android:strokeColor="#00000000"
+        android:fillType="evenOdd"
+        android:fillAlpha="0.02"
+        android:fillColor="#000000"
+        android:strokeWidth="1"/>
+    <path
+        android:pathData="M33.01,37.54L54.23,28L75.27,37.54C75.27,37.54 75.36,46.84 75.27,50.38C75.97,68.02 62.84,77.92 54.23,80C45.62,77.9 32.65,68.05 33.01,50.38C33.09,46.2 33.01,37.54 33.01,37.54ZM42.36,66.8C42.36,66.8 43.76,64.63 46.14,63.54C46.8,62.76 47.24,61.63 48.35,60.54C48.97,59.94 50.02,59.21 51,58.84C51.99,58.46 53.16,58.27 54.25,58.3C55.35,58.32 56.21,58.49 57.57,58.98C61,60.25 65.15,65.58 66.01,67.88C63.18,69.64 60.5,71.59 57.57,75.08C56.96,74.81 55.42,74.26 52.9,74.55C49.84,75.19 46.9,70.85 47.04,68.48C45.24,67.81 42.36,66.8 42.36,66.8ZM51.95,65.31C51.46,65.31 51.15,65.06 51.09,64.82C51.03,64.59 51.38,64.03 51.58,63.92C52.62,63.38 53.79,63.46 53.79,63.46C53.79,63.46 54.15,65.33 51.95,65.31ZM51.86,48.89L56.53,48.89L56.53,53.75L51.86,53.75L51.86,48.89ZM51.86,36.18L56.53,36.18L56.53,46.52L51.86,46.52L51.86,36.18Z"
+        android:strokeColor="#00000000"
+        android:fillType="evenOdd"
+        android:fillColor="#FDED00"
+        android:strokeWidth="1"/>
+</vector>
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml b/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
index d9d312e0..8e56c3d1 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
@@ -21,7 +21,7 @@
     android:background="#3c3c3c"
     >
   <ListView
-      android:id="@+id/__leak_canary_display_leak_list"
+      android:id="@+id/leak_canary_display_leak_list"
       android:layout_width="match_parent"
       android:layout_height="0dp"
       android:layout_weight="1"
@@ -29,7 +29,7 @@
       android:divider="@null"
       />
   <TextView
-      android:id="@+id/__leak_canary_display_leak_failure"
+      android:id="@+id/leak_canary_display_leak_failure"
       android:layout_width="match_parent"
       android:layout_height="0dp"
       android:layout_weight="1"
@@ -37,7 +37,7 @@
       android:visibility="gone"
       />
   <Button
-      android:id="@+id/__leak_canary_action"
+      android:id="@+id/leak_canary_action"
       android:layout_width="match_parent"
       android:layout_height="wrap_content"
       android:visibility="gone"
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml b/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml
index d6057ed2..14a2c648 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml
@@ -25,7 +25,7 @@
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
       android:layout_gravity="center_horizontal"
-      android:src="@drawable/leak_canary_icon"/>
+      android:src="@mipmap/leak_canary_icon"/>
 
   <TextView
       android:layout_width="wrap_content"
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml b/leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml
index 00e291b4..c5c5ac7f 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml
@@ -23,7 +23,7 @@
     >
 
   <TextView
-      android:id="@+id/__leak_canary_row_text"
+      android:id="@+id/leak_canary_row_text"
       android:layout_width="0dp"
       android:layout_weight="1"
       android:layout_height="wrap_content"
@@ -32,7 +32,7 @@
       />
 
   <TextView
-      android:id="@+id/__leak_canary_row_time"
+      android:id="@+id/leak_canary_row_time"
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
       android:layout_gravity="center_vertical"
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml b/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
index e5c125e4..947af46c 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
@@ -22,7 +22,7 @@
     >
 
   <com.squareup.leakcanary.internal.DisplayLeakConnectorView
-      android:id="@+id/__leak_canary_row_connector"
+      android:id="@+id/leak_canary_row_connector"
       android:layout_width="16dp"
       android:layout_height="match_parent"
       android:layout_marginStart="16dp"
@@ -30,7 +30,7 @@
       />
 
   <TextView
-      android:id="@+id/__leak_canary_row_text"
+      android:id="@+id/leak_canary_row_text"
       android:layout_width="0dp"
       android:layout_weight="1"
       android:layout_height="wrap_content"
@@ -38,7 +38,7 @@
       />
 
   <com.squareup.leakcanary.internal.MoreDetailsView
-      android:id="@+id/__leak_canary_row_more"
+      android:id="@+id/leak_canary_row_more"
       android:layout_width="12dp"
       android:layout_height="12dp"
       android:layout_gravity="center_vertical"
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml b/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
index 4fc704b5..c4803b76 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
@@ -16,7 +16,7 @@
   -->
 <TextView
     xmlns:android="http://schemas.android.com/apk/res/android"
-    android:id="@+id/__leak_canary_row_text"
+    android:id="@+id/leak_canary_row_text"
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
     android:layout_margin="16dp"
diff --git a/leakcanary-android/src/main/res/mipmap-anydpi-v26/leak_canary_icon.xml b/leakcanary-android/src/main/res/mipmap-anydpi-v26/leak_canary_icon.xml
new file mode 100644
index 00000000..c58c886c
--- /dev/null
+++ b/leakcanary-android/src/main/res/mipmap-anydpi-v26/leak_canary_icon.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
+  <background android:drawable="@color/leak_canary_icon_background"/>
+  <foreground android:drawable="@drawable/leak_canary_icon_foreground"/>
+</adaptive-icon>
diff --git a/leakcanary-android/src/main/res/mipmap-hdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/mipmap-hdpi/leak_canary_icon.png
new file mode 100644
index 00000000..b1a69510
Binary files /dev/null and b/leakcanary-android/src/main/res/mipmap-hdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/mipmap-mdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/mipmap-mdpi/leak_canary_icon.png
new file mode 100644
index 00000000..304c0d3d
Binary files /dev/null and b/leakcanary-android/src/main/res/mipmap-mdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/mipmap-xhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/mipmap-xhdpi/leak_canary_icon.png
new file mode 100644
index 00000000..b79b532b
Binary files /dev/null and b/leakcanary-android/src/main/res/mipmap-xhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/mipmap-xxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/mipmap-xxhdpi/leak_canary_icon.png
new file mode 100644
index 00000000..950797ed
Binary files /dev/null and b/leakcanary-android/src/main/res/mipmap-xxhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/mipmap-xxxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/mipmap-xxxhdpi/leak_canary_icon.png
new file mode 100644
index 00000000..f0655aac
Binary files /dev/null and b/leakcanary-android/src/main/res/mipmap-xxxhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
new file mode 100644
index 00000000..2c784aec
--- /dev/null
+++ b/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+    <string name="leak_canary_class_has_leaked">%1$s hat %2$s geleaked</string>
+    <string name="leak_canary_leak_excluded">[Ausgeschlossen] %1$s hat %2$s geleaked</string>
+    <string name="leak_canary_analysis_failed">Leak Analyse fehlgeschlagen</string>
+    <string name="leak_canary_leak_list_title">Leaks in %s</string>
+    <string name="leak_canary_notification_message">Für mehr Details hier klicken</string>
+    <string name="leak_canary_notification_channel">LeakCanary</string>
+    <string name="leak_canary_share_leak">Info teilen</string>
+    <string name="leak_canary_share_heap_dump">Heap Dump teilen</string>
+    <string name="leak_canary_share_with">Teilen mit…</string>
+    <string name="leak_canary_display_activity_label">Leaks</string>
+    <string name="leak_canary_storage_permission_activity_label">Storage Berechtigung</string>
+    <string name="leak_canary_toast_heap_dump">Sichere den Speicher, die App wird einfrieren. Brrr.</string>
+    <string name="leak_canary_delete">Löschen</string>
+    <string name="leak_canary_failure_report">"Bitte sende diesen Fehler an http://github.com/square/leakcanary\n"</string>
+    <string name="leak_canary_delete_all">Alle löschen</string>
+    <string name="leak_canary_delete_all_leaks_title">Bist du dir sicher, dass du alle Leaks löschen möchtest?</string>
+    <string name="leak_canary_could_not_save_title">Konnte Ergebnis nicht speichern.</string>
+    <string name="leak_canary_could_not_save_text">LeakCanary konnte das Ergebnis der Analyse nicht speichern.</string>
+    <string name="leak_canary_no_leak_title">Kein Leak gefunden</string>
+    <string name="leak_canary_no_leak_text">Der GC war untätig.</string>
+    <string name="leak_canary_excluded_row">[Ausgeschlossen] %s</string>
+    <string name="leak_canary_permission_not_granted">Bitte gewähre die Storage Berechtigung, andernfalls werden Memory Leaks nicht erkannt.</string>
+    <string name="leak_canary_permission_notification_title">Leak erkannt, benötige Berechtigung</string>
+    <string name="leak_canary_permission_notification_text">Hier klicken, um Storage Berechtigung für %s zu aktivieren.</string>
+</resources>
diff --git a/leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml b/leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml
deleted file mode 100644
index 409cb66b..00000000
--- a/leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<resources>
-  <style name="leak_canary_LeakCanary.Base" parent="android:Theme.Holo">
-  </style>
-</resources>
\ No newline at end of file
diff --git a/leakcanary-android/src/main/res/values/leak_canary_icon_background.xml b/leakcanary-android/src/main/res/values/leak_canary_icon_background.xml
new file mode 100644
index 00000000..833b79dc
--- /dev/null
+++ b/leakcanary-android/src/main/res/values/leak_canary_icon_background.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <color name="leak_canary_icon_background">#3C3C3C</color>
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_int.xml b/leakcanary-android/src/main/res/values/leak_canary_int.xml
deleted file mode 100644
index b7197372..00000000
--- a/leakcanary-android/src/main/res/values/leak_canary_int.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<resources>
-  <integer name="leak_canary_max_stored_leaks">7</integer>
-  <integer name="leak_canary_watch_delay_millis">5000</integer>
-</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_public.xml b/leakcanary-android/src/main/res/values/leak_canary_public.xml
index b5f11b97..165c1738 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_public.xml
+++ b/leakcanary-android/src/main/res/values/leak_canary_public.xml
@@ -18,8 +18,6 @@
 
   <public name="leak_canary_display_activity_label" type="string"/>
   <public name="leak_canary_heap_dump_toast" type="layout"/>
-  <public name="leak_canary_icon" type="drawable"/>
-  <public name="leak_canary_max_stored_leaks" type="integer"/>
-  <public name="leak_canary_watch_delay_millis" type="integer"/>
+  <public name="leak_canary_icon" type="mipmap"/>
 
 </resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_strings.xml b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
index 458c1f4b..faef413c 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_strings.xml
+++ b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
@@ -15,11 +15,12 @@
   ~ limitations under the License.
   -->
 <resources>
-  <string name="leak_canary_class_has_leaked">%1$s has leaked %2$s</string>
-  <string name="leak_canary_leak_excluded">%1$s has leaked %2$s (excluded leak)</string>
+  <string name="leak_canary_class_has_leaked">%1$s leaked %2$s</string>
+  <string name="leak_canary_leak_excluded">[Excluded] %1$s leaked %2$s</string>
   <string name="leak_canary_analysis_failed">Leak analysis failed</string>
   <string name="leak_canary_leak_list_title">Leaks in %s</string>
   <string name="leak_canary_notification_message">Click for more details</string>
+  <string name="leak_canary_notification_channel">LeakCanary</string>
   <string name="leak_canary_share_leak">Share info</string>
   <string name="leak_canary_share_heap_dump">Share heap dump</string>
   <string name="leak_canary_share_with">Share with…</string>
@@ -29,11 +30,13 @@
   <string name="leak_canary_delete">Delete</string>
   <string name="leak_canary_failure_report">"Please report this failure to http://github.com/square/leakcanary\n"</string>
   <string name="leak_canary_delete_all">Delete all</string>
+  <string name="leak_canary_delete_all_leaks_title">Are you sure you want to delete all leaks?</string>
   <string name="leak_canary_could_not_save_title">Could not save result.</string>
   <string name="leak_canary_could_not_save_text">LeakCanary was unable to save the analysis result.</string>
   <string name="leak_canary_no_leak_title">No leak found</string>
   <string name="leak_canary_no_leak_text">The GC was being lazy.</string>
   <string name="leak_canary_excluded_row">[Excluded] %s</string>
+  <string name="leak_canary_permission_not_granted">Please grant external storage permission, otherwise memory leaks will not be detected.</string>
   <string name="leak_canary_permission_notification_title">Leak detected, need permission</string>
   <string name="leak_canary_permission_notification_text">Click to enable storage permission for %s.</string>
 </resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_themes.xml b/leakcanary-android/src/main/res/values/leak_canary_themes.xml
index eebd0333..2ca041d4 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_themes.xml
+++ b/leakcanary-android/src/main/res/values/leak_canary_themes.xml
@@ -15,7 +15,7 @@
   ~ limitations under the License.
   -->
 <resources>
-  <style name="leak_canary_LeakCanary.Base" parent="android:Theme">
+  <style name="leak_canary_LeakCanary.Base" parent="android:Theme.Holo">
   </style>
 
   <style name="leak_canary_Theme.Transparent" parent="android:Theme">
diff --git a/leakcanary-android/src/main/res/xml/leak_canary_file_paths.xml b/leakcanary-android/src/main/res/xml/leak_canary_file_paths.xml
new file mode 100644
index 00000000..8fa00f15
--- /dev/null
+++ b/leakcanary-android/src/main/res/xml/leak_canary_file_paths.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<paths>
+  <external-path name="downloads" path="Download/" />
+</paths>
diff --git a/leakcanary-sample/build.gradle b/leakcanary-sample/build.gradle
index d80081b8..85f82d5e 100644
--- a/leakcanary-sample/build.gradle
+++ b/leakcanary-sample/build.gradle
@@ -1,23 +1,25 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-  debugCompile project(':leakcanary-android')
-  releaseCompile project(':leakcanary-android-no-op');
+  debugImplementation project(':leakcanary-android')
+  releaseImplementation project(':leakcanary-android-no-op')
+
+  testImplementation "junit:junit:4.12"
+  testImplementation "org.robolectric:robolectric:3.8"
 }
 
 android {
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
+  compileSdkVersion versions.compileSdk
 
   compileOptions {
-    sourceCompatibility rootProject.ext.javaVersion
-    targetCompatibility rootProject.ext.javaVersion
+    sourceCompatibility JavaVersion.VERSION_1_7
+    targetCompatibility JavaVersion.VERSION_1_7
   }
 
   defaultConfig {
     applicationId "com.example.leakcanary"
-    minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.compileSdkVersion
+    minSdkVersion versions.minSdk
+    targetSdkVersion versions.compileSdk
 
     versionCode 1
     versionName "1.0"
@@ -26,4 +28,18 @@ android {
   buildTypes {
     debug
   }
+
+  dexOptions {
+    dexInProcess false
+  }
+
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+  }
+
+  testOptions {
+    unitTests {
+      includeAndroidResources = true
+    }
+  }
 }
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
index 942be776..08cb841b 100644
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
@@ -19,24 +19,27 @@
 import android.os.StrictMode;
 import com.squareup.leakcanary.LeakCanary;
 
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.GINGERBREAD;
-
 public class ExampleApplication extends Application {
-
   @Override public void onCreate() {
     super.onCreate();
+    setupLeakCanary();
+  }
+
+  protected void setupLeakCanary() {
+    if (LeakCanary.isInAnalyzerProcess(this)) {
+      // This process is dedicated to LeakCanary for heap analysis.
+      // You should not init your app in this process.
+      return;
+    }
     enabledStrictMode();
     LeakCanary.install(this);
   }
 
-  private void enabledStrictMode() {
-    if (SDK_INT >= GINGERBREAD) {
-      StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() //
-          .detectAll() //
-          .penaltyLog() //
-          .penaltyDeath() //
-          .build());
-    }
+  private static void enabledStrictMode() {
+    StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() //
+        .detectAll() //
+        .penaltyLog() //
+        .penaltyDeath() //
+        .build());
   }
 }
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
index 870f59b1..e51f5a9a 100644
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
@@ -15,6 +15,7 @@
  */
 package com.example.leakcanary;
 
+import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.os.AsyncTask;
 import android.os.Bundle;
@@ -35,6 +36,7 @@
     });
   }
 
+  @SuppressLint("StaticFieldLeak")
   void startAsyncTask() {
     // This async task is an anonymous class and therefore has a hidden reference to the outer
     // class MainActivity. If the activity gets destroyed before the task finishes (e.g. rotation),
diff --git a/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png
index 099c77d4..65948fa3 100755
Binary files a/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png
index da2453c6..5d826c42 100755
Binary files a/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png
index 35a3ec97..c9c7ec58 100755
Binary files a/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png
index 6b3f35af..cb8a98ab 100755
Binary files a/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png
index 2d77dc1f..3ca3a7f6 100755
Binary files a/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/values/strings.xml b/leakcanary-sample/src/main/res/values/strings.xml
index 9e5bf782..8aa73b33 100644
--- a/leakcanary-sample/src/main/res/values/strings.xml
+++ b/leakcanary-sample/src/main/res/values/strings.xml
@@ -14,7 +14,9 @@
   ~ See the License for the specific language governing permissions and
   ~ limitations under the License.
   -->
-<resources>
+<resources
+    xmlns:tools="http://schemas.android.com/tools"
+    tools:ignore="MissingTranslation" >
   <string name="app_name">LeakCanary Sample</string>
   <string name="start_async_task">Start new AsyncTask</string>
   <string name="helper_text">Start the async task, <b>rotate the screen</b> and wait for a bit. A
diff --git a/leakcanary-sample/src/test/java/com/example/leakcanary/SampleTest.java b/leakcanary-sample/src/test/java/com/example/leakcanary/SampleTest.java
new file mode 100644
index 00000000..960cfedb
--- /dev/null
+++ b/leakcanary-sample/src/test/java/com/example/leakcanary/SampleTest.java
@@ -0,0 +1,20 @@
+package com.example.leakcanary;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.android.controller.ActivityController;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(constants = BuildConfig.class, application = TestExampleApplication.class)
+public class SampleTest {
+  @Test public void testTheThing() throws Exception {
+    ActivityController<MainActivity> controller =
+        Robolectric.buildActivity(MainActivity.class).create().start().resume().visible();
+    controller.get().findViewById(R.id.async_task).performClick();
+    controller.stop();
+    controller.destroy();
+  }
+}
diff --git a/leakcanary-sample/src/test/java/com/example/leakcanary/TestExampleApplication.java b/leakcanary-sample/src/test/java/com/example/leakcanary/TestExampleApplication.java
new file mode 100644
index 00000000..91750c2b
--- /dev/null
+++ b/leakcanary-sample/src/test/java/com/example/leakcanary/TestExampleApplication.java
@@ -0,0 +1,7 @@
+package com.example.leakcanary;
+
+public class TestExampleApplication extends ExampleApplication {
+  @Override protected void setupLeakCanary() {
+    // No leakcanary in unit tests.
+  }
+}
diff --git a/leakcanary-watcher/build.gradle b/leakcanary-watcher/build.gradle
index ac0cac77..f1085cda 100644
--- a/leakcanary-watcher/build.gradle
+++ b/leakcanary-watcher/build.gradle
@@ -1,45 +1,11 @@
-version rootProject.ext.VERSION_NAME
-group rootProject.ext.GROUP
+apply plugin: 'java-library'
 
-buildscript {
-  repositories {
-    mavenCentral()
-  }
-}
-
-apply plugin: 'com.android.library'
-
-repositories {
-  mavenCentral()
-}
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
 
 dependencies {
-  testCompile 'junit:junit:4.12'
-}
-
-android.libraryVariants.all { variant ->
-  def name = variant.buildType.name
-  if (name.equals(com.android.builder.core.BuilderConstants.DEBUG)) {
-    return; // Skip debug builds.
-  }
-  def task = project.tasks.create "jar${name.capitalize()}", Jar
-  task.dependsOn variant.javaCompile
-  task.from variant.javaCompile.destinationDir
-  artifacts.add('archives', task);
-}
-
-android {
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
-  defaultConfig {
-    minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.targetSdkVersion
-  }
-}
-
-task sourceJar(type: Jar) {
-  from 'src/main/java'
+  testImplementation 'junit:junit:4.12'
 }
 
 apply from: rootProject.file('gradle/checkstyle.gradle')
-apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-watcher/src/main/AndroidManifest.xml b/leakcanary-watcher/src/main/AndroidManifest.xml
deleted file mode 100644
index 3f8d7ca9..00000000
--- a/leakcanary-watcher/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<manifest
-    package="com.squareup.leakcanary.watcher">
-  <application/>
-</manifest>
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
index 9660eda2..6ac369eb 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
@@ -23,139 +23,170 @@
 import static java.util.Collections.unmodifiableMap;
 
 /**
- * Prevents specific references from being taken into account when computing the shortest reference
- * path from a suspected leaking instance to the GC roots.
+ * Prevents specific references from being taken into account when computing the shortest strong
+ * reference path from a suspected leaking instance to the GC roots.
  *
- * This class lets you ignore known memory leaks that you know about. If the shortest path
+ * This class lets you ignore known memory leaks that you known about. If the shortest path
  * matches {@link ExcludedRefs}, than the heap analyzer should look for a longer path with nothing
  * matching in {@link ExcludedRefs}.
  */
 public final class ExcludedRefs implements Serializable {
 
-  public final Map<String, Map<String, Boolean>> fieldNameByClassName;
-  public final Map<String, Map<String, Boolean>> staticFieldNameByClassName;
-  public final Map<String, Boolean> threadNames;
-  public final Map<String, Boolean> classNames;
-  public final Map<String, Boolean> rootSuperClassNames;
-
-  ExcludedRefs(Map<String, Map<String, Boolean>> fieldNameByClassName,
-      Map<String, Map<String, Boolean>> staticFieldNameByClassName,
-      Map<String, Boolean> threadNames, Map<String, Boolean> classNames,
-      Map<String, Boolean> rootSuperClassNames) {
-    // Copy + unmodifiable.
-    this.fieldNameByClassName = unmodifiableMap(new LinkedHashMap<>(fieldNameByClassName));
-    this.staticFieldNameByClassName =
-        unmodifiableMap(new LinkedHashMap<>(staticFieldNameByClassName));
-    this.threadNames = unmodifiableMap(new LinkedHashMap<>(threadNames));
-    this.classNames = unmodifiableMap(new LinkedHashMap<>(classNames));
-    this.rootSuperClassNames = unmodifiableMap(new LinkedHashMap<>(rootSuperClassNames));
+  public static Builder builder() {
+    return new BuilderWithParams();
+  }
+
+  public final Map<String, Map<String, Exclusion>> fieldNameByClassName;
+  public final Map<String, Map<String, Exclusion>> staticFieldNameByClassName;
+  public final Map<String, Exclusion> threadNames;
+  public final Map<String, Exclusion> classNames;
+
+  ExcludedRefs(BuilderWithParams builder) {
+    this.fieldNameByClassName = unmodifiableRefStringMap(builder.fieldNameByClassName);
+    this.staticFieldNameByClassName = unmodifiableRefStringMap(builder.staticFieldNameByClassName);
+    this.threadNames = unmodifiableRefMap(builder.threadNames);
+    this.classNames = unmodifiableRefMap(builder.classNames);
+  }
+
+  private Map<String, Map<String, Exclusion>> unmodifiableRefStringMap(
+      Map<String, Map<String, ParamsBuilder>> mapmap) {
+    LinkedHashMap<String, Map<String, Exclusion>> fieldNameByClassName = new LinkedHashMap<>();
+    for (Map.Entry<String, Map<String, ParamsBuilder>> entry : mapmap.entrySet()) {
+      fieldNameByClassName.put(entry.getKey(), unmodifiableRefMap(entry.getValue()));
+    }
+    return unmodifiableMap(fieldNameByClassName);
+  }
+
+  private Map<String, Exclusion> unmodifiableRefMap(Map<String, ParamsBuilder> fieldBuilderMap) {
+    Map<String, Exclusion> fieldMap = new LinkedHashMap<>();
+    for (Map.Entry<String, ParamsBuilder> fieldEntry : fieldBuilderMap.entrySet()) {
+      fieldMap.put(fieldEntry.getKey(), new Exclusion(fieldEntry.getValue()));
+    }
+    return unmodifiableMap(fieldMap);
   }
 
   @Override public String toString() {
     String string = "";
-    for (Map.Entry<String, Map<String, Boolean>> classes : fieldNameByClassName.entrySet()) {
+    for (Map.Entry<String, Map<String, Exclusion>> classes : fieldNameByClassName.entrySet()) {
       String clazz = classes.getKey();
-      for (Map.Entry<String, Boolean> field : classes.getValue().entrySet()) {
-        String always = field.getValue() ? " (always)" : "";
+      for (Map.Entry<String, Exclusion> field : classes.getValue().entrySet()) {
+        String always = field.getValue().alwaysExclude ? " (always)" : "";
         string += "| Field: " + clazz + "." + field.getKey() + always + "\n";
       }
     }
-    for (Map.Entry<String, Map<String, Boolean>> classes : staticFieldNameByClassName.entrySet()) {
+    for (Map.Entry<String, Map<String, Exclusion>> classes : staticFieldNameByClassName.entrySet()) {
       String clazz = classes.getKey();
-      for (Map.Entry<String, Boolean> field : classes.getValue().entrySet()) {
-        String always = field.getValue() ? " (always)" : "";
+      for (Map.Entry<String, Exclusion> field : classes.getValue().entrySet()) {
+        String always = field.getValue().alwaysExclude ? " (always)" : "";
         string += "| Static field: " + clazz + "." + field.getKey() + always + "\n";
       }
     }
-    for (Map.Entry<String, Boolean> thread : threadNames.entrySet()) {
-      String always = thread.getValue() ? " (always)" : "";
+    for (Map.Entry<String, Exclusion> thread : threadNames.entrySet()) {
+      String always = thread.getValue().alwaysExclude ? " (always)" : "";
       string += "| Thread:" + thread.getKey() + always + "\n";
     }
-    for (Map.Entry<String, Boolean> clazz : classNames.entrySet()) {
-      String always = clazz.getValue() ? " (always)" : "";
+    for (Map.Entry<String, Exclusion> clazz : classNames.entrySet()) {
+      String always = clazz.getValue().alwaysExclude ? " (always)" : "";
       string += "| Class:" + clazz.getKey() + always + "\n";
     }
-    for (Map.Entry<String, Boolean> clazz : rootSuperClassNames.entrySet()) {
-      String always = clazz.getValue() ? " (always)" : "";
-      string += "| Root Class:" + clazz.getKey() + always + "\n";
-    }
     return string;
   }
 
-  public static final class Builder {
-    private final Map<String, Map<String, Boolean>> fieldNameByClassName = new LinkedHashMap<>();
-    private final Map<String, Map<String, Boolean>> staticFieldNameByClassName =
+  static final class ParamsBuilder {
+    String name;
+    String reason;
+    boolean alwaysExclude;
+    final String matching;
+
+    ParamsBuilder(String matching) {
+      this.matching = matching;
+    }
+  }
+
+  public interface Builder {
+    BuilderWithParams instanceField(String className, String fieldName);
+
+    BuilderWithParams staticField(String className, String fieldName);
+
+    BuilderWithParams thread(String threadName);
+
+    BuilderWithParams clazz(String className);
+
+    ExcludedRefs build();
+  }
+
+  public static final class BuilderWithParams implements Builder {
+
+    private final Map<String, Map<String, ParamsBuilder>> fieldNameByClassName =
+        new LinkedHashMap<>();
+    private final Map<String, Map<String, ParamsBuilder>> staticFieldNameByClassName =
         new LinkedHashMap<>();
-    private final Map<String, Boolean> threadNames = new LinkedHashMap<>();
-    private final Map<String, Boolean> classNames = new LinkedHashMap<>();
-    private final Map<String, Boolean> rootSuperClassNames = new LinkedHashMap<>();
+    private final Map<String, ParamsBuilder> threadNames = new LinkedHashMap<>();
+    private final Map<String, ParamsBuilder> classNames = new LinkedHashMap<>();
 
-    public Builder instanceField(String className, String fieldName) {
-      return instanceField(className, fieldName, false);
+    private ParamsBuilder lastParams;
+
+    BuilderWithParams() {
     }
 
-    public Builder instanceField(String className, String fieldName, boolean always) {
+    @Override public BuilderWithParams instanceField(String className, String fieldName) {
       checkNotNull(className, "className");
       checkNotNull(fieldName, "fieldName");
-      Map<String, Boolean> excludedFields = fieldNameByClassName.get(className);
+      Map<String, ParamsBuilder> excludedFields = fieldNameByClassName.get(className);
       if (excludedFields == null) {
         excludedFields = new LinkedHashMap<>();
         fieldNameByClassName.put(className, excludedFields);
       }
-      excludedFields.put(fieldName, always);
+      lastParams = new ParamsBuilder("field " + className + "#" + fieldName);
+      excludedFields.put(fieldName, lastParams);
       return this;
     }
 
-    public Builder staticField(String className, String fieldName) {
-      return staticField(className, fieldName, false);
-    }
-
-    public Builder staticField(String className, String fieldName, boolean always) {
+    @Override public BuilderWithParams staticField(String className, String fieldName) {
       checkNotNull(className, "className");
       checkNotNull(fieldName, "fieldName");
-      Map<String, Boolean> excludedFields = staticFieldNameByClassName.get(className);
+      Map<String, ParamsBuilder> excludedFields = staticFieldNameByClassName.get(className);
       if (excludedFields == null) {
         excludedFields = new LinkedHashMap<>();
         staticFieldNameByClassName.put(className, excludedFields);
       }
-      excludedFields.put(fieldName, always);
+      lastParams = new ParamsBuilder("static field " + className + "#" + fieldName);
+      excludedFields.put(fieldName, lastParams);
       return this;
     }
 
-    public Builder thread(String threadName) {
-      return thread(threadName, false);
-    }
-
-    public Builder thread(String threadName, boolean always) {
+    @Override public BuilderWithParams thread(String threadName) {
       checkNotNull(threadName, "threadName");
-      threadNames.put(threadName, always);
+      lastParams = new ParamsBuilder("any threads named " + threadName);
+      threadNames.put(threadName, lastParams);
       return this;
     }
 
-    public Builder clazz(String className) {
-      return thread(className, false);
+    /** Ignores all fields and static fields of all subclasses of the provided class name. */
+    @Override public BuilderWithParams clazz(String className) {
+      checkNotNull(className, "className");
+      lastParams = new ParamsBuilder("any subclass of " + className);
+      classNames.put(className, lastParams);
+      return this;
     }
 
-    public Builder clazz(String className, boolean always) {
-      checkNotNull(className, "className");
-      classNames.put(className, always);
+    public BuilderWithParams named(String name) {
+      lastParams.name = name;
       return this;
     }
 
-    public Builder rootSuperClass(String rootSuperClassName) {
-      return rootSuperClass(rootSuperClassName, false);
+    public BuilderWithParams reason(String reason) {
+      lastParams.reason = reason;
+      return this;
     }
 
-    /** Ignores any GC root that is a subclass of the provided class name. */
-    public Builder rootSuperClass(String rootSuperClassName, boolean always) {
-      checkNotNull(rootSuperClassName, "rootSuperClassName");
-      rootSuperClassNames.put(rootSuperClassName, always);
+    public BuilderWithParams alwaysExclude() {
+      lastParams.alwaysExclude = true;
       return this;
     }
 
-    public ExcludedRefs build() {
-      return new ExcludedRefs(fieldNameByClassName, staticFieldNameByClassName, threadNames,
-          classNames, rootSuperClassNames);
+    @Override public ExcludedRefs build() {
+      return new ExcludedRefs(this);
     }
   }
 }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java
new file mode 100644
index 00000000..4d87d05e
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java
@@ -0,0 +1,17 @@
+package com.squareup.leakcanary;
+
+import java.io.Serializable;
+
+public final class Exclusion implements Serializable {
+  public final String name;
+  public final String reason;
+  public final boolean alwaysExclude;
+  public final String matching;
+
+  Exclusion(ExcludedRefs.ParamsBuilder builder) {
+    this.name = builder.name;
+    this.reason = builder.reason;
+    this.alwaysExclude = builder.alwaysExclude;
+    this.matching = builder.matching;
+  }
+}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
index fe88f38e..ee201585 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
@@ -20,9 +20,16 @@
 
 import static com.squareup.leakcanary.Preconditions.checkNotNull;
 
+/** Data structure holding information about a heap dump. */
 public final class HeapDump implements Serializable {
 
+  /** Receives a heap dump to analyze. */
   public interface Listener {
+    Listener NONE = new Listener() {
+      @Override public void analyze(HeapDump heapDump) {
+      }
+    };
+
     void analyze(HeapDump heapDump);
   }
 
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
index 715d089a..43a9499d 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
@@ -17,13 +17,19 @@
 
 import java.io.File;
 
+/** Dumps the heap into a file. */
 public interface HeapDumper {
+  HeapDumper NONE = new HeapDumper() {
+    @Override public File dumpHeap() {
+      return RETRY_LATER;
+    }
+  };
 
-  File NO_DUMP = null;
+  File RETRY_LATER = null;
 
   /**
-   * @return a {@link File} referencing the heap dump, or {@link #NO_DUMP} if the heap could not be
-   * dumped.
+   * @return a {@link File} referencing the dumped heap, or {@link #RETRY_LATER} if the heap could
+   * not be dumped.
    */
   File dumpHeap();
 }
\ No newline at end of file
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
index 7d2b9fc4..8a01a472 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
@@ -20,9 +20,11 @@
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.CopyOnWriteArraySet;
-import java.util.concurrent.Executor;
 
+import static com.squareup.leakcanary.HeapDumper.RETRY_LATER;
 import static com.squareup.leakcanary.Preconditions.checkNotNull;
+import static com.squareup.leakcanary.Retryable.Result.DONE;
+import static com.squareup.leakcanary.Retryable.Result.RETRY;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
 /**
@@ -33,24 +35,9 @@
  */
 public final class RefWatcher {
 
-  public static final RefWatcher DISABLED = new RefWatcher(new Executor() {
-    @Override public void execute(Runnable command) {
-    }
-  }, new DebuggerControl() {
-    @Override public boolean isDebuggerAttached() {
-      // Skips watching.
-      return true;
-    }
-  }, GcTrigger.DEFAULT, new HeapDumper() {
-    @Override public File dumpHeap() {
-      return null;
-    }
-  }, new HeapDump.Listener() {
-    @Override public void analyze(HeapDump heapDump) {
-    }
-  }, new ExcludedRefs.Builder().build());
+  public static final RefWatcher DISABLED = new RefWatcherBuilder<>().build();
 
-  private final Executor watchExecutor;
+  private final WatchExecutor watchExecutor;
   private final DebuggerControl debuggerControl;
   private final GcTrigger gcTrigger;
   private final HeapDumper heapDumper;
@@ -59,7 +46,7 @@
   private final HeapDump.Listener heapdumpListener;
   private final ExcludedRefs excludedRefs;
 
-  public RefWatcher(Executor watchExecutor, DebuggerControl debuggerControl, GcTrigger gcTrigger,
+  RefWatcher(WatchExecutor watchExecutor, DebuggerControl debuggerControl, GcTrigger gcTrigger,
       HeapDumper heapDumper, HeapDump.Listener heapdumpListener, ExcludedRefs excludedRefs) {
     this.watchExecutor = checkNotNull(watchExecutor, "watchExecutor");
     this.debuggerControl = checkNotNull(debuggerControl, "debuggerControl");
@@ -82,36 +69,47 @@ public void watch(Object watchedReference) {
 
   /**
    * Watches the provided references and checks if it can be GCed. This method is non blocking,
-   * the check is done on the {@link Executor} this {@link RefWatcher} has been constructed with.
+   * the check is done on the {@link WatchExecutor} this {@link RefWatcher} has been constructed
+   * with.
    *
    * @param referenceName An logical identifier for the watched object.
    */
   public void watch(Object watchedReference, String referenceName) {
-    checkNotNull(watchedReference, "watchedReference");
-    checkNotNull(referenceName, "referenceName");
-    if (debuggerControl.isDebuggerAttached()) {
+    if (this == DISABLED) {
       return;
     }
+    checkNotNull(watchedReference, "watchedReference");
+    checkNotNull(referenceName, "referenceName");
     final long watchStartNanoTime = System.nanoTime();
     String key = UUID.randomUUID().toString();
     retainedKeys.add(key);
     final KeyedWeakReference reference =
         new KeyedWeakReference(watchedReference, key, referenceName, queue);
 
-    watchExecutor.execute(new Runnable() {
-      @Override public void run() {
-        ensureGone(reference, watchStartNanoTime);
+    ensureGoneAsync(watchStartNanoTime, reference);
+  }
+
+  private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {
+    watchExecutor.execute(new Retryable() {
+      @Override public Retryable.Result run() {
+        return ensureGone(reference, watchStartNanoTime);
       }
     });
   }
 
-  void ensureGone(KeyedWeakReference reference, long watchStartNanoTime) {
+  @SuppressWarnings("ReferenceEquality") // Explicitly checking for named null.
+  Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {
     long gcStartNanoTime = System.nanoTime();
-
     long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);
+
     removeWeaklyReachableReferences();
-    if (gone(reference) || debuggerControl.isDebuggerAttached()) {
-      return;
+
+    if (debuggerControl.isDebuggerAttached()) {
+      // The debugger can create false leaks.
+      return RETRY;
+    }
+    if (gone(reference)) {
+      return DONE;
     }
     gcTrigger.runGc();
     removeWeaklyReachableReferences();
@@ -120,16 +118,16 @@ void ensureGone(KeyedWeakReference reference, long watchStartNanoTime) {
       long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);
 
       File heapDumpFile = heapDumper.dumpHeap();
-
-      if (heapDumpFile == HeapDumper.NO_DUMP) {
-        // Could not dump the heap, abort.
-        return;
+      if (heapDumpFile == RETRY_LATER) {
+        // Could not dump the heap.
+        return RETRY;
       }
       long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);
       heapdumpListener.analyze(
           new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,
               gcDurationMs, heapDumpDurationMs));
     }
+    return DONE;
   }
 
   private boolean gone(KeyedWeakReference reference) {
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
new file mode 100644
index 00000000..b4c9eb33
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
@@ -0,0 +1,124 @@
+package com.squareup.leakcanary;
+
+/**
+ * Responsible for building {@link RefWatcher} instances. Subclasses should provide sane defaults
+ * for the platform they support.
+ */
+public class RefWatcherBuilder<T extends RefWatcherBuilder<T>> {
+
+  private ExcludedRefs excludedRefs;
+  private HeapDump.Listener heapDumpListener;
+  private DebuggerControl debuggerControl;
+  private HeapDumper heapDumper;
+  private WatchExecutor watchExecutor;
+  private GcTrigger gcTrigger;
+
+  /** @see HeapDump.Listener */
+  public final T heapDumpListener(HeapDump.Listener heapDumpListener) {
+    this.heapDumpListener = heapDumpListener;
+    return self();
+  }
+
+  /** @see ExcludedRefs */
+  public final T excludedRefs(ExcludedRefs excludedRefs) {
+    this.excludedRefs = excludedRefs;
+    return self();
+  }
+
+  /** @see HeapDumper */
+  public final T heapDumper(HeapDumper heapDumper) {
+    this.heapDumper = heapDumper;
+    return self();
+  }
+
+  /** @see DebuggerControl */
+  public final T debuggerControl(DebuggerControl debuggerControl) {
+    this.debuggerControl = debuggerControl;
+    return self();
+  }
+
+  /** @see WatchExecutor */
+  public final T watchExecutor(WatchExecutor watchExecutor) {
+    this.watchExecutor = watchExecutor;
+    return self();
+  }
+
+  /** @see GcTrigger */
+  public final T gcTrigger(GcTrigger gcTrigger) {
+    this.gcTrigger = gcTrigger;
+    return self();
+  }
+
+  /** Creates a {@link RefWatcher}. */
+  public final RefWatcher build() {
+    if (isDisabled()) {
+      return RefWatcher.DISABLED;
+    }
+
+    ExcludedRefs excludedRefs = this.excludedRefs;
+    if (excludedRefs == null) {
+      excludedRefs = defaultExcludedRefs();
+    }
+
+    HeapDump.Listener heapDumpListener = this.heapDumpListener;
+    if (heapDumpListener == null) {
+      heapDumpListener = defaultHeapDumpListener();
+    }
+
+    DebuggerControl debuggerControl = this.debuggerControl;
+    if (debuggerControl == null) {
+      debuggerControl = defaultDebuggerControl();
+    }
+
+    HeapDumper heapDumper = this.heapDumper;
+    if (heapDumper == null) {
+      heapDumper = defaultHeapDumper();
+    }
+
+    WatchExecutor watchExecutor = this.watchExecutor;
+    if (watchExecutor == null) {
+      watchExecutor = defaultWatchExecutor();
+    }
+
+    GcTrigger gcTrigger = this.gcTrigger;
+    if (gcTrigger == null) {
+      gcTrigger = defaultGcTrigger();
+    }
+
+    return new RefWatcher(watchExecutor, debuggerControl, gcTrigger, heapDumper, heapDumpListener,
+        excludedRefs);
+  }
+
+  protected boolean isDisabled() {
+    return false;
+  }
+
+  protected GcTrigger defaultGcTrigger() {
+    return GcTrigger.DEFAULT;
+  }
+
+  protected DebuggerControl defaultDebuggerControl() {
+    return DebuggerControl.NONE;
+  }
+
+  protected ExcludedRefs defaultExcludedRefs() {
+    return ExcludedRefs.builder().build();
+  }
+
+  protected HeapDumper defaultHeapDumper() {
+    return HeapDumper.NONE;
+  }
+
+  protected HeapDump.Listener defaultHeapDumpListener() {
+    return HeapDump.Listener.NONE;
+  }
+
+  protected WatchExecutor defaultWatchExecutor() {
+    return WatchExecutor.NONE;
+  }
+
+  @SuppressWarnings("unchecked")
+  protected final T self() {
+    return (T) this;
+  }
+}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Retryable.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Retryable.java
new file mode 100644
index 00000000..d9d19d40
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Retryable.java
@@ -0,0 +1,11 @@
+package com.squareup.leakcanary;
+
+/** A unit of work that can be retried later. */
+public interface Retryable {
+
+  enum Result {
+    DONE, RETRY
+  }
+
+  Result run();
+}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/WatchExecutor.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/WatchExecutor.java
new file mode 100644
index 00000000..9446877c
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/WatchExecutor.java
@@ -0,0 +1,14 @@
+package com.squareup.leakcanary;
+
+/**
+ * A {@link WatchExecutor} is in charge of executing a {@link Retryable} in the future, and retry
+ * later if needed.
+ */
+public interface WatchExecutor {
+  WatchExecutor NONE = new WatchExecutor() {
+    @Override public void execute(Retryable retryable) {
+    }
+  };
+
+  void execute(Retryable retryable);
+}
diff --git a/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java b/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
index 31e65317..715d53fc 100644
--- a/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
+++ b/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
@@ -16,16 +16,16 @@
 package com.squareup.leakcanary;
 
 import java.io.File;
-import java.util.concurrent.Executor;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
+@RunWith(JUnit4.class)
 public class RefWatcherTest {
 
-  static final ExcludedRefs NO_REF = new ExcludedRefs.Builder().build();
-
   static class TestDumper implements HeapDumper {
     boolean called;
 
@@ -42,11 +42,11 @@
 
   @SuppressWarnings("FieldCanBeLocal") Object ref;
 
-  static class TestExecutor implements Executor {
-    Runnable command;
+  static class TestExecutor implements WatchExecutor {
+    Retryable retryable;
 
-    @Override public void execute(Runnable command) {
-      this.command = command;
+    @Override public void execute(Retryable retryable) {
+      this.retryable = retryable;
     }
   }
 
@@ -59,7 +59,7 @@
     TestExecutor executor = new TestExecutor();
     RefWatcher refWatcher = defaultWatcher(dumper, executor);
     refWatcher.watch(new Object());
-    executor.command.run();
+    executor.retryable.run();
     assertFalse(dumper.called);
   }
 
@@ -69,12 +69,14 @@
     RefWatcher refWatcher = defaultWatcher(dumper, executor);
     ref = new Object();
     refWatcher.watch(ref);
-    executor.command.run();
+    executor.retryable.run();
     assertTrue(dumper.called);
   }
 
   private RefWatcher defaultWatcher(TestDumper dumper, TestExecutor executor) {
-    return new RefWatcher(executor, DebuggerControl.NONE, GcTrigger.DEFAULT, dumper,
-        new TestListener(), NO_REF);
+    return new RefWatcherBuilder<>().watchExecutor(executor)
+        .heapDumper(dumper)
+        .heapDumpListener(new TestListener())
+        .build();
   }
 }
