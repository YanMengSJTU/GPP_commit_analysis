diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
index ab5d9fd5..b55f33ac 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -85,6 +85,8 @@ internal class HeapDumpTrigger(
       return
     }
 
+    // 可能存在被观察的引用将要变得弱可达，但是还未入队引用队列。
+    // 这时候应该主动调用一次 GC，可能可以避免一次 heap dump
     gcTrigger.runGc()
 
     retainedKeys = refWatcher.retainedKeys
@@ -96,7 +98,7 @@ internal class HeapDumpTrigger(
     CanaryLog.d("Found %d retained references, dumping the heap", retainedKeys.size)
     HeapDumpMemoryStore.heapDumpUptimeMillis = SystemClock.uptimeMillis()
     dismissNotification()
-    val heapDumpFile = heapDumper.dumpHeap()
+    val heapDumpFile = heapDumper.dumpHeap() // AndroidHeapDumper
     if (heapDumpFile == null) {
       CanaryLog.d("Failed to dump heap, will retry in %d ms", WAIT_AFTER_DUMP_FAILED_MILLIS)
       scheduleRetainedInstanceCheck("failed to dump heap", WAIT_AFTER_DUMP_FAILED_MILLIS)
@@ -104,9 +106,9 @@ internal class HeapDumpTrigger(
       return
     }
 
-    refWatcher.removeRetainedKeys(retainedKeys)
+    refWatcher.removeRetainedKeys(retainedKeys) // 移除已经 heap dump 的 retainedKeys
 
-    HeapAnalyzerService.runAnalysis(application, heapDumpFile)
+    HeapAnalyzerService.runAnalysis(application, heapDumpFile) // 分析 heap dump 文件
   }
 
   fun onDumpHeapReceived() {
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
index d27c0bb7..0ae6927c 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
@@ -41,7 +41,7 @@ internal class ActivityDestroyWatcher private constructor(
     ) {
       val activityDestroyWatcher =
         ActivityDestroyWatcher(refWatcher, configProvider)
-      application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)
+      application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks) // 注册 Activity 生命周期监听
     }
   }
 }
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
index a0317e8d..18260fe0 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
@@ -41,7 +41,7 @@ internal object InternalLeakSentry {
     }
   }
 
-  private val checkRetainedExecutor = Executor {
+  private val checkRetainedExecutor = Executor { // 默认五秒后执行
     mainHandler.postDelayed(it, LeakSentry.config.watchDurationMillis)
   }
   val refWatcher = RefWatcher(
@@ -53,20 +53,20 @@ internal object InternalLeakSentry {
 
   fun install(application: Application) {
     CanaryLog.d("Installing LeakSentry")
-    checkMainThread()
+    checkMainThread() // 只能在主线程调用，否则会抛出异常
     if (this::application.isInitialized) {
       return
     }
     InternalLeakSentry.application = application
 
     val configProvider = { LeakSentry.config }
-    ActivityDestroyWatcher.install(
+    ActivityDestroyWatcher.install( // 监听 Activity.onDestroy()
         application, refWatcher, configProvider
     )
-    FragmentDestroyWatcher.install(
+    FragmentDestroyWatcher.install( // 监听 Fragment.onDestroy()
         application, refWatcher, configProvider
     )
-    listener.onLeakSentryInstalled(application)
+    listener.onLeakSentryInstalled(application) // Sentry 哨兵
   }
 
   private fun checkMainThread() {
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryInstaller.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryInstaller.kt
index 84cf968b..d7f8252d 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryInstaller.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryInstaller.kt
@@ -10,13 +10,15 @@ import leakcanary.CanaryLog
 /**
  * Content providers are loaded before the application class is created. [LeakSentryInstaller] is
  * used to install [leaksentry.LeakSentry] on application start.
+ *
+ * Content Provider 在 Application 创建之前被自动加载，因此无需用户手动在 onCrate() 中进行初始化
  */
 internal class LeakSentryInstaller : ContentProvider() {
 
   override fun onCreate(): Boolean {
     CanaryLog.logger = DefaultCanaryLog()
     val application = context!!.applicationContext as Application
-    InternalLeakSentry.install(application)
+    InternalLeakSentry.install(application) // 进行初始化工作，核心
     return true
   }
 
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
index 87a01773..e3f35f1e 100644
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
@@ -24,7 +24,7 @@ open class ExampleApplication : Application() {
 
   override fun onCreate() {
     super.onCreate()
-    enabledStrictMode()
+//    enabledStrictMode()
   }
 
   private fun enabledStrictMode() {
