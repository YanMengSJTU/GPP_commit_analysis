diff --git a/build.gradle b/build.gradle
index 651eafbd..6a55c257 100644
--- a/build.gradle
+++ b/build.gradle
@@ -41,7 +41,7 @@ buildscript {
   }
   dependencies {
     classpath deps.kotlin.gradlePlugin
-    classpath 'com.android.tools.build:gradle:3.4.0'
+    classpath 'com.android.tools.build:gradle:3.4.2'
     classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.0.16'
     classpath 'com.github.ben-manes:gradle-versions-plugin:0.20.0'
     classpath "org.jetbrains.dokka:dokka-gradle-plugin:0.9.18"
diff --git a/docs/changelog.md b/docs/changelog.md
index e315d1da..02cf6832 100644
--- a/docs/changelog.md
+++ b/docs/changelog.md
@@ -1,8 +1,31 @@
 # Change Log
 
-## Version 2.0 Alpha 3 (2019-07-04)
+## Version 2.0 Beta 1 (2019-17-30)
+
+LeakCanary 2 reached **beta status**: the internals and APIs are mostly stable.
+
+Now is a great time to adopt it and provide feedback before the stable release. We're counting on you to find bugs and suggest improvements! Check out the new [Getting Started](https://square.github.io/leakcanary/getting_started) instructions and the [migration guide](https://square.github.io/leakcanary/upgrading-to-leakcanary-2.0/). 
+
+* New standalone library! [Shark](shark.md) is the heap analyzer that powers LeakCanary 2, and it can run in any Java VM. It comes with a [CLI](shark.md#shark-cli): you can now run `shark-cli analyze-process com.example.myapp` from your computer.
+* New Heap Explorer directly on device! Open a Heap Analysis in LeakCanary, tap the options menu and select "Heap Explorer". This is still experimental and not very user friendly, contributions welcome!
+* **Large API rewrite** to improve usability. If you used the alpha with a customized configuration, there are breaking changes. Of note: LeakSentry became [AppWatcher](/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/), RefWatcher became [ObjectWatcher](/api/leakcanary-object-watcher/leakcanary/-object-watcher/), AndroidExcludedRefs became [AndroidReferenceMatchers](/api/shark-android/shark/-android-reference-matchers/), AnalysisResultListener became [OnHeapAnalyzedListener](/api/leakcanary-android-core/leakcanary/-on-heap-analyzed-listener/), AndroidLeakTraceInspectors became [AndroidObjectInspectors](/api/shark-android/shark/-android-object-inspectors/).
+* The entire API surface is now documented and the documentation is available on this website: try the search bar at the top and **LeakCanary API âˆ¨** in the navigation menu.
+* Removed the **dependency on Android X**. No more configuration issues! [#1462](https://github.com/square/leakcanary/issues/1462) 
+* Added **Proguard rules** for LeakCanary and ObjectWatcher. [#1500](https://github.com/square/leakcanary/pull/1500) 
+* Display LeakCanary version in the About screen. [#1448](https://github.com/square/leakcanary/issues/1448) 
+* Bug fixes, new reference matchers and object inspectors
+
+Many thanks to
+[@arctouch-carlosottoboni](https://github.com/arctouch-carlosottoboni),
+[@jemaystermind](https://github.com/jemaystermind),
+[@kushagrakumar27](https://github.com/kushagrakumar27),
+[@pyricau](https://github.com/pyricau),
+[@snkashis](https://github.com/snkashis)
+for the contributions, bug reports and feature requests.
 
-**Thanks for testing the alpha**, we're counting on you to help us find bugs and suggest improvements! Check out the new [Getting Started](https://square.github.io/leakcanary/getting_started) instructions and the [migration guide](https://square.github.io/leakcanary/upgrading-to-leakcanary-2.0/). 
+For more details, see the [2.0-beta-1 Milestone](https://github.com/square/leakcanary/milestone/1) and the [full diff](https://github.com/square/leakcanary/compare/v2.0-alpha-3...v2.0-beta-1).
+
+## Version 2.0 Alpha 3 (2019-07-04)
 
 * [#1401](https://github.com/square/leakcanary/pull/1401) LeakCanary can now import all hprof files created from prior LeakCanary versions.
 * [#1414](https://github.com/square/leakcanary/pull/1414) New API: `RefWatcher.retainedInstances` which returns the instances that are currently considered retained.
diff --git a/docs/faq.md b/docs/faq.md
index b5e4d21e..20c9a14d 100644
--- a/docs/faq.md
+++ b/docs/faq.md
@@ -2,16 +2,16 @@
 
 ## Can a leak be caused by the Android SDK?
 
-Yes. There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: [AndroidExcludedRefs.kt](https://github.com/square/leakcanary/blob/master/leakcanary-analyzer/src/main/java/leakcanary/AndroidExcludedRefs.kt).
+Yes. There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: [AndroidReferenceMatchers](/api/shark-android/shark/-android-reference-matchers/).
 
 If you find a new one, please [create an issue](https://github.com/square/leakcanary/issues/new/choose) and follow these steps:
 
 1. Provide the entire leak trace information (reference key, device, etc), and use backticks (`) for formatting.
-2. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions [android/platform_frameworks_base](https://github.com/android/platform_frameworks_base).
+2. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions by switching branches on the GitHub mirror: [android/platform_frameworks_base](https://github.com/android/platform_frameworks_base).
 3. Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed.
 4. If it's still happening, build a simple repro case.
 5. File an issue on [b.android.com](http://b.android.com) with the leak trace and the repro case.
-6. Create a PR in LeakCanary to update `AndroidExcludedRefs.kt`. Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
+6. Create a PR in LeakCanary to update [AndroidReferenceMatchers](/api/shark-android/shark/-android-reference-matchers/). Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
 
 ## How do I share a leak trace?
 
@@ -32,6 +32,10 @@ Here's how you can find the leaking instance in the heap dump:
 4. The `referent` field of that `KeyedWeakReference` is your leaking object.
 5. From then on, the matter is in your hands. A good start is to look at the shortest path to GC Roots (excluding weak references).
 
+## How does LeakCanary get installed by only adding a dependency?
+
+On Android, content providers are created after the Application instance is created but before Application.onCreate() is called. The `leakcanary-object-watcher-android` artifact has a non exported ContentProvider defined in its `AndroidManifest.xml` file. When that ContentProvider is installed, it adds activity and fragment lifecycle listeners to the application.
+
 ## How many methods does LeakCanary add?
 
 **0**. LeakCanary is a debug only library.
@@ -42,7 +46,7 @@ Update your dependencies to the latest SNAPSHOT (see [build.gradle](https://gith
 
 ```gradle
  dependencies {
-   debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-4-SNAPSHOT'
+   debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-beta-2-SNAPSHOT'
  }
 ```
 
diff --git a/docs/fundamentals.md b/docs/fundamentals.md
index 952c7db2..77f248f6 100644
--- a/docs/fundamentals.md
+++ b/docs/fundamentals.md
@@ -10,7 +10,7 @@ For example, an Android activity instance is no longer needed after its `onDestr
 
 Most memory leaks are caused by bugs related to the lifecycle of objects. Here are a few common Android mistakes:
 
-* Storing an Activity context as a field in an object that survives activity recreation configuration changes.
+* Storing an Activity context as a field in an object that survives activity recreation due to configuration changes.
 * Registering a listener, broadcast receiver or RxJava subscription which references an object with lifecycle, and forgetting to unregister when the lifecycle reaches its end.
 * Storing a view in a static field, and not clearing that field when the view is detached.
 
@@ -24,17 +24,17 @@ When we first enabled LeakCanary in the Square Point Of Sale app, we were able t
 
 ### Detecting retained instances
 
-The foundation of LeakCanary is a library called Object Watcher Android. It hooks into the Android lifecycle to automatically detect when activities and fragments are destroyed and should be garbage collected. These destroyed instances are passed to an `ObjectWatcher`, which holds weak references to them. You can also watch any instance that is no longer needed, e.g. a detached view, a destroyed presenter, etc.
+The foundation of LeakCanary is a library called ObjectWatcher Android. It hooks into the Android lifecycle to automatically detect when activities and fragments are destroyed and should be garbage collected. These destroyed instances are passed to an `ObjectWatcher`, which holds weak references to them. You can also watch any instance that is no longer needed, for example a detached view, a destroyed presenter, etc.
 
 If the weak references aren't cleared after waiting 5 seconds and running the garbage collector, the watched instances are considered *retained*, and potentially leaking.
 
 ### Dumping the heap
 
-When the number of retained instances reaches a threshold, LeakCanary dumps the Java heap into a `.hprof` file stored onto the Android file system. The default threshold is 5 retained instances when the app is visible, 1 otherwise.
+When the number of retained instances reaches a threshold, LeakCanary dumps the Java heap into a `.hprof` file stored onto the Android file system. The default threshold is 5 retained instances when the app is visible, and 1 retained instance when the app is not visible.
 
 ### Analyzing the heap
 
-LeakCanary parses the `.hprof` file and finds the chain of references that prevents retained instances from being garbage collected: the **leak trace**. Leak trace is another name for the *shortest strong reference path from garbage collection roots to retained instances*. Once the leak trace is determined, LeakCanary uses its built-in knowledge of the Android framework to deduct which instances in the leak trace are leaking (see below [How do I fix a memory leak?](#how-do-i-fix-a-memory-leak)).
+LeakCanary parses the `.hprof` file using [Shark](shark.md) and finds the chain of references that prevents retained instances from being garbage collected: the **leak trace**. Leak trace is another name for the *shortest strong reference path from garbage collection roots to a retained object*. Once the leak trace is determined, LeakCanary uses its built-in knowledge of the Android framework to deduct which instances in the leak trace are leaking (see below [How do I fix a memory leak?](#how-do-i-fix-a-memory-leak)).
 
 ### Grouping leaks
 
@@ -113,7 +113,7 @@ At the top of the leak trace is a garbage-collection (GC) root. GC roots are spe
 is true)
 ```
 
-At the bottom of the leak trace is the leaking instance. This instance was passed to `RefWatcher.watch()` to confirm it would be garbage collected, and it ended up not being garbage collected which triggered LeakCanary.
+At the bottom of the leak trace is the leaking instance. This instance was passed to [AppWatcher.objectWatcher](/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/object-watcher/) to confirm it would be garbage collected, and it ended up not being garbage collected which triggered LeakCanary.
 
 ### Chain of references
 
@@ -143,17 +143,19 @@ The chain of references from the GC root to the leaking instance is what is prev
     â”‚    View.mWindowAttachCount=1
 ```
 
-LeakCanary runs heuristics to determine the lifecycle state of the nodes of the leak trace, and therefore whether they are leaking or not. For example, if a view has `View#mAttachInfo = null` and `mParent != null` then it is detached yet has a parent, so that view is probably leaking. In the leak trace, for each node you'll see `Leaking: YES / NO / UNKNOWN` with an explanation in parenthesis. LeakCanary can also surface extra information about the state of a node, e.g. `View.mWindowAttachCount=1`. You can customize this behavior and add your own heuristics by updating `LeakCanary.Config.leakTraceInspectors`.
+LeakCanary runs heuristics to determine the lifecycle state of the nodes of the leak trace, and therefore whether they are leaking or not. For example, if a view has `View#mAttachInfo = null` and `mParent != null` then it is detached yet has a parent, so that view is probably leaking. In the leak trace, for each node you'll see `Leaking: YES / NO / UNKNOWN` with an explanation in parenthesis. LeakCanary can also surface extra information about the state of a node, e.g. `View.mWindowAttachCount=1`. LeakCanary comes with a set of default heuristics: [AndroidObjectInspectors](/api/shark-android/shark/-android-object-inspectors/). You can add your own heuristics by updating [LeakCanary.Config.objectInspectors](/api/leakcanary-android-core/leakcanary/-leak-canary/-config/object-inspectors/) (see the [recipe](recipes.md#identifying-leaking-objects-and-labeling-objects)).
 
 ### Narrowing down the cause of a leak
 
 ```
     â”¬
-    â”œâ”€ leakcanary.internal.InternalLeakCanary
-    â”‚    Leaking: NO (it's a GC root and a class is never leaking)
-    â”‚    â†“ static InternalLeakCanary.application
+    â”œâ”€ android.provider.FontsContract
+    â”‚    Leaking: NO (ExampleApplicationâ†“ is not leaking and a class is never leaking)
+    â”‚    GC Root: System class
+    â”‚    â†“ static FontsContract.sContext
     â”œâ”€ com.example.leakcanary.ExampleApplication
     â”‚    Leaking: NO (Application is a singleton)
+    â”‚    ExampleApplication does not wrap an activity context
     â”‚    â†“ ExampleApplication.leakedViews
     â”‚                         ~~~~~~~~~~~
     â”œâ”€ java.util.ArrayList
@@ -162,13 +164,13 @@ LeakCanary runs heuristics to determine the lifecycle state of the nodes of the
     â”‚                ~~~~~~~~~~~
     â”œâ”€ java.lang.Object[]
     â”‚    Leaking: UNKNOWN
-    â”‚    â†“ array Object[].[0]
+    â”‚    â†“ array Object[].[1]
     â”‚                     ~~~
     â”œâ”€ android.widget.TextView
-    â”‚    Leaking: YES (View detached and has parent)
+    â”‚    Leaking: YES (View.mContext references a destroyed activity)
     â”‚    â†“ TextView.mContext
     â•°â†’ com.example.leakcanary.MainActivity
-    â€‹     Leaking: YES (RefWatcher was watching this and MainActivity#mDestroyed is true)
+    â€‹     Leaking: YES (TextViewâ†‘ is leaking and Activity#mDestroyed is true and ObjectWatcher was watching this)
 ```
 
 If a node is not leaking, then any prior reference that points to it is not the source of the leak, and also not leaking. Similarly, if a node is leaking then any node down the leak trace is also leaking. From that, we can deduce that the leak is caused by a reference that is after the last `Leaking: NO`	and before the first `Leaking: YES`.
@@ -190,7 +192,7 @@ In this example, the last `Leaking: NO` is on `com.example.leakcanary.ExampleApp
 ...
 ```
 
-Looking at the [source](https://github.com/square/leakcanary/blob/master/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt#L23), we can see that `ExampleApplication` has a list field:
+Looking at the [source](https://github.com/square/leakcanary/blob/master/leakcanary-android-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt#L23), we can see that `ExampleApplication` has a list field:
 
 ```
 open class ExampleApplication : Application() {
diff --git a/docs/getting_started.md b/docs/getting_started.md
index 2172d3c5..72eed82b 100644
--- a/docs/getting_started.md
+++ b/docs/getting_started.md
@@ -15,4 +15,4 @@ What's next?
 
 * Learn the [Fundamentals](fundamentals.md)
 * Try the [code recipes](recipes.md)
-* Read the [FAQ](faq.md)
+* Read the [FAQ](faq.md), e.g. [How does LeakCanary get installed by only adding a dependency?](faq.md#how-does-leakcanary-get-installed-by-only-adding-a-dependency)
diff --git a/docs/recipes.md b/docs/recipes.md
index 36123a1d..4559a6bf 100644
--- a/docs/recipes.md
+++ b/docs/recipes.md
@@ -2,9 +2,9 @@
 
 If you think a recipe might be missing or you're not sure that what you're trying to achieve is possible with the current APIs, please [file an issue](https://github.com/square/leakcanary/issues/new/choose). Your feedback help us make LeakCanary better for the entire community.
 
-## Configuring ObjectWatcher Android
+## Configuring AppWatcher in `object-watcher-android`
 
-ObjectWatcher Android can be configured by replacing `AppWatcher.config`:
+AppWatcher is in charge of detecting retained objects. Its configuration can be updated at any time by replacing [AppWatcher.config](/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/config/):
 ```kotlin
 class DebugExampleApplication : ExampleApplication() {
 
@@ -17,7 +17,7 @@ class DebugExampleApplication : ExampleApplication() {
 
 ## Configuring LeakCanary
 
-LeakCanary can be configured by replacing `LeakCanary.config`:
+LeakCanary can be configured by replacing [LeakCanary.config](/api/leakcanary-android-core/leakcanary/-leak-canary/config/):
 
 ```kotlin
 disableLeakCanaryButton.setOnClickListener {
@@ -27,7 +27,7 @@ disableLeakCanaryButton.setOnClickListener {
 
 ## Watching objects with a lifecycle
 
-In your application, you may have other objects with a lifecycle, such as fragments, services, Dagger components, etc. Use `AppWatcher.objectWatcher` to watch instances that should be garbage collected:
+In your application, you may have other objects with a lifecycle, such as fragments, services, Dagger components, etc. Use [AppWatcher.objectWatcher](/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/object-watcher/) to watch instances that should be garbage collected:
 
 ```kotlin
 class MyService : Service {
@@ -55,7 +55,7 @@ dependencies {
 
 In your leak reporting code:
 ```kotlin
-val retainedInstanceCount = AppWatcher.objectWatcher.retainedKeys.size
+val retainedInstanceCount = AppWatcher.objectWatcher.retainedObjectCount
 ```
 
 ## Running LeakCanary in instrumentation tests
@@ -82,7 +82,7 @@ android {
 Run the instrumentation tests:
 
 ```
-./gradlew leakcanary-sample:connectedCheck
+./gradlew leakcanary-android-sample:connectedCheck
 ```
 
 You can extend `FailTestOnLeakRunListener` to customize the behavior.
@@ -118,80 +118,128 @@ res/
 
 You can change the default behavior to upload the analysis result to a server of your choosing.
 
-Create a custom `AnalysisResultListener` that delegates to the default: 
+Create a custom [OnHeapAnalyzedListener](/api/leakcanary-android-core/leakcanary/-on-heap-analyzed-listener/) that delegates to [DefaultOnHeapAnalyzedListener](/api/leakcanary-android-core/leakcanary/-default-on-heap-analyzed-listener/): 
 
 ```kotlin
-class LeakUploader : AnalysisResultListener {
-  override fun invoke(
-    application: Application,
-    heapAnalysis: HeapAnalysis
-  ) {
+class LeakUploader : OnHeapAnalyzedListener {
+
+  val defaultListener = DefaultOnHeapAnalyzedListener.create()
+
+  override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {
     TODO("Upload heap analysis to server")
 
     // Delegate to default behavior (notification and saving result)
-    DefaultAnalysisResultListener(application, heapAnalysis)
+    defaultListener.onHeapAnalyzed(heapAnalysis)
   }
 }
 ```
 
-Set `analysisResultListener` on the LeakCanary config:
+Set [LeakCanary.config.onHeapAnalyzedListener](/api/leakcanary-android-core/leakcanary/-leak-canary/-config/on-heap-analyzed-listener/):
 
 ```kotlin
 class DebugExampleApplication : ExampleApplication() {
 
   override fun onCreate() {
     super.onCreate()
-    LeakCanary.config = LeakCanary.config.copy(analysisResultListener = LeakUploader())
+    LeakCanary.config = LeakCanary.config.copy(onHeapAnalyzedListener = LeakUploader())
   }
 }
 ```
 
 
-## Identifying 3rd party leaks as "won't fix"
+## Matching known library leaks
 
-Set `exclusionsFactory` on the LeakCanary config to a `ExclusionsFactory` that delegates to the default one and then and add custom exclusions:
+Set [LeakCanary.Config.referenceMatchers](/api/leakcanary-android-core/leakcanary/-leak-canary/-config/reference-matchers/) to a list that builds on top of [AndroidReferenceMatchers.appDefaults](/api/shark-android/shark/-android-reference-matchers/app-defaults/):
 
 ```kotlin
 class DebugExampleApplication : ExampleApplication() {
 
   override fun onCreate() {
     super.onCreate()
-    LeakCanary.config = LeakCanary.config.copy(exclusionsFactory = { hprofParser ->
-      val defaultFactory = AndroidExcludedRefs.exclusionsFactory(AndroidExcludedRefs.appDefaults)
-      val appDefaults = defaultFactory(hprofParser)
-      val customExclusion = Exclusion(
-          type = StaticFieldExclusion("com.thirdparty.SomeSingleton", "sContext"),
-          status = Exclusion.Status.WONT_FIX_LEAK,
-          reason = "SomeSingleton in library X has a static field leaking a context."
-      )
-      appDefaults + customExclusion
-    })
+    LeakCanary.config = LeakCanary.config.copy(
+        referenceMatchers = AndroidReferenceMatchers.appDefaults +
+            AndroidReferenceMatchers.staticFieldLeak(
+                className = "com.samsing.SomeSingleton",
+                fieldName = "sContext",
+                description = "SomeSingleton has a static field leaking a context.",
+                patternApplies = {
+                  manufacturer == "Samsing" && sdkInt == 26
+                }
+            )
+    )
   }
 }
 ```
 
-## Identifying leaking instances and labeling instances
+## Identifying leaking objects and labeling objects
 
 ```kotlin
 class DebugExampleApplication : ExampleApplication() {
 
   override fun onCreate() {
     super.onCreate()
-    val customLabeler: Labeler = { parser, node ->
-      listOf("Heap dump object id is ${node.instance}")
+    val addObjectIdLabel = ObjectInspector { reporter ->
+      reporter.addLabel("Heap dump object id is ${reporter.heapObject.objectId}")
     }
-    val labelers = AndroidLabelers.defaultAndroidLabelers(this) + customLabeler
 
-    val customInspector: LeakInspector = { parser, node ->
-      with(parser) {
-        if (node.instance.objectRecord.isInstanceOf("com.example.MySingleton")) {
-          LeakNodeStatus.notLeaking("MySingleton is a singleton")
-        } else LeakNodeStatus.unknown()
+    val singletonsInspector =
+      AppSingletonInspector("com.example.MySingleton", "com.example.OtherSingleton")
+
+    val mmvmInspector = ObjectInspector { reporter ->
+      reporter.whenInstanceOf("com.mmvm.SomeViewModel") { instance ->
+        val destroyedField = instance["com.mmvm.SomeViewModel", "destroyed"]!!
+        if (destroyedField.value.asBoolean!!) {
+          reportLeaking("SomeViewModel.destroyed is true")
+        } else {
+          reportNotLeaking("SomeViewModel.destroyed is false")
+        }
       }
     }
-    val leakInspectors = AndroidLeakInspectors.defaultAndroidInspectors() + customInspector
 
-    LeakCanary.config = LeakCanary.config.copy(labelers = labelers, leakInspectors = leakInspectors)
+    LeakCanary.config = LeakCanary.config.copy(
+        objectInspectors = AndroidObjectInspectors.appDefaults +
+            listOf(addObjectIdLabel, singletonsInspector, mmvmInspector)
+    )
+  }
+}
+```
+
+## Setting up LeakCanary for different product flavors
+
+You can setup LeakCanary to run in a specific product flavors of your app. For example, create:
+
+```
+android {
+  flavorDimensions "default"
+  productFlavors {
+    prod {
+      // ...
+    }
+    qa {
+      // ...
+    }
+    dev {
+      // ...
+    }
   }
 }
-```
\ No newline at end of file
+```
+
+Then, define a custom configuration for the flavor for which you want to enable LeakCanary:
+
+```
+android {
+  // ...
+}
+configurations {
+    devDebugImplementation {}
+}
+```
+
+You can now add the LeakCanary dependency for that configuration:
+
+```
+dependencies {
+  devDebugImplementation "com.squareup.leakcanary:leakcanary-android:${leakCanaryVersion}"
+}
+```
diff --git a/docs/shark.md b/docs/shark.md
index 05100c72..8e7e45bc 100644
--- a/docs/shark.md
+++ b/docs/shark.md
@@ -7,20 +7,75 @@
 <img src="https://github.com/square/leakcanary/wiki/assets/shark.png" />
 </p>
 
-Shark is the heap analyzer that powers LeakCanary. It's a standalone heap analyzer Kotlin library that can run in Java and Android VMs at **high speed** with a **low memory footprint**. It can analyze both Android and Java VM hprof files.
+Shark is the heap analyzer that powers LeakCanary 2. It's a Kotlin standalone heap analysis library that runs at **high speed** with a **low memory footprint**.
 
-Shark is released as several distinct libraries:
+Shark is released in layers:
 
-* `Shark Hprof`: Read and write records in hprof files
-* `Shark Graph`: Navigate the heap object graph
-* `Shark`: Generate heap analysis reports
-* `Shark Android`: Generate Android tailored heap analysis reports
+1. **Shark Hprof**: Read and write records in hprof files.
+2. **Shark Graph**: Navigate the heap object graph.
+3. **Shark**: Generate heap analysis reports.
+4. **Shark Android**: Android heuristics to generate tailored heap analysis reports.
+5. **Shark CLI**: Analyze the heap of debuggable apps installed on an Android device connected to your desktop. The output is similar to the output of LeakCanary, except you don't have to add the LeakCanary dependency to your app.
+6. **LeakCanary**: Builds on top. It automatically watches destroyed activities and fragments, triggers a heap dump, runs Shark Android and then displays the result.
 
-Shark is also released as a CLI tool, `Shark CLI`.
+A few more things:
 
-## Example usage
+* Shark is built on top of Okio. Okio makes it easy to parse heap dumps efficiently.
+* Shark is a 100% Kotlin library, and Kotlin is essential to its design, because Shark relies heavily on sealed classes and sequences to save memory.
+* Shark has the unique ability to help narrow down the cause of memory leaks through platform specific [heuristics](fundamentals.md#heuristics-and-labels).
+* Shark is heavily tested (80% test coverage).
+* Shark can run in both Java and Android VMs, with no other dependency than Okio and Kotlin.
+* Shark can analyze both Java and Android VM hprof files.
 
-### Reading records in a hprof file with shark-hprof
+## Shark CLI
+
+The Shark Command Line Interface (CLI) enables you to analyze heaps directly from your computer. It can dump the heap of an app installed on a connected Android device, analyze it, and even strip a heap dump of any sensitive data (e.g. PII, passwords or encryption keys) which is useful when sharing a heap dump.
+
+Download it [here](https://github.com/square/leakcanary/releases/download/v2.0-beta-1/shark-cli-2.0-beta-1.zip)!
+
+Usage instructions:
+
+```
+$ ./bin/shark-cli
+
+Shark CLI
+
+                 ^`.                 .=""=.
+ ^_              \  \               / _  _ \
+ \ \             {   \             |  d  b  |
+ {  \           /     `~~~--__     \   /\   /
+ {   \___----~~'              `~~-_/'-=\/=-'\,
+  \                         /// a  `~.      \ \
+  / /~~~~-, ,__.    ,      ///  __,,,,)      \ |
+  \/      \/    `~~~;   ,---~~-_`/ \        / \/
+                   /   /            '.    .'
+                  '._.'             _|`~~`|_
+                                    /|\  /|\
+
+Commands: [analyze-process, dump-process, analyze-hprof, strip-hprof]
+
+analyze-process: Dumps the heap for the provided process name, pulls the hprof file and analyzes it.
+  USAGE: analyze-process PROCESS_PACKAGE_NAME
+
+dump-process: Dumps the heap for the provided process name and pulls the hprof file.
+  USAGE: dump-process PROCESS_PACKAGE_NAME
+
+analyze-hprof: Analyzes the provided hprof file.
+  USAGE: analyze-hprof HPROF_FILE_PATH
+
+strip-hprof: Replaces all primitive arrays from the provided hprof file with arrays of zeroes.
+  USAGE: strip-hprof HPROF_FILE_PATH
+```
+
+## Shark code examples
+
+### Reading records in a hprof file
+
+```groovy
+dependencies {
+  implementation 'com.squareup.leakcanary:shark-hprof:$sharkVersion'
+}
+```
 
 ```kotlin
 // Prints all class and field names
@@ -34,13 +89,19 @@ Hprof.open(heapDumpFile)
     }
 ```
 
-### Navigating the heap object graph with shark-graph
+### Navigating the heap object graph
+
+```groovy
+dependencies {
+  implementation 'com.squareup.leakcanary:shark-graph:$sharkVersion'
+}
+```
 
 ```kotlin
 // Prints all thread names
 Hprof.open(heapDumpFile)
     .use { hprof ->
-      val heapGraph = HeapGraph.indexHprof(hprof)
+      val heapGraph = HprofHeapGraph.indexHprof(hprof)
       val threadClass = heapGraph.findClassByName("java.lang.Thread")!!
       val threadNames: Sequence<String> = threadClass.instances.map { instance ->
         val nameField = instance["java.lang.Thread", "name"]!!
@@ -50,7 +111,13 @@ Hprof.open(heapDumpFile)
     }
 ```
 
-### Generating a heap analysis report with shark
+### Generating a heap analysis report
+
+```groovy
+dependencies {
+  implementation 'com.squareup.leakcanary:shark:$sharkVersion'
+}
+```
 
 ```kotlin
 val heapAnalyzer = HeapAnalyzer(AnalyzerProgressListener.NONE)
@@ -61,7 +128,7 @@ val analysis = heapAnalyzer.checkForLeaks(
         val field = instance["com.example.ThingWithLifecycle", "destroyed"]!!
         val destroyed = field.value.asBoolean!!
         if (destroyed) {
-          reportLeaking(reason = "ThingWithLifecycle.destroyed = true")
+          leakingReasons += "ThingWithLifecycle.destroyed = true"
         }
       }
     })
@@ -69,7 +136,13 @@ val analysis = heapAnalyzer.checkForLeaks(
 println(analysis)
 ```
 
-### Generating an Android heap analysis report with shark-android
+### Generating an Android heap analysis report
+
+```groovy
+dependencies {
+  implementation 'com.squareup.leakcanary:shark-android:$sharkVersion'
+}
+```
 
 
 ```kotlin
diff --git a/docs/upgrading-to-leakcanary-2.0.md b/docs/upgrading-to-leakcanary-2.0.md
index 480b6745..48221383 100644
--- a/docs/upgrading-to-leakcanary-2.0.md
+++ b/docs/upgrading-to-leakcanary-2.0.md
@@ -15,7 +15,7 @@ dependencies {
 
 ```groovy
 dependencies {
-  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-2'
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-beta-1'
 }
 ```
 
@@ -24,8 +24,8 @@ dependencies {
 * The `leakcanary-android-no-op` artifact is gone. If you have compile errors, see below.
   * **Question**: if there's no no-op anymore, how do I ensure none of this runs during release builds?
   * **Answer**: as long as you add `leakcanary-android` as `debugImplementation`, there won't be any code referencing LeakCanary in your release builds.
-* LeakCanary now **depends on AndroidX** instead of the support library.
-* Detection of AndroidX fragments is now automatic if you have the AndroidX fragments dependency.
+* LeakCanary does not depend on the support library anymore, and it doesn't depend on AndroidX either.
+* Detection of AndroidX fragments is automatic if you have the AndroidX fragments dependency.
 
 ## Default setup code
 
@@ -61,58 +61,58 @@ There is no more code for default setup.
 ### Before
 
 ```kotlin
-val refWatcher = LeakCanary.installedRefWatcher()
+val refWatcher: RefWatcher = LeakCanary.installedRefWatcher()
 ```
 
 ### Now
 
 ```kotlin
-val refWatcher = LeakSentry.refWatcher
+val objectWatcher: ObjectWatcher = AppWatcher.objectWatcher
 ```
 
 ## Compile errors because RefWatcher is used in release code
 
-If you were using `RefWatcher` in non debug code, you now get a compile error because the no-op artifact is gone. `RefWatcher` now lives in the `leaksentry` artifact, which is suitable for production. You have two options:
+If you were using `RefWatcher` in non debug code, you now get a compile error because the no-op artifact is gone. [ObjectWatcher](/api/leakcanary-object-watcher/leakcanary/-object-watcher/) now lives in the `object-watcher` artifact, which is suitable for production. You have two options:
 
-### Option 1: Add `leaksentry` to release builds.
+### Option 1: Add `object-watcher-android` to release builds.
 
 ```groovy
 dependencies {
-  implementation 'com.squareup.leakcanary:leaksentry:2.0-alpha-2'
+  implementation 'com.squareup.leakcanary:object-watcher-android:2.0-beta-1'
 }
 ```
 
-* It will automatically keep weak references on activities, fragments, and any instance you pass to `RefWatcher`.
+* It will automatically keep weak references to destroyed activities, fragments, and any instance you pass to [AppWatcher.objectWatcher](/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/object-watcher/).
 * It will not trigger heap dumps or anything else that LeakCanary does.
 * It's very little code and should have a no impact on your release app.
-* You can use it to count how many instances are retained, for instance to add metadata to OutOfMemoryError crashes:
+* You can use it to count how many objects are retained, for example to add metadata to OutOfMemoryError crashes:
 
 ```kotlin
-val retainedInstanceCount = LeakSentry.refWatcher.retainedInstanceCount
+val retainedObjectCount = AppWatcher.objectWatcher.retainedObjectCount
 ```
 
-### Option 2: Make your own `RefWatcher` interface
+### Option 2: Make your own `ObjectWatcher` interface
 
 ```kotlin
 // In shared code
-interface MaybeRefWatcher {
-  fun watch(watchedInstance: Any)
+interface MaybeObjectWatcher {
+  fun watch(watchedObject: Any)
 
-  object None : MaybeRefWatcher {
-    override fun watch(watchedInstance: Any) {
+  object None : MaybeObjectWatcher {
+    override fun watch(watchedObject: Any) {
     }
   }
 }
 
 // In debug code
-class RealRefWatcher : MaybeRefWatcher {
-  override fun watch(watchedInstance: Any) {
-    LeakSentry.refWatcher.watch(watchedInstance)
+class RealObjectWatcher : MaybeObjectWatcher {
+  override fun watch(watchedObject: Any) {
+    AppWatcher.objectWatcher.watch(watchedObject)
   }
 }
 ```
 
-Use MaybeRefWatcher.None in release code and RealRefWatcher in debug code.
+Use `MaybeObjectWatcher.None` in release code and `RealObjectWatcher` in debug code.
 
 ## Configuring LeakCanary
 
@@ -131,18 +131,19 @@ public class DebugExampleApplication extends ExampleApplication {
 
 ### Now
 
-LeakSentry is in charge of detecting memory leaks. Its configuration can be updated at any time by replacing `LeakSentry.config`:
+AppWatcher is in charge of detecting retained objects. Its configuration can be updated at any time by replacing [AppWatcher.config](/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/config/):
+
 ```kotlin
 class DebugExampleApplication : ExampleApplication() {
 
   override fun onCreate() {
     super.onCreate()
-    LeakSentry.config = LeakSentry.config.copy(watchFragmentViews = false)
+    AppWatcher.config = AppWatcher.config.copy(watchFragmentViews = false)
   }
 }
 ```
 
-LeakCanary is in charge of taking heap dumps and analyzing them. Its configuration can be updated at any time by replacing `LeakCanary.config`:
+LeakCanary is in charge of taking heap dumps and analyzing them. Its configuration can be updated at any time by replacing [LeakCanary.config](/api/leakcanary-android-core/leakcanary/-leak-canary/config/):
 
 ```kotlin
 disableLeakCanaryButton.setOnClickListener {
@@ -236,21 +237,36 @@ RefWatcher refWatcher = LeakCanary.refWatcher(this)
 ### Now
 
 ```Kotlin
-LeakCanary.config = LeakCanary.config.copy(
-    analysisResultListener = { application, heapAnalysis ->
-      // TODO Upload result to server
-      DefaultAnalysisResultListener(application, heapAnalysis)
-    }
-)
+class LeakUploader : OnHeapAnalyzedListener {
+
+  val defaultListener = DefaultOnHeapAnalyzedListener.create()
+
+  override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {
+    TODO("Upload heap analysis to server")
+
+    // Delegate to default behavior (notification and saving result)
+    defaultListener.onHeapAnalyzed(heapAnalysis)
+  }
+}
+
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakCanary.config = LeakCanary.config.copy(
+        onHeapAnalyzedListener = LeakUploader()
+    )
+  }
+}
 ```
 
-### Marking known framework leaks as won't fix
+### Matching known library leaks
 
 ### Before
 
 ```java
 ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults()
-    .instanceField("com.example.ExampleClass", "exampleField")
+    .staticField("com.samsing.SomeSingleton", "sContext")
     .build();
 RefWatcher refWatcher = LeakCanary.refWatcher(this)
   .excludedRefs(excludedRefs)
@@ -262,16 +278,11 @@ RefWatcher refWatcher = LeakCanary.refWatcher(this)
 
 ```kotlin
 LeakCanary.config = LeakCanary.config.copy(
-  exclusionsFactory = { parser ->
-    val build = BuildMirror.readFromHprof(parser)
-    val exclusions =
-      AndroidExcludedRefs.exclusionsMatchingBuild(AndroidExcludedRefs.appDefaults, build)
-          .toMutableList()
-    exclusions += Exclusion(
-        type = InstanceFieldExclusion("com.example.ExampleClass", "exampleField")
-    )
-    exclusions
-  }
+    referenceMatchers = AndroidReferenceMatchers.appDefaults +
+        AndroidReferenceMatchers.staticFieldLeak(
+            "com.samsing.SomeSingleton",
+            "sContext"
+        )
 )
 ```
 
diff --git a/leakcanary-android-core/consumer-proguard-rules.pro b/leakcanary-android-core/consumer-proguard-rules.pro
index 48ffcc28..72f9d6c5 100644
--- a/leakcanary-android-core/consumer-proguard-rules.pro
+++ b/leakcanary-android-core/consumer-proguard-rules.pro
@@ -1,9 +1,6 @@
--dontwarn com.squareup.haha.guava.**
--dontwarn com.squareup.haha.perflib.**
--dontwarn com.squareup.haha.trove.**
--dontwarn com.squareup.leakcanary.**
--keep class com.squareup.haha.** { *; }
--keep class com.squareup.leakcanary.** { *; }
-
+# Loaded via reflection & referenced by shark.AndroidReferenceMatchers.LEAK_CANARY_INTERNAL
+-keep class leakcanary.internal.InternalLeakCanary { *; }
+# Referenced by shark.AndroidReferenceMatchers.LEAK_CANARY_HEAP_DUMPER
+-keep class leakcanary.internal.AndroidHeapDumper { *; }
 # Marshmallow removed Notification.setLatestEventInfo()
 -dontwarn android.app.Notification
diff --git a/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt b/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
index bb7dd5b6..74eec268 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
@@ -2,6 +2,7 @@ package leakcanary
 
 import android.app.Application
 import com.squareup.leakcanary.core.R
+import leakcanary.internal.InternalLeakCanary
 import leakcanary.internal.NotificationType.LEAKCANARY_RESULT
 import leakcanary.internal.Notifications
 import leakcanary.internal.activity.LeakActivity
@@ -71,4 +72,9 @@ class DefaultOnHeapAnalyzedListener(private val application: Application) : OnHe
         LEAKCANARY_RESULT
     )
   }
+
+  companion object {
+    fun create(): OnHeapAnalyzedListener =
+      DefaultOnHeapAnalyzedListener(InternalLeakCanary.application)
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
index d2174f6d..43175756 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -5,10 +5,10 @@ import leakcanary.LeakCanary.config
 import leakcanary.internal.InternalLeakCanary
 import shark.AndroidObjectInspectors
 import shark.AndroidReferenceMatchers
-import shark.ObjectInspector
-import shark.ReferenceMatcher
 import shark.IgnoredReferenceMatcher
 import shark.LibraryLeakReferenceMatcher
+import shark.ObjectInspector
+import shark.ReferenceMatcher
 
 /**
  * The entry point API for LeakCanary. LeakCanary builds on top of [AppWatcher]. AppWatcher
@@ -89,9 +89,7 @@ object LeakCanary {
      *
      * Defaults to [DefaultOnHeapAnalyzedListener]
      */
-    val onHeapAnalyzedListener: OnHeapAnalyzedListener = DefaultOnHeapAnalyzedListener(
-        InternalLeakCanary.application
-    ),
+    val onHeapAnalyzedListener: OnHeapAnalyzedListener = DefaultOnHeapAnalyzedListener.create(),
 
     /**
      * Whether to compute the retained heap size, which is the total number of bytes in memory that
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
index 059da4fc..7e490e4a 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
@@ -178,10 +178,10 @@ internal class DisplayLeakAdapter constructor(
 
     htmlString += "<br>"
 
-    val reachabilityString = when (element.leakStatusAndReason.status) {
+    val reachabilityString = when (element.leakStatus) {
       UNKNOWN -> "UNKNOWN"
-      NOT_LEAKING -> "NO (${element.leakStatusAndReason.reason})"
-      LEAKING -> "YES (${element.leakStatusAndReason.reason})"
+      NOT_LEAKING -> "NO (${element.leakStatusReason})"
+      LEAKING -> "YES (${element.leakStatusReason})"
     }
 
     val indentation = "&nbsp;".repeat(4)
@@ -224,23 +224,23 @@ internal class DisplayLeakAdapter constructor(
         return START_LAST_REACHABLE
       }
       val nextReachability = leakTrace.elements[elementIndex(position + 1)]
-      return if (nextReachability.leakStatusAndReason.status != NOT_LEAKING) {
+      return if (nextReachability.leakStatus != NOT_LEAKING) {
         START_LAST_REACHABLE
       } else START
     } else {
       val isLeakingInstance = position == count - 1
       if (isLeakingInstance) {
         val previousReachability = leakTrace.elements[elementIndex(position - 1)]
-        return if (previousReachability.leakStatusAndReason.status != LEAKING) {
+        return if (previousReachability.leakStatus != LEAKING) {
           END_FIRST_UNREACHABLE
         } else END
       } else {
         val reachability = leakTrace.elements[elementIndex(position)]
-        when (reachability.leakStatusAndReason.status) {
+        when (reachability.leakStatus) {
           UNKNOWN -> return NODE_UNKNOWN
           NOT_LEAKING -> {
             val nextReachability = leakTrace.elements[elementIndex(position + 1)]
-            return if (nextReachability.leakStatusAndReason.status != NOT_LEAKING) {
+            return if (nextReachability.leakStatus != NOT_LEAKING) {
               NODE_LAST_REACHABLE
             } else {
               NODE_REACHABLE
@@ -248,14 +248,14 @@ internal class DisplayLeakAdapter constructor(
           }
           LEAKING -> {
             val previousReachability = leakTrace.elements[elementIndex(position - 1)]
-            return if (previousReachability.leakStatusAndReason.status != LEAKING) {
+            return if (previousReachability.leakStatus != LEAKING) {
               NODE_FIRST_UNREACHABLE
             } else {
               NODE_UNREACHABLE
             }
           }
           else -> throw IllegalStateException(
-              "Unknown value: " + reachability.leakStatusAndReason.status
+              "Unknown value: " + reachability.leakStatus
           )
         }
       }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
index bd311184..f5acbf15 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
@@ -58,7 +58,7 @@ internal class HeapAnalyzerService : ForegroundService(
 
 
     val heapAnalysis =
-      heapAnalyzer.checkForLeaks(
+      heapAnalyzer.analyze(
           heapDumpFile, config.referenceMatchers, config.computeRetainedHeapSize, config.objectInspectors,
           if (config.useExperimentalLeakFinders) config.objectInspectors else listOf(
               ObjectInspectors.KEYED_WEAK_REFERENCE
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
index 72fac8d8..774a732a 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
@@ -210,9 +210,9 @@ internal object LeakingInstanceTable {
                   if (reference.type == ARRAY_ENTRY) {
                     // No array index in groups
                     element =
-                      element.copy(reference = reference.copy(name = "x"), labels = emptyList())
+                      element.copy(reference = reference.copy(name = "x"), labels = emptySet(), leakStatusReason = "")
                   } else {
-                    element = element.copy(labels = emptyList())
+                    element = element.copy(labels = emptySet(), leakStatusReason = "")
                   }
 
                   elements.add(element)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
index dafa91ec..aed738d9 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
@@ -26,6 +26,6 @@ internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
 
   companion object {
     // Last updated for next after 2.0-alpha-3
-    private const val VERSION = 15
+    private const val VERSION = 16
   }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
index edb1dc26..46f8dd18 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
@@ -16,7 +16,7 @@ import leakcanary.internal.activity.ui.SimpleListAdapter
 import leakcanary.internal.navigation.Screen
 import leakcanary.internal.navigation.activity
 import leakcanary.internal.navigation.inflate
-import shark.HeapClassField
+import shark.HeapField
 import shark.HprofHeapGraph
 import shark.HeapObject.HeapClass
 import shark.HeapObject.HeapInstance
@@ -269,7 +269,7 @@ internal class HprofExplorerScreen(
     }
   }
 
-  private fun Sequence<HeapClassField>.fieldsAsString(): List<Pair<HeapClassField, String>> {
+  private fun Sequence<HeapField>.fieldsAsString(): List<Pair<HeapField, String>> {
     return map { field ->
       field to "${field.declaringClass.simpleName}.${field.name} = ${field.value.heapValueAsString()}"
     }
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
index 9f250f32..6705c5cf 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
@@ -166,7 +166,7 @@ class InstrumentationLeakDetector {
     val listener = shark.OnAnalysisProgressListener.NO_OP
 
     val heapAnalyzer = HeapAnalyzer(listener)
-    val heapAnalysis = heapAnalyzer.checkForLeaks(
+    val heapAnalysis = heapAnalyzer.analyze(
         heapDumpFile, config.referenceMatchers,
         config.computeRetainedHeapSize,
         config.objectInspectors,
diff --git a/leakcanary-android-sample/build.gradle b/leakcanary-android-sample/build.gradle
index ad05c169..dd517107 100644
--- a/leakcanary-android-sample/build.gradle
+++ b/leakcanary-android-sample/build.gradle
@@ -37,7 +37,16 @@ android {
   }
 
   buildTypes {
-    debug
+    // Build with ./gradlew leakcanary-android-sample:installDebug -Pminify
+    if (project.hasProperty('minify')) {
+      debug {
+        minifyEnabled true
+        proguardFiles getDefaultProguardFile('proguard-android-optimize.txt')
+      }
+    } else {
+      debug
+    }
+
     release
   }
 
diff --git a/leakcanary-object-watcher-android-androidx/build.gradle b/leakcanary-object-watcher-android-androidx/build.gradle
index ba51c308..afa37c48 100644
--- a/leakcanary-object-watcher-android-androidx/build.gradle
+++ b/leakcanary-object-watcher-android-androidx/build.gradle
@@ -13,6 +13,7 @@ android {
   compileSdkVersion versions.compileSdk
   defaultConfig {
     minSdkVersion versions.minSdk
+    consumerProguardFiles 'consumer-proguard-rules.pro'
   }
   lintOptions {
     disable 'GoogleAppIndexingWarning'
diff --git a/leakcanary-object-watcher-android-androidx/consumer-proguard-rules.pro b/leakcanary-object-watcher-android-androidx/consumer-proguard-rules.pro
new file mode 100644
index 00000000..7f67c8b2
--- /dev/null
+++ b/leakcanary-object-watcher-android-androidx/consumer-proguard-rules.pro
@@ -0,0 +1,2 @@
+# AndroidXFragmentDestroyWatcher is loaded via reflection
+-keep class leakcanary.internal.AndroidXFragmentDestroyWatcher { *; }
diff --git a/leakcanary-object-watcher-android/build.gradle b/leakcanary-object-watcher-android/build.gradle
index 18fda0be..2ba1e7b4 100644
--- a/leakcanary-object-watcher-android/build.gradle
+++ b/leakcanary-object-watcher-android/build.gradle
@@ -12,6 +12,7 @@ android {
 
   defaultConfig {
     minSdkVersion versions.minSdk
+    consumerProguardFiles 'consumer-proguard-rules.pro'
   }
 
   lintOptions {
diff --git a/leakcanary-object-watcher-android/consumer-proguard-rules.pro b/leakcanary-object-watcher-android/consumer-proguard-rules.pro
new file mode 100644
index 00000000..04653f44
--- /dev/null
+++ b/leakcanary-object-watcher-android/consumer-proguard-rules.pro
@@ -0,0 +1,4 @@
+# A ContentProvider that gets created by Android on startup
+-keep class leakcanary.internal.AppWatcherInstaller { <init>(); }
+# KeyedWeakReference is looked up in the hprof file
+-keep class leakcanary.KeyedWeakReference { *; }
diff --git a/shark-android/src/main/java/shark/AndroidObjectInspectors.kt b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
index fd9c4863..2d963441 100644
--- a/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
+++ b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
@@ -49,59 +49,60 @@ enum class AndroidObjectInspectors : ObjectInspector {
         val mContext = instance["android.view.View", "mContext"]!!.value.asObject!!.asInstance!!
 
         val activityContext = mContext.unwrapActivityContext()
-        if (activityContext == null) {
-          addLabel("mContext instance of ${mContext.instanceClassName}, not wrapping activity")
+        labels += if (activityContext == null) {
+          "mContext instance of ${mContext.instanceClassName}, not wrapping activity"
         } else {
           val activityDescription =
-            " with mDestroyed = " + (activityContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean?.toString()
+            "with mDestroyed = " + (activityContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean?.toString()
                 ?: "UNKNOWN")
           if (activityContext == mContext) {
-            addLabel(
-                "mContext instance of ${activityContext.instanceClassName} $activityDescription"
-            )
+            "mContext instance of ${activityContext.instanceClassName} $activityDescription"
           } else {
-            addLabel(
-                "mContext instance of ${mContext.instanceClassName}, wrapping activity ${activityContext.instanceClassName} $activityDescription"
-            )
+            "mContext instance of ${mContext.instanceClassName}, wrapping activity ${activityContext.instanceClassName} $activityDescription"
           }
         }
-
-        addLabel("mContext = ${mContext.instanceClassName}")
-
         if (activityContext != null && activityContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean == true) {
-          reportLeaking("View.mContext references a destroyed activity")
+          leakingReasons += "View.mContext references a destroyed activity"
         } else {
           if (mParentSet && mWindowAttachCount > 0) {
             if (viewDetached) {
-              reportLikelyLeaking("View detached and has parent")
+              likelyLeakingReasons += "View detached and has parent"
             } else {
               val viewParent = mParentRef.asObject!!.asInstance!!
               if (viewParent instanceOf "android.view.View" &&
                   viewParent["android.view.View", "mAttachInfo"]!!.value.isNullReference
               ) {
-                reportLikelyLeaking("View attached but parent detached (attach disorder)")
+                likelyLeakingReasons += "View attached but parent detached (attach disorder)"
               } else {
-                reportNotLeaking("View attached")
+                notLeakingReasons += "View attached"
               }
             }
           }
         }
 
         if (mParentSet) {
-          addLabel("View#mParent is set")
+          labels += "View#mParent is set"
         } else {
-          addLabel("View#mParent is null")
+          labels += "View#mParent is null"
         }
 
         if (viewDetached) {
-          addLabel("View#mAttachInfo is null (view detached)")
+          labels += "View#mAttachInfo is null (view detached)"
         } else {
-          addLabel("View#mAttachInfo is not null (view attached)")
+          labels += "View#mAttachInfo is not null (view attached)"
         }
 
         // TODO Add back support for view id labels, see https://github.com/square/leakcanary/issues/1297
 
-        addLabel("View.mWindowAttachCount = $mWindowAttachCount")
+        labels += "View.mWindowAttachCount = $mWindowAttachCount"
+      }
+    }
+  },
+
+  EDITOR {
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("android.widget.Editor") { instance ->
+        applyFromField(VIEW, instance["android.widget.Editor", "mTextView"])
       }
     }
   },
@@ -118,9 +119,9 @@ enum class AndroidObjectInspectors : ObjectInspector {
 
         if (field != null) {
           if (field.value.asBoolean!!) {
-            reportLeaking(field describedWithValue "true")
+            leakingReasons += field describedWithValue "true"
           } else {
-            reportNotLeaking(field describedWithValue "false")
+            notLeakingReasons += field describedWithValue "false"
           }
         }
       }
@@ -136,20 +137,18 @@ enum class AndroidObjectInspectors : ObjectInspector {
         if (!(instance instanceOf "android.app.Activity")) {
           val activityContext = instance.unwrapActivityContext()
           if (activityContext != null) {
-            val mDestroyed = instance["android.app.Activity", "mDestroyed"]
+            val mDestroyed = activityContext["android.app.Activity", "mDestroyed"]
             if (mDestroyed != null) {
               if (mDestroyed.value.asBoolean!!) {
-                reportLeaking(
-                    "${instance.instanceClassSimpleName} wraps an Activity with Activity.mDestroyed true"
-                )
+                leakingReasons += "${instance.instanceClassSimpleName} wraps an Activity with Activity.mDestroyed true"
               } else {
                 // We can't assume it's not leaking, because this context might have a shorter lifecycle
                 // than the activity. So we'll just add a label.
-                addLabel(
-                    "${instance.instanceClassSimpleName} wraps an Activity with Activity.mDestroyed false"
-                )
+                labels += "${instance.instanceClassSimpleName} wraps an Activity with Activity.mDestroyed false"
               }
             }
+          } else {
+            labels += "${instance.instanceClassSimpleName} does not wrap an activity context"
           }
         }
       }
@@ -163,9 +162,9 @@ enum class AndroidObjectInspectors : ObjectInspector {
       reporter.whenInstanceOf("android.app.Dialog") { instance ->
         val mDecor = instance["android.app.Dialog", "mDecor"]!!
         if (mDecor.value.isNullReference) {
-          reportLeaking(mDecor describedWithValue "null")
+          leakingReasons += mDecor describedWithValue "null"
         } else {
-          reportNotLeaking(mDecor describedWithValue "not null")
+          notLeakingReasons += mDecor describedWithValue "not null"
         }
       }
     }
@@ -176,7 +175,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
       reporter: ObjectReporter
     ) {
       reporter.whenInstanceOf("android.app.Application") {
-        reportNotLeaking("Application is a singleton")
+        notLeakingReasons += "Application is a singleton"
       }
     }
   },
@@ -186,7 +185,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
       reporter: ObjectReporter
     ) {
       reporter.whenInstanceOf("android.view.inputmethod.InputMethodManager") {
-        reportNotLeaking("InputMethodManager is a singleton")
+        notLeakingReasons += "InputMethodManager is a singleton"
       }
     }
   },
@@ -198,13 +197,13 @@ enum class AndroidObjectInspectors : ObjectInspector {
       reporter.whenInstanceOf("android.app.Fragment") { instance ->
         val fragmentManager = instance["android.app.Fragment", "mFragmentManager"]!!
         if (fragmentManager.value.isNullReference) {
-          reportLeaking(fragmentManager describedWithValue "null")
+          leakingReasons += fragmentManager describedWithValue "null"
         } else {
-          reportNotLeaking(fragmentManager describedWithValue "not null")
+          notLeakingReasons += fragmentManager describedWithValue "not null"
         }
         val mTag = instance["android.app.Fragment", "mTag"]?.value?.readAsJavaString()
         if (!mTag.isNullOrEmpty()) {
-          addLabel("Fragment.mTag=$mTag")
+          labels += "Fragment.mTag=$mTag"
         }
       }
     }
@@ -217,13 +216,13 @@ enum class AndroidObjectInspectors : ObjectInspector {
       reporter.whenInstanceOf("android.support.v4.app.Fragment") { instance ->
         val fragmentManager = instance["android.support.v4.app.Fragment", "mFragmentManager"]!!
         if (fragmentManager.value.isNullReference) {
-          reportLeaking(fragmentManager describedWithValue "null")
+          leakingReasons += fragmentManager describedWithValue "null"
         } else {
-          reportNotLeaking(fragmentManager describedWithValue "not null")
+          notLeakingReasons += fragmentManager describedWithValue "not null"
         }
         val mTag = instance["android.support.v4.app.Fragment", "mTag"]?.value?.readAsJavaString()
         if (!mTag.isNullOrEmpty()) {
-          addLabel("Fragment.mTag=$mTag")
+          labels += "Fragment.mTag=$mTag"
         }
       }
     }
@@ -236,13 +235,13 @@ enum class AndroidObjectInspectors : ObjectInspector {
       reporter.whenInstanceOf("androidx.fragment.app.Fragment") { instance ->
         val fragmentManager = instance["androidx.fragment.app.Fragment", "mFragmentManager"]!!
         if (fragmentManager.value.isNullReference) {
-          reportLeaking(fragmentManager describedWithValue "null")
+          leakingReasons += fragmentManager describedWithValue "null"
         } else {
-          reportNotLeaking(fragmentManager describedWithValue "not null")
+          notLeakingReasons += fragmentManager describedWithValue "not null"
         }
         val mTag = instance["androidx.fragment.app.Fragment", "mTag"]?.value?.readAsJavaString()
         if (!mTag.isNullOrEmpty()) {
-          addLabel("Fragment.mTag=$mTag")
+          labels += "Fragment.mTag=$mTag"
         }
       }
     }
@@ -258,9 +257,9 @@ enum class AndroidObjectInspectors : ObjectInspector {
         val mQuitting = instance["android.os.MessageQueue", "mQuitting"]
             ?: instance["android.os.MessageQueue", "mQuiting"]!!
         if (mQuitting.value.asBoolean!!) {
-          reportLeaking(mQuitting describedWithValue "true")
+          leakingReasons += mQuitting describedWithValue "true"
         } else {
-          reportNotLeaking(mQuitting describedWithValue "false")
+          notLeakingReasons += mQuitting describedWithValue "false"
         }
       }
     }
@@ -276,7 +275,23 @@ enum class AndroidObjectInspectors : ObjectInspector {
         // when the view is null, we're pretty sure they  never leaking.
         val view = instance["mortar.Presenter", "view"]!!
         if (view.value.isNullReference) {
-          reportLeaking(view describedWithValue "null")
+          leakingReasons += view describedWithValue "null"
+        } else {
+          labels += view describedWithValue "set"
+        }
+      }
+    }
+  },
+
+  MORTAR_SCOPE {
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("mortar.MortarScope") { instance ->
+        val dead = instance["mortar.MortarScope", "dead"]!!.value.asBoolean!!
+        val scopeName = instance["mortar.MortarScope", "name"]!!.value.readAsJavaString()
+        if (dead) {
+          leakingReasons += "mortar.MortarScope.dead is true for scope $scopeName"
+        } else {
+          notLeakingReasons += "mortar.MortarScope.dead is false for scope $scopeName"
         }
       }
     }
@@ -289,9 +304,9 @@ enum class AndroidObjectInspectors : ObjectInspector {
       reporter.whenInstanceOf("com.squareup.coordinators.Coordinator") { instance ->
         val attached = instance["com.squareup.coordinators.Coordinator", "attached"]
         if (attached!!.value.asBoolean!!) {
-          reportNotLeaking(attached describedWithValue "true")
+          notLeakingReasons += attached describedWithValue "true"
         } else {
-          reportLeaking(attached describedWithValue "false")
+          leakingReasons += attached describedWithValue "false"
         }
       }
     }
@@ -304,7 +319,20 @@ enum class AndroidObjectInspectors : ObjectInspector {
       reporter.whenInstanceOf(Thread::class) { instance ->
         val threadName = instance[Thread::class, "name"]!!.value.readAsJavaString()
         if (threadName == "main") {
-          reportNotLeaking("the main thread always runs")
+          notLeakingReasons += "the main thread always runs"
+        }
+      }
+    }
+  },
+
+  VIEW_ROOT_IMPL {
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("android.view.ViewRootImpl") { instance ->
+        val mViewField = instance["android.view.ViewRootImpl", "mView"]!!
+        if (mViewField.value.isNullReference) {
+          leakingReasons += mViewField describedWithValue "null"
+        } else {
+          notLeakingReasons += mViewField describedWithValue "not null"
         }
       }
     }
@@ -318,9 +346,9 @@ enum class AndroidObjectInspectors : ObjectInspector {
         val mDestroyed = instance["android.view.Window", "mDestroyed"]!!
 
         if (mDestroyed.value.asBoolean!!) {
-          reportLeaking(mDestroyed describedWithValue "true")
+          leakingReasons += mDestroyed describedWithValue "true"
         } else {
-          reportNotLeaking(mDestroyed describedWithValue "false")
+          notLeakingReasons += mDestroyed describedWithValue "false"
         }
       }
     }
@@ -338,13 +366,9 @@ enum class AndroidObjectInspectors : ObjectInspector {
         if (tnInstance["android.widget.Toast\$TN", "mWM"]!!.value.isNonNullReference) {
           // mView is reset to null in android.widget.Toast.TN#handleHide
           if (tnInstance["android.widget.Toast\$TN", "mView"]!!.value.isNullReference) {
-            reportLeaking(
-                "This toast is done showing (Toast.mTN.mWM != null && Toast.mTN.mView == null)"
-            )
+            leakingReasons += "This toast is done showing (Toast.mTN.mWM != null && Toast.mTN.mView == null)"
           } else {
-            reportNotLeaking(
-                "This toast is showing (Toast.mTN.mWM != null && Toast.mTN.mView != null)"
-            )
+            notLeakingReasons += "This toast is showing (Toast.mTN.mWM != null && Toast.mTN.mView != null)"
           }
         }
       }
@@ -360,10 +384,31 @@ enum class AndroidObjectInspectors : ObjectInspector {
   }
 }
 
-private infix fun HeapClassField.describedWithValue(valueDescription: String): String {
+private infix fun HeapField.describedWithValue(valueDescription: String): String {
   return "${declaringClass.simpleName}#$name is $valueDescription"
 }
 
+private fun ObjectReporter.applyFromField(
+  inspector: ObjectInspector,
+  field: HeapField?
+) {
+  if (field == null) {
+    return
+  }
+  if (field.value.isNullReference) {
+    return
+  }
+  val heapObject = field.value.asObject!!
+  val delegateReporter = ObjectReporter(heapObject)
+  inspector.inspect(delegateReporter)
+  val prefix = "${field.declaringClass.simpleName}#${field.name}:"
+
+  labels += delegateReporter.labels.map { "$prefix $it" }
+  leakingReasons += delegateReporter.leakingReasons.map { "$prefix $it" }
+  likelyLeakingReasons += delegateReporter.likelyLeakingReasons.map { "$prefix $it" }
+  notLeakingReasons += delegateReporter.notLeakingReasons.map { "$prefix $it" }
+}
+
 /**
  * Recursively unwraps `this` [HeapInstance] as a ContextWrapper until an Activity is found in which case it is
  * returned. Returns null if no activity was found.
@@ -382,14 +427,29 @@ fun HeapInstance.unwrapActivityContext(): HeapInstance? {
       val mBase = context["android.content.ContextWrapper", "mBase"]!!.value
 
       if (mBase.isNonNullReference) {
+        var parentContext = context
         context = mBase.asObject!!.asInstance!!
         if (context instanceOf "android.app.Activity") {
           return context
-        } else if (context instanceOf "android.content.ContextWrapper" &&
-            // Avoids infinite loops
-            context.objectId !in visitedInstances
-        ) {
-          keepUnwrapping = true
+        } else {
+          if (parentContext instanceOf "com.android.internal.policy.DecorContext") {
+            // mBase isn't an activity, let's unwrap DecorContext.mPhoneWindow.mContext instead
+            val mPhoneWindowField =
+              parentContext["com.android.internal.policy.DecorContext", "mPhoneWindow"]
+            if (mPhoneWindowField != null) {
+              val phoneWindow = mPhoneWindowField.valueAsInstance!!
+              context = phoneWindow["android.view.Window", "mContext"]!!.valueAsInstance!!
+              if (context instanceOf "android.app.Activity") {
+                return context
+              }
+            }
+          }
+          if (context instanceOf "android.content.ContextWrapper" &&
+              // Avoids infinite loops
+              context.objectId !in visitedInstances
+          ) {
+            keepUnwrapping = true
+          }
         }
       }
     }
diff --git a/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt b/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
index 28e4bfda..a25e3376 100644
--- a/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
+++ b/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
@@ -17,8 +17,6 @@ package shark
 
 import shark.AndroidReferenceMatchers.Companion.appDefaults
 import shark.AndroidReferenceMatchers.Companion.buildKnownReferences
-import shark.IgnoredReferenceMatcher
-import shark.LibraryLeakReferenceMatcher
 import shark.ReferencePattern.InstanceFieldPattern
 import shark.ReferencePattern.JavaLocalPattern
 import shark.ReferencePattern.StaticFieldPattern
@@ -971,7 +969,7 @@ enum class AndroidReferenceMatchers {
     }
   },
 
-  ANDROID_HEAP_DUMPER {
+  LEAK_CANARY_HEAP_DUMPER {
     override fun add(references: MutableList<ReferenceMatcher>) {
       // Holds on to the resumed activity (which is never destroyed), so this will not cause leaks
       // but may surface on the path when a resumed activity holds on to destroyed objects.
@@ -980,6 +978,12 @@ enum class AndroidReferenceMatchers {
     }
   },
 
+  LEAK_CANARY_INTERNAL {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += ignoredInstanceField("leakcanary.internal.InternalLeakCanary", "application")
+    }
+  },
+
   EVENT_RECEIVER__MMESSAGE_QUEUE {
     override fun add(
       references: MutableList<ReferenceMatcher>
diff --git a/shark-android/src/test/java/shark/LegacyHprofTest.kt b/shark-android/src/test/java/shark/LegacyHprofTest.kt
index c3d88fc2..cba552da 100644
--- a/shark-android/src/test/java/shark/LegacyHprofTest.kt
+++ b/shark-android/src/test/java/shark/LegacyHprofTest.kt
@@ -2,6 +2,10 @@ package shark
 
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Test
+import shark.LeakNodeStatus.LEAKING
+import shark.LegacyHprofTest.WRAPS_ACTIVITY.DESTROYED
+import shark.LegacyHprofTest.WRAPS_ACTIVITY.NOT_ACTIVITY
+import shark.LegacyHprofTest.WRAPS_ACTIVITY.NOT_DESTROYED
 import java.io.File
 
 class LegacyHprofTest {
@@ -11,8 +15,8 @@ class LegacyHprofTest {
     assertThat(analysis.applicationLeaks).hasSize(2)
     val leak1 = analysis.applicationLeaks[0]
     val leak2 = analysis.applicationLeaks[1]
-    assertThat(leak1.className).isEqualTo("com.example.leakcanary.MainActivity")
-    assertThat(leak2.className).isEqualTo("android.graphics.Bitmap")
+    assertThat(leak1.className).isEqualTo("android.graphics.Bitmap")
+    assertThat(leak2.className).isEqualTo("com.example.leakcanary.MainActivity")
   }
 
   @Test fun androidM() {
@@ -21,20 +25,30 @@ class LegacyHprofTest {
     assertThat(analysis.applicationLeaks).hasSize(1)
     val leak = analysis.applicationLeaks[0]
     assertThat(leak.className).isEqualTo("com.example.leakcanary.MainActivity")
-    assertThat(leak.leakTrace.elements[0].labels).contains("Thread name: 'AsyncTask #1'")
+    assertThat(leak.leakTrace.elements[0].labels).contains("GC Root: System class")
   }
 
   @Test fun androidMStripped() {
     val stripper = HprofPrimitiveArrayStripper()
-    val strippedHprof =
-      stripper.stripPrimitiveArrays(fileFromResources("leak_asynctask_m.hprof"))
+    val sourceHprof = fileFromResources("leak_asynctask_m.hprof")
+    val strippedHprof = stripper.stripPrimitiveArrays(sourceHprof)
 
-    val analysis = analyzeHprof(strippedHprof)
+    assertThat(readThreadNames(sourceHprof)).contains("AsyncTask #1")
+    assertThat(readThreadNames(strippedHprof)).allMatch { threadName ->
+      threadName.all { character -> character == '?' }
+    }
+  }
 
-    assertThat(analysis.applicationLeaks).hasSize(1)
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.className).isEqualTo("com.example.leakcanary.MainActivity")
-    assertThat(leak.leakTrace.elements[0].labels).contains("Thread name: ''")
+  private fun readThreadNames(hprofFile: File): List<String> {
+    val threadNames = Hprof.open(hprofFile)
+        .use { hprof ->
+          val graph = HprofHeapGraph.indexHprof(hprof)
+          graph.findClassByName("java.lang.Thread")!!.instances.map { instance ->
+            instance["java.lang.Thread", "name"]!!.value.readAsJavaString()!!
+          }
+              .toList()
+        }
+    return threadNames
   }
 
   @Test fun androidO() {
@@ -45,6 +59,39 @@ class LegacyHprofTest {
     assertThat(leak.className).isEqualTo("com.example.leakcanary.MainActivity")
   }
 
+  private enum class WRAPS_ACTIVITY {
+    DESTROYED,
+    NOT_DESTROYED,
+    NOT_ACTIVITY
+  }
+
+  @Test fun androidOCountActivityWrappingContexts() {
+    val contextWrapperStatuses = Hprof.open(fileFromResources("leak_asynctask_o.hprof"))
+        .use { hprof ->
+          val graph = HprofHeapGraph.indexHprof(hprof)
+          graph.instances.filter { it instanceOf "android.content.ContextWrapper" && !(it instanceOf "android.app.Activity") }
+              .map { instance ->
+                val reporter = ObjectReporter(instance)
+                AndroidObjectInspectors.CONTEXT_WRAPPER.inspect(reporter)
+                if (reporter.leakingReasons.size == 1) {
+                  DESTROYED
+                } else if (reporter.labels.size == 1) {
+                  if ("Activity.mDestroyed false" in reporter.labels.first()) {
+                    NOT_DESTROYED
+                  } else {
+                    NOT_ACTIVITY
+                  }
+                } else throw IllegalStateException(
+                    "Unexpected, should have 1 leaking status ${reporter.leakingReasons} or one label ${reporter.labels}"
+                )
+              }
+              .toList()
+        }
+    assertThat(contextWrapperStatuses.filter { it == DESTROYED }).hasSize(12)
+    assertThat(contextWrapperStatuses.filter { it == NOT_DESTROYED }).hasSize(6)
+    assertThat(contextWrapperStatuses.filter { it == NOT_ACTIVITY }).hasSize(1)
+  }
+
   @Test fun gcRootInNonPrimaryHeap() {
     val analysis = analyzeHprof("gc_root_in_non_primary_heap.hprof")
 
@@ -66,7 +113,7 @@ class LegacyHprofTest {
 
   private fun analyzeHprof(hprofFile: File): HeapAnalysisSuccess {
     val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
-    val analysis = heapAnalyzer.checkForLeaks(
+    val analysis = heapAnalyzer.analyze(
         hprofFile, AndroidReferenceMatchers.appDefaults, false, AndroidObjectInspectors.appDefaults
     )
     println(analysis)
diff --git a/shark-cli/src/main/java/shark/Main.kt b/shark-cli/src/main/java/shark/Main.kt
index 6db5d618..1b37b366 100644
--- a/shark-cli/src/main/java/shark/Main.kt
+++ b/shark-cli/src/main/java/shark/Main.kt
@@ -1,6 +1,5 @@
 package shark
 
-import shark.OnAnalysisProgressListener.Step
 import java.io.File
 import java.text.SimpleDateFormat
 import java.util.Date
@@ -24,10 +23,22 @@ fun main(args: Array<String>) {
 fun printHelp() {
   val workingDirectory = File(System.getProperty("user.dir"))
 
+  // ASCII art is a remix of a shark from -David "TAZ" Baltazar- and chick from jgs.
   SharkLog.d(
       """
-    LeakCanary CLI
-    Running in directory $workingDirectory
+    Shark CLI, running in directory $workingDirectory
+
+                     ^`.                 .=""=.
+     ^_              \  \               / _  _ \
+     \ \             {   \             |  d  b  |
+     {  \           /     `~~~--__     \   /\   /
+     {   \___----~~'              `~~-_/'-=\/=-'\,
+      \                         /// a  `~.      \ \
+      / /~~~~-, ,__.    ,      ///  __,,,,)      \ |
+      \/      \/    `~~~;   ,---~~-_`/ \        / \/
+                       /   /            '.    .'
+                      '._.'             _|`~~`|_
+                                        /|\  /|\
 
     Commands: [analyze-process, dump-process, analyze-hprof, strip-hprof]
 
@@ -40,7 +51,7 @@ fun printHelp() {
     analyze-hprof: Analyzes the provided hprof file.
       USAGE: analyze-hprof HPROF_FILE_PATH
 
-    strip-hprof: Removes all primitive arrays from the provided hprof file and generates a new "-stripped" hprof file.
+    strip-hprof: Replaces all primitive arrays from the provided hprof file with arrays of zeroes and generates a new "-stripped" hprof file.
       USAGE: strip-hprof HPROF_FILE_PATH
   """.trimIndent()
   )
@@ -132,7 +143,7 @@ private fun analyze(heapDumpFile: File) {
 
   val heapAnalyzer = HeapAnalyzer(listener)
   SharkLog.d("Analyzing heap dump $heapDumpFile")
-  val heapAnalysis = heapAnalyzer.checkForLeaks(
+  val heapAnalysis = heapAnalyzer.analyze(
       heapDumpFile, AndroidReferenceMatchers.appDefaults, true,
       AndroidObjectInspectors.appDefaults
   )
diff --git a/shark-graph/src/main/java/shark/HeapClassField.kt b/shark-graph/src/main/java/shark/HeapField.kt
similarity index 98%
rename from shark-graph/src/main/java/shark/HeapClassField.kt
rename to shark-graph/src/main/java/shark/HeapField.kt
index 9d7b4b5d..e4500c4b 100644
--- a/shark-graph/src/main/java/shark/HeapClassField.kt
+++ b/shark-graph/src/main/java/shark/HeapField.kt
@@ -8,7 +8,7 @@ import shark.HeapObject.HeapPrimitiveArray
 /**
  * Represents a static field or an instance field.
  */
-class HeapClassField(
+class HeapField(
   /**
    * The class this field was declared in.
    */
diff --git a/shark-graph/src/main/java/shark/HeapGraph.kt b/shark-graph/src/main/java/shark/HeapGraph.kt
index 908aa376..82b83966 100644
--- a/shark-graph/src/main/java/shark/HeapGraph.kt
+++ b/shark-graph/src/main/java/shark/HeapGraph.kt
@@ -13,7 +13,8 @@ interface HeapGraph {
    */
   val context: GraphContext
   /**
-   * All GC roots which type matches types known to this heap graph.
+   * All GC roots which type matches types known to this heap graph and which point to non null
+   * references.
    */
   val gcRoots: List<GcRoot>
   /**
diff --git a/shark-graph/src/main/java/shark/HeapObject.kt b/shark-graph/src/main/java/shark/HeapObject.kt
index e7bd9778..82da8f33 100644
--- a/shark-graph/src/main/java/shark/HeapObject.kt
+++ b/shark-graph/src/main/java/shark/HeapObject.kt
@@ -188,14 +188,14 @@ sealed class HeapObject {
     }
 
     /**
-     * The static fields of this class, as a sequence of [HeapClassField].
+     * The static fields of this class, as a sequence of [HeapField].
      *
      * This may trigger IO reads.
      */
-    fun readStaticFields(): Sequence<HeapClassField> {
+    fun readStaticFields(): Sequence<HeapField> {
       return readRecord().staticFields.asSequence()
           .map { fieldRecord ->
-            HeapClassField(
+            HeapField(
                 this, hprofGraph.staticFieldName(fieldRecord),
                 HeapValue(hprofGraph, fieldRecord.value)
             )
@@ -203,7 +203,7 @@ sealed class HeapObject {
     }
 
     /**
-     * Returns a [HeapClassField] object that reflects the specified declared
+     * Returns a [HeapField] object that reflects the specified declared
      * field of the class represented by this [HeapClass] object, or null if this field does not
      * exist. The [name] parameter specifies the simple name of the desired field.
      *
@@ -211,10 +211,10 @@ sealed class HeapObject {
      *
      * This may trigger IO reads.
      */
-    fun readStaticField(fieldName: String): HeapClassField? {
+    fun readStaticField(fieldName: String): HeapField? {
       for (fieldRecord in readRecord().staticFields) {
         if (hprofGraph.staticFieldName(fieldRecord) == fieldName) {
-          return HeapClassField(
+          return HeapField(
               this, hprofGraph.staticFieldName(fieldRecord),
               HeapValue(hprofGraph, fieldRecord.value)
           )
@@ -309,12 +309,12 @@ sealed class HeapObject {
     fun readField(
       declaringClass: KClass<out Any>,
       fieldName: String
-    ): HeapClassField? {
+    ): HeapField? {
       return readField(declaringClass.java.name, fieldName)
     }
 
     /**
-     * Returns a [HeapClassField] object that reflects the specified declared
+     * Returns a [HeapField] object that reflects the specified declared
      * field of the instance represented by this [HeapInstance] object, or null if this field does
      * not exist. The [declaringClassName] specifies the class in which the desired field is
      * declared, and the [fieldName] parameter specifies the simple name of the desired field.
@@ -326,7 +326,7 @@ sealed class HeapObject {
     fun readField(
       declaringClassName: String,
       fieldName: String
-    ): HeapClassField? {
+    ): HeapField? {
       return readFields().firstOrNull { field -> field.declaringClass.name == declaringClassName && field.name == fieldName }
     }
 
@@ -336,7 +336,7 @@ sealed class HeapObject {
     operator fun get(
       declaringClass: KClass<out Any>,
       fieldName: String
-    ): HeapClassField? {
+    ): HeapField? {
       return readField(declaringClass, fieldName)
     }
 
@@ -349,11 +349,11 @@ sealed class HeapObject {
     ) = readField(declaringClassName, fieldName)
 
     /**
-     * The fields of this instance, as a sequence of [HeapClassField].
+     * The fields of this instance, as a sequence of [HeapField].
      *
      * This may trigger IO reads.
      */
-    fun readFields(): Sequence<HeapClassField> {
+    fun readFields(): Sequence<HeapField> {
       val fieldReader by lazy {
         hprofGraph.createFieldValuesReader(readRecord())
       }
@@ -364,7 +364,7 @@ sealed class HeapObject {
                 .map { fieldRecord ->
                   val fieldName = hprofGraph.fieldName(fieldRecord)
                   val fieldValue = fieldReader.readValue(fieldRecord)
-                  HeapClassField(heapClass, fieldName, HeapValue(hprofGraph, fieldValue))
+                  HeapField(heapClass, fieldName, HeapValue(hprofGraph, fieldValue))
                 }
           }
           .flatten()
diff --git a/shark-graph/src/main/java/shark/HeapValue.kt b/shark-graph/src/main/java/shark/HeapValue.kt
index ef2e2d15..b28d8cd6 100644
--- a/shark-graph/src/main/java/shark/HeapValue.kt
+++ b/shark-graph/src/main/java/shark/HeapValue.kt
@@ -1,6 +1,5 @@
 package shark
 
-import shark.HeapObject.HeapInstance
 import shark.ValueHolder.BooleanHolder
 import shark.ValueHolder.ByteHolder
 import shark.ValueHolder.CharHolder
diff --git a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
index 2b6976a8..70cd1a6f 100644
--- a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
+++ b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
@@ -29,6 +29,7 @@ import shark.HprofRecord.LoadClassRecord
 import shark.HprofRecord.StringRecord
 import shark.OnHprofRecordListener
 import shark.PrimitiveType
+import shark.ValueHolder
 import shark.internal.IndexedObject.IndexedClass
 import shark.internal.IndexedObject.IndexedInstance
 import shark.internal.IndexedObject.IndexedObjectArray
@@ -149,7 +150,7 @@ internal class HprofInMemoryIndex private constructor(
         }
         is GcRootRecord -> {
           val gcRoot = record.gcRoot
-          if (gcRoot.id != 0L && gcRoot::class in indexedGcRootsTypes) {
+          if (gcRoot.id != ValueHolder.NULL_REFERENCE && gcRoot::class in indexedGcRootsTypes) {
             gcRoots += gcRoot
           }
         }
diff --git a/shark-graph/src/test/java/shark/HprofPrimitiveArrayStripperTest.kt b/shark-graph/src/test/java/shark/HprofPrimitiveArrayStripperTest.kt
index cb2b9fb4..86ea4a39 100644
--- a/shark-graph/src/test/java/shark/HprofPrimitiveArrayStripperTest.kt
+++ b/shark-graph/src/test/java/shark/HprofPrimitiveArrayStripperTest.kt
@@ -39,7 +39,7 @@ class HprofPrimitiveArrayStripperTest {
           .toList()
       assertThat(booleanArrays).hasSize(1)
       assertThat(booleanArrays[0].id).isEqualTo(booleanArray.id)
-      assertThat(booleanArrays[0].array).isEmpty()
+      assertThat(booleanArrays[0].array).isEqualTo(booleanArrayOf(false, false, false, false))
 
       val charArrays = graph.objects
           .filter { it is HeapPrimitiveArray && it.primitiveType == CHAR }
@@ -47,7 +47,7 @@ class HprofPrimitiveArrayStripperTest {
           .toList()
       assertThat(charArrays).hasSize(1)
       assertThat(charArrays[0].id).isEqualTo(charArray.id)
-      assertThat(charArrays[0].array).isEmpty()
+      assertThat(charArrays[0].array).isEqualTo("????????????".toCharArray())
     }
   }
 
diff --git a/shark-hprof/src/main/java/shark/HprofPrimitiveArrayStripper.kt b/shark-hprof/src/main/java/shark/HprofPrimitiveArrayStripper.kt
index 752cb2dc..b603e06a 100644
--- a/shark-hprof/src/main/java/shark/HprofPrimitiveArrayStripper.kt
+++ b/shark-hprof/src/main/java/shark/HprofPrimitiveArrayStripper.kt
@@ -12,8 +12,9 @@ import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.Sh
 import java.io.File
 
 /**
- * Converts a Hprof file to another file with all primitive arrays replaces with empty arrays,
- * which can be useful to remove PII.
+ * Converts a Hprof file to another file with all primitive arrays replaced with arrays of zeroes,
+ * which can be useful to remove PII. Char arrays are handled slightly differently because 0 would
+ * be the null character so instead these become arrays of '?'.
  */
 class HprofPrimitiveArrayStripper {
 
@@ -35,7 +36,11 @@ class HprofPrimitiveArrayStripper {
     Hprof.open(inputHprofFile)
         .use { hprof ->
           val reader = hprof.reader
-          HprofWriter.open(outputHprofFile, identifierByteSize = reader.identifierByteSize)
+          HprofWriter.open(
+              outputHprofFile,
+              identifierByteSize = reader.identifierByteSize,
+              hprofVersion = hprof.hprofVersion
+          )
               .use { writer ->
                 reader.readHprofRecords(setOf(HprofRecord::class),
                     OnHprofRecordListener { _,
@@ -48,28 +53,38 @@ class HprofPrimitiveArrayStripper {
                       writer.write(
                           when (record) {
                             is BooleanArrayDump -> BooleanArrayDump(
-                                record.id, record.stackTraceSerialNumber, booleanArrayOf()
+                                record.id, record.stackTraceSerialNumber,
+                                BooleanArray(record.array.size)
                             )
                             is CharArrayDump -> CharArrayDump(
-                                record.id, record.stackTraceSerialNumber, charArrayOf()
+                                record.id, record.stackTraceSerialNumber,
+                                CharArray(record.array.size) {
+                                  '?'
+                                }
                             )
                             is FloatArrayDump -> FloatArrayDump(
-                                record.id, record.stackTraceSerialNumber, floatArrayOf()
+                                record.id, record.stackTraceSerialNumber,
+                                FloatArray(record.array.size)
                             )
                             is DoubleArrayDump -> DoubleArrayDump(
-                                record.id, record.stackTraceSerialNumber, doubleArrayOf()
+                                record.id, record.stackTraceSerialNumber,
+                                DoubleArray(record.array.size)
                             )
                             is ByteArrayDump -> ByteArrayDump(
-                                record.id, record.stackTraceSerialNumber, byteArrayOf()
+                                record.id, record.stackTraceSerialNumber,
+                                ByteArray(record.array.size)
                             )
                             is ShortArrayDump -> ShortArrayDump(
-                                record.id, record.stackTraceSerialNumber, shortArrayOf()
+                                record.id, record.stackTraceSerialNumber,
+                                ShortArray(record.array.size)
                             )
                             is IntArrayDump -> IntArrayDump(
-                                record.id, record.stackTraceSerialNumber, intArrayOf()
+                                record.id, record.stackTraceSerialNumber,
+                                IntArray(record.array.size)
                             )
                             is LongArrayDump -> LongArrayDump(
-                                record.id, record.stackTraceSerialNumber, longArrayOf()
+                                record.id, record.stackTraceSerialNumber,
+                                LongArray(record.array.size)
                             )
                             else -> {
                               record
diff --git a/shark/src/main/java/shark/AppSingletonInspector.kt b/shark/src/main/java/shark/AppSingletonInspector.kt
index 80ecf84b..b5f56eba 100644
--- a/shark/src/main/java/shark/AppSingletonInspector.kt
+++ b/shark/src/main/java/shark/AppSingletonInspector.kt
@@ -15,7 +15,7 @@ class AppSingletonInspector(private vararg val singletonClasses: String) : Objec
           .classHierarchy
           .forEach { heapClass ->
             if (heapClass.name in singletonClasses) {
-              reporter.reportNotLeaking("${heapClass.name} is an app singleton")
+              reporter.notLeakingReasons += "${heapClass.name} is an app singleton"
             }
           }
     }
diff --git a/shark/src/main/java/shark/HeapAnalyzer.kt b/shark/src/main/java/shark/HeapAnalyzer.kt
index 08599d46..4004e805 100644
--- a/shark/src/main/java/shark/HeapAnalyzer.kt
+++ b/shark/src/main/java/shark/HeapAnalyzer.kt
@@ -15,11 +15,6 @@
  */
 package shark
 
-import shark.OnAnalysisProgressListener.Step.BUILDING_LEAK_TRACES
-import shark.OnAnalysisProgressListener.Step.COMPUTING_NATIVE_RETAINED_SIZE
-import shark.OnAnalysisProgressListener.Step.COMPUTING_RETAINED_SIZE
-import shark.OnAnalysisProgressListener.Step.FINDING_LEAKING_INSTANCES
-import shark.OnAnalysisProgressListener.Step.PARSING_HEAP_DUMP
 import shark.GcRoot.JavaFrame
 import shark.GcRoot.JniGlobal
 import shark.GcRoot.JniLocal
@@ -43,13 +38,17 @@ import shark.LeakTraceElement.Holder.ARRAY
 import shark.LeakTraceElement.Holder.CLASS
 import shark.LeakTraceElement.Holder.OBJECT
 import shark.LeakTraceElement.Holder.THREAD
+import shark.OnAnalysisProgressListener.Step.BUILDING_LEAK_TRACES
+import shark.OnAnalysisProgressListener.Step.COMPUTING_NATIVE_RETAINED_SIZE
+import shark.OnAnalysisProgressListener.Step.COMPUTING_RETAINED_SIZE
+import shark.OnAnalysisProgressListener.Step.FINDING_LEAKING_INSTANCES
+import shark.OnAnalysisProgressListener.Step.PARSING_HEAP_DUMP
+import shark.internal.PathFinder
+import shark.internal.PathFinder.PathFindingResults
 import shark.internal.ReferencePathNode
 import shark.internal.ReferencePathNode.ChildNode
 import shark.internal.ReferencePathNode.ChildNode.LibraryLeakNode
 import shark.internal.ReferencePathNode.RootNode
-import shark.internal.ShortestPathFinder
-import shark.internal.ShortestPathFinder.Results
-import shark.internal.hppc.LongLongScatterMap
 import shark.internal.lastSegment
 import java.io.File
 import java.util.ArrayList
@@ -63,11 +62,19 @@ class HeapAnalyzer constructor(
   private val listener: OnAnalysisProgressListener
 ) {
 
+  private class FindLeakInput(
+    val graph: HeapGraph,
+    val leakFinders: List<ObjectInspector>,
+    val referenceMatchers: List<ReferenceMatcher>,
+    val computeRetainedHeapSize: Boolean,
+    val objectInspectors: List<ObjectInspector>
+  )
+
   /**
    * Searches the heap dump for leaking instances and then computes the shortest strong reference
    * path from those instances to the GC roots.
    */
-  fun checkForLeaks(
+  fun analyze(
     heapDumpFile: File,
     referenceMatchers: List<ReferenceMatcher> = emptyList(),
     computeRetainedHeapSize: Boolean = false,
@@ -86,32 +93,19 @@ class HeapAnalyzer constructor(
 
     try {
       listener.onAnalysisProgress(PARSING_HEAP_DUMP)
-      Hprof.open(heapDumpFile).use { hprof ->
-        val graph = HprofHeapGraph.indexHprof(hprof)
-        listener.onAnalysisProgress(FINDING_LEAKING_INSTANCES)
-
-        val leakingInstanceObjectIds = findLeakingInstances(graph, leakFinders)
-
-        val (shortestPathsToLeakingInstances, dominatedInstances) =
-          findShortestPaths(
-              graph, referenceMatchers, leakingInstanceObjectIds, computeRetainedHeapSize
-          )
-
-        val retainedSizes = if (computeRetainedHeapSize) {
-          computeRetainedSizes(graph, shortestPathsToLeakingInstances, dominatedInstances)
-        } else {
-          null
-        }
-
-        val (applicationLeaks, libraryLeaks) = buildLeakTraces(
-            objectInspectors, shortestPathsToLeakingInstances, graph, retainedSizes
-        )
-
-        return HeapAnalysisSuccess(
-            heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
-            applicationLeaks, libraryLeaks
-        )
-      }
+      Hprof.open(heapDumpFile)
+          .use { hprof ->
+            val graph = HprofHeapGraph.indexHprof(hprof)
+
+            val findLeakInput = FindLeakInput(
+                graph, leakFinders, referenceMatchers, computeRetainedHeapSize, objectInspectors
+            )
+            val (applicationLeaks, libraryLeaks) = findLeakInput.findLeaks()
+            return HeapAnalysisSuccess(
+                heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
+                applicationLeaks, libraryLeaks
+            )
+          }
     } catch (exception: Throwable) {
       return HeapAnalysisFailure(
           heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
@@ -120,34 +114,30 @@ class HeapAnalyzer constructor(
     }
   }
 
-  private fun findLeakingInstances(
-    graph: HeapGraph,
-    objectInspectors: List<ObjectInspector>
-  ): Set<Long> {
+  private fun FindLeakInput.findLeaks(): Pair<List<ApplicationLeak>, List<LibraryLeak>> {
+    val leakingInstanceObjectIds = findLeakingObjects()
+
+    val pathFinder = PathFinder(graph, listener, referenceMatchers)
+    val pathFindingResults =
+      pathFinder.findPathsFromGcRoots(leakingInstanceObjectIds, computeRetainedHeapSize)
+
+    return buildLeakTraces(pathFindingResults)
+  }
+
+  private fun FindLeakInput.findLeakingObjects(): Set<Long> {
+    listener.onAnalysisProgress(FINDING_LEAKING_INSTANCES)
     return graph.objects
         .filter { objectRecord ->
           val reporter = ObjectReporter(objectRecord)
-          objectInspectors.forEach { inspector ->
+          leakFinders.any { inspector ->
             inspector.inspect(reporter)
+            reporter.leakingReasons.isNotEmpty()
           }
-          reporter.leakingStatuses.isNotEmpty()
         }
         .map { it.objectId }
         .toSet()
   }
 
-  private fun findShortestPaths(
-    graph: HeapGraph,
-    referenceMatchers: List<ReferenceMatcher>,
-    leakingInstanceObjectIds: Set<Long>,
-    computeDominators: Boolean
-  ): Results {
-    val pathFinder = ShortestPathFinder()
-    return pathFinder.findPaths(
-        graph, referenceMatchers, leakingInstanceObjectIds, computeDominators, listener
-    )
-  }
-
   internal sealed class TrieNode {
     abstract val objectId: Long
 
@@ -224,11 +214,13 @@ class HeapAnalyzer constructor(
     }
   }
 
-  private fun computeRetainedSizes(
-    graph: HeapGraph,
-    results: List<ReferencePathNode>,
-    dominatedInstances: LongLongScatterMap
-  ): List<Int> {
+  private fun FindLeakInput.computeRetainedSizes(pathFindingResults: PathFindingResults): List<Int>? {
+    if (!computeRetainedHeapSize) {
+      return null
+    }
+    val pathsToLeakingInstances = pathFindingResults.pathsToLeakingInstances
+    val dominatedInstances = pathFindingResults.dominatedInstances
+
     listener.onAnalysisProgress(COMPUTING_NATIVE_RETAINED_SIZE)
 
     // Map of Object id to native size as tracked by NativeAllocationRegistry$CleanerThunk
@@ -274,7 +266,7 @@ class HeapAnalyzer constructor(
 
     // Include self size for leaking instances
     val leakingInstanceIds = mutableSetOf<Long>()
-    results.forEach { pathNode ->
+    pathsToLeakingInstances.forEach { pathNode ->
       val leakingInstanceObjectId = pathNode.instance
       leakingInstanceIds.add(leakingInstanceObjectId)
       val instanceRecord = graph.findObjectById(leakingInstanceObjectId).asInstance!!
@@ -308,7 +300,7 @@ class HeapAnalyzer constructor(
     var sizedMoved: Boolean
     do {
       sizedMoved = false
-      results.map { it.instance }
+      pathsToLeakingInstances.map { it.instance }
           .forEach { leakingInstanceId ->
             val dominator = dominatedInstances[leakingInstanceId]
             if (dominator != null) {
@@ -323,23 +315,20 @@ class HeapAnalyzer constructor(
           }
     } while (sizedMoved)
     dominatedInstances.release()
-    return results.map { pathNode ->
+    return pathsToLeakingInstances.map { pathNode ->
       sizeByDominator[pathNode.instance]!!
     }
   }
 
-  private fun buildLeakTraces(
-    objectInspectors: List<ObjectInspector>,
-    shortestPathsToLeakingInstances: List<ReferencePathNode>,
-    graph: HeapGraph,
-    retainedSizes: List<Int>?
-  ): Pair<List<ApplicationLeak>, List<LibraryLeak>> {
+  private fun FindLeakInput.buildLeakTraces(pathFindingResults: PathFindingResults): Pair<List<ApplicationLeak>, List<LibraryLeak>> {
+    val retainedSizes = computeRetainedSizes(pathFindingResults)
+
     listener.onAnalysisProgress(BUILDING_LEAK_TRACES)
 
     val applicationLeaks = mutableListOf<ApplicationLeak>()
     val libraryLeaks = mutableListOf<LibraryLeak>()
 
-    val deduplicatedPaths = deduplicateShortestPaths(shortestPathsToLeakingInstances)
+    val deduplicatedPaths = deduplicateShortestPaths(pathFindingResults.pathsToLeakingInstances)
 
     deduplicatedPaths.forEachIndexed { index, pathNode ->
       val shortestChildPath = mutableListOf<ChildNode>()
@@ -396,10 +385,12 @@ class HeapAnalyzer constructor(
 
     val elements = shortestPath.mapIndexed { index, pathNode ->
       val leakReporter = leakReporters[index]
-      val leakStatus = leakStatuses[index]
+      val (leakStatus, leakStatusReason) = leakStatuses[index]
       val reference =
         if (index < shortestPath.lastIndex) (shortestPath[index + 1] as ChildNode).referenceFromParent else null
-      buildLeakElement(graph, pathNode, reference, leakReporter.labels, leakStatus)
+      buildLeakElement(
+          graph, pathNode, reference, leakReporter.labels, leakStatus, leakStatusReason
+      )
     }
     return LeakTrace(elements)
   }
@@ -407,41 +398,41 @@ class HeapAnalyzer constructor(
   private fun computeLeakStatuses(
     rootNode: RootNode,
     leakReporters: List<ObjectReporter>
-  ): List<LeakNodeStatusAndReason> {
+  ): List<Pair<LeakNodeStatus, String>> {
     val lastElementIndex = leakReporters.size - 1
 
     val rootNodeReporter = leakReporters[0]
 
-    rootNodeReporter.addLabel(
-        "GC Root: " + when (rootNode.gcRoot) {
-          is ThreadObject -> "Thread object"
-          is JniGlobal -> "Global variable in native code"
-          is JniLocal -> "Local variable in native code"
-          is JavaFrame -> "Java local variable"
-          is NativeStack -> "Input or output parameters in native code"
-          is StickyClass -> "System class"
-          is ThreadBlock -> "Thread block"
-          is MonitorUsed -> "Monitor (anything that called the wait() or notify() methods, or that is synchronized.)"
-          is ReferenceCleanup -> "Reference cleanup"
-          is JniMonitor -> "Root JNI monitor"
-          else -> throw IllegalStateException("Unexpected gc root ${rootNode.gcRoot}")
-        }
-    )
+    rootNodeReporter.labels +=
+      "GC Root: " + when (rootNode.gcRoot) {
+        is ThreadObject -> "Thread object"
+        is JniGlobal -> "Global variable in native code"
+        is JniLocal -> "Local variable in native code"
+        is JavaFrame -> "Java local variable"
+        is NativeStack -> "Input or output parameters in native code"
+        is StickyClass -> "System class"
+        is ThreadBlock -> "Thread block"
+        is MonitorUsed -> "Monitor (anything that called the wait() or notify() methods, or that is synchronized.)"
+        is ReferenceCleanup -> "Reference cleanup"
+        is JniMonitor -> "Root JNI monitor"
+        else -> throw IllegalStateException("Unexpected gc root ${rootNode.gcRoot}")
+      }
 
     var lastNotLeakingElementIndex = 0
     var firstLeakingElementIndex = lastElementIndex
 
-    val leakStatuses = ArrayList<LeakNodeStatusAndReason>()
+    val leakStatuses = ArrayList<Pair<LeakNodeStatus, String>>()
 
     for ((index, reporter) in leakReporters.withIndex()) {
-      val leakStatus = resolveStatus(reporter)
-      leakStatuses.add(leakStatus)
-      if (leakStatus.status == NOT_LEAKING) {
+      val resolvedStatusPair = resolveStatus(reporter)
+      leakStatuses.add(resolvedStatusPair)
+      val (leakStatus, _) = resolvedStatusPair
+      if (leakStatus == NOT_LEAKING) {
         lastNotLeakingElementIndex = index
         // Reset firstLeakingElementIndex so that we never have
         // firstLeakingElementIndex < lastNotLeakingElementIndex
         firstLeakingElementIndex = lastElementIndex
-      } else if (firstLeakingElementIndex == lastElementIndex && leakStatus.status == LEAKING) {
+      } else if (firstLeakingElementIndex == lastElementIndex && leakStatus == LEAKING) {
         firstLeakingElementIndex = index
       }
     }
@@ -452,27 +443,19 @@ class HeapAnalyzer constructor(
 
     // First and last are always known.
     for (i in 0..lastElementIndex) {
-      val leakStatus = leakStatuses[i]
+      val (leakStatus, leakStatusReason) = leakStatuses[i]
       if (i < lastNotLeakingElementIndex) {
         val nextNotLeakingName = simpleClassNames[i + 1]
-        leakStatuses[i] = when (leakStatus.status) {
-          UNKNOWN -> LeakNodeStatus.notLeaking("$nextNotLeakingNameâ†“ is not leaking")
-          NOT_LEAKING -> LeakNodeStatus.notLeaking(
-              "$nextNotLeakingNameâ†“ is not leaking and ${leakStatus.reason}"
-          )
-          LEAKING -> LeakNodeStatus.notLeaking(
-              "$nextNotLeakingNameâ†“ is not leaking. Conflicts with ${leakStatus.reason}"
-          )
+        leakStatuses[i] = when (leakStatus) {
+          UNKNOWN -> NOT_LEAKING to "$nextNotLeakingNameâ†“ is not leaking"
+          NOT_LEAKING -> NOT_LEAKING to "$nextNotLeakingNameâ†“ is not leaking and $leakStatusReason"
+          LEAKING -> NOT_LEAKING to "$nextNotLeakingNameâ†“ is not leaking. Conflicts with $leakStatusReason"
         }
       } else if (i > firstLeakingElementIndex) {
         val previousLeakingName = simpleClassNames[i - 1]
-        leakStatuses[i] = LeakNodeStatus.leaking("$previousLeakingNameâ†‘ is leaking")
-
-        leakStatuses[i] = when (leakStatus.status) {
-          UNKNOWN -> LeakNodeStatus.leaking("$previousLeakingNameâ†‘ is leaking")
-          LEAKING -> LeakNodeStatus.leaking(
-              "$previousLeakingNameâ†‘ is leaking and ${leakStatus.reason}"
-          )
+        leakStatuses[i] = when (leakStatus) {
+          UNKNOWN -> LEAKING to "$previousLeakingNameâ†‘ is leaking"
+          LEAKING -> LEAKING to "$previousLeakingNameâ†‘ is leaking and $leakStatusReason"
           NOT_LEAKING -> throw IllegalStateException("Should never happen")
         }
       }
@@ -482,42 +465,34 @@ class HeapAnalyzer constructor(
 
   private fun resolveStatus(
     reporter: ObjectReporter
-  ): LeakNodeStatusAndReason {
-    // NOT_LEAKING always wins over LEAKING
-    var current = LeakNodeStatus.unknown()
-    for (statusAndReason in reporter.leakNodeStatuses) {
-      current = when {
-        current.status == UNKNOWN -> statusAndReason
-        current.status == LEAKING && statusAndReason.status == LEAKING -> {
-          LeakNodeStatus.leaking("${current.reason} and ${statusAndReason.reason}")
-        }
-        current.status == NOT_LEAKING && statusAndReason.status == NOT_LEAKING -> {
-          LeakNodeStatus.notLeaking("${current.reason} and ${statusAndReason.reason}")
-        }
-        current.status == NOT_LEAKING && statusAndReason.status == LEAKING -> {
-          LeakNodeStatus.notLeaking(
-              "${current.reason}. Conflicts with ${statusAndReason.reason}"
-          )
-        }
-        current.status == LEAKING && statusAndReason.status == NOT_LEAKING -> {
-          LeakNodeStatus.notLeaking(
-              "${statusAndReason.reason}. Conflicts with ${current.reason}"
-          )
-        }
-        else -> throw IllegalStateException(
-            "Should never happen ${current.status} ${statusAndReason.reason}"
-        )
+  ): Pair<LeakNodeStatus, String> {
+    var status = UNKNOWN
+    var reason = ""
+    if (reporter.notLeakingReasons.isNotEmpty()) {
+      status = NOT_LEAKING
+      reason = reporter.notLeakingReasons.joinToString(" and ")
+    }
+
+    val leakingReasons = reporter.leakingReasons + reporter.likelyLeakingReasons
+    if (leakingReasons.isNotEmpty()) {
+      // NOT_LEAKING wins over LEAKING
+      if (status == NOT_LEAKING) {
+        reason += ". Conflicts with ${leakingReasons.joinToString(" and ")}"
+      } else {
+        status = LEAKING
+        reason = leakingReasons.joinToString(" and ")
       }
     }
-    return current
+    return status to reason
   }
 
   private fun buildLeakElement(
     graph: HeapGraph,
     node: ReferencePathNode,
     reference: LeakReference?,
-    labels: List<String>,
-    leakStatus: LeakNodeStatusAndReason
+    labels: Set<String>,
+    leakStatus: LeakNodeStatus,
+    leakStatusReason: String
   ): LeakTraceElement {
     val objectId = node.instance
 
@@ -537,7 +512,7 @@ class HeapAnalyzer constructor(
         OBJECT
       }
     }
-    return LeakTraceElement(reference, holderType, className, labels, leakStatus)
+    return LeakTraceElement(reference, holderType, className, labels, leakStatus, leakStatusReason)
   }
 
   private fun recordClassName(
diff --git a/shark/src/main/java/shark/LeakNodeStatus.kt b/shark/src/main/java/shark/LeakNodeStatus.kt
index fe81dd2f..a8193c1c 100644
--- a/shark/src/main/java/shark/LeakNodeStatus.kt
+++ b/shark/src/main/java/shark/LeakNodeStatus.kt
@@ -1,33 +1,10 @@
 package shark
 
-import java.io.Serializable
-
 enum class LeakNodeStatus {
+  /** The instance was needed and therefore expected to be reachable. */
   NOT_LEAKING,
+  /** The instance was no longer needed and therefore expected to be unreachable. */
   LEAKING,
+  /** No decision can be made about the provided instance. */
   UNKNOWN;
-
-  companion object {
-    private val UNKNOWN_REACHABILITY = LeakNodeStatusAndReason(UNKNOWN, "")
-
-    /** The instance was needed and therefore expected to be reachable.  */
-    fun notLeaking(reason: String): LeakNodeStatusAndReason {
-      return LeakNodeStatusAndReason(NOT_LEAKING, reason)
-    }
-
-    /** The instance was no longer needed and therefore expected to be unreachable.  */
-    fun leaking(reason: String): LeakNodeStatusAndReason {
-      return LeakNodeStatusAndReason(LEAKING, reason)
-    }
-
-    /** No decision can be made about the provided instance.  */
-    fun unknown(): LeakNodeStatusAndReason {
-      return UNKNOWN_REACHABILITY
-    }
-  }
 }
-
-class LeakNodeStatusAndReason internal constructor(
-  val status: LeakNodeStatus,
-  val reason: String
-) : Serializable
\ No newline at end of file
diff --git a/shark/src/main/java/shark/LeakTrace.kt b/shark/src/main/java/shark/LeakTrace.kt
index bb3b9bfd..386765fb 100644
--- a/shark/src/main/java/shark/LeakTrace.kt
+++ b/shark/src/main/java/shark/LeakTrace.kt
@@ -21,10 +21,10 @@ data class LeakTrace(
   }
 
   fun elementMayBeLeakCause(index: Int): Boolean {
-    return when (elements[index].leakStatusAndReason.status) {
+    return when (elements[index].leakStatus) {
       UNKNOWN -> true
       NOT_LEAKING -> if (index < elements.lastIndex) {
-        elements[index + 1].leakStatusAndReason.status != NOT_LEAKING
+        elements[index + 1].leakStatus != NOT_LEAKING
       } else {
         false
       }
diff --git a/shark/src/main/java/shark/LeakTraceElement.kt b/shark/src/main/java/shark/LeakTraceElement.kt
index bd49a814..ff511769 100644
--- a/shark/src/main/java/shark/LeakTraceElement.kt
+++ b/shark/src/main/java/shark/LeakTraceElement.kt
@@ -16,11 +16,13 @@ data class LeakTraceElement(
   val className: String,
 
   /**
-   * Ordered labels that were computed during analysis. A label provides
-   * extra information that helps understand the leak trace element.
+   * Labels that were computed during analysis. A label provides extra information that helps
+   * understand the leak trace element.
    */
-  val labels: List<String>,
-  val leakStatusAndReason: LeakNodeStatusAndReason
+  val labels: Set<String>,
+  val leakStatus: LeakNodeStatus,
+  val leakStatusReason: String
+
 ) : Serializable {
 
   /**
diff --git a/shark/src/main/java/shark/ObjectInspectors.kt b/shark/src/main/java/shark/ObjectInspectors.kt
index af0d1a8d..4f4cd780 100644
--- a/shark/src/main/java/shark/ObjectInspectors.kt
+++ b/shark/src/main/java/shark/ObjectInspectors.kt
@@ -61,16 +61,16 @@ enum class ObjectInspectors : ObjectInspector {
       val objectId = reporter.heapObject.objectId
       references.forEach { ref ->
         if (ref.referent.value == objectId) {
-          reporter.reportLeaking("ObjectWatcher was watching this")
-          reporter.addLabel("key = ${ref.key}")
+          reporter.leakingReasons += "ObjectWatcher was watching this"
+          reporter.labels += "key = ${ref.key}"
           if (ref.name.isNotEmpty()) {
-            reporter.addLabel("name = ${ref.name}")
+            reporter.labels += "name = ${ref.name}"
           }
           if (ref.watchDurationMillis != null) {
-            reporter.addLabel("watchDurationMillis = ${ref.watchDurationMillis}")
+            reporter.labels += "watchDurationMillis = ${ref.watchDurationMillis}"
           }
           if (ref.retainedDurationMillis != null) {
-            reporter.addLabel("retainedDurationMillis = ${ref.retainedDurationMillis}")
+            reporter.labels += "retainedDurationMillis = ${ref.retainedDurationMillis}"
           }
         }
       }
@@ -82,7 +82,7 @@ enum class ObjectInspectors : ObjectInspector {
       reporter: ObjectReporter
     ) {
       reporter.whenInstanceOf(ClassLoader::class) {
-        reportNotLeaking("A ClassLoader is never leaking")
+        notLeakingReasons += "A ClassLoader is never leaking"
       }
     }
   },
@@ -92,7 +92,7 @@ enum class ObjectInspectors : ObjectInspector {
       reporter: ObjectReporter
     ) {
       if (reporter.heapObject is HeapClass) {
-        reporter.reportNotLeaking("a class is never leaking")
+        reporter.notLeakingReasons += "a class is never leaking"
       }
     }
   },
@@ -113,19 +113,17 @@ enum class ObjectInspectors : ObjectInspector {
               // use that instead.
               val actualClass = Class.forName(instanceClass.name)
               val interfaces = actualClass.interfaces
-              reporter.addLabel(
-                  if (interfaces.isNotEmpty()) {
-                    val implementedInterface = interfaces[0]
-                    "Anonymous class implementing ${implementedInterface.name}"
-                  } else {
-                    "Anonymous subclass of java.lang.Object"
-                  }
-              )
+              reporter.labels += if (interfaces.isNotEmpty()) {
+                val implementedInterface = interfaces[0]
+                "Anonymous class implementing ${implementedInterface.name}"
+              } else {
+                "Anonymous subclass of java.lang.Object"
+              }
             } catch (ignored: ClassNotFoundException) {
             }
           } else {
             // Makes it easier to figure out which anonymous class we're looking at.
-            reporter.addLabel("Anonymous subclass of ${parentClassRecord.name}")
+            reporter.labels += "Anonymous subclass of ${parentClassRecord.name}"
           }
         }
       }
@@ -138,7 +136,7 @@ enum class ObjectInspectors : ObjectInspector {
     ) {
       reporter.whenInstanceOf(Thread::class) { instance ->
         val threadName = instance[Thread::class, "name"]!!.value.readAsJavaString()
-        addLabel("Thread name: '$threadName'")
+        labels += "Thread name: '$threadName'"
       }
     }
   };
diff --git a/shark/src/main/java/shark/ObjectReporter.kt b/shark/src/main/java/shark/ObjectReporter.kt
index 1a0e5a20..850d968a 100644
--- a/shark/src/main/java/shark/ObjectReporter.kt
+++ b/shark/src/main/java/shark/ObjectReporter.kt
@@ -10,65 +10,31 @@ import kotlin.reflect.KClass
  * A given [ObjectReporter] only maps to one object in the heap, but is shared to many
  * [ObjectInspector] implementations and accumulates insights.
  */
-class ObjectReporter internal constructor(val heapObject: HeapObject) {
-
-  private val mutableLabels = mutableListOf<String>()
-
-  private val mutableLeakingStatuses = mutableListOf<LeakNodeStatusAndReason>()
-  private val mutableLikelyLeakingStatuses = mutableListOf<LeakNodeStatusAndReason>()
-  private val mutableNotLeakingStatuses = mutableListOf<LeakNodeStatusAndReason>()
-
-  /**
-   * All labels added via [addLabel] for the [heapObject] instance.
-   */
-  val labels: List<String>
-    get() = mutableLabels
-
-  /**
-   * All leaking insights added via [reportLikelyLeaking], [reportLeaking] and [reportNotLeaking]
-   * for the [heapObject] instance.
-   */
-  val leakNodeStatuses: List<LeakNodeStatusAndReason>
-    get() = mutableLeakingStatuses + mutableLikelyLeakingStatuses + mutableNotLeakingStatuses
-
-  /**
-   * All leaking insights added via [reportLeaking] for the [heapObject] instance.
-   */
-  val leakingStatuses: List<LeakNodeStatusAndReason>
-    get() = mutableLeakingStatuses
+class ObjectReporter constructor(val heapObject: HeapObject) {
 
   /**
-   * Adds a label that will be visible on the corresponding node in the leak trace.
+   * Labels that will be visible on the corresponding [heapObject] in the leak trace.
    */
-  fun addLabel(label: String) {
-    mutableLabels += label
-  }
+  val labels = linkedSetOf<String>()
 
   /**
-   * @see [reportLeaking]
+   * Reasons for which this object is expected to be unreachable (ie it's leaking).
+   *
+   * Only add reasons to this if you're 100% sure this object is leaking, otherwise add reasons to
+   * [likelyLeakingReasons]. The difference is that objects that are "likely leaking" are not
+   * considered to be leaking objects on which LeakCanary should compute the leak trace.
    */
-  fun reportLikelyLeaking(reason: String) {
-    mutableLikelyLeakingStatuses += LeakNodeStatus.leaking(reason)
-  }
+  val leakingReasons = mutableSetOf<String>()
 
   /**
-   * Call this to let LeakCanary know that this instance was expected to be unreachable, ie that
-   * it's leaking.
-   *
-   * Only call this method if you're 100% sure this instance is leaking, otherwise call
-   * [reportLikelyLeaking]. The difference is that instances that are "likely leaking" are not
-   * considered to be leaking instances on which LeakCanary should compute the leak trace.
+   * @see leakingReasons
    */
-  fun reportLeaking(reason: String) {
-    mutableLeakingStatuses += LeakNodeStatus.leaking(reason)
-  }
+  val likelyLeakingReasons = mutableSetOf<String>()
 
   /**
-   * Call this to let LeakCanary know that this instance was expected to be reachable.
+   * Reasons for which this object is expected to be reachable (ie it's not leaking).
    */
-  fun reportNotLeaking(reason: String) {
-    mutableNotLeakingStatuses += LeakNodeStatus.notLeaking(reason)
-  }
+  val notLeakingReasons = mutableSetOf<String>()
 
   /**
    * Runs [block] if [ObjectReporter.heapObject] is an instance of [expectedClass].
@@ -93,5 +59,4 @@ class ObjectReporter internal constructor(val heapObject: HeapObject) {
     }
   }
 
-
 }
\ No newline at end of file
diff --git a/shark/src/main/java/shark/internal/LeakTraceRenderer.kt b/shark/src/main/java/shark/internal/LeakTraceRenderer.kt
index 915ef2ad..3603848d 100644
--- a/shark/src/main/java/shark/internal/LeakTraceRenderer.kt
+++ b/shark/src/main/java/shark/internal/LeakTraceRenderer.kt
@@ -3,7 +3,6 @@ package shark.internal
 import shark.LeakNodeStatus.LEAKING
 import shark.LeakNodeStatus.NOT_LEAKING
 import shark.LeakNodeStatus.UNKNOWN
-import shark.LeakNodeStatusAndReason
 import shark.LeakTrace
 import shark.LeakTraceElement
 import shark.LeakTraceElement.Holder.ARRAY
@@ -29,8 +28,11 @@ internal fun LeakTrace.renderToString(): String {
       "$ZERO_WIDTH_SPACE     "
     }
 
-    val currentReachability = elements[index].leakStatusAndReason
-    result += "\n" + contentPrefix + "Leaking: " + currentReachability.renderToString()
+    result += "\n" + contentPrefix + "Leaking: " + when (elements[index].leakStatus) {
+      UNKNOWN -> "UNKNOWN"
+      NOT_LEAKING -> "NO (${elements[index].leakStatusReason})"
+      LEAKING -> "YES (${elements[index].leakStatusReason})"
+    }
 
     for (label in element.labels) {
       result += "\n" + contentPrefix + label
@@ -44,14 +46,6 @@ internal fun LeakTrace.renderToString(): String {
   return result
 }
 
-private fun LeakNodeStatusAndReason.renderToString(): String {
-  return when (status) {
-    UNKNOWN -> "UNKNOWN"
-    NOT_LEAKING -> "NO ($reason)"
-    LEAKING -> "YES ($reason)"
-  }
-}
-
 private fun getNextElementString(
   leakTrace: LeakTrace,
   element: LeakTraceElement,
diff --git a/shark/src/main/java/shark/internal/ShortestPathFinder.kt b/shark/src/main/java/shark/internal/PathFinder.kt
similarity index 70%
rename from shark/src/main/java/shark/internal/ShortestPathFinder.kt
rename to shark/src/main/java/shark/internal/PathFinder.kt
index c02fd848..366d5090 100644
--- a/shark/src/main/java/shark/internal/ShortestPathFinder.kt
+++ b/shark/src/main/java/shark/internal/PathFinder.kt
@@ -15,8 +15,6 @@
  */
 package shark.internal
 
-import shark.OnAnalysisProgressListener.Step.FINDING_DOMINATORS
-import shark.OnAnalysisProgressListener.Step.FINDING_PATHS_TO_LEAKING_INSTANCES
 import shark.GcRoot
 import shark.GcRoot.JavaFrame
 import shark.GcRoot.ThreadObject
@@ -26,16 +24,18 @@ import shark.HeapObject.HeapClass
 import shark.HeapObject.HeapInstance
 import shark.HeapObject.HeapObjectArray
 import shark.HeapObject.HeapPrimitiveArray
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.IgnoredReferenceMatcher
 import shark.LeakReference
 import shark.LeakTraceElement.Type.ARRAY_ENTRY
 import shark.LeakTraceElement.Type.INSTANCE_FIELD
 import shark.LeakTraceElement.Type.LOCAL
 import shark.LeakTraceElement.Type.STATIC_FIELD
-import shark.PrimitiveType
-import shark.ReferenceMatcher
-import shark.IgnoredReferenceMatcher
 import shark.LibraryLeakReferenceMatcher
+import shark.OnAnalysisProgressListener
+import shark.OnAnalysisProgressListener.Step.FINDING_DOMINATORS
+import shark.OnAnalysisProgressListener.Step.FINDING_PATHS_TO_LEAKING_INSTANCES
+import shark.PrimitiveType.INT
+import shark.ReferenceMatcher
 import shark.ReferencePattern
 import shark.ReferencePattern.InstanceFieldPattern
 import shark.ReferencePattern.StaticFieldPattern
@@ -57,67 +57,17 @@ import java.util.LinkedHashMap
  * identified as "to visit last" and then visiting them as needed if no path is
  * found.
  */
-internal class ShortestPathFinder {
-
-  /** Set of instances to visit */
-  private val toVisitQueue: Deque<ReferencePathNode> = ArrayDeque()
-  private val toVisitLastQueue: Deque<LibraryLeakNode> = ArrayDeque()
-  /**
-   * Enables fast checking of whether a node is already in the queue.
-   */
-  private val toVisitSet = HashSet<Long>()
-  private val toVisitLastSet = HashSet<Long>()
-
-  private val visitedSet = LongScatterSet()
-  private lateinit var leakingInstanceObjectIds: Set<Long>
-
-  /**
-   * Map of instances to their leaking dominator.
-   * var because the instance will be returned by [findPaths] and replaced with a new empty map
-   * here (copying it could be expensive).
-   *
-   * If an instance has been added to [toVisitSet] or [visitedSet] and is missing from
-   * [dominatedInstances] then it's considered "undomitable" ie it is dominated by gc roots
-   * and cannot be dominated by a leaking instance.
-   */
-  private var dominatedInstances = LongLongScatterMap()
-  private var sizeOfObjectInstances = 0
+internal class PathFinder(
+  private val graph: HeapGraph,
+  private val listener: OnAnalysisProgressListener,
+  referenceMatchers: List<ReferenceMatcher>
+) {
 
-  data class Results(
-    val shortestPathsToLeakingInstances: List<ReferencePathNode>,
-    val dominatedInstances: LongLongScatterMap
-  )
-
-  fun findPaths(
-    graph: HeapGraph,
-    referenceMatchers: List<ReferenceMatcher>,
-    leakingInstanceObjectIds: Set<Long>,
-    computeDominators: Boolean,
-    listener: shark.OnAnalysisProgressListener
-  ): Results {
-
-    listener.onAnalysisProgress(FINDING_PATHS_TO_LEAKING_INSTANCES)
-    clearState()
-    this.leakingInstanceObjectIds = leakingInstanceObjectIds
-
-    val objectClass = graph.findClassByName("java.lang.Object")
-    sizeOfObjectInstances = if (objectClass != null) {
-      // In Android 16 ClassDumpRecord.instanceSize for java.lang.Object can be 8 yet there are 0
-      // fields. This is likely because there is extra per instance data that isn't coming from
-      // fields in the Object class. See #1374
-      val objectClassFieldSize = objectClass.readFieldsByteSize()
-
-      // shadow$_klass_ (object id) + shadow$_monitor_ (Int)
-      val sizeOfObjectOnArt = graph.identifierByteSize + PrimitiveType.INT.byteSize
-      if (objectClassFieldSize == sizeOfObjectOnArt) {
-        sizeOfObjectOnArt
-      } else {
-        0
-      }
-    } else {
-      0
-    }
+  private val fieldNameByClassName: Map<String, Map<String, ReferenceMatcher>>
+  private val staticFieldNameByClassName: Map<String, Map<String, ReferenceMatcher>>
+  private val threadNameReferenceMatchers: Map<String, ReferenceMatcher>
 
+  init {
     val fieldNameByClassName = mutableMapOf<String, MutableMap<String, ReferenceMatcher>>()
     val staticFieldNameByClassName = mutableMapOf<String, MutableMap<String, ReferenceMatcher>>()
     val threadNames = mutableMapOf<String, ReferenceMatcher>()
@@ -152,20 +102,89 @@ internal class ShortestPathFinder {
             }
           }
         }
+    this.fieldNameByClassName = fieldNameByClassName
+    this.staticFieldNameByClassName = staticFieldNameByClassName
+    this.threadNameReferenceMatchers = threadNames
+  }
 
-    enqueueGcRoots(graph, threadNames, computeDominators)
+  private class State(
+    val leakingInstanceObjectIds: Set<Long>,
+    val sizeOfObjectInstances: Int,
+    val computeRetainedHeapSize: Boolean
+  ) {
 
-    val shortestPathsToLeakingInstances = mutableListOf<ReferencePathNode>()
-    visitingQueue@ while (!toVisitQueue.isEmpty() || !toVisitLastQueue.isEmpty()) {
-      val node = if (!toVisitQueue.isEmpty()) {
-        val removedNode = toVisitQueue.poll()
-        toVisitSet.remove(removedNode.instance)
-        removedNode
+    /** Set of instances to visit */
+    val toVisitQueue: Deque<ReferencePathNode> = ArrayDeque()
+
+    /**
+     * Instances to visit when [toVisitQueue] is empty. Should contain [JavaFrame] gc roots first,
+     * then [LibraryLeakNode].
+     */
+    val toVisitLastQueue: Deque<ReferencePathNode> = ArrayDeque()
+    /**
+     * Enables fast checking of whether a node is already in the queue.
+     */
+    val toVisitSet = HashSet<Long>()
+    val toVisitLastSet = HashSet<Long>()
+
+    val visitedSet = LongScatterSet()
+
+    /**
+     * Map of instances to their leaking dominator.
+     * If an instance has been added to [toVisitSet] or [visitedSet] and is missing from
+     * [dominatedInstances] then it's considered "undomitable" ie it is dominated by gc roots
+     * and cannot be dominated by a leaking instance.
+     */
+    val dominatedInstances = LongLongScatterMap()
+
+    val queuesNotEmpty: Boolean
+      get() = toVisitQueue.isNotEmpty() || toVisitLastQueue.isNotEmpty()
+  }
+
+  class PathFindingResults(
+    val pathsToLeakingInstances: List<ReferencePathNode>,
+    val dominatedInstances: LongLongScatterMap
+  )
+
+  fun findPathsFromGcRoots(
+    leakingInstanceObjectIds: Set<Long>,
+    computeRetainedHeapSize: Boolean
+  ): PathFindingResults {
+    listener.onAnalysisProgress(FINDING_PATHS_TO_LEAKING_INSTANCES)
+
+    val sizeOfObjectInstances = determineSizeOfObjectInstances(graph)
+
+    val state = State(leakingInstanceObjectIds, sizeOfObjectInstances, computeRetainedHeapSize)
+
+    return state.findPathsFromGcRoots(leakingInstanceObjectIds)
+  }
+
+  private fun determineSizeOfObjectInstances(graph: HeapGraph): Int {
+    val objectClass = graph.findClassByName("java.lang.Object")
+    return if (objectClass != null) {
+      // In Android 16 ClassDumpRecord.instanceSize for java.lang.Object can be 8 yet there are 0
+      // fields. This is likely because there is extra per instance data that isn't coming from
+      // fields in the Object class. See #1374
+      val objectClassFieldSize = objectClass.readFieldsByteSize()
+
+      // shadow$_klass_ (object id) + shadow$_monitor_ (Int)
+      val sizeOfObjectOnArt = graph.identifierByteSize + INT.byteSize
+      if (objectClassFieldSize == sizeOfObjectOnArt) {
+        sizeOfObjectOnArt
       } else {
-        val removedNode = toVisitLastQueue.poll()
-        toVisitLastSet.remove(removedNode.instance)
-        removedNode
+        0
       }
+    } else {
+      0
+    }
+  }
+
+  private fun State.findPathsFromGcRoots(leakingInstanceObjectIds: Set<Long>): PathFindingResults {
+    enqueueGcRoots()
+
+    val shortestPathsToLeakingInstances = mutableListOf<ReferencePathNode>()
+    visitingQueue@ while (queuesNotEmpty) {
+      val node = poll()
 
       if (checkSeen(node)) {
         throw IllegalStateException(
@@ -175,9 +194,9 @@ internal class ShortestPathFinder {
 
       if (node.instance in leakingInstanceObjectIds) {
         shortestPathsToLeakingInstances.add(node)
-        // Found all refs, stop searching (unless computing retained size which stops on weak reachables)
+        // Found all refs, stop searching (unless computing retained size)
         if (shortestPathsToLeakingInstances.size == leakingInstanceObjectIds.size) {
-          if (computeDominators) {
+          if (computeRetainedHeapSize) {
             listener.onAnalysisProgress(FINDING_DOMINATORS)
           } else {
             break@visitingQueue
@@ -185,58 +204,44 @@ internal class ShortestPathFinder {
         }
       }
 
-      when (val graphRecord = graph.findObjectById(node.instance)) {
-        is HeapClass -> visitClassRecord(
-            graph, graphRecord, node, staticFieldNameByClassName, computeDominators
-        )
-        is HeapInstance -> visitInstanceRecord(
-            graph, graphRecord, node, fieldNameByClassName, computeDominators
-        )
-        is HeapObjectArray -> visitObjectArrayRecord(
-            graph, graphRecord.readRecord(), node, computeDominators
-        )
+      when (val heapObject = graph.findObjectById(node.instance)) {
+        is HeapClass -> visitClassRecord(heapObject, node)
+        is HeapInstance -> visitInstanceRecord(heapObject, node)
+        is HeapObjectArray -> visitObjectArrayRecord(heapObject, node)
       }
     }
+    return PathFindingResults(shortestPathsToLeakingInstances, dominatedInstances)
+  }
 
-    val dominatedInstances = this.dominatedInstances
-
-    clearState()
-
-    return Results(shortestPathsToLeakingInstances, dominatedInstances)
+  private fun State.poll(): ReferencePathNode {
+    return if (!toVisitQueue.isEmpty()) {
+      val removedNode = toVisitQueue.poll()
+      toVisitSet.remove(removedNode.instance)
+      removedNode
+    } else {
+      val removedNode = toVisitLastQueue.poll()
+      toVisitLastSet.remove(removedNode.instance)
+      removedNode
+    }
   }
 
-  private fun checkSeen(node: ReferencePathNode): Boolean {
+  private fun State.checkSeen(node: ReferencePathNode): Boolean {
     val neverSeen = visitedSet.add(node.instance)
     return !neverSeen
   }
 
-  private fun clearState() {
-    toVisitQueue.clear()
-    toVisitLastQueue.clear()
-    toVisitSet.clear()
-    toVisitLastSet.clear()
-    visitedSet.release()
-    dominatedInstances = LongLongScatterMap()
-    leakingInstanceObjectIds = emptySet()
-    sizeOfObjectInstances = 0
-  }
-
-  private fun enqueueGcRoots(
-    graph: HeapGraph,
-    threadNameReferenceMatchers: Map<String, ReferenceMatcher>,
-    computeDominators: Boolean
-  ) {
-    val gcRoots = sortedGcRoots(graph)
+  private fun State.enqueueGcRoots() {
+    val gcRoots = sortedGcRoots()
 
     val threadsBySerialNumber = mutableMapOf<Int, Pair<HeapInstance, ThreadObject>>()
     gcRoots.forEach { (objectRecord, gcRoot) ->
-      if (computeDominators) {
-        undominateWithSkips(graph, gcRoot.id)
+      if (computeRetainedHeapSize) {
+        undominateWithSkips(gcRoot.id)
       }
       when (gcRoot) {
         is ThreadObject -> {
           threadsBySerialNumber[gcRoot.threadSerialNumber] = objectRecord.asInstance!! to gcRoot
-          enqueue(graph, RootNode(gcRoot, gcRoot.id))
+          enqueue(RootNode(gcRoot, gcRoot.id))
         }
         is JavaFrame -> {
           val (threadInstance, threadRoot) = threadsBySerialNumber.getValue(
@@ -246,10 +251,10 @@ internal class ShortestPathFinder {
           val referenceMatcher = threadNameReferenceMatchers[threadName]
 
           if (referenceMatcher !is IgnoredReferenceMatcher) {
-            // visitOrder is unused as this root node isn't enqueued.
             val rootNode = RootNode(gcRoot, threadRoot.id)
-            // TODO #1352 Instead of <Java Local>, it should be <local variable in Foo.bar()>
-            // We should also add the full stacktrace as a label of thread objects
+            // Unfortunately Android heap dumps do not include stack trace data, so
+            // JavaFrame.frameNumber is always -1 and we cannot know which method is causing the
+            // reference to be held.
             val leakReference = LeakReference(LOCAL, "")
 
             val childNode = if (referenceMatcher is LibraryLeakReferenceMatcher) {
@@ -257,10 +262,10 @@ internal class ShortestPathFinder {
             } else {
               NormalNode(gcRoot.id, rootNode, leakReference)
             }
-            enqueue(graph, childNode)
+            enqueue(childNode)
           }
         }
-        else -> enqueue(graph, RootNode(gcRoot, gcRoot.id))
+        else -> enqueue(RootNode(gcRoot, gcRoot.id))
       }
     }
   }
@@ -271,9 +276,7 @@ internal class ShortestPathFinder {
    * This ensures ThreadObjects are visited before JavaFrames, and threadsBySerialNumber can be
    * built before JavaFrames.
    */
-  private fun sortedGcRoots(
-    graph: HeapGraph
-  ): List<Pair<HeapObject, GcRoot>> {
+  private fun sortedGcRoots(): List<Pair<HeapObject, GcRoot>> {
     val rootClassName: (HeapObject) -> String = { graphObject ->
       when (graphObject) {
         is HeapClass -> {
@@ -304,12 +307,9 @@ internal class ShortestPathFinder {
         })
   }
 
-  private fun visitClassRecord(
-    graph: HeapGraph,
+  private fun State.visitClassRecord(
     heapClass: HeapClass,
-    parent: ReferencePathNode,
-    staticFieldNameByClassName: Map<String, Map<String, ReferenceMatcher>>,
-    computeRetainedHeapSize: Boolean
+    parent: ReferencePathNode
   ) {
     val ignoredStaticFields = staticFieldNameByClassName[heapClass.name] ?: emptyMap()
 
@@ -326,34 +326,25 @@ internal class ShortestPathFinder {
       val objectId = staticField.value.asObjectId!!
 
       if (computeRetainedHeapSize) {
-        undominateWithSkips(graph, objectId)
+        undominateWithSkips(objectId)
       }
 
-      when (val referenceMatcher = ignoredStaticFields[fieldName]) {
-        null -> {
-          enqueue(
-              graph,
-              NormalNode(objectId, parent, LeakReference(STATIC_FIELD, fieldName))
-          )
-        }
-        is LibraryLeakReferenceMatcher -> {
-          enqueue(
-              graph,
-              LibraryLeakNode(
-                  objectId, parent, LeakReference(STATIC_FIELD, fieldName), referenceMatcher
-              )
-          )
-        }
+      val node = when (val referenceMatcher = ignoredStaticFields[fieldName]) {
+        null -> NormalNode(objectId, parent, LeakReference(STATIC_FIELD, fieldName))
+        is LibraryLeakReferenceMatcher -> LibraryLeakNode(
+            objectId, parent, LeakReference(STATIC_FIELD, fieldName), referenceMatcher
+        )
+        is IgnoredReferenceMatcher -> null
+      }
+      if (node != null) {
+        enqueue(node)
       }
     }
   }
 
-  private fun visitInstanceRecord(
-    graph: HeapGraph,
+  private fun State.visitInstanceRecord(
     instance: HeapInstance,
-    parent: ReferencePathNode,
-    fieldNameByClassName: Map<String, Map<String, ReferenceMatcher>>,
-    computeRetainedHeapSize: Boolean
+    parent: ReferencePathNode
   ) {
     val fieldReferenceMatchers = LinkedHashMap<String, ReferenceMatcher>()
 
@@ -369,42 +360,36 @@ internal class ShortestPathFinder {
     }
 
     val fieldNamesAndValues = instance.readFields()
+        .filter { it.value.isNonNullReference }
         .toMutableList()
 
     fieldNamesAndValues.sortBy { it.name }
 
-    fieldNamesAndValues.filter { it.value.isNonNullReference }
-        .forEach { field ->
-          val objectId = field.value.asObjectId!!
-          if (computeRetainedHeapSize) {
-            updateDominatorWithSkips(graph, parent.instance, objectId)
-          }
-          when (val referenceMatcher = fieldReferenceMatchers[field.name]) {
-            null -> {
-              enqueue(
-                  graph,
-                  NormalNode(objectId, parent, LeakReference(INSTANCE_FIELD, field.name))
-              )
-            }
-            is LibraryLeakReferenceMatcher -> {
-              enqueue(
-                  graph,
-                  LibraryLeakNode(
-                      objectId, parent, LeakReference(INSTANCE_FIELD, field.name), referenceMatcher
-                  )
-              )
-            }
-          }
-        }
+    fieldNamesAndValues.forEach { field ->
+      val objectId = field.value.asObjectId!!
+      if (computeRetainedHeapSize) {
+        updateDominatorWithSkips(parent.instance, objectId)
+      }
+      val node = when (val referenceMatcher = fieldReferenceMatchers[field.name]) {
+        null -> NormalNode(objectId, parent, LeakReference(INSTANCE_FIELD, field.name))
+        is LibraryLeakReferenceMatcher ->
+          LibraryLeakNode(
+              objectId, parent, LeakReference(INSTANCE_FIELD, field.name), referenceMatcher
+          )
+        is IgnoredReferenceMatcher -> null
+      }
+      if (node != null) {
+        enqueue(node)
+      }
+    }
   }
 
-  private fun visitObjectArrayRecord(
-    graph: HeapGraph,
-    record: ObjectArrayDumpRecord,
-    parentNode: ReferencePathNode,
-    computeRetainedHeapSize: Boolean
+  private fun State.visitObjectArrayRecord(
+    objectArray: HeapObjectArray,
+    parent: ReferencePathNode
   ) {
-    record.elementIds.filter { objectId ->
+    val record = objectArray.readRecord()
+    val nonNullElementIds = record.elementIds.filter { objectId ->
       objectId != ValueHolder.NULL_REFERENCE && graph.objectExists(objectId).apply {
         if (!this) {
           // dalvik.system.PathClassLoader.runtimeInternalObjects references objects which don't
@@ -413,20 +398,16 @@ internal class ShortestPathFinder {
         }
       }
     }
-        .forEachIndexed { index, elementId ->
-          if (computeRetainedHeapSize) {
-            updateDominatorWithSkips(graph, parentNode.instance, elementId)
-          }
-          val name = Integer.toString(index)
-          enqueue(
-              graph,
-              NormalNode(elementId, parentNode, LeakReference(ARRAY_ENTRY, name))
-          )
-        }
+    nonNullElementIds.forEachIndexed { index, elementId ->
+      if (computeRetainedHeapSize) {
+        updateDominatorWithSkips(parent.instance, elementId)
+      }
+      val name = Integer.toString(index)
+      enqueue(NormalNode(elementId, parent, LeakReference(ARRAY_ENTRY, name)))
+    }
   }
 
-  private fun enqueue(
-    graph: HeapGraph,
+  private fun State.enqueue(
     node: ReferencePathNode
   ) {
     if (node.instance == ValueHolder.NULL_REFERENCE) {
@@ -439,10 +420,14 @@ internal class ShortestPathFinder {
     if (toVisitSet.contains(node.instance)) {
       return
     }
-    //
+
+    val visitLast =
+      node is LibraryLeakNode ||
+          (node is NormalNode && node.parent is RootNode && node.parent.gcRoot is JavaFrame)
+
     if (toVisitLastSet.contains(node.instance)) {
       // Already enqueued => shorter or equal distance amongst library leak ref patterns.
-      if (node is LibraryLeakNode) {
+      if (visitLast) {
         return
       } else {
         toVisitQueue.add(node)
@@ -476,7 +461,7 @@ internal class ShortestPathFinder {
         return
       }
     }
-    if (node is LibraryLeakNode) {
+    if (visitLast) {
       toVisitLastQueue.add(node)
       toVisitLastSet.add(node.instance)
     } else {
@@ -485,8 +470,7 @@ internal class ShortestPathFinder {
     }
   }
 
-  private fun updateDominatorWithSkips(
-    graph: HeapGraph,
+  private fun State.updateDominatorWithSkips(
     parentObjectId: Long,
     objectId: Long
   ) {
@@ -524,7 +508,7 @@ internal class ShortestPathFinder {
     }
   }
 
-  private fun updateDominator(
+  private fun State.updateDominator(
     parent: Long,
     instance: Long,
     neverEnqueued: Boolean
@@ -587,10 +571,7 @@ internal class ShortestPathFinder {
     }
   }
 
-  private fun undominateWithSkips(
-    graph: HeapGraph,
-    objectId: Long
-  ) {
+  private fun State.undominateWithSkips(objectId: Long) {
     when (val graphObject = graph.findObjectById(objectId)) {
       is HeapClass -> {
         undominate(objectId, false)
@@ -624,7 +605,7 @@ internal class ShortestPathFinder {
     }
   }
 
-  private fun undominate(
+  private fun State.undominate(
     instance: Long,
     neverEnqueued: Boolean
   ) {
diff --git a/shark/src/test/java/shark/HeapAnalyzerTest.kt b/shark/src/test/java/shark/HeapAnalyzerTest.kt
index 53bd1f5a..f0b7a901 100644
--- a/shark/src/test/java/shark/HeapAnalyzerTest.kt
+++ b/shark/src/test/java/shark/HeapAnalyzerTest.kt
@@ -7,6 +7,7 @@ import org.junit.Test
 import org.junit.rules.TemporaryFolder
 import shark.GcRoot.ThreadObject
 import shark.LeakTraceElement.Type.LOCAL
+import shark.LeakTraceElement.Type.STATIC_FIELD
 import shark.ValueHolder.ReferenceHolder
 import java.io.File
 
@@ -107,6 +108,18 @@ class HeapAnalyzerTest {
     assertThat(leak.leakTrace.elements[1].className).isEqualTo("Leaking")
   }
 
+  @Test fun localVariableLeakShortestPathGoesLast() {
+    hprofFile.writeTwoPathJavaLocalShorterLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+    println(analysis)
+
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.leakTrace.elements).hasSize(3)
+    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
+    assertThat(leak.leakTrace.elements[0].reference!!.type).isEqualTo(STATIC_FIELD)
+  }
+
   @Test fun threadFieldLeak() {
     hprofFile.dump {
       val threadClassId =
diff --git a/shark/src/test/java/shark/HeapDumps.kt b/shark/src/test/java/shark/HeapDumps.kt
index 8c8988da..961490af 100644
--- a/shark/src/test/java/shark/HeapDumps.kt
+++ b/shark/src/test/java/shark/HeapDumps.kt
@@ -136,4 +136,34 @@ fun File.writeJavaLocalLeak(
     val leaking = "Leaking" watchedInstance {}
     gcRoot(JavaFrame(id = leaking.value, threadSerialNumber = 42, frameNumber = 0))
   }
+}
+
+fun File.writeTwoPathJavaLocalShorterLeak(
+  threadClass: String,
+  threadName: String
+) {
+  dump {
+    val threadClassId =
+      clazz(className = "java.lang.Thread", fields = listOf("name" to ReferenceHolder::class))
+    val myThreadClassId = clazz(className = threadClass, superclassId = threadClassId)
+    val threadInstance = instance(myThreadClassId, listOf(string(threadName)))
+    gcRoot(
+        ThreadObject(
+            id = threadInstance.value, threadSerialNumber = 42, stackTraceSerialNumber = 0
+        )
+    )
+
+    val leaking = "Leaking" watchedInstance {}
+    gcRoot(JavaFrame(id = leaking.value, threadSerialNumber = 42, frameNumber = 0))
+
+    val hasLeaking = instance(
+        clazz("HasLeaking", fields = listOf("leaking" to ReferenceHolder::class)),
+        fields = listOf(leaking)
+    )
+    clazz(
+        "GcRoot", staticFields = listOf(
+        "longestPath" to hasLeaking
+    )
+    )
+  }
 }
\ No newline at end of file
diff --git a/shark/src/test/java/shark/LabelerTest.kt b/shark/src/test/java/shark/LabelerTest.kt
index bf4776f3..425d4caf 100644
--- a/shark/src/test/java/shark/LabelerTest.kt
+++ b/shark/src/test/java/shark/LabelerTest.kt
@@ -26,7 +26,7 @@ class LabelerTest {
         reporter: ObjectReporter
       ) {
         reporter.whenInstanceOf("java.lang.String")  { instance ->
-          addLabel("Hello ${instance.readAsJavaString()}")
+          labels += "Hello ${instance.readAsJavaString()}"
         }
       }
     }
diff --git a/shark/src/test/java/shark/LeakStatusTest.kt b/shark/src/test/java/shark/LeakStatusTest.kt
index 060ea61a..643d747a 100644
--- a/shark/src/test/java/shark/LeakStatusTest.kt
+++ b/shark/src/test/java/shark/LeakStatusTest.kt
@@ -32,7 +32,7 @@ class LeakStatusTest {
 
     val leak = analysis.applicationLeaks[0]
 
-    assertThat(leak.leakTrace.elements.first().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements.first().leakStatus).isEqualTo(NOT_LEAKING)
   }
 
   @Test fun leakingInstanceLeaking() {
@@ -42,7 +42,7 @@ class LeakStatusTest {
 
     val leak = analysis.applicationLeaks[0]
 
-    assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(LEAKING)
+    assertThat(leak.leakTrace.elements.last().leakStatus).isEqualTo(LEAKING)
   }
 
   @Test fun defaultsToUnknown() {
@@ -58,7 +58,7 @@ class LeakStatusTest {
 
     val leak = analysis.applicationLeaks[0]
 
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(UNKNOWN)
+    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(UNKNOWN)
   }
 
   @Test fun inspectorNotLeaking() {
@@ -75,7 +75,7 @@ class LeakStatusTest {
     )
 
     val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(NOT_LEAKING)
   }
 
   @Test fun inspectorLeaking() {
@@ -93,7 +93,7 @@ class LeakStatusTest {
       )
 
     val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(LEAKING)
+    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(LEAKING)
   }
 
   @Test fun leakingWinsUnknown() {
@@ -111,7 +111,7 @@ class LeakStatusTest {
       )
 
     val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(LEAKING)
+    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(LEAKING)
   }
 
   @Test fun notLeakingWhenNextIsNotLeaking() {
@@ -133,7 +133,7 @@ class LeakStatusTest {
       )
 
     val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(NOT_LEAKING)
   }
 
   @Test fun leakingWhenPreviousIsLeaking() {
@@ -156,7 +156,7 @@ class LeakStatusTest {
 
     val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements).hasSize(2)
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(LEAKING)
+    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(LEAKING)
   }
 
   @Test fun middleUnknown() {
@@ -180,7 +180,7 @@ class LeakStatusTest {
       )
 
     val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements[2].leakStatusAndReason.status).isEqualTo(UNKNOWN)
+    assertThat(leak.leakTrace.elements[2].leakStatus).isEqualTo(UNKNOWN)
   }
 
   @Test fun gcRootClassNotLeakingConflictingWithInspector() {
@@ -193,8 +193,8 @@ class LeakStatusTest {
 
     val leak = analysis.applicationLeaks[0]
 
-    assertThat(leak.leakTrace.elements.first().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements.first().leakStatusAndReason.reason).isEqualTo(
+    assertThat(leak.leakTrace.elements.first().leakStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements.first().leakStatusReason).isEqualTo(
         "a class is never leaking. Conflicts with GcRoot is leaking"
     )
   }
@@ -211,8 +211,8 @@ class LeakStatusTest {
 
     val leak = analysis.applicationLeaks[0]
 
-    assertThat(leak.leakTrace.elements.first().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements.first().leakStatusAndReason.reason).isEqualTo(
+    assertThat(leak.leakTrace.elements.first().leakStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements.first().leakStatusReason).isEqualTo(
         "GcRoot is not leaking and a class is never leaking"
     )
   }
@@ -225,8 +225,8 @@ class LeakStatusTest {
       )
 
     val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements.last().leakStatusAndReason.reason).isEqualTo(
+    assertThat(leak.leakTrace.elements.last().leakStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements.last().leakStatusReason).isEqualTo(
         "Leaking is not leaking. Conflicts with ObjectWatcher was watching this"
     )
   }
@@ -239,8 +239,8 @@ class LeakStatusTest {
       )
 
     val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(LEAKING)
-    assertThat(leak.leakTrace.elements.last().leakStatusAndReason.reason).isEqualTo(
+    assertThat(leak.leakTrace.elements.last().leakStatus).isEqualTo(LEAKING)
+    assertThat(leak.leakTrace.elements.last().leakStatusReason).isEqualTo(
         "Leaking is leaking and ObjectWatcher was watching this"
     )
   }
@@ -262,8 +262,8 @@ class LeakStatusTest {
       )
 
     val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.reason).isEqualTo(
+    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements[1].leakStatusReason).isEqualTo(
         "Class1 is not leaking. Conflicts with Class1 is leaking"
     )
   }
@@ -285,9 +285,9 @@ class LeakStatusTest {
       )
 
     val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.reason).isEqualTo(
-        "Class1 is not leaking and Class1 is not leaking"
+    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements[1].leakStatusReason).isEqualTo(
+        "Class1 is not leaking"
     )
   }
 
@@ -306,9 +306,9 @@ class LeakStatusTest {
       )
 
     val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(LEAKING)
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.reason).isEqualTo(
-        "Class1 is leaking and Class1 is leaking"
+    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(LEAKING)
+    assertThat(leak.leakTrace.elements[1].leakStatusReason).isEqualTo(
+        "Class1 is leaking"
     )
   }
 
@@ -431,7 +431,7 @@ class LeakStatusTest {
       ) {
         val record = reporter.heapObject
         if (record is HeapInstance && record.instanceClassName == className) {
-          reporter.reportNotLeaking("$className is not leaking")
+          reporter.notLeakingReasons += "$className is not leaking"
         }
       }
     }
@@ -444,7 +444,7 @@ class LeakStatusTest {
       ) {
         val record = reporter.heapObject
         if (record is HeapInstance && record.instanceClassName == className) {
-          reporter.reportLeaking("$className is leaking")
+          reporter.leakingReasons += "$className is leaking"
         }
       }
     }
@@ -457,7 +457,7 @@ class LeakStatusTest {
       ) {
         val record = reporter.heapObject
         if (record is HeapClass && record.name == className) {
-          reporter.reportNotLeaking("$className is not leaking")
+          reporter.notLeakingReasons += "$className is not leaking"
         }
       }
     }
@@ -470,7 +470,7 @@ class LeakStatusTest {
       ) {
         val record = reporter.heapObject
         if (record is HeapClass && record.name == className) {
-          reporter.reportLeaking("$className is leaking")
+          reporter.leakingReasons += "$className is leaking"
         }
       }
     }
diff --git a/shark/src/test/java/shark/LeakTraceRendererTest.kt b/shark/src/test/java/shark/LeakTraceRendererTest.kt
index 85612ebe..9f60e6bf 100644
--- a/shark/src/test/java/shark/LeakTraceRendererTest.kt
+++ b/shark/src/test/java/shark/LeakTraceRendererTest.kt
@@ -63,7 +63,7 @@ class LeakTraceRendererTest {
               reporter: ObjectReporter
             ) {
               reporter.whenInstanceOf("ClassB") {
-                reportLeaking("because reasons")
+                leakingReasons += "because reasons"
               }
             }
           })
@@ -97,7 +97,7 @@ class LeakTraceRendererTest {
           override fun inspect(
             reporter: ObjectReporter
           ) {
-            reporter.addLabel("Â¯\\_(ãƒ„)_/Â¯")
+            reporter.labels += "Â¯\\_(ãƒ„)_/Â¯"
           }
 
         })
diff --git a/shark/src/test/java/shark/TestUtil.kt b/shark/src/test/java/shark/TestUtil.kt
index 3d450d9d..60f9bccb 100644
--- a/shark/src/test/java/shark/TestUtil.kt
+++ b/shark/src/test/java/shark/TestUtil.kt
@@ -19,7 +19,7 @@ fun <T : HeapAnalysis> File.checkForLeaks(
     objectInspectors
   }
   val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
-  val result = heapAnalyzer.checkForLeaks(
+  val result = heapAnalyzer.analyze(
       this, referenceMatchers, computeRetainedHeapSize, inspectors
   )
   if (result is HeapAnalysisFailure) {
