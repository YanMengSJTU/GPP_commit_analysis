diff --git a/README.md b/README.md
index 67d8cced..3150132a 100644
--- a/README.md
+++ b/README.md
@@ -1,375 +1,580 @@
-# 🐤 LeakCanary
+大概一年以前，写过一篇 [LeakCanary 源码解析](https://juejin.im/post/5a9d46d2f265da237d0280a3) ，当时是基于 `1.5.4` 版本进行分析的 。Square 公司在今年四月份发布了全新的 `2.0` 版本，完全使用 Kotlin 进行重构，核心原理并没有太大变化，但是做了一定的性能优化。在本文中，就让我们通过源码来看看 `2.0` 版本发生了哪些变化。本文不会过多的分析源码细节，详细细节可以阅读我之前基于 `1.5.4` 版本写的文章，两个版本在原理方面并没有太大变化。
 
-A memory leak detection library for Android.
+> 含注释 fork 版本 [LeakCanary](https://github.com/lulululbj/leakcanary) 源码
 
-*“A small leak will sink a great ship.”* - Benjamin Franklin
+## 使用
 
-<p align="center">
-<img src="https://github.com/square/leakcanary/wiki/assets/screenshot-2.0.png"/>
-</p>
+首先来对比一下两个版本的使用方式。
 
-## Getting started
+### 1.5.4 版本
 
-Add LeakCanary to `build.gradle`:
+在老版本中，我们需要添加如下依赖：
 
-```gradle
+```
 dependencies {
-  // debugImplementation because LeakCanary should only run in debug builds.
-  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-2'
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.5.4'
+  releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.4'
 }
 ```
 
-**That's it, there is no code change needed!** LeakCanary will automatically show a notification when a memory leak is detected in debug builds.
-
-What's next?
-* Learn the [Fundamentals](#fundamentals)
-* Try the [code recipes](#code-recipes)
-* Read the [FAQ](#faq)
-* Watch [recorded presentations](https://github.com/square/leakcanary/wiki/Recorded-Presentations)
-* Read [blog articles](https://github.com/square/leakcanary/wiki/Blog-Articles)
+`leakcanary-android-no-op` 库在 `release` 版本中使用，其中是没有任何逻辑代码的。
 
-Note: **LeakCanary 2 is in alpha**.
-* Check out the [migration guide](https://github.com/square/leakcanary/wiki/Migrating-to-LeakCanary-2.0).
-* Here is the [change log](https://github.com/square/leakcanary/blob/master/CHANGELOG.md#version-20-alpha-2-2019-05-21).
-* To set up LeakCanary 1.6, go to the [1.6 Readme](https://github.com/square/leakcanary/blob/master/README-1.6.md).
+然后需要在自己的 `Application` 中进行初始化。
 
-## Fundamentals
+```java
+public class ExampleApplication extends Application {
 
-### What is a memory leak?
+  @Override public void onCreate() {
+    super.onCreate();
+    if (LeakCanary.isInAnalyzerProcess(this)) {
+      // This process is dedicated to LeakCanary for heap analysis.
+      // You should not init your app in this process.
+      return;
+    }
+    LeakCanary.install(this);
+    // Normal app init code...
+  }
+}
+```
 
-In a Java based runtime, a memory leak is a programming error that causes an application to keep a reference to an object that is no longer needed. As a result, the memory allocated for that object cannot be reclaimed, eventually leading to an OutOfMemoryError crash.
+`LeakCanary.install()` 执行后，就会构建 `RefWatcher` 对象，开始监听 `Activity.onDestroy()` 回调, 通过 `RefWatcher.watch()` 监测 Activity 引用的泄露情况。发现内存泄露之后进行 `heap dump` ，利用  `Square` 公司的另一个库 [haha](https://github.com/square/haha)（已废弃）来分析 heap dump 文件，找到引用链之后通知用户。这一套原理在新版本中还是没变的。
 
-For example, an Android activity instance is no longer needed after its `onDestroy()` method is called, and storing a reference to that activity in a static field would prevent it from being garbage collected.
+### 2.0 版本
 
-### Why should I use LeakCanary?
+新版本的使用更加方便了，你只需要在 `build.gradle` 文件中添加如下依赖：
 
-Memory leaks are very common in Android apps. OutOfMemoryError (OOM) is the top crash for most apps on the play store, however that's usually not counted correctly. When memory is low the OOM can be thrown from anywhere in your code, which means every OOM has a different stacktrace and they're counted as different crashes.
+```
+debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-2'
+```
 
-When we first enabled LeakCanary in the Square Point Of Sale app, we were able to find and fix several leaks and reduced the OutOfMemoryError crash rate by **94%**.
+是的，你没看过，这样就可以了。你肯定会有一个疑问，那它是如何初始化的呢？我刚看到这个使用文档的时候，同样也有这个疑问。当你看看源码之后就一目了然了。我先不解释，看一下源码中的 `LeakSentryInstaller` 这个类：
 
-### How does LeakCanary work?
+```kotlin
+/**
+ * Content providers are loaded before the application class is created. [LeakSentryInstaller] is
+ * used to install [leaksentry.LeakSentry] on application start.
+ *
+ * Content Provider 在 Application 创建之前被自动加载，因此无需用户手动在 onCrate() 中进行初始化
+ */
+internal class LeakSentryInstaller : ContentProvider() {
+
+  override fun onCreate(): Boolean {
+    CanaryLog.logger = DefaultCanaryLog()
+    val application = context!!.applicationContext as Application
+    InternalLeakSentry.install(application) // 进行初始化工作，核心
+    return true
+  }
 
-* The library automatically watches destroyed activities and destroyed fragments using weak references. You can also watch any instance that is no longer needed, e.g. a detached view.
-* If the weak references aren't cleared, after waiting 5 seconds and running the GC, the watched instances are considered *retained*, and potentially leaking.
-* When the number of retained instances reaches a threshold, LeakCanary dumps the Java heap into a `.hprof` file stored on the file system. The default threshold is 5 retained instances when the app is visible, 1 otherwise.
-* LeakCanary parses the `.hprof` file and finds the chain of references that prevents retained instances from being garbage collected (**leak trace**). A leak trace is technically the *shortest strong reference path from GC Roots to retained instances*, but that's a mouthful.
-* Once the leak trace is determined, LeakCanary uses its built in knowledge of the Android framework to deduct which instances in the leak trace are leaking. You can help LeakCanary by providing **Reachability inspectors** tailored to your own app.
-* Using the reachability information, LeakCanary narrows down the reference chain to a sub chain of possible leak causes, and displays the result. Leaks are grouped by identical sub chain.
+  override fun query(
+    uri: Uri,
+    strings: Array<String>?,
+    s: String?,
+    strings1: Array<String>?,
+    s1: String?
+  ): Cursor? {
+    return null
+  }
 
-### How do I fix a memory leak?
-To fix a memory leak, you need to look at the sub chain of possible leak causes and find which reference is causing the leak, i.e. which reference should have been cleared at the time of the leak. LeakCanary highlights with a red underline wave the references that are the possible causes of the leak.
+  override fun getType(uri: Uri): String? {
+    return null
+  }
 
-If you cannot figure out a leak, **please do not file an issue**. Instead, create a [Stack Overflow question](http://stackoverflow.com/questions/tagged/leakcanary) using the *leakcanary* tag.
+  override fun insert(
+    uri: Uri,
+    contentValues: ContentValues?
+  ): Uri? {
+    return null
+  }
 
-### LeakCanary artifacts
+  override fun delete(
+    uri: Uri,
+    s: String?,
+    strings: Array<String>?
+  ): Int {
+    return 0
+  }
 
-LeakCanary is released as several distinct libraries:
+  override fun update(
+    uri: Uri,
+    contentValues: ContentValues?,
+    s: String?,
+    strings: Array<String>?
+  ): Int {
+    return 0
+  }
+}
+```
 
-* LeakSentry
-  * Detects retained instances.
-  * Suitable for release builds.
-  * Artifact id: `com.squareup.leakcanary:leaksentry`.
-* LeakCanary
-  * Dumps the heap and analyzes it.
-  * Currently only suitable for debug builds.
-  * Depends on LeakSentry.
-  * Artifact id: `com.squareup.leakcanary:leakcanary-android`.
-* LeakCanary for Instrumentation tests
-  * Fails tests if a leak is detected
-  * Only suitable for Instrumentation tests
-  * Configures LeakCanary to wait for the end of tests before dumping the heap.
-  * Artifact id: `com.squareup.leakcanary:leakcanary-android-instrumentation`.
-  * See [Running LeakCanary in instrumentation tests](#running-leakcanary-in-instrumentation-tests)
+看到这个类你应该也明白了。LeakCanary 利用 `ContentProvier` 进行了初始化。`ContentProvier` 一般会在 `Application` 被创建之前被加载，LeakCanary 在其 `onCreate()` 方法中调用了 `InternalLeakSentry.install(application)` 进行初始化。这应该是我第一次看到第三方库这么进行初始化。这的确是方便了开发者，但是仔细想想弊端还是很大的，如果所有第三方库都这么干，开发者就没法控制应用启动时间了。很多开发者为了加快应用启动速度，都下了很大心血，包括按需延迟初始化第三方库。但在 LeakCanary 中，这个问题并不存在，因为它本身就是一个只在 debug 版本中使用的库，并不会对 release 版本有任何影响。
 
-## Code Recipes
+## 源码解析
 
-If you think a recipe might be missing or you're not sure that what you're trying to achieve is possible with the current APIs, please [file an issue](https://github.com/square/leakcanary/issues/new/choose). Your feedback help us make LeakCanary better for the entire community.
+前面提到了 `InternalLeakSentry.install()` 就是核心的初始化工作，其地位就和 1.5.4 版本中的 `LeakCanary.install()` 一样。下面就从 `install()` 方法开始，走进 `LeakCanary 2.0` 一探究竟。
 
-### Configuring LeakSentry
+### 1. LeakCanary.install()
 
-LeakSentry can be configured by replacing `LeakSentry.config`:
 ```kotlin
-class DebugExampleApplication : ExampleApplication() {
-
-  override fun onCreate() {
-    super.onCreate()
-    LeakSentry.config = LeakSentry.config.copy(watchFragmentViews = false)
-  }
+fun install(application: Application) {
+    CanaryLog.d("Installing LeakSentry")
+    checkMainThread() // 只能在主线程调用，否则会抛出异常
+    if (this::application.isInitialized) {
+      return
+    }
+    InternalLeakSentry.application = application
+
+    val configProvider = { LeakSentry.config }
+    ActivityDestroyWatcher.install( // 监听 Activity.onDestroy()，见 1.1
+        application, refWatcher, configProvider
+    )
+    FragmentDestroyWatcher.install( // 监听 Fragment.onDestroy()，见 1.2
+        application, refWatcher, configProvider
+    )
+    listener.onLeakSentryInstalled(application) // 见 1.3
 }
 ```
 
-### Configuring LeakCanary
+`install()` 方法主要做了三件事:
+
+* 注册 `Activity.onDestroy()` 监听
+* 注册 `Fragment.onDestroy()` 监听
+* 监听完成后进行一些初始化工作
 
-LeakCanary can be configured by replacing `LeakCanary.config`:
+依次看一看。
+
+#### 1.1 ActivityDestroyWatcher.install()
+
+`ActivityDestroyWatcher` 类的源码很简单：
 
 ```kotlin
-disableLeakCanaryButton.setOnClickListener {
-  LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
+internal class ActivityDestroyWatcher private constructor(
+  private val refWatcher: RefWatcher,
+  private val configProvider: () -> Config
+) {
+
+  private val lifecycleCallbacks = object : ActivityLifecycleCallbacksAdapter() {
+    override fun onActivityDestroyed(activity: Activity) {
+      if (configProvider().watchActivities) {
+        refWatcher.watch(activity) // 监听到 onDestroy() 之后，通过 refWatcher 监测 Activity
+      }
+    }
+  }
+
+  companion object {
+    fun install(
+      application: Application,
+      refWatcher: RefWatcher,
+      configProvider: () -> Config
+    ) {
+      val activityDestroyWatcher =
+        ActivityDestroyWatcher(refWatcher, configProvider)
+      // 注册 Activity 生命周期监听
+      application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)
+    }
+  }
 }
 ```
 
-### Watching objects with a lifecycle
+`install()` 方法中注册了 Activity 生命周期监听，在监听到 `onDestroy()` 时，调用 `RefWatcher.watch()` 方法开始监测 Activity。
+
+#### 1.2 FragmentDestroyWatcher.install()
 
-In your application, you may have other objects with a lifecycle, such as fragments, services, Dagger components, etc. Use `LeakSentry.refWatcher` to watch instances that should be garbage collected:
+`FragmentDestroyWatcher` 是一个接口，它有两个实现类 `AndroidOFragmentDestroyWatcher` 和 `SupportFragmentDestroyWatcher`。
 
 ```kotlin
-class MyService : Service {
+internal interface FragmentDestroyWatcher {
+
+  fun watchFragments(activity: Activity)
+
+  companion object {
+
+    private const val SUPPORT_FRAGMENT_CLASS_NAME = "androidx.fragment.app.Fragment"
+
+    fun install(
+      application: Application,
+      refWatcher: RefWatcher,
+      configProvider: () -> LeakSentry.Config
+    ) {
+      val fragmentDestroyWatchers = mutableListOf<FragmentDestroyWatcher>()
+
+      if (SDK_INT >= O) { // >= 26，使用 AndroidOFragmentDestroyWatcher
+        fragmentDestroyWatchers.add(
+            AndroidOFragmentDestroyWatcher(refWatcher, configProvider)
+        )
+      }
+
+      if (classAvailable(
+              SUPPORT_FRAGMENT_CLASS_NAME
+          )
+      ) {
+        fragmentDestroyWatchers.add( // androidx 使用 SupportFragmentDestroyWatcher
+            SupportFragmentDestroyWatcher(refWatcher, configProvider)
+        )
+      }
 
-  // ...
+      if (fragmentDestroyWatchers.size == 0) {
+        return
+      }
 
-  override fun onDestroy() {
-    super.onDestroy()
-    LeakSentry.refWatcher.watch(this)
+      application.registerActivityLifecycleCallbacks(object : ActivityLifecycleCallbacksAdapter() {
+        override fun onActivityCreated(
+          activity: Activity,
+          savedInstanceState: Bundle?
+        ) {
+          for (watcher in fragmentDestroyWatchers) {
+            watcher.watchFragments(activity)
+          }
+        }
+      })
+    }
+
+    private fun classAvailable(className: String): Boolean {
+      return try {
+        Class.forName(className)
+        true
+      } catch (e: ClassNotFoundException) {
+        false
+      }
+    }
   }
 }
 ```
 
-### Counting retained instances in production
+如果我没记错的话，`1.5.4` 是不监测 Fragment 的泄露的。而 `2.0` 版本提供了对 `Android O` 以及 `androidx` 版本中的 Fragment 的内存泄露检测。 `AndroidOFragmentDestroyWatcher` 和 `SupportFragmentDestroyWatcher` 的实现代码其实是一致的，Android O 及以后，androidx 都具备对 Fragment 生命周期的监听功能。以 `AndroidOFragmentDestroyWatcher` 为例，简单看一下它的实现。
 
-`com.squareup.leakcanary:leakcanary-android` should only be used in debug builds. It depends on `com.squareup.leakcanary:leaksentry` which you can use in production to track and count retained instances.
+```kotlin
+@RequiresApi(Build.VERSION_CODES.O) //
+internal class AndroidOFragmentDestroyWatcher(
+  private val refWatcher: RefWatcher,
+  private val configProvider: () -> Config
+) : FragmentDestroyWatcher {
+
+  private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {
+
+    override fun onFragmentViewDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      val view = fragment.view
+      if (view != null && configProvider().watchFragmentViews) {
+        refWatcher.watch(view)
+      }
+    }
 
-In your `build.gradle`:
+    override fun onFragmentDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      if (configProvider().watchFragments) {
+        refWatcher.watch(fragment)
+      }
+    }
+  }
 
-```gradle
-dependencies {
-  implementation 'com.squareup.leakcanary:leaksentry:2.0-alpha-2'
+  override fun watchFragments(activity: Activity) {
+    val fragmentManager = activity.fragmentManager
+    fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)
+  }
 }
 ```
 
-In your leak reporting code:
-```kotlin
-val retainedInstanceCount = LeakSentry.refWatcher.retainedKeys.size
-```
+同样，还是使用 `RefWatcher.watch()` 方法来进行监测。
 
-### Running LeakCanary in instrumentation tests
+#### 1.3 listener.onLeakSentryInstalled()
 
-Add the `leakcanary-android-instrumentation` dependency to your instrumentation tests:
+`onLeakSentryInstalled()` 回调中会初始化一些检测内存泄露过程中需要的对象，如下所示：
 
-```
-androidTestImplementation "com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion}"
-```
+```kotlin
+override fun onLeakSentryInstalled(application: Application) {
+    this.application = application
 
-Add the dedicated run listener to `defaultConfig` in your `build.gradle`:
+    val heapDumper = AndroidHeapDumper(application, leakDirectoryProvider) // 用于 heap dump
 
-```
-android {
-  defaultConfig {
-    // ...
+    val gcTrigger = GcTrigger.Default // 用于手动调用 GC
 
-    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
-    testInstrumentationRunnerArgument "listener", "leakcanary.FailTestOnLeakRunListener"
-  }
+    val configProvider = { LeakCanary.config } // 配置项
+
+    val handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)
+    handlerThread.start()
+    val backgroundHandler = Handler(handlerThread.looper) // 发起内存泄漏检测的线程
+
+    heapDumpTrigger = HeapDumpTrigger(
+        application, backgroundHandler, LeakSentry.refWatcher, gcTrigger, heapDumper, configProvider
+    )
+    application.registerVisibilityListener { applicationVisible ->
+      this.applicationVisible = applicationVisible
+      heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)
+    }
+    addDynamicShortcut(application)
 }
 ```
 
-Run the instrumentation tests:
+对老版本代码熟悉的同学，看到这些对象应该很熟悉。
 
-```
-./gradlew leakcanary-sample:connectedCheck
-```
+* `heapDumper` 用于确认内存泄漏之后进行 heap dump 工作。
+* `gcTrigger` 用于发现可能的内存泄漏之后手动调用 GC 确认是否真的为内存泄露。
 
-You can extend `FailTestOnLeakRunListener` to customize the behavior.
+这两个对象是 LeakCanary 检测内存泄漏的核心。后面会进行详细分析。
 
-### Icon and label
+到这里，整个 LeakCanary 的初始化工作就完成了。与 1.5.4 版本不同的是，新版本增加了对 Fragment 以及 androidx 的支持。当发生 `Activity.onDestroy()` ，`Fragment.onFragmentViewDestroyed()` , `Fragment.onFragmentDestroyed()` 三者之一时，`RefWatcher` 就开始工作了，调用其 `watch()` 方法开始检测引用是否泄露。
 
-The activity that displays leaks comes with a default icon and label, which you can change by providing `R.mipmap.leak_canary_icon` and `R.string.leak_canary_display_activity_label` in your app:
+### 2. RefWatcher.watch()
 
-```
-res/
-  mipmap-hdpi/
-    leak_canary_icon.png
-  mipmap-mdpi/
-    leak_canary_icon.png
-  mipmap-xhdpi/
-    leak_canary_icon.png
-  mipmap-xxhdpi/
-    leak_canary_icon.png
-  mipmap-xxxhdpi/
-    leak_canary_icon.png
-   mipmap-anydpi-v26/
-     leak_canary_icon.xml
-```
+在看源码之前，我们先来看几个后面会使用到的队列。
 
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-  <string name="leak_canary_display_activity_label">MyLeaks</string>
-</resources>
+```kotlin
+  /**
+   * References passed to [watch] that haven't made it to [retainedReferences] yet.
+   * watch() 方法传进来的引用，尚未判定为泄露
+   */
+  private val watchedReferences = mutableMapOf<String, KeyedWeakReference>()
+  /**
+   * References passed to [watch] that we have determined to be retained longer than they should
+   * have been.
+   * watch() 方法传进来的引用，已经被判定为泄露
+   */
+  private val retainedReferences = mutableMapOf<String, KeyedWeakReference>()
+  private val queue = ReferenceQueue<Any>() // 引用队列，配合弱引用使用
 ```
 
-### Uploading to a server
+通过 `watch()` 方法传入的引用都会保存在 `watchedReferences` 中，被判定泄露之后保存在 `retainedReferences` 中。注意，这里的判定过程不止会发生一次，已经进入队列 `retainedReferences` 的引用仍有可能被移除。`queue` 是一个 `ReferenceQueue` 引用队列，配合弱引用使用，这里记住一句话：
+
+> 弱引用一旦变得弱可达，就会立即入队。这将在 finalization 或者 GC 之前发生。
 
-You can change the default behavior to upload the analysis result to a server of your choosing.
+也就是说，会被 GC 回收的对象引用，会保存在队列 `queue` 中。
 
-Create a custom `AnalysisResultListener` that delegates to the default: 
+回头再来看看 `watch()` 方法的源码。
 
 ```kotlin
-class LeakUploader : AnalysisResultListener {
-  override fun invoke(
-    application: Application,
-    heapAnalysis: HeapAnalysis
+  @Synchronized fun watch(
+    watchedReference: Any,
+    referenceName: String
   ) {
-    TODO("Upload heap analysis to server")
+    if (!isEnabled()) {
+      return
+    }
+    removeWeaklyReachableReferences() // 移除队列中将要被 GC 的引用，见 2.1
+    val key = UUID.randomUUID()
+        .toString()
+    val watchUptimeMillis = clock.uptimeMillis()
+    val reference = // 构建当前引用的弱引用对象，并关联引用队列 queue
+      KeyedWeakReference(watchedReference, key, referenceName, watchUptimeMillis, queue)
+    if (referenceName != "") {
+      CanaryLog.d(
+          "Watching instance of %s named %s with key %s", reference.className,
+          referenceName, key
+      )
+    } else {
+      CanaryLog.d(
+          "Watching instance of %s with key %s", reference.className, key
+      )
+    }
 
-    // Delegate to default behavior (notification and saving result)
-    DefaultAnalysisResultListener(application, heapAnalysis)
+    watchedReferences[key] = reference // 将引用存入 watchedReferences
+    checkRetainedExecutor.execute {
+      moveToRetained(key) // 如果当前引用未被移除，仍在 watchedReferences  队列中，
+                          // 说明仍未被 GC，移入 retainedReferences 队列中,暂时标记为泄露
+                          // 见 2.2
+    }
   }
-}
 ```
 
-Set `analysisResultListener` on the LeakCanary config:
+逻辑还是比较清晰的，首先会调用 `removeWeaklyReachableReferences()` 方法，这个方法在整个过程中会多次调用。其作用是移除 `watchedReferences` 中将被 GC 的引用。
 
-```kotlin
-class DebugExampleApplication : ExampleApplication() {
+#### 2.1 removeWeaklyReachableReferences()
 
-  override fun onCreate() {
-    super.onCreate()
-    LeakCanary.config = LeakCanary.config.copy(analysisResultListener = LeakUploader())
+```kotlin
+  private fun removeWeaklyReachableReferences() {
+    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
+    // reachable. This is before finalization or garbage collection has actually happened.
+    // 弱引用一旦变得弱可达，就会立即入队。这将在 finalization 或者 GC 之前发生。
+    var ref: KeyedWeakReference?
+    do {
+      ref = queue.poll() as KeyedWeakReference? // 队列 queue 中的对象都是会被 GC 的
+      if (ref != null) {
+        val removedRef = watchedReferences.remove(ref.key)
+        if (removedRef == null) {
+          retainedReferences.remove(ref.key)
+        }
+        // 移除 watchedReferences 队列中的会被 GC 的 ref 对象，剩下的就是可能泄露的对象
+      }
+    } while (ref != null)
   }
-}
 ```
 
+整个过程中会多次调用，以确保将已经入队 `queue` 的将被 GC 的对象引用移除掉，避免无谓的 heap dump 操作。而仍在 `watchedReferences` 队列中的引用，则可能已经泄露，移到队列 `retainedReferences` 中，这就是 `moveToRetained()` 方法的逻辑。代码如下：
 
-### Identifying 3rd party leaks as "won't fix"
+#### 2.2 moveToRetained()
 
-Set `exclusionsFactory` on the LeakCanary config to a `ExclusionsFactory` that delegates to the default one and then and add custom exclusions:
+```kotlin
+  @Synchronized private fun moveToRetained(key: String) {
+    removeWeaklyReachableReferences() // 再次调用，防止遗漏
+    val retainedRef = watchedReferences.remove(key)
+    if (retainedRef != null) {
+      retainedReferences[key] = retainedRef
+      onReferenceRetained()
+    }
+  }
+```
+
+这里的 `onReferenceRetained()` 最后会回调到 `InternalLeakCanary.kt` 中。
 
 ```kotlin
-class DebugExampleApplication : ExampleApplication() {
-
-  override fun onCreate() {
-    super.onCreate()
-    LeakCanary.config = LeakCanary.config.copy(exclusionsFactory = { hprofParser ->
-      val defaultFactory = AndroidExcludedRefs.exclusionsFactory(AndroidExcludedRefs.appDefaults)
-      val appDefaults = defaultFactory(hprofParser)
-      val customExclusion = Exclusion(
-          type = StaticFieldExclusion("com.thirdparty.SomeSingleton", "sContext"),
-          status = Exclusion.Status.WONT_FIX_LEAK,
-          reason = "SomeSingleton in library X has a static field leaking a context."
-      )
-      appDefaults + customExclusion
-    })
+  override fun onReferenceRetained() {
+    if (this::heapDumpTrigger.isInitialized) {
+      heapDumpTrigger.onReferenceRetained()
+    }
   }
-}
 ```
 
-### Identifying leaking instances and labeling instances
+调用了 `HeapDumpTrigger` 的 `onReferenceRetained()` 方法。
 
 ```kotlin
-class DebugExampleApplication : ExampleApplication() {
+  fun onReferenceRetained() {
+    scheduleRetainedInstanceCheck("found new instance retained")
+  }
 
-  override fun onCreate() {
-    super.onCreate()
-    val customLabeler: Labeler = { parser, node ->
-      listOf("Heap dump object id is ${node.instance}")
+    private fun scheduleRetainedInstanceCheck(reason: String) {
+    if (checkScheduled) {
+      return
     }
-    val labelers = AndroidLabelers.defaultAndroidLabelers(this) + customLabeler
-
-    val customInspector: LeakInspector = { parser, node ->
-      with(parser) {
-        if (node.instance.objectRecord.isInstanceOf("com.example.MySingleton")) {
-          LeakNodeStatus.notLeaking("MySingleton is a singleton")
-        } else LeakNodeStatus.unknown()
-      }
+    checkScheduled = true
+    backgroundHandler.post {
+      checkScheduled = false
+      checkRetainedInstances(reason) // 检测泄露实例
     }
-    val leakInspectors = AndroidLeakInspectors.defaultAndroidInspectors() + customInspector
-
-    LeakCanary.config = LeakCanary.config.copy(labelers = labelers, leakInspectors = leakInspectors)
   }
-}
 ```
 
-## FAQ
-
-### Can a leak be caused by the Android SDK?
+`checkRetainedInstances()` 方法是确定泄露的最后一个方法了。这里会确认引用是否真的泄露，如果真的泄露，则发起 heap dump，分析 dump 文件，找到引用链，最后通知用户。整体流程和老版本是一致的，但在一些细节处理，以及 dump 文件的分析上有所区别。下面还是通过源码来看看这些区别。
 
-Yes. There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: [AndroidExcludedRefs.kt](https://github.com/square/leakcanary/blob/master/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt).
-
-If you find a new one, please [create an issue](https://github.com/square/leakcanary/issues/new/choose) and follow these steps:
+```kotlin
+  private fun checkRetainedInstances(reason: String) {
+    CanaryLog.d("Checking retained instances because %s", reason)
+    val config = configProvider()
+    // A tick will be rescheduled when this is turned back on.
+    if (!config.dumpHeap) {
+      return
+    }
 
-1. Provide the entire leak trace information (reference key, device, etc), and use backticks (`) for formatting.
-2. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions [android/platform_frameworks_base](https://github.com/android/platform_frameworks_base).
-3. Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed.
-4. If it's still happening, build a simple repro case
-5. File an issue on [b.android.com](http://b.android.com) with the leak trace and the repro case
-6. Create a PR in LeakCanary to update `AndroidExcludedRefs.kt`. Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
+    var retainedKeys = refWatcher.retainedKeys
 
-### How do I share a leak trace?
+    // 当前泄露实例个数小于 5 个，不进行 heap dump
+    if (checkRetainedCount(retainedKeys, config.retainedVisibleThreshold)) return
 
-* Go to the leak screen, click the overflow menu and select *Share Info*.
-* You can also find the leak trace in Logcat.
+    if (!config.dumpHeapWhenDebugging && DebuggerControl.isDebuggerAttached) {
+      showRetainedCountWithDebuggerAttached(retainedKeys.size)
+      scheduleRetainedInstanceCheck("debugger was attached", WAIT_FOR_DEBUG_MILLIS)
+      CanaryLog.d(
+          "Not checking for leaks while the debugger is attached, will retry in %d ms",
+          WAIT_FOR_DEBUG_MILLIS
+      )
+      return
+    }
 
-### How can I dig beyond the leak trace?
+    // 可能存在被观察的引用将要变得弱可达，但是还未入队引用队列。
+    // 这时候应该主动调用一次 GC，可能可以避免一次 heap dump
+    gcTrigger.runGc()
 
-Sometimes the leak trace isn't enough and you need to dig into a heap dump with [MAT](http://eclipse.org/mat/) or [YourKit](https://www.yourkit.com/).
+    retainedKeys = refWatcher.retainedKeys
 
-* Go to a heap analysis screen, click the overflow menu and select *Share Heap Dump*.
+    if (checkRetainedCount(retainedKeys, config.retainedVisibleThreshold)) return
 
-Here's how you can find the leaking instance in the heap dump:
+    HeapDumpMemoryStore.setRetainedKeysForHeapDump(retainedKeys)
 
-1. Look for all instances of `leakcanary.KeyedWeakReference`
-2. For each of these, look at the `key` field.
-3. Find the `KeyedWeakReference` that has a `key` field equal to the reference key reported by LeakCanary.
-4. The `referent` field of that `KeyedWeakReference` is your leaking object.
-5. From then on, the matter is in your hands. A good start is to look at the shortest path to GC Roots (excluding weak references).
+    CanaryLog.d("Found %d retained references, dumping the heap", retainedKeys.size)
+    HeapDumpMemoryStore.heapDumpUptimeMillis = SystemClock.uptimeMillis()
+    dismissNotification()
+    val heapDumpFile = heapDumper.dumpHeap() // AndroidHeapDumper
+    if (heapDumpFile == null) {
+      CanaryLog.d("Failed to dump heap, will retry in %d ms", WAIT_AFTER_DUMP_FAILED_MILLIS)
+      scheduleRetainedInstanceCheck("failed to dump heap", WAIT_AFTER_DUMP_FAILED_MILLIS)
+      showRetainedCountWithHeapDumpFailed(retainedKeys.size)
+      return
+    }
 
-### How many methods does LeakCanary add?
+    refWatcher.removeRetainedKeys(retainedKeys) // 移除已经 heap dump 的 retainedKeys
 
-**0**. LeakCanary is a debug only library.
+    HeapAnalyzerService.runAnalysis(application, heapDumpFile) // 分析 heap dump 文件
+  }
+```
 
-### How do I use the SNAPSHOT version?
+首先调用 `checkRetainedCount()` 函数判断当前泄露实例个数如果小于 5 个，仅仅只是给用户一个通知，不会进行 heap dump 操作，并在 5s 后再次发起检测。这是和老版本一个不同的地方。
 
-Update your dependencies to the latest SNAPSHOT (see [build.gradle](https://github.com/square/leakcanary/blob/master/build.gradle)):
+```kotlin
+  private fun checkRetainedCount(
+    retainedKeys: Set<String>,
+    retainedVisibleThreshold: Int // 默认为 5 个
+  ): Boolean {
+    if (retainedKeys.isEmpty()) {
+      CanaryLog.d("No retained instances")
+      dismissNotification()
+      return true
+    }
 
-```gradle
- dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-3-SNAPSHOT'
- }
+    if (retainedKeys.size < retainedVisibleThreshold) {
+      if (applicationVisible || applicationInvisibleLessThanWatchPeriod) {
+        CanaryLog.d(
+            "Found %d retained instances, which is less than the visible threshold of %d",
+            retainedKeys.size,
+            retainedVisibleThreshold
+        )
+        // 通知用户 "App visible, waiting until 5 retained instances"
+        showRetainedCountBelowThresholdNotification(retainedKeys.size, retainedVisibleThreshold)
+        scheduleRetainedInstanceCheck( // 5s 后再次发起检测
+            "Showing retained instance notification", WAIT_FOR_INSTANCE_THRESHOLD_MILLIS
+        )
+        return true
+      }
+    }
+    return false
+  }
 ```
 
-Add Sonatype's `snapshots` repository:
+当集齐 5 个泄露实例之后，也并不会立马进行 heap dump。而是先手动调用一次 GC。当然不是使用 `System.gc()`，如下所示：
 
-```
-  repositories {
-    mavenCentral()
-    maven {
-      url 'https://oss.sonatype.org/content/repositories/snapshots/'
+```kotlin
+  object Default : GcTrigger {
+    override fun runGc() {
+      // Code taken from AOSP FinalizationTest:
+      // https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
+      // java/lang/ref/FinalizationTester.java
+      // System.gc() does not garbage collect every time. Runtime.gc() is
+      // more likely to perform a gc.
+      Runtime.getRuntime()
+          .gc()
+      enqueueReferences()
+      System.runFinalization()
     }
-  }
 ```
 
-Status of the snapshot build: [![Build Status](https://travis-ci.org/square/leakcanary.svg?branch=master)](https://travis-ci.org/square/leakcanary)
+那么，为什么要进行这次 GC 呢？可能存在被观察的引用将要变得弱可达，但是还未入队引用队列的情况。这时候应该主动调用一次 GC，可能可以避免一次额外的 heap dump 。GC 之后再次调用 `checkRetainedCount()` 判断泄露实例个数。如果此时仍然满足条件，就要发起 heap dump 操作了。具体逻辑在 `AndroidHeapDumper.dumpHeap()` 方法中，核心方法就是下面这句代码：
 
-### Who's behind LeakCanary?
+```kotlin
+Debug.dumpHprofData(heapDumpFile.absolutePath)
+```
 
-LeakCanary was created and open sourced by [@pyricau](https://github.com/pyricau), with [many contributions](https://github.com/square/leakcanary/graphs/contributors) from the community.
+生成 heap dump 文件之后，要删除已经处理过的引用，
 
-### Why is it called LeakCanary?
+```
+refWatcher.removeRetainedKeys(retainedKeys)
+```
 
-The name **LeakCanary** is a reference to the expression [canary in a coal mine](http://en.wiktionary.org/wiki/canary_in_a_coal_mine), because LeakCanary is a sentinel used to detect risks by providing advance warning of a danger. Props to [@edenman](https://github.com/edenman) for suggesting it!
+最后启动一个前台服务 `HeapAnalyzerService` 来分析 heap dump 文件。老版本中是使用 Square 自己的 haha 库来解析的，这个库已经废弃了，Square 完全重写了解析库，主要逻辑都在 moudle `leakcanary-analyzer` 中。这部分我还没有阅读，就不在这里分析了。对于新的解析器，官网是这样介绍的：
 
-### Who made the logo?
+> Uses 90% less memory and 6 times faster than the prior heap parser.
 
-* [@pyricau](https://github.com/pyricau) quickly made the [first version](https://github.com/square/leakcanary/blob/f0cc04dfbf3cca92a669f0d250034d410eb05816/assets/icon_512.png) of the logo. It was based on cliparts from [Android Asset Studio](http://romannurik.github.io/AndroidAssetStudio/icons-generic.html), mixed with the selection from a photo of a Canary. The exclamation mark means danger, the shield stands for protection, and the bird, well, is a canary.
-* [@romainguy](https://github.com/romainguy) turned the ugly logo into [a nice vector asset](https://github.com/square/leakcanary/pull/36).
-* [@flickator](https://github.com/flickator) designed [a much nicer logo](https://github.com/square/leakcanary/pull/1269) for LeakCanary 2.0!
+减少了 90% 的内存占用，而且比原来快了 6 倍。后面有时间单独来分析一下这个解析库。
 
-<p align="center">
-<img src="https://github.com/square/leakcanary/wiki/assets/logo-2.0.png" />
-</p>
+后面的过程就不再赘述了，通过解析库找到最短 GC Roots 引用路径，然后展示给用户。
 
-## License
+## 总结
 
-    Copyright 2015 Square, Inc.
+通读完源码，LeakCanary 2 还是带来了很多的优化。与老版本相比，主要有以下不同：
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+* 百分之百使用 Kotlin 重写
+* 自动初始化，无需用户手动再添加初始化代码
+* 支持 fragment，支持 androidx
+* 当泄露引用到达 5 个时才会发起 heap dump
+* 全新的 heap parser，减少 90% 内存占用，提升 6 倍速度
 
-       http://www.apache.org/licenses/LICENSE-2.0
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
diff --git a/README_origin.md b/README_origin.md
new file mode 100644
index 00000000..67d8cced
--- /dev/null
+++ b/README_origin.md
@@ -0,0 +1,375 @@
+# 🐤 LeakCanary
+
+A memory leak detection library for Android.
+
+*“A small leak will sink a great ship.”* - Benjamin Franklin
+
+<p align="center">
+<img src="https://github.com/square/leakcanary/wiki/assets/screenshot-2.0.png"/>
+</p>
+
+## Getting started
+
+Add LeakCanary to `build.gradle`:
+
+```gradle
+dependencies {
+  // debugImplementation because LeakCanary should only run in debug builds.
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-2'
+}
+```
+
+**That's it, there is no code change needed!** LeakCanary will automatically show a notification when a memory leak is detected in debug builds.
+
+What's next?
+* Learn the [Fundamentals](#fundamentals)
+* Try the [code recipes](#code-recipes)
+* Read the [FAQ](#faq)
+* Watch [recorded presentations](https://github.com/square/leakcanary/wiki/Recorded-Presentations)
+* Read [blog articles](https://github.com/square/leakcanary/wiki/Blog-Articles)
+
+Note: **LeakCanary 2 is in alpha**.
+* Check out the [migration guide](https://github.com/square/leakcanary/wiki/Migrating-to-LeakCanary-2.0).
+* Here is the [change log](https://github.com/square/leakcanary/blob/master/CHANGELOG.md#version-20-alpha-2-2019-05-21).
+* To set up LeakCanary 1.6, go to the [1.6 Readme](https://github.com/square/leakcanary/blob/master/README-1.6.md).
+
+## Fundamentals
+
+### What is a memory leak?
+
+In a Java based runtime, a memory leak is a programming error that causes an application to keep a reference to an object that is no longer needed. As a result, the memory allocated for that object cannot be reclaimed, eventually leading to an OutOfMemoryError crash.
+
+For example, an Android activity instance is no longer needed after its `onDestroy()` method is called, and storing a reference to that activity in a static field would prevent it from being garbage collected.
+
+### Why should I use LeakCanary?
+
+Memory leaks are very common in Android apps. OutOfMemoryError (OOM) is the top crash for most apps on the play store, however that's usually not counted correctly. When memory is low the OOM can be thrown from anywhere in your code, which means every OOM has a different stacktrace and they're counted as different crashes.
+
+When we first enabled LeakCanary in the Square Point Of Sale app, we were able to find and fix several leaks and reduced the OutOfMemoryError crash rate by **94%**.
+
+### How does LeakCanary work?
+
+* The library automatically watches destroyed activities and destroyed fragments using weak references. You can also watch any instance that is no longer needed, e.g. a detached view.
+* If the weak references aren't cleared, after waiting 5 seconds and running the GC, the watched instances are considered *retained*, and potentially leaking.
+* When the number of retained instances reaches a threshold, LeakCanary dumps the Java heap into a `.hprof` file stored on the file system. The default threshold is 5 retained instances when the app is visible, 1 otherwise.
+* LeakCanary parses the `.hprof` file and finds the chain of references that prevents retained instances from being garbage collected (**leak trace**). A leak trace is technically the *shortest strong reference path from GC Roots to retained instances*, but that's a mouthful.
+* Once the leak trace is determined, LeakCanary uses its built in knowledge of the Android framework to deduct which instances in the leak trace are leaking. You can help LeakCanary by providing **Reachability inspectors** tailored to your own app.
+* Using the reachability information, LeakCanary narrows down the reference chain to a sub chain of possible leak causes, and displays the result. Leaks are grouped by identical sub chain.
+
+### How do I fix a memory leak?
+To fix a memory leak, you need to look at the sub chain of possible leak causes and find which reference is causing the leak, i.e. which reference should have been cleared at the time of the leak. LeakCanary highlights with a red underline wave the references that are the possible causes of the leak.
+
+If you cannot figure out a leak, **please do not file an issue**. Instead, create a [Stack Overflow question](http://stackoverflow.com/questions/tagged/leakcanary) using the *leakcanary* tag.
+
+### LeakCanary artifacts
+
+LeakCanary is released as several distinct libraries:
+
+* LeakSentry
+  * Detects retained instances.
+  * Suitable for release builds.
+  * Artifact id: `com.squareup.leakcanary:leaksentry`.
+* LeakCanary
+  * Dumps the heap and analyzes it.
+  * Currently only suitable for debug builds.
+  * Depends on LeakSentry.
+  * Artifact id: `com.squareup.leakcanary:leakcanary-android`.
+* LeakCanary for Instrumentation tests
+  * Fails tests if a leak is detected
+  * Only suitable for Instrumentation tests
+  * Configures LeakCanary to wait for the end of tests before dumping the heap.
+  * Artifact id: `com.squareup.leakcanary:leakcanary-android-instrumentation`.
+  * See [Running LeakCanary in instrumentation tests](#running-leakcanary-in-instrumentation-tests)
+
+## Code Recipes
+
+If you think a recipe might be missing or you're not sure that what you're trying to achieve is possible with the current APIs, please [file an issue](https://github.com/square/leakcanary/issues/new/choose). Your feedback help us make LeakCanary better for the entire community.
+
+### Configuring LeakSentry
+
+LeakSentry can be configured by replacing `LeakSentry.config`:
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakSentry.config = LeakSentry.config.copy(watchFragmentViews = false)
+  }
+}
+```
+
+### Configuring LeakCanary
+
+LeakCanary can be configured by replacing `LeakCanary.config`:
+
+```kotlin
+disableLeakCanaryButton.setOnClickListener {
+  LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
+}
+```
+
+### Watching objects with a lifecycle
+
+In your application, you may have other objects with a lifecycle, such as fragments, services, Dagger components, etc. Use `LeakSentry.refWatcher` to watch instances that should be garbage collected:
+
+```kotlin
+class MyService : Service {
+
+  // ...
+
+  override fun onDestroy() {
+    super.onDestroy()
+    LeakSentry.refWatcher.watch(this)
+  }
+}
+```
+
+### Counting retained instances in production
+
+`com.squareup.leakcanary:leakcanary-android` should only be used in debug builds. It depends on `com.squareup.leakcanary:leaksentry` which you can use in production to track and count retained instances.
+
+In your `build.gradle`:
+
+```gradle
+dependencies {
+  implementation 'com.squareup.leakcanary:leaksentry:2.0-alpha-2'
+}
+```
+
+In your leak reporting code:
+```kotlin
+val retainedInstanceCount = LeakSentry.refWatcher.retainedKeys.size
+```
+
+### Running LeakCanary in instrumentation tests
+
+Add the `leakcanary-android-instrumentation` dependency to your instrumentation tests:
+
+```
+androidTestImplementation "com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion}"
+```
+
+Add the dedicated run listener to `defaultConfig` in your `build.gradle`:
+
+```
+android {
+  defaultConfig {
+    // ...
+
+    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    testInstrumentationRunnerArgument "listener", "leakcanary.FailTestOnLeakRunListener"
+  }
+}
+```
+
+Run the instrumentation tests:
+
+```
+./gradlew leakcanary-sample:connectedCheck
+```
+
+You can extend `FailTestOnLeakRunListener` to customize the behavior.
+
+### Icon and label
+
+The activity that displays leaks comes with a default icon and label, which you can change by providing `R.mipmap.leak_canary_icon` and `R.string.leak_canary_display_activity_label` in your app:
+
+```
+res/
+  mipmap-hdpi/
+    leak_canary_icon.png
+  mipmap-mdpi/
+    leak_canary_icon.png
+  mipmap-xhdpi/
+    leak_canary_icon.png
+  mipmap-xxhdpi/
+    leak_canary_icon.png
+  mipmap-xxxhdpi/
+    leak_canary_icon.png
+   mipmap-anydpi-v26/
+     leak_canary_icon.xml
+```
+
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <string name="leak_canary_display_activity_label">MyLeaks</string>
+</resources>
+```
+
+### Uploading to a server
+
+You can change the default behavior to upload the analysis result to a server of your choosing.
+
+Create a custom `AnalysisResultListener` that delegates to the default: 
+
+```kotlin
+class LeakUploader : AnalysisResultListener {
+  override fun invoke(
+    application: Application,
+    heapAnalysis: HeapAnalysis
+  ) {
+    TODO("Upload heap analysis to server")
+
+    // Delegate to default behavior (notification and saving result)
+    DefaultAnalysisResultListener(application, heapAnalysis)
+  }
+}
+```
+
+Set `analysisResultListener` on the LeakCanary config:
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakCanary.config = LeakCanary.config.copy(analysisResultListener = LeakUploader())
+  }
+}
+```
+
+
+### Identifying 3rd party leaks as "won't fix"
+
+Set `exclusionsFactory` on the LeakCanary config to a `ExclusionsFactory` that delegates to the default one and then and add custom exclusions:
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakCanary.config = LeakCanary.config.copy(exclusionsFactory = { hprofParser ->
+      val defaultFactory = AndroidExcludedRefs.exclusionsFactory(AndroidExcludedRefs.appDefaults)
+      val appDefaults = defaultFactory(hprofParser)
+      val customExclusion = Exclusion(
+          type = StaticFieldExclusion("com.thirdparty.SomeSingleton", "sContext"),
+          status = Exclusion.Status.WONT_FIX_LEAK,
+          reason = "SomeSingleton in library X has a static field leaking a context."
+      )
+      appDefaults + customExclusion
+    })
+  }
+}
+```
+
+### Identifying leaking instances and labeling instances
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    val customLabeler: Labeler = { parser, node ->
+      listOf("Heap dump object id is ${node.instance}")
+    }
+    val labelers = AndroidLabelers.defaultAndroidLabelers(this) + customLabeler
+
+    val customInspector: LeakInspector = { parser, node ->
+      with(parser) {
+        if (node.instance.objectRecord.isInstanceOf("com.example.MySingleton")) {
+          LeakNodeStatus.notLeaking("MySingleton is a singleton")
+        } else LeakNodeStatus.unknown()
+      }
+    }
+    val leakInspectors = AndroidLeakInspectors.defaultAndroidInspectors() + customInspector
+
+    LeakCanary.config = LeakCanary.config.copy(labelers = labelers, leakInspectors = leakInspectors)
+  }
+}
+```
+
+## FAQ
+
+### Can a leak be caused by the Android SDK?
+
+Yes. There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: [AndroidExcludedRefs.kt](https://github.com/square/leakcanary/blob/master/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt).
+
+If you find a new one, please [create an issue](https://github.com/square/leakcanary/issues/new/choose) and follow these steps:
+
+1. Provide the entire leak trace information (reference key, device, etc), and use backticks (`) for formatting.
+2. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions [android/platform_frameworks_base](https://github.com/android/platform_frameworks_base).
+3. Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed.
+4. If it's still happening, build a simple repro case
+5. File an issue on [b.android.com](http://b.android.com) with the leak trace and the repro case
+6. Create a PR in LeakCanary to update `AndroidExcludedRefs.kt`. Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
+
+### How do I share a leak trace?
+
+* Go to the leak screen, click the overflow menu and select *Share Info*.
+* You can also find the leak trace in Logcat.
+
+### How can I dig beyond the leak trace?
+
+Sometimes the leak trace isn't enough and you need to dig into a heap dump with [MAT](http://eclipse.org/mat/) or [YourKit](https://www.yourkit.com/).
+
+* Go to a heap analysis screen, click the overflow menu and select *Share Heap Dump*.
+
+Here's how you can find the leaking instance in the heap dump:
+
+1. Look for all instances of `leakcanary.KeyedWeakReference`
+2. For each of these, look at the `key` field.
+3. Find the `KeyedWeakReference` that has a `key` field equal to the reference key reported by LeakCanary.
+4. The `referent` field of that `KeyedWeakReference` is your leaking object.
+5. From then on, the matter is in your hands. A good start is to look at the shortest path to GC Roots (excluding weak references).
+
+### How many methods does LeakCanary add?
+
+**0**. LeakCanary is a debug only library.
+
+### How do I use the SNAPSHOT version?
+
+Update your dependencies to the latest SNAPSHOT (see [build.gradle](https://github.com/square/leakcanary/blob/master/build.gradle)):
+
+```gradle
+ dependencies {
+   debugCompile 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-3-SNAPSHOT'
+ }
+```
+
+Add Sonatype's `snapshots` repository:
+
+```
+  repositories {
+    mavenCentral()
+    maven {
+      url 'https://oss.sonatype.org/content/repositories/snapshots/'
+    }
+  }
+```
+
+Status of the snapshot build: [![Build Status](https://travis-ci.org/square/leakcanary.svg?branch=master)](https://travis-ci.org/square/leakcanary)
+
+### Who's behind LeakCanary?
+
+LeakCanary was created and open sourced by [@pyricau](https://github.com/pyricau), with [many contributions](https://github.com/square/leakcanary/graphs/contributors) from the community.
+
+### Why is it called LeakCanary?
+
+The name **LeakCanary** is a reference to the expression [canary in a coal mine](http://en.wiktionary.org/wiki/canary_in_a_coal_mine), because LeakCanary is a sentinel used to detect risks by providing advance warning of a danger. Props to [@edenman](https://github.com/edenman) for suggesting it!
+
+### Who made the logo?
+
+* [@pyricau](https://github.com/pyricau) quickly made the [first version](https://github.com/square/leakcanary/blob/f0cc04dfbf3cca92a669f0d250034d410eb05816/assets/icon_512.png) of the logo. It was based on cliparts from [Android Asset Studio](http://romannurik.github.io/AndroidAssetStudio/icons-generic.html), mixed with the selection from a photo of a Canary. The exclamation mark means danger, the shield stands for protection, and the bird, well, is a canary.
+* [@romainguy](https://github.com/romainguy) turned the ugly logo into [a nice vector asset](https://github.com/square/leakcanary/pull/36).
+* [@flickator](https://github.com/flickator) designed [a much nicer logo](https://github.com/square/leakcanary/pull/1269) for LeakCanary 2.0!
+
+<p align="center">
+<img src="https://github.com/square/leakcanary/wiki/assets/logo-2.0.png" />
+</p>
+
+## License
+
+    Copyright 2015 Square, Inc.
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
