diff --git a/.github/CODE_OF_CONDUCT.md b/.github/CODE_OF_CONDUCT.md
new file mode 100644
index 00000000..173a1908
--- /dev/null
+++ b/.github/CODE_OF_CONDUCT.md
@@ -0,0 +1 @@
+See https://square.github.io/leakcanary/code_of_conduct
\ No newline at end of file
diff --git a/.github/CONTRIBUTING.md b/.github/CONTRIBUTING.md
index 338b931b..07ea8d16 100644
--- a/.github/CONTRIBUTING.md
+++ b/.github/CONTRIBUTING.md
@@ -1,16 +1 @@
-# Contributing
-
-If you would like to contribute code to LeakCanary you can do so through GitHub by
-forking the repository and sending a pull request.
-
-When submitting code, please make every effort to follow existing conventions
-and style in order to keep the code as readable as possible. Please also make
-sure your code compiles by running `./gradlew clean build`. Checkstyle failures
-during compilation indicate errors in your style and can be viewed in files
-located at `*/build/report/checkstyle` directories.
-
-Before your code can be accepted into the project you must also sign the
-[Individual Contributor License Agreement (CLA)][1].
-
-
- [1]: https://spreadsheets.google.com/spreadsheet/viewform?formkey=dDViT2xzUHAwRkI3X3k5Z0lQM091OGc6MQ&ndplr=1
\ No newline at end of file
+See https://square.github.io/leakcanary/contributing
\ No newline at end of file
diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
deleted file mode 100644
index b8432c90..00000000
--- a/.github/ISSUE_TEMPLATE.md
+++ /dev/null
@@ -1,16 +0,0 @@
-Welcome and thank you for reporting an issue!
-
-If you don't know how to fix a memory leak in your app, please do not file an issue. Read here: https://github.com/square/leakcanary/#how-do-i-fix-a-memory-leak
-
-Are you sure this issue isn't already reported? Try the search field in https://github.com/square/leakcanary/issues .
-
-^^^^^ PLEASE DELETE EVERYTHING ABOVE, INCLUDING THIS LINE ^^^^^
-
-LeakCanary Version: 
-
-
-```
-
-PASTE HERE ANY STACKTRACE OR OUTPUT FROM LEAKCANARY, IN BETWEEN THE TRIPLE BACKQUOTES. REMOVE THIS LINE <====
-
-```
diff --git a/.github/ISSUE_TEMPLATE/1-leak.md b/.github/ISSUE_TEMPLATE/1-leak.md
new file mode 100644
index 00000000..bec5b74e
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/1-leak.md
@@ -0,0 +1,17 @@
+---
+name: "\U0001F424Leak in your app"
+about: Use Stack Overflow instead
+title: "\U0001F649 [This issue will be immediately closed]"
+labels: 'Close immediately'
+assignees: ''
+
+---
+
+🛑 𝙎𝙏𝙊𝙋
+
+This issue tracker is not for help with memory leaks detected by LeakCanary in your own app.
+
+To fix a leak: 
+
+* First, learn the fundamentals: https://github.com/square/leakcanary#fundamentals
+* Then, create a Stack Overflow question: http://stackoverflow.com/questions/tagged/leakcanary
diff --git a/.github/ISSUE_TEMPLATE/2-bug.md b/.github/ISSUE_TEMPLATE/2-bug.md
new file mode 100644
index 00000000..2a8301be
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/2-bug.md
@@ -0,0 +1,32 @@
+---
+name: "\U0001F41BBug report"
+about: 'Build errors, bugs and runtime crashes in version 2.0'
+title: ''
+labels: 'type: bug'
+assignees: ''
+
+---
+
+### Description
+
+[Description of the issue]
+
+### Steps to Reproduce
+
+[Provide a sample project, a .hprof file or a failing test]
+
+1. [First Step]
+2. [Second Step]
+3. [and so on...]
+
+**Expected behavior:** [What you expect to happen]
+
+### Version Information
+
+* LeakCanary version:
+* Android OS version:
+* Gradle version:
+
+### Additional Information
+
+Any additional information, configuration or data that might be necessary to reproduce the issue.
diff --git a/.github/ISSUE_TEMPLATE/3-feature.md b/.github/ISSUE_TEMPLATE/3-feature.md
new file mode 100644
index 00000000..9620f7cf
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/3-feature.md
@@ -0,0 +1,14 @@
+---
+name: "\U0001F64FFeature request"
+about: Suggest an idea for LeakCanary
+title: ''
+labels: 'type: enhancement'
+assignees: ''
+
+---
+
+### Problem description
+
+### Potential solutions
+
+### Additional information
diff --git a/.github/ISSUE_TEMPLATE/4-doc.md b/.github/ISSUE_TEMPLATE/4-doc.md
new file mode 100644
index 00000000..9f785213
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/4-doc.md
@@ -0,0 +1,10 @@
+---
+name: "\U0001F4DADocumentation request"
+about: Point out what's confusing or missing
+title: ''
+labels: 'type: documentation'
+assignees: ''
+
+---
+
+
diff --git a/.github/ISSUE_TEMPLATE/5-sdk.md b/.github/ISSUE_TEMPLATE/5-sdk.md
new file mode 100644
index 00000000..e4e12c20
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/5-sdk.md
@@ -0,0 +1,16 @@
+---
+name: "\U0001F916Leak in Android SDK / support library"
+about: Help LeakCanary identify known leaks
+title: ''
+labels: 'type: leak'
+assignees: ''
+
+---
+
+Read this first: https://github.com/square/leakcanary#can-a-leak-be-caused-by-the-android-sdk
+
+### LeakTrace information
+
+```
+{REPLACE THIS LINE WITH THE OUTPUT FROM LEAKCANARY}
+```
diff --git a/.github/SUPPORT.md b/.github/SUPPORT.md
new file mode 100644
index 00000000..8872c01e
--- /dev/null
+++ b/.github/SUPPORT.md
@@ -0,0 +1 @@
+See https://square.github.io/leakcanary/support
\ No newline at end of file
diff --git a/.gitignore b/.gitignore
index 3e76ed69..8b05348b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -34,3 +34,6 @@ out
 
 # Finder
 .DS_Store
+
+# Docs
+site
\ No newline at end of file
diff --git a/.travis.yml b/.travis.yml
index ad327f32..ee5ea2c7 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,21 +1,33 @@
 language: android
 
-android:
-  components:
-    - tools
-    - platform-tools
-    - build-tools-23.0.2
-    - android-23
-
 jdk:
-  - oraclejdk7
   - oraclejdk8
 
+before_install:
+  # Install SDK license so Android Gradle plugin can install deps.
+  - mkdir "$ANDROID_HOME/licenses" || true
+  - echo "d56f5187479451eabf01fb78af6dfcb131a6481e" > "$ANDROID_HOME/licenses/android-sdk-license"
+  - echo "24333f8a63b6825ea9c5514f83c2829b004d1fee" >> "$ANDROID_HOME/licenses/android-sdk-license"
+  # Install the rest of tools (e.g., avdmanager)
+  - sdkmanager tools
+  # Install the system image
+  - sdkmanager "system-images;android-16;default;armeabi-v7a"
+  # Create and start emulator for the script. Meant to race the install task.
+  - echo no | avdmanager create avd --force -n test -k "system-images;android-16;default;armeabi-v7a"
+  - $ANDROID_HOME/emulator/emulator -avd test -no-audio -no-window &
+
+install: ./gradlew clean build assembleAndroidTest --stacktrace
+
+before_script:
+  - android-wait-for-emulator
+  # 82 is KEYCODE_MENU
+  - adb shell input keyevent 82
+
 script:
-  - ./gradlew clean build
+  - ./gradlew leakcanary-android-instrumentation:connectedCheck --stacktrace
 
 after_success:
-  - .buildscript/deploy_snapshot.sh
+  - .buildscript/deploy_snapshot.sh || test true
 
 env:
   global:
diff --git a/CHANGELOG.md b/CHANGELOG.md
deleted file mode 100644
index ddf1fa3d..00000000
--- a/CHANGELOG.md
+++ /dev/null
@@ -1,80 +0,0 @@
-# Change Log
-
-## Version 1.4-SNAPSHOT
-
-Nothing yet.
-
-### Public API changes
-
-Nothing yet.
-
-# Change Log
-
-All changes in 1.4+ are [tracked here](https://github.com/square/leakcanary/pulls?utf8=%E2%9C%93&q=milestone%3A1.4+is%3Apr).
-
-## Version 1.4-beta2 *(2016-03-23)*
-
-* Add reason for ignoring to analysis result [#365](https://github.com/square/leakcanary/issues/365).
-* Lower memory usage when parsing heap dumps on M [#223](https://github.com/square/leakcanary/issues/223).
-* Fix NPE in LeakCanaryInternals.isInServiceProcess() [#449](https://github.com/square/leakcanary/issues/449).
-* New ignored Android SDK leaks [#297](https://github.com/square/leakcanary/issues/297),[#322](https://github.com/square/leakcanary/issues/322).
-* Use leakcanary-android-no-op in test builds [#143](https://github.com/square/leakcanary/issues/143).
-* Fixes to allow LeakCanary to work with ProGuard [#398](https://github.com/square/leakcanary/pull/398).
-* Optimize png assets [#406](https://github.com/square/leakcanary/pull/406).
-* Fix delete button not working on error views [#408](https://github.com/square/leakcanary/pull/408).
-* Add German translation [#437](https://github.com/square/leakcanary/pull/437).
-
-## Version 1.4-beta1 *(2016-01-08)*
-
-* Switched to [HAHA 2.0.2](https://github.com/square/haha/blob/master/CHANGELOG.md#version-202-2015-07-20) with uses Perflib instead of MAT under the hood [#219](https://github.com/square/leakcanary/pull/219). This fixes crashes and improves speed a lot.
-* We can now parse Android M heap dumps [#267](https://github.com/square/leakcanary/issues/267), although there are still memory issues (see [#223](https://github.com/square/leakcanary/issues/223)).
-* Excluded leaks are now reported as well and available in the display leak activity.
-* Added ProGuard configuration for [#132](https://github.com/square/leakcanary/issues/132).
-* Many new ignored Android SDK leaks.
-* Added excluded leaks to text report [#119](https://github.com/square/leakcanary/issues/119).
-* Added LeakCanary SHA to text report [#120](https://github.com/square/leakcanary/issues/120).
-* Added CanaryLog API to replace the logger: [#201](https://github.com/square/leakcanary/issues/201).
-* Renamed all resources to begin with `leak_canary_` instead of `__leak_canary`[#161](https://github.com/square/leakcanary/pull/161)
-* No crash when heap dump fails [#226](https://github.com/square/leakcanary/issues/226).
-* Add retained size to leak reports [#162](https://github.com/square/leakcanary/issues/162).
-
-### Public API changes
-
-* AnalysisResult.failure is now a `Throwable` instead of an `Exception`. Main goal is to catch and correctly report OOMs while parsing.
-* Added ARRAY_ENTRY to LeakTraceElement.Type for references through array entries.
-* Renamed `ExcludedRefs` fields.
-* Each `ExcludedRef` entry can now be ignored entirely or "kept only if no other path".
-* Added support for ignoring all fields (static and non static) for a given class.
-
-## Version 1.3.1 *(2015-05-16)*
-
-* Heap dumps and analysis results are now saved on the sd card: [#21](https://github.com/square/leakcanary/issues/21).
-* `ExcludedRef` and `AndroidExcludedRefs` are customizable: [#12](https://github.com/square/leakcanary/issues/12) [#73](https://github.com/square/leakcanary/issues/73).
-* 7 new ignored Android SDK leaks: [#1](https://github.com/square/leakcanary/issues/1) [#4](https://github.com/square/leakcanary/issues/4) [#32](https://github.com/square/leakcanary/issues/32) [#89](https://github.com/square/leakcanary/pull/89) [#82](https://github.com/square/leakcanary/pull/82) [#97](https://github.com/square/leakcanary/pull/97).
-* Fixed 3 crashes in LeakCanary: [#37](https://github.com/square/leakcanary/issues/37) [#46](https://github.com/square/leakcanary/issues/46) [#66](https://github.com/square/leakcanary/issues/66).
-* Fixed StrictMode thread policy violations: [#15](https://github.com/square/leakcanary/issues/15).
-* Updated `minSdkVersion` from `9` to `8`: [#57](https://github.com/square/leakcanary/issues/57).
-* Added LeakCanary version name to `LeakCanary.leakInfo()`: [#49](https://github.com/square/leakcanary/issues/49).
-* `leakcanary-android-no-op` is lighter, it does not depend on `leakcanary-watcher` anymore, only 2 classes now: [#74](https://github.com/square/leakcanary/issues/74).
-* Adding field state details to the text leak trace.
-* A Toast is displayed while the heap dump is in progress to warn that the UI will freeze: [#20](https://github.com/square/leakcanary/issues/49). You can customize the toast by providing your own layout named `__leak_canary_heap_dump_toast.xml` (e.g. you could make it an empty layout).
-* If the analysis fails, the result and heap dump are kept so that it can be reported to LeakCanary: [#102](https://github.com/square/leakcanary/issues/102).
-* Update to HAHA 1.3 to fix a 2 crashes [#3](https://github.com/square/leakcanary/issues/3) [46](https://github.com/square/leakcanary/issues/46)
-
-### Public API changes
-
-* When upgrading from 1.3 to 1.3.1, previously saved heap dumps will not be readable any more, but they won't be removed from the app directory. You should probably uninstall your app.
-* Added `android.permission.WRITE_EXTERNAL_STORAGE` to `leakcanary-android` artifact.
-* `LeakCanary.androidWatcher()` parameter types have changed (+ExcludedRefs).
-* `LeakCanary.leakInfo()` parameter types have changed (+boolean)
-* `ExcludedRef` is now serializable and immutable, instances can be created using `ExcludedRef.Builder`.
-* `ExcludedRef` is available in `HeapDump`
-* `AndroidExcludedRefs` is an enum, you can now pick the leaks you want to ignore in `AndroidExcludedRefs` by creating an `EnumSet` and calling `AndroidExcludedRefs.createBuilder()`.
-* `AndroidExcludedRefs.createAppDefaults()` & `AndroidExcludedRefs.createAndroidDefaults()` return a `ExcludedRef.Builder`.
-* `ExcludedRef` moved from `leakcanary-analyzer` to `leakcanary-watcher`
-
-## Version 1.3 *(2015-05-08)*
-
-Initial release.
-
-### Dependencies
diff --git a/README-1.6.md b/README-1.6.md
new file mode 100644
index 00000000..aea17551
--- /dev/null
+++ b/README-1.6.md
@@ -0,0 +1,86 @@
+
+# LeakCanary
+
+A memory leak detection library for Android and Java.
+
+*“A small leak will sink a great ship.”* - Benjamin Franklin
+
+<p align="center">
+<img src="https://github.com/square/leakcanary/wiki/assets/screenshot.png"/>
+</p>
+
+## Getting started
+
+In your `build.gradle`:
+
+```groovy
+dependencies {
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.3'
+  releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.3'
+  // Optional, if you use support library fragments:
+  debugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.3'
+}
+```
+
+In your `Application` class:
+
+```java
+public class ExampleApplication extends Application {
+
+  @Override public void onCreate() {
+    super.onCreate();
+    if (LeakCanary.isInAnalyzerProcess(this)) {
+      // This process is dedicated to LeakCanary for heap analysis.
+      // You should not init your app in this process.
+      return;
+    }
+    LeakCanary.install(this);
+    // Normal app init code...
+  }
+}
+```
+
+**You're good to go!** LeakCanary will automatically show a notification when an activity or support fragment memory leak is detected in your debug build.
+
+**What's next?** You could watch a [live investigation](https://www.youtube.com/watch?v=KwArTJHLq5g) then [customize LeakCanary](https://github.com/square/leakcanary/wiki/Customizing-LeakCanary) to your needs.
+
+## FAQ
+
+* [Why should I use LeakCanary?](https://github.com/square/leakcanary/wiki/FAQ#why-should-i-use-leakcanary)
+* [How does it work?](https://github.com/square/leakcanary/wiki/FAQ#how-does-it-work)
+* [How do I fix a memory leak?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-fix-a-memory-leak)
+* [How do I customize LeakCanary to my needs?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-customize-leakcanary-to-my-needs)
+* [Where can I learn more?](https://github.com/square/leakcanary/wiki/FAQ#where-can-i-learn-more)
+* [How do I copy the leak trace?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-copy-the-leak-trace)
+* [Can a leak be caused by the Android SDK?](https://github.com/square/leakcanary/wiki/FAQ#can-a-leak-be-caused-by-the-android-sdk)
+* [How can I dig beyond the leak trace?](https://github.com/square/leakcanary/wiki/FAQ#how-can-i-dig-beyond-the-leak-trace)
+* [How do disable I LeakCanary in tests?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-disable-leakcanary-in-tests)
+* [How do I fix build errors?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-fix-build-errors)
+* [How many methods does LeakCanary add?](https://github.com/square/leakcanary/wiki/FAQ#how-many-methods-does-leakcanary-add)
+* [How do I use the SNAPSHOT version?](https://github.com/square/leakcanary/wiki/FAQ#how-do-i-use-the-snapshot-version)
+* [How can I be notified of new releases?](https://github.com/square/leakcanary/wiki/FAQ#how-can-i-be-notified-of-new-releases)
+* [Who's behind LeakCanary?](https://github.com/square/leakcanary/wiki/FAQ#whos-behind-leakcanary)
+* [Why is it called LeakCanary?](https://github.com/square/leakcanary/wiki/FAQ#why-is-it-called-leakcanary)
+* [Who made the logo?](https://github.com/square/leakcanary/wiki/FAQ#who-made-the-logo)
+* [Instant Run can trigger invalid leaks](https://github.com/square/leakcanary/wiki/FAQ#instant-run-can-trigger-invalid-leaks)
+* [I know I have a leak. Why doesn't the notification show?](https://github.com/square/leakcanary/wiki/FAQ#i-know-i-have-a-leak-why-doesnt-the-notification-show)
+
+<p align="center">
+<img src="https://github.com/square/leakcanary/wiki/assets/icon_512.png" width="250"/>
+</p>
+
+## License
+
+    Copyright 2015 Square, Inc.
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
diff --git a/README.md b/README.md
index ce382529..43f65124 100644
--- a/README.md
+++ b/README.md
@@ -1,40 +1,8 @@
-# LeakCanary
+# LeakCanary 🐤
 
-A memory leak detection library for Android and Java.
+A memory leak detection library for Android.
 
-*“A small leak will sink a great ship.”* - Benjamin Franklin
-
-![screenshot.png](assets/screenshot.png)
-
-## Getting started
-
-In your `build.gradle`:
-
-```gradle
- dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.4-beta2'
-   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.4-beta2'
-   testCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.4-beta2'
- }
-```
-
-In your `Application` class:
-
-```java
-public class ExampleApplication extends Application {
-
-  @Override public void onCreate() {
-    super.onCreate();
-    LeakCanary.install(this);
-  }
-}
-```
-
-**You're good to go!** LeakCanary will automatically show a notification when an activity memory leak is detected in your debug build.
-
-Questions? Check out [the FAQ](https://github.com/square/leakcanary/wiki/FAQ)!
-
-![icon_512.png](assets/icon_512.png)
+### [square.github.io/leakcanary](http://square.github.io/leakcanary)
 
 ## License
 
@@ -50,4 +18,4 @@ Questions? Check out [the FAQ](https://github.com/square/leakcanary/wiki/FAQ)!
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
-    limitations under the License.
+    limitations under the License.
\ No newline at end of file
diff --git a/assets/icon_1024.png b/assets/icon_1024.png
deleted file mode 100644
index f15c7586..00000000
Binary files a/assets/icon_1024.png and /dev/null differ
diff --git a/assets/icon_512.png b/assets/icon_512.png
deleted file mode 100644
index 0ca6bedf..00000000
Binary files a/assets/icon_512.png and /dev/null differ
diff --git a/assets/screenshot.png b/assets/screenshot.png
deleted file mode 100644
index 8faa278f..00000000
Binary files a/assets/screenshot.png and /dev/null differ
diff --git a/assets/source_icon.png b/assets/source_icon.png
deleted file mode 100644
index d04aace6..00000000
Binary files a/assets/source_icon.png and /dev/null differ
diff --git a/assets/vector_icon.afdesign b/assets/vector_icon.afdesign
deleted file mode 100644
index a30fcf97..00000000
Binary files a/assets/vector_icon.afdesign and /dev/null differ
diff --git a/assets/vector_icon.svg b/assets/vector_icon.svg
deleted file mode 100644
index 9a17f0dc..00000000
--- a/assets/vector_icon.svg
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" standalone="no"?>
-<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
-<svg width="100%" height="100%" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421;">
-    <image id="Container" x="33" y="44" width="443px" height="441px" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbsAAAG5CAYAAAAXoZoVAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAcMklEQVR4nO3dT4gkZ/nA8Wd6Zmc3mw1ZXEmCfxJCfgZJMDEHwaiRmEsQEolBAkET0Jw96CEXQQRFDyKePOXgIRhFBFFEzCFBEzRIFj0kIaJBCQZB8mezJG522Z3q38Gttqamqrq6u7q76u3PB4bu6Z3p6V525rvPW2/1bI3H4wCAlO2s+wF0YazYAEu1tbW1te7HsIitvnZi1oD19XkADF3bzvU5iL2KXVPg+vQ4Afivur71LXxrjd08cZv1dgDm0xCymT9v3fFbS+zqIld1c/E2oQNYraZGFf+sbRjXFb2Vxq4cuVnill+f9jkAdKdmSqv98/z9utsL7680eiuJ3bTINUWtTfAEEGBxbaazadfrLuu+xqqit9TYtY1c02Xx+iuvvBJ///vf44033ojXX39939upU6fi/PnzS3suAJvm6NGj8a53vStOnDhx4O2GG26Iyy67bF/UpgVvykS41OgtLXbF0LWJXPn6eDyOLMvixRdfjD/84Q/xzDPPxCuvvLKUxwrAbLa3t+PGG2+MW2+9NT7+8Y/HVVddVRu+ttFbZvCWEru60E2LW/7+yZMn46mnnoo//vGPcerUqc4fHwDduvbaa+NjH/tY3HHHHfH+97//QOzaRm9Zwes8dk2hqwpc8e2FF16IRx55JF588cVOHxMAqzEajeLOO++MBx54IE6cOHEgdnVTX/5+4Xqn0es0dnnoZo3cyy+/HD/84Q/jmWee6eyxALA+hw8fjnvvvTfuu+++OHr0aG30Wmxo6SR6ncWuKXTF4GVZNnn/9ddfj0cffTQef/zxyLKsk8cBQH9cfvnlcf/998fdd98dOzs7MRqN1jLldRK7cuiaJrk8di+88EJ885vfjDfffHPhrw9Av910003xta99LS6//PLK4LU4prdQ8BaOXVXoyteL01yWZfH444/HD37wA6cKAGyQq666Kr7xjW/ENddcsy94xesR1Ts4L16fO3gLxa4pdOXAjcfjuHDhQjzyyCPxi1/8Yu6vCcBwXXLJJfHwww/HRz/60QOhy9+P6D54c8euLnRVy5ZZlsXbb78d3/nOd+JPf/rTXF8PgDSMRqN48MEH47777psErjzpRXQbvLli1yZ0eeTG43GcPXs2Hn744fjb3/4289cCIE33339/fOELX5jEboZjeTPHbjTrJ0wLXR65/G1vby++//3vCx0A+/zkJz+Jp59+el8zql5opGLz48xT2kyxaxO6cvB++tOfxlNPPTXr4wIgcePxeDIMlQelvCX5x5WDN6vWsWuz67IYur29vXjmmWfi0UcfneuBAZC+c+fOxbe+9a14/fXXY29v78B0V3cO9qzT3czLmGVV01yWZfGPf/wjvve9781dYQA2w2uvvRbf/va349y5c5PglaO36HJmq9i13XmZR+/8+fPx3e9+N86ePTvjUwZgE/3lL3+Jxx57rHI5s4vgzbKMObms25Syt7cXe3t78cQTT8Q///nPmZ8sAJvrV7/6Vbz66qv7pru6jSuzmhq7umpWLV1mWRZnz56Nxx57bK4HA8DmOnfuXPz4xz9unOwiKl+acmoBG2NXt3xZdQAxn+x++ctfxhtvvLHI8wVgQz355JPx8ssvVwYvovp3oLZRG7um43TF94uhO336dPz85z9f4GkCsMmyLItHH320cikzD1+VadPdPCeVVz6ALMviZz/7WZw5c2bWuwSAiZMnT8YLL7xQu5xZNe1N03Y3Zu3GlPzy3Llz8cQTTyz2DAEgIn7zm9/UblKJ2H+ud65pupt2zO7A+3U7MZ977rl455135n5iAJD785//HOfOnTvwiirTNqvUqYxdsY5NU13x7dlnn+3sSQKw2c6cORPPP//8zKcf1E13TRtUDrxftwPzwoULcfLkyXmfEwAc8Oyzzx54RZWmE82bHIhduYrTjtVlWRYvvfRSnDp1qsOnCMCmO3ny5NRXVClqOu+u1TE7S5gArNqpU6fipZdeqvxtCAtNduVz66quF79I/sWff/75zp4cAOSee+65A92JmP3k8rkmu/JS5muvvdbFcwKAfV577bXaya5K3e1TN6hM24l54cKFePvttzt4SgCw36lTpxo3pjQcv9t3Q9UGlcovWBe9U6dO1f5yPQBYxOnTpw9siqwLXdNS5iR2bXZhVk13dmECsCz5QDXvKQe5upPKay/L46TYAbAsp0+frvzt5RHVQ1l+e1mb32d34LI42fl1PgAsS/4bdeZZuiyuWJZPPaj7hNr10rfeemumURIA2sjbknemKXjT4je6+IeVx+uK18vn2816jgMAzKrq/O7OjtkVv0j5/brz7QCgK3UDVvH9qo+r0+qYXdOOTABYhmLQyptT8tvbrjI2nlRe9UnlOy4Gz4QHQNfqdl+2+Zxcq5PKpx0QBIBlatpL0mZH5kynHtSdhgAAy9IUtrYNmhq7ui8qdACsUlN7Fj6pvOmLAsCyNZ0C19bUUw+6GB8BoAvzrio2vjZm1W2WLwFYpabuzH3MziuiANB3bU8mzxV/xU/ndw4AXVnkUNpcG1SEDoB1mLc/c+/GXOSLAsAsFu1NqxeCFjUA1qWLMwFaT3ZVr54CAKuySHcWWsYEgCEQOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTO4ABGI/H634IgyZ2AAMwHo8jy7J1P4zBEjuAARG8+YgdwMAI3uzEDqDnqo7XCd5sxA5goASvPbED6LmmnZiC147YAQyc4E0ndgA91vb8OsFrJnYAiRC8emIHkJAsy7zaSgWxA+ixecI1Ho8Fr0TsABIkePuJHUBPLRorwfsfsQNImOD9l9gB9FRXkRI8sQPYCJsePLED2BCbHDyxA+ihZUVpU4MndgAbZhODJ3YAPbTsGG1a8MQOYENtUvDEDqBnVhmgTQme2AFsuE0IntgB9Mw6wpN68MQOgIhIO3hiB8BEqsETO4Ae6UNoUgye2AFwQGrBEzsAKo3H48iybN0PoxNiB9AjfZymUgie2AEw1dCDJ3YAPdHHqa5oyMETOwBaG2rwxA6AmQwxeGIH0BN9X8YsGlrwxA6AuQwpeGIHwNyGEjyxA+iBIS1hlg0heGIHwML6HjyxA+iBIU92uT4HT+wA6Exfgyd2AHQqy7LeTapiB7BmfQtDF/r2K4LEDoCl6FPwxA6ApelL8MQOYM36EINl6kPwxA6ApVt38MQOYI3WPfGs0jqDJ3YArMy6gid2AKzUOoIndgBrtEnLmEWrDp7YAbAWqwye2AGwNqsKntgBrMmmLmGWrSJ4YgfA2i07eGIHsCYmu/2WGbydpdwrAMxB7ADYCMsInmVMgDWwhNms6yVNkx0AvZTHrovomewA6K3xeBx7e3sL34/YAayBZczVEjsAkid2ACRP7ABWzBLm6okdAMkTOwCSJ3YAK2YZc/XEDoDkiR3ACpnq1kPsAEie2AGQPLEDWCHLmOshdgAkT+wASJ7YAayIJcz1ETsAkid2ACRP7ABWxDLm+ogdAMkTO4AVMNWtl9gBkDyxAyB5YgewApYx10vsAEie2AGQPLEDWDJLmOsndgAkT+wASJ7YASyZZcz1EzsAkid2ACRP7ACWyBJmP4gdAMkTO4AlMtn1g9gBkDyxAyB5YgewJJYw+0PsAEie2AGQPLEDWBLLmP0hdgAkT+wASJ7YASyBJcx+ETsAkid2AEtgsusXsQMgeWIH0DFTXf+IHQDJEzsAkid2AB2zjNk/YgdA8sQOoEOmun4SOwCSJ3YAJE/sADpkGbOfxA6A5IkdQEdMdf0ldgAkT+wASJ7YAXTEMmZ/iR0AyRM7gA6Y6vpN7ABIntgBkDyxA+iAZcx+EzsAkid2AAsy1fWf2AGQPLEDWJDJrv/EDoDkiR3AAkx1wyB2ACRP7AAWYLIbBrEDIHliBzAnU91wiB0AyRM7gDmZ7IZD7ABIntgBzMFUNyxiB0DyxA5gDia7YRE7AJIndgAkT+wAZmQJc3jEDoDkiR3AjEx2wyN2ACRP7ABmYKobJrEDIHliBzADk90wiR0AyRM7gJZMdcMldgAtid1wiR0AyRM7gBZMdcMmdgAkT+wAWjDZDZvYAUwhdMMndgAkT+wApjDZDZ/YATQQujSIHQDJEzuABia7NIgdAMkTO4Aaprp0iB1ADbFLh9gBkDyxA6hgqkuL2AGQPLEDqGCyS4vYAZQIXXrEDoDkiR1AickuPWIHUCB0aRI7AJIndgAFJrs0iR3ARUKXLrEDuEjs0iV2ACRP7ADCVJc6sQMIsUud2AEbT+jSJ3YAJE/sgI1nskuf2AEbTeg2g9gBG03sNoPYARtL6DaH2AGQPLEDNpbJbnOIHbCRhG6ziB2wkcRus4gdsHGEbvOIHbBxxG7ziB2wUYRuM4kdsFHEbjOJHbAxhG5ziR2wMcRuc4kdsBGEbrOJHbARxG6ziR2QPKFD7ABIntgByTPZIXZA0oSOCLEDEid2RIgdkLAsy9b9EOgJsQOSZKKjSOyAJIkdRWIHJEfoKBM7IDliR5nYAUkROqqIHZCM8XgsdlQSOyAZQkcdsQOSIHQ0ETsgCWJHE7EDBs8rpTCN2AGDZqKjDbEDBk3saEPsgMGyfElbYgcMkomOWYgdMEhixyzEDhgcy5fMSuyAQTHRMQ+xAwbDa18yL7EDBkPomJfYAYPgOB2LEDug94SORYkd0GuWLumC2AG9ZUMKXRE7oJeEji6JHdBLQkeXxA7oHRtS6JrYAb0idCyD2AG9IXQsi9gBvSB0LJPYAWsndCyb2AFrJXSsgtgBayN0rMrOuh8AsHmcMM6qmeyAlRI61kHsgJUROtbFMiawEo7PsU4mO2DphI51M9kBS2PZkr4w2QFLIXT0ickO6JTI0UcmO6AzQkdfmeyAhYkcfSd2wELstGQIxA6Yi2mOIRE7YCYixxCJHdCKyDFkYgc0EjlSIHasXJZlsbW1FRExuaR/RI6UiB0rNxqNJjv48h+m4tcfIkeKxI612Nra2vcDNb9ejJ/wrY7AkTqxYy3ykNX9gC3+8DX1LUf5PxiQMrFjbaYFL1c19ZXvg/ZMcWwisWOt2gavqGr5UwDrmeBA7OiBeYJXJoD/I25wkNjRC10Er2xaAKveH5qq5wgcJHb0xjKCV1a+7/L7fYzhtMcMTCd29Er5lIRVaxuWZUZQzKB7YkfvFE867ytBgmHxm8rppdHIP02gO36i0FuCB3TFTxN6TfCALvhJQu/1YUckMGxiR+95UWhgUWLHIAgesAixYzAED5iX2DEoggfMQ+wYHMEDZiV2DJLYAbMQOwbLOXhAW35aMGiCB7ThJwWDJ3jANH5KkATBgzR19RtGOvkJMR6P/coT1k7wgDoL/3QQOfrELk1ITxedETuS4hw8SEfely6+p2f+TeX5F80vd3d3DwTPDxvWKf/35z9iMEzlQ2NHjx5d+D4bJ7titOoCdvz48YUfBHTNhAdpGI/HnXSm1TJm0w+N48eP26BCLwkeDN9oNIqdnf8uQi7y/bzQMbutra1J7CIsG9E/ggfDlA9R29vbB76H5/menil25eN1Ef9bxiwGT/ToE7GD4Sg2ZDwex+7ubkQs/n0892SXf+FDhw7FkSNHRI5ecw4eDEfek/F4HIcPH+7kPg/8BKia3qY5duxYZFkmePSa4EH/Fae6LMv27cRc5LDE5Lu/audl8Y7z6+UvtrW1FVdfffXkgRWLDH0jeNBfeTeyLJv05IMf/GDtx88Svrl3Yxajd8stt+yLnNDRZ4IH/VXuyJ133lk7jJVvazLzd33VtHfjjTfGzs7OvhoLHn1m0wr0S3lgyrIsLrvssrjkkksioj5ubb+Xp8auakmzfPvu7m584AMfOPBgBY++ckoC9E+5HzfccMOBASs36/fwzMuYdcfxbr755kmNTXcMgeBBP5Qnurwhd9111+Rj6vaNlP88v14208uFFd8fjUb73r/lllsiIg7ETvDoM8GDfijH7vDhw3HixInGwEV0sIzZtD5anuxGo1EcO3Ysrr/++skDNd0xFIIH61McjPb29ib9+NCHPhQRBye6qgmvaQPL1sUrtefZVX3itLd77rknIv473eUPWvAYAsGD9SlOdFmWxWg0igcffHCygjjtFLj8z5qMLn5Q5Ue1CV3xwVx99dVx880373vQgsdQCB6sVnnpMn+7/fbbY2dnp7Y1uaYJr2zfZFd3MnnVHRe/8Gg0mrz/2c9+Nkaj0b7pLg8e9J3YwWqUQ5f34vDhw3HvvfdWtqZpKXOa1rsxq0JXFbwTJ07ErbfeeuAJmO4YCiedw/IVY1fsxF133XVgiKoL3iym7sactpRZfkCj0SjuuuuuOHLkyIHgmfAYCsGD5akKXZZlcezYsbj99ttbha7NZpWi4mtjbhWuR/F6U+TKoct3Zt5zzz2T3TX5m+AxJIIH3SsvXeZvEREPPfTQvpZU9WWWwBW71njqQd0xvKoHUH679dZb47bbbjvwhCxpMiSCB92pCl3ehM985jNx3XXX1TalzUTXFL+ppx7s++DSMbppwbvnnnvi+uuvPzDhFZ8g9J1NK7C4uokuy7L48Ic/HJ/61Kcae1IVvogOTyov17NqU8r29nZsb2/vu769vR07OzvxxS9+Md797ndXPkHBYwickgDzq9p1WezAlVdeGQ888EBlT+qO3eUrLrMEr3zqwVbp/amnGxTfqh7kJZdcEg899NBkw8re3l5cuHBB9BgUwYPZTQvdkSNH4itf+cq+IanclLrJru6E81y5Z5WTXdU3dfmYXV3sytPdaDSKK664Ir70pS/FpZdeOnmiefAuXLjgtTQZBMGD9so7Li9cuDB5y0P31a9+NXZ3d/c1o9yPcgSrljDLmyqrtHoh6KolzDbLmMW3a6+9Nr785S/HVVdddWDCK056gkefCR40K09yxcjlP+OvuOKK+PrXvx4nTpyobUbdcmbVSmPE9KXMrXJYxhdvyG+vezmX4oSWv50/f37fW/G2/Pq5c+fiRz/6Ubz44osHgrnoAUhYFf8pg/9p04v89ptuuik+//nPx87OTuzs7MShQ4cml8W34m07OzuTfSBVS5s1097+w3JV37DF4FX9nqHiiYDF2FXFrer63t5ePP744/G73/0uxuNx662mxScC6yZ4bLJi4PLL/JBU3YuJfPrTn45PfvKTk9CVg1YVu/zjyhNf1QnnEZPVlwOh2Jn2hOpOMB+NRvtCtb29HVmWxfb29r44lq/n7rzzznjPe94Tv/71r+PNN9+cfEzTQUjRo2/KsVvVv0uRZV2qIlc1zRV//h87dizuv//+uO666/aFrhixqqDVDUER1b8Boen7r3Kyu/gExuUn07SzpmrCq7osr9+eP38+fv/738fTTz8dZ86cqTwmWF6jLT4p0WPdsiw7cNss/y6FiyGoi1x5oitGbnd3N+6444647bbb9gWtagmzPMnVLV/WTXVNOzEjpsSu6olVjal1wSsvX1a95Z979uzZePLJJ+PZZ5+N8+fP5w+41XQnfKxbVfBg6MqBy69PexuNRvGRj3wk7r777srzr8tBqwpeOY7FvR1NG1SqQhfRInZ1T65us0rTlNcUu/x+Tp8+Hb/97W/jr3/9a5w+fbr2pWBm2XIKq2BCY+hq9nBMvcyv7+7uxv/93//F5z73uX2nFIxGowNTXTl2VaErLm222c9RF7qIhthdfBKV013T7sxi7PLrdbErfnz5tdKyLIt//etf8dxzz8VLL70Ur776aozH48a4iR3rZsIjReXJLre1tRWXXnppXHfddfGJT3wirrzyysoXGilPdfn1cuzKf15cuqyLXf44Ll7WRqBxg8rW1tbWeDweb21tVYam+CK5xSBub2/vu738ufnnFx9slmWT9/PYve9974v3vve9kWVZvPnmm/H888/Hv//97/jPf/4Tb7/9dpw5cybeeeedyStmQx+Y8PzHMzWHDh2Ko0ePxtGjR+PYsWNx2WWXxTXXXBM33HBDHDp0qPbFRupiV/fWZnPKvJsVGye7iNmWM8sTXtWUV/V+eSmz/Mv8ipcR//vfc/7Q3nrrrTh9+vTkXI6K59DqLwO6UPXvcJYf/rMszYsKXakaSI4cORLHjx+P3d3dykNJxWNnTS8fWXUMrs2uzGmxm7YppWjqqQfT/kKK013bzys/2PyJ7O3t7bssb2HNL/OvmQf3+PHjcfnll0/uX9wAFtO0EXBa7KpeVaspeMWPaTPRVYR56v/62pxnt5VPd1XLmfn7VUuadX9xTX9J+bl2VedrlF9Dc9qBUwBmV7cBsOqt/HO8OJHl8aqb3KpCV/U6mFN247da3mg12TUFLw9T/mfTJr3yX9CisWsKnegBtFe3hF6MTP4zvnwKQNMSZjl4dUuW5dAVL2seb+t1/NbLmMXglZUjVfXAmv5XUPwL2tvbm1xWnYnfdrorEj2AZlXdqDtOV/czfNpSZtUUV7fjsuo8ulk3pRTNdMyubndmfhwtD115a+rW1lbs7e21Cl1+P/nLj9UFL/+65ejltxeJHUCzqg0q+WXT8bq6ya4ueOX4lT+nvPJXt3w5q5k3qBT/IuqCF1G9caX8wIuvhZmHLo9c+UVEy8ErT3WWMQEWN+/xuvyyKmDTLquWLqeFbpYlzIj5dmNuRfz3lIS2wav7i8oDVjxel7+VJ7umY3Y2qAB0p2ITyIHrdfsuqia8umXKNrsuuwhdxAKTXfEvpSp4VRGqi13dppSqJcy6pczi15nyqjCLPmWAQZvWirbTXdMmlbZvVeEsfr2KxzHXOubUk8qnqXpJsfyyHKaqKa0pblWhm2eDSuGxLvRcAVIxa/CmLWVWxW7abVX3Ufxa5cc5b+giOpjsCg+i8mXBImIy6eVPKP+44kuEFSe7cgyrohlxcKqzMQVgfk2bVPLLWSa8utvaHpvrKnQR3Sxj7juGd/H6gfG3ahorhq94vK9qils0dMIHUK0ucsXrs054VZfFZcqmaa7iMSz8unidTXZFVcfxqp5EHqliDIvBKx77swuTFJT/bXbwPQxLUTdl1U1jVZNa06aTVYYuooNjdmXjwh2WA1QVqbpz5preive9yPKlKAKbpm07Zpnuqm6bthu/+Gd1j62r0EUsIXYR9cHL36+bzOomt2nTXNVzEDKA+bQ5dpdfNgWv7rbi7VVfs8vITe5zWVEYV9xx06RXvK3NRDht96XYAcynqjU1m0Yqp7Sm61X3Ubi+tHX9pcUuV45e06TX9v3y/diMAtCtWTetlC+bPr7mPpd6AHvpscu1mfTa3NZ0e9X9AjC7pumu6s/nCVzhtqXv1FpZ7HJtJr26P2vz523+DICD2jRnWvCabq+4r5VtR1557HLTJr2m29s8ZrEDmM0s7ZkWtKb7WmXkJl9z3VGoil7hz5o+b9r9zv+gADbQtAbNOvkVblv7CaVrj13ZvPEDYHVahm/tkcv1LnZlTfEDoD/6FLey3seujggCrFafYzbNYGMHAG39P8QjHPIeCPK8AAAAAElFTkSuQmCC"/>
-    <path id="Canary Badge" d="M112.189,145.49L254.837,81.3501L396.288,145.49C396.288,145.49 396.862,207.984 396.288,231.803C400.997,350.37 312.745,416.946 254.837,430.897C196.973,416.761 109.794,350.592 112.189,231.803C112.756,203.667 112.189,145.49 112.189,145.49ZM175.089,342.14C175.089,342.14 184.466,327.557 200.474,320.28C204.922,315.034 207.831,307.409 215.292,300.115C219.468,296.033 226.552,291.174 233.166,288.656C239.785,286.137 247.648,284.843 255,285C262.352,285.157 268.152,286.319 277.281,289.599C300.356,298.133 328.246,333.945 334.028,349.404C315.038,361.253 296.986,374.343 277.281,397.842C273.2,395.993 262.831,392.31 245.929,394.232C225.332,398.578 205.605,369.407 206.507,353.455C194.408,348.947 175.089,342.14 175.089,342.14ZM239.502,332.155C236.224,332.127 234.144,330.44 233.732,328.884C233.319,327.329 235.679,323.517 237.026,322.821C244.051,319.192 251.916,319.735 251.916,319.735C251.916,319.735 254.299,332.28 239.502,332.155ZM238.929,221.803L270.281,221.803L270.281,254.418L238.929,254.418L238.929,221.803ZM238.929,136.356L270.281,136.356L270.281,205.834L238.929,205.834L238.929,136.356Z" style="fill:rgb(253,237,0);"/>
-</svg>
diff --git a/build.gradle b/build.gradle
index b0568c40..cd06185f 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,44 +1,100 @@
+apply plugin: 'com.github.ben-manes.versions'
+
+buildscript {
+  ext.versions = [
+      'minSdk'    : 14,
+      'compileSdk': 29,
+      'errorProne': '2.3.1',
+      'kotlin'    : '1.3.21',
+  ]
+  ext.deps = [
+      assertj_core  : 'org.assertj:assertj-core:3.9.1',
+      // We don't need the latest version of AndroidX (there are no bugs that impact what LeakCanary
+      // relies on), we're sticking a bit older because most apps will be using a more recent version
+      // and they'll automatically resolve to higher version without having to necessarily resort to a
+      // resolution strategy.
+      androidx      : [
+          annotation: 'androidx.annotation:annotation:1.0.2',
+          core: 'androidx.core:core:1.0.1',
+          fragment  : 'androidx.fragment:fragment:1.0.0',
+          test      : [
+              core    : 'androidx.test:core:1.0.0',
+              espresso: 'androidx.test.espresso:espresso-core:3.1.0',
+              rules   : 'androidx.test:rules:1.1.0',
+              runner  : 'androidx.test:runner:1.1.0',
+          ],
+      ],
+      junit         : 'junit:junit:4.12',
+      kotlin        : [
+          gradlePlugin: "org.jetbrains.kotlin:kotlin-gradle-plugin:${versions.kotlin}",
+          stdlib      : "org.jetbrains.kotlin:kotlin-stdlib:${versions.kotlin}"
+      ],
+      mockito       : 'org.mockito:mockito-core:2.7.5',
+      mockito_kotlin: 'com.nhaarman:mockito-kotlin-kt1.1:1.5.0',
+      okio: 'com.squareup.okio:okio:2.2.2',
+      robolectric   : 'org.robolectric:robolectric:4.0-alpha-3',
+  ]
+  repositories {
+    google()
+    maven { url 'https://plugins.gradle.org/m2/' }
+    jcenter()
+  }
+  dependencies {
+    classpath deps.kotlin.gradlePlugin
+    classpath 'com.android.tools.build:gradle:3.4.0'
+    classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.0.16'
+    classpath 'com.github.ben-manes:gradle-versions-plugin:0.20.0'
+  }
+}
+
 subprojects {
+  group = GROUP
+  version = VERSION_NAME
 
   repositories {
-    mavenCentral()
-//    maven {
-//      url 'https://oss.sonatype.org/content/repositories/snapshots/'
-//    }
-//    mavenLocal()
+    google()
+    //    maven {
+    //      url 'https://oss.sonatype.org/content/repositories/snapshots/'
+    //    }
+    //    mavenLocal()
+    jcenter()
   }
 
-  buildscript {
-    repositories {
-      mavenCentral()
+  apply plugin: 'net.ltgt.errorprone'
+
+  tasks.withType(JavaCompile) {
+    options.compilerArgs += [
+        '-Xlint:all',
+        '-Xlint:-serial',
+        '-Xlint:-deprecation',
+        // espresso-core classes say they're compiled with 51.0 but contain 52.0 attributes.
+        // warning: [classfile] MethodParameters attribute introduced in version 52.0 class files is ignored in version 51.0 class files
+        // '-Werror'
+    ]
+  }
+
+  configurations.all {
+    resolutionStrategy {
+      eachDependency { details ->
+        // Force all the error-prone dependencies to use the same version.
+        if (details.requested.group == 'com.google.errorprone' &&
+            details.requested.name.startsWith('error_prone_')) {
+          details.useVersion versions.errorProne
+        }
+      }
     }
-    dependencies {
-      classpath 'com.android.tools.build:gradle:1.5.0'
+  }
+
+  tasks.withType(Test) {
+    testLogging {
+      exceptionFormat 'FULL'
+      showCauses true
+      showExceptions true
+      showStackTraces true
     }
   }
-}
 
-ext {
-  minSdkVersion = 8
-  compileSdkVersion = 23
-  targetSdkVersion = compileSdkVersion
-  buildToolsVersion = '23.0.2'
-  javaVersion = JavaVersion.VERSION_1_7
-
-  GROUP = 'com.squareup.leakcanary'
-  VERSION_NAME = "1.4-SNAPSHOT"
-  POM_PACKAGING = "pom"
-  POM_DESCRIPTION= "Leak Canary"
-
-  POM_URL="http://github.com/square/leakcanary/"
-  POM_SCM_URL="http://github.com/square/leakcanary/"
-  POM_SCM_CONNECTION="scm:git:https://github.com/square/leakcanary.git"
-  POM_SCM_DEV_CONNECTION="scm:git:git@github.com:square/leakcanary.git"
-
-  POM_LICENCE_NAME="The Apache Software License, Version 2.0"
-  POM_LICENCE_URL="http://www.apache.org/licenses/LICENSE-2.0.txt"
-  POM_LICENCE_DIST="repo"
-
-  POM_DEVELOPER_ID="square"
-  POM_DEVELOPER_NAME="Square, Inc."
+  dependencies {
+    errorprone "com.google.errorprone:error_prone_core:${versions.errorProne}"
+  }
 }
diff --git a/checkstyle.xml b/checkstyle.xml
index 7fb7ad32..ce09c3d1 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -72,7 +72,9 @@
     <module name="AvoidStarImport"/>
     <module name="IllegalImport"/>
     <module name="RedundantImport"/>
-    <module name="UnusedImports"/>
+    <module name="UnusedImports">
+      <property name="processJavadoc" value="true"/>
+    </module>
 
 
     <!-- Checks for Size Violations.                    -->
@@ -81,7 +83,7 @@
       <!--property name="max" value="100"/-->
     <!--/module-->
     <!--module name="MethodLength"/-->
-    <module name="ParameterNumber"/>
+    <!--<module name="ParameterNumber"/>-->
 
 
     <!-- Checks for whitespace                               -->
@@ -89,8 +91,8 @@
     <module name="GenericWhitespace"/>
     <module name="EmptyForIteratorPad"/>
     <module name="MethodParamPad"/>
-    <module name="NoWhitespaceAfter"/>
-    <module name="NoWhitespaceBefore"/>
+    <!--<module name="NoWhitespaceAfter"/>-->
+    <!--<module name="NoWhitespaceBefore"/>-->
     <module name="OperatorWrap"/>
     <module name="ParenPad"/>
     <module name="TypecastParenPad"/>
@@ -145,4 +147,4 @@
     <!--module name="TodoComment"/-->
     <module name="UpperEll"/>
   </module>
-</module>
\ No newline at end of file
+</module>
diff --git a/docs/blog-articles.md b/docs/blog-articles.md
new file mode 100644
index 00000000..b3752f1f
--- /dev/null
+++ b/docs/blog-articles.md
@@ -0,0 +1,4 @@
+* [Detect memory leaks in your instrumentation tests using LeakCanary](https://proandroiddev.com/detecting-memory-leaks-in-your-instrumentation-tests-using-leakcanary-1268e911d5ce)
+* [9 ways to avoid memory leaks in Android](https://android.jlelse.eu/9-ways-to-avoid-memory-leaks-in-android-b6d81648e35e)
+
+Your article should be here, please update this list! Any technical level welcome.
\ No newline at end of file
diff --git a/docs/changelog.md b/docs/changelog.md
new file mode 100644
index 00000000..e315d1da
--- /dev/null
+++ b/docs/changelog.md
@@ -0,0 +1,313 @@
+# Change Log
+
+## Version 2.0 Alpha 3 (2019-07-04)
+
+**Thanks for testing the alpha**, we're counting on you to help us find bugs and suggest improvements! Check out the new [Getting Started](https://square.github.io/leakcanary/getting_started) instructions and the [migration guide](https://square.github.io/leakcanary/upgrading-to-leakcanary-2.0/). 
+
+* [#1401](https://github.com/square/leakcanary/pull/1401) LeakCanary can now import all hprof files created from prior LeakCanary versions.
+* [#1414](https://github.com/square/leakcanary/pull/1414) New API: `RefWatcher.retainedInstances` which returns the instances that are currently considered retained.
+* [#1419](https://github.com/square/leakcanary/pull/1419) New APIs: `LeakCanary.Config.maxStoredHeapDumps` (default 7) and `LeakCanary.Config.requestWriteExternalStoragePermission` (default false). LeakCanary won't ask for the external storage permission anymore by default.
+* [#1338](https://github.com/square/leakcanary/issues/1338) API change: `LeakCanary.Config.exclusionsFactory` replaced with `LeakCanary.Config.knownReferences` (simpler use), `LeakCanary.Config.leakInspectors` and `LeakCanary.Config.labelers` merged into `LeakCanary.Config.leakTraceInspectors` which provides access to the entire leak trace as well as a new graph oriented API that replaces the low level hprof parser API.
+* [#1382](https://github.com/square/leakcanary/issues/1382) LeakCanary now disables automatic heap dumping when running in AndroidX UI tests.
+* [#1424](https://github.com/square/leakcanary/pull/1424) API rename: `RefWatcher.hasRetainedReferences` => `RefWatcher.hasRetainedInstances`, `RefWatcher.retainedReferenceCount` => `RefWatcher.retainedInstanceCount`, `RefWatcher.hasWatchedReferences` => `RefWatcher.hasWatchedInstances`, `RefWatcher.removeKeysRetainedBeforeHeapDump` => `RefWatcher.removeInstancesRetainedBeforeHeapDump`, `RefWatcher.clearWatchedReferences` => `RefWatcher.clearWatchedInstances`.
+* [#1432](https://github.com/square/leakcanary/pull/1432) [#1438](https://github.com/square/leakcanary/pull/1438) [#1440](https://github.com/square/leakcanary/pull/1440) New "won't fix" leaks and leak trace inspectors
+* [#1374](https://github.com/square/leakcanary/issues/1374) [#1364](https://github.com/square/leakcanary/issues/1364) [#1366](https://github.com/square/leakcanary/issues/1366) [#1417](https://github.com/square/leakcanary/issues/1417) [#1399](https://github.com/square/leakcanary/issues/#1399) [#1416](https://github.com/square/leakcanary/issues/1416) [#1407](https://github.com/square/leakcanary/issues/1407) [#1427](https://github.com/square/leakcanary/issues/1427) [#1385](https://github.com/square/leakcanary/issues/1385) Bug and crash fixes
+
+Many thanks to
+[@1step2hell](https://github.com/1step2hell),
+[@afollestad](https://github.com/afollestad),
+[@ansman](https://github.com/ansman),
+[@bjdodson](https://github.com/bjdodson),
+[@BraisGabin](https://github.com/BraisGabin),
+[@EBfVince](https://github.com/EBfVince),
+[@jaredsburrows](https://github.com/jaredsburrows),
+[@pforhan](https://github.com/pforhan),
+[@pyricau](https://github.com/pyricau),
+[@tellypresence](https://github.com/tellypresence),
+[@wiyarmir](https://github.com/wiyarmir)
+for the contributions, bug reports and feature requests.
+
+For more details, see the [2.0-alpha-3 Milestone](https://github.com/square/leakcanary/milestone/8) and the [full diff](https://github.com/square/leakcanary/compare/v2.0-alpha-2...v2.0-alpha-3).
+
+## Version 2.0 Alpha 2 (2019-05-21)
+
+* [#1040](https://github.com/square/leakcanary/pull/1040) Import and analyze hprof files from other devices
+* [#1344](https://github.com/square/leakcanary/pull/1344) Computing retained size
+* [#1325](https://github.com/square/leakcanary/pull/1325) New notification showing current count of retained instances
+* [#1079](https://github.com/square/leakcanary/pull/1079) "Excluded" leaks have been renamed to "Won't fix" leaks to clarify meaning.
+* [#1328](https://github.com/square/leakcanary/pull/1328) New leaks are called out in the UI. 
+* [#1327](https://github.com/square/leakcanary/pull/1327) LeakSentry can be enabled / disabled and is automatically disabled in non debuggable builds.
+* [#1173](https://github.com/square/leakcanary/pull/1173) Experimental: now reporting leaks that only go through weak references (previously reported as "no path to instance")
+* [#1339](https://github.com/square/leakcanary/pull/1339) Readded support for Thread name based exclusions
+* [#1312](https://github.com/square/leakcanary/pull/1312) Fixed bug causing LeakCanary to stop detecting leaks after the app is killed.
+* [#1310](https://github.com/square/leakcanary/pull/1310) [#1313](https://github.com/square/leakcanary/pull/1313) [#1314](https://github.com/square/leakcanary/pull/1314) [#1340](https://github.com/square/leakcanary/pull/1340) [#1337](https://github.com/square/leakcanary/pull/1337) Many API changes
+* [#1296](https://github.com/square/leakcanary/pull/1296) [#1293](https://github.com/square/leakcanary/pull/1293) [#1306](https://github.com/square/leakcanary/pull/1306) [#1336](https://github.com/square/leakcanary/pull/1336) Fixed several crashes. 
+
+Many thanks to
+[@forrestbice](https://github.com/forrestbice),
+[@Foso](https://github.com/Foso),
+[@Goddchen](https://github.com/Goddchen),
+[@marcosholgado](https://github.com/marcosholgado),
+[@orionlee](https://github.com/orionlee),
+[@pyricau](https://github.com/pyricau),
+[@satoshun](https://github.com/satoshun),
+[@ZacSweers](https://github.com/ZacSweers)
+for the contributions!
+
+For more details, see the [2.0-alpha-2 Milestone](https://github.com/square/leakcanary/milestone/7) and the [full diff](https://github.com/square/leakcanary/compare/v2.0-alpha-1...v2.0-alpha-2).
+
+## Version 2.0 Alpha 1 (2019-04-23)
+
+<img src="https://github.com/square/leakcanary/wiki/assets/logo-2.0-200px.png" />
+
+* New [logo](https://github.com/square/leakcanary/wiki/FAQ#who-made-the-logo), thanks [@flickator](https://github.com/flickator)!
+* Entirely rewritten to **100% Kotlin**
+* Multiple leaks detected in one analysis
+    * The heap is dumped when the app goes in the background, or when a minimum of 5 leaks is reached in the foreground.
+* Leak grouping
+    * Leaks that share similar causes are grouped in the UI.
+    * New screens to see the list of groups and each group.
+    * Improved leaktrace strings to highlight leak causes.
+    * Leaks can be shared to Stack Overflow
+* New library: **LeakSentry**.
+    * Detects when objects are leaking and triggers LeakCanary
+    * Can be used independently in production, for instance to report the number of leaking instances on an OutOfMemoryError crash.
+* New heap parser
+    * Uses **90% less memory and 6 times** faster than the prior heap parser.
+    * Runs in the same process as the app on a low priority thread.
+    * No more dependency on Perflib and TroveJ. New dependency on Okio.
+    * The old parser is still available as `leakcanary-android-perflib` but will be removed after alpha.
+* Labelers can add any string content to leak elements
+* 0 code setup, just add the one debug dependency.
+* Simpler configuration options
+* Updated from support library to Android X
+
+Many thanks to
+[@BraisGabin](https://github.com/BraisGabin),
+[@colinmarsch](https://github.com/colinmarsch),
+[@jrodbx](https://github.com/jrodbx),
+[@flickator](https://github.com/flickator),
+[@JakeWharton](https://github.com/JakeWharton),
+[@pyricau](https://github.com/pyricau),
+[@WhatsEmo](https://github.com/WhatsEmo)
+for the contributions!
+
+For more details, see the [2.0-alpha-1 Milestone](https://github.com/square/leakcanary/milestone/6) and the [full diff](https://github.com/square/leakcanary/compare/v1.6.3...v2.0-alpha-1).
+
+## Version 1.6.3 (2019-01-10)
+
+* [#1163](https://github.com/square/leakcanary/issues/1163) Fixed leaks being incorrectly classified as "no leak" due to missed GC Roots.
+* [#1153](https://github.com/square/leakcanary/issues/1153) `LeakCanary.isInAnalyzerProcess` now correctly returns true in the analyzer process prior to any first leak (could be triggered by starting the leak result activity).
+* [#1158](https://github.com/square/leakcanary/issues/1158) Stopped enabling DisplayLeakActivity when not using DisplayLeakService.
+* [#1135](https://github.com/square/leakcanary/issues/1135) Fixed IndexOutOfBoundsException for leak traces of size 1.
+* [#1163](https://github.com/square/leakcanary/issues/1163) Keep "no leak" heap dumps.
+
+Many thanks to
+[@KMaragh](https://github.com/KMaragh),
+[@pyricau](https://github.com/pyricau),
+[@SebRut](https://github.com/SebRut)
+for the code contributions!
+
+For more details, see the [1.6.3 Milestone](https://github.com/square/leakcanary/milestone/5) and the [full diff](https://github.com/square/leakcanary/compare/v1.6.2...v1.6.3).
+
+
+## Version 1.6.2 (2018-10-16)
+
+* [#1067](https://github.com/square/leakcanary/issues/1067) Fixed TransactionTooLargeException crash (leak analysis would never complete).
+* [#1061](https://github.com/square/leakcanary/pull/1061) Detection of Fragment view leaks after Fragment#onDestroyView().
+* [#1076](https://github.com/square/leakcanary/pull/1076) Added the FOREGROUND_SERVICE permission for Android P.
+* [#1062](https://github.com/square/leakcanary/issues/1062) The LeakCanary toast now always shows correctly. It doesn't show if there is no activity in foreground.
+* [#1115](https://github.com/square/leakcanary/issues/1115) Reenabled the DisplayLeakActivity icon on fresh installs.
+* [#1100](https://github.com/square/leakcanary/pull/1100) Added nullability annotations to improve Kotlin support.
+* Updates to excluded leaks ([commits](https://github.com/square/leakcanary/commits/v1.6.2/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java)).
+* Updates to reachability inspectors ([commits](https://github.com/square/leakcanary/commits/v1.6.2/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java)).
+
+Many thanks to
+[@fractalwrench](https://github.com/fractalwrench),
+[@hzsweers](https://github.com/hzsweers),
+[@Goddchen](https://github.com/Goddchen),
+[@igokoro](https://github.com/igokoro),
+[@IlyaGulya](https://github.com/IlyaGulya),
+[@JakeWharton](https://github.com/JakeWharton),
+[@javmarina](https://github.com/javmarina),
+[@jokermonn](https://github.com/jokermonn),
+[@jrodbx](https://github.com/jrodbx),
+[@Parseus](https://github.com/Parseus),
+[@pyricau](https://github.com/pyricau),
+[@scottkennedy](https://github.com/scottkennedy)
+for the code contributions!
+
+### Public API changes
+
+* Subclasses of `AbstractAnalysisResultService` should now override `onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap)` instead of `onHeapAnalyzed(@NonNull HeapDump heapDump, @NonNull AnalysisResult result)`
+
+For more details, see the [1.6.2 Milestone](https://github.com/square/leakcanary/milestone/4) and the [full diff](https://github.com/square/leakcanary/compare/v1.6.1...v1.6.2).
+
+## Version 1.6.1 (2018-06-21)
+
+* [#727](https://github.com/square/leakcanary/issues/727) Improved leak analysis: LeakCanary now identifies and highlights the potential causes of the leak.
+* [#1011](https://github.com/square/leakcanary/issues/1011) We noticed that computing the retained heap size could take a long time, so it's now optional and off by default.
+* [#633](https://github.com/square/leakcanary/pull/633) Support for detecting leaks in instrumentation tests ([see the wiki](https://github.com/square/leakcanary/wiki/Customizing-LeakCanary#running-leakcanary-in-instrumentation-tests)).
+* [#985](https://github.com/square/leakcanary/pull/985) Ability to convert leak traces into stack traces for easy remote reporting ([see the wiki](https://github.com/square/leakcanary/wiki/Customizing-LeakCanary#uploading-to-a-server)).
+* [#983](https://github.com/square/leakcanary/issues/983) Support for watching destroyed Fragments.
+* [#846](https://github.com/square/leakcanary/issues/846) LeakCanary now uses foreground services and displays a notification when the analysis is in progress. This also fixes crashes when analyzing in background on O+.
+* The LeakCanary icon (to start to DisplayLeakActivity) is now hidden by default, and only enabled after the first leak is found.
+* [#775](https://github.com/square/leakcanary/issues/775) Fixed crash when sharing heap dumps on O+ and added a dependency to the support-core-utils library.
+* [#930](https://github.com/square/leakcanary/pull/930) DisplayLeakActivity has a responsive icon.
+* [#685](https://github.com/square/leakcanary/issues/685) Stopped doing IO on main thread in DisplayLeakActivity (fixes StrictMode errors).
+* [#999](https://github.com/square/leakcanary/pull/999) Updated HAHA to 2.0.4, which uses Trove4j as an external dependency (from jcenter) instead of rebundling it. This is to clarify licences (Apache v2 vs LGPL 2.1).
+* Several bug and crash fixes.
+
+Many thanks to [@AdityaAnand1](https://github.com/AdityaAnand1), [@alhah](https://github.com/alhah), [@christxph](https://github.com/christxph), [@csoon03](https://github.com/csoon03), [@daqi](https://github.com/daqi), [@JakeWharton](https://github.com/JakeWharton), [@jankovd](https://github.com/jankovd), [@jrodbx](https://github.com/jrodbx), [@kurtisnelson](https://github.com/kurtisnelson), [@NightlyNexus](https://github.com/NightlyNexus), [@pyricau](https://github.com/pyricau), [@SalvatoreT](https://github.com/SalvatoreT), [@shmuelr](https://github.com/shmuelr), [@tokou](https://github.com/tokou), [@xueqiushi](https://github.com/xueqiushi)
+ for the code contributions!
+
+Note: we made a 1.6 release but quickly followed up with 1.6.1 due to [#1058](https://github.com/square/leakcanary/issues/1058).
+
+### Public API changes
+
+* The installed ref watcher singleton is now available via `LeakCanary.installedRefWatcher()`
+* `AnalysisResult.leakTraceAsFakeException()` returns an exception that can be used to report and group leak traces to a tool like Bugsnag or Crashlytics.
+* New `InstrumentationLeakDetector` and `FailTestOnLeakRunListener` APIs for detecting leaks in instrumentation tests.
+* New `Reachability.Inspector` and `RefWatcherBuilder.stethoscopeClasses()` API to establish reachability and help identify leak causes.
+* Watching activities can be disabled with `AndroidRefWatcherBuilder.watchActivities(false)`, watching fragments can be disabled with `AndroidRefWatcherBuilder.watchFragments(false)`
+* `LeakCanary.setDisplayLeakActivityDirectoryProvider()` is deprecated and replaced with `LeakCanary.setLeakDirectoryProvider()`
+* New `RefWatcherBuilder.computeRetainedHeapSize()` API to enable the computing of the retained heap size (off by default).
+
+For more details, see the [1.6.1 Milestone](https://github.com/square/leakcanary/milestone/3) and the [full diff](https://github.com/square/leakcanary/compare/v1.5.4...v1.6.1).
+
+## Version 1.5.4 *(2017-09-22)*
+
+* Restore Java 7 compatibility in leakcanary-watcher
+
+## Version 1.5.3 *(2017-09-17)*
+
+* Fix broken 1.5.2 [build](https://github.com/square/leakcanary/issues/815)
+* Convert leakcanary-watcher from Android library to Java library
+* Disable finish animations in RequestStoragePermissionActivity
+* Corrected README sample for Robolectric tests
+
+For more details, see the [full diff](https://github.com/square/leakcanary/compare/v1.5.2...v1.5.3).
+
+## Version 1.5.2 *(2017-08-09)*
+
+* New excluded leaks
+* Move Leakcanary UI into leak analyzer process
+* Ignore computing retained sizes for bitmaps on O+
+* Add notification channel for persistent messages on O+
+* Exclude permission activity from recents menu
+* Updated README and sample for handling Robolectric tests
+
+For more details, see the [full diff](https://github.com/square/leakcanary/compare/v1.5.1...v1.5.2).
+
+## Version 1.5.1 *(2017-04-25)*
+
+* New excluded leaks
+* Fix java.util.MissingFormatArgumentException in DisplayLeakService
+* Separate task affinities for different apps
+* Bump minSdk to 14
+* Fix HahaHelper for O Preview
+  
+For more details, see the [full diff](https://github.com/square/leakcanary/compare/v1.5...v1.5.1).
+
+## Version 1.5 *(2016-09-28)*
+
+* New excluded leaks
+* Added `LeakCanary.isInAnalyzerProcess()` to the no-op jar
+* Fixed several file access issues:
+    * No more cleanup on startup, we rotate the heap dump files on every new heap dump.
+    * LeakCanary now falls back to the app directory until it can write to the external storage.
+* Leak notifications now each use a distinct notification instead of erasing each other.
+* If LeakCanary can't perform a heap dump for any reason (e.g. analysis in progress, debugger attached), it retries later with an exponential backoff.
+* Added confirmation dialog when user deletes all leaks.
+* Replace the two LeakCanary configuration methods with a builder that provides more flexibility, see `LeakCanary.refWatcher()`.
+
+For more details, see the [full diff](https://github.com/square/leakcanary/compare/v1.4...v1.5).
+
+### Public API changes
+
+* New `HeapAnalyzer.findTrackedReferences()` method for headless analysis when you have no context on what leaked.
+* Added `LeakCanary.isInAnalyzerProcess()` to the no-op jar
+* Added `LeakCanary.refWatcher()` which returns an `AndroidRefWatcherBuilder` that extends `RefWatcherBuilder` and lets you fully customize the `RefWatcher` instance.
+* Removed `LeakCanary.install(Application, Class)` and `LeakCanary.androidWatcher(Context, HeapDump.Listener, ExcludedRefs)`.
+* Removed `R.integer.leak_canary_max_stored_leaks` and `R.integer.leak_canary_watch_delay_millis`, those can now be set via `LeakCanary.refWatcher()`.
+* Updated the `LeakDirectoryProvider` API to centralize all file related responsibilities.
+* `RefWatcher` is now constructed with a `WatchExecutor` which executes a `Retryable`, instead of an `Executor` that executes a `Runnable`.
+* `HeapDumper.NO_DUMP` was renamed `HeapDumper.RETRY_LATER`
+
+## Version 1.4 *(2016-09-11)*
+
+* Fix false negative where GC root is of type android.os.Binder [#482](https://github.com/square/leakcanary/issues/482)
+* Update HAHA to 2.0.3; clear compiler warnings [#563](https://github.com/square/leakcanary/issues/563) 
+* Correct some mistakes in German translation [#516](https://github.com/square/leakcanary/pull/516)
+* Don't loop when storage permission denied [#422](https://github.com/square/leakcanary/issues/422)
+* Remove old references to "__" prefixed resources [#477](https://github.com/square/leakcanary/pull/477)
+* Fix permission crash for DisplayLeakActivity on M [#382](https://github.com/square/leakcanary/issues/382)
+* Fix NPE when thread name not found in heap dump [#417](https://github.com/square/leakcanary/issues/417)
+* Add version info to stacktrace [#473](https://github.com/square/leakcanary/issues/473)
+
+## Version 1.4-beta2 *(2016-03-23)*
+
+* Add reason for ignoring to analysis result [#365](https://github.com/square/leakcanary/issues/365).
+* Lower memory usage when parsing heap dumps on M [#223](https://github.com/square/leakcanary/issues/223).
+* Fix NPE in LeakCanaryInternals.isInServiceProcess() [#449](https://github.com/square/leakcanary/issues/449).
+* New ignored Android SDK leaks [#297](https://github.com/square/leakcanary/issues/297),[#322](https://github.com/square/leakcanary/issues/322).
+* Use leakcanary-android-no-op in test builds [#143](https://github.com/square/leakcanary/issues/143).
+* Fixes to allow LeakCanary to work with ProGuard [#398](https://github.com/square/leakcanary/pull/398).
+* Optimize png assets [#406](https://github.com/square/leakcanary/pull/406).
+* Fix delete button not working on error views [#408](https://github.com/square/leakcanary/pull/408).
+* Add German translation [#437](https://github.com/square/leakcanary/pull/437).
+
+## Version 1.4-beta1 *(2016-01-08)*
+
+* Switched to [HAHA 2.0.2](https://github.com/square/haha/blob/master/CHANGELOG.md#version-202-2015-07-20) with uses Perflib instead of MAT under the hood [#219](https://github.com/square/leakcanary/pull/219). This fixes crashes and improves speed a lot.
+* We can now parse Android M heap dumps [#267](https://github.com/square/leakcanary/issues/267), although there are still memory issues (see [#223](https://github.com/square/leakcanary/issues/223)).
+* Excluded leaks are now reported as well and available in the display leak activity.
+* Added ProGuard configuration for [#132](https://github.com/square/leakcanary/issues/132).
+* Many new ignored Android SDK leaks.
+* Added excluded leaks to text report [#119](https://github.com/square/leakcanary/issues/119).
+* Added LeakCanary SHA to text report [#120](https://github.com/square/leakcanary/issues/120).
+* Added CanaryLog API to replace the logger: [#201](https://github.com/square/leakcanary/issues/201).
+* Renamed all resources to begin with `leak_canary_` instead of `__leak_canary`[#161](https://github.com/square/leakcanary/pull/161)
+* No crash when heap dump fails [#226](https://github.com/square/leakcanary/issues/226).
+* Add retained size to leak reports [#162](https://github.com/square/leakcanary/issues/162).
+
+### Public API changes
+
+* AnalysisResult.failure is now a `Throwable` instead of an `Exception`. Main goal is to catch and correctly report OOMs while parsing.
+* Added ARRAY_ENTRY to LeakTraceElement.Type for references through array entries.
+* Renamed `ExcludedRefs` fields.
+* Each `ExcludedRef` entry can now be ignored entirely or "kept only if no other path".
+* Added support for ignoring all fields (static and non static) for a given class.
+
+## Version 1.3.1 *(2015-05-16)*
+
+* Heap dumps and analysis results are now saved on the sd card: [#21](https://github.com/square/leakcanary/issues/21).
+* `ExcludedRef` and `AndroidExcludedRefs` are customizable: [#12](https://github.com/square/leakcanary/issues/12) [#73](https://github.com/square/leakcanary/issues/73).
+* 7 new ignored Android SDK leaks: [#1](https://github.com/square/leakcanary/issues/1) [#4](https://github.com/square/leakcanary/issues/4) [#32](https://github.com/square/leakcanary/issues/32) [#89](https://github.com/square/leakcanary/pull/89) [#82](https://github.com/square/leakcanary/pull/82) [#97](https://github.com/square/leakcanary/pull/97).
+* Fixed 3 crashes in LeakCanary: [#37](https://github.com/square/leakcanary/issues/37) [#46](https://github.com/square/leakcanary/issues/46) [#66](https://github.com/square/leakcanary/issues/66).
+* Fixed StrictMode thread policy violations: [#15](https://github.com/square/leakcanary/issues/15).
+* Updated `minSdkVersion` from `9` to `8`: [#57](https://github.com/square/leakcanary/issues/57).
+* Added LeakCanary version name to `LeakCanary.leakInfo()`: [#49](https://github.com/square/leakcanary/issues/49).
+* `leakcanary-android-no-op` is lighter, it does not depend on `leakcanary-watcher` anymore, only 2 classes now: [#74](https://github.com/square/leakcanary/issues/74).
+* Adding field state details to the text leak trace.
+* A Toast is displayed while the heap dump is in progress to warn that the UI will freeze: [#20](https://github.com/square/leakcanary/issues/49). You can customize the toast by providing your own layout named `__leak_canary_heap_dump_toast.xml` (e.g. you could make it an empty layout).
+* If the analysis fails, the result and heap dump are kept so that it can be reported to LeakCanary: [#102](https://github.com/square/leakcanary/issues/102).
+* Update to HAHA 1.3 to fix a 2 crashes [#3](https://github.com/square/leakcanary/issues/3) [46](https://github.com/square/leakcanary/issues/46)
+
+### Public API changes
+
+* When upgrading from 1.3 to 1.3.1, previously saved heap dumps will not be readable any more, but they won't be removed from the app directory. You should probably uninstall your app.
+* Added `android.permission.WRITE_EXTERNAL_STORAGE` to `leakcanary-android` artifact.
+* `LeakCanary.androidWatcher()` parameter types have changed (+ExcludedRefs).
+* `LeakCanary.leakInfo()` parameter types have changed (+boolean)
+* `ExcludedRef` is now serializable and immutable, instances can be created using `ExcludedRef.Builder`.
+* `ExcludedRef` is available in `HeapDump`
+* `AndroidExcludedRefs` is an enum, you can now pick the leaks you want to ignore in `AndroidExcludedRefs` by creating an `EnumSet` and calling `AndroidExcludedRefs.createBuilder()`.
+* `AndroidExcludedRefs.createAppDefaults()` & `AndroidExcludedRefs.createAndroidDefaults()` return a `ExcludedRef.Builder`.
+* `ExcludedRef` moved from `leakcanary-analyzer` to `leakcanary-watcher`
+
+## Version 1.3 *(2015-05-08)*
+
+Initial release.
+
+### Dependencies
diff --git a/docs/code_of_conduct.md b/docs/code_of_conduct.md
new file mode 100644
index 00000000..6a97690c
--- /dev/null
+++ b/docs/code_of_conduct.md
@@ -0,0 +1,102 @@
+Open Source Code of Conduct
+===========================
+
+At Square, we are committed to contributing to the open source community and simplifying the process
+of releasing and managing open source software. We’ve seen incredible support and enthusiasm from
+thousands of people who have already contributed to our projects — and we want to ensure our community
+continues to be truly open for everyone.
+
+This code of conduct outlines our expectations for participants, as well as steps to reporting
+unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and
+expect our code of conduct to be honored.
+
+Square’s open source community strives to:
+
+ * **Be open**: We invite anyone to participate in any aspect of our projects. Our community is
+   open, and any responsibility can be carried by a contributor who demonstrates the required
+   capacity and competence.
+
+ * **Be considerate**: People use our work, and we depend on the work of others. Consider users and
+   colleagues before taking action. For example, changes to code, infrastructure, policy, and
+   documentation may negatively impact others.
+
+ * **Be respectful**: We expect people to work together to resolve conflict, assume good intentions,
+   and act with empathy. Do not turn disagreements into personal attacks.
+
+ * **Be collaborative**: Collaboration reduces redundancy and improves the quality of our work. We
+   strive for transparency within our open source community, and we work closely with upstream
+   developers and others in the free software community to coordinate our efforts.
+
+ * **Be pragmatic**: Questions are encouraged and should be asked early in the process to avoid
+   problems later. Be thoughtful and considerate when seeking out the appropriate forum for your
+   questions. Those who are asked should be responsive and helpful.
+
+ * **Step down considerately**: Members of every project come and go. When somebody leaves or
+   disengages from the project, they should make it known and take the proper steps to ensure that
+   others can pick up where they left off.
+
+This code is not exhaustive or complete. It serves to distill our common understanding of a
+collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in
+the letter.
+
+Diversity Statement
+-------------------
+
+We encourage everyone to participate and are committed to building a community for all. Although we
+may not be able to satisfy everyone, we all agree that everyone is equal.
+
+Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone
+has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do
+our best to right the wrong.
+
+Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity,
+gender identity or expression, language, national origin, political beliefs, profession, race,
+religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate
+discrimination based on any of the protected characteristics above, including participants with
+disabilities.
+
+Reporting Issues
+----------------
+
+If you experience or witness unacceptable behavior — or have any other concerns — please report it by
+emailing [codeofconduct@squareup.com][codeofconduct_at]. For more details, please see our Reporting
+Guidelines below.
+
+Thanks
+------
+
+Some of the ideas and wording for the statements and guidelines above were based on work by the
+[Twitter][twitter_coc], [Ubuntu][ubuntu_coc], [GDC][gdc_coc], and [Django][django_coc] communities.
+We are thankful for their work.
+
+Reporting Guide
+---------------
+
+If you experience or witness unacceptable behavior — or have any other concerns — please report it by
+emailing [codeofconduct@squareup.com][codeofconduct_at]. All reports will be handled with
+discretion.
+
+In your report please include:
+
+ * Your contact information.
+ * Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional
+   witnesses, please include them as well.
+ * Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly
+   available record (e.g. a mailing list archive or a public IRC logger), please include a link.
+ * Any additional information that may be helpful.
+
+After filing a report, a representative from the Square Code of Conduct committee will contact you
+personally. The committee will then review the incident, follow up with any additional questions,
+and make a decision as to how to respond.
+
+Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual
+engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem
+appropriate, up to and including a permanent ban from all of Square spaces without warning.
+
+
+[codeofconduct_at]: mailto:codeofconduct@squareup.com
+[twitter_coc]: https://github.com/twitter/code-of-conduct/blob/master/code-of-conduct.md
+[ubuntu_coc]: https://ubuntu.com/community/code-of-conduct
+[gdc_coc]: https://www.gdconf.com/code-of-conduct
+[django_coc]: https://www.djangoproject.com/conduct/reporting/
+
diff --git a/docs/contributing.md b/docs/contributing.md
new file mode 100644
index 00000000..7b4fb258
--- /dev/null
+++ b/docs/contributing.md
@@ -0,0 +1,8 @@
+# Contributing
+
+If you would like to contribute code to LeakCanary you can do so through GitHub by
+forking the repository and sending a pull request.
+
+When submitting code, please make every effort to follow existing conventions
+and style in order to keep the code as readable as possible. Please also make
+sure your code compiles by running `./gradlew build`.
diff --git a/docs/faq.md b/docs/faq.md
new file mode 100644
index 00000000..b5e4d21e
--- /dev/null
+++ b/docs/faq.md
@@ -0,0 +1,78 @@
+# FAQ
+
+## Can a leak be caused by the Android SDK?
+
+Yes. There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: [AndroidExcludedRefs.kt](https://github.com/square/leakcanary/blob/master/leakcanary-analyzer/src/main/java/leakcanary/AndroidExcludedRefs.kt).
+
+If you find a new one, please [create an issue](https://github.com/square/leakcanary/issues/new/choose) and follow these steps:
+
+1. Provide the entire leak trace information (reference key, device, etc), and use backticks (`) for formatting.
+2. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions [android/platform_frameworks_base](https://github.com/android/platform_frameworks_base).
+3. Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed.
+4. If it's still happening, build a simple repro case.
+5. File an issue on [b.android.com](http://b.android.com) with the leak trace and the repro case.
+6. Create a PR in LeakCanary to update `AndroidExcludedRefs.kt`. Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
+
+## How do I share a leak trace?
+
+* Go to the leak screen, click the overflow menu and select *Share Info*.
+* You can also find the leak trace in Logcat.
+
+## How can I dig beyond the leak trace?
+
+Sometimes the leak trace isn't enough and you need to dig into a heap dump with [MAT](http://eclipse.org/mat/) or [YourKit](https://www.yourkit.com/).
+
+* Go to a heap analysis screen, click the overflow menu and select *Share Heap Dump*.
+
+Here's how you can find the leaking instance in the heap dump:
+
+1. Look for all instances of `leakcanary.KeyedWeakReference`.
+2. For each of these, look at the `key` field.
+3. Find the `KeyedWeakReference` that has a `key` field equal to the reference key reported by LeakCanary.
+4. The `referent` field of that `KeyedWeakReference` is your leaking object.
+5. From then on, the matter is in your hands. A good start is to look at the shortest path to GC Roots (excluding weak references).
+
+## How many methods does LeakCanary add?
+
+**0**. LeakCanary is a debug only library.
+
+## How do I use the SNAPSHOT version?
+
+Update your dependencies to the latest SNAPSHOT (see [build.gradle](https://github.com/square/leakcanary/blob/master/build.gradle)):
+
+```gradle
+ dependencies {
+   debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-4-SNAPSHOT'
+ }
+```
+
+Add Sonatype's `snapshots` repository:
+
+```
+  repositories {
+    mavenCentral()
+    maven {
+      url 'https://oss.sonatype.org/content/repositories/snapshots/'
+    }
+  }
+```
+
+Status of the snapshot build: [![Build Status](https://travis-ci.org/square/leakcanary.svg?branch=master)](https://travis-ci.org/square/leakcanary)
+
+## Who's behind LeakCanary?
+
+LeakCanary was created and open sourced by [@pyricau](https://github.com/pyricau), with [many contributions](https://github.com/square/leakcanary/graphs/contributors) from the community.
+
+## Why is it called LeakCanary?
+
+The name **LeakCanary** is a reference to the expression [canary in a coal mine](http://en.wiktionary.org/wiki/canary_in_a_coal_mine), because LeakCanary is a sentinel used to detect risks by providing advance warning of a danger. Props to [@edenman](https://github.com/edenman) for suggesting it!
+
+## Who made the logo?
+
+* [@pyricau](https://github.com/pyricau) quickly made the [first version](https://github.com/square/leakcanary/blob/f0cc04dfbf3cca92a669f0d250034d410eb05816/assets/icon_512.png) of the logo. It was based on cliparts from [Android Asset Studio](http://romannurik.github.io/AndroidAssetStudio/icons-generic.html), mixed with the selection from a photo of a Canary. The exclamation mark means danger, the shield stands for protection, and the bird, well, is a canary.
+* [@romainguy](https://github.com/romainguy) turned the ugly logo into [a nice vector asset](https://github.com/square/leakcanary/pull/36).
+* [@flickator](https://github.com/flickator) designed [a much nicer logo](https://github.com/square/leakcanary/pull/1269) for LeakCanary 2.0!
+
+<p align="center">
+<img src="https://github.com/square/leakcanary/wiki/assets/logo-2.0.png" />
+</p>
diff --git a/docs/fundamentals.md b/docs/fundamentals.md
new file mode 100644
index 00000000..8c76ccba
--- /dev/null
+++ b/docs/fundamentals.md
@@ -0,0 +1,225 @@
+# Fundamentals
+
+## What is a memory leak?
+
+In a Java based runtime, a memory leak is a programming error that causes an application to keep a reference to an object that is no longer needed. As a result, the memory allocated for that object cannot be reclaimed, eventually leading to an OutOfMemoryError crash.
+
+For example, an Android activity instance is no longer needed after its `onDestroy()` method is called, and storing a reference to that activity in a static field would prevent it from being garbage collected.
+
+## Common causes for memory leaks
+
+Most memory leaks are caused by bugs related to the lifecycle of objects. Here are a few common Android mistakes:
+
+* Storing an Activity context as a field in an object that survives activity recreation configuration changes.
+* Registering a listener, broadcast receiver or RxJava subscription which references an object with lifecycle, and forgetting to unregister when the lifecycle reaches its end.
+* Storing a view in a static field, and not clearing that field when the view is detached.
+
+## Why should I use LeakCanary?
+
+Memory leaks are very common in Android apps. OutOfMemoryError (OOM) is the top crash for most apps on the play store, however that's usually not counted correctly. When memory is low the OOM can be thrown from anywhere in your code, which means every OOM has a different stacktrace and they're counted as different crashes.
+
+When we first enabled LeakCanary in the Square Point Of Sale app, we were able to find and fix several leaks and reduced the OutOfMemoryError crash rate by **94%**.
+
+## How does LeakCanary work?
+
+### Detecting retained instances
+
+The foundation of LeakCanary is a library called LeakSentry. LeakSentry hooks into the Android lifecycle to automatically detect when activities and fragments are destroyed and should be garbage collected. These destroyed instances are passed to a `RefWatcher`, which holds weak references to them. You can also watch any instance that is no longer needed, e.g. a detached view, a destroyed presenter, etc.
+
+If the weak references aren't cleared after waiting 5 seconds and running the garbage collector, the watched instances are considered *retained*, and potentially leaking.
+
+### Dumping the heap
+
+When the number of retained instances reaches a threshold, LeakCanary dumps the Java heap into a `.hprof` file stored onto the Android file system. The default threshold is 5 retained instances when the app is visible, 1 otherwise.
+
+### Analyzing the heap
+
+LeakCanary parses the `.hprof` file and finds the chain of references that prevents retained instances from being garbage collected: the **leak trace**. Leak trace is another name for the *shortest strong reference path from garbage collection roots to retained instances*. Once the leak trace is determined, LeakCanary uses its built-in knowledge of the Android framework to deduct which instances in the leak trace are leaking (see below [How do I fix a memory leak?](#how-do-i-fix-a-memory-leak)).
+
+### Grouping leaks
+
+Using the leak status information, LeakCanary narrows down the reference chain to a sub chain of possible leak causes, and displays the result. Leaks that have the same causal chain are considered to be the same leak, so leaks are grouped by identical sub chain.
+
+## How do I fix a memory leak?
+
+For each leaking instance, LeakCanary computes a leak trace and displays it in its UI:
+
+![leak trace](images/leaktrace.png)
+
+The leak trace is also logged to Logcat:
+
+```
+    ┬
+    ├─ leakcanary.internal.InternalLeakCanary
+    │    Leaking: NO (it's a GC root and a class is never leaking)
+    │    ↓ static InternalLeakCanary.application
+    ├─ com.example.leakcanary.ExampleApplication
+    │    Leaking: NO (Application is a singleton)
+    │    ↓ ExampleApplication.leakedViews
+    │                         ~~~~~~~~~~~
+    ├─ java.util.ArrayList
+    │    Leaking: UNKNOWN
+    │    ↓ ArrayList.elementData
+    │                ~~~~~~~~~~~
+    ├─ java.lang.Object[]
+    │    Leaking: UNKNOWN
+    │    ↓ array Object[].[0]
+    │                     ~~~
+    ├─ android.widget.TextView
+    │    Leaking: YES (View detached and has parent)
+    │    View#mAttachInfo is null (view detached)
+    │    View#mParent is set
+    │    View.mWindowAttachCount=1
+    │    ↓ TextView.mContext
+    ╰→ com.example.leakcanary.MainActivity
+    ​     Leaking: YES (RefWatcher was watching this and MainActivity#mDestroyed
+is true)
+```
+
+### Objects and references
+
+```
+├─ android.widget.TextView
+```
+
+Each node in the leak trace is a Java object and is either a class, an object array or an instance.
+
+```
+│    ↓ TextView.mContext
+```
+
+Going down, each node has a reference to the next node. In the UI, that reference is in **<span style="color:#9976a8">purple</span>**. In the Logcat representation, the reference is on the line that starts with a down arrow.
+
+### GC Root
+
+```
+    ┬
+    ├─ leakcanary.internal.InternalLeakCanary
+    │    Leaking: NO (it's a GC root and a class is never leaking)
+```
+
+At the top of the leak trace is a garbage-collection (GC) root. GC roots are special objects that are always reachable. There are four kinds of GC roots worth mentioning:
+
+  * **Local variables**, which belong to the stack of a thread.
+  * Instances of **active Java threads**.
+  * **Classes**, which never unload on Android.
+  * **Native references**, which are controlled by native code.
+
+### Leaking instance
+
+```
+    ╰→ com.example.leakcanary.MainActivity
+    ​     Leaking: YES (RefWatcher was watching this and MainActivity#mDestroyed
+is true)
+```
+
+At the bottom of the leak trace is the leaking instance. This instance was passed to `RefWatcher.watch()` to confirm it would be garbage collected, and it ended up not being garbage collected which triggered LeakCanary.
+
+### Chain of references
+
+```
+...
+    │    ↓ static InternalLeakCanary.application
+...
+    │    ↓ ExampleApplication.leakedViews
+...
+    │    ↓ ArrayList.elementData
+...
+    │    ↓ array Object[].[0]
+...
+    │    ↓ TextView.mContext
+...
+```
+
+The chain of references from the GC root to the leaking instance is what is preventing the leaking instance from being garbage collected. If you can identify the reference that should not exist at that point in time, then you can figure out why it's incorrectly still set and then fix the memory leak.
+
+### Heuristics and labels
+
+```
+    ├─ android.widget.TextView
+    │    Leaking: YES (View detached and has parent)
+    │    View#mAttachInfo is null (view detached)
+    │    View#mParent is set
+    │    View.mWindowAttachCount=1
+```
+
+LeakCanary runs heuristics to determine the lifecycle state of the nodes of the leak trace, and therefore whether they are leaking or not. For example, if a view has `View#mAttachInfo = null` and `mParent != null` then it is detached yet has a parent, so that view is probably leaking. In the leak trace, for each node you'll see `Leaking: YES / NO / UNKNOWN` with an explanation in parenthesis. LeakCanary can also surface extra information about the state of a node, e.g. `View.mWindowAttachCount=1`. You can customize this behavior and add your own heuristics by updating `LeakCanary.Config.leakTraceInspectors`.
+
+### Narrowing down the cause of a leak
+
+```
+    ┬
+    ├─ leakcanary.internal.InternalLeakCanary
+    │    Leaking: NO (it's a GC root and a class is never leaking)
+    │    ↓ static InternalLeakCanary.application
+    ├─ com.example.leakcanary.ExampleApplication
+    │    Leaking: NO (Application is a singleton)
+    │    ↓ ExampleApplication.leakedViews
+    │                         ~~~~~~~~~~~
+    ├─ java.util.ArrayList
+    │    Leaking: UNKNOWN
+    │    ↓ ArrayList.elementData
+    │                ~~~~~~~~~~~
+    ├─ java.lang.Object[]
+    │    Leaking: UNKNOWN
+    │    ↓ array Object[].[0]
+    │                     ~~~
+    ├─ android.widget.TextView
+    │    Leaking: YES (View detached and has parent)
+    │    ↓ TextView.mContext
+    ╰→ com.example.leakcanary.MainActivity
+    ​     Leaking: YES (RefWatcher was watching this and MainActivity#mDestroyed is true)
+```
+
+If a node is not leaking, then any prior reference that points to it is not the source of the leak, and also not leaking. Similarly, if a node is leaking then any node down the leak trace is also leaking. From that, we can deduce that the leak is caused by a reference that is after the last `Leaking: NO`	and before the first `Leaking: YES`.
+
+LeakCanary highlights those references with a **<span style="text-decoration: underline; text-decoration-color: red; text-decoration-style: wavy;">red underline</span>** in the UI, or a **~~~~** underline in the Logcat representation. These highlighted references are the **only possible causes of the leak**. These are the references you should spend time investigating.
+
+In this example, the last `Leaking: NO` is on `com.example.leakcanary.ExampleApplication` and the first `Leaking: YES` is on `android.widget.TextView`, so the leak is caused by one of the 3 references in between:
+
+```
+...
+    │    ↓ ExampleApplication.leakedViews
+    │                         ~~~~~~~~~~~
+...
+    │    ↓ ArrayList.elementData
+    │                ~~~~~~~~~~~
+...
+    │    ↓ array Object[].[0]
+    │                     ~~~
+...
+```
+
+Looking at the [source](https://github.com/square/leakcanary/blob/master/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt#L23), we can see that `ExampleApplication` has a list field:
+
+```
+open class ExampleApplication : Application() {
+  val leakedViews = mutableListOf<View>()
+}
+```
+
+It's unlikely that there's a bug in the `ArrayList` implementation itself, so the leak happens because we're adding views to `ExampleApplication.leakedViews`. If we stop doing that, we've fixed the leak!
+
+### Asking for help with a leak
+
+If you cannot figure out a leak, **please do not file an issue**. Instead, create a [Stack Overflow question](http://stackoverflow.com/questions/tagged/leakcanary?sort=active) using the *leakcanary* tag.
+
+## LeakCanary artifacts
+
+LeakCanary is released as several distinct libraries:
+
+* LeakSentry
+    * Detects retained instances.
+    * Suitable for release builds.
+    * Artifact id: `com.squareup.leakcanary:leaksentry`.
+* LeakCanary
+    * Dumps the heap and analyzes it.
+    * Currently only suitable for debug builds.
+    * Depends on LeakSentry.
+    * Artifact id: `com.squareup.leakcanary:leakcanary-android`.
+* LeakCanary for Instrumentation tests
+    * Fails tests if a leak is detected.
+    * Only suitable for Instrumentation tests.
+    * Configures LeakCanary to wait for the end of tests before dumping the heap.
+    * Artifact id: `com.squareup.leakcanary:leakcanary-android-instrumentation`.
+    * See [Running LeakCanary in instrumentation tests](recipes.md#running-leakcanary-in-instrumentation-tests).
diff --git a/docs/getting_started.md b/docs/getting_started.md
new file mode 100644
index 00000000..2172d3c5
--- /dev/null
+++ b/docs/getting_started.md
@@ -0,0 +1,18 @@
+# Getting started
+
+Add LeakCanary to `build.gradle`:
+
+```groovy
+dependencies {
+  // debugImplementation because LeakCanary should only run in debug builds.
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-3'
+}
+```
+
+**That's it, there is no code change needed!** LeakCanary will automatically show a notification when a memory leak is detected in debug builds.
+
+What's next?
+
+* Learn the [Fundamentals](fundamentals.md)
+* Try the [code recipes](recipes.md)
+* Read the [FAQ](faq.md)
diff --git a/docs/images/leaktrace.png b/docs/images/leaktrace.png
new file mode 100644
index 00000000..dfbe6a02
Binary files /dev/null and b/docs/images/leaktrace.png differ
diff --git a/docs/images/logo.png b/docs/images/logo.png
new file mode 100644
index 00000000..1c33a1de
Binary files /dev/null and b/docs/images/logo.png differ
diff --git a/docs/index.md b/docs/index.md
new file mode 100644
index 00000000..d35383bf
--- /dev/null
+++ b/docs/index.md
@@ -0,0 +1,16 @@
+# LeakCanary 🐤
+
+LeakCanary is a memory leak detection library for Android.
+
+<p align="center">
+<img src="https://github.com/square/leakcanary/wiki/assets/screenshot-2.0.png"/>
+</p>
+
+LeakCanary's knowledge of the internals of the Android Framework gives it a unique ability to narrow down the cause of each leak, helping developers dramatically reduce OutOfMemoryError crashes.
+
+[Get started!](getting_started.md)
+
+
+!!! quote
+    *“A small leak will sink a great ship.”* - Benjamin Franklin
+
diff --git a/docs/recipes.md b/docs/recipes.md
new file mode 100644
index 00000000..2c31ea67
--- /dev/null
+++ b/docs/recipes.md
@@ -0,0 +1,197 @@
+# Code Recipes
+
+If you think a recipe might be missing or you're not sure that what you're trying to achieve is possible with the current APIs, please [file an issue](https://github.com/square/leakcanary/issues/new/choose). Your feedback help us make LeakCanary better for the entire community.
+
+## Configuring LeakSentry
+
+LeakSentry can be configured by replacing `LeakSentry.config`:
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakSentry.config = LeakSentry.config.copy(watchFragmentViews = false)
+  }
+}
+```
+
+## Configuring LeakCanary
+
+LeakCanary can be configured by replacing `LeakCanary.config`:
+
+```kotlin
+disableLeakCanaryButton.setOnClickListener {
+  LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
+}
+```
+
+## Watching objects with a lifecycle
+
+In your application, you may have other objects with a lifecycle, such as fragments, services, Dagger components, etc. Use `LeakSentry.refWatcher` to watch instances that should be garbage collected:
+
+```kotlin
+class MyService : Service {
+
+  // ...
+
+  override fun onDestroy() {
+    super.onDestroy()
+    LeakSentry.refWatcher.watch(this)
+  }
+}
+```
+
+## Counting retained instances in production
+
+`com.squareup.leakcanary:leakcanary-android` should only be used in debug builds. It depends on `com.squareup.leakcanary:leaksentry` which you can use in production to track and count retained instances.
+
+In your `build.gradle`:
+
+```gradle
+dependencies {
+  implementation 'com.squareup.leakcanary:leaksentry:2.0-alpha-2'
+}
+```
+
+In your leak reporting code:
+```kotlin
+val retainedInstanceCount = LeakSentry.refWatcher.retainedKeys.size
+```
+
+## Running LeakCanary in instrumentation tests
+
+Add the `leakcanary-android-instrumentation` dependency to your instrumentation tests:
+
+```
+androidTestImplementation "com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion}"
+```
+
+Add the dedicated run listener to `defaultConfig` in your `build.gradle`:
+
+```
+android {
+  defaultConfig {
+    // ...
+
+    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    testInstrumentationRunnerArgument "listener", "leakcanary.FailTestOnLeakRunListener"
+  }
+}
+```
+
+Run the instrumentation tests:
+
+```
+./gradlew leakcanary-sample:connectedCheck
+```
+
+You can extend `FailTestOnLeakRunListener` to customize the behavior.
+
+## Icon and label
+
+The activity that displays leaks comes with a default icon and label, which you can change by providing `R.mipmap.leak_canary_icon` and `R.string.leak_canary_display_activity_label` in your app:
+
+```
+res/
+  mipmap-hdpi/
+    leak_canary_icon.png
+  mipmap-mdpi/
+    leak_canary_icon.png
+  mipmap-xhdpi/
+    leak_canary_icon.png
+  mipmap-xxhdpi/
+    leak_canary_icon.png
+  mipmap-xxxhdpi/
+    leak_canary_icon.png
+   mipmap-anydpi-v26/
+     leak_canary_icon.xml
+```
+
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <string name="leak_canary_display_activity_label">MyLeaks</string>
+</resources>
+```
+
+## Uploading to a server
+
+You can change the default behavior to upload the analysis result to a server of your choosing.
+
+Create a custom `AnalysisResultListener` that delegates to the default: 
+
+```kotlin
+class LeakUploader : AnalysisResultListener {
+  override fun invoke(
+    application: Application,
+    heapAnalysis: HeapAnalysis
+  ) {
+    TODO("Upload heap analysis to server")
+
+    // Delegate to default behavior (notification and saving result)
+    DefaultAnalysisResultListener(application, heapAnalysis)
+  }
+}
+```
+
+Set `analysisResultListener` on the LeakCanary config:
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakCanary.config = LeakCanary.config.copy(analysisResultListener = LeakUploader())
+  }
+}
+```
+
+
+## Identifying 3rd party leaks as "won't fix"
+
+Set `exclusionsFactory` on the LeakCanary config to a `ExclusionsFactory` that delegates to the default one and then and add custom exclusions:
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakCanary.config = LeakCanary.config.copy(exclusionsFactory = { hprofParser ->
+      val defaultFactory = AndroidExcludedRefs.exclusionsFactory(AndroidExcludedRefs.appDefaults)
+      val appDefaults = defaultFactory(hprofParser)
+      val customExclusion = Exclusion(
+          type = StaticFieldExclusion("com.thirdparty.SomeSingleton", "sContext"),
+          status = Exclusion.Status.WONT_FIX_LEAK,
+          reason = "SomeSingleton in library X has a static field leaking a context."
+      )
+      appDefaults + customExclusion
+    })
+  }
+}
+```
+
+## Identifying leaking instances and labeling instances
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    val customLabeler: Labeler = { parser, node ->
+      listOf("Heap dump object id is ${node.instance}")
+    }
+    val labelers = AndroidLabelers.defaultAndroidLabelers(this) + customLabeler
+
+    val customInspector: LeakInspector = { parser, node ->
+      with(parser) {
+        if (node.instance.objectRecord.isInstanceOf("com.example.MySingleton")) {
+          LeakNodeStatus.notLeaking("MySingleton is a singleton")
+        } else LeakNodeStatus.unknown()
+      }
+    }
+    val leakInspectors = AndroidLeakInspectors.defaultAndroidInspectors() + customInspector
+
+    LeakCanary.config = LeakCanary.config.copy(labelers = labelers, leakInspectors = leakInspectors)
+  }
+}
+```
\ No newline at end of file
diff --git a/docs/recorded-presentations.md b/docs/recorded-presentations.md
new file mode 100644
index 00000000..4e97c309
--- /dev/null
+++ b/docs/recorded-presentations.md
@@ -0,0 +1,7 @@
+* [LeakCanary 2: Leaner, Better, Faster, Kotliner!](https://www.youtube.com/watch?v=LEX8dn4BLUw)
+* [LeakCanary, then what? Nuking Nasty Memory Leaks](https://www.youtube.com/watch?v=fhE--eTEW84)
+* [Memory Leak Hunt](https://www.youtube.com/watch?v=KwArTJHLq5g), a live investigation.
+* [Installing LeakCanary](https://caster.io/lessons/installing-leakcanary) (LeakCanary 1.5)
+* [How to use LeakCanary](https://www.youtube.com/watch?v=qtrZVPGdDkU)
+
+Your presentation should be here, please update this list! Any technical level welcome.
\ No newline at end of file
diff --git a/docs/support.md b/docs/support.md
new file mode 100644
index 00000000..e8527600
--- /dev/null
+++ b/docs/support.md
@@ -0,0 +1,14 @@
+# LeakCanary Support
+
+If you're looking for support for LeakCanary:
+
+* Learn the [Fundamentals](fundamentals.md)
+* Try the [code recipes](recipes.md)
+* Read the [FAQ](https://square.github.io/leakcanary/faq/)
+* Watch [recorded presentations](recorded-presentations.md)
+* Read [blog articles](blog-articles.md)
+* Check out the StackOverflow [LeakCanary tag](http://stackoverflow.com/questions/tagged/leakcanary?sort=active) and ask a question
+
+Feel free to edit this file to add links to online communities that can help developers investigate LeakCanary leaks.
+
+
diff --git a/docs/upgrading-to-leakcanary-2.0.md b/docs/upgrading-to-leakcanary-2.0.md
new file mode 100644
index 00000000..480b6745
--- /dev/null
+++ b/docs/upgrading-to-leakcanary-2.0.md
@@ -0,0 +1,286 @@
+## Dependencies
+
+### Before
+
+```groovy
+dependencies {
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.3'
+  releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.3'
+  // Optional, if you use support library fragments:
+  debugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.3'
+}
+```
+
+### Now
+
+```groovy
+dependencies {
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-2'
+}
+```
+
+### Worth noting
+
+* The `leakcanary-android-no-op` artifact is gone. If you have compile errors, see below.
+  * **Question**: if there's no no-op anymore, how do I ensure none of this runs during release builds?
+  * **Answer**: as long as you add `leakcanary-android` as `debugImplementation`, there won't be any code referencing LeakCanary in your release builds.
+* LeakCanary now **depends on AndroidX** instead of the support library.
+* Detection of AndroidX fragments is now automatic if you have the AndroidX fragments dependency.
+
+## Default setup code
+
+### Before
+
+```java
+public class ExampleApplication extends Application {
+
+  @Override public void onCreate() {
+    super.onCreate();
+    if (LeakCanary.isInAnalyzerProcess(this)) {
+      // This process is dedicated to LeakCanary for heap analysis.
+      // You should not init your app in this process.
+      return;
+    }
+    LeakCanary.install(this);
+    // Normal app init code...
+  }
+}
+```
+
+### Now
+
+There is no more code for default setup.
+
+### Worth noting
+
+* LeakCanary auto installs itself
+* LeakCanary analysis now runs in the main process so there is no need to call `LeakCanary.isInAnalyzerProcess()`.
+
+## Retrieve the RefWatcher
+
+### Before
+
+```kotlin
+val refWatcher = LeakCanary.installedRefWatcher()
+```
+
+### Now
+
+```kotlin
+val refWatcher = LeakSentry.refWatcher
+```
+
+## Compile errors because RefWatcher is used in release code
+
+If you were using `RefWatcher` in non debug code, you now get a compile error because the no-op artifact is gone. `RefWatcher` now lives in the `leaksentry` artifact, which is suitable for production. You have two options:
+
+### Option 1: Add `leaksentry` to release builds.
+
+```groovy
+dependencies {
+  implementation 'com.squareup.leakcanary:leaksentry:2.0-alpha-2'
+}
+```
+
+* It will automatically keep weak references on activities, fragments, and any instance you pass to `RefWatcher`.
+* It will not trigger heap dumps or anything else that LeakCanary does.
+* It's very little code and should have a no impact on your release app.
+* You can use it to count how many instances are retained, for instance to add metadata to OutOfMemoryError crashes:
+
+```kotlin
+val retainedInstanceCount = LeakSentry.refWatcher.retainedInstanceCount
+```
+
+### Option 2: Make your own `RefWatcher` interface
+
+```kotlin
+// In shared code
+interface MaybeRefWatcher {
+  fun watch(watchedInstance: Any)
+
+  object None : MaybeRefWatcher {
+    override fun watch(watchedInstance: Any) {
+    }
+  }
+}
+
+// In debug code
+class RealRefWatcher : MaybeRefWatcher {
+  override fun watch(watchedInstance: Any) {
+    LeakSentry.refWatcher.watch(watchedInstance)
+  }
+}
+```
+
+Use MaybeRefWatcher.None in release code and RealRefWatcher in debug code.
+
+## Configuring LeakCanary
+
+### Before
+
+```java
+public class DebugExampleApplication extends ExampleApplication {
+
+  @Override protected void installLeakCanary() {
+    RefWatcher refWatcher = LeakCanary.refWatcher(this)
+      .watchActivities(false)
+      .buildAndInstall();
+  }
+}
+```
+
+### Now
+
+LeakSentry is in charge of detecting memory leaks. Its configuration can be updated at any time by replacing `LeakSentry.config`:
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakSentry.config = LeakSentry.config.copy(watchFragmentViews = false)
+  }
+}
+```
+
+LeakCanary is in charge of taking heap dumps and analyzing them. Its configuration can be updated at any time by replacing `LeakCanary.config`:
+
+```kotlin
+disableLeakCanaryButton.setOnClickListener {
+  LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
+}
+```
+
+## Running LeakCanary in instrumentation tests
+
+### Before
+
+In your `build.gradle` file:
+
+```groovy
+dependencies {
+  androidTestImplementation "com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion}"
+}
+
+android {
+  defaultConfig {
+    // ...
+
+    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    testInstrumentationRunnerArgument "listener", "com.squareup.leakcanary.FailTestOnLeakRunListener"
+  }
+}
+```
+
+In your test `Application` class:
+
+```java
+public class InstrumentationTestExampleApplication extends DebugExampleApplication {
+  @Override protected void installLeakCanary() {
+    InstrumentationLeakDetector.instrumentationRefWatcher(this)
+      .buildAndInstall();
+  }
+}
+```
+
+### Now
+
+In your `build.gradle` file:
+
+```groovy
+dependencies {
+  androidTestImplementation "com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion}"
+}
+
+android {
+  defaultConfig {
+    // ...
+
+    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    testInstrumentationRunnerArgument "listener", "leakcanary.FailTestOnLeakRunListener"
+  }
+}
+```
+
+No code is necessary.
+
+## Analysis listener / uploading to a server
+
+### Before
+
+
+```java
+public class LeakUploadService extends DisplayLeakService {
+  @Override protected void afterDefaultHandling(HeapDump heapDump, AnalysisResult result, String leakInfo) {
+    // TODO Upload result to server
+  }
+}
+```
+
+```java
+RefWatcher refWatcher = LeakCanary.refWatcher(this)
+  .listenerServiceClass(LeakUploadService.class);
+  .buildAndInstall();
+```
+
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    >
+  <application android:name="com.example.DebugExampleApplication">
+    <service android:name="com.example.LeakUploadService" />
+  </application>
+</manifest>
+```
+
+### Now
+
+```Kotlin
+LeakCanary.config = LeakCanary.config.copy(
+    analysisResultListener = { application, heapAnalysis ->
+      // TODO Upload result to server
+      DefaultAnalysisResultListener(application, heapAnalysis)
+    }
+)
+```
+
+### Marking known framework leaks as won't fix
+
+### Before
+
+```java
+ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults()
+    .instanceField("com.example.ExampleClass", "exampleField")
+    .build();
+RefWatcher refWatcher = LeakCanary.refWatcher(this)
+  .excludedRefs(excludedRefs)
+  .buildAndInstall();
+}
+```
+
+### Now
+
+```kotlin
+LeakCanary.config = LeakCanary.config.copy(
+  exclusionsFactory = { parser ->
+    val build = BuildMirror.readFromHprof(parser)
+    val exclusions =
+      AndroidExcludedRefs.exclusionsMatchingBuild(AndroidExcludedRefs.appDefaults, build)
+          .toMutableList()
+    exclusions += Exclusion(
+        type = InstanceFieldExclusion("com.example.ExampleClass", "exampleField")
+    )
+    exclusions
+  }
+)
+```
+
+## Public API packages
+
+### Before
+
+All public APIs were in `com.squareup.leakcanary.*`
+
+### Now
+
+All public APIs are in `leakcanary.*`
\ No newline at end of file
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 00000000..176c24f4
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,18 @@
+GROUP=com.squareup.leakcanary
+VERSION_NAME=2.0-alpha-4-SNAPSHOT
+
+POM_DESCRIPTION=Leak Canary
+
+POM_URL=http://github.com/square/leakcanary/
+POM_SCM_URL=http://github.com/square/leakcanary/
+POM_SCM_CONNECTION=scm:git:https://github.com/square/leakcanary.git
+POM_SCM_DEV_CONNECTION=scm:git:git@github.com:square/leakcanary.git
+
+POM_LICENCE_NAME=The Apache Software License, Version 2.0
+POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
+POM_LICENCE_DIST=repo
+
+POM_DEVELOPER_ID=square
+POM_DEVELOPER_NAME=Square, Inc.
+
+android.useAndroidX=true
diff --git a/gradle/checkstyle.gradle b/gradle/checkstyle.gradle
index 2e7c512c..afc5281a 100644
--- a/gradle/checkstyle.gradle
+++ b/gradle/checkstyle.gradle
@@ -2,17 +2,22 @@ apply plugin: 'checkstyle'
 
 checkstyle {
   configFile rootProject.file('checkstyle.xml')
+  ignoreFailures false
   showViolations true
 }
 
-android.libraryVariants.all { variant ->
-  def name = variant.buildType.name
+task checkstyle(type: Checkstyle) {
+  configFile rootProject.file('checkstyle.xml')
+  source 'src/main/java'
+  ignoreFailures false
+  showViolations true
+  include '**/*.java'
+
+  classpath = files()
+}
 
-  def checkstyle = project.tasks.create "checkstyle${name.capitalize()}", Checkstyle
-  checkstyle.dependsOn variant.javaCompile
-  checkstyle.source variant.javaCompile.source
-  checkstyle.classpath = project.fileTree(variant.javaCompile.destinationDir)
-  checkstyle.exclude('**/BuildConfig.java')
-  checkstyle.exclude('**/R.java')
-  project.tasks.getByName("check").dependsOn checkstyle
+afterEvaluate {
+  if (project.tasks.getByName("check")) {
+    check.dependsOn('checkstyle')
+  }
 }
\ No newline at end of file
diff --git a/gradle/gradle-mvn-push.gradle b/gradle/gradle-mvn-push.gradle
index 32763c86..ec8721e4 100644
--- a/gradle/gradle-mvn-push.gradle
+++ b/gradle/gradle-mvn-push.gradle
@@ -77,32 +77,61 @@ afterEvaluate { project ->
         sign configurations.archives
     }
 
-    task androidJavadocs(type: Javadoc) {
+    def plugins = project.getPlugins()
+    if (plugins.hasPlugin('com.android.application') || plugins.hasPlugin('com.android.library')) {
+      task androidJavadocs(type: Javadoc) {
         source = android.sourceSets.main.java.srcDirs
-        ext.androidJar = "${android.sdkDirectory}/platforms/${android.compileSdkVersion}/android.jar"
-        classpath += files(ext.androidJar)
-    }
+        // TODO Update to include KT files OR stop publishing javadoc artifacts.
+        exclude "**/*.kt"
+        exclude "**/internal/**"
+        classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+
+        // Append also the classpath and files for release library variants.
+        // This fixes the javadoc warnings.
+        // Copy pasta from https://github.com/novoda/bintray-release/pull/39/files
+        def releaseVariant = project.android.libraryVariants.find { it.name.endsWith("release") }
+
+        classpath += releaseVariant.javaCompile.classpath
+        classpath += releaseVariant.javaCompile.outputs.files
+      }
 
-    task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
+      task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
         classifier = 'javadoc'
         from androidJavadocs.destinationDir
-    }
+      }
 
-    task androidSourcesJar(type: Jar) {
+      task androidSourcesJar(type: Jar) {
         classifier = 'sources'
         from android.sourceSets.main.java.sourceFiles
+      }
+
+      artifacts {
+        archives androidSourcesJar
+        archives androidJavadocsJar
+      }
     }
+    else {
+      task sourcesJar(type: Jar, dependsOn: classes) {
+        classifier = 'sources'
+        from sourceSets.main.allSource
+      }
 
-    if (JavaVersion.current().isJava8Compatible()) {
-        allprojects {
-            tasks.withType(Javadoc) {
-                options.addStringOption('Xdoclint:none', '-quiet')
-            }
-        }
+      task javadocsJar(type: Jar, dependsOn: javadoc) {
+        classifier = 'javadoc'
+        from javadoc.destinationDir
+      }
+
+      artifacts {
+        archives sourcesJar
+        archives javadocsJar
+      }
     }
 
-    artifacts {
-        archives androidSourcesJar
-        archives androidJavadocsJar
+    if (JavaVersion.current().isJava8Compatible()) {
+      allprojects {
+        tasks.withType(Javadoc) {
+          options.addStringOption('Xdoclint:none', '-quiet')
+        }
+      }
     }
 }
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 58385981..5c2d1cf0 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 63b80488..ee69dd68 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Wed Feb 04 10:58:17 PST 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-5.4.1-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
diff --git a/gradlew b/gradlew
index 91a7e269..b0d6d0ab 100755
--- a/gradlew
+++ b/gradlew
@@ -1,4 +1,20 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
+
+#
+# Copyright 2015 the original author or authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
 
 ##############################################################################
 ##
@@ -6,20 +22,38 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -30,6 +64,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,31 +75,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -90,7 +105,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
@@ -114,6 +129,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
@@ -154,11 +170,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+exec "$JAVACMD" "$@"
diff --git a/leakcanary-analyzer/build.gradle b/leakcanary-analyzer/build.gradle
index 60e6bc79..cf4d3a4a 100644
--- a/leakcanary-analyzer/build.gradle
+++ b/leakcanary-analyzer/build.gradle
@@ -1,59 +1,20 @@
-version rootProject.ext.VERSION_NAME
-group rootProject.ext.GROUP
+apply plugin: 'java-library'
+apply plugin: 'kotlin'
 
-buildscript {
-  repositories {
-    mavenCentral()
-  }
-}
-
-apply plugin: 'com.android.library'
-
-repositories {
-  mavenCentral()
-}
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
 
 dependencies {
-  compile 'com.squareup.haha:haha:2.0.2'
-  compile project(':leakcanary-watcher')
-  testCompile 'junit:junit:4.12'
-  testCompile 'org.assertj:assertj-core:1.7.0'
-}
-
-android.libraryVariants.all { variant ->
-  def name = variant.buildType.name
-  if (name.equals(com.android.builder.core.BuilderConstants.DEBUG)) {
-    return; // Skip debug builds.
-  }
-  def task = project.tasks.create "jar${name.capitalize()}", Jar
-  task.dependsOn variant.javaCompile
-  task.from variant.javaCompile.destinationDir
-  artifacts.add('archives', task);
-}
+  api project(':leakcanary-watcher')
+  api project(':leakcanary-haha')
 
+  implementation deps.androidx.annotation
+  implementation deps.kotlin.stdlib
 
-// See: https://code.google.com/p/android/issues/detail?id=64887#c13
-task copyTestResources(type: Copy) {
-  from "${projectDir}/src/test/resources"
-  into "${buildDir}/classes/test"
-}
-
-afterEvaluate { project ->
-  testDebugUnitTest.dependsOn copyTestResources
-}
-
-android {
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
-  defaultConfig {
-    minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.targetSdkVersion
-  }
-}
-
-task sourceJar(type: Jar) {
-  from 'src/main/java'
+  testImplementation deps.assertj_core
+  testImplementation deps.junit
+  testImplementation deps.okio
 }
 
 apply from: rootProject.file('gradle/checkstyle.gradle')
-apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/leakcanary-analyzer/gradle.properties b/leakcanary-analyzer/gradle.properties
index 9ef04082..ed79fc10 100644
--- a/leakcanary-analyzer/gradle.properties
+++ b/leakcanary-analyzer/gradle.properties
@@ -1,3 +1,3 @@
 POM_ARTIFACT_ID=leakcanary-analyzer
 POM_NAME=LeakCanary Analyzer
-POM_PACKAGING=jar
\ No newline at end of file
+POM_PACKAGING=jar
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java b/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java
deleted file mode 100644
index 227bcb59..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.haha.perflib;
-
-public final class HahaSpy {
-
-  public static Instance allocatingThread(Instance instance) {
-    Snapshot snapshot = instance.mHeap.mSnapshot;
-    int threadSerialNumber;
-    if (instance instanceof RootObj) {
-      threadSerialNumber = ((RootObj) instance).mThread;
-    } else {
-      threadSerialNumber = instance.mStack.mThreadSerialNumber;
-    }
-    ThreadObj thread = snapshot.getThread(threadSerialNumber);
-    return snapshot.findInstance(thread.mId);
-  }
-
-  private HahaSpy() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
deleted file mode 100644
index 4c8270c1..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.Serializable;
-
-public final class AnalysisResult implements Serializable {
-
-  public static AnalysisResult noLeak(long analysisDurationMs) {
-    return new AnalysisResult(false, false, null, null, null, 0, analysisDurationMs);
-  }
-
-  public static AnalysisResult leakDetected(boolean excludedLeak, String className,
-      LeakTrace leakTrace, long retainedHeapSize, long analysisDurationMs) {
-    return new AnalysisResult(true, excludedLeak, className, leakTrace, null, retainedHeapSize,
-        analysisDurationMs);
-  }
-
-  public static AnalysisResult failure(Throwable failure, long analysisDurationMs) {
-    return new AnalysisResult(false, false, null, null, failure, 0, analysisDurationMs);
-  }
-
-  /** True if a leak was found in the heap dump. */
-  public final boolean leakFound;
-
-  /**
-   * True if {@link #leakFound} is true and the only path to the leaking reference is
-   * through excluded references. Usually, that means you can safely ignore this report.
-   */
-  public final boolean excludedLeak;
-
-  /**
-   * Class name of the object that leaked if {@link #leakFound} is true, null otherwise.
-   * The class name format is the same as what would be returned by {@link Class#getName()}.
-   */
-  public final String className;
-
-  /**
-   * Shortest path to GC roots for the leaking object if {@link #leakFound} is true, null
-   * otherwise. This can be used as a unique signature for the leak.
-   */
-  public final LeakTrace leakTrace;
-
-  /** Null unless the analysis failed. */
-  public final Throwable failure;
-
-  /**
-   * The number of bytes which would be freed if all references to the leaking object were
-   * released. 0 if {@link #leakFound} is false.
-   */
-  public final long retainedHeapSize;
-
-  /** Total time spent analyzing the heap. */
-  public final long analysisDurationMs;
-
-  private AnalysisResult(boolean leakFound, boolean excludedLeak, String className,
-      LeakTrace leakTrace, Throwable failure, long retainedHeapSize, long analysisDurationMs) {
-    this.leakFound = leakFound;
-    this.excludedLeak = excludedLeak;
-    this.className = className;
-    this.leakTrace = leakTrace;
-    this.failure = failure;
-    this.retainedHeapSize = retainedHeapSize;
-    this.analysisDurationMs = analysisDurationMs;
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
deleted file mode 100644
index fe01cd23..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.ArrayInstance;
-import com.squareup.haha.perflib.ClassInstance;
-import com.squareup.haha.perflib.ClassObj;
-import com.squareup.haha.perflib.Field;
-import com.squareup.haha.perflib.Heap;
-import com.squareup.haha.perflib.Instance;
-import com.squareup.haha.perflib.Type;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-import static java.util.Arrays.asList;
-
-public final class HahaHelper {
-
-  private static final Set<String> WRAPPER_TYPES = new HashSet<>(
-      asList(Boolean.class.getName(), Character.class.getName(), Float.class.getName(),
-          Double.class.getName(), Byte.class.getName(), Short.class.getName(),
-          Integer.class.getName(), Long.class.getName()));
-
-  static String fieldToString(Map.Entry<Field, Object> entry) {
-    return fieldToString(entry.getKey(), entry.getValue());
-  }
-
-  static String fieldToString(ClassInstance.FieldValue fieldValue) {
-    return fieldToString(fieldValue.getField(), fieldValue.getValue());
-  }
-
-  static String fieldToString(Field field, Object value) {
-    return field.getName() + " = " + value;
-  }
-
-  static String threadName(Instance holder) {
-    List<ClassInstance.FieldValue> values = classInstanceValues(holder);
-    Object nameField = fieldValue(values, "name");
-    if (nameField == null) {
-      // Sometimes we can't find the String at the expected memory address in the heap dump.
-      // See https://github.com/square/leakcanary/issues/417 .
-      return "Thread name not available";
-    }
-    return asString(nameField);
-  }
-
-  static boolean extendsThread(ClassObj clazz) {
-    boolean extendsThread = false;
-    ClassObj parentClass = clazz;
-    while (parentClass.getSuperClassObj() != null) {
-      if (clazz.getClassName().equals(Thread.class.getName())) {
-        extendsThread = true;
-        break;
-      }
-      parentClass = parentClass.getSuperClassObj();
-    }
-    return extendsThread;
-  }
-
-  static String asString(Object stringObject) {
-    Instance instance = (Instance) stringObject;
-    List<ClassInstance.FieldValue> values = classInstanceValues(instance);
-
-    Integer count = fieldValue(values, "count");
-    Object value = fieldValue(values, "value");
-    Integer offset;
-    ArrayInstance charArray;
-    if (isCharArray(value)) {
-      charArray = (ArrayInstance) value;
-      offset = 0;
-      // < API 23
-      // As of Marshmallow, substrings no longer share their parent strings' char arrays
-      // eliminating the need for String.offset
-      // https://android-review.googlesource.com/#/c/83611/
-      if (hasField(values, "offset")) {
-        offset = fieldValue(values, "offset");
-      }
-    } else {
-      // In M preview 2, the underlying char buffer resides in the heap with ID equaling the
-      // String's ID + 16.
-      // https://android-review.googlesource.com/#/c/160380/2/android/src/com/android/tools/idea/
-      // editors/hprof/descriptors/InstanceFieldDescriptorImpl.java
-      // This workaround is only needed for M preview 2, as it has been fixed on the hprof
-      // generation end by reintroducing a virtual "value" variable.
-      // https://android.googlesource.com/platform/art/+/master/runtime/hprof/hprof.cc#1242
-      Heap heap = instance.getHeap();
-      Instance inlineInstance = heap.getInstance(instance.getId() + 16);
-      if (isCharArray(inlineInstance)) {
-        charArray = (ArrayInstance) inlineInstance;
-        offset = 0;
-      } else {
-        throw new UnsupportedOperationException("Could not find char array in " + instance);
-      }
-    }
-    checkNotNull(count, "count");
-    checkNotNull(charArray, "charArray");
-    checkNotNull(offset, "offset");
-
-    if (count == 0) {
-      return "";
-    }
-
-    char[] chars = charArray.asCharArray(offset, count);
-
-    return new String(chars);
-  }
-
-  public static boolean isPrimitiveWrapper(Object value) {
-    if (!(value instanceof ClassInstance)) {
-      return false;
-    }
-    return WRAPPER_TYPES.contains(((ClassInstance) value).getClassObj().getClassName());
-  }
-
-  public static boolean isPrimitiveOrWrapperArray(Object value) {
-    if (!(value instanceof ArrayInstance)) {
-      return false;
-    }
-    ArrayInstance arrayInstance = (ArrayInstance) value;
-    if (arrayInstance.getArrayType() != Type.OBJECT) {
-      return true;
-    }
-    return WRAPPER_TYPES.contains(arrayInstance.getClassObj().getClassName());
-  }
-
-  private static boolean isCharArray(Object value) {
-    return value instanceof ArrayInstance && ((ArrayInstance) value).getArrayType() == Type.CHAR;
-  }
-
-  static List<ClassInstance.FieldValue> classInstanceValues(Instance instance) {
-    ClassInstance classInstance = (ClassInstance) instance;
-    return classInstance.getValues();
-  }
-
-  static <T> T fieldValue(List<ClassInstance.FieldValue> values, String fieldName) {
-    for (ClassInstance.FieldValue fieldValue : values) {
-      if (fieldValue.getField().getName().equals(fieldName)) {
-        //noinspection unchecked
-        return (T) fieldValue.getValue();
-      }
-    }
-    throw new IllegalArgumentException("Field " + fieldName + " does not exists");
-  }
-
-  static boolean hasField(List<ClassInstance.FieldValue> values, String fieldName) {
-    for (ClassInstance.FieldValue fieldValue : values) {
-      if (fieldValue.getField().getName().equals(fieldName)) {
-        //noinspection unchecked
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private HahaHelper() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
deleted file mode 100644
index 3b1effb6..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ /dev/null
@@ -1,322 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.ArrayInstance;
-import com.squareup.haha.perflib.ClassInstance;
-import com.squareup.haha.perflib.ClassObj;
-import com.squareup.haha.perflib.Field;
-import com.squareup.haha.perflib.HprofParser;
-import com.squareup.haha.perflib.Instance;
-import com.squareup.haha.perflib.RootObj;
-import com.squareup.haha.perflib.RootType;
-import com.squareup.haha.perflib.Snapshot;
-import com.squareup.haha.perflib.Type;
-import com.squareup.haha.perflib.io.HprofBuffer;
-import com.squareup.haha.perflib.io.MemoryMappedFileBuffer;
-import com.squareup.haha.trove.THashMap;
-import com.squareup.haha.trove.TObjectProcedure;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-
-import static com.squareup.leakcanary.AnalysisResult.failure;
-import static com.squareup.leakcanary.AnalysisResult.leakDetected;
-import static com.squareup.leakcanary.AnalysisResult.noLeak;
-import static com.squareup.leakcanary.HahaHelper.asString;
-import static com.squareup.leakcanary.HahaHelper.classInstanceValues;
-import static com.squareup.leakcanary.HahaHelper.extendsThread;
-import static com.squareup.leakcanary.HahaHelper.fieldToString;
-import static com.squareup.leakcanary.HahaHelper.fieldValue;
-import static com.squareup.leakcanary.HahaHelper.threadName;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.OBJECT;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-
-/**
- * Analyzes heap dumps generated by a {@link RefWatcher} to verify if suspected leaks are real.
- */
-public final class HeapAnalyzer {
-
-  private static final String ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$";
-
-  private final ExcludedRefs excludedRefs;
-
-  public HeapAnalyzer(ExcludedRefs excludedRefs) {
-    this.excludedRefs = excludedRefs;
-  }
-
-  /**
-   * Searches the heap dump for a {@link KeyedWeakReference} instance with the corresponding key,
-   * and then computes the shortest strong reference path from that instance to the GC roots.
-   */
-  public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
-    long analysisStartNanoTime = System.nanoTime();
-
-    if (!heapDumpFile.exists()) {
-      Exception exception = new IllegalArgumentException("File does not exist: " + heapDumpFile);
-      return failure(exception, since(analysisStartNanoTime));
-    }
-
-    try {
-      HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
-      HprofParser parser = new HprofParser(buffer);
-      Snapshot snapshot = parser.parse();
-      deduplicateGcRoots(snapshot);
-
-      Instance leakingRef = findLeakingReference(referenceKey, snapshot);
-
-      // False alarm, weak reference was cleared in between key check and heap dump.
-      if (leakingRef == null) {
-        return noLeak(since(analysisStartNanoTime));
-      }
-
-      return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);
-    } catch (Throwable e) {
-      return failure(e, since(analysisStartNanoTime));
-    }
-  }
-
-  /**
-   * Pruning duplicates reduces memory pressure from hprof bloat added in Marshmallow.
-   */
-  void deduplicateGcRoots(Snapshot snapshot) {
-    // THashMap has a smaller memory footprint than HashMap.
-    final THashMap<String, RootObj> uniqueRootMap = new THashMap<>();
-
-    final List<RootObj> gcRoots = (ArrayList) snapshot.getGCRoots();
-    for (RootObj root : gcRoots) {
-      String key = generateRootKey(root);
-      if (!uniqueRootMap.containsKey(key)) {
-        uniqueRootMap.put(key, root);
-      }
-    }
-
-    // Repopulate snapshot with unique GC roots.
-    gcRoots.clear();
-    uniqueRootMap.forEach(new TObjectProcedure<String>() {
-      @Override
-      public boolean execute(String key) {
-        return gcRoots.add(uniqueRootMap.get(key));
-      }
-    });
-  }
-
-  private String generateRootKey(RootObj root) {
-    return String.format("%s@0x%08x", root.getRootType().getName(), root.getId());
-  }
-
-  private Instance findLeakingReference(String key, Snapshot snapshot) {
-    ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());
-    List<String> keysFound = new ArrayList<>();
-    for (Instance instance : refClass.getInstancesList()) {
-      List<ClassInstance.FieldValue> values = classInstanceValues(instance);
-      String keyCandidate = asString(fieldValue(values, "key"));
-      if (keyCandidate.equals(key)) {
-        return fieldValue(values, "referent");
-      }
-      keysFound.add(keyCandidate);
-    }
-    throw new IllegalStateException(
-        "Could not find weak reference with key " + key + " in " + keysFound);
-  }
-
-  private AnalysisResult findLeakTrace(long analysisStartNanoTime, Snapshot snapshot,
-      Instance leakingRef) {
-
-    ShortestPathFinder pathFinder = new ShortestPathFinder(excludedRefs);
-    ShortestPathFinder.Result result = pathFinder.findPath(snapshot, leakingRef);
-
-    // False alarm, no strong reference path to GC Roots.
-    if (result.leakingNode == null) {
-      return noLeak(since(analysisStartNanoTime));
-    }
-
-    LeakTrace leakTrace = buildLeakTrace(result.leakingNode);
-
-    String className = leakingRef.getClassObj().getClassName();
-
-    // Side effect: computes retained size.
-    snapshot.computeDominators();
-
-    Instance leakingInstance = result.leakingNode.instance;
-
-    long retainedSize = leakingInstance.getTotalRetainedSize();
-
-    retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance);
-
-    return leakDetected(result.excludingKnownLeaks, className, leakTrace, retainedSize,
-        since(analysisStartNanoTime));
-  }
-
-  /**
-   * Bitmaps and bitmap byte arrays are sometimes held by native gc roots, so they aren't included
-   * in the retained size because their root dominator is a native gc root.
-   * To fix this, we check if the leaking instance is a dominator for each bitmap instance and then
-   * add the bitmap size.
-   *
-   * From experience, we've found that bitmap created in code (Bitmap.createBitmap()) are correctly
-   * accounted for, however bitmaps set in layouts are not.
-   */
-  private int computeIgnoredBitmapRetainedSize(Snapshot snapshot, Instance leakingInstance) {
-    int bitmapRetainedSize = 0;
-    ClassObj bitmapClass = snapshot.findClass("android.graphics.Bitmap");
-
-    for (Instance bitmapInstance : bitmapClass.getInstancesList()) {
-      if (isIgnoredDominator(leakingInstance, bitmapInstance)) {
-        ArrayInstance mBufferInstance = fieldValue(classInstanceValues(bitmapInstance), "mBuffer");
-        // Native bitmaps have mBuffer set to null. We sadly can't account for them.
-        if (mBufferInstance == null) {
-          continue;
-        }
-        long bufferSize = mBufferInstance.getTotalRetainedSize();
-        long bitmapSize = bitmapInstance.getTotalRetainedSize();
-        // Sometimes the size of the buffer isn't accounted for in the bitmap retained size. Since
-        // the buffer is large, it's easy to detect by checking for bitmap size < buffer size.
-        if (bitmapSize < bufferSize) {
-          bitmapSize += bufferSize;
-        }
-        bitmapRetainedSize += bitmapSize;
-      }
-    }
-    return bitmapRetainedSize;
-  }
-
-  private boolean isIgnoredDominator(Instance dominator, Instance instance) {
-    boolean foundNativeRoot = false;
-    while (true) {
-      Instance immediateDominator = instance.getImmediateDominator();
-      if (immediateDominator instanceof RootObj
-          && ((RootObj) immediateDominator).getRootType() == RootType.UNKNOWN) {
-        // Ignore native roots
-        instance = instance.getNextInstanceToGcRoot();
-        foundNativeRoot = true;
-      } else {
-        instance = immediateDominator;
-      }
-      if (instance == null) {
-        return false;
-      }
-      if (instance == dominator) {
-        return foundNativeRoot;
-      }
-    }
-  }
-
-  private LeakTrace buildLeakTrace(LeakNode leakingNode) {
-    List<LeakTraceElement> elements = new ArrayList<>();
-    // We iterate from the leak to the GC root
-    LeakNode node = new LeakNode(null, null, leakingNode, null, null);
-    while (node != null) {
-      LeakTraceElement element = buildLeakElement(node);
-      if (element != null) {
-        elements.add(0, element);
-      }
-      node = node.parent;
-    }
-    return new LeakTrace(elements);
-  }
-
-  private LeakTraceElement buildLeakElement(LeakNode node) {
-    if (node.parent == null) {
-      // Ignore any root node.
-      return null;
-    }
-    Instance holder = node.parent.instance;
-
-    if (holder instanceof RootObj) {
-      return null;
-    }
-    LeakTraceElement.Type type = node.referenceType;
-    String referenceName = node.referenceName;
-
-    LeakTraceElement.Holder holderType;
-    String className;
-    String extra = null;
-    List<String> fields = new ArrayList<>();
-    if (holder instanceof ClassObj) {
-      ClassObj classObj = (ClassObj) holder;
-      holderType = CLASS;
-      className = classObj.getClassName();
-      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-        Field field = entry.getKey();
-        Object value = entry.getValue();
-        fields.add("static " + field.getName() + " = " + value);
-      }
-    } else if (holder instanceof ArrayInstance) {
-      ArrayInstance arrayInstance = (ArrayInstance) holder;
-      holderType = ARRAY;
-      className = arrayInstance.getClassObj().getClassName();
-      if (arrayInstance.getArrayType() == Type.OBJECT) {
-        Object[] values = arrayInstance.getValues();
-        for (int i = 0; i < values.length; i++) {
-          fields.add("[" + i + "] = " + values[i]);
-        }
-      }
-    } else {
-      ClassInstance classInstance = (ClassInstance) holder;
-      ClassObj classObj = holder.getClassObj();
-      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-        fields.add("static " + fieldToString(entry));
-      }
-      for (ClassInstance.FieldValue field : classInstance.getValues()) {
-        fields.add(fieldToString(field));
-      }
-      className = classObj.getClassName();
-
-      if (extendsThread(classObj)) {
-        holderType = THREAD;
-        String threadName = threadName(holder);
-        extra = "(named '" + threadName + "')";
-      } else if (className.matches(ANONYMOUS_CLASS_NAME_PATTERN)) {
-        String parentClassName = classObj.getSuperClassObj().getClassName();
-        if (Object.class.getName().equals(parentClassName)) {
-          holderType = OBJECT;
-          try {
-            // This is an anonymous class implementing an interface. The API does not give access
-            // to the interfaces implemented by the class. We check if it's in the class path and
-            // use that instead.
-            Class<?> actualClass = Class.forName(classObj.getClassName());
-            Class<?>[] interfaces = actualClass.getInterfaces();
-            if (interfaces.length > 0) {
-              Class<?> implementedInterface = interfaces[0];
-              extra = "(anonymous implementation of " + implementedInterface.getName() + ")";
-            } else {
-              extra = "(anonymous subclass of java.lang.Object)";
-            }
-          } catch (ClassNotFoundException ignored) {
-          }
-        } else {
-          holderType = OBJECT;
-          // Makes it easier to figure out which anonymous class we're looking at.
-          extra = "(anonymous subclass of " + parentClassName + ")";
-        }
-      } else {
-        holderType = OBJECT;
-      }
-    }
-    return new LeakTraceElement(referenceName, type, holderType, className, extra, node.exclusion,
-        fields);
-  }
-
-  private long since(long analysisStartNanoTime) {
-    return NANOSECONDS.toMillis(System.nanoTime() - analysisStartNanoTime);
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
deleted file mode 100644
index b30df278..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.Instance;
-
-final class LeakNode {
-  /** May be null. */
-  final Exclusion exclusion;
-  final Instance instance;
-  final LeakNode parent;
-  final String referenceName;
-  final LeakTraceElement.Type referenceType;
-
-  LeakNode(Exclusion exclusion, Instance instance, LeakNode parent,
-      String referenceName, LeakTraceElement.Type referenceType) {
-    this.exclusion = exclusion;
-    this.instance = instance;
-    this.parent = parent;
-    this.referenceName = referenceName;
-    this.referenceType = referenceType;
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
deleted file mode 100644
index 607db22c..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.List;
-
-import static java.util.Collections.unmodifiableList;
-
-/**
- * A chain of references that constitute the shortest strong reference path from a leaking instance
- * to the GC roots. Fixing the leak usually means breaking one of the references in that chain.
- */
-public final class LeakTrace implements Serializable {
-
-  public final List<LeakTraceElement> elements;
-
-  LeakTrace(List<LeakTraceElement> elements) {
-    this.elements = unmodifiableList(new ArrayList<>(elements));
-  }
-
-  @Override public String toString() {
-    StringBuilder sb = new StringBuilder();
-    for (int i = 0; i < elements.size(); i++) {
-      LeakTraceElement element = elements.get(i);
-      sb.append("* ");
-      if (i == 0) {
-        sb.append("GC ROOT ");
-      } else if (i == elements.size() - 1) {
-        sb.append("leaks ");
-      } else {
-        sb.append("references ");
-      }
-      sb.append(element).append("\n");
-    }
-    return sb.toString();
-  }
-
-  public String toDetailedString() {
-    String string = "";
-    for (LeakTraceElement element : elements) {
-      string += element.toDetailedString();
-    }
-    return string;
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
deleted file mode 100644
index 89ef31e3..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.List;
-
-import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-import static java.util.Collections.unmodifiableList;
-import static java.util.Locale.US;
-
-/** Represents one reference in the chain of references that holds a leaking object in memory. */
-public final class LeakTraceElement implements Serializable {
-
-  public enum Type {
-    INSTANCE_FIELD, STATIC_FIELD, LOCAL, ARRAY_ENTRY
-  }
-
-  public enum Holder {
-    OBJECT, CLASS, THREAD, ARRAY
-  }
-
-  /** Null if this is the last element in the leak trace, ie the leaking object. */
-  public final String referenceName;
-
-  /** Null if this is the last element in the leak trace, ie the leaking object. */
-  public final Type type;
-  public final Holder holder;
-  public final String className;
-
-  /** Additional information, may be null. */
-  public final String extra;
-
-  /** If not null, there was no path that could exclude this element. */
-  public final Exclusion exclusion;
-
-  /** List of all fields (member and static) for that object. */
-  public final List<String> fields;
-
-  LeakTraceElement(String referenceName, Type type, Holder holder, String className, String extra,
-      Exclusion exclusion, List<String> fields) {
-    this.referenceName = referenceName;
-    this.type = type;
-    this.holder = holder;
-    this.className = className;
-    this.extra = extra;
-    this.exclusion = exclusion;
-    this.fields = unmodifiableList(new ArrayList<>(fields));
-  }
-
-  @Override public String toString() {
-    String string = "";
-
-    if (type == STATIC_FIELD) {
-      string += "static ";
-    }
-
-    if (holder == ARRAY || holder == THREAD) {
-      string += holder.name().toLowerCase(US) + " ";
-    }
-
-    string += className;
-
-    if (referenceName != null) {
-      string += "." + referenceName;
-    } else {
-      string += " instance";
-    }
-
-    if (extra != null) {
-      string += " " + extra;
-    }
-
-    if (exclusion != null) {
-      string += " , matching exclusion " + exclusion.matching;
-    }
-
-    return string;
-  }
-
-  public String toDetailedString() {
-    String string = "* ";
-    if (holder == ARRAY) {
-      string += "Array of";
-    } else if (holder == CLASS) {
-      string += "Class";
-    } else {
-      string += "Instance of";
-    }
-    string += " " + className + "\n";
-    for (String field : fields) {
-      string += "|   " + field + "\n";
-    }
-    return string;
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
deleted file mode 100644
index db6100ef..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
+++ /dev/null
@@ -1,343 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.ArrayInstance;
-import com.squareup.haha.perflib.ClassInstance;
-import com.squareup.haha.perflib.ClassObj;
-import com.squareup.haha.perflib.Field;
-import com.squareup.haha.perflib.HahaSpy;
-import com.squareup.haha.perflib.Instance;
-import com.squareup.haha.perflib.RootObj;
-import com.squareup.haha.perflib.RootType;
-import com.squareup.haha.perflib.Snapshot;
-import com.squareup.haha.perflib.Type;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.LinkedList;
-import java.util.Map;
-import java.util.Queue;
-
-import static com.squareup.leakcanary.HahaHelper.isPrimitiveOrWrapperArray;
-import static com.squareup.leakcanary.HahaHelper.isPrimitiveWrapper;
-import static com.squareup.leakcanary.HahaHelper.threadName;
-import static com.squareup.leakcanary.LeakTraceElement.Type.ARRAY_ENTRY;
-import static com.squareup.leakcanary.LeakTraceElement.Type.INSTANCE_FIELD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.LOCAL;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-
-/**
- * Not thread safe.
- *
- * Finds the shortest path from a leaking reference to a gc root, ignoring excluded
- * refs first and then including the ones that are not "always ignorable" as needed if no path is
- * found.
- */
-final class ShortestPathFinder {
-
-  private final ExcludedRefs excludedRefs;
-  private final Queue<LeakNode> toVisitQueue;
-  private final Queue<LeakNode> toVisitIfNoPathQueue;
-  private final LinkedHashSet<Instance> toVisitSet;
-  private final LinkedHashSet<Instance> toVisitIfNoPathSet;
-  private final LinkedHashSet<Instance> visitedSet;
-  private boolean canIgnoreStrings;
-
-  ShortestPathFinder(ExcludedRefs excludedRefs) {
-    this.excludedRefs = excludedRefs;
-    toVisitQueue = new LinkedList<>();
-    toVisitIfNoPathQueue = new LinkedList<>();
-    toVisitSet = new LinkedHashSet<>();
-    toVisitIfNoPathSet = new LinkedHashSet<>();
-    visitedSet = new LinkedHashSet<>();
-  }
-
-  static final class Result {
-    final LeakNode leakingNode;
-    final boolean excludingKnownLeaks;
-
-    Result(LeakNode leakingNode, boolean excludingKnownLeaks) {
-      this.leakingNode = leakingNode;
-      this.excludingKnownLeaks = excludingKnownLeaks;
-    }
-  }
-
-  Result findPath(Snapshot snapshot, Instance leakingRef) {
-    clearState();
-    canIgnoreStrings = !isString(leakingRef);
-
-    enqueueGcRoots(snapshot);
-
-    boolean excludingKnownLeaks = false;
-    LeakNode leakingNode = null;
-    while (!toVisitQueue.isEmpty() || !toVisitIfNoPathQueue.isEmpty()) {
-      LeakNode node;
-      if (!toVisitQueue.isEmpty()) {
-        node = toVisitQueue.poll();
-      } else {
-        node = toVisitIfNoPathQueue.poll();
-        if (node.exclusion == null) {
-          throw new IllegalStateException("Expected node to have an exclusion " + node);
-        }
-        excludingKnownLeaks = true;
-      }
-
-      // Termination
-      if (node.instance == leakingRef) {
-        leakingNode = node;
-        break;
-      }
-
-      if (checkSeen(node)) {
-        continue;
-      }
-
-      if (node.instance instanceof RootObj) {
-        visitRootObj(node);
-      } else if (node.instance instanceof ClassObj) {
-        visitClassObj(node);
-      } else if (node.instance instanceof ClassInstance) {
-        visitClassInstance(node);
-      } else if (node.instance instanceof ArrayInstance) {
-        visitArrayInstance(node);
-      } else {
-        throw new IllegalStateException("Unexpected type for " + node.instance);
-      }
-    }
-    return new Result(leakingNode, excludingKnownLeaks);
-  }
-
-  private void clearState() {
-    toVisitQueue.clear();
-    toVisitIfNoPathQueue.clear();
-    toVisitSet.clear();
-    toVisitIfNoPathSet.clear();
-    visitedSet.clear();
-  }
-
-  private void enqueueGcRoots(Snapshot snapshot) {
-    for (RootObj rootObj : snapshot.getGCRoots()) {
-      switch (rootObj.getRootType()) {
-        case JAVA_LOCAL:
-          Instance thread = HahaSpy.allocatingThread(rootObj);
-          String threadName = threadName(thread);
-          Exclusion params = excludedRefs.threadNames.get(threadName);
-          if (params == null || !params.alwaysExclude) {
-            enqueue(params, null, rootObj, null, null);
-          }
-          break;
-        case INTERNED_STRING:
-        case DEBUGGER:
-        case INVALID_TYPE:
-          // An object that is unreachable from any other root, but not a root itself.
-        case UNREACHABLE:
-        case UNKNOWN:
-          // An object that is in a queue, waiting for a finalizer to run.
-        case FINALIZING:
-          break;
-        case SYSTEM_CLASS:
-        case VM_INTERNAL:
-          // A local variable in native code.
-        case NATIVE_LOCAL:
-          // A global variable in native code.
-        case NATIVE_STATIC:
-          // An object that was referenced from an active thread block.
-        case THREAD_BLOCK:
-          // Everything that called the wait() or notify() methods, or that is synchronized.
-        case BUSY_MONITOR:
-        case NATIVE_MONITOR:
-        case REFERENCE_CLEANUP:
-          // Input or output parameters in native code.
-        case NATIVE_STACK:
-        case JAVA_STATIC:
-          enqueue(null, null, rootObj, null, null);
-          break;
-        default:
-          throw new UnsupportedOperationException("Unknown root type:" + rootObj.getRootType());
-      }
-    }
-  }
-
-  private boolean checkSeen(LeakNode node) {
-    return !visitedSet.add(node.instance);
-  }
-
-  private void visitRootObj(LeakNode node) {
-    RootObj rootObj = (RootObj) node.instance;
-    Instance child = rootObj.getReferredInstance();
-
-    Exclusion exclusion = rootSuperClassAlwaysIgnored(child);
-
-    if (exclusion != null && exclusion.alwaysExclude) {
-      return;
-    }
-
-    if (rootObj.getRootType() == RootType.JAVA_LOCAL) {
-      Instance holder = HahaSpy.allocatingThread(rootObj);
-      // We switch the parent node with the thread instance that holds
-      // the local reference.
-      LeakNode parent = new LeakNode(null, holder, null, null, null);
-      if (node.exclusion != null) {
-        exclusion = node.exclusion;
-      }
-      enqueue(exclusion, parent, child, "<Java Local>", LOCAL);
-    } else {
-      enqueue(exclusion, node, child, null, null);
-    }
-  }
-
-  private Exclusion rootSuperClassAlwaysIgnored(Instance child) {
-    if (child == null) {
-      return null;
-    }
-    Exclusion matchingParams = null;
-    ClassObj superClassObj = child.getClassObj();
-    while (superClassObj != null) {
-      Exclusion params = excludedRefs.rootClassNames.get(superClassObj.getClassName());
-      if (params != null) {
-        // true overrides null or false.
-        if (matchingParams == null || !matchingParams.alwaysExclude) {
-          matchingParams = params;
-        }
-      }
-      superClassObj = superClassObj.getSuperClassObj();
-    }
-    return matchingParams;
-  }
-
-  private void visitClassObj(LeakNode node) {
-    ClassObj classObj = (ClassObj) node.instance;
-    Map<String, Exclusion> ignoredStaticFields =
-        excludedRefs.staticFieldNameByClassName.get(classObj.getClassName());
-    for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-      Field field = entry.getKey();
-      if (field.getType() != Type.OBJECT) {
-        continue;
-      }
-      String fieldName = field.getName();
-      if (fieldName.equals("$staticOverhead")) {
-        continue;
-      }
-      Instance child = (Instance) entry.getValue();
-      boolean visit = true;
-      if (ignoredStaticFields != null) {
-        Exclusion params = ignoredStaticFields.get(fieldName);
-        if (params != null) {
-          visit = false;
-          if (!params.alwaysExclude) {
-            enqueue(params, node, child, fieldName, STATIC_FIELD);
-          }
-        }
-      }
-      if (visit) {
-        enqueue(null, node, child, fieldName, STATIC_FIELD);
-      }
-    }
-  }
-
-  private void visitClassInstance(LeakNode node) {
-    ClassInstance classInstance = (ClassInstance) node.instance;
-    Map<String, Exclusion> ignoredFields = new LinkedHashMap<>();
-    ClassObj superClassObj = classInstance.getClassObj();
-    Exclusion classExclusion = null;
-    while (superClassObj != null) {
-      Exclusion params = excludedRefs.classNames.get(superClassObj.getClassName());
-      if (params != null) {
-        // true overrides null or false.
-        if (classExclusion == null || !classExclusion.alwaysExclude) {
-          classExclusion = params;
-        }
-      }
-      Map<String, Exclusion> classIgnoredFields =
-          excludedRefs.fieldNameByClassName.get(superClassObj.getClassName());
-      if (classIgnoredFields != null) {
-        ignoredFields.putAll(classIgnoredFields);
-      }
-      superClassObj = superClassObj.getSuperClassObj();
-    }
-
-    if (classExclusion != null && classExclusion.alwaysExclude) {
-      return;
-    }
-
-    for (ClassInstance.FieldValue fieldValue : classInstance.getValues()) {
-      Exclusion fieldExclusion = classExclusion;
-      Field field = fieldValue.getField();
-      if (field.getType() != Type.OBJECT) {
-        continue;
-      }
-      Instance child = (Instance) fieldValue.getValue();
-      String fieldName = field.getName();
-      Exclusion params = ignoredFields.get(fieldName);
-      // If we found a field exclusion and it's stronger than a class exclusion
-      if (params != null && (fieldExclusion == null || (params.alwaysExclude
-          && !fieldExclusion.alwaysExclude))) {
-        fieldExclusion = params;
-      }
-      enqueue(fieldExclusion, node, child, fieldName, INSTANCE_FIELD);
-    }
-  }
-
-  private void visitArrayInstance(LeakNode node) {
-    ArrayInstance arrayInstance = (ArrayInstance) node.instance;
-    Type arrayType = arrayInstance.getArrayType();
-    if (arrayType == Type.OBJECT) {
-      Object[] values = arrayInstance.getValues();
-      for (int i = 0; i < values.length; i++) {
-        Instance child = (Instance) values[i];
-        enqueue(null, node, child, "[" + i + "]", ARRAY_ENTRY);
-      }
-    }
-  }
-
-  private void enqueue(Exclusion exclusion, LeakNode parent, Instance child, String referenceName,
-      LeakTraceElement.Type referenceType) {
-    if (child == null) {
-      return;
-    }
-    if (isPrimitiveOrWrapperArray(child) || isPrimitiveWrapper(child)) {
-      return;
-    }
-    // Whether we want to visit now or later, we should skip if this is already to visit.
-    if (toVisitSet.contains(child)) {
-      return;
-    }
-    boolean visitNow = exclusion == null;
-    if (!visitNow && toVisitIfNoPathSet.contains(child)) {
-      return;
-    }
-    if (canIgnoreStrings && isString(child)) {
-      return;
-    }
-    if (visitedSet.contains(child)) {
-      return;
-    }
-    LeakNode childNode = new LeakNode(exclusion, child, parent, referenceName, referenceType);
-    if (visitNow) {
-      toVisitSet.add(child);
-      toVisitQueue.add(childNode);
-    } else {
-      toVisitIfNoPathSet.add(child);
-      toVisitIfNoPathQueue.add(childNode);
-    }
-  }
-
-  private boolean isString(Instance instance) {
-    return instance.getClassObj() != null && instance.getClassObj()
-        .getClassName()
-        .equals(String.class.getName());
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt b/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt
new file mode 100644
index 00000000..52ca9f9c
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt
@@ -0,0 +1,32 @@
+package leakcanary
+
+interface AnalyzerProgressListener {
+
+  // These steps should be defined in the order in which they occur.
+  enum class Step {
+    READING_HEAP_DUMP_FILE,
+    PARSING_HEAP_DUMP,
+    SCANNING_HEAP_DUMP,
+    FINDING_WATCHED_REFERENCES,
+    DEDUPLICATING_GC_ROOTS,
+    FINDING_LEAKING_REF,
+    FINDING_LEAKING_REFS,
+    FINDING_SHORTEST_PATH,
+    FINDING_SHORTEST_PATHS,
+    FINDING_DOMINATORS,
+    COMPUTING_NATIVE_RETAINED_SIZE,
+    COMPUTING_RETAINED_SIZE,
+    BUILDING_LEAK_TRACE,
+    BUILDING_LEAK_TRACES,
+    COMPUTING_DOMINATORS
+  }
+
+  fun onProgressUpdate(step: Step)
+
+  companion object {
+    val NONE = object : AnalyzerProgressListener {
+      override fun onProgressUpdate(step: Step) {
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidKnownReference.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidKnownReference.kt
new file mode 100644
index 00000000..0e1eb917
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AndroidKnownReference.kt
@@ -0,0 +1,1131 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import leakcanary.Exclusion.ExclusionType
+import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
+import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
+import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
+import leakcanary.Exclusion.Status
+import leakcanary.Exclusion.Status.NEVER_REACHABLE
+import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
+import leakcanary.Exclusion.Status.WONT_FIX_LEAK
+import java.lang.ref.PhantomReference
+import java.lang.ref.SoftReference
+import java.lang.ref.WeakReference
+import java.util.EnumSet
+
+/**
+ * The first parameter is the value of android.os.Build.MANUFACTURER and the second
+ * parameter is the value of android.os.Build.VERSION.SDK_INT. Returns true if the known
+ * reference should be applied on the provided manufacturer / sdk int.
+ */
+typealias BuildFilter = (String, Int) -> Boolean
+
+/**
+ * This class is a work in progress. You can help by reporting leak traces that seem to be caused
+ * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
+ *
+ * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
+ * manufacturer implementation, they usually share their builds across multiple models, and the
+ * leaks eventually get fixed in newer versions.
+ *
+ * Most app developers should use [appDefaults]. However, you can also pick the
+ * leaks you want to ignore by creating an [EnumSet] that matches your needs and calling
+ * [buildKnownReferences]
+ */
+class AndroidKnownReference private constructor(
+  val type: ExclusionType,
+  val reason: String?,
+  val status: Status,
+  val filter: BuildFilter
+) {
+
+  companion object {
+    private const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
+    const val SAMSUNG = "samsung"
+    const val MOTOROLA = "motorola"
+    const val LENOVO = "LENOVO"
+    const val LG = "LGE"
+    const val NVIDIA = "NVIDIA"
+    const val MEIZU = "Meizu"
+    const val HUAWEI = "HUAWEI"
+    const val VIVO = "vivo"
+
+    /**
+     * This returns the references in the leak path that should be ignored by all on Android.
+     */
+    val androidDefaults: Set<AndroidKnownReference>
+      get() = buildKnownReferences(
+          EnumSet.of(
+              Defaults.REFERENCES,
+              Defaults.FINALIZER_WATCHDOG_DAEMON,
+              Defaults.MAIN,
+              Defaults.LEAK_CANARY_THREAD,
+              Defaults.EVENT_RECEIVER__MMESSAGE_QUEUE
+          )
+      )
+
+    /**
+     * This returns the references in the leak path that can be ignored for app developers. This
+     * doesn't mean there is no memory leak, to the contrary. However, some leaks are caused by bugs
+     * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
+     * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
+     */
+    val appDefaults: Set<AndroidKnownReference>
+      get() = buildKnownReferences(EnumSet.allOf(Defaults::class.java))
+
+    fun buildKnownReferences(defaults: Set<Defaults>): Set<AndroidKnownReference> {
+      val resultSet = mutableSetOf<AndroidKnownReference>()
+      defaults.forEach {
+        it.add(resultSet)
+      }
+      return resultSet
+    }
+
+    private val NO_FILTER: BuildFilter = { _, _ ->
+      true
+    }
+
+    fun staticField(
+      className: String,
+      fieldName: String,
+      reason: String? = null,
+      status: Status = WONT_FIX_LEAK,
+      filter: BuildFilter = NO_FILTER
+    ) = AndroidKnownReference(StaticFieldExclusion(className, fieldName), reason, status, filter)
+
+    fun instanceField(
+      className: String,
+      fieldName: String,
+      reason: String? = null,
+      status: Status = WONT_FIX_LEAK,
+      filter: BuildFilter = NO_FILTER
+    ) = AndroidKnownReference(InstanceFieldExclusion(className, fieldName), reason, status, filter)
+
+    fun javaLocal(
+      threadName: String,
+      reason: String? = null,
+      status: Status = WONT_FIX_LEAK,
+      filter: BuildFilter = NO_FILTER
+    ) = AndroidKnownReference(JavaLocalExclusion(threadName), reason, status, filter)
+
+    /**
+     * Used to transform [AndroidKnownReference] instances to [Exclusion] which is what
+     * the heap analyzer actually uses. The resulting set should only be used
+     * for exactly one analysis, it caches the Android version information.
+     */
+    fun mapToExclusions(knownReferences: Set<AndroidKnownReference>): List<Exclusion> {
+      val buildMirror = BuildMirror()
+      return knownReferences.map { knownReference ->
+        Exclusion(
+            knownReference.type, knownReference.reason, knownReference.status,
+            buildMirror.wrapFilter(knownReference.filter)
+        )
+      }
+    }
+  }
+
+  enum class Defaults {
+    // ######## Android Framework known leaks ########
+
+    ACTIVITY_CLIENT_RECORD__NEXT_IDLE {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.app.ActivityThread\$ActivityClientRecord", "nextIdle",
+            reason = "Android AOSP sometimes keeps a reference to a destroyed activity as a"
+                + " nextIdle client record in the android.app.ActivityThread.mActivities map."
+                + " Not sure what's going on there, input welcome."
+        ) { _, sdkInt ->
+          sdkInt in 19..27
+        }
+      }
+    },
+
+    SPAN_CONTROLLER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        val reason =
+          ("Editor inserts a special span, which has a reference to the EditText. That span is a"
+              + " NoCopySpan, which makes sure it gets dropped when creating a new"
+              + " SpannableStringBuilder from a given CharSequence."
+              + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
+              + " bundle. Prior to KitKat, that copy was done using the SpannableString"
+              + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
+              + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
+              + " reference to the textview and therefore the entire view hierarchy & activity"
+              + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
+              + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
+              + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
+              + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.")
+
+        references += instanceField(
+            "android.widget.Editor\$SpanController", "this$0", reason
+        ) { _, sdkInt ->
+          sdkInt <= 19
+        }
+
+        references += instanceField(
+            "android.widget.Editor\$EasyEditSpanController", "this$0", reason
+        ) { _, sdkInt ->
+          sdkInt <= 19
+        }
+      }
+    },
+
+    MEDIA_SESSION_LEGACY_HELPER__SINSTANCE {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references +=
+          staticField(
+              "android.media.session.MediaSessionLegacyHelper", "sInstance",
+              reason = "MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
+                  + " keeps a reference to the context it's given the first time"
+                  + " MediaSessionLegacyHelper.getHelper() is called."
+                  + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
+                  + " calling context.getApplicationContext()."
+                  + " Fix: https://github.com/android/platform_frameworks_base/commit"
+                  + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
+                  + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
+                  + " in Application.onCreate() and pass it the application context."
+          ) { _, sdkInt ->
+            sdkInt == 21
+          }
+      }
+    },
+
+    TEXT_LINE__SCACHED {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += staticField(
+            "android.text.TextLine", "sCached",
+            reason = "TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
+                + " at least two bugs that created memory leaks by not correctly clearing the"
+                + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
+                + " https://github.com/android/platform_frameworks_base/commit"
+                + "/893d6fe48d37f71e683f722457bea646994a10"
+                + " The second was fixed, not released yet:"
+                + " https://github.com/android/platform_frameworks_base/commit"
+                + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
+                + " To fix this, you could access TextLine.sCached and clear the pool every now"
+                + " and then (e.g. on activity destroy)."
+        ) { _, sdkInt ->
+          sdkInt <= 22
+        }
+      }
+    },
+
+    BLOCKING_QUEUE {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        val reason = ("A thread waiting on a blocking queue will leak the last"
+            + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
+            + " keeps a local reference to the last message it received. That message then gets"
+            + " recycled and can be used again. As long as all messages are recycled after being"
+            + " used, this won't be a problem, because these references are cleared when being"
+            + " recycled. However, dialogs create template Message instances to be copied when a"
+            + " message needs to be sent. These Message templates holds references to the dialog"
+            + " listeners, which most likely leads to holding a reference onto the activity in some"
+            + " way. Dialogs never recycle their template Message, assuming these Message instances"
+            + " will get GCed when the dialog is GCed."
+            + " The combination of these two things creates a high potential for memory leaks as soon"
+            + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
+            + " sleep for a long time."
+            + " To fix this, you could post empty messages to the idle handler threads from time to"
+            + " time. This won't be easy because you cannot access all handler threads, but a library"
+            + " that is widely used should consider doing this for its own handler threads. This leaks"
+            + " has been shown to happen in both Dalvik and ART.")
+
+        references += instanceField("android.os.Message", "obj", reason)
+        references += instanceField("android.os.Message", "next", reason)
+        references += instanceField("android.os.Message", "target", reason)
+      }
+    },
+
+    INPUT_METHOD_MANAGER_IS_TERRIBLE {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        val reason = ("When we detach a view that receives keyboard input, the InputMethodManager"
+            + " leaks a reference to it until a new view asks for keyboard input."
+            + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
+            + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414")
+
+        references += instanceField(
+            "android.view.inputmethod.InputMethodManager", "mNextServedView", reason
+        ) { _, sdkInt ->
+          sdkInt in 15..27
+        }
+
+        references += instanceField(
+            "android.view.inputmethod.InputMethodManager", "mServedView", reason
+        ) { _, sdkInt ->
+          sdkInt in 15..27
+        }
+
+        references += instanceField(
+            "android.view.inputmethod.InputMethodManager", "mServedInputConnection", reason
+        ) { _, sdkInt ->
+          sdkInt in 15..27
+        }
+
+        references += instanceField(
+            "android.view.inputmethod.InputMethodManager", "mLastSrvView"
+            ,
+            reason =
+            "HUAWEI added a mLastSrvView field to InputMethodManager" + " that leaks a reference to the last served view."
+        ) { manufacturer, sdkInt ->
+          manufacturer == HUAWEI && sdkInt in 23..27
+        }
+
+        references += instanceField(
+            "android.view.inputmethod.InputMethodManager", "mCurRootView",
+            reason = "The singleton InputMethodManager is holding a reference to mCurRootView long"
+                + " after the activity has been destroyed."
+                + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
+                + "#issuecomment-100579429"
+                + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414"
+        ) { _, sdkInt ->
+          sdkInt in 15..28
+        }
+
+        references += instanceField(
+            "android.view.inputmethod.InputMethodManager", "mImeInsetsConsumer",
+            reason = """
+              Android Q Beta has a leak where InputMethodManager.mImeInsetsConsumer isn't set to
+              null when the activity is destroyed.
+            """.trimIndent()
+        ) { _, sdkInt ->
+          sdkInt == 28
+        }
+
+        references += instanceField(
+            "android.view.inputmethod.InputMethodManager", "mCurrentInputConnection",
+            reason = """
+              In Android Q Beta InputMethodManager keeps its EditableInputConnection after the
+              activity has been destroyed.
+            """.trimIndent()
+        ) { _, sdkInt ->
+          sdkInt == 28
+        }
+      }
+    },
+
+    LAYOUT_TRANSITION {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.animation.LayoutTransition$1", "val\$parent",
+            reason = "LayoutTransition leaks parent ViewGroup through"
+                + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
+                + " window is destroyed. Tracked here:"
+                + " https://code.google.com/p/android/issues/detail?id=171830"
+        ) { _, sdkInt ->
+          sdkInt in 14..22
+        }
+      }
+    },
+
+    SPELL_CHECKER_SESSION {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.view.textservice.SpellCheckerSession$1", "this$0",
+            reason = "SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
+                + " SpellCheckerSession is closed before the service is connected."
+                + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542"
+        ) { _, sdkInt ->
+          sdkInt in 16..24
+        }
+      }
+    },
+
+    SPELL_CHECKER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.widget.SpellChecker$1", "this$0",
+            reason = "SpellChecker holds on to a detached view that points to a destroyed activity."
+                + " mSpellRunnable is being enqueued, and that callback should be removed when "
+                + " closeSession() is called. Maybe closeSession() wasn't called, or maybe it was "
+                + " called after the view was detached."
+        ) { _, sdkInt ->
+          sdkInt == 22
+        }
+      }
+    },
+
+    ACTIVITY_CHOOSE_MODEL {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        val reason = ("ActivityChooserModel holds a static reference to the last set"
+            + " ActivityChooserModelPolicy which can be an activity context."
+            + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
+            + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0")
+
+
+        references += instanceField(
+            "android.support.v7.internal.widget.ActivityChooserModel",
+            "mActivityChoserModelPolicy",
+            reason = reason
+        ) { _, sdkInt ->
+          sdkInt in 15..22
+        }
+
+        references += instanceField(
+            "android.widget.ActivityChooserModel", "mActivityChoserModelPolicy",
+            reason = reason
+        )
+      }
+    },
+
+    MEDIA_PROJECTION_CALLBACK {
+      override fun add(references: MutableSet<AndroidKnownReference>) {
+        references += instanceField("android.media.projection.MediaProjection\$MediaProjectionCallback",
+            "this$0", reason = """
+              MediaProjectionCallback is held by another process, and holds on to MediaProjection
+              which has an activity as its context.
+            """.trimIndent()) { _, sdkInt ->
+          sdkInt in 22..28
+        }
+      }
+
+    },
+
+    SPEECH_RECOGNIZER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.speech.SpeechRecognizer\$InternalListener", "this$0"
+            ,
+            reason = "Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
+                + " class and leaked the SpeechRecognizer which leaked an activity context."
+                + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+                + " /b37866db469e81aca534ff6186bdafd44352329b"
+        ) { _, sdkInt ->
+          sdkInt < 21
+        }
+      }
+    },
+
+    ACCOUNT_MANAGER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.accounts.AccountManager\$AmsTask\$Response", "this$1"
+            ,
+            reason =
+            "AccountManager\$AmsTask\$Response is a stub and is held in memory by native code,"
+                + " probably because the reference to the response in the other process hasn't been"
+                + " cleared."
+                + " AccountManager\$AmsTask is holding on to the activity reference to use for"
+                + " launching a new sub- Activity."
+                + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
+                + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
+                + " with the returned future to to get the result and correctly start an activity"
+                + " when it's available."
+        ) { _, sdkInt ->
+          sdkInt <= 27
+        }
+      }
+    },
+
+    MEDIA_SCANNER_CONNECTION {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.media.MediaScannerConnection", "mContext",
+
+            reason =
+            "The static method MediaScannerConnection.scanFile() takes an activity context"
+                + " but the service might not disconnect after the activity has been destroyed."
+                + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
+                + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
+                + " application context. Call connect() and disconnect() manually."
+        ) { _, sdkInt ->
+          sdkInt <= 22
+        }
+      }
+    },
+
+    USER_MANAGER__SINSTANCE {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.os.UserManager", "mContext",
+            reason =
+            "UserManager has a static sInstance field that creates an instance and caches it"
+                + " the first time UserManager.get() is called. This instance is created with the"
+                + " outer context (which is an activity base context)."
+                + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
+                + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
+                + "/27db46850b708070452c0ce49daf5f79503fbde6"
+                + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
+                + " UserManager instance gets cached with a reference to the application context."
+        ) { _, sdkInt ->
+          sdkInt in 18..25
+        }
+      }
+    },
+
+    APP_WIDGET_HOST_CALLBACKS {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.appwidget.AppWidgetHost\$Callbacks", "this$0"
+            ,
+            reason =
+            "android.appwidget.AppWidgetHost\$Callbacks is a stub and is held in memory native"
+                + " code. The reference to the `mContext` was not being cleared, which caused the"
+                + " Callbacks instance to retain this reference"
+                + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+                + "/7a96f3c917e0001ee739b65da37b2fadec7d7765"
+        ) { _, sdkInt ->
+          sdkInt < 22
+        }
+      }
+    },
+
+    AUDIO_MANAGER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.media.AudioManager$1", "this$0",
+            reason =
+            "Prior to Android M, VideoView required audio focus from AudioManager and"
+                + " never abandoned it, which leaks the Activity context through the AudioManager."
+                + " The root of the problem is that AudioManager uses whichever"
+                + " context it receives, which in the case of the VideoView example is an Activity,"
+                + " even though it only needs the application's context. The issue is fixed in"
+                + " Android M, and the AudioManager now uses the application's context."
+                + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
+                + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2"
+        ) { _, sdkInt ->
+          sdkInt <= 22
+        }
+      }
+    },
+
+    EDITTEXT_BLINK_MESSAGEQUEUE {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.widget.Editor\$Blink", "this$0",
+            reason =
+            "The EditText Blink of the Cursor is implemented using a callback and Messages,"
+                + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
+                + " contains a blinking cursor is detached, a message is posted with a delay after the"
+                + " dialog has been closed and as a result leaks the Activity."
+                + " This can be fixed manually by calling TextView.setCursorVisible(false) in the"
+                + " dismiss() method of the dialog."
+                + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
+                + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
+                + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/"
+        ) { _, sdkInt ->
+          sdkInt <= 22
+        }
+      }
+    },
+
+    CONNECTIVITY_MANAGER__SINSTANCE {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.net.ConnectivityManager", "sInstance",
+            reason =
+            "ConnectivityManager has a sInstance field that is set when the first"
+                + " ConnectivityManager instance is created. ConnectivityManager has a mContext field."
+                + " When calling activity.getSystemService(Context.CONNECTIVITY_SERVICE) , the first"
+                + " ConnectivityManager instance is created with the activity context and stored in"
+                + " sInstance. That activity context then leaks forever."
+                + " Until this is fixed, app developers can prevent this leak by making sure the"
+                + " ConnectivityManager is first created with an App Context. E.g. in some static"
+                + " init do: context.getApplicationContext()"
+                + ".getSystemService(Context.CONNECTIVITY_SERVICE)"
+                + " Tracked here: https://code.google.com/p/android/issues/detail?id=198852"
+                + " Introduced here: https://github.com/android/platform_frameworks_base/commit/"
+                + "e0bef71662d81caaaa0d7214fb0bef5d39996a69"
+        ) { _, sdkInt ->
+          sdkInt <= 23
+        }
+      }
+    },
+
+    ACCESSIBILITY_NODE_INFO__MORIGINALTEXT {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.view.accessibility.AccessibilityNodeInfo", "mOriginalText"
+            ,
+            reason =
+            "AccessibilityNodeInfo has a static sPool of AccessibilityNodeInfo. When"
+                + " AccessibilityNodeInfo instances are released back in the pool,"
+                + " AccessibilityNodeInfo.clear() does not clear the mOriginalText field, which"
+                + " causes spans to leak which in turns causes TextView.ChangeWatcher to leak and the"
+                + " whole view hierarchy. Introduced here: https://android.googlesource.com/platform/"
+                + "frameworks/base/+/193520e3dff5248ddcf8435203bf99d2ba667219%5E%21/core/java/"
+                + "android/view/accessibility/AccessibilityNodeInfo.java"
+        ) { _, sdkInt ->
+          sdkInt in 26..27
+        }
+      }
+    },
+
+    BACKDROP_FRAME_RENDERER__MDECORVIEW {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "com.android.internal.policy.BackdropFrameRenderer", "mDecorView"
+            ,
+            reason =
+            "When BackdropFrameRenderer.releaseRenderer() is called, there's an unknown case"
+                + " where mRenderer becomes null but mChoreographer doesn't and the thread doesn't"
+                + " stop and ends up leaking mDecorView which itself holds on to a destroyed"
+                + " activity"
+        ) { _, sdkInt ->
+          sdkInt in 24..26
+        }
+      }
+    },
+
+    VIEWLOCATIONHOLDER_ROOT {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.view.ViewGroup\$ViewLocationHolder",
+            "mRoot"
+            ,
+            reason = "In Android P, ViewLocationHolder has an mRoot field that is not cleared " +
+                "in its clear() method. Introduced in https://github.com/aosp-mirror" +
+                "/platform_frameworks_base/commit/86b326012813f09d8f1de7d6d26c986a909d Bug " +
+                "report: https://issuetracker.google.com/issues/112792715"
+        ) { _, sdkInt ->
+          sdkInt == 28
+        }
+      }
+    },
+
+    ACCESSIBILITY_NODE_ID_MANAGER {
+      override fun add(references: MutableSet<AndroidKnownReference>) {
+        references += instanceField(
+            "android.view.accessibility.AccessibilityNodeIdManager", "mIdsToViews"
+            ,
+            reason = """
+              Android Q Beta added AccessibilityNodeIdManager which stores all views from their
+              onAttachedToWindow() call, until detached. Unfortunately it's possible to trigger
+              the view framework to call detach before attach (by having a view removing itself
+              from its parent in onAttach, which then causes AccessibilityNodeIdManager to keep
+              children view forever. Future releases of Q will hold weak references.
+            """.trimIndent()
+        ) { _, sdkInt ->
+          sdkInt == 28
+        }
+      }
+
+    },
+
+    TEXT_TO_SPEECH {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        val reason =
+          ("TextToSpeech.shutdown() does not release its references to context objects." +
+              " Furthermore, TextToSpeech instances cannot be garbage collected due to other process" +
+              " keeping the references, resulting the context objects leaked." +
+              " Developers might be able to mitigate the issue by passing application context" +
+              " to TextToSpeech constructor." +
+              " Tracked at: https://github.com/square/leakcanary/issues/1210 and" +
+              " https://issuetracker.google.com/issues/129250419")
+        references += instanceField(
+            "android.speech.tts.TextToSpeech", "mContext",
+            reason = reason
+        ) { _, sdkInt ->
+          sdkInt == 24
+        }
+
+        references += instanceField(
+            "android.speech.tts.TtsEngines", "mContext",
+            reason = reason
+        ) { _, sdkInt ->
+          sdkInt == 24
+        }
+      }
+    },
+
+    // ######## Manufacturer specific known leaks ########
+
+    // SAMSUNG
+
+    SPEN_GESTURE_MANAGER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += staticField(
+            "com.samsung.android.smartclip.SpenGestureManager", "mContext"
+            ,
+            reason =
+            "SpenGestureManager has a static mContext field that leaks a reference to the" + " activity. Yes, a STATIC mContext field."
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt == 19
+        }
+      }
+    },
+
+    CLIPBOARD_UI_MANAGER__SINSTANCE {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.sec.clipboard.ClipboardUIManager", "mContext"
+            ,
+            reason =
+            "ClipboardUIManager is a static singleton that leaks an activity context."
+                + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
+                + " , so that the ClipboardUIManager instance gets cached with a reference to the"
+                + " application context. Example: https://gist.github.com/cypressious/"
+                + "91c4fb1455470d803a602838dfcd5774"
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt in 19..21
+        }
+      }
+    },
+
+    SEM_CLIPBOARD_MANAGER__MCONTEXT {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "com.samsung.android.content.clipboard.SemClipboardManager",
+            "mContext"
+            ,
+            reason =
+            "SemClipboardManager is held in memory by an anonymous inner class" + " implementation of android.os.Binder, thereby leaking an activity context."
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt in 19..24
+        }
+        references += instanceField(
+            "com.samsung.android.content.clipboard.SemClipboardManager$3",
+            "this$0"
+            ,
+            reason =
+            "SemClipboardManager is held in memory by an anonymous inner class" + " implementation of android.os.Binder, thereby leaking an activity context."
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt in 22..28
+        }
+      }
+    },
+
+    SEM_EMERGENCY_MANAGER__MCONTEXT {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "com.samsung.android.emergencymode.SemEmergencyManager", "mContext"
+            ,
+            reason =
+            "SemEmergencyManager is a static singleton that leaks a DecorContext." + " Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d"
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt in 19..24
+        }
+      }
+    },
+
+    SEM_PERSONA_MANAGER {
+      override fun add(references: MutableSet<AndroidKnownReference>) {
+        references += instanceField(
+            "com.samsung.android.knox.SemPersonaManager", "mContext"
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt == 24
+        }
+      }
+    },
+
+    SEM_APP_ICON_SOLUTION {
+      override fun add(references: MutableSet<AndroidKnownReference>) {
+        references += instanceField(
+            "android.app.SemAppIconSolution", "mContext"
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt == 28
+        }
+      }
+    },
+
+    AW_RESOURCE__SRESOURCES {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        // AwResource#setResources() is called with resources that hold a reference to the
+        // activity context (instead of the application context) and doesn't clear it.
+        // Not sure what's going on there, input welcome.
+        references += staticField(
+            "com.android.org.chromium.android_webview.AwResource", "sResources"
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt == 19
+        }
+      }
+    },
+
+    TEXT_VIEW__MLAST_HOVERED_VIEW {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += staticField(
+            "android.widget.TextView", "mLastHoveredView",
+            reason =
+            "mLastHoveredView is a static field in TextView that leaks the last hovered" + " view."
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt in 19..28
+        }
+      }
+    },
+
+    PERSONA_MANAGER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.os.PersonaManager", "mContext",
+            reason =
+            "android.app.LoadedApk.mResources has a reference to"
+                + " android.content.res.Resources.mPersonaManager which has a reference to"
+                + " android.os.PersonaManager.mContext which is an activity."
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt == 19
+        }
+      }
+    },
+
+    RESOURCES__MCONTEXT {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.content.res.Resources", "mContext",
+            reason =
+            "In AOSP the Resources class does not have a context."
+                + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
+                + " instance that has a context that is the activity."
+                + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184"
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt == 19
+        }
+      }
+    },
+
+    VIEW_CONFIGURATION__MCONTEXT {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.view.ViewConfiguration", "mContext",
+            reason =
+            "In AOSP the ViewConfiguration class does not have a context."
+                + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
+                + " ViewConfiguration instance that has a context that is the activity."
+                + " Observed here: https://github.com/square/leakcanary/issues"
+                + "/1#issuecomment-100324683"
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt == 19
+        }
+      }
+    },
+
+    AUDIO_MANAGER__MCONTEXT_STATIC {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += staticField(
+            "android.media.AudioManager", "mContext_static",
+            reason =
+            "Samsung added a static mContext_static field to AudioManager, holds a reference"
+                + " to the activity."
+                + " Observed here: https://github.com/square/leakcanary/issues/32"
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt == 19
+        }
+      }
+    },
+
+    ACTIVITY_MANAGER_MCONTEXT {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += staticField(
+            "android.app.ActivityManager", "mContext",
+            reason =
+            "Samsung added a static mContext field to ActivityManager, holds a reference"
+                + " to the activity."
+                + " Observed here: https://github.com/square/leakcanary/issues/177 Fix in comment:"
+                + " https://github.com/square/leakcanary/issues/177#issuecomment-222724283"
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt in 22..23
+        }
+      }
+    },
+
+    // OTHER MANUFACTURERS
+
+    GESTURE_BOOST_MANAGER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += staticField(
+            "android.gestureboost.GestureBoostManager", "mContext"
+            ,
+            reason =
+            "GestureBoostManager is a static singleton that leaks an activity context." + " Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756"
+        ) { manufacturer, sdkInt ->
+          manufacturer == HUAWEI && sdkInt in 24..25
+        }
+      }
+    },
+
+    BUBBLE_POPUP_HELPER__SHELPER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += staticField(
+            "android.widget.BubblePopupHelper", "sHelper",
+            reason =
+            "A static helper for EditText bubble popups leaks a reference to the latest" + " focused view."
+        ) { manufacturer, sdkInt ->
+          manufacturer == LG && sdkInt in 19..22
+        }
+      }
+    },
+
+    LGCONTEXT__MCONTEXT {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "com.lge.systemservice.core.LGContext", "mContext",
+            reason = "LGContext is a static singleton that leaks an activity context."
+        ) { manufacturer, sdkInt ->
+          manufacturer == LG && sdkInt == 21
+        }
+      }
+    },
+
+    MAPPER_CLIENT {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "com.nvidia.ControllerMapper.MapperClient\$ServiceClient", "this$0"
+            ,
+            reason =
+            "Not sure exactly what ControllerMapper is about, but there is an anonymous"
+                + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
+                + " ControllerMapper.MapperClient which leaks the activity context."
+        ) { manufacturer, sdkInt ->
+          manufacturer == NVIDIA && sdkInt == 19
+        }
+      }
+    },
+
+    SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += staticField(
+            "android.hardware.SystemSensorManager", "mAppContextImpl"
+            ,
+            reason =
+            "SystemSensorManager stores a reference to context"
+                + " in a static field in its constructor."
+                + " Fix: use application context to get SensorManager"
+        ) { manufacturer, sdkInt ->
+          (manufacturer == LENOVO && sdkInt == 19) || (manufacturer == VIVO && sdkInt == 22)
+        }
+      }
+    },
+
+    INSTRUMENTATION_RECOMMEND_ACTIVITY {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += staticField(
+            "android.app.Instrumentation", "mRecommendActivity",
+            reason =
+            "Instrumentation would leak com.android.internal.app.RecommendActivity (in"
+                + " framework.jar) in Meizu FlymeOS 4.5 and above, which is based on Android 5.0 and "
+                + " above"
+        ) { manufacturer, sdkInt ->
+          manufacturer == MEIZU && sdkInt in 21..22
+        }
+      }
+    },
+
+    DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.app.admin.DevicePolicyManager\$SettingsObserver", "this$0"
+            ,
+            reason =
+            "DevicePolicyManager keeps a reference to the context it has been created with"
+                + " instead of extracting the application context. In this Motorola build,"
+                + " DevicePolicyManager has an inner SettingsObserver class that is a content"
+                + " observer, which is held into memory by a binder transport object."
+        ) { manufacturer, sdkInt ->
+          manufacturer == MOTOROLA && sdkInt in 19..22
+        }
+      }
+    },
+
+
+    // ######## General known references (not leaks) ########
+
+    REFERENCES {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            WeakReference::class.java.name, "referent",
+            status = WEAKLY_REACHABLE
+        )
+        references += instanceField(
+            KeyedWeakReference::class.java.name, "referent"
+            ,
+            status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            SoftReference::class.java.name, "referent",
+            status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            PhantomReference::class.java.name, "referent",
+            status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            "java.lang.ref.Finalizer", "prev",
+            status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            "java.lang.ref.Finalizer", "element",
+            status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            "java.lang.ref.Finalizer", "next",
+            status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            "java.lang.ref.FinalizerReference", "prev",
+            status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            "java.lang.ref.FinalizerReference", "element",
+            status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            "java.lang.ref.FinalizerReference", "next",
+            status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            "sun.misc.Cleaner", "prev", status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            "sun.misc.Cleaner", "next", status = NEVER_REACHABLE
+        )
+      }
+    },
+
+    FINALIZER_WATCHDOG_DAEMON {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
+        // reference to the object and it was about to be GCed.
+        references += javaLocal(
+            "FinalizerWatchdogDaemon",
+            status = NEVER_REACHABLE
+        )
+      }
+    },
+
+    MAIN {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        // The main thread stack is ever changing so local variables aren't likely to hold references
+        // for long. If this is on the shortest path, it's probably that there's a longer path with
+        // a real leak.
+        references += javaLocal(
+            "main",
+            status = NEVER_REACHABLE
+        )
+      }
+    },
+
+    LEAK_CANARY_THREAD {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += javaLocal(
+            LEAK_CANARY_THREAD_NAME,
+            status = NEVER_REACHABLE
+        )
+      }
+    },
+
+    EVENT_RECEIVER__MMESSAGE_QUEUE {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
+        // the native peer of the receiver is using them.
+        // The main thread message queue is held on by the main Looper, but that might be a longer
+        // path. Let's not confuse people with a shorter path that is less meaningful.
+        references += instanceField(
+            "android.view.Choreographer\$FrameDisplayEventReceiver",
+            "mMessageQueue"
+            ,
+            status = NEVER_REACHABLE
+        )
+      }
+    },
+
+    ;
+
+    internal abstract fun add(references: MutableSet<AndroidKnownReference>)
+  }
+
+
+}
+
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakTraceInspectors.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakTraceInspectors.kt
new file mode 100644
index 00000000..6c08e69d
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakTraceInspectors.kt
@@ -0,0 +1,455 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import leakcanary.GraphObjectRecord.GraphClassRecord
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
+import kotlin.reflect.KClass
+
+/**
+ * A set of default [LeakInspector]s that knows about common AOSP and library
+ * classes.
+ *
+ * These are heuristics based on our experience and knowledge of AOSP and various library
+ * internals. We only make a decision if we're reasonably sure the state of an object is
+ * unlikely to be the result of a programmer mistake.
+ *
+ * For example, no matter how many mistakes we make in our code, the value of Activity.mDestroy
+ * will not be influenced by those mistakes.
+ */
+enum class AndroidLeakTraceInspectors : LeakTraceInspector {
+
+  VIEW {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.view.View") { instance ->
+        // This skips edge cases like Toast$TN.mNextView holding on to an unattached and unparented
+        // next toast view
+        val mParentRef = instance["android.view.View", "mParent"]!!.value
+        val mParentSet = mParentRef.isNonNullReference
+        val viewDetached = instance["android.view.View", "mAttachInfo"]!!.value.isNullReference
+
+        if (mParentSet) {
+          if (viewDetached) {
+            reportLeaking("View detached and has parent")
+          } else {
+            val viewParent = mParentRef.asObject!!.asInstance!!
+            if (viewParent instanceOf "android.view.View" &&
+                viewParent["android.view.View", "mAttachInfo"]!!.value.isNullReference) {
+              reportLeaking("View attached but parent detached (attach disorder)")
+            } else {
+              reportNotLeaking("View attached")
+            }
+          }
+        }
+
+        if (mParentSet) {
+          addLabel("View#mParent is set")
+        } else {
+          addLabel("View#mParent is null")
+        }
+
+        if (viewDetached) {
+          addLabel("View#mAttachInfo is null (view detached)")
+        } else {
+          addLabel("View#mAttachInfo is not null (view attached)")
+        }
+
+        // TODO Add back support for view id labels, see https://github.com/square/leakcanary/issues/1297
+
+        val mWindowAttachCount = instance["android.view.View", "mWindowAttachCount"]?.value?.asInt
+
+        if (mWindowAttachCount != null) {
+          addLabel("View.mWindowAttachCount=$mWindowAttachCount")
+        }
+      }
+    }
+  },
+
+  ACTIVITY {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.app.Activity") { instance ->
+        // Activity.mDestroyed was introduced in 17.
+        // https://android.googlesource.com/platform/frameworks/base/+
+        // /6d9dcbccec126d9b87ab6587e686e28b87e5a04d
+        val field = instance["android.app.Activity", "mDestroyed"]
+
+        if (field != null) {
+          if (field.value.asBoolean!!) {
+            reportLeaking(field describedWithValue "true")
+          } else {
+            reportNotLeaking(field describedWithValue "false")
+          }
+        }
+      }
+    }
+  },
+
+  CONTEXT_WRAPPER {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.content.ContextWrapper") { instance ->
+        // Activity is already taken care of
+        if (!(instance instanceOf "android.app.Activity")) {
+          var context = instance
+
+          val visitedInstances = mutableListOf<Long>()
+          var keepUnwrapping = true
+          while (keepUnwrapping) {
+            visitedInstances += context.objectId
+            keepUnwrapping = false
+            val mBase = context["android.content.ContextWrapper", "mBase"]!!.value
+
+            if (mBase.isNonNullReference) {
+              context = mBase.asObject!!.asInstance!!
+              if (context instanceOf "android.app.Activity") {
+                val mDestroyed = instance["android.app.Activity", "mDestroyed"]
+                if (mDestroyed != null) {
+                  if (mDestroyed.value.asBoolean!!) {
+                    reportLeaking(
+                        "${instance.classSimpleName} wraps an Activity with Activity.mDestroyed true"
+                    )
+                  } else {
+                    // We can't assume it's not leaking, because this context might have a shorter lifecycle
+                    // than the activity. So we'll just add a label.
+                    addLabel("${instance.classSimpleName} wraps an Activity with Activity.mDestroyed false")
+                  }
+                }
+              } else if (context instanceOf "android.content.ContextWrapper" &&
+                  // Avoids infinite loops
+                  context.objectId !in visitedInstances
+              ) {
+                keepUnwrapping = true
+              }
+            }
+          }
+        }
+      }
+    }
+  },
+
+  DIALOG {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.app.Dialog") { instance ->
+        val mDecor = instance["android.app.Dialog", "mDecor"]!!
+        if (mDecor.value.isNullReference) {
+          reportLeaking(mDecor describedWithValue "null")
+        } else {
+          reportNotLeaking(mDecor describedWithValue "not null")
+        }
+      }
+    }
+  },
+
+  APPLICATION {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.app.Application") {
+        reportNotLeaking("Application is a singleton")
+      }
+    }
+  },
+
+  INPUT_METHOD_MANAGER {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.view.inputmethod.InputMethodManager") {
+        reportNotLeaking("InputMethodManager is a singleton")
+      }
+    }
+  },
+
+  CLASSLOADER {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf(ClassLoader::class) {
+        reportNotLeaking("A ClassLoader is never leaking")
+      }
+    }
+  },
+
+  CLASS {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEach { reporter ->
+        if (reporter.objectRecord is GraphClassRecord) {
+          reporter.reportNotLeaking("a class is never leaking")
+        }
+      }
+    }
+  },
+
+  FRAGMENT {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.app.Fragment") { instance ->
+        val fragmentManager = instance["android.app.Fragment", "mFragmentManager"]!!
+        if (fragmentManager.value.isNullReference) {
+          reportLeaking(fragmentManager describedWithValue "null")
+        } else {
+          reportNotLeaking(fragmentManager describedWithValue "not null")
+        }
+        val mTag = instance["android.app.Fragment", "mTag"]?.value?.readAsJavaString()
+        if (!mTag.isNullOrEmpty()) {
+          addLabel("Fragment.mTag=$mTag")
+        }
+      }
+    }
+  },
+
+  SUPPORT_FRAGMENT {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.support.v4.app.Fragment") { instance ->
+        val fragmentManager = instance["android.support.v4.app.Fragment", "mFragmentManager"]!!
+        if (fragmentManager.value.isNullReference) {
+          reportLeaking(fragmentManager describedWithValue "null")
+        } else {
+          reportNotLeaking(fragmentManager describedWithValue "not null")
+        }
+        val mTag = instance["android.support.v4.app.Fragment", "mTag"]?.value?.readAsJavaString()
+        if (!mTag.isNullOrEmpty()) {
+          addLabel("Fragment.mTag=$mTag")
+        }
+      }
+    }
+  },
+
+  ANDROIDX_FRAGMENT {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("androidx.fragment.app.Fragment") { instance ->
+        val fragmentManager = instance["androidx.fragment.app.Fragment", "mFragmentManager"]!!
+        if (fragmentManager.value.isNullReference) {
+          reportLeaking(fragmentManager describedWithValue "null")
+        } else {
+          reportNotLeaking(fragmentManager describedWithValue "not null")
+        }
+        val mTag = instance["androidx.fragment.app.Fragment", "mTag"]?.value?.readAsJavaString()
+        if (!mTag.isNullOrEmpty()) {
+          addLabel("Fragment.mTag=$mTag")
+        }
+      }
+    }
+  },
+
+  MESSAGE_QUEUE {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.os.MessageQueue") { instance ->
+        val mQuitting = instance["android.os.MessageQueue", "mQuitting"]!!
+        if (mQuitting.value.asBoolean!!) {
+          reportLeaking(mQuitting describedWithValue "true")
+        } else {
+          reportNotLeaking(mQuitting describedWithValue "false")
+        }
+      }
+    }
+  },
+
+  MORTAR_PRESENTER {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("mortar.Presenter") { instance ->
+        // Bugs in view code tends to cause Mortar presenters to still have a view when they actually
+        // should be unreachable, so in that case we don't know their reachability status. However,
+        // when the view is null, we're pretty sure they  never leaking.
+        val view = instance["mortar.Presenter", "view"]!!
+        if (view.value.isNullReference) {
+          reportLeaking(view describedWithValue "null")
+        }
+      }
+    }
+  },
+
+  COORDINATOR {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("com.squareup.coordinators.Coordinator") { instance ->
+        val attached = instance["com.squareup.coordinators.Coordinator", "attached"]
+        if (attached!!.value.asBoolean!!) {
+          reportNotLeaking(attached describedWithValue "true")
+        } else {
+          reportLeaking(attached describedWithValue "false")
+        }
+      }
+    }
+  },
+
+  ANONYMOUS_CLASS {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEach { reporter ->
+        if (reporter.objectRecord is GraphInstanceRecord) {
+          val classRecord = reporter.objectRecord.instanceClass
+          if (classRecord.name.matches(HeapAnalyzer.ANONYMOUS_CLASS_NAME_PATTERN_REGEX)) {
+            val parentClassRecord = classRecord.superClass!!
+            if (parentClassRecord.name == "java.lang.Object") {
+              try {
+                // This is an anonymous class implementing an interface. The API does not give access
+                // to the interfaces implemented by the class. We check if it's in the class path and
+                // use that instead.
+                val actualClass = Class.forName(classRecord.name)
+                val interfaces = actualClass.interfaces
+                reporter.addLabel(
+                    if (interfaces.isNotEmpty()) {
+                      val implementedInterface = interfaces[0]
+                      "Anonymous class implementing ${implementedInterface.name}"
+                    } else {
+                      "Anonymous subclass of java.lang.Object"
+                    }
+                )
+              } catch (ignored: ClassNotFoundException) {
+              }
+            } else {
+              // Makes it easier to figure out which anonymous class we're looking at.
+              reporter.addLabel("Anonymous subclass of ${parentClassRecord.name}")
+            }
+          }
+        }
+      }
+    }
+  },
+
+  THREAD {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf(Thread::class) { instance ->
+        val threadName = instance[Thread::class, "name"]!!.value.readAsJavaString()
+        if (threadName == "main") {
+          reportNotLeaking("the main thread always runs")
+        }
+        addLabel("Thread name: '$threadName'")
+      }
+    }
+  },
+
+  WINDOW {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.view.Window") { instance ->
+        val mDestroyed = instance["android.view.Window", "mDestroyed"]!!
+
+        if (mDestroyed.value.asBoolean!!) {
+          reportLeaking(mDestroyed describedWithValue "true")
+        } else {
+          reportNotLeaking(mDestroyed describedWithValue "false")
+        }
+      }
+    }
+  },
+
+  TOAST {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.widget.Toast") { instance ->
+        val tnInstance =
+          instance["android.widget.Toast", "mTN"]!!.value.asObject!!.asInstance!!
+        // mWM is set in android.widget.Toast.TN#handleShow and never unset, so this toast was never
+        // shown, we don't know if it's leaking.
+        if (tnInstance["android.widget.Toast\$TN", "mWM"]!!.value.isNonNullReference) {
+          // mView is reset to null in android.widget.Toast.TN#handleHide
+          if (tnInstance["android.widget.Toast\$TN", "mView"]!!.value.isNullReference) {
+            reportLeaking(
+                "This toast is done showing (Toast.mTN.mWM != null && Toast.mTN.mView == null)"
+            )
+          } else {
+            reportNotLeaking(
+                "This toast is showing (Toast.mTN.mWM != null && Toast.mTN.mView != null)"
+            )
+          }
+        }
+      }
+    }
+  },
+
+  TOAST_TN {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.widget.Toast\$TN") {
+        reportNotLeaking("Toast.TN (Transient Notification) is never leaking")
+      }
+    }
+  };
+
+  companion object {
+    fun defaultInspectors(): List<LeakTraceInspector> {
+      return values().toList()
+    }
+  }
+}
+
+private infix fun GraphField.describedWithValue(valueDescription: String): String {
+  return "${classRecord.simpleName}#$name is $valueDescription"
+}
+
+inline fun List<LeakTraceElementReporter>.forEachInstanceOf(
+  expectedClass: KClass<out Any>,
+  action: LeakTraceElementReporter.(GraphInstanceRecord) -> Unit
+) {
+  forEachInstanceOf(expectedClass.java.name, action)
+}
+
+inline fun List<LeakTraceElementReporter>.forEachInstanceOf(
+  className: String,
+  action: LeakTraceElementReporter.(GraphInstanceRecord) -> Unit
+) {
+  for (reporter in this) {
+    if (reporter.objectRecord is GraphInstanceRecord && reporter.objectRecord instanceOf className) {
+      reporter.action(reporter.objectRecord)
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AppSingletonInspector.kt b/leakcanary-analyzer/src/main/java/leakcanary/AppSingletonInspector.kt
new file mode 100644
index 00000000..bc2ab18d
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AppSingletonInspector.kt
@@ -0,0 +1,26 @@
+package leakcanary
+
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
+
+/**
+ * Inspector that automatically marks instances of the provided class names as not leaking
+ * because they're app wide singletons.
+ */
+class AppSingletonInspector(private vararg val singletonClasses: String) : LeakTraceInspector {
+  override fun inspect(
+    graph: HprofGraph,
+    leakTrace: List<LeakTraceElementReporter>
+  ) {
+    leakTrace.forEach { reporter ->
+      if (reporter.objectRecord is GraphInstanceRecord) {
+        reporter.objectRecord.instanceClass
+            .classHierarchy
+            .forEach { classRecord ->
+              if (classRecord.name in singletonClasses) {
+                reporter.reportNotLeaking("${classRecord.name} is an app singleton")
+              }
+            }
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/BuildMirror.kt b/leakcanary-analyzer/src/main/java/leakcanary/BuildMirror.kt
new file mode 100644
index 00000000..3cdfab9c
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/BuildMirror.kt
@@ -0,0 +1,24 @@
+package leakcanary
+
+import kotlin.properties.Delegates.notNull
+
+/**
+ * Turns BuildFilter into exclusion filters that HeapAnalyzer understand. Since retrieving from
+ * the Hprof is not free, [BuildMirror] provides a caching mechanism. Make sure to use different
+ * [BuildMirror] and set of filters for every hprof parsing.
+ */
+class BuildMirror {
+
+  lateinit var manufacturer: String
+  var sdkInt: Int by notNull()
+
+  fun wrapFilter(filter: BuildFilter): (HprofGraph) -> Boolean = { graph ->
+    if (!::manufacturer.isInitialized) {
+      val buildClass = graph.indexedClass("android.os.Build")!!
+      val versionClass = graph.indexedClass("android.os.Build\$VERSION")!!
+      manufacturer = buildClass["MANUFACTURER"]!!.value.readAsJavaString()!!
+      sdkInt = versionClass["SDK_INT"]!!.value.asInt!!
+    }
+    filter(manufacturer, sdkInt)
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt b/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt
new file mode 100644
index 00000000..d949e1b8
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt
@@ -0,0 +1,89 @@
+package leakcanary
+
+import leakcanary.Exclusion.Status.WONT_FIX_LEAK
+import java.io.Serializable
+
+/**
+ * Deprioritizes specific references from being taken into account when computing the shortest strong
+ * reference path from a suspected leaking instance to the GC roots.
+ *
+ * This class lets you ignore known memory leaks that you known about. If the shortest path
+ * matches [Exclusion], than the heap analyzer should look for a longer path with nothing
+ * matching in [Exclusion].
+ *
+ * Exclusions should be used to match patterns of known leaks that are beyond your control, for
+ * examples leaks in the Android Framework or in 3rd party libraries. This won't fix the leaks,
+ * and LeakCanary will still trigger, but at least it'll indicate that there's nothing you can do
+ * about it.
+ */
+data class Exclusion(
+  val type: ExclusionType,
+  val reason: String? = null,
+  val status: Status = WONT_FIX_LEAK,
+  val filter: (HprofGraph) -> Boolean = {true}
+) {
+  val description
+    get() = ExclusionDescription(type.matching, reason)
+
+  // Note: the enum order matters for shortest paths, do not reorder
+  enum class Status {
+    /**
+     * References matching this cannot create leaks.
+     * The shortest path finder will never go through references that match this exclusion.
+     */
+    NEVER_REACHABLE,
+    /**
+     * References matching this are known to create leaks, but those leaks will not be fixed.
+     * The shortest path finder will only go through references that match this exclusion after it
+     * has exhausted references that don't match any exclusion.
+     */
+    WONT_FIX_LEAK,
+    /**
+     * The shortest path finder will only go through references that match this exclusion after it
+     * has exhausted references that match known leak exclusions.
+     */
+    WEAKLY_REACHABLE
+  }
+
+  sealed class ExclusionType {
+    abstract val matching: String
+
+    /**
+     * Local references held in the stack of frames of a given thread.
+     */
+    class JavaLocalExclusion(
+      val threadName: String
+    ) : ExclusionType() {
+      override val matching: String
+        get() = "local variable on thread $threadName"
+    }
+
+    class StaticFieldExclusion(
+      val className: String,
+      val fieldName: String
+    ) : ExclusionType() {
+      override val matching: String
+        get() = "static field $className#$fieldName"
+    }
+
+    /**
+     * Excludes a member field of an instance of a class. [fieldName] can belong to a superclass
+     * and will still match for subclasses. This is to support overriding of rules for specific
+     * cases. If two exclusions for the same field name but different classname match in a class
+     * hierarchy, then the closest class in the hierarchy wins.
+     */
+    class InstanceFieldExclusion(
+      val className: String,
+      val fieldName: String
+    ) : ExclusionType() {
+      override val matching: String
+        get() = "field $className#$fieldName"
+    }
+  }
+
+}
+
+class ExclusionDescription(
+  val matching: String,
+  val reason: String? = null
+) : Serializable
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
new file mode 100644
index 00000000..442b6f4d
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
@@ -0,0 +1,121 @@
+package leakcanary
+
+import leakcanary.Exclusion.Status.WONT_FIX_LEAK
+import leakcanary.internal.createSHA1Hash
+import java.io.File
+import java.io.Serializable
+
+sealed class HeapAnalysis : Serializable {
+  abstract val heapDumpFile: File
+  abstract val createdAtTimeMillis: Long
+  /** Total time spent analyzing the heap.  */
+  abstract val analysisDurationMillis: Long
+}
+
+data class HeapAnalysisFailure(
+  override val heapDumpFile: File,
+  override val createdAtTimeMillis: Long,
+  override val analysisDurationMillis: Long,
+  val exception: HeapAnalysisException
+) : HeapAnalysis()
+
+data class HeapAnalysisSuccess(
+  override val heapDumpFile: File,
+  override val createdAtTimeMillis: Long,
+  override val analysisDurationMillis: Long,
+  val retainedInstances: List<RetainedInstance>
+) : HeapAnalysis()
+
+sealed class RetainedInstance : Serializable {
+  /**
+   * Key associated to the [leakcanary.KeyedWeakReference] used to detect the memory leak.
+   * When analyzing a heap dump manually, search for all [leakcanary.KeyedWeakReference] instances,
+   * then open the one that has its "key" field set to this value. Its "referent" field contains the
+   * retained instance. Computing the shortest path to GC roots on that retained instance should
+   * enable you to figure out the cause of the leak, if any.
+   */
+  abstract val referenceKey: String
+  /**
+   * User defined name to help identify the retained instance.
+   */
+  abstract val referenceName: String
+  /**
+   * Class name of the retained instance.
+   * The class name format is the same as what would be returned by [Class.getName].
+   */
+  abstract val instanceClassName: String
+  /**
+   * Time from the request to watch the reference until the heap was dumped.
+   */
+  abstract val watchDurationMillis: Long
+  /**
+   * Time from when the instance was considered retained until the heap was dumped.
+   */
+  abstract val retainedDurationMillis: Long
+}
+
+data class NoPathToInstance(
+  override val referenceKey: String,
+  override val referenceName: String,
+  override val instanceClassName: String,
+  override val watchDurationMillis: Long,
+  override val retainedDurationMillis: Long
+) : RetainedInstance()
+
+data class LeakingInstance(
+  override val referenceKey: String,
+  override val referenceName: String,
+  override val instanceClassName: String,
+  override val watchDurationMillis: Long,
+  override val retainedDurationMillis: Long,
+
+  /**
+   * True if the only path to the leaking reference is through excluded references. Usually, that
+   * means you can safely ignore this report.
+   */
+  val exclusionStatus: Exclusion.Status?,
+  /**
+   * Shortest path to GC roots for the leaking instance.
+   */
+  val leakTrace: LeakTrace,
+  /**
+   * The number of bytes which would be freed if all references to the leaking object were
+   * released. Null if the retained heap size was not computed.
+   */
+  val retainedHeapSize: Int?
+
+) : RetainedInstance() {
+
+  val groupHash = createGroupHash()
+
+  val instanceClassSimpleName: String
+    get() {
+      val separator = instanceClassName.lastIndexOf('.')
+      return if (separator == -1) instanceClassName else instanceClassName.substring(separator + 1)
+    }
+
+  private fun createGroupHash(): String {
+    val uniqueString = if (exclusionStatus == WONT_FIX_LEAK) {
+      leakTrace.firstElementExclusion.matching
+    } else {
+      leakTrace.leakCauses
+          .joinToString(separator = "") { element ->
+            val referenceName = element.reference!!.groupingName
+            element.className + referenceName
+          }
+    }
+    return uniqueString.createSHA1Hash()
+  }
+}
+
+fun HeapAnalysis.leakingInstances(): List<LeakingInstance> {
+  if (this is HeapAnalysisFailure) {
+    return emptyList()
+  }
+  val success = this as HeapAnalysisSuccess
+  return success.retainedInstances.filter { it is LeakingInstance }
+      .map { it as LeakingInstance }
+}
+
+fun HeapAnalysis.applicationLeaks(): List<LeakingInstance> =
+  leakingInstances().filter { it.exclusionStatus == null }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysisException.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysisException.kt
new file mode 100644
index 00000000..313fafde
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysisException.kt
@@ -0,0 +1,13 @@
+package leakcanary
+
+import java.io.PrintWriter
+import java.io.StringWriter
+
+class HeapAnalysisException(cause: Throwable) : RuntimeException(cause) {
+
+  override fun toString(): String {
+    val stringWriter = StringWriter()
+    cause!!.printStackTrace(PrintWriter(stringWriter))
+    return "\n$stringWriter\n"
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
new file mode 100644
index 00000000..b1a14d8d
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
@@ -0,0 +1,619 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import leakcanary.AnalyzerProgressListener.Step.BUILDING_LEAK_TRACES
+import leakcanary.AnalyzerProgressListener.Step.COMPUTING_NATIVE_RETAINED_SIZE
+import leakcanary.AnalyzerProgressListener.Step.COMPUTING_RETAINED_SIZE
+import leakcanary.AnalyzerProgressListener.Step.FINDING_WATCHED_REFERENCES
+import leakcanary.AnalyzerProgressListener.Step.READING_HEAP_DUMP_FILE
+import leakcanary.AnalyzerProgressListener.Step.SCANNING_HEAP_DUMP
+import leakcanary.GcRoot.JavaFrame
+import leakcanary.GcRoot.JniGlobal
+import leakcanary.GcRoot.JniLocal
+import leakcanary.GcRoot.JniMonitor
+import leakcanary.GcRoot.MonitorUsed
+import leakcanary.GcRoot.NativeStack
+import leakcanary.GcRoot.ReferenceCleanup
+import leakcanary.GcRoot.StickyClass
+import leakcanary.GcRoot.ThreadBlock
+import leakcanary.GcRoot.ThreadObject
+import leakcanary.GraphObjectRecord.GraphClassRecord
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
+import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
+import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
+import leakcanary.HprofPushRecordsParser.OnRecordListener
+import leakcanary.LeakNode.ChildNode
+import leakcanary.LeakNodeStatus.LEAKING
+import leakcanary.LeakNodeStatus.NOT_LEAKING
+import leakcanary.LeakNodeStatus.UNKNOWN
+import leakcanary.LeakTraceElement.Holder.ARRAY
+import leakcanary.LeakTraceElement.Holder.CLASS
+import leakcanary.LeakTraceElement.Holder.OBJECT
+import leakcanary.LeakTraceElement.Holder.THREAD
+import leakcanary.PrimitiveType.BOOLEAN
+import leakcanary.PrimitiveType.BYTE
+import leakcanary.PrimitiveType.CHAR
+import leakcanary.PrimitiveType.DOUBLE
+import leakcanary.PrimitiveType.FLOAT
+import leakcanary.PrimitiveType.INT
+import leakcanary.PrimitiveType.LONG
+import leakcanary.PrimitiveType.SHORT
+import leakcanary.Record.HeapDumpRecord.GcRootRecord
+import leakcanary.internal.KeyedWeakReferenceMirror
+import leakcanary.internal.ShortestPathFinder
+import leakcanary.internal.ShortestPathFinder.Result
+import leakcanary.internal.ShortestPathFinder.Results
+import leakcanary.internal.hppc.LongLongScatterMap
+import leakcanary.internal.lastSegment
+import java.io.Closeable
+import java.io.File
+import java.util.ArrayList
+import java.util.LinkedHashMap
+import java.util.concurrent.TimeUnit.NANOSECONDS
+import kotlin.reflect.KClass
+
+/**
+ * Analyzes heap dumps to look for leaks.
+ */
+class HeapAnalyzer constructor(
+  private val listener: AnalyzerProgressListener
+) {
+
+  /**
+   * Searches the heap dump for a [KeyedWeakReference] instance with the corresponding key,
+   * and then computes the shortest strong reference path from that instance to the GC roots.
+   */
+  fun checkForLeaks(
+    heapDumpFile: File,
+    exclusions: List<Exclusion> = emptyList(),
+    computeRetainedHeapSize: Boolean = false,
+    leakTraceInspectors: List<LeakTraceInspector> = emptyList()
+  ): HeapAnalysis {
+    val analysisStartNanoTime = System.nanoTime()
+
+    if (!heapDumpFile.exists()) {
+      val exception = IllegalArgumentException("File does not exist: $heapDumpFile")
+      return HeapAnalysisFailure(
+          heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
+          HeapAnalysisException(exception)
+      )
+    }
+
+    listener.onProgressUpdate(READING_HEAP_DUMP_FILE)
+
+    try {
+      listener.onProgressUpdate(SCANNING_HEAP_DUMP)
+      val (graph, hprofCloseable, gcRootIds, keyedWeakReferenceInstances, cleaners) = scan(
+          heapDumpFile, computeRetainedHeapSize
+      )
+      hprofCloseable.use {
+        val analysisResults = mutableMapOf<String, RetainedInstance>()
+        listener.onProgressUpdate(FINDING_WATCHED_REFERENCES)
+
+        val retainedWeakRefs = findLeakingReferences(graph, keyedWeakReferenceInstances)
+
+        if (retainedWeakRefs.isEmpty()) {
+          val exception = IllegalStateException("No retained instances found in heap dump")
+          return HeapAnalysisFailure(
+              heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
+              HeapAnalysisException(exception)
+          )
+        }
+
+        val (pathResults, dominatedInstances) =
+          findShortestPaths(
+              graph, exclusions, retainedWeakRefs, gcRootIds,
+              computeRetainedHeapSize
+          )
+
+        val retainedSizes = if (computeRetainedHeapSize) {
+          computeRetainedSizes(graph, pathResults, dominatedInstances, cleaners)
+        } else {
+          null
+        }
+
+        buildLeakTraces(
+            leakTraceInspectors, pathResults, graph,
+            retainedWeakRefs, analysisResults, retainedSizes
+        )
+
+        addRemainingInstancesWithNoPath(retainedWeakRefs, analysisResults)
+
+        return HeapAnalysisSuccess(
+            heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
+            analysisResults.values.toList()
+        )
+      }
+    } catch (exception: Throwable) {
+      return HeapAnalysisFailure(
+          heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
+          HeapAnalysisException(exception)
+      )
+    }
+  }
+
+  private data class ScanResult(
+    val graph: HprofGraph,
+    val hprofCloseable: Closeable,
+    val gcRootIds: MutableList<GcRoot>,
+    val keyedWeakReferenceInstances: List<GraphInstanceRecord>,
+    val cleaners: MutableList<Long>
+  )
+
+  private fun scan(
+    hprofFile: File,
+    computeRetainedSize: Boolean
+  ): ScanResult {
+    val gcRoot = mutableListOf<GcRoot>()
+    val cleaners = mutableListOf<Long>()
+
+    val recordListener = object : OnRecordListener {
+      override fun recordTypes(): Set<KClass<out Record>> = setOf(GcRootRecord::class)
+
+      override fun onTypeSizesAvailable(typeSizes: Map<Int, Int>) {
+      }
+
+      override fun onRecord(
+        position: Long,
+        record: Record
+      ) {
+        when (record) {
+          is GcRootRecord -> {
+            // TODO Ignoring VmInternal because we've got 150K of it, but is this the right thing
+            // to do? What's VmInternal exactly? History does not go further than
+            // https://android.googlesource.com/platform/dalvik2/+/refs/heads/master/hit/src/com/android/hit/HprofParser.java#77
+            // We should log to figure out what objects VmInternal points to.
+            when (record.gcRoot) {
+              // ThreadObject points to threads, which we need to find the thread that a JavaLocalExclusion
+              // belongs to
+              is ThreadObject,
+              is JniGlobal,
+              is JniLocal,
+              is JavaFrame,
+              is NativeStack,
+              is StickyClass,
+              is ThreadBlock,
+              is MonitorUsed,
+                // TODO What is this and why do we care about it as a root?
+              is ReferenceCleanup,
+              is JniMonitor
+              -> {
+                gcRoot.add(record.gcRoot)
+              }
+            }
+          }
+          else -> {
+            throw IllegalArgumentException("Unexpected record $record")
+          }
+        }
+      }
+    }
+    val (graph, hprofCloseable) = HprofGraph.readHprof(hprofFile, recordListener)
+
+    val keyedWeakReferenceInstances = mutableListOf<GraphInstanceRecord>()
+    graph.instanceSequence()
+        .forEach { instance ->
+          val className = instance.className
+          if (className == "leakcanary.KeyedWeakReference" || className == "com.squareup.leakcanary.KeyedWeakReference") {
+            keyedWeakReferenceInstances.add(instance)
+          } else if (computeRetainedSize && className == "sun.misc.Cleaner") {
+            cleaners.add(instance.objectId)
+          }
+        }
+    return ScanResult(graph, hprofCloseable, gcRoot, keyedWeakReferenceInstances, cleaners)
+  }
+
+  private fun findLeakingReferences(
+    graph: HprofGraph,
+    keyedWeakReferenceInstances: List<GraphInstanceRecord>
+  ): MutableList<KeyedWeakReferenceMirror> {
+
+    val keyedWeakReferenceClass = graph.indexedClass(KeyedWeakReference::class.java.name)
+
+    val heapDumpUptimeMillis = if (keyedWeakReferenceClass == null) {
+      null
+    } else {
+      keyedWeakReferenceClass["heapDumpUptimeMillis"]?.value?.asLong
+    }
+
+    if (heapDumpUptimeMillis == null) {
+      CanaryLog.d(
+          "${KeyedWeakReference::class.java.name}.heapDumpUptimeMillis field not found, " +
+              "this must be a heap dump from an older version of LeakCanary."
+      )
+    }
+
+    val retainedInstances = mutableListOf<KeyedWeakReferenceMirror>()
+    keyedWeakReferenceInstances.forEach { record ->
+      val weakRef =
+        KeyedWeakReferenceMirror.fromInstance(record, heapDumpUptimeMillis)
+      if (weakRef.isRetained && weakRef.hasReferent) {
+        retainedInstances.add(weakRef)
+      }
+    }
+    return retainedInstances
+  }
+
+  private fun findShortestPaths(
+    graph: HprofGraph,
+    exclusions: List<Exclusion>,
+    leakingWeakRefs: List<KeyedWeakReferenceMirror>,
+    gcRootIds: MutableList<GcRoot>,
+    computeDominators: Boolean
+  ): Results {
+    val pathFinder = ShortestPathFinder()
+    return pathFinder.findPaths(
+        graph, exclusions, leakingWeakRefs, gcRootIds, computeDominators, listener
+    )
+  }
+
+  private fun computeRetainedSizes(
+    graph: HprofGraph,
+    results: List<Result>,
+    dominatedInstances: LongLongScatterMap,
+    cleaners: MutableList<Long>
+  ): List<Int> {
+    listener.onProgressUpdate(COMPUTING_NATIVE_RETAINED_SIZE)
+
+    // Map of Object id to native size as tracked by NativeAllocationRegistry$CleanerThunk
+    val nativeSizes = mutableMapOf<Long, Int>().withDefault { 0 }
+    // Doc from perflib:
+    // Native allocations can be identified by looking at instances of
+    // libcore.util.NativeAllocationRegistry$CleanerThunk. The "owning" Java object is the
+    // "referent" field of the "sun.misc.Cleaner" instance with a hard reference to the
+    // CleanerThunk.
+    //
+    // The size is in the 'size' field of the libcore.util.NativeAllocationRegistry instance
+    // that the CleanerThunk has a pointer to. The native pointer is in the 'nativePtr' field of
+    // the CleanerThunk. The hprof does not include the native bytes pointed to.
+
+    cleaners.forEach { objectId ->
+      val cleaner = graph.indexedObject(objectId).asInstance!!
+      val thunkField = cleaner["sun.misc.Cleaner", "thunk"]
+      val thunkId = thunkField?.value?.asNonNullObjectIdReference
+      val referentId =
+        cleaner["java.lang.ref.Reference", "referent"]?.value?.asNonNullObjectIdReference
+      if (thunkId != null && referentId != null) {
+        val thunkRecord = thunkField.value.asObject
+        if (thunkRecord is GraphInstanceRecord && thunkRecord instanceOf "libcore.util.NativeAllocationRegistry\$CleanerThunk") {
+          val allocationRegistryIdField =
+            thunkRecord["libcore.util.NativeAllocationRegistry\$CleanerThunk", "this\$0"]
+          if (allocationRegistryIdField != null && allocationRegistryIdField.value.isNonNullReference) {
+            val allocationRegistryRecord = allocationRegistryIdField.value.asObject
+            if (allocationRegistryRecord is GraphInstanceRecord && allocationRegistryRecord instanceOf "libcore.util.NativeAllocationRegistry") {
+              var nativeSize = nativeSizes.getValue(referentId)
+              nativeSize += allocationRegistryRecord["libcore.util.NativeAllocationRegistry", "size"]?.value?.asLong?.toInt()
+                  ?: 0
+              nativeSizes[referentId] = nativeSize
+            }
+          }
+        }
+      }
+    }
+
+    listener.onProgressUpdate(COMPUTING_RETAINED_SIZE)
+
+    val sizeByDominator = LinkedHashMap<Long, Int>().withDefault { 0 }
+
+    // Include self size for leaking instances
+    val leakingInstanceIds = mutableSetOf<Long>()
+    results.forEach { result ->
+      val leakingInstanceId = result.weakReference.referent.value
+      leakingInstanceIds.add(leakingInstanceId)
+      val instanceRecord = graph.indexedObject(leakingInstanceId).asInstance!!
+      val classRecord = instanceRecord.instanceClass
+      var retainedSize = sizeByDominator.getValue(leakingInstanceId)
+
+      retainedSize += classRecord.readRecord()
+          .instanceSize
+      sizeByDominator[leakingInstanceId] = retainedSize
+    }
+
+    // Compute the size of each dominated instance and add to dominator
+    dominatedInstances.forEach { instanceId, dominatorId ->
+      // Avoid double reporting as those sizes will move up to the root dominator
+      if (instanceId !in leakingInstanceIds) {
+        val currentSize = sizeByDominator.getValue(dominatorId)
+        val nativeSize = nativeSizes.getValue(instanceId)
+        val shallowSize = graph.computeShallowSize(graph.indexedObject(instanceId))
+        sizeByDominator[dominatorId] = currentSize + nativeSize + shallowSize
+      }
+    }
+
+    // Move retained sizes from dominated leaking instance to dominators leaking instances.
+    // Keep doing this until nothing moves.
+    var sizedMoved: Boolean
+    do {
+      sizedMoved = false
+      results.map { it.weakReference.referent.value }
+          .forEach { leakingInstanceId ->
+            val dominator = dominatedInstances[leakingInstanceId]
+            if (dominator != null) {
+              val retainedSize = sizeByDominator.getValue(leakingInstanceId)
+              if (retainedSize > 0) {
+                sizeByDominator[leakingInstanceId] = 0
+                val dominatorRetainedSize = sizeByDominator.getValue(dominator)
+                sizeByDominator[dominator] = retainedSize + dominatorRetainedSize
+                sizedMoved = true
+              }
+            }
+          }
+    } while (sizedMoved)
+    dominatedInstances.release()
+    return results.map { result ->
+      sizeByDominator[result.weakReference.referent.value]!!
+    }
+  }
+
+  private fun buildLeakTraces(
+    leakTraceInspectors: List<LeakTraceInspector>,
+    pathResults: List<Result>,
+    graph: HprofGraph,
+    leakingWeakRefs: MutableList<KeyedWeakReferenceMirror>,
+    analysisResults: MutableMap<String, RetainedInstance>,
+    retainedSizes: List<Int>?
+  ) {
+    listener.onProgressUpdate(BUILDING_LEAK_TRACES)
+
+    pathResults.forEachIndexed { index, pathResult ->
+      val weakReference = pathResult.weakReference
+      val removed = leakingWeakRefs.remove(weakReference)
+      if (!removed) {
+        throw IllegalStateException(
+            "ShortestPathFinder found an instance we didn't ask it to find: $pathResult"
+        )
+      }
+
+      val leakTrace =
+        buildLeakTrace(graph, leakTraceInspectors, pathResult.leakingNode)
+
+      // We get the class name from the heap dump rather than the weak reference because primitive
+      // arrays are more readable that way, e.g. "[C" at runtime vs "char[]" in the heap dump.
+      val instanceClassName =
+        recordClassName(graph.indexedObject(pathResult.leakingNode.instance))
+
+      val leakDetected = LeakingInstance(
+          referenceKey = weakReference.key,
+          referenceName = weakReference.name,
+          instanceClassName = instanceClassName,
+          watchDurationMillis = weakReference.watchDurationMillis,
+          retainedDurationMillis = weakReference.retainedDurationMillis ?: 0,
+          exclusionStatus = pathResult.exclusionStatus, leakTrace = leakTrace,
+          retainedHeapSize = retainedSizes?.get(index)
+      )
+      analysisResults[weakReference.key] = leakDetected
+    }
+  }
+
+  private fun addRemainingInstancesWithNoPath(
+    leakingWeakRefs: List<KeyedWeakReferenceMirror>,
+    analysisResults: MutableMap<String, RetainedInstance>
+  ) {
+    leakingWeakRefs.forEach { refWithNoPath ->
+      val key = refWithNoPath.key
+      val name = refWithNoPath.name
+      val className = refWithNoPath.className
+      val noLeak = NoPathToInstance(
+          key, name, className, refWithNoPath.watchDurationMillis,
+          refWithNoPath.retainedDurationMillis ?: 0
+      )
+      analysisResults[key] = noLeak
+    }
+  }
+
+  private fun buildLeakTrace(
+    graph: HprofGraph,
+    leakTraceInspectors: List<LeakTraceInspector>,
+    leakingNode: LeakNode
+  ): LeakTrace {
+    val elements = ArrayList<LeakTraceElement>()
+    // We iterate from the leak to the GC root
+    val ignored = leakingNode.instance
+
+    val leafNode = ChildNode(ignored, Int.MAX_VALUE, null, leakingNode, null)
+
+    var node: LeakNode = leafNode
+    val nodes = mutableListOf<LeakNode>()
+    val leakReporters = mutableListOf<LeakTraceElementReporter>()
+    while (node is ChildNode) {
+      nodes.add(0, node.parent)
+      leakReporters.add(
+          0, LeakTraceElementReporter(graph.indexedObject(node.parent.instance))
+      )
+      node = node.parent
+    }
+
+    leakTraceInspectors.forEach { it.inspect(graph, leakReporters) }
+
+    val leakStatuses = computeLeakStatuses(leakReporters)
+
+    node = leafNode
+    while (node is ChildNode) {
+      val index = (nodes.size - elements.size) - 1
+      val leakReporter = leakReporters[index]
+      val leakStatus = leakStatuses[index]
+      elements.add(0, buildLeakElement(graph, node, leakReporter.labels, leakStatus))
+      node = node.parent
+    }
+    return LeakTrace(elements)
+  }
+
+  private fun computeLeakStatuses(
+    leakReporters: List<LeakTraceElementReporter>
+  ): List<LeakNodeStatusAndReason> {
+    var lastNotLeakingElementIndex = 0
+    val lastElementIndex = leakReporters.size - 1
+    var firstLeakingElementIndex = lastElementIndex
+
+    val leakStatuses = ArrayList<LeakNodeStatusAndReason>()
+
+    for ((index, reporter) in leakReporters.withIndex()) {
+      val leakStatus = inspectElementLeakStatus(reporter)
+      leakStatuses.add(leakStatus)
+      if (leakStatus.status == NOT_LEAKING) {
+        lastNotLeakingElementIndex = index
+        // Reset firstLeakingElementIndex so that we never have
+        // firstLeakingElementIndex < lastNotLeakingElementIndex
+        firstLeakingElementIndex = lastElementIndex
+      } else if (firstLeakingElementIndex == lastElementIndex && leakStatus.status == LEAKING) {
+        firstLeakingElementIndex = index
+      }
+    }
+
+    leakStatuses[0] = when (leakStatuses[0].status) {
+      UNKNOWN -> LeakNodeStatus.notLeaking("it's a GC root")
+      NOT_LEAKING -> LeakNodeStatus.notLeaking(
+          "it's a GC root and ${leakStatuses[0].reason}"
+      )
+      LEAKING -> LeakNodeStatus.notLeaking(
+          "it's a GC root. Conflicts with ${leakStatuses[0].reason}"
+      )
+    }
+
+    leakStatuses[lastElementIndex] = when (leakStatuses[lastElementIndex].status) {
+      UNKNOWN -> LeakNodeStatus.leaking("RefWatcher was watching this")
+      LEAKING -> LeakNodeStatus.leaking(
+          "RefWatcher was watching this and ${leakStatuses[lastElementIndex].reason}"
+      )
+      NOT_LEAKING -> LeakNodeStatus.leaking(
+          "RefWatcher was watching this. Conflicts with ${leakStatuses[lastElementIndex].reason}"
+      )
+    }
+
+    val simpleClassNames = leakReporters.map { reporter ->
+      recordClassName(reporter.objectRecord).lastSegment('.')
+    }
+
+    // First and last are always known.
+    for (i in 1 until lastElementIndex) {
+      val leakStatus = leakStatuses[i]
+      if (i < lastNotLeakingElementIndex) {
+        val nextNotLeakingName = simpleClassNames[i + 1]
+        leakStatuses[i] = when (leakStatus.status) {
+          UNKNOWN -> LeakNodeStatus.notLeaking("$nextNotLeakingName↓ is not leaking")
+          NOT_LEAKING -> LeakNodeStatus.notLeaking(
+              "$nextNotLeakingName↓ is not leaking and ${leakStatus.reason}"
+          )
+          LEAKING -> LeakNodeStatus.notLeaking(
+              "$nextNotLeakingName↓ is not leaking. Conflicts with ${leakStatus.reason}"
+          )
+        }
+      } else if (i > firstLeakingElementIndex) {
+        val previousLeakingName = simpleClassNames[i - 1]
+        leakStatuses[i] = LeakNodeStatus.leaking("$previousLeakingName↑ is leaking")
+
+        leakStatuses[i] = when (leakStatus.status) {
+          UNKNOWN -> LeakNodeStatus.leaking("$previousLeakingName↑ is leaking")
+          LEAKING -> LeakNodeStatus.leaking(
+              "$previousLeakingName↑ is leaking and ${leakStatus.reason}"
+          )
+          NOT_LEAKING -> throw IllegalStateException("Should never happen")
+        }
+      }
+    }
+    return leakStatuses
+  }
+
+  private fun inspectElementLeakStatus(
+    reporter: LeakTraceElementReporter
+  ): LeakNodeStatusAndReason {
+    var current = LeakNodeStatus.unknown()
+    for (statusAndReason in reporter.leakNodeStatuses) {
+      current = when {
+        current.status == UNKNOWN -> statusAndReason
+        current.status == LEAKING && statusAndReason.status == LEAKING -> {
+          LeakNodeStatus.leaking("${current.reason} and ${statusAndReason.reason}")
+        }
+        current.status == NOT_LEAKING && statusAndReason.status == NOT_LEAKING -> {
+          LeakNodeStatus.notLeaking("${current.reason} and ${statusAndReason.reason}")
+        }
+        current.status == NOT_LEAKING && statusAndReason.status == LEAKING -> {
+          LeakNodeStatus.notLeaking(
+              "${current.reason}. Conflicts with ${statusAndReason.reason}"
+          )
+        }
+        current.status == LEAKING && statusAndReason.status == NOT_LEAKING -> {
+          LeakNodeStatus.notLeaking(
+              "${statusAndReason.reason}. Conflicts with ${current.reason}"
+          )
+        }
+        else -> throw IllegalStateException(
+            "Should never happen ${current.status} ${statusAndReason.reason}"
+        )
+      }
+    }
+    return current
+  }
+
+  private fun buildLeakElement(
+    graph: HprofGraph,
+    node: ChildNode,
+    labels: List<String>,
+    leakStatus: LeakNodeStatusAndReason
+  ): LeakTraceElement {
+    val objectId = node.parent.instance
+
+    val graphRecord = graph.indexedObject(objectId)
+
+    val className = recordClassName(graphRecord)
+
+    val holderType = if (graphRecord is GraphClassRecord) {
+      CLASS
+    } else if (graphRecord is GraphObjectArrayRecord || graphRecord is GraphPrimitiveArrayRecord) {
+      ARRAY
+    } else {
+      val instanceRecord = graphRecord.asInstance!!
+      if (instanceRecord.instanceClass.classHierarchy.any { it.name == Thread::class.java.name }) {
+        THREAD
+      } else {
+        OBJECT
+      }
+    }
+    return LeakTraceElement(
+        node.leakReference, holderType, className, node.exclusion, labels, leakStatus
+    )
+  }
+
+  private fun recordClassName(
+    graphRecord: GraphObjectRecord
+  ): String {
+    return when (graphRecord) {
+      is GraphClassRecord -> graphRecord.name
+      is GraphInstanceRecord -> graphRecord.className
+      is GraphObjectArrayRecord -> graphRecord.arrayClassName
+      is GraphPrimitiveArrayRecord -> when (graphRecord.primitiveType) {
+        BOOLEAN -> "boolean[]"
+        CHAR -> "char[]"
+        FLOAT -> "float[]"
+        DOUBLE -> "double[]"
+        BYTE -> "byte[]"
+        SHORT -> "short[]"
+        INT -> "int[]"
+        LONG -> "long[]"
+      }
+    }
+  }
+
+  private fun since(analysisStartNanoTime: Long): Long {
+    return NANOSECONDS.toMillis(System.nanoTime() - analysisStartNanoTime)
+  }
+
+  companion object {
+    private const val ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$"
+    internal val ANONYMOUS_CLASS_NAME_PATTERN_REGEX = ANONYMOUS_CLASS_NAME_PATTERN.toRegex()
+  }
+}
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
new file mode 100644
index 00000000..60ef3694
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
@@ -0,0 +1,23 @@
+package leakcanary
+
+sealed class LeakNode {
+  abstract val instance: Long
+  /** Used by the shortest path finder to create a segmented FIFO queue using a priority queue. */
+  abstract val visitOrder: Int
+
+  class RootNode(
+    override val instance: Long,
+    override val visitOrder: Int
+  ) : LeakNode()
+
+  class ChildNode(
+    override val instance: Long,
+    override val visitOrder: Int,
+    val exclusion: ExclusionDescription?,
+    val parent: LeakNode,
+    /**
+     * The reference from the parent to this node
+     */
+    val leakReference: LeakReference?
+  ) : LeakNode()
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakNodeStatus.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakNodeStatus.kt
new file mode 100644
index 00000000..526ef11f
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakNodeStatus.kt
@@ -0,0 +1,33 @@
+package leakcanary
+
+import java.io.Serializable
+
+enum class LeakNodeStatus {
+  NOT_LEAKING,
+  LEAKING,
+  UNKNOWN;
+
+  companion object {
+    private val UNKNOWN_REACHABILITY = LeakNodeStatusAndReason(UNKNOWN, "")
+
+    /** The instance was needed and therefore expected to be reachable.  */
+    fun notLeaking(reason: String): LeakNodeStatusAndReason {
+      return LeakNodeStatusAndReason(NOT_LEAKING, reason)
+    }
+
+    /** The instance was no longer needed and therefore expected to be unreachable.  */
+    fun leaking(reason: String): LeakNodeStatusAndReason {
+      return LeakNodeStatusAndReason(LEAKING, reason)
+    }
+
+    /** No decision can be made about the provided instance.  */
+    fun unknown(): LeakNodeStatusAndReason {
+      return UNKNOWN_REACHABILITY
+    }
+  }
+}
+
+class LeakNodeStatusAndReason internal constructor(
+  val status: LeakNodeStatus,
+  val reason: String
+) : Serializable
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakReference.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakReference.kt
new file mode 100644
index 00000000..1673d2d4
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakReference.kt
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import leakcanary.LeakTraceElement.Type
+import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
+import leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
+import leakcanary.LeakTraceElement.Type.LOCAL
+import leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import java.io.Serializable
+
+/**
+ * A single field in a [LeakTraceElement].
+ */
+data class LeakReference(
+  val type: Type,
+  val name: String
+) : Serializable {
+
+  val displayName: String
+    get() {
+      return when (type) {
+        ARRAY_ENTRY -> "[$name]"
+        STATIC_FIELD, INSTANCE_FIELD -> name
+        LOCAL -> "<Java Local>"
+      }
+    }
+
+  val groupingName: String
+    get() {
+      return when (type) {
+        // The specific array index in a leak rarely matters, this improves grouping.
+        ARRAY_ENTRY -> "[x]"
+        STATIC_FIELD, INSTANCE_FIELD -> name
+        LOCAL -> "<Java Local>"
+      }
+    }
+}
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakTrace.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakTrace.kt
new file mode 100644
index 00000000..1f05e5cb
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakTrace.kt
@@ -0,0 +1,40 @@
+package leakcanary
+
+import leakcanary.LeakNodeStatus.NOT_LEAKING
+import leakcanary.LeakNodeStatus.UNKNOWN
+import leakcanary.internal.renderToString
+import java.io.Serializable
+
+/**
+ * A chain of references that constitute the shortest strong reference path from a leaking instance
+ * to the GC roots. Fixing the leak usually means breaking one of the references in that chain.
+ */
+data class LeakTrace(
+  val elements: List<LeakTraceElement>
+) : Serializable {
+
+  val firstElementExclusion
+    get() = elements.first { element ->
+      element.exclusion != null
+    }.exclusion!!
+
+  val leakCauses = elements.filterIndexed { index, _ ->
+    elementMayBeLeakCause(index)
+  }
+
+  override fun toString(): String {
+    return "\n${renderToString()}\n"
+  }
+
+  fun elementMayBeLeakCause(index: Int): Boolean {
+    return when (elements[index].leakStatusAndReason.status) {
+      UNKNOWN -> true
+      NOT_LEAKING -> if (index < elements.lastIndex) {
+        elements[index + 1].leakStatusAndReason.status != NOT_LEAKING
+      } else {
+        true
+      }
+      else -> false
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt
new file mode 100644
index 00000000..940bf3fa
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt
@@ -0,0 +1,46 @@
+package leakcanary
+
+import leakcanary.internal.lastSegment
+import java.io.Serializable
+
+data class LeakTraceElement(
+  /**
+   * Information about the reference that points to the next [LeakTraceElement] in the leak
+   * chain. Null if this is the last element in the leak trace, ie the leaking object.
+   */
+  val reference: LeakReference?,
+
+  val holder: Holder,
+
+  val className: String,
+
+  /** If not null, there was no path that could exclude this element.  */
+  val exclusion: ExclusionDescription?,
+
+  /**
+   * Ordered labels that were computed during analysis. A label provides
+   * extra information that helps understand the leak trace element.
+   */
+  val labels: List<String>,
+  val leakStatusAndReason: LeakNodeStatusAndReason
+) : Serializable {
+
+  /**
+   * Returns {@link #className} without the package.
+   */
+  val classSimpleName: String get() = className.lastSegment('.')
+
+  enum class Type {
+    INSTANCE_FIELD,
+    STATIC_FIELD,
+    LOCAL,
+    ARRAY_ENTRY
+  }
+
+  enum class Holder {
+    OBJECT,
+    CLASS,
+    THREAD,
+    ARRAY
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElementReporter.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElementReporter.kt
new file mode 100644
index 00000000..a9344870
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElementReporter.kt
@@ -0,0 +1,26 @@
+package leakcanary
+
+class LeakTraceElementReporter(val objectRecord: GraphObjectRecord) {
+
+  private val mutableLabels = mutableListOf<String>()
+  private val mutableLeakNodeStatuses = mutableListOf<LeakNodeStatusAndReason>()
+
+  val labels: List<String>
+    get() = mutableLabels
+
+  val leakNodeStatuses: List<LeakNodeStatusAndReason>
+    get() = mutableLeakNodeStatuses
+
+  fun addLabel(label: String) {
+    mutableLabels += label
+  }
+
+  fun reportLeaking(reason: String) {
+    mutableLeakNodeStatuses += LeakNodeStatus.leaking(reason)
+  }
+
+  fun reportNotLeaking(reason: String) {
+    mutableLeakNodeStatuses += LeakNodeStatus.notLeaking(reason)
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceInspector.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceInspector.kt
new file mode 100644
index 00000000..786bddb8
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceInspector.kt
@@ -0,0 +1,8 @@
+package leakcanary
+
+interface LeakTraceInspector {
+  fun inspect(
+    graph: HprofGraph,
+    leakTrace: List<LeakTraceElementReporter>
+  )
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/Serializables.kt b/leakcanary-analyzer/src/main/java/leakcanary/Serializables.kt
new file mode 100644
index 00000000..786cb3aa
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/Serializables.kt
@@ -0,0 +1,30 @@
+package leakcanary
+
+import java.io.ByteArrayInputStream
+import java.io.ByteArrayOutputStream
+import java.io.ObjectInputStream
+import java.io.ObjectOutputStream
+import java.io.Serializable
+
+fun Serializable.toByteArray(): ByteArray {
+  val outputStream = ByteArrayOutputStream()
+  ObjectOutputStream(outputStream).writeObject(this)
+  return outputStream.toByteArray()
+}
+
+object Serializables {
+
+  inline fun <reified T> fromByteArray(byteArray: ByteArray): T? {
+    val inputStream = ByteArrayInputStream(byteArray)
+    return try {
+      val deserializedObject = ObjectInputStream(inputStream).readObject()
+      if (deserializedObject is T) {
+        deserializedObject
+      } else {
+        null
+      }
+    } catch (ignored: Throwable) {
+      null
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
new file mode 100644
index 00000000..9ccacdab
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
@@ -0,0 +1,58 @@
+package leakcanary.internal
+
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
+import leakcanary.HeapValue.ObjectReference
+
+internal class KeyedWeakReferenceMirror(
+  val referent: ObjectReference,
+  val key: String,
+    // The name field does not exist in pre 1.0 heap dumps.
+  val name: String,
+  // 0 in pre 2.0 alpha 3 heap dumps
+  val watchDurationMillis: Long,
+    // The className field does not exist in pre 2.0 heap dumps.
+  val className: String,
+    // null in pre 2.0 alpha 3 heap dumps, -1 if the instance is not retained.
+  val retainedDurationMillis: Long?
+) {
+
+  val hasReferent = referent.value != 0L
+
+  val isRetained = retainedDurationMillis == null || retainedDurationMillis != -1L
+
+  companion object {
+
+    private const val UNKNOWN_LEGACY = "Unknown (legacy)"
+
+    fun fromInstance(
+      weakRef: GraphInstanceRecord,
+      // Null for pre 2.0 alpha 3 heap dumps
+      heapDumpUptimeMillis: Long?
+    ): KeyedWeakReferenceMirror {
+
+      val keyWeakRefClassName = weakRef.className
+      val watchDurationMillis = if (heapDumpUptimeMillis != null)
+        heapDumpUptimeMillis - weakRef[keyWeakRefClassName, "watchUptimeMillis"]!!.value.asLong!!
+      else 0L
+
+      val retainedDurationMillis = if (heapDumpUptimeMillis != null) {
+        val retainedUptimeMillis = weakRef[keyWeakRefClassName, "retainedUptimeMillis"]!!.value.asLong!!
+        if (retainedUptimeMillis == -1L) -1L else heapDumpUptimeMillis - retainedUptimeMillis
+      } else null
+
+      val keyString = weakRef[keyWeakRefClassName, "key"]!!.value.readAsJavaString()!!
+
+      val name = weakRef[keyWeakRefClassName, "name"]?.value?.readAsJavaString() ?: UNKNOWN_LEGACY
+      val className = weakRef[keyWeakRefClassName, "className"]?.value?.readAsJavaString() ?: UNKNOWN_LEGACY
+      return KeyedWeakReferenceMirror(
+          watchDurationMillis = watchDurationMillis,
+          retainedDurationMillis = retainedDurationMillis,
+          referent = weakRef["java.lang.ref.Reference", "referent"]!!.value.actual as ObjectReference,
+          key = keyString,
+          name = name,
+          className = className
+      )
+    }
+  }
+}
+
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
new file mode 100644
index 00000000..476a011f
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
@@ -0,0 +1,88 @@
+package leakcanary.internal
+
+import leakcanary.LeakNodeStatus.LEAKING
+import leakcanary.LeakNodeStatus.NOT_LEAKING
+import leakcanary.LeakNodeStatus.UNKNOWN
+import leakcanary.LeakNodeStatusAndReason
+import leakcanary.LeakTrace
+import leakcanary.LeakTraceElement
+import leakcanary.LeakTraceElement.Holder.ARRAY
+import leakcanary.LeakTraceElement.Holder.THREAD
+import leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import java.util.Locale
+
+fun LeakTrace.renderToString(): String {
+  var result = "┬"
+
+  elements.forEachIndexed { index, element ->
+    val isLast = index == elements.lastIndex
+    val nodePrefix = if (!isLast) {
+      "├─ "
+    } else {
+      "╰→ "
+    }
+    result += "\n" + nodePrefix + element.className
+
+    val contentPrefix = if (!isLast) {
+      "│    "
+    } else {
+      "$ZERO_WIDTH_SPACE     "
+    }
+
+    val currentReachability = elements[index].leakStatusAndReason
+    result += "\n" + contentPrefix + "Leaking: " + currentReachability.renderToString()
+
+    if (element.exclusion != null) {
+      result += "\n" + contentPrefix + "Matches exclusion ${element.exclusion.matching}"
+    }
+
+    for (label in element.labels) {
+      result += "\n" + contentPrefix + label
+    }
+
+    if (!isLast) {
+      result += "\n" + contentPrefix + "↓ " + getNextElementString(this, element, index)
+    }
+
+  }
+  return result
+}
+
+private fun LeakNodeStatusAndReason.renderToString(): String {
+  return when (status) {
+    UNKNOWN -> "UNKNOWN"
+    NOT_LEAKING -> "NO ($reason)"
+    LEAKING -> "YES ($reason)"
+  }
+}
+
+private fun getNextElementString(
+  leakTrace: LeakTrace,
+  element: LeakTraceElement,
+  index: Int
+): String {
+  val maybeLeakCause = leakTrace.elementMayBeLeakCause(index)
+
+  val staticString =
+    if (element.reference != null && element.reference.type == STATIC_FIELD) "static " else ""
+  val holderString =
+    if (element.holder == ARRAY || element.holder == THREAD) {
+      "${element.holder.name.toLowerCase(Locale.US)} "
+    } else ""
+  val simpleClassName = element.classSimpleName
+  val referenceName = if (element.reference != null) ".${element.reference.displayName}" else ""
+  val requiredSpaces =
+    staticString.length + holderString.length + simpleClassName.length + "├─".length
+  val leakString = if (maybeLeakCause) {
+    "\n│$ELEMENT_DEFAULT_NEW_LINE_SPACE" + " ".repeat(
+        requiredSpaces
+    ) + "~".repeat(referenceName.length - 1)
+  } else {
+    ""
+  }
+
+  return staticString + holderString + simpleClassName + referenceName + leakString
+}
+
+private const val ZERO_WIDTH_SPACE = '\u200b'
+private const val ELEMENT_DEFAULT_NEW_LINE_SPACE = "     "
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
new file mode 100644
index 00000000..43007024
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
@@ -0,0 +1,627 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import leakcanary.AnalyzerProgressListener
+import leakcanary.AnalyzerProgressListener.Step.FINDING_DOMINATORS
+import leakcanary.AnalyzerProgressListener.Step.FINDING_SHORTEST_PATHS
+import leakcanary.Exclusion
+import leakcanary.Exclusion.ExclusionType
+import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
+import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
+import leakcanary.Exclusion.Status
+import leakcanary.Exclusion.Status.NEVER_REACHABLE
+import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
+import leakcanary.GcRoot
+import leakcanary.GcRoot.JavaFrame
+import leakcanary.GcRoot.ThreadObject
+import leakcanary.GraphObjectRecord.GraphClassRecord
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
+import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
+import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
+import leakcanary.HprofGraph
+import leakcanary.HprofReader
+import leakcanary.LeakNode
+import leakcanary.LeakNode.ChildNode
+import leakcanary.LeakNode.RootNode
+import leakcanary.LeakReference
+import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
+import leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
+import leakcanary.LeakTraceElement.Type.LOCAL
+import leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.internal.hppc.LongLongScatterMap
+import leakcanary.internal.hppc.LongScatterSet
+import java.util.LinkedHashMap
+import java.util.PriorityQueue
+
+/**
+ * Not thread safe.
+ *
+ * Finds the shortest path from leaking references to a gc root, ignoring excluded
+ * refs first and then including the ones that are not "always ignorable" as needed if no path is
+ * found.
+ *
+ * Skips enqueuing strings as an optimization, so if the leaking reference is a string then it will
+ * never be found.
+ */
+internal class ShortestPathFinder {
+
+  /**
+   * A segmented FIFO queue. The queue is segmented by [Status]. Within each segment the elements
+   * are ordered FIFO.
+   */
+  private val toVisitQueue = PriorityQueue<LeakNode>(1024, Comparator { node1, node2 ->
+    val priorityComparison = toVisitMap[node1.instance]!!.compareTo(toVisitMap[node2.instance]!!)
+    if (priorityComparison != 0) {
+      priorityComparison
+    } else {
+      node1.visitOrder.compareTo(node2.visitOrder)
+    }
+  })
+  /** Set of instances to visit */
+  private val toVisitMap = LinkedHashMap<Long, Status>()
+  private val visitedSet = LongScatterSet()
+  private lateinit var referentMap: Map<Long, KeyedWeakReferenceMirror>
+  private var visitOrder = 0
+
+  /**
+   * Map of instances to their leaking dominator.
+   * var because the instance will be returned by [findPaths] and replaced with a new empty map
+   * here (copying it could be expensive).
+   *
+   * If an instance has been added to [toVisitMap] or [visitedSet] and is missing from
+   * [dominatedInstances] then it's considered "undomitable" ie it is dominated by gc roots
+   * and cannot be dominated by a leaking instance.
+   */
+  private var dominatedInstances = LongLongScatterMap()
+  private var sizeOfObjectInstances = 0
+
+  class Result(
+    val leakingNode: LeakNode,
+    val exclusionStatus: Status?,
+    val weakReference: KeyedWeakReferenceMirror
+  )
+
+  data class Results(
+    val results: List<Result>,
+    val dominatedInstances: LongLongScatterMap
+  )
+
+  fun findPaths(
+    graph: HprofGraph,
+    exclusions: List<Exclusion>,
+    leakingWeakRefs: List<KeyedWeakReferenceMirror>,
+    gcRootIds: MutableList<GcRoot>,
+    computeDominators: Boolean,
+    listener: AnalyzerProgressListener
+  ): Results {
+    listener.onProgressUpdate(FINDING_SHORTEST_PATHS)
+    clearState()
+
+    val objectClass = graph.indexedClass("java.lang.Object")
+    sizeOfObjectInstances = if (objectClass != null) {
+      // In Android 16 ClassDumpRecord.instanceSize can be 8 yet there are 0 fields.
+      // Better rely on our own computation of instance size.
+      // See #1374
+      val objectClassFieldSize = objectClass.readRecord()
+          .fields.sumBy {
+        graph.sizeOfFieldType(it.type)
+      }
+
+      // shadow$_klass_ (object id) + shadow$_monitor_ (Int)
+      val sizeOfObjectOnArt =
+        graph.sizeOfFieldType(HprofReader.OBJECT_TYPE) + graph.sizeOfFieldType(HprofReader.INT_TYPE)
+      if (objectClassFieldSize == sizeOfObjectOnArt) {
+        sizeOfObjectOnArt
+      } else {
+        0
+      }
+    } else {
+      0
+    }
+
+    val fieldNameByClassName = mutableMapOf<String, MutableMap<String, Exclusion>>()
+    val staticFieldNameByClassName = mutableMapOf<String, MutableMap<String, Exclusion>>()
+    val threadNames = mutableMapOf<String, Exclusion>()
+
+    exclusions.filter { it.filter(graph) }
+        .forEach { exclusion ->
+          when (exclusion.type) {
+            is ExclusionType.JavaLocalExclusion -> {
+              threadNames[exclusion.type.threadName] = exclusion
+            }
+            is StaticFieldExclusion -> {
+              val mapOrNull = staticFieldNameByClassName[exclusion.type.className]
+              val map = if (mapOrNull != null) mapOrNull else {
+                val newMap = mutableMapOf<String, Exclusion>()
+                staticFieldNameByClassName[exclusion.type.className] = newMap
+                newMap
+              }
+              map[exclusion.type.fieldName] = exclusion
+            }
+            is InstanceFieldExclusion -> {
+              val mapOrNull = fieldNameByClassName[exclusion.type.className]
+              val map = if (mapOrNull != null) mapOrNull else {
+                val newMap = mutableMapOf<String, Exclusion>()
+                fieldNameByClassName[exclusion.type.className] = newMap
+                newMap
+              }
+              map[exclusion.type.fieldName] = exclusion
+            }
+          }
+        }
+
+    // Referent object id to weak ref mirror
+    referentMap = leakingWeakRefs.associateBy { it.referent.value }
+
+    enqueueGcRoots(graph, gcRootIds, threadNames, computeDominators)
+
+    var lowestPriority = ALWAYS_REACHABLE
+    val results = mutableListOf<Result>()
+    visitingQueue@ while (!toVisitQueue.isEmpty()) {
+      val node = toVisitQueue.poll()!!
+      val priority = toVisitMap[node.instance]!!
+      // Lowest priority has the highest value
+      if (priority > lowestPriority) {
+        lowestPriority = priority
+      }
+
+      toVisitMap.remove(node.instance)
+
+      if (checkSeen(node)) {
+        continue
+      }
+
+      val weakReference = referentMap[node.instance]
+      if (weakReference != null) {
+        val exclusionPriority = if (lowestPriority == ALWAYS_REACHABLE) null else lowestPriority
+        results.add(Result(node, exclusionPriority, weakReference))
+        // Found all refs, stop searching (unless computing retained size which stops on weak reachables)
+        if (results.size == leakingWeakRefs.size) {
+          if (computeDominators && lowestPriority < WEAKLY_REACHABLE) {
+            listener.onProgressUpdate(FINDING_DOMINATORS)
+          } else {
+            break@visitingQueue
+          }
+        }
+      }
+
+      if (results.size == leakingWeakRefs.size && computeDominators && lowestPriority >= WEAKLY_REACHABLE) {
+        break@visitingQueue
+      }
+
+      when (val graphRecord = graph.indexedObject(node.instance)) {
+        is GraphClassRecord -> visitClassRecord(
+            graph, graphRecord, node, staticFieldNameByClassName, computeDominators
+        )
+        is GraphInstanceRecord -> visitInstanceRecord(
+            graph, graphRecord, node, fieldNameByClassName, computeDominators
+        )
+        is GraphObjectArrayRecord -> visitObjectArrayRecord(
+            graph, graphRecord.readRecord(), node, computeDominators
+        )
+      }
+    }
+
+    val dominatedInstances = this.dominatedInstances
+
+    clearState()
+
+    return Results(results, dominatedInstances)
+  }
+
+  private fun checkSeen(node: LeakNode): Boolean {
+    val neverSeen = visitedSet.add(node.instance)
+    return !neverSeen
+  }
+
+  private fun clearState() {
+    toVisitQueue.clear()
+    toVisitMap.clear()
+    visitedSet.release()
+    visitOrder = 0
+    referentMap = emptyMap()
+    dominatedInstances = LongLongScatterMap()
+    sizeOfObjectInstances = 0
+  }
+
+  private fun enqueueGcRoots(
+    graph: HprofGraph,
+    gcRoots: MutableList<GcRoot>,
+    threadNameExclusions: Map<String, Exclusion>,
+    computeDominators: Boolean
+  ) {
+    gcRoots.removeAll { it.id == 0L }
+
+    // Sorting GC roots to get stable shortest path
+    // Once sorted all ThreadObject Gc Roots are located before JavaLocalExclusion Gc Roots.
+    // This ensures ThreadObjects are visited before JavaFrames, and threadsBySerialNumber can be
+    // built before JavaFrames.
+    sortGcRoots(graph, gcRoots)
+
+    val threadsBySerialNumber = mutableMapOf<Int, ThreadObject>()
+    gcRoots.forEach { gcRoot ->
+      if (computeDominators) {
+        undominateWithSkips(graph, gcRoot.id)
+      }
+      when (gcRoot) {
+        is ThreadObject -> {
+          threadsBySerialNumber[gcRoot.threadSerialNumber] = gcRoot
+          enqueue(graph, RootNode(gcRoot.id, visitOrder++), exclusionPriority = null)
+        }
+        is JavaFrame -> {
+          val threadRoot = threadsBySerialNumber.getValue(gcRoot.threadSerialNumber)
+          val threadInstance = graph.indexedObject(threadRoot.id).asInstance!!
+          val threadName = threadInstance[Thread::class, "name"]?.value?.readAsJavaString()
+          val exclusion = threadNameExclusions[threadName]
+
+          if (exclusion == null || exclusion.status != NEVER_REACHABLE) {
+            // visitOrder is unused as this root node isn't enqueued.
+            val rootNode = RootNode(threadRoot.id, visitOrder = 0)
+            // TODO #1352 Instead of <Java Local>, it should be <local variable in Foo.bar()>
+            // We should also add the full stacktrace as a label of thread objects
+            val leakReference = LeakReference(LOCAL, "")
+            enqueue(
+                graph,
+                ChildNode(gcRoot.id, visitOrder++, exclusion?.description, rootNode, leakReference),
+                exclusionPriority = exclusion?.status
+            )
+          }
+        }
+        else -> enqueue(graph, RootNode(gcRoot.id, visitOrder++), exclusionPriority = null)
+      }
+    }
+    gcRoots.clear()
+  }
+
+  private fun sortGcRoots(
+    graph: HprofGraph,
+    gcRoots: MutableList<GcRoot>
+  ) {
+    val rootClassName: (GcRoot) -> String = {
+      when (val graphObject = graph.indexedObject(it.id)) {
+        is GraphClassRecord -> {
+          graphObject.name
+        }
+        is GraphInstanceRecord -> {
+          graphObject.className
+        }
+        is GraphObjectArrayRecord -> {
+          graphObject.arrayClassName
+        }
+        is GraphPrimitiveArrayRecord -> {
+          graphObject.primitiveType.name
+        }
+      }
+    }
+    gcRoots.sortWith(Comparator { root1, root2 ->
+      // Sorting based on type name first. In reverse order so that ThreadObject is before JavaLocalExclusion
+      val gcRootTypeComparison = root2::class.java.name.compareTo(root1::class.java.name)
+      if (gcRootTypeComparison != 0) {
+        gcRootTypeComparison
+      } else {
+        rootClassName(root1).compareTo(rootClassName(root2))
+      }
+    })
+  }
+
+  private fun visitClassRecord(
+    graph: HprofGraph,
+    classRecord: GraphClassRecord,
+    node: LeakNode,
+    staticFieldNameByClassName: Map<String, Map<String, Exclusion>>,
+    computeRetainedHeapSize: Boolean
+  ) {
+    val ignoredStaticFields = staticFieldNameByClassName[classRecord.name] ?: emptyMap()
+
+    for (staticField in classRecord.readStaticFields()) {
+      if (!staticField.value.isNonNullReference) {
+        continue
+      }
+
+      val fieldName = staticField.name
+      if (fieldName == "\$staticOverhead") {
+        continue
+      }
+
+      val objectId = staticField.value.asObjectIdReference!!
+
+      if (computeRetainedHeapSize) {
+        undominateWithSkips(graph, objectId)
+      }
+
+      val leakReference = LeakReference(STATIC_FIELD, fieldName)
+
+      val exclusion = ignoredStaticFields[fieldName]
+
+      enqueue(
+          graph,
+          ChildNode(objectId, visitOrder++, exclusion?.description, node, leakReference),
+          exclusion?.status
+      )
+    }
+  }
+
+  private fun visitInstanceRecord(
+    graph: HprofGraph,
+    instanceRecord: GraphInstanceRecord,
+    parent: LeakNode,
+    fieldNameByClassName: Map<String, Map<String, Exclusion>>,
+    computeRetainedHeapSize: Boolean
+  ) {
+    val ignoredFields = LinkedHashMap<String, Exclusion>()
+
+    instanceRecord.instanceClass.classHierarchy.forEach {
+      val classExclusions = fieldNameByClassName[it.name]
+      if (classExclusions != null) {
+        for ((fieldName, exclusion) in classExclusions) {
+          if (!ignoredFields.containsKey(fieldName)) {
+            ignoredFields[fieldName] = exclusion
+          }
+        }
+      }
+    }
+
+    val fieldNamesAndValues = instanceRecord.readFields()
+        .toMutableList()
+
+    fieldNamesAndValues.sortBy { it.name }
+
+    fieldNamesAndValues.filter { it.value.isNonNullReference }
+        .forEach { field ->
+          val objectId = field.value.asObjectIdReference!!
+          if (computeRetainedHeapSize) {
+            updateDominatorWithSkips(graph, parent.instance, objectId)
+          }
+
+          val exclusion = ignoredFields[field.name]
+          enqueue(
+              graph, ChildNode(
+              objectId,
+              visitOrder++, exclusion?.description, parent,
+              LeakReference(INSTANCE_FIELD, field.name)
+          ), exclusion?.status
+          )
+        }
+  }
+
+  private fun visitObjectArrayRecord(
+    graph: HprofGraph,
+    record: ObjectArrayDumpRecord,
+    parentNode: LeakNode,
+    computeRetainedHeapSize: Boolean
+  ) {
+    record.elementIds.forEachIndexed { index, elementId ->
+      if (computeRetainedHeapSize) {
+        updateDominatorWithSkips(graph, parentNode.instance, elementId)
+      }
+      val name = Integer.toString(index)
+      val reference = LeakReference(ARRAY_ENTRY, name)
+      enqueue(graph, ChildNode(elementId, visitOrder++, null, parentNode, reference), null)
+    }
+  }
+
+  private fun enqueue(
+    graph: HprofGraph,
+    node: LeakNode,
+    exclusionPriority: Status?
+  ) {
+    // 0L is null
+    if (node.instance == 0L) {
+      return
+    }
+    if (visitedSet.contains(node.instance)) {
+      return
+    }
+    if (exclusionPriority == NEVER_REACHABLE) {
+      return
+    }
+
+    val nodePriority = exclusionPriority ?: ALWAYS_REACHABLE
+
+    // Whether we want to visit now or later, we should skip if this is already to visit.
+    val existingPriority = toVisitMap[node.instance]
+
+    if (existingPriority != null && existingPriority <= nodePriority) {
+      return
+    }
+
+    val isLeakingInstance = referentMap[node.instance] != null
+
+    if (!isLeakingInstance) {
+      val skip = when (val graphObject = graph.indexedObject(node.instance)) {
+        is GraphClassRecord -> false
+        is GraphInstanceRecord ->
+          when {
+            graphObject.isPrimitiveWrapper -> true
+            graphObject.className == "java.lang.String" -> true
+            graphObject.instanceClass.instanceSize <= sizeOfObjectInstances -> true
+            else -> false
+          }
+        is GraphObjectArrayRecord -> when {
+          graphObject.isPrimitiveWrapperArray -> true
+          else -> false
+        }
+        is GraphPrimitiveArrayRecord -> true
+      }
+      if (skip) {
+        return
+      }
+    }
+
+    if (existingPriority != null) {
+      toVisitQueue.removeAll { it.instance == node.instance }
+    }
+    toVisitMap[node.instance] = nodePriority
+    toVisitQueue.add(node)
+  }
+
+  private fun updateDominatorWithSkips(
+    graph: HprofGraph,
+    parentObjectId: Long,
+    objectId: Long
+  ) {
+
+    when (val graphObject = graph.indexedObject(objectId)) {
+      is GraphClassRecord -> {
+        undominate(objectId, false)
+      }
+      is GraphInstanceRecord -> {
+        // String internal array is never enqueued
+        if (graphObject.className == "java.lang.String") {
+          updateDominator(parentObjectId, objectId, true)
+          val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectIdReference
+          if (valueId != null) {
+            updateDominator(parentObjectId, valueId, true)
+          }
+        } else {
+          updateDominator(parentObjectId, objectId, false)
+        }
+      }
+      is GraphObjectArrayRecord -> {
+        // Primitive wrapper array elements are never enqueued
+        if (graphObject.isPrimitiveWrapperArray) {
+          updateDominator(parentObjectId, objectId, true)
+          for (wrapperId in graphObject.readRecord().elementIds) {
+            updateDominator(parentObjectId, wrapperId, true)
+          }
+        } else {
+          updateDominator(parentObjectId, objectId, false)
+        }
+      }
+      else -> {
+        updateDominator(parentObjectId, objectId, false)
+      }
+    }
+  }
+
+  private fun updateDominator(
+    parent: Long,
+    instance: Long,
+    neverEnqueued: Boolean
+  ) {
+    val currentDominator = dominatedInstances[instance]
+    if (currentDominator == null && (instance in visitedSet || instance in toVisitMap)) {
+      return
+    }
+    val parentDominator = dominatedInstances[parent]
+
+    val parentIsRetainedInstance = referentMap.containsKey(parent)
+
+    val nextDominator = if (parentIsRetainedInstance) parent else parentDominator
+
+    if (nextDominator == null) {
+      // parent is not a retained instance and parent has no dominator, but it must have been
+      // visited therefore we know parent belongs to undominated.
+      if (neverEnqueued) {
+        visitedSet.add(instance)
+      }
+
+      if (currentDominator != null) {
+        dominatedInstances.remove(instance)
+      }
+      return
+    }
+    if (currentDominator == null) {
+      dominatedInstances[instance] = nextDominator
+    } else {
+      val parentDominators = mutableListOf<Long>()
+      val currentDominators = mutableListOf<Long>()
+      var dominator: Long? = nextDominator
+      while (dominator != null) {
+        parentDominators.add(dominator)
+        dominator = dominatedInstances[dominator]
+      }
+      dominator = currentDominator
+      while (dominator != null) {
+        currentDominators.add(dominator)
+        dominator = dominatedInstances[dominator]
+      }
+
+      var sharedDominator: Long? = null
+      exit@ for (parentD in parentDominators) {
+        for (currentD in currentDominators) {
+          if (currentD == parentD) {
+            sharedDominator = currentD
+            break@exit
+          }
+        }
+      }
+      if (sharedDominator == null) {
+        dominatedInstances.remove(instance)
+        if (neverEnqueued) {
+          visitedSet.add(instance)
+        }
+      } else {
+        dominatedInstances[instance] = sharedDominator
+      }
+    }
+  }
+
+  private fun undominateWithSkips(
+    graph: HprofGraph,
+    objectId: Long
+  ) {
+    when (val graphObject = graph.indexedObject(objectId)) {
+      is GraphClassRecord -> {
+        undominate(objectId, false)
+      }
+      is GraphInstanceRecord -> {
+        // String internal array is never enqueued
+        if (graphObject.className == "java.lang.String") {
+          undominate(objectId, true)
+          val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectIdReference
+          if (valueId != null) {
+            undominate(valueId, true)
+          }
+        } else {
+          undominate(objectId, false)
+        }
+      }
+      is GraphObjectArrayRecord -> {
+        // Primitive wrapper array elements are never enqueued
+        if (graphObject.isPrimitiveWrapperArray) {
+          undominate(objectId, true)
+          for (wrapperId in graphObject.readRecord().elementIds) {
+            undominate(wrapperId, true)
+          }
+        } else {
+          undominate(objectId, false)
+        }
+      }
+      else -> {
+        undominate(objectId, false)
+      }
+    }
+  }
+
+  private fun undominate(
+    instance: Long,
+    neverEnqueued: Boolean
+  ) {
+    dominatedInstances.remove(instance)
+    if (neverEnqueued) {
+      visitedSet.add(instance)
+    }
+  }
+
+  companion object {
+    // Since NEVER_REACHABLE never ends up in the queue, we use its value to mean "ALWAYS_REACHABLE"
+    // For this to work we need NEVER_REACHABLE to be declared as the first enum value.
+    private val ALWAYS_REACHABLE = NEVER_REACHABLE
+  }
+}
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/Strings.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/Strings.kt
new file mode 100644
index 00000000..366f852f
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/Strings.kt
@@ -0,0 +1,43 @@
+package leakcanary.internal
+
+import java.nio.charset.Charset
+import java.security.MessageDigest
+import java.security.NoSuchAlgorithmException
+
+@JvmField
+internal val UTF_8: Charset = Charset.forName("UTF-8")
+
+internal fun String.lastSegment(segmentingChar: Char): String {
+  val separator = lastIndexOf(segmentingChar)
+  return if (separator == -1) this else this.substring(separator + 1)
+}
+
+internal fun String.createSHA1Hash(): String = createHash(this, "SHA-1")
+
+/**
+ * Derived from
+ * [this snippet](http://www.androidsnippets.com/create-a-md5-hash-and-dump-as-a-hex-string).
+ */
+private fun createHash(
+  text: String,
+  algorithm: String
+): String {
+  try {
+    // Create MD5 Hash.
+    val digest = MessageDigest.getInstance(algorithm)
+    digest.update(text.getBytes())
+    val messageDigest = digest.digest()
+
+    // Create Hex String.
+    val hexString = StringBuilder()
+    for (b in messageDigest) {
+      hexString.append(Integer.toHexString(0xff and b.toInt()))
+    }
+    return hexString.toString()
+  } catch (e: NoSuchAlgorithmException) {
+    throw AssertionError("Unable to construct MessageDigest for $algorithm")
+  }
+}
+
+/** Gets the string as an array of UTF-8 bytes. */
+internal fun String.getBytes(): ByteArray = toByteArray(UTF_8)
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/HHPC.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/HHPC.kt
new file mode 100644
index 00000000..08357b54
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/HHPC.kt
@@ -0,0 +1,88 @@
+package leakcanary.internal.hppc
+
+import java.util.Locale
+
+/**
+ * Code from https://github.com/carrotsearch/hppc copy pasted, inlined and converted to Kotlin.
+ */
+internal object HHPC {
+
+  private const val PHI_C64 = -0x61c8864680b583ebL
+
+  fun mixPhi(k: Long): Int {
+    val h = k * PHI_C64
+    return (h xor h.ushr(32)).toInt()
+  }
+
+  private const val MIN_HASH_ARRAY_LENGTH = 4
+  private const val MAX_HASH_ARRAY_LENGTH = (-0x80000000).ushr(1)
+
+
+  fun minBufferSize(
+    elements: Int,
+    loadFactor: Double
+  ): Int {
+    var length = Math.ceil(elements / loadFactor)
+        .toLong()
+    if (length == elements.toLong()) {
+      length++
+    }
+    length = Math.max(MIN_HASH_ARRAY_LENGTH.toLong(), nextHighestPowerOfTwo(length))
+
+    if (length > MAX_HASH_ARRAY_LENGTH) {
+      throw RuntimeException(
+          String.format(
+              Locale.ROOT,
+              "Maximum array size exceeded for this load factor (elements: %d, load factor: %f)",
+              elements,
+              loadFactor
+          )
+      )
+    }
+
+    return length.toInt()
+  }
+
+
+  fun nextHighestPowerOfTwo(input: Long): Long {
+    var v = input
+    v--
+    v = v or (v shr 1)
+    v = v or (v shr 2)
+    v = v or (v shr 4)
+    v = v or (v shr 8)
+    v = v or (v shr 16)
+    v = v or (v shr 32)
+    v++
+    return v
+  }
+
+
+  fun expandAtCount(
+    arraySize: Int,
+    loadFactor: Double
+  ): Int {
+    return Math.min(arraySize - 1, Math.ceil(arraySize * loadFactor).toInt())
+  }
+
+
+  fun nextBufferSize(
+    arraySize: Int,
+    elements: Int,
+    loadFactor: Double
+  ): Int {
+    if (arraySize == MAX_HASH_ARRAY_LENGTH) {
+      throw RuntimeException(
+          String.format(
+              Locale.ROOT,
+              "Maximum array size exceeded for this load factor (elements: %d, load factor: %f)",
+              elements,
+              loadFactor
+          )
+      )
+    }
+
+    return arraySize shl 1
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongLongScatterMap.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongLongScatterMap.kt
new file mode 100644
index 00000000..90e13d31
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongLongScatterMap.kt
@@ -0,0 +1,342 @@
+package leakcanary.internal.hppc
+
+import java.util.Locale
+
+/**
+ * Code from com.carrotsearch.hppc.LongLongScatterMap copy pasted, inlined and converted to Kotlin.
+ *
+ * See https://github.com/carrotsearch/hppc .
+ */
+internal class LongLongScatterMap {
+  /**
+   * The array holding keys.
+   */
+  private var keys: LongArray = longArrayOf()
+
+  /**
+   * The array holding values.
+   */
+  private var values: LongArray = longArrayOf()
+
+  /**
+   * The number of stored keys (assigned key slots), excluding the special
+   * "empty" key, if any (use [.size] instead).
+   *
+   * @see .size
+   */
+  private var assigned: Int = 0
+
+  /**
+   * Mask for slot scans in [.keys].
+   */
+  private var mask: Int = 0
+
+  /**
+   * Expand (rehash) [.keys] when [.assigned] hits this value.
+   */
+  private var resizeAt: Int = 0
+
+  /**
+   * Special treatment for the "empty slot" key marker.
+   */
+  private var hasEmptyKey: Boolean = false
+
+  /**
+   * The load factor for [.keys].
+   */
+  private var loadFactor: Double = 0.75
+
+  val isEmpty: Boolean
+    get() = size == 0
+
+  init {
+    ensureCapacity(4)
+  }
+
+  operator fun set(
+    key: Long,
+    value: Long
+  ): Long {
+    val mask = this.mask
+    if (key == 0L) {
+      hasEmptyKey = true
+      val previousValue = values[mask + 1]
+      values[mask + 1] = value
+      return previousValue
+    } else {
+      val keys = this.keys
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          val previousValue = values[slot]
+          values[slot] = value
+          return previousValue
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      if (assigned == resizeAt) {
+        allocateThenInsertThenRehash(slot, key, value)
+      } else {
+        keys[slot] = key
+        values[slot] = value
+      }
+
+      assigned++
+      return 0L
+    }
+  }
+
+  fun remove(key: Long): Long {
+    val mask = this.mask
+    if (key == 0L) {
+      hasEmptyKey = false
+      val previousValue = values[mask + 1]
+      values[mask + 1] = 0L
+      return previousValue
+    } else {
+      val keys = this.keys
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          val previousValue = values[slot]
+          shiftConflictingKeys(slot)
+          return previousValue
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      return 0L
+    }
+  }
+
+  operator fun get(key: Long): Long? {
+    if (key == 0L) {
+      return if (hasEmptyKey) values[mask + 1] else null
+    } else {
+      val keys = this.keys
+      val mask = this.mask
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          return values[slot]
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      return null
+    }
+  }
+
+  fun forEach(block: (Long, Long) -> Unit) {
+    val max = mask + 1
+    var slot = -1
+
+    exitWhile@while (true) {
+      if (slot < max) {
+        var existing: Long
+        slot++
+        while (slot < max) {
+          existing = keys[slot]
+          if (existing != 0L) {
+            block(existing, values[slot])
+            continue@exitWhile
+          }
+          slot++
+        }
+      }
+
+      if (slot == max && hasEmptyKey) {
+        slot++
+        block(0L, values[max])
+        continue@exitWhile
+      }
+      break@exitWhile
+    }
+  }
+
+  fun containsKey(key: Long): Boolean {
+    if (key == 0L) {
+      return hasEmptyKey
+    } else {
+      val keys = this.keys
+      val mask = this.mask
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          return true
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      return false
+    }
+  }
+
+  fun release() {
+    assigned = 0
+    hasEmptyKey = false
+
+    allocateBuffers(HHPC.minBufferSize(4, loadFactor))
+  }
+
+  val size: Int
+    get() {
+      return assigned + if (hasEmptyKey) 1 else 0
+    }
+
+  fun ensureCapacity(expectedElements: Int) {
+    if (expectedElements > resizeAt) {
+      val prevKeys = this.keys
+      val prevValues = this.values
+      allocateBuffers(HHPC.minBufferSize(expectedElements, loadFactor))
+      if (!isEmpty) {
+        rehash(prevKeys, prevValues)
+      }
+    }
+  }
+
+  private fun hashKey(key: Long): Int {
+    return HHPC.mixPhi(key)
+  }
+
+  /**
+   * Rehash from old buffers to new buffers.
+   */
+  private fun rehash(
+    fromKeys: LongArray,
+    fromValues: LongArray
+  ) {
+    // Rehash all stored key/value pairs into the new buffers.
+    val keys = this.keys
+    val values = this.values
+    val mask = this.mask
+    var existing: Long
+
+    // Copy the zero element's slot, then rehash everything else.
+    var from = fromKeys.size - 1
+    keys[keys.size - 1] = fromKeys[from]
+    values[values.size - 1] = fromValues[from]
+    while (--from >= 0) {
+      existing = fromKeys[from]
+      if (existing != 0L) {
+        var slot = hashKey(existing) and mask
+        while (keys[slot] != 0L) {
+          slot = slot + 1 and mask
+        }
+        keys[slot] = existing
+        values[slot] = fromValues[from]
+      }
+    }
+  }
+
+  /**
+   * Allocate new internal buffers. This method attempts to allocate
+   * and assign internal buffers atomically (either allocations succeed or not).
+   */
+  private fun allocateBuffers(arraySize: Int) {
+
+    // Ensure no change is done if we hit an OOM.
+    val prevKeys = this.keys
+    val prevValues = this.values
+    try {
+      val emptyElementSlot = 1
+      this.keys = LongArray(arraySize + emptyElementSlot)
+      this.values = LongArray(arraySize + emptyElementSlot)
+    } catch (e: OutOfMemoryError) {
+      this.keys = prevKeys
+      this.values = prevValues
+      throw RuntimeException(
+          String.format(
+              Locale.ROOT,
+              "Not enough memory to allocate buffers for rehashing: %,d -> %,d",
+              this.mask + 1,
+              arraySize
+          ), e
+      )
+    }
+
+    this.resizeAt = HHPC.expandAtCount(arraySize, loadFactor)
+    this.mask = arraySize - 1
+  }
+
+  /**
+   * This method is invoked when there is a new key/ value pair to be inserted into
+   * the buffers but there is not enough empty slots to do so.
+   *
+   * New buffers are allocated. If this succeeds, we know we can proceed
+   * with rehashing so we assign the pending element to the previous buffer
+   * (possibly violating the invariant of having at least one empty slot)
+   * and rehash all keys, substituting new buffers at the end.
+   */
+  private fun allocateThenInsertThenRehash(
+    slot: Int,
+    pendingKey: Long,
+    pendingValue: Long
+  ) {
+
+    // Try to allocate new buffers first. If we OOM, we leave in a consistent state.
+    val prevKeys = this.keys
+    val prevValues = this.values
+    allocateBuffers(HHPC.nextBufferSize(mask + 1, size, loadFactor))
+
+    // We have succeeded at allocating new data so insert the pending key/value at
+    // the free slot in the old arrays before rehashing.
+    prevKeys[slot] = pendingKey
+    prevValues[slot] = pendingValue
+
+    // Rehash old keys, including the pending key.
+    rehash(prevKeys, prevValues)
+  }
+
+  /**
+   * Shift all the slot-conflicting keys and values allocated to
+   * (and including) `slot`.
+   */
+  private fun shiftConflictingKeys(gapSlot: Int) {
+    var gapSlot = gapSlot
+    val keys = this.keys
+    val values = this.values
+    val mask = this.mask
+
+    // Perform shifts of conflicting keys to fill in the gap.
+    var distance = 0
+    while (true) {
+      val slot = gapSlot + ++distance and mask
+      val existing = keys[slot]
+      if (existing == 0L) {
+        break
+      }
+
+      val idealSlot = hashKey(existing)
+      val shift = slot - idealSlot and mask
+      if (shift >= distance) {
+        // Entry at this position was originally at or before the gap slot.
+        // Move the conflict-shifted entry to the gap's position and repeat the procedure
+        // for any entries to the right of the current position, treating it
+        // as the new gap.
+        keys[gapSlot] = existing
+        values[gapSlot] = values[slot]
+        gapSlot = slot
+        distance = 0
+      }
+    }
+
+    // Mark the last found gap slot without a conflict as empty.
+    keys[gapSlot] = 0L
+    values[gapSlot] = 0L
+    assigned--
+  }
+}
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongScatterSet.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongScatterSet.kt
new file mode 100644
index 00000000..7a4034f2
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongScatterSet.kt
@@ -0,0 +1,179 @@
+package leakcanary.internal.hppc
+
+import java.util.Locale
+
+/**
+ * Code from com.carrotsearch.hppc.LongScatterSet copy pasted, inlined and converted to Kotlin.
+ *
+ * See https://github.com/carrotsearch/hppc .
+ */
+internal class LongScatterSet {
+  /** The hash array holding keys.  */
+  private var keys: LongArray = longArrayOf()
+  /**
+   * The number of stored keys (assigned key slots), excluding the special
+   * "empty" key, if any.
+   *
+   * @see .size
+   * @see .hasEmptyKey
+   */
+  private var assigned = 0
+  /**
+   * Mask for slot scans in [.keys].
+   */
+  private var mask = 0
+
+  /**
+   * Expand (rehash) [.keys] when [.assigned] hits this value.
+   */
+  private var resizeAt = 0
+  /**
+   * Special treatment for the "empty slot" key marker.
+   */
+  private var hasEmptyKey = false
+  /**
+   * The load factor for [.keys].
+   */
+  private val loadFactor = 0.75
+
+  init {
+    ensureCapacity(4)
+  }
+
+  private fun hashKey(key: Long): Int {
+    return HHPC.mixPhi(key)
+  }
+
+  operator fun plusAssign(key: Long) {
+    add(key)
+  }
+
+  fun add(key: Long): Boolean {
+    if (key == 0L) {
+      val added = !hasEmptyKey
+      hasEmptyKey = true
+      return added
+    } else {
+      val keys = this.keys
+      val mask = this.mask
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          return false
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      if (assigned == resizeAt) {
+        allocateThenInsertThenRehash(slot, key)
+      } else {
+        keys[slot] = key
+      }
+
+      assigned++
+      return true
+    }
+  }
+
+  operator fun contains(key: Long): Boolean {
+    if (key == 0L) {
+      return hasEmptyKey
+    } else {
+      val keys = this.keys
+      val mask = this.mask
+      var slot = hashKey(key) and mask
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          return true
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+      return false
+    }
+  }
+
+  fun release() {
+    assigned = 0
+    hasEmptyKey = false
+    allocateBuffers(HHPC.minBufferSize(4, loadFactor))
+  }
+
+  fun ensureCapacity(expectedElements: Int) {
+    if (expectedElements > resizeAt) {
+      val prevKeys = this.keys
+      allocateBuffers(HHPC.minBufferSize(expectedElements, loadFactor))
+      if (size() != 0) {
+        rehash(prevKeys)
+      }
+    }
+  }
+
+  fun size(): Int {
+    return assigned + if (hasEmptyKey) 1 else 0
+  }
+
+  private fun rehash(fromKeys: LongArray) {
+    // Rehash all stored keys into the new buffers.
+    val keys = this.keys
+    val mask = this.mask
+    var existing: Long
+    var i = fromKeys.size - 1
+    while (--i >= 0) {
+      existing = fromKeys[i]
+      if (existing != 0L) {
+        var slot = hashKey(existing) and mask
+        while (keys[slot] != 0L) {
+          slot = slot + 1 and mask
+        }
+        keys[slot] = existing
+      }
+    }
+  }
+
+  /**
+   * Allocate new internal buffers. This method attempts to allocate
+   * and assign internal buffers atomically (either allocations succeed or not).
+   */
+  private fun allocateBuffers(arraySize: Int) {
+    // Ensure no change is done if we hit an OOM.
+    val prevKeys = this.keys
+    try {
+      val emptyElementSlot = 1
+      this.keys = LongArray(arraySize + emptyElementSlot)
+    } catch (e: OutOfMemoryError) {
+      this.keys = prevKeys
+      throw RuntimeException(
+          String.format(
+              Locale.ROOT,
+              "Not enough memory to allocate buffers for rehashing: %,d -> %,d",
+              size(),
+              arraySize
+          ), e
+      )
+    }
+
+    this.resizeAt = HHPC.expandAtCount(arraySize, loadFactor)
+    this.mask = arraySize - 1
+  }
+
+  private fun allocateThenInsertThenRehash(
+    slot: Int,
+    pendingKey: Long
+  ) {
+    // Try to allocate new buffers first. If we OOM, we leave in a consistent state.
+    val prevKeys = this.keys
+    allocateBuffers(HHPC.nextBufferSize(mask + 1, size(), loadFactor))
+
+    // We have succeeded at allocating new data so insert the pending key/value at
+    // the free slot in the old arrays before rehashing.
+    prevKeys[slot] = pendingKey
+
+    // Rehash old keys, including the pending key.
+    rehash(prevKeys)
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java
deleted file mode 100644
index ad43d493..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.lang.ref.WeakReference;
-import java.util.Collection;
-import java.util.List;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_MPREVIEW2;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_M_POSTPREVIEW2;
-import static com.squareup.leakcanary.TestUtil.analyze;
-import static java.util.Arrays.asList;
-import static org.hamcrest.core.StringContains.containsString;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-
-@RunWith(Parameterized.class) //
-public class AsyncTaskLeakTest {
-
-  static final String ASYNC_TASK_THREAD = "AsyncTask #1";
-  static final String ASYNC_TASK_CLASS = "android.os.AsyncTask";
-  static final String EXECUTOR_FIELD_1 = "SERIAL_EXECUTOR";
-  static final String EXECUTOR_FIELD_2 = "sDefaultExecutor";
-
-  @Parameterized.Parameters public static Collection<Object[]> data() {
-    return asList(new Object[][] {
-        { ASYNC_TASK }, //
-        { ASYNC_TASK_MPREVIEW2 }, //
-        { ASYNC_TASK_M_POSTPREVIEW2 } //
-    });
-  }
-
-  private final TestUtil.HeapDumpFile heapDumpFile;
-  ExcludedRefs.BuilderWithParams excludedRefs;
-
-  public AsyncTaskLeakTest(TestUtil.HeapDumpFile heapDumpFile) {
-    this.heapDumpFile = heapDumpFile;
-  }
-
-  @Before public void setUp() {
-    excludedRefs = new ExcludedRefs.BuilderWithParams().clazz(WeakReference.class.getName())
-        .alwaysExclude()
-        .clazz("java.lang.ref.FinalizerReference")
-        .alwaysExclude();
-  }
-
-  @Test public void leakFound() {
-    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
-    assertTrue(result.leakFound);
-    assertFalse(result.excludedLeak);
-    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
-    assertEquals(Thread.class.getName(), gcRoot.className);
-    assertEquals(THREAD, gcRoot.holder);
-    assertThat(gcRoot.extra, containsString(ASYNC_TASK_THREAD));
-  }
-
-  @Test public void excludeThread() {
-    excludedRefs.thread(ASYNC_TASK_THREAD);
-    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
-    assertTrue(result.leakFound);
-    assertFalse(result.excludedLeak);
-    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
-    assertEquals(ASYNC_TASK_CLASS, gcRoot.className);
-    assertEquals(STATIC_FIELD, gcRoot.type);
-    assertTrue(gcRoot.referenceName.equals(EXECUTOR_FIELD_1) || gcRoot.referenceName.equals(
-        EXECUTOR_FIELD_2));
-  }
-
-  @Test public void excludeStatic() {
-    excludedRefs.thread(ASYNC_TASK_THREAD).named(ASYNC_TASK_THREAD);
-    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_1).named(EXECUTOR_FIELD_1);
-    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_2).named(EXECUTOR_FIELD_2);
-    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
-    assertTrue(result.leakFound);
-    assertTrue(result.excludedLeak);
-    LeakTrace leakTrace = result.leakTrace;
-    List<LeakTraceElement> elements = leakTrace.elements;
-    Exclusion exclusion = elements.get(0).exclusion;
-
-    List<String> expectedExclusions = asList(ASYNC_TASK_THREAD, EXECUTOR_FIELD_1, EXECUTOR_FIELD_2);
-    assertTrue(expectedExclusions.contains(exclusion.name));
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java
deleted file mode 100644
index ba62c2ad..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java
+++ /dev/null
@@ -1,101 +0,0 @@
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.io.HprofBuffer;
-
-import java.io.UnsupportedEncodingException;
-import java.util.List;
-
-public final class FakeHprofBuffer implements HprofBuffer {
-  private List<Byte> byteList;
-  private List<byte[]> byteArrayList;
-
-  private int[] intsToRead;
-  private int intIndex = -1;
-  private String[] stringsToRead;
-  private int stringIndex = -1;
-
-  public void setIntsToRead(int... ints) {
-    intsToRead = ints;
-    intIndex = 0;
-  }
-
-  public void setStringsToRead(String... strings) {
-    stringsToRead = strings;
-    stringIndex = 0;
-  }
-
-  @Override
-  public byte readByte() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public void read(byte[] bytes) {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public void readSubSequence(byte[] bytes, int start, int length) {
-    if (stringsToRead == null || stringIndex < 0 || stringIndex >= stringsToRead.length) {
-      throw new UnsupportedOperationException("no bytes to read");
-    }
-
-    String s = stringsToRead[stringIndex++];
-    try {
-      System.arraycopy(s.getBytes("UTF-16BE"), start, bytes, 0, length);
-    } catch (UnsupportedEncodingException e) {
-      throw new UnsupportedOperationException(e);
-    }
-  }
-
-  @Override
-  public char readChar() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public short readShort() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public int readInt() {
-    if (intsToRead == null || intIndex < 0 || intIndex >= intsToRead.length) {
-      throw new UnsupportedOperationException("no bytes to read");
-    }
-    return intsToRead[intIndex++];
-  }
-
-  @Override
-  public long readLong() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public float readFloat() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public double readDouble() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public void setPosition(long l) {}
-
-  @Override
-  public long position() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public boolean hasRemaining() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public long remaining() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
deleted file mode 100644
index 03178cbe..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
+++ /dev/null
@@ -1,146 +0,0 @@
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.ArrayInstance;
-import com.squareup.haha.perflib.ClassInstance;
-import com.squareup.haha.perflib.ClassObj;
-import com.squareup.haha.perflib.Field;
-import com.squareup.haha.perflib.Snapshot;
-import com.squareup.haha.perflib.Type;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public class HahaHelperTest {
-  private static final int STRING_CLASS_ID = 100;
-  private static final int CHAR_ARRAY_CLASS_ID = 101;
-  private static final int STRING_INSTANCE_ID = 102;
-  private static final int VALUE_ARRAY_INSTANCE_ID = 103;
-
-  private static final int VALUE_ARRAY_LENGTH = 6;
-  private static final int COUNT_VALUE = 5;
-  private static final int OFFSET_VALUE = 1;
-
-  private FakeHprofBuffer buffer;
-  private Snapshot snapshot;
-
-  @Before
-  public void setUp() {
-    buffer = new FakeHprofBuffer();
-
-    snapshot = new Snapshot(buffer);
-    // set HPROF identifier size; required for Object instance field lookups
-    // cf. https://java.net/downloads/heap-snapshot/hprof-binary-format.html
-    snapshot.setIdSize(4);
-  }
-
-  @Test
-  public void readStringOffsetFromHeapDumpInstance() {
-    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
-    buffer.setStringsToRead("abcdef");
-
-    addStringClassToSnapshotWithFields(snapshot, new Field[]{
-            new Field(Type.INT, "count"),
-            new Field(Type.INT, "offset"),
-            new Field(Type.OBJECT, "value")
-    });
-
-    ClassInstance stringInstance = createStringInstance();
-    createCharArrayValueInstance();
-
-    String actual = HahaHelper.asString(stringInstance);
-    assertTrue(actual.equals("bcdef"));
-  }
-
-  @Test
-  public void defaultToZeroStringOffsetWhenHeapDumpInstanceIsMissingOffsetValue() {
-    buffer.setIntsToRead(COUNT_VALUE, VALUE_ARRAY_INSTANCE_ID);
-    buffer.setStringsToRead("abcdef");
-
-    addStringClassToSnapshotWithFields(snapshot, new Field[]{
-            new Field(Type.INT, "count"),
-            new Field(Type.OBJECT, "value")
-    });
-
-    ClassInstance stringInstance = createStringInstance();
-    createCharArrayValueInstance();
-
-    String actual = HahaHelper.asString(stringInstance);
-    assertTrue(actual.equals("abcde"));
-  }
-
-  @Test
-  public void defaultToZeroStringOffsetWhenReadingMPreview2HeapDump() {
-    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
-    buffer.setStringsToRead("abcdef");
-
-    addStringClassToSnapshotWithFields(snapshot, new Field[]{
-            new Field(Type.INT, "count"),
-            new Field(Type.INT, "offset"),
-            new Field(Type.OBJECT, "value")
-    });
-
-    ClassInstance stringInstance = createStringInstance();
-    createCharArrayValueInstance_M_Preview2();
-
-    String actual = HahaHelper.asString(stringInstance);
-    assertTrue(actual.equals("abcde"));
-  }
-
-  @Test
-  public void throwExceptionWhenMissingCharArrayValueForStringInMPreview2HeapDump() {
-    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
-    buffer.setStringsToRead("abcdef");
-
-    addStringClassToSnapshotWithFields(snapshot, new Field[]{
-            new Field(Type.INT, "count"),
-            new Field(Type.INT, "offset"),
-            new Field(Type.OBJECT, "value")
-    });
-
-    ClassInstance stringInstance = createStringInstance();
-    createObjectValueInstance_M_Preview2();
-
-    try {
-      HahaHelper.asString(stringInstance);
-      fail("this test should have thrown UnsupportedOperationException");
-    }
-    catch (UnsupportedOperationException uoe) {
-      String message = uoe.getMessage();
-      assertTrue(message.equals("Could not find char array in " + stringInstance));
-    }
-  }
-
-  private void addStringClassToSnapshotWithFields(Snapshot snapshot, Field[] fields) {
-    ClassObj charArrayClass = new ClassObj(0, null, "char[]", 0);
-    snapshot.addClass(CHAR_ARRAY_CLASS_ID, charArrayClass);
-
-    ClassObj stringClass = new ClassObj(0, null, "string", 0);
-    stringClass.setFields(fields);
-    snapshot.addClass(STRING_CLASS_ID, stringClass);
-  }
-
-  private void createCharArrayValueInstance() {
-    ArrayInstance valueArrayInstance = new ArrayInstance(0, null, Type.CHAR, VALUE_ARRAY_LENGTH, 0);
-    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID, valueArrayInstance);
-  }
-
-  private void createCharArrayValueInstance_M_Preview2() {
-    ArrayInstance valueInstance = new ArrayInstance(0, null, Type.CHAR, VALUE_ARRAY_LENGTH, 0);
-    snapshot.addInstance(STRING_INSTANCE_ID + 16, valueInstance);
-  }
-
-  private void createObjectValueInstance_M_Preview2() {
-    ClassInstance valueInstance = new ClassInstance(0, null, 0);
-    snapshot.addInstance(STRING_INSTANCE_ID + 16, valueInstance);
-  }
-
-  private ClassInstance createStringInstance() {
-    ClassInstance stringInstance = new ClassInstance(STRING_INSTANCE_ID, null, 100);
-    stringInstance.setClassId(STRING_CLASS_ID);
-    snapshot.addInstance(0, stringInstance);
-    return stringInstance;
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
deleted file mode 100644
index 0d5607d8..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.RootObj;
-import com.squareup.haha.perflib.Snapshot;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-
-import static com.squareup.haha.perflib.RootType.NATIVE_STATIC;
-import static com.squareup.haha.perflib.RootType.SYSTEM_CLASS;
-import static java.util.Arrays.asList;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class HeapAnalyzerTest {
-  private static final ExcludedRefs NO_EXCLUDED_REFS = null;
-  private static final List<RootObj> DUP_ROOTS =
-          asList(new RootObj(SYSTEM_CLASS, 6L),
-                  new RootObj(SYSTEM_CLASS, 5L),
-                  new RootObj(SYSTEM_CLASS, 3L),
-                  new RootObj(SYSTEM_CLASS, 5L),
-                  new RootObj(NATIVE_STATIC, 3L));
-
-  private HeapAnalyzer heapAnalyzer;
-
-  @Before
-  public void setUp() {
-    heapAnalyzer = new HeapAnalyzer(NO_EXCLUDED_REFS);
-  }
-
-  @Test
-  public void ensureUniqueRoots() {
-    Snapshot snapshot = createSnapshot(DUP_ROOTS);
-
-    heapAnalyzer.deduplicateGcRoots(snapshot);
-
-    Collection<RootObj> uniqueRoots = snapshot.getGCRoots();
-    assertThat(uniqueRoots).hasSize(4);
-
-    List<Long> rootIds = new ArrayList<>();
-    for (RootObj root : uniqueRoots) {
-      rootIds.add(root.getId());
-    }
-    Collections.sort(rootIds);
-
-    // 3 appears twice because even though two RootObjs have the same id, they're different types.
-    assertThat(rootIds).containsExactly(3L, 3L, 5L, 6L);
-  }
-
-  private Snapshot createSnapshot(List<RootObj> gcRoots) {
-    Snapshot snapshot = new Snapshot(null);
-    for (RootObj root : gcRoots) {
-      snapshot.addRoot(root);
-    }
-    return snapshot;
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java
deleted file mode 100644
index a414687d..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package com.squareup.leakcanary;
-
-import java.lang.ref.WeakReference;
-import java.util.Arrays;
-import java.util.Collection;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_MPREVIEW2;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_M_POSTPREVIEW2;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER_IGNORED;
-import static com.squareup.leakcanary.TestUtil.analyze;
-import static org.junit.Assert.assertEquals;
-
-/**
- * This test makes sure there is no regression on the retained size calculation.
- */
-@RunWith(Parameterized.class) //
-public class RetainedSizeTest {
-
-  @Parameterized.Parameters public static Collection<Object[]> data() {
-    return Arrays.asList(new Object[][] {
-        { ASYNC_TASK, 207_407 }, //
-        { ASYNC_TASK_MPREVIEW2, 1_604 }, //
-        { ASYNC_TASK_M_POSTPREVIEW2, 1_870 }, //
-        { SERVICE_BINDER, 378 }, //
-        { SERVICE_BINDER_IGNORED, 378 }, //
-    });
-  }
-
-  private final TestUtil.HeapDumpFile heapDumpFile;
-  private final long expectedRetainedHeapSize;
-  ExcludedRefs.BuilderWithParams excludedRefs;
-
-  public RetainedSizeTest(TestUtil.HeapDumpFile heapDumpFile, long expectedRetainedHeapSize) {
-    this.heapDumpFile = heapDumpFile;
-    this.expectedRetainedHeapSize = expectedRetainedHeapSize;
-  }
-
-  @Before public void setUp() {
-    excludedRefs = new ExcludedRefs.BuilderWithParams().clazz(WeakReference.class.getName())
-        .alwaysExclude()
-        .clazz("java.lang.ref.FinalizerReference")
-        .alwaysExclude();
-  }
-
-  @Test public void leakFound() {
-    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
-    assertEquals(expectedRetainedHeapSize, result.retainedHeapSize);
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/ServiceBinderLeakTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/ServiceBinderLeakTest.java
deleted file mode 100644
index a54feeb1..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/ServiceBinderLeakTest.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.lang.ref.WeakReference;
-import org.junit.Before;
-import org.junit.Test;
-
-import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.OBJECT;
-import static com.squareup.leakcanary.LeakTraceElement.Type.INSTANCE_FIELD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER_IGNORED;
-import static com.squareup.leakcanary.TestUtil.analyze;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-/**
- * leak_service_binder_ignored.hprof contains a "normal" leak when binding to a service, where
- * leak_service_binder.hprof contains a leak where a binder is leaked by a static field.
- */
-public class ServiceBinderLeakTest {
-
-  ExcludedRefs.BuilderWithParams excludedRefs;
-
-  @Before public void setUp() {
-    excludedRefs = new ExcludedRefs.BuilderWithParams().clazz(WeakReference.class.getName())
-        .alwaysExclude()
-        .clazz("java.lang.ref.FinalizerReference")
-        .alwaysExclude();
-  }
-
-  @Test public void realBinderLeak() {
-    excludedRefs.rootClass("android.os.Binder").alwaysExclude();
-
-    AnalysisResult result = analyze(SERVICE_BINDER, excludedRefs);
-
-    assertTrue(result.leakFound);
-    assertFalse(result.excludedLeak);
-    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
-    assertEquals(STATIC_FIELD, gcRoot.type);
-    assertEquals("com.example.leakcanary.LeakyService", gcRoot.className);
-    assertEquals(CLASS, gcRoot.holder);
-  }
-
-  @Test public void ignorableBinderLeak() {
-    excludedRefs.rootClass("android.os.Binder");
-
-    AnalysisResult result = analyze(SERVICE_BINDER_IGNORED, excludedRefs);
-
-    assertTrue(result.leakFound);
-    assertTrue(result.excludedLeak);
-    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
-    assertEquals(INSTANCE_FIELD, gcRoot.type);
-    assertEquals("com.example.leakcanary.LeakyService$MyBinder", gcRoot.className);
-    assertEquals(OBJECT, gcRoot.holder);
-  }
-
-  @Test public void alwaysIgnorableBinderLeak() {
-    excludedRefs.rootClass("android.os.Binder").alwaysExclude();
-
-    AnalysisResult result = analyze(SERVICE_BINDER_IGNORED, excludedRefs);
-
-    assertFalse(result.leakFound);
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
deleted file mode 100644
index e3666e5d..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.File;
-import java.net.URL;
-
-final class TestUtil {
-
-  enum HeapDumpFile {
-    ASYNC_TASK("leak_asynctask.hprof", "dc983a12-d029-4003-8890-7dd644c664c5"),
-    ASYNC_TASK_MPREVIEW2("leak_asynctask_mpreview2.hprof", "1114018e-e154-435f-9a3d-da63ae9b47fa"),
-    ASYNC_TASK_M_POSTPREVIEW2("leak_asynctask_m_postpreview2.hprof",
-        "25ae1778-7c1d-4ec7-ac50-5cce55424069"),
-
-    SERVICE_BINDER("leak_service_binder.hprof", "b3abfae6-2c53-42e1-b8c1-96b0558dbeae"),
-    SERVICE_BINDER_IGNORED("leak_service_binder_ignored.hprof",
-        "6e524414-9581-4ce7-8690-e8ddf8b82454"),;
-
-    private final String filename;
-    private final String referenceKey;
-
-    HeapDumpFile(String filename, String referenceKey) {
-      this.filename = filename;
-      this.referenceKey = referenceKey;
-    }
-
-  }
-
-  static File fileFromName(String filename) {
-    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
-    URL url = classLoader.getResource(filename);
-    return new File(url.getPath());
-  }
-
-  static AnalysisResult analyze(HeapDumpFile heapDumpFile, ExcludedRefs.BuilderWithParams excludedRefs) {
-    File file = fileFromName(heapDumpFile.filename);
-    String referenceKey = heapDumpFile.referenceKey;
-    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(excludedRefs.build());
-    AnalysisResult result = heapAnalyzer.checkForLeak(file, referenceKey);
-    if (result.failure != null) {
-      result.failure.printStackTrace();
-    }
-    if (result.leakTrace != null) {
-      System.out.println(result.leakTrace);
-    }
-    return result;
-  }
-
-  private TestUtil() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt
new file mode 100644
index 00000000..f0df046b
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt
@@ -0,0 +1,133 @@
+package leakcanary.internal
+
+import leakcanary.Exclusion
+import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
+import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
+import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
+import leakcanary.Exclusion.Status.NEVER_REACHABLE
+import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
+import leakcanary.Exclusion.Status.WONT_FIX_LEAK
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.KeyedWeakReference
+import leakcanary.LeakingInstance
+import leakcanary.NoPathToInstance
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+import java.lang.ref.WeakReference
+
+class ExclusionTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun shortestPathExcluded() {
+    hprofFile.writeTwoPathsToInstance()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        exclusions = listOf(Exclusion(StaticFieldExclusion("GcRoot", "shortestPath")))
+    )
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements).hasSize(3)
+    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
+    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("longestPath")
+    assertThat(leak.leakTrace.elements[1].className).isEqualTo("HasLeaking")
+    assertThat(leak.leakTrace.elements[1].reference!!.name).isEqualTo("leaking")
+    assertThat(leak.leakTrace.elements[2].className).isEqualTo("Leaking")
+  }
+
+  @Test fun allPathsExcluded_ShortestWins() {
+    hprofFile.writeTwoPathsToInstance()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        exclusions = listOf(
+            Exclusion(StaticFieldExclusion("GcRoot", "shortestPath")),
+            Exclusion(InstanceFieldExclusion("HasLeaking", "leaking"))
+        )
+    )
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.exclusionStatus).isEqualTo(WONT_FIX_LEAK)
+    assertThat(leak.leakTrace.elements).hasSize(2)
+    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
+    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("shortestPath")
+    assertThat(leak.leakTrace.elements[1].className).isEqualTo("Leaking")
+  }
+
+  @Test fun noPathToInstanceNeverReachable() {
+    hprofFile.writeTwoPathsToInstance()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        exclusions = listOf(
+            Exclusion(StaticFieldExclusion("GcRoot", "shortestPath"), status = NEVER_REACHABLE),
+            Exclusion(InstanceFieldExclusion("HasLeaking", "leaking"), status = NEVER_REACHABLE)
+        )
+    )
+    assertThat(analysis.retainedInstances[0]).isInstanceOf(NoPathToInstance::class.java)
+  }
+
+  @Test fun excludedThread() {
+    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        exclusions = listOf(Exclusion(JavaLocalExclusion("kroutine"), status = WONT_FIX_LEAK))
+    )
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.exclusionStatus).isEqualTo(WONT_FIX_LEAK)
+  }
+
+  @Test fun weaklyReachableExclusion() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["ref"] =
+          keyedWeakReference(className = "Leaking", referentInstanceId = "Leaking" instance {})
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        exclusions = listOf(
+            Exclusion(
+                type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
+                status = WEAKLY_REACHABLE
+            )
+        )
+    )
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.exclusionStatus).isEqualTo(WEAKLY_REACHABLE)
+  }
+
+  @Test fun overrideSuperclassExclusion() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["ref"] =
+          keyedWeakReference(className = "Leaking", referentInstanceId = "Leaking" instance {})
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        exclusions = listOf(
+            Exclusion(
+                type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
+                status = WEAKLY_REACHABLE
+            ), Exclusion(
+            type = InstanceFieldExclusion(KeyedWeakReference::class.java.name, "referent"),
+            status = NEVER_REACHABLE
+        )
+        )
+    )
+    assertThat(analysis.retainedInstances[0]).isInstanceOf(NoPathToInstance::class.java)
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
new file mode 100644
index 00000000..4665e516
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
@@ -0,0 +1,142 @@
+package leakcanary.internal
+
+import leakcanary.GcRoot.ThreadObject
+import leakcanary.HeapAnalysis
+import leakcanary.HeapAnalysisFailure
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.LeakTraceElement.Type.LOCAL
+import leakcanary.LeakingInstance
+import leakcanary.NoPathToInstance
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+
+class HeapAnalyzerTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun singlePathToInstance() {
+    hprofFile.writeSinglePathToInstance()
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    assertThat(analysis.retainedInstances[0]).isInstanceOf(LeakingInstance::class.java)
+  }
+
+  @Test fun pathToString() {
+    hprofFile.writeSinglePathToString()
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+
+    assertThat(leak.instanceClassName).isEqualTo("java.lang.String")
+  }
+
+  @Test fun pathToCharArray() {
+    hprofFile.writeSinglePathsToCharArrays(listOf("Hello"))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.instanceClassName).isEqualTo("char[]")
+  }
+
+  // Two char arrays to ensure we keep going after finding the first one
+  @Test fun pathToTwoCharArrays() {
+    hprofFile.writeSinglePathsToCharArrays(listOf("Hello", "World"))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysis>()
+    assertThat(analysis).isInstanceOf(HeapAnalysisSuccess::class.java)
+  }
+
+  @Test fun shortestPath() {
+    hprofFile.writeTwoPathsToInstance()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements).hasSize(2)
+    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
+    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("shortestPath")
+    assertThat(leak.leakTrace.elements[1].className).isEqualTo("Leaking")
+  }
+
+  @Test fun noPathToInstance() {
+    hprofFile.writeNoPathToInstance()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    assertThat(analysis.retainedInstances[0]).isInstanceOf(NoPathToInstance::class.java)
+  }
+
+  @Test fun weakRefCleared() {
+    hprofFile.writeWeakReferenceCleared()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisFailure>()
+    assertThat(analysis.exception.cause).isInstanceOf(IllegalStateException::class.java)
+        .hasMessage("No retained instances found in heap dump")
+  }
+
+  @Test fun failsNoRetainedKeys() {
+    hprofFile.writeMultipleActivityLeaks(0)
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysis>()
+
+    assertThat(analysis).isInstanceOf(HeapAnalysisFailure::class.java)
+  }
+
+  @Test fun findMultipleLeaks() {
+    hprofFile.writeMultipleActivityLeaks(5)
+
+    val leaks = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    assertThat(leaks.retainedInstances).hasSize(5)
+        .hasOnlyElementsOfType(LeakingInstance::class.java)
+  }
+
+  @Test fun localVariableLeak() {
+    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements).hasSize(2)
+    assertThat(leak.leakTrace.elements[0].className).isEqualTo("MyThread")
+    assertThat(leak.leakTrace.elements[0].reference!!.type).isEqualTo(LOCAL)
+    assertThat(leak.leakTrace.elements[1].className).isEqualTo("Leaking")
+  }
+
+  @Test fun threadFieldLeak() {
+    hprofFile.dump {
+      val threadClassId =
+        clazz(className = "java.lang.Thread", fields = listOf("name" to ObjectReference::class))
+      val myThreadClassId = clazz(
+          className = "MyThread", superClassId = threadClassId,
+          fields = listOf("leaking" to ObjectReference::class)
+      )
+      val threadInstance =
+        instance(myThreadClassId, listOf("Leaking" watchedInstance {}, string("Thread Name")))
+      gcRoot(
+          ThreadObject(
+              id = threadInstance.value, threadSerialNumber = 42, stackTraceSerialNumber = 0
+          )
+      )
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements).hasSize(2)
+    assertThat(leak.leakTrace.elements[0].className).isEqualTo("MyThread")
+    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("leaking")
+    assertThat(leak.leakTrace.elements[1].className).isEqualTo("Leaking")
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt
new file mode 100644
index 00000000..9d61a1e4
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt
@@ -0,0 +1,140 @@
+package leakcanary.internal
+
+import leakcanary.GcRoot.JavaFrame
+import leakcanary.GcRoot.ThreadObject
+import leakcanary.HeapValue.BooleanValue
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.HprofWriter
+import java.io.File
+
+fun File.writeWeakReferenceCleared() {
+  HprofWriter.open(this)
+      .helper {
+        keyedWeakReference("Leaking", ObjectReference(0))
+      }
+}
+
+fun File.writeNoPathToInstance() {
+  HprofWriter.open(this)
+      .helper {
+        keyedWeakReference("Leaking", instance(clazz("Leaking")))
+      }
+}
+
+fun File.writeSinglePathToInstance() {
+  HprofWriter.open(this)
+      .helper {
+        val leaking = instance(clazz("Leaking"))
+        keyedWeakReference("Leaking", leaking)
+        clazz(
+            "GcRoot", staticFields = listOf(
+            "shortestPath" to leaking
+        )
+        )
+      }
+}
+
+fun File.writeSinglePathToString(value: String = "Hi") {
+  HprofWriter.open(this)
+      .helper {
+        val leaking = string(value)
+        keyedWeakReference("java.lang.String", leaking)
+        clazz(
+            "GcRoot", staticFields = listOf(
+            "shortestPath" to leaking
+        )
+        )
+      }
+}
+
+fun File.writeSinglePathsToCharArrays(values: List<String>) {
+  HprofWriter.open(this)
+      .helper {
+        val arrays = mutableListOf<Long>()
+        values.forEach {
+          val leaking = it.charArrayDump
+          keyedWeakReference("char[]", leaking)
+          arrays.add(leaking.value)
+        }
+        clazz(
+            className = "GcRoot",
+            staticFields = listOf(
+                "arrays" to ObjectReference(
+                    objectArray(clazz("char[][]"), arrays.toLongArray())
+                )
+            )
+        )
+
+      }
+}
+
+fun File.writeTwoPathsToInstance() {
+  HprofWriter.open(this)
+      .helper {
+        val leaking = instance(clazz("Leaking"))
+        keyedWeakReference("Leaking", leaking)
+        val hasLeaking = instance(
+            clazz("HasLeaking", fields = listOf("leaking" to ObjectReference::class)),
+            fields = listOf(leaking)
+        )
+        clazz(
+            "GcRoot", staticFields = listOf(
+            "shortestPath" to leaking,
+            "longestPath" to hasLeaking
+        )
+        )
+      }
+}
+
+fun File.writeMultipleActivityLeaks(leakCount: Int) {
+  HprofWriter.open(this)
+      .helper {
+        val activityClassId = clazz(
+            className = "android.app.Activity",
+            fields = listOf("mDestroyed" to BooleanValue::class)
+        )
+        val exampleActivityClassId = clazz(
+            superClassId = activityClassId,
+            className = "com.example.ExampleActivity"
+        )
+        val activityArrayClassId = arrayClass("com.example.ExampleActivity")
+
+        val destroyedActivities = mutableListOf<ObjectReference>()
+        for (i in 1..leakCount) {
+          destroyedActivities.add(instance(exampleActivityClassId, listOf(BooleanValue(true))))
+        }
+
+        clazz(
+            className = "com.example.ActivityHolder",
+            staticFields = listOf(
+                "activities" to
+                    objectArrayOf(
+                        activityArrayClassId, *destroyedActivities.toTypedArray()
+                    )
+            )
+        )
+        destroyedActivities.forEach { instanceId ->
+          keyedWeakReference("com.example.ExampleActivity", instanceId)
+        }
+      }
+}
+
+fun File.writeJavaLocalLeak(
+  threadClass: String,
+  threadName: String
+) {
+  dump {
+    val threadClassId =
+      clazz(className = "java.lang.Thread", fields = listOf("name" to ObjectReference::class))
+    val myThreadClassId = clazz(className = threadClass, superClassId = threadClassId)
+    val threadInstance = instance(myThreadClassId, listOf(string(threadName)))
+    gcRoot(
+        ThreadObject(
+            id = threadInstance.value, threadSerialNumber = 42, stackTraceSerialNumber = 0
+        )
+    )
+
+    val leaking = "Leaking" watchedInstance {}
+    gcRoot(JavaFrame(id = leaking.value, threadSerialNumber = 42, frameNumber = 0))
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
new file mode 100644
index 00000000..d4e0b835
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
@@ -0,0 +1,304 @@
+package leakcanary.internal
+
+import leakcanary.GcRoot
+import leakcanary.GcRoot.StickyClass
+import leakcanary.HeapValue
+import leakcanary.HeapValue.BooleanValue
+import leakcanary.HeapValue.ByteValue
+import leakcanary.HeapValue.CharValue
+import leakcanary.HeapValue.DoubleValue
+import leakcanary.HeapValue.FloatValue
+import leakcanary.HeapValue.IntValue
+import leakcanary.HeapValue.LongValue
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.HeapValue.ShortValue
+import leakcanary.HprofReader
+import leakcanary.HprofWriter
+import leakcanary.Record.HeapDumpRecord.GcRootRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import leakcanary.Record.LoadClassRecord
+import leakcanary.Record.StringRecord
+import okio.Buffer
+import java.io.Closeable
+import java.io.File
+import java.util.UUID
+import kotlin.reflect.KClass
+
+class HprofWriterHelper constructor(
+  private val writer: HprofWriter
+) : Closeable {
+
+  private var lastId = 0L
+  private val id: Long
+    get() = ++lastId
+
+  private val typeSizes = mapOf(
+      // object
+      HprofReader.OBJECT_TYPE to writer.idSize,
+      HprofReader.BOOLEAN_TYPE to HprofReader.BOOLEAN_SIZE,
+      HprofReader.CHAR_TYPE to HprofReader.CHAR_SIZE,
+      HprofReader.FLOAT_TYPE to HprofReader.FLOAT_SIZE,
+      HprofReader.DOUBLE_TYPE to HprofReader.DOUBLE_SIZE,
+      HprofReader.BYTE_TYPE to HprofReader.BYTE_SIZE,
+      HprofReader.SHORT_TYPE to HprofReader.SHORT_SIZE,
+      HprofReader.INT_TYPE to HprofReader.INT_SIZE,
+      HprofReader.LONG_TYPE to HprofReader.LONG_SIZE
+  )
+
+  private val classDumps = mutableMapOf<Long, ClassDumpRecord>()
+
+  private val objectClassId = clazz(superClassId = 0, className = "java.lang.Object")
+  private val objectArrayClassId = arrayClass("java.lang.Object")
+  private val stringClassId = clazz(
+      className = "java.lang.String", fields = listOf(
+      "value" to ObjectReference::class,
+      "count" to IntValue::class
+  )
+  )
+
+  private val referenceClassId  = clazz(
+      className = "java.lang.ref.Reference",
+      fields = listOf(
+          "referent" to ObjectReference::class
+      )
+  )
+
+  private val weakReferenceClassId = clazz(
+      className = "java.lang.ref.WeakReference",
+      superClassId = referenceClassId
+  )
+  private val keyedWeakReferenceClassId = clazz(
+      superClassId = weakReferenceClassId,
+      className = "leakcanary.KeyedWeakReference",
+      staticFields = listOf("heapDumpUptimeMillis" to LongValue(Long.MAX_VALUE)),
+      fields = listOf(
+          "key" to ObjectReference::class,
+          "name" to ObjectReference::class,
+          "className" to ObjectReference::class,
+          "watchUptimeMillis" to LongValue::class,
+          "retainedUptimeMillis" to LongValue::class
+      )
+  )
+
+  fun clazz(
+    className: String,
+    superClassId: Long = -1L, // -1 defaults to java.lang.Object
+    staticFields: List<Pair<String, HeapValue>> = emptyList(),
+    fields: List<Pair<String, KClass<out HeapValue>>> = emptyList()
+  ): Long {
+    val classNameRecord = StringRecord(id, className)
+    writer.write(classNameRecord)
+    val loadClass = LoadClassRecord(1, id, 1, classNameRecord.id)
+    writer.write(loadClass)
+
+    val staticFieldRecords = staticFields.map {
+      val fieldName = StringRecord(id, it.first)
+      writer.write(fieldName)
+      StaticFieldRecord(fieldName.id, typeOf(it.second), it.second)
+    }
+
+    val fieldRecords = fields.map {
+      val fieldName = StringRecord(id, it.first)
+      writer.write(fieldName)
+      FieldRecord(fieldName.id, typeOf(it.second))
+    }
+
+    var instanceSize = fieldRecords.sumBy {
+      typeSizes.getValue(it.type)
+    }
+
+    var nextUpId = if (superClassId == -1L) objectClassId else superClassId
+    while (nextUpId != 0L) {
+      val nextUp = classDumps[nextUpId]!!
+      instanceSize += nextUp.fields.sumBy {
+        typeSizes.getValue(it.type)
+      }
+      nextUpId = nextUp.superClassId
+    }
+    val classDump = ClassDumpRecord(
+        id = loadClass.id,
+        stackTraceSerialNumber = 1,
+        superClassId = if (superClassId == -1L) objectClassId else superClassId,
+        classLoaderId = 0,
+        signersId = 0,
+        protectionDomainId = 0,
+        instanceSize = instanceSize,
+        staticFields = staticFieldRecords,
+        fields = fieldRecords
+    )
+    classDumps[loadClass.id] = classDump
+    writer.write(classDump)
+    val gcRoot = StickyClass(classDump.id)
+    gcRoot(gcRoot)
+    return classDump.id
+  }
+
+  fun gcRoot(gcRoot: GcRoot) {
+    val gcRootRecord = GcRootRecord(gcRoot = gcRoot)
+    writer.write(gcRootRecord)
+  }
+
+  fun arrayClass(className: String): Long {
+    return clazz(className = "$className[]")
+  }
+
+  fun string(
+    string: String
+  ): ObjectReference {
+    return instance(
+        stringClassId,
+        fields = listOf(string.charArrayDump, IntValue(string.length))
+    )
+  }
+
+  fun keyedWeakReference(
+    className: String,
+    referentInstanceId: ObjectReference
+  ): ObjectReference {
+    val referenceKey = string(UUID.randomUUID().toString())
+    return instance(
+        classId = keyedWeakReferenceClassId,
+        fields = listOf(
+            referenceKey,
+            string(""),
+            string(className),
+            LongValue(System.currentTimeMillis()),
+            LongValue(System.currentTimeMillis()),
+            ObjectReference(referentInstanceId.value)
+        )
+    )
+  }
+
+  fun instance(
+    classId: Long,
+    fields: List<HeapValue> = emptyList()
+  ): ObjectReference {
+    val fieldsBuffer = Buffer()
+    fields.forEach { value ->
+      with(writer) {
+        fieldsBuffer.writeValue(value)
+      }
+    }
+    val instanceDump = InstanceDumpRecord(
+        id = id,
+        stackTraceSerialNumber = 1,
+        classId = classId,
+        fieldValues = fieldsBuffer.readByteArray()
+    )
+    writer.write(instanceDump)
+    return ObjectReference(instanceDump.id)
+  }
+
+  inner class InstanceAndClassDefinition {
+    val field = LinkedHashMap<String, HeapValue>()
+    val staticField = LinkedHashMap<String, HeapValue>()
+  }
+
+  inner class ClassDefinition {
+    val staticField = LinkedHashMap<String, HeapValue>()
+  }
+
+  infix fun String.watchedInstance(block: InstanceAndClassDefinition.() -> Unit): ObjectReference {
+    val instance = this.instance(block)
+    keyedWeakReference("DummyClassName", instance)
+    return instance
+  }
+
+  infix fun String.instance(block: InstanceAndClassDefinition.() -> Unit): ObjectReference {
+    val definition = InstanceAndClassDefinition()
+    block(definition)
+
+    val classFields = definition.field.map {
+      it.key to it.value::class
+    }
+
+    val staticFields = definition.staticField.map { it.key to it.value }
+
+    val instanceFields = definition.field.map { it.value }
+
+    return instance(clazz(this, fields = classFields, staticFields = staticFields), instanceFields)
+  }
+
+  infix fun String.clazz(block: ClassDefinition.() -> Unit): Long {
+    val definition = ClassDefinition()
+    block(definition)
+
+    val staticFields = definition.staticField.map { it.key to it.value }
+    return clazz(this, staticFields = staticFields)
+  }
+
+  val String.charArrayDump: ObjectReference
+    get() {
+      val arrayDump = CharArrayDump(id, 1, toCharArray())
+      writer.write(arrayDump)
+      return ObjectReference(arrayDump.id)
+    }
+
+  fun objectArray(
+    vararg elements: ObjectReference
+  ): ObjectReference {
+    return objectArrayOf(objectArrayClassId, *elements)
+  }
+
+  fun objectArrayOf(
+    classId: Long,
+    vararg elements: ObjectReference
+  ): ObjectReference {
+    return ObjectReference(objectArray(classId, elements.map { it.value }.toLongArray()))
+  }
+
+  fun objectArray(
+    classId: Long,
+    array: LongArray
+  ): Long {
+    val arrayDump = ObjectArrayDumpRecord(id, 1, classId, array)
+    writer.write(arrayDump)
+    return arrayDump.id
+  }
+
+  private fun typeOf(wrapper: HeapValue): Int {
+    return when (wrapper) {
+      is ObjectReference -> HprofReader.OBJECT_TYPE
+      is BooleanValue -> HprofReader.BOOLEAN_TYPE
+      is CharValue -> HprofReader.CHAR_TYPE
+      is FloatValue -> HprofReader.FLOAT_TYPE
+      is DoubleValue -> HprofReader.DOUBLE_TYPE
+      is ByteValue -> HprofReader.BYTE_TYPE
+      is ShortValue -> HprofReader.SHORT_TYPE
+      is IntValue -> HprofReader.INT_TYPE
+      is LongValue -> HprofReader.LONG_TYPE
+    }
+  }
+
+  private fun typeOf(wrapperClass: KClass<out HeapValue>): Int {
+    return when (wrapperClass) {
+      ObjectReference::class -> HprofReader.OBJECT_TYPE
+      BooleanValue::class -> HprofReader.BOOLEAN_TYPE
+      CharValue::class -> HprofReader.CHAR_TYPE
+      FloatValue::class -> HprofReader.FLOAT_TYPE
+      DoubleValue::class -> HprofReader.DOUBLE_TYPE
+      ByteValue::class -> HprofReader.BYTE_TYPE
+      ShortValue::class -> HprofReader.SHORT_TYPE
+      IntValue::class -> HprofReader.INT_TYPE
+      LongValue::class -> HprofReader.LONG_TYPE
+      else -> throw IllegalArgumentException("Unexpected class $wrapperClass")
+    }
+  }
+
+  override fun close() {
+    writer.close()
+  }
+}
+
+fun File.dump(block: HprofWriterHelper.() -> Unit) {
+  HprofWriterHelper(HprofWriter.open(this)).use(block)
+}
+
+fun HprofWriter.helper(block: HprofWriterHelper.() -> Unit) {
+  HprofWriterHelper(this).use(block)
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
new file mode 100644
index 00000000..284f3248
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
@@ -0,0 +1,60 @@
+package leakcanary.internal
+
+import leakcanary.AndroidLeakTraceInspectors
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.HprofGraph
+import leakcanary.LeakTraceElementReporter
+import leakcanary.LeakTraceInspector
+import leakcanary.LeakingInstance
+import leakcanary.forEachInstanceOf
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+
+class LabelerTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun stringContentAsLabel() {
+    hprofFile.writeSinglePathToString("World")
+
+    val labeler = object : LeakTraceInspector{
+      override fun inspect(
+        graph: HprofGraph,
+        leakTrace: List<LeakTraceElementReporter>
+      ) {
+        leakTrace.forEachInstanceOf("java.lang.String")  { instance ->
+          addLabel("Hello ${instance.readAsJavaString()}")
+        }
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(leakTraceInspectors = listOf(labeler))
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+
+    assertThat(leak.leakTrace.elements.last().labels).isEqualTo(listOf("Hello World"))
+  }
+
+  @Test fun threadNameLabel() {
+    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(leakTraceInspectors = listOf(AndroidLeakTraceInspectors.THREAD))
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+
+    assertThat(leak.leakTrace.elements.first().labels).contains("Thread name: 'kroutine'")
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
new file mode 100644
index 00000000..761db959
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
@@ -0,0 +1,511 @@
+package leakcanary.internal
+
+import leakcanary.GraphObjectRecord.GraphClassRecord
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.HprofGraph
+import leakcanary.LeakNodeStatus.LEAKING
+import leakcanary.LeakNodeStatus.NOT_LEAKING
+import leakcanary.LeakNodeStatus.UNKNOWN
+import leakcanary.LeakTraceElementReporter
+import leakcanary.LeakTraceInspector
+import leakcanary.LeakingInstance
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+
+class LeakStatusTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun gcRootsNotLeaking() {
+    hprofFile.writeSinglePathToInstance()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+
+    assertThat(leak.leakTrace.elements.first().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
+  }
+
+  @Test fun leakingInstanceLeaking() {
+    hprofFile.writeSinglePathToInstance()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+
+    assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(LEAKING)
+  }
+
+  @Test fun defaultsToUnknown() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+
+    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(UNKNOWN)
+  }
+
+  @Test fun inspectorNotLeaking() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        leakTraceInspectors = listOf(notLeaking("Class1"))
+    )
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
+  }
+
+  @Test fun inspectorLeaking() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          leakTraceInspectors = listOf(leaking("Class1"))
+      )
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(LEAKING)
+  }
+
+  @Test fun leakingWinsUnknown() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          leakTraceInspectors = listOf(leaking("Class1"))
+      )
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(LEAKING)
+  }
+
+  @Test fun notLeakingWhenNextIsNotLeaking() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          leakTraceInspectors = listOf(notLeaking("Class3"))
+      )
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
+  }
+
+  @Test fun leakingWhenPreviousIsLeaking() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          leakTraceInspectors = listOf(leaking("Class1"))
+      )
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements[3].leakStatusAndReason.status).isEqualTo(LEAKING)
+  }
+
+  @Test fun notLeakingWinsConflicts() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          leakTraceInspectors = listOf(
+              notLeaking("Class3"), leaking("Class1")
+          )
+      )
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements[0].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements[0].leakStatusAndReason.reason).isEqualTo("it's a GC root")
+    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.reason).isEqualTo(
+        "Class2↓ is not leaking. Conflicts with Class1 is leaking"
+    )
+    assertThat(leak.leakTrace.elements[2].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements[2].leakStatusAndReason.reason).isEqualTo(
+        "Class3↓ is not leaking"
+    )
+    assertThat(leak.leakTrace.elements[3].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements[3].leakStatusAndReason.reason).isEqualTo(
+        "Class3 is not leaking"
+    )
+  }
+
+  @Test fun middleUnknown() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          leakTraceInspectors = listOf(
+              notLeaking("Class1"), leaking("Class3")
+          )
+      )
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements[2].leakStatusAndReason.status).isEqualTo(UNKNOWN)
+  }
+
+  @Test fun gcRootsNotLeakingConflictingWithInspector() {
+    hprofFile.writeSinglePathToInstance()
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          leakTraceInspectors = listOf(leaking("GcRoot"))
+      )
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+
+    assertThat(leak.leakTrace.elements.first().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements.first().leakStatusAndReason.reason).isEqualTo(
+        "it's a GC root. Conflicts with GcRoot is leaking"
+    )
+  }
+
+  @Test fun gcRootsNotLeakingAgreesWithInspector() {
+    hprofFile.writeSinglePathToInstance()
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          leakTraceInspectors = listOf(notLeaking("GcRoot"))
+      )
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+
+    assertThat(leak.leakTrace.elements.first().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements.first().leakStatusAndReason.reason).isEqualTo(
+        "it's a GC root and GcRoot is not leaking"
+    )
+  }
+
+  @Test fun leakingInstanceLeakingConflictingWithInspector() {
+    hprofFile.writeSinglePathToInstance()
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          leakTraceInspectors = listOf(notLeaking("Leaking"))
+      )
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(LEAKING)
+    assertThat(leak.leakTrace.elements.last().leakStatusAndReason.reason).isEqualTo(
+        "RefWatcher was watching this. Conflicts with Leaking is not leaking"
+    )
+  }
+
+  @Test fun leakingInstanceLeakingAgreesWithInspector() {
+    hprofFile.writeSinglePathToInstance()
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          leakTraceInspectors = listOf(leaking("Leaking"))
+      )
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(LEAKING)
+    assertThat(leak.leakTrace.elements.last().leakStatusAndReason.reason).isEqualTo(
+        "RefWatcher was watching this and Leaking is leaking"
+    )
+  }
+
+  @Test fun conflictNotLeakingWins() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          leakTraceInspectors = listOf(
+              notLeaking("Class1"), leaking("Class1")
+          )
+      )
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.reason).isEqualTo(
+        "Class1 is not leaking. Conflicts with Class1 is leaking"
+    )
+  }
+
+  @Test fun twoInspectorsAgreeNotLeaking() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          leakTraceInspectors = listOf(
+              notLeaking("Class1"), notLeaking("Class1")
+          )
+      )
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.reason).isEqualTo(
+        "Class1 is not leaking and Class1 is not leaking"
+    )
+  }
+
+  @Test fun twoInspectorsAgreeLeaking() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          leakTraceInspectors = listOf(leaking("Class1"), leaking("Class1"))
+      )
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(LEAKING)
+    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.reason).isEqualTo(
+        "Class1 is leaking and Class1 is leaking"
+    )
+  }
+
+  @Test fun leakCausesAreLastNotLeakingAndUnknown() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          leakTraceInspectors = listOf(
+              notLeaking("Class1"), leaking("Class3")
+          )
+      )
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elementMayBeLeakCause(0)).isFalse()
+    assertThat(leak.leakTrace.elementMayBeLeakCause(1)).isTrue()
+    assertThat(leak.leakTrace.elementMayBeLeakCause(2)).isTrue()
+    assertThat(leak.leakTrace.elementMayBeLeakCause(3)).isFalse()
+  }
+
+  @Test fun sameLeakTraceSameGroup() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+    val hash1 = computeGroupHash(notLeaking = "Class1", leaking = "Class3")
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+    val hash2 = computeGroupHash(notLeaking = "Class1", leaking = "Class3")
+    assertThat(hash1).isEqualTo(hash2)
+  }
+
+  @Test fun differentLeakTraceDifferentGroup() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1a"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+    val hash1 = computeGroupHash(notLeaking = "Class1", leaking = "Class3")
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1b"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+    val hash2 = computeGroupHash(notLeaking = "Class1", leaking = "Class3")
+    assertThat(hash1).isNotEqualTo(hash2)
+  }
+
+  @Test fun sameCausesSameGroup() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3a"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+    val hash1 = computeGroupHash(notLeaking = "Class1", leaking = "Class3")
+
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3b"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+    val hash2 = computeGroupHash(notLeaking = "Class1", leaking = "Class3")
+    assertThat(hash1).isEqualTo(hash2)
+  }
+
+  private fun notLeaking(className: String): LeakTraceInspector {
+    return object : LeakTraceInspector {
+      override fun inspect(
+        graph: HprofGraph,
+        leakTrace: List<LeakTraceElementReporter>
+      ) {
+        leakTrace.forEach { reporter ->
+          val record = reporter.objectRecord
+          if (record is GraphInstanceRecord && record.className == className) {
+            reporter.reportNotLeaking("$className is not leaking")
+          } else if (record is GraphClassRecord && record.name == className) {
+            reporter.reportNotLeaking("$className is not leaking")
+          }
+        }
+      }
+    }
+  }
+
+  private fun leaking(className: String): LeakTraceInspector {
+    return object : LeakTraceInspector {
+      override fun inspect(
+        graph: HprofGraph,
+        leakTrace: List<LeakTraceElementReporter>
+      ) {
+        leakTrace.forEach { reporter ->
+          val record = reporter.objectRecord
+          if (record is GraphInstanceRecord && record.className == className) {
+            reporter.reportLeaking("$className is leaking")
+          } else if (record is GraphClassRecord && record.name == className) {
+            reporter.reportLeaking("$className is leaking")
+          }
+        }
+      }
+    }
+  }
+
+  private fun computeGroupHash(
+    notLeaking: String,
+    leaking: String
+  ): String {
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          leakTraceInspectors = listOf(notLeaking(notLeaking), leaking(leaking))
+      )
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    return leak.groupHash
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
new file mode 100644
index 00000000..0bcdfaeb
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
@@ -0,0 +1,204 @@
+package leakcanary.internal
+
+import leakcanary.Exclusion
+import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.HprofGraph
+import leakcanary.LeakTraceElementReporter
+import leakcanary.LeakTraceInspector
+import leakcanary.LeakingInstance
+import leakcanary.forEachInstanceOf
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+
+class LeakTraceRendererTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun rendersSimplePath() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["leak"] = "Leaking" watchedInstance {}
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    analysis renders """
+    ┬
+    ├─ GcRoot
+    │    Leaking: NO (it's a GC root)
+    │    ↓ static GcRoot.leak
+    │                    ~~~~
+    ╰→ Leaking
+    ​     Leaking: YES (RefWatcher was watching this)
+    """
+  }
+
+  @Test fun rendersLeakingWithReason() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["instanceA"] = "ClassA" instance {
+          field["instanceB"] = "ClassB" instance {
+            field["leak"] = "Leaking" watchedInstance {}
+          }
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          leakTraceInspectors = listOf(object : LeakTraceInspector {
+            override fun inspect(
+              graph: HprofGraph,
+              leakTrace: List<LeakTraceElementReporter>
+            ) {
+              leakTrace.forEachInstanceOf("ClassB") {
+                reportLeaking("because reasons")
+              }
+            }
+          })
+      )
+
+    analysis renders """
+    ┬
+    ├─ GcRoot
+    │    Leaking: NO (it's a GC root)
+    │    ↓ static GcRoot.instanceA
+    │                    ~~~~~~~~~
+    ├─ ClassA
+    │    Leaking: UNKNOWN
+    │    ↓ ClassA.instanceB
+    │             ~~~~~~~~~
+    ├─ ClassB
+    │    Leaking: YES (because reasons)
+    │    ↓ ClassB.leak
+    ╰→ Leaking
+    ​     Leaking: YES (RefWatcher was watching this)
+    """
+  }
+
+  @Test fun rendersLabelsOnAllNodes() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["leak"] = "Leaking" watchedInstance {}
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        leakTraceInspectors = listOf(object : LeakTraceInspector {
+          override fun inspect(
+            graph: HprofGraph,
+            leakTrace: List<LeakTraceElementReporter>
+          ) {
+            leakTrace.forEach { reporter ->
+              reporter.addLabel("¯\\_(ツ)_/¯")
+            }
+          }
+
+        })
+    )
+
+    analysis renders """
+    ┬
+    ├─ GcRoot
+    │    Leaking: NO (it's a GC root)
+    │    ¯\_(ツ)_/¯
+    │    ↓ static GcRoot.leak
+    │                    ~~~~
+    ╰→ Leaking
+    ​     Leaking: YES (RefWatcher was watching this)
+    ​     ¯\_(ツ)_/¯
+    """
+  }
+
+  @Test fun rendersExclusion() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["instanceA"] = "ClassA" instance {
+          field["leak"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          exclusions = listOf(Exclusion(type = InstanceFieldExclusion("ClassA", "leak")))
+      )
+
+    analysis renders """
+    ┬
+    ├─ GcRoot
+    │    Leaking: NO (it's a GC root)
+    │    ↓ static GcRoot.instanceA
+    │                    ~~~~~~~~~
+    ├─ ClassA
+    │    Leaking: UNKNOWN
+    │    Matches exclusion field ClassA#leak
+    │    ↓ ClassA.leak
+    │             ~~~~
+    ╰→ Leaking
+    ​     Leaking: YES (RefWatcher was watching this)
+    """
+  }
+
+  @Test fun rendersArray() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["array"] = objectArray("Leaking" watchedInstance {})
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    analysis renders """
+    ┬
+    ├─ GcRoot
+    │    Leaking: NO (it's a GC root)
+    │    ↓ static GcRoot.array
+    │                    ~~~~~
+    ├─ java.lang.Object[]
+    │    Leaking: UNKNOWN
+    │    ↓ array Object[].[0]
+    │                     ~~~
+    ╰→ Leaking
+    ​     Leaking: YES (RefWatcher was watching this)
+    """
+  }
+
+  @Test fun rendersThread() {
+    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    analysis renders """
+    ┬
+    ├─ MyThread
+    │    Leaking: NO (it's a GC root)
+    │    ↓ thread MyThread.<Java Local>
+    │                      ~~~~~~~~~~~~
+    ╰→ Leaking
+    ​     Leaking: YES (RefWatcher was watching this)
+    """
+  }
+
+  private infix fun HeapAnalysisSuccess.renders(expectedString: String) {
+    val leak = retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.renderToString()).isEqualTo(
+        expectedString.trimIndent()
+    )
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
new file mode 100644
index 00000000..785e69e9
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
@@ -0,0 +1,65 @@
+package leakcanary.internal
+
+import leakcanary.AndroidKnownReference
+import leakcanary.AndroidLeakTraceInspectors
+import leakcanary.HeapAnalysis
+import leakcanary.HeapAnalysisFailure
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.LeakingInstance
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import java.io.File
+
+class LegacyHprofTest {
+
+  @Test fun preM() {
+    val analysis = analyzeHprof("leak_asynctask_pre_m.hprof")
+
+    assertThat(analysis.retainedInstances).hasSize(2)
+    val leak1 = analysis.retainedInstances[0] as LeakingInstance
+    val leak2 = analysis.retainedInstances[1] as LeakingInstance
+    assertThat(leak1.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
+    assertThat(leak2.instanceClassName).isEqualTo("android.graphics.Bitmap")
+  }
+
+  @Test fun androidM() {
+    val analysis = analyzeHprof("leak_asynctask_m.hprof")
+
+    assertThat(analysis.retainedInstances).hasSize(1)
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
+  }
+
+  @Test fun androidO() {
+    val analysis = analyzeHprof("leak_asynctask_o.hprof")
+
+    assertThat(analysis.retainedInstances).hasSize(1)
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
+  }
+
+  @Test fun gcRootInNonPrimaryHeap() {
+    val analysis = analyzeHprof("gc_root_in_non_primary_heap.hprof")
+
+    assertThat(analysis.retainedInstances).hasSize(1)
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
+  }
+
+  private fun analyzeHprof(fileName: String): HeapAnalysisSuccess {
+    val classLoader = Thread.currentThread()
+        .contextClassLoader
+    val url = classLoader.getResource(fileName)
+    val hprofFile = File(url.path)
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysis>(
+        leakTraceInspectors = AndroidLeakTraceInspectors.defaultInspectors(),
+        exclusions = AndroidKnownReference.mapToExclusions(AndroidKnownReference.appDefaults)
+    )
+    if (analysis is HeapAnalysisFailure) {
+      print(analysis)
+    }
+    return analysis as HeapAnalysisSuccess
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt
new file mode 100644
index 00000000..78197952
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt
@@ -0,0 +1,327 @@
+package leakcanary.internal
+
+import leakcanary.HeapAnalysis
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.HeapValue
+import leakcanary.HeapValue.IntValue
+import leakcanary.HeapValue.LongValue
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.HeapValue.ShortValue
+import leakcanary.LeakingInstance
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+
+class RetainedSizeTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun emptyLeakingInstance() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {}
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    assertThat(retainedSize).isEqualTo(0)
+  }
+
+  @Test fun leakingInstanceWithPrimitiveType() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = LongValue(42)
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 8 bytes for long
+    assertThat(retainedSize).isEqualTo(8)
+  }
+
+  @Test fun leakingInstanceWithPrimitiveArray() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = "42".charArrayDump
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference, 2 bytes per char
+    assertThat(retainedSize).isEqualTo(8)
+  }
+
+  @Test fun leakingInstanceWithString() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = string("42")
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference, string (4 array ref + 4 int + 2 byte per char)
+    assertThat(retainedSize).isEqualTo(16)
+  }
+
+  @Test fun leakingInstanceWithInstance() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = "FortyTwo" instance {
+            field["number"] = IntValue(42)
+          }
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference + 4 byte int
+    assertThat(retainedSize).isEqualTo(8)
+  }
+
+  @Test fun leakingInstanceWithPrimitiveWrapper() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = "java.lang.Integer" instance {
+            field["value"] = IntValue(42)
+          }
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference, int field
+    assertThat(retainedSize).isEqualTo(8)
+  }
+
+  @Test fun leakingInstanceWithPrimitiveWrapperArray() {
+    hprofFile.dump {
+      val intWrapperClass = clazz("java.lang.Integer", fields = listOf("value" to IntValue::class))
+
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = objectArrayOf(
+              intWrapperClass,
+              instance(
+                  intWrapperClass,
+                  fields = listOf<HeapValue>(IntValue(4))
+              ),
+              instance(
+                  intWrapperClass,
+                  fields = listOf<HeapValue>(IntValue(2))
+              )
+          )
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference * 3, 2 ints
+    assertThat(retainedSize).isEqualTo(20)
+  }
+
+  @Test fun leakingInstanceWithObjectArray() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = objectArray("Forty" instance {}, "Two" instance {})
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference, 4 bytes per object entry
+    assertThat(retainedSize).isEqualTo(12)
+  }
+
+  @Test fun leakingInstanceWithDeepRetainedObjects() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = "Forty" instance {
+            field["forty"] = "Two" instance {
+              field["two"] = string("42")
+            }
+          }
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference * 3, string (4 array ref + 4 int + 2 byte per char)
+    assertThat(retainedSize).isEqualTo(24)
+  }
+
+  @Test fun leakingInstanceNotDominating() {
+    hprofFile.dump {
+      val fortyTwo = string("42")
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = fortyTwo
+        }
+        staticField["rootDominator"] = fortyTwo
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference
+    assertThat(retainedSize).isEqualTo(4)
+  }
+
+  @Test fun leakingInstanceWithSuperClass() {
+    hprofFile.dump {
+      val parentClass = clazz("Parent", fields = listOf("value" to LongValue::class))
+      val childClass =
+        clazz("Child", superClassId = parentClass, fields = listOf("value" to IntValue::class))
+
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = instance(childClass, listOf(LongValue(42), IntValue(42)))
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference + Long + Int
+    assertThat(retainedSize).isEqualTo(16)
+  }
+
+  @Test fun leakingInstanceDominatedByOther() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "GrandParentLeaking" watchedInstance {
+          field["answer"] = ShortValue(42)
+          field["child"] = "ParentLeaking" watchedInstance {
+            field["answer"] = IntValue(42)
+            field["child"] = "ChildLeaking" watchedInstance {
+              field["answer"] = LongValue(42)
+            }
+          }
+        }
+      }
+    }
+
+    val retainedInstances = retainedInstances()
+    require(retainedInstances.size == 3)
+
+    retainedInstances.forEach { instance ->
+      when (instance.instanceClassName) {
+        "GrandParentLeaking" -> {
+          // 4 bytes per ref * 2 + short + int + long
+          assertThat(instance.retainedHeapSize).isEqualTo(22)
+        }
+        "ParentLeaking", "ChildLeaking" -> {
+          assertThat(instance.retainedHeapSize).isEqualTo(0)
+        }
+        else -> throw IllegalStateException("Unexpected ${instance.instanceClassName}")
+      }
+    }
+  }
+
+  @Test fun crossDominatedIsNotDominated() {
+    hprofFile.dump {
+      val fortyTwo = string("42")
+      "GcRoot1" clazz {
+        staticField["shortestPath"] = "Leaking1" watchedInstance {
+          field["answer"] = fortyTwo
+        }
+      }
+      "GcRoot2" clazz {
+        staticField["shortestPath"] = "Leaking2" watchedInstance {
+          field["answer"] = fortyTwo
+        }
+      }
+    }
+
+    val retainedInstances = retainedInstances()
+    require(retainedInstances.size == 2)
+
+    retainedInstances.forEach { instance ->
+      // 4 byte reference
+      assertThat(instance.retainedHeapSize).isEqualTo(4)
+    }
+  }
+
+  @Test fun nativeSizeAccountedFor() {
+    val width = 24
+    val height = 16
+    // pixel count * 4 bytes per pixel (ARGB_8888)
+    val nativeBitmapSize = width * height * 4
+
+    hprofFile.dump {
+      val bitmap = "android.graphics.Bitmap" instance {
+        field["mWidth"] = IntValue(width)
+        field["mHeight"] = IntValue(height)
+      }
+
+      val referenceClass =
+        clazz("java.lang.ref.Reference", fields = listOf("referent" to ObjectReference::class))
+      val cleanerClass = clazz(
+          "sun.misc.Cleaner", clazz("java.lang.ref.PhantomReference", referenceClass),
+          fields = listOf("thunk" to ObjectReference::class)
+      )
+
+      instance(
+          cleanerClass,
+          fields = listOf("libcore.util.NativeAllocationRegistry\$CleanerThunk" instance {
+            field["this\$0"] = "libcore.util.NativeAllocationRegistry" instance {
+              field["size"] = LongValue(nativeBitmapSize.toLong())
+            }
+          }, bitmap)
+      )
+
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["bitmap"] = bitmap
+        }
+      }
+    }
+
+    val retainedSize = firstRetainedSize()
+
+    // 4 byte reference + 2 * Int + native size
+    assertThat(retainedSize).isEqualTo(12 + nativeBitmapSize)
+  }
+
+  private fun retainedInstances(): List<LeakingInstance> {
+    val analysis = hprofFile.checkForLeaks<HeapAnalysis>(computeRetainedHeapSize = true)
+    println(analysis.toString())
+    analysis as HeapAnalysisSuccess
+    return analysis.retainedInstances.map { it as LeakingInstance }
+  }
+
+  private fun firstRetainedSize(): Int {
+    return retainedInstances()
+        .map { it.retainedHeapSize!! }
+        .first()
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
new file mode 100644
index 00000000..b74b5bf3
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
@@ -0,0 +1,104 @@
+package leakcanary.internal
+
+import leakcanary.AnalyzerProgressListener
+import leakcanary.Exclusion
+import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
+import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
+import leakcanary.Exclusion.Status.NEVER_REACHABLE
+import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
+import leakcanary.HeapAnalysis
+import leakcanary.HeapAnalysisFailure
+import leakcanary.HeapAnalyzer
+import leakcanary.KeyedWeakReference
+import leakcanary.LeakTraceInspector
+import java.io.File
+import java.lang.ref.PhantomReference
+import java.lang.ref.SoftReference
+import java.lang.ref.WeakReference
+
+@Suppress("UNCHECKED_CAST")
+fun <T : HeapAnalysis> File.checkForLeaks(
+  leakTraceInspectors: List<LeakTraceInspector> = emptyList(),
+  computeRetainedHeapSize: Boolean = false,
+  exclusions: List<Exclusion> = defaultExclusionsFactory
+): T {
+  val heapAnalyzer = HeapAnalyzer(AnalyzerProgressListener.NONE)
+  val result = heapAnalyzer.checkForLeaks(
+      this, exclusions, computeRetainedHeapSize, leakTraceInspectors
+  )
+  if (result is HeapAnalysisFailure) {
+    println(result)
+  }
+  return result as T
+}
+
+val defaultExclusionsFactory: List<Exclusion> =
+  listOf(
+      Exclusion(
+          type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
+          status = WEAKLY_REACHABLE
+      )
+      ,
+      Exclusion(
+          type = InstanceFieldExclusion(KeyedWeakReference::class.java.name, "referent"),
+          status = NEVER_REACHABLE
+      )
+      ,
+      Exclusion(
+          type = InstanceFieldExclusion(SoftReference::class.java.name, "referent"),
+          status = NEVER_REACHABLE
+      )
+      ,
+      Exclusion(
+          type = InstanceFieldExclusion(PhantomReference::class.java.name, "referent"),
+          status = NEVER_REACHABLE
+      )
+      ,
+      Exclusion(
+          type = InstanceFieldExclusion("java.lang.ref.Finalizer", "prev"),
+          status = NEVER_REACHABLE
+      )
+      ,
+      Exclusion(
+          type = InstanceFieldExclusion("java.lang.ref.Finalizer", "element"),
+          status = NEVER_REACHABLE
+      )
+      ,
+      Exclusion(
+          type = InstanceFieldExclusion("java.lang.ref.Finalizer", "next"),
+          status = NEVER_REACHABLE
+      )
+      ,
+      Exclusion(
+          type = InstanceFieldExclusion("java.lang.ref.FinalizerReference", "prev"),
+          status = NEVER_REACHABLE
+      )
+      ,
+      Exclusion(
+          type = InstanceFieldExclusion("java.lang.ref.FinalizerReference", "element"),
+          status = NEVER_REACHABLE
+      )
+      ,
+      Exclusion(
+          type = InstanceFieldExclusion("java.lang.ref.FinalizerReference", "next"),
+          status = NEVER_REACHABLE
+      )
+      ,
+      Exclusion(
+          type = InstanceFieldExclusion("sun.misc.Cleaner", "prev"), status = NEVER_REACHABLE
+      )
+      ,
+      Exclusion(
+          type = InstanceFieldExclusion("sun.misc.Cleaner", "next"), status = NEVER_REACHABLE
+      )
+      ,
+
+      Exclusion(
+          type = JavaLocalExclusion("FinalizerWatchdogDaemon"),
+          status = NEVER_REACHABLE
+      ),
+      Exclusion(
+          type = JavaLocalExclusion("main"),
+          status = NEVER_REACHABLE
+      )
+  )
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/resources/gc_root_in_non_primary_heap.hprof b/leakcanary-analyzer/src/test/resources/gc_root_in_non_primary_heap.hprof
new file mode 100644
index 00000000..7ca6d0bc
Binary files /dev/null and b/leakcanary-analyzer/src/test/resources/gc_root_in_non_primary_heap.hprof differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_m_postpreview2.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_m.hprof
similarity index 100%
rename from leakcanary-analyzer/src/test/resources/leak_asynctask_m_postpreview2.hprof
rename to leakcanary-analyzer/src/test/resources/leak_asynctask_m.hprof
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof
deleted file mode 100644
index 548f3a2a..00000000
Binary files a/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof and /dev/null differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_o.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_o.hprof
new file mode 100644
index 00000000..1c62d0e5
Binary files /dev/null and b/leakcanary-analyzer/src/test/resources/leak_asynctask_o.hprof differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_pre_m.hprof
similarity index 100%
rename from leakcanary-analyzer/src/test/resources/leak_asynctask.hprof
rename to leakcanary-analyzer/src/test/resources/leak_asynctask_pre_m.hprof
diff --git a/leakcanary-analyzer/src/test/resources/leak_service_binder.hprof b/leakcanary-analyzer/src/test/resources/leak_service_binder.hprof
deleted file mode 100644
index af1dab18..00000000
Binary files a/leakcanary-analyzer/src/test/resources/leak_service_binder.hprof and /dev/null differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_service_binder_ignored.hprof b/leakcanary-analyzer/src/test/resources/leak_service_binder_ignored.hprof
deleted file mode 100644
index cdb867c4..00000000
Binary files a/leakcanary-analyzer/src/test/resources/leak_service_binder_ignored.hprof and /dev/null differ
diff --git a/leakcanary-android-core/build.gradle b/leakcanary-android-core/build.gradle
new file mode 100644
index 00000000..89d39306
--- /dev/null
+++ b/leakcanary-android-core/build.gradle
@@ -0,0 +1,38 @@
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+
+dependencies {
+  api project(':leakcanary-analyzer')
+  api project(':leakcanary-leaksentry')
+
+  implementation deps.androidx.annotation
+  implementation deps.androidx.core
+  implementation deps.kotlin.stdlib
+
+  testImplementation deps.junit
+  testImplementation deps.mockito
+  testImplementation deps.mockito_kotlin
+}
+
+def gitSha() {
+  return 'git rev-parse --short HEAD'.execute().text.trim()
+}
+
+android {
+  resourcePrefix 'leak_canary_'
+  compileSdkVersion versions.compileSdk
+  defaultConfig {
+    minSdkVersion versions.minSdk
+    buildConfigField "String", "LIBRARY_VERSION", "\"${rootProject.ext.VERSION_NAME}\""
+    buildConfigField "String", "GIT_SHA", "\"${gitSha()}\""
+    consumerProguardFiles 'consumer-proguard-rules.pro'
+  }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    error 'ObsoleteSdkInt'
+    check 'Interoperability'
+  }
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android/consumer-proguard-rules.pro b/leakcanary-android-core/consumer-proguard-rules.pro
similarity index 100%
rename from leakcanary-android/consumer-proguard-rules.pro
rename to leakcanary-android-core/consumer-proguard-rules.pro
diff --git a/leakcanary-android-core/gradle.properties b/leakcanary-android-core/gradle.properties
new file mode 100644
index 00000000..f11d5355
--- /dev/null
+++ b/leakcanary-android-core/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-android-core
+POM_NAME=LeakCanary for Android - Core
+POM_PACKAGING=aar
diff --git a/leakcanary-android-core/lint.xml b/leakcanary-android-core/lint.xml
new file mode 100644
index 00000000..73841df8
--- /dev/null
+++ b/leakcanary-android-core/lint.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+  <issue id="SetTextI18n" severity="ignore" />
+</lint>
diff --git a/leakcanary-android-core/src/main/AndroidManifest.xml b/leakcanary-android-core/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..9e055c2e
--- /dev/null
+++ b/leakcanary-android-core/src/main/AndroidManifest.xml
@@ -0,0 +1,75 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.leakcanary.core"
+    >
+
+  <!-- To store the heap dumps and leak analysis results. -->
+  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+  <!-- To allow starting foreground services on Android P+ - https://developer.android.com/preview/behavior-changes#fg-svc -->
+  <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
+
+  <application>
+    <provider
+        android:name="leakcanary.internal.LeakCanaryFileProvider"
+        android:authorities="com.squareup.leakcanary.fileprovider.${applicationId}"
+        android:exported="false"
+        android:grantUriPermissions="true"
+        >
+      <meta-data
+          android:name="android.support.FILE_PROVIDER_PATHS"
+          android:resource="@xml/leak_canary_file_paths"/>
+    </provider>
+
+    <activity
+        android:name="leakcanary.internal.activity.LeakActivity"
+        android:icon="@mipmap/leak_canary_icon"
+        android:label="@string/leak_canary_display_activity_label"
+        android:taskAffinity="com.squareup.leakcanary.${applicationId}"
+        android:theme="@style/leak_canary_LeakCanary.Base"
+        />
+
+    <activity-alias
+        android:name="leakcanary.internal.activity.LeakLauncherActivity"
+        android:enabled="@bool/leak_canary_add_launcher_icon"
+        android:icon="@mipmap/leak_canary_icon"
+        android:label="@string/leak_canary_display_activity_label"
+        android:targetActivity="leakcanary.internal.activity.LeakActivity"
+        android:taskAffinity="com.squareup.leakcanary.${applicationId}"
+        android:theme="@style/leak_canary_LeakCanary.Base"
+        >
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+        <category android:name="android.intent.category.LAUNCHER"/>
+      </intent-filter>
+    </activity-alias>
+
+    <activity
+        android:name="leakcanary.internal.RequestStoragePermissionActivity"
+        android:excludeFromRecents="true"
+        android:icon="@mipmap/leak_canary_icon"
+        android:label="@string/leak_canary_storage_permission_activity_label"
+        android:taskAffinity="com.squareup.leakcanary.${applicationId}"
+        android:theme="@style/leak_canary_Theme.Transparent"
+        />
+
+    <receiver android:name="leakcanary.internal.NotificationReceiver" />
+
+  </application>
+</manifest>
diff --git a/leakcanary-android-core/src/main/ic_launcher-web.png b/leakcanary-android-core/src/main/ic_launcher-web.png
new file mode 100644
index 00000000..15b9d890
Binary files /dev/null and b/leakcanary-android-core/src/main/ic_launcher-web.png differ
diff --git a/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt b/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt
new file mode 100644
index 00000000..8c24a7d1
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt
@@ -0,0 +1,73 @@
+package leakcanary
+
+import android.app.Application
+import com.squareup.leakcanary.core.R
+import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
+import leakcanary.Exclusion.Status.WONT_FIX_LEAK
+import leakcanary.internal.NotificationType.LEAKCANARY_RESULT
+import leakcanary.internal.Notifications
+import leakcanary.internal.activity.LeakActivity
+import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.db.LeakingInstanceTable
+import leakcanary.internal.activity.db.LeaksDbHelper
+import leakcanary.internal.activity.screen.GroupListScreen
+import leakcanary.internal.activity.screen.HeapAnalysisFailureScreen
+import leakcanary.internal.activity.screen.HeapAnalysisListScreen
+import leakcanary.internal.activity.screen.HeapAnalysisSuccessScreen
+
+object DefaultAnalysisResultListener : AnalysisResultListener {
+  override fun invoke(
+    application: Application,
+    heapAnalysis: HeapAnalysis
+  ) {
+
+    // TODO better log that include leakcanary version, exclusions, etc.
+    CanaryLog.d("%s", heapAnalysis)
+
+    val (id, groupProjections) = LeaksDbHelper(application)
+        .writableDatabase.use { db ->
+      val id = HeapAnalysisTable.insert(db, heapAnalysis)
+      id to LeakingInstanceTable.retrieveAllByHeapAnalysisId(db, id)
+    }
+
+    val (contentTitle, screenToShow) = when (heapAnalysis) {
+      is HeapAnalysisFailure -> application.getString(
+          R.string.leak_canary_analysis_failed
+      ) to HeapAnalysisFailureScreen(id)
+      is HeapAnalysisSuccess -> {
+        var leakCount = 0
+        var newLeakCount = 0
+        var knownLeakCount = 0
+        var wontFixLeakCount = 0
+
+        for ((_, projection) in groupProjections) {
+          if (projection.exclusionStatus != WEAKLY_REACHABLE) {
+            leakCount += projection.leakCount
+            when {
+              projection.exclusionStatus == WONT_FIX_LEAK -> wontFixLeakCount += projection.leakCount
+              projection.isNew -> newLeakCount += projection.leakCount
+              else -> knownLeakCount += projection.leakCount
+            }
+          }
+        }
+
+        application.getString(
+            R.string.leak_canary_analysis_success_notification, leakCount, newLeakCount,
+            knownLeakCount, wontFixLeakCount
+        ) to HeapAnalysisSuccessScreen(id)
+      }
+    }
+
+    val pendingIntent = LeakActivity.createPendingIntent(
+        application, arrayListOf(GroupListScreen(), HeapAnalysisListScreen(), screenToShow)
+    )
+
+    val contentText = application.getString(R.string.leak_canary_notification_message)
+
+    Notifications.showNotification(
+        application, contentTitle, contentText, pendingIntent,
+        R.id.leak_canary_notification_analysis_result,
+        LEAKCANARY_RESULT
+    )
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
new file mode 100644
index 00000000..251a6407
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -0,0 +1,73 @@
+package leakcanary
+
+import android.app.Application
+import android.content.Intent
+import leakcanary.internal.InternalLeakCanary
+
+typealias AnalysisResultListener = (Application, HeapAnalysis) -> Unit
+
+object LeakCanary {
+
+  data class Config(
+    val dumpHeap: Boolean = true,
+    /**
+     * The debugger can create temporary memory leaks (for instance if a thread is blocked on a
+     * breakpoint) so by default LeakCanary does not dump the heap when the debugger is attached.
+     */
+    val dumpHeapWhenDebugging: Boolean = false,
+    /**
+     * When the app is visible, LeakCanary will wait for at least
+     * [retainedVisibleThreshold] retained instances before dumping the heap. Dumping the heap
+     * freezes the UI and can be frustrating for developers who are trying to work. This is
+     * especially frustrating as the Android Framework has a number of leaks that cannot easily
+     * be fixed.
+     *
+     * When the app becomes invisible, LeakCanary dumps the heap immediately.
+     *
+     * A higher threshold means LeakCanary will dump the heap less often, therefore it won't be
+     * bothering developers as much but it could miss some leaks.
+     */
+    val retainedVisibleThreshold: Int = 5,
+
+    val knownReferences: Set<AndroidKnownReference> = AndroidKnownReference.appDefaults,
+
+    val leakTraceInspectors: List<LeakTraceInspector> = AndroidLeakTraceInspectors.defaultInspectors(),
+
+    /**
+     * Called with the heap analysis result from a background thread.
+     * The heap dump file will be removed immediately after this function is invoked.
+     * If you want leaks to be added to the activity that lists leaks, make sure to delegate
+     * calls to [DefaultAnalysisResultListener].
+     */
+    val analysisResultListener: AnalysisResultListener = DefaultAnalysisResultListener,
+    /**
+     * Whether to compute the total number of bytes in memory that would be reclaimed if the
+     * detected leaks didn't happen. This includes native memory associated to Java objects
+     * (e.g. bitmaps).
+     * Computing the retained heap size can slow down the leak analysis and is off by default.
+     */
+    val computeRetainedHeapSize: Boolean = false,
+
+    /**
+     * How many heap dumps are kept locally. When this threshold is reached LeakCanary starts
+     * deleting the older heap dumps. As several heap dumps may be enqueued you should avoid
+     * going down to 1 or 2.
+     */
+    val maxStoredHeapDumps: Int = 7,
+
+    /**
+     * LeakCanary always attempts to store heap dumps on the external storage first. If the
+     * WRITE_EXTERNAL_STORAGE permission is not granted and [requestWriteExternalStoragePermission]
+     * is true, then LeakCanary will display a notification to ask for that permission.
+     */
+    val requestWriteExternalStoragePermission: Boolean = false
+
+  )
+
+  @Volatile
+  var config: Config = if (LeakSentry.isInstalled) Config() else InternalLeakCanary.noInstallConfig
+
+  /** [Intent] that can be used to programmatically launch the leak display activity. */
+  val leakDisplayActivityIntent
+    get() = InternalLeakCanary.leakDisplayActivityIntent
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
new file mode 100644
index 00000000..17655635
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.animation.Animator
+import android.animation.AnimatorListenerAdapter
+import android.app.Activity
+import android.app.Application
+import android.app.Notification
+import android.app.NotificationManager
+import android.content.Context
+import android.os.Debug
+import android.os.Handler
+import android.os.Looper
+import android.view.Gravity
+import android.view.LayoutInflater
+import android.view.View
+import android.widget.Toast
+import com.squareup.leakcanary.core.R
+import leakcanary.CanaryLog
+import leakcanary.internal.InternalHelper.noOpDelegate
+import leakcanary.internal.NotificationType.LEAKCANARY_LOW
+import java.io.File
+import java.util.concurrent.TimeUnit.SECONDS
+
+internal class AndroidHeapDumper(
+  context: Context,
+  private val leakDirectoryProvider: LeakDirectoryProvider
+) : HeapDumper {
+
+  private val context: Context = context.applicationContext
+  private val mainHandler: Handler = Handler(Looper.getMainLooper())
+
+  private var resumedActivity: Activity? = null
+
+  init {
+    val application = context.applicationContext as Application
+    application.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate()  {
+      override fun onActivityResumed(activity: Activity) {
+        resumedActivity = activity
+      }
+
+      override fun onActivityPaused(activity: Activity) {
+        if (resumedActivity === activity) {
+          resumedActivity = null
+        }
+      }
+    })
+  }
+
+  override fun dumpHeap(): File? {
+    val heapDumpFile = leakDirectoryProvider.newHeapDumpFile() ?: return null
+
+    val waitingForToast = FutureResult<Toast?>()
+    showToast(waitingForToast)
+
+    if (!waitingForToast.wait(5, SECONDS)) {
+      CanaryLog.d("Did not dump heap, too much time waiting for Toast.")
+      return null
+    }
+
+    val notificationManager =
+      context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+    if (Notifications.canShowNotification) {
+      val dumpingHeap = context.getString(R.string.leak_canary_notification_dumping)
+      val builder = Notification.Builder(context)
+          .setContentTitle(dumpingHeap)
+      val notification = Notifications.buildNotification(context, builder, LEAKCANARY_LOW)
+      notificationManager.notify(R.id.leak_canary_notification_dumping_heap, notification)
+    }
+
+    val toast = waitingForToast.get()
+
+    return try {
+      Debug.dumpHprofData(heapDumpFile.absolutePath)
+      if (heapDumpFile.length() == 0L) {
+        CanaryLog.d("Dumped heap file is 0 byte length")
+        null
+      } else {
+        heapDumpFile
+      }
+    } catch (e: Exception) {
+      CanaryLog.d(e, "Could not dump heap")
+      // Abort heap dump
+      null
+    } finally {
+      cancelToast(toast)
+      notificationManager.cancel(R.id.leak_canary_notification_dumping_heap)
+    }
+  }
+
+  private fun showToast(waitingForToast: FutureResult<Toast?>) {
+    mainHandler.post(Runnable {
+      val resumedActivity = resumedActivity
+      if (resumedActivity == null) {
+        waitingForToast.set(null)
+        return@Runnable
+      }
+      val toast = Toast(resumedActivity)
+      val iconSize = resumedActivity.resources.getDimensionPixelSize(
+          R.dimen.leak_canary_toast_icon_size
+      )
+      toast.setGravity(Gravity.CENTER_VERTICAL, 0, -iconSize)
+      toast.duration = Toast.LENGTH_LONG
+      // Inflating with application context: https://github.com/square/leakcanary/issues/1385
+      val inflater = LayoutInflater.from(context)
+      toast.view = inflater.inflate(R.layout.leak_canary_heap_dump_toast, null)
+      toast.show()
+
+      val toastIcon = toast.view.findViewById<View>(R.id.leak_canary_toast_icon)
+      toastIcon.translationY = -iconSize.toFloat()
+      toastIcon
+          .animate()
+          .translationY(0f)
+          .setListener(object : AnimatorListenerAdapter() {
+            override fun onAnimationEnd(animation: Animator) {
+              waitingForToast.set(toast)
+            }
+          })
+    })
+  }
+
+  private fun cancelToast(toast: Toast?) {
+    if (toast == null) {
+      return
+    }
+    mainHandler.post { toast.cancel() }
+  }
+}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/DebuggerControl.java b/leakcanary-android-core/src/main/java/leakcanary/internal/DebuggerControl.kt
similarity index 77%
rename from leakcanary-watcher/src/main/java/com/squareup/leakcanary/DebuggerControl.java
rename to leakcanary-android-core/src/main/java/leakcanary/internal/DebuggerControl.kt
index fdd03be2..ae001bb2 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/DebuggerControl.java
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DebuggerControl.kt
@@ -13,18 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary;
+package leakcanary.internal
+
+import android.os.Debug
 
 /**
  * Gives the opportunity to skip checking if a reference is gone when the debugger is connected.
  * An attached debugger might retain references and create false positives.
  */
-public interface DebuggerControl {
-  DebuggerControl NONE = new DebuggerControl() {
-    @Override public boolean isDebuggerAttached() {
-      return false;
-    }
-  };
+internal object DebuggerControl {
+
+  val isDebuggerAttached: Boolean
+    get() = Debug.isDebuggerConnected()
 
-  boolean isDebuggerAttached();
-}
\ No newline at end of file
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
new file mode 100644
index 00000000..06c6eec8
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
@@ -0,0 +1,372 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.content.Context
+import android.text.SpannableStringBuilder
+import android.text.Spanned
+import android.text.format.DateUtils
+import android.view.View
+import android.view.ViewGroup
+import android.widget.BaseAdapter
+import android.widget.TextView
+import androidx.annotation.ColorRes
+import androidx.core.content.ContextCompat
+import androidx.core.text.HtmlCompat
+import com.squareup.leakcanary.core.R
+import leakcanary.LeakNodeStatus.LEAKING
+import leakcanary.LeakNodeStatus.NOT_LEAKING
+import leakcanary.LeakNodeStatus.UNKNOWN
+import leakcanary.LeakTrace
+import leakcanary.LeakTraceElement
+import leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import leakcanary.internal.DisplayLeakConnectorView.Type
+import leakcanary.internal.DisplayLeakConnectorView.Type.END
+import leakcanary.internal.DisplayLeakConnectorView.Type.END_FIRST_UNREACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.HELP
+import leakcanary.internal.DisplayLeakConnectorView.Type.HELP_LEAK_GROUP
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_FIRST_UNREACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_LAST_REACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_REACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNKNOWN
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNREACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.START
+import leakcanary.internal.DisplayLeakConnectorView.Type.START_LAST_REACHABLE
+import leakcanary.internal.MoreDetailsView.Details.CLOSED
+import leakcanary.internal.MoreDetailsView.Details.NONE
+import leakcanary.internal.MoreDetailsView.Details.OPENED
+import leakcanary.internal.activity.db.LeakingInstanceTable.InstanceProjection
+import leakcanary.internal.navigation.inflate
+
+internal class DisplayLeakAdapter private constructor(
+  context: Context,
+  private val leakTrace: LeakTrace,
+  private val referenceName: String,
+  private val instanceProjections: List<InstanceProjection>
+) : BaseAdapter() {
+
+  private val isLeakGroup = instanceProjections.isNotEmpty()
+
+  constructor(
+    context: Context,
+    leakTrace: LeakTrace,
+    referenceName: String
+  ) : this(context, leakTrace, referenceName, emptyList())
+
+  constructor(
+    context: Context,
+    leakTrace: LeakTrace,
+    instanceProjections: List<InstanceProjection>
+  ) : this(context, leakTrace, "", instanceProjections)
+
+  private val opened = BooleanArray(TOP_ROW_COUNT + leakTrace.elements.size)
+
+  private val classNameColorHexString: String
+  private val leakColorHexString: String
+  private val referenceColorHexString: String
+  private val extraColorHexString: String
+  private val helpColorHexString: String
+
+  init {
+    classNameColorHexString = hexStringColor(context, R.color.leak_canary_class_name)
+    leakColorHexString = hexStringColor(context, R.color.leak_canary_leak)
+    referenceColorHexString = hexStringColor(context, R.color.leak_canary_reference)
+    extraColorHexString = hexStringColor(context, R.color.leak_canary_extra)
+    helpColorHexString = hexStringColor(context, R.color.leak_canary_help)
+  }
+
+  override fun getView(
+    position: Int,
+    convertView: View?,
+    parent: ViewGroup
+  ): View {
+    return when (getItemViewType(position)) {
+      TOP_ROW -> {
+        val view = convertView ?: parent.inflate(R.layout.leak_canary_ref_top_row)
+        bindTopRow(view)
+        view
+      }
+      CONNECTOR_ROW -> {
+        val view = convertView ?: parent.inflate(R.layout.leak_canary_ref_row)
+        bindConnectorRow(view, position)
+        view
+      }
+      else -> {
+        val view = convertView ?: parent.inflate(R.layout.leak_canary_leak_row)
+        bindLeakInstanceRow(view, position)
+        view
+      }
+    }
+  }
+
+  private fun bindTopRow(view: View) {
+    val textView = view.findViewById<TextView>(R.id.leak_canary_row_text)
+    textView.text = view.context.packageName
+  }
+
+  private fun bindConnectorRow(
+    view: View,
+    position: Int
+  ) {
+    val titleView = view.findViewById<TextView>(R.id.leak_canary_row_title)
+    val detailView = view.findViewById<TextView>(R.id.leak_canary_row_details)
+    val connector = view.findViewById<DisplayLeakConnectorView>(R.id.leak_canary_row_connector)
+    val moreDetailsView = view.findViewById<MoreDetailsView>(R.id.leak_canary_row_more)
+
+    connector.setType(getConnectorType(position))
+
+    moreDetailsView.setDetails(
+        when {
+          isLeakGroup -> NONE
+          // Learn more row
+          isFirstConnectorRow(position) -> NONE
+          opened[position] -> OPENED
+          else -> CLOSED
+        }
+    )
+
+    if (opened[position]) {
+      detailView.visibility = View.VISIBLE
+    } else {
+      detailView.visibility = View.GONE
+    }
+
+    val resources = view.resources
+    if (isFirstConnectorRow(position)) {
+      titleView.text = if (isLeakGroup) {
+        HtmlCompat.fromHtml(
+            """
+              <font color='$helpColorHexString'>
+                <b>Known likely causes of leak group</b>
+              </font>
+            """,
+            HtmlCompat.FROM_HTML_MODE_LEGACY
+        )
+      } else {
+        HtmlCompat.fromHtml(
+            """
+              <font color='$helpColorHexString'>
+                <b>${resources.getString(R.string.leak_canary_help_title)}</b>
+              </font>
+            """,
+            HtmlCompat.FROM_HTML_MODE_LEGACY
+        )
+      }
+    } else {
+      val isLast = position == (TOP_ROW_COUNT + leakTrace.elements.size) - 1
+
+      val elementIndex = elementIndex(position)
+      val element = leakTrace.elements[elementIndex]
+
+      val maybeLeakCause = if (isLeakGroup) {
+        true
+      } else leakTrace.elementMayBeLeakCause(elementIndex)
+
+      val htmlTitle = htmlTitle(element, maybeLeakCause, view.context)
+
+      titleView.text = htmlTitle
+
+      if (opened[position]) {
+        val htmlDetail = htmlDetails(isLast, element)
+        detailView.text = htmlDetail
+      }
+    }
+  }
+
+  private fun bindLeakInstanceRow(
+    view: View,
+    position: Int
+  ) {
+    val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
+    val timeView = view.findViewById<TextView>(R.id.leak_canary_row_time)
+
+    val projection = instanceProjections[position - TOP_ROW_COUNT - leakTrace.elements.size]
+
+    titleView.text =
+      view.resources.getString(R.string.leak_canary_class_has_leaked, projection.classSimpleName)
+
+    timeView.text = DateUtils.formatDateTime(
+        view.context, projection.createdAtTimeMillis,
+        DateUtils.FORMAT_SHOW_TIME or DateUtils.FORMAT_SHOW_DATE
+    )
+  }
+
+  private fun htmlTitle(
+    element: LeakTraceElement,
+    maybeLeakCause: Boolean,
+    context: Context
+  ): Spanned {
+
+    val packageEnd = element.className.lastIndexOf('.')
+    var simpleName = element.classSimpleName
+    simpleName = simpleName.replace("[]", "[ ]")
+    val styledClassName = "<font color='$classNameColorHexString'>$simpleName</font>"
+
+    var htmlString =
+      if (packageEnd != -1) "<font color='$extraColorHexString'>${element.className.substring(
+          0, packageEnd
+      )}</font>.$styledClassName" else styledClassName
+
+    htmlString += "<br>"
+
+    val reachabilityString = when (element.leakStatusAndReason.status) {
+      UNKNOWN -> "UNKNOWN"
+      NOT_LEAKING -> "NO (${element.leakStatusAndReason.reason})"
+      LEAKING -> "YES (${element.leakStatusAndReason.reason})"
+    }
+
+    val indentation = "&nbsp;".repeat(4)
+    htmlString += "$indentation<font color='$extraColorHexString'>Leaking: $reachabilityString</font><br>"
+
+    element.labels.forEach { label ->
+      htmlString += "$indentation<font color='$extraColorHexString'>$label</font><br>"
+    }
+
+    val reference = element.reference
+    if (reference != null) {
+      var referenceName = reference.displayName.replace("<".toRegex(), "&lt;")
+          .replace(">".toRegex(), "&gt;")
+
+      referenceName = if (maybeLeakCause) {
+        "<u><font color='$leakColorHexString'>$referenceName</font></u>"
+      } else {
+        "<font color='$referenceColorHexString'>$referenceName</font>"
+      }
+
+      if (reference.type == STATIC_FIELD) {
+        referenceName = "<i>$referenceName</i>"
+      }
+
+      htmlString += "$indentation$styledClassName.${if (maybeLeakCause) "<b>$referenceName</b>" else referenceName}"
+    }
+
+    val exclusion = element.exclusion
+    if (exclusion != null) {
+      htmlString += " (excluded)"
+    }
+    val builder =
+      HtmlCompat.fromHtml(htmlString, HtmlCompat.FROM_HTML_MODE_LEGACY) as SpannableStringBuilder
+    if (maybeLeakCause) {
+      SquigglySpan.replaceUnderlineSpans(builder, context)
+    }
+
+    return builder
+  }
+
+  private fun htmlDetails(
+    isLeakingInstance: Boolean,
+    element: LeakTraceElement
+  ): Spanned {
+    var htmlString = ""
+    val exclusion = element.exclusion
+    if (exclusion != null) {
+      htmlString += "<br/><br/>Excluded by rule"
+      htmlString += " matching <font color='#f3cf83'>" + exclusion.matching + "</font>"
+      if (exclusion.reason != null) {
+        htmlString += " because <font color='#f3cf83'>" + exclusion.reason + "</font>"
+      }
+    }
+    if (isLeakingInstance && referenceName != "") {
+      htmlString += " <font color='$extraColorHexString'>$referenceName</font>"
+    }
+
+    return HtmlCompat.fromHtml(htmlString, HtmlCompat.FROM_HTML_MODE_LEGACY)
+  }
+
+  private fun getConnectorType(position: Int): Type {
+    if (isFirstConnectorRow(position)) {
+      return if (isLeakGroup) HELP_LEAK_GROUP else HELP
+    } else if (position == TOP_ROW_COUNT) {
+      if (leakTrace.elements.size == 1) {
+        return START_LAST_REACHABLE
+      }
+      val nextReachability = leakTrace.elements[elementIndex(position + 1)]
+      return if (nextReachability.leakStatusAndReason.status != NOT_LEAKING) {
+        START_LAST_REACHABLE
+      } else START
+    } else {
+      val isLeakingInstance = position == count - 1
+      if (isLeakingInstance) {
+        val previousReachability = leakTrace.elements[elementIndex(position - 1)]
+        return if (previousReachability.leakStatusAndReason.status != LEAKING) {
+          END_FIRST_UNREACHABLE
+        } else END
+      } else {
+        val reachability = leakTrace.elements[elementIndex(position)]
+        when (reachability.leakStatusAndReason.status) {
+          UNKNOWN -> return NODE_UNKNOWN
+          NOT_LEAKING -> {
+            val nextReachability = leakTrace.elements[elementIndex(position + 1)]
+            return if (nextReachability.leakStatusAndReason.status != NOT_LEAKING) {
+              NODE_LAST_REACHABLE
+            } else {
+              NODE_REACHABLE
+            }
+          }
+          LEAKING -> {
+            val previousReachability = leakTrace.elements[elementIndex(position - 1)]
+            return if (previousReachability.leakStatusAndReason.status != LEAKING) {
+              NODE_FIRST_UNREACHABLE
+            } else {
+              NODE_UNREACHABLE
+            }
+          }
+          else -> throw IllegalStateException("Unknown value: " + reachability.leakStatusAndReason.status)
+        }
+      }
+    }
+  }
+
+  fun isLearnMoreRow(position: Int) = isFirstConnectorRow(position) && !isLeakGroup
+
+  fun isFirstConnectorRow(position: Int) = position == TOP_ROW_COUNT - 1
+
+  fun toggleRow(position: Int) {
+    opened[position] = !opened[position]
+    notifyDataSetChanged()
+  }
+
+  override fun getCount() = TOP_ROW_COUNT + leakTrace.elements.size + instanceProjections.size
+
+  override fun getItem(position: Int) = null
+
+  private fun elementIndex(position: Int): Int {
+    return position - TOP_ROW_COUNT
+  }
+
+  override fun getViewTypeCount() = 3
+
+  override fun getItemViewType(position: Int) = when {
+    position == 0 -> TOP_ROW
+    position < TOP_ROW_COUNT + leakTrace.elements.size -> CONNECTOR_ROW
+    else -> LEAK_ROW
+  }
+
+  override fun getItemId(position: Int) = position.toLong()
+
+  companion object {
+
+    private const val TOP_ROW = 0
+    private const val CONNECTOR_ROW = 1
+    private const val LEAK_ROW = 2
+    private const val TOP_ROW_COUNT = 2
+
+    // https://stackoverflow.com/a/6540378/703646
+    private fun hexStringColor(context: Context, @ColorRes colorResId: Int): String {
+      return String.format("#%06X", 0xFFFFFF and ContextCompat.getColor(context, colorResId))
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt
new file mode 100644
index 00000000..923e20ae
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt
@@ -0,0 +1,255 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.content.Context
+import android.graphics.Bitmap
+import android.graphics.Bitmap.Config.ARGB_8888
+import android.graphics.Canvas
+import android.graphics.Color
+import android.graphics.DashPathEffect
+import android.graphics.Paint
+import android.graphics.PorterDuff.Mode.CLEAR
+import android.graphics.PorterDuffXfermode
+import android.util.AttributeSet
+import android.view.View
+import androidx.core.content.ContextCompat
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.DisplayLeakConnectorView.Type.END
+import leakcanary.internal.DisplayLeakConnectorView.Type.END_FIRST_UNREACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.HELP
+import leakcanary.internal.DisplayLeakConnectorView.Type.HELP_LEAK_GROUP
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_FIRST_UNREACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_LAST_REACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_REACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNKNOWN
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNREACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.START
+import leakcanary.internal.DisplayLeakConnectorView.Type.START_LAST_REACHABLE
+
+internal class DisplayLeakConnectorView(
+  context: Context,
+  attrs: AttributeSet
+) : View(context, attrs) {
+
+  private val classNamePaint: Paint
+  private val leakGroupRootPaint: Paint
+  private val leakPaint: Paint
+  private val clearPaint: Paint
+  private val referencePaint: Paint
+  private val strokeSize: Float
+  private val circleY: Float
+
+  private var type: Type? = null
+  private var cache: Bitmap? = null
+
+  enum class Type {
+    HELP,
+    HELP_LEAK_GROUP,
+    START,
+    START_LAST_REACHABLE,
+    NODE_UNKNOWN,
+    NODE_FIRST_UNREACHABLE,
+    NODE_UNREACHABLE,
+    NODE_REACHABLE,
+    NODE_LAST_REACHABLE,
+    END,
+    END_FIRST_UNREACHABLE
+  }
+
+  init {
+
+    val resources = resources
+
+    type = NODE_UNKNOWN
+    circleY = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_center_y)
+        .toFloat()
+    strokeSize = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_stroke_size)
+        .toFloat()
+
+    classNamePaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    classNamePaint.color = ContextCompat.getColor(context, R.color.leak_canary_class_name)
+    classNamePaint.strokeWidth = strokeSize
+
+    leakGroupRootPaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    leakGroupRootPaint.color = ContextCompat.getColor(context, R.color.leak_canary_class_name)
+    leakGroupRootPaint.strokeWidth = strokeSize
+    val pathLines = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_leak_dash_line)
+        .toFloat()
+    leakGroupRootPaint.pathEffect = DashPathEffect(floatArrayOf(pathLines, pathLines), 0f)
+
+    leakPaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    leakPaint.color = ContextCompat.getColor(context, R.color.leak_canary_leak)
+    leakPaint.style = Paint.Style.STROKE
+    leakPaint.strokeWidth = strokeSize
+
+    val pathGaps = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_leak_dash_gap)
+        .toFloat()
+    leakPaint.pathEffect = DashPathEffect(floatArrayOf(pathLines, pathGaps), 0f)
+
+    clearPaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    clearPaint.color = Color.TRANSPARENT
+    clearPaint.xfermode = CLEAR_XFER_MODE
+
+    referencePaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    referencePaint.color = ContextCompat.getColor(context, R.color.leak_canary_reference)
+    referencePaint.strokeWidth = strokeSize
+  }
+
+  override fun onDraw(canvas: Canvas) {
+    val width = measuredWidth
+    val height = measuredHeight
+
+    if (cache != null && (cache!!.width != width || cache!!.height != height)) {
+      cache!!.recycle()
+      cache = null
+    }
+
+    if (cache == null) {
+      cache = Bitmap.createBitmap(width, height, ARGB_8888)
+
+      val cacheCanvas = Canvas(cache!!)
+
+      when (type) {
+        NODE_UNKNOWN -> drawItems(cacheCanvas, leakPaint, leakPaint)
+        NODE_UNREACHABLE, NODE_REACHABLE -> drawItems(
+            cacheCanvas, referencePaint, referencePaint
+        )
+        NODE_FIRST_UNREACHABLE -> drawItems(
+            cacheCanvas, leakPaint, referencePaint
+        )
+        NODE_LAST_REACHABLE -> drawItems(
+            cacheCanvas, referencePaint, leakPaint
+        )
+        START -> {
+          drawStartLine(cacheCanvas)
+          drawItems(cacheCanvas, null, referencePaint)
+        }
+        START_LAST_REACHABLE -> {
+          drawStartLine(cacheCanvas)
+          drawItems(cacheCanvas, null, leakPaint)
+        }
+        END -> drawItems(cacheCanvas, referencePaint, null)
+        END_FIRST_UNREACHABLE -> drawItems(
+            cacheCanvas, leakPaint, null
+        )
+        HELP -> drawRoot(cacheCanvas, false)
+        HELP_LEAK_GROUP -> drawRoot(cacheCanvas, true)
+        else -> throw UnsupportedOperationException("Unknown type " + type!!)
+      }
+    }
+    canvas.drawBitmap(cache!!, 0f, 0f, null)
+  }
+
+  private fun drawStartLine(cacheCanvas: Canvas) {
+    val width = measuredWidth
+    val halfWidth = width / 2f
+    cacheCanvas.drawLine(halfWidth, 0f, halfWidth, circleY, classNamePaint)
+  }
+
+  private fun drawRoot(
+    cacheCanvas: Canvas,
+    leakGroup: Boolean
+  ) {
+    val width = measuredWidth
+    val height = measuredHeight
+    val halfWidth = width / 2f
+    val radiusClear = halfWidth - strokeSize / 2f
+    cacheCanvas.drawRect(0f, 0f, width.toFloat(), radiusClear, classNamePaint)
+    cacheCanvas.drawCircle(0f, radiusClear, radiusClear, clearPaint)
+    cacheCanvas.drawCircle(width.toFloat(), radiusClear, radiusClear, clearPaint)
+    cacheCanvas.drawLine(
+        halfWidth, 0f, halfWidth, height.toFloat(),
+        if (leakGroup) leakGroupRootPaint else classNamePaint
+    )
+  }
+
+  private fun drawItems(
+    cacheCanvas: Canvas,
+    arrowHeadPaint: Paint?,
+    nextArrowPaint: Paint?
+  ) {
+    if (arrowHeadPaint != null) {
+      drawArrowHead(cacheCanvas, arrowHeadPaint)
+    }
+    if (nextArrowPaint != null) {
+      drawNextArrowLine(cacheCanvas, nextArrowPaint)
+    }
+    drawInstanceCircle(cacheCanvas)
+  }
+
+  private fun drawArrowHead(
+    cacheCanvas: Canvas,
+    paint: Paint
+  ) {
+    // Circle center is at half height
+    val width = measuredWidth
+    val halfWidth = width / 2f
+    val circleRadius = width / 3f
+// Splitting the arrow head in two makes an isosceles right triangle.
+    // It's hypotenuse is side * sqrt(2)
+    val arrowHeight = halfWidth / 2 * SQRT_TWO
+    val halfStrokeSize = strokeSize / 2
+    val translateY = circleY - arrowHeight - circleRadius * 2 - strokeSize
+
+    val lineYEnd = circleY - circleRadius - strokeSize / 2
+    cacheCanvas.drawLine(halfWidth, 0f, halfWidth, lineYEnd, paint)
+    cacheCanvas.translate(halfWidth, translateY)
+    cacheCanvas.rotate(45f)
+    cacheCanvas.drawLine(
+        0f, halfWidth, halfWidth + halfStrokeSize, halfWidth,
+        paint
+    )
+    cacheCanvas.drawLine(halfWidth, 0f, halfWidth, halfWidth, paint)
+    cacheCanvas.rotate(-45f)
+    cacheCanvas.translate(-halfWidth, -translateY)
+  }
+
+  private fun drawNextArrowLine(
+    cacheCanvas: Canvas,
+    paint: Paint
+  ) {
+    val height = measuredHeight
+    val width = measuredWidth
+    val centerX = width / 2f
+    cacheCanvas.drawLine(centerX, circleY, centerX, height.toFloat(), paint)
+  }
+
+  private fun drawInstanceCircle(cacheCanvas: Canvas) {
+    val width = measuredWidth
+    val circleX = width / 2f
+    val circleRadius = width / 3f
+    cacheCanvas.drawCircle(circleX, circleY, circleRadius, classNamePaint)
+  }
+
+  fun setType(type: Type) {
+    if (type != this.type) {
+      this.type = type
+      if (cache != null) {
+        cache!!.recycle()
+        cache = null
+      }
+      invalidate()
+    }
+  }
+
+  companion object {
+
+    private val SQRT_TWO = Math.sqrt(2.0)
+        .toFloat()
+    private val CLEAR_XFER_MODE = PorterDuffXfermode(CLEAR)
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/ForegroundService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/ForegroundService.kt
new file mode 100644
index 00000000..9208e0d1
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/ForegroundService.kt
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.app.IntentService
+import android.app.Notification
+import android.content.Intent
+import android.os.IBinder
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.NotificationType.LEAKCANARY_LOW
+
+abstract class ForegroundService(
+  name: String,
+  private val notificationContentTitleResId: Int,
+  private val notificationId: Int
+) : IntentService(name) {
+
+  override fun onCreate() {
+    super.onCreate()
+    showForegroundNotification(
+        max = 100, progress = 0, indeterminate = true,
+        contentText = getString(R.string.leak_canary_notification_foreground_text)
+    )
+  }
+
+  protected fun showForegroundNotification(
+    max: Int,
+    progress: Int,
+    indeterminate: Boolean,
+    contentText: String
+  ) {
+    val builder = Notification.Builder(this)
+        .setContentTitle(getString(notificationContentTitleResId))
+        .setContentText(contentText)
+        .setProgress(max, progress, indeterminate)
+    val notification =
+      Notifications.buildNotification(this, builder, LEAKCANARY_LOW)
+    startForeground(notificationId, notification)
+  }
+
+  override fun onHandleIntent(intent: Intent?) {
+    onHandleIntentInForeground(intent)
+  }
+
+  protected abstract fun onHandleIntentInForeground(intent: Intent?)
+
+  override fun onDestroy() {
+    super.onDestroy()
+    stopForeground(true)
+  }
+
+  override fun onBind(intent: Intent): IBinder? {
+    return null
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/FutureResult.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/FutureResult.kt
new file mode 100644
index 00000000..500b697f
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/FutureResult.kt
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import java.util.concurrent.CountDownLatch
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.atomic.AtomicReference
+
+internal class FutureResult<T> {
+
+  private val resultHolder: AtomicReference<T> = AtomicReference()
+  private val latch: CountDownLatch = CountDownLatch(1)
+
+  fun wait(
+    timeout: Long,
+    unit: TimeUnit
+  ): Boolean {
+    try {
+      return latch.await(timeout, unit)
+    } catch (e: InterruptedException) {
+      throw RuntimeException("Did not expect thread to be interrupted", e)
+    }
+
+  }
+
+  fun get(): T {
+    if (latch.count > 0) {
+      throw IllegalStateException("Call wait() and check its result")
+    }
+    return resultHolder.get()
+  }
+
+  fun set(result: T) {
+    resultHolder.set(result)
+    latch.countDown()
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
new file mode 100644
index 00000000..263f6946
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.content.Context
+import android.content.Intent
+import android.os.Process
+import androidx.core.content.ContextCompat
+import com.squareup.leakcanary.core.R
+import leakcanary.AnalyzerProgressListener
+import leakcanary.AndroidKnownReference
+import leakcanary.CanaryLog
+import leakcanary.HeapAnalyzer
+import leakcanary.LeakCanary
+import java.io.File
+
+/**
+ * This service runs in a main app process.
+ */
+internal class HeapAnalyzerService : ForegroundService(
+    HeapAnalyzerService::class.java.simpleName,
+    R.string.leak_canary_notification_analysing,
+    R.id.leak_canary_notification_analyzing_heap
+), AnalyzerProgressListener {
+
+  override fun onHandleIntentInForeground(intent: Intent?) {
+    if (intent == null) {
+      CanaryLog.d("HeapAnalyzerService received a null intent, ignoring.")
+      return
+    }
+    // Since we're running in the main process we should be careful not to impact it.
+    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)
+    val heapDumpFile = intent.getSerializableExtra(HEAPDUMP_FILE_EXTRA) as File
+
+    if (!heapDumpFile.exists()) {
+      throw IllegalStateException(
+          "Hprof file missing due to: [${LeakDirectoryProvider.hprofDeleteReason(
+              heapDumpFile
+          )}] $heapDumpFile"
+      )
+    }
+
+    val heapAnalyzer = HeapAnalyzer(this)
+    val config = LeakCanary.config
+
+    val exclusions = AndroidKnownReference.mapToExclusions(config.knownReferences)
+
+    val heapAnalysis =
+      heapAnalyzer.checkForLeaks(
+          heapDumpFile, exclusions, config.computeRetainedHeapSize, config.leakTraceInspectors
+      )
+
+    config.analysisResultListener(application, heapAnalysis)
+  }
+
+  override fun onProgressUpdate(step: AnalyzerProgressListener.Step) {
+    val percent = (100f * step.ordinal / AnalyzerProgressListener.Step.values().size).toInt()
+    CanaryLog.d("Analysis in progress, working on: %s", step.name)
+    val lowercase = step.name.replace("_", " ")
+        .toLowerCase()
+    val message = lowercase.substring(0, 1).toUpperCase() + lowercase.substring(1)
+    showForegroundNotification(100, percent, false, message)
+  }
+
+  companion object {
+    private const val HEAPDUMP_FILE_EXTRA = "HEAPDUMP_FILE_EXTRA"
+
+    fun runAnalysis(
+      context: Context,
+      heapDumpFile: File
+    ) {
+      val intent = Intent(context, HeapAnalyzerService::class.java)
+      intent.putExtra(HEAPDUMP_FILE_EXTRA, heapDumpFile)
+      ContextCompat.startForegroundService(context, intent)
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
new file mode 100644
index 00000000..ee54c63d
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -0,0 +1,311 @@
+package leakcanary.internal
+
+import android.app.Application
+import android.app.Notification
+import android.app.NotificationManager
+import android.content.Context
+import android.os.Handler
+import android.os.SystemClock
+import com.squareup.leakcanary.core.R
+import leakcanary.CanaryLog
+import leakcanary.GcTrigger
+import leakcanary.KeyedWeakReference
+import leakcanary.LeakCanary.Config
+import leakcanary.LeakSentry
+import leakcanary.RefWatcher
+import leakcanary.internal.NotificationReceiver.Action.CANCEL_NOTIFICATION
+import leakcanary.internal.NotificationReceiver.Action.DUMP_HEAP
+import leakcanary.internal.NotificationType.LEAKCANARY_LOW
+
+internal class HeapDumpTrigger(
+  private val application: Application,
+  private val backgroundHandler: Handler,
+  private val refWatcher: RefWatcher,
+  private val gcTrigger: GcTrigger,
+  private val heapDumper: HeapDumper,
+  private val configProvider: () -> Config
+) {
+
+  private val notificationManager
+    get() =
+      application.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+
+  private val applicationVisible
+    get() = applicationInvisibleAt == -1L
+
+  @Volatile
+  private var checkScheduled: Boolean = false
+
+  private var lastDisplayedRetainedInstanceCount = 0
+
+  private val scheduleDismissRetainedCountNotification = {
+    dismissRetainedCountNotification()
+  }
+
+  private val scheduleDismissNoRetainedOnTapNotification = {
+    dismissNoRetainedOnTapNotification()
+  }
+
+  /**
+   * When the app becomes invisible, we don't dump the heap immediately. Instead we wait in case
+   * the app came back to the foreground, but also to wait for new leaks that typically occur on
+   * back press (activity destroy).
+   */
+  private val applicationInvisibleLessThanWatchPeriod: Boolean
+    get() {
+      val applicationInvisibleAt = applicationInvisibleAt
+      return applicationInvisibleAt != -1L && SystemClock.uptimeMillis() - applicationInvisibleAt < LeakSentry.config.watchDurationMillis
+    }
+
+  @Volatile
+  private var applicationInvisibleAt = -1L
+
+  fun onApplicationVisibilityChanged(applicationVisible: Boolean) {
+    if (applicationVisible) {
+      applicationInvisibleAt = -1L
+    } else {
+      applicationInvisibleAt = SystemClock.uptimeMillis()
+      scheduleRetainedInstanceCheck("app became invisible", LeakSentry.config.watchDurationMillis)
+    }
+  }
+
+  fun onReferenceRetained() {
+    scheduleRetainedInstanceCheck("found new instance retained")
+  }
+
+  private fun checkRetainedInstances(reason: String) {
+    val config = configProvider()
+    // A tick will be rescheduled when this is turned back on.
+    if (!config.dumpHeap) {
+      CanaryLog.d("No checking for retained instance: LeakCanary.Config.dumpHeap is false")
+      return
+    }
+    CanaryLog.d("Checking retained instances because %s", reason)
+
+    var retainedReferenceCount = refWatcher.retainedInstanceCount
+
+    if (retainedReferenceCount > 0) {
+      gcTrigger.runGc()
+      retainedReferenceCount = refWatcher.retainedInstanceCount
+    }
+
+    if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return
+
+    if (!config.dumpHeapWhenDebugging && DebuggerControl.isDebuggerAttached) {
+      showRetainedCountWithDebuggerAttached(retainedReferenceCount)
+      scheduleRetainedInstanceCheck("debugger was attached", WAIT_FOR_DEBUG_MILLIS)
+      CanaryLog.d(
+          "Not checking for leaks while the debugger is attached, will retry in %d ms",
+          WAIT_FOR_DEBUG_MILLIS
+      )
+      return
+    }
+
+    CanaryLog.d("Found %d retained references, dumping the heap", retainedReferenceCount)
+    val heapDumpUptimeMillis = SystemClock.uptimeMillis()
+    KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis
+    dismissRetainedCountNotification()
+    val heapDumpFile = heapDumper.dumpHeap()
+    if (heapDumpFile == null) {
+      CanaryLog.d("Failed to dump heap, will retry in %d ms", WAIT_AFTER_DUMP_FAILED_MILLIS)
+      scheduleRetainedInstanceCheck("failed to dump heap", WAIT_AFTER_DUMP_FAILED_MILLIS)
+      showRetainedCountWithHeapDumpFailed(retainedReferenceCount)
+      return
+    }
+    lastDisplayedRetainedInstanceCount = 0
+    refWatcher.removeInstancesRetainedBeforeHeapDump(heapDumpUptimeMillis)
+
+    HeapAnalyzerService.runAnalysis(application, heapDumpFile)
+  }
+
+  fun onDumpHeapReceived() {
+    backgroundHandler.post {
+      dismissNoRetainedOnTapNotification()
+      gcTrigger.runGc()
+      val retainedReferenceCount = refWatcher.retainedInstanceCount
+      if (retainedReferenceCount == 0) {
+        CanaryLog.d("No retained instances after GC")
+        val builder = Notification.Builder(application)
+            .setContentTitle(
+                application.getString(R.string.leak_canary_notification_no_retained_instance_title)
+            )
+            .setContentText(
+                application.getString(
+                    R.string.leak_canary_notification_no_retained_instance_content
+                )
+            )
+            .setAutoCancel(true)
+            .setContentIntent(NotificationReceiver.pendingIntent(application, CANCEL_NOTIFICATION))
+        val notification =
+          Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
+        notificationManager.notify(
+            R.id.leak_canary_notification_no_retained_instance_on_tap, notification
+        )
+        backgroundHandler.postDelayed(
+            scheduleDismissNoRetainedOnTapNotification,
+            DISMISS_NO_RETAINED_INSTANCE_NOTIFICATION_MILLIS
+        )
+        lastDisplayedRetainedInstanceCount = 0
+        return@post
+      }
+
+      val heapDumpUptimeMillis = SystemClock.uptimeMillis()
+      KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis
+      CanaryLog.d("Dumping the heap because user tapped notification")
+
+      val heapDumpFile = heapDumper.dumpHeap()
+      if (heapDumpFile == null) {
+        CanaryLog.d("Failed to dump heap")
+        showRetainedCountWithHeapDumpFailed(retainedReferenceCount)
+        return@post
+      }
+      lastDisplayedRetainedInstanceCount = 0
+      refWatcher.removeInstancesRetainedBeforeHeapDump(heapDumpUptimeMillis)
+      HeapAnalyzerService.runAnalysis(application, heapDumpFile)
+    }
+  }
+
+  private fun checkRetainedCount(
+    retainedKeysCount: Int,
+    retainedVisibleThreshold: Int
+  ): Boolean {
+    val countChanged = lastDisplayedRetainedInstanceCount != retainedKeysCount
+    lastDisplayedRetainedInstanceCount = retainedKeysCount
+    if (retainedKeysCount == 0) {
+      CanaryLog.d("No retained instances")
+      if (countChanged) {
+        showNoMoreRetainedInstanceNotification()
+      }
+      return true
+    }
+
+    if (retainedKeysCount < retainedVisibleThreshold) {
+      if (applicationVisible || applicationInvisibleLessThanWatchPeriod) {
+        CanaryLog.d(
+            "Found %d retained instances, which is less than the visible threshold of %d",
+            retainedKeysCount,
+            retainedVisibleThreshold
+        )
+        showRetainedCountBelowThresholdNotification(retainedKeysCount, retainedVisibleThreshold)
+        scheduleRetainedInstanceCheck(
+            "Showing retained instance notification", WAIT_FOR_INSTANCE_THRESHOLD_MILLIS
+        )
+        return true
+      }
+    }
+    return false
+  }
+
+  private fun scheduleRetainedInstanceCheck(reason: String) {
+    if (checkScheduled) {
+      CanaryLog.d("Already scheduled retained check, ignoring ($reason)")
+      return
+    }
+    checkScheduled = true
+    backgroundHandler.post {
+      checkScheduled = false
+      checkRetainedInstances(reason)
+    }
+  }
+
+  private fun scheduleRetainedInstanceCheck(
+    reason: String,
+    delayMillis: Long
+  ) {
+    if (checkScheduled) {
+      CanaryLog.d("Already scheduled retained check, ignoring ($reason)")
+      return
+    }
+    checkScheduled = true
+    backgroundHandler.postDelayed({
+      checkScheduled = false
+      checkRetainedInstances(reason)
+    }, delayMillis)
+  }
+
+  private fun showRetainedCountBelowThresholdNotification(
+    instanceCount: Int,
+    retainedVisibleThreshold: Int
+  ) {
+    showRetainedCountNotification(
+        instanceCount, application.getString(
+        R.string.leak_canary_notification_retained_visible, retainedVisibleThreshold
+    )
+    )
+  }
+
+  private fun showRetainedCountWithDebuggerAttached(instanceCount: Int) {
+    showRetainedCountNotification(
+        instanceCount,
+        application.getString(R.string.leak_canary_notification_retained_debugger_attached)
+    )
+  }
+
+  private fun showRetainedCountWithHeapDumpFailed(instanceCount: Int) {
+    showRetainedCountNotification(
+        instanceCount, application.getString(R.string.leak_canary_notification_retained_dump_failed)
+    )
+  }
+
+  private fun showNoMoreRetainedInstanceNotification() {
+    backgroundHandler.removeCallbacks(scheduleDismissRetainedCountNotification)
+    if (!Notifications.canShowNotification) {
+      return
+    }
+    val builder = Notification.Builder(application)
+        .setContentTitle(
+            application.getString(R.string.leak_canary_notification_no_retained_instance_title)
+        )
+        .setContentText(
+            application.getString(
+                R.string.leak_canary_notification_no_retained_instance_content
+            )
+        )
+        .setAutoCancel(true)
+        .setContentIntent(NotificationReceiver.pendingIntent(application, CANCEL_NOTIFICATION))
+    val notification =
+      Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
+    notificationManager.notify(R.id.leak_canary_notification_retained_instances, notification)
+    backgroundHandler.postDelayed(
+        scheduleDismissRetainedCountNotification, DISMISS_NO_RETAINED_INSTANCE_NOTIFICATION_MILLIS
+    )
+  }
+
+  private fun showRetainedCountNotification(
+    instanceCount: Int,
+    contentText: String
+  ) {
+    backgroundHandler.removeCallbacks(scheduleDismissRetainedCountNotification)
+    if (!Notifications.canShowNotification) {
+      return
+    }
+    val builder = Notification.Builder(application)
+        .setContentTitle(
+            application.getString(R.string.leak_canary_notification_retained_title, instanceCount)
+        )
+        .setContentText(contentText)
+        .setAutoCancel(true)
+        .setContentIntent(NotificationReceiver.pendingIntent(application, DUMP_HEAP))
+    val notification =
+      Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
+    notificationManager.notify(R.id.leak_canary_notification_retained_instances, notification)
+  }
+
+  private fun dismissRetainedCountNotification() {
+    backgroundHandler.removeCallbacks(scheduleDismissRetainedCountNotification)
+    notificationManager.cancel(R.id.leak_canary_notification_retained_instances)
+  }
+
+  private fun dismissNoRetainedOnTapNotification() {
+    backgroundHandler.removeCallbacks(scheduleDismissNoRetainedOnTapNotification)
+    notificationManager.cancel(R.id.leak_canary_notification_no_retained_instance_on_tap)
+  }
+
+  companion object {
+    private const val WAIT_FOR_DEBUG_MILLIS = 20_000L
+    private const val WAIT_AFTER_DUMP_FAILED_MILLIS = 5_000L
+    private const val WAIT_FOR_INSTANCE_THRESHOLD_MILLIS = 2_000L
+    private const val DISMISS_NO_RETAINED_INSTANCE_NOTIFICATION_MILLIS = 30_000L
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumper.kt
similarity index 71%
rename from leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
rename to leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumper.kt
index 715d089a..c115a0c3 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumper.kt
@@ -13,17 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary;
+package leakcanary.internal
 
-import java.io.File;
+import java.io.File
 
-public interface HeapDumper {
-
-  File NO_DUMP = null;
+/** Dumps the heap into a file.  */
+internal interface HeapDumper {
 
   /**
-   * @return a {@link File} referencing the heap dump, or {@link #NO_DUMP} if the heap could not be
-   * dumped.
+   * @return a [File] referencing the dumped heap, or [.RETRY_LATER] if the heap could
+   * not be dumped.
    */
-  File dumpHeap();
-}
\ No newline at end of file
+  fun dumpHeap(): File?
+
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
new file mode 100644
index 00000000..8c71a08b
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -0,0 +1,221 @@
+package leakcanary.internal
+
+import android.app.Application
+import android.app.Instrumentation
+import android.content.ComponentName
+import android.content.Intent
+import android.content.pm.ShortcutInfo.Builder
+import android.content.pm.ShortcutManager
+import android.graphics.drawable.Icon
+import android.os.Build.VERSION
+import android.os.Build.VERSION_CODES
+import android.os.Handler
+import android.os.HandlerThread
+import com.squareup.leakcanary.core.R
+import leakcanary.CanaryLog
+import leakcanary.GcTrigger
+import leakcanary.LeakCanary
+import leakcanary.LeakCanary.Config
+import leakcanary.LeakSentry
+import leakcanary.internal.activity.LeakActivity
+import java.util.concurrent.atomic.AtomicReference
+
+internal object InternalLeakCanary : LeakSentryListener {
+
+  private const val DYNAMIC_SHORTCUT_ID = "com.squareup.leakcanary.dynamic_shortcut"
+
+  private lateinit var heapDumpTrigger: HeapDumpTrigger
+
+  lateinit var application: Application
+  @Volatile
+  var applicationVisible = false
+    private set
+
+  val leakDirectoryProvider: LeakDirectoryProvider by lazy {
+    LeakDirectoryProvider(application, {
+      LeakCanary.config.maxStoredHeapDumps
+    }, {
+      LeakCanary.config.requestWriteExternalStoragePermission
+    })
+  }
+
+  val leakDisplayActivityIntent: Intent
+    get() = LeakActivity.createIntent(application)
+
+  val noInstallConfig: Config
+    get() = Config(
+        dumpHeap = false, knownReferences = emptySet(), leakTraceInspectors = emptyList()
+    )
+
+  override fun onLeakSentryInstalled(application: Application) {
+    this.application = application
+
+    val heapDumper = AndroidHeapDumper(application, leakDirectoryProvider)
+
+    val gcTrigger = GcTrigger.Default
+
+    val configProvider = { LeakCanary.config }
+
+    val handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)
+    handlerThread.start()
+    val backgroundHandler = Handler(handlerThread.looper)
+
+    heapDumpTrigger = HeapDumpTrigger(
+        application, backgroundHandler, LeakSentry.refWatcher, gcTrigger, heapDumper, configProvider
+    )
+    application.registerVisibilityListener { applicationVisible ->
+      this.applicationVisible = applicationVisible
+      heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)
+    }
+    addDynamicShortcut(application)
+
+    disableDumpHeapInInstrumentationTests()
+  }
+
+  private fun disableDumpHeapInInstrumentationTests() {
+    // This is called before Application.onCreate(), so InstrumentationRegistry has no reference to
+    // the instrumentation yet. That happens immediately after the content providers are created,
+    // in the same main thread message, so by posting to the end of the main thread queue we're
+    // guaranteed that the instrumentation will be in place.
+    Handler().post {
+      val runningInInstrumentationTests = try {
+        // This is assuming all UI tests rely on InstrumentationRegistry. Should be mostly true
+        // these days (especially since we force the Android X dependency on consumers).
+        val registryClass = Class.forName("androidx.test.platform.app.InstrumentationRegistry")
+        val instrumentationRefField = registryClass.getDeclaredField("instrumentationRef")
+        instrumentationRefField.isAccessible = true
+        @Suppress("UNCHECKED_CAST")
+        val instrumentationRef = instrumentationRefField.get(
+            null
+        ) as AtomicReference<Instrumentation>
+        instrumentationRef.get() != null
+      } catch (ignored: Throwable) {
+        false
+      }
+
+      if (runningInInstrumentationTests) {
+        CanaryLog.d("Instrumentation test detected, setting LeakCanary.Config.dumpHeap to false")
+        LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
+      }
+    }
+  }
+
+  private fun addDynamicShortcut(application: Application) {
+    if (VERSION.SDK_INT < VERSION_CODES.N_MR1) {
+      return
+    }
+    if (!application.resources.getBoolean(R.bool.leak_canary_add_dynamic_shortcut)) {
+      return
+    }
+
+    val shortcutManager = application.getSystemService(ShortcutManager::class.java)!!
+    val dynamicShortcuts = shortcutManager.dynamicShortcuts
+
+    val shortcutInstalled =
+      dynamicShortcuts.any { shortcut -> shortcut.id == DYNAMIC_SHORTCUT_ID }
+
+    if (shortcutInstalled) {
+      return
+    }
+
+    val mainIntent = Intent(Intent.ACTION_MAIN, null)
+    mainIntent.addCategory(Intent.CATEGORY_LAUNCHER)
+    mainIntent.setPackage(application.packageName)
+    val activities = application.packageManager.queryIntentActivities(mainIntent, 0)
+        .filter {
+          it.activityInfo.name != "leakcanary.internal.activity.LeakLauncherActivity"
+        }
+
+    if (activities.isEmpty()) {
+      return
+    }
+
+    val firstMainActivity = activities.first()
+        .activityInfo
+
+    // Displayed on long tap on app icon
+    val longLabel: String
+    // Label when dropping shortcut to launcher
+    val shortLabel: String
+
+    val leakActivityLabel = application.getString(R.string.leak_canary_shortcut_label)
+
+    if (activities.isEmpty()) {
+      longLabel = leakActivityLabel
+      shortLabel = leakActivityLabel
+    } else {
+
+      val firstLauncherActivityLabel = if (firstMainActivity.labelRes != 0) {
+        application.getString(firstMainActivity.labelRes)
+      } else {
+        val applicationInfo = application.applicationInfo
+        if (applicationInfo.labelRes != 0) {
+          application.getString(applicationInfo.labelRes)
+        } else {
+          applicationInfo.nonLocalizedLabel.toString()
+        }
+      }
+      val fullLengthLabel = "$firstLauncherActivityLabel $leakActivityLabel"
+      // short label should be under 10 and long label under 25
+      if (fullLengthLabel.length > 10) {
+        if (fullLengthLabel.length <= 25) {
+          longLabel = fullLengthLabel
+          shortLabel = leakActivityLabel
+        } else {
+          longLabel = leakActivityLabel
+          shortLabel = leakActivityLabel
+        }
+      } else {
+        longLabel = fullLengthLabel
+        shortLabel = fullLengthLabel
+      }
+    }
+
+    val componentName = ComponentName(firstMainActivity.packageName, firstMainActivity.name)
+
+    val shortcutCount = dynamicShortcuts.count { shortcutInfo ->
+      shortcutInfo.activity == componentName
+    } + shortcutManager.manifestShortcuts.count { shortcutInfo ->
+      shortcutInfo.activity == componentName
+    }
+
+    if (shortcutCount >= shortcutManager.maxShortcutCountPerActivity) {
+      return
+    }
+
+    val intent = leakDisplayActivityIntent
+    intent.action = "Dummy Action because Android is stupid"
+    val shortcut = Builder(application, DYNAMIC_SHORTCUT_ID)
+        .setLongLabel(longLabel)
+        .setShortLabel(shortLabel)
+        .setActivity(componentName)
+        .setIcon(Icon.createWithResource(application, R.mipmap.leak_canary_icon))
+        .setIntent(intent)
+        .build()
+
+    try {
+      shortcutManager.addDynamicShortcuts(listOf(shortcut))
+    } catch (ignored: Throwable) {
+      CanaryLog.d(
+          ignored,
+          "Could not add dynamic shortcut. " +
+              "shortcutCount=$shortcutCount, " +
+              "maxShortcutCountPerActivity=${shortcutManager.maxShortcutCountPerActivity}"
+      )
+    }
+  }
+
+  override fun onReferenceRetained() {
+    if (this::heapDumpTrigger.isInitialized) {
+      heapDumpTrigger.onReferenceRetained()
+    }
+  }
+
+  fun onDumpHeapReceived() {
+    if (this::heapDumpTrigger.isInitialized) {
+      heapDumpTrigger.onDumpHeapReceived()
+    }
+  }
+
+  private const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt
new file mode 100644
index 00000000..cade0684
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt
@@ -0,0 +1,9 @@
+package leakcanary.internal
+
+import androidx.core.content.FileProvider
+
+/**
+ * There can only be one [FileProvider] provider registered per app, so we extend that class
+ * just to use a distinct name.
+ */
+internal class LeakCanaryFileProvider : FileProvider()
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanarySingleThreadFactory.kt
similarity index 63%
rename from leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java
rename to leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanarySingleThreadFactory.kt
index 4eb3a3a0..a3c30910 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanarySingleThreadFactory.kt
@@ -13,22 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary.internal;
+package leakcanary.internal
 
-import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadFactory
 
 /**
  * This is intended to only be used with a single thread executor.
  */
-final class LeakCanarySingleThreadFactory implements ThreadFactory {
+internal class LeakCanarySingleThreadFactory(threadName: String) : ThreadFactory {
 
-  private final String threadName;
+  private val threadName: String = "LeakCanary-$threadName"
 
-  LeakCanarySingleThreadFactory(String threadName) {
-    this.threadName = "LeakCanary-" + threadName;
-  }
-
-  @Override public Thread newThread(Runnable runnable) {
-    return new Thread(runnable, threadName);
+  override fun newThread(runnable: Runnable): Thread {
+    return Thread(runnable, threadName)
   }
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
new file mode 100644
index 00000000..a42d6fdc
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.Manifest.permission.WRITE_EXTERNAL_STORAGE
+import android.annotation.TargetApi
+import android.content.Context
+import android.content.pm.PackageManager.PERMISSION_GRANTED
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.M
+import android.os.Environment
+import android.os.Environment.DIRECTORY_DOWNLOADS
+import com.squareup.leakcanary.core.R
+import leakcanary.CanaryLog
+import leakcanary.internal.NotificationType.LEAKCANARY_LOW
+import java.io.File
+import java.io.FilenameFilter
+import java.text.SimpleDateFormat
+import java.util.ArrayList
+import java.util.Arrays
+import java.util.Date
+import java.util.Locale
+
+/**
+ * Provides access to where heap dumps and analysis results will be stored.
+ */
+internal class LeakDirectoryProvider constructor(
+  context: Context,
+  private val maxStoredHeapDumps: () -> Int,
+  private val requestExternalStoragePermission: () -> Boolean
+) {
+
+  private val context: Context = context.applicationContext
+
+  @Volatile private var writeExternalStorageGranted: Boolean = false
+  @Volatile private var permissionNotificationDisplayed: Boolean = false
+
+  fun listFiles(filter: FilenameFilter): MutableList<File> {
+    if (!hasStoragePermission() && requestExternalStoragePermission()) {
+      requestWritePermissionNotification()
+    }
+    val files = ArrayList<File>()
+
+    val externalFiles = externalStorageDirectory().listFiles(filter)
+    if (externalFiles != null) {
+      files.addAll(Arrays.asList(*externalFiles))
+    }
+
+    val appFiles = appStorageDirectory().listFiles(filter)
+    if (appFiles != null) {
+      files.addAll(Arrays.asList(*appFiles))
+    }
+    return files
+  }
+
+  fun newHeapDumpFile(): File? {
+    cleanupOldHeapDumps()
+
+    var storageDirectory = externalStorageDirectory()
+    if (!directoryWritableAfterMkdirs(storageDirectory)) {
+      if (!hasStoragePermission()) {
+        if (requestExternalStoragePermission()) {
+          CanaryLog.d("WRITE_EXTERNAL_STORAGE permission not granted, requesting")
+          requestWritePermissionNotification()
+        } else {
+          CanaryLog.d("WRITE_EXTERNAL_STORAGE permission not granted, ignoring")
+        }
+      } else {
+        val state = Environment.getExternalStorageState()
+        if (Environment.MEDIA_MOUNTED != state) {
+          CanaryLog.d("External storage not mounted, state: %s", state)
+        } else {
+          CanaryLog.d(
+              "Could not create heap dump directory in external storage: [%s]",
+              storageDirectory.absolutePath
+          )
+        }
+      }
+      // Fallback to app storage.
+      storageDirectory = appStorageDirectory()
+      if (!directoryWritableAfterMkdirs(storageDirectory)) {
+        CanaryLog.d(
+            "Could not create heap dump directory in app storage: [%s]",
+            storageDirectory.absolutePath
+        )
+        return null
+      }
+    }
+
+    val fileName = SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'.hprof'", Locale.US).format(Date())
+    return File(storageDirectory, fileName)
+  }
+
+  fun clearLeakDirectory() {
+    val allFilesExceptPending =
+      listFiles(FilenameFilter { _, filename ->
+        true
+      })
+    for (file in allFilesExceptPending) {
+      val path = file.absolutePath
+      val deleted = file.delete()
+      if (deleted) {
+        filesDeletedClearDirectory += path
+      }
+      if (!deleted) {
+        CanaryLog.d("Could not delete file %s", file.path)
+      }
+    }
+  }
+
+  @TargetApi(M) fun hasStoragePermission(): Boolean {
+    if (SDK_INT < M) {
+      return true
+    }
+    // Once true, this won't change for the life of the process so we can cache it.
+    if (writeExternalStorageGranted) {
+      return true
+    }
+    writeExternalStorageGranted =
+      context.checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED
+    return writeExternalStorageGranted
+  }
+
+  fun requestWritePermissionNotification() {
+    if (permissionNotificationDisplayed) {
+      return
+    }
+    permissionNotificationDisplayed = true
+
+    val pendingIntent = RequestStoragePermissionActivity.createPendingIntent(context)
+    val contentTitle = context.getString(
+        R.string.leak_canary_permission_notification_title
+    )
+    val packageName = context.packageName
+    val contentText =
+      context.getString(R.string.leak_canary_permission_notification_text, packageName)
+
+    Notifications.showNotification(
+        context, contentTitle, contentText, pendingIntent,
+        R.id.leak_canary_notification_write_permission, LEAKCANARY_LOW
+    )
+  }
+
+  private fun externalStorageDirectory(): File {
+    val downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS)
+    return File(downloadsDirectory, "leakcanary-" + context.packageName)
+  }
+
+  private fun appStorageDirectory(): File {
+    val appFilesDirectory = context.filesDir
+    return File(appFilesDirectory, "leakcanary")
+  }
+
+  private fun directoryWritableAfterMkdirs(directory: File): Boolean {
+    val success = directory.mkdirs()
+    return (success || directory.exists()) && directory.canWrite()
+  }
+
+  private fun cleanupOldHeapDumps() {
+    val hprofFiles = listFiles(FilenameFilter { _, name ->
+      name.endsWith(
+          HPROF_SUFFIX
+      )
+    })
+    val maxStoredHeapDumps = maxStoredHeapDumps()
+    if (maxStoredHeapDumps < 1) {
+      throw IllegalArgumentException("maxStoredHeapDumps must be at least 1")
+    }
+
+    val filesToRemove = hprofFiles.size - maxStoredHeapDumps
+    if (filesToRemove > 0) {
+      CanaryLog.d("Removing %d heap dumps", filesToRemove)
+      // Sort with oldest modified first.
+      hprofFiles.sortWith(Comparator { lhs, rhs ->
+        java.lang.Long.valueOf(lhs.lastModified())
+            .compareTo(rhs.lastModified())
+      })
+      for (i in 0 until filesToRemove) {
+        val path = hprofFiles[i].absolutePath
+        val deleted = hprofFiles[i].delete()
+        if (deleted) {
+          filesDeletedTooOld += path
+        } else {
+          CanaryLog.d("Could not delete old hprof file %s", hprofFiles[i].path)
+        }
+      }
+    }
+  }
+
+  companion object {
+
+    private val filesDeletedTooOld = mutableListOf<String>()
+    private val filesDeletedClearDirectory = mutableListOf<String>()
+    val filesDeletedRemoveLeak = mutableListOf<String>()
+
+    private const val HPROF_SUFFIX = ".hprof"
+
+    fun hprofDeleteReason(file: File): String {
+      val path = file.absolutePath
+      return when {
+        filesDeletedTooOld.contains(path) -> "Older than all other hprof files"
+        filesDeletedClearDirectory.contains(path) -> "Hprof directory cleared"
+        filesDeletedRemoveLeak.contains(path) -> "Leak manually removed"
+        else -> "Unknown"
+      }
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/MoreDetailsView.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/MoreDetailsView.kt
new file mode 100644
index 00000000..ab13f6ea
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/MoreDetailsView.kt
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.annotation.SuppressLint
+import android.content.Context
+import android.graphics.Canvas
+import android.graphics.Color
+import android.graphics.Paint
+import android.util.AttributeSet
+import android.view.View
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.MoreDetailsView.Details.CLOSED
+import leakcanary.internal.MoreDetailsView.Details.OPENED
+
+internal class MoreDetailsView(
+  context: Context,
+  attrs: AttributeSet
+) : View(context, attrs) {
+
+  enum class Details {
+    OPENED,
+    CLOSED,
+    NONE
+  }
+
+  private val iconPaint: Paint
+
+  private var details = Details.NONE
+
+  init {
+    val resources = resources
+    iconPaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    val strokeSize = resources.getDimensionPixelSize(R.dimen.leak_canary_more_stroke_width)
+        .toFloat()
+    iconPaint.strokeWidth = strokeSize
+
+    // This lint check doesn't work for libraries which have a common prefix.
+    @SuppressLint("CustomViewStyleable") //
+    val a = context.obtainStyledAttributes(attrs, R.styleable.leak_canary_MoreDetailsView)
+    val plusColor =
+      a.getColor(R.styleable.leak_canary_MoreDetailsView_leak_canary_plus_color, Color.BLACK)
+    a.recycle()
+
+    iconPaint.color = plusColor
+  }
+
+  override fun onDraw(canvas: Canvas) {
+    val width = width
+    val height = height
+    val halfHeight = height / 2
+    val halfWidth = width / 2
+
+    if (details == OPENED) {
+      canvas.drawLine(0f, halfHeight.toFloat(), width.toFloat(), halfHeight.toFloat(), iconPaint)
+    } else if (details == CLOSED) {
+      canvas.drawLine(0f, halfHeight.toFloat(), width.toFloat(), halfHeight.toFloat(), iconPaint)
+      canvas.drawLine(halfWidth.toFloat(), 0f, halfWidth.toFloat(), height.toFloat(), iconPaint)
+    }
+  }
+
+  fun setDetails(details: Details) {
+    if (details != this.details) {
+      this.details = details
+      invalidate()
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationReceiver.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationReceiver.kt
new file mode 100644
index 00000000..f7e7f86c
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationReceiver.kt
@@ -0,0 +1,45 @@
+package leakcanary.internal
+
+import android.app.PendingIntent
+import android.content.BroadcastReceiver
+import android.content.Context
+import android.content.Intent
+import leakcanary.CanaryLog
+import leakcanary.internal.NotificationReceiver.Action.CANCEL_NOTIFICATION
+import leakcanary.internal.NotificationReceiver.Action.DUMP_HEAP
+
+internal class NotificationReceiver : BroadcastReceiver() {
+
+  enum class Action {
+    DUMP_HEAP,
+    CANCEL_NOTIFICATION
+  }
+
+  override fun onReceive(
+    context: Context,
+    intent: Intent
+  ) {
+    when (intent.action) {
+      DUMP_HEAP.name -> {
+        InternalLeakCanary.onDumpHeapReceived()
+      }
+      CANCEL_NOTIFICATION.name -> {
+        // Do nothing, the notification has auto cancel true.
+      }
+      else -> {
+        CanaryLog.d("NotificationReceiver received unknown intent action for $intent")
+      }
+    }
+  }
+
+  companion object {
+    fun pendingIntent(
+      context: Context,
+      action: Action
+    ): PendingIntent {
+      val broadcastIntent = Intent(context, NotificationReceiver::class.java)
+      broadcastIntent.action = action.name
+      return PendingIntent.getBroadcast(context, 0, broadcastIntent, 0)
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt
new file mode 100644
index 00000000..677f7f48
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt
@@ -0,0 +1,16 @@
+package leakcanary.internal
+
+import androidx.annotation.StringRes
+import com.squareup.leakcanary.core.R
+
+enum class NotificationType(@StringRes val nameResId: Int, val importance: Int) {
+  LEAKCANARY_LOW(
+      R.string.leak_canary_notification_channel_low, IMPORTANCE_LOW
+  ),
+  LEAKCANARY_RESULT(
+      R.string.leak_canary_notification_channel_result, IMPORTANCE_DEFAULT
+  );
+}
+
+private const val IMPORTANCE_LOW = 2
+private const val IMPORTANCE_DEFAULT = 3
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt
new file mode 100644
index 00000000..3559c153
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.app.Notification
+import android.app.NotificationChannel
+import android.app.NotificationManager
+import android.app.PendingIntent
+import android.content.Context
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.JELLY_BEAN
+import android.os.Build.VERSION_CODES.O
+import com.squareup.leakcanary.core.R
+
+internal object Notifications {
+
+  val canShowNotification: Boolean
+    get() = canShowBackgroundNotifications || InternalLeakCanary.applicationVisible
+
+  private val canShowBackgroundNotifications = if (SDK_INT >= O) {
+    // Instants apps cannot show background notifications
+    // See https://github.com/square/leakcanary/issues/1197
+    !InternalLeakCanary.application.packageManager.isInstantApp
+  } else true
+
+  fun showNotification(
+    context: Context,
+    contentTitle: CharSequence,
+    contentText: CharSequence,
+    pendingIntent: PendingIntent?,
+    notificationId: Int,
+    type: NotificationType
+  ) {
+    if (!canShowNotification) {
+      return
+    }
+    val builder = Notification.Builder(context)
+        .setContentText(contentText)
+        .setContentTitle(contentTitle)
+        .setAutoCancel(true)
+        .setContentIntent(pendingIntent)
+
+    val notification =
+      buildNotification(context, builder, type)
+    val notificationManager =
+      context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+    notificationManager.notify(notificationId, notification)
+  }
+
+  fun buildNotification(
+    context: Context,
+    builder: Notification.Builder,
+    type: NotificationType
+  ): Notification {
+    builder.setSmallIcon(R.drawable.leak_canary_notification)
+        .setWhen(System.currentTimeMillis())
+
+    if (SDK_INT >= O) {
+      val notificationManager =
+        context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+      var notificationChannel: NotificationChannel? =
+        notificationManager.getNotificationChannel(type.name)
+      if (notificationChannel == null) {
+        val channelName = context.getString(type.nameResId)
+        notificationChannel =
+          NotificationChannel(type.name, channelName, type.importance)
+        notificationManager.createNotificationChannel(notificationChannel)
+      }
+      builder.setChannelId(type.name)
+    }
+
+    return if (SDK_INT < JELLY_BEAN) {
+      builder.notification
+    } else {
+      builder.build()
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/RequestStoragePermissionActivity.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/RequestStoragePermissionActivity.kt
new file mode 100644
index 00000000..00272b52
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/RequestStoragePermissionActivity.kt
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.Manifest.permission.WRITE_EXTERNAL_STORAGE
+import android.annotation.TargetApi
+import android.app.Activity
+import android.app.PendingIntent
+import android.app.PendingIntent.FLAG_UPDATE_CURRENT
+import android.content.Context
+import android.content.Intent
+import android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP
+import android.content.Intent.FLAG_ACTIVITY_NEW_TASK
+import android.content.pm.PackageManager.PERMISSION_GRANTED
+import android.os.Build.VERSION_CODES.M
+import android.os.Bundle
+import android.widget.Toast
+import android.widget.Toast.LENGTH_LONG
+import com.squareup.leakcanary.core.R
+
+@TargetApi(M) //
+internal class RequestStoragePermissionActivity : Activity() {
+
+  override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+
+    if (savedInstanceState == null) {
+      if (hasStoragePermission()) {
+        finish()
+        return
+      }
+      val permissions = arrayOf(WRITE_EXTERNAL_STORAGE)
+      requestPermissions(permissions, 42)
+    }
+  }
+
+  override fun onRequestPermissionsResult(
+    requestCode: Int,
+    permissions: Array<String>,
+    grantResults: IntArray
+  ) {
+    if (!hasStoragePermission()) {
+      Toast.makeText(application, R.string.leak_canary_permission_not_granted, LENGTH_LONG)
+          .show()
+    }
+    finish()
+  }
+
+  override fun finish() {
+    // Reset the animation to avoid flickering.
+    overridePendingTransition(0, 0)
+    super.finish()
+  }
+
+  private fun hasStoragePermission(): Boolean {
+    return checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED
+  }
+
+  companion object {
+
+    fun createPendingIntent(context: Context): PendingIntent {
+      val intent = Intent(context, RequestStoragePermissionActivity::class.java)
+      intent.flags = FLAG_ACTIVITY_NEW_TASK or FLAG_ACTIVITY_CLEAR_TOP
+      return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT)
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/RowElementLayout.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/RowElementLayout.kt
new file mode 100644
index 00000000..5d470a4d
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/RowElementLayout.kt
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.content.Context
+import android.util.AttributeSet
+import android.view.View
+import android.view.ViewGroup
+import com.squareup.leakcanary.core.R
+
+internal class RowElementLayout(
+  context: Context,
+  attrs: AttributeSet
+) : ViewGroup(context, attrs) {
+
+  private val connectorWidth: Int
+  private val rowMargins: Int
+  private val moreSize: Int
+  private val minHeight: Int
+  private val titleMarginTop: Int
+  private val moreMarginTop: Int
+
+  private var connector: View? = null
+  private var moreButton: View? = null
+  private var title: View? = null
+  private var details: View? = null
+
+  init {
+    val resources = resources
+    connectorWidth = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_width)
+    rowMargins = resources.getDimensionPixelSize(R.dimen.leak_canary_row_margins)
+    moreSize = resources.getDimensionPixelSize(R.dimen.leak_canary_more_size)
+    minHeight = resources.getDimensionPixelSize(R.dimen.leak_canary_row_min)
+    titleMarginTop = resources.getDimensionPixelSize(R.dimen.leak_canary_row_title_margin_top)
+    moreMarginTop = resources.getDimensionPixelSize(R.dimen.leak_canary_more_margin_top)
+  }
+
+  override fun onFinishInflate() {
+    super.onFinishInflate()
+    connector = findViewById(R.id.leak_canary_row_connector)
+    moreButton = findViewById(R.id.leak_canary_row_more)
+    title = findViewById(R.id.leak_canary_row_title)
+    details = findViewById(R.id.leak_canary_row_details)
+  }
+
+  override fun onMeasure(
+    widthMeasureSpec: Int,
+    heightMeasureSpec: Int
+  ) {
+    val availableWidth = View.MeasureSpec.getSize(widthMeasureSpec)
+    val titleWidth = availableWidth - connectorWidth - moreSize - 4 * rowMargins
+    val titleWidthSpec = View.MeasureSpec.makeMeasureSpec(titleWidth, View.MeasureSpec.AT_MOST)
+    val titleHeightSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)
+    title!!.measure(titleWidthSpec, titleHeightSpec)
+
+    val moreSizeSpec = View.MeasureSpec.makeMeasureSpec(moreSize, View.MeasureSpec.EXACTLY)
+    moreButton!!.measure(moreSizeSpec, moreSizeSpec)
+
+    var totalHeight = titleMarginTop + title!!.measuredHeight
+
+    val detailsWidth = availableWidth - connectorWidth - 3 * rowMargins
+    val detailsWidthSpec = View.MeasureSpec.makeMeasureSpec(detailsWidth, View.MeasureSpec.AT_MOST)
+    val detailsHeightSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)
+    details!!.measure(detailsWidthSpec, detailsHeightSpec)
+    if (details!!.visibility != View.GONE) {
+      totalHeight += details!!.measuredHeight
+    }
+    totalHeight = Math.max(totalHeight, minHeight)
+
+    val connectorWidthSpec =
+      View.MeasureSpec.makeMeasureSpec(connectorWidth, View.MeasureSpec.EXACTLY)
+    val connectorHeightSpec =
+      View.MeasureSpec.makeMeasureSpec(totalHeight, View.MeasureSpec.EXACTLY)
+
+    connector!!.measure(connectorWidthSpec, connectorHeightSpec)
+    setMeasuredDimension(availableWidth, totalHeight)
+  }
+
+  override fun onLayout(
+    changed: Boolean,
+    l: Int,
+    t: Int,
+    r: Int,
+    b: Int
+  ) {
+    val width = measuredWidth
+    val connectorRight = rowMargins + connector!!.measuredWidth
+    connector!!.layout(rowMargins, 0, connectorRight, connector!!.measuredHeight)
+
+    moreButton!!.layout(
+        width - rowMargins - moreSize, moreMarginTop, width - rowMargins,
+        moreMarginTop + moreSize
+    )
+
+    val titleLeft = connectorRight + rowMargins
+    val titleBottom = titleMarginTop + title!!.measuredHeight
+    title!!.layout(titleLeft, titleMarginTop, titleLeft + title!!.measuredWidth, titleBottom)
+
+    if (details!!.visibility != View.GONE) {
+      details!!.layout(
+          titleLeft, titleBottom, width - rowMargins,
+          titleBottom + details!!.measuredHeight
+      )
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt
new file mode 100644
index 00000000..747f488f
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.content.Context
+import android.graphics.Canvas
+import android.graphics.Paint
+import android.graphics.Path
+import android.text.SpannableStringBuilder
+import android.text.style.ReplacementSpan
+import android.text.style.UnderlineSpan
+import androidx.core.content.ContextCompat
+import com.squareup.leakcanary.core.R
+
+/**
+ * Inspired from https://github.com/flavienlaurent/spans and
+ * https://github.com/andyxialm/WavyLineView
+ */
+internal class SquigglySpan(context: Context) : ReplacementSpan() {
+
+  private val squigglyPaint: Paint = Paint(Paint.ANTI_ALIAS_FLAG)
+  private val path: Path
+  private val referenceColor: Int
+  private val halfStrokeWidth: Float
+  private val amplitude: Float
+  private val halfWaveHeight: Float
+  private val periodDegrees: Float
+
+  private var width: Int = 0
+
+  init {
+    val resources = context.resources
+    squigglyPaint.style = Paint.Style.STROKE
+    squigglyPaint.color = ContextCompat.getColor(context, R.color.leak_canary_leak)
+    val strokeWidth =
+      resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_stroke_width)
+          .toFloat()
+    squigglyPaint.strokeWidth = strokeWidth
+
+    halfStrokeWidth = strokeWidth / 2
+    amplitude = resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_amplitude)
+        .toFloat()
+    periodDegrees =
+      resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_period_degrees)
+          .toFloat()
+    path = Path()
+    val waveHeight = 2 * amplitude + strokeWidth
+    halfWaveHeight = waveHeight / 2
+    referenceColor = ContextCompat.getColor(context, R.color.leak_canary_reference)
+  }
+
+  override fun getSize(
+    paint: Paint,
+    text: CharSequence,
+    start: Int,
+    end: Int,
+    fm: Paint.FontMetricsInt?
+  ): Int {
+    width = paint.measureText(text, start, end)
+        .toInt()
+    return width
+  }
+
+  override fun draw(
+    canvas: Canvas,
+    text: CharSequence,
+    start: Int,
+    end: Int,
+    x: Float,
+    top: Int,
+    y: Int,
+    bottom: Int,
+    paint: Paint
+  ) {
+    squigglyHorizontalPath(
+        path,
+        x + halfStrokeWidth,
+        x + width - halfStrokeWidth,
+        bottom - halfWaveHeight,
+        amplitude, periodDegrees
+    )
+    canvas.drawPath(path, squigglyPaint)
+
+    paint.color = referenceColor
+    canvas.drawText(text, start, end, x, y.toFloat(), paint)
+  }
+
+  companion object {
+
+    fun replaceUnderlineSpans(
+      builder: SpannableStringBuilder,
+      context: Context
+    ) {
+      val underlineSpans = builder.getSpans(0, builder.length, UnderlineSpan::class.java)
+      for (span in underlineSpans) {
+        val start = builder.getSpanStart(span)
+        val end = builder.getSpanEnd(span)
+        builder.removeSpan(span)
+        builder.setSpan(SquigglySpan(context), start, end, 0)
+      }
+    }
+
+    private fun squigglyHorizontalPath(
+      path: Path,
+      left: Float,
+      right: Float,
+      centerY: Float,
+      amplitude: Float,
+      periodDegrees: Float
+    ) {
+      path.reset()
+
+      var y: Float
+      path.moveTo(left, centerY)
+      val period = (2 * Math.PI / periodDegrees).toFloat()
+
+      var x = 0f
+      while (x <= right - left) {
+        y = (amplitude * Math.sin((40 + period * x).toDouble()) + centerY).toFloat()
+        path.lineTo(left + x, y)
+        x += 1f
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
new file mode 100644
index 00000000..ca214b51
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
@@ -0,0 +1,44 @@
+package leakcanary.internal
+
+import android.app.Activity
+import android.app.Application
+import leakcanary.internal.InternalHelper.noOpDelegate
+
+internal class VisibilityTracker(
+  private val listener: (Boolean) -> Unit
+) :
+    Application.ActivityLifecycleCallbacks by noOpDelegate() {
+
+  private var startedActivityCount = 0
+
+  /**
+   * Visible activities are any activity started but not stopped yet. An activity can be paused
+   * yet visible: this will happen when another activity shows on top with a transparent background
+   * and the activity behind won't get touch inputs but still need to render / animate.
+   */
+  private var hasVisibleActivities: Boolean = false
+
+  override fun onActivityStarted(activity: Activity) {
+    startedActivityCount++
+    if (!hasVisibleActivities && startedActivityCount == 1) {
+      hasVisibleActivities = true
+      listener.invoke(true)
+    }
+  }
+
+  override fun onActivityStopped(activity: Activity) {
+    // This could happen if the callbacks were registered after some activities were already
+    // started. In that case we effectively considers those past activities as not visible.
+    if (startedActivityCount > 0) {
+      startedActivityCount--
+    }
+    if (hasVisibleActivities && startedActivityCount == 0 && !activity.isChangingConfigurations) {
+      hasVisibleActivities = false
+      listener.invoke(false)
+    }
+  }
+}
+
+internal fun Application.registerVisibilityListener(listener: (Boolean) -> Unit) {
+  registerActivityLifecycleCallbacks(VisibilityTracker(listener))
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt
new file mode 100644
index 00000000..bd1ba2e0
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt
@@ -0,0 +1,121 @@
+package leakcanary.internal.activity
+
+import android.app.PendingIntent
+import android.content.Context
+import android.content.Intent
+import android.net.Uri
+import android.os.AsyncTask
+import android.os.Bundle
+import com.squareup.leakcanary.core.R
+import leakcanary.CanaryLog
+import leakcanary.internal.HeapAnalyzerService
+import leakcanary.internal.InternalLeakCanary
+import leakcanary.internal.activity.db.Db
+import leakcanary.internal.activity.screen.GroupListScreen
+import leakcanary.internal.navigation.NavigatingActivity
+import leakcanary.internal.navigation.Screen
+import java.io.FileInputStream
+import java.io.IOException
+
+internal class LeakActivity : NavigatingActivity() {
+
+  override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+    setContentView(R.layout.leak_canary_leak_activity)
+
+    installNavigation(savedInstanceState, findViewById(R.id.main_container))
+  }
+
+  override fun getLauncherScreen(): Screen {
+    return GroupListScreen()
+  }
+
+  fun requestImportHprof() {
+    val requestFileIntent = Intent(Intent.ACTION_GET_CONTENT).apply {
+      type = "*/*"
+      addCategory(Intent.CATEGORY_OPENABLE)
+    }
+
+    val chooserIntent = Intent.createChooser(
+        requestFileIntent, resources.getString(R.string.leak_canary_import_from_title)
+    )
+    startActivityForResult(chooserIntent, FILE_REQUEST_CODE)
+  }
+
+  override fun onActivityResult(
+    requestCode: Int,
+    resultCode: Int,
+    returnIntent: Intent?
+  ) {
+    CanaryLog.d(
+        "Got activity result with requestCode=$requestCode resultCode=$resultCode returnIntent=$returnIntent"
+    )
+    if (requestCode == FILE_REQUEST_CODE && resultCode == RESULT_OK && returnIntent != null) {
+      returnIntent.data?.let { fileUri ->
+        AsyncTask.THREAD_POOL_EXECUTOR.execute {
+          importHprof(fileUri)
+        }
+      }
+    }
+  }
+
+  private fun importHprof(fileUri: Uri) {
+    try {
+      contentResolver.openFileDescriptor(fileUri, "r")
+          ?.fileDescriptor?.let { fileDescriptor ->
+        val inputStream = FileInputStream(fileDescriptor)
+        InternalLeakCanary.leakDirectoryProvider
+            .newHeapDumpFile()
+            ?.let { target ->
+              inputStream.use { input ->
+                target.outputStream()
+                    .use { output ->
+                      input.copyTo(output, DEFAULT_BUFFER_SIZE)
+                    }
+              }
+              HeapAnalyzerService.runAnalysis(this, target)
+            }
+      }
+    } catch (e: IOException) {
+      CanaryLog.d(e, "Could not imported Hprof file")
+    }
+  }
+
+  override fun onDestroy() {
+    super.onDestroy()
+    if (!isChangingConfigurations) {
+      Db.closeDatabase()
+    }
+  }
+
+  override fun setTheme(resid: Int) {
+    // We don't want this to be called with an incompatible theme.
+    // This could happen if you implement runtime switching of themes
+    // using ActivityLifecycleCallbacks.
+    if (resid != R.style.leak_canary_LeakCanary_Base) {
+      return
+    }
+    super.setTheme(resid)
+  }
+
+  companion object {
+    private const val FILE_REQUEST_CODE = 0
+
+    fun createPendingIntent(
+      context: Context,
+      screens: ArrayList<Screen>
+    ): PendingIntent {
+      val intent = Intent(context, LeakActivity::class.java)
+      intent.putExtra("screens", screens)
+      intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
+      return PendingIntent.getActivity(context, 1, intent, PendingIntent.FLAG_UPDATE_CURRENT)
+    }
+
+    fun createIntent(context: Context): Intent {
+      val intent = Intent(context, LeakActivity::class.java)
+      intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
+      return intent
+    }
+  }
+
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
new file mode 100644
index 00000000..d6e750d7
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
@@ -0,0 +1,65 @@
+package leakcanary.internal.activity
+
+import android.annotation.SuppressLint
+import android.content.ClipData
+import android.content.ClipboardManager
+import android.content.Context
+import android.content.Intent
+import android.net.Uri
+import android.os.AsyncTask
+import android.view.View
+import android.widget.Toast
+import androidx.core.content.FileProvider
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.navigation.activity
+import java.io.File
+
+internal fun View.share(content: String) {
+  val intent = Intent(Intent.ACTION_SEND)
+  intent.type = "text/plain"
+  intent.putExtra(Intent.EXTRA_TEXT, content)
+  activity.startActivity(
+      Intent.createChooser(intent, resources.getString(R.string.leak_canary_share_with))
+  )
+}
+
+@SuppressLint("SetWorldReadable")
+internal fun View.shareHeapDump(heapDumpFile: File) {
+  AsyncTask.SERIAL_EXECUTOR.execute {
+    heapDumpFile.setReadable(true, false)
+    val heapDumpUri = FileProvider.getUriForFile(
+        activity,
+        "com.squareup.leakcanary.fileprovider." + activity.packageName,
+        heapDumpFile
+    )
+    activity.runOnUiThread { startShareIntentChooser(heapDumpUri) }
+  }
+}
+
+private fun View.startShareIntentChooser(uri: Uri) {
+  val intent = Intent(Intent.ACTION_SEND)
+  intent.type = "application/octet-stream"
+  intent.putExtra(Intent.EXTRA_STREAM, uri)
+  activity.startActivity(
+      Intent.createChooser(intent, resources.getString(R.string.leak_canary_share_with))
+  )
+}
+
+internal fun View.shareToStackOverflow(content: String) {
+  val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
+  // AsyncTask was needed here due to setPrimaryClip making a disk write which
+  // violated StrictMode if on the main thread
+  AsyncTask.execute {
+    clipboard.primaryClip = ClipData.newPlainText(
+        context.getString(R.string.leak_canary_leak_clipdata_label),
+        "```\n$content```"
+    )
+  }
+  Toast.makeText(context, R.string.leak_canary_leak_copied, Toast.LENGTH_LONG)
+      .show()
+  val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(STACKOVERFLOW_QUESTION_URL))
+  activity.startActivity(browserIntent)
+}
+
+private const val STACKOVERFLOW_QUESTION_URL =
+  "http://stackoverflow.com/questions/ask?guided=false&tags=leakcanary"
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Cursors.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Cursors.kt
new file mode 100644
index 00000000..534bbf02
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Cursors.kt
@@ -0,0 +1,37 @@
+package leakcanary.internal.activity.db
+
+import android.database.Cursor
+import android.database.sqlite.SQLiteDatabase
+
+/**
+ * Similar to the more generic use() for Closable.
+ * Cursor started implementing Closable in API 16.
+ */
+internal inline fun <R> Cursor.use(block: (Cursor) -> R): R {
+  var exception: Throwable? = null
+  try {
+    return block(this)
+  } catch (e: Throwable) {
+    exception = e
+    throw e
+  } finally {
+    when (exception) {
+      null -> close()
+      else -> try {
+        close()
+      } catch (ignoredCloseException: Throwable) {
+      }
+    }
+  }
+}
+
+internal inline fun <T> SQLiteDatabase.inTransaction(block: SQLiteDatabase.() -> T): T {
+  try {
+    beginTransaction()
+    val result = block()
+    setTransactionSuccessful()
+    return result
+  } finally {
+    endTransaction()
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Db.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Db.kt
new file mode 100644
index 00000000..f314cba8
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Db.kt
@@ -0,0 +1,53 @@
+package leakcanary.internal.activity.db
+
+import android.database.sqlite.SQLiteDatabase
+import android.view.View
+import leakcanary.internal.InternalLeakCanary
+import leakcanary.internal.activity.db.Db.OnDb
+import leakcanary.internal.activity.db.Io.OnIo
+
+internal object Db {
+
+  private val dbHelper = LeaksDbHelper(InternalLeakCanary.application)
+
+  interface OnDb : OnIo {
+    val db: SQLiteDatabase
+  }
+
+  private class DbContext(override val db: SQLiteDatabase) : OnDb {
+    var updateUi: (View.() -> Unit)? = null
+
+    override fun updateUi(updateUi: View.() -> Unit) {
+      this.updateUi = updateUi
+    }
+  }
+
+  fun execute(
+    view: View,
+    block: OnDb.() -> Unit
+  ) {
+
+    Io.execute(view) {
+      val dbBlock = DbContext(dbHelper.writableDatabase)
+      block(dbBlock)
+      val updateUi = dbBlock.updateUi
+      if (updateUi != null) {
+        updateUi {
+          updateUi()
+        }
+      }
+    }
+  }
+
+  fun closeDatabase() {
+    // Closing on the serial IO thread to ensure we don't close while using the db.
+    Io.execute {
+      dbHelper.close()
+    }
+  }
+
+}
+
+internal fun View.executeOnDb(block: OnDb.() -> Unit) {
+  Db.execute(this, block)
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
new file mode 100644
index 00000000..69b48390
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
@@ -0,0 +1,159 @@
+package leakcanary.internal.activity.db
+
+import android.content.ContentValues
+import android.content.Context
+import android.database.sqlite.SQLiteDatabase
+import android.os.AsyncTask
+import leakcanary.CanaryLog
+import leakcanary.HeapAnalysis
+import leakcanary.HeapAnalysisFailure
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.Serializables
+import leakcanary.internal.InternalLeakCanary
+import leakcanary.internal.LeakDirectoryProvider
+import leakcanary.leakingInstances
+import leakcanary.toByteArray
+import org.intellij.lang.annotations.Language
+import java.io.File
+
+internal object HeapAnalysisTable {
+
+  @Language("RoomSql")
+  const val create = """CREATE TABLE heap_analysis
+        (
+        id INTEGER PRIMARY KEY AUTOINCREMENT,
+        created_at_time_millis INTEGER,
+        retained_instance_count INTEGER DEFAULT 0,
+        exception_summary TEXT DEFAULT NULL,
+        object BLOB
+        )"""
+
+  @Language("RoomSql")
+  const val drop = "DROP TABLE IF EXISTS heap_analysis"
+
+  fun insert(
+    db: SQLiteDatabase,
+    heapAnalysis: HeapAnalysis
+  ): Long {
+    val values = ContentValues()
+    values.put("created_at_time_millis", heapAnalysis.createdAtTimeMillis)
+    values.put("object", heapAnalysis.toByteArray())
+    when (heapAnalysis) {
+      is HeapAnalysisSuccess -> {
+        values.put("retained_instance_count", heapAnalysis.retainedInstances.size)
+      }
+      is HeapAnalysisFailure -> {
+        val cause = heapAnalysis.exception.cause!!
+        val exceptionSummary = "${cause.javaClass.simpleName} ${cause.message}"
+        values.put("exception_summary", exceptionSummary)
+      }
+    }
+
+    return db.inTransaction {
+      val heapAnalysisId = db.insertOrThrow("heap_analysis", null, values)
+      heapAnalysis.leakingInstances()
+          .forEach { leakingInstance ->
+            LeakingInstanceTable.insert(
+                db, heapAnalysisId, leakingInstance
+            )
+          }
+      heapAnalysisId
+    }
+  }
+
+  inline fun <reified T : HeapAnalysis> retrieve(
+    db: SQLiteDatabase,
+    id: Long
+  ): T? {
+    db.inTransaction {
+      return db.rawQuery(
+          """
+              SELECT
+              object
+              FROM heap_analysis
+              WHERE id=$id
+              """, null
+      )
+          .use { cursor ->
+            if (cursor.moveToNext()) {
+              val analysis = Serializables.fromByteArray<T>(cursor.getBlob(0))
+              if (analysis == null) {
+                delete(db, id, null)
+              }
+              analysis
+            } else
+              null
+          } ?: return null
+    }
+  }
+
+  fun retrieveAll(db: SQLiteDatabase): List<Projection> {
+    return db.rawQuery(
+        """
+          SELECT
+          id
+          , created_at_time_millis
+          , retained_instance_count
+          , exception_summary
+          FROM heap_analysis
+          ORDER BY created_at_time_millis DESC
+          """, null
+    )
+        .use { cursor ->
+          val all = mutableListOf<Projection>()
+          while (cursor.moveToNext()) {
+            val summary = Projection(
+                id = cursor.getLong(0),
+                createdAtTimeMillis = cursor.getLong(1),
+                retainedInstanceCount = cursor.getInt(2),
+                exceptionSummary = cursor.getString(3)
+            )
+            all.add(summary)
+          }
+          all
+        }
+  }
+
+  fun delete(
+    db: SQLiteDatabase,
+    id: Long,
+    heapDumpFile: File?
+  ) {
+    if (heapDumpFile != null) {
+      AsyncTask.SERIAL_EXECUTOR.execute {
+        val path = heapDumpFile.absolutePath
+        val heapDumpDeleted = heapDumpFile.delete()
+        if (heapDumpDeleted) {
+          LeakDirectoryProvider.filesDeletedRemoveLeak += path
+        } else {
+          CanaryLog.d("Could not delete heap dump file %s", heapDumpFile.path)
+        }
+      }
+    }
+
+    db.inTransaction {
+      db.delete("heap_analysis", "id=$id", null)
+      LeakingInstanceTable.deleteByHeapAnalysisId(db, id)
+    }
+  }
+
+  fun deleteAll(
+    db: SQLiteDatabase,
+    context: Context
+  ) {
+    val leakDirectoryProvider = InternalLeakCanary.leakDirectoryProvider
+    AsyncTask.SERIAL_EXECUTOR.execute { leakDirectoryProvider.clearLeakDirectory() }
+    db.inTransaction {
+      db.delete("heap_analysis", null, null)
+      LeakingInstanceTable.deleteAll(db)
+    }
+  }
+
+  class Projection(
+    val id: Long,
+    val createdAtTimeMillis: Long,
+    val retainedInstanceCount: Int,
+    val exceptionSummary: String?
+  )
+
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Io.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Io.kt
new file mode 100644
index 00000000..71229908
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Io.kt
@@ -0,0 +1,80 @@
+package leakcanary.internal.activity.db
+
+import android.os.Handler
+import android.os.Looper
+import android.view.View
+import android.view.View.OnAttachStateChangeListener
+import leakcanary.internal.activity.db.Io.OnIo
+import java.util.concurrent.Executors
+
+internal object Io {
+
+  private val serialExecutor = Executors.newSingleThreadExecutor()
+  private val mainHandler = Handler(Looper.getMainLooper())
+
+  interface OnIo {
+    fun updateUi(updateUi: View.() -> Unit)
+  }
+
+  private class IoContext : OnIo {
+    var updateUi: (View.() -> Unit)? = null
+
+    override fun updateUi(updateUi: View.() -> Unit) {
+      this.updateUi = updateUi
+    }
+  }
+
+  fun execute(block: () -> Unit) {
+    serialExecutor.execute(block)
+  }
+
+  fun execute(
+    view: View,
+    block: OnIo.() -> Unit
+  ) {
+    checkMainThread()
+    val viewWrapper: VolatileObjectRef<View> = VolatileObjectRef(view)
+    view.addOnAttachStateChangeListener(object : OnAttachStateChangeListener {
+      override fun onViewAttachedToWindow(v: View?) {
+      }
+
+      override fun onViewDetachedFromWindow(v: View?) {
+        viewWrapper.element = null
+      }
+    })
+    serialExecutor.execute backgroundExecute@{
+      if (viewWrapper.element == null) {
+        return@backgroundExecute
+      }
+      val context = IoContext()
+      block(context)
+      val updateUi = context.updateUi
+      if (viewWrapper.element != null && updateUi != null) {
+        mainHandler.post mainThreadPost@{
+          val attachedView = viewWrapper.element ?: return@mainThreadPost
+          updateUi(attachedView)
+        }
+      }
+    }
+  }
+
+  private fun checkMainThread() {
+    if (Looper.getMainLooper().thread !== Thread.currentThread()) {
+      throw UnsupportedOperationException(
+          "Should be called from the main thread, not ${Thread.currentThread()}"
+      )
+    }
+  }
+
+  /**
+   * Similar to kotlin.jvm.internal.Ref.ObjectRef but volatile
+   */
+  private class VolatileObjectRef<T>(
+    @Volatile
+    var element: T? = null
+  )
+}
+
+internal fun View.executeOnIo(block: OnIo.() -> Unit) {
+  Io.execute(this, block)
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
new file mode 100644
index 00000000..0803bb72
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
@@ -0,0 +1,291 @@
+package leakcanary.internal.activity.db
+
+import android.content.ContentValues
+import android.database.sqlite.SQLiteDatabase
+import leakcanary.Exclusion
+import leakcanary.Exclusion.Status.WONT_FIX_LEAK
+import leakcanary.LeakTrace
+import leakcanary.LeakTraceElement
+import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
+import leakcanary.LeakingInstance
+import leakcanary.Serializables
+import leakcanary.internal.utils.to
+import leakcanary.toByteArray
+import org.intellij.lang.annotations.Language
+
+internal object LeakingInstanceTable {
+
+  @Language("RoomSql")
+  const val create = """
+        CREATE TABLE leaking_instance
+        (
+        id INTEGER PRIMARY KEY,
+        heap_analysis_id REFERENCES heap_analysis(id),
+        group_hash TEXT,
+        group_description TEXT,
+        class_simple_name TEXT,
+        exclusion_status INTEGER,
+        object BLOB
+        )"""
+
+  @Language("RoomSql")
+  const val createGroupHashIndex = """
+        CREATE INDEX leaking_instance_group_hash
+        on leaking_instance (group_hash)
+    """
+
+  @Language("RoomSql")
+  const val drop = "DROP TABLE IF EXISTS leaking_instance"
+
+  fun insert(
+    db: SQLiteDatabase,
+    heapAnalysisId: Long,
+    leakingInstance: LeakingInstance
+  ): Long {
+    val values = ContentValues()
+    values.put("heap_analysis_id", heapAnalysisId)
+    values.put("group_hash", leakingInstance.groupHash)
+    values.put("group_description", leakingInstance.createGroupDescription())
+    values.put("class_simple_name", leakingInstance.instanceClassSimpleName)
+    values.put("object", leakingInstance.toByteArray())
+    values.put("exclusion_status", leakingInstance.exclusionStatus?.ordinal ?: -1)
+    return db.insertOrThrow("leaking_instance", null, values)
+  }
+
+  fun retrieve(
+    db: SQLiteDatabase,
+    id: Long
+  ): Pair<Long, LeakingInstance>? {
+    return db.rawQuery(
+        """
+          SELECT
+          heap_analysis_id,
+          object
+          FROM leaking_instance
+          WHERE id=$id
+          """, null
+    )
+        .use { cursor ->
+          if (cursor.moveToNext()) {
+            val heapAnalysisId = cursor.getLong(0)
+            val leakingInstance = Serializables.fromByteArray<LeakingInstance>(cursor.getBlob(1))
+            if (leakingInstance == null) {
+              null
+            } else {
+              heapAnalysisId to leakingInstance
+            }
+          } else
+            null
+        }
+  }
+
+  class HeapAnalysisGroupProjection(
+    val hash: String,
+    val description: String,
+    val createdAtTimeMillis: Long,
+    val leakCount: Int,
+    val totalLeakCount: Int,
+    val isNew: Boolean,
+    val exclusionStatus: Exclusion.Status?
+  )
+
+  fun retrieveAllByHeapAnalysisId(
+    db: SQLiteDatabase,
+    heapAnalysisId: Long
+  ): Map<String, HeapAnalysisGroupProjection> {
+
+    val isLatestHeapAnalysis = db.rawQuery("SELECT MAX(id) FROM heap_analysis", null)
+        .use { cursor ->
+          cursor.moveToNext()
+          cursor.getLong(0) == heapAnalysisId
+        }
+
+    return db.rawQuery(
+        """
+          SELECT
+          group_hash
+          , group_description
+          , MAX(created_at_time_millis) as created_at_time_millis
+          , SUM(CASE WHEN heap_analysis_id=$heapAnalysisId THEN 1 ELSE 0 END) as leak_count
+          , COUNT(*) as total_leak_count
+          , MIN(exclusion_status) as exclusion_status
+          FROM leaking_instance l
+          LEFT JOIN heap_analysis h ON l.heap_analysis_id = h.id
+          GROUP BY 1, 2
+          HAVING leak_count > 0
+          ORDER BY leak_count, created_at_time_millis DESC
+          """, null
+    )
+        .use { cursor ->
+          val projectionsByHash = linkedMapOf<String, HeapAnalysisGroupProjection>()
+          while (cursor.moveToNext()) {
+            val hash = cursor.getString(0)
+            val description = cursor.getString(1)
+            val createdAtTimeMillis = cursor.getLong(2)
+            val leakCount = cursor.getInt(3)
+            val totalLeakCount = cursor.getInt(4)
+            val isNew = isLatestHeapAnalysis && leakCount == totalLeakCount
+            val exclusionStatusOrdinal = cursor.getInt(5)
+            val exclusionStatus =
+              if (exclusionStatusOrdinal == -1) null else Exclusion.Status.values()[exclusionStatusOrdinal]
+            val group = HeapAnalysisGroupProjection(
+                hash, description, createdAtTimeMillis, leakCount, totalLeakCount, isNew,
+                exclusionStatus
+            )
+            projectionsByHash[hash] = group
+          }
+          projectionsByHash
+        }
+  }
+
+  class GroupProjection(
+    val hash: String,
+    val description: String,
+    val createdAtTimeMillis: Long,
+    val leakCount: Int
+  )
+
+  fun retrieveAllGroups(
+    db: SQLiteDatabase
+  ): List<GroupProjection> {
+    return db.rawQuery(
+        """
+          SELECT
+          group_hash
+          , group_description
+          , MAX(created_at_time_millis) as created_at_time_millis
+          , COUNT(*) as leak_count
+          FROM leaking_instance l
+          LEFT JOIN heap_analysis h ON l.heap_analysis_id = h.id
+          GROUP BY 1, 2
+          ORDER BY leak_count, created_at_time_millis DESC
+          """, null
+    )
+        .use { cursor ->
+          val all = mutableListOf<GroupProjection>()
+          while (cursor.moveToNext()) {
+            val group = GroupProjection(
+                hash = cursor.getString(0),
+                description = cursor.getString(1),
+                createdAtTimeMillis = cursor.getLong(2),
+                leakCount = cursor.getInt(3)
+            )
+            all.add(group)
+          }
+          all
+        }
+  }
+
+  class InstanceProjection(
+    val id: Long,
+    val classSimpleName: String,
+    val createdAtTimeMillis: Long
+  )
+
+  fun retrieveGroup(
+    db: SQLiteDatabase,
+    groupHash: String
+  ): Triple<LeakTrace, String, List<InstanceProjection>>? {
+    val pair = db.rawQuery(
+        """
+           SELECT
+            object
+            , group_description
+            FROM leaking_instance
+            WHERE group_hash = ?
+            LIMIT 1
+            """, arrayOf(groupHash)
+    )
+        .use { cursor ->
+          if (cursor.moveToNext()) {
+            val leakingInstance = Serializables.fromByteArray<LeakingInstance>(cursor.getBlob(0))!!
+            val leakTrace = leakingInstance.leakTrace
+
+            val groupLeakTrace = if (leakingInstance.exclusionStatus == WONT_FIX_LEAK) {
+              val index = leakTrace.elements.indexOfFirst { element -> element.exclusion != null }
+              LeakTrace(
+                  elements = listOf(leakTrace.elements[index].copy(labels = emptyList()))
+              )
+            } else {
+              val elements = mutableListOf<LeakTraceElement>()
+              for (index in 0 until leakTrace.elements.size) {
+                if (leakTrace.elementMayBeLeakCause(index)) {
+                  var element = leakTrace.elements[index]
+
+                  val reference = element.reference!!
+                  if (reference.type == ARRAY_ENTRY) {
+                    // No array index in groups
+                    element = element.copy(reference = reference.copy(name = "x"), labels = emptyList())
+                  } else {
+                    element = element.copy(labels = emptyList())
+                  }
+
+                  elements.add(element)
+                }
+              }
+              LeakTrace(elements)
+            }
+            val groupDescription = cursor.getString(1)!!
+            groupLeakTrace to groupDescription
+          } else
+            null
+        } ?: return null
+
+    val projections = db.rawQuery(
+        """
+         SELECT
+          l.id
+          , class_simple_name
+          , h.created_at_time_millis
+          FROM leaking_instance l
+          LEFT JOIN heap_analysis h ON l.heap_analysis_id = h.id
+          WHERE l.group_hash = ?
+          ORDER BY h.created_at_time_millis DESC
+          """, arrayOf(groupHash)
+    )
+        .use { cursor ->
+          val projections = mutableListOf<InstanceProjection>()
+          while (cursor.moveToNext()) {
+            projections.add(
+                InstanceProjection(
+                    id = cursor.getLong(0),
+                    classSimpleName = cursor.getString(1),
+                    createdAtTimeMillis = cursor.getLong(2)
+                )
+            )
+          }
+          projections
+        }
+
+    return pair to projections
+  }
+
+  fun deleteByHeapAnalysisId(
+    db: SQLiteDatabase,
+    heapAnalysisId: Long
+  ) {
+    db.delete("leaking_instance", "heap_analysis_id=$heapAnalysisId", null)
+  }
+
+  fun deleteAll(db: SQLiteDatabase) {
+    db.delete("leaking_instance", null, null)
+  }
+
+  private fun LeakingInstance.createGroupDescription(): String {
+    return if (exclusionStatus == WONT_FIX_LEAK) {
+      leakTrace.firstElementExclusion.matching
+    } else {
+      val leakCauses = leakTrace.leakCauses
+      if (leakCauses.isEmpty()) {
+        // Should rarely happen, don't expect to see 0 unknown and 100% leaking or 100% not leaking
+        instanceClassName
+      } else {
+        val element = leakCauses.first()
+        val referenceName = element.reference!!.groupingName
+        val refDescription = element.classSimpleName + "." + referenceName
+        refDescription
+      }
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
new file mode 100644
index 00000000..2a010a8e
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
@@ -0,0 +1,31 @@
+package leakcanary.internal.activity.db
+
+import android.content.Context
+import android.database.sqlite.SQLiteDatabase
+import android.database.sqlite.SQLiteOpenHelper
+
+internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
+    context, "leaks.db", null, VERSION
+) {
+
+  override fun onCreate(db: SQLiteDatabase) {
+    db.execSQL(HeapAnalysisTable.create)
+    db.execSQL(LeakingInstanceTable.create)
+    db.execSQL(LeakingInstanceTable.createGroupHashIndex)
+  }
+
+  override fun onUpgrade(
+    db: SQLiteDatabase,
+    oldVersion: Int,
+    newVersion: Int
+  ) {
+    db.execSQL(HeapAnalysisTable.drop)
+    db.execSQL(LeakingInstanceTable.drop)
+    onCreate(db)
+  }
+
+  companion object {
+    // Last updated for next after 2.0-alpha-3
+    private const val VERSION = 11
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt
new file mode 100644
index 00000000..005e697d
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt
@@ -0,0 +1,94 @@
+package leakcanary.internal.activity.screen
+
+import android.app.AlertDialog
+import android.text.format.DateUtils
+import android.text.method.LinkMovementMethod
+import android.view.View
+import android.view.ViewGroup
+import android.widget.ListView
+import android.widget.TextView
+import androidx.core.content.ContextCompat
+import androidx.core.text.HtmlCompat
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.activity.LeakActivity
+import leakcanary.internal.activity.db.LeakingInstanceTable
+import leakcanary.internal.activity.db.LeakingInstanceTable.GroupProjection
+import leakcanary.internal.activity.db.executeOnDb
+import leakcanary.internal.activity.ui.SimpleListAdapter
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.goTo
+import leakcanary.internal.navigation.inflate
+import leakcanary.internal.navigation.onCreateOptionsMenu
+
+internal class GroupListScreen : Screen() {
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_list).apply {
+      activity.title = resources.getString(R.string.leak_canary_loading_title)
+      executeOnDb {
+        val projections = LeakingInstanceTable.retrieveAllGroups(db)
+        updateUi { onGroupsRetrieved(projections) }
+      }
+
+      onCreateOptionsMenu { menu ->
+        menu.add(R.string.leak_canary_options_menu_see_analysis_list)
+            .setOnMenuItemClickListener {
+              goTo(HeapAnalysisListScreen())
+              true
+            }
+
+        menu.add(R.string.leak_canary_about_title)
+            .setOnMenuItemClickListener {
+              val dialog = AlertDialog.Builder(context)
+                  .setIcon(ContextCompat.getDrawable(context, R.drawable.leak_canary_icon))
+                  .setTitle(R.string.leak_canary_about_title)
+                  .setMessage(
+                      HtmlCompat.fromHtml(
+                          resources.getString(R.string.leak_canary_about_message),
+                          HtmlCompat.FROM_HTML_MODE_LEGACY
+                      )
+                  )
+                  .setPositiveButton(android.R.string.ok, null)
+                  .show()
+              val messageView = dialog.findViewById<TextView>(android.R.id.message)
+              messageView.movementMethod = LinkMovementMethod.getInstance()
+              true
+            }
+
+        menu.add(R.string.leak_canary_options_menu_import_hprof_file)
+            .setOnMenuItemClickListener {
+              activity<LeakActivity>().requestImportHprof()
+              true
+            }
+      }
+
+    }
+
+  private fun View.onGroupsRetrieved(projections: List<GroupProjection>) {
+    activity.title =
+      resources.getString(R.string.leak_canary_group_list_screen_title, projections.size)
+
+    val listView = findViewById<ListView>(R.id.leak_canary_list)
+
+    listView.adapter =
+      SimpleListAdapter(R.layout.leak_canary_leak_row, projections) { view, position ->
+        val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
+        val timeView = view.findViewById<TextView>(R.id.leak_canary_row_time)
+
+        val projection = projections[position]
+
+        titleView.text = "(${projection.leakCount}) ${projection.description}"
+
+        val formattedDate = DateUtils.formatDateTime(
+            view.context, projection.createdAtTimeMillis,
+            DateUtils.FORMAT_SHOW_TIME or DateUtils.FORMAT_SHOW_DATE
+        )
+        timeView.text =
+          resources.getString(R.string.leak_canary_group_list_time_label, formattedDate)
+      }
+
+    listView.setOnItemClickListener { _, _, position, _ ->
+      goTo(GroupScreen(projections[position].hash))
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt
new file mode 100644
index 00000000..7c2d567a
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt
@@ -0,0 +1,59 @@
+package leakcanary.internal.activity.screen
+
+import android.view.View
+import android.view.ViewGroup
+import android.widget.ListView
+import com.squareup.leakcanary.core.R
+import com.squareup.leakcanary.core.R.plurals
+import leakcanary.LeakTrace
+import leakcanary.internal.DisplayLeakAdapter
+import leakcanary.internal.activity.db.LeakingInstanceTable
+import leakcanary.internal.activity.db.LeakingInstanceTable.InstanceProjection
+import leakcanary.internal.activity.db.executeOnDb
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.goTo
+import leakcanary.internal.navigation.inflate
+
+internal class GroupScreen(private val groupHash: String) : Screen() {
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_list).apply {
+      activity.title = resources.getString(R.string.leak_canary_loading_title)
+      executeOnDb {
+        val triple = LeakingInstanceTable.retrieveGroup(db, groupHash)
+        updateUi {
+          if (triple == null) {
+            activity.title = resources.getString(R.string.leak_canary_analysis_deleted_title)
+          } else {
+            // TODO add projects to list.
+            val (leakTrace, groupDescription, projections) = triple
+            onGroupRetrieved(projections, groupDescription, leakTrace)
+          }
+        }
+      }
+    }
+
+  private fun View.onGroupRetrieved(
+    projections: List<InstanceProjection>,
+    groupDescription: String,
+    leakTrace: LeakTrace
+  ) {
+    activity.title = String.format(
+        resources.getQuantityText(
+            plurals.leak_canary_group_screen_title, projections.size
+        ).toString(), projections.size, groupDescription
+    )
+
+    val listView = findViewById<ListView>(R.id.leak_canary_list)
+
+    val adapter = DisplayLeakAdapter(context, leakTrace, projections)
+    listView.adapter = adapter
+
+    listView.setOnItemClickListener { _, _, position, _ ->
+      val index = position - (adapter.count - projections.size)
+      if (index >= 0) {
+        goTo(LeakingInstanceScreen(projections[index].id))
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt
new file mode 100644
index 00000000..e058a835
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt
@@ -0,0 +1,82 @@
+package leakcanary.internal.activity.screen
+
+import android.view.View
+import android.view.ViewGroup
+import android.widget.TextView
+import com.squareup.leakcanary.core.BuildConfig
+import com.squareup.leakcanary.core.R
+import leakcanary.HeapAnalysisFailure
+import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.db.executeOnDb
+import leakcanary.internal.activity.share
+import leakcanary.internal.activity.shareHeapDump
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.goBack
+import leakcanary.internal.navigation.inflate
+import leakcanary.internal.navigation.onCreateOptionsMenu
+
+internal class HeapAnalysisFailureScreen(
+  private val analysisId: Long
+) : Screen() {
+
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_heap_analysis_failure_screen).apply {
+      activity.title = resources.getString(R.string.leak_canary_loading_title)
+      executeOnDb {
+        val heapAnalysis = HeapAnalysisTable.retrieve<HeapAnalysisFailure>(db, analysisId)
+        if (heapAnalysis == null) {
+          updateUi {
+            activity.title = resources.getString(R.string.leak_canary_analysis_deleted_title)
+          }
+        } else {
+          val heapDumpFileExist = heapAnalysis.heapDumpFile.exists()
+          updateUi { onFailureRetrieved(heapAnalysis, heapDumpFileExist) }
+        }
+      }
+    }
+
+  private fun View.onFailureRetrieved(
+    heapAnalysis: HeapAnalysisFailure,
+    heapDumpFileExist: Boolean
+  ) {
+    activity.title = resources.getString(R.string.leak_canary_analysis_failed)
+
+    val failureTextView = findViewById<TextView>(R.id.leak_canary_failure)
+    val path = heapAnalysis.heapDumpFile.absolutePath
+
+    val failureText = """
+          |${resources.getString(R.string.leak_canary_failure_report)}
+          |LeakCanary ${BuildConfig.LIBRARY_VERSION} ${BuildConfig.GIT_SHA}
+          |${heapAnalysis.exception}
+          |${resources.getString(R.string.leak_canary_download_dump, path)}
+          """.trimMargin()
+    failureTextView.text = failureText
+
+    onCreateOptionsMenu { menu ->
+      menu.add(R.string.leak_canary_share_leak)
+          .setOnMenuItemClickListener {
+            // TODO Add version information
+            share(heapAnalysis.exception.toString())
+            true
+          }
+      menu.add(R.string.leak_canary_delete)
+          .setOnMenuItemClickListener {
+            executeOnDb {
+              HeapAnalysisTable.delete(db, analysisId, heapAnalysis.heapDumpFile)
+              updateUi {
+                goBack()
+              }
+            }
+            true
+          }
+      if (heapDumpFileExist) {
+        menu.add(R.string.leak_canary_share_heap_dump)
+            .setOnMenuItemClickListener {
+              shareHeapDump(heapAnalysis.heapDumpFile)
+              true
+            }
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt
new file mode 100644
index 00000000..6eb7ab03
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt
@@ -0,0 +1,94 @@
+package leakcanary.internal.activity.screen
+
+import android.app.AlertDialog
+import android.text.format.DateUtils
+import android.view.View
+import android.view.ViewGroup
+import android.widget.ListView
+import android.widget.TextView
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.db.HeapAnalysisTable.Projection
+import leakcanary.internal.activity.db.executeOnDb
+import leakcanary.internal.activity.ui.SimpleListAdapter
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.goTo
+import leakcanary.internal.navigation.inflate
+import leakcanary.internal.navigation.onCreateOptionsMenu
+
+internal class HeapAnalysisListScreen : Screen() {
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_list).apply {
+      activity.title = resources.getString(
+          R.string.leak_canary_heap_analysis_list_screen_title
+      )
+
+      onCreateOptionsMenu { menu ->
+        menu.add(R.string.leak_canary_delete_all)
+            .setOnMenuItemClickListener {
+              AlertDialog.Builder(context)
+                  .setIcon(android.R.drawable.ic_dialog_alert)
+                  .setTitle(R.string.leak_canary_delete_all)
+                  .setMessage(R.string.leak_canary_delete_all_leaks_title)
+                  .setPositiveButton(android.R.string.ok) { _, _ ->
+                    executeOnDb {
+                      HeapAnalysisTable.deleteAll(db, context)
+                      updateUi {
+                        val listView = findViewById<ListView>(R.id.leak_canary_list)
+                        listView.adapter =
+                          SimpleListAdapter(
+                              R.layout.leak_canary_leak_row, emptyList<Any>()
+                          ) { _, _ -> }
+                      }
+                    }
+                  }
+                  .setNegativeButton(android.R.string.cancel, null)
+                  .show()
+              true
+            }
+      }
+
+      executeOnDb {
+        val projections = HeapAnalysisTable.retrieveAll(db)
+        updateUi { onAnalysesRetrieved(projections) }
+      }
+
+    }
+
+  private fun View.onAnalysesRetrieved(projections: List<Projection>) {
+    val listView = findViewById<ListView>(R.id.leak_canary_list)
+
+    listView.setOnItemClickListener { _, _, position, _ ->
+      val projection = projections[position]
+      val analysisScreen = if (projection.exceptionSummary != null)
+        HeapAnalysisFailureScreen(projection.id)
+      else
+        HeapAnalysisSuccessScreen(projection.id)
+      goTo(analysisScreen)
+    }
+
+    listView.adapter =
+      SimpleListAdapter(R.layout.leak_canary_leak_row, projections) { view, position ->
+        val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
+        val timeView = view.findViewById<TextView>(R.id.leak_canary_row_time)
+        // Results are sorted by timestamp DESC so the top item of the list is the last
+        // occurrence, hence the reversed index.
+        val index = count - position
+
+        val projection = getItem(position)
+
+        timeView.text = DateUtils.formatDateTime(
+            view.context, projection.createdAtTimeMillis,
+            DateUtils.FORMAT_SHOW_TIME or DateUtils.FORMAT_SHOW_DATE
+        )
+
+        val title = projection.exceptionSummary ?: resources.getQuantityString(
+            R.plurals.leak_canary_heap_analysis_list_retained_instances,
+            projection.retainedInstanceCount, projection.retainedInstanceCount
+        )
+        titleView.text = "$index. $title"
+      }
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
new file mode 100644
index 00000000..b1aa79a0
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
@@ -0,0 +1,169 @@
+package leakcanary.internal.activity.screen
+
+import android.text.format.DateUtils
+import android.view.View
+import android.view.ViewGroup
+import android.widget.ListView
+import android.widget.TextView
+import com.squareup.leakcanary.core.R
+import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
+import leakcanary.Exclusion.Status.WONT_FIX_LEAK
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.LeakingInstance
+import leakcanary.NoPathToInstance
+import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.db.LeakingInstanceTable
+import leakcanary.internal.activity.db.LeakingInstanceTable.HeapAnalysisGroupProjection
+import leakcanary.internal.activity.db.executeOnDb
+import leakcanary.internal.activity.shareHeapDump
+import leakcanary.internal.activity.ui.SimpleListAdapter
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.goBack
+import leakcanary.internal.navigation.goTo
+import leakcanary.internal.navigation.inflate
+import leakcanary.internal.navigation.onCreateOptionsMenu
+
+internal class HeapAnalysisSuccessScreen(
+  private val analysisId: Long
+) : Screen() {
+
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_list).apply {
+      activity.title = resources.getString(R.string.leak_canary_loading_title)
+
+      executeOnDb {
+        val heapAnalysis = HeapAnalysisTable.retrieve<HeapAnalysisSuccess>(db, analysisId)
+        if (heapAnalysis == null) {
+          updateUi {
+            activity.title = resources.getString(R.string.leak_canary_analysis_deleted_title)
+          }
+        } else {
+          val leakGroupByHash =
+            LeakingInstanceTable.retrieveAllByHeapAnalysisId(db, analysisId)
+          val heapDumpFileExist = heapAnalysis.heapDumpFile.exists()
+          updateUi { onSuccessRetrieved(heapAnalysis, leakGroupByHash, heapDumpFileExist) }
+        }
+      }
+    }
+
+  private fun View.onSuccessRetrieved(
+    heapAnalysis: HeapAnalysisSuccess,
+    leakGroupByHash: Map<String, HeapAnalysisGroupProjection>,
+    heapDumpFileExist: Boolean
+  ) {
+    activity.title = resources.getString(
+        R.string.leak_canary_heap_analysis_success_screen_title,
+        heapAnalysis.retainedInstances.size
+    )
+
+    onCreateOptionsMenu { menu ->
+      menu.add(R.string.leak_canary_delete)
+          .setOnMenuItemClickListener {
+            executeOnDb {
+              HeapAnalysisTable.delete(db, analysisId, heapAnalysis.heapDumpFile)
+              updateUi {
+                goBack()
+              }
+            }
+            true
+          }
+      if (heapDumpFileExist) {
+        menu.add(R.string.leak_canary_share_heap_dump)
+            .setOnMenuItemClickListener {
+              shareHeapDump(heapAnalysis.heapDumpFile)
+              true
+            }
+        menu.add(R.string.leak_canary_options_menu_render_heap_dump)
+            .setOnMenuItemClickListener {
+              goTo(RenderHeapDumpScreen(heapAnalysis.heapDumpFile))
+              true
+            }
+      }
+    }
+
+    val listView = findViewById<ListView>(R.id.leak_canary_list)
+
+    val retainedInstances = heapAnalysis.retainedInstances
+
+    var noPathToInstanceCount = 0
+    retainedInstances.forEach { retainedInstance ->
+      when (retainedInstance) {
+        is LeakingInstance -> {
+          if (leakGroupByHash[retainedInstance.groupHash] == null) {
+            throw IllegalStateException(
+                "Removing groups is not supported, this should never happen."
+            )
+          }
+        }
+        is NoPathToInstance -> {
+          noPathToInstanceCount++
+        }
+      }
+    }
+
+    val rowList = mutableListOf<Pair<String, String>>()
+
+    val leakGroups = leakGroupByHash.values.toList()
+
+    rowList.addAll(leakGroups.map { projection ->
+      val description = when (projection.exclusionStatus) {
+        WONT_FIX_LEAK -> {
+          "[Won't Fix] ${projection.description}"
+        }
+        WEAKLY_REACHABLE -> {
+          "[Weakly Reachable] ${projection.description}"
+        }
+        else -> {
+          projection.description
+        }
+      }
+
+      val titleText = if (projection.isNew && projection.exclusionStatus == null) {
+        resources.getString(
+            R.string.leak_canary_heap_analysis_success_screen_row_title_new, projection.leakCount,
+            description
+        )
+      } else {
+        resources.getString(
+            R.string.leak_canary_heap_analysis_success_screen_row_title, projection.leakCount,
+            projection.totalLeakCount, description
+        )
+      }
+      val timeText = resources.getString(
+          R.string.leak_canary_heap_analysis_success_screen_row_time_format,
+          DateUtils.formatDateTime(
+              context, projection.createdAtTimeMillis,
+              DateUtils.FORMAT_SHOW_TIME or DateUtils.FORMAT_SHOW_DATE
+          )
+      )
+      titleText to timeText
+    })
+
+    if (noPathToInstanceCount > 0) {
+      rowList.add(
+          resources.getString(
+              R.string.leak_canary_heap_analysis_success_screen_no_path_to_instance_count,
+              noPathToInstanceCount
+          ) to ""
+      )
+    }
+
+    listView.adapter =
+      SimpleListAdapter(R.layout.leak_canary_leak_row, rowList) { view, position ->
+        val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
+        val timeView = view.findViewById<TextView>(R.id.leak_canary_row_time)
+
+        val (titleText, timeText) = getItem(position)
+
+        titleView.text = titleText
+        timeView.text = timeText
+      }
+
+    listView.setOnItemClickListener { _, _, position, _ ->
+      if (position < leakGroupByHash.size) {
+        goTo(GroupScreen(leakGroups[position].hash))
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
new file mode 100644
index 00000000..d310f95d
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
@@ -0,0 +1,287 @@
+package leakcanary.internal.activity.screen
+
+import android.content.Context
+import android.content.res.Resources
+import android.graphics.Bitmap
+import android.graphics.Bitmap.Config.ARGB_8888
+import android.graphics.Canvas
+import android.graphics.Color
+import android.graphics.Paint
+import android.graphics.Paint.Style.FILL
+import android.graphics.Paint.Style.STROKE
+import android.graphics.Rect
+import androidx.core.content.ContextCompat
+import com.squareup.leakcanary.core.R
+import leakcanary.HprofPushRecordsParser
+import leakcanary.HprofPushRecordsParser.OnRecordListener
+import leakcanary.Record
+import leakcanary.Record.HeapDumpEndRecord
+import leakcanary.Record.HeapDumpRecord.GcRootRecord
+import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import leakcanary.Record.LoadClassRecord
+import leakcanary.Record.StackTraceRecord
+import leakcanary.Record.StringRecord
+import java.io.File
+import kotlin.reflect.KClass
+
+object HeapDumpRenderer {
+
+  private class HasDensity(resources: Resources) {
+    val density = resources.displayMetrics.density
+
+    val Int.dp
+      get() = this * density
+
+    val Float.dp
+      get() = this * density
+  }
+
+  fun render(
+    context: Context,
+    heapDumpFile: File,
+    sourceWidth: Int,
+    sourceHeight: Int,
+    /**
+     * If [sourceBytesPerPixel] > 0 then [sourceHeight] will be ignored.
+     */
+    sourceBytesPerPixel: Int
+  ): Bitmap = with(HasDensity(context.resources)) {
+    val recordPositions = mutableListOf<Pair<Int, Long>>()
+    var currentRecord: Record? = null
+
+    val otherColor = ContextCompat.getColor(context, R.color.leak_canary_heap_other)
+    val stackTraceColor = ContextCompat.getColor(context, R.color.leak_canary_heap_stack_trace)
+    val hprofStringColor = ContextCompat.getColor(context, R.color.leak_canary_heap_hprof_string)
+    val loadClassColor = ContextCompat.getColor(context, R.color.leak_canary_heap_load_class)
+    val classDumpColor = ContextCompat.getColor(context, R.color.leak_canary_heap_class_dump)
+    val instanceColor = ContextCompat.getColor(context, R.color.leak_canary_heap_instance)
+    val objectArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_object_array)
+    val booleanArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_boolean_array)
+    val charArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_char_array)
+    val floatArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_float_array)
+    val doubleArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_double_array)
+    val byteArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_byte_array)
+    val shortArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_short_array)
+    val intArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_int_array)
+    val longArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_long_array)
+    val colors = mapOf(
+        StringRecord::class to hprofStringColor,
+        LoadClassRecord::class to loadClassColor,
+        ClassDumpRecord::class to classDumpColor,
+        InstanceDumpRecord::class to instanceColor,
+        ObjectArrayDumpRecord::class to objectArrayColor,
+        BooleanArrayDump::class to booleanArrayColor,
+        CharArrayDump::class to charArrayColor,
+        FloatArrayDump::class to floatArrayColor,
+        DoubleArrayDump::class to doubleArrayColor,
+        ByteArrayDump::class to byteArrayColor,
+        ShortArrayDump::class to shortArrayColor,
+        IntArrayDump::class to intArrayColor,
+        LongArrayDump::class to longArrayColor,
+        StackTraceRecord::class to stackTraceColor,
+        HeapDumpEndRecord::class to otherColor,
+        GcRootRecord::class to otherColor
+    )
+
+    val appHeapColor = ContextCompat.getColor(context, R.color.leak_canary_heap_app)
+    val imageHeapColor = ContextCompat.getColor(context, R.color.leak_canary_heap_image)
+    val zygoteHeapColor = ContextCompat.getColor(context, R.color.leak_canary_heap_zygote)
+    val stringColor = ContextCompat.getColor(context, R.color.leak_canary_heap_instance_string)
+
+    val parser = HprofPushRecordsParser()
+    val reader = parser.readHprofRecords(heapDumpFile, setOf(object : OnRecordListener {
+      override fun recordTypes(): Set<KClass<out Record>> = setOf(Record::class)
+
+      val hprofStringCache = mutableMapOf<Long, String>()
+      val classNames = mutableMapOf<Long, Long>()
+
+      override fun onTypeSizesAvailable(typeSizes: Map<Int, Int>) {
+      }
+
+      override fun onRecord(
+        position: Long,
+        record: Record
+      ) {
+        when (record) {
+          is StringRecord -> {
+            hprofStringCache[record.id] = record.string
+          }
+          is LoadClassRecord -> {
+            classNames[record.id] = record.classNameStringId
+          }
+        }
+        val localCurrentRecord = currentRecord
+        when {
+          localCurrentRecord is HeapDumpInfoRecord -> {
+            val colorForHeapInfo =
+              when (hprofStringCache[localCurrentRecord.heapNameStringId]) {
+                // The primary heap on which your app allocates memory.
+                "app" -> appHeapColor
+                // The system boot image, containing classes that are preloaded during boot time.
+                // Allocations here are guaranteed to never move or go away.
+                "image" -> imageHeapColor
+                // The copy-on-write heap where an app process is forked from in the Android system.
+                "zygote" -> zygoteHeapColor
+                // JNI heap: The heap that shows where Java Native Interface (JNI) references are allocated and released.
+                // default heap: When no heap is specified by the system
+                else -> otherColor
+              }
+            recordPositions.add(colorForHeapInfo to position)
+            currentRecord = record
+          }
+          localCurrentRecord is InstanceDumpRecord
+              && hprofStringCache[classNames[localCurrentRecord.classId]] == "java.lang.String"
+              && (record !is InstanceDumpRecord || hprofStringCache[classNames[record.classId]]
+              != "java.lang.String")
+          -> {
+            recordPositions.add(stringColor to position)
+            currentRecord = record
+          }
+          currentRecord == null -> {
+            recordPositions.add(otherColor to position)
+            currentRecord = record
+          }
+          currentRecord!!::class != record::class -> {
+            recordPositions.add(colors.getValue(currentRecord!!::class) to position)
+            currentRecord = record
+          }
+        }
+      }
+    }))
+    val heapLength = reader.position
+    reader.close()
+
+    val width = sourceWidth
+    var height: Int
+    val bytesPerPixel: Double
+
+    if (sourceBytesPerPixel > 0) {
+      bytesPerPixel = sourceBytesPerPixel.toDouble()
+      height = Math.ceil((heapLength / bytesPerPixel) / width)
+          .toInt()
+    } else {
+      height = sourceHeight
+      bytesPerPixel = heapLength * 1.0 / (width * height)
+    }
+
+    val bitmap: Bitmap =
+      Bitmap.createBitmap(width, height, ARGB_8888)
+
+    val canvas = Canvas(bitmap)
+
+    val legend = mapOf(
+        "Hprof string" to hprofStringColor,
+        "Class name" to loadClassColor,
+        "App heap" to appHeapColor,
+        "Image heap" to imageHeapColor,
+        "Zygote heap" to zygoteHeapColor,
+        "Other heap" to otherColor,
+        "Class content" to classDumpColor,
+        "Instance" to instanceColor,
+        "String" to stringColor,
+        "Object array" to objectArrayColor,
+        "Boolean array" to booleanArrayColor,
+        "Char array" to charArrayColor,
+        "Float array" to floatArrayColor,
+        "Double array" to doubleArrayColor,
+        "Byte array" to byteArrayColor,
+        "Short array" to shortArrayColor,
+        "Int array" to intArrayColor,
+        "Long array" to longArrayColor,
+        "Stack trace" to stackTraceColor,
+        "Heap End" to otherColor
+    )
+
+    val legendTextPaint = Paint(Paint.ANTI_ALIAS_FLAG)
+
+    legendTextPaint.color = Color.WHITE
+    legendTextPaint.style = FILL
+    canvas.drawPaint(legendTextPaint)
+
+    val legendSquareFillPaint = Paint()
+    legendSquareFillPaint.style = FILL
+    val legendSquareStrokePaint = Paint()
+    legendSquareStrokePaint.style = STROKE
+    legendSquareStrokePaint.strokeWidth = 0.8f.dp
+    legendSquareStrokePaint.color = Color.BLACK
+
+    legendTextPaint.color = Color.BLACK
+    legendTextPaint.textSize = 16.dp
+
+    val metrics = legendTextPaint.fontMetrics
+    val textHeight = metrics.descent - metrics.ascent
+
+    val xBounds = Rect()
+    legendTextPaint.getTextBounds("x", 0, 1, xBounds)
+    val squareSize = xBounds.height()
+    val squarePaddingTop = (textHeight - squareSize) / 2
+    val squareToTextPadding = 4.dp
+    val blockToBlockPadding = 8.dp
+
+    var maxTextWidth = 0f
+    for (name in legend.keys) {
+      maxTextWidth = Math.max(maxTextWidth, legendTextPaint.measureText(name))
+    }
+
+    val padding = 8.dp
+    var blockLeft = padding
+    var blockTop = padding
+    val legendWidth = width - 2 * padding
+    for ((name, color) in legend) {
+      if (blockLeft + squareSize + squareToTextPadding + maxTextWidth > legendWidth) {
+        blockLeft = padding
+        blockTop += textHeight
+      }
+
+      legendSquareFillPaint.color = color
+      canvas.drawRect(
+          blockLeft, blockTop + squarePaddingTop, blockLeft + squareSize,
+          blockTop + squarePaddingTop + squareSize,
+          legendSquareFillPaint
+      )
+      canvas.drawRect(
+          blockLeft, blockTop + squarePaddingTop, blockLeft + squareSize,
+          blockTop + squarePaddingTop + squareSize,
+          legendSquareStrokePaint
+      )
+      blockLeft += squareSize + squareToTextPadding
+      canvas.drawText(name, blockLeft, blockTop - metrics.ascent, legendTextPaint)
+      blockLeft += maxTextWidth
+      blockLeft += blockToBlockPadding
+    }
+    val legendHeight = blockTop + textHeight + padding
+    val source = Rect(0, 0, width, legendHeight.toInt())
+    val destination = Rect(0, (height - legendHeight).toInt(), width, height)
+    canvas.drawBitmap(bitmap, source, destination, null)
+    height -= legendHeight.toInt()
+
+    val pixelPaint = Paint()
+    pixelPaint.style = FILL
+
+    var recordIndex = 0
+    for (y in 0 until height) {
+      for (x in 0 until width) {
+        val bitmapPosition = y * width + x
+        val heapPosition = (bitmapPosition * bytesPerPixel).toInt()
+        while (heapPosition > recordPositions[recordIndex].second && recordIndex < recordPositions.lastIndex) {
+          recordIndex++
+        }
+        pixelPaint.color = recordPositions[recordIndex].first
+        canvas.drawPoint(x.toFloat(), y.toFloat(), pixelPaint)
+      }
+    }
+    return bitmap
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
new file mode 100644
index 00000000..fd83040f
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
@@ -0,0 +1,110 @@
+package leakcanary.internal.activity.screen
+
+import android.content.Intent
+import android.net.Uri
+import android.view.View
+import android.view.ViewGroup
+import android.widget.ListView
+import com.squareup.leakcanary.core.R
+import leakcanary.LeakingInstance
+import leakcanary.internal.DisplayLeakAdapter
+import leakcanary.internal.activity.db.LeakingInstanceTable
+import leakcanary.internal.activity.db.executeOnDb
+import leakcanary.internal.activity.screen.LeakingInstanceScreen.InstanceOrId.Id
+import leakcanary.internal.activity.screen.LeakingInstanceScreen.InstanceOrId.Instance
+import leakcanary.internal.activity.share
+import leakcanary.internal.activity.shareToStackOverflow
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.goTo
+import leakcanary.internal.navigation.inflate
+import leakcanary.internal.navigation.onCreateOptionsMenu
+import java.io.Serializable
+
+internal class LeakingInstanceScreen private constructor(
+  private val instanceOrId: InstanceOrId
+) : Screen() {
+
+  constructor(id: Long) : this(Id(id))
+
+  sealed class InstanceOrId : Serializable {
+    class Instance(
+      val heapAnalysisId: Long,
+      val instance: LeakingInstance
+    ) : InstanceOrId()
+
+    class Id(val id: Long) : InstanceOrId()
+  }
+
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_list).apply {
+
+      when (instanceOrId) {
+        is Instance -> {
+          onInstanceRetrieved(instanceOrId.heapAnalysisId, instanceOrId.instance)
+        }
+        is Id -> {
+          activity.title = resources.getString(R.string.leak_canary_loading_title)
+          executeOnDb {
+            val pair = LeakingInstanceTable.retrieve(db, instanceOrId.id)
+            updateUi {
+              if (pair == null) {
+                activity.title = resources.getString(R.string.leak_canary_analysis_deleted_title)
+              } else {
+                val (heapAnalysisId, leakingInstance) = pair
+                onInstanceRetrieved(heapAnalysisId, leakingInstance)
+              }
+            }
+          }
+        }
+      }
+    }
+
+  private fun View.onInstanceRetrieved(
+    heapAnalysisId: Long,
+    leakingInstance: LeakingInstance
+  ) {
+    val classSimpleName = leakingInstance.instanceClassSimpleName
+    activity.title =
+      resources.getString(R.string.leak_canary_class_has_leaked, classSimpleName)
+
+    val listView = findViewById<ListView>(R.id.leak_canary_list)
+
+    val adapter =
+      DisplayLeakAdapter(context, leakingInstance.leakTrace, leakingInstance.referenceName)
+    listView.adapter = adapter
+
+    listView.setOnItemClickListener { _, _, position, _ ->
+      if (adapter.isLearnMoreRow(position)) {
+        val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(LEARN_MORE_URL))
+        activity.startActivity(browserIntent)
+      } else {
+        adapter.toggleRow(position)
+      }
+    }
+
+    onCreateOptionsMenu { menu ->
+      menu.add(R.string.leak_canary_go_to_heap_analysis)
+          .setOnMenuItemClickListener {
+            goTo(HeapAnalysisSuccessScreen(heapAnalysisId))
+            true
+          }
+      menu.add(R.string.leak_canary_share_leak)
+          .setOnMenuItemClickListener {
+            // TODO Add version information
+            share(leakingInstance.toString())
+            true
+          }
+      menu.add(R.string.leak_canary_stackoverflow_share)
+          .setOnMenuItemClickListener {
+            // TODO Add version information
+            shareToStackOverflow(leakingInstance.toString())
+            true
+          }
+    }
+  }
+  companion object {
+    private const val LEARN_MORE_URL =
+      "https://square.github.io/leakcanary/fundamentals/"
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
new file mode 100644
index 00000000..7311da16
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
@@ -0,0 +1,160 @@
+package leakcanary.internal.activity.screen
+
+import android.content.Intent
+import android.graphics.Bitmap
+import android.os.Build.VERSION
+import android.os.Build.VERSION_CODES
+import android.os.Environment
+import android.os.Environment.DIRECTORY_DOWNLOADS
+import android.view.View
+import android.view.ViewGroup
+import android.view.ViewTreeObserver.OnGlobalLayoutListener
+import android.widget.ImageView
+import android.widget.Toast
+import androidx.core.content.FileProvider
+import com.squareup.leakcanary.core.R
+import leakcanary.CanaryLog
+import leakcanary.internal.InternalLeakCanary
+import leakcanary.internal.activity.db.executeOnIo
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.inflate
+import leakcanary.internal.navigation.onCreateOptionsMenu
+import java.io.File
+import java.io.FileOutputStream
+import java.io.IOException
+
+internal class RenderHeapDumpScreen(
+  private val heapDumpFile: File
+) : Screen() {
+
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_heap_render).apply {
+      container.activity.title = resources.getString(R.string.leak_canary_loading_title)
+
+      executeOnIo {
+        val byteCount = humanReadableByteCount(heapDumpFile.length(), false)
+        updateUi {
+          container.activity.title =
+            resources.getString(R.string.leak_canary_heap_dump_screen_title, byteCount)
+        }
+      }
+
+      val loadingView = findViewById<View>(R.id.leak_canary_loading)
+      val imageView = findViewById<ImageView>(R.id.leak_canary_heap_rendering)
+
+      viewTreeObserver.addOnGlobalLayoutListener(object : OnGlobalLayoutListener {
+        override fun onGlobalLayout() {
+
+          executeOnIo {
+            val bitmap = HeapDumpRenderer.render(
+                context, heapDumpFile, measuredWidth, measuredHeight, 0
+            )
+            updateUi {
+              imageView.setImageBitmap(bitmap)
+              loadingView.visibility = View.GONE
+              imageView.visibility = View.VISIBLE
+            }
+          }
+          if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN) {
+            viewTreeObserver.removeOnGlobalLayoutListener(this)
+          } else {
+            viewTreeObserver.removeGlobalOnLayoutListener(this)
+          }
+        }
+      })
+
+      onCreateOptionsMenu { menu ->
+        menu.add(R.string.leak_canary_options_menu_generate_hq_bitmap)
+            .setOnMenuItemClickListener {
+              val leakDirectoryProvider = InternalLeakCanary.leakDirectoryProvider
+              if (!leakDirectoryProvider.hasStoragePermission()) {
+                Toast.makeText(
+                    context,
+                    R.string.leak_canary_options_menu_permission_toast,
+                    Toast.LENGTH_LONG
+                )
+                    .show()
+                leakDirectoryProvider.requestWritePermissionNotification()
+              } else {
+                Toast.makeText(
+                    context,
+                    R.string.leak_canary_generating_hq_bitmap_toast_notice,
+                    Toast.LENGTH_LONG
+                )
+                    .show()
+                executeOnIo {
+                  val bitmap = HeapDumpRenderer.render(context, heapDumpFile, 2048, 0, 4)
+                  val storageDir =
+                    Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS)
+
+                  val imageFile = File(storageDir, "${heapDumpFile.name}.png")
+                  val saved = savePng(imageFile, bitmap)
+                  if (saved) {
+                    CanaryLog.d("Png saved at $imageFile")
+                    imageFile.setReadable(true, false)
+                    val imageUri = FileProvider.getUriForFile(
+                        activity,
+                        "com.squareup.leakcanary.fileprovider." + activity.packageName,
+                        imageFile
+                    )
+
+                    updateUi {
+                      val intent = Intent(Intent.ACTION_SEND)
+                      intent.type = "image/png"
+                      intent.putExtra(Intent.EXTRA_STREAM, imageUri)
+                      activity.startActivity(
+                          Intent.createChooser(
+                              intent,
+                              resources.getString(
+                                  R.string.leak_canary_share_heap_dump_bitmap_screen_title
+                              )
+                          )
+                      )
+                    }
+                  } else {
+                    updateUi {
+                      Toast.makeText(
+                          context,
+                          R.string.leak_canary_generating_hq_bitmap_toast_failure_notice,
+                          Toast.LENGTH_LONG
+                      )
+                          .show()
+                    }
+                  }
+                }
+              }
+              true
+            }
+      }
+    }
+
+  // https://stackoverflow.com/a/3758880
+  fun humanReadableByteCount(
+    bytes: Long,
+    si: Boolean
+  ): String {
+    val unit = if (si) 1000 else 1024
+    if (bytes < unit) return "$bytes B"
+    val exp = (Math.log(bytes.toDouble()) / Math.log(unit.toDouble())).toInt()
+    val pre = (if (si) "kMGTPE" else "KMGTPE")[exp - 1] + if (si) "" else "i"
+    return String.format("%.1f %sB", bytes / Math.pow(unit.toDouble(), exp.toDouble()), pre)
+  }
+
+  fun savePng(
+    imageFile: File,
+    source: Bitmap
+  ): Boolean {
+    var outStream: FileOutputStream? = null
+    return try {
+      outStream = FileOutputStream(imageFile)
+      source.compress(Bitmap.CompressFormat.PNG, 100, outStream)
+      true
+    } catch (e: IOException) {
+      false
+    } finally {
+      outStream?.close()
+    }
+  }
+}
+
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt
new file mode 100644
index 00000000..29264091
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt
@@ -0,0 +1,30 @@
+package leakcanary.internal.activity.ui
+
+import android.view.View
+import android.view.ViewGroup
+import android.widget.BaseAdapter
+import androidx.annotation.LayoutRes
+import leakcanary.internal.navigation.inflate
+
+class SimpleListAdapter<T>(
+  @LayoutRes
+  private val rowResId: Int,
+  private val items: List<T>,
+  private val bindView: SimpleListAdapter<T>.(View, Int) -> Unit
+) : BaseAdapter() {
+  override fun getView(
+    position: Int,
+    convertView: View?,
+    parent: ViewGroup
+  ): View {
+    val view = convertView ?: parent.inflate(rowResId)
+    bindView(view, position)
+    return view
+  }
+
+  override fun getItem(position: Int) = items[position]
+
+  override fun getItemId(position: Int) = position.toLong()
+
+  override fun getCount() = items.size
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/BackstackFrame.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/BackstackFrame.kt
new file mode 100644
index 00000000..1a9d412c
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/BackstackFrame.kt
@@ -0,0 +1,66 @@
+package leakcanary.internal.navigation
+
+import android.os.Parcel
+import android.os.Parcelable
+import android.util.SparseArray
+import android.view.View
+
+internal class BackstackFrame : Parcelable {
+
+  val screen: Screen
+  private val viewState: SparseArray<Parcelable>?
+
+  private constructor(
+    source: Parcel
+  ) {
+    this.screen = source.readSerializable() as Screen
+    @Suppress("UNCHECKED_CAST")
+    this.viewState = source.readSparseArray<Parcelable>(javaClass.classLoader)
+  }
+
+  constructor(
+    screen: Screen
+  ) {
+    this.screen = screen
+    viewState = null
+  }
+
+  constructor(
+    screen: Screen,
+    view: View
+  ) {
+    this.screen = screen
+    viewState = SparseArray()
+    view.saveHierarchyState(viewState)
+  }
+
+  fun restore(view: View) {
+    if (viewState != null) {
+      view.restoreHierarchyState(viewState)
+    }
+  }
+
+  override fun describeContents() = 0
+
+  @Suppress("UNCHECKED_CAST")
+  override fun writeToParcel(
+    dest: Parcel,
+    flags: Int
+  ) {
+    dest.writeSerializable(screen)
+    dest.writeSparseArray(viewState as SparseArray<Any>?)
+  }
+
+  companion object {
+    @Suppress("UNCHECKED_CAST")
+    @JvmField val CREATOR = object : Parcelable.Creator<BackstackFrame> {
+      override fun createFromParcel(source: Parcel): BackstackFrame {
+        return BackstackFrame(source)
+      }
+
+      override fun newArray(size: Int): Array<BackstackFrame?> {
+        return arrayOfNulls(size)
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/NavigatingActivity.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/NavigatingActivity.kt
new file mode 100644
index 00000000..f53117e1
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/NavigatingActivity.kt
@@ -0,0 +1,147 @@
+package leakcanary.internal.navigation
+
+import android.app.Activity
+import android.content.Intent
+import android.os.Bundle
+import android.os.Parcelable
+import android.view.Menu
+import android.view.MenuItem
+import android.view.View
+import android.view.ViewGroup
+import android.view.animation.AnimationUtils.loadAnimation
+import com.squareup.leakcanary.core.R
+
+/**
+ * A simple backstack navigating activity
+ */
+internal abstract class NavigatingActivity : Activity() {
+
+  private lateinit var backstack: ArrayList<BackstackFrame>
+  private lateinit var currentScreen: Screen
+
+  private lateinit var container: ViewGroup
+  private lateinit var currentView: View
+
+  var onCreateOptionsMenu = NO_MENU
+
+  fun installNavigation(
+    savedInstanceState: Bundle?,
+    container: ViewGroup
+  ) {
+    this.container = container
+
+    if (savedInstanceState == null) {
+      backstack = ArrayList()
+      currentScreen = if (intent.hasExtra("screens")) {
+        @Suppress("UNCHECKED_CAST")
+        val screens = intent.getSerializableExtra("screens") as List<Screen>
+        screens.dropLast(1)
+            .forEach { screen ->
+              backstack.add(BackstackFrame(screen))
+            }
+        screens.last()
+      } else {
+        getLauncherScreen()
+      }
+    } else {
+      currentScreen = savedInstanceState.getSerializable("currentScreen") as Screen
+      @Suppress("UNCHECKED_CAST")
+      backstack = savedInstanceState.getParcelableArrayList<Parcelable>(
+          "backstack"
+      ) as ArrayList<BackstackFrame>
+    }
+    currentView = currentScreen.createView(container)
+    container.addView(currentView)
+    updateActionBar()
+  }
+
+  override fun onNewIntent(intent: Intent) {
+    if (intent.hasExtra("screens")) {
+      @Suppress("UNCHECKED_CAST")
+      val screens = intent.getSerializableExtra("screens") as List<Screen>
+      goTo(intent.getSerializableExtra("screen") as Screen)
+      backstack.clear()
+      screens.dropLast(1)
+          .forEach { screen ->
+            backstack.add(BackstackFrame(screen))
+          }
+    }
+  }
+
+  open fun getLauncherScreen(): Screen {
+    TODO("Launcher activities should override getLauncherScreen()")
+  }
+
+  public override fun onSaveInstanceState(outState: Bundle) {
+    super.onSaveInstanceState(outState)
+    outState.putSerializable("currentScreen", currentScreen)
+    outState.putParcelableArrayList("backstack", backstack)
+  }
+
+  override fun onBackPressed() {
+    if (backstack.size > 0) {
+      goBack()
+      return
+    }
+    super.onBackPressed()
+  }
+
+  fun goTo(screen: Screen) {
+    onCreateOptionsMenu = NO_MENU
+
+    currentView.startAnimation(loadAnimation(this, R.anim.leak_canary_exit_forward))
+    container.removeView(currentView)
+    val backstackFrame = BackstackFrame(currentScreen, currentView)
+    backstack.add(backstackFrame)
+
+    currentScreen = screen
+    currentView = currentScreen.createView(container)
+    currentView.startAnimation(loadAnimation(this, R.anim.leak_canary_enter_forward))
+    container.addView(currentView)
+
+    updateActionBar()
+  }
+
+  fun goBack() {
+    onCreateOptionsMenu = NO_MENU
+
+    currentView.startAnimation(loadAnimation(this, R.anim.leak_canary_exit_backward))
+    container.removeView(currentView)
+
+    val latest = backstack.removeAt(backstack.size - 1)
+    currentScreen = latest.screen
+    currentView = currentScreen.createView(container)
+    currentView.startAnimation(loadAnimation(this, R.anim.leak_canary_enter_backward))
+    container.addView(currentView, 0)
+    latest.restore(currentView)
+
+    updateActionBar()
+  }
+
+  private fun updateActionBar() {
+    invalidateOptionsMenu()
+    val actionBar = actionBar
+        ?: // https://github.com/square/leakcanary/issues/967
+        return
+    actionBar.setDisplayHomeAsUpEnabled(backstack.size > 0)
+  }
+
+  override fun onCreateOptionsMenu(menu: Menu): Boolean {
+    onCreateOptionsMenu.invoke(menu)
+    return true
+  }
+
+  override fun onOptionsItemSelected(item: MenuItem): Boolean =
+    when (item.itemId) {
+      android.R.id.home -> {
+        goBack()
+        true
+      }
+      else -> super.onOptionsItemSelected(item)
+    }
+
+  companion object {
+    val NO_MENU: ((Menu) -> Unit) = {}
+  }
+
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Screen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Screen.kt
new file mode 100644
index 00000000..85c4561f
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Screen.kt
@@ -0,0 +1,14 @@
+package leakcanary.internal.navigation
+
+import android.view.View
+import android.view.ViewGroup
+import java.io.Serializable
+
+/**
+ * Replaces Fragments, MVP, MVC, MVVM, MVMVMVM and everything else in just one tiny class.
+ * A screen is a location to go to, and it can build a view to display.
+ */
+internal abstract class Screen : Serializable {
+
+  abstract fun createView(container: ViewGroup): View
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt
new file mode 100644
index 00000000..13603e4e
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt
@@ -0,0 +1,30 @@
+package leakcanary.internal.navigation
+
+import android.app.Activity
+import android.view.LayoutInflater
+import android.view.Menu
+import android.view.View
+import android.view.ViewGroup
+import androidx.annotation.LayoutRes
+
+internal fun ViewGroup.inflate(@LayoutRes layoutResId: Int) = LayoutInflater.from(context)
+    .inflate(layoutResId, this, false)!!
+
+internal val View.activity
+  get() = context as Activity
+
+@Suppress("UNCHECKED_CAST")
+internal fun <T : Activity> View.activity() = context as T
+
+internal fun View.onCreateOptionsMenu(onCreateOptionsMenu: (Menu) -> Unit) {
+  activity<NavigatingActivity>().onCreateOptionsMenu = onCreateOptionsMenu
+  activity.invalidateOptionsMenu()
+}
+
+internal fun View.goTo(screen: Screen) {
+  activity<NavigatingActivity>().goTo(screen)
+}
+
+internal fun View.goBack() {
+  activity<NavigatingActivity>().goBack()
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Tuples.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Tuples.kt
new file mode 100644
index 00000000..6a3164d3
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Tuples.kt
@@ -0,0 +1,3 @@
+package leakcanary.internal.utils
+
+infix fun <A, B, C> Pair<A, B>.to(that: C): Triple<A, B, C> = Triple(first, second, that)
diff --git a/leakcanary-android-core/src/main/res/anim/leak_canary_enter_backward.xml b/leakcanary-android-core/src/main/res/anim/leak_canary_enter_backward.xml
new file mode 100644
index 00000000..d2430eae
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/anim/leak_canary_enter_backward.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<translate
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:fromXDelta="-100%" android:toXDelta="0%"
+    android:fromYDelta="0%" android:toYDelta="0%"
+    android:duration="@android:integer/config_mediumAnimTime"/>
diff --git a/leakcanary-android-core/src/main/res/anim/leak_canary_enter_forward.xml b/leakcanary-android-core/src/main/res/anim/leak_canary_enter_forward.xml
new file mode 100644
index 00000000..1dc5cfc4
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/anim/leak_canary_enter_forward.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<translate
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:fromXDelta="100%" android:toXDelta="0%"
+    android:fromYDelta="0%" android:toYDelta="0%"
+    android:duration="@android:integer/config_mediumAnimTime"/>
diff --git a/leakcanary-android-core/src/main/res/anim/leak_canary_exit_backward.xml b/leakcanary-android-core/src/main/res/anim/leak_canary_exit_backward.xml
new file mode 100644
index 00000000..7dea9fbf
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/anim/leak_canary_exit_backward.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<translate
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:fromXDelta="0%" android:toXDelta="100%"
+    android:fromYDelta="0%" android:toYDelta="0%"
+    android:duration="@android:integer/config_mediumAnimTime"/>
diff --git a/leakcanary-android-core/src/main/res/anim/leak_canary_exit_forward.xml b/leakcanary-android-core/src/main/res/anim/leak_canary_exit_forward.xml
new file mode 100644
index 00000000..b7292341
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/anim/leak_canary_exit_forward.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<translate
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:fromXDelta="0%" android:toXDelta="-100%"
+    android:fromYDelta="0%" android:toYDelta="0%"
+    android:duration="@android:integer/config_mediumAnimTime"/>
diff --git a/leakcanary-android-core/src/main/res/drawable-anydpi-v24/leak_canary_notification.xml b/leakcanary-android-core/src/main/res/drawable-anydpi-v24/leak_canary_notification.xml
new file mode 100644
index 00000000..f5f88aa7
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable-anydpi-v24/leak_canary_notification.xml
@@ -0,0 +1,38 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportWidth="184.32971"
+    android:viewportHeight="184.32971"
+    android:tint="#FFFFFF">
+  <group android:translateX="-0.33514494"
+      android:translateY="-0.33514494">
+    <group>
+      <clip-path android:pathData="M0,0h185v185h-185z M 0,0"/>
+      <path
+          android:pathData="M55.8327 80.944L68.1676 83.3835M59.6321 89.5079L62.4202 75.4109"
+          android:strokeWidth="4.257"
+          android:fillColor="#00000000"
+          android:strokeColor="#151C1F"
+          android:strokeLineCap="round"/>
+      <path
+          android:pathData="M33.0396 88.6436L148.284 41.1702C148.308 41.1931 148.333 41.216 148.357 41.2389C147.773 76.5754 125.2 119.136 72.6948 132.558C66.2444 121.606 47.4716 97.5578 32.6694 89.9372C32.799 89.5158 32.9224 89.0844 33.0396 88.6436Z"
+          android:fillColor="#ffffff"
+          android:fillType="evenOdd"/>
+      <path
+          android:pathData="M81.4818 31.7162L72.8251 55.9266L71.7247 54.5065C66.7399 48.0734 60.8251 42.4184 54.1748 37.7274L69.4736 20.6696L68.6881 39.2884L81.4818 31.7162Z"
+          android:fillColor="#ffffff"/>
+      <path
+          android:pathData="M64.8741 100.079C81.01 89.2721 85.3298 67.4304 74.5226 51.2946C63.7154 35.1587 41.8738 30.8389 25.7379 41.6461C9.60205 52.4532 5.28228 74.2949 16.0894 90.4308C26.8966 106.567 48.7382 110.886 64.8741 100.079ZM43.6335 56.9634C42.5166 57.3298 41.9082 58.5324 42.2747 59.6494C42.6412 60.7663 43.8437 61.3747 44.9607 61.0082L48.0585 59.9918L49.7842 65.2515C50.1507 66.3684 51.3532 66.9768 52.4702 66.6103C53.5871 66.2439 54.1955 65.0413 53.829 63.9244L52.1033 58.6647L56.9078 57.0883C58.0248 56.7218 58.6332 55.5193 58.2667 54.4023C57.9002 53.2853 56.6977 52.677 55.5807 53.0434L50.7762 54.6198L49.3491 50.2704C48.9826 49.1535 47.7801 48.5451 46.6631 48.9116C45.5462 49.278 44.9378 50.4806 45.3043 51.5976L46.7313 55.947L43.6335 56.9634Z"
+          android:fillColor="#ffffff"
+          android:fillType="evenOdd"/>
+      <path
+          android:pathData="M10.1416 71.2627C10.4815 113.278 38.6085 151.594 81.1309 162.988C113.627 171.695 146.704 162.582 170.003 141.637C159.823 142.304 149.364 141.343 138.964 138.556C113.428 131.714 93.0844 115.164 80.8316 93.9338L10.1416 71.2627Z"
+          android:fillColor="#ffffff"
+          android:fillType="evenOdd"/>
+      <path
+          android:pathData="M175.463 56.9136L57.9672 97.0664C57.8158 97.5113 57.6587 97.9458 57.4956 98.3692C71.736 106.994 88.8027 132.282 94.4811 143.653C105.725 141.594 115.73 138.149 124.547 133.665C121.291 132.305 118.248 130.405 115.554 128.011L114.859 127.392C114.033 126.658 113.959 125.394 114.693 124.569C115.427 123.743 116.691 123.669 117.516 124.403L118.212 125.021C121.434 127.886 125.228 129.941 129.286 131.091C130.47 130.405 131.632 129.699 132.769 128.975C130.868 128.149 129.036 127.135 127.302 125.938L126.535 125.409C125.626 124.782 125.398 123.537 126.025 122.627C126.653 121.718 127.898 121.49 128.807 122.117L129.573 122.646C131.83 124.203 134.276 125.407 136.83 126.243C137.942 125.453 139.03 124.644 140.093 123.818C139.482 123.453 138.88 123.067 138.29 122.66L137.524 122.131C136.615 121.504 136.387 120.259 137.014 119.349C137.641 118.44 138.887 118.212 139.796 118.839L140.562 119.368C141.487 120.006 142.444 120.585 143.428 121.104C163.878 103.673 174.394 79.6305 176.271 57.779C176.004 57.4894 175.735 57.2009 175.463 56.9136Z"
+          android:fillColor="#ffffff"
+          android:fillType="evenOdd"/>
+    </group>
+  </group>
+</vector>
diff --git a/leakcanary-android-core/src/main/res/drawable-hdpi/leak_canary_notification.png b/leakcanary-android-core/src/main/res/drawable-hdpi/leak_canary_notification.png
new file mode 100644
index 00000000..b3fe4bcc
Binary files /dev/null and b/leakcanary-android-core/src/main/res/drawable-hdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android-core/src/main/res/drawable-mdpi/leak_canary_notification.png b/leakcanary-android-core/src/main/res/drawable-mdpi/leak_canary_notification.png
new file mode 100644
index 00000000..9843dc04
Binary files /dev/null and b/leakcanary-android-core/src/main/res/drawable-mdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android-core/src/main/res/drawable-xhdpi/leak_canary_notification.png b/leakcanary-android-core/src/main/res/drawable-xhdpi/leak_canary_notification.png
new file mode 100644
index 00000000..18b6aead
Binary files /dev/null and b/leakcanary-android-core/src/main/res/drawable-xhdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android-core/src/main/res/drawable-xxhdpi/leak_canary_notification.png b/leakcanary-android-core/src/main/res/drawable-xxhdpi/leak_canary_notification.png
new file mode 100644
index 00000000..e27d8a18
Binary files /dev/null and b/leakcanary-android-core/src/main/res/drawable-xxhdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_icon.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_icon.xml
new file mode 100644
index 00000000..aa225f7a
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_icon.xml
@@ -0,0 +1,17 @@
+<vector android:height="24dp" android:viewportHeight="185"
+    android:viewportWidth="185" android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
+    <group>
+        <clip-path android:pathData="M0,0h185v185h-185z M 0,0"/>
+        <path android:fillColor="#00000000"
+            android:pathData="M55.8327 80.944L68.1676 83.3835M59.6321 89.5079L62.4202 75.4109"
+            android:strokeColor="#151C1F" android:strokeLineCap="round" android:strokeWidth="4.257"/>
+        <path android:fillColor="#F5BD14" android:fillType="evenOdd" android:pathData="M33.0396 88.6436L148.284 41.1702C148.308 41.1931 148.333 41.216 148.357 41.2389C147.773 76.5754 125.2 119.136 72.6948 132.558C66.2444 121.606 47.4716 97.5578 32.6694 89.9372C32.799 89.5158 32.9224 89.0844 33.0396 88.6436Z"/>
+        <path android:fillColor="#F86932" android:pathData="M81.4818 31.7162L72.8251 55.9266L71.7247 54.5065C66.7399 48.0734 60.8251 42.4184 54.1748 37.7274L69.4736 20.6696L68.6881 39.2884L81.4818 31.7162Z"/>
+        <path android:fillColor="#FFCC32" android:pathData="M45.3062,70.8628m-35.1642,0.0a35.1642,35.1642,0,1,1,70.3284,0.0a35.1642,35.1642,0,1,1,-70.3284,0.0"/>
+        <path android:fillColor="#00000000"
+            android:pathData="M44.2972 58.986L56.2444 55.066M51.8067 64.5881L47.3268 50.9342"
+            android:strokeColor="#151C1F" android:strokeLineCap="round" android:strokeWidth="4.257"/>
+        <path android:fillColor="#FFCC32" android:fillType="evenOdd" android:pathData="M10.1416 71.2627C10.4815 113.278 38.6085 151.594 81.1309 162.988C113.627 171.695 146.704 162.582 170.003 141.637C159.823 142.304 149.364 141.343 138.964 138.556C113.428 131.714 93.0844 115.164 80.8316 93.9338L10.1416 71.2627Z"/>
+        <path android:fillColor="#FFCC32" android:fillType="evenOdd" android:pathData="M175.463 56.9136L57.9672 97.0664C57.8158 97.5113 57.6587 97.9458 57.4956 98.3692C71.736 106.994 88.8027 132.282 94.4811 143.653C105.725 141.594 115.73 138.149 124.547 133.665C121.291 132.305 118.248 130.405 115.554 128.011L114.859 127.392C114.033 126.658 113.959 125.394 114.693 124.569C115.427 123.743 116.691 123.669 117.516 124.403L118.212 125.021C121.434 127.886 125.228 129.941 129.286 131.091C130.47 130.405 131.632 129.699 132.769 128.975C130.868 128.149 129.036 127.135 127.302 125.938L126.535 125.409C125.626 124.782 125.398 123.537 126.025 122.627C126.653 121.718 127.898 121.49 128.807 122.117L129.573 122.646C131.83 124.203 134.276 125.407 136.83 126.243C137.942 125.453 139.03 124.644 140.093 123.818C139.482 123.453 138.88 123.067 138.29 122.66L137.524 122.131C136.615 121.504 136.387 120.259 137.014 119.349C137.641 118.44 138.887 118.212 139.796 118.839L140.562 119.368C141.487 120.006 142.444 120.585 143.428 121.104C163.878 103.673 174.394 79.6305 176.271 57.779C176.004 57.4894 175.735 57.2009 175.463 56.9136Z"/>
+    </group>
+</vector>
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_icon_foreground.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_icon_foreground.xml
new file mode 100644
index 00000000..49b7ea7e
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_icon_foreground.xml
@@ -0,0 +1,23 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="108dp"
+    android:height="108dp"
+    android:viewportWidth="336.36365"
+    android:viewportHeight="336.36365">
+  <group android:translateX="75.681816"
+      android:translateY="75.681816">
+      <group>
+          <clip-path android:pathData="M0,0h185v185h-185z M 0,0"/>
+          <path android:fillColor="#00000000"
+              android:pathData="M55.8327 80.944L68.1676 83.3835M59.6321 89.5079L62.4202 75.4109"
+              android:strokeColor="#151C1F" android:strokeLineCap="round" android:strokeWidth="4.257"/>
+          <path android:fillColor="#F5BD14" android:fillType="evenOdd" android:pathData="M33.0396 88.6436L148.284 41.1702C148.308 41.1931 148.333 41.216 148.357 41.2389C147.773 76.5754 125.2 119.136 72.6948 132.558C66.2444 121.606 47.4716 97.5578 32.6694 89.9372C32.799 89.5158 32.9224 89.0844 33.0396 88.6436Z"/>
+          <path android:fillColor="#F86932" android:pathData="M81.4818 31.7162L72.8251 55.9266L71.7247 54.5065C66.7399 48.0734 60.8251 42.4184 54.1748 37.7274L69.4736 20.6696L68.6881 39.2884L81.4818 31.7162Z"/>
+          <path android:fillColor="#FFCC32" android:pathData="M45.3062,70.8628m-35.1642,0.0a35.1642,35.1642,0,1,1,70.3284,0.0a35.1642,35.1642,0,1,1,-70.3284,0.0"/>
+          <path android:fillColor="#00000000"
+              android:pathData="M44.2972 58.986L56.2444 55.066M51.8067 64.5881L47.3268 50.9342"
+              android:strokeColor="#151C1F" android:strokeLineCap="round" android:strokeWidth="4.257"/>
+          <path android:fillColor="#FFCC32" android:fillType="evenOdd" android:pathData="M10.1416 71.2627C10.4815 113.278 38.6085 151.594 81.1309 162.988C113.627 171.695 146.704 162.582 170.003 141.637C159.823 142.304 149.364 141.343 138.964 138.556C113.428 131.714 93.0844 115.164 80.8316 93.9338L10.1416 71.2627Z"/>
+          <path android:fillColor="#FFCC32" android:fillType="evenOdd" android:pathData="M175.463 56.9136L57.9672 97.0664C57.8158 97.5113 57.6587 97.9458 57.4956 98.3692C71.736 106.994 88.8027 132.282 94.4811 143.653C105.725 141.594 115.73 138.149 124.547 133.665C121.291 132.305 118.248 130.405 115.554 128.011L114.859 127.392C114.033 126.658 113.959 125.394 114.693 124.569C115.427 123.743 116.691 123.669 117.516 124.403L118.212 125.021C121.434 127.886 125.228 129.941 129.286 131.091C130.47 130.405 131.632 129.699 132.769 128.975C130.868 128.149 129.036 127.135 127.302 125.938L126.535 125.409C125.626 124.782 125.398 123.537 126.025 122.627C126.653 121.718 127.898 121.49 128.807 122.117L129.573 122.646C131.83 124.203 134.276 125.407 136.83 126.243C137.942 125.453 139.03 124.644 140.093 123.818C139.482 123.453 138.88 123.067 138.29 122.66L137.524 122.131C136.615 121.504 136.387 120.259 137.014 119.349C137.641 118.44 138.887 118.212 139.796 118.839L140.562 119.368C141.487 120.006 142.444 120.585 143.428 121.104C163.878 103.673 174.394 79.6305 176.271 57.779C176.004 57.4894 175.735 57.2009 175.463 56.9136Z"/>
+      </group>
+  </group>
+</vector>
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_notification.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_notification.xml
new file mode 100644
index 00000000..3fe6f482
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_notification.xml
@@ -0,0 +1,14 @@
+<vector android:height="24dp" android:viewportHeight="185"
+    android:viewportWidth="185" android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
+    <group>
+        <clip-path android:pathData="M0,0h185v185h-185z M 0,0"/>
+        <path android:fillColor="#00000000"
+            android:pathData="M55.8327 80.944L68.1676 83.3835M59.6321 89.5079L62.4202 75.4109"
+            android:strokeColor="#151C1F" android:strokeLineCap="round" android:strokeWidth="4.257"/>
+        <path android:fillColor="#ffffff" android:fillType="evenOdd" android:pathData="M33.0396 88.6436L148.284 41.1702C148.308 41.1931 148.333 41.216 148.357 41.2389C147.773 76.5754 125.2 119.136 72.6948 132.558C66.2444 121.606 47.4716 97.5578 32.6694 89.9372C32.799 89.5158 32.9224 89.0844 33.0396 88.6436Z"/>
+        <path android:fillColor="#ffffff" android:pathData="M81.4818 31.7162L72.8251 55.9266L71.7247 54.5065C66.7399 48.0734 60.8251 42.4184 54.1748 37.7274L69.4736 20.6696L68.6881 39.2884L81.4818 31.7162Z"/>
+        <path android:fillColor="#ffffff" android:fillType="evenOdd" android:pathData="M64.8741 100.079C81.01 89.2721 85.3298 67.4304 74.5226 51.2946C63.7154 35.1587 41.8738 30.8389 25.7379 41.6461C9.60205 52.4532 5.28228 74.2949 16.0894 90.4308C26.8966 106.567 48.7382 110.886 64.8741 100.079ZM43.6335 56.9634C42.5166 57.3298 41.9082 58.5324 42.2747 59.6494C42.6412 60.7663 43.8437 61.3747 44.9607 61.0082L48.0585 59.9918L49.7842 65.2515C50.1507 66.3684 51.3532 66.9768 52.4702 66.6103C53.5871 66.2439 54.1955 65.0413 53.829 63.9244L52.1033 58.6647L56.9078 57.0883C58.0248 56.7218 58.6332 55.5193 58.2667 54.4023C57.9002 53.2853 56.6977 52.677 55.5807 53.0434L50.7762 54.6198L49.3491 50.2704C48.9826 49.1535 47.7801 48.5451 46.6631 48.9116C45.5462 49.278 44.9378 50.4806 45.3043 51.5976L46.7313 55.947L43.6335 56.9634Z"/>
+        <path android:fillColor="#ffffff" android:fillType="evenOdd" android:pathData="M10.1416 71.2627C10.4815 113.278 38.6085 151.594 81.1309 162.988C113.627 171.695 146.704 162.582 170.003 141.637C159.823 142.304 149.364 141.343 138.964 138.556C113.428 131.714 93.0844 115.164 80.8316 93.9338L10.1416 71.2627Z"/>
+        <path android:fillColor="#ffffff" android:fillType="evenOdd" android:pathData="M175.463 56.9136L57.9672 97.0664C57.8158 97.5113 57.6587 97.9458 57.4956 98.3692C71.736 106.994 88.8027 132.282 94.4811 143.653C105.725 141.594 115.73 138.149 124.547 133.665C121.291 132.305 118.248 130.405 115.554 128.011L114.859 127.392C114.033 126.658 113.959 125.394 114.693 124.569C115.427 123.743 116.691 123.669 117.516 124.403L118.212 125.021C121.434 127.886 125.228 129.941 129.286 131.091C130.47 130.405 131.632 129.699 132.769 128.975C130.868 128.149 129.036 127.135 127.302 125.938L126.535 125.409C125.626 124.782 125.398 123.537 126.025 122.627C126.653 121.718 127.898 121.49 128.807 122.117L129.573 122.646C131.83 124.203 134.276 125.407 136.83 126.243C137.942 125.453 139.03 124.644 140.093 123.818C139.482 123.453 138.88 123.067 138.29 122.66L137.524 122.131C136.615 121.504 136.387 120.259 137.014 119.349C137.641 118.44 138.887 118.212 139.796 118.839L140.562 119.368C141.487 120.006 142.444 120.585 143.428 121.104C163.878 103.673 174.394 79.6305 176.271 57.779C176.004 57.4894 175.735 57.2009 175.463 56.9136Z"/>
+    </group>
+</vector>
diff --git a/leakcanary-android/src/main/res/drawable/leak_canary_toast_background.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_toast_background.xml
similarity index 95%
rename from leakcanary-android/src/main/res/drawable/leak_canary_toast_background.xml
rename to leakcanary-android-core/src/main/res/drawable/leak_canary_toast_background.xml
index a90b8c2c..0bf11fb8 100644
--- a/leakcanary-android/src/main/res/drawable/leak_canary_toast_background.xml
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_toast_background.xml
@@ -2,4 +2,4 @@
 <shape xmlns:android="http://schemas.android.com/apk/res/android">
   <solid android:color="#cc000000"/>
   <corners android:radius="16dp"/>
-</shape>
\ No newline at end of file
+</shape>
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_heap_analysis_failure_screen.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_analysis_failure_screen.xml
new file mode 100644
index 00000000..739a7670
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_analysis_failure_screen.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<TextView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/leak_canary_failure"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@color/leak_canary_background_color"
+    android:textSize="12sp"
+    />
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_dump_toast.xml
similarity index 58%
rename from leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml
rename to leakcanary-android-core/src/main/res/layout/leak_canary_heap_dump_toast.xml
index d6057ed2..0f411da0 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_dump_toast.xml
@@ -14,26 +14,43 @@
   ~ See the License for the specific language governing permissions and
   ~ limitations under the License.
   -->
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="wrap_content"
     android:layout_height="wrap_content"
-    android:orientation="vertical"
-    android:background="@drawable/leak_canary_toast_background"
-    android:padding="16dp"
     >
-  <ImageView
+
+  <LinearLayout
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
+      android:background="@drawable/leak_canary_toast_background"
+      android:orientation="vertical"
+      android:layout_marginTop="48dp"
+      android:padding="16dp"
+      >
+  <!-- Holds the stop for the image on top-->
+  <View
+      android:layout_width="@dimen/leak_canary_toast_icon_size"
+      android:layout_height="@dimen/leak_canary_toast_icon_size"
       android:layout_gravity="center_horizontal"
-      android:src="@drawable/leak_canary_icon"/>
+      />
 
   <TextView
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
       android:layout_gravity="center_horizontal"
+      android:text="@string/leak_canary_toast_heap_dump"
       android:textColor="#ffffff"
       android:textSize="18sp"
-      android:text="@string/leak_canary_toast_heap_dump"
+      />
+  </LinearLayout>
+
+  <ImageView
+      android:id="@+id/leak_canary_toast_icon"
+      android:layout_marginTop="@dimen/leak_canary_toast_icon_size"
+      android:layout_width="@dimen/leak_canary_toast_icon_size"
+      android:layout_height="@dimen/leak_canary_toast_icon_size"
+      android:layout_gravity="center_horizontal"
+      android:src="@drawable/leak_canary_icon"
       />
 
-</LinearLayout>
+</FrameLayout>
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_heap_render.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_render.xml
new file mode 100644
index 00000000..7ecde1f6
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_render.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@color/leak_canary_background_color"
+    >
+  <ProgressBar
+      android:id="@+id/leak_canary_loading"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_gravity="center"
+      android:indeterminate="true"
+      style="?android:attr/progressBarStyleLarge"
+      />
+  <ImageView
+      android:id="@+id/leak_canary_heap_rendering"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      />
+
+</FrameLayout>
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_leak_activity.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_leak_activity.xml
new file mode 100644
index 00000000..bab4f43c
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_leak_activity.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/main_container"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    />
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_leak_row.xml
similarity index 82%
rename from leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml
rename to leakcanary-android-core/src/main/res/layout/leak_canary_leak_row.xml
index c5c5ac7f..ca20a3d1 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_leak_row.xml
@@ -17,6 +17,7 @@
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
+    xmlns:tools="http://schemas.android.com/tools"
     android:minHeight="48dp"
     android:padding="16dp"
     android:orientation="horizontal"
@@ -26,6 +27,9 @@
       android:id="@+id/leak_canary_row_text"
       android:layout_width="0dp"
       android:layout_weight="1"
+      android:layout_marginEnd="5dp"
+      android:layout_marginRight="5dp"
+      tools:text="5. ExampleApplication.leakedViews"
       android:layout_height="wrap_content"
       android:layout_gravity="center_vertical"
       android:textSize="18sp"
@@ -35,6 +39,9 @@
       android:id="@+id/leak_canary_row_time"
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
+      android:layout_marginLeft="5dp"
+      android:layout_marginStart="5dp"
+      tools:text="Latest: April 26th, 4:20 PM"
       android:layout_gravity="center_vertical"
       android:textColor="#919191"
       android:textSize="14sp"
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_list.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_list.xml
new file mode 100644
index 00000000..8d6a1f62
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_list.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@color/leak_canary_background_color"
+    android:orientation="vertical"
+    >
+  <ListView
+      android:id="@+id/leak_canary_list"
+      android:layout_width="match_parent"
+      android:layout_height="match_parent"
+      android:divider="@null"
+      android:dividerHeight="0dp"
+      />
+</FrameLayout>
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_ref_row.xml
similarity index 52%
rename from leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
rename to leakcanary-android-core/src/main/res/layout/leak_canary_ref_row.xml
index 947af46c..7a19621e 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_ref_row.xml
@@ -14,36 +14,38 @@
   ~ See the License for the specific language governing permissions and
   ~ limitations under the License.
   -->
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+<leakcanary.internal.RowElementLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:lib="http://schemas.android.com/apk/res-auto"
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
-    android:minHeight="48dp"
-    android:orientation="horizontal"
+    android:clipChildren="false"
     >
 
-  <com.squareup.leakcanary.internal.DisplayLeakConnectorView
+  <leakcanary.internal.DisplayLeakConnectorView
       android:id="@+id/leak_canary_row_connector"
-      android:layout_width="16dp"
-      android:layout_height="match_parent"
-      android:layout_marginStart="16dp"
-      android:layout_marginEnd="16dp"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      />
+
+  <leakcanary.internal.MoreDetailsView
+      android:id="@+id/leak_canary_row_more"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      lib:leak_canary_plus_color="@color/leak_canary_class_name"
       />
 
   <TextView
-      android:id="@+id/leak_canary_row_text"
-      android:layout_width="0dp"
-      android:layout_weight="1"
+      android:id="@+id/leak_canary_row_title"
+      android:layout_width="wrap_content"
       android:layout_height="wrap_content"
-      android:layout_gravity="center_vertical"
       />
 
-  <com.squareup.leakcanary.internal.MoreDetailsView
-      android:id="@+id/leak_canary_row_more"
-      android:layout_width="12dp"
-      android:layout_height="12dp"
-      android:layout_gravity="center_vertical"
-      android:layout_marginStart="16dp"
-      android:layout_marginEnd="16dp"
+  <TextView
+      android:id="@+id/leak_canary_row_details"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:visibility="gone"
       />
 
-</LinearLayout>
+</leakcanary.internal.RowElementLayout>
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_ref_top_row.xml
similarity index 89%
rename from leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
rename to leakcanary-android-core/src/main/res/layout/leak_canary_ref_top_row.xml
index c4803b76..4d70df54 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_ref_top_row.xml
@@ -21,7 +21,7 @@
     android:layout_height="wrap_content"
     android:layout_margin="16dp"
     android:textSize="18sp"
-    android:background="#84a6c5"
+    android:background="@color/leak_canary_class_name"
     android:padding="16dp"
-    android:textColor="#ffffff"
+    android:textColor="@color/leak_canary_background_color"
     />
diff --git a/leakcanary-android-core/src/main/res/mipmap-anydpi-v26/leak_canary_icon.xml b/leakcanary-android-core/src/main/res/mipmap-anydpi-v26/leak_canary_icon.xml
new file mode 100644
index 00000000..c58c886c
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/mipmap-anydpi-v26/leak_canary_icon.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
+  <background android:drawable="@color/leak_canary_icon_background"/>
+  <foreground android:drawable="@drawable/leak_canary_icon_foreground"/>
+</adaptive-icon>
diff --git a/leakcanary-android-core/src/main/res/mipmap-hdpi/leak_canary_icon.png b/leakcanary-android-core/src/main/res/mipmap-hdpi/leak_canary_icon.png
new file mode 100644
index 00000000..9ad0073e
Binary files /dev/null and b/leakcanary-android-core/src/main/res/mipmap-hdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android-core/src/main/res/mipmap-mdpi/leak_canary_icon.png b/leakcanary-android-core/src/main/res/mipmap-mdpi/leak_canary_icon.png
new file mode 100644
index 00000000..2166d069
Binary files /dev/null and b/leakcanary-android-core/src/main/res/mipmap-mdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android-core/src/main/res/mipmap-xhdpi/leak_canary_icon.png b/leakcanary-android-core/src/main/res/mipmap-xhdpi/leak_canary_icon.png
new file mode 100644
index 00000000..6aee0412
Binary files /dev/null and b/leakcanary-android-core/src/main/res/mipmap-xhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android-core/src/main/res/mipmap-xxhdpi/leak_canary_icon.png b/leakcanary-android-core/src/main/res/mipmap-xxhdpi/leak_canary_icon.png
new file mode 100644
index 00000000..e35493b9
Binary files /dev/null and b/leakcanary-android-core/src/main/res/mipmap-xxhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android-core/src/main/res/mipmap-xxxhdpi/leak_canary_icon.png b/leakcanary-android-core/src/main/res/mipmap-xxxhdpi/leak_canary_icon.png
new file mode 100644
index 00000000..a50f8e03
Binary files /dev/null and b/leakcanary-android-core/src/main/res/mipmap-xxxhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
new file mode 100644
index 00000000..b5b1e2c9
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
@@ -0,0 +1,75 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <string name="leak_canary_about_title">About LeakCanary</string>
+  <string name="leak_canary_about_message"><![CDATA[<a href="https://github.com/square/leakcanary">LeakCanary</a>
+  ist eine Memory-Leak-Detection Bibliothek für Android, erstellt von
+  <a href="https://twitter.com/Piwai">Pierre-Yves Ricau</a> und open-sourced von <a href="https://square.github.io">Square</a>.<br><br>
+  Wir begrüßen Contributions aus der Community, bitte zögert nicht
+  <a href="https://github.com/square/leakcanary/issues">Fehler zu reporten</a> oder ein Pull Request zu erstellen!<br>]]></string>
+  <string name="leak_canary_class_has_leaked">%1$s hat geleaked</string>
+  <string name="leak_canary_download_dump">Du kannst den Heap Dump unter \"Menu > Heap Dump teilen\" oder \"adb pull $1$s\" herunterladen</string>
+  <string name="leak_canary_analysis_failed">Leak Analyse fehlgeschlagen</string>
+  <string name="leak_canary_notification_analysing">Analysiere Heap Dump</string>
+  <string name="leak_canary_notification_dumping">Sichere Heap</string>
+  <string name="leak_canary_notification_foreground_text">LeakCanary ist beschäftigt.</string>
+  <string name="leak_canary_notification_message">Für mehr Details, hier klicken</string>
+  <string name="leak_canary_share_leak">Info teilen</string>
+  <string name="leak_canary_share_heap_dump">Heap Dump teilen</string>
+  <string name="leak_canary_share_with">Teilen mit…</string>
+  <string name="leak_canary_display_activity_label">Leaks</string>
+  <string name="leak_canary_storage_permission_activity_label">Storage Berechtigung</string>
+  <string name="leak_canary_toast_heap_dump">LeakCanary erstellt einen Heap Dump, die App wird einfrieren. Brrrr.</string>
+  <string name="leak_canary_delete">Löschen</string>
+  <string name="leak_canary_failure_report">"Bitte sende diesen Fehler an http://github.com/square/leakcanary"</string>
+  <string name="leak_canary_delete_all">Alle löschen</string>
+  <string name="leak_canary_delete_all_leaks_title">Bist du dir sicher, dass du alle Leaks löschen möchtest?</string>
+  <string name="leak_canary_permission_not_granted">Bitte gewähre die Storage Berechtigung, andernfalls werden Memory Leaks nicht erkannt.</string>
+  <string name="leak_canary_permission_notification_title">Leak erkannt, benötige Berechtigung</string>
+  <string name="leak_canary_permission_notification_text">Hier klicken, um Storage Berechtigung für %s zu aktivieren.</string>
+  <string name="leak_canary_shortcut_label">Leaks</string>
+  <string name="leak_canary_stackoverflow_share">Leak auf Stack Overflow teilen</string>
+  <string name="leak_canary_leak_copied">Leak Info in Zwischenablage kopiert</string>
+  <string name="leak_canary_leak_clipdata_label">LeakCanary Leak Trace</string>
+  <string name="leak_canary_options_menu_generate_hq_bitmap">HQ Bitmap generieren</string>
+  <string name="leak_canary_options_menu_permission_toast">Bitte erlaube zunächst die Speicher-Berechtigung, siehe Benachrichtigung…</string>
+  <string name="leak_canary_generating_hq_bitmap_toast_notice">Rendere HQ Bitmap, das könnte eine Weile dauern…</string>
+  <string name="leak_canary_generating_hq_bitmap_toast_failure_notice">Rendere HQ Bitmap, das könnte eine Weile dauern…</string>
+  <plurals name="leak_canary_heap_analysis_list_retained_instances">
+    <item quantity="one">%d erhaltene Instanz</item>
+    <item quantity="other">%d erhaltene Instanzen</item>
+  </plurals>
+  <string name="leak_canary_share_heap_dump_bitmap_screen_title">Heap Dump Bitmap teilen</string>
+  <string name="leak_canary_heap_dump_screen_title">Heap Dump %s</string>
+  <string name="leak_canary_analysis_deleted_title">Analyse gelöscht</string>
+  <string name="leak_canary_go_to_heap_analysis">Zur Heap Analyse</string>
+  <string name="leak_canary_heap_analysis_success_screen_title">Heap Analyse (%d erhaltene Instanzen)</string>
+  <string name="leak_canary_heap_analysis_success_screen_row_title">(%1$d / %2$d Gesamt) %3$s</string>
+  <string name="leak_canary_heap_analysis_success_screen_row_time_format">Neueste: %s</string>
+  <string name="leak_canary_heap_analysis_list_screen_title">Alle Analysen</string>
+  <plurals name="leak_canary_group_screen_title">
+    <item quantity="one">%1$d Leak in %2$s</item>
+    <item quantity="other">%1$d Leaks in %2$s</item>
+  </plurals>
+  <string name="leak_canary_group_list_screen_title">%d Leak Gruppen</string>
+  <string name="leak_canary_group_list_time_label">Neueste: %s</string>
+  <string name="leak_canary_import_from_title">Importieren von…</string>
+  <string name="leak_canary_options_menu_import_hprof_file">Hprof Datei importieren &amp; analysieren</string>
+  <string name="leak_canary_options_menu_see_analysis_list">Siehe Analyse-Liste</string>
+  <string name="leak_canary_options_menu_render_heap_dump">Heap Dump rendern</string>
+  <string name="leak_canary_heap_analysis_success_screen_no_path_to_instance_count">%d erhaltene Instanzen ohne Leaks</string>
+  <string name="leak_canary_help_title">Tippe hier, um mehr zu erfahren</string>
+</resources>
diff --git a/leakcanary-android/src/main/res/values-v21/leak_canary_themes.xml b/leakcanary-android-core/src/main/res/values-v21/leak_canary_themes.xml
similarity index 98%
rename from leakcanary-android/src/main/res/values-v21/leak_canary_themes.xml
rename to leakcanary-android-core/src/main/res/values-v21/leak_canary_themes.xml
index 0a43b8f9..bce4a40c 100644
--- a/leakcanary-android/src/main/res/values-v21/leak_canary_themes.xml
+++ b/leakcanary-android-core/src/main/res/values-v21/leak_canary_themes.xml
@@ -17,4 +17,4 @@
 <resources>
   <style name="leak_canary_LeakCanary.Base" parent="android:Theme.Material">
   </style>
-</resources>
\ No newline at end of file
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_int.xml b/leakcanary-android-core/src/main/res/values/leak_canary_attrs.xml
similarity index 78%
rename from leakcanary-android/src/main/res/values/leak_canary_int.xml
rename to leakcanary-android-core/src/main/res/values/leak_canary_attrs.xml
index b7197372..092508ba 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_int.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_attrs.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-  ~ Copyright (C) 2015 Square, Inc.
+  ~ Copyright (C) 2018 Square, Inc.
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
@@ -15,6 +15,7 @@
   ~ limitations under the License.
   -->
 <resources>
-  <integer name="leak_canary_max_stored_leaks">7</integer>
-  <integer name="leak_canary_watch_delay_millis">5000</integer>
+  <declare-styleable name="leak_canary_MoreDetailsView">
+    <attr name="leak_canary_plus_color" format="color" />
+  </declare-styleable>
 </resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_bools.xml b/leakcanary-android-core/src/main/res/values/leak_canary_bools.xml
new file mode 100644
index 00000000..88bbf123
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_bools.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <bool name="leak_canary_add_dynamic_shortcut">true</bool>
+  <bool name="leak_canary_add_launcher_icon">true</bool>
+</resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_colors.xml b/leakcanary-android-core/src/main/res/values/leak_canary_colors.xml
new file mode 100644
index 00000000..25ca9c8e
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_colors.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <color name="leak_canary_class_name">#bababa</color>
+  <color name="leak_canary_leak">#be383f</color>
+  <color name="leak_canary_reference">#9976a8</color>
+  <color name="leak_canary_extra">#919191</color>
+  <color name="leak_canary_help">#6a98b9</color>
+  <color name="leak_canary_background_color">#2b2b2b</color>
+  <color name="leak_canary_icon_background">#ffffff</color>
+  <color name="leak_canary_heap_stack_trace">#ffd40b</color>
+  <color name="leak_canary_heap_app">#00ffff</color>
+  <color name="leak_canary_heap_image">#039dff</color>
+  <color name="leak_canary_heap_zygote">#000a8b</color>
+  <color name="leak_canary_heap_instance">#72547a</color>
+  <color name="leak_canary_heap_load_class">#12580f</color>
+  <color name="leak_canary_heap_class_dump">#689959</color>
+  <color name="leak_canary_heap_hprof_string">#900000</color>
+  <color name="leak_canary_heap_instance_string">#ff0000</color>
+  <color name="leak_canary_heap_char_array">#ffa500</color>
+  <color name="leak_canary_heap_boolean_array">#383838</color>
+  <color name="leak_canary_heap_float_array">#4d4d4d</color>
+  <color name="leak_canary_heap_double_array">#4d4d4d</color>
+  <color name="leak_canary_heap_short_array">#797979</color>
+  <color name="leak_canary_heap_int_array">#797979</color>
+  <color name="leak_canary_heap_long_array">#797979</color>
+  <color name="leak_canary_heap_byte_array">#e23ff7</color>
+  <color name="leak_canary_heap_object_array">#ffffff</color>
+  <color name="leak_canary_heap_other">#000000</color>
+</resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_dimens.xml b/leakcanary-android-core/src/main/res/values/leak_canary_dimens.xml
new file mode 100644
index 00000000..5c445974
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_dimens.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <dimen name="leak_canary_squiggly_span_stroke_width">1dp</dimen>
+  <dimen name="leak_canary_squiggly_span_amplitude">1dp</dimen>
+  <!-- DP because the period increased with the density. -->
+  <dimen name="leak_canary_squiggly_span_period_degrees">4dp</dimen>
+  <dimen name="leak_canary_connector_center_y">24dp</dimen>
+  <dimen name="leak_canary_connector_stroke_size">2dp</dimen>
+  <dimen name="leak_canary_connector_leak_dash_line">5dp</dimen>
+  <dimen name="leak_canary_connector_leak_dash_gap">1dp</dimen>
+  <dimen name="leak_canary_more_stroke_width">2dp</dimen>
+  <dimen name="leak_canary_connector_width">16dp</dimen>
+  <dimen name="leak_canary_row_margins">16dp</dimen>
+  <dimen name="leak_canary_more_size">12dp</dimen>
+  <dimen name="leak_canary_more_margin_top">18dp</dimen>
+  <dimen name="leak_canary_row_min">48dp</dimen>
+  <dimen name="leak_canary_row_title_margin_top">14.5dp</dimen>
+  <dimen name="leak_canary_toast_icon_size">64dp</dimen>
+
+</resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml b/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
new file mode 100644
index 00000000..d352338b
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <item type="id" name="leak_canary_notification_write_permission" />
+  <item type="id" name="leak_canary_notification_analysis_result" />
+  <item type="id" name="leak_canary_notification_dumping_heap" />
+  <item type="id" name="leak_canary_notification_analyzing_heap" />
+  <item type="id" name="leak_canary_notification_retained_instances" />
+  <item type="id" name="leak_canary_notification_no_retained_instance_on_tap" />
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_public.xml b/leakcanary-android-core/src/main/res/values/leak_canary_public.xml
similarity index 81%
rename from leakcanary-android/src/main/res/values/leak_canary_public.xml
rename to leakcanary-android-core/src/main/res/values/leak_canary_public.xml
index b5f11b97..8947e504 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_public.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_public.xml
@@ -18,8 +18,8 @@
 
   <public name="leak_canary_display_activity_label" type="string"/>
   <public name="leak_canary_heap_dump_toast" type="layout"/>
-  <public name="leak_canary_icon" type="drawable"/>
-  <public name="leak_canary_max_stored_leaks" type="integer"/>
-  <public name="leak_canary_watch_delay_millis" type="integer"/>
+  <public name="leak_canary_icon" type="mipmap"/>
+  <public name="leak_canary_add_dynamic_shortcut" type="bool"/>
+  <public name="leak_canary_add_launcher_icon" type="bool"/>
 
 </resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
new file mode 100644
index 00000000..314fdf00
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
@@ -0,0 +1,87 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources xmlns:tools="http://schemas.android.com/tools" tools:ignore="MissingTranslation">
+  <string name="leak_canary_about_title">About LeakCanary</string>
+  <string name="leak_canary_about_message"><![CDATA[<a href="https://github.com/square/leakcanary">LeakCanary</a>
+  is a memory leak detection library for Android, created by
+  <a href="https://twitter.com/Piwai">Pierre-Yves Ricau</a> and open sourced by <a href="https://square.github.io">Square</a>.<br><br>
+  We welcome contributions from the community, please do not hesitate to
+  <a href="https://github.com/square/leakcanary/issues">report an issue</a> or open a pull request!<br>]]></string>
+  <string name="leak_canary_analysis_failed">Leak analysis failed</string>
+  <string name="leak_canary_analysis_success_notification">Analysis done: %1$d leaks (%2$d new, %3$d known, %4$d won\'t fix)</string>
+  <string name="leak_canary_class_has_leaked">%1$s Leaked</string>
+  <string name="leak_canary_download_dump">You can download the heap dump via \"Menu > Share Heap Dump\" or \"adb pull %1$s\"</string>
+  <string name="leak_canary_loading_title">Loading…</string>
+  <string name="leak_canary_notification_analysing">Analyzing Heap Dump</string>
+  <string name="leak_canary_notification_channel_low">LeakCanary Low Priority</string>
+  <string name="leak_canary_notification_channel_result">LeakCanary Result</string>
+  <string name="leak_canary_notification_dumping">Dumping Heap</string>
+  <string name="leak_canary_notification_foreground_text">LeakCanary is working.</string>
+  <string name="leak_canary_notification_message">Click for more details</string>
+  <string name="leak_canary_notification_no_retained_instance_title">All retained instances were garbage collected</string>
+  <string name="leak_canary_notification_no_retained_instance_content">Tap to dismiss</string>
+  <string name="leak_canary_notification_retained_debugger_attached">Waiting for debugger to detach</string>
+  <string name="leak_canary_notification_retained_dump_failed">Failed to dump heap</string>
+  <string name="leak_canary_notification_retained_title">%d retained instances, tap to dump heap</string>
+  <string name="leak_canary_notification_retained_visible">App visible, waiting until %d retained instances</string>
+  <string name="leak_canary_share_leak">Share Info</string>
+  <string name="leak_canary_share_heap_dump">Share Heap Dump</string>
+  <string name="leak_canary_share_with">Share with…</string>
+  <string name="leak_canary_display_activity_label">Leaks</string>
+  <string name="leak_canary_storage_permission_activity_label">Storage permission</string>
+  <string name="leak_canary_toast_heap_dump">LeakCanary is dumping the heap, app will freeze. Brrrr.</string>
+  <string name="leak_canary_delete">Delete</string>
+  <string name="leak_canary_failure_report">"Please report this failure to http://github.com/square/leakcanary and share the heapdump file that caused it."</string>
+  <string name="leak_canary_delete_all">Delete all</string>
+  <string name="leak_canary_delete_all_leaks_title">Are you sure you want to delete all leaks?</string>
+  <string name="leak_canary_permission_not_granted">Please grant external storage permission, otherwise memory leaks will not be detected.</string>
+  <string name="leak_canary_permission_notification_title">Leak detected, need permission</string>
+  <string name="leak_canary_permission_notification_text">Click to enable storage permission for %s.</string>
+  <string name="leak_canary_shortcut_label">Leaks</string>
+  <string name="leak_canary_stackoverflow_share">Share Leak On Stack Overflow</string>
+  <string name="leak_canary_leak_copied">Leak info copied to clipboard</string>
+  <string name="leak_canary_leak_clipdata_label">LeakCanary Leak Trace</string>
+  <string name="leak_canary_options_menu_generate_hq_bitmap">Generate HQ Bitmap</string>
+  <string name="leak_canary_options_menu_permission_toast">Please grant the External Storage Permission first, see notification…</string>
+  <string name="leak_canary_generating_hq_bitmap_toast_notice">Rendering HQ Bitmap, this may take a while…</string>
+  <string name="leak_canary_generating_hq_bitmap_toast_failure_notice">Rendering HQ Bitmap, this may take a while…</string>
+  <plurals name="leak_canary_heap_analysis_list_retained_instances">
+    <item quantity="one">%d Retained Instance</item>
+    <item quantity="other">%d Retained Instances</item>
+  </plurals>
+  <string name="leak_canary_share_heap_dump_bitmap_screen_title">Share Heap Dump Bitmap</string>
+  <string name="leak_canary_heap_dump_screen_title">Heap Dump %s</string>
+  <string name="leak_canary_analysis_deleted_title">Analysis Deleted</string>
+  <string name="leak_canary_go_to_heap_analysis">Go to Heap Analysis</string>
+  <string name="leak_canary_heap_analysis_success_screen_title">Heap Analysis (%d Retained Instances)</string>
+  <string name="leak_canary_heap_analysis_success_screen_row_title">(%1$d / %2$d Total) %3$s</string>
+  <string name="leak_canary_heap_analysis_success_screen_row_title_new">[NEW] (%1$d) %2$s</string>
+  <string name="leak_canary_heap_analysis_success_screen_row_time_format">Latest: %s</string>
+  <string name="leak_canary_heap_analysis_list_screen_title">All Analysis</string>
+  <plurals name="leak_canary_group_screen_title">
+    <item quantity="one">%1$d leak in %2$s</item>
+    <item quantity="other">%1$d leaks in %2$s</item>
+  </plurals>
+  <string name="leak_canary_group_list_screen_title">%d Leak Groups</string>
+  <string name="leak_canary_group_list_time_label">Latest: %s</string>
+  <string name="leak_canary_import_from_title">Import From…</string>
+  <string name="leak_canary_options_menu_import_hprof_file">Import &amp; Analyze Hprof File</string>
+  <string name="leak_canary_options_menu_see_analysis_list">See Analysis List</string>
+  <string name="leak_canary_options_menu_render_heap_dump">Render Heap Dump</string>
+  <string name="leak_canary_heap_analysis_success_screen_no_path_to_instance_count">%d non leaking retained instances</string>
+  <string name="leak_canary_help_title">Tap here to learn more</string>
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_themes.xml b/leakcanary-android-core/src/main/res/values/leak_canary_themes.xml
similarity index 99%
rename from leakcanary-android/src/main/res/values/leak_canary_themes.xml
rename to leakcanary-android-core/src/main/res/values/leak_canary_themes.xml
index eebd0333..2ca041d4 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_themes.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_themes.xml
@@ -15,7 +15,7 @@
   ~ limitations under the License.
   -->
 <resources>
-  <style name="leak_canary_LeakCanary.Base" parent="android:Theme">
+  <style name="leak_canary_LeakCanary.Base" parent="android:Theme.Holo">
   </style>
 
   <style name="leak_canary_Theme.Transparent" parent="android:Theme">
diff --git a/leakcanary-android-core/src/main/res/xml/leak_canary_file_paths.xml b/leakcanary-android-core/src/main/res/xml/leak_canary_file_paths.xml
new file mode 100644
index 00000000..05952829
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/xml/leak_canary_file_paths.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<paths>
+  <external-path name="downloads" path="Download/" />
+  <files-path name="leakcanary" path="leakcanary/" />
+
+</paths>
diff --git a/leakcanary-android-instrumentation/build.gradle b/leakcanary-android-instrumentation/build.gradle
new file mode 100644
index 00000000..02f90246
--- /dev/null
+++ b/leakcanary-android-instrumentation/build.gradle
@@ -0,0 +1,32 @@
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+
+dependencies {
+  api project(':leakcanary-android-core')
+
+  implementation deps.androidx.test.runner
+  implementation deps.kotlin.stdlib
+
+  androidTestImplementation deps.androidx.test.core
+  androidTestImplementation deps.androidx.test.espresso
+  androidTestImplementation deps.androidx.test.rules
+  androidTestImplementation deps.androidx.test.runner
+  androidTestImplementation deps.androidx.fragment
+}
+
+android {
+  compileSdkVersion versions.compileSdk
+  defaultConfig {
+    minSdkVersion versions.minSdk
+    testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
+  }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    // junit references java.lang.management
+    ignore 'InvalidPackage'
+    check 'Interoperability'
+  }
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android-instrumentation/gradle.properties b/leakcanary-android-instrumentation/gradle.properties
new file mode 100644
index 00000000..ab8ed750
--- /dev/null
+++ b/leakcanary-android-instrumentation/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-android-instrumentation
+POM_NAME=LeakCanary extension for Android instrumentation tests.
+POM_PACKAGING=aar
\ No newline at end of file
diff --git a/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
new file mode 100644
index 00000000..db8d12fe
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    package="com.squareup.leakcanary.instrumentation.test">
+  <!-- Disabled debuggable for accurate performance results -->
+  <application android:name="leakcanary.InstrumentationTestApplication"
+      android:debuggable="false"
+      tools:ignore="HardcodedDebugMode"
+      tools:replace="android:debuggable"
+      >
+    <activity android:name="leakcanary.TestActivity"/>
+  </application>
+</manifest>
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FailAnnotatedTestOnLeakRunListenerTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FailAnnotatedTestOnLeakRunListenerTest.kt
new file mode 100644
index 00000000..69aebdd7
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FailAnnotatedTestOnLeakRunListenerTest.kt
@@ -0,0 +1,36 @@
+package leakcanary
+
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertNull
+import org.junit.Test
+import org.junit.runner.Description
+
+/**
+ * Tests that the [FailAnnotatedTestOnLeakRunListenerTest] only detect leaks
+ * in instrumentation tests when the correct annotation is used
+ */
+class FailAnnotatedTestOnLeakRunListenerTest {
+
+  @FailTestOnLeak
+  @Test
+  fun detectsLeak() {
+    val annotation =
+      javaClass.getMethod("detectsLeak").getAnnotation(FailTestOnLeak::class.java)
+    val description = Description.createTestDescription("test", "Test mechanism", annotation)
+    val listener = FailAnnotatedTestOnLeakRunListener()
+    val method = listener.javaClass.getDeclaredMethod("skipLeakDetectionReason", Description::class.java)
+    method.isAccessible = true
+    val result = method.invoke(listener, description)
+    assertNull(result)
+  }
+
+  @Test
+  fun skipsLeakDetectionWithoutAnnotation() {
+    val description = Description.createTestDescription("test", "Test mechanism")
+    val listener = FailAnnotatedTestOnLeakRunListener()
+    val method = listener.javaClass.getDeclaredMethod("skipLeakDetectionReason", Description::class.java)
+    method.isAccessible = true
+    val result = method.invoke(listener, description)
+    assertEquals("test is not annotated with @FailTestOnLeak", result)
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
new file mode 100644
index 00000000..f8513a60
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
@@ -0,0 +1,113 @@
+package leakcanary
+
+import android.app.Activity
+import android.app.Application
+import android.os.Bundle
+import android.os.Looper
+import android.os.MessageQueue
+import android.view.View
+import androidx.test.core.app.ApplicationProvider.getApplicationContext
+import androidx.test.rule.ActivityTestRule
+import leakcanary.TestUtils.assertLeak
+import leakcanary.internal.InternalHelper.noOpDelegate
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import java.util.concurrent.CountDownLatch
+
+class FragmentLeakTest {
+
+  @get:Rule
+  var activityRule = ActivityTestRule(
+      TestActivity::class.java, !TOUCH_MODE, !LAUNCH_ACTIVITY
+  )
+
+  @Before fun setUp() {
+    LeakSentry.refWatcher
+        .clearWatchedInstances()
+  }
+
+  @After fun tearDown() {
+    LeakSentry.refWatcher
+        .clearWatchedInstances()
+  }
+
+  @Test
+  fun fragmentShouldLeak() {
+    startActivityAndWaitForCreate()
+
+    LeakingFragment.add(activityRule.activity)
+
+    val waitForFragmentDetach = activityRule.activity.waitForFragmentDetached()
+    val waitForActivityDestroy = waitForActivityDestroy()
+    activityRule.finishActivity()
+    waitForFragmentDetach.await()
+    waitForActivityDestroy.await()
+
+    assertLeak(LeakingFragment::class.java)
+  }
+
+  @Test
+  fun fragmentViewShouldLeak() {
+    startActivityAndWaitForCreate()
+    val activity = activityRule.activity
+
+    val waitForFragmentViewDestroyed = activity.waitForFragmentViewDestroyed()
+    // First, add a new fragment
+    ViewLeakingFragment.addToBackstack(activity)
+    // Then, add a new fragment again, which destroys the view of the previous fragment and puts
+    // that fragment in the backstack.
+    ViewLeakingFragment.addToBackstack(activity)
+    waitForFragmentViewDestroyed.await()
+
+    assertLeak(View::class.java)
+  }
+
+  private fun startActivityAndWaitForCreate() {
+    val waitForActivityOnCreate = CountDownLatch(1)
+    val app = getApplicationContext<Application>()
+    app.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
+      override fun onActivityCreated(
+        activity: Activity,
+        savedInstanceState: Bundle?
+      ) {
+        app.unregisterActivityLifecycleCallbacks(this)
+        waitForActivityOnCreate.countDown()
+      }
+    })
+
+    activityRule.launchActivity(null)
+
+    try {
+      waitForActivityOnCreate.await()
+    } catch (e: InterruptedException) {
+      throw RuntimeException(e)
+    }
+  }
+
+  private fun waitForActivityDestroy(): CountDownLatch {
+    val latch = CountDownLatch(1)
+    val countDownOnIdle = MessageQueue.IdleHandler {
+      latch.countDown()
+      false
+    }
+    val testActivity = activityRule.activity
+    testActivity.application.registerActivityLifecycleCallbacks(
+        object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
+          override fun onActivityDestroyed(activity: Activity) {
+            if (activity == testActivity) {
+              activity.application.unregisterActivityLifecycleCallbacks(this)
+              Looper.myQueue()
+                  .addIdleHandler(countDownOnIdle)
+            }
+          }
+        })
+    return latch
+  }
+
+  companion object {
+    private const val TOUCH_MODE = true
+    private const val LAUNCH_ACTIVITY = true
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Fragments.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Fragments.kt
new file mode 100644
index 00000000..87af731a
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Fragments.kt
@@ -0,0 +1,40 @@
+package leakcanary
+
+import androidx.fragment.app.Fragment
+import androidx.fragment.app.FragmentActivity
+import androidx.fragment.app.FragmentManager
+import java.util.concurrent.CountDownLatch
+
+internal fun FragmentActivity.waitForFragmentDetached(): CountDownLatch {
+  val latch = CountDownLatch(1)
+  val fragmentManager = supportFragmentManager
+  fragmentManager.registerFragmentLifecycleCallbacks(
+      object : FragmentManager.FragmentLifecycleCallbacks() {
+        override fun onFragmentDetached(
+          fm: FragmentManager,
+          f: Fragment
+        ) {
+          fragmentManager.unregisterFragmentLifecycleCallbacks(this)
+          latch.countDown()
+        }
+      }, false
+  )
+  return latch
+}
+
+internal fun FragmentActivity.waitForFragmentViewDestroyed(): CountDownLatch {
+  val latch = CountDownLatch(1)
+  val fragmentManager = supportFragmentManager
+  fragmentManager.registerFragmentLifecycleCallbacks(
+      object : FragmentManager.FragmentLifecycleCallbacks() {
+        override fun onFragmentViewDestroyed(
+          fm: FragmentManager,
+          f: Fragment
+        ) {
+          fragmentManager.unregisterFragmentLifecycleCallbacks(this)
+          latch.countDown()
+        }
+      }, false
+  )
+  return latch
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
new file mode 100644
index 00000000..3f15083f
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
@@ -0,0 +1,35 @@
+package leakcanary
+
+import leakcanary.TestUtils.assertLeak
+import org.junit.After
+import org.junit.Before
+import org.junit.Test
+import java.util.Date
+
+/**
+ * Tests that the [InstrumentationLeakDetector] can detect leaks
+ * in instrumentation tests
+ */
+class InstrumentationLeakDetectorTest {
+
+  @Before fun setUp() {
+    LeakSentry.refWatcher
+        .clearWatchedInstances()
+  }
+
+  @After fun tearDown() {
+    LeakSentry.refWatcher
+        .clearWatchedInstances()
+  }
+
+  @Test fun detectsLeak() {
+    leaking = Date()
+    val refWatcher = LeakSentry.refWatcher
+    refWatcher.watch(leaking)
+    assertLeak(Date::class.java)
+  }
+
+  companion object {
+    private lateinit var leaking: Any
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationTestApplication.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationTestApplication.kt
new file mode 100644
index 00000000..289621e0
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationTestApplication.kt
@@ -0,0 +1,10 @@
+package leakcanary
+
+import android.app.Application
+
+class InstrumentationTestApplication : Application() {
+  override fun onCreate() {
+    super.onCreate()
+    InstrumentationLeakDetector.updateConfig()
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LeakingFragment.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LeakingFragment.kt
new file mode 100644
index 00000000..316d11f1
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LeakingFragment.kt
@@ -0,0 +1,21 @@
+package leakcanary
+
+import androidx.fragment.app.Fragment
+
+import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
+
+class LeakingFragment : Fragment() {
+  companion object {
+    fun add(activity: TestActivity) {
+      getInstrumentation().runOnMainSync {
+        leakingFragment = LeakingFragment()
+        activity.supportFragmentManager
+            .beginTransaction()
+            .add(0, leakingFragment)
+            .commitNow()
+      }
+    }
+
+    private lateinit var leakingFragment: LeakingFragment
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestActivity.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestActivity.kt
new file mode 100644
index 00000000..d9d7367d
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestActivity.kt
@@ -0,0 +1,12 @@
+package leakcanary
+
+import android.os.Bundle
+import androidx.fragment.app.FragmentActivity
+import com.squareup.leakcanary.instrumentation.test.R
+
+class TestActivity : FragmentActivity() {
+  override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+    setContentView(R.layout.activity_test)
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
new file mode 100644
index 00000000..639e4d8d
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
@@ -0,0 +1,31 @@
+package leakcanary
+
+import leakcanary.InstrumentationLeakDetector.Result.AnalysisPerformed
+import leakcanary.InstrumentationLeakDetector.Result.NoAnalysis
+
+object TestUtils {
+  fun assertLeak(expectedLeakClass: Class<*>) {
+    val leakDetector = InstrumentationLeakDetector()
+    val result = leakDetector.detectLeaks()
+
+    val heapAnalysis = when (result) {
+      is NoAnalysis -> throw AssertionError("Expected analysis to be performed")
+      is AnalysisPerformed -> result.heapAnalysis
+    }
+
+    val applicationLeaks = heapAnalysis.applicationLeaks()
+    if (applicationLeaks.size != 1) {
+      throw AssertionError(
+          "Expected exactly one leak in $heapAnalysis"
+      )
+    }
+
+    val leakInstance = applicationLeaks.first()
+
+    if (leakInstance.instanceClassName != expectedLeakClass.name) {
+      throw AssertionError(
+          "Expected a leak of $expectedLeakClass, not ${leakInstance.instanceClassName} in $heapAnalysis"
+      )
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ViewLeakingFragment.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ViewLeakingFragment.kt
new file mode 100644
index 00000000..0ad9fd42
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ViewLeakingFragment.kt
@@ -0,0 +1,41 @@
+package leakcanary
+
+import android.os.Bundle
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import androidx.fragment.app.Fragment
+import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
+import com.squareup.leakcanary.instrumentation.test.R
+
+class ViewLeakingFragment : Fragment() {
+
+  private var leakingView: View? = null
+
+  override fun onCreateView(
+    inflater: LayoutInflater,
+    container: ViewGroup?,
+    savedInstanceState: Bundle?
+  ) = View(container?.context)
+
+  override fun onViewCreated(
+    view: View,
+    savedInstanceState: Bundle?
+  ) {
+    // Leak: this fragment will stay in memory after being replaced, leakingView should be cleared
+    // onDestroyView()
+    leakingView = view
+  }
+
+  companion object {
+    fun addToBackstack(activity: TestActivity) {
+      getInstrumentation().runOnMainSync {
+        activity.supportFragmentManager
+            .beginTransaction()
+            .addToBackStack(null)
+            .replace(R.id.fragments, ViewLeakingFragment())
+            .commit()
+      }
+    }
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/res/layout/activity_test.xml b/leakcanary-android-instrumentation/src/androidTest/res/layout/activity_test.xml
new file mode 100644
index 00000000..39664a73
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/res/layout/activity_test.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/fragments"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    />
diff --git a/leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml b/leakcanary-android-instrumentation/src/main/AndroidManifest.xml
similarity index 81%
rename from leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml
rename to leakcanary-android-instrumentation/src/main/AndroidManifest.xml
index 409cb66b..72e8cd5f 100644
--- a/leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml
+++ b/leakcanary-android-instrumentation/src/main/AndroidManifest.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-  ~ Copyright (C) 2015 Square, Inc.
+  ~ Copyright (C) 2018 Square, Inc.
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
@@ -14,7 +14,5 @@
   ~ See the License for the specific language governing permissions and
   ~ limitations under the License.
   -->
-<resources>
-  <style name="leak_canary_LeakCanary.Base" parent="android:Theme.Holo">
-  </style>
-</resources>
\ No newline at end of file
+<manifest package="com.squareup.leakcanary.instrumentation">
+</manifest>
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailAnnotatedTestOnLeakRunListener.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailAnnotatedTestOnLeakRunListener.kt
new file mode 100644
index 00000000..346cd239
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailAnnotatedTestOnLeakRunListener.kt
@@ -0,0 +1,22 @@
+package leakcanary
+
+import org.junit.runner.Description
+import org.junit.runner.notification.RunListener
+
+/**
+ *
+ * A JUnit [RunListener] subclassing [FailTestOnLeakRunListener] for detecting memory
+ * leaks in Android instrumentation tests only when the [FailTestOnLeak] annotation
+ * is used.
+ *
+ * @see FailTestOnLeak
+ */
+class FailAnnotatedTestOnLeakRunListener: FailTestOnLeakRunListener() {
+
+  override fun skipLeakDetectionReason(description: Description): String? {
+    return if (description.getAnnotation(FailTestOnLeak::class.java) != null)
+          null
+      else
+          "test is not annotated with @FailTestOnLeak"
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeak.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeak.kt
new file mode 100644
index 00000000..1721e18c
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeak.kt
@@ -0,0 +1,13 @@
+package leakcanary
+
+/**
+ *
+ * An [Annotation] class to be used in conjunction with [FailAnnotatedTestOnLeakRunListener]
+ * for detecting memory leaks. When using [FailAnnotatedTestOnLeakRunListener], the tests
+ * should be annotated with this class in order for the listener to detect memory leaks.
+ *
+ * @see FailAnnotatedTestOnLeakRunListener
+ */
+@Retention(AnnotationRetention.RUNTIME)
+@Target(AnnotationTarget.FUNCTION)
+annotation class FailTestOnLeak
\ No newline at end of file
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
new file mode 100644
index 00000000..cd470232
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import android.app.Instrumentation
+import android.os.Bundle
+import androidx.test.internal.runner.listener.InstrumentationResultPrinter
+import androidx.test.internal.runner.listener.InstrumentationResultPrinter.REPORT_VALUE_RESULT_FAILURE
+import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
+import leakcanary.InstrumentationLeakDetector.Result.AnalysisPerformed
+import org.junit.runner.Description
+import org.junit.runner.Result
+import org.junit.runner.notification.Failure
+import org.junit.runner.notification.RunListener
+
+/**
+ *
+ * A JUnit [RunListener] for detecting memory leaks in Android instrumentation tests. It
+ * waits for the end of a test, and if the test succeeds then it will look for leaking
+ * references, trigger a heap dump if needed and perform an analysis.
+ *
+ *  [FailTestOnLeakRunListener] can be subclassed to override
+ * [skipLeakDetectionReason], [reportLeaks]
+ * or [buildLeakDetectedMessage]
+ *
+ * @see InstrumentationLeakDetector
+ */
+open class FailTestOnLeakRunListener : RunListener() {
+  private lateinit var bundle: Bundle
+  private var skipLeakDetectionReason: String? = null
+
+  override fun testStarted(description: Description) {
+    skipLeakDetectionReason = skipLeakDetectionReason(description)
+    if (skipLeakDetectionReason != null) {
+      return
+    }
+    val testClass = description.className
+    val testName = description.methodName
+
+    bundle = Bundle()
+    bundle.putString(
+        Instrumentation.REPORT_KEY_IDENTIFIER, FailTestOnLeakRunListener::class.java.name
+    )
+    bundle.putString(InstrumentationResultPrinter.REPORT_KEY_NAME_CLASS, testClass)
+    bundle.putString(InstrumentationResultPrinter.REPORT_KEY_NAME_TEST, testName)
+  }
+
+  /**
+   * Can be overridden to skip leak detection based on the description provided when a test
+   * is started. Returns null to continue leak detection, or a string describing the reason for
+   * skipping otherwise.
+   */
+  protected open fun skipLeakDetectionReason(description: Description): String? {
+    return null
+  }
+
+  override fun testFailure(failure: Failure) {
+    skipLeakDetectionReason = "failed"
+  }
+
+  override fun testIgnored(description: Description) {
+    skipLeakDetectionReason = "was ignored"
+  }
+
+  override fun testAssumptionFailure(failure: Failure) {
+    skipLeakDetectionReason = "had an assumption failure"
+  }
+
+  override fun testFinished(description: Description) {
+    detectLeaks()
+    LeakSentry.refWatcher.clearWatchedInstances()
+  }
+
+  override fun testRunStarted(description: Description) {
+    InstrumentationLeakDetector.updateConfig()
+  }
+
+  override fun testRunFinished(result: Result) {}
+
+  private fun detectLeaks() {
+    if (skipLeakDetectionReason != null) {
+      CanaryLog.d("Skipping leak detection because the test %s", skipLeakDetectionReason)
+      skipLeakDetectionReason = null
+      return
+    }
+
+    val leakDetector = InstrumentationLeakDetector()
+    val result = leakDetector.detectLeaks()
+
+    if (result is AnalysisPerformed) {
+      val applicationLeaks = result.heapAnalysis.applicationLeaks()
+      if (applicationLeaks.isNotEmpty()) {
+        reportLeaks(result.heapAnalysis, applicationLeaks)
+      }
+    }
+  }
+
+  /** Can be overridden to report leaks in a different way or do additional reporting.  */
+  protected open fun reportLeaks(
+    heapAnalysis: HeapAnalysis,
+    applicationLeaks: List<LeakingInstance>
+  ) {
+    val message = buildLeakDetectedMessage(heapAnalysis, applicationLeaks)
+
+    bundle.putString(InstrumentationResultPrinter.REPORT_KEY_STACK, message)
+    getInstrumentation().sendStatus(REPORT_VALUE_RESULT_FAILURE, bundle)
+  }
+
+  /** Can be overridden to customize the failure string message.  */
+  protected open fun buildLeakDetectedMessage(
+    heapAnalysis: HeapAnalysis,
+    applicationLeaks: List<LeakingInstance>
+  ): String {
+    val failureMessage = StringBuilder()
+    failureMessage.append(
+        "Test failed because memory leaks were detected, see leak traces below.\n"
+    )
+    failureMessage.append(SEPARATOR)
+
+    applicationLeaks.forEach { applicationLeak ->
+      // TODO Improve rendering
+      failureMessage.append(applicationLeak.toString())
+      failureMessage.append("\n ")
+      failureMessage.append(SEPARATOR)
+    }
+
+    return failureMessage.toString()
+  }
+
+  companion object {
+    private const val SEPARATOR = "######################################\n"
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
new file mode 100644
index 00000000..3310522f
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import android.os.Debug
+import android.os.SystemClock
+import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
+import leakcanary.GcTrigger.Default.runGc
+import leakcanary.InstrumentationLeakDetector.Result.AnalysisPerformed
+import leakcanary.InstrumentationLeakDetector.Result.NoAnalysis
+import org.junit.runner.notification.RunListener
+import java.io.File
+
+/**
+ * TODO Update this doc to match LeakCanary 2.0
+ *
+ * [InstrumentationLeakDetector] can be used to detect memory leaks in instrumentation tests.
+ *
+ * To use it, you need to:
+ *
+ *  * Install a custom RefWatcher that will not trigger heapdumps while the tests run.
+ *  * Add an instrumentation test listener (a [RunListener]) that will invoke
+ * [detectLeaks]
+ *
+ * ### Installing the instrumentation RefWatcher
+ *
+ * For [detectLeaks] to work correctly, the [RefWatcher] must keep track of
+ * references but not trigger any heap dump until this [detectLeaks] runs, otherwise an
+ * analysis in progress might prevent this listener from performing its own analysis.
+ *
+ * Create and install the [RefWatcher] instance using
+ * [instrumentationRefWatcher] instead of
+ * [LeakCanary.install] or [LeakCanary.refWatcher].
+ *
+ * ```
+ * public class InstrumentationExampleApplication extends ExampleApplication {
+ *  @Override protected void setupLeakCanary() {
+ *    InstrumentationLeakDetector.instrumentationRefWatcher(this)
+ *      .buildAndInstall();
+ *  }
+ * }
+ * ```
+ *
+ * ### Add an instrumentation test listener
+ *
+ * LeakCanary provides [FailTestOnLeakRunListener], but you should feel free to implement
+ * your own [RunListener] and call [.detectLeaks] directly if you need a more custom
+ * behavior (for instance running it only once per test suite, or reporting to a backend).
+ *
+ * All you need to do is add the following to the defaultConfig of your build.gradle:
+ *
+ * `testInstrumentationRunnerArgument "listener", "leakcanary.FailTestOnLeakRunListener"`
+ *
+ * Then you can run your instrumentation tests via Gradle as usually, and they will fail when
+ * a memory leak is detected:
+ *
+ * `./gradlew leakcanary-sample:connectedCheck`
+ *
+ * If instead you want to run UI tests via adb, add a *listener* execution argument to
+ * your command line for running the UI tests:
+ * `-e listener leakcanary.FailTestOnLeakRunListener`. The full command line
+ * should look something like this:
+ * ```
+ * adb shell am instrument \\
+ * -w com.android.foo/android.support.test.runner.AndroidJUnitRunner \\
+ * -e listener leakcanary.FailTestOnLeakRunListener
+ * ```
+ *
+ * ### Rationale
+ * Instead of using the [FailTestOnLeakRunListener], one could simply enable LeakCanary in
+ * instrumentation tests.
+ *
+ * This approach would have two disadvantages:
+ *
+ *  * Heap dumps freeze the VM, and the leak analysis is IO and CPU heavy. This can slow down
+ * the test and introduce flakiness
+ *  * The leak analysis is asynchronous by default, and happens in a separate process. This means
+ * the tests could finish and the process die before the analysis is finished.
+ *
+ * The approach taken here is to collect all references to watch as you run the test, but not
+ * do any heap dump during the test. Then, at the end, if any of the watched objects is still in
+ * memory we dump the heap and perform a blocking analysis. There is only one heap dump performed,
+ * no matter the number of objects leaking.
+ */
+class InstrumentationLeakDetector {
+
+  sealed class Result {
+    object NoAnalysis : Result()
+    class AnalysisPerformed(val heapAnalysis: HeapAnalysis) : Result()
+  }
+
+  fun detectLeaks(): Result {
+    val leakDetectionTime = SystemClock.uptimeMillis()
+    val watchDurationMillis = LeakSentry.config.watchDurationMillis
+    val instrumentation = getInstrumentation()
+    val context = instrumentation.targetContext
+    val refWatcher = LeakSentry.refWatcher
+
+    if (!refWatcher.hasWatchedInstances) {
+      return NoAnalysis
+    }
+
+    instrumentation.waitForIdleSync()
+    if (!refWatcher.hasWatchedInstances) {
+      return NoAnalysis
+    }
+
+    runGc()
+    if (!refWatcher.hasWatchedInstances) {
+      return NoAnalysis
+    }
+
+    // Waiting for any delayed UI post (e.g. scroll) to clear. This shouldn't be needed, but
+    // Android simply has way too many delayed posts that aren't canceled when views are detached.
+    SystemClock.sleep(2000)
+
+    if (!refWatcher.hasWatchedInstances) {
+      return NoAnalysis
+    }
+
+    // Aaand we wait some more.
+    // 4 seconds (2+2) is greater than the 3 seconds delay for
+    // FINISH_TOKEN in android.widget.Filter
+    SystemClock.sleep(2000)
+
+    val endOfWatchDelay = watchDurationMillis - (SystemClock.uptimeMillis() - leakDetectionTime)
+    if (endOfWatchDelay > 0) {
+      SystemClock.sleep(endOfWatchDelay)
+    }
+
+    runGc()
+
+    if (!refWatcher.hasRetainedInstances) {
+      return NoAnalysis
+    }
+
+    // We're always reusing the same file since we only execute this once at a time.
+    val heapDumpFile = File(context.filesDir, "instrumentation_tests_heapdump.hprof")
+
+    val config = LeakCanary.config
+
+    val heapDumpUptimeMillis = SystemClock.uptimeMillis()
+    KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis
+
+    try {
+      Debug.dumpHprofData(heapDumpFile.absolutePath)
+    } catch (exception: Exception) {
+      CanaryLog.d(exception, "Could not dump heap")
+      return AnalysisPerformed(
+          HeapAnalysisFailure(
+              heapDumpFile, analysisDurationMillis = 0,
+              createdAtTimeMillis = System.currentTimeMillis(),
+              exception = HeapAnalysisException(exception)
+          )
+      )
+    }
+
+    refWatcher.removeInstancesRetainedBeforeHeapDump(heapDumpUptimeMillis)
+
+    val listener = AnalyzerProgressListener.NONE
+
+    val heapAnalyzer = HeapAnalyzer(listener)
+    val heapAnalysis = heapAnalyzer.checkForLeaks(
+        heapDumpFile, AndroidKnownReference.mapToExclusions(config.knownReferences), config.computeRetainedHeapSize,
+        config.leakTraceInspectors
+    )
+
+    CanaryLog.d("Heap Analysis:\n%s", heapAnalysis)
+
+    return AnalysisPerformed(heapAnalysis)
+  }
+
+  companion object {
+
+    /**
+     * Configures LeakCanary to not dump the heap so that instrumentation tests run smoothly,
+     * and we can look for leaks at the end of a test. This is automatically called by
+     * [FailTestOnLeakRunListener] when the tests start running.
+     */
+    fun updateConfig() {
+      LeakSentry.config = LeakSentry.config.copy(enabled = true)
+    }
+  }
+}
diff --git a/leakcanary-android-no-op/build.gradle b/leakcanary-android-no-op/build.gradle
deleted file mode 100644
index 5f3dc025..00000000
--- a/leakcanary-android-no-op/build.gradle
+++ /dev/null
@@ -1,33 +0,0 @@
-version rootProject.ext.VERSION_NAME
-group rootProject.ext.GROUP
-
-buildscript {
-  repositories {
-    mavenCentral()
-  }
-}
-
-apply plugin: 'com.android.library'
-
-repositories {
-  mavenCentral()
-}
-
-dependencies {
-}
-
-android {
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
-  defaultConfig {
-    minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.targetSdkVersion
-  }
-}
-
-task sourceJar(type: Jar) {
-  from 'src/main/java'
-}
-
-apply from: rootProject.file('gradle/checkstyle.gradle')
-apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/leakcanary-android-no-op/gradle.properties b/leakcanary-android-no-op/gradle.properties
deleted file mode 100644
index 60494b8a..00000000
--- a/leakcanary-android-no-op/gradle.properties
+++ /dev/null
@@ -1,2 +0,0 @@
-POM_ARTIFACT_ID=leakcanary-android-no-op
-POM_NAME=No op LeakCanary for Android
\ No newline at end of file
diff --git a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
deleted file mode 100644
index 8fc8a58c..00000000
--- a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package com.squareup.leakcanary;
-
-import android.app.Application;
-
-/**
- * A no-op version of {@link LeakCanary} that can be used in release builds.
- */
-public final class LeakCanary {
-
-  public static RefWatcher install(Application application) {
-    return RefWatcher.DISABLED;
-  }
-
-  private LeakCanary() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/RefWatcher.java
deleted file mode 100644
index ca9f6602..00000000
--- a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package com.squareup.leakcanary;
-
-/**
- * No-op implementation of {@link RefWatcher} for release builds. Please use {@link
- * RefWatcher#DISABLED}.
- */
-public final class RefWatcher {
-
-  public static final RefWatcher DISABLED = new RefWatcher();
-
-  private RefWatcher() {
-  }
-
-  public void watch(Object watchedReference) {
-  }
-
-  public void watch(Object watchedReference, String referenceName) {
-  }
-}
diff --git a/leakcanary-android-process/build.gradle b/leakcanary-android-process/build.gradle
new file mode 100644
index 00000000..2c2b98eb
--- /dev/null
+++ b/leakcanary-android-process/build.gradle
@@ -0,0 +1,24 @@
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+
+dependencies {
+  api project(':leakcanary-android-core')
+
+  implementation deps.kotlin.stdlib
+}
+
+android {
+  compileSdkVersion versions.compileSdk
+  defaultConfig {
+    minSdkVersion versions.minSdk
+  }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    // junit references java.lang.management
+    ignore 'InvalidPackage'
+    check 'Interoperability'
+  }
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android-process/gradle.properties b/leakcanary-android-process/gradle.properties
new file mode 100644
index 00000000..6227cda1
--- /dev/null
+++ b/leakcanary-android-process/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-android-process
+POM_NAME=LeakCanary Android running in a separate process
+POM_PACKAGING=aar
diff --git a/leakcanary-android-no-op/src/main/AndroidManifest.xml b/leakcanary-android-process/src/main/AndroidManifest.xml
similarity index 58%
rename from leakcanary-android-no-op/src/main/AndroidManifest.xml
rename to leakcanary-android-process/src/main/AndroidManifest.xml
index acd455c3..59728db4 100644
--- a/leakcanary-android-no-op/src/main/AndroidManifest.xml
+++ b/leakcanary-android-process/src/main/AndroidManifest.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-  ~ Copyright (C) 2015 Square, Inc.
+  ~ Copyright (C) 2018 Square, Inc.
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
@@ -14,8 +14,20 @@
   ~ See the License for the specific language governing permissions and
   ~ limitations under the License.
   -->
-<manifest
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.squareup.leakcanary.android.noop"
-    >
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.leakcanary">
+
+  <application>
+    <service
+        android:name="leakcanary.internal.HeapAnalyzerService"
+        android:exported="false"
+        android:process=":leakcanary"
+        >
+      <intent-filter>
+        <action android:name="leakcanary.ANALYSIS_ACTION"/>
+      </intent-filter>
+    </service>
+
+  </application>
+
 </manifest>
diff --git a/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt b/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt
new file mode 100644
index 00000000..39186f60
--- /dev/null
+++ b/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt
@@ -0,0 +1,101 @@
+package leakcanary
+
+import android.app.ActivityManager
+import android.app.Service
+import android.content.ComponentName
+import android.content.Context
+import android.content.pm.PackageInfo
+import android.content.pm.PackageManager
+import android.content.pm.ServiceInfo
+
+object LeakCanaryProcess {
+
+  @Volatile private var isInAnalyzerProcess: Boolean? = null
+
+  /**
+   * Whether the current process is the process running the heap analyzer, which is
+   * a different process than the normal app process.
+   */
+  fun isInAnalyzerProcess(context: Context): Boolean {
+    val analyzerServiceClass: Class<out Service>
+    @Suppress("UNCHECKED_CAST")
+    try {
+      analyzerServiceClass =
+        Class.forName("leakcanary.internal.HeapAnalyzerService") as Class<out Service>
+    } catch (e: Exception) {
+      return false
+    }
+
+    var isInAnalyzerProcess: Boolean? = isInAnalyzerProcess
+    // This only needs to be computed once per process.
+    if (isInAnalyzerProcess == null) {
+      isInAnalyzerProcess = isInServiceProcess(context, analyzerServiceClass)
+      this.isInAnalyzerProcess = isInAnalyzerProcess
+    }
+    return isInAnalyzerProcess
+  }
+
+  private fun isInServiceProcess(
+    context: Context,
+    serviceClass: Class<out Service>
+  ): Boolean {
+    val packageManager = context.packageManager
+    val packageInfo: PackageInfo
+    try {
+      packageInfo = packageManager.getPackageInfo(context.packageName, PackageManager.GET_SERVICES)
+    } catch (e: Exception) {
+      CanaryLog.d(e, "Could not get package info for %s", context.packageName)
+      return false
+    }
+
+    val mainProcess = packageInfo.applicationInfo.processName
+
+    val component = ComponentName(context, serviceClass)
+    val serviceInfo: ServiceInfo
+    try {
+      serviceInfo =
+        packageManager.getServiceInfo(component, PackageManager.GET_DISABLED_COMPONENTS)
+    } catch (ignored: PackageManager.NameNotFoundException) {
+      // Service is disabled.
+      return false
+    }
+
+    if (serviceInfo.processName == null) {
+      CanaryLog.d("Did not expect service %s to have a null process name", serviceClass)
+      return false
+    } else if (serviceInfo.processName == mainProcess) {
+      CanaryLog.d(
+          "Did not expect service %s to run in main process %s", serviceClass, mainProcess
+      )
+      // Technically we are in the service process, but we're not in the service dedicated process.
+      return false
+    }
+
+    val myPid = android.os.Process.myPid()
+    val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
+    var myProcess: ActivityManager.RunningAppProcessInfo? = null
+    val runningProcesses: List<ActivityManager.RunningAppProcessInfo>?
+    try {
+      runningProcesses = activityManager.runningAppProcesses
+    } catch (exception: SecurityException) {
+      // https://github.com/square/leakcanary/issues/948
+      CanaryLog.d("Could not get running app processes %d", exception)
+      return false
+    }
+
+    if (runningProcesses != null) {
+      for (process in runningProcesses) {
+        if (process.pid == myPid) {
+          myProcess = process
+          break
+        }
+      }
+    }
+    if (myProcess == null) {
+      CanaryLog.d("Could not find running process for %d", myPid)
+      return false
+    }
+
+    return myProcess.processName == serviceInfo.processName
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android/build.gradle b/leakcanary-android/build.gradle
index beb07063..2c2b98eb 100644
--- a/leakcanary-android/build.gradle
+++ b/leakcanary-android/build.gradle
@@ -1,42 +1,24 @@
-version rootProject.ext.VERSION_NAME
-group rootProject.ext.GROUP
-
-buildscript {
-  repositories {
-    mavenCentral()
-  }
-}
-
 apply plugin: 'com.android.library'
-
-repositories {
-  mavenCentral()
-}
+apply plugin: 'kotlin-android'
 
 dependencies {
-  compile project(':leakcanary-analyzer')
-}
+  api project(':leakcanary-android-core')
 
-def gitSha() {
-  return 'git rev-parse --short HEAD'.execute().text.trim()
+  implementation deps.kotlin.stdlib
 }
 
 android {
-  resourcePrefix 'leak_canary_'
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
+  compileSdkVersion versions.compileSdk
   defaultConfig {
-    minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.targetSdkVersion
-    buildConfigField "String", "LIBRARY_VERSION", "\"${rootProject.ext.VERSION_NAME}\""
-    buildConfigField "String", "GIT_SHA", "\"${gitSha()}\""
-    consumerProguardFiles 'consumer-proguard-rules.pro'
+    minSdkVersion versions.minSdk
+  }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    // junit references java.lang.management
+    ignore 'InvalidPackage'
+    check 'Interoperability'
   }
-}
-
-task sourceJar(type: Jar) {
-  from 'src/main/java'
 }
 
 apply from: rootProject.file('gradle/checkstyle.gradle')
-apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android/gradle.properties b/leakcanary-android/gradle.properties
index beee3e6f..e40174ac 100644
--- a/leakcanary-android/gradle.properties
+++ b/leakcanary-android/gradle.properties
@@ -1,2 +1,3 @@
 POM_ARTIFACT_ID=leakcanary-android
-POM_NAME=LeakCanary for Android
\ No newline at end of file
+POM_NAME=LeakCanary Android
+POM_PACKAGING=aar
diff --git a/leakcanary-android/src/main/AndroidManifest.xml b/leakcanary-android/src/main/AndroidManifest.xml
index b5393171..0ee35e1c 100644
--- a/leakcanary-android/src/main/AndroidManifest.xml
+++ b/leakcanary-android/src/main/AndroidManifest.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
-  ~ Copyright (C) 2015 Square, Inc.
+  ~ Copyright (C) 2018 Square, Inc.
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
@@ -14,46 +14,19 @@
   ~ See the License for the specific language governing permissions and
   ~ limitations under the License.
   -->
-<manifest
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.squareup.leakcanary"
-    >
-
-  <!-- To store the heap dumps and leak analysis results. -->
-  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
-  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.leakcanary">
 
   <application>
     <service
-        android:name=".internal.HeapAnalyzerService"
-        android:process=":leakcanary"
-        android:enabled="false"
-        />
-    <service
-        android:name=".DisplayLeakService"
-        android:enabled="false"
-        />
-    <activity
-        android:theme="@style/leak_canary_LeakCanary.Base"
-        android:name=".internal.DisplayLeakActivity"
-        android:enabled="false"
-        android:label="@string/leak_canary_display_activity_label"
-        android:icon="@drawable/leak_canary_icon"
-        android:taskAffinity="com.squareup.leakcanary"
+        android:name="leakcanary.internal.HeapAnalyzerService"
+        android:exported="false"
         >
       <intent-filter>
-        <action android:name="android.intent.action.MAIN"/>
-        <category android:name="android.intent.category.LAUNCHER"/>
+        <action android:name="leakcanary.ANALYSIS_ACTION"/>
       </intent-filter>
-    </activity>
-    <activity
-        android:theme="@style/leak_canary_Theme.Transparent"
-        android:name=".internal.RequestStoragePermissionActivity"
-        android:taskAffinity="com.squareup.leakcanary"
-        android:enabled="false"
-        android:icon="@drawable/leak_canary_icon"
-        android:label="@string/leak_canary_storage_permission_activity_label"
-        />
+    </service>
 
   </application>
+
 </manifest>
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
deleted file mode 100644
index 9b193831..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.app.IntentService;
-import android.content.Context;
-import android.content.Intent;
-
-public abstract class AbstractAnalysisResultService extends IntentService {
-
-  private static final String HEAP_DUMP_EXTRA = "heap_dump_extra";
-  private static final String RESULT_EXTRA = "result_extra";
-
-  public static void sendResultToListener(Context context, String listenerServiceClassName,
-      HeapDump heapDump, AnalysisResult result) {
-    Class<?> listenerServiceClass;
-    try {
-      listenerServiceClass = Class.forName(listenerServiceClassName);
-    } catch (ClassNotFoundException e) {
-      throw new RuntimeException(e);
-    }
-    Intent intent = new Intent(context, listenerServiceClass);
-    intent.putExtra(HEAP_DUMP_EXTRA, heapDump);
-    intent.putExtra(RESULT_EXTRA, result);
-    context.startService(intent);
-  }
-
-  public AbstractAnalysisResultService() {
-    super(AbstractAnalysisResultService.class.getName());
-  }
-
-  @Override protected final void onHandleIntent(Intent intent) {
-    HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAP_DUMP_EXTRA);
-    AnalysisResult result = (AnalysisResult) intent.getSerializableExtra(RESULT_EXTRA);
-    try {
-      onHeapAnalyzed(heapDump, result);
-    } finally {
-      //noinspection ResultOfMethodCallIgnored
-      heapDump.heapDumpFile.delete();
-    }
-  }
-
-  /**
-   * Called after a heap dump is analyzed, whether or not a leak was found.
-   * Check {@link AnalysisResult#leakFound} and {@link AnalysisResult#excludedLeak} to see if there
-   * was a leak and if it can be ignored.
-   *
-   * This will be called from a background intent service thread.
-   * <p>
-   * It's OK to block here and wait for the heap dump to be uploaded.
-   * <p>
-   * The heap dump file will be deleted immediately after this callback returns.
-   */
-  protected abstract void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result);
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
deleted file mode 100644
index 160e840f..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.Application;
-import android.os.Bundle;
-
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH;
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-
-@TargetApi(ICE_CREAM_SANDWICH) public final class ActivityRefWatcher {
-
-  public static void installOnIcsPlus(Application application, RefWatcher refWatcher) {
-    if (SDK_INT < ICE_CREAM_SANDWICH) {
-      // If you need to support Android < ICS, override onDestroy() in your base activity.
-      return;
-    }
-    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);
-    activityRefWatcher.watchActivities();
-  }
-
-  private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =
-      new Application.ActivityLifecycleCallbacks() {
-        @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
-        }
-
-        @Override public void onActivityStarted(Activity activity) {
-        }
-
-        @Override public void onActivityResumed(Activity activity) {
-        }
-
-        @Override public void onActivityPaused(Activity activity) {
-        }
-
-        @Override public void onActivityStopped(Activity activity) {
-        }
-
-        @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
-        }
-
-        @Override public void onActivityDestroyed(Activity activity) {
-          ActivityRefWatcher.this.onActivityDestroyed(activity);
-        }
-      };
-
-  private final Application application;
-  private final RefWatcher refWatcher;
-
-  /**
-   * Constructs an {@link ActivityRefWatcher} that will make sure the activities are not leaking
-   * after they have been destroyed.
-   */
-  public ActivityRefWatcher(Application application, final RefWatcher refWatcher) {
-    this.application = checkNotNull(application, "application");
-    this.refWatcher = checkNotNull(refWatcher, "refWatcher");
-  }
-
-  void onActivityDestroyed(Activity activity) {
-    refWatcher.watch(activity);
-  }
-
-  public void watchActivities() {
-    // Make sure you don't get installed twice.
-    stopWatchingActivities();
-    application.registerActivityLifecycleCallbacks(lifecycleCallbacks);
-  }
-
-  public void stopWatchingActivities() {
-    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks);
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java
deleted file mode 100644
index 7c58b997..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.os.Debug;
-
-public final class AndroidDebuggerControl implements DebuggerControl {
-  @Override public boolean isDebuggerAttached() {
-    return Debug.isDebuggerConnected();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
deleted file mode 100644
index e4a9dfd5..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
+++ /dev/null
@@ -1,488 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.lang.ref.PhantomReference;
-import java.lang.ref.SoftReference;
-import java.lang.ref.WeakReference;
-import java.util.EnumSet;
-
-import static android.os.Build.MANUFACTURER;
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.ECLAIR;
-import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH;
-import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1;
-import static android.os.Build.VERSION_CODES.JELLY_BEAN;
-import static android.os.Build.VERSION_CODES.KITKAT;
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
-import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
-import static android.os.Build.VERSION_CODES.M;
-import static com.squareup.leakcanary.AndroidWatchExecutor.LEAK_CANARY_THREAD_NAME;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.LG;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.MOTOROLA;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.NVIDIA;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.SAMSUNG;
-
-/**
- * This class is a work in progress. You can help by reporting leak traces that seem to be caused
- * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
- *
- * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
- * manufacturer implementation, they usually share their builds across multiple models, and the
- * leaks eventually get fixed in newer versions.
- *
- * Most app developers should use {@link #createAppDefaults()}. However, you can also pick the
- * leaks you want to ignore by creating an {@link EnumSet} that matches your needs and calling
- * {@link #createBuilder(EnumSet)}
- */
-public enum AndroidExcludedRefs {
-
-  ACTIVITY_CLIENT_RECORD__NEXT_IDLE(SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle")
-          .reason("Android AOSP sometimes keeps a reference to a destroyed activity as a"
-              + " nextIdle client record in the android.app.ActivityThread.mActivities map."
-              + " Not sure what's going on there, input welcome.");
-    }
-  },
-
-  SPAN_CONTROLLER(SDK_INT <= KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason =
-          "Editor inserts a special span, which has a reference to the EditText. That span is a"
-              + " NoCopySpan, which makes sure it gets dropped when creating a new"
-              + " SpannableStringBuilder from a given CharSequence."
-              + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
-              + " bundle. Prior to KitKat, that copy was done using the SpannableString"
-              + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
-              + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
-              + " reference to the textview and therefore the entire view hierarchy & activity"
-              + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
-              + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
-              + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
-              + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.";
-      excluded.instanceField("android.widget.Editor$EasyEditSpanController", "this$0")
-          .reason(reason);
-      excluded.instanceField("android.widget.Editor$SpanController", "this$0").reason(reason);
-    }
-  },
-
-  MEDIA_SESSION_LEGACY_HELPER__SINSTANCE(SDK_INT == LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance")
-          .reason("MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
-              + " keeps a reference to the context it's given the first time"
-              + " MediaSessionLegacyHelper.getHelper() is called."
-              + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
-              + " calling context.getApplicationContext()."
-              + " Fix: https://github.com/android/platform_frameworks_base/commit"
-              + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
-              + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
-              + " in Application.onCreate() and pass it the application context.");
-    }
-  },
-
-  TEXT_LINE__SCACHED(SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.text.TextLine", "sCached")
-          .reason("TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
-              + " at least two bugs that created memory leaks by not correctly clearing the"
-              + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
-              + " https://github.com/android/platform_frameworks_base/commit"
-              + "/893d6fe48d37f71e683f722457bea646994a10"
-              + " The second was fixed, not released yet:"
-              + " https://github.com/android/platform_frameworks_base/commit"
-              + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
-              + " To fix this, you could access TextLine.sCached and clear the pool every now"
-              + " and then (e.g. on activity destroy).");
-    }
-  },
-
-  BLOCKING_QUEUE(SDK_INT < LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason = "Prior to ART, a thread waiting on a blocking queue will leak the last"
-          + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
-          + " keeps a local reference to the last message it received. That message then gets"
-          + " recycled and can be used again. As long as all messages are recycled after being"
-          + "used, this won't be a problem, because these references are cleared when being"
-          + "recycled. However, dialogs create template Message instances to be copied when a"
-          + "message needs to be sent. These Message templates holds references to the dialog"
-          + "listeners, which most likely leads to holding a reference onto the activity in some"
-          + "way. Dialogs never recycle their template Message, assuming these Message instances"
-          + " will get GCed when the dialog is GCed."
-          + " The combination of these two things creates a high potential for memory leaks as soon"
-          + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
-          + " sleep for a long time."
-          + " To fix this, you could post empty messages to the idle handler threads from time to"
-          + " time. This won't be easy because you cannot access all handler threads, but a library"
-          + "that is widely used should consider doing this for its own handler threads.";
-      excluded.instanceField("android.os.Message", "obj").reason(reason);
-      excluded.instanceField("android.os.Message", "next").reason(reason);
-      excluded.instanceField("android.os.Message", "target").reason(reason);
-    }
-  },
-
-  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= M) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason = "When we detach a view that receives keyboard input, the InputMethodManager"
-          + " leaks a reference to it until a new view asks for keyboard input."
-          + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
-          + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414";
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView")
-          .reason(reason);
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView")
-          .reason(reason);
-      excluded.instanceField("android.view.inputmethod.InputMethodManager",
-          "mServedInputConnection").reason(reason);
-    }
-  },
-
-  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= M) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView")
-          .reason("The singleton InputMethodManager is holding a reference to mCurRootView long"
-              + " after the activity has been destroyed."
-              + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
-              + "#issuecomment-100579429"
-              + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414");
-    }
-  },
-
-  LAYOUT_TRANSITION(SDK_INT >= ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.animation.LayoutTransition$1", "val$parent")
-          .reason("LayoutTransition leaks parent ViewGroup through"
-              + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
-              + " window is destroyed. Tracked here:"
-              + " https://code.google.com/p/android/issues/detail?id=171830");
-    }
-  },
-
-  SPELL_CHECKER_SESSION(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0")
-          .reason("SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
-              + " SpellCheckerSession is closed before the service is connected."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542");
-    }
-  },
-
-  ACTIVITY_CHOOSE_MODEL(SDK_INT > ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason = "ActivityChooserModel holds a static reference to the last set"
-          + " ActivityChooserModelPolicy which can be an activity context."
-          + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
-          + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0";
-      excluded.instanceField("android.support.v7.internal.widget.ActivityChooserModel",
-          "mActivityChoserModelPolicy").reason(reason);
-      excluded.instanceField("android.widget.ActivityChooserModel", "mActivityChoserModelPolicy")
-          .reason(reason);
-    }
-  },
-
-  SPEECH_RECOGNIZER(SDK_INT < LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.speech.SpeechRecognizer$InternalListener", "this$0")
-          .reason("Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
-              + " class and leaked the SpeechRecognizer which leaked an activity context."
-              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
-              + " /b37866db469e81aca534ff6186bdafd44352329b");
-    }
-  },
-
-  ACCOUNT_MANAGER(SDK_INT > ECLAIR && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.accounts.AccountManager$AmsTask$Response", "this$1")
-          .reason("AccountManager$AmsTask$Response is a stub and is held in memory by native code,"
-              + " probably because the reference to the response in the other process hasn't been"
-              + " cleared."
-              + " AccountManager$AmsTask is holding on to the activity reference to use for"
-              + " launching a new sub- Activity."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
-              + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
-              + " with the returned future to to get the result and correctly start an activity"
-              + " when it's available.");
-    }
-  },
-
-  MEDIA_SCANNER_CONNECTION(SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.media.MediaScannerConnection", "mContext")
-          .reason("The static method MediaScannerConnection.scanFile() takes an activity context"
-              + " but the service might not disconnect after the activity has been destroyed."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
-              + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
-              + " application context. Call connect() and disconnect() manually.");
-    }
-  },
-
-  USER_MANAGER__SINSTANCE(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.os.UserManager", "mContext")
-          .reason("UserManager has a static sInstance field that creates an instance and caches it"
-              + " the first time UserManager.get() is called. This instance is created with the"
-              + " outer context (which is an activity base context)."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
-              + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
-              + "/27db46850b708070452c0ce49daf5f79503fbde6"
-              + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
-              + " UserManager instance gets cached with a reference to the application context.");
-    }
-  },
-
-  APP_WIDGET_HOST_CALLBACKS(SDK_INT < LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.appwidget.AppWidgetHost$Callbacks", "this$0")
-          .reason("android.appwidget.AppWidgetHost$Callbacks is a stub and is held in memory native"
-              + " code. The reference to the `mContext` was not being cleared, which caused the"
-              + " Callbacks instance to retain this reference"
-              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
-              + "/7a96f3c917e0001ee739b65da37b2fadec7d7765");
-    }
-  },
-
-  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER(MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      if (MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-        excluded.instanceField("android.app.admin.DevicePolicyManager$SettingsObserver", "this$0")
-            .reason("DevicePolicyManager keeps a reference to the context it has been created with"
-                + " instead of extracting the application context. In this Motorola build,"
-                + " DevicePolicyManager has an inner SettingsObserver class that is a content"
-                + " observer, which is held into memory by a binder transport object.");
-      }
-    }
-  },
-
-  SPEN_GESTURE_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext")
-          .reason("SpenGestureManager has a static mContext field that leaks a reference to the"
-              + " activity. Yes, a STATIC mContext field.");
-    }
-  },
-
-  CLIPBOARD_UI_MANAGER__SINSTANCE(
-      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.sec.clipboard.ClipboardUIManager", "mContext")
-          .reason("ClipboardUIManager is a static singleton that leaks an activity context."
-              + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
-              + " , so that the ClipboardUIManager instance gets cached with a reference to the"
-              + " application context. Example: https://gist.github.com/pepyakin"
-              + "/8d2221501fd572d4a61c");
-    }
-  },
-
-  BUBBLE_POPUP_HELPER__SHELPER(
-      LG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.widget.BubblePopupHelper", "sHelper")
-          .reason("A static helper for EditText bubble popups leaks a reference to the latest"
-              + "focused view.");
-    }
-  },
-
-  AW_RESOURCE__SRESOURCES(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // AwResource#setResources() is called with resources that hold a reference to the
-      // activity context (instead of the application context) and doesn't clear it.
-      // Not sure what's going on there, input welcome.
-      excluded.staticField("com.android.org.chromium.android_webview.AwResource", "sResources");
-    }
-  },
-
-  MAPPER_CLIENT(NVIDIA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient$ServiceClient", "this$0")
-          .reason("Not sure exactly what ControllerMapper is about, but there is an anonymous"
-              + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
-              + " ControllerMapper.MapperClient which leaks the activity context.");
-    }
-  },
-
-  TEXT_VIEW__MLAST_HOVERED_VIEW(
-      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.widget.TextView", "mLastHoveredView")
-          .reason("mLastHoveredView is a static field in TextView that leaks the last hovered"
-              + " view.");
-    }
-  },
-
-  PERSONA_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.os.PersonaManager", "mContext")
-          .reason("android.app.LoadedApk.mResources has a reference to"
-              + " android.content.res.Resources.mPersonaManager which has a reference to"
-              + " android.os.PersonaManager.mContext which is an activity.");
-    }
-  },
-
-  RESOURCES__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.content.res.Resources", "mContext")
-          .reason("In AOSP the Resources class does not have a context."
-              + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
-              + " instance that has a context that is the activity."
-              + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184");
-    }
-  },
-
-  VIEW_CONFIGURATION__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.view.ViewConfiguration", "mContext")
-          .reason("In AOSP the ViewConfiguration class does not have a context."
-              + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
-              + " ViewConfiguration instance that has a context that is the activity."
-              + " Observed here: https://github.com/square/leakcanary/issues"
-              + "/1#issuecomment-100324683");
-    }
-  },
-
-  AUDIO_MANAGER__MCONTEXT_STATIC(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.media.AudioManager", "mContext_static")
-          .reason("Samsung added a static mContext_static field to AudioManager, holds a reference"
-              + " to the activity."
-              + " Observed here: https://github.com/square/leakcanary/issues/32");
-    }
-  },
-
-  AUDIO_MANAGER(SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.media.AudioManager$1", "this$0")
-          .reason("Prior to Android M, VideoView required audio focus from AudioManager and"
-              + " never abandoned it, which leaks the Activity context through the AudioManager."
-              + " The root of the problem is that AudioManager uses whichever"
-              + " context it receives, which in the case of the VideoView example is an Activity,"
-              + " even though it only needs the application's context. The issue is fixed in"
-              + " Android M, and the AudioManager now uses the application's context."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
-              + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2");
-    }
-  },
-
-  EDITTEXT_BLINK_MESSAGEQUEUE {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.widget.Editor$Blink", "this$0")
-          .reason("The EditText Blink of the Cursor is implemented using a callback and Messages,"
-              + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
-              + " contains a blinking cursor is detached a message is posted with a delay after the"
-              + " dialog has been closed and as a result leaks the Activity."
-              + " This can be fixed manually by calling setCursorEnabled(false) in the dismiss()"
-              + " method of the dialog."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
-              + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
-              + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/");
-    }
-  },
-
-  SERVICE_BINDER {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // We should ignore leaks where an android.os.Binder is the root of the leak.
-      // When you bind and unbind from a Service, the OS will keep a reference to the Binder
-      // until the client binder has been GC'ed. This means the Binder can be retained after
-      // Service.onDestroy() is called.
-      excluded.rootClass("android.os.Binder").alwaysExclude();
-    }
-  },
-
-  SOFT_REFERENCES {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.clazz(WeakReference.class.getName()).alwaysExclude();
-      excluded.clazz(SoftReference.class.getName()).alwaysExclude();
-      excluded.clazz(PhantomReference.class.getName()).alwaysExclude();
-      excluded.clazz("java.lang.ref.Finalizer").alwaysExclude();
-      excluded.clazz("java.lang.ref.FinalizerReference").alwaysExclude();
-    }
-  },
-
-  FINALIZER_WATCHDOG_DAEMON {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
-      // reference to the object and it was about to be GCed.
-      excluded.thread("FinalizerWatchdogDaemon").alwaysExclude();
-    }
-  },
-
-  MAIN {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // The main thread stack is ever changing so local variables aren't likely to hold references
-      // for long. If this is on the shortest path, it's probably that there's a longer path with
-      // a real leak.
-      excluded.thread("main").alwaysExclude();
-    }
-  },
-
-  LEAK_CANARY_THREAD {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.thread(LEAK_CANARY_THREAD_NAME).alwaysExclude();
-    }
-  },
-
-  EVENT_RECEIVER__MMESSAGE_QUEUE {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
-      // the native peer of the receiver is using them.
-      // The main thread message queue is held on by the main Looper, but that might be a longer
-      // path. Let's not confuse people with a shorter path that is less meaningful.
-      excluded.instanceField("android.view.Choreographer$FrameDisplayEventReceiver",
-          "mMessageQueue").alwaysExclude();
-    }
-  };
-
-  /**
-   * This returns the references in the leak path that should be ignored by all on Android.
-   */
-  public static ExcludedRefs.Builder createAndroidDefaults() {
-    return createBuilder(
-        EnumSet.of(SOFT_REFERENCES, FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
-            EVENT_RECEIVER__MMESSAGE_QUEUE, SERVICE_BINDER));
-  }
-
-  /**
-   * This returns the references in the leak path that can be ignored for app developers. This
-   * doesn't mean there is no memory leak, to the contrary. However, some leaks are caused by bugs
-   * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
-   * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
-   */
-  public static ExcludedRefs.Builder createAppDefaults() {
-    return createBuilder(EnumSet.allOf(AndroidExcludedRefs.class));
-  }
-
-  public static ExcludedRefs.Builder createBuilder(EnumSet<AndroidExcludedRefs> refs) {
-    ExcludedRefs.Builder excluded = ExcludedRefs.builder();
-    for (AndroidExcludedRefs ref : refs) {
-      if (ref.applies) {
-        ref.add(excluded);
-        ((ExcludedRefs.BuilderWithParams) excluded).named(ref.name());
-      }
-    }
-    return excluded;
-  }
-
-  final boolean applies;
-
-  AndroidExcludedRefs() {
-    this(true);
-  }
-
-  AndroidExcludedRefs(boolean applies) {
-    this.applies = applies;
-  }
-
-  abstract void add(ExcludedRefs.Builder excluded);
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
deleted file mode 100644
index c46435f3..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.content.Context;
-import android.os.Debug;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.MessageQueue;
-import android.view.Gravity;
-import android.view.LayoutInflater;
-import android.widget.Toast;
-import com.squareup.leakcanary.internal.FutureResult;
-import com.squareup.leakcanary.internal.LeakCanaryInternals;
-import java.io.File;
-import java.io.IOException;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-
-public final class AndroidHeapDumper implements HeapDumper {
-
-  private static final String HEAPDUMP_FILE = "suspected_leak_heapdump.hprof";
-
-  final Context context;
-  final LeakDirectoryProvider leakDirectoryProvider;
-  private final Handler mainHandler;
-
-  public AndroidHeapDumper(Context context, LeakDirectoryProvider leakDirectoryProvider) {
-    this.leakDirectoryProvider = leakDirectoryProvider;
-    this.context = context.getApplicationContext();
-    mainHandler = new Handler(Looper.getMainLooper());
-  }
-
-  @Override public File dumpHeap() {
-    if (!leakDirectoryProvider.isLeakStorageWritable()) {
-      CanaryLog.d("Could not write to leak storage to dump heap.");
-      leakDirectoryProvider.requestWritePermissionNotification();
-      return NO_DUMP;
-    }
-    File heapDumpFile = getHeapDumpFile();
-    // Atomic way to check for existence & create the file if it doesn't exist.
-    // Prevents several processes in the same app to attempt a heapdump at the same time.
-    boolean fileCreated;
-    try {
-      fileCreated = heapDumpFile.createNewFile();
-    } catch (IOException e) {
-      cleanup();
-      CanaryLog.d(e, "Could not check if heap dump file exists");
-      return NO_DUMP;
-    }
-
-    if (!fileCreated) {
-      CanaryLog.d("Could not dump heap, previous analysis still is in progress.");
-      // Heap analysis in progress, let's not put too much pressure on the device.
-      return NO_DUMP;
-    }
-
-    FutureResult<Toast> waitingForToast = new FutureResult<>();
-    showToast(waitingForToast);
-
-    if (!waitingForToast.wait(5, SECONDS)) {
-      CanaryLog.d("Did not dump heap, too much time waiting for Toast.");
-      return NO_DUMP;
-    }
-
-    Toast toast = waitingForToast.get();
-    try {
-      Debug.dumpHprofData(heapDumpFile.getAbsolutePath());
-      cancelToast(toast);
-      return heapDumpFile;
-    } catch (Exception e) {
-      cleanup();
-      CanaryLog.d(e, "Could not perform heap dump");
-      // Abort heap dump
-      return NO_DUMP;
-    }
-  }
-
-  /**
-   * Call this on app startup to clean up all heap dump files that had not been handled yet when
-   * the app process was killed.
-   */
-  public void cleanup() {
-    LeakCanaryInternals.executeOnFileIoThread(new Runnable() {
-      @Override public void run() {
-        if (!leakDirectoryProvider.isLeakStorageWritable()) {
-          CanaryLog.d("Could not attempt cleanup, leak storage not writable.");
-          return;
-        }
-        File heapDumpFile = getHeapDumpFile();
-        if (heapDumpFile.exists()) {
-          CanaryLog.d("Previous analysis did not complete correctly, cleaning: %s", heapDumpFile);
-          boolean success = heapDumpFile.delete();
-          if (!success) {
-            CanaryLog.d("Could not delete file %s", heapDumpFile.getPath());
-          }
-        }
-      }
-    });
-  }
-
-  File getHeapDumpFile() {
-    return new File(leakDirectoryProvider.leakDirectory(), HEAPDUMP_FILE);
-  }
-
-  private void showToast(final FutureResult<Toast> waitingForToast) {
-    mainHandler.post(new Runnable() {
-      @Override public void run() {
-        final Toast toast = new Toast(context);
-        toast.setGravity(Gravity.CENTER_VERTICAL, 0, 0);
-        toast.setDuration(Toast.LENGTH_LONG);
-        LayoutInflater inflater = LayoutInflater.from(context);
-        toast.setView(inflater.inflate(R.layout.leak_canary_heap_dump_toast, null));
-        toast.show();
-        // Waiting for Idle to make sure Toast gets rendered.
-        Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
-          @Override public boolean queueIdle() {
-            waitingForToast.set(toast);
-            return false;
-          }
-        });
-      }
-    });
-  }
-
-  private void cancelToast(final Toast toast) {
-    mainHandler.post(new Runnable() {
-      @Override public void run() {
-        toast.cancel();
-      }
-    });
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
deleted file mode 100644
index 8f8eff4b..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.MessageQueue;
-import java.util.concurrent.Executor;
-
-/**
- * {@link Executor} suitable for watching Android reference leaks. This executor waits for the main
- * thread to be idle then posts to a serial background thread with a delay of
- * {@link R.integer#leak_canary_watch_delay_millis} seconds.
- */
-public final class AndroidWatchExecutor implements Executor {
-
-  static final String LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump";
-  private final Handler mainHandler;
-  final Handler backgroundHandler;
-  final long delayMillis;
-
-  public AndroidWatchExecutor(int delayMillis) {
-    mainHandler = new Handler(Looper.getMainLooper());
-    HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);
-    handlerThread.start();
-    backgroundHandler = new Handler(handlerThread.getLooper());
-    this.delayMillis = delayMillis;
-  }
-
-  @Override public void execute(final Runnable command) {
-    if (isOnMainThread()) {
-      executeDelayedAfterIdleUnsafe(command);
-    } else {
-      mainHandler.post(new Runnable() {
-        @Override public void run() {
-          executeDelayedAfterIdleUnsafe(command);
-        }
-      });
-    }
-  }
-
-  private boolean isOnMainThread() {
-    return Looper.getMainLooper().getThread() == Thread.currentThread();
-  }
-
-  void executeDelayedAfterIdleUnsafe(final Runnable runnable) {
-    // This needs to be called from the main thread.
-    Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
-      @Override public boolean queueIdle() {
-        backgroundHandler.postDelayed(runnable, delayMillis);
-        return false;
-      }
-    });
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
deleted file mode 100644
index b4e288db..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package com.squareup.leakcanary;
-
-import android.util.Log;
-
-public final class CanaryLog {
-
-  private static volatile Logger logger = new DefaultLogger();
-
-  public interface Logger {
-    void d(String message, Object... args);
-
-    void d(Throwable throwable, String message, Object... args);
-  }
-
-  private static class DefaultLogger implements Logger {
-    DefaultLogger() { }
-
-    @Override public void d(String message, Object... args) {
-      String formatted = String.format(message, args);
-      if (formatted.length() < 4000) {
-        Log.d("LeakCanary", formatted);
-      } else {
-        String[] lines = formatted.split("\n");
-        for (String line : lines) {
-          Log.d("LeakCanary", line);
-        }
-      }
-    }
-
-    @Override public void d(Throwable throwable, String message, Object... args) {
-      d(String.format(message, args) + '\n' + Log.getStackTraceString(throwable));
-    }
-  }
-
-  public static void setLogger(Logger logger) {
-    CanaryLog.logger = logger;
-  }
-
-  public static void d(String message, Object... args) {
-    // Local variable to prevent the ref from becoming null after the null check.
-    Logger logger = CanaryLog.logger;
-    if (logger == null) {
-      return;
-    }
-    logger.d(message, args);
-  }
-
-  public static void d(Throwable throwable, String message, Object... args) {
-    // Local variable to prevent the ref from becoming null after the null check.
-    Logger logger = CanaryLog.logger;
-    if (logger == null) {
-      return;
-    }
-    logger.d(throwable, message, args);
-  }
-
-  private CanaryLog() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
deleted file mode 100644
index 812b6e64..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.PendingIntent;
-import android.content.Context;
-import android.os.Environment;
-import com.squareup.leakcanary.internal.RequestStoragePermissionActivity;
-import java.io.File;
-
-import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
-import static android.content.pm.PackageManager.PERMISSION_GRANTED;
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.M;
-import static android.os.Environment.DIRECTORY_DOWNLOADS;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.showNotification;
-
-public final class DefaultLeakDirectoryProvider implements LeakDirectoryProvider {
-
-  private final Context context;
-
-  public DefaultLeakDirectoryProvider(Context context) {
-    this.context = context.getApplicationContext();
-  }
-
-  @Override public File leakDirectory() {
-    File downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS);
-    File directory = new File(downloadsDirectory, "leakcanary-" + context.getPackageName());
-    boolean success = directory.mkdirs();
-    if (!success && !directory.exists()) {
-      throw new UnsupportedOperationException(
-          "Could not create leak directory " + directory.getPath());
-    }
-    return directory;
-  }
-
-  @Override public void requestWritePermissionNotification() {
-    if (hasStoragePermission()) {
-      return;
-    }
-    PendingIntent pendingIntent = RequestStoragePermissionActivity.createPendingIntent(context);
-    String contentTitle = context.getString(R.string.leak_canary_permission_notification_title);
-    CharSequence packageName = context.getPackageName();
-    String contentText =
-        context.getString(R.string.leak_canary_permission_notification_text, packageName);
-    showNotification(context, contentTitle, contentText, pendingIntent);
-  }
-
-  @TargetApi(M) @Override public void requestPermission(Activity activity) {
-    if (hasStoragePermission()) {
-      return;
-    }
-    String[] permissions = {
-        WRITE_EXTERNAL_STORAGE
-    };
-    activity.requestPermissions(permissions, 42);
-  }
-
-  @Override public boolean isLeakStorageWritable() {
-    if (!hasStoragePermission()) {
-      return false;
-    }
-    String state = Environment.getExternalStorageState();
-    return Environment.MEDIA_MOUNTED.equals(state);
-  }
-
-  @TargetApi(M) private boolean hasStoragePermission() {
-    if (SDK_INT < M) {
-      return true;
-    }
-    return context.checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED;
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
deleted file mode 100644
index afdc4e94..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.app.PendingIntent;
-import android.content.res.Resources;
-import com.squareup.leakcanary.internal.DisplayLeakActivity;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.FilenameFilter;
-import java.io.IOException;
-import java.io.ObjectOutputStream;
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Comparator;
-import java.util.Date;
-import java.util.Locale;
-
-import static android.text.format.Formatter.formatShortFileSize;
-import static com.squareup.leakcanary.LeakCanary.leakInfo;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.classSimpleName;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.showNotification;
-
-/**
- * Logs leak analysis results, and then shows a notification which will start {@link
- * DisplayLeakActivity}.
- *
- * You can extend this class and override {@link #afterDefaultHandling(HeapDump, AnalysisResult,
- * String)} to add custom behavior, e.g. uploading the heap dump.
- */
-public class DisplayLeakService extends AbstractAnalysisResultService {
-
-  @Override protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
-    String leakInfo = leakInfo(this, heapDump, result, true);
-    CanaryLog.d(leakInfo);
-
-    boolean resultSaved = false;
-    boolean shouldSaveResult = result.leakFound || result.failure != null;
-    if (shouldSaveResult) {
-      heapDump = renameHeapdump(heapDump);
-      resultSaved = saveResult(heapDump, result);
-    }
-
-    PendingIntent pendingIntent;
-    String contentTitle;
-    String contentText;
-
-    if (!shouldSaveResult) {
-      contentTitle = getString(R.string.leak_canary_no_leak_title);
-      contentText = getString(R.string.leak_canary_no_leak_text);
-      pendingIntent = null;
-    } else if (resultSaved) {
-      pendingIntent = DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);
-
-      if (result.failure == null) {
-        String size = formatShortFileSize(this, result.retainedHeapSize);
-        String className = classSimpleName(result.className);
-        if (result.excludedLeak) {
-          contentTitle = getString(R.string.leak_canary_leak_excluded, className, size);
-        } else {
-          contentTitle = getString(R.string.leak_canary_class_has_leaked, className, size);
-        }
-      } else {
-        contentTitle = getString(R.string.leak_canary_analysis_failed);
-      }
-      contentText = getString(R.string.leak_canary_notification_message);
-    } else {
-      contentTitle = getString(R.string.leak_canary_could_not_save_title);
-      contentText = getString(R.string.leak_canary_could_not_save_text);
-      pendingIntent = null;
-    }
-    showNotification(this, contentTitle, contentText, pendingIntent);
-    afterDefaultHandling(heapDump, result, leakInfo);
-  }
-
-  private boolean saveResult(HeapDump heapDump, AnalysisResult result) {
-    File resultFile = new File(heapDump.heapDumpFile.getParentFile(),
-        heapDump.heapDumpFile.getName() + ".result");
-    FileOutputStream fos = null;
-    try {
-      fos = new FileOutputStream(resultFile);
-      ObjectOutputStream oos = new ObjectOutputStream(fos);
-      oos.writeObject(heapDump);
-      oos.writeObject(result);
-      return true;
-    } catch (IOException e) {
-      CanaryLog.d(e, "Could not save leak analysis result to disk.");
-    } finally {
-      if (fos != null) {
-        try {
-          fos.close();
-        } catch (IOException ignored) {
-        }
-      }
-    }
-    return false;
-  }
-
-  private HeapDump renameHeapdump(HeapDump heapDump) {
-    String fileName =
-        new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'.hprof'", Locale.US).format(new Date());
-
-    File newFile = new File(heapDump.heapDumpFile.getParent(), fileName);
-    boolean renamed = heapDump.heapDumpFile.renameTo(newFile);
-    if (!renamed) {
-      CanaryLog.d("Could not rename heap dump file %s to %s", heapDump.heapDumpFile.getPath(),
-          newFile.getPath());
-    }
-    heapDump =
-        new HeapDump(newFile, heapDump.referenceKey, heapDump.referenceName, heapDump.excludedRefs,
-            heapDump.watchDurationMs, heapDump.gcDurationMs, heapDump.heapDumpDurationMs);
-
-    Resources resources = getResources();
-    int maxStoredHeapDumps =
-        Math.max(resources.getInteger(R.integer.leak_canary_max_stored_leaks), 1);
-    File[] hprofFiles = heapDump.heapDumpFile.getParentFile().listFiles(new FilenameFilter() {
-      @Override public boolean accept(File dir, String filename) {
-        return filename.endsWith(".hprof");
-      }
-    });
-
-    if (hprofFiles.length > maxStoredHeapDumps) {
-      // Sort with oldest modified first.
-      Arrays.sort(hprofFiles, new Comparator<File>() {
-        @Override public int compare(File lhs, File rhs) {
-          return Long.valueOf(lhs.lastModified()).compareTo(rhs.lastModified());
-        }
-      });
-      boolean deleted = hprofFiles[0].delete();
-      if (!deleted) {
-        CanaryLog.d("Could not delete old hprof file %s", hprofFiles[0].getPath());
-      }
-    }
-    return heapDump;
-  }
-
-  /**
-   * You can override this method and do a blocking call to a server to upload the leak trace and
-   * the heap dump. Don't forget to check {@link AnalysisResult#leakFound} and {@link
-   * AnalysisResult#excludedLeak} first.
-   */
-  protected void afterDefaultHandling(HeapDump heapDump, AnalysisResult result, String leakInfo) {
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
deleted file mode 100644
index 1081ae34..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.app.Application;
-import android.content.Context;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.res.Resources;
-import android.os.Build;
-import android.util.Log;
-import com.squareup.leakcanary.internal.DisplayLeakActivity;
-import com.squareup.leakcanary.internal.HeapAnalyzerService;
-
-import static android.text.format.Formatter.formatShortFileSize;
-import static com.squareup.leakcanary.BuildConfig.GIT_SHA;
-import static com.squareup.leakcanary.BuildConfig.LIBRARY_VERSION;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.isInServiceProcess;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabled;
-
-public final class LeakCanary {
-
-  /**
-   * Creates a {@link RefWatcher} that works out of the box, and starts watching activity
-   * references (on ICS+).
-   */
-  public static RefWatcher install(Application application) {
-    return install(application, DisplayLeakService.class,
-        AndroidExcludedRefs.createAppDefaults().build());
-  }
-
-  /**
-   * Creates a {@link RefWatcher} that reports results to the provided service, and starts watching
-   * activity references (on ICS+).
-   */
-  public static RefWatcher install(Application application,
-      Class<? extends AbstractAnalysisResultService> listenerServiceClass,
-      ExcludedRefs excludedRefs) {
-    if (isInAnalyzerProcess(application)) {
-      return RefWatcher.DISABLED;
-    }
-    enableDisplayLeakActivity(application);
-    HeapDump.Listener heapDumpListener =
-        new ServiceHeapDumpListener(application, listenerServiceClass);
-    RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);
-    ActivityRefWatcher.installOnIcsPlus(application, refWatcher);
-    return refWatcher;
-  }
-
-  /**
-   * Creates a {@link RefWatcher} with a default configuration suitable for Android.
-   */
-  public static RefWatcher androidWatcher(Context context, HeapDump.Listener heapDumpListener,
-      ExcludedRefs excludedRefs) {
-    LeakDirectoryProvider leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
-    DebuggerControl debuggerControl = new AndroidDebuggerControl();
-    AndroidHeapDumper heapDumper = new AndroidHeapDumper(context, leakDirectoryProvider);
-    heapDumper.cleanup();
-    Resources resources = context.getResources();
-    int watchDelayMillis = resources.getInteger(R.integer.leak_canary_watch_delay_millis);
-    AndroidWatchExecutor executor = new AndroidWatchExecutor(watchDelayMillis);
-    return new RefWatcher(executor, debuggerControl, GcTrigger.DEFAULT, heapDumper,
-        heapDumpListener, excludedRefs);
-  }
-
-  public static void enableDisplayLeakActivity(Context context) {
-    setEnabled(context, DisplayLeakActivity.class, true);
-  }
-
-  public static void setDisplayLeakActivityDirectoryProvider(
-      LeakDirectoryProvider leakDirectoryProvider) {
-    DisplayLeakActivity.setLeakDirectoryProvider(leakDirectoryProvider);
-  }
-
-  /** Returns a string representation of the result of a heap analysis. */
-  public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult result,
-      boolean detailed) {
-    PackageManager packageManager = context.getPackageManager();
-    String packageName = context.getPackageName();
-    PackageInfo packageInfo;
-    try {
-      packageInfo = packageManager.getPackageInfo(packageName, 0);
-    } catch (PackageManager.NameNotFoundException e) {
-      throw new RuntimeException(e);
-    }
-    String versionName = packageInfo.versionName;
-    int versionCode = packageInfo.versionCode;
-    String info = "In " + packageName + ":" + versionName + ":" + versionCode + ".\n";
-    String detailedString = "";
-    if (result.leakFound) {
-      if (result.excludedLeak) {
-        info += "* EXCLUDED LEAK.\n";
-      }
-      info += "* " + result.className;
-      if (!heapDump.referenceName.equals("")) {
-        info += " (" + heapDump.referenceName + ")";
-      }
-      info += " has leaked:\n" + result.leakTrace.toString() + "\n";
-      info += "* Retaining: " + formatShortFileSize(context, result.retainedHeapSize) + ".\n";
-      if (detailed) {
-        detailedString = "\n* Details:\n" + result.leakTrace.toDetailedString();
-      }
-    } else if (result.failure != null) {
-      // We duplicate the library version & Sha information because bug reports often only contain
-      // the stacktrace.
-      info += "* FAILURE in " + LIBRARY_VERSION + " " + GIT_SHA + ":" + Log.getStackTraceString(
-          result.failure) + "\n";
-    } else {
-      info += "* NO LEAK FOUND.\n\n";
-    }
-    if (detailed) {
-      detailedString += "* Excluded Refs:\n" + heapDump.excludedRefs;
-    }
-
-    info += "* Reference Key: "
-        + heapDump.referenceKey
-        + "\n"
-        + "* Device: "
-        + Build.MANUFACTURER
-        + " "
-        + Build.BRAND
-        + " "
-        + Build.MODEL
-        + " "
-        + Build.PRODUCT
-        + "\n"
-        + "* Android Version: "
-        + Build.VERSION.RELEASE
-        + " API: "
-        + Build.VERSION.SDK_INT
-        + " LeakCanary: "
-        + LIBRARY_VERSION
-        + " "
-        + GIT_SHA
-        + "\n"
-        + "* Durations: watch="
-        + heapDump.watchDurationMs
-        + "ms, gc="
-        + heapDump.gcDurationMs
-        + "ms, heap dump="
-        + heapDump.heapDumpDurationMs
-        + "ms, analysis="
-        + result.analysisDurationMs
-        + "ms"
-        + "\n"
-        + detailedString;
-
-    return info;
-  }
-
-  /**
-   * Whether the current process is the process running the {@link HeapAnalyzerService}, which is
-   * a different process than the normal app process.
-   */
-  public static boolean isInAnalyzerProcess(Context context) {
-    return isInServiceProcess(context, HeapAnalyzerService.class);
-  }
-
-  private LeakCanary() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
deleted file mode 100644
index 1e7ebf87..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.app.Activity;
-import java.io.File;
-
-/**
- * Provides the directory in which heap dumps and analysis results will be stored.
- * When using your own implementation, you may also want to call {@link
- * LeakCanary#setDisplayLeakActivityDirectoryProvider(LeakDirectoryProvider)}.
- */
-public interface LeakDirectoryProvider {
-
-  /** Returns a path to an existing directory were leaks can be stored. */
-  File leakDirectory();
-
-  void requestWritePermissionNotification();
-
-  void requestPermission(Activity activity);
-
-  /** True if we can currently write to the leak directory. */
-  boolean isLeakStorageWritable();
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
deleted file mode 100644
index 2ccb1422..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.content.Context;
-import com.squareup.leakcanary.internal.HeapAnalyzerService;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabled;
-
-public final class ServiceHeapDumpListener implements HeapDump.Listener {
-
-  private final Context context;
-  private final Class<? extends AbstractAnalysisResultService> listenerServiceClass;
-
-  public ServiceHeapDumpListener(Context context,
-      Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
-    setEnabled(context, listenerServiceClass, true);
-    setEnabled(context, HeapAnalyzerService.class, true);
-    this.listenerServiceClass = checkNotNull(listenerServiceClass, "listenerServiceClass");
-    this.context = checkNotNull(context, "context").getApplicationContext();
-  }
-
-  @Override public void analyze(HeapDump heapDump) {
-    checkNotNull(heapDump, "heapDump");
-    HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass);
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
deleted file mode 100644
index 4ab1baf2..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
+++ /dev/null
@@ -1,522 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.PendingIntent;
-import android.content.Context;
-import android.content.Intent;
-import android.net.Uri;
-import android.os.Build;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Looper;
-import android.text.format.DateUtils;
-import android.util.Log;
-import android.view.LayoutInflater;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.AdapterView;
-import android.widget.BaseAdapter;
-import android.widget.Button;
-import android.widget.ListAdapter;
-import android.widget.ListView;
-import android.widget.TextView;
-import com.squareup.leakcanary.AnalysisResult;
-import com.squareup.leakcanary.CanaryLog;
-import com.squareup.leakcanary.DefaultLeakDirectoryProvider;
-import com.squareup.leakcanary.HeapDump;
-import com.squareup.leakcanary.LeakDirectoryProvider;
-import com.squareup.leakcanary.R;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FilenameFilter;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-import java.util.concurrent.Executor;
-
-import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
-import static android.text.format.DateUtils.FORMAT_SHOW_DATE;
-import static android.text.format.DateUtils.FORMAT_SHOW_TIME;
-import static android.text.format.Formatter.formatShortFileSize;
-import static android.view.View.GONE;
-import static android.view.View.VISIBLE;
-import static com.squareup.leakcanary.BuildConfig.GIT_SHA;
-import static com.squareup.leakcanary.BuildConfig.LIBRARY_VERSION;
-import static com.squareup.leakcanary.LeakCanary.leakInfo;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.newSingleThreadExecutor;
-
-@SuppressWarnings("ConstantConditions") @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-public final class DisplayLeakActivity extends Activity {
-
-  private static LeakDirectoryProvider leakDirectoryProvider = null;
-
-  private static final String SHOW_LEAK_EXTRA = "show_latest";
-
-  public static PendingIntent createPendingIntent(Context context) {
-    return createPendingIntent(context, null);
-  }
-
-  public static PendingIntent createPendingIntent(Context context, String referenceKey) {
-    Intent intent = new Intent(context, DisplayLeakActivity.class);
-    intent.putExtra(SHOW_LEAK_EXTRA, referenceKey);
-    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
-    return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);
-  }
-
-  public static void setLeakDirectoryProvider(LeakDirectoryProvider leakDirectoryProvider) {
-    DisplayLeakActivity.leakDirectoryProvider = leakDirectoryProvider;
-  }
-
-  private static LeakDirectoryProvider leakDirectoryProvider(Context context) {
-    LeakDirectoryProvider leakDirectoryProvider = DisplayLeakActivity.leakDirectoryProvider;
-    if (leakDirectoryProvider == null) {
-      leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
-    }
-    return leakDirectoryProvider;
-  }
-
-  // null until it's been first loaded.
-  List<Leak> leaks;
-  String visibleLeakRefKey;
-
-  private ListView listView;
-  private TextView failureView;
-  private Button actionButton;
-
-  @Override protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-
-    if (savedInstanceState != null) {
-      visibleLeakRefKey = savedInstanceState.getString("visibleLeakRefKey");
-    } else {
-      Intent intent = getIntent();
-      if (intent.hasExtra(SHOW_LEAK_EXTRA)) {
-        visibleLeakRefKey = intent.getStringExtra(SHOW_LEAK_EXTRA);
-      }
-    }
-
-    //noinspection unchecked
-    leaks = (List<Leak>) getLastNonConfigurationInstance();
-
-    setContentView(R.layout.leak_canary_display_leak);
-
-    listView = (ListView) findViewById(R.id.leak_canary_display_leak_list);
-    failureView = (TextView) findViewById(R.id.leak_canary_display_leak_failure);
-    actionButton = (Button) findViewById(R.id.leak_canary_action);
-
-    updateUi();
-  }
-
-  // No, it's not deprecated. Android lies.
-  @Override public Object onRetainNonConfigurationInstance() {
-    return leaks;
-  }
-
-  @Override protected void onSaveInstanceState(Bundle outState) {
-    super.onSaveInstanceState(outState);
-    outState.putString("visibleLeakRefKey", visibleLeakRefKey);
-  }
-
-  @Override protected void onResume() {
-    super.onResume();
-    LeakDirectoryProvider leakDirectoryProvider = leakDirectoryProvider(this);
-    if (leakDirectoryProvider.isLeakStorageWritable()) {
-      File leakDirectory = leakDirectoryProvider.leakDirectory();
-      LoadLeaks.load(this, leakDirectory);
-    } else {
-      leakDirectoryProvider.requestPermission(this);
-    }
-  }
-
-  @Override public void setTheme(int resid) {
-    // We don't want this to be called with an incompatible theme.
-    // This could happen if you implement runtime switching of themes
-    // using ActivityLifecycleCallbacks.
-    if (resid != R.style.leak_canary_LeakCanary_Base) {
-      return;
-    }
-    super.setTheme(resid);
-  }
-
-  @Override protected void onDestroy() {
-    super.onDestroy();
-    LoadLeaks.forgetActivity();
-  }
-
-  @Override public boolean onCreateOptionsMenu(Menu menu) {
-    Leak visibleLeak = getVisibleLeak();
-    if (visibleLeak != null) {
-      menu.add(R.string.leak_canary_share_leak)
-          .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
-            @Override public boolean onMenuItemClick(MenuItem item) {
-              shareLeak();
-              return true;
-            }
-          });
-      if (visibleLeak.heapDump.heapDumpFile.exists()) {
-        menu.add(R.string.leak_canary_share_heap_dump)
-            .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
-              @Override public boolean onMenuItemClick(MenuItem item) {
-                shareHeapDump();
-                return true;
-              }
-            });
-      }
-      return true;
-    }
-    return false;
-  }
-
-  @Override public boolean onOptionsItemSelected(MenuItem item) {
-    if (item.getItemId() == android.R.id.home) {
-      visibleLeakRefKey = null;
-      updateUi();
-    }
-    return true;
-  }
-
-  @Override public void onBackPressed() {
-    if (visibleLeakRefKey != null) {
-      visibleLeakRefKey = null;
-      updateUi();
-    } else {
-      super.onBackPressed();
-    }
-  }
-
-  void shareLeak() {
-    Leak visibleLeak = getVisibleLeak();
-    String leakInfo = leakInfo(this, visibleLeak.heapDump, visibleLeak.result, true);
-    Intent intent = new Intent(Intent.ACTION_SEND);
-    intent.setType("text/plain");
-    intent.putExtra(Intent.EXTRA_TEXT, leakInfo);
-    startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
-  }
-
-  void shareHeapDump() {
-    Leak visibleLeak = getVisibleLeak();
-    File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
-    heapDumpFile.setReadable(true, false);
-    Intent intent = new Intent(Intent.ACTION_SEND);
-    intent.setType("application/octet-stream");
-    intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(heapDumpFile));
-    startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
-  }
-
-  void deleteVisibleLeak() {
-    Leak visibleLeak = getVisibleLeak();
-    File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
-    File resultFile = visibleLeak.resultFile;
-    boolean resultDeleted = resultFile.delete();
-    if (!resultDeleted) {
-      CanaryLog.d("Could not delete result file %s", resultFile.getPath());
-    }
-    boolean heapDumpDeleted = heapDumpFile.delete();
-    if (!heapDumpDeleted) {
-      CanaryLog.d("Could not delete heap dump file %s", heapDumpFile.getPath());
-    }
-    visibleLeakRefKey = null;
-    leaks.remove(visibleLeak);
-    updateUi();
-  }
-
-  void deleteAllLeaks() {
-    File leakDirectory = leakDirectoryProvider(DisplayLeakActivity.this).leakDirectory();
-    File[] files = leakDirectory.listFiles();
-    if (files != null) {
-      for (File file : files) {
-        boolean deleted = file.delete();
-        if (!deleted) {
-          CanaryLog.d("Could not delete file %s", file.getPath());
-        }
-      }
-    }
-    leaks = Collections.emptyList();
-    updateUi();
-  }
-
-  void updateUi() {
-    if (leaks == null) {
-      setTitle("Loading leaks...");
-      return;
-    }
-    if (leaks.isEmpty()) {
-      visibleLeakRefKey = null;
-    }
-
-    final Leak visibleLeak = getVisibleLeak();
-    if (visibleLeak == null) {
-      visibleLeakRefKey = null;
-    }
-
-    ListAdapter listAdapter = listView.getAdapter();
-    // Reset to defaults
-    listView.setVisibility(VISIBLE);
-    failureView.setVisibility(GONE);
-
-    if (visibleLeak != null) {
-      AnalysisResult result = visibleLeak.result;
-      if (result.failure != null) {
-        listView.setVisibility(GONE);
-        failureView.setVisibility(VISIBLE);
-        String failureMessage = getString(R.string.leak_canary_failure_report)
-            + LIBRARY_VERSION
-            + " "
-            + GIT_SHA
-            + "\n"
-            + Log.getStackTraceString(result.failure);
-        failureView.setText(failureMessage);
-        setTitle(R.string.leak_canary_analysis_failed);
-        invalidateOptionsMenu();
-        getActionBar().setDisplayHomeAsUpEnabled(true);
-        actionButton.setVisibility(VISIBLE);
-        actionButton.setText(R.string.leak_canary_delete);
-        actionButton.setOnClickListener(new View.OnClickListener() {
-          @Override public void onClick(View v) {
-            deleteVisibleLeak();
-          }
-        });
-        listView.setAdapter(null);
-      } else {
-        final DisplayLeakAdapter adapter;
-        if (listAdapter instanceof DisplayLeakAdapter) {
-          adapter = (DisplayLeakAdapter) listAdapter;
-        } else {
-          adapter = new DisplayLeakAdapter();
-          listView.setAdapter(adapter);
-          listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-            @Override
-            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-              adapter.toggleRow(position);
-            }
-          });
-          invalidateOptionsMenu();
-          getActionBar().setDisplayHomeAsUpEnabled(true);
-          actionButton.setVisibility(VISIBLE);
-          actionButton.setText(R.string.leak_canary_delete);
-          actionButton.setOnClickListener(new View.OnClickListener() {
-            @Override public void onClick(View v) {
-              deleteVisibleLeak();
-            }
-          });
-        }
-        HeapDump heapDump = visibleLeak.heapDump;
-        adapter.update(result.leakTrace, heapDump.referenceKey, heapDump.referenceName);
-        String size = formatShortFileSize(this, result.retainedHeapSize);
-        String className = classSimpleName(result.className);
-        setTitle(getString(R.string.leak_canary_class_has_leaked, className, size));
-      }
-    } else {
-      if (listAdapter instanceof LeakListAdapter) {
-        ((LeakListAdapter) listAdapter).notifyDataSetChanged();
-      } else {
-        LeakListAdapter adapter = new LeakListAdapter();
-        listView.setAdapter(adapter);
-        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-          @Override
-          public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-            visibleLeakRefKey = leaks.get(position).heapDump.referenceKey;
-            updateUi();
-          }
-        });
-        invalidateOptionsMenu();
-        setTitle(getString(R.string.leak_canary_leak_list_title, getPackageName()));
-        getActionBar().setDisplayHomeAsUpEnabled(false);
-        actionButton.setText(R.string.leak_canary_delete_all);
-        actionButton.setOnClickListener(new View.OnClickListener() {
-          @Override public void onClick(View v) {
-            deleteAllLeaks();
-          }
-        });
-      }
-      actionButton.setVisibility(leaks.size() == 0 ? GONE : VISIBLE);
-    }
-  }
-
-  Leak getVisibleLeak() {
-    if (leaks == null) {
-      return null;
-    }
-    for (Leak leak : leaks) {
-      if (leak.heapDump.referenceKey.equals(visibleLeakRefKey)) {
-        return leak;
-      }
-    }
-    return null;
-  }
-
-  class LeakListAdapter extends BaseAdapter {
-
-    @Override public int getCount() {
-      return leaks.size();
-    }
-
-    @Override public Leak getItem(int position) {
-      return leaks.get(position);
-    }
-
-    @Override public long getItemId(int position) {
-      return position;
-    }
-
-    @Override public View getView(int position, View convertView, ViewGroup parent) {
-      if (convertView == null) {
-        convertView = LayoutInflater.from(DisplayLeakActivity.this)
-            .inflate(R.layout.leak_canary_leak_row, parent, false);
-      }
-      TextView titleView = (TextView) convertView.findViewById(R.id.leak_canary_row_text);
-      TextView timeView = (TextView) convertView.findViewById(R.id.leak_canary_row_time);
-      Leak leak = getItem(position);
-
-      String index = (leaks.size() - position) + ". ";
-
-      String title;
-      if (leak.result.failure == null) {
-        String className = classSimpleName(leak.result.className);
-        String size = formatShortFileSize(DisplayLeakActivity.this, leak.result.retainedHeapSize);
-        title = getString(R.string.leak_canary_class_has_leaked, className, size);
-        if (leak.result.excludedLeak) {
-          title = getString(R.string.leak_canary_excluded_row, title);
-        }
-        title = index + title;
-      } else {
-        title = index
-            + leak.result.failure.getClass().getSimpleName()
-            + " "
-            + leak.result.failure.getMessage();
-      }
-      titleView.setText(title);
-      String time =
-          DateUtils.formatDateTime(DisplayLeakActivity.this, leak.resultFile.lastModified(),
-              FORMAT_SHOW_TIME | FORMAT_SHOW_DATE);
-      timeView.setText(time);
-      return convertView;
-    }
-  }
-
-  static class Leak {
-    final HeapDump heapDump;
-    final AnalysisResult result;
-    final File resultFile;
-
-    Leak(HeapDump heapDump, AnalysisResult result, File resultFile) {
-      this.heapDump = heapDump;
-      this.result = result;
-      this.resultFile = resultFile;
-    }
-  }
-
-  static class LoadLeaks implements Runnable {
-
-    static final List<LoadLeaks> inFlight = new ArrayList<>();
-
-    static final Executor backgroundExecutor = newSingleThreadExecutor("LoadLeaks");
-
-    static void load(DisplayLeakActivity activity, File leakDirectory) {
-      LoadLeaks loadLeaks = new LoadLeaks(activity, leakDirectory);
-      inFlight.add(loadLeaks);
-      backgroundExecutor.execute(loadLeaks);
-    }
-
-    static void forgetActivity() {
-      for (LoadLeaks loadLeaks : inFlight) {
-        loadLeaks.activityOrNull = null;
-      }
-      inFlight.clear();
-    }
-
-    DisplayLeakActivity activityOrNull;
-    private final File leakDirectory;
-    private final Handler mainHandler;
-
-    LoadLeaks(DisplayLeakActivity activity, File leakDirectory) {
-      this.activityOrNull = activity;
-      this.leakDirectory = leakDirectory;
-      mainHandler = new Handler(Looper.getMainLooper());
-    }
-
-    @Override public void run() {
-      final List<Leak> leaks = new ArrayList<>();
-      File[] files = leakDirectory.listFiles(new FilenameFilter() {
-        @Override public boolean accept(File dir, String filename) {
-          return filename.endsWith(".result");
-        }
-      });
-
-      if (files != null) {
-        for (File resultFile : files) {
-          FileInputStream fis = null;
-          try {
-            fis = new FileInputStream(resultFile);
-            ObjectInputStream ois = new ObjectInputStream(fis);
-            HeapDump heapDump = (HeapDump) ois.readObject();
-            AnalysisResult result = (AnalysisResult) ois.readObject();
-            leaks.add(new Leak(heapDump, result, resultFile));
-          } catch (IOException | ClassNotFoundException e) {
-            // Likely a change in the serializable result class.
-            // Let's remove the files, we can't read them anymore.
-            boolean deleted = resultFile.delete();
-            if (deleted) {
-              CanaryLog.d(e, "Could not read result file %s, deleted it.", resultFile);
-            } else {
-              CanaryLog.d(e, "Could not read result file %s, could not delete it either.",
-                  resultFile);
-            }
-          } finally {
-            if (fis != null) {
-              try {
-                fis.close();
-              } catch (IOException ignored) {
-              }
-            }
-          }
-        }
-        Collections.sort(leaks, new Comparator<Leak>() {
-          @Override public int compare(Leak lhs, Leak rhs) {
-            return Long.valueOf(rhs.resultFile.lastModified())
-                .compareTo(lhs.resultFile.lastModified());
-          }
-        });
-      }
-      mainHandler.post(new Runnable() {
-        @Override public void run() {
-          inFlight.remove(LoadLeaks.this);
-          if (activityOrNull != null) {
-            activityOrNull.leaks = leaks;
-            activityOrNull.updateUi();
-          }
-        }
-      });
-    }
-  }
-
-  static String classSimpleName(String className) {
-    int separator = className.lastIndexOf('.');
-    if (separator == -1) {
-      return className;
-    } else {
-      return className.substring(separator + 1);
-    }
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
deleted file mode 100644
index fd23cfbd..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.Context;
-import android.text.Html;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.BaseAdapter;
-import android.widget.TextView;
-import com.squareup.leakcanary.Exclusion;
-import com.squareup.leakcanary.LeakTrace;
-import com.squareup.leakcanary.LeakTraceElement;
-import com.squareup.leakcanary.R;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-
-final class DisplayLeakAdapter extends BaseAdapter {
-
-  private static final int TOP_ROW = 0;
-  private static final int NORMAL_ROW = 1;
-
-  private boolean[] opened = new boolean[0];
-
-  private List<LeakTraceElement> elements = Collections.emptyList();
-  private String referenceKey;
-  private String referenceName = "";
-
-  @Override public View getView(int position, View convertView, ViewGroup parent) {
-    Context context = parent.getContext();
-    if (getItemViewType(position) == TOP_ROW) {
-      if (convertView == null) {
-        convertView =
-            LayoutInflater.from(context).inflate(R.layout.leak_canary_ref_top_row, parent, false);
-      }
-      TextView textView = findById(convertView, R.id.leak_canary_row_text);
-      textView.setText(context.getPackageName());
-    } else {
-      if (convertView == null) {
-        convertView =
-            LayoutInflater.from(context).inflate(R.layout.leak_canary_ref_row, parent, false);
-      }
-      TextView textView = findById(convertView, R.id.leak_canary_row_text);
-
-      boolean isRoot = position == 1;
-      boolean isLeakingInstance = position == getCount() - 1;
-      LeakTraceElement element = getItem(position);
-      String htmlString = elementToHtmlString(element, isRoot, opened[position]);
-      if (isLeakingInstance && !referenceName.equals("") && opened[position]) {
-        htmlString += " <font color='#919191'>" + referenceName + "</font>";
-      }
-      textView.setText(Html.fromHtml(htmlString));
-
-      DisplayLeakConnectorView connector = findById(convertView, R.id.leak_canary_row_connector);
-      if (isRoot) {
-        connector.setType(DisplayLeakConnectorView.Type.START);
-      } else {
-        if (isLeakingInstance) {
-          connector.setType(DisplayLeakConnectorView.Type.END);
-        } else {
-          connector.setType(DisplayLeakConnectorView.Type.NODE);
-        }
-      }
-      MoreDetailsView moreDetailsView = findById(convertView, R.id.leak_canary_row_more);
-      moreDetailsView.setOpened(opened[position]);
-    }
-
-    return convertView;
-  }
-
-  private String elementToHtmlString(LeakTraceElement element, boolean root, boolean opened) {
-    String htmlString = "";
-
-    if (element.referenceName == null) {
-      htmlString += "leaks ";
-    } else if (!root) {
-      htmlString += "references ";
-    }
-
-    if (element.type == STATIC_FIELD) {
-      htmlString += "<font color='#c48a47'>static</font> ";
-    }
-
-    if (element.holder == ARRAY || element.holder == THREAD) {
-      htmlString += "<font color='#f3cf83'>" + element.holder.name().toLowerCase() + "</font> ";
-    }
-
-    int separator = element.className.lastIndexOf('.');
-    String qualifier;
-    String simpleName;
-    if (separator == -1) {
-      qualifier = "";
-      simpleName = element.className;
-    } else {
-      qualifier = element.className.substring(0, separator + 1);
-      simpleName = element.className.substring(separator + 1);
-    }
-
-    if (opened) {
-      htmlString += "<font color='#919191'>" + qualifier + "</font>";
-    }
-
-    String styledClassName = "<font color='#ffffff'>" + simpleName + "</font>";
-
-    htmlString += styledClassName;
-
-    if (element.referenceName != null) {
-      htmlString += ".<font color='#998bb5'>" + element.referenceName.replaceAll("<", "&lt;")
-          .replaceAll(">", "&gt;") + "</font>";
-    } else {
-      htmlString += " <font color='#f3cf83'>instance</font>";
-    }
-
-    if (opened && element.extra != null) {
-      htmlString += " <font color='#919191'>" + element.extra + "</font>";
-    }
-
-    Exclusion exclusion = element.exclusion;
-    if (exclusion != null) {
-      if (opened) {
-        htmlString += "<br/><br/>Excluded by rule";
-        if (exclusion.name != null) {
-          htmlString += " <font color='#ffffff'>" + exclusion.name + "</font>";
-        }
-        htmlString += " matching <font color='#f3cf83'>" + exclusion.matching + "</font>";
-        if (exclusion.reason != null) {
-          htmlString += " because <font color='#f3cf83'>" + exclusion.reason + "</font>";
-        }
-      } else {
-        htmlString += " (excluded)";
-      }
-    }
-
-    return htmlString;
-  }
-
-  public void update(LeakTrace leakTrace, String referenceKey, String referenceName) {
-    if (referenceKey.equals(this.referenceKey)) {
-      // Same data, nothing to change.
-      return;
-    }
-    this.referenceKey = referenceKey;
-    this.referenceName = referenceName;
-    this.elements = new ArrayList<>(leakTrace.elements);
-    opened = new boolean[1 + elements.size()];
-    notifyDataSetChanged();
-  }
-
-  public void toggleRow(int position) {
-    opened[position] = !opened[position];
-    notifyDataSetChanged();
-  }
-
-  @Override public int getCount() {
-    return 1 + elements.size();
-  }
-
-  @Override public LeakTraceElement getItem(int position) {
-    if (getItemViewType(position) == TOP_ROW) {
-      return null;
-    }
-    return elements.get(position - 1);
-  }
-
-  @Override public int getViewTypeCount() {
-    return 2;
-  }
-
-  @Override public int getItemViewType(int position) {
-    if (position == 0) {
-      return TOP_ROW;
-    }
-    return NORMAL_ROW;
-  }
-
-  @Override public long getItemId(int position) {
-    return position;
-  }
-
-  @SuppressWarnings("unchecked") private static <T extends View> T findById(View view, int id) {
-    return (T) view.findViewById(id);
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
deleted file mode 100644
index e854ac2a..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.Paint;
-import android.util.AttributeSet;
-import android.view.View;
-
-import static android.graphics.Bitmap.Config.ARGB_8888;
-
-public final class DisplayLeakConnectorView extends View {
-
-  private static final Paint iconPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  private static final Paint rootPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  private static final Paint leakPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  private static final Paint clearPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-
-  static {
-    iconPaint.setColor(LeakCanaryUi.LIGHT_GREY);
-    rootPaint.setColor(LeakCanaryUi.ROOT_COLOR);
-    leakPaint.setColor(LeakCanaryUi.LEAK_COLOR);
-    clearPaint.setColor(Color.TRANSPARENT);
-    clearPaint.setXfermode(LeakCanaryUi.CLEAR_XFER_MODE);
-  }
-
-  public enum Type {
-    START, NODE, END
-  }
-
-  private Type type;
-  private Bitmap cache;
-
-  public DisplayLeakConnectorView(Context context, AttributeSet attrs) {
-    super(context, attrs);
-
-    type = Type.NODE;
-  }
-
-  @SuppressWarnings("SuspiciousNameCombination") @Override protected void onDraw(Canvas canvas) {
-    int width = getWidth();
-    int height = getHeight();
-
-    if (cache != null && (cache.getWidth() != width || cache.getHeight() != height)) {
-      cache.recycle();
-      cache = null;
-    }
-
-    if (cache == null) {
-      cache = Bitmap.createBitmap(width, height, ARGB_8888);
-
-      Canvas cacheCanvas = new Canvas(cache);
-
-      float halfWidth = width / 2f;
-      float halfHeight = height / 2f;
-      float thirdWidth = width / 3f;
-
-      float strokeSize = LeakCanaryUi.dpToPixel(4f, getResources());
-
-      iconPaint.setStrokeWidth(strokeSize);
-      rootPaint.setStrokeWidth(strokeSize);
-
-      switch (type) {
-        case NODE:
-          cacheCanvas.drawLine(halfWidth, 0, halfWidth, height, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, halfWidth, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, clearPaint);
-          break;
-        case START:
-          float radiusClear = halfWidth - strokeSize / 2f;
-          cacheCanvas.drawRect(0, 0, width, radiusClear, rootPaint);
-          cacheCanvas.drawCircle(0, radiusClear, radiusClear, clearPaint);
-          cacheCanvas.drawCircle(width, radiusClear, radiusClear, clearPaint);
-          cacheCanvas.drawLine(halfWidth, 0, halfWidth, halfHeight, rootPaint);
-          cacheCanvas.drawLine(halfWidth, halfHeight, halfWidth, height, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, halfWidth, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, clearPaint);
-          break;
-        default:
-          cacheCanvas.drawLine(halfWidth, 0, halfWidth, halfHeight, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, leakPaint);
-          break;
-      }
-    }
-    canvas.drawBitmap(cache, 0, 0, null);
-  }
-
-  public void setType(Type type) {
-    if (type != this.type) {
-      this.type = type;
-      if (cache != null) {
-        cache.recycle();
-        cache = null;
-      }
-      invalidate();
-    }
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.java
deleted file mode 100644
index 8cd6b27f..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-
-public final class FutureResult<T> {
-
-  private final AtomicReference<T> resultHolder;
-  private final CountDownLatch latch;
-
-  public FutureResult() {
-    resultHolder = new AtomicReference<>();
-    latch = new CountDownLatch(1);
-  }
-
-  public boolean wait(long timeout, TimeUnit unit) {
-    try {
-      return latch.await(timeout, unit);
-    } catch (InterruptedException e) {
-      throw new RuntimeException("Did not expect thread to be interrupted", e);
-    }
-  }
-
-  public T get() {
-    if (latch.getCount() > 0) {
-      throw new IllegalStateException("Call wait() and check its result");
-    }
-    return resultHolder.get();
-  }
-
-  public void set(T result) {
-    resultHolder.set(result);
-    latch.countDown();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
deleted file mode 100644
index d03dad94..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.app.IntentService;
-import android.content.Context;
-import android.content.Intent;
-import com.squareup.leakcanary.AbstractAnalysisResultService;
-import com.squareup.leakcanary.AnalysisResult;
-import com.squareup.leakcanary.CanaryLog;
-import com.squareup.leakcanary.HeapAnalyzer;
-import com.squareup.leakcanary.HeapDump;
-
-/**
- * This service runs in a separate process to avoid slowing down the app process or making it run
- * out of memory.
- */
-public final class HeapAnalyzerService extends IntentService {
-
-  private static final String LISTENER_CLASS_EXTRA = "listener_class_extra";
-  private static final String HEAPDUMP_EXTRA = "heapdump_extra";
-
-  public static void runAnalysis(Context context, HeapDump heapDump,
-      Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
-    Intent intent = new Intent(context, HeapAnalyzerService.class);
-    intent.putExtra(LISTENER_CLASS_EXTRA, listenerServiceClass.getName());
-    intent.putExtra(HEAPDUMP_EXTRA, heapDump);
-    context.startService(intent);
-  }
-
-  public HeapAnalyzerService() {
-    super(HeapAnalyzerService.class.getSimpleName());
-  }
-
-  @Override protected void onHandleIntent(Intent intent) {
-    if (intent == null) {
-      CanaryLog.d("HeapAnalyzerService received a null intent, ignoring.");
-      return;
-    }
-    String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);
-    HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);
-
-    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(heapDump.excludedRefs);
-
-    AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);
-    AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
deleted file mode 100644
index cdb5a055..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.annotation.TargetApi;
-import android.app.ActivityManager;
-import android.app.Notification;
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.app.Service;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.ServiceInfo;
-import com.squareup.leakcanary.CanaryLog;
-import com.squareup.leakcanary.R;
-import java.lang.reflect.Method;
-import java.util.List;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
-import static android.content.pm.PackageManager.DONT_KILL_APP;
-import static android.content.pm.PackageManager.GET_SERVICES;
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.HONEYCOMB;
-import static android.os.Build.VERSION_CODES.JELLY_BEAN;
-
-public final class LeakCanaryInternals {
-
-  public static final String SAMSUNG = "samsung";
-  public static final String MOTOROLA = "motorola";
-  public static final String LG = "LGE";
-  public static final String NVIDIA = "NVIDIA";
-
-  private static final Executor fileIoExecutor = newSingleThreadExecutor("File-IO");
-
-  public static void executeOnFileIoThread(Runnable runnable) {
-    fileIoExecutor.execute(runnable);
-  }
-
-  /** Extracts the class simple name out of a string containing a fully qualified class name. */
-  public static String classSimpleName(String className) {
-    int separator = className.lastIndexOf('.');
-    if (separator == -1) {
-      return className;
-    } else {
-      return className.substring(separator + 1);
-    }
-  }
-
-  public static void setEnabled(Context context, final Class<?> componentClass,
-      final boolean enabled) {
-    final Context appContext = context.getApplicationContext();
-    executeOnFileIoThread(new Runnable() {
-      @Override public void run() {
-        setEnabledBlocking(appContext, componentClass, enabled);
-      }
-    });
-  }
-
-  public static void setEnabledBlocking(Context appContext, Class<?> componentClass,
-      boolean enabled) {
-    ComponentName component = new ComponentName(appContext, componentClass);
-    PackageManager packageManager = appContext.getPackageManager();
-    int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED;
-    // Blocks on IPC.
-    packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);
-  }
-
-  public static boolean isInServiceProcess(Context context, Class<? extends Service> serviceClass) {
-    PackageManager packageManager = context.getPackageManager();
-    PackageInfo packageInfo;
-    try {
-      packageInfo = packageManager.getPackageInfo(context.getPackageName(), GET_SERVICES);
-    } catch (Exception e) {
-      CanaryLog.d(e, "Could not get package info for %s", context.getPackageName());
-      return false;
-    }
-    String mainProcess = packageInfo.applicationInfo.processName;
-
-    ComponentName component = new ComponentName(context, serviceClass);
-    ServiceInfo serviceInfo;
-    try {
-      serviceInfo = packageManager.getServiceInfo(component, 0);
-    } catch (PackageManager.NameNotFoundException ignored) {
-      // Service is disabled.
-      return false;
-    }
-
-    if (serviceInfo.processName.equals(mainProcess)) {
-      CanaryLog.d("Did not expect service %s to run in main process %s", serviceClass, mainProcess);
-      // Technically we are in the service process, but we're not in the service dedicated process.
-      return false;
-    }
-
-    int myPid = android.os.Process.myPid();
-    ActivityManager activityManager =
-        (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
-    ActivityManager.RunningAppProcessInfo myProcess = null;
-    List<ActivityManager.RunningAppProcessInfo> runningProcesses =
-        activityManager.getRunningAppProcesses();
-    if (runningProcesses != null) {
-      for (ActivityManager.RunningAppProcessInfo process : runningProcesses) {
-        if (process.pid == myPid) {
-          myProcess = process;
-          break;
-        }
-      }
-    }
-    if (myProcess == null) {
-      CanaryLog.d("Could not find running process for %d", myPid);
-      return false;
-    }
-
-    return myProcess.processName.equals(serviceInfo.processName);
-  }
-
-  @TargetApi(HONEYCOMB)
-  public static void showNotification(Context context, CharSequence contentTitle,
-      CharSequence contentText, PendingIntent pendingIntent) {
-    NotificationManager notificationManager =
-        (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
-
-    Notification notification;
-    if (SDK_INT < HONEYCOMB) {
-      notification = new Notification();
-      notification.icon = R.drawable.leak_canary_notification;
-      notification.when = System.currentTimeMillis();
-      notification.flags |= Notification.FLAG_AUTO_CANCEL;
-      try {
-        Method method =
-            Notification.class.getMethod("setLatestEventInfo", Context.class, CharSequence.class,
-                CharSequence.class, PendingIntent.class);
-        method.invoke(notification, context, contentTitle, contentText, pendingIntent);
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    } else {
-      Notification.Builder builder = new Notification.Builder(context) //
-          .setSmallIcon(R.drawable.leak_canary_notification)
-          .setWhen(System.currentTimeMillis())
-          .setContentTitle(contentTitle)
-          .setContentText(contentText)
-          .setAutoCancel(true)
-          .setContentIntent(pendingIntent);
-      if (SDK_INT < JELLY_BEAN) {
-        notification = builder.getNotification();
-      } else {
-        notification = builder.build();
-      }
-    }
-    notificationManager.notify(0xDEAFBEEF, notification);
-  }
-
-  public static Executor newSingleThreadExecutor(String threadName) {
-    return Executors.newSingleThreadExecutor(new LeakCanarySingleThreadFactory(threadName));
-  }
-
-  private LeakCanaryInternals() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java
deleted file mode 100644
index 74fbf986..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.res.Resources;
-import android.graphics.PorterDuffXfermode;
-import android.util.DisplayMetrics;
-
-import static android.graphics.PorterDuff.Mode.CLEAR;
-
-final class LeakCanaryUi {
-  static final int LIGHT_GREY = 0xFFbababa;
-  static final int ROOT_COLOR = 0xFF84a6c5;
-  static final int LEAK_COLOR = 0xFFb1554e;
-
-  static final PorterDuffXfermode CLEAR_XFER_MODE = new PorterDuffXfermode(CLEAR);
-
-  /**
-   * Converts from device independent pixels (dp or dip) to
-   * device dependent pixels. This method returns the input
-   * multiplied by the display's density. The result is not
-   * rounded nor clamped.
-   *
-   * The value returned by this method is well suited for
-   * drawing with the Canvas API but should not be used to
-   * set layout dimensions.
-   *
-   * @param dp The value in dp to convert to pixels
-   * @param resources An instances of Resources
-   */
-  static float dpToPixel(float dp, Resources resources) {
-    DisplayMetrics metrics = resources.getDisplayMetrics();
-    return metrics.density * dp;
-  }
-
-  private LeakCanaryUi() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
deleted file mode 100644
index 81bf8a0f..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.Context;
-import android.graphics.Canvas;
-import android.graphics.Paint;
-import android.util.AttributeSet;
-import android.view.View;
-
-public final class MoreDetailsView extends View {
-
-  private static final Paint iconPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-
-  static {
-    iconPaint.setColor(LeakCanaryUi.ROOT_COLOR);
-  }
-
-  public MoreDetailsView(Context context, AttributeSet attrs) {
-    super(context, attrs);
-
-    float strokeSize = LeakCanaryUi.dpToPixel(2f, getResources());
-    iconPaint.setStrokeWidth(strokeSize);
-  }
-
-  private boolean opened;
-
-  @Override protected void onDraw(Canvas canvas) {
-    int width = getWidth();
-    int height = getHeight();
-    int halfHeight = height / 2;
-    int halfWidth = width / 2;
-
-    if (opened) {
-      canvas.drawLine(0, halfHeight, width, halfHeight, iconPaint);
-    } else {
-      canvas.drawLine(0, halfHeight, width, halfHeight, iconPaint);
-      canvas.drawLine(halfWidth, 0, halfWidth, height, iconPaint);
-    }
-  }
-
-  public void setOpened(boolean opened) {
-    if (opened != this.opened) {
-      this.opened = opened;
-      invalidate();
-    }
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java
deleted file mode 100644
index 3d8a23f1..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.PendingIntent;
-import android.content.Context;
-import android.content.Intent;
-import android.os.Bundle;
-import android.widget.Toast;
-import com.squareup.leakcanary.R;
-
-import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
-import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
-import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
-import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
-import static android.content.pm.PackageManager.PERMISSION_GRANTED;
-import static android.os.Build.VERSION_CODES.M;
-import static android.widget.Toast.LENGTH_LONG;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabledBlocking;
-
-@TargetApi(M) //
-public class RequestStoragePermissionActivity extends Activity {
-
-  public static PendingIntent createPendingIntent(Context context) {
-    setEnabledBlocking(context, RequestStoragePermissionActivity.class, true);
-    Intent intent = new Intent(context, RequestStoragePermissionActivity.class);
-    intent.setFlags(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TOP);
-    return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);
-  }
-
-  @Override protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-
-    if (savedInstanceState == null) {
-      if (hasStoragePermission()) {
-        finish();
-        return;
-      }
-      String[] permissions = {
-          WRITE_EXTERNAL_STORAGE
-      };
-      requestPermissions(permissions, 42);
-    }
-  }
-
-  @Override public void onRequestPermissionsResult(int requestCode, String[] permissions,
-      int[] grantResults) {
-    if (!hasStoragePermission()) {
-      Toast.makeText(getApplication(), R.string.leak_canary_permission_not_granted, LENGTH_LONG)
-          .show();
-    }
-    finish();
-  }
-
-  private boolean hasStoragePermission() {
-    return checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED;
-  }
-}
diff --git a/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png
deleted file mode 100755
index 07bb09fc..00000000
Binary files a/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png
deleted file mode 100755
index 74348d82..00000000
Binary files a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png
deleted file mode 100755
index 13b33116..00000000
Binary files a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png
deleted file mode 100755
index 9738ad81..00000000
Binary files a/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png
deleted file mode 100755
index 37f5057f..00000000
Binary files a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png
deleted file mode 100755
index dc92783b..00000000
Binary files a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png
deleted file mode 100755
index 538e0214..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png
deleted file mode 100755
index 56a94f27..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png
deleted file mode 100755
index 1e1b977f..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png
deleted file mode 100755
index d3ef4b71..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png
deleted file mode 100755
index 34b7d41b..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png
deleted file mode 100755
index c652efdd..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png
deleted file mode 100755
index 4713f18d..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png
deleted file mode 100755
index 855d6052..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png
deleted file mode 100755
index bb458f2c..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml b/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
deleted file mode 100644
index 8e56c3d1..00000000
--- a/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
+++ /dev/null
@@ -1,46 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:orientation="vertical"
-    android:background="#3c3c3c"
-    >
-  <ListView
-      android:id="@+id/leak_canary_display_leak_list"
-      android:layout_width="match_parent"
-      android:layout_height="0dp"
-      android:layout_weight="1"
-      android:dividerHeight="0dp"
-      android:divider="@null"
-      />
-  <TextView
-      android:id="@+id/leak_canary_display_leak_failure"
-      android:layout_width="match_parent"
-      android:layout_height="0dp"
-      android:layout_weight="1"
-      android:textSize="12sp"
-      android:visibility="gone"
-      />
-  <Button
-      android:id="@+id/leak_canary_action"
-      android:layout_width="match_parent"
-      android:layout_height="wrap_content"
-      android:visibility="gone"
-      />
-
-</LinearLayout>
diff --git a/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
deleted file mode 100644
index a176ac0d..00000000
--- a/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
+++ /dev/null
@@ -1,39 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?><!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<resources>
-    <string name="leak_canary_class_has_leaked">%1$s hat %2$s geleaked</string>
-    <string name="leak_canary_leak_excluded">[Ausgeschlossen] %1$s hat %2$s geleaked</string>
-    <string name="leak_canary_analysis_failed">Leak Analyse fehlgeschlagen</string>
-    <string name="leak_canary_leak_list_title">Leaks in %s</string>
-    <string name="leak_canary_notification_message">Für mehr Details hier klicken</string>
-    <string name="leak_canary_share_leak">Info teilen</string>
-    <string name="leak_canary_share_heap_dump">Heap Dump teilen</string>
-    <string name="leak_canary_share_with">Teilen mit…</string>
-    <string name="leak_canary_display_activity_label">Leaks</string>
-    <string name="leak_canary_storage_permission_activity_label">Storage Berechtigung</string>
-    <string name="leak_canary_toast_heap_dump">Analysiere Speichert, die App wird einfrieren. Brrr.</string>
-    <string name="leak_canary_delete">Löschen</string>
-    <string name="leak_canary_failure_report">"Bitte sende diesen Fehler an http://github.com/square/leakcanary\n"</string>
-    <string name="leak_canary_delete_all">Alle löschen</string>
-    <string name="leak_canary_could_not_save_title">Konnte Ergebnis nicht speichern.</string>
-    <string name="leak_canary_could_not_save_text">LeakCanary konnte das Ergebnis der Analyse nicht speichern.</string>
-    <string name="leak_canary_no_leak_title">Kein Leak gefunden</string>
-    <string name="leak_canary_no_leak_text">Der GC war untätig.</string>
-    <string name="leak_canary_excluded_row">[Ausgeschlossen] %s</string>
-    <string name="leak_canary_permission_not_granted">Please grant external storage permission, otherwise memory leaks will not be detected.</string>
-    <string name="leak_canary_permission_notification_title">Leak detektiert, benötige Berechtigung</string>
-    <string name="leak_canary_permission_notification_text">Hier klicken um Storage Berechtigung für %s zu aktivieren.</string>
-</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_strings.xml b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
deleted file mode 100644
index d9aaee13..00000000
--- a/leakcanary-android/src/main/res/values/leak_canary_strings.xml
+++ /dev/null
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<resources>
-  <string name="leak_canary_class_has_leaked">%1$s leaked %2$s</string>
-  <string name="leak_canary_leak_excluded">[Excluded] %1$s leaked %2$s</string>
-  <string name="leak_canary_analysis_failed">Leak analysis failed</string>
-  <string name="leak_canary_leak_list_title">Leaks in %s</string>
-  <string name="leak_canary_notification_message">Click for more details</string>
-  <string name="leak_canary_share_leak">Share info</string>
-  <string name="leak_canary_share_heap_dump">Share heap dump</string>
-  <string name="leak_canary_share_with">Share with…</string>
-  <string name="leak_canary_display_activity_label">Leaks</string>
-  <string name="leak_canary_storage_permission_activity_label">Storage permission</string>
-  <string name="leak_canary_toast_heap_dump">Dumping memory, app will freeze. Brrrr.</string>
-  <string name="leak_canary_delete">Delete</string>
-  <string name="leak_canary_failure_report">"Please report this failure to http://github.com/square/leakcanary\n"</string>
-  <string name="leak_canary_delete_all">Delete all</string>
-  <string name="leak_canary_could_not_save_title">Could not save result.</string>
-  <string name="leak_canary_could_not_save_text">LeakCanary was unable to save the analysis result.</string>
-  <string name="leak_canary_no_leak_title">No leak found</string>
-  <string name="leak_canary_no_leak_text">The GC was being lazy.</string>
-  <string name="leak_canary_excluded_row">[Excluded] %s</string>
-  <string name="leak_canary_permission_not_granted">Please grant external storage permission, otherwise memory leaks will not be detected.</string>
-  <string name="leak_canary_permission_notification_title">Leak detected, need permission</string>
-  <string name="leak_canary_permission_notification_text">Click to enable storage permission for %s.</string>
-</resources>
diff --git a/leakcanary-haha/build.gradle b/leakcanary-haha/build.gradle
new file mode 100644
index 00000000..ee1d5a52
--- /dev/null
+++ b/leakcanary-haha/build.gradle
@@ -0,0 +1,18 @@
+apply plugin: 'java-library'
+apply plugin: 'kotlin'
+
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
+
+dependencies {
+  api project(':leakcanary-log')
+
+  implementation deps.kotlin.stdlib
+  implementation deps.okio
+
+  testImplementation deps.assertj_core
+  testImplementation deps.junit
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/leakcanary-haha/gradle.properties b/leakcanary-haha/gradle.properties
new file mode 100644
index 00000000..b7629a2c
--- /dev/null
+++ b/leakcanary-haha/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-haha
+POM_NAME=LeakCanary Headless Android Heap Analyzer
+POM_PACKAGING=jar
diff --git a/leakcanary-haha/src/main/java/leakcanary/FieldValuesReader.kt b/leakcanary-haha/src/main/java/leakcanary/FieldValuesReader.kt
new file mode 100644
index 00000000..9ab4dfe5
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/FieldValuesReader.kt
@@ -0,0 +1,7 @@
+package leakcanary
+
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+
+interface FieldValuesReader {
+  fun readValue(field: FieldRecord): HeapValue
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/GcRoot.kt b/leakcanary-haha/src/main/java/leakcanary/GcRoot.kt
new file mode 100644
index 00000000..fa7b3b9f
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/GcRoot.kt
@@ -0,0 +1,102 @@
+package leakcanary
+
+sealed class GcRoot {
+
+  abstract val id: Long
+
+  class Unknown(override val id: Long) : GcRoot()
+
+  /**
+   * A global variable in native code.
+   */
+  class JniGlobal(
+    override val id: Long,
+    val jniGlobalRefId: Long
+  ) : GcRoot()
+
+  /**
+   * A local variable in native code.
+   */
+  class JniLocal(
+    override val id: Long,
+    val threadSerialNumber: Int,
+    /**
+     * frame number in stack trace (-1 for empty)
+     */
+    val frameNumber: Int
+  ) : GcRoot()
+
+  /**
+   * Java local variable
+   */
+  class JavaFrame(
+    override val id: Long,
+    val threadSerialNumber: Int,
+    /**
+     * frame number in stack trace (-1 for empty)
+     */
+    val frameNumber: Int
+  ) : GcRoot()
+
+  /**
+   * Input or output parameters in native code
+   */
+  class NativeStack(
+    override val id: Long,
+    /**
+     * Thread is sometimes not found, see:
+     * https://issuetracker.google.com/issues/122713143
+     */
+    val threadSerialNumber: Int
+  ) : GcRoot()
+
+  /**
+   * System class
+   */
+  class StickyClass(override val id: Long) : GcRoot()
+
+  class ThreadBlock(
+    override val id: Long,
+    val threadSerialNumber: Int
+  ) : GcRoot()
+
+  /**
+   * Everything that called the wait() or notify() methods, or
+   * that is synchronized.
+   */
+  class MonitorUsed(override val id: Long) : GcRoot()
+
+  /**
+   * Added at https://android.googlesource.com/platform/tools/base/+/c0f0d528c155cab32e372dac77370569a386245c
+   */
+  class ThreadObject(
+    override val id: Long,
+    val threadSerialNumber: Int,
+    val stackTraceSerialNumber: Int
+  ) : GcRoot()
+
+  class ReferenceCleanup(override val id: Long) : GcRoot()
+
+  class VmInternal(override val id: Long) : GcRoot()
+
+  class JniMonitor(
+    override val id: Long,
+    val stackTraceSerialNumber: Int,
+    val stackDepth: Int
+  ) : GcRoot()
+
+  class InternedString(override val id: Long) : GcRoot()
+
+  /**
+   * An object that is in a queue, waiting for a finalizer to run.
+   */
+  class Finalizing(override val id: Long) : GcRoot()
+
+  class Debugger(override val id: Long) : GcRoot()
+
+  /**
+   * An object that is unreachable from any other root, but not a root itself.
+   */
+  class Unreachable(override val id: Long) : GcRoot()
+
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphField.kt b/leakcanary-haha/src/main/java/leakcanary/GraphField.kt
new file mode 100644
index 00000000..ce400a5b
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphField.kt
@@ -0,0 +1,9 @@
+package leakcanary
+
+import leakcanary.GraphObjectRecord.GraphClassRecord
+
+class GraphField(
+  val classRecord: GraphClassRecord,
+  val name: String,
+  val value: GraphHeapValue
+)
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt b/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
new file mode 100644
index 00000000..a19c8de3
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
@@ -0,0 +1,65 @@
+package leakcanary
+
+import leakcanary.HeapValue.BooleanValue
+import leakcanary.HeapValue.ByteValue
+import leakcanary.HeapValue.CharValue
+import leakcanary.HeapValue.DoubleValue
+import leakcanary.HeapValue.FloatValue
+import leakcanary.HeapValue.IntValue
+import leakcanary.HeapValue.LongValue
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.HeapValue.ShortValue
+
+class GraphHeapValue(
+  private val graph: HprofGraph,
+  val actual: HeapValue
+) {
+  val asBoolean: Boolean?
+    get() = if (actual is BooleanValue) actual.value else null
+
+  val asChar: Char?
+    get() = if (actual is CharValue) actual.value else null
+
+  val asFloat: Float?
+    get() = if (actual is FloatValue) actual.value else null
+
+  val asDouble: Double?
+    get() = if (actual is DoubleValue) actual.value else null
+
+  val asByte: Byte?
+    get() = if (actual is ByteValue) actual.value else null
+
+  val asShort: Short?
+    get() = if (actual is ShortValue) actual.value else null
+
+  val asInt: Int?
+    get() = if (actual is IntValue) actual.value else null
+
+  val asLong: Long?
+    get() = if (actual is LongValue) actual.value else null
+
+  val asObjectIdReference: Long?
+    get() = if (actual is ObjectReference) actual.value else null
+
+  val asNonNullObjectIdReference: Long?
+    get() = if (actual is ObjectReference && !actual.isNull) actual.value else null
+
+  val isNullReference: Boolean
+    get() = actual is ObjectReference && actual.isNull
+
+  val isNonNullReference: Boolean
+    get() = actual is ObjectReference && !actual.isNull
+
+  val asObject: GraphObjectRecord?
+    get() {
+      return if (actual is ObjectReference && !actual.isNull) {
+        return graph.indexedObject(actual.value)
+      } else {
+        null
+      }
+    }
+
+  fun readAsJavaString(): String? {
+    return asObject?.asInstance?.readAsJavaString()
+  }
+}
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt b/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
new file mode 100644
index 00000000..69ff4183
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
@@ -0,0 +1,232 @@
+package leakcanary
+
+import leakcanary.Record.HeapDumpRecord.ObjectRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import leakcanary.internal.IndexedObject.IndexedClass
+import leakcanary.internal.IndexedObject.IndexedInstance
+import leakcanary.internal.IndexedObject.IndexedObjectArray
+import leakcanary.internal.IndexedObject.IndexedPrimitiveArray
+import java.nio.charset.Charset
+import kotlin.reflect.KClass
+
+sealed class GraphObjectRecord {
+
+  abstract val objectId: Long
+
+  abstract fun readRecord(): ObjectRecord
+
+  val asClass: GraphClassRecord?
+    get() = if (this is GraphClassRecord) this else null
+
+  val asInstance: GraphInstanceRecord?
+    get() = if (this is GraphInstanceRecord) this else null
+
+  val asObjectArray: GraphObjectArrayRecord?
+    get() = if (this is GraphObjectArrayRecord) this else null
+
+  val asPrimitiveArray: GraphPrimitiveArrayRecord?
+    get() = if (this is GraphPrimitiveArrayRecord) this else null
+
+  class GraphClassRecord internal constructor(
+    private val graph: HprofGraph,
+    private val indexedObject: IndexedClass,
+    override val objectId: Long
+  ) : GraphObjectRecord() {
+    override fun readRecord(): ClassDumpRecord {
+      return graph.readClassDumpRecord(objectId, indexedObject)
+    }
+
+    val name: String
+      get() = graph.className(objectId)
+
+    val simpleName: String
+      get() {
+        val className = this.name
+        val separator = className.lastIndexOf('.')
+        return if (separator == -1) {
+          className
+        } else {
+          className.substring(separator + 1)
+        }
+      }
+
+    val instanceSize: Int
+      get() = indexedObject.instanceSize
+
+    val superClass: GraphClassRecord?
+      get() {
+        if (indexedObject.superClassId == 0L) return null
+        return graph.indexedObject(indexedObject.superClassId) as GraphClassRecord
+      }
+
+    val classHierarchy: Sequence<GraphClassRecord>
+      get() = generateSequence(this) { it.superClass }
+
+    fun readStaticFields(): List<GraphField> {
+      val fields = mutableListOf<GraphField>()
+      for (fieldRecord in readRecord().staticFields) {
+        fields += GraphField(
+            this, graph.staticFieldName(fieldRecord), GraphHeapValue(graph, fieldRecord.value)
+        )
+      }
+      return fields
+    }
+
+    operator fun get(fieldName: String): GraphField? {
+      for (fieldRecord in readRecord().staticFields) {
+        if (graph.staticFieldName(fieldRecord) == fieldName) {
+          return GraphField(
+              this, graph.staticFieldName(fieldRecord), GraphHeapValue(graph, fieldRecord.value)
+          )
+        }
+      }
+      return null
+    }
+  }
+
+  class GraphInstanceRecord internal constructor(
+    private val graph: HprofGraph,
+    private val indexedObject: IndexedInstance,
+    override val objectId: Long,
+    val isPrimitiveWrapper: Boolean
+  ) : GraphObjectRecord() {
+    override fun readRecord(): InstanceDumpRecord {
+      return graph.readInstanceDumpRecord(objectId, indexedObject)
+    }
+
+    infix fun instanceOf(className: String): Boolean {
+      var currentClassId = indexedObject.classId
+      while (currentClassId != 0L) {
+        if (graph.className(currentClassId) == className) {
+          return true
+        }
+
+        val currentClassRecord = graph.readObjectRecord(currentClassId) as ClassDumpRecord
+        currentClassId = currentClassRecord.superClassId
+      }
+      return false
+    }
+
+    infix fun instanceOf(expectedClass: KClass<*>) =
+      this instanceOf expectedClass.java.name
+
+    operator fun get(
+      declaringClass: KClass<out Any>,
+      fieldName: String
+    ): GraphField? {
+      return get(declaringClass.java.name, fieldName)
+    }
+
+    operator fun get(
+      declaringClassName: String,
+      fieldName: String
+    ): GraphField? {
+      return readFields().firstOrNull { field -> field.classRecord.name == declaringClassName && field.name == fieldName }
+    }
+
+    val className: String
+      get() = graph.className(indexedObject.classId)
+
+    val classSimpleName: String
+      get() {
+        val className = this.className
+        val separator = className.lastIndexOf('.')
+        return if (separator == -1) {
+          className
+        } else {
+          className.substring(separator + 1)
+        }
+      }
+
+    val instanceClass: GraphClassRecord
+      get() {
+        return graph.indexedObject(indexedObject.classId) as GraphClassRecord
+      }
+
+    fun readFields(): Sequence<GraphField> {
+      val fieldReader by lazy {
+        graph.createFieldValuesReader(readRecord())
+      }
+      return instanceClass.classHierarchy
+          .map { classRecord ->
+            classRecord.readRecord()
+                .fields.asSequence()
+                .map { fieldRecord ->
+                  val fieldName = graph.fieldName(fieldRecord)
+                  val fieldValue = fieldReader.readValue(fieldRecord)
+                  GraphField(classRecord, fieldName, GraphHeapValue(graph, fieldValue))
+                }
+          }
+          .flatten()
+    }
+
+    fun readAsJavaString(): String? {
+      if (className != "java.lang.String") {
+        return null
+      }
+      val count = this["java.lang.String", "count"]!!.value.asInt!!
+      if (count == 0) {
+        return ""
+      }
+
+      // Prior to API 26 String.value was a char array.
+      // Since API 26 String.value is backed by native code. The vast majority of strings in a
+      // heap dump are backed by a byte array, but we still find a few backed by a char array.
+      when (val valueRecord =
+        this["java.lang.String", "value"]!!.value.asObject!!.readRecord()) {
+        is CharArrayDump -> {
+          // < API 23
+          // As of Marshmallow, substrings no longer share their parent strings' char arrays
+          // eliminating the need for String.offset
+          // https://android-review.googlesource.com/#/c/83611/
+          val offset = this["java.lang.String", "offset"]?.value?.asInt ?: 0
+
+          val chars = valueRecord.array.copyOfRange(offset, offset + count)
+          return String(chars)
+        }
+        is ByteArrayDump -> {
+          return String(valueRecord.array, Charset.forName("UTF-8"))
+        }
+        else -> throw UnsupportedOperationException(
+            "'value' field ${this["java.lang.String", "value"]!!.value} was expected to be either" +
+                " a char or byte array in string instance with id $objectId"
+        )
+      }
+    }
+  }
+
+  class GraphObjectArrayRecord internal constructor(
+    private val graph: HprofGraph,
+    private val indexedObject: IndexedObjectArray,
+    override val objectId: Long,
+    val isPrimitiveWrapperArray: Boolean
+  ) : GraphObjectRecord() {
+
+    val arrayClassName: String
+      get() = graph.className(indexedObject.arrayClassId)
+
+    override fun readRecord(): ObjectArrayDumpRecord {
+      return graph.readObjectArrayDumpRecord(objectId, indexedObject)
+    }
+
+  }
+
+  class GraphPrimitiveArrayRecord internal constructor(
+    private val graph: HprofGraph,
+    private val indexedObject: IndexedPrimitiveArray,
+    override val objectId: Long
+  ) : GraphObjectRecord() {
+    val primitiveType: PrimitiveType
+      get() = indexedObject.primitiveType
+
+    override fun readRecord(): PrimitiveArrayDumpRecord {
+      return graph.readPrimitiveArrayDumpRecord(objectId, indexedObject)
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt b/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt
new file mode 100644
index 00000000..3178c479
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt
@@ -0,0 +1,84 @@
+package leakcanary
+
+import leakcanary.HeapValue.BooleanValue
+import leakcanary.HeapValue.ByteValue
+import leakcanary.HeapValue.CharValue
+import leakcanary.HeapValue.DoubleValue
+import leakcanary.HeapValue.FloatValue
+import leakcanary.HeapValue.IntValue
+import leakcanary.HeapValue.LongValue
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.HeapValue.ShortValue
+
+sealed class HeapValue {
+  data class ObjectReference(val value: Long) : HeapValue() {
+    val isNull
+      get() = value == 0L
+  }
+
+  data class BooleanValue(val value: Boolean) : HeapValue()
+  data class CharValue(val value: Char) : HeapValue()
+  data class FloatValue(val value: Float) : HeapValue()
+  data class DoubleValue(val value: Double) : HeapValue()
+  data class ByteValue(val value: Byte) : HeapValue()
+  data class ShortValue(val value: Short) : HeapValue()
+  data class IntValue(val value: Int) : HeapValue()
+  data class LongValue(val value: Long) : HeapValue()
+}
+
+val HeapValue?.isNullReference
+  get() = this is ObjectReference && isNull
+
+val HeapValue?.reference
+  get() = if (this is ObjectReference && !isNull) {
+    this.value
+  } else
+    null
+
+val HeapValue?.boolean
+  get() = if (this is BooleanValue) {
+    this.value
+  } else
+    null
+
+val HeapValue?.char
+  get() = if (this is CharValue) {
+    this.value
+  } else
+    null
+
+val HeapValue?.float
+  get() = if (this is FloatValue) {
+    this.value
+  } else
+    null
+
+val HeapValue?.double
+  get() = if (this is DoubleValue) {
+    this.value
+  } else
+    null
+
+val HeapValue?.byte
+  get() = if (this is ByteValue) {
+    this.value
+  } else
+    null
+
+val HeapValue?.short
+  get() = if (this is ShortValue) {
+    this.value
+  } else
+    null
+
+val HeapValue?.int
+  get() = if (this is IntValue) {
+    this.value
+  } else
+    null
+
+val HeapValue?.long
+  get() = if (this is LongValue) {
+    this.value
+  } else
+    null
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
new file mode 100644
index 00000000..71810636
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
@@ -0,0 +1,216 @@
+package leakcanary
+
+import leakcanary.GraphObjectRecord.GraphClassRecord
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
+import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
+import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
+import leakcanary.HprofPushRecordsParser.OnRecordListener
+import leakcanary.Record.HeapDumpRecord.ObjectRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import leakcanary.internal.HprofInMemoryIndex
+import leakcanary.internal.IndexedObject
+import leakcanary.internal.IndexedObject.IndexedClass
+import leakcanary.internal.IndexedObject.IndexedInstance
+import leakcanary.internal.IndexedObject.IndexedObjectArray
+import leakcanary.internal.IndexedObject.IndexedPrimitiveArray
+import leakcanary.internal.LruCache
+import okio.Buffer
+import java.io.Closeable
+import java.io.File
+
+/**
+ * Enables navigation through the Hprof graph of objects.
+ */
+class HprofGraph internal constructor(
+  private val reader: SeekableHprofReader,
+  private val index: HprofInMemoryIndex
+) {
+
+  /**
+   * LRU cache size of 3000 is a sweet spot to balance hits vs memory usage.
+   * This is based on running InstrumentationLeakDetectorTest a bunch of time on a
+   * Pixel 2 XL API 28. Hit count was ~120K, miss count ~290K
+   */
+  private val objectCache = LruCache<Long, ObjectRecord>(3000)
+
+  fun indexedClass(className: String): GraphClassRecord? {
+    val classId = index.classId(className)
+    return if (classId == null) {
+      null
+    } else {
+      return indexedObject(classId) as GraphClassRecord
+    }
+  }
+
+  fun readObjectRecord(objectId: Long): ObjectRecord {
+    return when (val indexedObject = index.indexedObject(objectId)) {
+      is IndexedInstance -> readInstanceDumpRecord(objectId, indexedObject)
+      is IndexedClass -> readClassDumpRecord(objectId, indexedObject)
+      is IndexedObjectArray -> readObjectArrayDumpRecord(objectId, indexedObject)
+      is IndexedPrimitiveArray -> readPrimitiveArrayDumpRecord(objectId, indexedObject)
+    }
+  }
+
+  fun indexedObject(objectId: Long): GraphObjectRecord {
+    return when (val indexedObject = index.indexedObject(objectId)) {
+      is IndexedClass -> GraphClassRecord(this, indexedObject, objectId)
+      is IndexedInstance -> {
+        val isPrimitiveWrapper = index.primitiveWrapperTypes.contains(indexedObject.classId)
+        GraphInstanceRecord(this, indexedObject, objectId, isPrimitiveWrapper)
+      }
+      is IndexedObjectArray -> {
+        val isPrimitiveWrapperArray =
+          index.primitiveWrapperTypes.contains(indexedObject.arrayClassId)
+        GraphObjectArrayRecord(this, indexedObject, objectId, isPrimitiveWrapperArray)
+      }
+      is IndexedPrimitiveArray -> GraphPrimitiveArrayRecord(this, indexedObject, objectId)
+    }
+  }
+
+  fun computeShallowSize(graphObject: GraphObjectRecord): Int {
+    return when (graphObject) {
+      is GraphInstanceRecord -> graphObject.instanceClass.instanceSize
+      is GraphObjectArrayRecord -> graphObject.readRecord().elementIds.size * index.idSize
+      is GraphPrimitiveArrayRecord -> when (val record = graphObject.readRecord()) {
+        is BooleanArrayDump -> record.array.size * HprofReader.BOOLEAN_SIZE
+        is CharArrayDump -> record.array.size * HprofReader.CHAR_SIZE
+        is FloatArrayDump -> record.array.size * HprofReader.FLOAT_SIZE
+        is DoubleArrayDump -> record.array.size * HprofReader.DOUBLE_SIZE
+        is ByteArrayDump -> record.array.size * HprofReader.BYTE_SIZE
+        is ShortArrayDump -> record.array.size * HprofReader.SHORT_SIZE
+        is IntArrayDump -> record.array.size * HprofReader.INT_SIZE
+        is LongArrayDump -> record.array.size * HprofReader.LONG_SIZE
+      }
+      is GraphClassRecord -> throw IllegalStateException(
+          "Unexpected record ${graphObject.readRecord()}"
+      )
+    }
+  }
+
+  fun instanceSequence(): Sequence<GraphInstanceRecord> {
+    return index.indexedInstanceSequence()
+        .map {
+          val objectId = it.first
+          val indexedObject = it.second
+          val isPrimitiveWrapper = index.primitiveWrapperTypes.contains(indexedObject.classId)
+          GraphInstanceRecord(this, indexedObject, objectId, isPrimitiveWrapper)
+        }
+  }
+
+  fun classSequence(): Sequence<GraphClassRecord> {
+    return index.indexedClassSequence()
+        .map {
+          val objectId = it.first
+          val indexedObject = it.second
+          GraphClassRecord(this, indexedObject, objectId)
+        }
+  }
+
+  fun sizeOfFieldType(hprofType: Int) = index.sizeOfFieldType(hprofType)
+
+  internal fun fieldName(fieldRecord: FieldRecord): String {
+    return index.hprofStringById(fieldRecord.nameStringId)
+  }
+
+  internal fun staticFieldName(fieldRecord: StaticFieldRecord): String {
+    return index.hprofStringById(fieldRecord.nameStringId)
+  }
+
+  internal fun createFieldValuesReader(record: InstanceDumpRecord): FieldValuesReader {
+    val buffer = Buffer()
+    buffer.write(record.fieldValues)
+
+    val reader = HprofReader(buffer, 0, index.idSize)
+
+    return object : FieldValuesReader {
+      override fun readValue(field: FieldRecord): HeapValue {
+        return reader.readValue(field.type)
+      }
+    }
+  }
+
+  internal fun className(classId: Long): String {
+    return index.className(classId)
+  }
+
+  internal fun readObjectArrayDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedObjectArray
+  ): ObjectArrayDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      reader.readObjectArrayDumpRecord()
+    }
+  }
+
+  internal fun readPrimitiveArrayDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedPrimitiveArray
+  ): PrimitiveArrayDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      reader.readPrimitiveArrayDumpRecord()
+    }
+  }
+
+  internal fun readClassDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedClass
+  ): ClassDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      reader.readClassDumpRecord()
+    }
+  }
+
+  internal fun readInstanceDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedInstance
+  ): InstanceDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      reader.readInstanceDumpRecord()
+    }
+  }
+
+  private fun <T : ObjectRecord> readObjectRecord(
+    objectId: Long,
+    indexedObject: IndexedObject,
+    readBlock: () -> T
+  ): T {
+    val objectRecordOrNull = objectCache[objectId]
+    @Suppress("UNCHECKED_CAST")
+    if (objectRecordOrNull != null) {
+      return objectRecordOrNull as T
+    }
+    reader.moveTo(indexedObject.position)
+    return readBlock().apply { objectCache.put(objectId, this) }
+  }
+
+  companion object {
+    fun readHprof(
+      heapDump: File,
+      vararg onRecordListeners: OnRecordListener
+    ): Pair<HprofGraph, Closeable> {
+      val indexListener = HprofInMemoryIndex.createOnRecordListener()
+
+      val parser = HprofPushRecordsParser()
+
+      val reader = parser.readHprofRecords(heapDump, setOf(indexListener) + onRecordListeners)
+
+      val hprofGraph = HprofGraph(reader, indexListener.buildIndex())
+
+      return hprofGraph to reader
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt b/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt
new file mode 100644
index 00000000..10b6847f
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt
@@ -0,0 +1,658 @@
+package leakcanary
+
+import leakcanary.GcRoot.Debugger
+import leakcanary.GcRoot.Finalizing
+import leakcanary.GcRoot.InternedString
+import leakcanary.GcRoot.JavaFrame
+import leakcanary.GcRoot.JniGlobal
+import leakcanary.GcRoot.JniLocal
+import leakcanary.GcRoot.JniMonitor
+import leakcanary.GcRoot.MonitorUsed
+import leakcanary.GcRoot.NativeStack
+import leakcanary.GcRoot.ReferenceCleanup
+import leakcanary.GcRoot.StickyClass
+import leakcanary.GcRoot.ThreadBlock
+import leakcanary.GcRoot.ThreadObject
+import leakcanary.GcRoot.Unknown
+import leakcanary.GcRoot.Unreachable
+import leakcanary.GcRoot.VmInternal
+import leakcanary.HprofReader.Companion.INT_SIZE
+import leakcanary.HprofReader.Companion.LONG_SIZE
+import leakcanary.Record.HeapDumpEndRecord
+import leakcanary.Record.HeapDumpRecord
+import leakcanary.Record.HeapDumpRecord.GcRootRecord
+import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import leakcanary.Record.LoadClassRecord
+import leakcanary.Record.StackFrameRecord
+import leakcanary.Record.StackTraceRecord
+import leakcanary.Record.StringRecord
+import okio.buffer
+import okio.source
+import java.io.File
+import kotlin.reflect.KClass
+
+/**
+ * A streaming push heap dump parser.
+ *
+ * Expected usage: call [readHprofRecords] once, which will go read through the entire heap dump
+ * and notify the provided listener of records found.
+ *
+ * This class is not thread safe, should be used from a single thread.
+ *
+ * Binary Dump Format reference: http://hg.openjdk.java.net/jdk6/jdk6/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html#mozTocId848088
+ *
+ * The Android Hprof format differs in some ways from that reference. This parser implementation
+ * is largely adapted from https://android.googlesource.com/platform/tools/base/+/studio-master-dev/perflib/src/main/java/com/android/tools/perflib
+ */
+class HprofPushRecordsParser {
+
+  interface OnRecordListener {
+    fun recordTypes(): Set<KClass<out Record>>
+
+    fun onTypeSizesAvailable(typeSizes: Map<Int, Int>)
+
+    fun onRecord(
+      position: Long,
+      record: Record
+    )
+  }
+
+  fun readHprofRecords(
+    heapDump: File,
+    listeners: Set<OnRecordListener>
+  ): SeekableHprofReader {
+    if (heapDump.length() == 0L) {
+      throw IllegalArgumentException("Heap dump file is 0 byte length")
+    }
+    val inputStream = heapDump.inputStream()
+    val channel = inputStream.channel
+    val source = inputStream.source()
+        .buffer()
+
+    val endOfVersionString = source.indexOf(0)
+    source.skip(endOfVersionString + 1)
+    val idSize = source.readInt()
+    val startPosition = endOfVersionString + 1 + 4
+
+    val reader = SeekableHprofReader(channel, source, startPosition, idSize)
+
+    listeners.forEach { it.onTypeSizesAvailable(reader.typeSizes) }
+
+    reader.readHprofRecords(listeners)
+    return reader
+  }
+
+  private fun SeekableHprofReader.readHprofRecords(listeners: Set<OnRecordListener>) {
+
+    val readStringRecord = mutableSetOf<OnRecordListener>()
+    val readLoadClassRecord = mutableSetOf<OnRecordListener>()
+    val readStackFrameRecord = mutableSetOf<OnRecordListener>()
+    val readStackTraceRecord = mutableSetOf<OnRecordListener>()
+    val readGcRootRecord = mutableSetOf<OnRecordListener>()
+    val readClassDumpRecord = mutableSetOf<OnRecordListener>()
+    val readInstanceDumpRecord = mutableSetOf<OnRecordListener>()
+    val readObjectArrayDumpRecord = mutableSetOf<OnRecordListener>()
+    val readPrimitiveArrayDumpRecord = mutableSetOf<OnRecordListener>()
+    val readHeapDumpInfoRecord = mutableSetOf<OnRecordListener>()
+    val readHeapDumpEnd = mutableSetOf<OnRecordListener>()
+
+    for (listener in listeners) {
+      val config = listener.recordTypes()
+      config.forEach { recordClass ->
+        when (recordClass) {
+          Record::class -> {
+            readStringRecord += listener
+            readLoadClassRecord += listener
+            readStackFrameRecord += listener
+            readStackTraceRecord += listener
+            readGcRootRecord += listener
+            readClassDumpRecord += listener
+            readInstanceDumpRecord += listener
+            readObjectArrayDumpRecord += listener
+            readPrimitiveArrayDumpRecord += listener
+            readHeapDumpInfoRecord += listener
+            readHeapDumpEnd += listener
+          }
+          StringRecord::class -> {
+            readStringRecord += listener
+          }
+          LoadClassRecord::class -> {
+            readLoadClassRecord += listener
+          }
+          HeapDumpEndRecord::class -> {
+            readHeapDumpEnd += listener
+          }
+          StackFrameRecord::class -> {
+            readStackFrameRecord += listener
+          }
+          StackTraceRecord::class -> {
+            readStackTraceRecord += listener
+          }
+          HeapDumpRecord::class -> {
+            readGcRootRecord += listener
+            readClassDumpRecord += listener
+            readInstanceDumpRecord += listener
+            readObjectArrayDumpRecord += listener
+            readPrimitiveArrayDumpRecord += listener
+            readHeapDumpInfoRecord += listener
+          }
+          GcRootRecord::class -> {
+            readGcRootRecord += listener
+          }
+          ObjectRecord::class -> {
+            readClassDumpRecord += listener
+            readInstanceDumpRecord += listener
+            readObjectArrayDumpRecord += listener
+            readPrimitiveArrayDumpRecord += listener
+          }
+          ClassDumpRecord::class -> {
+            readClassDumpRecord += listener
+          }
+          InstanceDumpRecord::class -> {
+            readInstanceDumpRecord += listener
+          }
+          ObjectArrayDumpRecord::class -> {
+            readObjectArrayDumpRecord += listener
+          }
+          PrimitiveArrayDumpRecord::class -> {
+            readPrimitiveArrayDumpRecord += listener
+          }
+          HeapDumpInfoRecord::class -> {
+            readHeapDumpInfoRecord += listener
+          }
+        }
+      }
+    }
+
+    // heap dump timestamp
+    skip(LONG_SIZE)
+
+    while (!exhausted()) {
+      // type of the record
+      val tag = readUnsignedByte()
+
+      // number of microseconds since the time stamp in the header
+      skip(INT_SIZE)
+
+      // number of bytes that follow and belong to this record
+      val length = readUnsignedInt()
+
+      when (tag) {
+        STRING_IN_UTF8 -> {
+          if (readStringRecord.isNotEmpty()) {
+            val recordPosition = position
+            val id = readId()
+            val stringLength = length - idSize
+            val string = readUtf8(stringLength)
+            val record = StringRecord(id, string)
+            readStringRecord.forEach { it.onRecord(recordPosition, record) }
+          } else {
+            skip(length)
+          }
+        }
+        LOAD_CLASS -> {
+          if (readLoadClassRecord.isNotEmpty()) {
+            val recordPosition = position
+            val classSerialNumber = readInt()
+            val id = readId()
+            val stackTraceSerialNumber = readInt()
+            val classNameStringId = readId()
+            val record = LoadClassRecord(
+                classSerialNumber = classSerialNumber,
+                id = id,
+                stackTraceSerialNumber = stackTraceSerialNumber,
+                classNameStringId = classNameStringId
+            )
+            readLoadClassRecord.forEach {
+              it.onRecord(recordPosition, record)
+            }
+          } else {
+            skip(length)
+          }
+        }
+        STACK_FRAME -> {
+          if (readStackFrameRecord.isNotEmpty()) {
+            val recordPosition = position
+            val record = StackFrameRecord(
+                id = readId(),
+                methodNameStringId = readId(),
+                methodSignatureStringId = readId(),
+                sourceFileNameStringId = readId(),
+                classSerialNumber = readInt(),
+                lineNumber = readInt()
+            )
+            readStackFrameRecord.forEach {
+              it.onRecord(recordPosition, record)
+            }
+          } else {
+            skip(length)
+          }
+        }
+        STACK_TRACE -> {
+          if (readStackTraceRecord.isNotEmpty()) {
+            val recordPosition = position
+            val stackTraceSerialNumber = readInt()
+            val threadSerialNumber = readInt()
+            val frameCount = readInt()
+            val stackFrameIds = readIdArray(frameCount)
+            val record = StackTraceRecord(
+                stackTraceSerialNumber = stackTraceSerialNumber,
+                threadSerialNumber = threadSerialNumber,
+                stackFrameIds = stackFrameIds
+            )
+            readStackTraceRecord.forEach {
+              it.onRecord(recordPosition, record)
+            }
+          } else {
+            skip(length)
+          }
+        }
+        HEAP_DUMP, HEAP_DUMP_SEGMENT -> {
+          val heapDumpStart = position
+          var previousTag = 0
+          while (position - heapDumpStart < length) {
+            val heapDumpTag = readUnsignedByte()
+
+            when (heapDumpTag) {
+              ROOT_UNKNOWN -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val record = GcRootRecord(gcRoot = Unknown(id = readId()))
+                  readGcRootRecord.forEach { it.onRecord(recordPosition, record) }
+                } else {
+                  skip(idSize)
+                }
+              }
+              ROOT_JNI_GLOBAL -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord =
+                    GcRootRecord(gcRoot = JniGlobal(id = readId(), jniGlobalRefId = readId()))
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize + idSize)
+                }
+              }
+
+              ROOT_JNI_LOCAL -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = JniLocal(
+                          id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
+                      )
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize + INT_SIZE + INT_SIZE)
+                }
+              }
+
+              ROOT_JAVA_FRAME -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = JavaFrame(
+                          id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
+                      )
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize + INT_SIZE + INT_SIZE)
+                }
+              }
+
+              ROOT_NATIVE_STACK -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = NativeStack(id = readId(), threadSerialNumber = readInt())
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize + INT_SIZE)
+                }
+              }
+
+              ROOT_STICKY_CLASS -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = StickyClass(id = readId())
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              // An object that was referenced from an active thread block.
+              ROOT_THREAD_BLOCK -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = ThreadBlock(id = readId(), threadSerialNumber = readInt())
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize + INT_SIZE)
+                }
+              }
+
+              ROOT_MONITOR_USED -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = MonitorUsed(id = readId())
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_THREAD_OBJECT -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = ThreadObject(
+                          id = readId(),
+                          threadSerialNumber = readInt(),
+                          stackTraceSerialNumber = readInt()
+                      )
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize + INT_SIZE + INT_SIZE)
+                }
+              }
+
+              ROOT_INTERNED_STRING -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(gcRoot = InternedString(id = readId()))
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_FINALIZING -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = Finalizing(id = readId())
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_DEBUGGER -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = Debugger(id = readId())
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_REFERENCE_CLEANUP -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = ReferenceCleanup(id = readId())
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_VM_INTERNAL -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = VmInternal(id = readId())
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize)
+                }
+              }
+
+              ROOT_JNI_MONITOR -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = JniMonitor(
+                          id = readId(), stackTraceSerialNumber = readInt(),
+                          stackDepth = readInt()
+                      )
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize + INT_SIZE + INT_SIZE)
+                }
+              }
+
+              ROOT_UNREACHABLE -> {
+                if (readGcRootRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = Unreachable(id = readId())
+                  )
+                  readGcRootRecord.forEach {
+                    it.onRecord(
+                        recordPosition, gcRootRecord
+                    )
+                  }
+                } else {
+                  skip(idSize)
+                }
+              }
+              CLASS_DUMP -> {
+                if (readClassDumpRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val record = readClassDumpRecord()
+                  readClassDumpRecord.forEach {
+                    it.onRecord(recordPosition, record)
+                  }
+                } else {
+                  skipClassDumpRecord()
+                }
+              }
+
+              INSTANCE_DUMP -> {
+                if (readInstanceDumpRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val instanceDumpRecord = readInstanceDumpRecord()
+                  readInstanceDumpRecord.forEach {
+                    it.onRecord(recordPosition, instanceDumpRecord)
+                  }
+                } else {
+                  skipInstanceDumpRecord()
+                }
+              }
+
+              OBJECT_ARRAY_DUMP -> {
+                if (readObjectArrayDumpRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val arrayRecord = readObjectArrayDumpRecord()
+                  readObjectArrayDumpRecord.forEach {
+                    it.onRecord(recordPosition, arrayRecord)
+                  }
+                } else {
+                  skipObjectArrayDumpRecord()
+                }
+              }
+
+              PRIMITIVE_ARRAY_DUMP -> {
+                if (readPrimitiveArrayDumpRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val record = readPrimitiveArrayDumpRecord()
+                  readPrimitiveArrayDumpRecord.forEach {
+                    it.onRecord(recordPosition, record)
+                  }
+                } else {
+                  skipPrimitiveArrayDumpRecord()
+                }
+              }
+
+              PRIMITIVE_ARRAY_NODATA -> {
+                throw UnsupportedOperationException("PRIMITIVE_ARRAY_NODATA cannot be parsed")
+              }
+
+              HEAP_DUMP_INFO -> {
+                if (readHeapDumpInfoRecord.isNotEmpty()) {
+                  val recordPosition = position
+                  val record = readHeapDumpInfoRecord()
+                  readHeapDumpInfoRecord.forEach {
+                    it.onRecord(recordPosition, record)
+                  }
+                } else {
+                  skipHeapDumpInfoRecord()
+                }
+              }
+
+              else -> throw IllegalStateException(
+                  "Unknown tag $heapDumpTag after $previousTag"
+              )
+            }
+            previousTag = heapDumpTag
+          }
+        }
+        HEAP_DUMP_END -> {
+          if (readHeapDumpEnd.isNotEmpty()) {
+            val recordPosition = position
+            val record = HeapDumpEndRecord
+            readHeapDumpEnd.forEach {
+              it.onRecord(recordPosition, record)
+            }
+          }
+        }
+        else -> {
+          skip(length)
+        }
+      }
+    }
+  }
+
+  companion object {
+    internal const val STRING_IN_UTF8 = 0x01
+    internal const val LOAD_CLASS = 0x02
+    internal const val UNLOAD_CLASS = 0x03
+    internal const val STACK_FRAME = 0x04
+    internal const val STACK_TRACE = 0x05
+    internal const val ALLOC_SITES = 0x06
+    internal const val HEAP_SUMMARY = 0x07
+    // TODO Maybe parse this?
+    internal const val START_THREAD = 0x0a
+    internal const val END_THREAD = 0x0b
+    internal const val HEAP_DUMP = 0x0c
+    internal const val HEAP_DUMP_SEGMENT = 0x1c
+    internal const val HEAP_DUMP_END = 0x2c
+    internal const val CPU_SAMPLES = 0x0d
+    internal const val CONTROL_SETTINGS = 0x0e
+    internal const val ROOT_UNKNOWN = 0xff
+    internal const val ROOT_JNI_GLOBAL = 0x01
+    internal const val ROOT_JNI_LOCAL = 0x02
+    internal const val ROOT_JAVA_FRAME = 0x03
+    internal const val ROOT_NATIVE_STACK = 0x04
+    internal const val ROOT_STICKY_CLASS = 0x05
+    internal const val ROOT_THREAD_BLOCK = 0x06
+    internal const val ROOT_MONITOR_USED = 0x07
+    internal const val ROOT_THREAD_OBJECT = 0x08
+    internal const val CLASS_DUMP = 0x20
+    internal const val INSTANCE_DUMP = 0x21
+    internal const val OBJECT_ARRAY_DUMP = 0x22
+    internal const val PRIMITIVE_ARRAY_DUMP = 0x23
+
+    /**
+     * Android format addition
+     *
+     * Specifies information about which heap certain objects came from. When a sub-tag of this type
+     * appears in a HPROF_HEAP_DUMP or HPROF_HEAP_DUMP_SEGMENT record, entries that follow it will
+     * be associated with the specified heap.  The HEAP_DUMP_INFO data is reset at the end of the
+     * HEAP_DUMP[_SEGMENT].  Multiple HEAP_DUMP_INFO entries may appear in a single
+     * HEAP_DUMP[_SEGMENT].
+     *
+     * Format: u1: Tag value (0xFE) u4: heap ID ID: heap name string ID
+     */
+    internal const val HEAP_DUMP_INFO = 0xfe
+    internal const val ROOT_INTERNED_STRING = 0x89
+    internal const val ROOT_FINALIZING = 0x8a
+    internal const val ROOT_DEBUGGER = 0x8b
+    internal const val ROOT_REFERENCE_CLEANUP = 0x8c
+    internal const val ROOT_VM_INTERNAL = 0x8d
+    internal const val ROOT_JNI_MONITOR = 0x8e
+    internal const val ROOT_UNREACHABLE = 0x90
+    internal const val PRIMITIVE_ARRAY_NODATA = 0xc3
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt b/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt
new file mode 100644
index 00000000..596228ef
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt
@@ -0,0 +1,411 @@
+package leakcanary
+
+import leakcanary.HeapValue.BooleanValue
+import leakcanary.HeapValue.ByteValue
+import leakcanary.HeapValue.CharValue
+import leakcanary.HeapValue.DoubleValue
+import leakcanary.HeapValue.FloatValue
+import leakcanary.HeapValue.IntValue
+import leakcanary.HeapValue.LongValue
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.HeapValue.ShortValue
+import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import okio.BufferedSource
+import java.io.Closeable
+import java.nio.charset.Charset
+
+/**
+ * Not thread safe, should be used from a single thread.
+ */
+open class HprofReader constructor(
+  protected var source: BufferedSource,
+  protected val startPosition: Long,
+  val idSize: Int
+): Closeable {
+  override fun close() {
+    source.close()
+  }
+
+  var position: Long = startPosition
+    protected set
+
+  val isOpen
+    get() = source.isOpen
+
+  val typeSizes = mapOf(
+      // object
+      OBJECT_TYPE to idSize,
+      BOOLEAN_TYPE to BOOLEAN_SIZE,
+      CHAR_TYPE to CHAR_SIZE,
+      FLOAT_TYPE to FLOAT_SIZE,
+      DOUBLE_TYPE to DOUBLE_SIZE,
+      BYTE_TYPE to BYTE_SIZE,
+      SHORT_TYPE to SHORT_SIZE,
+      INT_TYPE to INT_SIZE,
+      LONG_TYPE to LONG_SIZE
+  )
+
+  fun readValue(type: Int): HeapValue {
+    return when (type) {
+      OBJECT_TYPE -> ObjectReference(readId())
+      BOOLEAN_TYPE -> BooleanValue(readBoolean())
+      CHAR_TYPE -> CharValue(readChar())
+      FLOAT_TYPE -> FloatValue(readFloat())
+      DOUBLE_TYPE -> DoubleValue(readDouble())
+      BYTE_TYPE -> ByteValue(readByte())
+      SHORT_TYPE -> ShortValue(readShort())
+      INT_TYPE -> IntValue(readInt())
+      LONG_TYPE -> LongValue(readLong())
+      else -> throw IllegalStateException("Unknown type $type")
+    }
+  }
+
+  fun typeSize(type: Int): Int {
+    return typeSizes.getValue(type)
+  }
+
+  fun readShort(): Short {
+    position += SHORT_SIZE
+    return source.readShort()
+  }
+
+  fun readInt(): Int {
+    position += INT_SIZE
+    return source.readInt()
+  }
+
+  fun readIdArray(arrayLength: Int): LongArray {
+    return LongArray(arrayLength) { readId() }
+  }
+
+  fun readBooleanArray(arrayLength: Int): BooleanArray {
+    return BooleanArray(arrayLength) { readByte().toInt() != 0 }
+  }
+
+  fun readCharArray(arrayLength: Int): CharArray {
+    return readString(CHAR_SIZE * arrayLength, Charsets.UTF_16BE).toCharArray()
+  }
+
+  fun readString(
+    byteCount: Int,
+    charset: Charset
+  ): String {
+    position += byteCount
+    return source.readString(byteCount.toLong(), charset)
+  }
+
+  fun readFloatArray(arrayLength: Int): FloatArray {
+    return FloatArray(arrayLength) { readFloat() }
+  }
+
+  fun readDoubleArray(arrayLength: Int): DoubleArray {
+    return DoubleArray(arrayLength) { readDouble() }
+  }
+
+  fun readShortArray(arrayLength: Int): ShortArray {
+    return ShortArray(arrayLength) { readShort() }
+  }
+
+  fun readIntArray(arrayLength: Int): IntArray {
+    return IntArray(arrayLength) { readInt() }
+  }
+
+  fun readLongArray(arrayLength: Int): LongArray {
+    return LongArray(arrayLength) { readLong() }
+  }
+
+  fun readLong(): Long {
+    position += LONG_SIZE
+    return source.readLong()
+  }
+
+  fun exhausted() = source.exhausted()
+
+  open fun skip(byteCount: Long) {
+    position += byteCount
+    return source.skip(byteCount)
+  }
+
+  fun readByte(): Byte {
+    position += BYTE_SIZE
+    return source.readByte()
+  }
+
+  fun readBoolean(): Boolean {
+    position += BOOLEAN_SIZE
+    return source.readByte().toInt() != 0
+  }
+
+  fun readByteArray(byteCount: Int): ByteArray {
+    position += byteCount
+    return source.readByteArray(byteCount.toLong())
+  }
+
+  fun readChar(): Char {
+    return readString(CHAR_SIZE, Charsets.UTF_16BE)[0]
+  }
+
+  fun readFloat(): Float {
+    return Float.fromBits(readInt())
+  }
+
+  fun readDouble(): Double {
+    return Double.fromBits(readLong())
+  }
+
+  fun readId(): Long {
+    // As long as we don't interpret IDs, reading signed values here is fine.
+    return when (idSize) {
+      1 -> readByte().toLong()
+      2 -> readShort().toLong()
+      4 -> readInt().toLong()
+      8 -> readLong()
+      else -> throw IllegalArgumentException("ID Length must be 1, 2, 4, or 8")
+    }
+  }
+
+  fun readUtf8(byteCount: Long): String {
+    position += byteCount
+    return source.readUtf8(byteCount)
+  }
+
+  fun readUnsignedInt(): Long {
+    return readInt().toLong() and INT_MASK
+  }
+
+  fun readUnsignedByte(): Int {
+    return readByte().toInt() and BYTE_MASK
+  }
+
+  fun readUnsignedShort(): Int {
+    return readShort().toInt() and 0xFFFF
+  }
+
+  fun skip(byteCount: Int) {
+    position += byteCount
+    return source.skip(byteCount.toLong())
+  }
+
+  fun readInstanceDumpRecord(): InstanceDumpRecord {
+    val id = readId()
+    val stackTraceSerialNumber = readInt()
+    val classId = readId()
+    val remainingBytesInInstance = readInt()
+    val fieldValues = readByteArray(remainingBytesInInstance)
+    return InstanceDumpRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        classId = classId,
+        fieldValues = fieldValues
+    )
+  }
+
+  fun readClassDumpRecord(): ClassDumpRecord {
+    val id = readId()
+    // stack trace serial number
+    val stackTraceSerialNumber = readInt()
+    val superClassId = readId()
+    // class loader object ID
+    val classLoaderId = readId()
+    // signers object ID
+    val signersId = readId()
+    // protection domain object ID
+    val protectionDomainId = readId()
+    // reserved
+    readId()
+    // reserved
+    readId()
+
+    // instance size (in bytes)
+    // Useful to compute retained size
+    val instanceSize = readInt()
+
+    // Skip over the constant pool
+    val constantPoolCount = readUnsignedShort()
+    for (i in 0 until constantPoolCount) {
+      // constant pool index
+      skip(SHORT_SIZE)
+      skip(typeSize(readUnsignedByte()))
+    }
+
+    val staticFieldCount = readUnsignedShort()
+    val staticFields = ArrayList<StaticFieldRecord>(staticFieldCount)
+    for (i in 0 until staticFieldCount) {
+
+      val nameStringId = readId()
+      val type = readUnsignedByte()
+      val value = readValue(type)
+
+      staticFields.add(
+          StaticFieldRecord(
+              nameStringId = nameStringId,
+              type = type,
+              value = value
+          )
+      )
+    }
+
+    val fieldCount = readUnsignedShort()
+    val fields = ArrayList<FieldRecord>(fieldCount)
+    for (i in 0 until fieldCount) {
+      fields.add(FieldRecord(nameStringId = readId(), type = readUnsignedByte()))
+    }
+
+    return ClassDumpRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        superClassId = superClassId,
+        classLoaderId = classLoaderId,
+        signersId = signersId,
+        protectionDomainId = protectionDomainId,
+        instanceSize = instanceSize,
+        staticFields = staticFields,
+        fields = fields
+    )
+  }
+
+  fun skipInstanceDumpRecord() {
+    skip(idSize + INT_SIZE + idSize)
+    val remainingBytesInInstance = readInt()
+    skip(remainingBytesInInstance)
+  }
+
+  fun skipClassDumpRecord() {
+    skip(
+        idSize + INT_SIZE + idSize + idSize + idSize + idSize + idSize + idSize + INT_SIZE
+    )
+    // Skip over the constant pool
+    val constantPoolCount = readUnsignedShort()
+    for (i in 0 until constantPoolCount) {
+      // constant pool index
+      skip(SHORT_SIZE)
+      skip(typeSize(readUnsignedByte()))
+    }
+
+    val staticFieldCount = readUnsignedShort()
+
+    for (i in 0 until staticFieldCount) {
+      skip(idSize)
+      val type = readUnsignedByte()
+      skip(typeSize(type))
+    }
+
+    val fieldCount = readUnsignedShort()
+    skip(fieldCount * (idSize + BYTE_SIZE))
+  }
+
+  fun readObjectArrayDumpRecord(
+  ): ObjectArrayDumpRecord {
+    val id = readId()
+    // stack trace serial number
+    val stackTraceSerialNumber = readInt()
+    val arrayLength = readInt()
+    val arrayClassId = readId()
+    val elementIds = readIdArray(arrayLength)
+    return ObjectArrayDumpRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        arrayClassId = arrayClassId,
+        elementIds = elementIds
+    )
+  }
+
+  fun skipObjectArrayDumpRecord() {
+    skip(idSize + INT_SIZE)
+    val arrayLength = readInt()
+    skip(idSize + arrayLength * idSize)
+  }
+
+  fun readPrimitiveArrayDumpRecord(): PrimitiveArrayDumpRecord {
+    val id = readId()
+    val stackTraceSerialNumber = readInt()
+    // length
+    val arrayLength = readInt()
+    val type = readUnsignedByte()
+    return when (type) {
+      BOOLEAN_TYPE -> BooleanArrayDump(
+          id, stackTraceSerialNumber, readBooleanArray(arrayLength)
+      )
+      CHAR_TYPE -> CharArrayDump(
+          id, stackTraceSerialNumber, readCharArray(arrayLength)
+      )
+      FLOAT_TYPE -> FloatArrayDump(
+          id, stackTraceSerialNumber, readFloatArray(arrayLength)
+      )
+      DOUBLE_TYPE -> DoubleArrayDump(
+          id, stackTraceSerialNumber, readDoubleArray(arrayLength)
+      )
+      BYTE_TYPE -> ByteArrayDump(
+          id, stackTraceSerialNumber, readByteArray(arrayLength)
+      )
+      SHORT_TYPE -> ShortArrayDump(
+          id, stackTraceSerialNumber, readShortArray(arrayLength)
+      )
+      INT_TYPE -> IntArrayDump(
+          id, stackTraceSerialNumber, readIntArray(arrayLength)
+      )
+      LONG_TYPE -> LongArrayDump(
+          id, stackTraceSerialNumber, readLongArray(arrayLength)
+      )
+      else -> throw IllegalStateException("Unexpected type $type")
+    }
+  }
+
+  fun skipPrimitiveArrayDumpRecord() {
+    skip(idSize + INT_SIZE)
+    val arrayLength = readInt()
+    val type = readUnsignedByte()
+    skip(idSize + arrayLength * typeSize(type))
+  }
+
+  fun readHeapDumpInfoRecord(): HeapDumpInfoRecord {
+    val heapId = readInt()
+    return HeapDumpInfoRecord(heapId = heapId, heapNameStringId = readId())
+  }
+
+  fun skipHeapDumpInfoRecord() {
+    skip(idSize + idSize)
+  }
+
+  val tagPositionAfterReadingId
+    get() = position - (idSize + BYTE_SIZE)
+
+  companion object {
+    const val BOOLEAN_SIZE = 1
+    const val CHAR_SIZE = 2
+    const val FLOAT_SIZE = 4
+    const val DOUBLE_SIZE = 8
+    const val BYTE_SIZE = 1
+    const val SHORT_SIZE = 2
+    const val INT_SIZE = 4
+    const val LONG_SIZE = 8
+
+    const val OBJECT_TYPE = 2
+    const val BOOLEAN_TYPE = 4
+    const val CHAR_TYPE = 5
+    const val FLOAT_TYPE = 6
+    const val DOUBLE_TYPE = 7
+    const val BYTE_TYPE = 8
+    const val SHORT_TYPE = 9
+    const val INT_TYPE = 10
+    const val LONG_TYPE = 11
+
+    const val INT_MASK = 0xffffffffL
+    const val BYTE_MASK = 0xff
+  }
+
+}
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt b/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt
new file mode 100644
index 00000000..421f922d
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt
@@ -0,0 +1,404 @@
+package leakcanary
+
+import leakcanary.GcRoot.Debugger
+import leakcanary.GcRoot.Finalizing
+import leakcanary.GcRoot.InternedString
+import leakcanary.GcRoot.JavaFrame
+import leakcanary.GcRoot.JniGlobal
+import leakcanary.GcRoot.JniLocal
+import leakcanary.GcRoot.JniMonitor
+import leakcanary.GcRoot.MonitorUsed
+import leakcanary.GcRoot.NativeStack
+import leakcanary.GcRoot.ReferenceCleanup
+import leakcanary.GcRoot.StickyClass
+import leakcanary.GcRoot.ThreadBlock
+import leakcanary.GcRoot.ThreadObject
+import leakcanary.GcRoot.Unknown
+import leakcanary.GcRoot.Unreachable
+import leakcanary.GcRoot.VmInternal
+import leakcanary.HeapValue.BooleanValue
+import leakcanary.HeapValue.ByteValue
+import leakcanary.HeapValue.CharValue
+import leakcanary.HeapValue.DoubleValue
+import leakcanary.HeapValue.FloatValue
+import leakcanary.HeapValue.IntValue
+import leakcanary.HeapValue.LongValue
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.HeapValue.ShortValue
+import leakcanary.Record.HeapDumpEndRecord
+import leakcanary.Record.HeapDumpRecord.GcRootRecord
+import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import leakcanary.Record.LoadClassRecord
+import leakcanary.Record.StackTraceRecord
+import leakcanary.Record.StringRecord
+import okio.Buffer
+import okio.BufferedSink
+import okio.buffer
+import okio.sink
+import java.io.Closeable
+import java.io.File
+
+class HprofWriter private constructor(
+  private val sink: BufferedSink,
+  val idSize: Int
+) : Closeable {
+
+  private val workBuffer = Buffer()
+
+  fun write(record: Record) {
+    sink.write(record)
+  }
+
+  private fun BufferedSink.write(record: Record) {
+    when (record) {
+      is StringRecord -> {
+        writeNonHeapRecord(HprofPushRecordsParser.STRING_IN_UTF8) {
+          writeId(record.id)
+          writeUtf8(record.string)
+        }
+      }
+      is LoadClassRecord -> {
+        writeNonHeapRecord(HprofPushRecordsParser.LOAD_CLASS) {
+          writeInt(record.classSerialNumber)
+          writeId(record.id)
+          writeInt(record.stackTraceSerialNumber)
+          writeId(record.classNameStringId)
+        }
+      }
+      is StackTraceRecord -> {
+        writeNonHeapRecord(HprofPushRecordsParser.STACK_TRACE) {
+          writeInt(record.stackTraceSerialNumber)
+          writeInt(record.threadSerialNumber)
+          writeInt(record.stackFrameIds.size)
+          writeIdArray(record.stackFrameIds)
+        }
+      }
+      is GcRootRecord -> {
+        with(workBuffer) {
+          when (val gcRoot = record.gcRoot) {
+            is Unknown -> {
+              writeByte(HprofPushRecordsParser.ROOT_UNKNOWN)
+              writeId(gcRoot.id)
+            }
+            is JniGlobal -> {
+              writeByte(
+                  HprofPushRecordsParser.ROOT_JNI_GLOBAL
+              )
+              writeId(gcRoot.id)
+              writeId(gcRoot.jniGlobalRefId)
+            }
+            is JniLocal -> {
+              writeByte(HprofPushRecordsParser.ROOT_JNI_LOCAL)
+              writeId(gcRoot.id)
+              writeInt(gcRoot.threadSerialNumber)
+              writeInt(gcRoot.frameNumber)
+            }
+            is JavaFrame -> {
+              writeByte(HprofPushRecordsParser.ROOT_JAVA_FRAME)
+              writeId(gcRoot.id)
+              writeInt(gcRoot.threadSerialNumber)
+              writeInt(gcRoot.frameNumber)
+            }
+            is NativeStack -> {
+              writeByte(HprofPushRecordsParser.ROOT_NATIVE_STACK)
+              writeId(gcRoot.id)
+              writeInt(gcRoot.threadSerialNumber)
+            }
+            is StickyClass -> {
+              writeByte(HprofPushRecordsParser.ROOT_STICKY_CLASS)
+              writeId(gcRoot.id)
+            }
+            is ThreadBlock -> {
+              writeByte(HprofPushRecordsParser.ROOT_THREAD_BLOCK)
+              writeId(gcRoot.id)
+              writeInt(gcRoot.threadSerialNumber)
+            }
+            is MonitorUsed -> {
+              writeByte(HprofPushRecordsParser.ROOT_MONITOR_USED)
+              writeId(gcRoot.id)
+            }
+            is ThreadObject -> {
+              writeByte(HprofPushRecordsParser.ROOT_THREAD_OBJECT)
+              writeId(gcRoot.id)
+              writeInt(gcRoot.threadSerialNumber)
+              writeInt(gcRoot.stackTraceSerialNumber)
+            }
+            is ReferenceCleanup -> {
+              writeByte(HprofPushRecordsParser.ROOT_REFERENCE_CLEANUP)
+              writeId(gcRoot.id)
+            }
+            is VmInternal -> {
+              writeByte(HprofPushRecordsParser.ROOT_VM_INTERNAL)
+              writeId(gcRoot.id)
+            }
+            is JniMonitor -> {
+              writeByte(HprofPushRecordsParser.ROOT_JNI_MONITOR)
+              writeId(gcRoot.id)
+              writeInt(gcRoot.stackTraceSerialNumber)
+              writeInt(gcRoot.stackDepth)
+            }
+            is InternedString -> {
+              writeByte(HprofPushRecordsParser.ROOT_INTERNED_STRING)
+              writeId(gcRoot.id)
+            }
+            is Finalizing -> {
+              writeByte(HprofPushRecordsParser.ROOT_FINALIZING)
+              writeId(gcRoot.id)
+            }
+            is Debugger -> {
+              writeByte(HprofPushRecordsParser.ROOT_DEBUGGER)
+              writeId(gcRoot.id)
+            }
+            is Unreachable -> {
+              writeByte(HprofPushRecordsParser.ROOT_UNREACHABLE)
+              writeId(gcRoot.id)
+            }
+          }
+        }
+      }
+      is ClassDumpRecord -> {
+        with(workBuffer) {
+          writeByte(HprofPushRecordsParser.CLASS_DUMP)
+          writeId(record.id)
+          writeInt(record.stackTraceSerialNumber)
+          writeId(record.superClassId)
+          writeId(record.classLoaderId)
+          writeId(record.signersId)
+          writeId(record.protectionDomainId)
+          // reserved
+          writeId(0)
+          // reserved
+          writeId(0)
+          writeInt(record.instanceSize)
+          // Not writing anything in the constant pool
+          val constantPoolCount = 0
+          writeShort(constantPoolCount)
+          writeShort(record.staticFields.size)
+          record.staticFields.forEach { field ->
+            writeId(field.nameStringId)
+            writeByte(field.type)
+            writeValue(field.value)
+          }
+          writeShort(record.fields.size)
+          record.fields.forEach { field ->
+            writeId(field.nameStringId)
+            writeByte(field.type)
+          }
+        }
+      }
+      is InstanceDumpRecord -> {
+        with(workBuffer) {
+          writeByte(HprofPushRecordsParser.INSTANCE_DUMP)
+          writeId(record.id)
+          writeInt(record.stackTraceSerialNumber)
+          writeId(record.classId)
+          writeInt(record.fieldValues.size)
+          write(record.fieldValues)
+        }
+      }
+      is ObjectArrayDumpRecord -> {
+        with(workBuffer) {
+          writeByte(HprofPushRecordsParser.OBJECT_ARRAY_DUMP)
+          writeId(record.id)
+          writeInt(record.stackTraceSerialNumber)
+          writeInt(record.elementIds.size)
+          writeId(record.arrayClassId)
+          writeIdArray(record.elementIds)
+        }
+      }
+      is PrimitiveArrayDumpRecord -> {
+        with(workBuffer) {
+          writeByte(HprofPushRecordsParser.PRIMITIVE_ARRAY_DUMP)
+          writeId(record.id)
+          writeInt(record.stackTraceSerialNumber)
+
+          when (record) {
+            is BooleanArrayDump -> {
+              writeInt(record.array.size)
+              writeByte(HprofReader.BOOLEAN_TYPE)
+              write(record.array)
+            }
+            is CharArrayDump -> {
+              writeInt(record.array.size)
+              writeByte(HprofReader.CHAR_TYPE)
+              write(record.array)
+            }
+            is FloatArrayDump -> {
+              writeInt(record.array.size)
+              writeByte(HprofReader.FLOAT_TYPE)
+              write(record.array)
+            }
+            is DoubleArrayDump -> {
+              writeInt(record.array.size)
+              writeByte(HprofReader.DOUBLE_TYPE)
+              write(record.array)
+            }
+            is ByteArrayDump -> {
+              writeInt(record.array.size)
+              writeByte(HprofReader.BYTE_TYPE)
+              write(record.array)
+            }
+            is ShortArrayDump -> {
+              writeInt(record.array.size)
+              writeByte(HprofReader.SHORT_TYPE)
+              write(record.array)
+            }
+            is IntArrayDump -> {
+              writeInt(record.array.size)
+              writeByte(HprofReader.INT_TYPE)
+              write(record.array)
+            }
+            is LongArrayDump -> {
+              writeInt(record.array.size)
+              writeByte(HprofReader.LONG_TYPE)
+              write(record.array)
+            }
+          }
+        }
+      }
+      is HeapDumpInfoRecord -> {
+        with(workBuffer) {
+          writeByte(HprofPushRecordsParser.HEAP_DUMP_INFO)
+          writeInt(record.heapId)
+          writeId(record.heapNameStringId)
+        }
+      }
+      is HeapDumpEndRecord -> {
+        throw IllegalArgumentException("HprofWriter automatically emits HeapDumpEndRecord")
+      }
+    }
+  }
+
+  fun BufferedSink.writeValue(wrapper: HeapValue) {
+    when (wrapper) {
+      is ObjectReference -> writeId(wrapper.value)
+      is BooleanValue -> writeBoolean(wrapper.value)
+      is CharValue -> write(charArrayOf(wrapper.value))
+      is FloatValue -> writeFloat(wrapper.value)
+      is DoubleValue -> writeDouble(wrapper.value)
+      is ByteValue -> writeByte(wrapper.value.toInt())
+      is ShortValue -> writeShort(wrapper.value.toInt())
+      is IntValue -> writeInt(wrapper.value)
+      is LongValue -> writeLong(wrapper.value)
+    }
+  }
+
+  private fun BufferedSink.writeDouble(value: Double) {
+    writeLong(value.toBits())
+  }
+
+  private fun BufferedSink.writeFloat(value: Float) {
+    writeInt(value.toBits())
+  }
+
+  private fun BufferedSink.writeBoolean(value: Boolean) {
+    writeByte(if (value) 1 else 0)
+  }
+
+  private fun BufferedSink.writeIdArray(array: LongArray) {
+    array.forEach { writeId(it) }
+  }
+
+  private fun BufferedSink.write(array: BooleanArray) {
+    array.forEach { writeByte(if (it) 1 else 0) }
+  }
+
+  private fun BufferedSink.write(array: CharArray) {
+    writeString(String(array), Charsets.UTF_16BE)
+  }
+
+  private fun BufferedSink.write(array: FloatArray) {
+    array.forEach { writeFloat(it) }
+  }
+
+  private fun BufferedSink.write(array: DoubleArray) {
+    array.forEach { writeDouble(it) }
+  }
+
+  private fun BufferedSink.write(array: ShortArray) {
+    array.forEach { writeShort(it.toInt()) }
+  }
+
+  private fun BufferedSink.write(array: IntArray) {
+    array.forEach { writeInt(it) }
+  }
+
+  private fun BufferedSink.write(array: LongArray) {
+    array.forEach { writeLong(it) }
+  }
+
+  private fun BufferedSink.writeNonHeapRecord(
+    tag: Int,
+    block: BufferedSink.() -> Unit
+  ) {
+    flushHeapBuffer()
+    workBuffer.block()
+    writeTagHeader(tag, workBuffer.size)
+    writeAll(workBuffer)
+  }
+
+  private fun BufferedSink.flushHeapBuffer() {
+    if (workBuffer.size > 0) {
+      writeTagHeader(HprofPushRecordsParser.HEAP_DUMP, workBuffer.size)
+      writeAll(workBuffer)
+      writeTagHeader(HprofPushRecordsParser.HEAP_DUMP_END, 0)
+    }
+  }
+
+  private fun BufferedSink.writeTagHeader(
+    tag: Int,
+    length: Long
+  ) {
+    writeByte(tag)
+    // number of microseconds since the time stamp in the header
+    writeInt(0)
+    writeInt(length.toInt())
+  }
+
+  private fun BufferedSink.writeId(id: Long) {
+    when (idSize) {
+      1 -> writeByte(id.toInt())
+      2 -> writeShort(id.toInt())
+      4 -> writeInt(id.toInt())
+      8 -> writeLong(id)
+      else -> throw IllegalArgumentException("ID Length must be 1, 2, 4, or 8")
+    }
+  }
+
+  override fun close() {
+    sink.flushHeapBuffer()
+    sink.close()
+  }
+
+  companion object {
+    fun open(
+      hprofFile: File,
+      idSize: Int = 4
+    ): HprofWriter {
+
+      val sink = hprofFile.outputStream()
+          .sink()
+          .buffer()
+
+      val hprofVersion = "JAVA PROFILE 1.0.3"
+      sink.writeUtf8(hprofVersion)
+      sink.writeByte(0)
+      sink.writeInt(idSize)
+      val heapDumpTimestamp = System.currentTimeMillis()
+      sink.writeLong(heapDumpTimestamp)
+      return HprofWriter(sink, idSize)
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HydratedClass.kt b/leakcanary-haha/src/main/java/leakcanary/HydratedClass.kt
new file mode 100644
index 00000000..f3d730f9
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/HydratedClass.kt
@@ -0,0 +1,60 @@
+package leakcanary
+
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+
+class HydratedClass(
+  val record: ClassDumpRecord,
+  val className: String,
+  val staticFieldNames: List<String>,
+  val fieldNames: List<String>
+) {
+  inline fun <reified T : HeapValue> staticFieldValue(name: String): T {
+    return staticFieldValueOrNull(name) ?: throw IllegalArgumentException(
+        "Could not find static field $name in class $className with id ${record.id} and static fields $staticFieldNames"
+    )
+  }
+
+  fun fieldType(name: String): Int {
+    fieldNames.forEachIndexed { index, fieldName ->
+      if (fieldName == name) {
+        return record.fields[index].type
+      }
+    }
+    throw IllegalArgumentException(
+        "Could not find field $name in class $className with id ${record.id} and fields $fieldNames"
+    )
+  }
+
+  inline fun <reified T : HeapValue> staticFieldValueOrNull(name: String): T? {
+    staticFieldNames.forEachIndexed { fieldIndex, fieldName ->
+      if (fieldName == name) {
+        val fieldValue = record.staticFields[fieldIndex].value
+        return if (fieldValue is T) {
+          fieldValue
+        } else null
+      }
+    }
+    return null
+  }
+
+  operator fun get(name: String): HeapValue? = staticFieldValueOrNull(name)
+
+  fun hasStaticField(name: String): Boolean {
+    staticFieldNames.forEach { fieldName ->
+      if (fieldName == name) {
+        return true
+      }
+    }
+    return false
+  }
+
+  val simpleClassName: String
+    get() {
+      val separator = className.lastIndexOf('.')
+      return if (separator == -1) {
+        className
+      } else {
+        className.substring(separator + 1)
+      }
+    }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HydratedInstance.kt b/leakcanary-haha/src/main/java/leakcanary/HydratedInstance.kt
new file mode 100644
index 00000000..87affe41
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/HydratedInstance.kt
@@ -0,0 +1,49 @@
+package leakcanary
+
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+
+class HydratedInstance(
+  val record: InstanceDumpRecord,
+  val classHierarchy: List<HydratedClass>,
+  /**
+   * One list of field values per class
+   */
+  val fieldValues: List<List<HeapValue>>
+) {
+  inline fun <reified T : HeapValue> fieldValue(name: String): T {
+    return fieldValueOrNull(name) ?: throw IllegalArgumentException(
+        "Could not find field $name in instance with id ${record.id}"
+    )
+  }
+
+  inline fun <reified T : HeapValue> fieldValueOrNull(name: String): T? {
+    classHierarchy.forEachIndexed { classIndex, hydratedClass ->
+      hydratedClass.fieldNames.forEachIndexed { fieldIndex, fieldName ->
+        if (fieldName == name) {
+          val fieldValue = fieldValues[classIndex][fieldIndex]
+          return if (fieldValue is T) {
+            fieldValue
+          } else null
+        }
+      }
+    }
+    return null
+  }
+
+  operator fun get(name: String): HeapValue? = fieldValueOrNull(name)
+
+  fun hasField(name: String): Boolean {
+    classHierarchy.forEach { hydratedClass ->
+      hydratedClass.fieldNames.forEach { fieldName ->
+        if (fieldName == name) {
+          return true
+        }
+      }
+    }
+    return false
+  }
+
+  fun isInstanceOf(className: String): Boolean {
+    return classHierarchy.any { it.className == className }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/PrimitiveType.kt b/leakcanary-haha/src/main/java/leakcanary/PrimitiveType.kt
new file mode 100644
index 00000000..f809124d
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/PrimitiveType.kt
@@ -0,0 +1,12 @@
+package leakcanary
+
+enum class PrimitiveType {
+  BOOLEAN,
+  CHAR,
+  FLOAT,
+  DOUBLE,
+  BYTE,
+  SHORT,
+  INT,
+  LONG
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/Record.kt b/leakcanary-haha/src/main/java/leakcanary/Record.kt
new file mode 100644
index 00000000..cd139855
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/Record.kt
@@ -0,0 +1,173 @@
+package leakcanary
+
+sealed class Record {
+  class StringRecord(
+    val id: Long,
+    val string: String
+  ) : Record()
+
+  class LoadClassRecord(
+    val classSerialNumber: Int,
+    val id: Long,
+    val stackTraceSerialNumber: Int,
+    val classNameStringId: Long
+  ) : Record()
+
+  object HeapDumpEndRecord : Record()
+
+  class StackFrameRecord(
+    val id: Long,
+    val methodNameStringId: Long,
+    val methodSignatureStringId: Long,
+    val sourceFileNameStringId: Long,
+    val classSerialNumber: Int,
+    /**
+     * >0 line number
+     * 0 no line information available
+     * -1 unknown location
+     * -2 compiled method (Not implemented)
+     * -3 native method (Not implemented)
+     */
+    val lineNumber: Int
+  ) : Record()
+
+  class StackTraceRecord(
+    val stackTraceSerialNumber: Int,
+    val threadSerialNumber: Int,
+    val stackFrameIds: LongArray
+  ) : Record()
+
+  sealed class HeapDumpRecord : Record() {
+    class GcRootRecord(
+      val gcRoot: GcRoot
+    ) : HeapDumpRecord()
+
+    sealed class ObjectRecord : HeapDumpRecord() {
+      class ClassDumpRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val superClassId: Long,
+        val classLoaderId: Long,
+        val signersId: Long,
+        val protectionDomainId: Long,
+        val instanceSize: Int,
+        val staticFields: List<StaticFieldRecord>,
+        val fields: List<FieldRecord>
+      ) : ObjectRecord() {
+        data class StaticFieldRecord(
+          val nameStringId: Long,
+          val type: Int,
+          val value: HeapValue
+        )
+
+        data class FieldRecord(
+          val nameStringId: Long,
+          val type: Int
+        )
+      }
+
+      class InstanceDumpRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val classId: Long,
+        val fieldValues: ByteArray
+      ) : ObjectRecord()
+
+      class ObjectArrayDumpRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val arrayClassId: Long,
+        val elementIds: LongArray
+      ) : ObjectRecord()
+
+      /**
+       * Note: we could move the arrays to the parent class as a ByteString or ByteArray
+       * and then each subtype can create a new array of the right type if needed.
+       * However, experimenting with live parsing has shown that we never to read arrays except
+       * when we want to display leak trace information, in which case we do need the data.
+       */
+      sealed class PrimitiveArrayDumpRecord : ObjectRecord() {
+        abstract val id: Long
+        abstract val stackTraceSerialNumber: Int
+        abstract val size: Int
+
+        class BooleanArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: BooleanArray
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
+
+        class CharArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: CharArray
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
+
+        class FloatArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: FloatArray
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
+
+        class DoubleArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: DoubleArray
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
+
+        class ByteArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: ByteArray
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
+
+        class ShortArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: ShortArray
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
+
+        class IntArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: IntArray
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
+
+        class LongArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: LongArray
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
+      }
+    }
+
+    class HeapDumpInfoRecord(
+      val heapId: Int,
+      val heapNameStringId: Long
+    ) : HeapDumpRecord()
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt b/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt
new file mode 100644
index 00000000..d5ec5a22
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt
@@ -0,0 +1,25 @@
+package leakcanary
+
+import okio.BufferedSource
+import java.nio.channels.FileChannel
+
+class SeekableHprofReader(
+  private val channel: FileChannel,
+  source: BufferedSource,
+  startPosition: Long,
+  idSize: Int
+) : HprofReader(source, startPosition, idSize) {
+
+  fun moveTo(newPosition: Long) {
+    if (position == newPosition) {
+      return
+    }
+    source.buffer.clear()
+    channel.position(newPosition)
+    position = newPosition
+  }
+
+  fun reset() {
+    moveTo(startPosition)
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt b/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt
new file mode 100644
index 00000000..031e1c9a
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt
@@ -0,0 +1,193 @@
+package leakcanary.internal
+
+import leakcanary.HprofPushRecordsParser.OnRecordListener
+import leakcanary.HprofReader
+import leakcanary.PrimitiveType
+import leakcanary.Record
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import leakcanary.Record.LoadClassRecord
+import leakcanary.Record.StringRecord
+import leakcanary.internal.IndexedObject.IndexedClass
+import leakcanary.internal.IndexedObject.IndexedInstance
+import leakcanary.internal.IndexedObject.IndexedObjectArray
+import leakcanary.internal.IndexedObject.IndexedPrimitiveArray
+import kotlin.reflect.KClass
+
+/**
+ * This class is not thread safe, should be used from a single thread.
+ */
+internal class HprofInMemoryIndex private constructor(
+  private val hprofStringCache: LongToStringSparseArray,
+  private val classNames: LongToLongSparseArray,
+  private val objectIndex: LongToObjectSparseArray<IndexedObject>,
+  private val typeSizes: Map<Int, Int>,
+  val primitiveWrapperTypes: Set<Long>
+) {
+  val idSize: Int
+    get() = typeSizes.getValue(HprofReader.OBJECT_TYPE)
+
+  fun sizeOfFieldType(hprofType: Int): Int = typeSizes.getValue(hprofType)
+
+  fun hprofStringById(id: Long): String {
+    return hprofStringCache[id] ?: throw IllegalArgumentException("Hprof string $id not in cache")
+  }
+
+  fun className(classId: Long): String {
+    // String, primitive types
+    return hprofStringById(classNames[classId])
+  }
+
+  fun classId(className: String): Long? {
+    // Note: this performs two linear scans over arrays
+    return hprofStringCache.getKey(className)
+        ?.let { stringId -> classNames.getKey(stringId) }
+  }
+
+  fun indexedClassSequence(): Sequence<Pair<Long, IndexedClass>> {
+    return objectIndex.entrySequence()
+        .filter { it.second is IndexedClass }
+        .map { it.first to it.second as IndexedClass }
+  }
+
+  fun indexedInstanceSequence(): Sequence<Pair<Long, IndexedInstance>> {
+    return objectIndex.entrySequence()
+        .filter { it.second is IndexedInstance }
+        .map { it.first to it.second as IndexedInstance }
+  }
+
+  fun indexedObject(objectId: Long): IndexedObject {
+    return objectIndex[objectId]
+  }
+
+  class Builder : OnRecordListener {
+    /**
+     * Map of string id to string
+     * This currently keeps all the hprof strings that we could care about: class names,
+     * static field names and instance fields names
+     */
+    // TODO Replacing with a radix trie reversed into a sparse array of long to trie leaf could save
+    // memory.
+    // Another option is to switch back to reading from the file system as necessary, and keep a much
+    // smaller cache for strings we need during shortest path (those are for exclusions)
+    private val hprofStringCache = LongToStringSparseArray(60000)
+
+    /**
+     * class id to string id
+     */
+    private val classNames = LongToLongSparseArray(20000)
+
+    /**
+     * Object id to [IndexedObject].
+     * The id can be for classes instances, classes, object arrays and primitive arrays
+     */
+    private val objectIndex = LongToObjectSparseArray<IndexedObject>(250000)
+
+    /**
+     * Class ids for primitive wrapper types
+     */
+    private val primitiveWrapperTypes = mutableSetOf<Long>()
+
+    /**
+     * String ids for class names of primitive wrapper types
+     */
+    private val primitiveWrapperClassNames = mutableSetOf<Long>()
+
+    private lateinit var typeSizes: Map<Int, Int>
+    private var consumed = false
+
+    override fun recordTypes(): Set<KClass<out Record>> = setOf(
+        StringRecord::class,
+        LoadClassRecord::class,
+        ClassDumpRecord::class,
+        InstanceDumpRecord::class,
+        ObjectArrayDumpRecord::class,
+        PrimitiveArrayDumpRecord::class
+    )
+
+    override fun onTypeSizesAvailable(typeSizes: Map<Int, Int>) {
+      this.typeSizes = typeSizes
+    }
+
+    override fun onRecord(
+      position: Long,
+      record: Record
+    ) {
+      if (consumed) {
+        throw IllegalStateException("This builder instance already produced a HprofInMemoryIndex")
+      }
+      when (record) {
+        is StringRecord -> {
+          if (PRIMITIVE_WRAPPER_TYPES.contains(record.string)) {
+            primitiveWrapperClassNames.add(record.id)
+          }
+          hprofStringCache[record.id] = record.string
+        }
+        is LoadClassRecord -> {
+          classNames[record.id] = record.classNameStringId
+          if (primitiveWrapperClassNames.contains(record.classNameStringId)) {
+            primitiveWrapperTypes.add(record.id)
+          }
+        }
+        is ClassDumpRecord -> {
+          objectIndex[record.id] = IndexedClass(position, record.superClassId, record.instanceSize)
+        }
+        is InstanceDumpRecord -> {
+          objectIndex[record.id] =
+            IndexedInstance(position, record.classId)
+        }
+        is ObjectArrayDumpRecord -> {
+          objectIndex[record.id] = IndexedObjectArray(position, record.arrayClassId)
+        }
+        is PrimitiveArrayDumpRecord -> {
+          val primitiveType = when (record) {
+            is BooleanArrayDump -> PrimitiveType.BOOLEAN
+            is CharArrayDump -> PrimitiveType.CHAR
+            is FloatArrayDump -> PrimitiveType.FLOAT
+            is DoubleArrayDump -> PrimitiveType.DOUBLE
+            is ByteArrayDump -> PrimitiveType.BYTE
+            is ShortArrayDump -> PrimitiveType.SHORT
+            is IntArrayDump -> PrimitiveType.INT
+            is LongArrayDump -> PrimitiveType.LONG
+          }
+          objectIndex[record.id] = IndexedPrimitiveArray(position, primitiveType)
+        }
+      }
+    }
+
+    fun buildIndex(): HprofInMemoryIndex {
+      consumed = true
+      // Passing references to avoid copying the underlying data structures.
+      return HprofInMemoryIndex(
+          hprofStringCache, classNames, objectIndex,
+          typeSizes,
+          primitiveWrapperTypes
+      )
+    }
+
+  }
+
+  companion object {
+
+    private val PRIMITIVE_WRAPPER_TYPES = setOf<String>(
+        Boolean::class.java.name, Char::class.java.name, Float::class.java.name,
+        Double::class.java.name, Byte::class.java.name, Short::class.java.name,
+        Int::class.java.name, Long::class.java.name
+    )
+
+    fun createOnRecordListener(): Builder {
+      return Builder()
+    }
+
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/IndexedObject.kt b/leakcanary-haha/src/main/java/leakcanary/internal/IndexedObject.kt
new file mode 100644
index 00000000..925fe8f1
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/IndexedObject.kt
@@ -0,0 +1,33 @@
+package leakcanary.internal
+
+import leakcanary.PrimitiveType
+
+internal sealed class IndexedObject {
+  abstract val position: Long
+
+  class IndexedClass(
+    override val position: Long,
+    val superClassId: Long,
+    val instanceSize: Int
+  ) : IndexedObject()
+
+  class IndexedInstance(
+    override val position: Long,
+    val classId: Long
+  ) : IndexedObject()
+
+  class IndexedObjectArray(
+    override val position: Long,
+    val arrayClassId: Long
+  ) : IndexedObject()
+
+  class IndexedPrimitiveArray(
+    override val position: Long,
+    primitiveType: PrimitiveType
+  ) : IndexedObject() {
+    private val primitiveTypeOrdinal: Byte = primitiveType.ordinal.toByte()
+    val primitiveType: PrimitiveType
+      get() = PrimitiveType.values()[primitiveTypeOrdinal.toInt()]
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToIntSparseArray.kt b/leakcanary-haha/src/main/java/leakcanary/internal/LongToIntSparseArray.kt
new file mode 100644
index 00000000..4f701ae1
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/LongToIntSparseArray.kt
@@ -0,0 +1,82 @@
+package leakcanary.internal
+
+import leakcanary.internal.SparseArrayUtils.appendInt
+import leakcanary.internal.SparseArrayUtils.appendLong
+import leakcanary.internal.SparseArrayUtils.binarySearch
+import leakcanary.internal.SparseArrayUtils.insertInt
+import leakcanary.internal.SparseArrayUtils.insertLong
+
+/**
+ * Same as [LongToLongSparseArray] but long to int instead.
+ */
+internal class LongToIntSparseArray(initialCapacity: Int) : Cloneable {
+  private var keys: LongArray
+  private var values: IntArray
+
+  var size: Int = 0
+    private set
+
+  init {
+    keys = LongArray(initialCapacity)
+    values = IntArray(initialCapacity)
+    size = 0
+  }
+
+  operator fun get(key: Long): Int {
+    val i = binarySearch(keys, size, key)
+
+    return if (i < 0 || values[i] == DELETED_INT) {
+      DELETED_INT
+    } else {
+      values[i]
+    }
+  }
+
+  operator fun set(
+    key: Long,
+    value: Int
+  ) {
+    require(value != DELETED_INT) {
+      "$DELETED_INT is a magic value that indicates a deleted entry"
+    }
+
+    if (size != 0 && key <= keys[size - 1]) {
+      insert(key, value)
+      return
+    }
+
+    keys = appendLong(keys, size, key)
+    values = appendInt(values, size, value)
+    size++
+  }
+
+  private fun insert(
+    key: Long,
+    value: Int
+  ) {
+    if (value == DELETED_INT) {
+      throw IllegalArgumentException("$DELETED_INT is a special value")
+    }
+    var i = binarySearch(keys, size, key)
+
+    if (i >= 0) {
+      values[i] = value
+    } else {
+      i = i.inv()
+
+      if (i < size && values[i] == DELETED_INT) {
+        keys[i] = key
+        values[i] = value
+        return
+      }
+
+      keys = insertLong(keys, size, i, key)
+      values = insertInt(values, size, i, value)
+      size++
+    }
+  }
+
+  companion object {
+    private const val DELETED_INT = 0
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToLongSparseArray.kt b/leakcanary-haha/src/main/java/leakcanary/internal/LongToLongSparseArray.kt
new file mode 100644
index 00000000..4a9dd23c
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/LongToLongSparseArray.kt
@@ -0,0 +1,93 @@
+package leakcanary.internal
+
+import leakcanary.internal.SparseArrayUtils.appendLong
+import leakcanary.internal.SparseArrayUtils.binarySearch
+import leakcanary.internal.SparseArrayUtils.insertLong
+
+/**
+ * Based on android.util.LongSparseArray, but with several tweaks:
+ *
+ * - Values array is a LongArray
+ * - No compaction, ever. This object can only keep growing, until it is garbage collected. Note
+ * that there is no remove() method.
+ */
+internal class LongToLongSparseArray(initialCapacity: Int) : Cloneable {
+  private var keys: LongArray
+  private var values: LongArray
+
+  var size: Int = 0
+    private set
+
+  init {
+    keys = LongArray(initialCapacity)
+    values = LongArray(initialCapacity)
+    size = 0
+  }
+
+  operator fun get(key: Long): Long {
+    val i = binarySearch(keys, size, key)
+
+    return if (i < 0 || values[i] == DELETED_LONG) {
+      DELETED_LONG
+    } else {
+      values[i]
+    }
+  }
+
+  fun getKey(value: Long): Long? {
+    for (i in 0 until size) {
+      if (values[i] == value) {
+        return keys[i]
+      }
+    }
+    return null
+  }
+
+  operator fun set(
+    key: Long,
+    value: Long
+  ) {
+    require(value != DELETED_LONG) {
+      "$DELETED_LONG is a magic value that indicates a deleted entry"
+    }
+
+    if (size != 0 && key <= keys[size - 1]) {
+      insert(key, value)
+      return
+    }
+
+    keys = appendLong(keys, size, key)
+    values = appendLong(values, size, value)
+    size++
+  }
+
+  private fun insert(
+    key: Long,
+    value: Long
+  ) {
+    if (value == DELETED_LONG) {
+      throw IllegalArgumentException("$DELETED_LONG is a special value")
+    }
+    var i = binarySearch(keys, size, key)
+
+    if (i >= 0) {
+      values[i] = value
+    } else {
+      i = i.inv()
+
+      if (i < size && values[i] == DELETED_LONG) {
+        keys[i] = key
+        values[i] = value
+        return
+      }
+
+      keys = insertLong(keys, size, i, key)
+      values = insertLong(values, size, i, value)
+      size++
+    }
+  }
+
+  companion object {
+    private const val DELETED_LONG: Long = 0
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToObjectSparseArray.kt b/leakcanary-haha/src/main/java/leakcanary/internal/LongToObjectSparseArray.kt
new file mode 100644
index 00000000..cf2ff87a
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/LongToObjectSparseArray.kt
@@ -0,0 +1,77 @@
+package leakcanary.internal
+
+import leakcanary.internal.SparseArrayUtils.appendLong
+import leakcanary.internal.SparseArrayUtils.appendObject
+import leakcanary.internal.SparseArrayUtils.binarySearch
+import leakcanary.internal.SparseArrayUtils.insertLong
+import leakcanary.internal.SparseArrayUtils.insertObject
+
+/**
+ * Same as [LongToLongSparseArray] but long to object instead.
+ */
+internal class LongToObjectSparseArray<T>(initialCapacity: Int) : Cloneable {
+  private var keys: LongArray
+  private var values: Array<T?>
+
+  var size: Int = 0
+    private set
+
+  init {
+    keys = LongArray(initialCapacity)
+    @Suppress("UNCHECKED_CAST")
+    values = arrayOfNulls<Any?>(initialCapacity) as Array<T?>
+    size = 0
+  }
+
+  operator fun get(key: Long): T {
+    val i = binarySearch(keys, size, key)
+
+    return if (i < 0 || values[i] == null) {
+      throw NullPointerException("Key $key not set")
+    } else {
+      values[i]!!
+    }
+  }
+
+  operator fun set(
+    key: Long,
+    value: T
+  ) {
+    if (size != 0 && key <= keys[size - 1]) {
+      insert(key, value)
+      return
+    }
+
+    keys = appendLong(keys, size, key)
+    values = appendObject(values, size, value)
+    size++
+  }
+
+  fun entrySequence(): Sequence<Pair<Long, T>> {
+    return (0..size).asSequence().filter { values[it] != null }.map { keys[it] to values[it]!! }
+  }
+
+  private fun insert(
+    key: Long,
+    value: T
+  ) {
+    var i = binarySearch(keys, size, key)
+
+    if (i >= 0) {
+      values[i] = value
+    } else {
+      i = i.inv()
+
+      if (i < size && values[i] == null) {
+        keys[i] = key
+        values[i] = value
+        return
+      }
+
+      keys = insertLong(keys, size, i, key)
+      values = insertObject(values, size, i, value)
+      size++
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToStringSparseArray.kt b/leakcanary-haha/src/main/java/leakcanary/internal/LongToStringSparseArray.kt
new file mode 100644
index 00000000..67ec9435
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/LongToStringSparseArray.kt
@@ -0,0 +1,81 @@
+package leakcanary.internal
+
+import leakcanary.internal.SparseArrayUtils.appendLong
+import leakcanary.internal.SparseArrayUtils.appendString
+import leakcanary.internal.SparseArrayUtils.binarySearch
+import leakcanary.internal.SparseArrayUtils.insertLong
+import leakcanary.internal.SparseArrayUtils.insertString
+
+/**
+ * Same as [LongToLongSparseArray] but long to string instead.
+ */
+internal class LongToStringSparseArray(initialCapacity: Int) : Cloneable {
+
+  private var keys: LongArray
+  private var values: Array<String?>
+
+  var size: Int = 0
+    private set
+
+  init {
+    keys = LongArray(initialCapacity)
+    values = arrayOfNulls(initialCapacity)
+    size = 0
+  }
+
+  operator fun get(key: Long): String? {
+    val i = binarySearch(keys, size, key)
+
+    return if (i < 0 || values[i] == null) {
+      null
+    } else {
+      values[i]
+    }
+  }
+
+  fun getKey(value: String): Long? {
+    for (i in 0 until size) {
+      if (values[i] == value) {
+        return keys[i]
+      }
+    }
+    return null
+  }
+
+  operator fun set(
+    key: Long,
+    value: String
+  ) {
+    if (size != 0 && key <= keys[size - 1]) {
+      insert(key, value)
+      return
+    }
+
+    keys = appendLong(keys, size, key)
+    values = appendString(values, size, value)
+    size++
+  }
+
+  private fun insert(
+    key: Long,
+    value: String
+  ) {
+    var i = binarySearch(keys, size, key)
+
+    if (i >= 0) {
+      values[i] = value
+    } else {
+      i = i.inv()
+
+      if (i < size && values[i] == null) {
+        keys[i] = key
+        values[i] = value
+        return
+      }
+
+      keys = insertLong(keys, size, i, key)
+      values = insertString(values, size, i, value)
+      size++
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LruCache.kt b/leakcanary-haha/src/main/java/leakcanary/internal/LruCache.kt
new file mode 100644
index 00000000..46d81d9b
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/LruCache.kt
@@ -0,0 +1,77 @@
+package leakcanary.internal
+
+import java.util.LinkedHashMap
+import kotlin.collections.MutableMap.MutableEntry
+
+/**
+ * API is a simplified version of android.util.LruCache
+ * Implementation is inspired from http://chriswu.me/blog/a-lru-cache-in-10-lines-of-java/
+ */
+internal class LruCache<K, V>(
+  val maxSize: Int
+) {
+  private val cache: LinkedHashMap<K, V>
+
+  val size
+    get() = cache.size
+
+  var putCount: Int = 0
+    private set
+  var evictionCount: Int = 0
+    private set
+  var hitCount: Int = 0
+    private set
+  var missCount: Int = 0
+    private set
+
+  init {
+    require(maxSize > 0) {
+      "maxSize=$maxSize <= 0"
+    }
+    this.cache = object : LinkedHashMap<K, V>(maxSize, 0.75f, true) {
+      override fun removeEldestEntry(eldest: MutableEntry<K, V>?) = if (size >= maxSize) {
+        evictionCount++
+        true
+      } else {
+        false
+      }
+    }
+  }
+
+  operator fun get(key: K?): V? {
+    // get() moves the key to the front
+    val value: V? = cache[key]
+    return if (value != null) {
+      hitCount++
+      value
+    } else {
+      missCount++
+      null
+    }
+  }
+
+  fun put(
+    key: K,
+    value: V
+  ): V? {
+    putCount++
+    return cache.put(key, value)
+  }
+
+  fun remove(key: K): V? {
+    return cache.remove(key)
+  }
+
+  fun evictAll() {
+    cache.clear()
+  }
+
+  override fun toString(): String {
+    val accesses = hitCount + missCount
+    val hitPercent = if (accesses != 0) 100 * hitCount / accesses else 0
+    return String.format(
+        "LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]",
+        maxSize, hitCount, missCount, hitPercent
+    )
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/SparseArrayUtils.kt b/leakcanary-haha/src/main/java/leakcanary/internal/SparseArrayUtils.kt
new file mode 100644
index 00000000..8a3e0557
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/SparseArrayUtils.kt
@@ -0,0 +1,170 @@
+package leakcanary.internal
+
+internal object SparseArrayUtils {
+
+  fun insertInt(
+    array: IntArray,
+    currentSize: Int,
+    index: Int,
+    element: Int
+  ): IntArray {
+    if (currentSize + 1 <= array.size) {
+      System.arraycopy(array, index, array, index + 1, currentSize - index)
+      array[index] = element
+      return array
+    }
+
+    val newArray = IntArray(growSize(currentSize))
+    System.arraycopy(array, 0, newArray, 0, index)
+    newArray[index] = element
+    System.arraycopy(array, index, newArray, index + 1, array.size - index)
+    return newArray
+  }
+
+  fun <T> insertObject(
+    array: Array<T?>,
+    currentSize: Int,
+    index: Int,
+    element: T
+  ): Array<T?> {
+    if (currentSize + 1 <= array.size) {
+      System.arraycopy(array, index, array, index + 1, currentSize - index)
+      array[index] = element
+      return array
+    }
+
+    @Suppress("UNCHECKED_CAST")
+    val newArray = arrayOfNulls<Any?>(growSize(currentSize)) as Array<T?>
+    System.arraycopy(array, 0, newArray, 0, index)
+    newArray[index] = element
+    System.arraycopy(array, index, newArray, index + 1, array.size - index)
+    return newArray
+  }
+
+  fun insertLong(
+    array: LongArray,
+    currentSize: Int,
+    index: Int,
+    element: Long
+  ): LongArray {
+    if (currentSize + 1 <= array.size) {
+      System.arraycopy(array, index, array, index + 1, currentSize - index)
+      array[index] = element
+      return array
+    }
+
+    val newArray = LongArray(growSize(currentSize))
+    System.arraycopy(array, 0, newArray, 0, index)
+    newArray[index] = element
+    System.arraycopy(array, index, newArray, index + 1, array.size - index)
+    return newArray
+  }
+
+  fun insertString(
+    array: Array<String?>,
+    currentSize: Int,
+    index: Int,
+    element: String?
+  ): Array<String?> {
+    if (currentSize + 1 <= array.size) {
+      System.arraycopy(array, index, array, index + 1, currentSize - index)
+      array[index] = element
+      return array
+    }
+
+    val newArray = arrayOfNulls<String>(growSize(currentSize))
+    System.arraycopy(array, 0, newArray, 0, index)
+    newArray[index] = element
+    System.arraycopy(array, index, newArray, index + 1, array.size - index)
+    return newArray
+  }
+
+  fun appendInt(
+    array: IntArray,
+    currentSize: Int,
+    element: Int
+  ): IntArray {
+    var returnedArray = array
+    if (currentSize + 1 > returnedArray.size) {
+      val newArray = IntArray(growSize(currentSize))
+      System.arraycopy(returnedArray, 0, newArray, 0, currentSize)
+      returnedArray = newArray
+    }
+    returnedArray[currentSize] = element
+    return returnedArray
+  }
+
+  fun appendLong(
+    array: LongArray,
+    currentSize: Int,
+    element: Long
+  ): LongArray {
+    var returnedArray = array
+    if (currentSize + 1 > returnedArray.size) {
+      val newArray = LongArray(growSize(currentSize))
+      System.arraycopy(returnedArray, 0, newArray, 0, currentSize)
+      returnedArray = newArray
+    }
+    returnedArray[currentSize] = element
+    return returnedArray
+  }
+
+  fun <T> appendObject(
+    array: Array<T?>,
+    currentSize: Int,
+    element: T
+  ): Array<T?> {
+    var returnedArray = array
+    if (currentSize + 1 > returnedArray.size) {
+      @Suppress("UNCHECKED_CAST")
+      val newArray = arrayOfNulls<Any?>(growSize(currentSize)) as Array<T?>
+      System.arraycopy(returnedArray, 0, newArray, 0, currentSize)
+      returnedArray = newArray
+    }
+    returnedArray[currentSize] = element
+    return returnedArray
+  }
+
+  fun appendString(
+    array: Array<String?>,
+    currentSize: Int,
+    element: String?
+  ): Array<String?> {
+    var returnedArray = array
+    if (currentSize + 1 > returnedArray.size) {
+
+      val newArray = arrayOfNulls<String>(growSize(currentSize))
+      System.arraycopy(returnedArray, 0, newArray, 0, currentSize)
+      returnedArray = newArray
+    }
+    returnedArray[currentSize] = element
+    return returnedArray
+  }
+
+  /**
+   * Android array helpers use 2. C++ uses 2. ArrayList uses 1.5
+   * We're dealing with large arrays here so being conservative is good for memory.
+   */
+  private fun growSize(currentSize: Int) = (currentSize * 1.5).toInt()
+
+  fun binarySearch(
+    array: LongArray?,
+    size: Int,
+    value: Long
+  ): Int {
+    var lo = 0
+    var hi = size - 1
+
+    while (lo <= hi) {
+      val mid = (lo + hi).ushr(1)
+      val midVal = array!![mid]
+
+      when {
+        midVal < value -> lo = mid + 1
+        midVal > value -> hi = mid - 1
+        else -> return mid  // value found
+      }
+    }
+    return lo.inv()  // value not present
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt b/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
new file mode 100644
index 00000000..a3d0b26d
--- /dev/null
+++ b/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
@@ -0,0 +1,132 @@
+package leakcanary
+
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.LoadClassRecord
+import leakcanary.Record.StringRecord
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+
+class HprofWriterTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+
+  private var lastId = 0L
+  private val id: Long
+    get() = ++lastId
+
+  @Test
+  fun writeAndReadHprof() {
+    val hprofFile = testFolder.newFile("temp.hprof")
+    val records = createRecords()
+
+    hprofFile.writeRecords(records)
+
+    hprofFile.readHprof { graph ->
+      val treasureChestClass = graph.indexedClass(TREASURE_CHEST_CLASS_NAME)!!
+      val baguetteInstance =
+        treasureChestClass[CONTENT_FIELD_NAME]!!.value.asObject!!.asInstance!!
+
+      assertThat(
+          baguetteInstance[BAGUETTE_CLASS_NAME, ANSWER_FIELD_NAME]!!.value.asInt!!
+      ).isEqualTo(42)
+    }
+  }
+
+  private fun createRecords(): List<Record> {
+    val magicWandClassName = StringRecord(id, MAGIC_WAND_CLASS_NAME)
+    val baguetteClassName = StringRecord(id, BAGUETTE_CLASS_NAME)
+    val answerFieldName = StringRecord(id, ANSWER_FIELD_NAME)
+    val treasureChestClassName = StringRecord(id, TREASURE_CHEST_CLASS_NAME)
+    val contentFieldName = StringRecord(id, CONTENT_FIELD_NAME)
+    val loadMagicWandClass = LoadClassRecord(1, id, 1, magicWandClassName.id)
+    val loadBaguetteClass = LoadClassRecord(1, id, 1, baguetteClassName.id)
+    val loadTreasureChestClass = LoadClassRecord(1, id, 1, treasureChestClassName.id)
+    val magicWandClassDump = ClassDumpRecord(
+        id = loadMagicWandClass.id,
+        stackTraceSerialNumber = 1,
+        superClassId = 0,
+        classLoaderId = 0,
+        signersId = 0,
+        protectionDomainId = 0,
+        instanceSize = 0,
+        staticFields = emptyList(),
+        fields = emptyList()
+    )
+    val baguetteClassDump = ClassDumpRecord(
+        id = loadBaguetteClass.id,
+        stackTraceSerialNumber = 1,
+        superClassId = loadMagicWandClass.id,
+        classLoaderId = 0,
+        signersId = 0,
+        protectionDomainId = 0,
+        instanceSize = 0,
+        staticFields = emptyList(),
+        fields = listOf(FieldRecord(answerFieldName.id, HprofReader.INT_TYPE))
+    )
+
+    val baguetteInstanceDump = InstanceDumpRecord(
+        id = id,
+        stackTraceSerialNumber = 1,
+        classId = loadBaguetteClass.id,
+        fieldValues = byteArrayOf(0x0, 0x0, 0x0, 0x2a)
+    )
+
+    val treasureChestClassDump = ClassDumpRecord(
+        id = loadTreasureChestClass.id,
+        stackTraceSerialNumber = 1,
+        superClassId = 0,
+        classLoaderId = 0,
+        signersId = 0,
+        protectionDomainId = 0,
+        instanceSize = 0,
+        staticFields = listOf(
+            StaticFieldRecord(
+                contentFieldName.id, HprofReader.OBJECT_TYPE,
+                ObjectReference(baguetteInstanceDump.id)
+            )
+        ),
+        fields = emptyList()
+    )
+
+    return listOf(
+        magicWandClassName, baguetteClassName, answerFieldName, treasureChestClassName,
+        contentFieldName, loadMagicWandClass,
+        loadBaguetteClass, loadTreasureChestClass,
+        magicWandClassDump, baguetteClassDump, baguetteInstanceDump, treasureChestClassDump
+    )
+  }
+
+  private fun File.writeRecords(
+    records: List<Record>
+  ) {
+    HprofWriter.open(this)
+        .use { writer ->
+          records.forEach { record ->
+            writer.write(record)
+          }
+        }
+  }
+
+  fun File.readHprof(block: (HprofGraph) -> Unit) {
+    val (graph, closeable) = HprofGraph.readHprof(this)
+    closeable.use {
+      block(graph)
+    }
+  }
+
+  companion object {
+    const val MAGIC_WAND_CLASS_NAME = "com.example.MagicWand"
+    const val BAGUETTE_CLASS_NAME = "com.example.Baguette"
+    const val ANSWER_FIELD_NAME = "answer"
+    const val TREASURE_CHEST_CLASS_NAME = "com.example.TreasureChest"
+    const val CONTENT_FIELD_NAME = "content"
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/build.gradle b/leakcanary-leaksentry/build.gradle
new file mode 100644
index 00000000..dd0f4e90
--- /dev/null
+++ b/leakcanary-leaksentry/build.gradle
@@ -0,0 +1,32 @@
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+
+dependencies {
+  api project(':leakcanary-watcher')
+
+  implementation deps.androidx.core
+  implementation deps.kotlin.stdlib
+  // Optional dependency
+  compileOnly deps.androidx.fragment
+}
+
+android {
+  compileSdkVersion versions.compileSdk
+
+  defaultConfig {
+    minSdkVersion versions.minSdk
+  }
+
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    check 'Interoperability'
+  }
+
+  // TODO replace with https://issuetracker.google.com/issues/72050365 once released.
+  libraryVariants.all {
+    it.generateBuildConfig.enabled = false
+  }
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-leaksentry/gradle.properties b/leakcanary-leaksentry/gradle.properties
new file mode 100644
index 00000000..a0b9bd2c
--- /dev/null
+++ b/leakcanary-leaksentry/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leaksentry
+POM_NAME=LeakSentry
+POM_PACKAGING=aar
diff --git a/leakcanary-analyzer/src/main/AndroidManifest.xml b/leakcanary-leaksentry/src/androidTest/AndroidManifest.xml
similarity index 81%
rename from leakcanary-analyzer/src/main/AndroidManifest.xml
rename to leakcanary-leaksentry/src/androidTest/AndroidManifest.xml
index 3bde165b..d23bb44d 100644
--- a/leakcanary-analyzer/src/main/AndroidManifest.xml
+++ b/leakcanary-leaksentry/src/androidTest/AndroidManifest.xml
@@ -1,5 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
 <!--
-  ~ Copyright (C) 2015 Square, Inc.
+  ~ Copyright (C) 2018 Square, Inc.
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
@@ -14,6 +15,5 @@
   ~ limitations under the License.
   -->
 <manifest
-    package="com.squareup.leakcanary.analyzer">
-  <application/>
+    package="com.squareup.leakcanary.instrumentation.test">
 </manifest>
diff --git a/leakcanary-leaksentry/src/main/AndroidManifest.xml b/leakcanary-leaksentry/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..3b42b180
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/AndroidManifest.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.leakcanary.leaksentry"
+    >
+
+  <application>
+    <provider
+        android:name="leakcanary.internal.LeakSentryInstaller"
+        android:authorities="${applicationId}.leak-sentry-installer"
+        android:exported="false"/>
+  </application>
+</manifest>
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt b/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
new file mode 100644
index 00000000..c79c1d45
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
@@ -0,0 +1,52 @@
+package leakcanary
+
+import android.app.Application
+import leakcanary.internal.InternalLeakSentry
+import java.util.concurrent.TimeUnit
+
+object LeakSentry {
+
+  data class Config(
+    /**
+     * Whether LeakSentry should watch instances (by keeping weak references to them). Default is
+     * true in debuggable builds and false is non debuggable builds.
+     */
+    val enabled: Boolean = InternalLeakSentry.isDebuggableBuild,
+    /**
+     * Whether LeakCanary should automatically watch destroyed activities.
+     */
+    val watchActivities: Boolean = true,
+    /**
+     * Whether LeakCanary should automatically watch destroyed fragments.
+     */
+    val watchFragments: Boolean = true,
+    /**
+     * Whether LeakCanary should automatically watch destroyed fragment views.
+     */
+    val watchFragmentViews: Boolean = true,
+    /**
+     * How long to wait before reporting a watched instance as retained. Default is 5 seconds.
+     */
+    val watchDurationMillis: Long = TimeUnit.SECONDS.toMillis(5)
+  )
+
+  @Volatile
+  var config: Config = if (isInstalled) Config() else Config(enabled = false)
+
+  val refWatcher
+    get() = InternalLeakSentry.refWatcher
+
+  /** @see [manualInstall] */
+  val isInstalled
+    get() = InternalLeakSentry.isInstalled
+
+  /**
+   * [LeakSentry] is automatically installed on main process start by
+   * [leakcanary.internal.LeakSentryInstaller] which is registered in the AndroidManifest.xml of
+   * your app. If you disabled [leakcanary.internal.LeakSentryInstaller] or you need LeakSentry
+   * or LeakCanary to run outside of the main process then you can call this method to install
+   * [LeakSentry].
+   */
+  fun manualInstall(application: Application) = InternalLeakSentry.install(application)
+
+}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
new file mode 100644
index 00000000..aec2cc7c
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.app.Activity
+import android.app.Application
+import leakcanary.LeakSentry.Config
+import leakcanary.RefWatcher
+import leakcanary.internal.InternalHelper.noOpDelegate
+
+internal class ActivityDestroyWatcher private constructor(
+  private val refWatcher: RefWatcher,
+  private val configProvider: () -> Config
+) {
+
+  private val lifecycleCallbacks =
+    object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
+      override fun onActivityDestroyed(activity: Activity) {
+        if (configProvider().watchActivities) {
+          refWatcher.watch(activity)
+        }
+      }
+    }
+
+  companion object {
+    fun install(
+      application: Application,
+      refWatcher: RefWatcher,
+      configProvider: () -> Config
+    ) {
+      val activityDestroyWatcher =
+        ActivityDestroyWatcher(refWatcher, configProvider)
+      application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)
+    }
+  }
+}
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
new file mode 100644
index 00000000..62ef6a25
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@file:Suppress("DEPRECATION")
+
+package leakcanary.internal
+
+import android.app.Activity
+import android.app.Fragment
+import android.app.FragmentManager
+import android.os.Build
+import androidx.annotation.RequiresApi
+import leakcanary.RefWatcher
+import leakcanary.LeakSentry.Config
+
+@RequiresApi(Build.VERSION_CODES.O) //
+internal class AndroidOFragmentDestroyWatcher(
+  private val refWatcher: RefWatcher,
+  private val configProvider: () -> Config
+) : FragmentDestroyWatcher {
+
+  private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {
+
+    override fun onFragmentViewDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      val view = fragment.view
+      if (view != null && configProvider().watchFragmentViews) {
+        refWatcher.watch(view)
+      }
+    }
+
+    override fun onFragmentDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      if (configProvider().watchFragments) {
+        refWatcher.watch(fragment)
+      }
+    }
+  }
+
+  override fun watchFragments(activity: Activity) {
+    val fragmentManager = activity.fragmentManager
+    fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)
+  }
+}
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
new file mode 100644
index 00000000..2b7e8e45
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
@@ -0,0 +1,39 @@
+package leakcanary.internal
+
+import android.util.Log
+import leakcanary.CanaryLog.Logger
+
+internal class DefaultCanaryLog : Logger {
+
+  override fun d(
+    message: String,
+    vararg args: Any?
+  ) {
+    val formatted = if (args.isNotEmpty()) {
+      String.format(message, *args)
+    } else {
+      message
+    }
+    if (formatted.length < 4000) {
+      Log.d("LeakCanary", formatted)
+    } else {
+      val lines = formatted.split("\n".toRegex())
+          .toTypedArray()
+      for (line in lines) {
+        Log.d("LeakCanary", line)
+      }
+    }
+  }
+
+  override fun d(
+    throwable: Throwable?,
+    message: String,
+    vararg args: Any?
+  ) {
+    d(
+        String.format(message, *args) + '\n'.toString() + Log.getStackTraceString(
+            throwable
+        )
+    )
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
new file mode 100644
index 00000000..54976015
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.app.Activity
+import android.app.Application
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.O
+import android.os.Bundle
+import leakcanary.LeakSentry
+import leakcanary.RefWatcher
+import leakcanary.internal.InternalHelper.noOpDelegate
+
+/**
+ * Internal class used to watch for fragments leaks.
+ */
+internal interface FragmentDestroyWatcher {
+
+  fun watchFragments(activity: Activity)
+
+  companion object {
+
+    private const val SUPPORT_FRAGMENT_CLASS_NAME = "androidx.fragment.app.Fragment"
+
+    fun install(
+      application: Application,
+      refWatcher: RefWatcher,
+      configProvider: () -> LeakSentry.Config
+    ) {
+      val fragmentDestroyWatchers = mutableListOf<FragmentDestroyWatcher>()
+
+      if (SDK_INT >= O) {
+        fragmentDestroyWatchers.add(
+            AndroidOFragmentDestroyWatcher(refWatcher, configProvider)
+        )
+      }
+
+      if (classAvailable(
+              SUPPORT_FRAGMENT_CLASS_NAME
+          )
+      ) {
+        fragmentDestroyWatchers.add(
+            SupportFragmentDestroyWatcher(refWatcher, configProvider)
+        )
+      }
+
+      if (fragmentDestroyWatchers.size == 0) {
+        return
+      }
+
+      application.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
+        override fun onActivityCreated(
+          activity: Activity,
+          savedInstanceState: Bundle?
+        ) {
+          for (watcher in fragmentDestroyWatchers) {
+            watcher.watchFragments(activity)
+          }
+        }
+      })
+    }
+
+    private fun classAvailable(className: String): Boolean {
+      return try {
+        Class.forName(className)
+        true
+      } catch (e: ClassNotFoundException) {
+        false
+      }
+    }
+  }
+}
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalHelper.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalHelper.kt
new file mode 100644
index 00000000..64e05ead
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalHelper.kt
@@ -0,0 +1,18 @@
+package leakcanary.internal
+
+import java.lang.reflect.InvocationHandler
+import java.lang.reflect.Proxy
+
+/** Visible across several internal modules. */
+object InternalHelper {
+  inline fun <reified T : Any> noOpDelegate(): T {
+    val javaClass = T::class.java
+    val noOpHandler = InvocationHandler { _, _, _ ->
+      // no op
+    }
+    return Proxy.newProxyInstance(
+        javaClass.classLoader, arrayOf(javaClass), noOpHandler
+    ) as T
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
new file mode 100644
index 00000000..d91fecaf
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
@@ -0,0 +1,79 @@
+package leakcanary.internal
+
+import android.app.Application
+import android.content.pm.ApplicationInfo
+import android.os.Handler
+import android.os.Looper
+import android.os.SystemClock
+import leakcanary.CanaryLog
+import leakcanary.Clock
+import leakcanary.LeakSentry
+import leakcanary.RefWatcher
+import java.util.concurrent.Executor
+
+internal object InternalLeakSentry {
+
+  val isInstalled
+    get() = ::application.isInitialized
+
+  private val listener: LeakSentryListener
+
+  val isDebuggableBuild by lazy {
+    (application.applicationInfo.flags and ApplicationInfo.FLAG_DEBUGGABLE) != 0
+  }
+
+  lateinit var application: Application
+
+  private val clock = object : Clock {
+    override fun uptimeMillis(): Long {
+      return SystemClock.uptimeMillis()
+    }
+  }
+
+  private val mainHandler = Handler(Looper.getMainLooper())
+
+  init {
+    listener = try {
+      val leakCanaryListener = Class.forName("leakcanary.internal.InternalLeakCanary")
+      leakCanaryListener.getDeclaredField("INSTANCE").get(null) as LeakSentryListener
+    } catch (ignored: Throwable) {
+      LeakSentryListener.None
+    }
+  }
+
+  private val checkRetainedExecutor = Executor {
+    mainHandler.postDelayed(it, LeakSentry.config.watchDurationMillis)
+  }
+  val refWatcher = RefWatcher(
+      clock = clock,
+      checkRetainedExecutor = checkRetainedExecutor,
+      onInstanceRetained = { listener.onReferenceRetained() },
+      isEnabled = { LeakSentry.config.enabled }
+  )
+
+  fun install(application: Application) {
+    CanaryLog.d("Installing LeakSentry")
+    checkMainThread()
+    if (this::application.isInitialized) {
+      return
+    }
+    InternalLeakSentry.application = application
+
+    val configProvider = { LeakSentry.config }
+    ActivityDestroyWatcher.install(
+        application, refWatcher, configProvider
+    )
+    FragmentDestroyWatcher.install(
+        application, refWatcher, configProvider
+    )
+    listener.onLeakSentryInstalled(application)
+  }
+
+  private fun checkMainThread() {
+    if (Looper.getMainLooper().thread !== Thread.currentThread()) {
+      throw UnsupportedOperationException(
+          "Should be called from the main thread, not ${Thread.currentThread()}"
+      )
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryInstaller.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryInstaller.kt
new file mode 100644
index 00000000..84cf968b
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryInstaller.kt
@@ -0,0 +1,60 @@
+package leakcanary.internal
+
+import android.app.Application
+import android.content.ContentProvider
+import android.content.ContentValues
+import android.database.Cursor
+import android.net.Uri
+import leakcanary.CanaryLog
+
+/**
+ * Content providers are loaded before the application class is created. [LeakSentryInstaller] is
+ * used to install [leaksentry.LeakSentry] on application start.
+ */
+internal class LeakSentryInstaller : ContentProvider() {
+
+  override fun onCreate(): Boolean {
+    CanaryLog.logger = DefaultCanaryLog()
+    val application = context!!.applicationContext as Application
+    InternalLeakSentry.install(application)
+    return true
+  }
+
+  override fun query(
+    uri: Uri,
+    strings: Array<String>?,
+    s: String?,
+    strings1: Array<String>?,
+    s1: String?
+  ): Cursor? {
+    return null
+  }
+
+  override fun getType(uri: Uri): String? {
+    return null
+  }
+
+  override fun insert(
+    uri: Uri,
+    contentValues: ContentValues?
+  ): Uri? {
+    return null
+  }
+
+  override fun delete(
+    uri: Uri,
+    s: String?,
+    strings: Array<String>?
+  ): Int {
+    return 0
+  }
+
+  override fun update(
+    uri: Uri,
+    contentValues: ContentValues?,
+    s: String?,
+    strings: Array<String>?
+  ): Int {
+    return 0
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryListener.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryListener.kt
new file mode 100644
index 00000000..362550b1
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryListener.kt
@@ -0,0 +1,16 @@
+package leakcanary.internal
+
+import android.app.Application
+
+interface LeakSentryListener {
+  fun onLeakSentryInstalled(application: Application)
+  fun onReferenceRetained()
+
+  object None : LeakSentryListener {
+    override fun onLeakSentryInstalled(application: Application) {
+    }
+
+    override fun onReferenceRetained() {
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/SupportFragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/SupportFragmentDestroyWatcher.kt
new file mode 100644
index 00000000..a4fc2f29
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/SupportFragmentDestroyWatcher.kt
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.app.Activity
+import androidx.fragment.app.Fragment
+import androidx.fragment.app.FragmentActivity
+import androidx.fragment.app.FragmentManager
+import leakcanary.RefWatcher
+import leakcanary.LeakSentry.Config
+
+internal class SupportFragmentDestroyWatcher(
+  private val refWatcher: RefWatcher,
+  private val configProvider: () -> Config
+) : FragmentDestroyWatcher {
+
+  private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {
+
+    override fun onFragmentViewDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      val view = fragment.view
+      if (view != null && configProvider().watchFragmentViews) {
+        refWatcher.watch(view)
+      }
+    }
+
+    override fun onFragmentDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      if (configProvider().watchFragments) {
+        refWatcher.watch(fragment)
+      }
+    }
+  }
+
+  override fun watchFragments(activity: Activity) {
+    if (activity is FragmentActivity) {
+      val supportFragmentManager = activity.supportFragmentManager
+      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)
+    }
+  }
+}
diff --git a/leakcanary-log/build.gradle b/leakcanary-log/build.gradle
new file mode 100644
index 00000000..6655f74f
--- /dev/null
+++ b/leakcanary-log/build.gradle
@@ -0,0 +1,12 @@
+apply plugin: 'java-library'
+apply plugin: 'kotlin'
+
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
+
+dependencies {
+  implementation deps.kotlin.stdlib
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-log/gradle.properties b/leakcanary-log/gradle.properties
new file mode 100644
index 00000000..d14febb2
--- /dev/null
+++ b/leakcanary-log/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-log
+POM_NAME=LeakCanary Log
+POM_PACKAGING=jar
diff --git a/leakcanary-log/src/main/java/leakcanary/CanaryLog.kt b/leakcanary-log/src/main/java/leakcanary/CanaryLog.kt
new file mode 100644
index 00000000..a2eccf46
--- /dev/null
+++ b/leakcanary-log/src/main/java/leakcanary/CanaryLog.kt
@@ -0,0 +1,38 @@
+package leakcanary
+
+object CanaryLog {
+
+  interface Logger {
+    fun d(
+      message: String,
+      vararg args: Any?
+    )
+
+    fun d(
+      throwable: Throwable?,
+      message: String,
+      vararg args: Any?
+    )
+  }
+
+  @Volatile var logger: Logger? = null
+
+  fun d(
+    message: String,
+    vararg args: Any?
+  ) {
+    // Local variable to prevent the ref from becoming null after the null check.
+    val logger = logger ?: return
+    logger.d(message, *args)
+  }
+
+  fun d(
+    throwable: Throwable?,
+    message: String,
+    vararg args: Any?
+  ) {
+    // Local variable to prevent the ref from becoming null after the null check.
+    val logger = logger ?: return
+    logger.d(throwable, message, *args)
+  }
+}
diff --git a/leakcanary-sample/build.gradle b/leakcanary-sample/build.gradle
index d80081b8..ad05c169 100644
--- a/leakcanary-sample/build.gradle
+++ b/leakcanary-sample/build.gradle
@@ -1,29 +1,69 @@
 apply plugin: 'com.android.application'
+apply plugin: 'kotlin-android'
 
 dependencies {
-  debugCompile project(':leakcanary-android')
-  releaseCompile project(':leakcanary-android-no-op');
+  debugImplementation project(':leakcanary-android')
+
+  implementation deps.kotlin.stdlib
+
+  testImplementation deps.junit
+  testImplementation deps.robolectric
+
+  androidTestImplementation project(':leakcanary-android-instrumentation')
+  androidTestImplementation deps.androidx.test.espresso
+  androidTestImplementation deps.androidx.test.rules
+  androidTestImplementation deps.androidx.test.runner
 }
 
 android {
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
+  compileSdkVersion versions.compileSdk
 
   compileOptions {
-    sourceCompatibility rootProject.ext.javaVersion
-    targetCompatibility rootProject.ext.javaVersion
+    sourceCompatibility JavaVersion.VERSION_1_8
+    targetCompatibility JavaVersion.VERSION_1_8
   }
 
   defaultConfig {
     applicationId "com.example.leakcanary"
-    minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.compileSdkVersion
+    minSdkVersion versions.minSdk
+    targetSdkVersion versions.compileSdk
 
     versionCode 1
     versionName "1.0"
+
+    testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
+    testInstrumentationRunnerArgument "listener",
+        "leakcanary.FailTestOnLeakRunListener"
   }
 
   buildTypes {
     debug
+    release
+  }
+
+  dexOptions {
+    dexInProcess false
+  }
+
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+  }
+
+  testOptions {
+    unitTests {
+      includeAndroidResources = true
+    }
+  }
+}
+
+// Instrumentation test dependencies resolve to 27.1.1 so we align the sample.
+configurations.all {
+  resolutionStrategy {
+    eachDependency { details ->
+      // Force all of the primary support libraries to use the same version.
+      if (details.requested.group == 'com.android.support') {
+        details.useVersion "27.1.1"
+      }
+    }
   }
 }
diff --git a/leakcanary-watcher/src/main/AndroidManifest.xml b/leakcanary-sample/src/androidTest/AndroidManifest.xml
similarity index 81%
rename from leakcanary-watcher/src/main/AndroidManifest.xml
rename to leakcanary-sample/src/androidTest/AndroidManifest.xml
index 3f8d7ca9..d23bb44d 100644
--- a/leakcanary-watcher/src/main/AndroidManifest.xml
+++ b/leakcanary-sample/src/androidTest/AndroidManifest.xml
@@ -1,5 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
 <!--
-  ~ Copyright (C) 2015 Square, Inc.
+  ~ Copyright (C) 2018 Square, Inc.
   ~
   ~ Licensed under the Apache License, Version 2.0 (the "License");
   ~ you may not use this file except in compliance with the License.
@@ -14,6 +15,5 @@
   ~ limitations under the License.
   -->
 <manifest
-    package="com.squareup.leakcanary.watcher">
-  <application/>
+    package="com.squareup.leakcanary.instrumentation.test">
 </manifest>
diff --git a/leakcanary-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt b/leakcanary-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
new file mode 100644
index 00000000..b07ec28f
--- /dev/null
+++ b/leakcanary-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
@@ -0,0 +1,48 @@
+package leakcanary.tests
+
+import androidx.test.espresso.Espresso.onView
+import androidx.test.espresso.assertion.ViewAssertions.matches
+import androidx.test.espresso.matcher.ViewMatchers.withId
+import androidx.test.espresso.matcher.ViewMatchers.withText
+import androidx.test.rule.ActivityTestRule
+import com.example.leakcanary.MainActivity
+import com.example.leakcanary.R
+import org.junit.Rule
+import org.junit.Test
+
+/**
+ * This UI test looks like it should succeed, but it will actually fail because
+ * it triggers a leak.
+ *
+ * Run this test with:
+ *
+ * ./gradlew leakcanary-sample:connectedCheck
+ *
+ * To set this up, we installed a special RefWatcher dedicated to detecting leaks in
+ * instrumentation tests in [InstrumentationExampleApplication], and then added the FailTestOnLeakRunListener
+ * to the config of our build.gradle:
+ *
+ * testInstrumentationRunnerArgument "listener", "leakcanary.FailTestOnLeakRunListener"
+ *
+ *
+ * Why is this class named "TuPeuxPasTest"?
+ *
+ * This test fails, intentionally. In French, "Tu peux pas test" could mean "you cannot test"
+ * written with poor grammar. Except, that's not what it means.
+ * If you're curious, interested in French and have time to waste:
+ * https://www.youtube.com/watch?v=DZZpbmAc-0A
+ * https://www.youtube.com/watch?v=nHeAA6X-XUQ
+ */
+class TuPeuxPasTest {
+
+  @get:Rule
+  var activityRule = ActivityTestRule(MainActivity::class.java)
+
+  /**
+   * A dummy test that fails because MainActivity is leaking
+   */
+  @Test
+  fun helperTextHasExpectedContent() {
+    onView(withId(R.id.helper_text)).check(matches(withText(R.string.helper_text)))
+  }
+}
diff --git a/leakcanary-sample/src/main/AndroidManifest.xml b/leakcanary-sample/src/main/AndroidManifest.xml
index d72ca551..e5b5138c 100644
--- a/leakcanary-sample/src/main/AndroidManifest.xml
+++ b/leakcanary-sample/src/main/AndroidManifest.xml
@@ -18,15 +18,19 @@
     xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.example.leakcanary"
     >
-  <application android:name=".ExampleApplication" android:allowBackup="false"
-      android:icon="@drawable/ic_launcher"
+
+  <application
+      android:name=".ExampleApplication"
+      android:allowBackup="false"
+      android:icon="@mipmap/ic_launcher"
+      android:label="@string/app_name"
       >
     <activity
-        android:label="@string/app_name"
         android:name=".MainActivity"
         >
       <intent-filter>
         <action android:name="android.intent.action.MAIN"/>
+
         <category android:name="android.intent.category.LAUNCHER"/>
         <category android:name="android.intent.category.DEFAULT"/>
       </intent-filter>
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
deleted file mode 100644
index 942be776..00000000
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.leakcanary;
-
-import android.app.Application;
-import android.os.StrictMode;
-import com.squareup.leakcanary.LeakCanary;
-
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.GINGERBREAD;
-
-public class ExampleApplication extends Application {
-
-  @Override public void onCreate() {
-    super.onCreate();
-    enabledStrictMode();
-    LeakCanary.install(this);
-  }
-
-  private void enabledStrictMode() {
-    if (SDK_INT >= GINGERBREAD) {
-      StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() //
-          .detectAll() //
-          .penaltyLog() //
-          .penaltyDeath() //
-          .build());
-    }
-  }
-}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Preconditions.java b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
similarity index 55%
rename from leakcanary-watcher/src/main/java/com/squareup/leakcanary/Preconditions.java
rename to leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
index f7521e90..87a01773 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Preconditions.java
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
@@ -13,23 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary;
+package com.example.leakcanary
 
-final class Preconditions {
+import android.app.Application
+import android.os.StrictMode
+import android.view.View
 
-  /**
-   * Returns instance unless it's null.
-   *
-   * @throws NullPointerException if instance is null
-   */
-  static <T> T checkNotNull(T instance, String name) {
-    if (instance == null) {
-      throw new NullPointerException(name + " must not be null");
-    }
-    return instance;
+open class ExampleApplication : Application() {
+  val leakedViews = mutableListOf<View>()
+
+  override fun onCreate() {
+    super.onCreate()
+    enabledStrictMode()
   }
 
-  private Preconditions() {
-    throw new AssertionError();
+  private fun enabledStrictMode() {
+    StrictMode.setThreadPolicy(
+        StrictMode.ThreadPolicy.Builder()
+            .detectAll()
+            .penaltyLog()
+            .penaltyDeath()
+            .build()
+    )
   }
 }
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/LeakingSingleton.kt b/leakcanary-sample/src/main/java/com/example/leakcanary/LeakingSingleton.kt
new file mode 100644
index 00000000..9ebe1e19
--- /dev/null
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/LeakingSingleton.kt
@@ -0,0 +1,7 @@
+package com.example.leakcanary
+
+import android.view.View
+
+object LeakingSingleton {
+  val leakedViews = mutableListOf<View>()
+}
\ No newline at end of file
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/LeakingThread.kt b/leakcanary-sample/src/main/java/com/example/leakcanary/LeakingThread.kt
new file mode 100644
index 00000000..24138036
--- /dev/null
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/LeakingThread.kt
@@ -0,0 +1,24 @@
+package com.example.leakcanary
+
+import android.view.View
+
+class LeakingThread : Thread() {
+
+  val leakedViews = mutableListOf<View>()
+
+  init {
+    name = "Leaking thread"
+    start()
+  }
+
+  override fun run() {
+    synchronized(obj) {
+      obj.wait()
+    }
+  }
+
+  companion object {
+    private val obj = Object()
+    val thread = LeakingThread()
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
deleted file mode 100644
index 870f59b1..00000000
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.leakcanary;
-
-import android.app.Activity;
-import android.os.AsyncTask;
-import android.os.Bundle;
-import android.os.SystemClock;
-import android.view.View;
-
-public class MainActivity extends Activity {
-
-  @Override protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-    setContentView(R.layout.main_activity);
-
-    View button = findViewById(R.id.async_task);
-    button.setOnClickListener(new View.OnClickListener() {
-      @Override public void onClick(View v) {
-        startAsyncTask();
-      }
-    });
-  }
-
-  void startAsyncTask() {
-    // This async task is an anonymous class and therefore has a hidden reference to the outer
-    // class MainActivity. If the activity gets destroyed before the task finishes (e.g. rotation),
-    // the activity instance will leak.
-    new AsyncTask<Void, Void, Void>() {
-      @Override protected Void doInBackground(Void... params) {
-        // Do some slow work in background
-        SystemClock.sleep(20000);
-        return null;
-      }
-    }.execute();
-  }
-}
-
-
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.kt b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.kt
new file mode 100644
index 00000000..6fa5b3fd
--- /dev/null
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.kt
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.leakcanary
+
+import android.app.Activity
+import android.os.Bundle
+import android.os.SystemClock
+import android.view.View
+import java.util.concurrent.atomic.AtomicReference
+import kotlin.random.Random
+
+class MainActivity : Activity() {
+
+  override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+    setContentView(R.layout.main_activity)
+
+    val app = application as ExampleApplication
+    val leakedView = findViewById<View>(R.id.helper_text)
+
+    when (Random.nextInt(4)) {
+      // Leak from application class
+      0 -> app.leakedViews.add(leakedView)
+      // Leak from Kotlin object singleton
+      1 -> LeakingSingleton.leakedViews.add(leakedView)
+      2 -> {
+        // Leak from local variable on thread
+        val ref = AtomicReference(this)
+        val thread = Thread {
+          val activity = ref.get()
+          ref.set(null)
+          while (true) {
+            print(activity)
+            SystemClock.sleep(1000)
+          }
+        }
+        thread.name = "Leaking local variables"
+        thread.start()
+      }
+      // Leak from thread fields
+      else -> LeakingThread.thread.leakedViews.add(leakedView)
+    }
+  }
+}
diff --git a/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png
deleted file mode 100755
index 65948fa3..00000000
Binary files a/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png and /dev/null differ
diff --git a/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png
deleted file mode 100755
index 5d826c42..00000000
Binary files a/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png and /dev/null differ
diff --git a/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png
deleted file mode 100755
index c9c7ec58..00000000
Binary files a/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png and /dev/null differ
diff --git a/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100755
index cb8a98ab..00000000
Binary files a/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png
deleted file mode 100755
index 3ca3a7f6..00000000
Binary files a/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png and /dev/null differ
diff --git a/leakcanary-sample/src/main/res/layout/main_activity.xml b/leakcanary-sample/src/main/res/layout/main_activity.xml
index 2dc62d61..d1f96a18 100644
--- a/leakcanary-sample/src/main/res/layout/main_activity.xml
+++ b/leakcanary-sample/src/main/res/layout/main_activity.xml
@@ -23,17 +23,11 @@
     >
 
   <TextView
+      android:id="@+id/helper_text"
       android:layout_width="match_parent"
       android:layout_height="wrap_content"
       android:layout_marginBottom="16dp"
       android:text="@string/helper_text"
       />
 
-  <Button
-      android:id="@+id/async_task"
-      android:layout_width="match_parent"
-      android:layout_height="wrap_content"
-      android:text="@string/start_async_task"
-      />
-
-</LinearLayout>
\ No newline at end of file
+</LinearLayout>
diff --git a/leakcanary-sample/src/main/res/mipmap-hdpi/ic_launcher.png b/leakcanary-sample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 00000000..97aa0b79
Binary files /dev/null and b/leakcanary-sample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/mipmap-mdpi/ic_launcher.png b/leakcanary-sample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 00000000..77a7ef0c
Binary files /dev/null and b/leakcanary-sample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/mipmap-xhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 00000000..4f046561
Binary files /dev/null and b/leakcanary-sample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 00000000..f8c5988e
Binary files /dev/null and b/leakcanary-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 00000000..42beb64b
Binary files /dev/null and b/leakcanary-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/values/strings.xml b/leakcanary-sample/src/main/res/values/strings.xml
index 9e5bf782..0f66736c 100644
--- a/leakcanary-sample/src/main/res/values/strings.xml
+++ b/leakcanary-sample/src/main/res/values/strings.xml
@@ -14,11 +14,11 @@
   ~ See the License for the specific language governing permissions and
   ~ limitations under the License.
   -->
-<resources>
-  <string name="app_name">LeakCanary Sample</string>
-  <string name="start_async_task">Start new AsyncTask</string>
-  <string name="helper_text">Start the async task, <b>rotate the screen</b> and wait for a bit. A
-    wild notification appears.
+<resources
+    xmlns:tools="http://schemas.android.com/tools"
+    tools:ignore="MissingTranslation">
+  <string name="app_name">Example App</string>
+  <string name="helper_text">Rotate the screen 5 times to create 5 leaks and trigger a foreground
+    heap dump. Or press back to cause a leak and trigger a background heap dump.
   </string>
-  <string name="leak_canary_display_activity_label">Leaks Sample</string>
-</resources>
\ No newline at end of file
+</resources>
diff --git a/leakcanary-watcher/build.gradle b/leakcanary-watcher/build.gradle
index ac0cac77..984bad02 100644
--- a/leakcanary-watcher/build.gradle
+++ b/leakcanary-watcher/build.gradle
@@ -1,45 +1,16 @@
-version rootProject.ext.VERSION_NAME
-group rootProject.ext.GROUP
+apply plugin: 'java-library'
+apply plugin: 'kotlin'
 
-buildscript {
-  repositories {
-    mavenCentral()
-  }
-}
-
-apply plugin: 'com.android.library'
-
-repositories {
-  mavenCentral()
-}
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
 
 dependencies {
-  testCompile 'junit:junit:4.12'
-}
-
-android.libraryVariants.all { variant ->
-  def name = variant.buildType.name
-  if (name.equals(com.android.builder.core.BuilderConstants.DEBUG)) {
-    return; // Skip debug builds.
-  }
-  def task = project.tasks.create "jar${name.capitalize()}", Jar
-  task.dependsOn variant.javaCompile
-  task.from variant.javaCompile.destinationDir
-  artifacts.add('archives', task);
-}
-
-android {
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
-  defaultConfig {
-    minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.targetSdkVersion
-  }
-}
+  implementation deps.kotlin.stdlib
+  api project(':leakcanary-log')
 
-task sourceJar(type: Jar) {
-  from 'src/main/java'
+  testImplementation deps.assertj_core
+  testImplementation deps.junit
 }
 
 apply from: rootProject.file('gradle/checkstyle.gradle')
-apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
deleted file mode 100644
index 47662445..00000000
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
+++ /dev/null
@@ -1,209 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.Serializable;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-import static java.util.Collections.unmodifiableMap;
-
-/**
- * Prevents specific references from being taken into account when computing the shortest reference
- * path from a suspected leaking instance to the GC roots.
- *
- * This class lets you ignore known memory leaks that you know about. If the shortest path
- * matches {@link ExcludedRefs}, than the heap analyzer should look for a longer path with nothing
- * matching in {@link ExcludedRefs}.
- */
-public final class ExcludedRefs implements Serializable {
-
-  public static Builder builder() {
-    return new BuilderWithParams();
-  }
-
-  public final Map<String, Map<String, Exclusion>> fieldNameByClassName;
-  public final Map<String, Map<String, Exclusion>> staticFieldNameByClassName;
-  public final Map<String, Exclusion> threadNames;
-  public final Map<String, Exclusion> classNames;
-  public final Map<String, Exclusion> rootClassNames;
-
-  ExcludedRefs(BuilderWithParams builder) {
-    this.fieldNameByClassName = unmodifiableRefStringMap(builder.fieldNameByClassName);
-    this.staticFieldNameByClassName = unmodifiableRefStringMap(builder.staticFieldNameByClassName);
-    this.threadNames = unmodifiableRefMap(builder.threadNames);
-    this.classNames = unmodifiableRefMap(builder.classNames);
-    this.rootClassNames = unmodifiableRefMap(builder.rootClassNames);
-  }
-
-  private Map<String, Map<String, Exclusion>> unmodifiableRefStringMap(
-      Map<String, Map<String, ParamsBuilder>> mapmap) {
-    LinkedHashMap<String, Map<String, Exclusion>> fieldNameByClassName = new LinkedHashMap<>();
-    for (Map.Entry<String, Map<String, ParamsBuilder>> entry : mapmap.entrySet()) {
-      fieldNameByClassName.put(entry.getKey(), unmodifiableRefMap(entry.getValue()));
-    }
-    return unmodifiableMap(fieldNameByClassName);
-  }
-
-  private Map<String, Exclusion> unmodifiableRefMap(Map<String, ParamsBuilder> fieldBuilderMap) {
-    Map<String, Exclusion> fieldMap = new LinkedHashMap<>();
-    for (Map.Entry<String, ParamsBuilder> fieldEntry : fieldBuilderMap.entrySet()) {
-      fieldMap.put(fieldEntry.getKey(), new Exclusion(fieldEntry.getValue()));
-    }
-    return unmodifiableMap(fieldMap);
-  }
-
-  @Override public String toString() {
-    String string = "";
-    for (Map.Entry<String, Map<String, Exclusion>> classes : fieldNameByClassName.entrySet()) {
-      String clazz = classes.getKey();
-      for (Map.Entry<String, Exclusion> field : classes.getValue().entrySet()) {
-        String always = field.getValue().alwaysExclude ? " (always)" : "";
-        string += "| Field: " + clazz + "." + field.getKey() + always + "\n";
-      }
-    }
-    for (Map.Entry<String, Map<String, Exclusion>> classes : staticFieldNameByClassName.entrySet()) {
-      String clazz = classes.getKey();
-      for (Map.Entry<String, Exclusion> field : classes.getValue().entrySet()) {
-        String always = field.getValue().alwaysExclude ? " (always)" : "";
-        string += "| Static field: " + clazz + "." + field.getKey() + always + "\n";
-      }
-    }
-    for (Map.Entry<String, Exclusion> thread : threadNames.entrySet()) {
-      String always = thread.getValue().alwaysExclude ? " (always)" : "";
-      string += "| Thread:" + thread.getKey() + always + "\n";
-    }
-    for (Map.Entry<String, Exclusion> clazz : classNames.entrySet()) {
-      String always = clazz.getValue().alwaysExclude ? " (always)" : "";
-      string += "| Class:" + clazz.getKey() + always + "\n";
-    }
-    for (Map.Entry<String, Exclusion> clazz : rootClassNames.entrySet()) {
-      String always = clazz.getValue().alwaysExclude ? " (always)" : "";
-      string += "| Root Class:" + clazz.getKey() + always + "\n";
-    }
-    return string;
-  }
-
-  static final class ParamsBuilder {
-    String name;
-    String reason;
-    boolean alwaysExclude;
-    final String matching;
-
-    ParamsBuilder(String matching) {
-      this.matching = matching;
-    }
-  }
-
-  public interface Builder {
-    BuilderWithParams instanceField(String className, String fieldName);
-
-    BuilderWithParams staticField(String className, String fieldName);
-
-    BuilderWithParams thread(String threadName);
-
-    BuilderWithParams clazz(String className);
-
-    BuilderWithParams rootClass(String rootSuperClassName);
-
-    ExcludedRefs build();
-  }
-
-  public static final class BuilderWithParams implements Builder {
-
-    private final Map<String, Map<String, ParamsBuilder>> fieldNameByClassName =
-        new LinkedHashMap<>();
-    private final Map<String, Map<String, ParamsBuilder>> staticFieldNameByClassName =
-        new LinkedHashMap<>();
-    private final Map<String, ParamsBuilder> threadNames = new LinkedHashMap<>();
-    private final Map<String, ParamsBuilder> classNames = new LinkedHashMap<>();
-    private final Map<String, ParamsBuilder> rootClassNames = new LinkedHashMap<>();
-
-    private ParamsBuilder lastParams;
-
-    BuilderWithParams() {
-    }
-
-    @Override public BuilderWithParams instanceField(String className, String fieldName) {
-      checkNotNull(className, "className");
-      checkNotNull(fieldName, "fieldName");
-      Map<String, ParamsBuilder> excludedFields = fieldNameByClassName.get(className);
-      if (excludedFields == null) {
-        excludedFields = new LinkedHashMap<>();
-        fieldNameByClassName.put(className, excludedFields);
-      }
-      lastParams = new ParamsBuilder("field " + className + "#" + fieldName);
-      excludedFields.put(fieldName, lastParams);
-      return this;
-    }
-
-    @Override public BuilderWithParams staticField(String className, String fieldName) {
-      checkNotNull(className, "className");
-      checkNotNull(fieldName, "fieldName");
-      Map<String, ParamsBuilder> excludedFields = staticFieldNameByClassName.get(className);
-      if (excludedFields == null) {
-        excludedFields = new LinkedHashMap<>();
-        staticFieldNameByClassName.put(className, excludedFields);
-      }
-      lastParams = new ParamsBuilder("static field " + className + "#" + fieldName);
-      excludedFields.put(fieldName, lastParams);
-      return this;
-    }
-
-    @Override public BuilderWithParams thread(String threadName) {
-      checkNotNull(threadName, "threadName");
-      lastParams = new ParamsBuilder("any threads named " + threadName);
-      threadNames.put(threadName, lastParams);
-      return this;
-    }
-
-    /** Ignores all fields and static fields of all subclasses of the provided class name. */
-    @Override public BuilderWithParams clazz(String className) {
-      checkNotNull(className, "className");
-      lastParams = new ParamsBuilder("any subclass of " + className);
-      classNames.put(className, lastParams);
-      return this;
-    }
-
-    /** Ignores any GC root that belongs to a subclass of the provided class name. */
-    @Override public BuilderWithParams rootClass(String rootClassName) {
-      checkNotNull(rootClassName, "rootClassName");
-      lastParams = new ParamsBuilder("any GC root subclass of " + rootClassName);
-      rootClassNames.put(rootClassName, lastParams);
-      return this;
-    }
-
-    public BuilderWithParams named(String name) {
-      lastParams.name = name;
-      return this;
-    }
-
-    public BuilderWithParams reason(String reason) {
-      lastParams.reason = reason;
-      return this;
-    }
-
-    public BuilderWithParams alwaysExclude() {
-      lastParams.alwaysExclude = true;
-      return this;
-    }
-
-    public ExcludedRefs build() {
-      return new ExcludedRefs(this);
-    }
-  }
-}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java
deleted file mode 100644
index 4d87d05e..00000000
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package com.squareup.leakcanary;
-
-import java.io.Serializable;
-
-public final class Exclusion implements Serializable {
-  public final String name;
-  public final String reason;
-  public final boolean alwaysExclude;
-  public final String matching;
-
-  Exclusion(ExcludedRefs.ParamsBuilder builder) {
-    this.name = builder.name;
-    this.reason = builder.reason;
-    this.alwaysExclude = builder.alwaysExclude;
-    this.matching = builder.matching;
-  }
-}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
deleted file mode 100644
index fe88f38e..00000000
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.File;
-import java.io.Serializable;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-
-public final class HeapDump implements Serializable {
-
-  public interface Listener {
-    void analyze(HeapDump heapDump);
-  }
-
-  /** The heap dump file, which you might want to upload somewhere. */
-  public final File heapDumpFile;
-
-  /**
-   * Key associated to the {@link KeyedWeakReference} used to detect the memory leak.
-   * When analyzing a heap dump, search for all {@link KeyedWeakReference} instances, then open
-   * the one that has its "key" field set to this value. Its "referent" field contains the
-   * leaking object. Computing the shortest path to GC roots on that leaking object should enable
-   * you to figure out the cause of the leak.
-   */
-  public final String referenceKey;
-
-  /**
-   * User defined name to help identify the leaking instance.
-   */
-  public final String referenceName;
-
-  /** References that should be ignored when analyzing this heap dump. */
-  public final ExcludedRefs excludedRefs;
-
-  /** Time from the request to watch the reference until the GC was triggered. */
-  public final long watchDurationMs;
-  public final long gcDurationMs;
-  public final long heapDumpDurationMs;
-
-  public HeapDump(File heapDumpFile, String referenceKey, String referenceName,
-      ExcludedRefs excludedRefs, long watchDurationMs, long gcDurationMs, long heapDumpDurationMs) {
-    this.heapDumpFile = checkNotNull(heapDumpFile, "heapDumpFile");
-    this.referenceKey = checkNotNull(referenceKey, "referenceKey");
-    this.referenceName = checkNotNull(referenceName, "referenceName");
-    this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
-    this.watchDurationMs = watchDurationMs;
-    this.gcDurationMs = gcDurationMs;
-    this.heapDumpDurationMs = heapDumpDurationMs;
-  }
-}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java
deleted file mode 100644
index 9932308a..00000000
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.lang.ref.ReferenceQueue;
-import java.lang.ref.WeakReference;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-
-/** @see {@link HeapDump#referenceKey}. */
-final class KeyedWeakReference extends WeakReference<Object> {
-  public final String key;
-  public final String name;
-
-  KeyedWeakReference(Object referent, String key, String name,
-      ReferenceQueue<Object> referenceQueue) {
-    super(checkNotNull(referent, "referent"), checkNotNull(referenceQueue, "referenceQueue"));
-    this.key = checkNotNull(key, "key");
-    this.name = checkNotNull(name, "name");
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
deleted file mode 100644
index 5d124535..00000000
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.File;
-import java.lang.ref.ReferenceQueue;
-import java.util.Set;
-import java.util.UUID;
-import java.util.concurrent.CopyOnWriteArraySet;
-import java.util.concurrent.Executor;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-
-/**
- * Watches references that should become weakly reachable. When the {@link RefWatcher} detects that
- * a reference might not be weakly reachable when it should, it triggers the {@link HeapDumper}.
- *
- * <p>This class is thread-safe: you can call {@link #watch(Object)} from any thread.
- */
-public final class RefWatcher {
-
-  public static final RefWatcher DISABLED = new RefWatcher(new Executor() {
-    @Override public void execute(Runnable command) {
-    }
-  }, new DebuggerControl() {
-    @Override public boolean isDebuggerAttached() {
-      // Skips watching.
-      return true;
-    }
-  }, GcTrigger.DEFAULT, new HeapDumper() {
-    @Override public File dumpHeap() {
-      return null;
-    }
-  }, new HeapDump.Listener() {
-    @Override public void analyze(HeapDump heapDump) {
-    }
-  }, new ExcludedRefs.BuilderWithParams().build());
-
-  private final Executor watchExecutor;
-  private final DebuggerControl debuggerControl;
-  private final GcTrigger gcTrigger;
-  private final HeapDumper heapDumper;
-  private final Set<String> retainedKeys;
-  private final ReferenceQueue<Object> queue;
-  private final HeapDump.Listener heapdumpListener;
-  private final ExcludedRefs excludedRefs;
-
-  public RefWatcher(Executor watchExecutor, DebuggerControl debuggerControl, GcTrigger gcTrigger,
-      HeapDumper heapDumper, HeapDump.Listener heapdumpListener, ExcludedRefs excludedRefs) {
-    this.watchExecutor = checkNotNull(watchExecutor, "watchExecutor");
-    this.debuggerControl = checkNotNull(debuggerControl, "debuggerControl");
-    this.gcTrigger = checkNotNull(gcTrigger, "gcTrigger");
-    this.heapDumper = checkNotNull(heapDumper, "heapDumper");
-    this.heapdumpListener = checkNotNull(heapdumpListener, "heapdumpListener");
-    this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
-    retainedKeys = new CopyOnWriteArraySet<>();
-    queue = new ReferenceQueue<>();
-  }
-
-  /**
-   * Identical to {@link #watch(Object, String)} with an empty string reference name.
-   *
-   * @see #watch(Object, String)
-   */
-  public void watch(Object watchedReference) {
-    watch(watchedReference, "");
-  }
-
-  /**
-   * Watches the provided references and checks if it can be GCed. This method is non blocking,
-   * the check is done on the {@link Executor} this {@link RefWatcher} has been constructed with.
-   *
-   * @param referenceName An logical identifier for the watched object.
-   */
-  public void watch(Object watchedReference, String referenceName) {
-    checkNotNull(watchedReference, "watchedReference");
-    checkNotNull(referenceName, "referenceName");
-    if (debuggerControl.isDebuggerAttached()) {
-      return;
-    }
-    final long watchStartNanoTime = System.nanoTime();
-    String key = UUID.randomUUID().toString();
-    retainedKeys.add(key);
-    final KeyedWeakReference reference =
-        new KeyedWeakReference(watchedReference, key, referenceName, queue);
-
-    watchExecutor.execute(new Runnable() {
-      @Override public void run() {
-        ensureGone(reference, watchStartNanoTime);
-      }
-    });
-  }
-
-  void ensureGone(KeyedWeakReference reference, long watchStartNanoTime) {
-    long gcStartNanoTime = System.nanoTime();
-
-    long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);
-    removeWeaklyReachableReferences();
-    if (gone(reference) || debuggerControl.isDebuggerAttached()) {
-      return;
-    }
-    gcTrigger.runGc();
-    removeWeaklyReachableReferences();
-    if (!gone(reference)) {
-      long startDumpHeap = System.nanoTime();
-      long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);
-
-      File heapDumpFile = heapDumper.dumpHeap();
-
-      if (heapDumpFile == HeapDumper.NO_DUMP) {
-        // Could not dump the heap, abort.
-        return;
-      }
-      long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);
-      heapdumpListener.analyze(
-          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,
-              gcDurationMs, heapDumpDurationMs));
-    }
-  }
-
-  private boolean gone(KeyedWeakReference reference) {
-    return !retainedKeys.contains(reference.key);
-  }
-
-  private void removeWeaklyReachableReferences() {
-    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
-    // reachable. This is before finalization or garbage collection has actually happened.
-    KeyedWeakReference ref;
-    while ((ref = (KeyedWeakReference) queue.poll()) != null) {
-      retainedKeys.remove(ref.key);
-    }
-  }
-}
diff --git a/leakcanary-watcher/src/main/java/leakcanary/Clock.kt b/leakcanary-watcher/src/main/java/leakcanary/Clock.kt
new file mode 100644
index 00000000..bd3b146b
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/leakcanary/Clock.kt
@@ -0,0 +1,6 @@
+package leakcanary
+
+interface Clock {
+  /** See Android SystemClock.uptimeMillis().  */
+  fun uptimeMillis(): Long
+}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java b/leakcanary-watcher/src/main/java/leakcanary/GcTrigger.kt
similarity index 68%
rename from leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
rename to leakcanary-watcher/src/main/java/leakcanary/GcTrigger.kt
index 8beade52..023889b8 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
+++ b/leakcanary-watcher/src/main/java/leakcanary/GcTrigger.kt
@@ -13,36 +13,37 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary;
+package leakcanary
 
 /**
  * Called when a watched reference is expected to be weakly reachable, but hasn't been enqueued
- * in the reference queue yet. This gives the application a hook to run the GC before the {@link
- * RefWatcher} checks the reference queue again, to avoid taking a heap dump if possible.
+ * in the reference queue yet. This gives the application a hook to run the GC before the [ ] checks the reference queue again, to avoid taking a heap dump if possible.
  */
-public interface GcTrigger {
-  GcTrigger DEFAULT = new GcTrigger() {
-    @Override public void runGc() {
+interface GcTrigger {
+
+  fun runGc()
+
+  object Default : GcTrigger {
+    override fun runGc() {
       // Code taken from AOSP FinalizationTest:
       // https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
       // java/lang/ref/FinalizationTester.java
       // System.gc() does not garbage collect every time. Runtime.gc() is
-      // more likely to perfom a gc.
-      Runtime.getRuntime().gc();
-      enqueueReferences();
-      System.runFinalization();
+      // more likely to perform a gc.
+      Runtime.getRuntime()
+          .gc()
+      enqueueReferences()
+      System.runFinalization()
     }
 
-    private void enqueueReferences() {
+    private fun enqueueReferences() {
       // Hack. We don't have a programmatic way to wait for the reference queue daemon to move
       // references to the appropriate queues.
       try {
-        Thread.sleep(100);
-      } catch (InterruptedException e) {
-        throw new AssertionError();
+        Thread.sleep(100)
+      } catch (e: InterruptedException) {
+        throw AssertionError()
       }
     }
-  };
-
-  void runGc();
-}
\ No newline at end of file
+  }
+}
diff --git a/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt b/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
new file mode 100644
index 00000000..dde8d61c
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import java.lang.ref.ReferenceQueue
+import java.lang.ref.WeakReference
+
+@Suppress("unused")
+class KeyedWeakReference(
+  referent: Any,
+  val key: String,
+  val name: String,
+  val watchUptimeMillis: Long,
+  referenceQueue: ReferenceQueue<Any>
+) : WeakReference<Any>(
+    referent, referenceQueue
+) {
+  val className: String = referent.javaClass.name
+
+  /**
+   * Compared against [heapDumpUptimeMillis] so that the Hprof Parser knows only to look at
+   * instances that were moved to retained, then used to remove weak references post heap dump.
+   **/
+  @Volatile
+  var retainedUptimeMillis = -1L
+
+  companion object {
+    @Volatile
+    @JvmStatic var heapDumpUptimeMillis = 0L
+  }
+
+}
diff --git a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
new file mode 100644
index 00000000..4709d4bb
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import java.lang.ref.ReferenceQueue
+import java.util.UUID
+import java.util.concurrent.Executor
+
+/**
+ * Thread safe by locking on all methods, which is reasonably efficient given how often
+ * these methods are accessed.
+ */
+class RefWatcher constructor(
+  private val clock: Clock,
+  private val checkRetainedExecutor: Executor,
+  private val onInstanceRetained: () -> Unit,
+  /**
+   * Calls to [watch] will be ignored when [isEnabled] returns false
+   */
+  private val isEnabled: () -> Boolean = { true }
+) {
+
+  /**
+   * References passed to [watch].
+   */
+  private val watchedInstances = mutableMapOf<String, KeyedWeakReference>()
+
+  private val queue = ReferenceQueue<Any>()
+
+  /**
+   * Returns true if there are watched instances that aren't weakly reachable, and
+   * have been watched for long enough to be considered retained.
+   */
+  val hasRetainedInstances: Boolean
+    @Synchronized get() {
+      removeWeaklyReachableInstances()
+      return watchedInstances.any { it.value.retainedUptimeMillis != -1L }
+    }
+
+  val retainedInstanceCount: Int
+    @Synchronized get() {
+      removeWeaklyReachableInstances()
+      return watchedInstances.count { it.value.retainedUptimeMillis != -1L }
+    }
+
+  /**
+   * Returns true if there are watched instances that aren't weakly reachable, even
+   * if they haven't been watched for long enough to be considered retained.
+   */
+  val hasWatchedInstances: Boolean
+    @Synchronized get() {
+      removeWeaklyReachableInstances()
+      return watchedInstances.isNotEmpty()
+    }
+
+  /**
+   * Returns the instances that are currently considered retained. Useful for logging purposes.
+   * Be careful with those instances and release them ASAP as you may creating longer lived leaks
+   * then the one that are already there.
+   */
+  val retainedInstances: List<Any>
+    @Synchronized get() {
+      removeWeaklyReachableInstances()
+      val instances = mutableListOf<Any>()
+      for (weakReference in watchedInstances.values) {
+        if (weakReference.retainedUptimeMillis != -1L) {
+          val instance = weakReference.get()
+          if (instance != null) {
+            instances.add(instance)
+          }
+        }
+      }
+      return instances
+    }
+
+  /**
+   * Identical to [.watch] with an empty string reference name.
+   */
+  @Synchronized fun watch(watchedInstance: Any) {
+    watch(watchedInstance, "")
+  }
+
+  /**
+   * Watches the provided instances.
+   *
+   * @param name A logical identifier for the watched object.
+   */
+  @Synchronized fun watch(
+    watchedInstance: Any,
+    name: String
+  ) {
+    if (!isEnabled()) {
+      return
+    }
+    removeWeaklyReachableInstances()
+    val key = UUID.randomUUID()
+        .toString()
+    val watchUptimeMillis = clock.uptimeMillis()
+    val reference =
+      KeyedWeakReference(watchedInstance, key, name, watchUptimeMillis, queue)
+    if (name != "") {
+      CanaryLog.d(
+          "Watching instance of %s named %s with key %s", reference.className,
+          name, key
+      )
+    } else {
+      CanaryLog.d(
+          "Watching instance of %s with key %s", reference.className, key
+      )
+    }
+
+    watchedInstances[key] = reference
+    checkRetainedExecutor.execute {
+      moveToRetained(key)
+    }
+  }
+
+  @Synchronized private fun moveToRetained(key: String) {
+    removeWeaklyReachableInstances()
+    val retainedRef = watchedInstances[key]
+    if (retainedRef != null) {
+      retainedRef.retainedUptimeMillis = clock.uptimeMillis()
+      onInstanceRetained()
+    }
+  }
+
+  @Synchronized fun removeInstancesRetainedBeforeHeapDump(heapDumpUptimeMillis: Long) {
+    val retainedBeforeHeapdump =
+      watchedInstances.filter { it.value.retainedUptimeMillis in 0..heapDumpUptimeMillis }
+          .keys
+    watchedInstances.keys.removeAll(retainedBeforeHeapdump)
+  }
+
+  @Synchronized fun clearWatchedInstances() {
+    watchedInstances.clear()
+  }
+
+  private fun removeWeaklyReachableInstances() {
+    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
+    // reachable. This is before finalization or garbage collection has actually happened.
+    var ref: KeyedWeakReference?
+    do {
+      ref = queue.poll() as KeyedWeakReference?
+      if (ref != null) {
+        watchedInstances.remove(ref.key)
+      }
+    } while (ref != null)
+  }
+}
diff --git a/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java b/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
deleted file mode 100644
index 15b44def..00000000
--- a/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.File;
-import java.util.concurrent.Executor;
-import org.junit.Test;
-
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-public class RefWatcherTest {
-
-  static final ExcludedRefs NO_REF = new ExcludedRefs.BuilderWithParams().build();
-
-  static class TestDumper implements HeapDumper {
-    boolean called;
-
-    @Override public File dumpHeap() {
-      called = true;
-      return new File("");
-    }
-  }
-
-  static class TestListener implements HeapDump.Listener {
-    @Override public void analyze(HeapDump heapDump) {
-    }
-  }
-
-  @SuppressWarnings("FieldCanBeLocal") Object ref;
-
-  static class TestExecutor implements Executor {
-    Runnable command;
-
-    @Override public void execute(Runnable command) {
-      this.command = command;
-    }
-  }
-
-  /**
-   * In theory, this test doesn't have a 100% chance of success. In practice, {@link
-   * GcTrigger#DEFAULT} is good enough.
-   */
-  @Test public void unreachableObject_noDump() {
-    TestDumper dumper = new TestDumper();
-    TestExecutor executor = new TestExecutor();
-    RefWatcher refWatcher = defaultWatcher(dumper, executor);
-    refWatcher.watch(new Object());
-    executor.command.run();
-    assertFalse(dumper.called);
-  }
-
-  @Test public void retainedObject_triggersDump() {
-    TestDumper dumper = new TestDumper();
-    TestExecutor executor = new TestExecutor();
-    RefWatcher refWatcher = defaultWatcher(dumper, executor);
-    ref = new Object();
-    refWatcher.watch(ref);
-    executor.command.run();
-    assertTrue(dumper.called);
-  }
-
-  private RefWatcher defaultWatcher(TestDumper dumper, TestExecutor executor) {
-    return new RefWatcher(executor, DebuggerControl.NONE, GcTrigger.DEFAULT, dumper,
-        new TestListener(), NO_REF);
-  }
-}
diff --git a/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt b/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt
new file mode 100644
index 00000000..2d76440b
--- /dev/null
+++ b/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt
@@ -0,0 +1,39 @@
+package leakcanary
+
+import leakcanary.GcTrigger.Default.runGc
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import java.util.concurrent.Executor
+
+class RefWatcherTest {
+
+  private val onRefRetained: () -> Unit = {
+  }
+
+  private val checkRetainedExecutor: Executor = Executor {
+    it.run()
+  }
+
+  val refWatcher = RefWatcher(object : Clock {
+    override fun uptimeMillis(): Long {
+      return time
+    }
+  }, checkRetainedExecutor, onRefRetained)
+  var time: Long = 0
+
+  var ref: Any? = Any()
+
+  @Test fun `unreachable object not retained`() {
+    refWatcher.watch(ref!!)
+    ref = null
+    runGc()
+    assertThat(refWatcher.hasRetainedInstances).isFalse()
+  }
+
+  @Test fun `reachable object retained`() {
+    refWatcher.watch(ref!!)
+    runGc()
+    assertThat(refWatcher.hasRetainedInstances).isTrue()
+  }
+
+}
\ No newline at end of file
diff --git a/mkdocs.yml b/mkdocs.yml
new file mode 100644
index 00000000..10eede1a
--- /dev/null
+++ b/mkdocs.yml
@@ -0,0 +1,59 @@
+# pip install mkdocs mkdocs-material
+# mkdocs serve
+# mkdocs gh-deploy
+
+site_name: LeakCanary
+repo_name: LeakCanary
+repo_url: https://github.com/square/leakcanary
+site_description: "A memory leak detection library for Android"
+site_author: Square, Inc.
+remote_branch: gh-pages
+
+copyright: 'Copyright &copy; 2015 Square, Inc.'
+
+theme:
+  name: 'material'
+  logo: 'images/logo.png'
+  favicon: 'images/logo.png'
+  palette:
+    primary: 'deep-orange'
+    accent: 'deep-purple'
+
+markdown_extensions:
+  - smarty
+  - codehilite:
+      guess_lang: false
+  - footnotes
+  - meta
+  - toc:
+      permalink: true
+  - pymdownx.betterem:
+      smart_enable: all
+  - pymdownx.caret
+  - pymdownx.inlinehilite
+  - pymdownx.magiclink
+  - pymdownx.smartsymbols
+  - pymdownx.superfences
+  - pymdownx.emoji
+  - tables
+  - admonition
+
+nav:
+  - 'Overview': index.md
+  - 'Getting Started': getting_started.md
+  - 'Fundamentals': fundamentals.md
+  - 'Code recipes': recipes.md
+  - 'FAQ': faq.md
+  - 'Stack Overflow ⏏': https://stackoverflow.com/questions/tagged/leakcanary?sort=active
+  - 'Change Log': changelog.md
+  - 'Support': support.md
+  - 'Upgrading to LeakCanary 2': upgrading-to-leakcanary-2.0.md
+  - 'Blog Articles': blog-articles.md
+  - 'Recorded Presentations': recorded-presentations.md
+  - 'Contributing': contributing.md
+  - 'Code of Conduct': code_of_conduct.md
+
+# Google Analytics. Add export LEAKCANARY_GOOGLE_ANALYTICS_KEY="UA-XXXXXXXXX-X" to your ~/.bashrc
+google_analytics:
+  - !!python/object/apply:os.getenv ["LEAKCANARY_GOOGLE_ANALYTICS_KEY"]
+  - auto
diff --git a/settings.gradle b/settings.gradle
index 73da17f3..ed968aba 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,5 +1,10 @@
-include ':leakcanary-watcher'
 include ':leakcanary-analyzer'
 include ':leakcanary-android'
-include ':leakcanary-android-no-op'
+include ':leakcanary-android-core'
+include ':leakcanary-android-instrumentation'
+include ':leakcanary-android-process'
+include ':leakcanary-haha'
+include ':leakcanary-leaksentry'
+include ':leakcanary-log'
 include ':leakcanary-sample'
+include ':leakcanary-watcher'
\ No newline at end of file
