diff --git a/docs/theme/main.html b/docs/theme/main.html
new file mode 100644
index 00000000..9843940b
--- /dev/null
+++ b/docs/theme/main.html
@@ -0,0 +1,25 @@
+{% extends "base.html" %}
+
+{% block content %}
+                {% if page.edit_url %}
+				<span style="float: right">ðŸ¤”Documentation issue? <a href="https://github.com/square/leakcanary/issues/new?assignees=&labels=type%3A+documentation&template=4-doc.md&title=Doc%20issue%20with%20{{ page.url }}%20page">Report</a> or <a href="{{ page.edit_url }}">edit</a> </span>
+                {% endif %}
+                {% if not "\x3ch1" in page.content %}
+                  <h1>{{ page.title | default(config.site_name, true)}}</h1>
+                {% endif %}
+                {{ page.content }}
+                {% block source %}
+                  {% if page and page.meta and page.meta.source %}
+                    <h2 id="__source">{{ lang.t("meta.source") }}</h2>
+                    {% set repo = config.repo_url %}
+                    {% if repo | last == "/" %}
+                      {% set repo = repo[:-1] %}
+                    {% endif %}
+                    {% set path = page.meta.path | default([""]) %}
+                    {% set file = page.meta.source %}
+                    <a href="{{ [repo, path, file] | join('/') }}" title="{{ file }}" class="md-source-file">
+                      {{ file }}
+                    </a>
+                  {% endif %}
+                {% endblock %}
+{% endblock %}
diff --git a/leakcanary-analyzer/build.gradle b/leakcanary-analyzer/build.gradle
index cf4d3a4a..c3ae9ff5 100644
--- a/leakcanary-analyzer/build.gradle
+++ b/leakcanary-analyzer/build.gradle
@@ -8,7 +8,6 @@ dependencies {
   api project(':leakcanary-watcher')
   api project(':leakcanary-haha')
 
-  implementation deps.androidx.annotation
   implementation deps.kotlin.stdlib
 
   testImplementation deps.assertj_core
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidObjectInspectors.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidObjectInspectors.kt
index 658b4126..2e0efd9c 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/AndroidObjectInspectors.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AndroidObjectInspectors.kt
@@ -17,6 +17,7 @@ package leakcanary
 
 import leakcanary.GraphObjectRecord.GraphClassRecord
 import leakcanary.GraphObjectRecord.GraphInstanceRecord
+import leakcanary.internal.KeyedWeakReferenceMirror
 import kotlin.reflect.KClass
 
 /**
@@ -32,29 +33,106 @@ import kotlin.reflect.KClass
  */
 enum class AndroidObjectInspectors : ObjectInspector {
 
+  KEYED_WEAK_REFERENCE {
+    override fun inspect(
+      graph: HprofGraph,
+      reporter: ObjectReporter
+    ) {
+      val references: List<KeyedWeakReferenceMirror> = graph.context[KEYED_WEAK_REFERENCE.name] ?: {
+        val keyedWeakReferenceClass = graph.indexedClass("leakcanary.KeyedWeakReference")
+
+        val heapDumpUptimeMillis = if (keyedWeakReferenceClass == null) {
+          null
+        } else {
+          keyedWeakReferenceClass["heapDumpUptimeMillis"]?.value?.asLong
+        }
+
+        if (heapDumpUptimeMillis == null) {
+          CanaryLog.d(
+              "${KeyedWeakReference::class.java.name}.heapDumpUptimeMillis field not found, " +
+                  "this must be a heap dump from an older version of LeakCanary."
+          )
+        }
+
+        val addedToContext: List<KeyedWeakReferenceMirror> = graph.instanceSequence()
+            .filter { instance ->
+              val className = instance.className
+              className == "leakcanary.KeyedWeakReference" || className == "com.squareup.leakcanary.KeyedWeakReference"
+            }
+            .map { KeyedWeakReferenceMirror.fromInstance(it, heapDumpUptimeMillis) }
+            .filter { it.hasReferent }
+            .toList()
+        graph.context[KEYED_WEAK_REFERENCE.name] = addedToContext
+        addedToContext
+      }()
+
+      val objectId = reporter.objectRecord.objectId
+      references.forEach { ref ->
+        if (ref.referent.value == objectId) {
+          reporter.reportLeaking("RefWatcher was watching this")
+          reporter.addLabel("key = ${ref.key}")
+          if (ref.name.isNotEmpty()) {
+            reporter.addLabel("name = ${ref.name}")
+          }
+          if (ref.watchDurationMillis != null) {
+            reporter.addLabel("watchDurationMillis = ${ref.watchDurationMillis}")
+          }
+          if (ref.retainedDurationMillis != null) {
+            reporter.addLabel("retainedDurationMillis = ${ref.retainedDurationMillis}")
+          }
+        }
+      }
+    }
+  },
+
   VIEW {
     override fun inspect(
       graph: HprofGraph,
       reporter: ObjectReporter
     ) {
-      reporter.asInstance("android.view.View") { instance ->
+      reporter.whenInstanceOf("android.view.View") { instance ->
         // This skips edge cases like Toast$TN.mNextView holding on to an unattached and unparented
         // next toast view
         val mParentRef = instance["android.view.View", "mParent"]!!.value
         val mParentSet = mParentRef.isNonNullReference
+        val mWindowAttachCount =
+          instance["android.view.View", "mWindowAttachCount"]?.value!!.asInt!!
         val viewDetached = instance["android.view.View", "mAttachInfo"]!!.value.isNullReference
+        val mContext = instance["android.view.View", "mContext"]!!.value.asObject!!.asInstance!!
 
-        if (mParentSet) {
-          if (viewDetached) {
-            reportLeaking("View detached and has parent")
+        val activityContext = mContext.unwrapActivityContext()
+        if (activityContext == null) {
+          addLabel("mContext instance of ${mContext.className}, not wrapping activity")
+        } else {
+          val activityDescription =
+            " with mDestroyed = " + (activityContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean?.toString()
+                ?: "UNKNOWN")
+          if (activityContext == mContext) {
+            addLabel("mContext instance of ${activityContext.className} $activityDescription")
           } else {
-            val viewParent = mParentRef.asObject!!.asInstance!!
-            if (viewParent instanceOf "android.view.View" &&
-                viewParent["android.view.View", "mAttachInfo"]!!.value.isNullReference
-            ) {
-              reportLeaking("View attached but parent detached (attach disorder)")
+            addLabel(
+                "mContext instance of ${mContext.className}, wrapping activity ${activityContext.className} $activityDescription"
+            )
+          }
+        }
+
+        addLabel("mContext = ${mContext.className}")
+
+        if (activityContext != null && activityContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean == true) {
+          reportLeaking("View.mContext references a destroyed activity")
+        } else {
+          if (mParentSet && mWindowAttachCount > 0) {
+            if (viewDetached) {
+              reportLikelyLeaking("View detached and has parent")
             } else {
-              reportNotLeaking("View attached")
+              val viewParent = mParentRef.asObject!!.asInstance!!
+              if (viewParent instanceOf "android.view.View" &&
+                  viewParent["android.view.View", "mAttachInfo"]!!.value.isNullReference
+              ) {
+                reportLikelyLeaking("View attached but parent detached (attach disorder)")
+              } else {
+                reportNotLeaking("View attached")
+              }
             }
           }
         }
@@ -73,11 +151,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
 
         // TODO Add back support for view id labels, see https://github.com/square/leakcanary/issues/1297
 
-        val mWindowAttachCount = instance["android.view.View", "mWindowAttachCount"]?.value?.asInt
-
-        if (mWindowAttachCount != null) {
-          addLabel("View.mWindowAttachCount=$mWindowAttachCount")
-        }
+        addLabel("View.mWindowAttachCount = $mWindowAttachCount")
       }
     }
   },
@@ -87,7 +161,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
       graph: HprofGraph,
       reporter: ObjectReporter
     ) {
-      reporter.asInstance("android.app.Activity") { instance ->
+      reporter.whenInstanceOf("android.app.Activity") { instance ->
         // Activity.mDestroyed was introduced in 17.
         // https://android.googlesource.com/platform/frameworks/base/+
         // /6d9dcbccec126d9b87ab6587e686e28b87e5a04d
@@ -109,40 +183,23 @@ enum class AndroidObjectInspectors : ObjectInspector {
       graph: HprofGraph,
       reporter: ObjectReporter
     ) {
-      reporter.asInstance("android.content.ContextWrapper") { instance ->
+      reporter.whenInstanceOf("android.content.ContextWrapper") { instance ->
         // Activity is already taken care of
         if (!(instance instanceOf "android.app.Activity")) {
-          var context = instance
-
-          val visitedInstances = mutableListOf<Long>()
-          var keepUnwrapping = true
-          while (keepUnwrapping) {
-            visitedInstances += context.objectId
-            keepUnwrapping = false
-            val mBase = context["android.content.ContextWrapper", "mBase"]!!.value
-
-            if (mBase.isNonNullReference) {
-              context = mBase.asObject!!.asInstance!!
-              if (context instanceOf "android.app.Activity") {
-                val mDestroyed = instance["android.app.Activity", "mDestroyed"]
-                if (mDestroyed != null) {
-                  if (mDestroyed.value.asBoolean!!) {
-                    reportLeaking(
-                        "${instance.classSimpleName} wraps an Activity with Activity.mDestroyed true"
-                    )
-                  } else {
-                    // We can't assume it's not leaking, because this context might have a shorter lifecycle
-                    // than the activity. So we'll just add a label.
-                    addLabel(
-                        "${instance.classSimpleName} wraps an Activity with Activity.mDestroyed false"
-                    )
-                  }
-                }
-              } else if (context instanceOf "android.content.ContextWrapper" &&
-                  // Avoids infinite loops
-                  context.objectId !in visitedInstances
-              ) {
-                keepUnwrapping = true
+          val activityContext = instance.unwrapActivityContext()
+          if (activityContext != null) {
+            val mDestroyed = instance["android.app.Activity", "mDestroyed"]
+            if (mDestroyed != null) {
+              if (mDestroyed.value.asBoolean!!) {
+                reportLeaking(
+                    "${instance.classSimpleName} wraps an Activity with Activity.mDestroyed true"
+                )
+              } else {
+                // We can't assume it's not leaking, because this context might have a shorter lifecycle
+                // than the activity. So we'll just add a label.
+                addLabel(
+                    "${instance.classSimpleName} wraps an Activity with Activity.mDestroyed false"
+                )
               }
             }
           }
@@ -156,7 +213,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
       graph: HprofGraph,
       reporter: ObjectReporter
     ) {
-      reporter.asInstance("android.app.Dialog") { instance ->
+      reporter.whenInstanceOf("android.app.Dialog") { instance ->
         val mDecor = instance["android.app.Dialog", "mDecor"]!!
         if (mDecor.value.isNullReference) {
           reportLeaking(mDecor describedWithValue "null")
@@ -172,7 +229,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
       graph: HprofGraph,
       reporter: ObjectReporter
     ) {
-      reporter.asInstance("android.app.Application") {
+      reporter.whenInstanceOf("android.app.Application") {
         reportNotLeaking("Application is a singleton")
       }
     }
@@ -183,7 +240,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
       graph: HprofGraph,
       reporter: ObjectReporter
     ) {
-      reporter.asInstance("android.view.inputmethod.InputMethodManager") {
+      reporter.whenInstanceOf("android.view.inputmethod.InputMethodManager") {
         reportNotLeaking("InputMethodManager is a singleton")
       }
     }
@@ -194,7 +251,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
       graph: HprofGraph,
       reporter: ObjectReporter
     ) {
-      reporter.asInstance(ClassLoader::class) {
+      reporter.whenInstanceOf(ClassLoader::class) {
         reportNotLeaking("A ClassLoader is never leaking")
       }
     }
@@ -216,7 +273,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
       graph: HprofGraph,
       reporter: ObjectReporter
     ) {
-      reporter.asInstance("android.app.Fragment") { instance ->
+      reporter.whenInstanceOf("android.app.Fragment") { instance ->
         val fragmentManager = instance["android.app.Fragment", "mFragmentManager"]!!
         if (fragmentManager.value.isNullReference) {
           reportLeaking(fragmentManager describedWithValue "null")
@@ -236,7 +293,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
       graph: HprofGraph,
       reporter: ObjectReporter
     ) {
-      reporter.asInstance("android.support.v4.app.Fragment") { instance ->
+      reporter.whenInstanceOf("android.support.v4.app.Fragment") { instance ->
         val fragmentManager = instance["android.support.v4.app.Fragment", "mFragmentManager"]!!
         if (fragmentManager.value.isNullReference) {
           reportLeaking(fragmentManager describedWithValue "null")
@@ -256,7 +313,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
       graph: HprofGraph,
       reporter: ObjectReporter
     ) {
-      reporter.asInstance("androidx.fragment.app.Fragment") { instance ->
+      reporter.whenInstanceOf("androidx.fragment.app.Fragment") { instance ->
         val fragmentManager = instance["androidx.fragment.app.Fragment", "mFragmentManager"]!!
         if (fragmentManager.value.isNullReference) {
           reportLeaking(fragmentManager describedWithValue "null")
@@ -276,8 +333,11 @@ enum class AndroidObjectInspectors : ObjectInspector {
       graph: HprofGraph,
       reporter: ObjectReporter
     ) {
-      reporter.asInstance("android.os.MessageQueue") { instance ->
-        val mQuitting = instance["android.os.MessageQueue", "mQuitting"]!!
+      reporter.whenInstanceOf("android.os.MessageQueue") { instance ->
+        // mQuiting had a typo and was renamed to mQuitting
+        // https://android.googlesource.com/platform/frameworks/base/+/013cf847bcfd2828d34dced60adf2d3dd98021dc
+        val mQuitting = instance["android.os.MessageQueue", "mQuitting"]
+            ?: instance["android.os.MessageQueue", "mQuiting"]!!
         if (mQuitting.value.asBoolean!!) {
           reportLeaking(mQuitting describedWithValue "true")
         } else {
@@ -292,7 +352,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
       graph: HprofGraph,
       reporter: ObjectReporter
     ) {
-      reporter.asInstance("mortar.Presenter") { instance ->
+      reporter.whenInstanceOf("mortar.Presenter") { instance ->
         // Bugs in view code tends to cause Mortar presenters to still have a view when they actually
         // should be unreachable, so in that case we don't know their reachability status. However,
         // when the view is null, we're pretty sure they  never leaking.
@@ -309,7 +369,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
       graph: HprofGraph,
       reporter: ObjectReporter
     ) {
-      reporter.asInstance("com.squareup.coordinators.Coordinator") { instance ->
+      reporter.whenInstanceOf("com.squareup.coordinators.Coordinator") { instance ->
         val attached = instance["com.squareup.coordinators.Coordinator", "attached"]
         if (attached!!.value.asBoolean!!) {
           reportNotLeaking(attached describedWithValue "true")
@@ -360,7 +420,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
       graph: HprofGraph,
       reporter: ObjectReporter
     ) {
-      reporter.asInstance(Thread::class) { instance ->
+      reporter.whenInstanceOf(Thread::class) { instance ->
         val threadName = instance[Thread::class, "name"]!!.value.readAsJavaString()
         if (threadName == "main") {
           reportNotLeaking("the main thread always runs")
@@ -375,7 +435,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
       graph: HprofGraph,
       reporter: ObjectReporter
     ) {
-      reporter.asInstance("android.view.Window") { instance ->
+      reporter.whenInstanceOf("android.view.Window") { instance ->
         val mDestroyed = instance["android.view.Window", "mDestroyed"]!!
 
         if (mDestroyed.value.asBoolean!!) {
@@ -392,7 +452,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
       graph: HprofGraph,
       reporter: ObjectReporter
     ) {
-      reporter.asInstance("android.widget.Toast") { instance ->
+      reporter.whenInstanceOf("android.widget.Toast") { instance ->
         val tnInstance =
           instance["android.widget.Toast", "mTN"]!!.value.asObject!!.asInstance!!
         // mWM is set in android.widget.Toast.TN#handleShow and never unset, so this toast was never
@@ -411,17 +471,6 @@ enum class AndroidObjectInspectors : ObjectInspector {
         }
       }
     }
-  },
-
-  TOAST_TN {
-    override fun inspect(
-      graph: HprofGraph,
-      reporter: ObjectReporter
-    ) {
-      reporter.asInstance("android.widget.Toast\$TN") {
-        reportNotLeaking("Toast.TN (Transient Notification) is never leaking")
-      }
-    }
   };
 
   companion object {
@@ -435,18 +484,47 @@ private infix fun GraphField.describedWithValue(valueDescription: String): Strin
   return "${classRecord.simpleName}#$name is $valueDescription"
 }
 
-inline fun ObjectReporter.asInstance(
+inline fun ObjectReporter.whenInstanceOf(
   expectedClass: KClass<out Any>,
   action: ObjectReporter.(GraphInstanceRecord) -> Unit
 ) {
-  asInstance(expectedClass.java.name, action)
+  whenInstanceOf(expectedClass.java.name, action)
 }
 
-inline fun ObjectReporter.asInstance(
+inline fun ObjectReporter.whenInstanceOf(
   className: String,
   block: ObjectReporter.(GraphInstanceRecord) -> Unit
 ) {
   if (objectRecord is GraphInstanceRecord && objectRecord instanceOf className) {
     block(objectRecord)
   }
+}
+
+fun GraphInstanceRecord.unwrapActivityContext(): GraphInstanceRecord? {
+  if (this instanceOf "android.app.Activity") {
+    return this
+  }
+  if (this instanceOf "android.content.ContextWrapper") {
+    var context = this
+    val visitedInstances = mutableListOf<Long>()
+    var keepUnwrapping = true
+    while (keepUnwrapping) {
+      visitedInstances += context.objectId
+      keepUnwrapping = false
+      val mBase = context["android.content.ContextWrapper", "mBase"]!!.value
+
+      if (mBase.isNonNullReference) {
+        context = mBase.asObject!!.asInstance!!
+        if (context instanceOf "android.app.Activity") {
+          return context
+        } else if (context instanceOf "android.content.ContextWrapper" &&
+            // Avoids infinite loops
+            context.objectId !in visitedInstances
+        ) {
+          keepUnwrapping = true
+        }
+      }
+    }
+  }
+  return null
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
index 442b6f4d..b4ba3a67 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
@@ -23,52 +23,15 @@ data class HeapAnalysisSuccess(
   override val heapDumpFile: File,
   override val createdAtTimeMillis: Long,
   override val analysisDurationMillis: Long,
-  val retainedInstances: List<RetainedInstance>
+  val leakingInstances: List<LeakingInstance>
 ) : HeapAnalysis()
 
-sealed class RetainedInstance : Serializable {
-  /**
-   * Key associated to the [leakcanary.KeyedWeakReference] used to detect the memory leak.
-   * When analyzing a heap dump manually, search for all [leakcanary.KeyedWeakReference] instances,
-   * then open the one that has its "key" field set to this value. Its "referent" field contains the
-   * retained instance. Computing the shortest path to GC roots on that retained instance should
-   * enable you to figure out the cause of the leak, if any.
-   */
-  abstract val referenceKey: String
-  /**
-   * User defined name to help identify the retained instance.
-   */
-  abstract val referenceName: String
+data class LeakingInstance(
   /**
-   * Class name of the retained instance.
+   * Class name of the leaking instance.
    * The class name format is the same as what would be returned by [Class.getName].
    */
-  abstract val instanceClassName: String
-  /**
-   * Time from the request to watch the reference until the heap was dumped.
-   */
-  abstract val watchDurationMillis: Long
-  /**
-   * Time from when the instance was considered retained until the heap was dumped.
-   */
-  abstract val retainedDurationMillis: Long
-}
-
-data class NoPathToInstance(
-  override val referenceKey: String,
-  override val referenceName: String,
-  override val instanceClassName: String,
-  override val watchDurationMillis: Long,
-  override val retainedDurationMillis: Long
-) : RetainedInstance()
-
-data class LeakingInstance(
-  override val referenceKey: String,
-  override val referenceName: String,
-  override val instanceClassName: String,
-  override val watchDurationMillis: Long,
-  override val retainedDurationMillis: Long,
-
+  val instanceClassName: String,
   /**
    * True if the only path to the leaking reference is through excluded references. Usually, that
    * means you can safely ignore this report.
@@ -84,7 +47,7 @@ data class LeakingInstance(
    */
   val retainedHeapSize: Int?
 
-) : RetainedInstance() {
+) : Serializable {
 
   val groupHash = createGroupHash()
 
@@ -109,12 +72,10 @@ data class LeakingInstance(
 }
 
 fun HeapAnalysis.leakingInstances(): List<LeakingInstance> {
-  if (this is HeapAnalysisFailure) {
-    return emptyList()
+  return when (this) {
+    is HeapAnalysisFailure -> emptyList()
+    is HeapAnalysisSuccess -> leakingInstances
   }
-  val success = this as HeapAnalysisSuccess
-  return success.retainedInstances.filter { it is LeakingInstance }
-      .map { it as LeakingInstance }
 }
 
 fun HeapAnalysis.applicationLeaks(): List<LeakingInstance> =
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
index d1b55154..78a07fed 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
@@ -35,7 +35,8 @@ import leakcanary.GraphObjectRecord.GraphClassRecord
 import leakcanary.GraphObjectRecord.GraphInstanceRecord
 import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
 import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
-import leakcanary.HprofPushRecordsParser.OnRecordListener
+import leakcanary.HeapAnalyzer.TrieNode.LeafNode
+import leakcanary.HeapAnalyzer.TrieNode.ParentNode
 import leakcanary.LeakNode.ChildNode
 import leakcanary.LeakNode.RootNode
 import leakcanary.LeakNodeStatus.LEAKING
@@ -45,27 +46,16 @@ import leakcanary.LeakTraceElement.Holder.ARRAY
 import leakcanary.LeakTraceElement.Holder.CLASS
 import leakcanary.LeakTraceElement.Holder.OBJECT
 import leakcanary.LeakTraceElement.Holder.THREAD
-import leakcanary.PrimitiveType.BOOLEAN
-import leakcanary.PrimitiveType.BYTE
-import leakcanary.PrimitiveType.CHAR
-import leakcanary.PrimitiveType.DOUBLE
-import leakcanary.PrimitiveType.FLOAT
-import leakcanary.PrimitiveType.INT
-import leakcanary.PrimitiveType.LONG
-import leakcanary.PrimitiveType.SHORT
-import leakcanary.Record.HeapDumpRecord.GcRootRecord
-import leakcanary.internal.KeyedWeakReferenceMirror
+import leakcanary.internal.GcRootRecordListener
 import leakcanary.internal.ShortestPathFinder
 import leakcanary.internal.ShortestPathFinder.Result
 import leakcanary.internal.ShortestPathFinder.Results
 import leakcanary.internal.hppc.LongLongScatterMap
 import leakcanary.internal.lastSegment
-import java.io.Closeable
 import java.io.File
 import java.util.ArrayList
 import java.util.LinkedHashMap
 import java.util.concurrent.TimeUnit.NANOSECONDS
-import kotlin.reflect.KClass
 
 /**
  * Analyzes heap dumps to look for leaks.
@@ -82,7 +72,8 @@ class HeapAnalyzer constructor(
     heapDumpFile: File,
     exclusions: List<Exclusion> = emptyList(),
     computeRetainedHeapSize: Boolean = false,
-    objectInspectors: List<ObjectInspector> = emptyList()
+    objectInspectors: List<ObjectInspector> = emptyList(),
+    leakFinders: List<ObjectInspector> = objectInspectors
   ): HeapAnalysis {
     val analysisStartNanoTime = System.nanoTime()
 
@@ -98,45 +89,33 @@ class HeapAnalyzer constructor(
 
     try {
       listener.onProgressUpdate(SCANNING_HEAP_DUMP)
-      val (graph, hprofCloseable, gcRootIds, keyedWeakReferenceInstances, cleaners) = scan(
-          heapDumpFile, computeRetainedHeapSize
-      )
+
+      val gcRootRecordListener = GcRootRecordListener()
+      val (graph, hprofCloseable) = HprofGraph.readHprof(heapDumpFile, gcRootRecordListener)
+
       hprofCloseable.use {
-        val analysisResults = mutableMapOf<String, RetainedInstance>()
+        val analysisResults = mutableListOf<LeakingInstance>()
         listener.onProgressUpdate(FINDING_WATCHED_REFERENCES)
 
-        val retainedWeakRefs = findLeakingReferences(graph, keyedWeakReferenceInstances)
-
-        if (retainedWeakRefs.isEmpty()) {
-          val exception = IllegalStateException("No retained instances found in heap dump")
-          return HeapAnalysisFailure(
-              heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
-              HeapAnalysisException(exception)
-          )
-        }
+        val leakingInstanceObjectIds = findLeakingInstances(graph, leakFinders)
 
         val (pathResults, dominatedInstances) =
           findShortestPaths(
-              graph, exclusions, retainedWeakRefs, gcRootIds,
+              graph, exclusions, leakingInstanceObjectIds, gcRootRecordListener.gcRoots,
               computeRetainedHeapSize
           )
 
         val retainedSizes = if (computeRetainedHeapSize) {
-          computeRetainedSizes(graph, pathResults, dominatedInstances, cleaners)
+          computeRetainedSizes(graph, pathResults, dominatedInstances)
         } else {
           null
         }
 
-        buildLeakTraces(
-            objectInspectors, pathResults, graph,
-            retainedWeakRefs, analysisResults, retainedSizes
-        )
-
-        addRemainingInstancesWithNoPath(retainedWeakRefs, analysisResults)
+        buildLeakTraces(objectInspectors, pathResults, graph, analysisResults, retainedSizes)
 
         return HeapAnalysisSuccess(
             heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
-            analysisResults.values.toList()
+            analysisResults
         )
       }
     } catch (exception: Throwable) {
@@ -147,126 +126,112 @@ class HeapAnalyzer constructor(
     }
   }
 
-  private data class ScanResult(
-    val graph: HprofGraph,
-    val hprofCloseable: Closeable,
-    val gcRootIds: MutableList<GcRoot>,
-    val keyedWeakReferenceInstances: List<GraphInstanceRecord>,
-    val cleaners: MutableList<Long>
-  )
-
-  private fun scan(
-    hprofFile: File,
-    computeRetainedSize: Boolean
-  ): ScanResult {
-    val gcRoot = mutableListOf<GcRoot>()
-    val cleaners = mutableListOf<Long>()
-
-    val recordListener = object : OnRecordListener {
-      override fun recordTypes(): Set<KClass<out Record>> = setOf(GcRootRecord::class)
-
-      override fun onTypeSizesAvailable(typeSizes: Map<Int, Int>) {
-      }
-
-      override fun onRecord(
-        position: Long,
-        record: Record
-      ) {
-        when (record) {
-          is GcRootRecord -> {
-            // TODO Ignoring VmInternal because we've got 150K of it, but is this the right thing
-            // to do? What's VmInternal exactly? History does not go further than
-            // https://android.googlesource.com/platform/dalvik2/+/refs/heads/master/hit/src/com/android/hit/HprofParser.java#77
-            // We should log to figure out what objects VmInternal points to.
-            when (record.gcRoot) {
-              // ThreadObject points to threads, which we need to find the thread that a JavaLocalExclusion
-              // belongs to
-              is ThreadObject,
-              is JniGlobal,
-              is JniLocal,
-              is JavaFrame,
-              is NativeStack,
-              is StickyClass,
-              is ThreadBlock,
-              is MonitorUsed,
-                // TODO What is this and why do we care about it as a root?
-              is ReferenceCleanup,
-              is JniMonitor
-              -> {
-                gcRoot.add(record.gcRoot)
-              }
-            }
-          }
-          else -> {
-            throw IllegalArgumentException("Unexpected record $record")
-          }
-        }
-      }
-    }
-    val (graph, hprofCloseable) = HprofGraph.readHprof(hprofFile, recordListener)
-
-    val keyedWeakReferenceInstances = mutableListOf<GraphInstanceRecord>()
-    graph.instanceSequence()
-        .forEach { instance ->
-          val className = instance.className
-          if (className == "leakcanary.KeyedWeakReference" || className == "com.squareup.leakcanary.KeyedWeakReference") {
-            keyedWeakReferenceInstances.add(instance)
-          } else if (computeRetainedSize && className == "sun.misc.Cleaner") {
-            cleaners.add(instance.objectId)
+  private fun findLeakingInstances(
+    graph: HprofGraph,
+    objectInspectors: List<ObjectInspector>
+  ): Set<Long> {
+    return graph.objectSequence()
+        .filter { objectRecord ->
+          val reporter = ObjectReporter(objectRecord)
+          objectInspectors.forEach { inspector ->
+            inspector.inspect(graph, reporter)
           }
+          reporter.leakingStatuses.isNotEmpty()
         }
-    return ScanResult(graph, hprofCloseable, gcRoot, keyedWeakReferenceInstances, cleaners)
+        .map { it.objectId }
+        .toSet()
   }
 
-  private fun findLeakingReferences(
+  private fun findShortestPaths(
     graph: HprofGraph,
-    keyedWeakReferenceInstances: List<GraphInstanceRecord>
-  ): MutableList<KeyedWeakReferenceMirror> {
+    exclusions: List<Exclusion>,
+    leakingInstanceObjectIds: Set<Long>,
+    gcRootIds: MutableList<GcRoot>,
+    computeDominators: Boolean
+  ): Results {
+    val pathFinder = ShortestPathFinder()
+    return pathFinder.findPaths(
+        graph, exclusions, leakingInstanceObjectIds, gcRootIds, computeDominators, listener
+    )
+  }
 
-    val keyedWeakReferenceClass = graph.indexedClass(KeyedWeakReference::class.java.name)
+  internal sealed class TrieNode {
+    abstract val objectId: Long
 
-    val heapDumpUptimeMillis = if (keyedWeakReferenceClass == null) {
-      null
-    } else {
-      keyedWeakReferenceClass["heapDumpUptimeMillis"]?.value?.asLong
+    class ParentNode(override val objectId: Long) : TrieNode() {
+      val children = mutableMapOf<Long, TrieNode>()
     }
 
-    if (heapDumpUptimeMillis == null) {
-      CanaryLog.d(
-          "${KeyedWeakReference::class.java.name}.heapDumpUptimeMillis field not found, " +
-              "this must be a heap dump from an older version of LeakCanary."
-      )
+    class LeafNode(
+      override val objectId: Long,
+      val result: Result
+    ) : TrieNode()
+
+  }
+
+  private fun deduplicateResults(inputPathResults: List<Result>): List<Result> {
+    val rootTrieNode = ParentNode(0)
+
+    for (result in inputPathResults) {
+      // Go through the linked list of nodes and build the reverse list of instances from
+      // root to leaking.
+      val path = mutableListOf<Long>()
+      var leakNode: LeakNode = result.leakingNode
+      while (leakNode is ChildNode) {
+        path.add(0, leakNode.instance)
+        leakNode = leakNode.parent
+      }
+      path.add(0, leakNode.instance)
+      updateTrie(result, path, 0, rootTrieNode)
     }
 
-    val retainedInstances = mutableListOf<KeyedWeakReferenceMirror>()
-    keyedWeakReferenceInstances.forEach { record ->
-      val weakRef =
-        KeyedWeakReferenceMirror.fromInstance(record, heapDumpUptimeMillis)
-      if (weakRef.isRetained && weakRef.hasReferent) {
-        retainedInstances.add(weakRef)
+    val outputPathResults = mutableListOf<Result>()
+    findResultsInTrie(rootTrieNode, outputPathResults)
+    return outputPathResults
+  }
+
+  private fun updateTrie(
+    result: Result,
+    path: List<Long>,
+    pathIndex: Int,
+    parentNode: ParentNode
+  ) {
+    val objectId = path[pathIndex]
+    if (pathIndex == path.lastIndex) {
+      // Replace any preexisting children, this is shorter.
+      parentNode.children[objectId] = LeafNode(objectId, result)
+    } else {
+      val childNode = parentNode.children[objectId] ?: {
+        val newChildNode = ParentNode(objectId)
+        parentNode.children[objectId] = newChildNode
+        newChildNode
+      }()
+      if (childNode is ParentNode) {
+        updateTrie(result, path, pathIndex + 1, childNode)
       }
     }
-    return retainedInstances
   }
 
-  private fun findShortestPaths(
-    graph: HprofGraph,
-    exclusions: List<Exclusion>,
-    leakingWeakRefs: List<KeyedWeakReferenceMirror>,
-    gcRootIds: MutableList<GcRoot>,
-    computeDominators: Boolean
-  ): Results {
-    val pathFinder = ShortestPathFinder()
-    return pathFinder.findPaths(
-        graph, exclusions, leakingWeakRefs, gcRootIds, computeDominators, listener
-    )
+  private fun findResultsInTrie(
+    parentNode: ParentNode,
+    outputPathResults: MutableList<Result>
+  ) {
+    parentNode.children.values.forEach { childNode ->
+      when (childNode) {
+        is ParentNode -> {
+          findResultsInTrie(childNode, outputPathResults)
+        }
+        is LeafNode -> {
+          outputPathResults += childNode.result
+        }
+      }
+    }
   }
 
   private fun computeRetainedSizes(
     graph: HprofGraph,
     results: List<Result>,
-    dominatedInstances: LongLongScatterMap,
-    cleaners: MutableList<Long>
+    dominatedInstances: LongLongScatterMap
   ): List<Int> {
     listener.onProgressUpdate(COMPUTING_NATIVE_RETAINED_SIZE)
 
@@ -282,29 +247,30 @@ class HeapAnalyzer constructor(
     // that the CleanerThunk has a pointer to. The native pointer is in the 'nativePtr' field of
     // the CleanerThunk. The hprof does not include the native bytes pointed to.
 
-    cleaners.forEach { objectId ->
-      val cleaner = graph.indexedObject(objectId).asInstance!!
-      val thunkField = cleaner["sun.misc.Cleaner", "thunk"]
-      val thunkId = thunkField?.value?.asNonNullObjectIdReference
-      val referentId =
-        cleaner["java.lang.ref.Reference", "referent"]?.value?.asNonNullObjectIdReference
-      if (thunkId != null && referentId != null) {
-        val thunkRecord = thunkField.value.asObject
-        if (thunkRecord is GraphInstanceRecord && thunkRecord instanceOf "libcore.util.NativeAllocationRegistry\$CleanerThunk") {
-          val allocationRegistryIdField =
-            thunkRecord["libcore.util.NativeAllocationRegistry\$CleanerThunk", "this\$0"]
-          if (allocationRegistryIdField != null && allocationRegistryIdField.value.isNonNullReference) {
-            val allocationRegistryRecord = allocationRegistryIdField.value.asObject
-            if (allocationRegistryRecord is GraphInstanceRecord && allocationRegistryRecord instanceOf "libcore.util.NativeAllocationRegistry") {
-              var nativeSize = nativeSizes.getValue(referentId)
-              nativeSize += allocationRegistryRecord["libcore.util.NativeAllocationRegistry", "size"]?.value?.asLong?.toInt()
-                  ?: 0
-              nativeSizes[referentId] = nativeSize
+    graph.instanceSequence()
+        .filter { it.className == "sun.misc.Cleaner" }
+        .forEach { cleaner ->
+          val thunkField = cleaner["sun.misc.Cleaner", "thunk"]
+          val thunkId = thunkField?.value?.asNonNullObjectIdReference
+          val referentId =
+            cleaner["java.lang.ref.Reference", "referent"]?.value?.asNonNullObjectIdReference
+          if (thunkId != null && referentId != null) {
+            val thunkRecord = thunkField.value.asObject
+            if (thunkRecord is GraphInstanceRecord && thunkRecord instanceOf "libcore.util.NativeAllocationRegistry\$CleanerThunk") {
+              val allocationRegistryIdField =
+                thunkRecord["libcore.util.NativeAllocationRegistry\$CleanerThunk", "this\$0"]
+              if (allocationRegistryIdField != null && allocationRegistryIdField.value.isNonNullReference) {
+                val allocationRegistryRecord = allocationRegistryIdField.value.asObject
+                if (allocationRegistryRecord is GraphInstanceRecord && allocationRegistryRecord instanceOf "libcore.util.NativeAllocationRegistry") {
+                  var nativeSize = nativeSizes.getValue(referentId)
+                  nativeSize += allocationRegistryRecord["libcore.util.NativeAllocationRegistry", "size"]?.value?.asLong?.toInt()
+                      ?: 0
+                  nativeSizes[referentId] = nativeSize
+                }
+              }
             }
           }
         }
-      }
-    }
 
     listener.onProgressUpdate(COMPUTING_RETAINED_SIZE)
 
@@ -313,15 +279,15 @@ class HeapAnalyzer constructor(
     // Include self size for leaking instances
     val leakingInstanceIds = mutableSetOf<Long>()
     results.forEach { result ->
-      val leakingInstanceId = result.weakReference.referent.value
-      leakingInstanceIds.add(leakingInstanceId)
-      val instanceRecord = graph.indexedObject(leakingInstanceId).asInstance!!
+      val leakingInstanceObjectId = result.leakingNode.instance
+      leakingInstanceIds.add(leakingInstanceObjectId)
+      val instanceRecord = graph.indexedObject(leakingInstanceObjectId).asInstance!!
       val classRecord = instanceRecord.instanceClass
-      var retainedSize = sizeByDominator.getValue(leakingInstanceId)
+      var retainedSize = sizeByDominator.getValue(leakingInstanceObjectId)
 
       retainedSize += classRecord.readRecord()
           .instanceSize
-      sizeByDominator[leakingInstanceId] = retainedSize
+      sizeByDominator[leakingInstanceObjectId] = retainedSize
     }
 
     // Compute the size of each dominated instance and add to dominator
@@ -340,7 +306,7 @@ class HeapAnalyzer constructor(
     var sizedMoved: Boolean
     do {
       sizedMoved = false
-      results.map { it.weakReference.referent.value }
+      results.map { it.leakingNode.instance }
           .forEach { leakingInstanceId ->
             val dominator = dominatedInstances[leakingInstanceId]
             if (dominator != null) {
@@ -356,7 +322,7 @@ class HeapAnalyzer constructor(
     } while (sizedMoved)
     dominatedInstances.release()
     return results.map { result ->
-      sizeByDominator[result.weakReference.referent.value]!!
+      sizeByDominator[result.leakingNode.instance]!!
     }
   }
 
@@ -364,21 +330,14 @@ class HeapAnalyzer constructor(
     objectInspectors: List<ObjectInspector>,
     pathResults: List<Result>,
     graph: HprofGraph,
-    leakingWeakRefs: MutableList<KeyedWeakReferenceMirror>,
-    analysisResults: MutableMap<String, RetainedInstance>,
+    analysisResults: MutableList<LeakingInstance>,
     retainedSizes: List<Int>?
   ) {
     listener.onProgressUpdate(BUILDING_LEAK_TRACES)
 
-    pathResults.forEachIndexed { index, pathResult ->
-      val weakReference = pathResult.weakReference
-      val removed = leakingWeakRefs.remove(weakReference)
-      if (!removed) {
-        throw IllegalStateException(
-            "ShortestPathFinder found an instance we didn't ask it to find: $pathResult"
-        )
-      }
+    val deduplicatedResults = deduplicateResults(pathResults)
 
+    deduplicatedResults.forEachIndexed { index, pathResult ->
       val leakTrace =
         buildLeakTrace(graph, objectInspectors, pathResult.leakingNode)
 
@@ -388,31 +347,11 @@ class HeapAnalyzer constructor(
         recordClassName(graph.indexedObject(pathResult.leakingNode.instance))
 
       val leakDetected = LeakingInstance(
-          referenceKey = weakReference.key,
-          referenceName = weakReference.name,
           instanceClassName = instanceClassName,
-          watchDurationMillis = weakReference.watchDurationMillis,
-          retainedDurationMillis = weakReference.retainedDurationMillis ?: 0,
           exclusionStatus = pathResult.exclusionStatus, leakTrace = leakTrace,
           retainedHeapSize = retainedSizes?.get(index)
       )
-      analysisResults[weakReference.key] = leakDetected
-    }
-  }
-
-  private fun addRemainingInstancesWithNoPath(
-    leakingWeakRefs: List<KeyedWeakReferenceMirror>,
-    analysisResults: MutableMap<String, RetainedInstance>
-  ) {
-    leakingWeakRefs.forEach { refWithNoPath ->
-      val key = refWithNoPath.key
-      val name = refWithNoPath.name
-      val className = refWithNoPath.className
-      val noLeak = NoPathToInstance(
-          key, name, className, refWithNoPath.watchDurationMillis,
-          refWithNoPath.retainedDurationMillis ?: 0
-      )
-      analysisResults[key] = noLeak
+      analysisResults += leakDetected
     }
   }
 
@@ -440,7 +379,7 @@ class HeapAnalyzer constructor(
     val rootNode = node as RootNode
 
     // Looping on inspectors first to get more cache hits.
-    objectInspectors.forEach {inspector ->
+    objectInspectors.forEach { inspector ->
       leakReporters.forEach { reporter ->
         inspector.inspect(graph, reporter)
       }
@@ -483,12 +422,6 @@ class HeapAnalyzer constructor(
         }
     )
 
-    when (rootNode.gcRoot) {
-      is StickyClass -> rootNodeReporter.reportNotLeaking("a system class never leaks")
-    }
-
-    leakReporters[lastElementIndex].reportLeaking("RefWatcher was watching this")
-
     var lastNotLeakingElementIndex = 0
     var firstLeakingElementIndex = lastElementIndex
 
@@ -512,7 +445,7 @@ class HeapAnalyzer constructor(
     }
 
     // First and last are always known.
-    for (i in 0 ..lastElementIndex) {
+    for (i in 0..lastElementIndex) {
       val leakStatus = leakStatuses[i]
       if (i < lastNotLeakingElementIndex) {
         val nextNotLeakingName = simpleClassNames[i + 1]
@@ -609,16 +542,7 @@ class HeapAnalyzer constructor(
       is GraphClassRecord -> graphRecord.name
       is GraphInstanceRecord -> graphRecord.className
       is GraphObjectArrayRecord -> graphRecord.arrayClassName
-      is GraphPrimitiveArrayRecord -> when (graphRecord.primitiveType) {
-        BOOLEAN -> "boolean[]"
-        CHAR -> "char[]"
-        FLOAT -> "float[]"
-        DOUBLE -> "double[]"
-        BYTE -> "byte[]"
-        SHORT -> "short[]"
-        INT -> "int[]"
-        LONG -> "long[]"
-      }
+      is GraphPrimitiveArrayRecord -> graphRecord.arrayClassName
     }
   }
 
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/ObjectReporter.kt b/leakcanary-analyzer/src/main/java/leakcanary/ObjectReporter.kt
index 7b81295e..3f00f5c6 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/ObjectReporter.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/ObjectReporter.kt
@@ -3,24 +3,43 @@ package leakcanary
 class ObjectReporter(val objectRecord: GraphObjectRecord) {
 
   private val mutableLabels = mutableListOf<String>()
-  private val mutableLeakNodeStatuses = mutableListOf<LeakNodeStatusAndReason>()
+
+  private val mutableLeakingStatuses = mutableListOf<LeakNodeStatusAndReason>()
+  private val mutableLikelyLeakingStatuses = mutableListOf<LeakNodeStatusAndReason>()
+  private val mutableNotLeakingStatuses = mutableListOf<LeakNodeStatusAndReason>()
 
   val labels: List<String>
     get() = mutableLabels
 
   val leakNodeStatuses: List<LeakNodeStatusAndReason>
-    get() = mutableLeakNodeStatuses
+    get() = mutableLeakingStatuses + mutableLikelyLeakingStatuses + mutableNotLeakingStatuses
+
+  val leakingStatuses: List<LeakNodeStatusAndReason>
+    get() = mutableLeakingStatuses
 
   fun addLabel(label: String) {
     mutableLabels += label
   }
 
+
+  /**
+   * The inspector is almost sure this instance is leaking, but not 100%. This information will
+   * be used for decorating leaktraces, but [HeapAnalyzer] will not look for these instances.
+   */
+  fun reportLikelyLeaking(reason: String) {
+    mutableLikelyLeakingStatuses += LeakNodeStatus.leaking(reason)
+  }
+
+  /**
+   * The inspector is 100% sure this instance is leaking. [HeapAnalyzer] will look for these
+   * instances.
+   */
   fun reportLeaking(reason: String) {
-    mutableLeakNodeStatuses += LeakNodeStatus.leaking(reason)
+    mutableLeakingStatuses += LeakNodeStatus.leaking(reason)
   }
 
   fun reportNotLeaking(reason: String) {
-    mutableLeakNodeStatuses += LeakNodeStatus.notLeaking(reason)
+    mutableNotLeakingStatuses += LeakNodeStatus.notLeaking(reason)
   }
 
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/GcRootRecordListener.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/GcRootRecordListener.kt
new file mode 100644
index 00000000..2c3aacde
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/GcRootRecordListener.kt
@@ -0,0 +1,62 @@
+package leakcanary.internal
+
+import leakcanary.GcRoot
+import leakcanary.GcRoot.JavaFrame
+import leakcanary.GcRoot.JniGlobal
+import leakcanary.GcRoot.JniLocal
+import leakcanary.GcRoot.JniMonitor
+import leakcanary.GcRoot.MonitorUsed
+import leakcanary.GcRoot.NativeStack
+import leakcanary.GcRoot.ReferenceCleanup
+import leakcanary.GcRoot.StickyClass
+import leakcanary.GcRoot.ThreadBlock
+import leakcanary.GcRoot.ThreadObject
+import leakcanary.HprofPushRecordsParser.OnRecordListener
+import leakcanary.Record
+import leakcanary.Record.HeapDumpRecord.GcRootRecord
+import kotlin.reflect.KClass
+
+internal class GcRootRecordListener : OnRecordListener {
+
+  val gcRoots = mutableListOf<GcRoot>()
+
+  override fun recordTypes(): Set<KClass<out Record>> = setOf(GcRootRecord::class)
+
+  override fun onTypeSizesAvailable(typeSizes: Map<Int, Int>) {
+  }
+
+  override fun onRecord(
+    position: Long,
+    record: Record
+  ) {
+    when (record) {
+      is GcRootRecord -> {
+        // TODO Ignoring VmInternal because we've got 150K of it, but is this the right thing
+        // to do? What's VmInternal exactly? History does not go further than
+        // https://android.googlesource.com/platform/dalvik2/+/refs/heads/master/hit/src/com/android/hit/HprofParser.java#77
+        // We should log to figure out what objects VmInternal points to.
+        when (record.gcRoot) {
+          // ThreadObject points to threads, which we need to find the thread that a JavaLocalExclusion
+          // belongs to
+          is ThreadObject,
+          is JniGlobal,
+          is JniLocal,
+          is JavaFrame,
+          is NativeStack,
+          is StickyClass,
+          is ThreadBlock,
+          is MonitorUsed,
+            // TODO What is this and why do we care about it as a root?
+          is ReferenceCleanup,
+          is JniMonitor
+          -> {
+            gcRoots.add(record.gcRoot)
+          }
+        }
+      }
+      else -> {
+        throw IllegalArgumentException("Unexpected record $record")
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
index 9ccacdab..e47af626 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
@@ -8,10 +8,8 @@ internal class KeyedWeakReferenceMirror(
   val key: String,
     // The name field does not exist in pre 1.0 heap dumps.
   val name: String,
-  // 0 in pre 2.0 alpha 3 heap dumps
-  val watchDurationMillis: Long,
-    // The className field does not exist in pre 2.0 heap dumps.
-  val className: String,
+  // null in pre 2.0 alpha 3 heap dumps
+  val watchDurationMillis: Long?,
     // null in pre 2.0 alpha 3 heap dumps, -1 if the instance is not retained.
   val retainedDurationMillis: Long?
 ) {
@@ -33,7 +31,7 @@ internal class KeyedWeakReferenceMirror(
       val keyWeakRefClassName = weakRef.className
       val watchDurationMillis = if (heapDumpUptimeMillis != null)
         heapDumpUptimeMillis - weakRef[keyWeakRefClassName, "watchUptimeMillis"]!!.value.asLong!!
-      else 0L
+      else null
 
       val retainedDurationMillis = if (heapDumpUptimeMillis != null) {
         val retainedUptimeMillis = weakRef[keyWeakRefClassName, "retainedUptimeMillis"]!!.value.asLong!!
@@ -43,14 +41,12 @@ internal class KeyedWeakReferenceMirror(
       val keyString = weakRef[keyWeakRefClassName, "key"]!!.value.readAsJavaString()!!
 
       val name = weakRef[keyWeakRefClassName, "name"]?.value?.readAsJavaString() ?: UNKNOWN_LEGACY
-      val className = weakRef[keyWeakRefClassName, "className"]?.value?.readAsJavaString() ?: UNKNOWN_LEGACY
       return KeyedWeakReferenceMirror(
           watchDurationMillis = watchDurationMillis,
           retainedDurationMillis = retainedDurationMillis,
           referent = weakRef["java.lang.ref.Reference", "referent"]!!.value.actual as ObjectReference,
           key = keyString,
-          name = name,
-          className = className
+          name = name
       )
     }
   }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
index e73d150f..110001cf 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
@@ -18,6 +18,7 @@ package leakcanary.internal
 import leakcanary.AnalyzerProgressListener
 import leakcanary.AnalyzerProgressListener.Step.FINDING_DOMINATORS
 import leakcanary.AnalyzerProgressListener.Step.FINDING_SHORTEST_PATHS
+import leakcanary.CanaryLog
 import leakcanary.Exclusion
 import leakcanary.Exclusion.ExclusionType
 import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
@@ -75,7 +76,7 @@ internal class ShortestPathFinder {
   /** Set of instances to visit */
   private val toVisitMap = LinkedHashMap<Long, Status>()
   private val visitedSet = LongScatterSet()
-  private lateinit var referentMap: Map<Long, KeyedWeakReferenceMirror>
+  private lateinit var leakingInstanceObjectIds: Set<Long>
   private var visitOrder = 0
 
   /**
@@ -92,8 +93,7 @@ internal class ShortestPathFinder {
 
   class Result(
     val leakingNode: LeakNode,
-    val exclusionStatus: Status?,
-    val weakReference: KeyedWeakReferenceMirror
+    val exclusionStatus: Status?
   )
 
   data class Results(
@@ -104,13 +104,14 @@ internal class ShortestPathFinder {
   fun findPaths(
     graph: HprofGraph,
     exclusions: List<Exclusion>,
-    leakingWeakRefs: List<KeyedWeakReferenceMirror>,
+    leakingInstanceObjectIds: Set<Long>,
     gcRootIds: MutableList<GcRoot>,
     computeDominators: Boolean,
     listener: AnalyzerProgressListener
   ): Results {
     listener.onProgressUpdate(FINDING_SHORTEST_PATHS)
     clearState()
+    this.leakingInstanceObjectIds = leakingInstanceObjectIds
 
     val objectClass = graph.indexedClass("java.lang.Object")
     sizeOfObjectInstances = if (objectClass != null) {
@@ -165,9 +166,6 @@ internal class ShortestPathFinder {
           }
         }
 
-    // Referent object id to weak ref mirror
-    referentMap = leakingWeakRefs.associateBy { it.referent.value }
-
     enqueueGcRoots(graph, gcRootIds, threadNames, computeDominators)
 
     var lowestPriority = ALWAYS_REACHABLE
@@ -186,12 +184,11 @@ internal class ShortestPathFinder {
         continue
       }
 
-      val weakReference = referentMap[node.instance]
-      if (weakReference != null) {
+      if (node.instance in leakingInstanceObjectIds) {
         val exclusionPriority = if (lowestPriority == ALWAYS_REACHABLE) null else lowestPriority
-        results.add(Result(node, exclusionPriority, weakReference))
+        results.add(Result(node, exclusionPriority))
         // Found all refs, stop searching (unless computing retained size which stops on weak reachables)
-        if (results.size == leakingWeakRefs.size) {
+        if (results.size == leakingInstanceObjectIds.size) {
           if (computeDominators && lowestPriority < WEAKLY_REACHABLE) {
             listener.onProgressUpdate(FINDING_DOMINATORS)
           } else {
@@ -200,7 +197,7 @@ internal class ShortestPathFinder {
         }
       }
 
-      if (results.size == leakingWeakRefs.size && computeDominators && lowestPriority >= WEAKLY_REACHABLE) {
+      if (results.size == leakingInstanceObjectIds.size && computeDominators && lowestPriority >= WEAKLY_REACHABLE) {
         break@visitingQueue
       }
 
@@ -234,8 +231,8 @@ internal class ShortestPathFinder {
     toVisitMap.clear()
     visitedSet.release()
     visitOrder = 0
-    referentMap = emptyMap()
     dominatedInstances = LongLongScatterMap()
+    leakingInstanceObjectIds = emptySet()
     sizeOfObjectInstances = 0
   }
 
@@ -304,7 +301,7 @@ internal class ShortestPathFinder {
           graphObject.arrayClassName
         }
         is GraphPrimitiveArrayRecord -> {
-          graphObject.primitiveType.name
+          graphObject.arrayClassName
         }
       }
     }
@@ -405,7 +402,15 @@ internal class ShortestPathFinder {
     parentNode: LeakNode,
     computeRetainedHeapSize: Boolean
   ) {
-    record.elementIds.filter { it != 0L }
+    record.elementIds.filter {objectId ->
+      objectId != 0L && graph.objectIdExists(objectId).apply {
+        if (!this) {
+          // dalvik.system.PathClassLoader.runtimeInternalObjects references objects which don't
+          // otherwise exist in the heap dump.
+          CanaryLog.d("Invalid Hprof? Found unknown object id $objectId")
+        }
+      }
+    }
         .forEachIndexed { index, elementId ->
           if (computeRetainedHeapSize) {
             updateDominatorWithSkips(graph, parentNode.instance, elementId)
@@ -441,7 +446,7 @@ internal class ShortestPathFinder {
       return
     }
 
-    val isLeakingInstance = referentMap[node.instance] != null
+    val isLeakingInstance = node.instance in leakingInstanceObjectIds
 
     if (!isLeakingInstance) {
       val skip = when (val graphObject = graph.indexedObject(node.instance)) {
@@ -521,7 +526,7 @@ internal class ShortestPathFinder {
     }
     val parentDominator = dominatedInstances[parent]
 
-    val parentIsRetainedInstance = referentMap.containsKey(parent)
+    val parentIsRetainedInstance = parent in leakingInstanceObjectIds
 
     val nextDominator = if (parentIsRetainedInstance) parent else parentDominator
 
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt
index f0df046b..926958fa 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt
@@ -9,8 +9,6 @@ import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.Exclusion.Status.WONT_FIX_LEAK
 import leakcanary.HeapAnalysisSuccess
 import leakcanary.KeyedWeakReference
-import leakcanary.LeakingInstance
-import leakcanary.NoPathToInstance
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
@@ -37,7 +35,7 @@ class ExclusionTest {
         exclusions = listOf(Exclusion(StaticFieldExclusion("GcRoot", "shortestPath")))
     )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.leakTrace.elements).hasSize(3)
     assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
     assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("longestPath")
@@ -56,7 +54,7 @@ class ExclusionTest {
         )
     )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.exclusionStatus).isEqualTo(WONT_FIX_LEAK)
     assertThat(leak.leakTrace.elements).hasSize(2)
     assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
@@ -73,7 +71,7 @@ class ExclusionTest {
             Exclusion(InstanceFieldExclusion("HasLeaking", "leaking"), status = NEVER_REACHABLE)
         )
     )
-    assertThat(analysis.retainedInstances[0]).isInstanceOf(NoPathToInstance::class.java)
+    assertThat(analysis.leakingInstances).isEmpty()
   }
 
   @Test fun excludedThread() {
@@ -83,7 +81,7 @@ class ExclusionTest {
         exclusions = listOf(Exclusion(JavaLocalExclusion("kroutine"), status = WONT_FIX_LEAK))
     )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.exclusionStatus).isEqualTo(WONT_FIX_LEAK)
   }
 
@@ -91,7 +89,7 @@ class ExclusionTest {
     hprofFile.dump {
       "GcRoot" clazz {
         staticField["ref"] =
-          keyedWeakReference(className = "Leaking", referentInstanceId = "Leaking" instance {})
+          keyedWeakReference(referentInstanceId = "Leaking" instance {})
       }
     }
 
@@ -104,7 +102,7 @@ class ExclusionTest {
         )
     )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.exclusionStatus).isEqualTo(WEAKLY_REACHABLE)
   }
 
@@ -112,7 +110,7 @@ class ExclusionTest {
     hprofFile.dump {
       "GcRoot" clazz {
         staticField["ref"] =
-          keyedWeakReference(className = "Leaking", referentInstanceId = "Leaking" instance {})
+          keyedWeakReference(referentInstanceId = "Leaking" instance {})
       }
     }
 
@@ -127,7 +125,7 @@ class ExclusionTest {
         )
         )
     )
-    assertThat(analysis.retainedInstances[0]).isInstanceOf(NoPathToInstance::class.java)
+    assertThat(analysis.leakingInstances).isEmpty()
   }
 
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
index 4665e516..63b75b57 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
@@ -2,12 +2,10 @@ package leakcanary.internal
 
 import leakcanary.GcRoot.ThreadObject
 import leakcanary.HeapAnalysis
-import leakcanary.HeapAnalysisFailure
 import leakcanary.HeapAnalysisSuccess
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.LeakTraceElement.Type.LOCAL
 import leakcanary.LeakingInstance
-import leakcanary.NoPathToInstance
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
@@ -30,14 +28,14 @@ class HeapAnalyzerTest {
     hprofFile.writeSinglePathToInstance()
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    assertThat(analysis.retainedInstances[0]).isInstanceOf(LeakingInstance::class.java)
+    assertThat(analysis.leakingInstances[0]).isInstanceOf(LeakingInstance::class.java)
   }
 
   @Test fun pathToString() {
     hprofFile.writeSinglePathToString()
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
 
     assertThat(leak.instanceClassName).isEqualTo("java.lang.String")
   }
@@ -45,7 +43,7 @@ class HeapAnalyzerTest {
   @Test fun pathToCharArray() {
     hprofFile.writeSinglePathsToCharArrays(listOf("Hello"))
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.instanceClassName).isEqualTo("char[]")
   }
 
@@ -61,7 +59,7 @@ class HeapAnalyzerTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.leakTrace.elements).hasSize(2)
     assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
     assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("shortestPath")
@@ -73,23 +71,22 @@ class HeapAnalyzerTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    assertThat(analysis.retainedInstances[0]).isInstanceOf(NoPathToInstance::class.java)
+    assertThat(analysis.leakingInstances).isEmpty()
   }
 
   @Test fun weakRefCleared() {
     hprofFile.writeWeakReferenceCleared()
 
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisFailure>()
-    assertThat(analysis.exception.cause).isInstanceOf(IllegalStateException::class.java)
-        .hasMessage("No retained instances found in heap dump")
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+    assertThat(analysis.leakingInstances).isEmpty()
   }
 
   @Test fun failsNoRetainedKeys() {
     hprofFile.writeMultipleActivityLeaks(0)
 
-    val analysis = hprofFile.checkForLeaks<HeapAnalysis>()
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    assertThat(analysis).isInstanceOf(HeapAnalysisFailure::class.java)
+    assertThat(analysis.leakingInstances).isEmpty()
   }
 
   @Test fun findMultipleLeaks() {
@@ -97,7 +94,7 @@ class HeapAnalyzerTest {
 
     val leaks = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    assertThat(leaks.retainedInstances).hasSize(5)
+    assertThat(leaks.leakingInstances).hasSize(5)
         .hasOnlyElementsOfType(LeakingInstance::class.java)
   }
 
@@ -106,7 +103,7 @@ class HeapAnalyzerTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.leakTrace.elements).hasSize(2)
     assertThat(leak.leakTrace.elements[0].className).isEqualTo("MyThread")
     assertThat(leak.leakTrace.elements[0].reference!!.type).isEqualTo(LOCAL)
@@ -132,7 +129,7 @@ class HeapAnalyzerTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.leakTrace.elements).hasSize(2)
     assertThat(leak.leakTrace.elements[0].className).isEqualTo("MyThread")
     assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("leaking")
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt
index 9d61a1e4..7f6fac38 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt
@@ -10,14 +10,14 @@ import java.io.File
 fun File.writeWeakReferenceCleared() {
   HprofWriter.open(this)
       .helper {
-        keyedWeakReference("Leaking", ObjectReference(0))
+        keyedWeakReference(ObjectReference(0))
       }
 }
 
 fun File.writeNoPathToInstance() {
   HprofWriter.open(this)
       .helper {
-        keyedWeakReference("Leaking", instance(clazz("Leaking")))
+        keyedWeakReference(instance(clazz("Leaking")))
       }
 }
 
@@ -25,7 +25,7 @@ fun File.writeSinglePathToInstance() {
   HprofWriter.open(this)
       .helper {
         val leaking = instance(clazz("Leaking"))
-        keyedWeakReference("Leaking", leaking)
+        keyedWeakReference(leaking)
         clazz(
             "GcRoot", staticFields = listOf(
             "shortestPath" to leaking
@@ -38,7 +38,7 @@ fun File.writeSinglePathToString(value: String = "Hi") {
   HprofWriter.open(this)
       .helper {
         val leaking = string(value)
-        keyedWeakReference("java.lang.String", leaking)
+        keyedWeakReference(leaking)
         clazz(
             "GcRoot", staticFields = listOf(
             "shortestPath" to leaking
@@ -53,7 +53,7 @@ fun File.writeSinglePathsToCharArrays(values: List<String>) {
         val arrays = mutableListOf<Long>()
         values.forEach {
           val leaking = it.charArrayDump
-          keyedWeakReference("char[]", leaking)
+          keyedWeakReference(leaking)
           arrays.add(leaking.value)
         }
         clazz(
@@ -72,7 +72,7 @@ fun File.writeTwoPathsToInstance() {
   HprofWriter.open(this)
       .helper {
         val leaking = instance(clazz("Leaking"))
-        keyedWeakReference("Leaking", leaking)
+        keyedWeakReference(leaking)
         val hasLeaking = instance(
             clazz("HasLeaking", fields = listOf("leaking" to ObjectReference::class)),
             fields = listOf(leaking)
@@ -114,7 +114,7 @@ fun File.writeMultipleActivityLeaks(leakCount: Int) {
             )
         )
         destroyedActivities.forEach { instanceId ->
-          keyedWeakReference("com.example.ExampleActivity", instanceId)
+          keyedWeakReference(instanceId)
         }
       }
 }
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
index d4e0b835..90f77c3b 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
@@ -27,6 +27,7 @@ import okio.Buffer
 import java.io.Closeable
 import java.io.File
 import java.util.UUID
+import kotlin.random.Random
 import kotlin.reflect.KClass
 
 class HprofWriterHelper constructor(
@@ -37,6 +38,13 @@ class HprofWriterHelper constructor(
   private val id: Long
     get() = ++lastId
 
+  private val weakRefKeyRandom = Random(42)
+
+  // Sequence identical for every test run
+  private val weakRefKey: String
+    get() =
+      UUID(weakRefKeyRandom.nextLong(), weakRefKeyRandom.nextLong()).toString()
+
   private val typeSizes = mapOf(
       // object
       HprofReader.OBJECT_TYPE to writer.idSize,
@@ -61,7 +69,7 @@ class HprofWriterHelper constructor(
   )
   )
 
-  private val referenceClassId  = clazz(
+  private val referenceClassId = clazz(
       className = "java.lang.ref.Reference",
       fields = listOf(
           "referent" to ObjectReference::class
@@ -75,11 +83,10 @@ class HprofWriterHelper constructor(
   private val keyedWeakReferenceClassId = clazz(
       superClassId = weakReferenceClassId,
       className = "leakcanary.KeyedWeakReference",
-      staticFields = listOf("heapDumpUptimeMillis" to LongValue(Long.MAX_VALUE)),
+      staticFields = listOf("heapDumpUptimeMillis" to LongValue(30000)),
       fields = listOf(
           "key" to ObjectReference::class,
           "name" to ObjectReference::class,
-          "className" to ObjectReference::class,
           "watchUptimeMillis" to LongValue::class,
           "retainedUptimeMillis" to LongValue::class
       )
@@ -157,18 +164,16 @@ class HprofWriterHelper constructor(
   }
 
   fun keyedWeakReference(
-    className: String,
     referentInstanceId: ObjectReference
   ): ObjectReference {
-    val referenceKey = string(UUID.randomUUID().toString())
+    val referenceKey = string(weakRefKey)
     return instance(
         classId = keyedWeakReferenceClassId,
         fields = listOf(
             referenceKey,
             string(""),
-            string(className),
-            LongValue(System.currentTimeMillis()),
-            LongValue(System.currentTimeMillis()),
+            LongValue(5000),
+            LongValue(20000),
             ObjectReference(referentInstanceId.value)
         )
     )
@@ -205,7 +210,7 @@ class HprofWriterHelper constructor(
 
   infix fun String.watchedInstance(block: InstanceAndClassDefinition.() -> Unit): ObjectReference {
     val instance = this.instance(block)
-    keyedWeakReference("DummyClassName", instance)
+    keyedWeakReference(instance)
     return instance
   }
 
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
index b631ce6c..7a946696 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
@@ -3,10 +3,9 @@ package leakcanary.internal
 import leakcanary.AndroidObjectInspectors
 import leakcanary.HeapAnalysisSuccess
 import leakcanary.HprofGraph
-import leakcanary.LeakingInstance
 import leakcanary.ObjectInspector
 import leakcanary.ObjectReporter
-import leakcanary.asInstance
+import leakcanary.whenInstanceOf
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
@@ -33,7 +32,7 @@ class LabelerTest {
         graph: HprofGraph,
         reporter: ObjectReporter
       ) {
-        reporter.asInstance("java.lang.String")  { instance ->
+        reporter.whenInstanceOf("java.lang.String")  { instance ->
           addLabel("Hello ${instance.readAsJavaString()}")
         }
       }
@@ -41,9 +40,9 @@ class LabelerTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(objectInspectors = listOf(labeler))
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
 
-    assertThat(leak.leakTrace.elements.last().labels).isEqualTo(listOf("Hello World"))
+    assertThat(leak.leakTrace.elements.last().labels).contains("Hello World")
   }
 
   @Test fun threadNameLabel() {
@@ -52,7 +51,7 @@ class LabelerTest {
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(objectInspectors = listOf(AndroidObjectInspectors.THREAD))
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
 
     assertThat(leak.leakTrace.elements.first().labels).contains("Thread name: 'kroutine'")
   }
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
index cbac3b1a..db291474 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
@@ -1,5 +1,6 @@
 package leakcanary.internal
 
+import leakcanary.AndroidObjectInspectors
 import leakcanary.GraphObjectRecord.GraphClassRecord
 import leakcanary.GraphObjectRecord.GraphInstanceRecord
 import leakcanary.HeapAnalysisSuccess
@@ -7,9 +8,8 @@ import leakcanary.HprofGraph
 import leakcanary.LeakNodeStatus.LEAKING
 import leakcanary.LeakNodeStatus.NOT_LEAKING
 import leakcanary.LeakNodeStatus.UNKNOWN
-import leakcanary.ObjectReporter
-import leakcanary.LeakingInstance
 import leakcanary.ObjectInspector
+import leakcanary.ObjectReporter
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
@@ -28,12 +28,14 @@ class LeakStatusTest {
     hprofFile = testFolder.newFile("temp.hprof")
   }
 
-  @Test fun gcRootsNotLeaking() {
+  @Test fun gcRootClassNotLeaking() {
     hprofFile.writeSinglePathToInstance()
 
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(AndroidObjectInspectors.CLASS)
+    )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
 
     assertThat(leak.leakTrace.elements.first().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
   }
@@ -43,7 +45,7 @@ class LeakStatusTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
 
     assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(LEAKING)
   }
@@ -59,7 +61,7 @@ class LeakStatusTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
 
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(UNKNOWN)
   }
@@ -74,10 +76,10 @@ class LeakStatusTest {
     }
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-        objectInspectors = listOf(notLeaking("Class1"))
+        objectInspectors = listOf(notLeakingInstance("Class1"))
     )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
   }
 
@@ -92,10 +94,10 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          objectInspectors = listOf(leaking("Class1"))
+          objectInspectors = listOf(leakingInstance("Class1"))
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(LEAKING)
   }
 
@@ -110,10 +112,10 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          objectInspectors = listOf(leaking("Class1"))
+          objectInspectors = listOf(leakingInstance("Class1"))
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(LEAKING)
   }
 
@@ -132,10 +134,10 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          objectInspectors = listOf(notLeaking("Class3"))
+          objectInspectors = listOf(notLeakingInstance("Class3"))
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
   }
 
@@ -154,50 +156,12 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          objectInspectors = listOf(leaking("Class1"))
+          objectInspectors = listOf(leakingInstance("Class1"))
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.leakTrace.elements[3].leakStatusAndReason.status).isEqualTo(LEAKING)
-  }
-
-  @Test fun notLeakingWinsConflicts() {
-    hprofFile.dump {
-      "GcRoot" clazz {
-        staticField["staticField1"] = "Class1" instance {
-          field["field1"] = "Class2" instance {
-            field["field2"] = "Class3" instance {
-              field["field3"] = "Leaking" watchedInstance {}
-            }
-          }
-        }
-      }
-    }
-
-    val analysis =
-      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          objectInspectors = listOf(
-              notLeaking("Class3"), leaking("Class1")
-          )
-      )
-
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.leakTrace.elements[0].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements[0].leakStatusAndReason.reason).isEqualTo(
-        "Class1â†“ is not leaking and a system class never leaks"
-    )
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.reason).isEqualTo(
-        "Class2â†“ is not leaking. Conflicts with Class1 is leaking"
-    )
-    assertThat(leak.leakTrace.elements[2].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements[2].leakStatusAndReason.reason).isEqualTo(
-        "Class3â†“ is not leaking"
-    )
-    assertThat(leak.leakTrace.elements[3].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements[3].leakStatusAndReason.reason).isEqualTo(
-        "Class3 is not leaking"
-    )
+    val leak = analysis.leakingInstances[0]
+    assertThat(leak.leakTrace.elements).hasSize(2)
+    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(LEAKING)
   }
 
   @Test fun middleUnknown() {
@@ -216,43 +180,45 @@ class LeakStatusTest {
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
           objectInspectors = listOf(
-              notLeaking("Class1"), leaking("Class3")
+              notLeakingInstance("Class1"), leakingInstance("Class3")
           )
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.leakTrace.elements[2].leakStatusAndReason.status).isEqualTo(UNKNOWN)
   }
 
-  @Test fun gcRootsNotLeakingConflictingWithInspector() {
+  @Test fun gcRootClassNotLeakingConflictingWithInspector() {
     hprofFile.writeSinglePathToInstance()
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          objectInspectors = listOf(leaking("GcRoot"))
+          objectInspectors = listOf(leakingClass("GcRoot"), AndroidObjectInspectors.CLASS)
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
 
     assertThat(leak.leakTrace.elements.first().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
     assertThat(leak.leakTrace.elements.first().leakStatusAndReason.reason).isEqualTo(
-        "a system class never leaks. Conflicts with GcRoot is leaking"
+        "a class is never leaking. Conflicts with GcRoot is leaking"
     )
   }
 
-  @Test fun gcRootsNotLeakingAgreesWithInspector() {
+  @Test fun gcRootClassNotLeakingAgreesWithInspector() {
     hprofFile.writeSinglePathToInstance()
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          objectInspectors = listOf(notLeaking("GcRoot"))
+          objectInspectors = listOf(notLeakingClass("GcRoot"), AndroidObjectInspectors.CLASS)
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    println(analysis)
+
+    val leak = analysis.leakingInstances[0]
 
     assertThat(leak.leakTrace.elements.first().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
     assertThat(leak.leakTrace.elements.first().leakStatusAndReason.reason).isEqualTo(
-        "GcRoot is not leaking and a system class never leaks"
+        "GcRoot is not leaking and a class is never leaking"
     )
   }
 
@@ -260,10 +226,10 @@ class LeakStatusTest {
     hprofFile.writeSinglePathToInstance()
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          objectInspectors = listOf(notLeaking("Leaking"))
+          objectInspectors = listOf(notLeakingInstance("Leaking"))
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
     assertThat(leak.leakTrace.elements.last().leakStatusAndReason.reason).isEqualTo(
         "Leaking is not leaking. Conflicts with RefWatcher was watching this"
@@ -274,10 +240,10 @@ class LeakStatusTest {
     hprofFile.writeSinglePathToInstance()
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          objectInspectors = listOf(leaking("Leaking"))
+          objectInspectors = listOf(leakingInstance("Leaking"))
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(LEAKING)
     assertThat(leak.leakTrace.elements.last().leakStatusAndReason.reason).isEqualTo(
         "Leaking is leaking and RefWatcher was watching this"
@@ -296,11 +262,11 @@ class LeakStatusTest {
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
           objectInspectors = listOf(
-              notLeaking("Class1"), leaking("Class1")
+              notLeakingInstance("Class1"), leakingInstance("Class1")
           )
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.reason).isEqualTo(
         "Class1 is not leaking. Conflicts with Class1 is leaking"
@@ -319,11 +285,11 @@ class LeakStatusTest {
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
           objectInspectors = listOf(
-              notLeaking("Class1"), notLeaking("Class1")
+              notLeakingInstance("Class1"), notLeakingInstance("Class1")
           )
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.reason).isEqualTo(
         "Class1 is not leaking and Class1 is not leaking"
@@ -341,10 +307,10 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          objectInspectors = listOf(leaking("Class1"), leaking("Class1"))
+          objectInspectors = listOf(leakingInstance("Class1"), leakingInstance("Class1"))
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(LEAKING)
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.reason).isEqualTo(
         "Class1 is leaking and Class1 is leaking"
@@ -367,11 +333,11 @@ class LeakStatusTest {
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
           objectInspectors = listOf(
-              notLeaking("Class1"), leaking("Class3")
+              notLeakingInstance("Class1"), leakingInstance("Class3")
           )
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.leakTrace.elementMayBeLeakCause(0)).isFalse()
     assertThat(leak.leakTrace.elementMayBeLeakCause(1)).isTrue()
     assertThat(leak.leakTrace.elementMayBeLeakCause(2)).isTrue()
@@ -463,7 +429,7 @@ class LeakStatusTest {
     assertThat(hash1).isEqualTo(hash2)
   }
 
-  private fun notLeaking(className: String): ObjectInspector {
+  private fun notLeakingInstance(className: String): ObjectInspector {
     return object : ObjectInspector {
       override fun inspect(
         graph: HprofGraph,
@@ -472,14 +438,12 @@ class LeakStatusTest {
         val record = reporter.objectRecord
         if (record is GraphInstanceRecord && record.className == className) {
           reporter.reportNotLeaking("$className is not leaking")
-        } else if (record is GraphClassRecord && record.name == className) {
-          reporter.reportNotLeaking("$className is not leaking")
         }
       }
     }
   }
 
-  private fun leaking(className: String): ObjectInspector {
+  private fun leakingInstance(className: String): ObjectInspector {
     return object : ObjectInspector {
       override fun inspect(
         graph: HprofGraph,
@@ -488,7 +452,33 @@ class LeakStatusTest {
         val record = reporter.objectRecord
         if (record is GraphInstanceRecord && record.className == className) {
           reporter.reportLeaking("$className is leaking")
-        } else if (record is GraphClassRecord && record.name == className) {
+        }
+      }
+    }
+  }
+
+  private fun notLeakingClass(className: String): ObjectInspector {
+    return object : ObjectInspector {
+      override fun inspect(
+        graph: HprofGraph,
+        reporter: ObjectReporter
+      ) {
+        val record = reporter.objectRecord
+        if (record is GraphClassRecord && record.name == className) {
+          reporter.reportNotLeaking("$className is not leaking")
+        }
+      }
+    }
+  }
+
+  private fun leakingClass(className: String): ObjectInspector {
+    return object : ObjectInspector {
+      override fun inspect(
+        graph: HprofGraph,
+        reporter: ObjectReporter
+      ) {
+        val record = reporter.objectRecord
+        if (record is GraphClassRecord && record.name == className) {
           reporter.reportLeaking("$className is leaking")
         }
       }
@@ -501,9 +491,12 @@ class LeakStatusTest {
   ): String {
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          objectInspectors = listOf(notLeaking(notLeaking), leaking(leaking))
+          objectInspectors = listOf(notLeakingInstance(notLeaking), leakingInstance(leaking))
       )
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    require(analysis.leakingInstances.size == 1) {
+      "Expecting 1 retained instance in ${analysis.leakingInstances}"
+    }
+    val leak = analysis.leakingInstances[0]
     return leak.groupHash
   }
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
index c0d5eb65..8de8eeec 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
@@ -4,10 +4,9 @@ import leakcanary.Exclusion
 import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
 import leakcanary.HeapAnalysisSuccess
 import leakcanary.HprofGraph
-import leakcanary.ObjectReporter
-import leakcanary.LeakingInstance
 import leakcanary.ObjectInspector
-import leakcanary.asInstance
+import leakcanary.ObjectReporter
+import leakcanary.whenInstanceOf
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
@@ -38,12 +37,15 @@ class LeakTraceRendererTest {
     analysis renders """
     â”¬
     â”œâ”€ GcRoot
-    â”‚    Leaking: NO (a system class never leaks)
+    â”‚    Leaking: UNKNOWN
     â”‚    GC Root: System class
     â”‚    â†“ static GcRoot.leak
     â”‚                    ~~~~
     â•°â†’ Leaking
     â€‹     Leaking: YES (RefWatcher was watching this)
+    â€‹     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    â€‹     watchDurationMillis = 25000
+    â€‹     retainedDurationMillis = 10000
     """
   }
 
@@ -65,7 +67,7 @@ class LeakTraceRendererTest {
               graph: HprofGraph,
               reporter: ObjectReporter
             ) {
-              reporter.asInstance("ClassB") {
+              reporter.whenInstanceOf("ClassB") {
                 reportLeaking("because reasons")
               }
             }
@@ -75,7 +77,7 @@ class LeakTraceRendererTest {
     analysis renders """
     â”¬
     â”œâ”€ GcRoot
-    â”‚    Leaking: NO (a system class never leaks)
+    â”‚    Leaking: UNKNOWN
     â”‚    GC Root: System class
     â”‚    â†“ static GcRoot.instanceA
     â”‚                    ~~~~~~~~~
@@ -83,11 +85,8 @@ class LeakTraceRendererTest {
     â”‚    Leaking: UNKNOWN
     â”‚    â†“ ClassA.instanceB
     â”‚             ~~~~~~~~~
-    â”œâ”€ ClassB
-    â”‚    Leaking: YES (because reasons)
-    â”‚    â†“ ClassB.leak
-    â•°â†’ Leaking
-    â€‹     Leaking: YES (ClassBâ†‘ is leaking and RefWatcher was watching this)
+    â•°â†’ ClassB
+    â€‹     Leaking: YES (because reasons)
     """
   }
 
@@ -113,7 +112,7 @@ class LeakTraceRendererTest {
     analysis renders """
     â”¬
     â”œâ”€ GcRoot
-    â”‚    Leaking: NO (a system class never leaks)
+    â”‚    Leaking: UNKNOWN
     â”‚    Â¯\_(ãƒ„)_/Â¯
     â”‚    GC Root: System class
     â”‚    â†“ static GcRoot.leak
@@ -121,6 +120,9 @@ class LeakTraceRendererTest {
     â•°â†’ Leaking
     â€‹     Leaking: YES (RefWatcher was watching this)
     â€‹     Â¯\_(ãƒ„)_/Â¯
+    â€‹     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    â€‹     watchDurationMillis = 25000
+    â€‹     retainedDurationMillis = 10000
     """
   }
 
@@ -141,7 +143,7 @@ class LeakTraceRendererTest {
     analysis renders """
     â”¬
     â”œâ”€ GcRoot
-    â”‚    Leaking: NO (a system class never leaks)
+    â”‚    Leaking: UNKNOWN
     â”‚    GC Root: System class
     â”‚    â†“ static GcRoot.instanceA
     â”‚                    ~~~~~~~~~
@@ -152,6 +154,9 @@ class LeakTraceRendererTest {
     â”‚             ~~~~
     â•°â†’ Leaking
     â€‹     Leaking: YES (RefWatcher was watching this)
+    â€‹     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    â€‹     watchDurationMillis = 25000
+    â€‹     retainedDurationMillis = 10000
     """
   }
 
@@ -168,7 +173,7 @@ class LeakTraceRendererTest {
     analysis renders """
     â”¬
     â”œâ”€ GcRoot
-    â”‚    Leaking: NO (a system class never leaks)
+    â”‚    Leaking: UNKNOWN
     â”‚    GC Root: System class
     â”‚    â†“ static GcRoot.array
     â”‚                    ~~~~~
@@ -178,6 +183,9 @@ class LeakTraceRendererTest {
     â”‚                     ~~~
     â•°â†’ Leaking
     â€‹     Leaking: YES (RefWatcher was watching this)
+    â€‹     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    â€‹     watchDurationMillis = 25000
+    â€‹     retainedDurationMillis = 10000
     """
   }
 
@@ -196,11 +204,14 @@ class LeakTraceRendererTest {
     â”‚                      ~~~~~~~~~~~~
     â•°â†’ Leaking
     â€‹     Leaking: YES (RefWatcher was watching this)
+    â€‹     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    â€‹     watchDurationMillis = 25000
+    â€‹     retainedDurationMillis = 10000
     """
   }
 
   private infix fun HeapAnalysisSuccess.renders(expectedString: String) {
-    val leak = retainedInstances[0] as LeakingInstance
+    val leak = leakingInstances[0]
     assertThat(leak.leakTrace.renderToString()).isEqualTo(
         expectedString.trimIndent()
     )
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
index 5e1c8a5d..c555300b 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
@@ -5,7 +5,6 @@ import leakcanary.AndroidObjectInspectors
 import leakcanary.HeapAnalysis
 import leakcanary.HeapAnalysisFailure
 import leakcanary.HeapAnalysisSuccess
-import leakcanary.LeakingInstance
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Test
 import java.io.File
@@ -15,9 +14,9 @@ class LegacyHprofTest {
   @Test fun preM() {
     val analysis = analyzeHprof("leak_asynctask_pre_m.hprof")
 
-    assertThat(analysis.retainedInstances).hasSize(2)
-    val leak1 = analysis.retainedInstances[0] as LeakingInstance
-    val leak2 = analysis.retainedInstances[1] as LeakingInstance
+    assertThat(analysis.leakingInstances).hasSize(2)
+    val leak1 = analysis.leakingInstances[0]
+    val leak2 = analysis.leakingInstances[1]
     assertThat(leak1.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
     assertThat(leak2.instanceClassName).isEqualTo("android.graphics.Bitmap")
   }
@@ -25,24 +24,24 @@ class LegacyHprofTest {
   @Test fun androidM() {
     val analysis = analyzeHprof("leak_asynctask_m.hprof")
 
-    assertThat(analysis.retainedInstances).hasSize(1)
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(analysis.leakingInstances).hasSize(1)
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
   }
 
   @Test fun androidO() {
     val analysis = analyzeHprof("leak_asynctask_o.hprof")
 
-    assertThat(analysis.retainedInstances).hasSize(1)
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(analysis.leakingInstances).hasSize(1)
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
   }
 
   @Test fun gcRootInNonPrimaryHeap() {
     val analysis = analyzeHprof("gc_root_in_non_primary_heap.hprof")
 
-    assertThat(analysis.retainedInstances).hasSize(1)
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(analysis.leakingInstances).hasSize(1)
+    val leak = analysis.leakingInstances[0]
     assertThat(leak.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
   }
 
@@ -56,9 +55,7 @@ class LegacyHprofTest {
         objectInspectors = AndroidObjectInspectors.defaultInspectors(),
         exclusions = AndroidKnownReference.mapToExclusions(AndroidKnownReference.appDefaults)
     )
-    if (analysis is HeapAnalysisFailure) {
-      print(analysis)
-    }
+    print(analysis)
     return analysis as HeapAnalysisSuccess
   }
 
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt
index 78197952..a503489f 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt
@@ -230,20 +230,13 @@ class RetainedSizeTest {
     }
 
     val retainedInstances = retainedInstances()
-    require(retainedInstances.size == 3)
+    require(retainedInstances.size == 1)
 
-    retainedInstances.forEach { instance ->
-      when (instance.instanceClassName) {
-        "GrandParentLeaking" -> {
-          // 4 bytes per ref * 2 + short + int + long
-          assertThat(instance.retainedHeapSize).isEqualTo(22)
-        }
-        "ParentLeaking", "ChildLeaking" -> {
-          assertThat(instance.retainedHeapSize).isEqualTo(0)
-        }
-        else -> throw IllegalStateException("Unexpected ${instance.instanceClassName}")
-      }
-    }
+    val instance = retainedInstances[0]
+
+    assertThat(instance.instanceClassName).isEqualTo("GrandParentLeaking")
+    // 4 bytes per ref * 2 + short + int + long
+    assertThat(instance.retainedHeapSize).isEqualTo(22)
   }
 
   @Test fun crossDominatedIsNotDominated() {
@@ -315,7 +308,7 @@ class RetainedSizeTest {
     val analysis = hprofFile.checkForLeaks<HeapAnalysis>(computeRetainedHeapSize = true)
     println(analysis.toString())
     analysis as HeapAnalysisSuccess
-    return analysis.retainedInstances.map { it as LeakingInstance }
+    return analysis.leakingInstances.map { it }
   }
 
   private fun firstRetainedSize(): Int {
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
index 210dcc19..03f35c28 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
@@ -1,6 +1,7 @@
 package leakcanary.internal
 
 import leakcanary.AnalyzerProgressListener
+import leakcanary.AndroidObjectInspectors
 import leakcanary.Exclusion
 import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
 import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
@@ -22,9 +23,14 @@ fun <T : HeapAnalysis> File.checkForLeaks(
   computeRetainedHeapSize: Boolean = false,
   exclusions: List<Exclusion> = defaultExclusionsFactory
 ): T {
+  val inspectors = if (AndroidObjectInspectors.KEYED_WEAK_REFERENCE !in objectInspectors) {
+    objectInspectors + AndroidObjectInspectors.KEYED_WEAK_REFERENCE
+  } else {
+    objectInspectors
+  }
   val heapAnalyzer = HeapAnalyzer(AnalyzerProgressListener.NONE)
   val result = heapAnalyzer.checkForLeaks(
-      this, exclusions, computeRetainedHeapSize, objectInspectors
+      this, exclusions, computeRetainedHeapSize, inspectors
   )
   if (result is HeapAnalysisFailure) {
     println(result)
diff --git a/leakcanary-android-core/build.gradle b/leakcanary-android-core/build.gradle
index 89d39306..a854cfee 100644
--- a/leakcanary-android-core/build.gradle
+++ b/leakcanary-android-core/build.gradle
@@ -4,9 +4,8 @@ apply plugin: 'kotlin-android'
 dependencies {
   api project(':leakcanary-analyzer')
   api project(':leakcanary-leaksentry')
+  api project(':leakcanary-fragments-androidx')
 
-  implementation deps.androidx.annotation
-  implementation deps.androidx.core
   implementation deps.kotlin.stdlib
 
   testImplementation deps.junit
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
index f4f01046..e07e0601 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -60,8 +60,15 @@ object LeakCanary {
      * WRITE_EXTERNAL_STORAGE permission is not granted and [requestWriteExternalStoragePermission]
      * is true, then LeakCanary will display a notification to ask for that permission.
      */
-    val requestWriteExternalStoragePermission: Boolean = false
+    val requestWriteExternalStoragePermission: Boolean = false,
 
+    /**
+     * When true, [objectInspectors] are used to find leaks instead of only checking instances
+     * tracked by [KeyedWeakReference]. This leads to finding more leaks and shorter leak traces.
+     * However this also means the same leaking instances will be found in every heap dump for a
+     * given process life.
+     */
+    val useExperimentalLeakFinders: Boolean = false
   )
 
   @Volatile
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
index 06c6eec8..6da53dd2 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
@@ -16,6 +16,7 @@
 package leakcanary.internal
 
 import android.content.Context
+import android.text.Html
 import android.text.SpannableStringBuilder
 import android.text.Spanned
 import android.text.format.DateUtils
@@ -23,9 +24,6 @@ import android.view.View
 import android.view.ViewGroup
 import android.widget.BaseAdapter
 import android.widget.TextView
-import androidx.annotation.ColorRes
-import androidx.core.content.ContextCompat
-import androidx.core.text.HtmlCompat
 import com.squareup.leakcanary.core.R
 import leakcanary.LeakNodeStatus.LEAKING
 import leakcanary.LeakNodeStatus.NOT_LEAKING
@@ -50,11 +48,13 @@ import leakcanary.internal.MoreDetailsView.Details.NONE
 import leakcanary.internal.MoreDetailsView.Details.OPENED
 import leakcanary.internal.activity.db.LeakingInstanceTable.InstanceProjection
 import leakcanary.internal.navigation.inflate
+import android.os.Build.VERSION.SDK_INT
+import leakcanary.internal.navigation.getColorCompat
 
-internal class DisplayLeakAdapter private constructor(
+@Suppress("DEPRECATION")
+internal class DisplayLeakAdapter constructor(
   context: Context,
   private val leakTrace: LeakTrace,
-  private val referenceName: String,
   private val instanceProjections: List<InstanceProjection>
 ) : BaseAdapter() {
 
@@ -62,15 +62,8 @@ internal class DisplayLeakAdapter private constructor(
 
   constructor(
     context: Context,
-    leakTrace: LeakTrace,
-    referenceName: String
-  ) : this(context, leakTrace, referenceName, emptyList())
-
-  constructor(
-    context: Context,
-    leakTrace: LeakTrace,
-    instanceProjections: List<InstanceProjection>
-  ) : this(context, leakTrace, "", instanceProjections)
+    leakTrace: LeakTrace
+  ) : this(context, leakTrace, emptyList())
 
   private val opened = BooleanArray(TOP_ROW_COUNT + leakTrace.elements.size)
 
@@ -147,27 +140,23 @@ internal class DisplayLeakAdapter private constructor(
     val resources = view.resources
     if (isFirstConnectorRow(position)) {
       titleView.text = if (isLeakGroup) {
-        HtmlCompat.fromHtml(
+        Html.fromHtml(
             """
               <font color='$helpColorHexString'>
                 <b>Known likely causes of leak group</b>
               </font>
-            """,
-            HtmlCompat.FROM_HTML_MODE_LEGACY
+            """
         )
       } else {
-        HtmlCompat.fromHtml(
+        Html.fromHtml(
             """
               <font color='$helpColorHexString'>
                 <b>${resources.getString(R.string.leak_canary_help_title)}</b>
               </font>
-            """,
-            HtmlCompat.FROM_HTML_MODE_LEGACY
+            """
         )
       }
     } else {
-      val isLast = position == (TOP_ROW_COUNT + leakTrace.elements.size) - 1
-
       val elementIndex = elementIndex(position)
       val element = leakTrace.elements[elementIndex]
 
@@ -180,7 +169,7 @@ internal class DisplayLeakAdapter private constructor(
       titleView.text = htmlTitle
 
       if (opened[position]) {
-        val htmlDetail = htmlDetails(isLast, element)
+        val htmlDetail = htmlDetails(element)
         detailView.text = htmlDetail
       }
     }
@@ -257,8 +246,7 @@ internal class DisplayLeakAdapter private constructor(
     if (exclusion != null) {
       htmlString += " (excluded)"
     }
-    val builder =
-      HtmlCompat.fromHtml(htmlString, HtmlCompat.FROM_HTML_MODE_LEGACY) as SpannableStringBuilder
+    val builder = Html.fromHtml(htmlString) as SpannableStringBuilder
     if (maybeLeakCause) {
       SquigglySpan.replaceUnderlineSpans(builder, context)
     }
@@ -266,10 +254,7 @@ internal class DisplayLeakAdapter private constructor(
     return builder
   }
 
-  private fun htmlDetails(
-    isLeakingInstance: Boolean,
-    element: LeakTraceElement
-  ): Spanned {
+  private fun htmlDetails(element: LeakTraceElement): Spanned {
     var htmlString = ""
     val exclusion = element.exclusion
     if (exclusion != null) {
@@ -279,11 +264,7 @@ internal class DisplayLeakAdapter private constructor(
         htmlString += " because <font color='#f3cf83'>" + exclusion.reason + "</font>"
       }
     }
-    if (isLeakingInstance && referenceName != "") {
-      htmlString += " <font color='$extraColorHexString'>$referenceName</font>"
-    }
-
-    return HtmlCompat.fromHtml(htmlString, HtmlCompat.FROM_HTML_MODE_LEGACY)
+    return Html.fromHtml(htmlString)
   }
 
   private fun getConnectorType(position: Int): Type {
@@ -365,8 +346,8 @@ internal class DisplayLeakAdapter private constructor(
     private const val TOP_ROW_COUNT = 2
 
     // https://stackoverflow.com/a/6540378/703646
-    private fun hexStringColor(context: Context, @ColorRes colorResId: Int): String {
-      return String.format("#%06X", 0xFFFFFF and ContextCompat.getColor(context, colorResId))
+    private fun hexStringColor(context: Context, colorResId: Int): String {
+      return String.format("#%06X", 0xFFFFFF and context.getColorCompat(colorResId))
     }
   }
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt
index 923e20ae..03c7fbc5 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt
@@ -26,7 +26,6 @@ import android.graphics.PorterDuff.Mode.CLEAR
 import android.graphics.PorterDuffXfermode
 import android.util.AttributeSet
 import android.view.View
-import androidx.core.content.ContextCompat
 import com.squareup.leakcanary.core.R
 import leakcanary.internal.DisplayLeakConnectorView.Type.END
 import leakcanary.internal.DisplayLeakConnectorView.Type.END_FIRST_UNREACHABLE
@@ -39,6 +38,7 @@ import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNKNOWN
 import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNREACHABLE
 import leakcanary.internal.DisplayLeakConnectorView.Type.START
 import leakcanary.internal.DisplayLeakConnectorView.Type.START_LAST_REACHABLE
+import leakcanary.internal.navigation.getColorCompat
 
 internal class DisplayLeakConnectorView(
   context: Context,
@@ -81,18 +81,18 @@ internal class DisplayLeakConnectorView(
         .toFloat()
 
     classNamePaint = Paint(Paint.ANTI_ALIAS_FLAG)
-    classNamePaint.color = ContextCompat.getColor(context, R.color.leak_canary_class_name)
+    classNamePaint.color = context.getColorCompat(R.color.leak_canary_class_name)
     classNamePaint.strokeWidth = strokeSize
 
     leakGroupRootPaint = Paint(Paint.ANTI_ALIAS_FLAG)
-    leakGroupRootPaint.color = ContextCompat.getColor(context, R.color.leak_canary_class_name)
+    leakGroupRootPaint.color = context.getColorCompat(R.color.leak_canary_class_name)
     leakGroupRootPaint.strokeWidth = strokeSize
     val pathLines = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_leak_dash_line)
         .toFloat()
     leakGroupRootPaint.pathEffect = DashPathEffect(floatArrayOf(pathLines, pathLines), 0f)
 
     leakPaint = Paint(Paint.ANTI_ALIAS_FLAG)
-    leakPaint.color = ContextCompat.getColor(context, R.color.leak_canary_leak)
+    leakPaint.color = context.getColorCompat(R.color.leak_canary_leak)
     leakPaint.style = Paint.Style.STROKE
     leakPaint.strokeWidth = strokeSize
 
@@ -105,7 +105,7 @@ internal class DisplayLeakConnectorView(
     clearPaint.xfermode = CLEAR_XFER_MODE
 
     referencePaint = Paint(Paint.ANTI_ALIAS_FLAG)
-    referencePaint.color = ContextCompat.getColor(context, R.color.leak_canary_reference)
+    referencePaint.color = context.getColorCompat(R.color.leak_canary_reference)
     referencePaint.strokeWidth = strokeSize
   }
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
index fa62ba45..f99a2da5 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
@@ -17,11 +17,12 @@ package leakcanary.internal
 
 import android.content.Context
 import android.content.Intent
+import android.os.Build.VERSION.SDK_INT
 import android.os.Process
-import androidx.core.content.ContextCompat
 import com.squareup.leakcanary.core.R
 import leakcanary.AnalyzerProgressListener
 import leakcanary.AndroidKnownReference
+import leakcanary.AndroidObjectInspectors
 import leakcanary.CanaryLog
 import leakcanary.HeapAnalyzer
 import leakcanary.LeakCanary
@@ -60,7 +61,10 @@ internal class HeapAnalyzerService : ForegroundService(
 
     val heapAnalysis =
       heapAnalyzer.checkForLeaks(
-          heapDumpFile, exclusions, config.computeRetainedHeapSize, config.objectInspectors
+          heapDumpFile, exclusions, config.computeRetainedHeapSize, config.objectInspectors,
+          if (config.useExperimentalLeakFinders) config.objectInspectors else listOf(
+              AndroidObjectInspectors.KEYED_WEAK_REFERENCE
+          )
       )
 
     config.analysisResultListener(application, heapAnalysis)
@@ -84,7 +88,19 @@ internal class HeapAnalyzerService : ForegroundService(
     ) {
       val intent = Intent(context, HeapAnalyzerService::class.java)
       intent.putExtra(HEAPDUMP_FILE_EXTRA, heapDumpFile)
-      ContextCompat.startForegroundService(context, intent)
+      startForegroundService(context, intent)
+    }
+
+    fun startForegroundService(
+      context: Context,
+      intent: Intent
+    ) {
+      if (SDK_INT >= 26) {
+        context.startForegroundService(intent)
+      } else {
+        // Pre-O behavior.
+        context.startService(intent)
+      }
     }
   }
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
index ee54c63d..c0110559 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -113,7 +113,7 @@ internal class HeapDumpTrigger(
       return
     }
     lastDisplayedRetainedInstanceCount = 0
-    refWatcher.removeInstancesRetainedBeforeHeapDump(heapDumpUptimeMillis)
+    refWatcher.removeInstancesWatchedBeforeHeapDump(heapDumpUptimeMillis)
 
     HeapAnalyzerService.runAnalysis(application, heapDumpFile)
   }
@@ -125,6 +125,7 @@ internal class HeapDumpTrigger(
       val retainedReferenceCount = refWatcher.retainedInstanceCount
       if (retainedReferenceCount == 0) {
         CanaryLog.d("No retained instances after GC")
+        @Suppress("DEPRECATION")
         val builder = Notification.Builder(application)
             .setContentTitle(
                 application.getString(R.string.leak_canary_notification_no_retained_instance_title)
@@ -160,7 +161,7 @@ internal class HeapDumpTrigger(
         return@post
       }
       lastDisplayedRetainedInstanceCount = 0
-      refWatcher.removeInstancesRetainedBeforeHeapDump(heapDumpUptimeMillis)
+      refWatcher.removeInstancesWatchedBeforeHeapDump(heapDumpUptimeMillis)
       HeapAnalyzerService.runAnalysis(application, heapDumpFile)
     }
   }
@@ -279,6 +280,7 @@ internal class HeapDumpTrigger(
     if (!Notifications.canShowNotification) {
       return
     }
+    @Suppress("DEPRECATION")
     val builder = Notification.Builder(application)
         .setContentTitle(
             application.getString(R.string.leak_canary_notification_retained_title, instanceCount)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.java b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.java
new file mode 100644
index 00000000..a76fe7f4
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.java
@@ -0,0 +1,541 @@
+package leakcanary.internal;
+
+import static org.xmlpull.v1.XmlPullParser.END_DOCUMENT;
+import static org.xmlpull.v1.XmlPullParser.START_TAG;
+
+import android.content.ContentProvider;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ProviderInfo;
+import android.content.res.XmlResourceParser;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Environment;
+import android.os.ParcelFileDescriptor;
+import android.provider.OpenableColumns;
+import android.text.TextUtils;
+import android.webkit.MimeTypeMap;
+
+import org.xmlpull.v1.XmlPullParserException;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+public class LeakCanaryFileProvider extends ContentProvider {
+    private static final String[] COLUMNS = {
+            OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE };
+
+    private static final String
+            META_DATA_FILE_PROVIDER_PATHS = "android.support.FILE_PROVIDER_PATHS";
+
+    private static final String TAG_ROOT_PATH = "root-path";
+    private static final String TAG_FILES_PATH = "files-path";
+    private static final String TAG_CACHE_PATH = "cache-path";
+    private static final String TAG_EXTERNAL = "external-path";
+    private static final String TAG_EXTERNAL_FILES = "external-files-path";
+    private static final String TAG_EXTERNAL_CACHE = "external-cache-path";
+    private static final String TAG_EXTERNAL_MEDIA = "external-media-path";
+
+    private static final String ATTR_NAME = "name";
+    private static final String ATTR_PATH = "path";
+
+    private static final File DEVICE_ROOT = new File("/");
+
+    private static HashMap<String, PathStrategy> sCache = new HashMap<String, PathStrategy>();
+
+    private PathStrategy mStrategy;
+
+    /**
+     * The default FileProvider implementation does not need to be initialized. If you want to
+     * override this method, you must provide your own subclass of FileProvider.
+     */
+    @Override
+    public boolean onCreate() {
+        return true;
+    }
+
+    /**
+     * After the FileProvider is instantiated, this method is called to provide the system with
+     * information about the provider.
+     *
+     * @param context A {@link Context} for the current component.
+     * @param info A {@link ProviderInfo} for the new provider.
+     */
+    @Override
+    public void attachInfo(Context context, ProviderInfo info) {
+        super.attachInfo(context, info);
+
+        // Sanity check our security
+        if (info.exported) {
+            throw new SecurityException("Provider must not be exported");
+        }
+        if (!info.grantUriPermissions) {
+            throw new SecurityException("Provider must grant uri permissions");
+        }
+
+        mStrategy = getPathStrategy(context, info.authority);
+    }
+
+    /**
+     * Return a content URI for a given {@link File}. Specific temporary
+     * permissions for the content URI can be set with
+     * {@link Context#grantUriPermission(String, Uri, int)}, or added
+     * to an {@link Intent} by calling {@link Intent#setData(Uri) setData()} and then
+     * {@link Intent#setFlags(int) setFlags()}; in both cases, the applicable flags are
+     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} and
+     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION}. A FileProvider can only return a
+     * <code>content</code> {@link Uri} for file paths defined in their <code>&lt;paths&gt;</code>
+     * meta-data element. See the Class Overview for more information.
+     *
+     * @param context A {@link Context} for the current component.
+     * @param authority The authority of a {@link FileProvider} defined in a
+     *            {@code <provider>} element in your app's manifest.
+     * @param file A {@link File} pointing to the filename for which you want a
+     * <code>content</code> {@link Uri}.
+     * @return A content URI for the file.
+     * @throws IllegalArgumentException When the given {@link File} is outside
+     * the paths supported by the provider.
+     */
+    public static Uri getUriForFile(Context context, String authority,
+            File file) {
+        final PathStrategy strategy = getPathStrategy(context, authority);
+        return strategy.getUriForFile(file);
+    }
+
+    /**
+     * Use a content URI returned by
+     * {@link #getUriForFile(Context, String, File) getUriForFile()} to get information about a file
+     * managed by the FileProvider.
+     * FileProvider reports the column names defined in {@link android.provider.OpenableColumns}:
+     * <ul>
+     * <li>{@link android.provider.OpenableColumns#DISPLAY_NAME}</li>
+     * <li>{@link android.provider.OpenableColumns#SIZE}</li>
+     * </ul>
+     * For more information, see
+     * {@link ContentProvider#query(Uri, String[], String, String[], String)
+     * ContentProvider.query()}.
+     *
+     * @param uri A content URI returned by {@link #getUriForFile}.
+     * @param projection The list of columns to put into the {@link Cursor}. If null all columns are
+     * included.
+     * @param selection Selection criteria to apply. If null then all data that matches the content
+     * URI is returned.
+     * @param selectionArgs An array of {@link java.lang.String}, containing arguments to bind to
+     * the <i>selection</i> parameter. The <i>query</i> method scans <i>selection</i> from left to
+     * right and iterates through <i>selectionArgs</i>, replacing the current "?" character in
+     * <i>selection</i> with the value at the current position in <i>selectionArgs</i>. The
+     * values are bound to <i>selection</i> as {@link java.lang.String} values.
+     * @param sortOrder A {@link java.lang.String} containing the column name(s) on which to sort
+     * the resulting {@link Cursor}.
+     * @return A {@link Cursor} containing the results of the query.
+     *
+     */
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection,
+            String[] selectionArgs,
+            String sortOrder) {
+        // ContentProvider has already checked granted permissions
+        final File file = mStrategy.getFileForUri(uri);
+
+        if (projection == null) {
+            projection = COLUMNS;
+        }
+
+        String[] cols = new String[projection.length];
+        Object[] values = new Object[projection.length];
+        int i = 0;
+        for (String col : projection) {
+            if (OpenableColumns.DISPLAY_NAME.equals(col)) {
+                cols[i] = OpenableColumns.DISPLAY_NAME;
+                values[i++] = file.getName();
+            } else if (OpenableColumns.SIZE.equals(col)) {
+                cols[i] = OpenableColumns.SIZE;
+                values[i++] = file.length();
+            }
+        }
+
+        cols = copyOf(cols, i);
+        values = copyOf(values, i);
+
+        final MatrixCursor cursor = new MatrixCursor(cols, 1);
+        cursor.addRow(values);
+        return cursor;
+    }
+
+    /**
+     * Returns the MIME type of a content URI returned by
+     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
+     *
+     * @param uri A content URI returned by
+     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
+     * @return If the associated file has an extension, the MIME type associated with that
+     * extension; otherwise <code>application/octet-stream</code>.
+     */
+    @Override
+    public String getType(Uri uri) {
+        // ContentProvider has already checked granted permissions
+        final File file = mStrategy.getFileForUri(uri);
+
+        final int lastDot = file.getName().lastIndexOf('.');
+        if (lastDot >= 0) {
+            final String extension = file.getName().substring(lastDot + 1);
+            final String mime = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);
+            if (mime != null) {
+                return mime;
+            }
+        }
+
+        return "application/octet-stream";
+    }
+
+    /**
+     * By default, this method throws an {@link java.lang.UnsupportedOperationException}. You must
+     * subclass FileProvider if you want to provide different functionality.
+     */
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+        throw new UnsupportedOperationException("No external inserts");
+    }
+
+    /**
+     * By default, this method throws an {@link java.lang.UnsupportedOperationException}. You must
+     * subclass FileProvider if you want to provide different functionality.
+     */
+    @Override
+    public int update(Uri uri, ContentValues values, String selection,
+            String[] selectionArgs) {
+        throw new UnsupportedOperationException("No external updates");
+    }
+
+    /**
+     * Deletes the file associated with the specified content URI, as
+     * returned by {@link #getUriForFile(Context, String, File) getUriForFile()}. Notice that this
+     * method does <b>not</b> throw an {@link java.io.IOException}; you must check its return value.
+     *
+     * @param uri A content URI for a file, as returned by
+     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
+     * @param selection Ignored. Set to {@code null}.
+     * @param selectionArgs Ignored. Set to {@code null}.
+     * @return 1 if the delete succeeds; otherwise, 0.
+     */
+    @Override
+    public int delete(Uri uri, String selection,
+            String[] selectionArgs) {
+        // ContentProvider has already checked granted permissions
+        final File file = mStrategy.getFileForUri(uri);
+        return file.delete() ? 1 : 0;
+    }
+
+    /**
+     * By default, FileProvider automatically returns the
+     * {@link ParcelFileDescriptor} for a file associated with a <code>content://</code>
+     * {@link Uri}. To get the {@link ParcelFileDescriptor}, call
+     * {@link android.content.ContentResolver#openFileDescriptor(Uri, String)
+     * ContentResolver.openFileDescriptor}.
+     *
+     * To override this method, you must provide your own subclass of FileProvider.
+     *
+     * @param uri A content URI associated with a file, as returned by
+     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
+     * @param mode Access mode for the file. May be "r" for read-only access, "rw" for read and
+     * write access, or "rwt" for read and write access that truncates any existing file.
+     * @return A new {@link ParcelFileDescriptor} with which you can access the file.
+     */
+    @Override
+    public ParcelFileDescriptor openFile(Uri uri, String mode)
+            throws FileNotFoundException {
+        // ContentProvider has already checked granted permissions
+        final File file = mStrategy.getFileForUri(uri);
+        final int fileMode = modeToMode(mode);
+        return ParcelFileDescriptor.open(file, fileMode);
+    }
+
+    /**
+     * Return {@link PathStrategy} for given authority, either by parsing or
+     * returning from cache.
+     */
+    private static PathStrategy getPathStrategy(Context context, String authority) {
+        PathStrategy strat;
+        synchronized (sCache) {
+            strat = sCache.get(authority);
+            if (strat == null) {
+                try {
+                    strat = parsePathStrategy(context, authority);
+                } catch (IOException e) {
+                    throw new IllegalArgumentException(
+                            "Failed to parse " + META_DATA_FILE_PROVIDER_PATHS + " meta-data", e);
+                } catch (XmlPullParserException e) {
+                    throw new IllegalArgumentException(
+                            "Failed to parse " + META_DATA_FILE_PROVIDER_PATHS + " meta-data", e);
+                }
+                sCache.put(authority, strat);
+            }
+        }
+        return strat;
+    }
+
+    /**
+     * Parse and return {@link PathStrategy} for given authority as defined in
+     * {@link #META_DATA_FILE_PROVIDER_PATHS} {@code <meta-data>}.
+     *
+     * @see #getPathStrategy(Context, String)
+     */
+    private static PathStrategy parsePathStrategy(Context context, String authority)
+            throws IOException, XmlPullParserException {
+        final SimplePathStrategy strat = new SimplePathStrategy(authority);
+
+        final ProviderInfo info = context.getPackageManager()
+                .resolveContentProvider(authority, PackageManager.GET_META_DATA);
+        final XmlResourceParser in = info.loadXmlMetaData(
+                context.getPackageManager(), META_DATA_FILE_PROVIDER_PATHS);
+        if (in == null) {
+            throw new IllegalArgumentException(
+                    "Missing " + META_DATA_FILE_PROVIDER_PATHS + " meta-data");
+        }
+
+        int type;
+        while ((type = in.next()) != END_DOCUMENT) {
+            if (type == START_TAG) {
+                final String tag = in.getName();
+
+                final String name = in.getAttributeValue(null, ATTR_NAME);
+                String path = in.getAttributeValue(null, ATTR_PATH);
+
+                File target = null;
+                if (TAG_ROOT_PATH.equals(tag)) {
+                    target = DEVICE_ROOT;
+                } else if (TAG_FILES_PATH.equals(tag)) {
+                    target = context.getFilesDir();
+                } else if (TAG_CACHE_PATH.equals(tag)) {
+                    target = context.getCacheDir();
+                } else if (TAG_EXTERNAL.equals(tag)) {
+                    target = Environment.getExternalStorageDirectory();
+                } else if (TAG_EXTERNAL_FILES.equals(tag)) {
+                    File[] externalFilesDirs = getExternalFilesDirs(context, null);
+                    if (externalFilesDirs.length > 0) {
+                        target = externalFilesDirs[0];
+                    }
+                } else if (TAG_EXTERNAL_CACHE.equals(tag)) {
+                    File[] externalCacheDirs = getExternalCacheDirs(context);
+                    if (externalCacheDirs.length > 0) {
+                        target = externalCacheDirs[0];
+                    }
+                } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP
+                        && TAG_EXTERNAL_MEDIA.equals(tag)) {
+                    File[] externalMediaDirs = context.getExternalMediaDirs();
+                    if (externalMediaDirs.length > 0) {
+                        target = externalMediaDirs[0];
+                    }
+                }
+
+                if (target != null) {
+                    strat.addRoot(name, buildPath(target, path));
+                }
+            }
+        }
+
+        return strat;
+    }
+
+    private static File[] getExternalFilesDirs(Context context, String type) {
+        if (Build.VERSION.SDK_INT >= 19) {
+            return context.getExternalFilesDirs(type);
+        } else {
+            return new File[] { context.getExternalFilesDir(type) };
+        }
+    }
+
+    private static File[] getExternalCacheDirs(Context context) {
+        if (Build.VERSION.SDK_INT >= 19) {
+            return context.getExternalCacheDirs();
+        } else {
+            return new File[] { context.getExternalCacheDir() };
+        }
+    }
+
+    /**
+     * Strategy for mapping between {@link File} and {@link Uri}.
+     * <p>
+     * Strategies must be symmetric so that mapping a {@link File} to a
+     * {@link Uri} and then back to a {@link File} points at the original
+     * target.
+     * <p>
+     * Strategies must remain consistent across app launches, and not rely on
+     * dynamic state. This ensures that any generated {@link Uri} can still be
+     * resolved if your process is killed and later restarted.
+     *
+     * @see SimplePathStrategy
+     */
+    interface PathStrategy {
+        /**
+         * Return a {@link Uri} that represents the given {@link File}.
+         */
+        Uri getUriForFile(File file);
+
+        /**
+         * Return a {@link File} that represents the given {@link Uri}.
+         */
+        File getFileForUri(Uri uri);
+    }
+
+    /**
+     * Strategy that provides access to files living under a narrow whitelist of
+     * filesystem roots. It will throw {@link SecurityException} if callers try
+     * accessing files outside the configured roots.
+     * <p>
+     * For example, if configured with
+     * {@code addRoot("myfiles", context.getFilesDir())}, then
+     * {@code context.getFileStreamPath("foo.txt")} would map to
+     * {@code content://myauthority/myfiles/foo.txt}.
+     */
+    static class SimplePathStrategy implements PathStrategy {
+        private final String mAuthority;
+        private final HashMap<String, File> mRoots = new HashMap<String, File>();
+
+        SimplePathStrategy(String authority) {
+            mAuthority = authority;
+        }
+
+        /**
+         * Add a mapping from a name to a filesystem root. The provider only offers
+         * access to files that live under configured roots.
+         */
+        void addRoot(String name, File root) {
+            if (TextUtils.isEmpty(name)) {
+                throw new IllegalArgumentException("Name must not be empty");
+            }
+
+            try {
+                // Resolve to canonical path to keep path checking fast
+                root = root.getCanonicalFile();
+            } catch (IOException e) {
+                throw new IllegalArgumentException(
+                        "Failed to resolve canonical path for " + root, e);
+            }
+
+            mRoots.put(name, root);
+        }
+
+        @Override
+        public Uri getUriForFile(File file) {
+            String path;
+            try {
+                path = file.getCanonicalPath();
+            } catch (IOException e) {
+                throw new IllegalArgumentException("Failed to resolve canonical path for " + file);
+            }
+
+            // Find the most-specific root path
+            Map.Entry<String, File> mostSpecific = null;
+            for (Map.Entry<String, File> root : mRoots.entrySet()) {
+                final String rootPath = root.getValue().getPath();
+                if (path.startsWith(rootPath) && (mostSpecific == null
+                        || rootPath.length() > mostSpecific.getValue().getPath().length())) {
+                    mostSpecific = root;
+                }
+            }
+
+            if (mostSpecific == null) {
+                throw new IllegalArgumentException(
+                        "Failed to find configured root that contains " + path);
+            }
+
+            // Start at first char of path under root
+            final String rootPath = mostSpecific.getValue().getPath();
+            if (rootPath.endsWith("/")) {
+                path = path.substring(rootPath.length());
+            } else {
+                path = path.substring(rootPath.length() + 1);
+            }
+
+            // Encode the tag and path separately
+            path = Uri.encode(mostSpecific.getKey()) + '/' + Uri.encode(path, "/");
+            return new Uri.Builder().scheme("content")
+                    .authority(mAuthority).encodedPath(path).build();
+        }
+
+        @Override
+        public File getFileForUri(Uri uri) {
+            String path = uri.getEncodedPath();
+
+            final int splitIndex = path.indexOf('/', 1);
+            final String tag = Uri.decode(path.substring(1, splitIndex));
+            path = Uri.decode(path.substring(splitIndex + 1));
+
+            final File root = mRoots.get(tag);
+            if (root == null) {
+                throw new IllegalArgumentException("Unable to find configured root for " + uri);
+            }
+
+            File file = new File(root, path);
+            try {
+                file = file.getCanonicalFile();
+            } catch (IOException e) {
+                throw new IllegalArgumentException("Failed to resolve canonical path for " + file);
+            }
+
+            if (!file.getPath().startsWith(root.getPath())) {
+                throw new SecurityException("Resolved path jumped beyond configured root");
+            }
+
+            return file;
+        }
+    }
+
+    /**
+     * Copied from ContentResolver.java
+     */
+    private static int modeToMode(String mode) {
+        int modeBits;
+        if ("r".equals(mode)) {
+            modeBits = ParcelFileDescriptor.MODE_READ_ONLY;
+        } else if ("w".equals(mode) || "wt".equals(mode)) {
+            modeBits = ParcelFileDescriptor.MODE_WRITE_ONLY
+                    | ParcelFileDescriptor.MODE_CREATE
+                    | ParcelFileDescriptor.MODE_TRUNCATE;
+        } else if ("wa".equals(mode)) {
+            modeBits = ParcelFileDescriptor.MODE_WRITE_ONLY
+                    | ParcelFileDescriptor.MODE_CREATE
+                    | ParcelFileDescriptor.MODE_APPEND;
+        } else if ("rw".equals(mode)) {
+            modeBits = ParcelFileDescriptor.MODE_READ_WRITE
+                    | ParcelFileDescriptor.MODE_CREATE;
+        } else if ("rwt".equals(mode)) {
+            modeBits = ParcelFileDescriptor.MODE_READ_WRITE
+                    | ParcelFileDescriptor.MODE_CREATE
+                    | ParcelFileDescriptor.MODE_TRUNCATE;
+        } else {
+            throw new IllegalArgumentException("Invalid mode: " + mode);
+        }
+        return modeBits;
+    }
+
+    private static File buildPath(File base, String... segments) {
+        File cur = base;
+        for (String segment : segments) {
+            if (segment != null) {
+                cur = new File(cur, segment);
+            }
+        }
+        return cur;
+    }
+
+    private static String[] copyOf(String[] original, int newLength) {
+        final String[] result = new String[newLength];
+        System.arraycopy(original, 0, result, 0, newLength);
+        return result;
+    }
+
+    private static Object[] copyOf(Object[] original, int newLength) {
+        final Object[] result = new Object[newLength];
+        System.arraycopy(original, 0, result, 0, newLength);
+        return result;
+    }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt
deleted file mode 100644
index cade0684..00000000
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt
+++ /dev/null
@@ -1,9 +0,0 @@
-package leakcanary.internal
-
-import androidx.core.content.FileProvider
-
-/**
- * There can only be one [FileProvider] provider registered per app, so we extend that class
- * just to use a distinct name.
- */
-internal class LeakCanaryFileProvider : FileProvider()
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
index a42d6fdc..d569f833 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
@@ -154,6 +154,7 @@ internal class LeakDirectoryProvider constructor(
     )
   }
 
+  @Suppress("DEPRECATION")
   private fun externalStorageDirectory(): File {
     val downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS)
     return File(downloadsDirectory, "leakcanary-" + context.packageName)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt
index 677f7f48..b033e32d 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt
@@ -1,9 +1,8 @@
 package leakcanary.internal
 
-import androidx.annotation.StringRes
 import com.squareup.leakcanary.core.R
 
-enum class NotificationType(@StringRes val nameResId: Int, val importance: Int) {
+enum class NotificationType(val nameResId: Int, val importance: Int) {
   LEAKCANARY_LOW(
       R.string.leak_canary_notification_channel_low, IMPORTANCE_LOW
   ),
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt
index 3559c153..9db6e924 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt
@@ -83,6 +83,7 @@ internal object Notifications {
     }
 
     return if (SDK_INT < JELLY_BEAN) {
+      @Suppress("DEPRECATION")
       builder.notification
     } else {
       builder.build()
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt
index 747f488f..a817e24b 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt
@@ -22,8 +22,8 @@ import android.graphics.Path
 import android.text.SpannableStringBuilder
 import android.text.style.ReplacementSpan
 import android.text.style.UnderlineSpan
-import androidx.core.content.ContextCompat
 import com.squareup.leakcanary.core.R
+import leakcanary.internal.navigation.getColorCompat
 
 /**
  * Inspired from https://github.com/flavienlaurent/spans and
@@ -44,7 +44,7 @@ internal class SquigglySpan(context: Context) : ReplacementSpan() {
   init {
     val resources = context.resources
     squigglyPaint.style = Paint.Style.STROKE
-    squigglyPaint.color = ContextCompat.getColor(context, R.color.leak_canary_leak)
+    squigglyPaint.color = context.getColorCompat(R.color.leak_canary_leak)
     val strokeWidth =
       resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_stroke_width)
           .toFloat()
@@ -59,7 +59,7 @@ internal class SquigglySpan(context: Context) : ReplacementSpan() {
     path = Path()
     val waveHeight = 2 * amplitude + strokeWidth
     halfWaveHeight = waveHeight / 2
-    referenceColor = ContextCompat.getColor(context, R.color.leak_canary_reference)
+    referenceColor = context.getColorCompat(R.color.leak_canary_reference)
   }
 
   override fun getSize(
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
index d6e750d7..4f7c8db6 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
@@ -9,8 +9,8 @@ import android.net.Uri
 import android.os.AsyncTask
 import android.view.View
 import android.widget.Toast
-import androidx.core.content.FileProvider
 import com.squareup.leakcanary.core.R
+import leakcanary.internal.LeakCanaryFileProvider
 import leakcanary.internal.navigation.activity
 import java.io.File
 
@@ -27,7 +27,7 @@ internal fun View.share(content: String) {
 internal fun View.shareHeapDump(heapDumpFile: File) {
   AsyncTask.SERIAL_EXECUTOR.execute {
     heapDumpFile.setReadable(true, false)
-    val heapDumpUri = FileProvider.getUriForFile(
+    val heapDumpUri = LeakCanaryFileProvider.getUriForFile(
         activity,
         "com.squareup.leakcanary.fileprovider." + activity.packageName,
         heapDumpFile
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
index 69b48390..f7a63fc9 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
@@ -40,7 +40,7 @@ internal object HeapAnalysisTable {
     values.put("object", heapAnalysis.toByteArray())
     when (heapAnalysis) {
       is HeapAnalysisSuccess -> {
-        values.put("retained_instance_count", heapAnalysis.retainedInstances.size)
+        values.put("retained_instance_count", heapAnalysis.leakingInstances.size)
       }
       is HeapAnalysisFailure -> {
         val cause = heapAnalysis.exception.cause!!
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
index 2a010a8e..7e713797 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
@@ -26,6 +26,6 @@ internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
 
   companion object {
     // Last updated for next after 2.0-alpha-3
-    private const val VERSION = 11
+    private const val VERSION = 12
   }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt
index 18b43754..628befce 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt
@@ -1,14 +1,16 @@
 package leakcanary.internal.activity.screen
 
 import android.app.AlertDialog
+import android.content.Context
+import android.graphics.drawable.Drawable
+import android.os.Build.VERSION.SDK_INT
+import android.text.Html
 import android.text.format.DateUtils
 import android.text.method.LinkMovementMethod
 import android.view.View
 import android.view.ViewGroup
 import android.widget.ListView
 import android.widget.TextView
-import androidx.core.content.ContextCompat
-import androidx.core.text.HtmlCompat
 import com.squareup.leakcanary.core.BuildConfig
 import com.squareup.leakcanary.core.R
 import leakcanary.internal.activity.LeakActivity
@@ -40,14 +42,12 @@ internal class GroupListScreen : Screen() {
 
         menu.add(R.string.leak_canary_about_menu)
             .setOnMenuItemClickListener {
+              @Suppress("DEPRECATION")
               val dialog = AlertDialog.Builder(context)
-                  .setIcon(ContextCompat.getDrawable(context, R.drawable.leak_canary_icon))
+                  .setIcon(context.getDrawableCompat(R.drawable.leak_canary_icon))
                   .setTitle(resources.getString(R.string.leak_canary_about_title, BuildConfig.LIBRARY_VERSION))
                   .setMessage(
-                      HtmlCompat.fromHtml(
-                          resources.getString(R.string.leak_canary_about_message),
-                          HtmlCompat.FROM_HTML_MODE_LEGACY
-                      )
+                      Html.fromHtml(resources.getString(R.string.leak_canary_about_message))
                   )
                   .setPositiveButton(android.R.string.ok, null)
                   .show()
@@ -65,6 +65,15 @@ internal class GroupListScreen : Screen() {
 
     }
 
+  private fun Context.getDrawableCompat(id: Int): Drawable {
+    if (SDK_INT >= 21) {
+      return getDrawable(id)!!
+    } else  {
+      @Suppress("DEPRECATION")
+      return resources.getDrawable(id)
+    }
+  }
+
   private fun View.onGroupsRetrieved(projections: List<GroupProjection>) {
     activity.title =
       resources.getString(R.string.leak_canary_group_list_screen_title, projections.size)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
index a8c4aa94..c53b6511 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
@@ -9,8 +9,6 @@ import com.squareup.leakcanary.core.R
 import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.Exclusion.Status.WONT_FIX_LEAK
 import leakcanary.HeapAnalysisSuccess
-import leakcanary.LeakingInstance
-import leakcanary.NoPathToInstance
 import leakcanary.internal.activity.db.HeapAnalysisTable
 import leakcanary.internal.activity.db.LeakingInstanceTable
 import leakcanary.internal.activity.db.LeakingInstanceTable.HeapAnalysisGroupProjection
@@ -54,7 +52,7 @@ internal class HeapAnalysisSuccessScreen(
   ) {
     activity.title = resources.getString(
         R.string.leak_canary_heap_analysis_success_screen_title,
-        heapAnalysis.retainedInstances.size
+        heapAnalysis.leakingInstances.size
     )
 
     onCreateOptionsMenu { menu ->
@@ -89,21 +87,13 @@ internal class HeapAnalysisSuccessScreen(
 
     val listView = findViewById<ListView>(R.id.leak_canary_list)
 
-    val retainedInstances = heapAnalysis.retainedInstances
+    val retainedInstances = heapAnalysis.leakingInstances
 
-    var noPathToInstanceCount = 0
     retainedInstances.forEach { retainedInstance ->
-      when (retainedInstance) {
-        is LeakingInstance -> {
-          if (leakGroupByHash[retainedInstance.groupHash] == null) {
-            throw IllegalStateException(
-                "Removing groups is not supported, this should never happen."
-            )
-          }
-        }
-        is NoPathToInstance -> {
-          noPathToInstanceCount++
-        }
+      if (leakGroupByHash[retainedInstance.groupHash] == null) {
+        throw IllegalStateException(
+            "Removing groups is not supported, this should never happen."
+        )
       }
     }
 
@@ -145,15 +135,6 @@ internal class HeapAnalysisSuccessScreen(
       titleText to timeText
     })
 
-    if (noPathToInstanceCount > 0) {
-      rowList.add(
-          resources.getString(
-              R.string.leak_canary_heap_analysis_success_screen_no_path_to_instance_count,
-              noPathToInstanceCount
-          ) to ""
-      )
-    }
-
     listView.adapter =
       SimpleListAdapter(R.layout.leak_canary_leak_row, rowList) { view, position ->
         val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
index d310f95d..ddd3fbba 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
@@ -10,7 +10,6 @@ import android.graphics.Paint
 import android.graphics.Paint.Style.FILL
 import android.graphics.Paint.Style.STROKE
 import android.graphics.Rect
-import androidx.core.content.ContextCompat
 import com.squareup.leakcanary.core.R
 import leakcanary.HprofPushRecordsParser
 import leakcanary.HprofPushRecordsParser.OnRecordListener
@@ -32,6 +31,7 @@ import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.Sh
 import leakcanary.Record.LoadClassRecord
 import leakcanary.Record.StackTraceRecord
 import leakcanary.Record.StringRecord
+import leakcanary.internal.navigation.getColorCompat
 import java.io.File
 import kotlin.reflect.KClass
 
@@ -60,21 +60,21 @@ object HeapDumpRenderer {
     val recordPositions = mutableListOf<Pair<Int, Long>>()
     var currentRecord: Record? = null
 
-    val otherColor = ContextCompat.getColor(context, R.color.leak_canary_heap_other)
-    val stackTraceColor = ContextCompat.getColor(context, R.color.leak_canary_heap_stack_trace)
-    val hprofStringColor = ContextCompat.getColor(context, R.color.leak_canary_heap_hprof_string)
-    val loadClassColor = ContextCompat.getColor(context, R.color.leak_canary_heap_load_class)
-    val classDumpColor = ContextCompat.getColor(context, R.color.leak_canary_heap_class_dump)
-    val instanceColor = ContextCompat.getColor(context, R.color.leak_canary_heap_instance)
-    val objectArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_object_array)
-    val booleanArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_boolean_array)
-    val charArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_char_array)
-    val floatArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_float_array)
-    val doubleArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_double_array)
-    val byteArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_byte_array)
-    val shortArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_short_array)
-    val intArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_int_array)
-    val longArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_long_array)
+    val otherColor = context.getColorCompat(R.color.leak_canary_heap_other)
+    val stackTraceColor = context.getColorCompat(R.color.leak_canary_heap_stack_trace)
+    val hprofStringColor = context.getColorCompat(R.color.leak_canary_heap_hprof_string)
+    val loadClassColor = context.getColorCompat(R.color.leak_canary_heap_load_class)
+    val classDumpColor = context.getColorCompat(R.color.leak_canary_heap_class_dump)
+    val instanceColor = context.getColorCompat(R.color.leak_canary_heap_instance)
+    val objectArrayColor = context.getColorCompat(R.color.leak_canary_heap_object_array)
+    val booleanArrayColor = context.getColorCompat(R.color.leak_canary_heap_boolean_array)
+    val charArrayColor = context.getColorCompat(R.color.leak_canary_heap_char_array)
+    val floatArrayColor = context.getColorCompat(R.color.leak_canary_heap_float_array)
+    val doubleArrayColor = context.getColorCompat(R.color.leak_canary_heap_double_array)
+    val byteArrayColor = context.getColorCompat(R.color.leak_canary_heap_byte_array)
+    val shortArrayColor = context.getColorCompat(R.color.leak_canary_heap_short_array)
+    val intArrayColor = context.getColorCompat(R.color.leak_canary_heap_int_array)
+    val longArrayColor = context.getColorCompat(R.color.leak_canary_heap_long_array)
     val colors = mapOf(
         StringRecord::class to hprofStringColor,
         LoadClassRecord::class to loadClassColor,
@@ -94,10 +94,10 @@ object HeapDumpRenderer {
         GcRootRecord::class to otherColor
     )
 
-    val appHeapColor = ContextCompat.getColor(context, R.color.leak_canary_heap_app)
-    val imageHeapColor = ContextCompat.getColor(context, R.color.leak_canary_heap_image)
-    val zygoteHeapColor = ContextCompat.getColor(context, R.color.leak_canary_heap_zygote)
-    val stringColor = ContextCompat.getColor(context, R.color.leak_canary_heap_instance_string)
+    val appHeapColor = context.getColorCompat(R.color.leak_canary_heap_app)
+    val imageHeapColor = context.getColorCompat(R.color.leak_canary_heap_image)
+    val zygoteHeapColor = context.getColorCompat(R.color.leak_canary_heap_zygote)
+    val stringColor = context.getColorCompat(R.color.leak_canary_heap_instance_string)
 
     val parser = HprofPushRecordsParser()
     val reader = parser.readHprofRecords(heapDumpFile, setOf(object : OnRecordListener {
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
index a29c00c5..78addf1f 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
@@ -303,16 +303,7 @@ internal class HprofExplorerScreen(
             is GraphObjectArrayRecord -> {
               objectRecord.arrayClassName
             }
-            is GraphPrimitiveArrayRecord -> when (objectRecord.primitiveType) {
-              BOOLEAN -> "boolean[]"
-              CHAR -> "char[]"
-              FLOAT -> "float[]"
-              DOUBLE -> "double[]"
-              BYTE -> "byte[]"
-              SHORT -> "short[]"
-              INT -> "int[]"
-              LONG -> "long[]"
-            }
+            is GraphPrimitiveArrayRecord -> objectRecord.arrayClassName
           }
         }
       }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
index fd83040f..90d3f2f2 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
@@ -70,8 +70,7 @@ internal class LeakingInstanceScreen private constructor(
 
     val listView = findViewById<ListView>(R.id.leak_canary_list)
 
-    val adapter =
-      DisplayLeakAdapter(context, leakingInstance.leakTrace, leakingInstance.referenceName)
+    val adapter = DisplayLeakAdapter(context, leakingInstance.leakTrace)
     listView.adapter = adapter
 
     listView.setOnItemClickListener { _, _, position, _ ->
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
index 7311da16..e07fecbb 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
@@ -11,10 +11,10 @@ import android.view.ViewGroup
 import android.view.ViewTreeObserver.OnGlobalLayoutListener
 import android.widget.ImageView
 import android.widget.Toast
-import androidx.core.content.FileProvider
 import com.squareup.leakcanary.core.R
 import leakcanary.CanaryLog
 import leakcanary.internal.InternalLeakCanary
+import leakcanary.internal.LeakCanaryFileProvider
 import leakcanary.internal.activity.db.executeOnIo
 import leakcanary.internal.navigation.Screen
 import leakcanary.internal.navigation.activity
@@ -85,7 +85,7 @@ internal class RenderHeapDumpScreen(
                     .show()
                 executeOnIo {
                   val bitmap = HeapDumpRenderer.render(context, heapDumpFile, 2048, 0, 4)
-                  val storageDir =
+                  @Suppress("DEPRECATION") val storageDir =
                     Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS)
 
                   val imageFile = File(storageDir, "${heapDumpFile.name}.png")
@@ -93,7 +93,7 @@ internal class RenderHeapDumpScreen(
                   if (saved) {
                     CanaryLog.d("Png saved at $imageFile")
                     imageFile.setReadable(true, false)
-                    val imageUri = FileProvider.getUriForFile(
+                    val imageUri = LeakCanaryFileProvider.getUriForFile(
                         activity,
                         "com.squareup.leakcanary.fileprovider." + activity.packageName,
                         imageFile
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt
index 29264091..2c697900 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt
@@ -3,11 +3,9 @@ package leakcanary.internal.activity.ui
 import android.view.View
 import android.view.ViewGroup
 import android.widget.BaseAdapter
-import androidx.annotation.LayoutRes
 import leakcanary.internal.navigation.inflate
 
 class SimpleListAdapter<T>(
-  @LayoutRes
   private val rowResId: Int,
   private val items: List<T>,
   private val bindView: SimpleListAdapter<T>.(View, Int) -> Unit
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt
index 13603e4e..89d3c5ec 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt
@@ -1,13 +1,14 @@
 package leakcanary.internal.navigation
 
 import android.app.Activity
+import android.content.Context
+import android.os.Build.VERSION
 import android.view.LayoutInflater
 import android.view.Menu
 import android.view.View
 import android.view.ViewGroup
-import androidx.annotation.LayoutRes
 
-internal fun ViewGroup.inflate(@LayoutRes layoutResId: Int) = LayoutInflater.from(context)
+internal fun ViewGroup.inflate(layoutResId: Int) = LayoutInflater.from(context)
     .inflate(layoutResId, this, false)!!
 
 internal val View.activity
@@ -27,4 +28,12 @@ internal fun View.goTo(screen: Screen) {
 
 internal fun View.goBack() {
   activity<NavigatingActivity>().goBack()
+}
+
+internal fun Context.getColorCompat(id: Int): Int {
+  return if (VERSION.SDK_INT >= 23) {
+    getColor(id)
+  } else {
+    resources.getColor(id)
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
index 56cf4619..0c625e36 100644
--- a/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
+++ b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
@@ -70,6 +70,5 @@
   <string name="leak_canary_options_menu_import_hprof_file">Hprof Datei importieren &amp; analysieren</string>
   <string name="leak_canary_options_menu_see_analysis_list">Siehe Analyse-Liste</string>
   <string name="leak_canary_options_menu_render_heap_dump">Heap Dump rendern</string>
-  <string name="leak_canary_heap_analysis_success_screen_no_path_to_instance_count">%d erhaltene Instanzen ohne Leaks</string>
   <string name="leak_canary_help_title">Tippe hier, um mehr zu erfahren</string>
 </resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
index 3445d9ab..aa915031 100644
--- a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
@@ -85,6 +85,5 @@
   <string name="leak_canary_options_menu_see_analysis_list">See Analysis List</string>
   <string name="leak_canary_options_menu_render_heap_dump">Render Heap Dump</string>
   <string name="leak_canary_options_menu_explore_heap_dump">Explore Heap Dump</string>
-  <string name="leak_canary_heap_analysis_success_screen_no_path_to_instance_count">%d non leaking retained instances</string>
   <string name="leak_canary_help_title">Tap here to learn more</string>
 </resources>
diff --git a/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
index db8d12fe..cd9660ab 100644
--- a/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
+++ b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
@@ -15,14 +15,9 @@
   ~ limitations under the License.
   -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
     package="com.squareup.leakcanary.instrumentation.test">
-  <!-- Disabled debuggable for accurate performance results -->
-  <application android:name="leakcanary.InstrumentationTestApplication"
-      android:debuggable="false"
-      tools:ignore="HardcodedDebugMode"
-      tools:replace="android:debuggable"
-      >
+
+  <application android:name="leakcanary.InstrumentationTestApplication">
     <activity android:name="leakcanary.TestActivity"/>
   </application>
 </manifest>
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
index f38d1d44..09b4fbb4 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
@@ -168,14 +168,18 @@ class InstrumentationLeakDetector {
       )
     }
 
-    refWatcher.removeInstancesRetainedBeforeHeapDump(heapDumpUptimeMillis)
+    refWatcher.removeInstancesWatchedBeforeHeapDump(heapDumpUptimeMillis)
 
     val listener = AnalyzerProgressListener.NONE
 
     val heapAnalyzer = HeapAnalyzer(listener)
     val heapAnalysis = heapAnalyzer.checkForLeaks(
-        heapDumpFile, AndroidKnownReference.mapToExclusions(config.knownReferences), config.computeRetainedHeapSize,
-        config.objectInspectors
+        heapDumpFile, AndroidKnownReference.mapToExclusions(config.knownReferences),
+        config.computeRetainedHeapSize,
+        config.objectInspectors,
+        if (config.useExperimentalLeakFinders) config.objectInspectors else listOf(
+            AndroidObjectInspectors.KEYED_WEAK_REFERENCE
+        )
     )
 
     CanaryLog.d("Heap Analysis:\n%s", heapAnalysis)
diff --git a/leakcanary-cli/build.gradle b/leakcanary-cli/build.gradle
index 0aa040f9..a2833274 100644
--- a/leakcanary-cli/build.gradle
+++ b/leakcanary-cli/build.gradle
@@ -8,7 +8,6 @@ targetCompatibility = JavaVersion.VERSION_1_7
 dependencies {
   api project(':leakcanary-analyzer')
 
-  implementation deps.androidx.annotation
   implementation deps.kotlin.stdlib
 }
 
diff --git a/leakcanary-fragments-androidx/build.gradle b/leakcanary-fragments-androidx/build.gradle
new file mode 100644
index 00000000..3e2f7a90
--- /dev/null
+++ b/leakcanary-fragments-androidx/build.gradle
@@ -0,0 +1,25 @@
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+
+dependencies {
+  api project(':leakcanary-leaksentry')
+
+  implementation deps.kotlin.stdlib
+  // Optional dependency
+  compileOnly deps.androidx.fragment
+}
+
+android {
+  compileSdkVersion versions.compileSdk
+  defaultConfig {
+    minSdkVersion versions.minSdk
+  }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    error 'ObsoleteSdkInt'
+    check 'Interoperability'
+  }
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-fragments-androidx/gradle.properties b/leakcanary-fragments-androidx/gradle.properties
new file mode 100644
index 00000000..54f53098
--- /dev/null
+++ b/leakcanary-fragments-androidx/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-fragments-androidx
+POM_NAME=LeakCanary Android X fragments support
+POM_PACKAGING=aar
diff --git a/leakcanary-fragments-androidx/src/main/AndroidManifest.xml b/leakcanary-fragments-androidx/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..22eac305
--- /dev/null
+++ b/leakcanary-fragments-androidx/src/main/AndroidManifest.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    package="com.squareup.leakcanary.fragments.androidx"
+    >
+</manifest>
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/SupportFragmentDestroyWatcher.kt b/leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
similarity index 97%
rename from leakcanary-leaksentry/src/main/java/leakcanary/internal/SupportFragmentDestroyWatcher.kt
rename to leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
index a4fc2f29..d12efa0c 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/SupportFragmentDestroyWatcher.kt
+++ b/leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
@@ -22,7 +22,7 @@ import androidx.fragment.app.FragmentManager
 import leakcanary.RefWatcher
 import leakcanary.LeakSentry.Config
 
-internal class SupportFragmentDestroyWatcher(
+internal class AndroidXFragmentDestroyWatcher(
   private val refWatcher: RefWatcher,
   private val configProvider: () -> Config
 ) : FragmentDestroyWatcher {
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphContext.kt b/leakcanary-haha/src/main/java/leakcanary/GraphContext.kt
new file mode 100644
index 00000000..2df3000e
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphContext.kt
@@ -0,0 +1,25 @@
+package leakcanary
+
+class GraphContext {
+  private val store = mutableMapOf<String, Any>()
+  operator fun <T> get(key: String): T? {
+    @Suppress("UNCHECKED_CAST")
+    return store[key] as T?
+  }
+
+  operator fun <T> set(
+    key: String,
+    value: T
+  ) {
+    store[key] = (value as Any)
+  }
+
+  operator fun contains(key: String): Boolean {
+    return key in store
+  }
+
+  operator fun minusAssign(key: String) {
+    @Suppress("UNCHECKED_CAST")
+    store -= key
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt b/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
index de1dc72c..3638445f 100644
--- a/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
@@ -1,6 +1,14 @@
 package leakcanary
 
 import leakcanary.HeapValue.ObjectReference
+import leakcanary.PrimitiveType.BOOLEAN
+import leakcanary.PrimitiveType.BYTE
+import leakcanary.PrimitiveType.CHAR
+import leakcanary.PrimitiveType.DOUBLE
+import leakcanary.PrimitiveType.FLOAT
+import leakcanary.PrimitiveType.INT
+import leakcanary.PrimitiveType.LONG
+import leakcanary.PrimitiveType.SHORT
 import leakcanary.Record.HeapDumpRecord.ObjectRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
@@ -90,6 +98,10 @@ sealed class GraphObjectRecord {
       }
       return null
     }
+
+    override fun toString(): String {
+      return "record of class $name"
+    }
   }
 
   class GraphInstanceRecord internal constructor(
@@ -201,6 +213,10 @@ sealed class GraphObjectRecord {
         )
       }
     }
+
+    override fun toString(): String {
+      return "instance @$objectId of $className"
+    }
   }
 
   class GraphObjectArrayRecord internal constructor(
@@ -221,6 +237,10 @@ sealed class GraphObjectRecord {
       return readRecord().elementIds.asSequence()
           .map { GraphHeapValue(graph, ObjectReference(it)) }
     }
+
+    override fun toString(): String {
+      return "object array @$objectId of $arrayClassName"
+    }
   }
 
   class GraphPrimitiveArrayRecord internal constructor(
@@ -231,9 +251,25 @@ sealed class GraphObjectRecord {
     val primitiveType: PrimitiveType
       get() = indexedObject.primitiveType
 
+    val arrayClassName: String
+      get() = when (primitiveType) {
+        BOOLEAN -> "boolean[]"
+        CHAR -> "char[]"
+        FLOAT -> "float[]"
+        DOUBLE -> "double[]"
+        BYTE -> "byte[]"
+        SHORT -> "short[]"
+        INT -> "int[]"
+        LONG -> "long[]"
+      }
+
     override fun readRecord(): PrimitiveArrayDumpRecord {
       return graph.readPrimitiveArrayDumpRecord(objectId, indexedObject)
     }
+
+    override fun toString(): String {
+      return "primitive array @$objectId of $arrayClassName"
+    }
   }
 
 }
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
index 71810636..cac15530 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
@@ -39,6 +39,8 @@ class HprofGraph internal constructor(
   private val index: HprofInMemoryIndex
 ) {
 
+  val context = GraphContext()
+
   /**
    * LRU cache size of 3000 is a sweet spot to balance hits vs memory usage.
    * This is based on running InstrumentationLeakDetectorTest a bunch of time on a
@@ -65,19 +67,11 @@ class HprofGraph internal constructor(
   }
 
   fun indexedObject(objectId: Long): GraphObjectRecord {
-    return when (val indexedObject = index.indexedObject(objectId)) {
-      is IndexedClass -> GraphClassRecord(this, indexedObject, objectId)
-      is IndexedInstance -> {
-        val isPrimitiveWrapper = index.primitiveWrapperTypes.contains(indexedObject.classId)
-        GraphInstanceRecord(this, indexedObject, objectId, isPrimitiveWrapper)
-      }
-      is IndexedObjectArray -> {
-        val isPrimitiveWrapperArray =
-          index.primitiveWrapperTypes.contains(indexedObject.arrayClassId)
-        GraphObjectArrayRecord(this, indexedObject, objectId, isPrimitiveWrapperArray)
-      }
-      is IndexedPrimitiveArray -> GraphPrimitiveArrayRecord(this, indexedObject, objectId)
-    }
+    return wrapIndexedObject(index.indexedObject(objectId), objectId)
+  }
+
+  fun objectIdExists(objectId: Long): Boolean {
+    return index.objectIdIsIndexed(objectId)
   }
 
   fun computeShallowSize(graphObject: GraphObjectRecord): Int {
@@ -110,6 +104,13 @@ class HprofGraph internal constructor(
         }
   }
 
+  fun objectSequence(): Sequence<GraphObjectRecord> {
+    return index.indexedObjectSequence()
+        .map {
+          wrapIndexedObject(it.second, it.first)
+        }
+  }
+
   fun classSequence(): Sequence<GraphClassRecord> {
     return index.indexedClassSequence()
         .map {
@@ -196,6 +197,25 @@ class HprofGraph internal constructor(
     return readBlock().apply { objectCache.put(objectId, this) }
   }
 
+  private fun wrapIndexedObject(
+    indexedObject: IndexedObject,
+    objectId: Long
+  ): GraphObjectRecord {
+    return when (indexedObject) {
+      is IndexedClass -> GraphClassRecord(this, indexedObject, objectId)
+      is IndexedInstance -> {
+        val isPrimitiveWrapper = index.primitiveWrapperTypes.contains(indexedObject.classId)
+        GraphInstanceRecord(this, indexedObject, objectId, isPrimitiveWrapper)
+      }
+      is IndexedObjectArray -> {
+        val isPrimitiveWrapperArray =
+          index.primitiveWrapperTypes.contains(indexedObject.arrayClassId)
+        GraphObjectArrayRecord(this, indexedObject, objectId, isPrimitiveWrapperArray)
+      }
+      is IndexedPrimitiveArray -> GraphPrimitiveArrayRecord(this, indexedObject, objectId)
+    }
+  }
+
   companion object {
     fun readHprof(
       heapDump: File,
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt b/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt
index 10b6847f..f0e60cbf 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt
@@ -579,7 +579,6 @@ class HprofPushRecordsParser {
                   skipHeapDumpInfoRecord()
                 }
               }
-
               else -> throw IllegalStateException(
                   "Unknown tag $heapDumpTag after $previousTag"
               )
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt b/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt
index 031e1c9a..b347bf11 100644
--- a/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt
@@ -1,9 +1,11 @@
 package leakcanary.internal
 
+import leakcanary.GcRoot.JniGlobal
 import leakcanary.HprofPushRecordsParser.OnRecordListener
 import leakcanary.HprofReader
 import leakcanary.PrimitiveType
 import leakcanary.Record
+import leakcanary.Record.HeapDumpRecord.GcRootRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
@@ -17,6 +19,8 @@ import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.In
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
 import leakcanary.Record.LoadClassRecord
+import leakcanary.Record.StackFrameRecord
+import leakcanary.Record.StackTraceRecord
 import leakcanary.Record.StringRecord
 import leakcanary.internal.IndexedObject.IndexedClass
 import leakcanary.internal.IndexedObject.IndexedInstance
@@ -66,8 +70,16 @@ internal class HprofInMemoryIndex private constructor(
         .map { it.first to it.second as IndexedInstance }
   }
 
+  fun indexedObjectSequence(): Sequence<Pair<Long, IndexedObject>> {
+    return objectIndex.entrySequence()
+  }
+
   fun indexedObject(objectId: Long): IndexedObject {
-    return objectIndex[objectId]
+    return objectIndex[objectId]!!
+  }
+
+  fun objectIdIsIndexed(objectId: Long): Boolean {
+    return objectIndex[objectId] != null
   }
 
   class Builder : OnRecordListener {
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToObjectSparseArray.kt b/leakcanary-haha/src/main/java/leakcanary/internal/LongToObjectSparseArray.kt
index cf2ff87a..3c36482a 100644
--- a/leakcanary-haha/src/main/java/leakcanary/internal/LongToObjectSparseArray.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/LongToObjectSparseArray.kt
@@ -23,11 +23,11 @@ internal class LongToObjectSparseArray<T>(initialCapacity: Int) : Cloneable {
     size = 0
   }
 
-  operator fun get(key: Long): T {
+  operator fun get(key: Long): T? {
     val i = binarySearch(keys, size, key)
 
     return if (i < 0 || values[i] == null) {
-      throw NullPointerException("Key $key not set")
+      null
     } else {
       values[i]!!
     }
diff --git a/leakcanary-leaksentry/build.gradle b/leakcanary-leaksentry/build.gradle
index dd0f4e90..97ffdfca 100644
--- a/leakcanary-leaksentry/build.gradle
+++ b/leakcanary-leaksentry/build.gradle
@@ -4,10 +4,7 @@ apply plugin: 'kotlin-android'
 dependencies {
   api project(':leakcanary-watcher')
 
-  implementation deps.androidx.core
   implementation deps.kotlin.stdlib
-  // Optional dependency
-  compileOnly deps.androidx.fragment
 }
 
 android {
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
index 62ef6a25..dd2f7d4a 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
@@ -17,15 +17,14 @@
 
 package leakcanary.internal
 
+import android.annotation.SuppressLint
 import android.app.Activity
 import android.app.Fragment
 import android.app.FragmentManager
-import android.os.Build
-import androidx.annotation.RequiresApi
-import leakcanary.RefWatcher
 import leakcanary.LeakSentry.Config
+import leakcanary.RefWatcher
 
-@RequiresApi(Build.VERSION_CODES.O) //
+@SuppressLint("NewApi")
 internal class AndroidOFragmentDestroyWatcher(
   private val refWatcher: RefWatcher,
   private val configProvider: () -> Config
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
index 54976015..9cbe23e9 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
@@ -27,13 +27,15 @@ import leakcanary.internal.InternalHelper.noOpDelegate
 /**
  * Internal class used to watch for fragments leaks.
  */
-internal interface FragmentDestroyWatcher {
+interface FragmentDestroyWatcher {
 
   fun watchFragments(activity: Activity)
 
   companion object {
 
-    private const val SUPPORT_FRAGMENT_CLASS_NAME = "androidx.fragment.app.Fragment"
+    private const val ANDROIDX_FRAGMENT_CLASS_NAME = "androidx.fragment.app.Fragment"
+    private const val ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =
+      "leakcanary.internal.AndroidXFragmentDestroyWatcher"
 
     fun install(
       application: Application,
@@ -48,12 +50,13 @@ internal interface FragmentDestroyWatcher {
         )
       }
 
-      if (classAvailable(
-              SUPPORT_FRAGMENT_CLASS_NAME
-          )
+      if (classAvailable(ANDROIDX_FRAGMENT_CLASS_NAME) &&
+          classAvailable(ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME)
       ) {
+        val watcherConstructor = Class.forName(ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME)
+            .getDeclaredConstructor(RefWatcher::class.java, Function0::class.java)
         fragmentDestroyWatchers.add(
-            SupportFragmentDestroyWatcher(refWatcher, configProvider)
+            watcherConstructor.newInstance(refWatcher, configProvider) as FragmentDestroyWatcher
         )
       }
 
diff --git a/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt b/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
index dde8d61c..7772ce2d 100644
--- a/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
+++ b/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
@@ -28,8 +28,6 @@ class KeyedWeakReference(
 ) : WeakReference<Any>(
     referent, referenceQueue
 ) {
-  val className: String = referent.javaClass.name
-
   /**
    * Compared against [heapDumpUptimeMillis] so that the Hprof Parser knows only to look at
    * instances that were moved to retained, then used to remove weak references post heap dump.
diff --git a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
index 4709d4bb..0cd4e8f1 100644
--- a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
+++ b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
@@ -111,16 +111,10 @@ class RefWatcher constructor(
     val watchUptimeMillis = clock.uptimeMillis()
     val reference =
       KeyedWeakReference(watchedInstance, key, name, watchUptimeMillis, queue)
-    if (name != "") {
-      CanaryLog.d(
-          "Watching instance of %s named %s with key %s", reference.className,
-          name, key
-      )
-    } else {
-      CanaryLog.d(
-          "Watching instance of %s with key %s", reference.className, key
-      )
-    }
+    CanaryLog.d(
+        "Watching %s with key %s",
+        ((if (watchedInstance is Class<*>) watchedInstance.toString() else "instance of ${watchedInstance.javaClass.name}") + if (name.isNotEmpty()) " named $name" else ""), key
+    )
 
     watchedInstances[key] = reference
     checkRetainedExecutor.execute {
@@ -137,11 +131,10 @@ class RefWatcher constructor(
     }
   }
 
-  @Synchronized fun removeInstancesRetainedBeforeHeapDump(heapDumpUptimeMillis: Long) {
-    val retainedBeforeHeapdump =
-      watchedInstances.filter { it.value.retainedUptimeMillis in 0..heapDumpUptimeMillis }
-          .keys
-    watchedInstances.keys.removeAll(retainedBeforeHeapdump)
+  @Synchronized fun removeInstancesWatchedBeforeHeapDump(heapDumpUptimeMillis: Long) {
+    val weakRefsToRemove = watchedInstances.filter { it.value.watchUptimeMillis <= heapDumpUptimeMillis }
+    weakRefsToRemove.values.forEach { it.clear() }
+    watchedInstances.keys.removeAll(weakRefsToRemove.keys)
   }
 
   @Synchronized fun clearWatchedInstances() {
diff --git a/mkdocs.yml b/mkdocs.yml
index 10eede1a..2741caf1 100644
--- a/mkdocs.yml
+++ b/mkdocs.yml
@@ -13,6 +13,7 @@ copyright: 'Copyright &copy; 2015 Square, Inc.'
 
 theme:
   name: 'material'
+  custom_dir: 'docs/theme'
   logo: 'images/logo.png'
   favicon: 'images/logo.png'
   palette:
diff --git a/settings.gradle b/settings.gradle
index 5b1579ed..3fddcaea 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -4,6 +4,7 @@ include ':leakcanary-android-core'
 include ':leakcanary-android-instrumentation'
 include ':leakcanary-android-process'
 include ':leakcanary-cli'
+include ':leakcanary-fragments-androidx'
 include ':leakcanary-haha'
 include ':leakcanary-leaksentry'
 include ':leakcanary-log'
