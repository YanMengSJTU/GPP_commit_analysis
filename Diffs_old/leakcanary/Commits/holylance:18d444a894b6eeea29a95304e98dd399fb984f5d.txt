diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
index 26c22646..442b6f4d 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
@@ -35,11 +35,6 @@ sealed class RetainedInstance : Serializable {
    * enable you to figure out the cause of the leak, if any.
    */
   abstract val referenceKey: String
-}
-
-data class WeakReferenceMissing(override val referenceKey: String) : RetainedInstance()
-
-sealed class WeakReferenceFound : RetainedInstance() {
   /**
    * User defined name to help identify the retained instance.
    */
@@ -49,29 +44,31 @@ sealed class WeakReferenceFound : RetainedInstance() {
    * The class name format is the same as what would be returned by [Class.getName].
    */
   abstract val instanceClassName: String
-  /** Time from the request to watch the reference until the GC was triggered.  */
+  /**
+   * Time from the request to watch the reference until the heap was dumped.
+   */
   abstract val watchDurationMillis: Long
+  /**
+   * Time from when the instance was considered retained until the heap was dumped.
+   */
+  abstract val retainedDurationMillis: Long
 }
 
-data class WeakReferenceCleared(
-  override val referenceKey: String,
-  override val referenceName: String,
-  override val instanceClassName: String,
-  override val watchDurationMillis: Long
-) : WeakReferenceFound()
-
 data class NoPathToInstance(
   override val referenceKey: String,
   override val referenceName: String,
   override val instanceClassName: String,
-  override val watchDurationMillis: Long
-) : WeakReferenceFound()
+  override val watchDurationMillis: Long,
+  override val retainedDurationMillis: Long
+) : RetainedInstance()
 
 data class LeakingInstance(
   override val referenceKey: String,
   override val referenceName: String,
   override val instanceClassName: String,
   override val watchDurationMillis: Long,
+  override val retainedDurationMillis: Long,
+
   /**
    * True if the only path to the leaking reference is through excluded references. Usually, that
    * means you can safely ignore this report.
@@ -87,10 +84,16 @@ data class LeakingInstance(
    */
   val retainedHeapSize: Int?
 
-) : WeakReferenceFound() {
+) : RetainedInstance() {
 
   val groupHash = createGroupHash()
 
+  val instanceClassSimpleName: String
+    get() {
+      val separator = instanceClassName.lastIndexOf('.')
+      return if (separator == -1) instanceClassName else instanceClassName.substring(separator + 1)
+    }
+
   private fun createGroupHash(): String {
     val uniqueString = if (exclusionStatus == WONT_FIX_LEAK) {
       leakTrace.firstElementExclusion.matching
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
index 1168e02e..01ac5e29 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
@@ -18,7 +18,6 @@ package leakcanary
 import leakcanary.AnalyzerProgressListener.Step.BUILDING_LEAK_TRACES
 import leakcanary.AnalyzerProgressListener.Step.COMPUTING_NATIVE_RETAINED_SIZE
 import leakcanary.AnalyzerProgressListener.Step.COMPUTING_RETAINED_SIZE
-import leakcanary.AnalyzerProgressListener.Step.FINDING_LEAKING_REFS
 import leakcanary.AnalyzerProgressListener.Step.FINDING_WATCHED_REFERENCES
 import leakcanary.AnalyzerProgressListener.Step.READING_HEAP_DUMP_FILE
 import leakcanary.AnalyzerProgressListener.Step.SCANNING_HEAP_DUMP
@@ -32,7 +31,6 @@ import leakcanary.GcRoot.ReferenceCleanup
 import leakcanary.GcRoot.StickyClass
 import leakcanary.GcRoot.ThreadBlock
 import leakcanary.GcRoot.ThreadObject
-import leakcanary.HeapValue.ObjectReference
 import leakcanary.HprofParser.RecordCallbacks
 import leakcanary.LeakNode.ChildNode
 import leakcanary.LeakNodeStatus.LEAKING
@@ -42,7 +40,6 @@ import leakcanary.LeakTraceElement.Holder.ARRAY
 import leakcanary.LeakTraceElement.Holder.CLASS
 import leakcanary.LeakTraceElement.Holder.OBJECT
 import leakcanary.LeakTraceElement.Holder.THREAD
-import leakcanary.ObjectIdMetadata.STRING
 import leakcanary.Record.HeapDumpRecord.GcRootRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
@@ -107,27 +104,20 @@ class HeapAnalyzer constructor(
             )
             val analysisResults = mutableMapOf<String, RetainedInstance>()
             listener.onProgressUpdate(FINDING_WATCHED_REFERENCES)
-            val (retainedKeys, heapDumpUptimeMillis) = readHeapDumpMemoryStore(
-                parser, keyedWeakReferenceInstances
-            )
 
-            if (retainedKeys.isEmpty()) {
-              val exception = IllegalStateException("No retained keys found in heap dump")
+            val retainedWeakRefs = findLeakingReferences(parser, keyedWeakReferenceInstances)
+
+            if (retainedWeakRefs.isEmpty()) {
+              val exception = IllegalStateException("No retained instances found in heap dump")
               return HeapAnalysisFailure(
                   heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
                   HeapAnalysisException(exception)
               )
             }
 
-            val leakingWeakRefs =
-              findLeakingReferences(
-                  parser, retainedKeys, analysisResults, keyedWeakReferenceInstances,
-                  heapDumpUptimeMillis
-              )
-
             val (pathResults, dominatedInstances) =
               findShortestPaths(
-                  parser, exclusionsFactory, leakingWeakRefs, gcRootIds,
+                  parser, exclusionsFactory, retainedWeakRefs, gcRootIds,
                   computeRetainedHeapSize
               )
 
@@ -139,10 +129,10 @@ class HeapAnalyzer constructor(
 
             buildLeakTraces(
                 reachabilityInspectors, labelers, pathResults, parser,
-                leakingWeakRefs, analysisResults, retainedSizes
+                retainedWeakRefs, analysisResults, retainedSizes
             )
 
-            addRemainingInstancesWithNoPath(parser, leakingWeakRefs, analysisResults)
+            addRemainingInstancesWithNoPath(retainedWeakRefs, analysisResults)
 
             return HeapAnalysisSuccess(
                 heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
@@ -207,77 +197,38 @@ class HeapAnalyzer constructor(
     return ScanResult(gcRoot, keyedWeakReferenceInstances, cleaners)
   }
 
-  private fun readHeapDumpMemoryStore(
+  private fun findLeakingReferences(
     parser: HprofParser,
     keyedWeakReferenceInstances: List<InstanceDumpRecord>
-  ): Pair<MutableSet<Long>, Long> = with(parser) {
-    val heapDumpMemoryStoreClassId = parser.classId(HeapDumpMemoryStore::class.java.name)
-
-    // Pre 2.0 had no HeapDumpMemoryStore, so instead we look for all KeyedWeakReference instances
-    if (heapDumpMemoryStoreClassId == null) {
-      val leakingWeakRefs = mutableListOf<KeyedWeakReferenceMirror>()
-      keyedWeakReferenceInstances.forEach { record ->
-        val weakRef =
-          KeyedWeakReferenceMirror.fromInstance(parser.hydrateInstance(record), 0)
-        if (weakRef.hasReferent) {
-          leakingWeakRefs.add(weakRef)
-        }
-      }
+  ): MutableList<KeyedWeakReferenceMirror> {
 
-      val retainedKeysForHeapDump = leakingWeakRefs.map { it.key.value }
-          .toMutableSet()
-      val heapDumpUptimeMillis = 0L
-      return retainedKeysForHeapDump to heapDumpUptimeMillis
-    } else {
-      val storeClass = parser.hydrateClassHierarchy(heapDumpMemoryStoreClassId)[0]
-      val retainedKeysRecord =
-        storeClass["retainedKeysForHeapDump"].reference!!.objectRecord as ObjectArrayDumpRecord
+    val keyedWeakReferenceClassId = parser.classId(KeyedWeakReference::class.java.name)
 
-      val retainedKeysForHeapDump = retainedKeysRecord.elementIds.toMutableSet()
-      val heapDumpUptimeMillis = storeClass["heapDumpUptimeMillis"].long!!
-      return retainedKeysForHeapDump to heapDumpUptimeMillis
+    val heapDumpUptimeMillis = if (keyedWeakReferenceClassId == null) {
+      null
+    } else {
+      val keyedWeakReferenceClass = parser.hydrateClassHierarchy(keyedWeakReferenceClassId)[0]
+      keyedWeakReferenceClass["heapDumpUptimeMillis"].long
     }
-  }
 
-  private fun findLeakingReferences(
-    parser: HprofParser,
-    retainedKeys: MutableSet<Long>,
-    analysisResults: MutableMap<String, RetainedInstance>,
-    keyedWeakReferenceInstances: List<InstanceDumpRecord>,
-    heapDumpUptimeMillis: Long
-  ): MutableList<KeyedWeakReferenceMirror> {
-    listener.onProgressUpdate(FINDING_LEAKING_REFS)
-
-    val leakingWeakRefs = mutableListOf<KeyedWeakReferenceMirror>()
+    if (heapDumpUptimeMillis == null) {
+      CanaryLog.d(
+          "${KeyedWeakReference::class.java.name}.heapDumpUptimeMillis field not found, " +
+              "this must be a heap dump from an older version of LeakCanary."
+      )
+    }
 
+    val retainedInstances = mutableListOf<KeyedWeakReferenceMirror>()
     keyedWeakReferenceInstances.forEach { record ->
       val weakRef =
-        KeyedWeakReferenceMirror.fromInstance(parser.hydrateInstance(record), heapDumpUptimeMillis)
-      val wasRetained = retainedKeys.remove(weakRef.key.value)
-      if (wasRetained) {
-        if (weakRef.hasReferent) {
-          leakingWeakRefs.add(weakRef)
-        } else {
-          val key = parser.retrieveString(weakRef.key)
-          val name =
-            if (weakRef.name != null) parser.retrieveString(weakRef.name) else UNKNOWN_LEGACY
-          val className =
-            if (weakRef.className != null) parser.retrieveString(
-                weakRef.className
-            ) else UNKNOWN_LEGACY
-          val noLeak = WeakReferenceCleared(key, name, className, weakRef.watchDurationMillis)
-          analysisResults[key] = noLeak
-        }
+        KeyedWeakReferenceMirror.fromInstance(
+            parser, parser.hydrateInstance(record), heapDumpUptimeMillis
+        )
+      if (weakRef.isRetained && weakRef.hasReferent) {
+        retainedInstances.add(weakRef)
       }
     }
-    retainedKeys.forEach { referenceKeyId ->
-      // This could happen if RefWatcher removed weakly reachable references after providing
-      // the set of retained keys
-      val referenceKey = parser.retrieveStringById(referenceKeyId)
-      val noLeak = WeakReferenceMissing(referenceKey)
-      analysisResults[referenceKey] = noLeak
-    }
-    return leakingWeakRefs
+    return retainedInstances
   }
 
   private fun findShortestPaths(
@@ -439,35 +390,31 @@ class HeapAnalyzer constructor(
       val instanceClassName =
         recordClassName(parser.retrieveRecordById(pathResult.leakingNode.instance), parser)
 
-      val key = parser.retrieveString(weakReference.key)
       val leakDetected = LeakingInstance(
-          referenceKey = key,
-          referenceName = if (weakReference.name != null) parser.retrieveString(
-              weakReference.name
-          ) else UNKNOWN_LEGACY,
+          referenceKey = weakReference.key,
+          referenceName = weakReference.name,
           instanceClassName = instanceClassName,
           watchDurationMillis = weakReference.watchDurationMillis,
+          retainedDurationMillis = weakReference.retainedDurationMillis ?: 0,
           exclusionStatus = pathResult.exclusionStatus, leakTrace = leakTrace,
           retainedHeapSize = retainedSizes?.get(index)
       )
-      analysisResults[key] = leakDetected
+      analysisResults[weakReference.key] = leakDetected
     }
   }
 
   private fun addRemainingInstancesWithNoPath(
-    parser: HprofParser,
     leakingWeakRefs: List<KeyedWeakReferenceMirror>,
     analysisResults: MutableMap<String, RetainedInstance>
   ) {
     leakingWeakRefs.forEach { refWithNoPath ->
-      val key = parser.retrieveString(refWithNoPath.key)
-      val name = if (refWithNoPath.name != null) parser.retrieveString(
-          refWithNoPath.name
-      ) else UNKNOWN_LEGACY
-      val className = if (refWithNoPath.className != null) parser.retrieveString(
-          refWithNoPath.className
-      ) else UNKNOWN_LEGACY
-      val noLeak = NoPathToInstance(key, name, className, refWithNoPath.watchDurationMillis)
+      val key = refWithNoPath.key
+      val name = refWithNoPath.name
+      val className = refWithNoPath.className
+      val noLeak = NoPathToInstance(
+          key, name, className, refWithNoPath.watchDurationMillis,
+          refWithNoPath.retainedDurationMillis ?: 0
+      )
       analysisResults[key] = noLeak
     }
   }
@@ -675,7 +622,6 @@ class HeapAnalyzer constructor(
   }
 
   companion object {
-    private const val UNKNOWN_LEGACY = "Unknown (legacy)"
     private const val ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$"
     internal val ANONYMOUS_CLASS_NAME_PATTERN_REGEX = ANONYMOUS_CLASS_NAME_PATTERN.toRegex()
   }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapDumpMemoryStore.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapDumpMemoryStore.kt
deleted file mode 100644
index b699ad74..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapDumpMemoryStore.kt
+++ /dev/null
@@ -1,16 +0,0 @@
-package leakcanary
-
-object HeapDumpMemoryStore {
-
-  @Volatile
-  @JvmStatic var retainedKeysForHeapDump: Array<String>? = null
-    private set
-
-  @Volatile
-  @JvmStatic var heapDumpUptimeMillis: Long = 0
-
-  @JvmStatic fun setRetainedKeysForHeapDump(retainedKeys: Set<String>) {
-    retainedKeysForHeapDump = retainedKeys.toTypedArray()
-  }
-
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
index ed9d9b38..fa97567b 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
@@ -2,36 +2,63 @@ package leakcanary.internal
 
 import leakcanary.HeapValue.LongValue
 import leakcanary.HeapValue.ObjectReference
+import leakcanary.HprofParser
 import leakcanary.HydratedInstance
 
 internal class KeyedWeakReferenceMirror(
-  val key: ObjectReference,
-    // The className field does not exist in pre 1.0 heap dumps.
-  val name: ObjectReference?,
-    // The className field does not exist in pre 2.0 heap dumps.
-  val className: ObjectReference?,
+  val referent: ObjectReference,
+  val key: String,
+    // The name field does not exist in pre 1.0 heap dumps.
+  val name: String,
+  // 0 in pre 2.0 alpha 3 heap dumps
   val watchDurationMillis: Long,
-  val referent: ObjectReference
+    // The className field does not exist in pre 2.0 heap dumps.
+  val className: String,
+    // null in pre 2.0 alpha 3 heap dumps, -1 if the instance is not retained.
+  val retainedDurationMillis: Long?
 ) {
 
   val hasReferent = referent.value != 0L
 
+  val isRetained = retainedDurationMillis == null || retainedDurationMillis != -1L
+
   companion object {
+
+    private const val UNKNOWN_LEGACY = "Unknown (legacy)"
+
     fun fromInstance(
+      parser: HprofParser,
       weakRef: HydratedInstance,
-      heapDumpUptimeMillis: Long
+      // Null for pre 2.0 alpha 3 heap dumps
+      heapDumpUptimeMillis: Long?
     ): KeyedWeakReferenceMirror {
-      // The watchUptimeMillis field does not exist in pre 2.0 heap dumps.
-      val watchUptimeMillis = weakRef.fieldValueOrNull<LongValue>(
-          "watchUptimeMillis"
-      )
-          ?.value ?: 0
+
+      val watchDurationMillis = if (heapDumpUptimeMillis != null)
+        heapDumpUptimeMillis - weakRef.fieldValue<LongValue>("watchUptimeMillis").value
+      else 0L
+
+      val retainedDurationMillis = if (heapDumpUptimeMillis != null) {
+        val retainedUptimeMillis = weakRef.fieldValue<LongValue>("retainedUptimeMillis")
+            .value
+        if (retainedUptimeMillis == -1L) -1L else heapDumpUptimeMillis - retainedUptimeMillis
+      } else null
+
+      val key = weakRef.fieldValue<ObjectReference>("key")
+      val keyString = parser.retrieveString(key)
+
+      val name = weakRef.fieldValueOrNull<ObjectReference>("name")
+      val nameString = if (name != null) parser.retrieveString(name) else UNKNOWN_LEGACY
+      val className = weakRef.fieldValueOrNull<ObjectReference>("className")
+      val classNameString =
+        if (className != null) parser.retrieveString(className) else UNKNOWN_LEGACY
+
       return KeyedWeakReferenceMirror(
-          key = weakRef.fieldValue("key"),
-          name = weakRef.fieldValueOrNull("name"),
-          className = weakRef.fieldValueOrNull("className"),
-          watchDurationMillis = heapDumpUptimeMillis - watchUptimeMillis,
-          referent = weakRef.fieldValue("referent")
+          watchDurationMillis = watchDurationMillis,
+          retainedDurationMillis = retainedDurationMillis,
+          referent = weakRef.fieldValue("referent"),
+          key = keyString,
+          name = nameString,
+          className = classNameString
       )
     }
   }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/Strings.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/Strings.kt
index a7e5f753..366f852f 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/Strings.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/Strings.kt
@@ -5,14 +5,14 @@ import java.security.MessageDigest
 import java.security.NoSuchAlgorithmException
 
 @JvmField
-val UTF_8: Charset = Charset.forName("UTF-8")
+internal val UTF_8: Charset = Charset.forName("UTF-8")
 
-fun String.lastSegment(segmentingChar: Char): String {
+internal fun String.lastSegment(segmentingChar: Char): String {
   val separator = lastIndexOf(segmentingChar)
   return if (separator == -1) this else this.substring(separator + 1)
 }
 
-fun String.createSHA1Hash(): String = createHash(this, "SHA-1")
+internal fun String.createSHA1Hash(): String = createHash(this, "SHA-1")
 
 /**
  * Derived from
@@ -40,4 +40,4 @@ private fun createHash(
 }
 
 /** Gets the string as an array of UTF-8 bytes. */
-fun String.getBytes(): ByteArray = toByteArray(UTF_8)
+internal fun String.getBytes(): ByteArray = toByteArray(UTF_8)
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
index 75b9c6d7..4665e516 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
@@ -8,7 +8,6 @@ import leakcanary.HeapValue.ObjectReference
 import leakcanary.LeakTraceElement.Type.LOCAL
 import leakcanary.LeakingInstance
 import leakcanary.NoPathToInstance
-import leakcanary.WeakReferenceCleared
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
@@ -80,9 +79,9 @@ class HeapAnalyzerTest {
   @Test fun weakRefCleared() {
     hprofFile.writeWeakReferenceCleared()
 
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
-
-    assertThat(analysis.retainedInstances[0]).isInstanceOf(WeakReferenceCleared::class.java)
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisFailure>()
+    assertThat(analysis.exception.cause).isInstanceOf(IllegalStateException::class.java)
+        .hasMessage("No retained instances found in heap dump")
   }
 
   @Test fun failsNoRetainedKeys() {
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
index 385113ea..7b0b0f0b 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
@@ -2,7 +2,6 @@ package leakcanary.internal
 
 import leakcanary.GcRoot
 import leakcanary.GcRoot.StickyClass
-import leakcanary.HeapDumpMemoryStore
 import leakcanary.HeapValue
 import leakcanary.HeapValue.BooleanValue
 import leakcanary.HeapValue.ByteValue
@@ -51,8 +50,6 @@ class HprofWriterHelper constructor(
       HprofReader.LONG_TYPE to HprofReader.LONG_SIZE
   )
 
-  private val weakRefKeys = mutableSetOf<Long>()
-
   private val classDumps = mutableMapOf<Long, ClassDumpRecord>()
 
   private val objectClassId = clazz(superClassId = 0, className = "java.lang.Object")
@@ -72,11 +69,13 @@ class HprofWriterHelper constructor(
   private val keyedWeakReferenceClassId = clazz(
       superClassId = weakReferenceClassId,
       className = "leakcanary.KeyedWeakReference",
+      staticFields = listOf("heapDumpUptimeMillis" to LongValue(Long.MAX_VALUE)),
       fields = listOf(
           "key" to ObjectReference::class,
           "name" to ObjectReference::class,
           "className" to ObjectReference::class,
-          "watchUptimeMillis" to LongValue::class
+          "watchUptimeMillis" to LongValue::class,
+          "retainedUptimeMillis" to LongValue::class
       )
   )
 
@@ -156,7 +155,6 @@ class HprofWriterHelper constructor(
     referentInstanceId: ObjectReference
   ): ObjectReference {
     val referenceKey = string(UUID.randomUUID().toString())
-    weakRefKeys.add(referenceKey.value)
     return instance(
         classId = keyedWeakReferenceClassId,
         fields = listOf(
@@ -164,6 +162,7 @@ class HprofWriterHelper constructor(
             string(""),
             string(className),
             LongValue(System.currentTimeMillis()),
+            LongValue(System.currentTimeMillis()),
             ObjectReference(referentInstanceId.value)
         )
     )
@@ -286,16 +285,6 @@ class HprofWriterHelper constructor(
   }
 
   override fun close() {
-    val elementIds = weakRefKeys.toLongArray()
-    val weakRefKeysArray = ObjectArrayDumpRecord(id, 1, stringClassId, elementIds)
-    writer.write(weakRefKeysArray)
-    clazz(
-        className = HeapDumpMemoryStore::class.java.name,
-        staticFields = listOf(
-            "retainedKeysForHeapDump" to ObjectReference(weakRefKeysArray.id),
-            "heapDumpUptimeMillis" to LongValue(System.currentTimeMillis())
-        )
-    )
     writer.close()
   }
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
index ab5d9fd5..8f3177f8 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -9,7 +9,7 @@ import android.os.SystemClock
 import com.squareup.leakcanary.core.R
 import leakcanary.CanaryLog
 import leakcanary.GcTrigger
-import leakcanary.HeapDumpMemoryStore
+import leakcanary.KeyedWeakReference
 import leakcanary.LeakCanary.Config
 import leakcanary.LeakSentry
 import leakcanary.RefWatcher
@@ -71,12 +71,12 @@ internal class HeapDumpTrigger(
       return
     }
 
-    var retainedKeys = refWatcher.retainedKeys
+    var retainedReferenceCount = refWatcher.retainedReferenceCount
 
-    if (checkRetainedCount(retainedKeys, config.retainedVisibleThreshold)) return
+    if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return
 
     if (!config.dumpHeapWhenDebugging && DebuggerControl.isDebuggerAttached) {
-      showRetainedCountWithDebuggerAttached(retainedKeys.size)
+      showRetainedCountWithDebuggerAttached(retainedReferenceCount)
       scheduleRetainedInstanceCheck("debugger was attached", WAIT_FOR_DEBUG_MILLIS)
       CanaryLog.d(
           "Not checking for leaks while the debugger is attached, will retry in %d ms",
@@ -87,24 +87,23 @@ internal class HeapDumpTrigger(
 
     gcTrigger.runGc()
 
-    retainedKeys = refWatcher.retainedKeys
+    retainedReferenceCount = refWatcher.retainedReferenceCount
 
-    if (checkRetainedCount(retainedKeys, config.retainedVisibleThreshold)) return
+    if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return
 
-    HeapDumpMemoryStore.setRetainedKeysForHeapDump(retainedKeys)
-
-    CanaryLog.d("Found %d retained references, dumping the heap", retainedKeys.size)
-    HeapDumpMemoryStore.heapDumpUptimeMillis = SystemClock.uptimeMillis()
+    CanaryLog.d("Found %d retained references, dumping the heap", retainedReferenceCount)
+    val heapDumpUptimeMillis = SystemClock.uptimeMillis()
+    KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis
     dismissNotification()
     val heapDumpFile = heapDumper.dumpHeap()
     if (heapDumpFile == null) {
       CanaryLog.d("Failed to dump heap, will retry in %d ms", WAIT_AFTER_DUMP_FAILED_MILLIS)
       scheduleRetainedInstanceCheck("failed to dump heap", WAIT_AFTER_DUMP_FAILED_MILLIS)
-      showRetainedCountWithHeapDumpFailed(retainedKeys.size)
+      showRetainedCountWithHeapDumpFailed(retainedReferenceCount)
       return
     }
 
-    refWatcher.removeRetainedKeys(retainedKeys)
+    refWatcher.removeKeysRetainedBeforeHeapDump(heapDumpUptimeMillis)
 
     HeapAnalyzerService.runAnalysis(application, heapDumpFile)
   }
@@ -112,8 +111,8 @@ internal class HeapDumpTrigger(
   fun onDumpHeapReceived() {
     backgroundHandler.post {
       gcTrigger.runGc()
-      val retainedKeys = refWatcher.retainedKeys
-      if (retainedKeys.isEmpty()) {
+      val retainedReferenceCount = refWatcher.retainedReferenceCount
+      if (retainedReferenceCount == 0) {
         CanaryLog.d("No retained instances after GC")
         val builder = Notification.Builder(application)
             .setContentTitle(
@@ -132,40 +131,40 @@ internal class HeapDumpTrigger(
         return@post
       }
 
-      HeapDumpMemoryStore.setRetainedKeysForHeapDump(retainedKeys)
-
+      val heapDumpUptimeMillis = SystemClock.uptimeMillis()
+      KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis
       CanaryLog.d("Dumping the heap because user tapped notification")
 
       val heapDumpFile = heapDumper.dumpHeap()
       if (heapDumpFile == null) {
         CanaryLog.d("Failed to dump heap")
-        showRetainedCountWithHeapDumpFailed(retainedKeys.size)
+        showRetainedCountWithHeapDumpFailed(retainedReferenceCount)
         return@post
       }
 
-      refWatcher.removeRetainedKeys(retainedKeys)
+      refWatcher.removeKeysRetainedBeforeHeapDump(heapDumpUptimeMillis)
       HeapAnalyzerService.runAnalysis(application, heapDumpFile)
     }
   }
 
   private fun checkRetainedCount(
-    retainedKeys: Set<String>,
+    retainedKeysCount: Int,
     retainedVisibleThreshold: Int
   ): Boolean {
-    if (retainedKeys.isEmpty()) {
+    if (retainedKeysCount == 0) {
       CanaryLog.d("No retained instances")
       dismissNotification()
       return true
     }
 
-    if (retainedKeys.size < retainedVisibleThreshold) {
+    if (retainedKeysCount < retainedVisibleThreshold) {
       if (applicationVisible || applicationInvisibleLessThanWatchPeriod) {
         CanaryLog.d(
             "Found %d retained instances, which is less than the visible threshold of %d",
-            retainedKeys.size,
+            retainedKeysCount,
             retainedVisibleThreshold
         )
-        showRetainedCountBelowThresholdNotification(retainedKeys.size, retainedVisibleThreshold)
+        showRetainedCountBelowThresholdNotification(retainedKeysCount, retainedVisibleThreshold)
         scheduleRetainedInstanceCheck(
             "Showing retained instance notification", WAIT_FOR_INSTANCE_THRESHOLD_MILLIS
         )
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
index d5d67d06..fdbaac68 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
@@ -9,7 +9,6 @@ import leakcanary.LeakTraceElement
 import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
 import leakcanary.LeakingInstance
 import leakcanary.Serializables
-import leakcanary.internal.lastSegment
 import leakcanary.internal.utils.to
 import leakcanary.toByteArray
 import org.intellij.lang.annotations.Language
@@ -47,7 +46,7 @@ internal object LeakingInstanceTable {
     values.put("heap_analysis_id", heapAnalysisId)
     values.put("group_hash", leakingInstance.groupHash)
     values.put("group_description", leakingInstance.createGroupDescription())
-    values.put("class_simple_name", leakingInstance.instanceClassName.lastSegment('.'))
+    values.put("class_simple_name", leakingInstance.instanceClassSimpleName)
     values.put("object", leakingInstance.toByteArray())
     values.put("exclusion_status", leakingInstance.exclusionStatus?.ordinal ?: -1)
     return db.insertOrThrow("leaking_instance", null, values)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
index cc63c5ad..3d0b3d1f 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
@@ -25,7 +25,7 @@ internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
   }
 
   companion object {
-    // Last updated for 2.0-alpha-2
-    private const val VERSION = 9
+    // Last updated for 2.0-alpha-3
+    private const val VERSION = 10
   }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
index 60f4575a..b1aa79a0 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
@@ -6,14 +6,11 @@ import android.view.ViewGroup
 import android.widget.ListView
 import android.widget.TextView
 import com.squareup.leakcanary.core.R
-import leakcanary.Exclusion
 import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.Exclusion.Status.WONT_FIX_LEAK
 import leakcanary.HeapAnalysisSuccess
 import leakcanary.LeakingInstance
 import leakcanary.NoPathToInstance
-import leakcanary.WeakReferenceCleared
-import leakcanary.WeakReferenceMissing
 import leakcanary.internal.activity.db.HeapAnalysisTable
 import leakcanary.internal.activity.db.LeakingInstanceTable
 import leakcanary.internal.activity.db.LeakingInstanceTable.HeapAnalysisGroupProjection
@@ -89,9 +86,7 @@ internal class HeapAnalysisSuccessScreen(
 
     val retainedInstances = heapAnalysis.retainedInstances
 
-    var weakReferenceClearedCount = 0
     var noPathToInstanceCount = 0
-    var weakReferenceMissingCount = 0
     retainedInstances.forEach { retainedInstance ->
       when (retainedInstance) {
         is LeakingInstance -> {
@@ -101,15 +96,9 @@ internal class HeapAnalysisSuccessScreen(
             )
           }
         }
-        is WeakReferenceCleared -> {
-          weakReferenceClearedCount++
-        }
         is NoPathToInstance -> {
           noPathToInstanceCount++
         }
-        is WeakReferenceMissing -> {
-          weakReferenceMissingCount++
-        }
       }
     }
 
@@ -151,15 +140,6 @@ internal class HeapAnalysisSuccessScreen(
       titleText to timeText
     })
 
-    if (weakReferenceClearedCount > 0) {
-      rowList.add(
-          resources.getString(
-              R.string.leak_canary_heap_analysis_success_screen_weak_reference_cleared_count,
-              weakReferenceClearedCount
-          ) to ""
-      )
-    }
-
     if (noPathToInstanceCount > 0) {
       rowList.add(
           resources.getString(
@@ -169,16 +149,6 @@ internal class HeapAnalysisSuccessScreen(
       )
     }
 
-    if (weakReferenceMissingCount > 0) {
-      rowList.add(
-          resources.getString(
-              R.string.leak_canary_heap_analysis_success_screen_garbage_collected_weak_references,
-              weakReferenceMissingCount
-          ) to ""
-      )
-    }
-
-
     listView.adapter =
       SimpleListAdapter(R.layout.leak_canary_leak_row, rowList) { view, position ->
         val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
index b781bbe8..673fdfec 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
@@ -12,7 +12,6 @@ import leakcanary.internal.activity.screen.LeakingInstanceScreen.InstanceOrId.Id
 import leakcanary.internal.activity.screen.LeakingInstanceScreen.InstanceOrId.Instance
 import leakcanary.internal.activity.share
 import leakcanary.internal.activity.shareToStackOverflow
-import leakcanary.internal.lastSegment
 import leakcanary.internal.navigation.Screen
 import leakcanary.internal.navigation.activity
 import leakcanary.internal.navigation.goTo
@@ -63,7 +62,7 @@ internal class LeakingInstanceScreen private constructor(
     heapAnalysisId: Long,
     leakingInstance: LeakingInstance
   ) {
-    val classSimpleName = leakingInstance.instanceClassName.lastSegment('.')
+    val classSimpleName = leakingInstance.instanceClassSimpleName
     activity.title =
       resources.getString(R.string.leak_canary_class_has_leaked, classSimpleName)
 
diff --git a/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
index e1d7b778..47782581 100644
--- a/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
+++ b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
@@ -70,9 +70,7 @@
   <string name="leak_canary_options_menu_import_hprof_file">Hprof Datei importieren &amp; analysieren</string>
   <string name="leak_canary_options_menu_see_analysis_list">Siehe Analyse-Liste</string>
   <string name="leak_canary_options_menu_render_heap_dump">Heap Dump rendern</string>
-  <string name="leak_canary_heap_analysis_success_screen_weak_reference_cleared_count">%d bereits aufgelöste schwache Referenzen</string>
   <string name="leak_canary_heap_analysis_success_screen_no_path_to_instance_count">%d erhaltene Instanzen ohne Leaks</string>
-  <string name="leak_canary_heap_analysis_success_screen_garbage_collected_weak_references">%d aufgeräumte schwache Referenzen</string>
   <string name="leak_canary_help_title">Tippe hier, um mehr zu erfahren</string>
   <string name="leak_canary_help_detail"><![CDATA[Ein Memory-Leak ist ein Programmierfehler der
     dafür sorgt, dass deine Anwendung eine Referenz auf ein Objekt hält, das nicht länger benötigt
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
index 8787cb4a..6b6026cc 100644
--- a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
@@ -82,9 +82,7 @@
   <string name="leak_canary_options_menu_import_hprof_file">Import &amp; Analyze Hprof File</string>
   <string name="leak_canary_options_menu_see_analysis_list">See Analysis List</string>
   <string name="leak_canary_options_menu_render_heap_dump">Render Heap Dump</string>
-  <string name="leak_canary_heap_analysis_success_screen_weak_reference_cleared_count">%d already cleared weak references</string>
   <string name="leak_canary_heap_analysis_success_screen_no_path_to_instance_count">%d non leaking retained instances</string>
-  <string name="leak_canary_heap_analysis_success_screen_garbage_collected_weak_references">%d garbage collected weak references</string>
   <string name="leak_canary_help_title">Tap here to learn more</string>
   <string name="leak_canary_help_detail"><![CDATA[A memory leak is a programming error that causes
   your application to keep a reference to an object that is no longer needed. As a result, the
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/AnalysisBenchmarkTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/AnalysisBenchmarkTest.kt
deleted file mode 100644
index 10947dc2..00000000
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/AnalysisBenchmarkTest.kt
+++ /dev/null
@@ -1,61 +0,0 @@
-package leakcanary
-
-import android.os.Debug
-import android.os.SystemClock
-import androidx.benchmark.BenchmarkRule
-import androidx.benchmark.measureRepeated
-import androidx.test.platform.app.InstrumentationRegistry
-import org.junit.Ignore
-import org.junit.Rule
-import org.junit.Test
-import java.io.File
-import java.util.Date
-import java.util.concurrent.Executor
-
-@Ignore
-class AnalysisBenchmarkTest {
-
-  @get:Rule
-  val benchmarkRule = BenchmarkRule()
-
-  @Test fun benchmarkAnalysis() {
-    leaking = Date()
-
-    val clock = object : Clock {
-      override fun uptimeMillis(): Long {
-        return SystemClock.uptimeMillis()
-      }
-    }
-    val executor = Executor { command -> command.run() }
-    val onReferenceRetained = {}
-    val refWatcher = RefWatcher(clock, executor, onReferenceRetained)
-    refWatcher.watch(leaking)
-
-    val instrumentation = InstrumentationRegistry.getInstrumentation()
-    val context = instrumentation.targetContext
-
-    val heapDumpFile = File(context.filesDir, "HeapAnalyzerComparisonTest.hprof")
-
-    val retainedKeys = refWatcher.retainedKeys
-    HeapDumpMemoryStore.setRetainedKeysForHeapDump(retainedKeys)
-    HeapDumpMemoryStore.heapDumpUptimeMillis = SystemClock.uptimeMillis()
-
-    Debug.dumpHprofData(heapDumpFile.absolutePath)
-
-    val config = LeakCanary.config
-    val heapAnalyzer = HeapAnalyzer(AnalyzerProgressListener.NONE)
-
-
-    benchmarkRule.measureRepeated {
-      val analysis = heapAnalyzer.checkForLeaks(
-          heapDumpFile, config.exclusionsFactory, true, config.leakInspectors, config.labelers
-      ) as HeapAnalysisSuccess
-      require(analysis.retainedInstances.size == 1)
-      require(analysis.retainedInstances[0] is LeakingInstance)
-    }
-  }
-
-  companion object {
-    private lateinit var leaking: Any
-  }
-}
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
index d2b126d5..a38a6dd5 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
@@ -152,10 +152,8 @@ class InstrumentationLeakDetector {
 
     val config = LeakCanary.config
 
-    val retainedKeys = refWatcher.retainedKeys
-    HeapDumpMemoryStore.setRetainedKeysForHeapDump(retainedKeys)
-    HeapDumpMemoryStore.heapDumpUptimeMillis = SystemClock.uptimeMillis()
-
+    val heapDumpUptimeMillis = SystemClock.uptimeMillis()
+    KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis
 
     try {
       Debug.dumpHprofData(heapDumpFile.absolutePath)
@@ -170,7 +168,7 @@ class InstrumentationLeakDetector {
       )
     }
 
-    refWatcher.removeRetainedKeys(retainedKeys)
+    refWatcher.removeKeysRetainedBeforeHeapDump(heapDumpUptimeMillis)
 
     val listener = AnalyzerProgressListener.NONE
 
diff --git a/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt b/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
index 2e66cab5..dde8d61c 100644
--- a/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
+++ b/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
@@ -21,9 +21,6 @@ import java.lang.ref.WeakReference
 @Suppress("unused")
 class KeyedWeakReference(
   referent: Any,
-  /**
-   * Key used to find the retained references in the heap dump.
-   */
   val key: String,
   val name: String,
   val watchUptimeMillis: Long,
@@ -32,4 +29,17 @@ class KeyedWeakReference(
     referent, referenceQueue
 ) {
   val className: String = referent.javaClass.name
+
+  /**
+   * Compared against [heapDumpUptimeMillis] so that the Hprof Parser knows only to look at
+   * instances that were moved to retained, then used to remove weak references post heap dump.
+   **/
+  @Volatile
+  var retainedUptimeMillis = -1L
+
+  companion object {
+    @Volatile
+    @JvmStatic var heapDumpUptimeMillis = 0L
+  }
+
 }
diff --git a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
index 8916c887..5dbc8632 100644
--- a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
+++ b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
@@ -16,7 +16,6 @@
 package leakcanary
 
 import java.lang.ref.ReferenceQueue
-import java.util.HashSet
 import java.util.UUID
 import java.util.concurrent.Executor
 
@@ -35,32 +34,56 @@ class RefWatcher constructor(
 ) {
 
   /**
-   * References passed to [watch] that haven't made it to [retainedReferences] yet.
+   * References passed to [watch].
    */
   private val watchedReferences = mutableMapOf<String, KeyedWeakReference>()
-  /**
-   * References passed to [watch] that we have determined to be retained longer than they should
-   * have been.
-   */
-  private val retainedReferences = mutableMapOf<String, KeyedWeakReference>()
+
   private val queue = ReferenceQueue<Any>()
 
+  /**
+   * Returns true if there are watched instances that aren't weakly reachable, and
+   * have been watched for long enough to be considered retained.
+   */
   val hasRetainedReferences: Boolean
     @Synchronized get() {
       removeWeaklyReachableReferences()
-      return retainedReferences.isNotEmpty()
+      return watchedReferences.any { it.value.retainedUptimeMillis != -1L }
+    }
+
+  val retainedReferenceCount: Int
+    @Synchronized get() {
+      removeWeaklyReachableReferences()
+      return watchedReferences.count { it.value.retainedUptimeMillis != -1L }
     }
 
+  /**
+   * Returns true if there are watched instances that aren't weakly reachable, even
+   * if they haven't been watched for long enough to be considered retained.
+   */
   val hasWatchedReferences: Boolean
     @Synchronized get() {
       removeWeaklyReachableReferences()
-      return retainedReferences.isNotEmpty() || watchedReferences.isNotEmpty()
+      return watchedReferences.isNotEmpty()
     }
 
-  val retainedKeys: Set<String>
+  /**
+   * Returns the instances that are currently considered retained. Useful for logging purposes.
+   * Be careful with those instances and release them ASAP as you may creating longer lived leaks
+   * then the one that are already there.
+   */
+  val retainedInstances: List<Any>
     @Synchronized get() {
       removeWeaklyReachableReferences()
-      return HashSet(retainedReferences.keys)
+      val instances = mutableListOf<Any>()
+      for (reference in watchedReferences.values) {
+        if (reference.retainedUptimeMillis != -1L) {
+          val instance = reference.get()
+          if (instance != null) {
+            instances.add(instance)
+          }
+        }
+      }
+      return instances
     }
 
   /**
@@ -107,20 +130,22 @@ class RefWatcher constructor(
 
   @Synchronized private fun moveToRetained(key: String) {
     removeWeaklyReachableReferences()
-    val retainedRef = watchedReferences.remove(key)
+    val retainedRef = watchedReferences[key]
     if (retainedRef != null) {
-      retainedReferences[key] = retainedRef
+      retainedRef.retainedUptimeMillis = clock.uptimeMillis()
       onReferenceRetained()
     }
   }
 
-  @Synchronized fun removeRetainedKeys(keysToRemove: Set<String>) {
-    retainedReferences.keys.removeAll(keysToRemove)
+  @Synchronized fun removeKeysRetainedBeforeHeapDump(heapDumpUptimeMillis: Long) {
+    val retainedBeforeHeapdump =
+      watchedReferences.filter { it.value.retainedUptimeMillis in 0..heapDumpUptimeMillis }
+          .keys
+    watchedReferences.keys.removeAll(retainedBeforeHeapdump)
   }
 
   @Synchronized fun clearWatchedReferences() {
     watchedReferences.clear()
-    retainedReferences.clear()
   }
 
   private fun removeWeaklyReachableReferences() {
@@ -130,10 +155,7 @@ class RefWatcher constructor(
     do {
       ref = queue.poll() as KeyedWeakReference?
       if (ref != null) {
-        val removedRef = watchedReferences.remove(ref.key)
-        if (removedRef == null) {
-          retainedReferences.remove(ref.key)
-        }
+        watchedReferences.remove(ref.key)
       }
     } while (ref != null)
   }
diff --git a/mkdocs.yml b/mkdocs.yml
index 305528c4..10eede1a 100644
--- a/mkdocs.yml
+++ b/mkdocs.yml
@@ -19,10 +19,6 @@ theme:
     primary: 'deep-orange'
     accent: 'deep-purple'
 
-
-# extra_css:
-#  - 'css/app.css'
-
 markdown_extensions:
   - smarty
   - codehilite:
@@ -56,3 +52,8 @@ nav:
   - 'Recorded Presentations': recorded-presentations.md
   - 'Contributing': contributing.md
   - 'Code of Conduct': code_of_conduct.md
+
+# Google Analytics. Add export LEAKCANARY_GOOGLE_ANALYTICS_KEY="UA-XXXXXXXXX-X" to your ~/.bashrc
+google_analytics:
+  - !!python/object/apply:os.getenv ["LEAKCANARY_GOOGLE_ANALYTICS_KEY"]
+  - auto
